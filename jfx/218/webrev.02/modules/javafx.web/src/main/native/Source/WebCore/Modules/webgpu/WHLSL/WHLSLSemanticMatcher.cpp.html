<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLSemanticMatcher.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLSemanticMatcher.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLBuiltInSemantic.h&quot;
 32 #include &quot;WHLSLFunctionDefinition.h&quot;
 33 #include &quot;WHLSLGatherEntryPointItems.h&quot;
 34 #include &quot;WHLSLInferTypes.h&quot;
 35 #include &quot;WHLSLPipelineDescriptor.h&quot;
 36 #include &quot;WHLSLProgram.h&quot;
 37 #include &quot;WHLSLResourceSemantic.h&quot;
 38 #include &quot;WHLSLStageInOutSemantic.h&quot;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/Optional.h&gt;
 42 #include &lt;wtf/text/WTFString.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 namespace WHLSL {
 47 
 48 static bool matchMode(Binding::BindingDetails bindingType, AST::ResourceSemantic::Mode mode)
 49 {
 50     return WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) -&gt; bool {
 51         return mode == AST::ResourceSemantic::Mode::Buffer;
 52     }, [&amp;](SamplerBinding) -&gt; bool {
 53         return mode == AST::ResourceSemantic::Mode::Sampler;
 54     }, [&amp;](TextureBinding) -&gt; bool {
 55         return mode == AST::ResourceSemantic::Mode::Texture;
 56     }, [&amp;](StorageBufferBinding) -&gt; bool {
 57         return mode == AST::ResourceSemantic::Mode::UnorderedAccessView;
 58     }), bindingType);
 59 }
 60 
 61 static Optional&lt;HashMap&lt;Binding*, size_t&gt;&gt; matchResources(Vector&lt;EntryPointItem&gt;&amp; entryPointItems, Layout&amp; layout, ShaderStage shaderStage)
 62 {
 63     HashMap&lt;Binding*, size_t&gt; result;
 64     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;
 65     for (auto&amp; bindGroup : layout) {
 66         auto space = bindGroup.name;
 67         for (auto&amp; binding : bindGroup.bindings) {
 68             if (!binding.visibility.contains(shaderStage))
 69                 continue;
 70             for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 71                 auto&amp; item = entryPointItems[i];
 72                 auto&amp; semantic = *item.semantic;
 73                 if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 74                     continue;
 75                 auto&amp; resourceSemantic = WTF::get&lt;AST::ResourceSemantic&gt;(semantic);
 76                 if (!matchMode(binding.binding, resourceSemantic.mode()))
 77                     continue;
 78                 if (binding.externalName != resourceSemantic.index())
 79                     continue;
 80                 if (space != resourceSemantic.space())
 81                     continue;
 82                 result.add(&amp;binding, i);
 83                 itemIndices.add(i);
 84             }
 85         }
 86     }
 87 
 88     for (size_t i = 0; i &lt; entryPointItems.size(); ++i) {
 89         auto&amp; item = entryPointItems[i];
 90         auto&amp; semantic = *item.semantic;
 91         if (!WTF::holds_alternative&lt;AST::ResourceSemantic&gt;(semantic))
 92             continue;
 93         if (!itemIndices.contains(i))
 94             return WTF::nullopt;
 95     }
 96 
 97     return result;
 98 }
 99 
100 static bool matchInputsOutputs(Vector&lt;EntryPointItem&gt;&amp; vertexOutputs, Vector&lt;EntryPointItem&gt;&amp; fragmentInputs)
101 {
102     for (auto&amp; fragmentInput : fragmentInputs) {
103         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic))
104             continue;
105         auto&amp; fragmentInputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*fragmentInput.semantic);
106         bool found = false;
107         for (auto&amp; vertexOutput : vertexOutputs) {
108             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic))
109                 continue;
110             auto&amp; vertexOutputStageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*vertexOutput.semantic);
111             if (fragmentInputStageInOutSemantic.index() == vertexOutputStageInOutSemantic.index()) {
112                 if (matches(*fragmentInput.unnamedType, *vertexOutput.unnamedType)) {
113                     found = true;
114                     break;
115                 }
116                 return false;
117             }
118         }
119         if (!found)
120             return false;
121     }
122     return true;
123 }
124 
125 static bool isAcceptableFormat(VertexFormat vertexFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics)
126 {
127     switch (vertexFormat) {
128     case VertexFormat::FloatR32G32B32A32:
129         return matches(unnamedType, intrinsics.float4Type());
130     case VertexFormat::FloatR32G32B32:
131         return matches(unnamedType, intrinsics.float3Type());
132     case VertexFormat::FloatR32G32:
133         return matches(unnamedType, intrinsics.float2Type());
134     default:
135         ASSERT(vertexFormat == VertexFormat::FloatR32);
136         return matches(unnamedType, intrinsics.floatType());
137     }
138 }
139 
140 static Optional&lt;HashMap&lt;VertexAttribute*, size_t&gt;&gt; matchVertexAttributes(Vector&lt;EntryPointItem&gt;&amp; vertexInputs, VertexAttributes&amp; vertexAttributes, Intrinsics&amp; intrinsics)
141 {
142     HashMap&lt;VertexAttribute*, size_t&gt; result;
143     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;
144     for (auto&amp; vertexAttribute : vertexAttributes) {
145         for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
146             auto&amp; item = vertexInputs[i];
147             auto&amp; semantic = *item.semantic;
148             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
149                 continue;
150             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
151             if (stageInOutSemantic.index() != vertexAttribute.shaderLocation)
152                 continue;
153             if (!isAcceptableFormat(vertexAttribute.vertexFormat, *item.unnamedType, intrinsics))
154                 return WTF::nullopt;
155             result.add(&amp;vertexAttribute, i);
156             itemIndices.add(i);
157         }
158     }
159 
160     for (size_t i = 0; i &lt; vertexInputs.size(); ++i) {
161         auto&amp; item = vertexInputs[i];
162         auto&amp; semantic = *item.semantic;
163         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
164             continue;
165         if (!itemIndices.contains(i))
166             return WTF::nullopt;
167     }
168 
169     return result;
170 }
171 
172 static bool isAcceptableFormat(TextureFormat textureFormat, AST::UnnamedType&amp; unnamedType, Intrinsics&amp; intrinsics, bool isColor)
173 {
174     if (isColor) {
175         switch (textureFormat) {
176         case TextureFormat::R8Unorm:
177         case TextureFormat::R8UnormSrgb:
178         case TextureFormat::R8Snorm:
179         case TextureFormat::R16Unorm:
180         case TextureFormat::R16Snorm:
181         case TextureFormat::R16Float:
182         case TextureFormat::R32Float:
183             return matches(unnamedType, intrinsics.floatType());
184         case TextureFormat::RG8Unorm:
185         case TextureFormat::RG8UnormSrgb:
186         case TextureFormat::RG8Snorm:
187         case TextureFormat::RG16Unorm:
188         case TextureFormat::RG16Snorm:
189         case TextureFormat::RG16Float:
190         case TextureFormat::RG32Float:
191             return matches(unnamedType, intrinsics.float2Type());
192         case TextureFormat::B5G6R5Unorm:
193         case TextureFormat::RG11B10Float:
194             return matches(unnamedType, intrinsics.float3Type());
195         case TextureFormat::RGBA8Unorm:
196         case TextureFormat::RGBA8UnormSrgb:
197         case TextureFormat::BGRA8Unorm:
198         case TextureFormat::BGRA8UnormSrgb:
199         case TextureFormat::RGBA8Snorm:
200         case TextureFormat::RGB10A2Unorm:
201         case TextureFormat::RGBA16Unorm:
202         case TextureFormat::RGBA16Snorm:
203         case TextureFormat::RGBA16Float:
204         case TextureFormat::RGBA32Float:
205             return matches(unnamedType, intrinsics.float4Type());
206         case TextureFormat::R32Uint:
207             return matches(unnamedType, intrinsics.uintType());
208         case TextureFormat::R32Sint:
209             return matches(unnamedType, intrinsics.intType());
210         case TextureFormat::RG32Uint:
211             return matches(unnamedType, intrinsics.uint2Type());
212         case TextureFormat::RG32Sint:
213             return matches(unnamedType, intrinsics.int2Type());
214         case TextureFormat::RGBA32Uint:
215             return matches(unnamedType, intrinsics.uint4Type());
216         case TextureFormat::RGBA32Sint:
217             return matches(unnamedType, intrinsics.int4Type());
218         default:
219             ASSERT_NOT_REACHED();
220             return false;
221         }
222     }
223     return false;
224 }
225 
226 static Optional&lt;HashMap&lt;AttachmentDescriptor*, size_t&gt;&gt; matchColorAttachments(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Vector&lt;AttachmentDescriptor&gt;&amp; attachmentDescriptors, Intrinsics&amp; intrinsics)
227 {
228     HashMap&lt;AttachmentDescriptor*, size_t&gt; result;
229     HashSet&lt;size_t, DefaultHash&lt;size_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;size_t&gt;&gt; itemIndices;
230     for (auto&amp; attachmentDescriptor : attachmentDescriptors) {
231         for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
232             auto&amp; item = fragmentOutputs[i];
233             auto&amp; semantic = *item.semantic;
234             if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
235                 continue;
236             auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
237             if (stageInOutSemantic.index() != attachmentDescriptor.name)
238                 continue;
239             if (!isAcceptableFormat(attachmentDescriptor.textureFormat, *item.unnamedType, intrinsics, true))
240                 return WTF::nullopt;
241             result.add(&amp;attachmentDescriptor, i);
242             itemIndices.add(i);
243         }
244     }
245 
246     for (size_t i = 0; i &lt; fragmentOutputs.size(); ++i) {
247         auto&amp; item = fragmentOutputs[i];
248         auto&amp; semantic = *item.semantic;
249         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(semantic))
250             continue;
251         if (!itemIndices.contains(i))
252             return WTF::nullopt;
253     }
254 
255     return result;
256 }
257 
258 static bool matchDepthAttachment(Vector&lt;EntryPointItem&gt;&amp; fragmentOutputs, Optional&lt;AttachmentDescriptor&gt;&amp; depthStencilAttachmentDescriptor, Intrinsics&amp; intrinsics)
259 {
260     auto iterator = std::find_if(fragmentOutputs.begin(), fragmentOutputs.end(), [&amp;](EntryPointItem&amp; item) {
261         auto&amp; semantic = *item.semantic;
262         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))
263             return false;
264         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(semantic);
265         return builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVDepth;
266     });
267     if (iterator == fragmentOutputs.end())
268         return true;
269 
270     if (depthStencilAttachmentDescriptor) {
271         ASSERT(!depthStencilAttachmentDescriptor-&gt;name);
272         return isAcceptableFormat(depthStencilAttachmentDescriptor-&gt;textureFormat, *iterator-&gt;unnamedType, intrinsics, false);
273     }
274     return false;
275 }
276 
277 Optional&lt;MatchedRenderSemantics&gt; matchSemantics(Program&amp; program, RenderPipelineDescriptor&amp; renderPipelineDescriptor, bool distinctFragmentShader, bool fragmentShaderExists)
278 {
279     auto vertexFunctions = program.nameContext().getFunctions(renderPipelineDescriptor.vertexEntryPointName, AST::NameSpace::NameSpace1);
280     if (vertexFunctions.size() != 1 || !vertexFunctions[0].get().entryPointType() || !is&lt;AST::FunctionDefinition&gt;(vertexFunctions[0].get()))
281         return WTF::nullopt;
282     auto&amp; vertexShaderEntryPoint = downcast&lt;AST::FunctionDefinition&gt;(vertexFunctions[0].get());
283     auto vertexShaderEntryPointItems = gatherEntryPointItems(program.intrinsics(), vertexShaderEntryPoint);
284     if (!vertexShaderEntryPointItems)
285         return WTF::nullopt;
286     auto vertexShaderResourceMap = matchResources(vertexShaderEntryPointItems-&gt;inputs, renderPipelineDescriptor.layout, ShaderStage::Vertex);
287     if (!vertexShaderResourceMap)
288         return WTF::nullopt;
289     auto matchedVertexAttributes = matchVertexAttributes(vertexShaderEntryPointItems-&gt;inputs, renderPipelineDescriptor.vertexAttributes, program.intrinsics());
290     if (!matchedVertexAttributes)
291         return WTF::nullopt;
292     if (!fragmentShaderExists)
293         return {{ &amp;vertexShaderEntryPoint, nullptr, *vertexShaderEntryPointItems, EntryPointItems(), *vertexShaderResourceMap, HashMap&lt;Binding*, size_t&gt;(), *matchedVertexAttributes, HashMap&lt;AttachmentDescriptor*, size_t&gt;() }};
294 
295     auto fragmentNameSpace = distinctFragmentShader ? AST::NameSpace::NameSpace2 : AST::NameSpace::NameSpace1;
296     auto fragmentFunctions = program.nameContext().getFunctions(renderPipelineDescriptor.fragmentEntryPointName, fragmentNameSpace);
297     if (fragmentFunctions.size() != 1 || !fragmentFunctions[0].get().entryPointType() || !is&lt;AST::FunctionDefinition&gt;(fragmentFunctions[0].get()))
298         return WTF::nullopt;
299     auto&amp; fragmentShaderEntryPoint = downcast&lt;AST::FunctionDefinition&gt;(fragmentFunctions[0].get());
300     auto fragmentShaderEntryPointItems = gatherEntryPointItems(program.intrinsics(), fragmentShaderEntryPoint);
301     if (!fragmentShaderEntryPointItems)
302         return WTF::nullopt;
303     auto fragmentShaderResourceMap = matchResources(fragmentShaderEntryPointItems-&gt;inputs, renderPipelineDescriptor.layout, ShaderStage::Fragment);
304     if (!fragmentShaderResourceMap)
305         return WTF::nullopt;
306     if (!matchInputsOutputs(vertexShaderEntryPointItems-&gt;outputs, fragmentShaderEntryPointItems-&gt;inputs))
307         return WTF::nullopt;
308     auto matchedColorAttachments = matchColorAttachments(fragmentShaderEntryPointItems-&gt;outputs, renderPipelineDescriptor.attachmentsStateDescriptor.attachmentDescriptors, program.intrinsics());
309     if (!matchedColorAttachments)
310         return WTF::nullopt;
311     if (!matchDepthAttachment(fragmentShaderEntryPointItems-&gt;outputs, renderPipelineDescriptor.attachmentsStateDescriptor.depthStencilAttachmentDescriptor, program.intrinsics()))
312         return WTF::nullopt;
313     return {{ &amp;vertexShaderEntryPoint, &amp;fragmentShaderEntryPoint, *vertexShaderEntryPointItems, *fragmentShaderEntryPointItems, *vertexShaderResourceMap, *fragmentShaderResourceMap, *matchedVertexAttributes, *matchedColorAttachments }};
314 }
315 
316 Optional&lt;MatchedComputeSemantics&gt; matchSemantics(Program&amp; program, ComputePipelineDescriptor&amp; computePipelineDescriptor)
317 {
318     auto functions = program.nameContext().getFunctions(computePipelineDescriptor.entryPointName, AST::NameSpace::NameSpace1);
319     if (functions.size() != 1 || !functions[0].get().entryPointType() || !is&lt;AST::FunctionDefinition&gt;(functions[0].get()))
320         return WTF::nullopt;
321     auto&amp; entryPoint = downcast&lt;AST::FunctionDefinition&gt;(functions[0].get());
322     auto entryPointItems = gatherEntryPointItems(program.intrinsics(), entryPoint);
323     if (!entryPointItems)
324         return WTF::nullopt;
325     ASSERT(entryPointItems-&gt;outputs.isEmpty());
326     auto resourceMap = matchResources(entryPointItems-&gt;inputs, computePipelineDescriptor.layout, ShaderStage::Compute);
327     if (!resourceMap)
328         return WTF::nullopt;
329     return {{ &amp;entryPoint, *entryPointItems, *resourceMap }};
330 }
331 
332 } // namespace WHLSL
333 
334 } // namespace WebCore
335 
336 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
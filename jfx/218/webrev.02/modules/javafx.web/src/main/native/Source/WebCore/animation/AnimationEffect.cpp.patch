diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp b/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationEffect.cpp
@@ -62,31 +62,10 @@
 {
     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
     // to each other a fair bit, so rather than implementing them as individual methods, it's more efficient
     // to return them all as a single BasicEffectTiming.
 
-    auto activeDuration = [this]() -> Seconds {
-        // 3.8.2. Calculating the active duration
-        // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration
-
-        // The active duration is calculated as follows:
-        // active duration = iteration duration × iteration count
-        // If either the iteration duration or iteration count are zero, the active duration is zero.
-        if (!m_iterationDuration || !m_iterations)
-            return 0_s;
-        return m_iterationDuration * m_iterations;
-    }();
-
-    auto endTime = [this, activeDuration]() -> Seconds {
-        // 3.5.3 The active interval
-        // https://drafts.csswg.org/web-animations-1/#end-time
-
-        // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).
-        auto endTime = m_delay + activeDuration + m_endDelay;
-        return endTime > 0_s ? endTime : 0_s;
-    }();
-
     auto localTime = [this]() -> Optional<Seconds> {
         // 4.5.4. Local time
         // https://drafts.csswg.org/web-animations-1/#local-time-section
 
         // The local time of an animation effect at a given moment is based on the first matching condition from the following:
@@ -95,17 +74,17 @@
         if (m_animation)
             return m_animation->currentTime();
         return WTF::nullopt;
     }();
 
-    auto phase = [this, endTime, localTime, activeDuration]() -> AnimationEffectPhase {
+    auto phase = [this, localTime]() -> AnimationEffectPhase {
         // 3.5.5. Animation effect phases and states
         // https://drafts.csswg.org/web-animations-1/#animation-effect-phases-and-states
 
         bool animationIsBackwards = m_animation && m_animation->playbackRate() < 0;
-        auto beforeActiveBoundaryTime = std::max(std::min(m_delay, endTime), 0_s);
-        auto activeAfterBoundaryTime = std::max(std::min(m_delay + activeDuration, endTime), 0_s);
+        auto beforeActiveBoundaryTime = std::max(std::min(m_delay, m_endTime), 0_s);
+        auto activeAfterBoundaryTime = std::max(std::min(m_delay + m_activeDuration, m_endTime), 0_s);
 
         // (This should be the last statement, but it's more efficient to cache the local time and return right away if it's not resolved.)
         // Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases
         // as being in the idle phase.
         if (!localTime)
@@ -129,11 +108,11 @@
         // in either the before phase nor the after phase.
         // (No need to check, we've already established that local time was resolved).
         return AnimationEffectPhase::Active;
     }();
 
-    auto activeTime = [this, localTime, phase, activeDuration]() -> Optional<Seconds> {
+    auto activeTime = [this, localTime, phase]() -> Optional<Seconds> {
         // 3.8.3.1. Calculating the active time
         // https://drafts.csswg.org/web-animations-1/#calculating-the-active-time
 
         // The active time is based on the local time and start delay. However, it is only defined
         // when the animation effect should produce an output and hence depends on its fill mode
@@ -158,31 +137,30 @@
         // condition from the following,
         if (phase == AnimationEffectPhase::After) {
             // If the fill mode is forwards or both, return the result of evaluating
             // max(min(local time - start delay, active duration), 0).
             if (m_fill == FillMode::Forwards || m_fill == FillMode::Both)
-                return std::max(std::min(*localTime - m_delay, activeDuration), 0_s);
+                return std::max(std::min(*localTime - m_delay, m_activeDuration), 0_s);
             // Otherwise, return an unresolved time value.
             return WTF::nullopt;
         }
 
         // Otherwise (the local time is unresolved), return an unresolved time value.
         return WTF::nullopt;
     }();
 
-    return { localTime, activeTime, endTime, activeDuration, phase };
+    return { localTime, activeTime, m_endTime, m_activeDuration, phase };
 }
 
 ComputedEffectTiming AnimationEffect::getComputedTiming() const
 {
     // The Web Animations spec introduces a number of animation effect time-related definitions that refer
     // to each other a fair bit, so rather than implementing them as individual methods, it's more efficient
     // to return them all as a single ComputedEffectTiming.
 
     auto basicEffectTiming = getBasicTiming();
     auto activeTime = basicEffectTiming.activeTime;
-    auto activeDuration = basicEffectTiming.activeDuration;
     auto phase = basicEffectTiming.phase;
 
     auto overallProgress = [this, phase, activeTime]() -> Optional<double> {
         // 3.8.3.2. Calculating the overall progress
         // https://drafts.csswg.org/web-animations-1/#calculating-the-overall-progress
@@ -208,11 +186,11 @@
         // 3. Return the result of calculating overall progress + iteration start.
         overallProgress += m_iterationStart;
         return std::abs(overallProgress);
     }();
 
-    auto simpleIterationProgress = [this, overallProgress, phase, activeTime, activeDuration]() -> Optional<double> {
+    auto simpleIterationProgress = [this, overallProgress, phase, activeTime]() -> Optional<double> {
         // 3.8.3.3. Calculating the simple iteration progress
         // https://drafts.csswg.org/web-animations-1/#calculating-the-simple-iteration-progress
 
         // The simple iteration progress is a fraction of the progress through the current iteration that
         // ignores transformations to the time introduced by the playback direction or timing functions
@@ -231,11 +209,11 @@
         // the simple iteration progress calculated above is zero, and
         // the animation effect is in the active phase or the after phase, and
         // the active time is equal to the active duration, and
         // the iteration count is not equal to zero.
         // let the simple iteration progress be 1.0.
-        if (!simpleIterationProgress && (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) && std::abs(activeTime->microseconds() - activeDuration.microseconds()) < timeEpsilon.microseconds() && m_iterations)
+        if (!simpleIterationProgress && (phase == AnimationEffectPhase::Active || phase == AnimationEffectPhase::After) && std::abs(activeTime->microseconds() - m_activeDuration.microseconds()) < timeEpsilon.microseconds() && m_iterations)
             return 1;
 
         return simpleIterationProgress;
     }();
 
@@ -345,12 +323,12 @@
     computedTiming.iterationStart = m_iterationStart;
     computedTiming.iterations = m_iterations;
     computedTiming.duration = secondsToWebAnimationsAPITime(m_iterationDuration);
     computedTiming.direction = m_direction;
     computedTiming.easing = m_timingFunction->cssText();
-    computedTiming.endTime = secondsToWebAnimationsAPITime(basicEffectTiming.endTime);
-    computedTiming.activeDuration = secondsToWebAnimationsAPITime(activeDuration);
+    computedTiming.endTime = secondsToWebAnimationsAPITime(m_endTime);
+    computedTiming.activeDuration = secondsToWebAnimationsAPITime(m_activeDuration);
     if (basicEffectTiming.localTime)
         computedTiming.localTime = secondsToWebAnimationsAPITime(*basicEffectTiming.localTime);
     computedTiming.simpleIterationProgress = simpleIterationProgress;
     computedTiming.progress = transformedProgress;
     computedTiming.currentIteration = currentIteration;
@@ -365,10 +343,14 @@
 
     // To update the timing properties of an animation effect, effect, from an EffectTiming or OptionalEffectTiming object, input, perform the following steps:
     if (!timing)
         return { };
 
+    Optional<ComputedEffectTiming> previousTiming;
+    if (m_animation)
+        previousTiming = getComputedTiming();
+
     // 1. If the iterationStart member of input is present and less than zero, throw a TypeError and abort this procedure.
     if (timing->iterationStart) {
         if (timing->iterationStart.value() < 0)
             return Exception { TypeError };
     }
@@ -430,16 +412,40 @@
         m_iterationDuration = WTF::holds_alternative<double>(timing->duration.value()) ? Seconds::fromMilliseconds(WTF::get<double>(timing->duration.value())) : 0_s;
 
     if (timing->direction)
         m_direction = timing->direction.value();
 
+    updateStaticTimingProperties();
+
     if (m_animation)
-        m_animation->effectTimingDidChange();
+        m_animation->effectTimingDidChange(previousTiming);
 
     return { };
 }
 
+void AnimationEffect::updateStaticTimingProperties()
+{
+    // 3.8.2. Calculating the active duration
+    // https://drafts.csswg.org/web-animations-1/#calculating-the-active-duration
+
+    // The active duration is calculated as follows:
+    // active duration = iteration duration × iteration count
+    // If either the iteration duration or iteration count are zero, the active duration is zero.
+    if (!m_iterationDuration || !m_iterations)
+        m_activeDuration = 0_s;
+    else
+        m_activeDuration = m_iterationDuration * m_iterations;
+
+    // 3.5.3 The active interval
+    // https://drafts.csswg.org/web-animations-1/#end-time
+
+    // The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).
+    m_endTime = m_delay + m_activeDuration + m_endDelay;
+    if (m_endTime < 0_s)
+        m_endTime = 0_s;
+}
+
 ExceptionOr<void> AnimationEffect::setIterationStart(double iterationStart)
 {
     // https://drafts.csswg.org/web-animations-1/#dom-animationeffecttiming-iterationstart
     // If an attempt is made to set this attribute to a value less than zero, a TypeError must
     // be thrown and the value of the iterationStart attribute left unchanged.

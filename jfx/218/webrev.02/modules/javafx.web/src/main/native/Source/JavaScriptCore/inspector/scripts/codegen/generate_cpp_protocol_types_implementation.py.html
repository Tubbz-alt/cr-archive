<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_cpp_protocol_types_implementation.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014-2018 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 
 28 import logging
 29 import string
 30 from string import Template
 31 from operator import methodcaller
 32 
 33 try:
 34     from .cpp_generator import CppGenerator
 35     from .cpp_generator_templates import CppGeneratorTemplates as CppTemplates
 36     from .generator import Generator, ucfirst
 37     from .models import AliasedType, ArrayType, EnumType, ObjectType
 38 except ValueError:
 39     from cpp_generator import CppGenerator
 40     from cpp_generator_templates import CppGeneratorTemplates as CppTemplates
 41     from generator import Generator, ucfirst
 42     from models import AliasedType, ArrayType, EnumType, ObjectType
 43 
 44 log = logging.getLogger(&#39;global&#39;)
 45 
 46 
 47 class CppProtocolTypesImplementationGenerator(CppGenerator):
 48     def __init__(self, *args, **kwargs):
 49         CppGenerator.__init__(self, *args, **kwargs)
 50 
 51     def output_filename(self):
 52         return &quot;%sProtocolObjects.cpp&quot; % self.protocol_name()
 53 
 54     def generate_output(self):
 55         domains = self.domains_to_generate()
 56         self.calculate_types_requiring_shape_assertions(domains)
 57 
 58         secondary_headers = [
 59             &#39;&lt;wtf/Optional.h&gt;&#39;,
 60             &#39;&lt;wtf/text/CString.h&gt;&#39;,
 61         ]
 62 
 63         header_args = {
 64             &#39;primaryInclude&#39;: &#39;&quot;%sProtocolObjects.h&quot;&#39; % self.protocol_name(),
 65             &#39;secondaryIncludes&#39;: self._generate_secondary_header_includes(),
 66         }
 67 
 68         sections = []
 69         sections.append(self.generate_license())
 70         sections.append(Template(CppTemplates.ImplementationPrelude).substitute(None, **header_args))
 71         sections.append(&#39;namespace Protocol {&#39;)
 72         sections.extend(self._generate_enum_mapping_and_conversion_methods(domains))
 73         sections.append(self._generate_open_field_names())
 74         builder_sections = list(map(self._generate_builders_for_domain, domains))
 75         sections.extend([section for section in builder_sections if len(section) &gt; 0])
 76         sections.append(&#39;} // namespace Protocol&#39;)
 77         sections.append(Template(CppTemplates.ImplementationPostlude).substitute(None, **header_args))
 78 
 79         return &quot;\n\n&quot;.join(sections)
 80 
 81     # Private methods.
 82 
 83     def _generate_secondary_header_includes(self):
 84         header_includes = [
 85             ([&quot;JavaScriptCore&quot;, &quot;WebKit&quot;], (&quot;WTF&quot;, &quot;wtf/Optional.h&quot;)),
 86             ([&quot;JavaScriptCore&quot;, &quot;WebKit&quot;], (&quot;WTF&quot;, &quot;wtf/text/CString.h&quot;)),
 87         ]
 88 
 89         return &#39;\n&#39;.join(self.generate_includes_from_entries(header_includes))
 90 
 91     def _generate_enum_mapping(self):
 92         if not self.assigned_enum_values():
 93             return []
 94 
 95         lines = []
 96         lines.append(&#39;static const char* const enum_constant_values[] = {&#39;)
 97         lines.extend([&#39;    &quot;%s&quot;,&#39; % enum_value for enum_value in self.assigned_enum_values()])
 98         lines.append(&#39;};&#39;)
 99         lines.append(&#39;&#39;)
100         lines.append(&#39;String getEnumConstantValue(int code) {&#39;)
101         lines.append(&#39;    return enum_constant_values[code];&#39;)
102         lines.append(&#39;}&#39;)
103         return [&#39;\n&#39;.join(lines)]
104 
105     def _generate_enum_conversion_methods_for_domain(self, domain):
106 
107         def type_member_is_anonymous_enum_type(type_member):
108             return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
109 
110         def generate_conversion_method_body(enum_type, cpp_protocol_type):
111             body_lines = []
112             body_lines.extend([
113                 &#39;template&lt;&gt;&#39;,
114                 &#39;Optional&lt;%s&gt; parseEnumValueFromString&lt;%s&gt;(const String&amp; protocolString)&#39; % (cpp_protocol_type, cpp_protocol_type),
115                 &#39;{&#39;,
116                 &#39;    static const size_t constantValues[] = {&#39;,
117             ])
118 
119             enum_values = enum_type.enum_values()
120             for enum_value in enum_values:
121                 body_lines.append(&#39;        (size_t)%s::%s,&#39; % (cpp_protocol_type, Generator.stylized_name_for_enum_value(enum_value)))
122 
123             body_lines.extend([
124                 &#39;    };&#39;,
125                 &#39;    for (size_t i = 0; i &lt; %d; ++i)&#39; % len(enum_values),
126                 &#39;        if (protocolString == enum_constant_values[constantValues[i]])&#39;,
127                 &#39;            return (%s)constantValues[i];&#39; % cpp_protocol_type,
128                 &#39;&#39;,
129                 &#39;    return WTF::nullopt;&#39;,
130                 &#39;}&#39;,
131                 &#39;&#39;,
132             ])
133             return body_lines
134 
135         type_declarations = self.type_declarations_for_domain(domain)
136         declaration_types = [decl.type for decl in type_declarations]
137         object_types = [_type for _type in declaration_types if isinstance(_type, ObjectType)]
138         enum_types = [_type for _type in declaration_types if isinstance(_type, EnumType)]
139         if len(object_types) + len(enum_types) == 0:
140             return &#39;&#39;
141 
142         sorted(object_types, key=methodcaller(&#39;raw_name&#39;))
143         sorted(enum_types, key=methodcaller(&#39;raw_name&#39;))
144 
145         lines = []
146         lines.append(&quot;// Enums in the &#39;%s&#39; Domain&quot; % domain.domain_name)
147         for enum_type in enum_types:
148             cpp_protocol_type = CppGenerator.cpp_protocol_type_for_type(enum_type)
149             lines.extend(generate_conversion_method_body(enum_type, cpp_protocol_type))
150 
151         for object_type in object_types:
152             for enum_member in filter(type_member_is_anonymous_enum_type, object_type.members):
153                 cpp_protocol_type = CppGenerator.cpp_protocol_type_for_type_member(enum_member, object_type.declaration())
154                 lines.extend(generate_conversion_method_body(enum_member.type, cpp_protocol_type))
155 
156         if len(lines) == 1:
157             return &#39;&#39;  # No real declarations to emit, just the domain comment.
158 
159         return self.wrap_with_guard_for_domain(domain, &#39;\n&#39;.join(lines))
160 
161     def _generate_enum_mapping_and_conversion_methods(self, domains):
162         sections = []
163         sections.append(&#39;namespace %s {&#39; % self.helpers_namespace())
164         sections.extend(self._generate_enum_mapping())
165         enum_parser_sections = list(map(self._generate_enum_conversion_methods_for_domain, domains))
166         sections.extend([section for section in enum_parser_sections if len(section) &gt; 0])
167         if len(sections) == 1:
168             return []  # No declarations to emit, just the namespace.
169 
170         sections.append(&#39;} // namespace %s&#39; % self.helpers_namespace())
171         return sections
172 
173     def _generate_open_field_names(self):
174         lines = []
175         for domain in self.domains_to_generate():
176             type_declarations = self.type_declarations_for_domain(domain)
177             for type_declaration in [decl for decl in type_declarations if Generator.type_has_open_fields(decl.type)]:
178                 open_members = Generator.open_fields(type_declaration)
179                 for type_member in sorted(open_members, key=lambda member: member.member_name):
180                     field_name = &#39;::&#39;.join([&#39;Inspector&#39;, &#39;Protocol&#39;, domain.domain_name, ucfirst(type_declaration.type_name), ucfirst(type_member.member_name)])
181                     lines.append(&#39;const char* %s = &quot;%s&quot;;&#39; % (field_name, type_member.member_name))
182 
183         return &#39;\n&#39;.join(lines)
184 
185     def _generate_builders_for_domain(self, domain):
186         sections = []
187         type_declarations = self.type_declarations_for_domain(domain)
188         declarations_to_generate = [decl for decl in type_declarations if self.type_needs_shape_assertions(decl.type)]
189 
190         for type_declaration in declarations_to_generate:
191             for type_member in type_declaration.type_members:
192                 if isinstance(type_member.type, EnumType):
193                     sections.append(self._generate_assertion_for_enum(type_member, type_declaration))
194 
195             if isinstance(type_declaration.type, ObjectType):
196                 sections.append(self._generate_assertion_for_object_declaration(type_declaration))
197                 if Generator.type_needs_runtime_casts(type_declaration.type):
198                     sections.append(self._generate_runtime_cast_for_object_declaration(type_declaration))
199 
200         return &#39;\n\n&#39;.join(sections)
201 
202     def _generate_runtime_cast_for_object_declaration(self, object_declaration):
203         args = {
204             &#39;objectType&#39;: CppGenerator.cpp_protocol_type_for_type(object_declaration.type)
205         }
206         return Template(CppTemplates.ProtocolObjectRuntimeCast).substitute(None, **args)
207 
208     def _generate_assertion_for_object_declaration(self, object_declaration):
209         required_members = [member for member in object_declaration.type_members if not member.is_optional]
210         optional_members = [member for member in object_declaration.type_members if member.is_optional]
211         should_count_properties = not Generator.type_has_open_fields(object_declaration.type)
212         lines = []
213 
214         lines.append(&#39;void BindingTraits&lt;%s&gt;::assertValueHasExpectedType(JSON::Value* value)&#39; % (CppGenerator.cpp_protocol_type_for_type(object_declaration.type)))
215         lines.append(&quot;&quot;&quot;{
216 #if ASSERT_ENABLED
217     ASSERT_ARG(value, value);
218     RefPtr&lt;JSON::Object&gt; object;
219     bool castSucceeded = value-&gt;asObject(object);
220     ASSERT_UNUSED(castSucceeded, castSucceeded);&quot;&quot;&quot;)
221         for type_member in required_members:
222             args = {
223                 &#39;memberName&#39;: type_member.member_name,
224                 &#39;assertMethod&#39;: CppGenerator.cpp_assertion_method_for_type_member(type_member, object_declaration)
225             }
226 
227             lines.append(&quot;&quot;&quot;    {
228         auto %(memberName)sPos = object-&gt;find(&quot;%(memberName)s&quot;_s);
229         ASSERT(%(memberName)sPos != object-&gt;end());
230         %(assertMethod)s(%(memberName)sPos-&gt;value.get());
231     }&quot;&quot;&quot; % args)
232 
233         if should_count_properties:
234             lines.append(&#39;&#39;)
235             lines.append(&#39;    int foundPropertiesCount = %s;&#39; % len(required_members))
236 
237         for type_member in optional_members:
238             args = {
239                 &#39;memberName&#39;: type_member.member_name,
240                 &#39;assertMethod&#39;: CppGenerator.cpp_assertion_method_for_type_member(type_member, object_declaration)
241             }
242 
243             lines.append(&quot;&quot;&quot;    {
244         auto %(memberName)sPos = object-&gt;find(&quot;%(memberName)s&quot;_s);
245         if (%(memberName)sPos != object-&gt;end()) {
246             %(assertMethod)s(%(memberName)sPos-&gt;value.get());&quot;&quot;&quot; % args)
247 
248             if should_count_properties:
249                 lines.append(&#39;            ++foundPropertiesCount;&#39;)
250             lines.append(&#39;        }&#39;)
251             lines.append(&#39;    }&#39;)
252 
253         if should_count_properties:
254             lines.append(&#39;    if (foundPropertiesCount != object-&gt;size())&#39;)
255             lines.append(&#39;        FATAL(&quot;Unexpected properties in object: %s\\n&quot;, object-&gt;toJSONString().ascii().data());&#39;)
256         lines.append(&#39;#else // ASSERT_ENABLED&#39;)
257         lines.append(&#39;    UNUSED_PARAM(value);&#39;)
258         lines.append(&#39;#endif // ASSERT_ENABLED&#39;)
259         lines.append(&#39;}&#39;)
260         return &#39;\n&#39;.join(lines)
261 
262     def _generate_assertion_for_enum(self, enum_member, object_declaration):
263         lines = []
264         lines.append(&#39;void %s(JSON::Value* value)&#39; % CppGenerator.cpp_assertion_method_for_type_member(enum_member, object_declaration))
265         lines.append(&#39;{&#39;)
266         lines.append(&#39;#if ASSERT_ENABLED&#39;)
267         lines.append(&#39;    ASSERT_ARG(value, value);&#39;)
268         lines.append(&#39;    String result;&#39;)
269         lines.append(&#39;    bool castSucceeded = value-&gt;asString(result);&#39;)
270         lines.append(&#39;    ASSERT(castSucceeded);&#39;)
271 
272         assert_condition = &#39; || &#39;.join([&#39;result == &quot;%s&quot;&#39; % enum_value for enum_value in enum_member.type.enum_values()])
273         lines.append(&#39;    ASSERT(%s);&#39; % assert_condition)
274         lines.append(&#39;#else // ASSERT_ENABLED&#39;)
275         lines.append(&#39;    UNUSED_PARAM(value);&#39;)
276         lines.append(&#39;#endif // ASSERT_ENABLED&#39;)
277         lines.append(&#39;}&#39;)
278 
279         return &#39;\n&#39;.join(lines)
    </pre>
  </body>
</html>
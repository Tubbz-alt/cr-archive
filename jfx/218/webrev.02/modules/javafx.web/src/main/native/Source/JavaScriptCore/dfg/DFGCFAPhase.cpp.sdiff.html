<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFAPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGByteCodeParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFGSimplificationPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFAPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
153                 }
154             }
155         }
156 
157         return true;
158     }
159 
160 private:
161     bool injectOSR(BasicBlock* block)
162     {
163         if (m_verbose)
164             dataLog(&quot;   Found must-handle block: &quot;, *block, &quot;\n&quot;);
165 
166         // This merges snapshot of stack values while CFA phase want to have proven types and values. This is somewhat tricky.
167         // But this is OK as long as DFG OSR entry validates the inputs with *proven* AbstracValue values. And it turns out that this
168         // type widening is critical to navier-stokes. Without it, navier-stokes has more strict constraint on OSR entry and
169         // fails OSR entry repeatedly.
170         bool changed = false;
171         const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
172         for (size_t i = mustHandleValues.size(); i--;) {
<span class="line-modified">173             int operand = mustHandleValues.operandForIndex(i);</span>
174             Optional&lt;JSValue&gt; value = mustHandleValues[i];
175             if (!value) {
176                 if (m_verbose)
<span class="line-modified">177                     dataLog(&quot;   Not live in bytecode: &quot;, VirtualRegister(operand), &quot;\n&quot;);</span>
178                 continue;
179             }
180             Node* node = block-&gt;variablesAtHead.operand(operand);
181             if (!node) {
182                 if (m_verbose)
<span class="line-modified">183                     dataLog(&quot;   Not live: &quot;, VirtualRegister(operand), &quot;\n&quot;);</span>
184                 continue;
185             }
186 
187             if (m_verbose)
<span class="line-modified">188                 dataLog(&quot;   Widening &quot;, VirtualRegister(operand), &quot; with &quot;, value.value(), &quot;\n&quot;);</span>
189 
190             AbstractValue&amp; target = block-&gt;valuesAtHead.operand(operand);
191             changed |= target.mergeOSREntryValue(m_graph, value.value(), node-&gt;variableAccessData(), node);
192         }
193 
194         if (changed || !block-&gt;cfaHasVisited) {
195             block-&gt;cfaShouldRevisit = true;
196             return true;
197         }
198 
199         return false;
200     }
201 
202     void performBlockCFA(BasicBlock* block)
203     {
204         if (!block)
205             return;
206         if (!block-&gt;cfaShouldRevisit)
207             return;
208         if (m_verbose)
</pre>
<hr />
<pre>
218                 dataLog(&quot;      head regs: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtHead), &quot;\n&quot;);
219         }
220         for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
221             Node* node = block-&gt;at(i);
222             if (m_verbose) {
223                 dataLogF(&quot;      %s @%u: &quot;, Graph::opName(node-&gt;op()), node-&gt;index());
224 
225                 if (!safeToExecute(m_state, m_graph, node))
226                     dataLog(&quot;(UNSAFE) &quot;);
227 
228                 dataLog(m_state.variablesForDebugging(), &quot; &quot;, m_interpreter);
229 
230                 dataLogF(&quot;\n&quot;);
231             }
232             if (!m_interpreter.execute(i)) {
233                 if (m_verbose)
234                     dataLogF(&quot;         Expect OSR exit.\n&quot;);
235                 break;
236             }
237 
<span class="line-modified">238             if (!ASSERT_DISABLED</span>
239                 &amp;&amp; m_state.didClobberOrFolded() != writesOverlap(m_graph, node, JSCell_structureID))
240                 DFG_CRASH(m_graph, node, toCString(&quot;AI-clobberize disagreement; AI says &quot;, m_state.clobberState(), &quot; while clobberize says &quot;, writeSet(m_graph, node)).data());
241         }
242         if (m_verbose) {
243             dataLogF(&quot;      tail regs: &quot;);
244             m_interpreter.dump(WTF::dataFile());
245             dataLogF(&quot;\n&quot;);
246         }
247         m_changed |= m_state.endBasicBlock();
248 
249         if (m_verbose) {
250             dataLog(&quot;      tail vars: &quot;, block-&gt;valuesAtTail, &quot;\n&quot;);
251             if (m_graph.m_form == SSA)
252                 dataLog(&quot;      head regs: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtTail), &quot;\n&quot;);
253         }
254     }
255 
256     void performForwardCFA()
257     {
258         ++m_count;
259         if (m_verbose)
260             dataLogF(&quot;CFA [%u]\n&quot;, m_count);
261 
262         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
263             performBlockCFA(m_graph.block(blockIndex));
264     }
265 
266 private:
267     InPlaceAbstractState m_state;
268     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
269     BlockSet m_blocksWithOSR;
270 
<span class="line-modified">271     bool m_verbose;</span>
272 
273     bool m_changed;
274     unsigned m_count;
275 };
276 
277 bool performCFA(Graph&amp; graph)
278 {
279     return runPhase&lt;CFAPhase&gt;(graph);
280 }
281 
282 } } // namespace JSC::DFG
283 
284 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
153                 }
154             }
155         }
156 
157         return true;
158     }
159 
160 private:
161     bool injectOSR(BasicBlock* block)
162     {
163         if (m_verbose)
164             dataLog(&quot;   Found must-handle block: &quot;, *block, &quot;\n&quot;);
165 
166         // This merges snapshot of stack values while CFA phase want to have proven types and values. This is somewhat tricky.
167         // But this is OK as long as DFG OSR entry validates the inputs with *proven* AbstracValue values. And it turns out that this
168         // type widening is critical to navier-stokes. Without it, navier-stokes has more strict constraint on OSR entry and
169         // fails OSR entry repeatedly.
170         bool changed = false;
171         const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
172         for (size_t i = mustHandleValues.size(); i--;) {
<span class="line-modified">173             Operand operand = mustHandleValues.operandForIndex(i);</span>
174             Optional&lt;JSValue&gt; value = mustHandleValues[i];
175             if (!value) {
176                 if (m_verbose)
<span class="line-modified">177                     dataLog(&quot;   Not live in bytecode: &quot;, operand, &quot;\n&quot;);</span>
178                 continue;
179             }
180             Node* node = block-&gt;variablesAtHead.operand(operand);
181             if (!node) {
182                 if (m_verbose)
<span class="line-modified">183                     dataLog(&quot;   Not live: &quot;, operand, &quot;\n&quot;);</span>
184                 continue;
185             }
186 
187             if (m_verbose)
<span class="line-modified">188                 dataLog(&quot;   Widening &quot;, operand, &quot; with &quot;, value.value(), &quot;\n&quot;);</span>
189 
190             AbstractValue&amp; target = block-&gt;valuesAtHead.operand(operand);
191             changed |= target.mergeOSREntryValue(m_graph, value.value(), node-&gt;variableAccessData(), node);
192         }
193 
194         if (changed || !block-&gt;cfaHasVisited) {
195             block-&gt;cfaShouldRevisit = true;
196             return true;
197         }
198 
199         return false;
200     }
201 
202     void performBlockCFA(BasicBlock* block)
203     {
204         if (!block)
205             return;
206         if (!block-&gt;cfaShouldRevisit)
207             return;
208         if (m_verbose)
</pre>
<hr />
<pre>
218                 dataLog(&quot;      head regs: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtHead), &quot;\n&quot;);
219         }
220         for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
221             Node* node = block-&gt;at(i);
222             if (m_verbose) {
223                 dataLogF(&quot;      %s @%u: &quot;, Graph::opName(node-&gt;op()), node-&gt;index());
224 
225                 if (!safeToExecute(m_state, m_graph, node))
226                     dataLog(&quot;(UNSAFE) &quot;);
227 
228                 dataLog(m_state.variablesForDebugging(), &quot; &quot;, m_interpreter);
229 
230                 dataLogF(&quot;\n&quot;);
231             }
232             if (!m_interpreter.execute(i)) {
233                 if (m_verbose)
234                     dataLogF(&quot;         Expect OSR exit.\n&quot;);
235                 break;
236             }
237 
<span class="line-modified">238             if (ASSERT_ENABLED</span>
239                 &amp;&amp; m_state.didClobberOrFolded() != writesOverlap(m_graph, node, JSCell_structureID))
240                 DFG_CRASH(m_graph, node, toCString(&quot;AI-clobberize disagreement; AI says &quot;, m_state.clobberState(), &quot; while clobberize says &quot;, writeSet(m_graph, node)).data());
241         }
242         if (m_verbose) {
243             dataLogF(&quot;      tail regs: &quot;);
244             m_interpreter.dump(WTF::dataFile());
245             dataLogF(&quot;\n&quot;);
246         }
247         m_changed |= m_state.endBasicBlock();
248 
249         if (m_verbose) {
250             dataLog(&quot;      tail vars: &quot;, block-&gt;valuesAtTail, &quot;\n&quot;);
251             if (m_graph.m_form == SSA)
252                 dataLog(&quot;      head regs: &quot;, nodeValuePairListDump(block-&gt;ssa-&gt;valuesAtTail), &quot;\n&quot;);
253         }
254     }
255 
256     void performForwardCFA()
257     {
258         ++m_count;
259         if (m_verbose)
260             dataLogF(&quot;CFA [%u]\n&quot;, m_count);
261 
262         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
263             performBlockCFA(m_graph.block(blockIndex));
264     }
265 
266 private:
267     InPlaceAbstractState m_state;
268     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
269     BlockSet m_blocksWithOSR;
270 
<span class="line-modified">271     const bool m_verbose;</span>
272 
273     bool m_changed;
274     unsigned m_count;
275 };
276 
277 bool performCFA(Graph&amp; graph)
278 {
279     return runPhase&lt;CFAPhase&gt;(graph);
280 }
281 
282 } } // namespace JSC::DFG
283 
284 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGByteCodeParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCFGSimplificationPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
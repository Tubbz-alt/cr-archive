diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SelectionRangeData.cpp
@@ -47,12 +47,12 @@
 
 struct SelectionData {
     using RendererMap = HashMap<RenderObject*, std::unique_ptr<RenderSelectionInfo>>;
     using RenderBlockMap = HashMap<const RenderBlock*, std::unique_ptr<RenderBlockSelectionInfo>>;
 
-    Optional<unsigned> startPosition;
-    Optional<unsigned> endPosition;
+    Optional<unsigned> startOffset;
+    Optional<unsigned> endOffset;
     RendererMap renderers;
     RenderBlockMap blocks;
 };
 
 class SelectionIterator {
@@ -96,11 +96,11 @@
     Vector<RenderMultiColumnSpannerPlaceholder*> m_spannerStack;
 };
 
 } // anonymous namespace
 
-static RenderObject* rendererAfterPosition(const RenderObject& renderer, unsigned offset)
+static RenderObject* rendererAfterOffset(const RenderObject& renderer, unsigned offset)
 {
     auto* child = renderer.childAt(offset);
     return child ? child : renderer.nextInPreOrderAfterChildren();
 }
 
@@ -117,18 +117,18 @@
     return is<RenderView>(containingBlock) ? nullptr : containingBlock;
 }
 
 static SelectionData collect(const SelectionRangeData::Context& selection, bool repaintDifference)
 {
-    SelectionData oldSelectionData { selection.startPosition(), selection.endPosition(), { }, { } };
+    SelectionData oldSelectionData { selection.startOffset(), selection.endOffset(), { }, { } };
     // Blocks contain selected objects and fill gaps between them, either on the left, right, or in between lines and blocks.
     // In order to get the repaint rect right, we have to examine left, middle, and right rects individually, since otherwise
     // the union of those rects might remain the same even when changes have occurred.
     auto* start = selection.start();
     RenderObject* stop = nullptr;
     if (selection.end())
-        stop = rendererAfterPosition(*selection.end(), selection.endPosition().value());
+        stop = rendererAfterOffset(*selection.end(), selection.endOffset().value());
     SelectionIterator selectionIterator(start);
     while (start && start != stop) {
         if (isValidRendererForSelection(*start, selection)) {
             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
             oldSelectionData.renderers.set(start, makeUnique<RenderSelectionInfo>(*start, true));
@@ -152,14 +152,51 @@
     , m_selectionRectGatherer(view)
 #endif
 {
 }
 
+void SelectionRangeData::setContext(const Context& context)
+{
+    ASSERT(context.start() && context.end());
+    m_selectionContext = context;
+}
+
+RenderObject::SelectionState SelectionRangeData::selectionStateForRenderer(RenderObject& renderer)
+{
+    // FIXME: we shouldln't have to check that a renderer is a descendant of the render node
+    // from the range. This is likely because we aren't using VisiblePositions yet.
+    // Planned fix in a followup: <rdar://problem/58095923>
+    // https://bugs.webkit.org/show_bug.cgi?id=205529
+
+    if (&renderer == m_selectionContext.start()) {
+        if (m_selectionContext.start() && m_selectionContext.end() && m_selectionContext.start() == m_selectionContext.end())
+            return RenderObject::SelectionBoth;
+        if (m_selectionContext.start())
+            return RenderObject::SelectionStart;
+    }
+    if (&renderer == m_selectionContext.end())
+        return RenderObject::SelectionEnd;
+
+    RenderObject* selectionEnd = nullptr;
+    auto* selectionDataEnd = m_selectionContext.end();
+    if (selectionDataEnd)
+        selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());
+    SelectionIterator selectionIterator(m_selectionContext.start());
+    for (auto* currentRenderer = m_selectionContext.start(); currentRenderer && currentRenderer != m_selectionContext.end(); currentRenderer = selectionIterator.next()) {
+        if (currentRenderer == m_selectionContext.start() || currentRenderer == m_selectionContext.end())
+            continue;
+        if (!currentRenderer->canBeSelectionLeaf())
+            continue;
+        if (&renderer == currentRenderer)
+            return RenderObject::SelectionInside;
+    }
+    return RenderObject::SelectionNone;
+
+}
+
 void SelectionRangeData::set(const Context& selection, RepaintMode blockRepaintMode)
 {
-    // Make sure both our start and end objects are defined.
-    // Check www.msnbc.com and try clicking around to find the case where this happened.
     if ((selection.start() && !selection.end()) || (selection.end() && !selection.start()))
         return;
     // Just return if the selection hasn't changed.
     auto isCaret = m_renderView.frame().selection().isCaret();
     if (selection == m_selectionContext && m_selectionWasCaret == isCaret)
@@ -182,11 +219,11 @@
 void SelectionRangeData::repaint() const
 {
     HashSet<RenderBlock*> processedBlocks;
     RenderObject* end = nullptr;
     if (m_selectionContext.end())
-        end = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());
+        end = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());
     SelectionIterator selectionIterator(m_selectionContext.start());
     for (auto* renderer = selectionIterator.current(); renderer && renderer != end; renderer = selectionIterator.next()) {
         if (!renderer->canBeSelectionLeaf() && renderer != m_selectionContext.start() && renderer != m_selectionContext.end())
             continue;
         if (renderer->selectionState() == RenderObject::SelectionNone)
@@ -205,11 +242,11 @@
 {
     SelectionData::RendererMap renderers;
     auto* start = m_selectionContext.start();
     RenderObject* stop = nullptr;
     if (m_selectionContext.end())
-        stop = rendererAfterPosition(*m_selectionContext.end(), m_selectionContext.endPosition().value());
+        stop = rendererAfterOffset(*m_selectionContext.end(), m_selectionContext.endOffset().value());
     SelectionIterator selectionIterator(start);
     while (start && start != stop) {
         if ((start->canBeSelectionLeaf() || start == m_selectionContext.start() || start == m_selectionContext.end())
             && start->selectionState() != RenderObject::SelectionNone) {
             // Blocks are responsible for painting line gaps and margin gaps. They must be examined as well.
@@ -259,11 +296,11 @@
     }
 
     RenderObject* selectionEnd = nullptr;
     auto* selectionDataEnd = m_selectionContext.end();
     if (selectionDataEnd)
-        selectionEnd = rendererAfterPosition(*selectionDataEnd, m_selectionContext.endPosition().value());
+        selectionEnd = rendererAfterOffset(*selectionDataEnd, m_selectionContext.endOffset().value());
     SelectionIterator selectionIterator(selectionStart);
     for (auto* currentRenderer = selectionStart; currentRenderer && currentRenderer != selectionEnd; currentRenderer = selectionIterator.next()) {
         if (currentRenderer == selectionStart || currentRenderer == m_selectionContext.end())
             continue;
         if (!currentRenderer->canBeSelectionLeaf())
@@ -310,12 +347,12 @@
     for (auto& selectedRendererInfo : oldSelectionData.renderers) {
         auto* renderer = selectedRendererInfo.key;
         auto* newInfo = newSelectedRenderers.get(renderer);
         auto* oldInfo = selectedRendererInfo.value.get();
         if (!newInfo || oldInfo->rect() != newInfo->rect() || oldInfo->state() != newInfo->state()
-            || (m_selectionContext.start() == renderer && oldSelectionData.startPosition != m_selectionContext.startPosition())
-            || (m_selectionContext.end() == renderer && oldSelectionData.endPosition != m_selectionContext.endPosition())) {
+            || (m_selectionContext.start() == renderer && oldSelectionData.startOffset != m_selectionContext.startOffset())
+            || (m_selectionContext.end() == renderer && oldSelectionData.endOffset != m_selectionContext.endOffset())) {
             oldInfo->repaint();
             if (newInfo) {
                 newInfo->repaint();
                 newSelectedRenderers.remove(renderer);
             }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AirCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCustom.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCustom.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirInstInlines.h&quot;
 32 #include &quot;B3CCallValue.h&quot;
 33 #include &quot;B3ValueInlines.h&quot;

 34 
 35 namespace JSC { namespace B3 { namespace Air {
 36 
 37 bool PatchCustom::isValidForm(Inst&amp; inst)
 38 {
 39     if (inst.args.size() &lt; 1)
 40         return false;
 41     if (!inst.args[0].isSpecial())
 42         return false;
 43     if (!inst.args[0].special()-&gt;isValid(inst))
 44         return false;
 45     RegisterSet clobberedEarly = inst.extraEarlyClobberedRegs();
 46     RegisterSet clobberedLate = inst.extraClobberedRegs();
 47     bool ok = true;
 48     inst.forEachTmp(
 49         [&amp;] (Tmp&amp; tmp, Arg::Role role, Bank, Width) {
 50             if (!tmp.isReg())
 51                 return;
 52             if (Arg::isLateDef(role) || Arg::isLateUse(role))
 53                 ok &amp;= !clobberedLate.get(tmp.reg());
</pre>
<hr />
<pre>
 79 
 80     // If there is a result then it cannot be an immediate.
 81     if (value-&gt;type() != Void) {
 82         if (inst.args[1].isSomeImm())
 83             return false;
 84         if (!inst.args[1].canRepresent(value))
 85             return false;
 86         offset++;
 87     }
 88 
 89     for (unsigned i = value-&gt;numChildren(); i-- &gt; 1;) {
 90         Value* child = value-&gt;child(i);
 91         Arg arg = inst.args[offset + i];
 92         if (!arg.canRepresent(child))
 93             return false;
 94     }
 95 
 96     return true;
 97 }
 98 
<span class="line-modified"> 99 CCallHelpers::Jump CCallCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)</span>
100 {
101     dataLog(&quot;FATAL: Unlowered C call: &quot;, inst, &quot;\n&quot;);
102     UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">103     return CCallHelpers::Jump();</span>
104 }
105 
106 bool ShuffleCustom::isValidForm(Inst&amp; inst)
107 {
108     if (inst.args.size() % 3)
109         return false;
110 
111     // A destination may only appear once. This requirement allows us to avoid the undefined behavior
112     // of having a destination that is supposed to get multiple inputs simultaneously. It also
113     // imposes some interesting constraints on the &quot;shape&quot; of the shuffle. If we treat a shuffle pair
114     // as an edge and the Args as nodes, then the single-destination requirement means that the
115     // shuffle graph consists of two kinds of subgraphs:
116     //
117     // - Spanning trees. We call these shifts. They can be executed as a sequence of Move
118     //   instructions and don&#39;t usually require scratch registers.
119     //
120     // - Closed loops. These loops consist of nodes that have one successor and one predecessor, so
121     //   there is no way to &quot;get into&quot; the loop from outside of it. These can be executed using swaps
122     //   or by saving one of the Args to a scratch register and executing it as a shift.
123     HashSet&lt;Arg&gt; dsts;
</pre>
<hr />
<pre>
154 
155     // No destination register may appear in any address expressions. The lowering can&#39;t handle it
156     // and it&#39;s not useful for the way we end up using Shuffles. Normally, Shuffles only used for
157     // stack addresses and non-stack registers.
158     for (Arg&amp; arg : inst.args) {
159         if (!arg.isMemory())
160             continue;
161         bool ok = true;
162         arg.forEachTmpFast(
163             [&amp;] (Tmp tmp) {
164                 if (dsts.contains(tmp))
165                     ok = false;
166             });
167         if (!ok)
168             return false;
169     }
170 
171     return true;
172 }
173 
<span class="line-modified">174 CCallHelpers::Jump ShuffleCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)</span>
175 {
176     dataLog(&quot;FATAL: Unlowered shuffle: &quot;, inst, &quot;\n&quot;);
177     UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">178     return CCallHelpers::Jump();</span>
179 }
180 
181 bool WasmBoundsCheckCustom::isValidForm(Inst&amp; inst)
182 {
183     if (inst.args.size() != 2)
184         return false;
185     if (!inst.args[0].isTmp() &amp;&amp; !inst.args[0].isSomeImm())
186         return false;
187 
188     return inst.args[1].isReg() || inst.args[1].isTmp() || inst.args[1].isSomeImm();
189 }
190 






















191 
192 } } } // namespace JSC::B3::Air
193 
194 #endif // ENABLE(B3_JIT)
195 
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCustom.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirInstInlines.h&quot;
 32 #include &quot;B3CCallValue.h&quot;
 33 #include &quot;B3ValueInlines.h&quot;
<span class="line-added"> 34 #include &quot;CCallHelpers.h&quot;</span>
 35 
 36 namespace JSC { namespace B3 { namespace Air {
 37 
 38 bool PatchCustom::isValidForm(Inst&amp; inst)
 39 {
 40     if (inst.args.size() &lt; 1)
 41         return false;
 42     if (!inst.args[0].isSpecial())
 43         return false;
 44     if (!inst.args[0].special()-&gt;isValid(inst))
 45         return false;
 46     RegisterSet clobberedEarly = inst.extraEarlyClobberedRegs();
 47     RegisterSet clobberedLate = inst.extraClobberedRegs();
 48     bool ok = true;
 49     inst.forEachTmp(
 50         [&amp;] (Tmp&amp; tmp, Arg::Role role, Bank, Width) {
 51             if (!tmp.isReg())
 52                 return;
 53             if (Arg::isLateDef(role) || Arg::isLateUse(role))
 54                 ok &amp;= !clobberedLate.get(tmp.reg());
</pre>
<hr />
<pre>
 80 
 81     // If there is a result then it cannot be an immediate.
 82     if (value-&gt;type() != Void) {
 83         if (inst.args[1].isSomeImm())
 84             return false;
 85         if (!inst.args[1].canRepresent(value))
 86             return false;
 87         offset++;
 88     }
 89 
 90     for (unsigned i = value-&gt;numChildren(); i-- &gt; 1;) {
 91         Value* child = value-&gt;child(i);
 92         Arg arg = inst.args[offset + i];
 93         if (!arg.canRepresent(child))
 94             return false;
 95     }
 96 
 97     return true;
 98 }
 99 
<span class="line-modified">100 MacroAssembler::Jump CCallCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)</span>
101 {
102     dataLog(&quot;FATAL: Unlowered C call: &quot;, inst, &quot;\n&quot;);
103     UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">104     return MacroAssembler::Jump();</span>
105 }
106 
107 bool ShuffleCustom::isValidForm(Inst&amp; inst)
108 {
109     if (inst.args.size() % 3)
110         return false;
111 
112     // A destination may only appear once. This requirement allows us to avoid the undefined behavior
113     // of having a destination that is supposed to get multiple inputs simultaneously. It also
114     // imposes some interesting constraints on the &quot;shape&quot; of the shuffle. If we treat a shuffle pair
115     // as an edge and the Args as nodes, then the single-destination requirement means that the
116     // shuffle graph consists of two kinds of subgraphs:
117     //
118     // - Spanning trees. We call these shifts. They can be executed as a sequence of Move
119     //   instructions and don&#39;t usually require scratch registers.
120     //
121     // - Closed loops. These loops consist of nodes that have one successor and one predecessor, so
122     //   there is no way to &quot;get into&quot; the loop from outside of it. These can be executed using swaps
123     //   or by saving one of the Args to a scratch register and executing it as a shift.
124     HashSet&lt;Arg&gt; dsts;
</pre>
<hr />
<pre>
155 
156     // No destination register may appear in any address expressions. The lowering can&#39;t handle it
157     // and it&#39;s not useful for the way we end up using Shuffles. Normally, Shuffles only used for
158     // stack addresses and non-stack registers.
159     for (Arg&amp; arg : inst.args) {
160         if (!arg.isMemory())
161             continue;
162         bool ok = true;
163         arg.forEachTmpFast(
164             [&amp;] (Tmp tmp) {
165                 if (dsts.contains(tmp))
166                     ok = false;
167             });
168         if (!ok)
169             return false;
170     }
171 
172     return true;
173 }
174 
<span class="line-modified">175 MacroAssembler::Jump ShuffleCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)</span>
176 {
177     dataLog(&quot;FATAL: Unlowered shuffle: &quot;, inst, &quot;\n&quot;);
178     UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">179     return MacroAssembler::Jump();</span>
180 }
181 
182 bool WasmBoundsCheckCustom::isValidForm(Inst&amp; inst)
183 {
184     if (inst.args.size() != 2)
185         return false;
186     if (!inst.args[0].isTmp() &amp;&amp; !inst.args[0].isSomeImm())
187         return false;
188 
189     return inst.args[1].isReg() || inst.args[1].isTmp() || inst.args[1].isSomeImm();
190 }
191 
<span class="line-added">192 MacroAssembler::Jump WasmBoundsCheckCustom::generate(Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)</span>
<span class="line-added">193 {</span>
<span class="line-added">194     WasmBoundsCheckValue* value = inst.origin-&gt;as&lt;WasmBoundsCheckValue&gt;();</span>
<span class="line-added">195     MacroAssembler::Jump outOfBounds = Inst(Air::Branch64, value, Arg::relCond(MacroAssembler::AboveOrEqual), inst.args[0], inst.args[1]).generate(jit, context);</span>
<span class="line-added">196 </span>
<span class="line-added">197     context.latePaths.append(createSharedTask&lt;GenerationContext::LatePathFunction&gt;(</span>
<span class="line-added">198         [outOfBounds, value] (CCallHelpers&amp; jit, Air::GenerationContext&amp; context) {</span>
<span class="line-added">199             outOfBounds.link(&amp;jit);</span>
<span class="line-added">200             switch (value-&gt;boundsType()) {</span>
<span class="line-added">201             case WasmBoundsCheckValue::Type::Pinned:</span>
<span class="line-added">202                 context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, value-&gt;bounds().pinnedSize);</span>
<span class="line-added">203                 break;</span>
<span class="line-added">204 </span>
<span class="line-added">205             case WasmBoundsCheckValue::Type::Maximum:</span>
<span class="line-added">206                 context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, InvalidGPRReg);</span>
<span class="line-added">207                 break;</span>
<span class="line-added">208             }</span>
<span class="line-added">209         }));</span>
<span class="line-added">210 </span>
<span class="line-added">211     // We said we were not a terminal.</span>
<span class="line-added">212     return MacroAssembler::Jump();</span>
<span class="line-added">213 }</span>
214 
215 } } } // namespace JSC::B3::Air
216 
217 #endif // ENABLE(B3_JIT)
218 
</pre>
</td>
</tr>
</table>
<center><a href="AirCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirCustom.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeRareData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
460     void dispatchEvent(Event&amp;) override;
461 
462     void dispatchScopedEvent(Event&amp;);
463 
464     virtual void handleLocalEvents(Event&amp;, EventInvokePhase);
465 
466     void dispatchSubtreeModifiedEvent();
467     void dispatchDOMActivateEvent(Event&amp; underlyingClickEvent);
468 
469 #if ENABLE(TOUCH_EVENTS)
470     virtual bool allowsDoubleTapGesture() const { return true; }
471 #endif
472 
473     bool dispatchBeforeLoadEvent(const String&amp; sourceURL);
474 
475     WEBCORE_EXPORT void dispatchInputEvent();
476 
477     // Perform the default action for an event.
478     virtual void defaultEventHandler(Event&amp;);
479 
<span class="line-modified">480     void ref();</span>
<span class="line-modified">481     void deref();</span>
482     bool hasOneRef() const;
483     unsigned refCount() const;
484 
<span class="line-modified">485 #ifndef NDEBUG</span>
486     bool m_deletionHasBegun { false };
<span class="line-modified">487     bool m_inRemovedLastRefFunction { false };</span>
488     bool m_adoptionIsRequired { true };
489 #endif
490 
491     EventTargetData* eventTargetData() final;
492     EventTargetData* eventTargetDataConcurrently() final;
493     EventTargetData&amp; ensureEventTargetData() final;
494 
495     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; registeredMutationObservers(MutationObserver::MutationType, const QualifiedName* attributeName);
496     void registerMutationObserver(MutationObserver&amp;, MutationObserverOptions, const HashSet&lt;AtomString&gt;&amp; attributeFilter);
497     void unregisterMutationObserver(MutationObserverRegistration&amp;);
498     void registerTransientMutationObserver(MutationObserverRegistration&amp;);
499     void unregisterTransientMutationObserver(MutationObserverRegistration&amp;);
500     void notifyMutationObserversNodeWillDetach();
501 
502     WEBCORE_EXPORT void textRects(Vector&lt;IntRect&gt;&amp;) const;
503 
504     unsigned connectedSubframeCount() const;
505     void incrementConnectedSubframeCount(unsigned amount = 1);
506     void decrementConnectedSubframeCount(unsigned amount = 1);
507     void updateAncestorConnectedSubframeCountForRemoval() const;
</pre>
<hr />
<pre>
651     bool isNode() const final;
652 
653     void trackForDebugging();
654     void materializeRareData();
655 
656     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* mutationObserverRegistry();
657     HashSet&lt;MutationObserverRegistration*&gt;* transientMutationObserverRegistry();
658 
659     void adjustStyleValidity(Style::Validity, Style::InvalidationMode);
660 
661     void* opaqueRootSlow() const;
662 
663     static void moveShadowTreeToNewDocument(ShadowRoot&amp;, Document&amp; oldDocument, Document&amp; newDocument);
664     static void moveTreeToNewScope(Node&amp;, TreeScope&amp; oldScope, TreeScope&amp; newScope);
665     void moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
666 
667     struct NodeRareDataDeleter {
668         void operator()(NodeRareData*) const;
669     };
670 
<span class="line-modified">671     uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
672     mutable uint32_t m_nodeFlags;
673 
674     ContainerNode* m_parentNode { nullptr };
675     TreeScope* m_treeScope { nullptr };
676     Node* m_previous { nullptr };
677     Node* m_next { nullptr };
678     CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;
679     std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;
680 };
681 
<span class="line-modified">682 #ifndef NDEBUG</span>
683 inline void adopted(Node* node)
684 {
685     if (!node)
686         return;
687     ASSERT(!node-&gt;m_deletionHasBegun);
688     ASSERT(!node-&gt;m_inRemovedLastRefFunction);
689     node-&gt;m_adoptionIsRequired = false;
690 }
<span class="line-modified">691 #endif</span>
692 
<span class="line-modified">693 ALWAYS_INLINE void Node::ref()</span>
694 {
695     ASSERT(isMainThread());
696     ASSERT(!m_deletionHasBegun);
697     ASSERT(!m_inRemovedLastRefFunction);
698     ASSERT(!m_adoptionIsRequired);
699     m_refCountAndParentBit += s_refCountIncrement;
700 }
701 
<span class="line-modified">702 ALWAYS_INLINE void Node::deref()</span>
703 {
704     ASSERT(isMainThread());
705     ASSERT(refCount());
706     ASSERT(!m_deletionHasBegun);
707     ASSERT(!m_inRemovedLastRefFunction);
708     ASSERT(!m_adoptionIsRequired);
709     auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;
710     if (!updatedRefCount) {
711         // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.
712         // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
<span class="line-modified">713 #ifndef NDEBUG</span>
714         m_inRemovedLastRefFunction = true;
715 #endif
<span class="line-modified">716         removedLastRef();</span>
717         return;
718     }
719     m_refCountAndParentBit = updatedRefCount;
720 }
721 
722 ALWAYS_INLINE bool Node::hasOneRef() const
723 {
724     ASSERT(!m_deletionHasBegun);
725     ASSERT(!m_inRemovedLastRefFunction);
726     return refCount() == 1;
727 }
728 
729 ALWAYS_INLINE unsigned Node::refCount() const
730 {
731     return m_refCountAndParentBit / s_refCountIncrement;
732 }
733 
734 // Used in Node::addSubresourceAttributeURLs() and in addSubresourceStyleURLs()
735 inline void addSubresourceURL(ListHashSet&lt;URL&gt;&amp; urls, const URL&amp; url)
736 {
</pre>
<hr />
<pre>
773 
774 inline bool Node::styleResolutionShouldRecompositeLayer() const
775 {
776     return getFlag(StyleResolutionShouldRecompositeLayerFlag);
777 }
778 
779 inline void Node::setHasValidStyle()
780 {
781     m_nodeFlags &amp;= ~StyleValidityMask;
782     clearFlag(StyleResolutionShouldRecompositeLayerFlag);
783 }
784 
785 inline void Node::setTreeScopeRecursively(TreeScope&amp; newTreeScope)
786 {
787     ASSERT(!isDocumentNode());
788     ASSERT(!m_deletionHasBegun);
789     if (m_treeScope != &amp;newTreeScope)
790         moveTreeToNewScope(*this, *m_treeScope, newTreeScope);
791 }
792 


793 } // namespace WebCore
794 
795 #if ENABLE(TREE_DEBUGGING)
796 // Outside the WebCore namespace for ease of invocation from the debugger.
797 void showTree(const WebCore::Node*);
798 void showNodePath(const WebCore::Node*);
799 #endif
800 
801 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Node)
802     static bool isType(const WebCore::EventTarget&amp; target) { return target.isNode(); }
803 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
<td>
<hr />
<pre>
460     void dispatchEvent(Event&amp;) override;
461 
462     void dispatchScopedEvent(Event&amp;);
463 
464     virtual void handleLocalEvents(Event&amp;, EventInvokePhase);
465 
466     void dispatchSubtreeModifiedEvent();
467     void dispatchDOMActivateEvent(Event&amp; underlyingClickEvent);
468 
469 #if ENABLE(TOUCH_EVENTS)
470     virtual bool allowsDoubleTapGesture() const { return true; }
471 #endif
472 
473     bool dispatchBeforeLoadEvent(const String&amp; sourceURL);
474 
475     WEBCORE_EXPORT void dispatchInputEvent();
476 
477     // Perform the default action for an event.
478     virtual void defaultEventHandler(Event&amp;);
479 
<span class="line-modified">480     void ref() const;</span>
<span class="line-modified">481     void deref() const;</span>
482     bool hasOneRef() const;
483     unsigned refCount() const;
484 
<span class="line-modified">485 #if ASSERT_ENABLED</span>
486     bool m_deletionHasBegun { false };
<span class="line-modified">487     mutable bool m_inRemovedLastRefFunction { false };</span>
488     bool m_adoptionIsRequired { true };
489 #endif
490 
491     EventTargetData* eventTargetData() final;
492     EventTargetData* eventTargetDataConcurrently() final;
493     EventTargetData&amp; ensureEventTargetData() final;
494 
495     HashMap&lt;Ref&lt;MutationObserver&gt;, MutationRecordDeliveryOptions&gt; registeredMutationObservers(MutationObserver::MutationType, const QualifiedName* attributeName);
496     void registerMutationObserver(MutationObserver&amp;, MutationObserverOptions, const HashSet&lt;AtomString&gt;&amp; attributeFilter);
497     void unregisterMutationObserver(MutationObserverRegistration&amp;);
498     void registerTransientMutationObserver(MutationObserverRegistration&amp;);
499     void unregisterTransientMutationObserver(MutationObserverRegistration&amp;);
500     void notifyMutationObserversNodeWillDetach();
501 
502     WEBCORE_EXPORT void textRects(Vector&lt;IntRect&gt;&amp;) const;
503 
504     unsigned connectedSubframeCount() const;
505     void incrementConnectedSubframeCount(unsigned amount = 1);
506     void decrementConnectedSubframeCount(unsigned amount = 1);
507     void updateAncestorConnectedSubframeCountForRemoval() const;
</pre>
<hr />
<pre>
651     bool isNode() const final;
652 
653     void trackForDebugging();
654     void materializeRareData();
655 
656     Vector&lt;std::unique_ptr&lt;MutationObserverRegistration&gt;&gt;* mutationObserverRegistry();
657     HashSet&lt;MutationObserverRegistration*&gt;* transientMutationObserverRegistry();
658 
659     void adjustStyleValidity(Style::Validity, Style::InvalidationMode);
660 
661     void* opaqueRootSlow() const;
662 
663     static void moveShadowTreeToNewDocument(ShadowRoot&amp;, Document&amp; oldDocument, Document&amp; newDocument);
664     static void moveTreeToNewScope(Node&amp;, TreeScope&amp; oldScope, TreeScope&amp; newScope);
665     void moveNodeToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
666 
667     struct NodeRareDataDeleter {
668         void operator()(NodeRareData*) const;
669     };
670 
<span class="line-modified">671     mutable uint32_t m_refCountAndParentBit { s_refCountIncrement };</span>
672     mutable uint32_t m_nodeFlags;
673 
674     ContainerNode* m_parentNode { nullptr };
675     TreeScope* m_treeScope { nullptr };
676     Node* m_previous { nullptr };
677     Node* m_next { nullptr };
678     CompactPointerTuple&lt;RenderObject*, uint8_t&gt; m_rendererWithStyleFlags;
679     std::unique_ptr&lt;NodeRareData, NodeRareDataDeleter&gt; m_rareData;
680 };
681 
<span class="line-modified">682 #if ASSERT_ENABLED</span>
683 inline void adopted(Node* node)
684 {
685     if (!node)
686         return;
687     ASSERT(!node-&gt;m_deletionHasBegun);
688     ASSERT(!node-&gt;m_inRemovedLastRefFunction);
689     node-&gt;m_adoptionIsRequired = false;
690 }
<span class="line-modified">691 #endif // ASSERT_ENABLED</span>
692 
<span class="line-modified">693 ALWAYS_INLINE void Node::ref() const</span>
694 {
695     ASSERT(isMainThread());
696     ASSERT(!m_deletionHasBegun);
697     ASSERT(!m_inRemovedLastRefFunction);
698     ASSERT(!m_adoptionIsRequired);
699     m_refCountAndParentBit += s_refCountIncrement;
700 }
701 
<span class="line-modified">702 ALWAYS_INLINE void Node::deref() const</span>
703 {
704     ASSERT(isMainThread());
705     ASSERT(refCount());
706     ASSERT(!m_deletionHasBegun);
707     ASSERT(!m_inRemovedLastRefFunction);
708     ASSERT(!m_adoptionIsRequired);
709     auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;
710     if (!updatedRefCount) {
711         // Don&#39;t update m_refCountAndParentBit to avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;.
712         // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
<span class="line-modified">713 #if ASSERT_ENABLED</span>
714         m_inRemovedLastRefFunction = true;
715 #endif
<span class="line-modified">716         const_cast&lt;Node&amp;&gt;(*this).removedLastRef();</span>
717         return;
718     }
719     m_refCountAndParentBit = updatedRefCount;
720 }
721 
722 ALWAYS_INLINE bool Node::hasOneRef() const
723 {
724     ASSERT(!m_deletionHasBegun);
725     ASSERT(!m_inRemovedLastRefFunction);
726     return refCount() == 1;
727 }
728 
729 ALWAYS_INLINE unsigned Node::refCount() const
730 {
731     return m_refCountAndParentBit / s_refCountIncrement;
732 }
733 
734 // Used in Node::addSubresourceAttributeURLs() and in addSubresourceStyleURLs()
735 inline void addSubresourceURL(ListHashSet&lt;URL&gt;&amp; urls, const URL&amp; url)
736 {
</pre>
<hr />
<pre>
773 
774 inline bool Node::styleResolutionShouldRecompositeLayer() const
775 {
776     return getFlag(StyleResolutionShouldRecompositeLayerFlag);
777 }
778 
779 inline void Node::setHasValidStyle()
780 {
781     m_nodeFlags &amp;= ~StyleValidityMask;
782     clearFlag(StyleResolutionShouldRecompositeLayerFlag);
783 }
784 
785 inline void Node::setTreeScopeRecursively(TreeScope&amp; newTreeScope)
786 {
787     ASSERT(!isDocumentNode());
788     ASSERT(!m_deletionHasBegun);
789     if (m_treeScope != &amp;newTreeScope)
790         moveTreeToNewScope(*this, *m_treeScope, newTreeScope);
791 }
792 
<span class="line-added">793 bool areNodesConnectedInSameTreeScope(const Node*, const Node*);</span>
<span class="line-added">794 </span>
795 } // namespace WebCore
796 
797 #if ENABLE(TREE_DEBUGGING)
798 // Outside the WebCore namespace for ease of invocation from the debugger.
799 void showTree(const WebCore::Node*);
800 void showNodePath(const WebCore::Node*);
801 #endif
802 
803 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Node)
804     static bool isType(const WebCore::EventTarget&amp; target) { return target.isNode(); }
805 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
</tr>
</table>
<center><a href="Node.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NodeRareData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
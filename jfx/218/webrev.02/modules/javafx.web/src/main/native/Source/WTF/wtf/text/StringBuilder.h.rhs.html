<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &lt;wtf/CheckedArithmetic.h&gt;
 30 #include &lt;wtf/text/AtomString.h&gt;
 31 #include &lt;wtf/text/IntegerToStringConversion.h&gt;
 32 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 33 #include &lt;wtf/text/StringView.h&gt;
 34 #include &lt;wtf/text/WTFString.h&gt;
 35 
 36 namespace WTF {
 37 
 38 // StringBuilder currently uses a Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; for m_length.
 39 // Ideally, we would want to make StringBuilder a template with an OverflowHandler parameter, and
 40 // m_length can be instantiated based on that OverflowHandler instead. However, currently, we&#39;re
 41 // not able to get clang to export explicitly instantiated template methods (which would be needed
 42 // if we templatize StringBuilder). As a workaround, we use the ConditionalCrashOnOverflow handler
 43 // instead to do a runtime check on whether it should crash on overflows or not.
 44 //
 45 // When clang is able to export explicitly instantiated template methods, we can templatize
 46 // StringBuilder and do away with ConditionalCrashOnOverflow.
 47 // See https://bugs.webkit.org/show_bug.cgi?id=191050.
 48 
 49 class StringBuilder {
 50     // Disallow copying since it&#39;s expensive and we don&#39;t want code to do it by accident.
 51     WTF_MAKE_NONCOPYABLE(StringBuilder);
 52     WTF_MAKE_FAST_ALLOCATED;
 53 
 54 public:
 55     enum class OverflowHandler {
 56         CrashOnOverflow,
 57         RecordOverflow
 58     };
 59 
 60     StringBuilder(OverflowHandler handler = OverflowHandler::CrashOnOverflow)
 61         : m_bufferCharacters8(nullptr)
 62     {
 63         m_length.setShouldCrashOnOverflow(handler == OverflowHandler::CrashOnOverflow);
 64     }
 65     StringBuilder(StringBuilder&amp;&amp;) = default;
 66     StringBuilder&amp; operator=(StringBuilder&amp;&amp;) = default;
 67 
 68     ALWAYS_INLINE void didOverflow() { m_length.overflowed(); }
 69     ALWAYS_INLINE bool hasOverflowed() const { return m_length.hasOverflowed(); }
 70     ALWAYS_INLINE bool crashesOnOverflow() const { return m_length.shouldCrashOnOverflow(); }
 71 
 72     WTF_EXPORT_PRIVATE void appendCharacters(const UChar*, unsigned);
 73     WTF_EXPORT_PRIVATE void appendCharacters(const LChar*, unsigned);
 74 
 75     ALWAYS_INLINE void appendCharacters(const char* characters, unsigned length) { appendCharacters(reinterpret_cast&lt;const LChar*&gt;(characters), length); }
 76 
 77     void append(const AtomString&amp; atomString)
 78     {
 79         append(atomString.string());
 80     }
 81 
 82     void append(const String&amp; string)
 83     {
 84         if (hasOverflowed())
 85             return;
 86 
 87         if (!string.length())
 88             return;
 89 
 90         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
 91         // then just retain the string.
 92         if (!m_length &amp;&amp; !m_buffer) {
 93             m_string = string;
 94             m_length = string.length();
 95             m_is8Bit = m_string.is8Bit();
 96             return;
 97         }
 98 
 99         if (string.is8Bit())
100             appendCharacters(string.characters8(), string.length());
101         else
102             appendCharacters(string.characters16(), string.length());
103     }
104 
105     void append(const StringBuilder&amp; other)
106     {
107         if (hasOverflowed())
108             return;
109         if (other.hasOverflowed())
110             return didOverflow();
111 
112         if (!other.m_length)
113             return;
114 
115         // If we&#39;re appending to an empty string, and there is not a buffer (reserveCapacity has not been called)
116         // then just retain the string.
117         if (!m_length &amp;&amp; !m_buffer &amp;&amp; !other.m_string.isNull()) {
118             m_string = other.m_string;
119             m_length = other.m_length;
120             m_is8Bit = other.m_is8Bit;
121             return;
122         }
123 
124         if (other.is8Bit())
125             appendCharacters(other.characters8(), other.m_length.unsafeGet());
126         else
127             appendCharacters(other.characters16(), other.m_length.unsafeGet());
128     }
129 
130     void append(StringView stringView)
131     {
132         if (stringView.is8Bit())
133             appendCharacters(stringView.characters8(), stringView.length());
134         else
135             appendCharacters(stringView.characters16(), stringView.length());
136     }
137 
138 #if USE(CF)
139     WTF_EXPORT_PRIVATE void append(CFStringRef);
140 #endif
141 #if USE(CF) &amp;&amp; defined(__OBJC__)
142     void append(NSString *string) { append((__bridge CFStringRef)string); }
143 #endif
144 
<a name="1" id="anc1"></a><span class="line-modified">145     void appendSubstring(const String&amp; string, unsigned offset, unsigned length = String::MaxLength)</span>
146     {
<a name="2" id="anc2"></a><span class="line-modified">147         if (offset &gt;= string.length())</span>



148             return;
149 
<a name="3" id="anc3"></a><span class="line-added">150         unsigned clampedLength = std::min(length, string.length() - offset);</span>
151         if (string.is8Bit())
<a name="4" id="anc4"></a><span class="line-modified">152             appendCharacters(string.characters8() + offset, clampedLength);</span>
153         else
<a name="5" id="anc5"></a><span class="line-modified">154             appendCharacters(string.characters16() + offset, clampedLength);</span>
155     }
156 
157     void append(const char* characters)
158     {
159         if (characters)
160             appendCharacters(characters, strlen(characters));
161     }
162 
163     void appendCharacter(UChar) = delete;
164     void append(UChar c)
165     {
166         if (hasOverflowed())
167             return;
168         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
169         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
170             if (!m_is8Bit) {
171                 m_bufferCharacters16[length] = c;
172                 m_length++;
173                 return;
174             }
175 
176             if (isLatin1(c)) {
177                 m_bufferCharacters8[length] = static_cast&lt;LChar&gt;(c);
178                 m_length++;
179                 return;
180             }
181         }
182         appendCharacters(&amp;c, 1);
183     }
184 
185     void appendCharacter(LChar) = delete;
186     void append(LChar c)
187     {
188         if (hasOverflowed())
189             return;
190         unsigned length = m_length.unsafeGet&lt;unsigned&gt;();
191         if (m_buffer &amp;&amp; length &lt; m_buffer-&gt;length() &amp;&amp; m_string.isNull()) {
192             if (m_is8Bit)
193                 m_bufferCharacters8[length] = c;
194             else
195                 m_bufferCharacters16[length] = c;
196             m_length++;
197         } else
198             appendCharacters(&amp;c, 1);
199     }
200 
201     void appendCharacter(char) = delete;
202     void append(char c)
203     {
204         append(static_cast&lt;LChar&gt;(c));
205     }
206 
207     void appendCharacter(UChar32 c)
208     {
209         if (U_IS_BMP(c)) {
210             append(static_cast&lt;UChar&gt;(c));
211             return;
212         }
213         append(U16_LEAD(c));
214         append(U16_TRAIL(c));
215     }
216 
217     WTF_EXPORT_PRIVATE void appendQuotedJSONString(const String&amp;);
218 
219     template&lt;unsigned characterCount&gt;
220     ALWAYS_INLINE void appendLiteral(const char (&amp;characters)[characterCount]) { appendCharacters(characters, characterCount - 1); }
221 
222     WTF_EXPORT_PRIVATE void appendNumber(int);
223     WTF_EXPORT_PRIVATE void appendNumber(unsigned);
224     WTF_EXPORT_PRIVATE void appendNumber(long);
225     WTF_EXPORT_PRIVATE void appendNumber(unsigned long);
226     WTF_EXPORT_PRIVATE void appendNumber(long long);
227     WTF_EXPORT_PRIVATE void appendNumber(unsigned long long);
228     WTF_EXPORT_PRIVATE void appendNumber(float);
229     WTF_EXPORT_PRIVATE void appendNumber(double);
230 
<a name="6" id="anc6"></a>




231     template&lt;typename... StringTypes&gt; void append(StringTypes...);
232 
233     String toString()
234     {
235         if (!m_string.isNull()) {
236             ASSERT(!m_buffer || m_isReified);
237             ASSERT(!hasOverflowed());
238             return m_string;
239         }
240 
241         RELEASE_ASSERT(!hasOverflowed());
242         shrinkToFit();
243         reifyString();
244         return m_string;
245     }
246 
247     const String&amp; toStringPreserveCapacity() const
248     {
249         RELEASE_ASSERT(!hasOverflowed());
250         if (m_string.isNull())
251             reifyString();
252         return m_string;
253     }
254 
255     AtomString toAtomString() const
256     {
257         RELEASE_ASSERT(!hasOverflowed());
258         if (!m_length)
259             return emptyAtom();
260 
261         // If the buffer is sufficiently over-allocated, make a new AtomString from a copy so its buffer is not so large.
262         if (canShrink()) {
263             if (is8Bit())
264                 return AtomString(characters8(), length());
265             return AtomString(characters16(), length());
266         }
267 
268         if (!m_string.isNull())
269             return AtomString(m_string);
270 
271         ASSERT(m_buffer);
272         return AtomString(m_buffer.get(), 0, m_length.unsafeGet());
273     }
274 
275     unsigned length() const
276     {
277         RELEASE_ASSERT(!hasOverflowed());
278         return m_length.unsafeGet();
279     }
280 
281     bool isEmpty() const { return !m_length; }
282 
283     WTF_EXPORT_PRIVATE void reserveCapacity(unsigned newCapacity);
284 
285     unsigned capacity() const
286     {
287         RELEASE_ASSERT(!hasOverflowed());
288         return m_buffer ? m_buffer-&gt;length() : m_length.unsafeGet();
289     }
290 
291     WTF_EXPORT_PRIVATE void resize(unsigned newSize);
292 
293     WTF_EXPORT_PRIVATE bool canShrink() const;
294 
295     WTF_EXPORT_PRIVATE void shrinkToFit();
296 
297     UChar operator[](unsigned i) const
298     {
299         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!hasOverflowed() &amp;&amp; i &lt; m_length.unsafeGet&lt;unsigned&gt;());
300         if (m_is8Bit)
301             return characters8()[i];
302         return characters16()[i];
303     }
304 
305     const LChar* characters8() const
306     {
307         ASSERT(m_is8Bit);
308         if (!m_length)
309             return nullptr;
310         if (!m_string.isNull())
311             return m_string.characters8();
312         ASSERT(m_buffer);
313         return m_buffer-&gt;characters8();
314     }
315 
316     const UChar* characters16() const
317     {
318         ASSERT(!m_is8Bit);
319         if (!m_length)
320             return nullptr;
321         if (!m_string.isNull())
322             return m_string.characters16();
323         ASSERT(m_buffer);
324         return m_buffer-&gt;characters16();
325     }
326 
327     bool is8Bit() const { return m_is8Bit; }
328 
329     void clear()
330     {
331         m_length = 0;
332         m_string = String();
333         m_buffer = nullptr;
334         m_bufferCharacters8 = nullptr;
335         m_is8Bit = true;
336     }
337 
338     void swap(StringBuilder&amp; stringBuilder)
339     {
340         std::swap(m_length, stringBuilder.m_length);
341         m_string.swap(stringBuilder.m_string);
342         m_buffer.swap(stringBuilder.m_buffer);
343         std::swap(m_is8Bit, stringBuilder.m_is8Bit);
344         std::swap(m_bufferCharacters8, stringBuilder.m_bufferCharacters8);
345         ASSERT(!m_buffer || hasOverflowed() || m_buffer-&gt;length() &gt;= m_length.unsafeGet&lt;unsigned&gt;());
346     }
347 
348 private:
349     void allocateBuffer(const LChar* currentCharacters, unsigned requiredLength);
350     void allocateBuffer(const UChar* currentCharacters, unsigned requiredLength);
351     void allocateBufferUpConvert(const LChar* currentCharacters, unsigned requiredLength);
352     template&lt;typename CharacterType&gt; void reallocateBuffer(unsigned requiredLength);
353     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppending(unsigned additionalLength);
354     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* extendBufferForAppendingWithoutOverflowCheck(CheckedInt32 requiredLength);
355     template&lt;typename CharacterType&gt; CharacterType* extendBufferForAppendingSlowCase(unsigned requiredLength);
356     WTF_EXPORT_PRIVATE LChar* extendBufferForAppending8(CheckedInt32 requiredLength);
357     WTF_EXPORT_PRIVATE UChar* extendBufferForAppending16(CheckedInt32 requiredLength);
358 
359     template&lt;typename CharacterType&gt; ALWAYS_INLINE CharacterType* getBufferCharacters();
360     WTF_EXPORT_PRIVATE void reifyString() const;
361 
362     template&lt;typename... StringTypeAdapters&gt; void appendFromAdapters(StringTypeAdapters...);
363 
364     mutable String m_string;
365     RefPtr&lt;StringImpl&gt; m_buffer;
366     union {
367         LChar* m_bufferCharacters8;
368         UChar* m_bufferCharacters16;
369     };
370     static_assert(String::MaxLength == std::numeric_limits&lt;int32_t&gt;::max(), &quot;&quot;);
371     Checked&lt;int32_t, ConditionalCrashOnOverflow&gt; m_length;
372     bool m_is8Bit { true };
<a name="7" id="anc7"></a><span class="line-modified">373 #if ASSERT_ENABLED</span>
374     mutable bool m_isReified { false };
375 #endif
376 };
377 
378 template&lt;&gt;
379 ALWAYS_INLINE LChar* StringBuilder::getBufferCharacters&lt;LChar&gt;()
380 {
381     ASSERT(m_is8Bit);
382     return m_bufferCharacters8;
383 }
384 
385 template&lt;&gt;
386 ALWAYS_INLINE UChar* StringBuilder::getBufferCharacters&lt;UChar&gt;()
387 {
388     ASSERT(!m_is8Bit);
389     return m_bufferCharacters16;
390 }
391 
392 template&lt;typename... StringTypeAdapters&gt;
393 void StringBuilder::appendFromAdapters(StringTypeAdapters... adapters)
394 {
395     auto requiredLength = checkedSum&lt;int32_t&gt;(m_length, adapters.length()...);
396     if (m_is8Bit &amp;&amp; are8Bit(adapters...)) {
397         LChar* destination = extendBufferForAppending8(requiredLength);
398         if (!destination) {
399             ASSERT(hasOverflowed());
400             return;
401         }
402         stringTypeAdapterAccumulator(destination, adapters...);
403     } else {
404         UChar* destination = extendBufferForAppending16(requiredLength);
405         if (!destination) {
406             ASSERT(hasOverflowed());
407             return;
408         }
409         stringTypeAdapterAccumulator(destination, adapters...);
410     }
411 }
412 
413 template&lt;typename... StringTypes&gt;
414 void StringBuilder::append(StringTypes... strings)
415 {
416     appendFromAdapters(StringTypeAdapter&lt;StringTypes&gt;(strings)...);
417 }
418 
419 template&lt;typename CharacterType&gt;
420 bool equal(const StringBuilder&amp; s, const CharacterType* buffer, unsigned length)
421 {
422     if (s.length() != length)
423         return false;
424 
425     if (s.is8Bit())
426         return equal(s.characters8(), buffer, length);
427 
428     return equal(s.characters16(), buffer, length);
429 }
430 
431 template&lt;typename StringType&gt;
432 bool equal(const StringBuilder&amp; a, const StringType&amp; b)
433 {
434     if (a.length() != b.length())
435         return false;
436 
437     if (!a.length())
438         return true;
439 
440     if (a.is8Bit()) {
441         if (b.is8Bit())
442             return equal(a.characters8(), b.characters8(), a.length());
443         return equal(a.characters8(), b.characters16(), a.length());
444     }
445 
446     if (b.is8Bit())
447         return equal(a.characters16(), b.characters8(), a.length());
448     return equal(a.characters16(), b.characters16(), a.length());
449 }
450 
451 inline bool operator==(const StringBuilder&amp; a, const StringBuilder&amp; b) { return equal(a, b); }
452 inline bool operator!=(const StringBuilder&amp; a, const StringBuilder&amp; b) { return !equal(a, b); }
453 inline bool operator==(const StringBuilder&amp; a, const String&amp; b) { return equal(a, b); }
454 inline bool operator!=(const StringBuilder&amp; a, const String&amp; b) { return !equal(a, b); }
455 inline bool operator==(const String&amp; a, const StringBuilder&amp; b) { return equal(b, a); }
456 inline bool operator!=(const String&amp; a, const StringBuilder&amp; b) { return !equal(b, a); }
457 
458 template&lt;&gt; struct IntegerToStringConversionTrait&lt;StringBuilder&gt; {
459     using ReturnType = void;
460     using AdditionalArgumentType = StringBuilder;
461     static void flush(LChar* characters, unsigned length, StringBuilder* stringBuilder) { stringBuilder-&gt;appendCharacters(characters, length); }
462 };
463 
464 } // namespace WTF
465 
466 using WTF::StringBuilder;
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
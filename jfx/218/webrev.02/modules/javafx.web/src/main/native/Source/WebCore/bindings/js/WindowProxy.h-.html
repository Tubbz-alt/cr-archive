<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;DOMWrapperWorld.h&quot;
 24 #include &lt;JavaScriptCore/Strong.h&gt;
 25 #include &lt;wtf/HashMap.h&gt;
 26 #include &lt;wtf/RefCounted.h&gt;
 27 
 28 namespace JSC {
 29 class Debugger;
 30 }
 31 
 32 namespace WebCore {
 33 
 34 class AbstractDOMWindow;
 35 class AbstractFrame;
 36 class JSDOMGlobalObject;
 37 class JSWindowProxy;
 38 
 39 class WindowProxy : public RefCounted&lt;WindowProxy&gt; {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     using ProxyMap = HashMap&lt;RefPtr&lt;DOMWrapperWorld&gt;, JSC::Strong&lt;JSWindowProxy&gt;&gt;;
 43 
 44     static Ref&lt;WindowProxy&gt; create(AbstractFrame&amp; frame)
 45     {
 46         return adoptRef(*new WindowProxy(frame));
 47     }
 48 
 49     WEBCORE_EXPORT ~WindowProxy();
 50 
 51     AbstractFrame* frame() const { return m_frame; }
 52     void detachFromFrame();
 53 
 54     void destroyJSWindowProxy(DOMWrapperWorld&amp;);
 55 
 56     ProxyMap::ValuesConstIteratorRange jsWindowProxies() const { return m_jsWindowProxies.values(); }
 57     Vector&lt;JSC::Strong&lt;JSWindowProxy&gt;&gt; jsWindowProxiesAsVector() const;
 58 
 59     ProxyMap releaseJSWindowProxies() { return std::exchange(m_jsWindowProxies, ProxyMap()); }
 60     void setJSWindowProxies(ProxyMap&amp;&amp; windowProxies) { m_jsWindowProxies = WTFMove(windowProxies); }
 61 
 62     JSWindowProxy* jsWindowProxy(DOMWrapperWorld&amp; world)
 63     {
 64         if (!m_frame)
 65             return nullptr;
 66 
 67         if (auto* existingProxy = existingJSWindowProxy(world))
 68             return existingProxy;
 69 
 70         return &amp;createJSWindowProxyWithInitializedScript(world);
 71     }
 72 
 73     JSWindowProxy* existingJSWindowProxy(DOMWrapperWorld&amp; world) const
 74     {
 75         auto it = m_jsWindowProxies.find(&amp;world);
 76         return (it != m_jsWindowProxies.end()) ? it-&gt;value.get() : nullptr;
 77     }
 78 
 79     WEBCORE_EXPORT JSDOMGlobalObject* globalObject(DOMWrapperWorld&amp;);
 80 
 81     void clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow*, bool goingIntoPageCache);
 82 
 83     WEBCORE_EXPORT void setDOMWindow(AbstractDOMWindow*);
 84 
 85     // Debugger can be nullptr to detach any existing Debugger.
 86     void attachDebugger(JSC::Debugger*); // Attaches/detaches in all worlds/window proxies.
 87 
 88     WEBCORE_EXPORT AbstractDOMWindow* window() const;
 89 
 90 private:
 91     explicit WindowProxy(AbstractFrame&amp;);
 92 
 93     JSWindowProxy&amp; createJSWindowProxy(DOMWrapperWorld&amp;);
 94     WEBCORE_EXPORT JSWindowProxy&amp; createJSWindowProxyWithInitializedScript(DOMWrapperWorld&amp;);
 95 
 96     AbstractFrame* m_frame;
 97     ProxyMap m_jsWindowProxies;
 98 };
 99 
100 } // namespace WebCore
    </pre>
  </body>
</html>
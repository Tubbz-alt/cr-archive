<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/Repatch.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Repatch.h&quot;
  28 
  29 #if ENABLE(JIT)
  30 
  31 #include &quot;BinarySwitch.h&quot;
  32 #include &quot;CCallHelpers.h&quot;
<a name="2" id="anc2"></a>
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGOperations.h&quot;
  35 #include &quot;DFGSpeculativeJIT.h&quot;
  36 #include &quot;DOMJITGetterSetter.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;ExecutableBaseInlines.h&quot;
  39 #include &quot;FTLThunks.h&quot;
  40 #include &quot;FullCodeOrigin.h&quot;
  41 #include &quot;FunctionCodeBlock.h&quot;
  42 #include &quot;GCAwareJITStubRoutine.h&quot;
  43 #include &quot;GetterSetter.h&quot;
  44 #include &quot;GetterSetterAccessCase.h&quot;
  45 #include &quot;ICStats.h&quot;
  46 #include &quot;InlineAccess.h&quot;
  47 #include &quot;InstanceOfAccessCase.h&quot;
  48 #include &quot;IntrinsicGetterAccessCase.h&quot;
  49 #include &quot;JIT.h&quot;
  50 #include &quot;JITInlines.h&quot;
  51 #include &quot;JSCInlines.h&quot;
  52 #include &quot;JSModuleNamespaceObject.h&quot;
  53 #include &quot;JSWebAssembly.h&quot;
  54 #include &quot;JSWebAssemblyModule.h&quot;
  55 #include &quot;LinkBuffer.h&quot;
  56 #include &quot;ModuleNamespaceAccessCase.h&quot;
  57 #include &quot;PolymorphicAccess.h&quot;
  58 #include &quot;ScopedArguments.h&quot;
  59 #include &quot;ScratchRegisterAllocator.h&quot;
  60 #include &quot;StackAlignment.h&quot;
  61 #include &quot;StructureRareDataInlines.h&quot;
  62 #include &quot;StructureStubClearingWatchpoint.h&quot;
  63 #include &quot;StructureStubInfo.h&quot;
  64 #include &quot;SuperSampler.h&quot;
  65 #include &quot;ThunkGenerators.h&quot;
  66 #include &quot;WebAssemblyFunction.h&quot;
<a name="3" id="anc3"></a><span class="line-removed">  67 #include &quot;WebAssemblyToJSCallee.h&quot;</span>
  68 #include &lt;wtf/CommaPrinter.h&gt;
  69 #include &lt;wtf/ListDump.h&gt;
  70 #include &lt;wtf/StringPrintStream.h&gt;
  71 
  72 namespace JSC {
  73 
  74 static FunctionPtr&lt;CFunctionPtrTag&gt; readPutICCallTarget(CodeBlock* codeBlock, CodeLocationCall&lt;JSInternalPtrTag&gt; call)
  75 {
  76     FunctionPtr&lt;OperationPtrTag&gt; target = MacroAssembler::readCallTarget&lt;OperationPtrTag&gt;(call);
  77 #if ENABLE(FTL_JIT)
  78     if (codeBlock-&gt;jitType() == JITType::FTLJIT) {
  79         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; thunk = MacroAssemblerCodePtr&lt;OperationPtrTag&gt;::createFromExecutableAddress(target.executableAddress()).retagged&lt;JITThunkPtrTag&gt;();
  80         return codeBlock-&gt;vm().ftlThunks-&gt;keyForSlowPathCallThunk(thunk).callTarget().retagged&lt;CFunctionPtrTag&gt;();
  81     }
  82 #else
  83     UNUSED_PARAM(codeBlock);
  84 #endif // ENABLE(FTL_JIT)
  85     return target.retagged&lt;CFunctionPtrTag&gt;();
  86 }
  87 
  88 void ftlThunkAwareRepatchCall(CodeBlock* codeBlock, CodeLocationCall&lt;JSInternalPtrTag&gt; call, FunctionPtr&lt;CFunctionPtrTag&gt; newCalleeFunction)
  89 {
  90 #if ENABLE(FTL_JIT)
  91     if (codeBlock-&gt;jitType() == JITType::FTLJIT) {
  92         VM&amp; vm = codeBlock-&gt;vm();
  93         FTL::Thunks&amp; thunks = *vm.ftlThunks;
  94         FunctionPtr&lt;OperationPtrTag&gt; target = MacroAssembler::readCallTarget&lt;OperationPtrTag&gt;(call);
  95         auto slowPathThunk = MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt;::createFromExecutableAddress(target.retaggedExecutableAddress&lt;JITThunkPtrTag&gt;());
  96         FTL::SlowPathCallKey key = thunks.keyForSlowPathCallThunk(slowPathThunk);
  97         key = key.withCallTarget(newCalleeFunction);
<a name="4" id="anc4"></a><span class="line-modified">  98         MacroAssembler::repatchCall(call, FunctionPtr&lt;OperationPtrTag&gt;(thunks.getSlowPathCallThunk(key).retaggedCode&lt;OperationPtrTag&gt;()));</span>
  99         return;
 100     }
 101 #else // ENABLE(FTL_JIT)
 102     UNUSED_PARAM(codeBlock);
 103 #endif // ENABLE(FTL_JIT)
 104     MacroAssembler::repatchCall(call, newCalleeFunction.retagged&lt;OperationPtrTag&gt;());
 105 }
 106 
 107 enum InlineCacheAction {
 108     GiveUpOnCache,
 109     RetryCacheLater,
 110     AttemptToCache
 111 };
 112 
 113 static InlineCacheAction actionForCell(VM&amp; vm, JSCell* cell)
 114 {
 115     Structure* structure = cell-&gt;structure(vm);
 116 
 117     TypeInfo typeInfo = structure-&gt;typeInfo();
 118     if (typeInfo.prohibitsPropertyCaching())
 119         return GiveUpOnCache;
 120 
 121     if (structure-&gt;isUncacheableDictionary()) {
 122         if (structure-&gt;hasBeenFlattenedBefore())
 123             return GiveUpOnCache;
 124         // Flattening could have changed the offset, so return early for another try.
 125         asObject(cell)-&gt;flattenDictionaryObject(vm);
 126         return RetryCacheLater;
 127     }
 128 
 129     if (!structure-&gt;propertyAccessesAreCacheable())
 130         return GiveUpOnCache;
 131 
 132     return AttemptToCache;
 133 }
 134 
<a name="5" id="anc5"></a><span class="line-modified"> 135 static bool forceICFailure(ExecState*)</span>
 136 {
 137     return Options::forceICFailure();
 138 }
 139 
 140 ALWAYS_INLINE static void fireWatchpointsAndClearStubIfNeeded(VM&amp; vm, StructureStubInfo&amp; stubInfo, CodeBlock* codeBlock, AccessGenerationResult&amp; result)
 141 {
 142     if (result.shouldResetStubAndFireWatchpoints()) {
 143         result.fireWatchpoints(vm);
 144         stubInfo.reset(codeBlock);
 145     }
 146 }
 147 
<a name="6" id="anc6"></a><span class="line-modified"> 148 inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateOptimizingGetByIdFunction(GetByIDKind kind)</span>
 149 {
 150     switch (kind) {
<a name="7" id="anc7"></a><span class="line-modified"> 151     case GetByIDKind::Normal:</span>
 152         return operationGetByIdOptimize;
<a name="8" id="anc8"></a><span class="line-modified"> 153     case GetByIDKind::WithThis:</span>
 154         return operationGetByIdWithThisOptimize;
<a name="9" id="anc9"></a><span class="line-modified"> 155     case GetByIDKind::Try:</span>
 156         return operationTryGetByIdOptimize;
<a name="10" id="anc10"></a><span class="line-modified"> 157     case GetByIDKind::Direct:</span>
 158         return operationGetByIdDirectOptimize;
<a name="11" id="anc11"></a>

 159     }
<a name="12" id="anc12"></a><span class="line-modified"> 160     ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 161     return operationGetById;</span>
 162 }
 163 
<a name="13" id="anc13"></a><span class="line-modified"> 164 inline FunctionPtr&lt;CFunctionPtrTag&gt; appropriateGetByIdFunction(GetByIDKind kind)</span>
 165 {
 166     switch (kind) {
<a name="14" id="anc14"></a><span class="line-modified"> 167     case GetByIDKind::Normal:</span>
 168         return operationGetById;
<a name="15" id="anc15"></a><span class="line-modified"> 169     case GetByIDKind::WithThis:</span>
 170         return operationGetByIdWithThis;
<a name="16" id="anc16"></a><span class="line-modified"> 171     case GetByIDKind::Try:</span>
 172         return operationTryGetById;
<a name="17" id="anc17"></a><span class="line-modified"> 173     case GetByIDKind::Direct:</span>
 174         return operationGetByIdDirect;
<a name="18" id="anc18"></a>

 175     }
<a name="19" id="anc19"></a><span class="line-modified"> 176     ASSERT_NOT_REACHED();</span>
<span class="line-removed"> 177     return operationGetById;</span>
 178 }
 179 
<a name="20" id="anc20"></a><span class="line-modified"> 180 static InlineCacheAction tryCacheGetByID(ExecState* exec, JSValue baseValue, const Identifier&amp; propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
 181 {
<a name="21" id="anc21"></a><span class="line-modified"> 182     VM&amp; vm = exec-&gt;vm();</span>
 183     AccessGenerationResult result;
 184 
 185     {
<a name="22" id="anc22"></a><span class="line-modified"> 186         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, exec-&gt;vm().heap);</span>
 187 
<a name="23" id="anc23"></a><span class="line-modified"> 188         if (forceICFailure(exec))</span>
 189             return GiveUpOnCache;
 190 
 191         // FIXME: Cache property access for immediates.
 192         if (!baseValue.isCell())
 193             return GiveUpOnCache;
 194         JSCell* baseCell = baseValue.asCell();
 195 
<a name="24" id="anc24"></a><span class="line-removed"> 196         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 197 </span>
 198         std::unique_ptr&lt;AccessCase&gt; newCase;
 199 
 200         if (propertyName == vm.propertyNames-&gt;length) {
 201             if (isJSArray(baseCell)) {
<a name="25" id="anc25"></a><span class="line-modified"> 202                 if (stubInfo.cacheType == CacheType::Unset</span>
 203                     &amp;&amp; slot.slotBase() == baseCell
 204                     &amp;&amp; InlineAccess::isCacheableArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell))) {
 205 
 206                     bool generatedCodeInline = InlineAccess::generateArrayLength(stubInfo, jsCast&lt;JSArray*&gt;(baseCell));
 207                     if (generatedCodeInline) {
<a name="26" id="anc26"></a><span class="line-modified"> 208                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
 209                         stubInfo.initArrayLength();
 210                         return RetryCacheLater;
 211                     }
 212                 }
 213 
<a name="27" id="anc27"></a><span class="line-modified"> 214                 newCase = AccessCase::create(vm, codeBlock, AccessCase::ArrayLength);</span>
 215             } else if (isJSString(baseCell)) {
<a name="28" id="anc28"></a><span class="line-modified"> 216                 if (stubInfo.cacheType == CacheType::Unset &amp;&amp; InlineAccess::isCacheableStringLength(stubInfo)) {</span>
 217                     bool generatedCodeInline = InlineAccess::generateStringLength(stubInfo);
 218                     if (generatedCodeInline) {
<a name="29" id="anc29"></a><span class="line-modified"> 219                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
 220                         stubInfo.initStringLength();
 221                         return RetryCacheLater;
 222                     }
 223                 }
 224 
<a name="30" id="anc30"></a><span class="line-modified"> 225                 newCase = AccessCase::create(vm, codeBlock, AccessCase::StringLength);</span>
<span class="line-modified"> 226             }</span>
<span class="line-removed"> 227             else if (DirectArguments* arguments = jsDynamicCast&lt;DirectArguments*&gt;(vm, baseCell)) {</span>
 228                 // If there were overrides, then we can handle this as a normal property load! Guarding
 229                 // this with such a check enables us to add an IC case for that load if needed.
 230                 if (!arguments-&gt;overrodeThings())
<a name="31" id="anc31"></a><span class="line-modified"> 231                     newCase = AccessCase::create(vm, codeBlock, AccessCase::DirectArgumentsLength);</span>
 232             } else if (ScopedArguments* arguments = jsDynamicCast&lt;ScopedArguments*&gt;(vm, baseCell)) {
 233                 // Ditto.
 234                 if (!arguments-&gt;overrodeThings())
<a name="32" id="anc32"></a><span class="line-modified"> 235                     newCase = AccessCase::create(vm, codeBlock, AccessCase::ScopedArgumentsLength);</span>
 236             }
 237         }
 238 
 239         if (!propertyName.isSymbol() &amp;&amp; baseCell-&gt;inherits&lt;JSModuleNamespaceObject&gt;(vm) &amp;&amp; !slot.isUnset()) {
 240             if (auto moduleNamespaceSlot = slot.moduleNamespaceSlot())
<a name="33" id="anc33"></a><span class="line-modified"> 241                 newCase = ModuleNamespaceAccessCase::create(vm, codeBlock, jsCast&lt;JSModuleNamespaceObject*&gt;(baseCell), moduleNamespaceSlot-&gt;environment, ScopeOffset(moduleNamespaceSlot-&gt;scopeOffset));</span>
 242         }
 243 
 244         if (!newCase) {
 245             if (!slot.isCacheable() &amp;&amp; !slot.isUnset())
 246                 return GiveUpOnCache;
 247 
 248             ObjectPropertyConditionSet conditionSet;
 249             Structure* structure = baseCell-&gt;structure(vm);
 250 
 251             bool loadTargetFromProxy = false;
 252             if (baseCell-&gt;type() == PureForwardingProxyType) {
 253                 baseValue = jsCast&lt;JSProxy*&gt;(baseCell)-&gt;target();
 254                 baseCell = baseValue.asCell();
 255                 structure = baseCell-&gt;structure(vm);
 256                 loadTargetFromProxy = true;
 257             }
 258 
 259             InlineCacheAction action = actionForCell(vm, baseCell);
 260             if (action != AttemptToCache)
 261                 return action;
 262 
 263             // Optimize self access.
<a name="34" id="anc34"></a><span class="line-modified"> 264             if (stubInfo.cacheType == CacheType::Unset</span>
 265                 &amp;&amp; slot.isCacheableValue()
 266                 &amp;&amp; slot.slotBase() == baseValue
 267                 &amp;&amp; !slot.watchpointSet()
 268                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()
 269                 &amp;&amp; !loadTargetFromProxy) {
 270 
 271                 bool generatedCodeInline = InlineAccess::generateSelfPropertyAccess(stubInfo, structure, slot.cachedOffset());
 272                 if (generatedCodeInline) {
<a name="35" id="anc35"></a><span class="line-modified"> 273                     LOG_IC((ICEvent::GetByIdSelfPatch, structure-&gt;classInfo(), propertyName, slot.slotBase() == baseValue));</span>
 274                     structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<a name="36" id="anc36"></a><span class="line-modified"> 275                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
<span class="line-modified"> 276                     stubInfo.initGetByIdSelf(codeBlock, structure, slot.cachedOffset());</span>
 277                     return RetryCacheLater;
 278                 }
 279             }
 280 
 281             std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
 282 
 283             PropertyOffset offset = slot.isUnset() ? invalidOffset : slot.cachedOffset();
 284 
<a name="37" id="anc37"></a>








 285             if (slot.isUnset() || slot.slotBase() != baseValue) {
 286                 if (structure-&gt;typeInfo().prohibitsPropertyCaching())
 287                     return GiveUpOnCache;
 288 
 289                 if (structure-&gt;isDictionary()) {
 290                     if (structure-&gt;hasBeenFlattenedBefore())
 291                         return GiveUpOnCache;
 292                     structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
<a name="38" id="anc38"></a>
 293                 }
 294 
 295                 if (slot.isUnset() &amp;&amp; structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
 296                     return GiveUpOnCache;
 297 
<a name="39" id="anc39"></a><span class="line-modified"> 298                 // If a kind is GetByIDKind::Direct, we do not need to investigate prototype chains further.</span>
 299                 // Cacheability just depends on the head structure.
<a name="40" id="anc40"></a><span class="line-modified"> 300                 if (kind != GetByIDKind::Direct) {</span>
<span class="line-modified"> 301                     bool usesPolyProto;</span>
<span class="line-modified"> 302                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot, usesPolyProto);</span>
<span class="line-removed"> 303                     if (!prototypeAccessChain) {</span>
<span class="line-removed"> 304                         // It&#39;s invalid to access this prototype property.</span>
 305                         return GiveUpOnCache;
<a name="41" id="anc41"></a>



 306                     }
 307 
<a name="42" id="anc42"></a><span class="line-modified"> 308                     if (!usesPolyProto) {</span>





 309                         // We use ObjectPropertyConditionSet instead for faster accesses.
 310                         prototypeAccessChain = nullptr;
 311 
 312                         // FIXME: Maybe this `if` should be inside generateConditionsForPropertyBlah.
 313                         // https://bugs.webkit.org/show_bug.cgi?id=185215
 314                         if (slot.isUnset()) {
 315                             conditionSet = generateConditionsForPropertyMiss(
<a name="43" id="anc43"></a><span class="line-modified"> 316                                 vm, codeBlock, exec, structure, propertyName.impl());</span>
 317                         } else if (!slot.isCacheableCustom()) {
 318                             conditionSet = generateConditionsForPrototypePropertyHit(
<a name="44" id="anc44"></a><span class="line-modified"> 319                                 vm, codeBlock, exec, structure, slot.slotBase(),</span>
<span class="line-modified"> 320                                 propertyName.impl());</span>

 321                         } else {
 322                             conditionSet = generateConditionsForPrototypePropertyHitCustom(
<a name="45" id="anc45"></a><span class="line-modified"> 323                                 vm, codeBlock, exec, structure, slot.slotBase(),</span>
<span class="line-modified"> 324                                 propertyName.impl());</span>
 325                         }
 326 
 327                         if (!conditionSet.isValid())
 328                             return GiveUpOnCache;
 329                     }
 330                 }
<a name="46" id="anc46"></a><span class="line-removed"> 331 </span>
<span class="line-removed"> 332                 offset = slot.isUnset() ? invalidOffset : slot.cachedOffset();</span>
 333             }
 334 
 335             JSFunction* getter = nullptr;
 336             if (slot.isCacheableGetter())
 337                 getter = jsDynamicCast&lt;JSFunction*&gt;(vm, slot.getterSetter()-&gt;getter());
 338 
 339             Optional&lt;DOMAttributeAnnotation&gt; domAttribute;
 340             if (slot.isCacheableCustom() &amp;&amp; slot.domAttribute())
 341                 domAttribute = slot.domAttribute();
 342 
<a name="47" id="anc47"></a><span class="line-modified"> 343             if (kind == GetByIDKind::Try) {</span>
 344                 AccessCase::AccessType type;
 345                 if (slot.isCacheableValue())
 346                     type = AccessCase::Load;
 347                 else if (slot.isUnset())
 348                     type = AccessCase::Miss;
 349                 else if (slot.isCacheableGetter())
 350                     type = AccessCase::GetGetter;
 351                 else
 352                     RELEASE_ASSERT_NOT_REACHED();
 353 
<a name="48" id="anc48"></a><span class="line-modified"> 354                 newCase = ProxyableAccessCase::create(vm, codeBlock, type, offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
 355             } else if (!loadTargetFromProxy &amp;&amp; getter &amp;&amp; IntrinsicGetterAccessCase::canEmitIntrinsicGetter(getter, structure))
<a name="49" id="anc49"></a><span class="line-modified"> 356                 newCase = IntrinsicGetterAccessCase::create(vm, codeBlock, slot.cachedOffset(), structure, conditionSet, getter, WTFMove(prototypeAccessChain));</span>
 357             else {
 358                 if (slot.isCacheableValue() || slot.isUnset()) {
 359                     newCase = ProxyableAccessCase::create(vm, codeBlock, slot.isUnset() ? AccessCase::Miss : AccessCase::Load,
<a name="50" id="anc50"></a><span class="line-modified"> 360                         offset, structure, conditionSet, loadTargetFromProxy, slot.watchpointSet(), WTFMove(prototypeAccessChain));</span>
 361                 } else {
 362                     AccessCase::AccessType type;
 363                     if (slot.isCacheableGetter())
 364                         type = AccessCase::Getter;
 365                     else if (slot.attributes() &amp; PropertyAttribute::CustomAccessor)
 366                         type = AccessCase::CustomAccessorGetter;
 367                     else
 368                         type = AccessCase::CustomValueGetter;
 369 
<a name="51" id="anc51"></a><span class="line-modified"> 370                     if (kind == GetByIDKind::WithThis &amp;&amp; type == AccessCase::CustomAccessorGetter &amp;&amp; domAttribute)</span>
 371                         return GiveUpOnCache;
 372 
 373                     newCase = GetterSetterAccessCase::create(
<a name="52" id="anc52"></a><span class="line-modified"> 374                         vm, codeBlock, type, offset, structure, conditionSet, loadTargetFromProxy,</span>
 375                         slot.watchpointSet(), slot.isCacheableCustom() ? slot.customGetter() : nullptr,
 376                         slot.isCacheableCustom() &amp;&amp; slot.slotBase() != baseValue ? slot.slotBase() : nullptr,
 377                         domAttribute, WTFMove(prototypeAccessChain));
 378                 }
 379             }
 380         }
 381 
<a name="53" id="anc53"></a><span class="line-modified"> 382         LOG_IC((ICEvent::GetByIdAddAccessCase, baseValue.classInfoOrNull(vm), propertyName, slot.slotBase() == baseValue));</span>
 383 
 384         result = stubInfo.addAccessCase(locker, codeBlock, propertyName, WTFMove(newCase));
 385 
 386         if (result.generatedSomeCode()) {
<a name="54" id="anc54"></a><span class="line-modified"> 387             LOG_IC((ICEvent::GetByIdReplaceWithJump, baseValue.classInfoOrNull(vm), propertyName, slot.slotBase() == baseValue));</span>
 388 
 389             RELEASE_ASSERT(result.code());
 390             InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
 391         }
 392     }
 393 
<a name="55" id="anc55"></a><span class="line-modified"> 394     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
 395 
 396     return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
 397 }
 398 
<a name="56" id="anc56"></a><span class="line-modified"> 399 void repatchGetByID(ExecState* exec, JSValue baseValue, const Identifier&amp; propertyName, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
 400 {
 401     SuperSamplerScope superSamplerScope(false);
 402 
<a name="57" id="anc57"></a><span class="line-modified"> 403     if (tryCacheGetByID(exec, baseValue, propertyName, slot, stubInfo, kind) == GiveUpOnCache) {</span>
<span class="line-modified"> 404         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-modified"> 405         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateGetByIdFunction(kind));</span>





















































































 406     }
<a name="58" id="anc58"></a>








 407 }
 408 
<a name="59" id="anc59"></a><span class="line-modified"> 409 static V_JITOperation_ESsiJJI appropriateGenericPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
 410 {
 411     if (slot.isStrictMode()) {
 412         if (putKind == Direct)
 413             return operationPutByIdDirectStrict;
 414         return operationPutByIdStrict;
 415     }
 416     if (putKind == Direct)
 417         return operationPutByIdDirectNonStrict;
 418     return operationPutByIdNonStrict;
 419 }
 420 
<a name="60" id="anc60"></a><span class="line-modified"> 421 static V_JITOperation_ESsiJJI appropriateOptimizingPutByIdFunction(const PutPropertySlot &amp;slot, PutKind putKind)</span>
 422 {
 423     if (slot.isStrictMode()) {
 424         if (putKind == Direct)
 425             return operationPutByIdDirectStrictOptimize;
 426         return operationPutByIdStrictOptimize;
 427     }
 428     if (putKind == Direct)
 429         return operationPutByIdDirectNonStrictOptimize;
 430     return operationPutByIdNonStrictOptimize;
 431 }
 432 
<a name="61" id="anc61"></a><span class="line-modified"> 433 static InlineCacheAction tryCachePutByID(ExecState* exec, JSValue baseValue, Structure* structure, const Identifier&amp; ident, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
 434 {
<a name="62" id="anc62"></a><span class="line-modified"> 435     VM&amp; vm = exec-&gt;vm();</span>
 436     AccessGenerationResult result;
 437     {
<a name="63" id="anc63"></a><span class="line-modified"> 438         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, exec-&gt;vm().heap);</span>
 439 
<a name="64" id="anc64"></a><span class="line-modified"> 440         if (forceICFailure(exec))</span>
 441             return GiveUpOnCache;
 442 
<a name="65" id="anc65"></a><span class="line-removed"> 443         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 444 </span>
 445         if (!baseValue.isCell())
 446             return GiveUpOnCache;
 447 
 448         if (!slot.isCacheablePut() &amp;&amp; !slot.isCacheableCustom() &amp;&amp; !slot.isCacheableSetter())
 449             return GiveUpOnCache;
 450 
 451         // FIXME: We should try to do something smarter here...
<a name="66" id="anc66"></a><span class="line-modified"> 452         if (isCopyOnWrite(structure-&gt;indexingMode()))</span>
 453             return GiveUpOnCache;
 454         // We can&#39;t end up storing to a CoW on the prototype since it shouldn&#39;t own properties.
 455         ASSERT(!isCopyOnWrite(slot.base()-&gt;indexingMode()));
 456 
<a name="67" id="anc67"></a><span class="line-modified"> 457         if (!structure-&gt;propertyAccessesAreCacheable())</span>
 458             return GiveUpOnCache;
 459 
 460         std::unique_ptr&lt;AccessCase&gt; newCase;
 461         JSCell* baseCell = baseValue.asCell();
 462 
 463         if (slot.base() == baseValue &amp;&amp; slot.isCacheablePut()) {
 464             if (slot.type() == PutPropertySlot::ExistingProperty) {
 465                 // This assert helps catch bugs if we accidentally forget to disable caching
 466                 // when we transition then store to an existing property. This is common among
 467                 // paths that reify lazy properties. If we reify a lazy property and forget
 468                 // to disable caching, we may come down this path. The Replace IC does not
 469                 // know how to model these types of structure transitions (or any structure
 470                 // transition for that matter).
<a name="68" id="anc68"></a><span class="line-modified"> 471                 RELEASE_ASSERT(baseValue.asCell()-&gt;structure(vm) == structure);</span>
 472 
<a name="69" id="anc69"></a><span class="line-modified"> 473                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
 474 
<a name="70" id="anc70"></a><span class="line-modified"> 475                 if (stubInfo.cacheType == CacheType::Unset</span>
 476                     &amp;&amp; InlineAccess::canGenerateSelfPropertyReplace(stubInfo, slot.cachedOffset())
<a name="71" id="anc71"></a><span class="line-modified"> 477                     &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {</span>
 478 
<a name="72" id="anc72"></a><span class="line-modified"> 479                     bool generatedCodeInline = InlineAccess::generateSelfPropertyReplace(stubInfo, structure, slot.cachedOffset());</span>
 480                     if (generatedCodeInline) {
<a name="73" id="anc73"></a><span class="line-modified"> 481                         LOG_IC((ICEvent::PutByIdSelfPatch, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
<span class="line-modified"> 482                         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingPutByIdFunction(slot, putKind));</span>
<span class="line-modified"> 483                         stubInfo.initPutByIdReplace(codeBlock, structure, slot.cachedOffset());</span>
 484                         return RetryCacheLater;
 485                     }
 486                 }
 487 
<a name="74" id="anc74"></a><span class="line-modified"> 488                 newCase = AccessCase::create(vm, codeBlock, AccessCase::Replace, slot.cachedOffset(), structure);</span>
 489             } else {
 490                 ASSERT(slot.type() == PutPropertySlot::NewProperty);
 491 
<a name="75" id="anc75"></a><span class="line-modified"> 492                 if (!structure-&gt;isObject())</span>
 493                     return GiveUpOnCache;
 494 
<a name="76" id="anc76"></a><span class="line-modified"> 495                 if (structure-&gt;isDictionary()) {</span>
<span class="line-modified"> 496                     if (structure-&gt;hasBeenFlattenedBefore())</span>
<span class="line-modified"> 497                         return GiveUpOnCache;</span>
<span class="line-modified"> 498                     structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseValue));</span>
<span class="line-removed"> 499                 }</span>
 500 
 501                 PropertyOffset offset;
<a name="77" id="anc77"></a><span class="line-modified"> 502                 Structure* newStructure =</span>
<span class="line-removed"> 503                     Structure::addPropertyTransitionToExistingStructureConcurrently(</span>
<span class="line-removed"> 504                         structure, ident.impl(), 0, offset);</span>
 505                 if (!newStructure || !newStructure-&gt;propertyAccessesAreCacheable())
 506                     return GiveUpOnCache;
 507 
<a name="78" id="anc78"></a><span class="line-modified"> 508                 ASSERT(newStructure-&gt;previousID() == structure);</span>








 509                 ASSERT(!newStructure-&gt;isDictionary());
 510                 ASSERT(newStructure-&gt;isObject());
 511 
 512                 std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
 513                 ObjectPropertyConditionSet conditionSet;
 514                 if (putKind == NotDirect) {
<a name="79" id="anc79"></a><span class="line-modified"> 515                     bool usesPolyProto;</span>
<span class="line-modified"> 516                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, nullptr, usesPolyProto);</span>
<span class="line-removed"> 517                     if (!prototypeAccessChain) {</span>
<span class="line-removed"> 518                         // It&#39;s invalid to access this prototype property.</span>
 519                         return GiveUpOnCache;
<a name="80" id="anc80"></a><span class="line-removed"> 520                     }</span>
 521 
<a name="81" id="anc81"></a><span class="line-modified"> 522                     if (!usesPolyProto) {</span>




 523                         prototypeAccessChain = nullptr;
<a name="82" id="anc82"></a><span class="line-modified"> 524                         conditionSet =</span>
<span class="line-modified"> 525                             generateConditionsForPropertySetterMiss(</span>
<span class="line-removed"> 526                                 vm, codeBlock, exec, newStructure, ident.impl());</span>
 527                         if (!conditionSet.isValid())
 528                             return GiveUpOnCache;
 529                     }
<a name="83" id="anc83"></a><span class="line-removed"> 530 </span>
 531                 }
 532 
<a name="84" id="anc84"></a><span class="line-modified"> 533                 newCase = AccessCase::create(vm, codeBlock, offset, structure, newStructure, conditionSet, WTFMove(prototypeAccessChain));</span>
 534             }
 535         } else if (slot.isCacheableCustom() || slot.isCacheableSetter()) {
 536             if (slot.isCacheableCustom()) {
 537                 ObjectPropertyConditionSet conditionSet;
 538                 std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
 539 
<a name="85" id="anc85"></a><span class="line-modified"> 540                 if (slot.base() != baseValue) {</span>
<span class="line-modified"> 541                     bool usesPolyProto;</span>
<span class="line-modified"> 542                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot.base(), usesPolyProto);</span>
<span class="line-modified"> 543                     if (!prototypeAccessChain) {</span>
<span class="line-modified"> 544                         // It&#39;s invalid to access this prototype property.</span>
<span class="line-modified"> 545                         return GiveUpOnCache;</span>
<span class="line-removed"> 546                     }</span>
 547 
<a name="86" id="anc86"></a><span class="line-modified"> 548                     if (!usesPolyProto) {</span>





 549                         prototypeAccessChain = nullptr;
<a name="87" id="anc87"></a><span class="line-modified"> 550                         conditionSet =</span>
<span class="line-modified"> 551                             generateConditionsForPrototypePropertyHitCustom(</span>
<span class="line-removed"> 552                                 vm, codeBlock, exec, structure, slot.base(), ident.impl());</span>
 553                         if (!conditionSet.isValid())
 554                             return GiveUpOnCache;
 555                     }
 556                 }
 557 
 558                 newCase = GetterSetterAccessCase::create(
<a name="88" id="anc88"></a><span class="line-modified"> 559                     vm, codeBlock, slot.isCustomAccessor() ? AccessCase::CustomAccessorSetter : AccessCase::CustomValueSetter, structure, invalidOffset,</span>
<span class="line-modified"> 560                     conditionSet, WTFMove(prototypeAccessChain), slot.customSetter(), slot.base() != baseValue ? slot.base() : nullptr);</span>
 561             } else {
 562                 ObjectPropertyConditionSet conditionSet;
 563                 std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
 564                 PropertyOffset offset = slot.cachedOffset();
 565 
 566                 if (slot.base() != baseValue) {
<a name="89" id="anc89"></a><span class="line-modified"> 567                     bool usesPolyProto;</span>
<span class="line-modified"> 568                     prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), baseCell, slot.base(), usesPolyProto);</span>
<span class="line-removed"> 569                     if (!prototypeAccessChain) {</span>
<span class="line-removed"> 570                         // It&#39;s invalid to access this prototype property.</span>
 571                         return GiveUpOnCache;
<a name="90" id="anc90"></a><span class="line-modified"> 572                     }</span>

 573 
<a name="91" id="anc91"></a><span class="line-modified"> 574                     if (!usesPolyProto) {</span>





 575                         prototypeAccessChain = nullptr;
<a name="92" id="anc92"></a><span class="line-modified"> 576                         conditionSet =</span>
<span class="line-modified"> 577                             generateConditionsForPrototypePropertyHit(</span>
<span class="line-removed"> 578                                 vm, codeBlock, exec, structure, slot.base(), ident.impl());</span>
 579                         if (!conditionSet.isValid())
 580                             return GiveUpOnCache;
 581 
 582                         if (!(conditionSet.slotBaseCondition().attributes() &amp; PropertyAttribute::Accessor))
 583                             return GiveUpOnCache;
 584 
 585                         offset = conditionSet.slotBaseCondition().offset();
 586                     }
<a name="93" id="anc93"></a><span class="line-removed"> 587 </span>
 588                 }
 589 
 590                 newCase = GetterSetterAccessCase::create(
<a name="94" id="anc94"></a><span class="line-modified"> 591                     vm, codeBlock, AccessCase::Setter, structure, offset, conditionSet, WTFMove(prototypeAccessChain));</span>
 592             }
 593         }
 594 
<a name="95" id="anc95"></a><span class="line-modified"> 595         LOG_IC((ICEvent::PutByIdAddAccessCase, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
 596 
 597         result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
 598 
 599         if (result.generatedSomeCode()) {
<a name="96" id="anc96"></a><span class="line-modified"> 600             LOG_IC((ICEvent::PutByIdReplaceWithJump, structure-&gt;classInfo(), ident, slot.base() == baseValue));</span>
 601 
 602             RELEASE_ASSERT(result.code());
 603 
 604             InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
 605         }
 606     }
 607 
<a name="97" id="anc97"></a><span class="line-modified"> 608     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
 609 
 610     return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
 611 }
 612 
<a name="98" id="anc98"></a><span class="line-modified"> 613 void repatchPutByID(ExecState* exec, JSValue baseValue, Structure* structure, const Identifier&amp; propertyName, const PutPropertySlot&amp; slot, StructureStubInfo&amp; stubInfo, PutKind putKind)</span>
 614 {
 615     SuperSamplerScope superSamplerScope(false);
 616 
<a name="99" id="anc99"></a><span class="line-modified"> 617     if (tryCachePutByID(exec, baseValue, structure, propertyName, slot, stubInfo, putKind) == GiveUpOnCache) {</span>
<span class="line-modified"> 618         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 619         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateGenericPutByIdFunction(slot, putKind));</span>
<span class="line-removed"> 620     }</span>
 621 }
 622 
 623 static InlineCacheAction tryCacheInByID(
<a name="100" id="anc100"></a><span class="line-modified"> 624     ExecState* exec, JSObject* base, const Identifier&amp; ident,</span>
 625     bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)
 626 {
<a name="101" id="anc101"></a><span class="line-modified"> 627     VM&amp; vm = exec-&gt;vm();</span>
 628     AccessGenerationResult result;
 629 
 630     {
<a name="102" id="anc102"></a><span class="line-modified"> 631         GCSafeConcurrentJSLocker locker(exec-&gt;codeBlock()-&gt;m_lock, vm.heap);</span>
<span class="line-modified"> 632         if (forceICFailure(exec))</span>
 633             return GiveUpOnCache;
 634 
 635         if (!base-&gt;structure(vm)-&gt;propertyAccessesAreCacheable() || (!wasFound &amp;&amp; !base-&gt;structure(vm)-&gt;propertyAccessesAreCacheableForAbsence()))
 636             return GiveUpOnCache;
 637 
 638         if (wasFound) {
 639             if (!slot.isCacheable())
 640                 return GiveUpOnCache;
 641         }
 642 
<a name="103" id="anc103"></a><span class="line-removed"> 643         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 644         Structure* structure = base-&gt;structure(vm);
 645 
 646         std::unique_ptr&lt;PolyProtoAccessChain&gt; prototypeAccessChain;
 647         ObjectPropertyConditionSet conditionSet;
 648         if (wasFound) {
 649             InlineCacheAction action = actionForCell(vm, base);
 650             if (action != AttemptToCache)
 651                 return action;
 652 
 653             // Optimize self access.
<a name="104" id="anc104"></a><span class="line-modified"> 654             if (stubInfo.cacheType == CacheType::Unset</span>
 655                 &amp;&amp; slot.isCacheableValue()
 656                 &amp;&amp; slot.slotBase() == base
 657                 &amp;&amp; !slot.watchpointSet()
 658                 &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
 659                 bool generatedCodeInline = InlineAccess::generateSelfInAccess(stubInfo, structure);
 660                 if (generatedCodeInline) {
 661                     LOG_IC((ICEvent::InByIdSelfPatch, structure-&gt;classInfo(), ident, slot.slotBase() == base));
 662                     structure-&gt;startWatchingPropertyForReplacements(vm, slot.cachedOffset());
<a name="105" id="anc105"></a><span class="line-modified"> 663                     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInByIdOptimize);</span>
 664                     stubInfo.initInByIdSelf(codeBlock, structure, slot.cachedOffset());
 665                     return RetryCacheLater;
 666                 }
 667             }
 668 
 669             if (slot.slotBase() != base) {
<a name="106" id="anc106"></a><span class="line-modified"> 670                 bool usesPolyProto;</span>
<span class="line-modified"> 671                 prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), base, slot, usesPolyProto);</span>
<span class="line-removed"> 672                 if (!prototypeAccessChain) {</span>
<span class="line-removed"> 673                     // It&#39;s invalid to access this prototype property.</span>
 674                     return GiveUpOnCache;
<a name="107" id="anc107"></a><span class="line-modified"> 675                 }</span>
<span class="line-modified"> 676                 if (!usesPolyProto) {</span>







 677                     prototypeAccessChain = nullptr;
 678                     conditionSet = generateConditionsForPrototypePropertyHit(
<a name="108" id="anc108"></a><span class="line-modified"> 679                         vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());</span>



 680                 }
 681             }
 682         } else {
<a name="109" id="anc109"></a><span class="line-modified"> 683             bool usesPolyProto;</span>
<span class="line-modified"> 684             prototypeAccessChain = PolyProtoAccessChain::create(exec-&gt;lexicalGlobalObject(), base, slot, usesPolyProto);</span>
<span class="line-removed"> 685             if (!prototypeAccessChain) {</span>
<span class="line-removed"> 686                 // It&#39;s invalid to access this prototype property.</span>
 687                 return GiveUpOnCache;
<a name="110" id="anc110"></a><span class="line-removed"> 688             }</span>
 689 
<a name="111" id="anc111"></a><span class="line-modified"> 690             if (!usesPolyProto) {</span>




 691                 prototypeAccessChain = nullptr;
 692                 conditionSet = generateConditionsForPropertyMiss(
<a name="112" id="anc112"></a><span class="line-modified"> 693                     vm, codeBlock, exec, structure, ident.impl());</span>


 694             }
 695         }
<a name="113" id="anc113"></a><span class="line-removed"> 696         if (!conditionSet.isValid())</span>
<span class="line-removed"> 697             return GiveUpOnCache;</span>
 698 
 699         LOG_IC((ICEvent::InAddAccessCase, structure-&gt;classInfo(), ident, slot.slotBase() == base));
 700 
 701         std::unique_ptr&lt;AccessCase&gt; newCase = AccessCase::create(
<a name="114" id="anc114"></a><span class="line-modified"> 702             vm, codeBlock, wasFound ? AccessCase::InHit : AccessCase::InMiss, wasFound ? slot.cachedOffset() : invalidOffset, structure, conditionSet, WTFMove(prototypeAccessChain));</span>
 703 
 704         result = stubInfo.addAccessCase(locker, codeBlock, ident, WTFMove(newCase));
 705 
 706         if (result.generatedSomeCode()) {
 707             LOG_IC((ICEvent::InReplaceWithJump, structure-&gt;classInfo(), ident, slot.slotBase() == base));
 708 
 709             RELEASE_ASSERT(result.code());
 710             InlineAccess::rewireStubAsJump(stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
 711         }
 712     }
 713 
<a name="115" id="anc115"></a><span class="line-modified"> 714     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, exec-&gt;codeBlock(), result);</span>
 715 
 716     return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
 717 }
 718 
<a name="116" id="anc116"></a><span class="line-modified"> 719 void repatchInByID(ExecState* exec, JSObject* baseObject, const Identifier&amp; propertyName, bool wasFound, const PropertySlot&amp; slot, StructureStubInfo&amp; stubInfo)</span>
 720 {
 721     SuperSamplerScope superSamplerScope(false);
 722 
<a name="117" id="anc117"></a><span class="line-modified"> 723     if (tryCacheInByID(exec, baseObject, propertyName, wasFound, slot, stubInfo) == GiveUpOnCache) {</span>
<span class="line-modified"> 724         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 725         ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInById);</span>
<span class="line-removed"> 726     }</span>
 727 }
 728 
 729 static InlineCacheAction tryCacheInstanceOf(
<a name="118" id="anc118"></a><span class="line-modified"> 730     ExecState* exec, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
 731     bool wasFound)
 732 {
<a name="119" id="anc119"></a><span class="line-modified"> 733     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed"> 734     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
 735     AccessGenerationResult result;
 736 
 737     RELEASE_ASSERT(valueValue.isCell()); // shouldConsiderCaching rejects non-cells.
 738 
<a name="120" id="anc120"></a><span class="line-modified"> 739     if (forceICFailure(exec))</span>
 740         return GiveUpOnCache;
 741 
 742     {
 743         GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
 744 
 745         JSCell* value = valueValue.asCell();
 746         Structure* structure = value-&gt;structure(vm);
 747         std::unique_ptr&lt;AccessCase&gt; newCase;
 748         JSObject* prototype = jsDynamicCast&lt;JSObject*&gt;(vm, prototypeValue);
 749         if (prototype) {
 750             if (!jsDynamicCast&lt;JSObject*&gt;(vm, value)) {
 751                 newCase = InstanceOfAccessCase::create(
 752                     vm, codeBlock, AccessCase::InstanceOfMiss, structure, ObjectPropertyConditionSet(),
 753                     prototype);
 754             } else if (structure-&gt;prototypeQueriesAreCacheable()) {
 755                 // FIXME: Teach this to do poly proto.
 756                 // https://bugs.webkit.org/show_bug.cgi?id=185663
<a name="121" id="anc121"></a><span class="line-modified"> 757 </span>
 758                 ObjectPropertyConditionSet conditionSet = generateConditionsForInstanceOf(
<a name="122" id="anc122"></a><span class="line-modified"> 759                     vm, codeBlock, exec, structure, prototype, wasFound);</span>
 760 
 761                 if (conditionSet.isValid()) {
 762                     newCase = InstanceOfAccessCase::create(
 763                         vm, codeBlock,
 764                         wasFound ? AccessCase::InstanceOfHit : AccessCase::InstanceOfMiss,
 765                         structure, conditionSet, prototype);
 766                 }
 767             }
 768         }
 769 
 770         if (!newCase)
<a name="123" id="anc123"></a><span class="line-modified"> 771             newCase = AccessCase::create(vm, codeBlock, AccessCase::InstanceOfGeneric);</span>
 772 
 773         LOG_IC((ICEvent::InstanceOfAddAccessCase, structure-&gt;classInfo(), Identifier()));
 774 
<a name="124" id="anc124"></a><span class="line-modified"> 775         result = stubInfo.addAccessCase(locker, codeBlock, Identifier(), WTFMove(newCase));</span>
 776 
 777         if (result.generatedSomeCode()) {
 778             LOG_IC((ICEvent::InstanceOfReplaceWithJump, structure-&gt;classInfo(), Identifier()));
 779 
 780             RELEASE_ASSERT(result.code());
 781 
 782             MacroAssembler::repatchJump(
 783                 stubInfo.patchableJump(),
 784                 CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(result.code()));
 785         }
 786     }
 787 
 788     fireWatchpointsAndClearStubIfNeeded(vm, stubInfo, codeBlock, result);
 789 
 790     return result.shouldGiveUpNow() ? GiveUpOnCache : RetryCacheLater;
 791 }
 792 
 793 void repatchInstanceOf(
<a name="125" id="anc125"></a><span class="line-modified"> 794     ExecState* exec, JSValue valueValue, JSValue prototypeValue, StructureStubInfo&amp; stubInfo,</span>
 795     bool wasFound)
 796 {
 797     SuperSamplerScope superSamplerScope(false);
<a name="126" id="anc126"></a><span class="line-modified"> 798     if (tryCacheInstanceOf(exec, valueValue, prototypeValue, stubInfo, wasFound) == GiveUpOnCache)</span>
<span class="line-modified"> 799         ftlThunkAwareRepatchCall(exec-&gt;codeBlock(), stubInfo.slowPathCallLocation(), operationInstanceOfGeneric);</span>
 800 }
 801 
 802 static void linkSlowFor(VM&amp;, CallLinkInfo&amp; callLinkInfo, MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; codeRef)
 803 {
 804     MacroAssembler::repatchNearCall(callLinkInfo.callReturnLocation(), CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(codeRef.code()));
 805 }
 806 
 807 static void linkSlowFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo, ThunkGenerator generator)
 808 {
 809     linkSlowFor(vm, callLinkInfo, vm.getCTIStub(generator).retagged&lt;JITStubRoutinePtrTag&gt;());
 810 }
 811 
 812 static void linkSlowFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
 813 {
 814     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
 815     linkSlowFor(vm, callLinkInfo, virtualThunk);
<a name="127" id="anc127"></a><span class="line-modified"> 816     callLinkInfo.setSlowStub(createJITStubRoutine(virtualThunk, vm, nullptr, true));</span>
 817 }
 818 
 819 static JSCell* webAssemblyOwner(JSCell* callee)
 820 {
 821 #if ENABLE(WEBASSEMBLY)
 822     // Each WebAssembly.Instance shares the stubs from their WebAssembly.Module, which are therefore the appropriate owner.
<a name="128" id="anc128"></a><span class="line-modified"> 823     return jsCast&lt;WebAssemblyToJSCallee*&gt;(callee)-&gt;module();</span>
 824 #else
 825     UNUSED_PARAM(callee);
 826     RELEASE_ASSERT_NOT_REACHED();
 827     return nullptr;
 828 #endif // ENABLE(WEBASSEMBLY)
 829 }
 830 
 831 void linkFor(
<a name="129" id="anc129"></a><span class="line-modified"> 832     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
 833     JSObject* callee, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
 834 {
 835     ASSERT(!callLinkInfo.stub());
 836 
<a name="130" id="anc130"></a><span class="line-modified"> 837     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
 838     // Our caller must have a cell for a callee. When calling
 839     // this from Wasm, we ensure the callee is a cell.
 840     ASSERT(callerFrame-&gt;callee().isCell());
 841 
<a name="131" id="anc131"></a><span class="line-removed"> 842     VM&amp; vm = callerFrame-&gt;vm();</span>
 843     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
 844 
 845     // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
<a name="132" id="anc132"></a><span class="line-modified"> 846     JSCell* owner = isWebAssemblyToJSCallee(callerFrame-&gt;callee().asCell()) ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;</span>
 847     ASSERT(owner);
 848 
 849     ASSERT(!callLinkInfo.isLinked());
 850     callLinkInfo.setCallee(vm, owner, callee);
 851     MacroAssembler::repatchPointer(callLinkInfo.hotPathBegin(), callee);
 852     callLinkInfo.setLastSeenCallee(vm, owner, callee);
 853     if (shouldDumpDisassemblyFor(callerCodeBlock))
 854         dataLog(&quot;Linking call in &quot;, FullCodeOrigin(callerCodeBlock, callLinkInfo.codeOrigin()), &quot; to &quot;, pointerDump(calleeCodeBlock), &quot;, entrypoint at &quot;, codePtr, &quot;\n&quot;);
 855 
 856     MacroAssembler::repatchNearCall(callLinkInfo.hotPathOther(), CodeLocationLabel&lt;JSEntryPtrTag&gt;(codePtr));
 857 
 858     if (calleeCodeBlock)
 859         calleeCodeBlock-&gt;linkIncomingCall(callerFrame, &amp;callLinkInfo);
 860 
 861     if (callLinkInfo.specializationKind() == CodeForCall &amp;&amp; callLinkInfo.allowStubs()) {
 862         linkSlowFor(vm, callLinkInfo, linkPolymorphicCallThunkGenerator);
 863         return;
 864     }
 865 
 866     linkSlowFor(vm, callLinkInfo);
 867 }
 868 
 869 void linkDirectFor(
<a name="133" id="anc133"></a><span class="line-modified"> 870     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CodeBlock* calleeCodeBlock,</span>
 871     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr)
 872 {
 873     ASSERT(!callLinkInfo.stub());
 874 
<a name="134" id="anc134"></a><span class="line-modified"> 875     CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
 876 
 877     VM&amp; vm = callerCodeBlock-&gt;vm();
 878 
 879     ASSERT(!callLinkInfo.isLinked());
 880     callLinkInfo.setCodeBlock(vm, callerCodeBlock, jsCast&lt;FunctionCodeBlock*&gt;(calleeCodeBlock));
 881     if (shouldDumpDisassemblyFor(callerCodeBlock))
 882         dataLog(&quot;Linking call in &quot;, FullCodeOrigin(callerCodeBlock, callLinkInfo.codeOrigin()), &quot; to &quot;, pointerDump(calleeCodeBlock), &quot;, entrypoint at &quot;, codePtr, &quot;\n&quot;);
 883 
 884     if (callLinkInfo.callType() == CallLinkInfo::DirectTailCall)
 885         MacroAssembler::repatchJumpToNop(callLinkInfo.patchableJump());
 886     MacroAssembler::repatchNearCall(callLinkInfo.hotPathOther(), CodeLocationLabel&lt;JSEntryPtrTag&gt;(codePtr));
 887 
 888     if (calleeCodeBlock)
<a name="135" id="anc135"></a><span class="line-modified"> 889         calleeCodeBlock-&gt;linkIncomingCall(exec, &amp;callLinkInfo);</span>
 890 }
 891 
<a name="136" id="anc136"></a><span class="line-modified"> 892 void linkSlowFor(</span>
<span class="line-removed"> 893     ExecState* exec, CallLinkInfo&amp; callLinkInfo)</span>
 894 {
<a name="137" id="anc137"></a><span class="line-modified"> 895     CodeBlock* callerCodeBlock = exec-&gt;callerFrame()-&gt;codeBlock();</span>
 896     VM&amp; vm = callerCodeBlock-&gt;vm();
 897 
 898     linkSlowFor(vm, callLinkInfo);
 899 }
 900 
 901 static void revertCall(VM&amp; vm, CallLinkInfo&amp; callLinkInfo, MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; codeRef)
 902 {
 903     if (callLinkInfo.isDirect()) {
 904         callLinkInfo.clearCodeBlock();
 905         if (!callLinkInfo.clearedByJettison()) {
 906             if (callLinkInfo.callType() == CallLinkInfo::DirectTailCall)
 907                 MacroAssembler::repatchJump(callLinkInfo.patchableJump(), callLinkInfo.slowPathStart());
 908             else
 909                 MacroAssembler::repatchNearCall(callLinkInfo.hotPathOther(), callLinkInfo.slowPathStart());
 910         }
 911     } else {
 912         if (!callLinkInfo.clearedByJettison()) {
 913             MacroAssembler::revertJumpReplacementToBranchPtrWithPatch(
 914                 MacroAssembler::startOfBranchPtrWithPatchOnRegister(callLinkInfo.hotPathBegin()),
 915                 callLinkInfo.calleeGPR(), 0);
 916             linkSlowFor(vm, callLinkInfo, codeRef);
 917             MacroAssembler::repatchPointer(callLinkInfo.hotPathBegin(), nullptr);
 918         }
 919         callLinkInfo.clearCallee();
 920     }
 921     callLinkInfo.clearSeen();
 922     callLinkInfo.clearStub();
 923     callLinkInfo.clearSlowStub();
 924     if (callLinkInfo.isOnList())
 925         callLinkInfo.remove();
 926 }
 927 
 928 void unlinkFor(VM&amp; vm, CallLinkInfo&amp; callLinkInfo)
 929 {
<a name="138" id="anc138"></a><span class="line-modified"> 930     if (Options::dumpDisassembly())</span>
<span class="line-removed"> 931         dataLog(&quot;Unlinking call at &quot;, callLinkInfo.hotPathOther(), &quot;\n&quot;);</span>
 932 
 933     revertCall(vm, callLinkInfo, vm.getCTIStub(linkCallThunkGenerator).retagged&lt;JITStubRoutinePtrTag&gt;());
 934 }
 935 
<a name="139" id="anc139"></a><span class="line-modified"> 936 static void linkVirtualFor(ExecState* exec, CallLinkInfo&amp; callLinkInfo)</span>
 937 {
<a name="140" id="anc140"></a><span class="line-modified"> 938     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
<span class="line-removed"> 939     VM&amp; vm = callerFrame-&gt;vm();</span>
 940     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
 941 
<a name="141" id="anc141"></a><span class="line-modified"> 942     if (shouldDumpDisassemblyFor(callerCodeBlock))</span>
<span class="line-modified"> 943         dataLog(&quot;Linking virtual call at &quot;, FullCodeOrigin(callerCodeBlock, callerFrame-&gt;codeOrigin()), &quot;\n&quot;);</span>
 944 
 945     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; virtualThunk = virtualThunkFor(vm, callLinkInfo);
 946     revertCall(vm, callLinkInfo, virtualThunk);
<a name="142" id="anc142"></a><span class="line-modified"> 947     callLinkInfo.setSlowStub(createJITStubRoutine(virtualThunk, vm, nullptr, true));</span>
 948     callLinkInfo.setClearedByVirtual();
 949 }
 950 
 951 namespace {
 952 struct CallToCodePtr {
 953     CCallHelpers::Call call;
 954     MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
 955 };
 956 } // annonymous namespace
 957 
<a name="143" id="anc143"></a><span class="line-modified"> 958 void linkPolymorphicCall(</span>
<span class="line-removed"> 959     ExecState* exec, CallLinkInfo&amp; callLinkInfo, CallVariant newVariant)</span>
 960 {
 961     RELEASE_ASSERT(callLinkInfo.allowStubs());
 962 
<a name="144" id="anc144"></a><span class="line-modified"> 963     CallFrame* callerFrame = exec-&gt;callerFrame();</span>
<span class="line-modified"> 964     VM&amp; vm = callerFrame-&gt;vm();</span>
 965 
 966     // During execution of linkPolymorphicCall, we strongly assume that we never do GC.
 967     // GC jettisons CodeBlocks, changes CallLinkInfo etc. and breaks assumption done before and after this call.
 968     DeferGCForAWhile deferGCForAWhile(vm.heap);
 969 
 970     if (!newVariant) {
<a name="145" id="anc145"></a><span class="line-modified"> 971         linkVirtualFor(exec, callLinkInfo);</span>
 972         return;
 973     }
 974 
 975     // Our caller must be have a cell for a callee. When calling
 976     // this from Wasm, we ensure the callee is a cell.
 977     ASSERT(callerFrame-&gt;callee().isCell());
 978 
 979     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<a name="146" id="anc146"></a><span class="line-modified"> 980     bool isWebAssembly = isWebAssemblyToJSCallee(callerFrame-&gt;callee().asCell());</span>
 981 
 982     // WebAssembly -&gt; JS stubs don&#39;t have a valid CodeBlock.
 983     JSCell* owner = isWebAssembly ? webAssemblyOwner(callerFrame-&gt;callee().asCell()) : callerCodeBlock;
 984     ASSERT(owner);
 985 
 986     CallVariantList list;
 987     if (PolymorphicCallStubRoutine* stub = callLinkInfo.stub())
 988         list = stub-&gt;variants();
 989     else if (JSObject* oldCallee = callLinkInfo.callee())
 990         list = CallVariantList { CallVariant(oldCallee) };
 991 
 992     list = variantListWithVariant(list, newVariant);
 993 
 994     // If there are any closure calls then it makes sense to treat all of them as closure calls.
 995     // This makes switching on callee cheaper. It also produces profiling that&#39;s easier on the DFG;
 996     // the DFG doesn&#39;t really want to deal with a combination of closure and non-closure callees.
 997     bool isClosureCall = false;
 998     for (CallVariant variant : list)  {
 999         if (variant.isClosureCall()) {
1000             list = despecifiedVariantList(list);
1001             isClosureCall = true;
1002             break;
1003         }
1004     }
1005 
1006     if (isClosureCall)
1007         callLinkInfo.setHasSeenClosure();
1008 
1009     Vector&lt;PolymorphicCallCase&gt; callCases;
1010     Vector&lt;int64_t&gt; caseValues;
1011 
1012     // Figure out what our cases are.
1013     for (CallVariant variant : list) {
1014         CodeBlock* codeBlock = nullptr;
1015         if (variant.executable() &amp;&amp; !variant.executable()-&gt;isHostFunction()) {
1016             ExecutableBase* executable = variant.executable();
1017             codeBlock = jsCast&lt;FunctionExecutable*&gt;(executable)-&gt;codeBlockForCall();
1018             // If we cannot handle a callee, either because we don&#39;t have a CodeBlock or because arity mismatch,
1019             // assume that it&#39;s better for this whole thing to be a virtual call.
<a name="147" id="anc147"></a><span class="line-modified">1020             if (!codeBlock || exec-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()) || callLinkInfo.isVarargs()) {</span>
<span class="line-modified">1021                 linkVirtualFor(exec, callLinkInfo);</span>
1022                 return;
1023             }
1024         }
1025 
1026         int64_t newCaseValue = 0;
1027         if (isClosureCall) {
1028             newCaseValue = bitwise_cast&lt;intptr_t&gt;(variant.executable());
1029             // FIXME: We could add a fast path for InternalFunction with closure call.
1030             // https://bugs.webkit.org/show_bug.cgi?id=179311
1031             if (!newCaseValue)
1032                 continue;
1033         } else {
1034             if (auto* function = variant.function())
1035                 newCaseValue = bitwise_cast&lt;intptr_t&gt;(function);
1036             else
1037                 newCaseValue = bitwise_cast&lt;intptr_t&gt;(variant.internalFunction());
1038         }
1039 
<a name="148" id="anc148"></a><span class="line-modified">1040         if (!ASSERT_DISABLED) {</span>
1041             if (caseValues.contains(newCaseValue)) {
1042                 dataLog(&quot;ERROR: Attempt to add duplicate case value.\n&quot;);
1043                 dataLog(&quot;Existing case values: &quot;);
1044                 CommaPrinter comma;
1045                 for (auto&amp; value : caseValues)
1046                     dataLog(comma, value);
1047                 dataLog(&quot;\n&quot;);
1048                 dataLog(&quot;Attempting to add: &quot;, newCaseValue, &quot;\n&quot;);
1049                 dataLog(&quot;Variant list: &quot;, listDump(callCases), &quot;\n&quot;);
1050                 RELEASE_ASSERT_NOT_REACHED();
1051             }
1052         }
1053 
1054         callCases.append(PolymorphicCallCase(variant, codeBlock));
1055         caseValues.append(newCaseValue);
1056     }
1057     ASSERT(callCases.size() == caseValues.size());
1058 
1059     // If we are over the limit, just use a normal virtual call.
1060     unsigned maxPolymorphicCallVariantListSize;
1061     if (isWebAssembly)
1062         maxPolymorphicCallVariantListSize = Options::maxPolymorphicCallVariantListSizeForWebAssemblyToJS();
1063     else if (callerCodeBlock-&gt;jitType() == JITCode::topTierJIT())
1064         maxPolymorphicCallVariantListSize = Options::maxPolymorphicCallVariantListSizeForTopTier();
1065     else
1066         maxPolymorphicCallVariantListSize = Options::maxPolymorphicCallVariantListSize();
1067 
1068     // We use list.size() instead of callCases.size() because we respect CallVariant size for now.
1069     if (list.size() &gt; maxPolymorphicCallVariantListSize) {
<a name="149" id="anc149"></a><span class="line-modified">1070         linkVirtualFor(exec, callLinkInfo);</span>
1071         return;
1072     }
1073 
1074     Vector&lt;CallToCodePtr&gt; calls(callCases.size());
1075     UniqueArray&lt;uint32_t&gt; fastCounts;
1076 
1077     if (!isWebAssembly &amp;&amp; callerCodeBlock-&gt;jitType() != JITCode::topTierJIT()) {
1078         fastCounts = makeUniqueArray&lt;uint32_t&gt;(callCases.size());
1079         memset(fastCounts.get(), 0, callCases.size() * sizeof(uint32_t));
1080     }
1081 
1082     GPRReg calleeGPR = callLinkInfo.calleeGPR();
1083 
1084     CCallHelpers stubJit(callerCodeBlock);
1085 
1086     std::unique_ptr&lt;CallFrameShuffler&gt; frameShuffler;
1087     if (callLinkInfo.frameShuffleData()) {
1088         ASSERT(callLinkInfo.isTailCall());
1089         frameShuffler = makeUnique&lt;CallFrameShuffler&gt;(stubJit, *callLinkInfo.frameShuffleData());
1090 #if USE(JSVALUE32_64)
1091         // We would have already checked that the callee is a cell, and we can
1092         // use the additional register this buys us.
1093         frameShuffler-&gt;assumeCalleeIsCell();
1094 #endif
1095         frameShuffler-&gt;lockGPR(calleeGPR);
1096     }
1097 
1098     GPRReg comparisonValueGPR;
1099     if (isClosureCall) {
1100         if (frameShuffler)
1101             comparisonValueGPR = frameShuffler-&gt;acquireGPR();
1102         else
1103             comparisonValueGPR = AssemblyHelpers::selectScratchGPR(calleeGPR);
1104     } else
1105         comparisonValueGPR = calleeGPR;
1106 
1107     GPRReg fastCountsBaseGPR;
1108     if (frameShuffler)
1109         fastCountsBaseGPR = frameShuffler-&gt;acquireGPR();
1110     else {
1111         fastCountsBaseGPR =
1112             AssemblyHelpers::selectScratchGPR(calleeGPR, comparisonValueGPR, GPRInfo::regT3);
1113     }
1114     stubJit.move(CCallHelpers::TrustedImmPtr(fastCounts.get()), fastCountsBaseGPR);
1115 
1116     if (!frameShuffler &amp;&amp; callLinkInfo.isTailCall()) {
1117         // We strongly assume that calleeGPR is not a callee save register in the slow path.
1118         ASSERT(!callerCodeBlock-&gt;calleeSaveRegisters()-&gt;find(calleeGPR));
1119         stubJit.emitRestoreCalleeSaves();
1120     }
1121 
1122     CCallHelpers::JumpList slowPath;
1123     if (isClosureCall) {
1124         // Verify that we have a function and stash the executable in scratchGPR.
1125 #if USE(JSVALUE64)
1126         if (callLinkInfo.isTailCall())
1127             slowPath.append(stubJit.branchIfNotCell(calleeGPR, DoNotHaveTagRegisters));
1128         else
1129             slowPath.append(stubJit.branchIfNotCell(calleeGPR));
1130 #else
1131         // We would have already checked that the callee is a cell.
1132 #endif
1133         // FIXME: We could add a fast path for InternalFunction with closure call.
1134         slowPath.append(stubJit.branchIfNotFunction(calleeGPR));
1135 
<a name="150" id="anc150"></a><span class="line-modified">1136         stubJit.loadPtr(</span>
<span class="line-modified">1137             CCallHelpers::Address(calleeGPR, JSFunction::offsetOfExecutable()),</span>
<span class="line-modified">1138             comparisonValueGPR);</span>

1139     }
1140 
1141     BinarySwitch binarySwitch(comparisonValueGPR, caseValues, BinarySwitch::IntPtr);
1142     CCallHelpers::JumpList done;
1143     while (binarySwitch.advance(stubJit)) {
1144         size_t caseIndex = binarySwitch.caseIndex();
1145 
1146         CallVariant variant = callCases[caseIndex].variant();
1147 
1148         MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
1149         if (variant.executable()) {
1150             ASSERT(variant.executable()-&gt;hasJITCodeForCall());
1151 
1152             codePtr = jsToWasmICCodePtr(vm, callLinkInfo.specializationKind(), variant.function());
1153             if (!codePtr)
1154                 codePtr = variant.executable()-&gt;generatedJITCodeForCall()-&gt;addressForCall(ArityCheckNotRequired);
1155         } else {
1156             ASSERT(variant.internalFunction());
1157             codePtr = vm.getCTIInternalFunctionTrampolineFor(CodeForCall);
1158         }
1159 
1160         if (fastCounts) {
1161             stubJit.add32(
1162                 CCallHelpers::TrustedImm32(1),
1163                 CCallHelpers::Address(fastCountsBaseGPR, caseIndex * sizeof(uint32_t)));
1164         }
1165         if (frameShuffler) {
1166             CallFrameShuffler(stubJit, frameShuffler-&gt;snapshot()).prepareForTailCall();
1167             calls[caseIndex].call = stubJit.nearTailCall();
1168         } else if (callLinkInfo.isTailCall()) {
1169             stubJit.prepareForTailCallSlow();
1170             calls[caseIndex].call = stubJit.nearTailCall();
1171         } else
1172             calls[caseIndex].call = stubJit.nearCall();
1173         calls[caseIndex].codePtr = codePtr;
1174         done.append(stubJit.jump());
1175     }
1176 
1177     slowPath.link(&amp;stubJit);
1178     binarySwitch.fallThrough().link(&amp;stubJit);
1179 
1180     if (frameShuffler) {
1181         frameShuffler-&gt;releaseGPR(calleeGPR);
1182         frameShuffler-&gt;releaseGPR(comparisonValueGPR);
1183         frameShuffler-&gt;releaseGPR(fastCountsBaseGPR);
1184 #if USE(JSVALUE32_64)
1185         frameShuffler-&gt;setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT1, GPRInfo::regT0));
1186 #else
1187         frameShuffler-&gt;setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
1188 #endif
1189         frameShuffler-&gt;prepareForSlowPath();
1190     } else {
1191         stubJit.move(calleeGPR, GPRInfo::regT0);
1192 #if USE(JSVALUE32_64)
1193         stubJit.move(CCallHelpers::TrustedImm32(JSValue::CellTag), GPRInfo::regT1);
1194 #endif
1195     }
<a name="151" id="anc151"></a>
1196     stubJit.move(CCallHelpers::TrustedImmPtr(&amp;callLinkInfo), GPRInfo::regT2);
1197     stubJit.move(CCallHelpers::TrustedImmPtr(callLinkInfo.callReturnLocation().untaggedExecutableAddress()), GPRInfo::regT4);
1198 
1199     stubJit.restoreReturnAddressBeforeReturn(GPRInfo::regT4);
1200     AssemblyHelpers::Jump slow = stubJit.jump();
1201 
1202     LinkBuffer patchBuffer(stubJit, owner, JITCompilationCanFail);
1203     if (patchBuffer.didFailToAllocate()) {
<a name="152" id="anc152"></a><span class="line-modified">1204         linkVirtualFor(exec, callLinkInfo);</span>
1205         return;
1206     }
1207 
1208     RELEASE_ASSERT(callCases.size() == calls.size());
1209     for (CallToCodePtr callToCodePtr : calls) {
1210 #if CPU(ARM_THUMB2)
1211         // Tail call special-casing ensures proper linking on ARM Thumb2, where a tail call jumps to an address
1212         // with a non-decorated bottom bit but a normal call calls an address with a decorated bottom bit.
1213         bool isTailCall = callToCodePtr.call.isFlagSet(CCallHelpers::Call::Tail);
1214         void* target = isTailCall ? callToCodePtr.codePtr.dataLocation() : callToCodePtr.codePtr.executableAddress();
1215         patchBuffer.link(callToCodePtr.call, FunctionPtr&lt;JSEntryPtrTag&gt;(MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt;::createFromExecutableAddress(target)));
1216 #else
1217         patchBuffer.link(callToCodePtr.call, FunctionPtr&lt;JSEntryPtrTag&gt;(callToCodePtr.codePtr));
1218 #endif
1219     }
1220     if (isWebAssembly || JITCode::isOptimizingJIT(callerCodeBlock-&gt;jitType()))
1221         patchBuffer.link(done, callLinkInfo.callReturnLocation().labelAtOffset(0));
1222     else
1223         patchBuffer.link(done, callLinkInfo.hotPathOther().labelAtOffset(0));
1224     patchBuffer.link(slow, CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm.getCTIStub(linkPolymorphicCallThunkGenerator).code()));
1225 
1226     auto stubRoutine = adoptRef(*new PolymorphicCallStubRoutine(
1227         FINALIZE_CODE_FOR(
1228             callerCodeBlock, patchBuffer, JITStubRoutinePtrTag,
1229             &quot;Polymorphic call stub for %s, return point %p, targets %s&quot;,
1230                 isWebAssembly ? &quot;WebAssembly&quot; : toCString(*callerCodeBlock).data(), callLinkInfo.callReturnLocation().labelAtOffset(0).executableAddress(),
1231                 toCString(listDump(callCases)).data()),
<a name="153" id="anc153"></a><span class="line-modified">1232         vm, owner, exec-&gt;callerFrame(), callLinkInfo, callCases,</span>
1233         WTFMove(fastCounts)));
1234 
1235     MacroAssembler::replaceWithJump(
1236         MacroAssembler::startOfBranchPtrWithPatchOnRegister(callLinkInfo.hotPathBegin()),
1237         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(stubRoutine-&gt;code().code()));
1238     // The original slow path is unreachable on 64-bits, but still
1239     // reachable on 32-bits since a non-cell callee will always
1240     // trigger the slow path
1241     linkSlowFor(vm, callLinkInfo);
1242 
1243     // If there had been a previous stub routine, that one will die as soon as the GC runs and sees
1244     // that it&#39;s no longer on stack.
1245     callLinkInfo.setStub(WTFMove(stubRoutine));
1246 
1247     // The call link info no longer has a call cache apart from the jump to the polymorphic call
1248     // stub.
1249     if (callLinkInfo.isOnList())
1250         callLinkInfo.remove();
1251 }
1252 
<a name="154" id="anc154"></a><span class="line-modified">1253 void resetGetByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo, GetByIDKind kind)</span>
1254 {
<a name="155" id="anc155"></a><span class="line-modified">1255     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), appropriateOptimizingGetByIdFunction(kind));</span>
<span class="line-modified">1256     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
1257 }
1258 
1259 void resetPutByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
1260 {
<a name="156" id="anc156"></a><span class="line-modified">1261     V_JITOperation_ESsiJJI unoptimizedFunction = reinterpret_cast&lt;V_JITOperation_ESsiJJI&gt;(readPutICCallTarget(codeBlock, stubInfo.slowPathCallLocation()).executableAddress());</span>
<span class="line-modified">1262     V_JITOperation_ESsiJJI optimizedFunction;</span>
1263     if (unoptimizedFunction == operationPutByIdStrict || unoptimizedFunction == operationPutByIdStrictOptimize)
1264         optimizedFunction = operationPutByIdStrictOptimize;
1265     else if (unoptimizedFunction == operationPutByIdNonStrict || unoptimizedFunction == operationPutByIdNonStrictOptimize)
1266         optimizedFunction = operationPutByIdNonStrictOptimize;
1267     else if (unoptimizedFunction == operationPutByIdDirectStrict || unoptimizedFunction == operationPutByIdDirectStrictOptimize)
1268         optimizedFunction = operationPutByIdDirectStrictOptimize;
1269     else {
1270         ASSERT(unoptimizedFunction == operationPutByIdDirectNonStrict || unoptimizedFunction == operationPutByIdDirectNonStrictOptimize);
1271         optimizedFunction = operationPutByIdDirectNonStrictOptimize;
1272     }
1273 
<a name="157" id="anc157"></a><span class="line-modified">1274     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), optimizedFunction);</span>
<span class="line-modified">1275     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
1276 }
1277 
1278 static void resetPatchableJump(StructureStubInfo&amp; stubInfo)
1279 {
<a name="158" id="anc158"></a><span class="line-modified">1280     MacroAssembler::repatchJump(stubInfo.patchableJump(), stubInfo.slowPathStartLocation());</span>
1281 }
1282 
1283 void resetInByID(CodeBlock* codeBlock, StructureStubInfo&amp; stubInfo)
1284 {
<a name="159" id="anc159"></a><span class="line-modified">1285     ftlThunkAwareRepatchCall(codeBlock, stubInfo.slowPathCallLocation(), operationInByIdOptimize);</span>
<span class="line-modified">1286     InlineAccess::rewireStubAsJump(stubInfo, stubInfo.slowPathStartLocation());</span>
1287 }
1288 
1289 void resetInstanceOf(StructureStubInfo&amp; stubInfo)
1290 {
1291     resetPatchableJump(stubInfo);
1292 }
1293 
1294 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; jsToWasmICCodePtr(VM&amp; vm, CodeSpecializationKind kind, JSObject* callee)
1295 {
1296 #if ENABLE(WEBASSEMBLY)
1297     if (!callee)
1298         return nullptr;
1299     if (kind != CodeForCall)
1300         return nullptr;
1301     if (auto* wasmFunction = jsDynamicCast&lt;WebAssemblyFunction*&gt;(vm, callee))
1302         return wasmFunction-&gt;jsCallEntrypoint();
1303 #else
1304     UNUSED_PARAM(vm);
1305     UNUSED_PARAM(kind);
1306     UNUSED_PARAM(callee);
1307 #endif
1308     return nullptr;
1309 }
1310 
1311 } // namespace JSC
1312 
1313 #endif
<a name="160" id="anc160"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="160" type="hidden" />
</body>
</html>
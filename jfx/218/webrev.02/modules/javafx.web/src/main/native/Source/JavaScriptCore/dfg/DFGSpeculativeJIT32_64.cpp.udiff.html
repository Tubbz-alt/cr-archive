<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -211,17 +211,17 @@</span>
  
      std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
      if (baseTagGPROrNone == InvalidGPRReg) {
          slowPath = slowPathCall(
              slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="udiff-line-modified-removed">-             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),</span>
<span class="udiff-line-modified-added">+             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),</span>
              CCallHelpers::CellValue(basePayloadGPR),
              identifierUID(identifierNumber));
      } else {
          slowPath = slowPathCall(
              slowCases, this, appropriateOptimizingGetByIdFunction(type),
<span class="udiff-line-modified-removed">-             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));</span>
<span class="udiff-line-modified-added">+             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), identifierUID(identifierNumber));</span>
      }
  
      m_jit.addGetById(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -233,11 +233,11 @@</span>
      RegisterSet usedRegisters = this-&gt;usedRegisters();
  
      CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
      JITGetByIdWithThisGenerator gen(
          m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<span class="udiff-line-modified-removed">-         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), AccessType::GetWithThis);</span>
<span class="udiff-line-modified-added">+         JSValueRegs(resultTagGPR, resultPayloadGPR), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR));</span>
  
      gen.generateFastPath(m_jit);
  
      JITCompiler::JumpList slowCases;
      if (!slowPathTarget.empty())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -246,21 +246,21 @@</span>
  
      std::unique_ptr&lt;SlowPathGenerator&gt; slowPath;
      if (baseTagGPROrNone == InvalidGPRReg &amp;&amp; thisTagGPR == InvalidGPRReg) {
          slowPath = slowPathCall(
              slowCases, this, operationGetByIdWithThisOptimize,
<span class="udiff-line-modified-removed">-             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(),</span>
<span class="udiff-line-modified-added">+             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(),</span>
              CCallHelpers::CellValue(basePayloadGPR),
              CCallHelpers::CellValue(thisPayloadGPR),
              identifierUID(identifierNumber));
      } else {
          ASSERT(baseTagGPROrNone != InvalidGPRReg);
          ASSERT(thisTagGPR != InvalidGPRReg);
  
          slowPath = slowPathCall(
              slowCases, this, operationGetByIdWithThisOptimize,
<span class="udiff-line-modified-removed">-             JSValueRegs(resultTagGPR, resultPayloadGPR), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));</span>
<span class="udiff-line-modified-added">+             JSValueRegs(resultTagGPR, resultPayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), JSValueRegs(baseTagGPROrNone, basePayloadGPR), JSValueRegs(thisTagGPR, thisPayloadGPR), identifierUID(identifierNumber));</span>
      }
  
      m_jit.addGetByIdWithThis(gen, slowPath.get());
      addSlowPathGenerator(WTFMove(slowPath));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -414,20 +414,20 @@</span>
          // see if we get lucky: if the arguments are cells and they reference the same
          // cell, then they must be strictly equal.
          branchPtr(JITCompiler::Equal, arg1PayloadGPR, arg2PayloadGPR, invert ? notTaken : taken);
  
          silentSpillAllRegisters(resultPayloadGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);</span>
          m_jit.exceptionCheck();
          silentFillAllRegisters();
  
          branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
      } else {
          // FIXME: Add fast paths for twoCells, number etc.
  
          silentSpillAllRegisters(resultPayloadGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
          m_jit.exceptionCheck();
          silentFillAllRegisters();
  
          branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultPayloadGPR, taken);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -460,22 +460,22 @@</span>
          JITCompiler::Jump done = m_jit.jump();
  
          notEqualCase.link(&amp;m_jit);
  
          silentSpillAllRegisters(resultPayloadGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEqCell, resultPayloadGPR, arg1PayloadGPR, arg2PayloadGPR);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEqCell, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1PayloadGPR, arg2PayloadGPR);</span>
          m_jit.exceptionCheck();
          silentFillAllRegisters();
  
          m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
  
          done.link(&amp;m_jit);
      } else {
          // FIXME: Add fast paths.
  
          silentSpillAllRegisters(resultPayloadGPR);
<span class="udiff-line-modified-removed">-         callOperation(operationCompareStrictEq, resultPayloadGPR, arg1Regs, arg2Regs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationCompareStrictEq, resultPayloadGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          m_jit.andPtr(JITCompiler::TrustedImm32(1), resultPayloadGPR);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -582,10 +582,11 @@</span>
      Edge calleeEdge = m_jit.graph().child(node, 0);
      GPRReg calleeTagGPR = InvalidGPRReg;
      GPRReg calleePayloadGPR = InvalidGPRReg;
      CallFrameShuffleData shuffleData;
  
<span class="udiff-line-added">+     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
      ExecutableBase* executable = nullptr;
      FunctionExecutable* functionExecutable = nullptr;
      if (isDirect) {
          executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
          functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -623,11 +624,11 @@</span>
                  inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
              // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
              emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
              JITCompiler::Jump done = m_jit.jump();
              slowCase.link(&amp;m_jit);
<span class="udiff-line-modified-removed">-             callOperation(operationThrowStackOverflowForVarargs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
              m_jit.exceptionCheck();
              m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
              done.link(&amp;m_jit);
          } else {
              GPRReg argumentsPayloadGPR;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -655,21 +656,21 @@</span>
  
              DFG_ASSERT(m_jit.graph(), node, isFlushed());
  
              // Right now, arguments is in argumentsTagGPR/argumentsPayloadGPR and the register file is
              // flushed.
<span class="udiff-line-modified-removed">-             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
<span class="udiff-line-modified-added">+             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
              m_jit.exceptionCheck();
  
              // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
              // Reconstruct the arguments operand while preserving the callee frame.
              loadArgumentsGPR(GPRInfo::returnValueGPR);
              m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
              emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
              m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 6 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
  
<span class="udiff-line-modified-removed">-             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, JSValueRegs(argumentsTagGPR, argumentsPayloadGPR), data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
              m_jit.exceptionCheck();
              m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
          }
  
          DFG_ASSERT(m_jit.graph(), node, isFlushed());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,11 +733,11 @@</span>
              }
  
              for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
                  shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
          } else {
<span class="udiff-line-modified-removed">-             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCount));</span>
<span class="udiff-line-modified-added">+             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), m_jit.calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
  
              for (unsigned i = 0; i &lt; numPassedArgs; i++) {
                  Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
                  JSValueOperand arg(this, argEdge);
                  GPRReg argTagGPR = arg.tagGPR();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -802,33 +803,33 @@</span>
          m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
  
          // Now we need to make room for:
          // - The caller frame and PC of a call to operationCallEval.
          // - Potentially two arguments on the stack.
<span class="udiff-line-modified-removed">-         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(ExecState*) * 2;</span>
<span class="udiff-line-modified-added">+         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
          requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
          m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<span class="udiff-line-modified-removed">-         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(GPRInfo::regT0);</span>
<span class="udiff-line-modified-added">+         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);</span>
          prepareForExternalCall();
          m_jit.appendCall(operationCallEval);
          m_jit.exceptionCheck();
          JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR2);
  
          // This is the part where we meant to make a normal call. Oops.
          m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
          m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(PayloadOffset), GPRInfo::regT0);
          m_jit.load32(JITCompiler::calleeFrameSlot(CallFrameSlot::callee).withOffset(TagOffset), GPRInfo::regT1);
<span class="udiff-line-modified-removed">-         m_jit.emitDumbVirtualCall(vm(), info);</span>
<span class="udiff-line-modified-added">+         m_jit.emitDumbVirtualCall(vm(), globalObject, info);</span>
  
          done.link(&amp;m_jit);
          setResultAndResetStack();
          return;
      }
  
      if (isDirect) {
          info-&gt;setExecutableDuringCompilation(executable);
<span class="udiff-line-modified-removed">-         info-&gt;setMaxNumArguments(numAllocatedArgs);</span>
<span class="udiff-line-modified-added">+         info-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
  
          if (isTail) {
              RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
  
              JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -862,13 +863,10 @@</span>
  
          JITCompiler::Call call = m_jit.nearCall();
          JITCompiler::Jump done = m_jit.jump();
  
          JITCompiler::Label slowPath = m_jit.label();
<span class="udiff-line-removed">-         if (isX86())</span>
<span class="udiff-line-removed">-             m_jit.pop(JITCompiler::selectScratchGPR(calleePayloadGPR));</span>
<span class="udiff-line-removed">- </span>
          callOperation(operationLinkDirectCall, info, calleePayloadGPR);
          m_jit.exceptionCheck();
          m_jit.jump().linkTo(mainPath, &amp;m_jit);
  
          done.link(&amp;m_jit);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -922,10 +920,11 @@</span>
          if (isTail)
              m_jit.emitRestoreCalleeSaves();
      }
  
      m_jit.move(TrustedImmPtr(info), GPRInfo::regT2);
<span class="udiff-line-added">+     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3);</span>
      JITCompiler::Call slowCall = m_jit.nearCall();
  
      done.link(&amp;m_jit);
  
      if (isTail)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1784,16 +1783,16 @@</span>
      if (arrayMode.isOutOfBounds()) {
          if (node-&gt;op() == PutByValDirect) {
              addSlowPathGenerator(slowPathCall(
                  slowCase, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
          } else {
              addSlowPathGenerator(slowPathCall(
                  slowCase, this,
                  m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="udiff-line-modified-removed">-                 NoResult, baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
<span class="udiff-line-modified-added">+                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTag, valuePayloadReg)));</span>
          }
      }
  
      noResult(node, UseChildrenCalledExplicitly);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1821,12 +1820,17 @@</span>
      case Identity: {
          compileIdentity(node);
          break;
      }
  
<span class="udiff-line-added">+     case Inc:</span>
<span class="udiff-line-added">+     case Dec:</span>
<span class="udiff-line-added">+         compileIncOrDec(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
      case GetLocal: {
<span class="udiff-line-modified-removed">-         AbstractValue&amp; value = m_state.operand(node-&gt;local());</span>
<span class="udiff-line-modified-added">+         AbstractValue&amp; value = m_state.operand(node-&gt;operand());</span>
  
          // If the CFA is tracking this variable and it found that the variable
          // cannot have been assigned, then don&#39;t attempt to proceed.
          if (value.isClear()) {
              m_compileOkay = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1906,11 +1910,11 @@</span>
          noResult(node);
          break;
      }
  
      case ZombieHint: {
<span class="udiff-line-modified-removed">-         recordSetLocal(m_currentNode-&gt;unlinkedLocal(), VirtualRegister(), DataFormatDead);</span>
<span class="udiff-line-modified-added">+         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);</span>
          noResult(node);
          break;
      }
  
      case ExitOK: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2003,11 +2007,15 @@</span>
  
      case ValueBitLShift:
          compileValueLShiftOp(node);
          break;
  
<span class="udiff-line-modified-removed">-     case BitRShift:</span>
<span class="udiff-line-modified-added">+     case ValueBitRShift:</span>
<span class="udiff-line-added">+         compileValueBitRShift(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case ArithBitRShift:</span>
      case ArithBitLShift:
      case BitURShift:
          compileShiftOp(node);
          break;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2208,10 +2216,15 @@</span>
      case StringFromCharCode: {
          compileFromCharCode(node);
          break;
      }
  
<span class="udiff-line-added">+     case CheckNeutered: {</span>
<span class="udiff-line-added">+         compileCheckNeutered(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case CheckArray: {
          checkArray(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2249,32 +2262,79 @@</span>
              m_jit.move(MacroAssembler::TrustedImm32(0), resultPayloadGPR);
              jsValueResult(resultTagGPR, resultPayloadGPR, node, UseChildrenCalledExplicitly);
              break;
          }
          case Array::Generic: {
<span class="udiff-line-modified-removed">-             if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="udiff-line-modified-removed">-                 if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="udiff-line-modified-removed">-                     compileGetByValForObjectWithString(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-added">+             if (m_graph.m_slowGetByVal.contains(node)) {</span>
<span class="udiff-line-modified-added">+                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="udiff-line-modified-added">+                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="udiff-line-modified-added">+                         compileGetByValForObjectWithString(node);</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="udiff-line-added">+                         compileGetByValForObjectWithSymbol(node);</span>
<span class="udiff-line-added">+                         break;</span>
<span class="udiff-line-added">+                     }</span>
                  }
  
<span class="udiff-line-modified-removed">-                 if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="udiff-line-modified-removed">-                     compileGetByValForObjectWithSymbol(node);</span>
<span class="udiff-line-modified-removed">-                     break;</span>
<span class="udiff-line-modified-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.</span>
<span class="udiff-line-modified-added">+                 JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-added">+                 GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-modified-added">+                 JSValueRegs propertyRegs = property.jsValueRegs();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 flushRegisters();</span>
<span class="udiff-line-added">+                 JSValueRegsFlushedCallResult result(this);</span>
<span class="udiff-line-added">+                 JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-added">+                 callOperation(operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs);</span>
<span class="udiff-line-added">+                 m_jit.exceptionCheck();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 jsValueResult(resultRegs, node);</span>
<span class="udiff-line-added">+                 break;</span>
              }
  
<span class="udiff-line-modified-removed">-             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0)); // Save a register, speculate cell. We&#39;ll probably be right.</span>
<span class="udiff-line-modified-removed">-             JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-removed">-             GPRReg baseGPR = base.gpr();</span>
<span class="udiff-line-modified-added">+             speculate(node, m_graph.varArgChild(node, 0));</span>
<span class="udiff-line-modified-added">+             speculate(node, m_graph.varArgChild(node, 1));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="udiff-line-added">+             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="udiff-line-added">+             GPRTemporary resultTag(this, Reuse, property, TagWord);</span>
<span class="udiff-line-added">+             GPRTemporary resultPayload(this, Reuse, property, PayloadWord);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JSValueRegs baseRegs = base.jsValueRegs();</span>
              JSValueRegs propertyRegs = property.jsValueRegs();
<span class="udiff-line-added">+             JSValueRegs resultRegs(resultTag.gpr(), resultPayload.gpr());</span>
  
<span class="udiff-line-modified-removed">-             flushRegisters();</span>
<span class="udiff-line-modified-removed">-             JSValueRegsFlushedCallResult result(this);</span>
<span class="udiff-line-modified-removed">-             JSValueRegs resultRegs = result.regs();</span>
<span class="udiff-line-modified-removed">-             callOperation(operationGetByValCell, resultRegs, baseGPR, propertyRegs);</span>
<span class="udiff-line-modified-removed">-             m_jit.exceptionCheck();</span>
<span class="udiff-line-modified-added">+             CodeOrigin codeOrigin = node-&gt;origin.semantic;</span>
<span class="udiff-line-modified-added">+             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());</span>
<span class="udiff-line-modified-added">+             RegisterSet usedRegisters = this-&gt;usedRegisters();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             JITCompiler::JumpList slowCases;</span>
<span class="udiff-line-added">+             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))</span>
<span class="udiff-line-added">+                 slowCases.append(m_jit.branchIfNotCell(baseRegs.tagGPR()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             JITGetByValGenerator gen(</span>
<span class="udiff-line-added">+                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,</span>
<span class="udiff-line-added">+                 baseRegs, propertyRegs, resultRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsString = true;</span>
<span class="udiff-line-added">+             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="udiff-line-added">+             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="udiff-line-added">+                 gen.stubInfo()-&gt;propertyIsSymbol = true;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             gen.generateFastPath(m_jit);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             slowCases.append(gen.slowPathJump());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(</span>
<span class="udiff-line-added">+                 slowCases, this, operationGetByValOptimize,</span>
<span class="udiff-line-added">+                 resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseRegs, propertyRegs);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             m_jit.addGetByVal(gen, slowPath.get());</span>
<span class="udiff-line-added">+             addSlowPathGenerator(WTFMove(slowPath));</span>
  
              jsValueResult(resultRegs, node);
              break;
          }
          case Array::Int32:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2358,11 +2418,11 @@</span>
              slowCases.append(m_jit.branchIfEmpty(resultTagReg));
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
  
              jsValueResult(resultTagReg, resultPayloadReg, node);
              break;
          }
          case Array::Double: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2413,11 +2473,11 @@</span>
              boxDouble(tempReg, resultTagReg, resultPayloadReg);
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     JSValueRegs(resultTagReg, resultPayloadReg), baseReg, propertyReg));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
  
              jsValueResult(resultTagReg, resultPayloadReg, node);
              break;
          }
          case Array::ArrayStorage:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2471,11 +2531,11 @@</span>
              slowCases.append(outOfBounds);
              slowCases.append(hole);
              addSlowPathGenerator(
                  slowPathCall(
                      slowCases, this, operationGetByValObjectInt,
<span class="udiff-line-modified-removed">-                     JSValueRegs(resultTagReg, resultPayloadReg),</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(resultTagReg, resultPayloadReg), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)),</span>
                      baseReg, propertyReg));
  
              jsValueResult(resultTagReg, resultPayloadReg, node);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2567,13 +2627,13 @@</span>
              JSValueRegs propertyRegs = property.jsValueRegs();
              JSValueRegs valueRegs = value.jsValueRegs();
  
              flushRegisters();
              if (node-&gt;op() == PutByValDirect)
<span class="udiff-line-modified-removed">-                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
<span class="udiff-line-modified-added">+                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);</span>
              else
<span class="udiff-line-modified-removed">-                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, baseGPR, propertyRegs, valueRegs);</span>
<span class="udiff-line-modified-added">+                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs);</span>
              m_jit.exceptionCheck();
  
              noResult(node);
              alreadyHandled = true;
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2681,16 +2741,16 @@</span>
              if (!slowCases.empty()) {
                  if (node-&gt;op() == PutByValDirect) {
                      addSlowPathGenerator(slowPathCall(
                          slowCases, this,
                          m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValDirectBeyondArrayBoundsNonStrict,
<span class="udiff-line-modified-removed">-                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
<span class="udiff-line-modified-added">+                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
                  } else {
                      addSlowPathGenerator(slowPathCall(
                          slowCases, this,
                          m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsNonStrict,
<span class="udiff-line-modified-removed">-                         NoResult, baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
<span class="udiff-line-modified-added">+                         NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, JSValueRegs(valueTagReg, valuePayloadReg)));</span>
                  }
              }
  
              noResult(node, UseChildrenCalledExplicitly);
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2705,51 +2765,10 @@</span>
          } }
          break;
      }
  
      case PutByValWithThis: {
<span class="udiff-line-removed">- #if CPU(X86)</span>
<span class="udiff-line-removed">-         // We don&#39;t have enough registers on X86 to do this</span>
<span class="udiff-line-removed">-         // without setting up the call frame incrementally.</span>
<span class="udiff-line-removed">-         unsigned index = 0;</span>
<span class="udiff-line-removed">-         m_jit.poke(GPRInfo::callFrameRegister, index++);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));</span>
<span class="udiff-line-removed">-             GPRReg baseTag = base.tagGPR();</span>
<span class="udiff-line-removed">-             GPRReg basePayload = base.payloadGPR();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));</span>
<span class="udiff-line-removed">-             GPRReg thisValueTag = thisValue.tagGPR();</span>
<span class="udiff-line-removed">-             GPRReg thisValuePayload = thisValue.payloadGPR();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));</span>
<span class="udiff-line-removed">-             GPRReg propertyTag = property.tagGPR();</span>
<span class="udiff-line-removed">-             GPRReg propertyPayload = property.payloadGPR();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             m_jit.poke(basePayload, index++);</span>
<span class="udiff-line-removed">-             m_jit.poke(baseTag, index++);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             m_jit.poke(thisValuePayload, index++);</span>
<span class="udiff-line-removed">-             m_jit.poke(thisValueTag, index++);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             m_jit.poke(propertyPayload, index++);</span>
<span class="udiff-line-removed">-             m_jit.poke(propertyTag, index++);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             flushRegisters();</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));</span>
<span class="udiff-line-removed">-         GPRReg valueTag = value.tagGPR();</span>
<span class="udiff-line-removed">-         GPRReg valuePayload = value.payloadGPR();</span>
<span class="udiff-line-removed">-         m_jit.poke(valuePayload, index++);</span>
<span class="udiff-line-removed">-         m_jit.poke(valueTag, index++);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         flushRegisters();</span>
<span class="udiff-line-removed">-         appendCall(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis);</span>
<span class="udiff-line-removed">-         m_jit.exceptionCheck();</span>
<span class="udiff-line-removed">- #else</span>
          static_assert(GPRInfo::numberOfRegisters &gt;= 8, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
  
          JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
          JSValueRegs baseRegs = base.jsValueRegs();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2762,13 +2781,12 @@</span>
          JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
          JSValueRegs valueRegs = value.jsValueRegs();
  
          flushRegisters();
          callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,
<span class="udiff-line-modified-removed">-             NoResult, baseRegs, thisRegs, propertyRegs, valueRegs);</span>
<span class="udiff-line-modified-added">+             TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, propertyRegs, valueRegs);</span>
          m_jit.exceptionCheck();
<span class="udiff-line-removed">- #endif // CPU(X86)</span>
  
          noResult(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2863,11 +2881,11 @@</span>
                      MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
                      MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
              addSlowPathGenerator(
                  slowPathCall(
                      slowCase, this, operationArrayPopAndRecoverLength,
<span class="udiff-line-modified-removed">-                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
  
              jsValueResult(valueTagGPR, valuePayloadGPR, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2901,11 +2919,11 @@</span>
                      MacroAssembler::TrustedImm32(jsUndefined().tag()), valueTagGPR,
                      MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
              addSlowPathGenerator(
                  slowPathCall(
                      slowCase, this, operationArrayPopAndRecoverLength,
<span class="udiff-line-modified-removed">-                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
  
              jsValueResult(valueTagGPR, valuePayloadGPR, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2940,11 +2958,11 @@</span>
                      MacroAssembler::TrustedImm32(jsUndefined().payload()), valuePayloadGPR));
  
              addSlowPathGenerator(
                  slowPathCall(
                      slowCase, this, operationArrayPop,
<span class="udiff-line-modified-removed">-                     JSValueRegs(valueTagGPR, valuePayloadGPR), baseGPR));</span>
<span class="udiff-line-modified-added">+                     JSValueRegs(valueTagGPR, valuePayloadGPR), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
  
              jsValueResult(valueTagGPR, valuePayloadGPR, node);
              break;
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3075,10 +3093,15 @@</span>
      case ToPrimitive: {
          compileToPrimitive(node);
          break;
      }
  
<span class="udiff-line-added">+     case ToPropertyKey: {</span>
<span class="udiff-line-added">+         compileToPropertyKey(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case ToNumber: {
          JSValueOperand argument(this, node-&gt;child1());
          GPRTemporary resultTag(this, Reuse, argument, TagWord);
          GPRTemporary resultPayload(this, Reuse, argument, PayloadWord);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3092,11 +3115,11 @@</span>
          // We have several attempts to remove ToNumber. But ToNumber still exists.
          // It means that converting non-numbers to numbers by this ToNumber is not rare.
          // Instead of the slow path generator, we emit callOperation here.
          if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
              flushRegisters();
<span class="udiff-line-modified-removed">-             callOperation(operationToNumber, resultRegs, argumentRegs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
              m_jit.exceptionCheck();
          } else {
              MacroAssembler::Jump notNumber;
              {
                  GPRTemporary scratch(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3106,21 +3129,26 @@</span>
              m_jit.move(argumentPayloadGPR, resultRegs.payloadGPR());
              MacroAssembler::Jump done = m_jit.jump();
  
              notNumber.link(&amp;m_jit);
              silentSpillAllRegisters(resultRegs);
<span class="udiff-line-modified-removed">-             callOperation(operationToNumber, resultRegs, argumentRegs);</span>
<span class="udiff-line-modified-added">+             callOperation(operationToNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
              silentFillAllRegisters();
              m_jit.exceptionCheck();
  
              done.link(&amp;m_jit);
          }
  
          jsValueResult(resultRegs.tagGPR(), resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
          break;
      }
  
<span class="udiff-line-added">+     case ToNumeric: {</span>
<span class="udiff-line-added">+         compileToNumeric(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case ToString:
      case CallStringConstructor:
      case StringValueOf: {
          compileToStringOrCallStringConstructorOrStringValueOf(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3195,15 +3223,50 @@</span>
      case CreateThis: {
          compileCreateThis(node);
          break;
      }
  
<span class="udiff-line-added">+     case CreatePromise: {</span>
<span class="udiff-line-added">+         compileCreatePromise(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CreateGenerator: {</span>
<span class="udiff-line-added">+         compileCreateGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case CreateAsyncGenerator: {</span>
<span class="udiff-line-added">+         compileCreateAsyncGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case NewObject: {
          compileNewObject(node);
          break;
      }
  
<span class="udiff-line-added">+     case NewPromise: {</span>
<span class="udiff-line-added">+         compileNewPromise(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewGenerator: {</span>
<span class="udiff-line-added">+         compileNewGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewAsyncGenerator: {</span>
<span class="udiff-line-added">+         compileNewAsyncGenerator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case NewArrayIterator: {</span>
<span class="udiff-line-added">+         compileNewArrayIterator(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case GetCallee: {
          compileGetCallee(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3245,32 +3308,42 @@</span>
      case PutClosureVar: {
          compilePutClosureVar(node);
          break;
      }
  
<span class="udiff-line-added">+     case GetInternalField: {</span>
<span class="udiff-line-added">+         compileGetInternalField(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     case PutInternalField: {</span>
<span class="udiff-line-added">+         compilePutInternalField(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case TryGetById: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::TryGet);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::TryGetById);</span>
          break;
      }
  
      case GetByIdDirect: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::GetDirect);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::GetByIdDirect);</span>
          break;
      }
  
      case GetByIdDirectFlush: {
<span class="udiff-line-modified-removed">-         compileGetByIdFlush(node, AccessType::GetDirect);</span>
<span class="udiff-line-modified-added">+         compileGetByIdFlush(node, AccessType::GetByIdDirect);</span>
          break;
      }
  
      case GetById: {
<span class="udiff-line-modified-removed">-         compileGetById(node, AccessType::Get);</span>
<span class="udiff-line-modified-added">+         compileGetById(node, AccessType::GetById);</span>
          break;
      }
  
      case GetByIdFlush: {
<span class="udiff-line-modified-removed">-         compileGetByIdFlush(node, AccessType::Get);</span>
<span class="udiff-line-modified-added">+         compileGetByIdFlush(node, AccessType::GetById);</span>
          break;
      }
  
      case GetByIdWithThis: {
          if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3334,12 +3407,12 @@</span>
      case CheckNotEmpty: {
          compileCheckNotEmpty(node);
          break;
      }
  
<span class="udiff-line-modified-removed">-     case CheckStringIdent:</span>
<span class="udiff-line-modified-removed">-         compileCheckStringIdent(node);</span>
<span class="udiff-line-modified-added">+     case CheckIdent:</span>
<span class="udiff-line-modified-added">+         compileCheckIdent(node);</span>
          break;
  
      case GetExecutable: {
          compileGetExecutable(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3619,11 +3692,11 @@</span>
          JSValueOperand input(this, node-&gt;child1());
          JSValueRegs inputRegs = input.jsValueRegs();
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationNumberIsInteger, resultGPR, inputRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationNumberIsInteger, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);</span>
          booleanResult(resultGPR, node);
          break;
      }
  
      case IsObject: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3662,11 +3735,11 @@</span>
          JSValueRegs inputRegs = input.jsValueRegs();
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
<span class="udiff-line-modified-removed">-         callOperation(operationMapHash, resultGPR, inputRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), inputRegs);</span>
          m_jit.exceptionCheck();
          int32Result(resultGPR, node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3693,13 +3766,13 @@</span>
  
          flushRegisters();
          GPRFlushedCallResult result(this);
          GPRReg resultGPR = result.gpr();
          if (node-&gt;child1().useKind() == MapObjectUse)
<span class="udiff-line-modified-removed">-             callOperation(operationJSMapFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);</span>
          else
<span class="udiff-line-modified-removed">-             callOperation(operationJSSetFindBucket, resultGPR, mapGPR, keyRegs, hashGPR);</span>
<span class="udiff-line-modified-added">+             callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, hashGPR);</span>
          m_jit.exceptionCheck();
          cellResult(resultGPR, node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3764,10 +3837,15 @@</span>
      case DirectTailCall:
      case DirectTailCallInlinedCaller:
          emitCall(node);
          break;
  
<span class="udiff-line-added">+     case VarargsLength: {</span>
<span class="udiff-line-added">+         compileVarargsLength(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case LoadVarargs: {
          compileLoadVarargs(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3814,10 +3892,15 @@</span>
      case CreateClonedArguments: {
          compileCreateClonedArguments(node);
          break;
      }
  
<span class="udiff-line-added">+     case CreateArgumentsButterfly: {</span>
<span class="udiff-line-added">+         compileCreateArgumentsButterfly(node);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      case CreateRest: {
          compileCreateRest(node);
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3844,26 +3927,10 @@</span>
      case InByVal:
          compileInByVal(node);
          break;
  
      case HasOwnProperty: {
<span class="udiff-line-removed">- #if CPU(X86)</span>
<span class="udiff-line-removed">-         ASSERT(node-&gt;child2().useKind() == UntypedUse);</span>
<span class="udiff-line-removed">-         SpeculateCellOperand object(this, node-&gt;child1());</span>
<span class="udiff-line-removed">-         JSValueOperand key(this, node-&gt;child2());</span>
<span class="udiff-line-removed">-         GPRTemporary result(this, Reuse, object);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSValueRegs keyRegs = key.jsValueRegs();</span>
<span class="udiff-line-removed">-         GPRReg objectGPR = object.gpr();</span>
<span class="udiff-line-removed">-         GPRReg resultGPR = result.gpr();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         speculateObject(node-&gt;child1());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         flushRegisters();</span>
<span class="udiff-line-removed">-         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);</span>
<span class="udiff-line-removed">-         booleanResult(resultGPR, node);</span>
<span class="udiff-line-removed">- #else</span>
          SpeculateCellOperand object(this, node-&gt;child1());
          GPRTemporary uniquedStringImpl(this);
          GPRTemporary temp(this);
          GPRTemporary hash(this);
          GPRTemporary structureID(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3952,17 +4019,16 @@</span>
          silentSpillAllRegisters(resultGPR);
          if (node-&gt;child2().useKind() != UntypedUse) {
              m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), tempGPR);
              keyRegs = JSValueRegs(tempGPR, keyRegs.payloadGPR());
          }
<span class="udiff-line-modified-removed">-         callOperation(operationHasOwnProperty, resultGPR, objectGPR, keyRegs);</span>
<span class="udiff-line-modified-added">+         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyRegs);</span>
          silentFillAllRegisters();
          m_jit.exceptionCheck();
  
          done.link(&amp;m_jit);
          booleanResult(resultGPR, node);
<span class="udiff-line-removed">- #endif // CPU(X86)</span>
          break;
      }
  
      case StoreBarrier:
      case FencedStoreBarrier: {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4114,12 +4180,16 @@</span>
  
      case CheckStructureOrEmpty:
          DFG_CRASH(m_jit.graph(), node, &quot;CheckStructureOrEmpty only used in 64-bit DFG&quot;);
          break;
  
<span class="udiff-line-added">+     case CheckArrayOrEmpty:</span>
<span class="udiff-line-added">+         DFG_CRASH(m_jit.graph(), node, &quot;CheckArrayOrEmpty only used in 64-bit DFG&quot;);</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+ </span>
      case FilterCallLinkStatus:
<span class="udiff-line-modified-removed">-     case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+     case FilterGetByStatus:</span>
      case FilterPutByIdStatus:
      case FilterInByIdStatus:
          m_interpreter.filterICStatus(node);
          noResult(node);
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4144,14 +4214,16 @@</span>
      case PhantomNewFunction:
      case PhantomNewGeneratorFunction:
      case PhantomNewAsyncFunction:
      case PhantomNewAsyncGeneratorFunction:
      case PhantomCreateActivation:
<span class="udiff-line-added">+     case PhantomNewArrayIterator:</span>
      case PhantomNewRegexp:
      case PutHint:
      case CheckStructureImmediate:
      case MaterializeCreateActivation:
<span class="udiff-line-added">+     case MaterializeNewInternalFieldObject:</span>
      case PutStack:
      case KillStack:
      case GetStack:
      case GetMyArgumentByVal:
      case GetMyArgumentByValOutOfBounds:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4176,10 +4248,13 @@</span>
      case CPUIntrinsic:
      case AssertNotEmpty:
      case DataViewGetInt:
      case DataViewGetFloat:
      case DataViewSet:
<span class="udiff-line-added">+     case DateGetInt32OrNaN:</span>
<span class="udiff-line-added">+     case DateGetTime:</span>
<span class="udiff-line-added">+     case StringCodePointAt:</span>
          DFG_CRASH(m_jit.graph(), node, &quot;unexpected node in DFG backend&quot;);
          break;
      }
  
      if (!m_compileOkay)
</pre>
<center><a href="DFGSpeculativeJIT.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../bytecode/Watchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,26 ***</span>
  #include &quot;BytecodeGenerator.h&quot;
  
  #include &quot;ArithProfile.h&quot;
  #include &quot;BuiltinExecutables.h&quot;
  #include &quot;BuiltinNames.h&quot;
  #include &quot;BytecodeGeneratorification.h&quot;
  #include &quot;BytecodeLivenessAnalysis.h&quot;
<span class="line-removed">- #include &quot;BytecodeStructs.h&quot;</span>
  #include &quot;BytecodeUseDef.h&quot;
  #include &quot;CatchScope.h&quot;
  #include &quot;DefinePropertyAttributes.h&quot;
  #include &quot;Interpreter.h&quot;
<span class="line-modified">! #include &quot;JSAsyncGeneratorFunction.h&quot;</span>
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
  #include &quot;LowLevelInterpreter.h&quot;
  #include &quot;Options.h&quot;
  #include &quot;PreciseJumpTargetsInlines.h&quot;
  #include &quot;StackAlignment.h&quot;
  #include &quot;StrongInlines.h&quot;
<span class="line-new-header">--- 32,26 ---</span>
  #include &quot;BytecodeGenerator.h&quot;
  
  #include &quot;ArithProfile.h&quot;
  #include &quot;BuiltinExecutables.h&quot;
  #include &quot;BuiltinNames.h&quot;
<span class="line-added">+ #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  #include &quot;BytecodeGeneratorification.h&quot;
  #include &quot;BytecodeLivenessAnalysis.h&quot;
  #include &quot;BytecodeUseDef.h&quot;
  #include &quot;CatchScope.h&quot;
  #include &quot;DefinePropertyAttributes.h&quot;
  #include &quot;Interpreter.h&quot;
<span class="line-modified">! #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSBigInt.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSTemplateObjectDescriptor.h&quot;
<span class="line-added">+ #include &quot;LinkTimeConstant.h&quot;</span>
  #include &quot;LowLevelInterpreter.h&quot;
  #include &quot;Options.h&quot;
  #include &quot;PreciseJumpTargetsInlines.h&quot;
  #include &quot;StackAlignment.h&quot;
  #include &quot;StrongInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 83,19 ***</span>
  template&lt;typename CallOp&gt;
  struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
      using type = OpCallVarargs;
  };
  
<span class="line-modified">! </span>
<span class="line-modified">! template&lt;typename T&gt;</span>
<span class="line-removed">- static inline void shrinkToFit(T&amp; segmentedVector)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     while (segmentedVector.size() &amp;&amp; !segmentedVector.last().refCount())</span>
<span class="line-removed">-         segmentedVector.removeLast();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Label::setLocation(BytecodeGenerator&amp; generator, unsigned location)</span>
  {
      m_location = location;
  
      for (auto offset : m_unresolvedJumps) {
          auto instruction = generator.m_writer.ref(offset);
<span class="line-new-header">--- 83,12 ---</span>
  template&lt;typename CallOp&gt;
  struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
      using type = OpCallVarargs;
  };
  
<span class="line-modified">! template&lt;&gt;</span>
<span class="line-modified">! void GenericLabel&lt;JSGeneratorTraits&gt;::setLocation(BytecodeGenerator&amp; generator, unsigned location)</span>
  {
      m_location = location;
  
      for (auto offset : m_unresolvedJumps) {
          auto instruction = generator.m_writer.ref(offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,45 ***</span>
          }
  #undef CASE
      }
  }
  
<span class="line-removed">- int BoundLabel::target()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     switch (m_type) {</span>
<span class="line-removed">-     case Offset:</span>
<span class="line-removed">-         return m_target;</span>
<span class="line-removed">-     case GeneratorBackward:</span>
<span class="line-removed">-         return m_target - m_generator-&gt;m_writer.position();</span>
<span class="line-removed">-     case GeneratorForward:</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int BoundLabel::saveTarget()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_type == GeneratorForward) {</span>
<span class="line-removed">-         m_savedTarget = m_generator-&gt;m_writer.position();</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_savedTarget = target();</span>
<span class="line-removed">-     return m_savedTarget;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int BoundLabel::commitTarget()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_type == GeneratorForward) {</span>
<span class="line-removed">-         m_label-&gt;m_unresolvedJumps.append(m_savedTarget);</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return m_savedTarget;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Variable::dump(PrintStream&amp; out) const
  {
      out.print(
          &quot;{ident = &quot;, m_ident,
          &quot;, offset = &quot;, m_offset,
<span class="line-new-header">--- 130,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,11 ***</span>
              } else
                  RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
<span class="line-modified">!     bool callingClassConstructor = constructorKind() != ConstructorKind::None &amp;&amp; !isConstructor();</span>
      if (!callingClassConstructor)
          m_scopeNode-&gt;emitBytecode(*this);
      else {
          // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
          // just an artifact of how this generator is structured. That code never runs, but it confuses
<span class="line-new-header">--- 204,20 ---</span>
              } else
                  RELEASE_ASSERT_NOT_REACHED();
          }
      }
  
<span class="line-modified">!     bool callingClassConstructor = false;</span>
<span class="line-added">+     switch (constructorKind()) {</span>
<span class="line-added">+     case ConstructorKind::None:</span>
<span class="line-added">+     case ConstructorKind::Naked:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case ConstructorKind::Base:</span>
<span class="line-added">+     case ConstructorKind::Extends:</span>
<span class="line-added">+         callingClassConstructor = !isConstructor();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
      if (!callingClassConstructor)
          m_scopeNode-&gt;emitBytecode(*this);
      else {
          // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
          // just an artifact of how this generator is structured. That code never runs, but it confuses
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,41 ***</span>
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
          performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
  
      RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
<span class="line-modified">!     m_codeBlock-&gt;setInstructions(m_writer.finalize());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_codeBlock-&gt;shrinkToFit();</span>
<span class="line-removed">- </span>
      if (m_expressionTooDeep)
          return ParserError(ParserError::OutOfMemory);
      return ParserError(ParserError::ErrorNone);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(programNode)
<span class="line-removed">-     , m_codeBlock(vm, codeBlock)</span>
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(GlobalCode)
      , m_vm(vm)
      , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
<span class="line-removed">-     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed">-         constantRegister = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     allocateCalleeSaveSpace();</span>
<span class="line-removed">- </span>
      m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
  
      emitEnter();
  
      allocateAndEmitScope();
  
      const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
  
      for (auto* function : functionStack)
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
  
<span class="line-new-header">--- 286,35 ---</span>
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
          performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
  
      RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
<span class="line-modified">!     m_codeBlock-&gt;finalize(m_writer.finalize());</span>
      if (m_expressionTooDeep)
          return ParserError(ParserError::OutOfMemory);
      return ParserError(ParserError::ErrorNone);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added">+     , m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(programNode)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(GlobalCode)
      , m_vm(vm)
      , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-added">+     emitCheckTraps();</span>
<span class="line-added">+ </span>
      const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
  
      for (auto* function : functionStack)
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,31 ***</span>
          emitPutThisToArrowFunctionContextScope();
      }
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(functionNode)
<span class="line-removed">-     , m_codeBlock(vm, codeBlock)</span>
      , m_codeType(FunctionCode)
      , m_vm(vm)
      , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      // FIXME: We should be able to have tail call elimination with the profiler
      // enabled. This is currently not possible because the profiler expects
      // op_will_call / op_did_call pairs before and after a call, which are not
      // compatible with tail calls (we have no way of emitting op_did_call).
      // https://bugs.webkit.org/show_bug.cgi?id=148819
      , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
      , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
<span class="line-removed">-     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed">-         constantRegister = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     allocateCalleeSaveSpace();</span>
<span class="line-removed">- </span>
      SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
      functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      int symbolTableConstantIndex = 0;
  
      FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
<span class="line-new-header">--- 334,28 ---</span>
          emitPutThisToArrowFunctionContextScope();
      }
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added">+     , m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(functionNode)
      , m_codeType(FunctionCode)
      , m_vm(vm)
      , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      // FIXME: We should be able to have tail call elimination with the profiler
      // enabled. This is currently not possible because the profiler expects
      // op_will_call / op_did_call pairs before and after a call, which are not
      // compatible with tail calls (we have no way of emitting op_did_call).
      // https://bugs.webkit.org/show_bug.cgi?id=148819
<span class="line-added">+     //</span>
<span class="line-added">+     // Note that we intentionally enable tail call for naked constructors since it does not have special code for &quot;return&quot;.</span>
      , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
      , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
      functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      int symbolTableConstantIndex = 0;
  
      FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 413,11 ***</span>
  
      bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
      bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
  
      bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<span class="line-modified">!     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction()));</span>
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
          // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
          needsArguments = false;
      }
<span class="line-new-header">--- 371,11 ---</span>
  
      bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
      bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
  
      bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<span class="line-modified">!     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction())) &amp;&amp; parseMode != SourceParseMode::InstanceFieldInitializerMode;</span>
  
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
          // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
          needsArguments = false;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 469,10 ***</span>
<span class="line-new-header">--- 427,12 ---</span>
      if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
          m_generatorRegister = &amp;m_parameters[1];
  
      allocateAndEmitScope();
  
<span class="line-added">+     emitCheckTraps();</span>
<span class="line-added">+ </span>
      if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
          ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
          ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
          bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
          bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,11 ***</span>
                      // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
                      // So, we just disable it.
                      entry.disableWatching(m_vm);
                      functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
                  }
<span class="line-modified">!                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
              }
  
              // This creates a scoped arguments object and copies the overflow arguments into the
              // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
              OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
<span class="line-new-header">--- 507,11 ---</span>
                      // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
                      // So, we just disable it.
                      entry.disableWatching(m_vm);
                      functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
                  }
<span class="line-modified">!                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
              }
  
              // This creates a scoped arguments object and copies the overflow arguments into the
              // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
              OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,20 ***</span>
                  continue;
  
              if (!captures(name)) {
                  // This is the easy case - just tell the symbol table about the argument. It will
                  // be accessed directly.
<span class="line-modified">!                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgument(1 + i))));</span>
                  continue;
              }
  
              ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
              const Identifier&amp; ident =
                  static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
              functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
  
<span class="line-modified">!             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgument(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
          }
      }
  
      if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
          // Allocate a cloned arguments object.
<span class="line-new-header">--- 536,20 ---</span>
                  continue;
  
              if (!captures(name)) {
                  // This is the easy case - just tell the symbol table about the argument. It will
                  // be accessed directly.
<span class="line-modified">!                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgumentIncludingThis(1 + i))));</span>
                  continue;
              }
  
              ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
              const Identifier&amp; ident =
                  static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
              functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
  
<span class="line-modified">!             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
          }
      }
  
      if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
          // Allocate a cloned arguments object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 635,11 ***</span>
                  break;
              }
          }
  
          bool shouldCreateArgumensVariable = !haveParameterNamedArguments
<span class="line-modified">!             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(m_codeBlock-&gt;parseMode());</span>
          shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
          // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
          if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
              createVariable(
                  propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
<span class="line-new-header">--- 595,11 ---</span>
                  break;
              }
          }
  
          bool shouldCreateArgumensVariable = !haveParameterNamedArguments
<span class="line-modified">!             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::InstanceFieldInitializerMode).contains(m_codeBlock-&gt;parseMode());</span>
          shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
          // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
          if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
              createVariable(
                  propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 666,57 ***</span>
      if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
          m_newTargetRegister = addVar();
  
      switch (parseMode) {
      case SourceParseMode::GeneratorWrapperFunctionMode:
<span class="line-modified">!     case SourceParseMode::GeneratorWrapperMethodMode:</span>
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
          m_generatorRegister = addVar();
  
          // FIXME: Emit to_this only when Generator uses it.
          // https://bugs.webkit.org/show_bug.cgi?id=151586
          emitToThis();
  
<span class="line-modified">!         move(m_generatorRegister, &amp;m_calleeRegister);</span>
<span class="line-removed">-         emitCreateThis(m_generatorRegister);</span>
          break;
      }
  
      case SourceParseMode::AsyncArrowFunctionMode:
      case SourceParseMode::AsyncMethodMode:
      case SourceParseMode::AsyncFunctionMode: {
          ASSERT(!isConstructor());
          ASSERT(constructorKind() == ConstructorKind::None);
          m_generatorRegister = addVar();
<span class="line-modified">!         m_promiseCapabilityRegister = addVar();</span>
  
          if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
              // FIXME: Emit to_this only when AsyncFunctionBody uses it.
              // https://bugs.webkit.org/show_bug.cgi?id=151586
              emitToThis();
          }
  
<span class="line-modified">!         emitNewObject(m_generatorRegister);</span>
<span class="line-modified">! </span>
<span class="line-removed">-         // let promiseCapability be @newPromiseCapability(@Promise)</span>
<span class="line-removed">-         auto varNewPromiseCapability = variable(propertyNames().builtinNames().newPromiseCapabilityPrivateName());</span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; scope = newTemporary();</span>
<span class="line-removed">-         move(scope.get(), emitResolveScope(scope.get(), varNewPromiseCapability));</span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; newPromiseCapability = emitGetFromScope(newTemporary(), scope.get(), varNewPromiseCapability, ThrowIfNotFound);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         CallArguments args(*this, nullptr, 1);</span>
<span class="line-removed">-         emitLoad(args.thisRegister(), jsUndefined());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto&amp; builtinNames = propertyNames().builtinNames();</span>
<span class="line-removed">-         auto varPromiseConstructor = variable(m_isBuiltinFunction ? builtinNames.InternalPromisePrivateName() : builtinNames.PromisePrivateName());</span>
<span class="line-removed">-         move(scope.get(), emitResolveScope(scope.get(), varPromiseConstructor));</span>
<span class="line-removed">-         emitGetFromScope(args.argumentRegister(0), scope.get(), varPromiseConstructor, ThrowIfNotFound);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // JSTextPosition(int _line, int _offset, int _lineStartOffset)</span>
<span class="line-removed">-         JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());</span>
<span class="line-removed">-         emitCall(promiseCapabilityRegister(), newPromiseCapability.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
          break;
      }
  
      case SourceParseMode::AsyncGeneratorBodyMode:
      case SourceParseMode::AsyncFunctionBodyMode:
<span class="line-new-header">--- 626,49 ---</span>
      if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
          m_newTargetRegister = addVar();
  
      switch (parseMode) {
      case SourceParseMode::GeneratorWrapperFunctionMode:
<span class="line-modified">!     case SourceParseMode::GeneratorWrapperMethodMode: {</span>
<span class="line-added">+         m_generatorRegister = addVar();</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: Emit to_this only when Generator uses it.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=151586</span>
<span class="line-added">+         emitToThis();</span>
<span class="line-added">+ </span>
<span class="line-added">+         emitCreateGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case SourceParseMode::AsyncGeneratorWrapperMethodMode:
      case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
          m_generatorRegister = addVar();
  
          // FIXME: Emit to_this only when Generator uses it.
          // https://bugs.webkit.org/show_bug.cgi?id=151586
          emitToThis();
  
<span class="line-modified">!         emitCreateAsyncGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>
          break;
      }
  
      case SourceParseMode::AsyncArrowFunctionMode:
      case SourceParseMode::AsyncMethodMode:
      case SourceParseMode::AsyncFunctionMode: {
          ASSERT(!isConstructor());
          ASSERT(constructorKind() == ConstructorKind::None);
          m_generatorRegister = addVar();
<span class="line-modified">!         m_promiseRegister = addVar();</span>
  
          if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
              // FIXME: Emit to_this only when AsyncFunctionBody uses it.
              // https://bugs.webkit.org/show_bug.cgi?id=151586
              emitToThis();
          }
  
<span class="line-modified">!         emitNewGenerator(m_generatorRegister);</span>
<span class="line-modified">!         emitNewPromise(promiseRegister(), m_isBuiltinFunction);</span>
          break;
      }
  
      case SourceParseMode::AsyncGeneratorBodyMode:
      case SourceParseMode::AsyncFunctionBodyMode:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,37 ***</span>
      default: {
          if (SourceParseMode::ArrowFunctionMode != parseMode) {
              if (isConstructor()) {
                  if (m_newTargetRegister)
                      move(m_newTargetRegister, &amp;m_thisRegister);
<span class="line-modified">!                 if (constructorKind() == ConstructorKind::Extends) {</span>
<span class="line-modified">!                     moveEmptyValue(&amp;m_thisRegister);</span>
<span class="line-modified">!                 } else</span>
                      emitCreateThis(&amp;m_thisRegister);
<span class="line-modified">!             } else if (constructorKind() != ConstructorKind::None)</span>
<span class="line-modified">!                 emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 bool shouldEmitToThis = false;</span>
<span class="line-modified">!                 if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())</span>
<span class="line-modified">!                     shouldEmitToThis = true;</span>
<span class="line-modified">!                 else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {</span>
<span class="line-modified">!                     // We must emit to_this when we&#39;re not in strict mode because we</span>
<span class="line-modified">!                     // will convert |this| to an object, and that object may be passed</span>
<span class="line-modified">!                     // to a strict function as |this|. This is observable because that</span>
<span class="line-modified">!                     // strict function&#39;s to_this will just return the object.</span>
<span class="line-modified">!                     //</span>
<span class="line-modified">!                     // We don&#39;t need to emit this for strict-mode code because</span>
<span class="line-modified">!                     // strict-mode code may call another strict function, which will</span>
<span class="line-modified">!                     // to_this if it directly uses this; this is OK, because we defer</span>
<span class="line-modified">!                     // to_this until |this| is used directly. Strict-mode code might</span>
<span class="line-modified">!                     // also call a sloppy mode function, and that will to_this, which</span>
<span class="line-modified">!                     // will defer the conversion, again, until necessary.</span>
<span class="line-modified">!                     shouldEmitToThis = true;</span>
                  }
<span class="line-removed">- </span>
<span class="line-removed">-                 if (shouldEmitToThis)</span>
<span class="line-removed">-                     emitToThis();</span>
              }
          }
          break;
      }
      }
<span class="line-new-header">--- 683,57 ---</span>
      default: {
          if (SourceParseMode::ArrowFunctionMode != parseMode) {
              if (isConstructor()) {
                  if (m_newTargetRegister)
                      move(m_newTargetRegister, &amp;m_thisRegister);
<span class="line-modified">!                 switch (constructorKind()) {</span>
<span class="line-modified">!                 case ConstructorKind::Naked:</span>
<span class="line-modified">!                     // Naked constructor not create |this| automatically.</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 case ConstructorKind::None:</span>
<span class="line-added">+                 case ConstructorKind::Base:</span>
                      emitCreateThis(&amp;m_thisRegister);
<span class="line-modified">!                     if (Options::useClassFields())</span>
<span class="line-modified">!                         emitInstanceFieldInitializationIfNeeded(&amp;m_thisRegister, &amp;m_calleeRegister, m_scopeNode-&gt;position(), m_scopeNode-&gt;position(), m_scopeNode-&gt;position());</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 case ConstructorKind::Extends:</span>
<span class="line-modified">!                     moveEmptyValue(&amp;m_thisRegister);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">!             } else {</span>
<span class="line-modified">!                 switch (constructorKind()) {</span>
<span class="line-modified">!                 case ConstructorKind::None: {</span>
<span class="line-modified">!                     bool shouldEmitToThis = false;</span>
<span class="line-modified">!                     if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())</span>
<span class="line-modified">!                         shouldEmitToThis = true;</span>
<span class="line-modified">!                     else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {</span>
<span class="line-modified">!                         // We must emit to_this when we&#39;re not in strict mode because we</span>
<span class="line-modified">!                         // will convert |this| to an object, and that object may be passed</span>
<span class="line-modified">!                         // to a strict function as |this|. This is observable because that</span>
<span class="line-modified">!                         // strict function&#39;s to_this will just return the object.</span>
<span class="line-modified">!                         //</span>
<span class="line-added">+                         // We don&#39;t need to emit this for strict-mode code because</span>
<span class="line-added">+                         // strict-mode code may call another strict function, which will</span>
<span class="line-added">+                         // to_this if it directly uses this; this is OK, because we defer</span>
<span class="line-added">+                         // to_this until |this| is used directly. Strict-mode code might</span>
<span class="line-added">+                         // also call a sloppy mode function, and that will to_this, which</span>
<span class="line-added">+                         // will defer the conversion, again, until necessary.</span>
<span class="line-added">+                         shouldEmitToThis = true;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     if (shouldEmitToThis)</span>
<span class="line-added">+                         emitToThis();</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 case ConstructorKind::Naked:</span>
<span class="line-added">+                     emitThrowTypeError(&quot;Cannot call a constructor without |new|&quot;);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 case ConstructorKind::Base:</span>
<span class="line-added">+                 case ConstructorKind::Extends:</span>
<span class="line-added">+                     emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);</span>
<span class="line-added">+                     break;</span>
                  }
              }
          }
          break;
      }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,22 ***</span>
          popTry(tryFormalParametersData, catchLabel.get());
  
          RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
          emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
  
<span class="line-modified">!         // return promiseCapability.@reject(thrownValue)</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; reject = emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().rejectPrivateName());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         CallArguments args(*this, nullptr, 1);</span>
          emitLoad(args.thisRegister(), jsUndefined());
<span class="line-modified">!         move(args.argumentRegister(0), thrownValue.get());</span>
<span class="line-modified">! </span>
          JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
  
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; result = emitCall(newTemporary(), reject.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
<span class="line-removed">-         emitReturn(emitGetById(newTemporary(), promiseCapabilityRegister(), m_vm.propertyNames-&gt;builtinNames().promisePrivateName()));</span>
<span class="line-removed">- </span>
          emitLabel(didNotThrow.get());
      }
  
      // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
      // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
<span class="line-new-header">--- 777,21 ---</span>
          popTry(tryFormalParametersData, catchLabel.get());
  
          RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
          emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
  
<span class="line-modified">!         // @rejectPromiseWithFirstResolvingFunctionCallCheck(@promise, thrownValue);</span>
<span class="line-modified">!         // return @promise;</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; rejectPromise = moveLinkTimeConstant(nullptr, LinkTimeConstant::rejectPromiseWithFirstResolvingFunctionCallCheck);</span>
<span class="line-modified">!         CallArguments args(*this, nullptr, 2);</span>
          emitLoad(args.thisRegister(), jsUndefined());
<span class="line-modified">!         move(args.argumentRegister(0), promiseRegister());</span>
<span class="line-modified">!         move(args.argumentRegister(1), thrownValue.get());</span>
          JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
<span class="line-added">+         emitCall(newTemporary(), rejectPromise.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
  
<span class="line-modified">!         emitReturn(promiseRegister());</span>
          emitLabel(didNotThrow.get());
      }
  
      // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
      // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 845,41 ***</span>
              // In this case, we would like to avoid creating a lexical environment as much as possible.
              // op_create_generator_frame_environment is a marker, which is similar to op_yield.
              // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
              OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
          }
<span class="line-modified">!         emitPutById(generatorRegister(), propertyNames().builtinNames().generatorFramePrivateName(), generatorFrameRegister());</span>
      }
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(evalNode)
<span class="line-removed">-     , m_codeBlock(vm, codeBlock)</span>
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(EvalCode)
      , m_vm(vm)
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
<span class="line-removed">-     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed">-         constantRegister = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     allocateCalleeSaveSpace();</span>
<span class="line-removed">- </span>
      m_codeBlock-&gt;setNumParameters(1);
  
      pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
  
      emitEnter();
  
      allocateAndEmitScope();
  
      for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
          m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
      }
  
<span class="line-new-header">--- 816,39 ---</span>
              // In this case, we would like to avoid creating a lexical environment as much as possible.
              // op_create_generator_frame_environment is a marker, which is similar to op_yield.
              // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
              OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
          }
<span class="line-modified">!         static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Frame));</span>
<span class="line-added">+         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame), generatorFrameRegister());</span>
      }
  
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added">+     , m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(evalNode)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(EvalCode)
      , m_vm(vm)
      , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
      , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
      , m_derivedContextType(codeBlock-&gt;derivedContextType())
  {
      m_codeBlock-&gt;setNumParameters(1);
  
      pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-added">+     emitCheckTraps();</span>
<span class="line-added">+ </span>
      for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
          m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
          m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 914,26 ***</span>
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(moduleProgramNode)
<span class="line-removed">-     , m_codeBlock(vm, codeBlock)</span>
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(ModuleCode)
      , m_vm(vm)
      , m_usesNonStrictEval(false)
      , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
<span class="line-removed">-     for (auto&amp; constantRegister : m_linkTimeConstantRegisters)</span>
<span class="line-removed">-         constantRegister = nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     allocateCalleeSaveSpace();</span>
<span class="line-removed">- </span>
      SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
      moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
  
      bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<span class="line-new-header">--- 883,21 ---</span>
      bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
      pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
  }
  
  BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<span class="line-modified">!     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added">+     , m_codeGenerationMode(codeGenerationMode)</span>
      , m_scopeNode(moduleProgramNode)
      , m_thisRegister(CallFrame::thisArgumentOffset())
      , m_codeType(ModuleCode)
      , m_vm(vm)
      , m_usesNonStrictEval(false)
      , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
  {
      ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
  
      SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
      moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
      moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
  
      bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 960,10 ***</span>
<span class="line-new-header">--- 924,12 ---</span>
  
      emitEnter();
  
      allocateAndEmitScope();
  
<span class="line-added">+     emitCheckTraps();</span>
<span class="line-added">+ </span>
      m_calleeRegister.setIndex(CallFrameSlot::callee);
  
      m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
  
      // Now declare all variables.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1215,23 ***</span>
      }
  }
  
  RegisterID* BytecodeGenerator::initializeNextParameter()
  {
<span class="line-modified">!     VirtualRegister reg = virtualRegisterForArgument(m_codeBlock-&gt;numParameters());</span>
      m_parameters.grow(m_parameters.size() + 1);
      auto&amp; parameter = registerFor(reg);
<span class="line-modified">!     parameter.setIndex(reg.offset());</span>
<span class="line-modified">!     m_codeBlock-&gt;addParameter();</span>
      return &amp;parameter;
  }
  
  void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
  {
      // Make sure the code block knows about all of our parameters, and make sure that parameters
      // needing destructuring are noted.
<span class="line-modified">!     m_thisRegister.setIndex(initializeNextParameter()-&gt;index()); // this</span>
  
      bool nonSimpleArguments = false;
      for (unsigned i = 0; i &lt; parameters.size(); ++i) {
          auto parameter = parameters.at(i);
          auto pattern = parameter.first;
<span class="line-new-header">--- 1181,23 ---</span>
      }
  }
  
  RegisterID* BytecodeGenerator::initializeNextParameter()
  {
<span class="line-modified">!     VirtualRegister reg = virtualRegisterForArgumentIncludingThis(m_codeBlock-&gt;numParameters());</span>
      m_parameters.grow(m_parameters.size() + 1);
      auto&amp; parameter = registerFor(reg);
<span class="line-modified">!     parameter.setIndex(reg);</span>
<span class="line-modified">!     m_codeBlock-&gt;setNumParameters(m_codeBlock-&gt;numParameters() + 1);</span>
      return &amp;parameter;
  }
  
  void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
  {
      // Make sure the code block knows about all of our parameters, and make sure that parameters
      // needing destructuring are noted.
<span class="line-modified">!     m_thisRegister.setIndex(VirtualRegister(initializeNextParameter()-&gt;index())); // this</span>
  
      bool nonSimpleArguments = false;
      for (unsigned i = 0; i &lt; parameters.size(); ++i) {
          auto parameter = parameters.at(i);
          auto pattern = parameter.first;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1273,108 ***</span>
              return ident.impl();
      }
      return nullptr;
  }
  
<span class="line-removed">- RegisterID* BytecodeGenerator::newRegister()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_calleeLocals.append(virtualRegisterForLocal(m_calleeLocals.size()));</span>
<span class="line-removed">-     int numCalleeLocals = std::max&lt;int&gt;(m_codeBlock-&gt;m_numCalleeLocals, m_calleeLocals.size());</span>
<span class="line-removed">-     numCalleeLocals = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), numCalleeLocals);</span>
<span class="line-removed">-     m_codeBlock-&gt;m_numCalleeLocals = numCalleeLocals;</span>
<span class="line-removed">-     return &amp;m_calleeLocals.last();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BytecodeGenerator::reclaimFreeRegisters()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     shrinkToFit(m_calleeLocals);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  RegisterID* BytecodeGenerator::newBlockScopeVariable()
  {
      reclaimFreeRegisters();
  
      return newRegister();
  }
  
<span class="line-removed">- RegisterID* BytecodeGenerator::newTemporary()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     reclaimFreeRegisters();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RegisterID* result = newRegister();</span>
<span class="line-removed">-     result-&gt;setTemporary();</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
  {
      shrinkToFit(m_labelScopes);
  
      // Allocate new label scope.
      m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
      return m_labelScopes.last();
  }
  
<span class="line-removed">- Ref&lt;Label&gt; BytecodeGenerator::newLabel()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     shrinkToFit(m_labels);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Allocate new label ID.</span>
<span class="line-removed">-     m_labels.append();</span>
<span class="line-removed">-     return m_labels.last();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Ref&lt;Label&gt; BytecodeGenerator::newEmittedLabel()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Ref&lt;Label&gt; label = newLabel();</span>
<span class="line-removed">-     emitLabel(label.get());</span>
<span class="line-removed">-     return label;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BytecodeGenerator::recordOpcode(OpcodeID opcodeID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_lastOpcodeID == op_end || (m_lastOpcodeID == m_lastInstruction-&gt;opcodeID() &amp;&amp; m_writer.position() == m_lastInstruction.offset() + m_lastInstruction-&gt;size()));</span>
<span class="line-removed">-     m_lastInstruction = m_writer.ref();</span>
<span class="line-removed">-     m_lastOpcodeID = opcodeID;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BytecodeGenerator::alignWideOpcode16()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-removed">-     while ((m_writer.position() + 1) % OpcodeSize::Wide16)</span>
<span class="line-removed">-         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BytecodeGenerator::alignWideOpcode32()</span>
<span class="line-removed">- {</span>
<span class="line-removed">- #if CPU(NEEDS_ALIGNED_ACCESS)</span>
<span class="line-removed">-     while ((m_writer.position() + 1) % OpcodeSize::Wide32)</span>
<span class="line-removed">-         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void BytecodeGenerator::emitLabel(Label&amp; l0)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     unsigned newLabelIndex = instructions().size();</span>
<span class="line-removed">-     l0.setLocation(*this, newLabelIndex);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_codeBlock-&gt;numberOfJumpTargets()) {</span>
<span class="line-removed">-         unsigned lastLabelIndex = m_codeBlock-&gt;lastJumpTarget();</span>
<span class="line-removed">-         ASSERT(lastLabelIndex &lt;= newLabelIndex);</span>
<span class="line-removed">-         if (newLabelIndex == lastLabelIndex) {</span>
<span class="line-removed">-             // Peephole optimizations have already been disabled by emitting the last label</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_codeBlock-&gt;addJumpTarget(newLabelIndex);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // This disables peephole optimizations when an instruction is a jump target</span>
<span class="line-removed">-     m_lastOpcodeID = op_end;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void BytecodeGenerator::emitEnter()
  {
      OpEnter::emit(this);
  
      if (LIKELY(Options::optimizeRecursiveTailCalls())) {
<span class="line-new-header">--- 1239,26 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1387,17 ***</span>
<span class="line-new-header">--- 1271,23 ---</span>
  }
  
  void BytecodeGenerator::emitLoopHint()
  {
      OpLoopHint::emit(this);
<span class="line-added">+     emitCheckTraps();</span>
  }
  
  void BytecodeGenerator::emitJump(Label&amp; target)
  {
      OpJmp::emit(this, target.bind(this));
  }
  
<span class="line-added">+ void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpCheckTraps::emit(this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ALWAYS_INLINE BytecodeGenerator::rewind()
  {
      ASSERT(m_lastInstruction.isValid());
      m_lastOpcodeID = op_end;
      m_writer.rewind(m_lastInstruction);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1533,16 ***</span>
      OpJfalse::emit(this, cond, target.bind(this));
  }
  
  void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     OpJneqPtr::emit(this, cond, Special::CallFunction, target.bind(this));</span>
  }
  
  void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     OpJneqPtr::emit(this, cond, Special::ApplyFunction, target.bind(this));</span>
  }
  
  bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
  {
      UniquedStringImpl* rep = ident.impl();
<span class="line-new-header">--- 1423,16 ---</span>
      OpJfalse::emit(this, cond, target.bind(this));
  }
  
  void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::callFunction), target.bind(this));</span>
  }
  
  void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
  {
<span class="line-modified">!     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::applyFunction), target.bind(this));</span>
  }
  
  bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
  {
      UniquedStringImpl* rep = ident.impl();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1590,21 ***</span>
      return &amp;m_constantPoolRegisters[index];
  }
  
  RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
  {
<span class="line-modified">!     unsigned constantIndex = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">-     if (!m_linkTimeConstantRegisters[constantIndex]) {</span>
          int index = addConstantIndex();
          m_codeBlock-&gt;addConstant(type);
<span class="line-modified">!         m_linkTimeConstantRegisters[constantIndex] = &amp;m_constantPoolRegisters[index];</span>
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
      if (!dst)
<span class="line-modified">!         return m_linkTimeConstantRegisters[constantIndex];</span>
  
<span class="line-modified">!     OpMov::emit(this, dst, m_linkTimeConstantRegisters[constantIndex]);</span>
  
      return dst;
  }
  
  RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
<span class="line-new-header">--- 1480,19 ---</span>
      return &amp;m_constantPoolRegisters[index];
  }
  
  RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
  {
<span class="line-modified">!     RegisterID* constant = m_linkTimeConstantRegisters.ensure(type, [&amp;] {</span>
          int index = addConstantIndex();
          m_codeBlock-&gt;addConstant(type);
<span class="line-modified">!         return &amp;m_constantPoolRegisters[index];</span>
<span class="line-modified">!     }).iterator-&gt;value;</span>
      if (!dst)
<span class="line-modified">!         return constant;</span>
  
<span class="line-modified">!     OpMov::emit(this, dst, constant);</span>
  
      return dst;
  }
  
  RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1624,25 ***</span>
      OpMov::emit(this, dst, src);
  
      return dst;
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, OperandTypes types)</span>
  {
      switch (opcodeID) {
      case op_not:
          emitUnaryOp&lt;OpNot&gt;(dst, src);
          break;
      case op_negate:
<span class="line-modified">!         OpNegate::emit(this, dst, src, types);</span>
          break;
      case op_bitnot:
          emitUnaryOp&lt;OpBitnot&gt;(dst, src);
          break;
      case op_to_number:
          emitUnaryOp&lt;OpToNumber&gt;(dst, src);
          break;
      default:
          ASSERT_NOT_REACHED();
      }
      return dst;
  }
<span class="line-new-header">--- 1512,28 ---</span>
      OpMov::emit(this, dst, src);
  
      return dst;
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, ResultType type)</span>
  {
      switch (opcodeID) {
      case op_not:
          emitUnaryOp&lt;OpNot&gt;(dst, src);
          break;
      case op_negate:
<span class="line-modified">!         OpNegate::emit(this, dst, src, type);</span>
          break;
      case op_bitnot:
          emitUnaryOp&lt;OpBitnot&gt;(dst, src);
          break;
      case op_to_number:
          emitUnaryOp&lt;OpToNumber&gt;(dst, src);
          break;
<span class="line-added">+     case op_to_numeric:</span>
<span class="line-added">+         emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">+         break;</span>
      default:
          ASSERT_NOT_REACHED();
      }
      return dst;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1709,10 ***</span>
<span class="line-new-header">--- 1600,15 ---</span>
  RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
  {
      return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
  }
  
<span class="line-added">+ RegisterID* BytecodeGenerator::emitToNumeric(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
  {
      return emitUnaryOp&lt;OpToString&gt;(dst, src);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1738,15 ***</span>
      if (!canDoPeepholeOptimization())
          return false;
  
      if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
          auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">!         if (src1-&gt;index() == op.m_dst.offset()</span>
              &amp;&amp; src1-&gt;isTemporary()
<span class="line-modified">!             &amp;&amp; m_codeBlock-&gt;isConstantRegisterIndex(src2-&gt;index())</span>
<span class="line-modified">!             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;index()).get().isString()) {</span>
<span class="line-modified">!             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;index()).get())-&gt;tryGetValue();</span>
              if (value == &quot;undefined&quot;) {
                  rewind();
                  OpIsUndefined::emit(this, dst, op.m_value);
                  return true;
              }
<span class="line-new-header">--- 1634,15 ---</span>
      if (!canDoPeepholeOptimization())
          return false;
  
      if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
          auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified">!         if (src1-&gt;virtualRegister() == op.m_dst</span>
              &amp;&amp; src1-&gt;isTemporary()
<span class="line-modified">!             &amp;&amp; src2-&gt;virtualRegister().isConstant()</span>
<span class="line-modified">!             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get().isString()) {</span>
<span class="line-modified">!             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get())-&gt;tryGetValue();</span>
              if (value == &quot;undefined&quot;) {
                  rewind();
                  OpIsUndefined::emit(this, dst, op.m_value);
                  return true;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2217,11 ***</span>
          local-&gt;deref();
      }
  
      if (hasCapturedVariables) {
          RELEASE_ASSERT(stackEntry.m_scope);
<span class="line-modified">!         emitPopScope(scopeRegister(), stackEntry.m_scope);</span>
          popLocalControlFlowScope();
          stackEntry.m_scope-&gt;deref();
      }
  
      m_TDZStack.removeLast();
<span class="line-new-header">--- 2113,11 ---</span>
          local-&gt;deref();
      }
  
      if (hasCapturedVariables) {
          RELEASE_ASSERT(stackEntry.m_scope);
<span class="line-modified">!         emitGetParentScope(scopeRegister(), stackEntry.m_scope);</span>
          popLocalControlFlowScope();
          stackEntry.m_scope-&gt;deref();
      }
  
      m_TDZStack.removeLast();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2275,19 ***</span>
      // each loop iteration has a new activation object. (It&#39;s pretty ugly).
      // Also, this new activation needs to be assigned to the same register
      // as the previous scope because the loop body is compiled under
      // the assumption that the scope&#39;s register index is constant even
      // though the value in that register will change on each loop iteration.
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), loopScope);</span>
<span class="line-removed">-     move(scopeRegister(), parentScope.get());</span>
  
      OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
  
      move(scopeRegister(), loopScope);
  
      {
<span class="line-modified">!         for (auto pair : activationValuesToCopyOver) {</span>
              const Identifier&amp; identifier = pair.second;
              SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
              RELEASE_ASSERT(!entry.isNull());
              RegisterID* transitionValue = pair.first;
              emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
<span class="line-new-header">--- 2171,18 ---</span>
      // each loop iteration has a new activation object. (It&#39;s pretty ugly).
      // Also, this new activation needs to be assigned to the same register
      // as the previous scope because the loop body is compiled under
      // the assumption that the scope&#39;s register index is constant even
      // though the value in that register will change on each loop iteration.
<span class="line-modified">!     emitGetParentScope(scopeRegister(), loopScope);</span>
  
      OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
  
      move(scopeRegister(), loopScope);
  
      {
<span class="line-modified">!         for (const auto&amp; pair : activationValuesToCopyOver) {</span>
              const Identifier&amp; identifier = pair.second;
              SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
              RELEASE_ASSERT(!entry.isNull());
              RegisterID* transitionValue = pair.first;
              emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2466,11 ***</span>
      case VarKind::Invalid:
          // Indicates non-local resolution.
  
          dst = tempDestination(dst);
          OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());
<span class="line-removed">-         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
          return dst;
      }
  
      RELEASE_ASSERT_NOT_REACHED();
      return nullptr;
<span class="line-new-header">--- 2361,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2495,11 ***</span>
              scope,
              addConstant(variable.ident()),
              GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
              localScopeDepth(),
              variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);
<span class="line-removed">-         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
          return dst;
      } }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
<span class="line-new-header">--- 2389,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2528,11 ***</span>
              ASSERT(resolveType() != LocalClosureVar);
              getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
              symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
          }
          OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);
<span class="line-removed">-         m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
          return value;
      } }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
<span class="line-new-header">--- 2421,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2579,11 ***</span>
  RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
  {
      ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
  
      OpGetById::emit(this, kill(dst), base, addConstant(property));
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
      return dst;
  }
  
  RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
  {
<span class="line-new-header">--- 2471,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2596,11 ***</span>
  RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
  {
      ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
  
      OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
      return dst;
  }
  
  RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
  {
<span class="line-new-header">--- 2487,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2609,12 ***</span>
      unsigned propertyIndex = addConstant(property);
  
      m_staticPropertyAnalyzer.putById(base, propertyIndex);
  
      OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
<span class="line-removed">- </span>
      return value;
  }
  
  RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
  {
<span class="line-new-header">--- 2499,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2635,11 ***</span>
  
      m_staticPropertyAnalyzer.putById(base, propertyIndex);
  
      PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;
      OpPutById::emit(this, base, propertyIndex, value, type);
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
      return value;
  }
  
  void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
  {
<span class="line-new-header">--- 2523,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2676,42 ***</span>
      OpPutSetterByVal::emit(this, base, property, attributes, setter);
  }
  
  void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
  {
<span class="line-modified">!     // FIXME: Currently, we just create an object and store generator related fields as its properties for ease.</span>
<span class="line-removed">-     // But to make it efficient, we will introduce JSGenerator class, add opcode new_generator and use its C++ fields instead of these private properties.</span>
<span class="line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=151545</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);</span>
  
      // We do not store &#39;this&#39; in arrow function within constructor,
      // because it might be not initialized, if super is called later.
      if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
<span class="line-modified">!         emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(0)), PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
  }
  
  void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
  {
      ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
  
<span class="line-modified">!     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorNextPrivateName(), nextFunction, PropertyNode::KnownDirect);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorThisPrivateName(), &amp;m_thisRegister, PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorStatePrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorState::SuspendedStart))), PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().generatorFramePrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::None))), PropertyNode::KnownDirect);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueFirstPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
<span class="line-removed">-     emitDirectPutById(m_generatorRegister, propertyNames().builtinNames().asyncGeneratorQueueLastPrivateName(), emitLoad(nullptr, jsNull()), PropertyNode::KnownDirect);</span>
  }
  
  RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
  {
      OpDelById::emit(this, dst, base, addConstant(property));
<span class="line-new-header">--- 2563,24 ---</span>
      OpPutSetterByVal::emit(this, base, property, attributes, setter);
  }
  
  void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
  {
<span class="line-modified">!     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::Next), nextFunction);</span>
  
      // We do not store &#39;this&#39; in arrow function within constructor,
      // because it might be not initialized, if super is called later.
      if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
<span class="line-modified">!         emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::This), &amp;m_thisRegister);</span>
  }
  
  void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
  {
      ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
  
<span class="line-modified">!     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Next), nextFunction);</span>
<span class="line-modified">!     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::This), &amp;m_thisRegister);</span>
  }
  
  RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
  {
      OpDelById::emit(this, dst, base, addConstant(property));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2778,10 ***</span>
<span class="line-new-header">--- 2647,22 ---</span>
  {
      OpDelByVal::emit(this, dst, base, property);
      return dst;
  }
  
<span class="line-added">+ RegisterID* BytecodeGenerator::emitGetInternalField(RegisterID* dst, RegisterID* base, unsigned index)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpGetInternalField::emit(this, dst, base, index);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitPutInternalField(RegisterID* base, unsigned index, RegisterID* value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpPutInternalField::emit(this, base, index, value);</span>
<span class="line-added">+     return value;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void BytecodeGenerator::emitSuperSamplerBegin()
  {
      OpSuperSamplerBegin::emit(this);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2809,12 ***</span>
  
  RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
  {
      OpCreateThis::emit(this, dst, dst, 0);
      m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
  
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
      return dst;
  }
  
  void BytecodeGenerator::emitTDZCheck(RegisterID* target)
  {
<span class="line-new-header">--- 2690,59 ---</span>
  
  RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
  {
      OpCreateThis::emit(this, dst, dst, 0);
      m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitCreatePromise(RegisterID* dst, RegisterID* newTarget, bool isInternalPromise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpCreatePromise::emit(this, dst, newTarget, isInternalPromise);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitNewPromise(RegisterID* dst, bool isInternalPromise)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpNewPromise::emit(this, dst, isInternalPromise);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitCreateGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpCreateGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitNewGenerator(RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpNewGenerator::emit(this, dst);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitCreateAsyncGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpCreateAsyncGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitCreateArgumentsButterfly(RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpCreateArgumentsButterfly::emit(this, dst);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeGenerator::emitInstanceFieldInitializationIfNeeded(RegisterID* dst, RegisterID* constructor, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!(isConstructor() || isDerivedConstructorContext()) || needsClassFieldInitializer() == NeedsClassFieldInitializer::No)</span>
<span class="line-added">+         return dst;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; initializer = emitDirectGetById(newTemporary(), constructor, propertyNames().builtinNames().instanceFieldInitializerPrivateName());</span>
<span class="line-added">+     CallArguments args(*this, nullptr);</span>
<span class="line-added">+     emitMove(args.thisRegister(), dst);</span>
<span class="line-added">+     emitCall(newTemporary(), initializer.get(), NoExpectedFunction, args, divot, divotStart, divotEnd, DebuggableCall::No);</span>
  
      return dst;
  }
  
  void BytecodeGenerator::emitTDZCheck(RegisterID* target)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2947,14 ***</span>
  {
      return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
          auto scope = DECLARE_CATCH_SCOPE(vm());
          auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
          JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);
<span class="line-removed">-         // FIXME: [ESNext] Enables a way to throw an error on ByteCodeGenerator step</span>
<span class="line-removed">-         // https://bugs.webkit.org/show_bug.cgi?id=180139</span>
          scope.assertNoException();
<span class="line-removed">-         RELEASE_ASSERT(bigIntInMap);</span>
          addConstantValue(bigIntInMap);
  
          return bigIntInMap;
      }).iterator-&gt;value;
  }
<span class="line-new-header">--- 2875,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3095,23 ***</span>
      emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
      return dst;
  }
  
  RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
<span class="line-modified">!     const Identifier&amp; ecmaName, const SourceCode&amp; classSource)</span>
  {
<span class="line-modified">!     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name);</span>
      executable-&gt;setInvalidTypeProfilingOffsets();
      executable-&gt;setEcmaName(ecmaName);
      executable-&gt;setClassSource(classSource);
  
      unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
  
      OpNewFuncExp::emit(this, dst, scopeRegister(), index);
      return dst;
  }
  
  RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
  {
      unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
      if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
          OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
<span class="line-new-header">--- 3020,50 ---</span>
      emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
      return dst;
  }
  
  RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
<span class="line-modified">!     const Identifier&amp; ecmaName, const SourceCode&amp; classSource, NeedsClassFieldInitializer needsClassFieldInitializer)</span>
  {
<span class="line-modified">!     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name, needsClassFieldInitializer);</span>
      executable-&gt;setInvalidTypeProfilingOffsets();
      executable-&gt;setEcmaName(ecmaName);
      executable-&gt;setClassSource(classSource);
  
      unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
  
      OpNewFuncExp::emit(this, dst, scopeRegister(), index);
      return dst;
  }
  
<span class="line-added">+ RegisterID* BytecodeGenerator::emitNewInstanceFieldInitializerFunction(RegisterID* dst, Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations, bool isDerived)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DerivedContextType newDerivedContextType;</span>
<span class="line-added">+     SuperBinding superBinding;</span>
<span class="line-added">+     if (!isDerived) {</span>
<span class="line-added">+         newDerivedContextType = DerivedContextType::None;</span>
<span class="line-added">+         superBinding = SuperBinding::NotNeeded;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         newDerivedContextType = DerivedContextType::DerivedMethodContext;</span>
<span class="line-added">+         superBinding = SuperBinding::Needed;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Optional&lt;CompactVariableMap::Handle&gt; variablesUnderTDZ = getVariablesUnderTDZ();</span>
<span class="line-added">+     SourceParseMode parseMode = SourceParseMode::InstanceFieldInitializerMode;</span>
<span class="line-added">+     ConstructAbility constructAbility = ConstructAbility::CannotConstruct;</span>
<span class="line-added">+ </span>
<span class="line-added">+     const bool alwaysStrictInClass = true;</span>
<span class="line-added">+     FunctionMetadataNode metadata(parserArena(), JSTokenLocation(), JSTokenLocation(), 0, 0, 0, 0, 0, alwaysStrictInClass, ConstructorKind::None, superBinding, 0, parseMode, false);</span>
<span class="line-added">+     metadata.finishParsing(m_scopeNode-&gt;source(), Identifier(), FunctionMode::MethodDefinition);</span>
<span class="line-added">+     auto initializer = UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), &amp;metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(variablesUnderTDZ), newDerivedContextType, NeedsClassFieldInitializer::No);</span>
<span class="line-added">+     initializer-&gt;setInstanceFieldLocations(WTFMove(instanceFieldLocations));</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned index = m_codeBlock-&gt;addFunctionExpr(initializer);</span>
<span class="line-added">+     OpNewFuncExp::emit(this, dst, scopeRegister(), index);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
  {
      unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
      if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
          OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3122,11 ***</span>
      else
          OpNewFunc::emit(this, dst, scopeRegister(), index);
      return dst;
  }
  
<span class="line-modified">! void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)</span>
  {
      if (valueNode-&gt;isBaseFuncExprNode()) {
          FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
          if (!metadata-&gt;ecmaName().isNull())
              return;
<span class="line-new-header">--- 3074,12 ---</span>
      else
          OpNewFunc::emit(this, dst, scopeRegister(), index);
      return dst;
  }
  
<span class="line-modified">! template&lt;typename LazyNameRegisterFn&gt;</span>
<span class="line-added">+ void BytecodeGenerator::emitSetFunctionNameIfNeededImpl(ExpressionNode* valueNode, RegisterID* value, const LazyNameRegisterFn&amp; lazyNameFn)</span>
  {
      if (valueNode-&gt;isBaseFuncExprNode()) {
          FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
          if (!metadata-&gt;ecmaName().isNull())
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3137,15 ***</span>
<span class="line-new-header">--- 3090,27 ---</span>
          if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))
              return;
      } else
          return;
  
<span class="line-added">+     RegisterID* name = lazyNameFn();</span>
<span class="line-added">+ </span>
      // FIXME: We should use an op_call to an internal function here instead.
      // https://bugs.webkit.org/show_bug.cgi?id=155547
      OpSetFunctionName::emit(this, value, name);
  }
  
<span class="line-added">+ void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, const Identifier&amp; ident)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return emitLoad(newTemporary(), ident); });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return name; });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
  {
      return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3179,11 ***</span>
      case ExpectObjectConstructor: {
          // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
          if (callArguments.argumentCountIncludingThis() &gt;= 2)
              return NoExpectedFunction;
  
<span class="line-modified">!         OpJneqPtr::emit(this, func, Special::ObjectConstructor, realCall-&gt;bind(this));</span>
  
          if (dst != ignoredResult())
              emitNewObject(dst);
          break;
      }
<span class="line-new-header">--- 3144,11 ---</span>
      case ExpectObjectConstructor: {
          // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
          if (callArguments.argumentCountIncludingThis() &gt;= 2)
              return NoExpectedFunction;
  
<span class="line-modified">!         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Object), realCall-&gt;bind(this));</span>
  
          if (dst != ignoredResult())
              emitNewObject(dst);
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3195,11 ***</span>
          // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
          // things sounds like it&#39;s worth it.
          if (callArguments.argumentCountIncludingThis() &gt; 2)
              return NoExpectedFunction;
  
<span class="line-modified">!         OpJneqPtr::emit(this, func, Special::ArrayConstructor, realCall-&gt;bind(this));</span>
  
          if (dst != ignoredResult()) {
              if (callArguments.argumentCountIncludingThis() == 2)
                  emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
              else {
<span class="line-new-header">--- 3160,11 ---</span>
          // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
          // things sounds like it&#39;s worth it.
          if (callArguments.argumentCountIncludingThis() &gt; 2)
              return NoExpectedFunction;
  
<span class="line-modified">!         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Array), realCall-&gt;bind(this));</span>
  
          if (dst != ignoredResult()) {
              if (callArguments.argumentCountIncludingThis() == 2)
                  emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
              else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3317,10 ***</span>
<span class="line-new-header">--- 3282,12 ---</span>
          emitLogShadowChickenTailIfNecessary();
  
      // Emit call.
      ASSERT(dst != ignoredResult());
      VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
<span class="line-added">+     if (VarargsOp::opcodeID != op_tail_call_forward_arguments)</span>
<span class="line-added">+         ASSERT(m_codeBlock-&gt;hasCheckpoints());</span>
      return dst;
  }
  
  void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3363,11 ***</span>
      emitExpressionInfo(position, position, position);
  
      if (attributes.hasGet() || attributes.hasSet()) {
          RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
          if (!attributes.hasGet() || !attributes.hasSet())
<span class="line-modified">!             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::ThrowTypeErrorFunction);</span>
  
          RefPtr&lt;RegisterID&gt; getter;
          if (attributes.hasGet())
              getter = getterRegister;
          else
<span class="line-new-header">--- 3330,11 ---</span>
      emitExpressionInfo(position, position, position);
  
      if (attributes.hasGet() || attributes.hasSet()) {
          RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
          if (!attributes.hasGet() || !attributes.hasSet())
<span class="line-modified">!             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::throwTypeErrorFunction);</span>
  
          RefPtr&lt;RegisterID&gt; getter;
          if (attributes.hasGet())
              getter = getterRegister;
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3385,11 ***</span>
      }
  }
  
  RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
  {
<span class="line-modified">!     if (isConstructor()) {</span>
          bool isDerived = constructorKind() == ConstructorKind::Extends;
          bool srcIsThis = src-&gt;index() == m_thisRegister.index();
  
          if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
              emitTDZCheck(src);
<span class="line-new-header">--- 3352,12 ---</span>
      }
  }
  
  RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
  {
<span class="line-modified">!     // Normal functions and naked constructors do not handle `return` specially.</span>
<span class="line-added">+     if (isConstructor() &amp;&amp; constructorKind() != ConstructorKind::Naked) {</span>
          bool isDerived = constructorKind() == ConstructorKind::Extends;
          bool srcIsThis = src-&gt;index() == m_thisRegister.index();
  
          if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
              emitTDZCheck(src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3484,10 ***</span>
<span class="line-new-header">--- 3452,16 ---</span>
  void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
  {
      OpToPrimitive::emit(this, dst, src);
  }
  
<span class="line-added">+ RegisterID* BytecodeGenerator::emitToPropertyKey(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     OpToPropertyKey::emit(this, dst, src);</span>
<span class="line-added">+     return dst;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void BytecodeGenerator::emitGetScope()
  {
      OpGetScope::emit(this, scopeRegister());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3509,19 ***</span>
  {
      OpGetParentScope::emit(this, dst, scope);
      return dst;
  }
  
<span class="line-removed">- void BytecodeGenerator::emitPopScope(RegisterID* dst, RegisterID* scope)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; parentScope = emitGetParentScope(newTemporary(), scope);</span>
<span class="line-removed">-     move(dst, parentScope.get());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void BytecodeGenerator::emitPopWithScope()
  {
<span class="line-modified">!     emitPopScope(scopeRegister(), scopeRegister());</span>
      popLocalControlFlowScope();
      auto stackEntry = m_lexicalScopeStack.takeLast();
      stackEntry.m_scope-&gt;deref();
      RELEASE_ASSERT(stackEntry.m_isWithScope);
  }
<span class="line-new-header">--- 3483,13 ---</span>
  {
      OpGetParentScope::emit(this, dst, scope);
      return dst;
  }
  
  void BytecodeGenerator::emitPopWithScope()
  {
<span class="line-modified">!     emitGetParentScope(scopeRegister(), scopeRegister());</span>
      popLocalControlFlowScope();
      auto stackEntry = m_lexicalScopeStack.takeLast();
      stackEntry.m_scope-&gt;deref();
      RELEASE_ASSERT(stackEntry.m_isWithScope);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3638,21 ***</span>
              return result; // may be null.
      }
      return nullptr;
  }
  
<span class="line-removed">- void BytecodeGenerator::allocateCalleeSaveSpace()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     size_t virtualRegisterCountForCalleeSaves = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (size_t i = 0; i &lt; virtualRegisterCountForCalleeSaves; i++) {</span>
<span class="line-removed">-         RegisterID* localRegister = addVar();</span>
<span class="line-removed">-         localRegister-&gt;ref();</span>
<span class="line-removed">-         m_localRegistersForCalleeSaveRegisters.append(localRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void BytecodeGenerator::allocateAndEmitScope()
  {
      m_scopeRegister = addVar();
      m_scopeRegister-&gt;ref();
      m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
<span class="line-new-header">--- 3606,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3819,13 ***</span>
      VariableEnvironment nameScopeEnvironment;
      auto addResult = nameScopeEnvironment.add(property);
      if (isCaptured)
          addResult.iterator-&gt;value.setIsCaptured();
      addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
<span class="line-modified">!     unsigned numVars = m_codeBlock-&gt;m_numVars;</span>
      pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
<span class="line-modified">!     ASSERT_UNUSED(numVars, m_codeBlock-&gt;m_numVars == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.</span>
      bool shouldTreatAsLexicalVariable = isStrictMode();
      Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
      emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
  }
  
<span class="line-new-header">--- 3776,13 ---</span>
      VariableEnvironment nameScopeEnvironment;
      auto addResult = nameScopeEnvironment.add(property);
      if (isCaptured)
          addResult.iterator-&gt;value.setIsCaptured();
      addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
<span class="line-modified">!     unsigned numVars = m_codeBlock-&gt;numVars();</span>
      pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
<span class="line-modified">!     ASSERT_UNUSED(numVars, m_codeBlock-&gt;numVars() == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.</span>
      bool shouldTreatAsLexicalVariable = isStrictMode();
      Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
      emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3912,12 ***</span>
      UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
      const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
      int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
  {
      jumpTable.min = min;
<span class="line-modified">!     jumpTable.branchOffsets.resize(max - min + 1);</span>
<span class="line-modified">!     jumpTable.branchOffsets.fill(0);</span>
      for (uint32_t i = 0; i &lt; clauseCount; ++i) {
          // We&#39;re emitting this after the clause labels should have been fixed, so
          // the labels should not be &quot;forward&quot; references
          ASSERT(!labels[i]-&gt;isForward());
          jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
<span class="line-new-header">--- 3869,12 ---</span>
      UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
      const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
      int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
  {
      jumpTable.min = min;
<span class="line-modified">!     jumpTable.branchOffsets = RefCountedArray&lt;int32_t&gt;(max - min + 1);</span>
<span class="line-modified">!     std::fill(jumpTable.branchOffsets.begin(), jumpTable.branchOffsets.end(), 0);</span>
      for (uint32_t i = 0; i &lt; clauseCount; ++i) {
          // We&#39;re emitting this after the clause labels should have been fixed, so
          // the labels should not be &quot;forward&quot; references
          ASSERT(!labels[i]-&gt;isForward());
          jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4331,11 ***</span>
      m_forInContextStack.removeLast();
  }
  
  RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
  {
<span class="line-modified">!     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode);</span>
  
      return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
  }
  
  void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
<span class="line-new-header">--- 4288,11 ---</span>
      m_forInContextStack.removeLast();
  }
  
  RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
  {
<span class="line-modified">!     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode || m_codeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode);</span>
  
      return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
  }
  
  void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4355,10 ***</span>
<span class="line-new-header">--- 4312,18 ---</span>
  {
      Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
      return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
  }
  
<span class="line-added">+ RegisterID* BytecodeGenerator::emitLoadDerivedConstructor()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext());</span>
<span class="line-added">+     if (constructorKind() == ConstructorKind::Extends)</span>
<span class="line-added">+         return &amp;m_calleeRegister;</span>
<span class="line-added">+     return emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeGenerator::ensureThis()
  {
      if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
          if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
              emitLoadThisFromArrowFunctionLexicalEnvironment();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4459,19 ***</span>
      OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
      emitThrowTypeError(error);
      emitLabel(target.get());
  }
  
<span class="line-modified">! void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)</span>
  {
      Ref&lt;Label&gt; mergePoint = newLabel();
      unsigned yieldPointIndex = m_yieldPoints++;
      emitGeneratorStateChange(yieldPointIndex + 1);
  
      if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
          int suspendReason = static_cast&lt;int32_t&gt;(result);
<span class="line-modified">!         emitPutById(generatorRegister(), propertyNames().builtinNames().asyncGeneratorSuspendReasonPrivateName(), emitLoad(nullptr, jsNumber(suspendReason)));</span>
      }
  
      // Split the try range here.
      Ref&lt;Label&gt; savePoint = newEmittedLabel();
      for (unsigned i = m_tryContextStack.size(); i--;) {
<span class="line-new-header">--- 4424,19 ---</span>
      OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
      emitThrowTypeError(error);
      emitLabel(target.get());
  }
  
<span class="line-modified">! void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
  {
      Ref&lt;Label&gt; mergePoint = newLabel();
      unsigned yieldPointIndex = m_yieldPoints++;
      emitGeneratorStateChange(yieldPointIndex + 1);
  
      if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
          int suspendReason = static_cast&lt;int32_t&gt;(result);
<span class="line-modified">!         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::SuspendReason), emitLoad(nullptr, jsNumber(suspendReason)));</span>
      }
  
      // Split the try range here.
      Ref&lt;Label&gt; savePoint = newEmittedLabel();
      for (unsigned i = m_tryContextStack.size(); i--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4499,21 ***</span>
      // Restore the try contexts, which start offset is updated to the merge point.
      m_tryContextStack.swap(savedTryContextStack);
      emitLabel(mergePoint.get());
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason result)</span>
  {
      emitYieldPoint(argument, result);
  
      Ref&lt;Label&gt; normalLabel = newLabel();
      RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">!     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
      emitJumpIfTrue(condition.get(), normalLabel.get());
  
      Ref&lt;Label&gt; throwLabel = newLabel();
<span class="line-modified">!     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));</span>
      emitJumpIfTrue(condition.get(), throwLabel.get());
      // Return.
      {
          RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
          bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
<span class="line-new-header">--- 4464,21 ---</span>
      // Restore the try contexts, which start offset is updated to the merge point.
      m_tryContextStack.swap(savedTryContextStack);
      emitLabel(mergePoint.get());
  }
  
<span class="line-modified">! RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
  {
      emitYieldPoint(argument, result);
  
      Ref&lt;Label&gt; normalLabel = newLabel();
      RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">!     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
      emitJumpIfTrue(condition.get(), normalLabel.get());
  
      Ref&lt;Label&gt; throwLabel = newLabel();
<span class="line-modified">!     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
      emitJumpIfTrue(condition.get(), throwLabel.get());
      // Return.
      {
          RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
          bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4539,11 ***</span>
      return iterator;
  }
  
  void BytecodeGenerator::emitAwait(RegisterID* value)
  {
<span class="line-modified">!     emitYield(value, JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);</span>
      move(value, generatorValueRegister());
  }
  
  RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
  {
<span class="line-new-header">--- 4504,11 ---</span>
      return iterator;
  }
  
  void BytecodeGenerator::emitAwait(RegisterID* value)
  {
<span class="line-modified">!     emitYield(value, JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
      move(value, generatorValueRegister());
  }
  
  RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4568,14 ***</span>
      RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
      move(iterator.get(), commonIterator.get());
  
      RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
  
<span class="line-modified">!     auto varCreateAsyncFromSyncIterator = variable(propertyNames().builtinNames().createAsyncFromSyncIteratorPrivateName());</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; scope = newTemporary();</span>
<span class="line-removed">-     move(scope.get(), emitResolveScope(scope.get(), varCreateAsyncFromSyncIterator));</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = emitGetFromScope(newTemporary(), scope.get(), varCreateAsyncFromSyncIterator, ThrowIfNotFound);</span>
  
      CallArguments args(*this, nullptr, 2);
      emitLoad(args.thisRegister(), jsUndefined());
  
      move(args.argumentRegister(0), iterator.get());
<span class="line-new-header">--- 4533,11 ---</span>
      RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
      move(iterator.get(), commonIterator.get());
  
      RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
  
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = moveLinkTimeConstant(nullptr, LinkTimeConstant::createAsyncFromSyncIterator);</span>
  
      CallArguments args(*this, nullptr, 2);
      emitLoad(args.thisRegister(), jsUndefined());
  
      move(args.argumentRegister(0), iterator.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4611,20 ***</span>
              emitLabel(loopStart.get());
              emitLoopHint();
  
              Ref&lt;Label&gt; branchOnResult = newLabel();
              {
<span class="line-modified">!                 emitYieldPoint(value.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);</span>
  
                  Ref&lt;Label&gt; normalLabel = newLabel();
                  Ref&lt;Label&gt; returnLabel = newLabel();
                  {
                      RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">!                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
                      emitJumpIfTrue(condition.get(), normalLabel.get());
  
<span class="line-modified">!                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ReturnMode))));</span>
                      emitJumpIfTrue(condition.get(), returnLabel.get());
  
                      // Fallthrough to ThrowMode.
                  }
  
<span class="line-new-header">--- 4573,20 ---</span>
              emitLabel(loopStart.get());
              emitLoopHint();
  
              Ref&lt;Label&gt; branchOnResult = newLabel();
              {
<span class="line-modified">!                 emitYieldPoint(value.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
  
                  Ref&lt;Label&gt; normalLabel = newLabel();
                  Ref&lt;Label&gt; returnLabel = newLabel();
                  {
                      RefPtr&lt;RegisterID&gt; condition = newTemporary();
<span class="line-modified">!                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
                      emitJumpIfTrue(condition.get(), normalLabel.get());
  
<span class="line-modified">!                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ReturnMode))));</span>
                      emitJumpIfTrue(condition.get(), returnLabel.get());
  
                      // Fallthrough to ThrowMode.
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4722,11 ***</span>
  
  
  void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
  {
      RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
<span class="line-modified">!     emitPutById(generatorRegister(), propertyNames().builtinNames().generatorStatePrivateName(), completedState);</span>
  }
  
  bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
  {
      ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
<span class="line-new-header">--- 4684,12 ---</span>
  
  
  void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
  {
      RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
<span class="line-modified">!     static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::State) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::State));</span>
<span class="line-added">+     emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::State), completedState);</span>
  }
  
  bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
  {
      ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4980,11 ***</span>
  {
      ASSERT(m_optionalChainTargetStack.size());
      emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
  }
  
<span class="line-modified">! void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
      // either of the following conditions is true:
      //
      // (1) The loop iteration variable is re-assigned within the body of the loop.
<span class="line-new-header">--- 4943,11 ---</span>
  {
      ASSERT(m_optionalChainTargetStack.size());
      emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
  }
  
<span class="line-modified">! void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
      // either of the following conditions is true:
      //
      // (1) The loop iteration variable is re-assigned within the body of the loop.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4996,22 ***</span>
      // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
      // reassigned from its original value.
  
      for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
          auto instruction = generator.instructions().at(offset);
<span class="line-modified">!         OpcodeID opcodeID = instruction-&gt;opcodeID();</span>
<span class="line-modified">! </span>
<span class="line-removed">-         ASSERT(opcodeID != op_enter);</span>
<span class="line-removed">-         computeDefsForBytecodeOffset(codeBlock, opcodeID, instruction.ptr(), [&amp;] (VirtualRegister operand) {</span>
              if (local()-&gt;virtualRegister() == operand)
                  invalidate();
          });
          offset += instruction-&gt;size();
      }
  }
  
<span class="line-modified">! void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
      if (isValid())
          return;
  
<span class="line-new-header">--- 4959,20 ---</span>
      // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
      // reassigned from its original value.
  
      for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
          auto instruction = generator.instructions().at(offset);
<span class="line-modified">!         ASSERT(!instruction-&gt;is&lt;OpEnter&gt;());</span>
<span class="line-modified">!         computeDefsForBytecodeIndex(codeBlock, instruction.ptr(), [&amp;] (VirtualRegister operand) {</span>
              if (local()-&gt;virtualRegister() == operand)
                  invalidate();
          });
          offset += instruction-&gt;size();
      }
  }
  
<span class="line-modified">! void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
      if (isValid())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5046,11 ***</span>
          generator.m_lastOpcodeID = lastOpcodeID;
          generator.m_lastInstruction = lastInstruction;
      }
  }
  
<span class="line-modified">! void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlock* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
      if (isValid())
          return;
  
<span class="line-new-header">--- 5007,11 ---</span>
          generator.m_lastOpcodeID = lastOpcodeID;
          generator.m_lastInstruction = lastInstruction;
      }
  }
  
<span class="line-modified">! void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
  {
      Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
      if (isValid())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5085,11 ***</span>
  }
  
  void BytecodeGenerator::emitToThis()
  {
      OpToThis::emit(this, kill(&amp;m_thisRegister));
<span class="line-removed">-     m_codeBlock-&gt;addPropertyAccessInstruction(m_lastInstruction.offset());</span>
  }
  
  } // namespace JSC
  
  namespace WTF {
<span class="line-new-header">--- 5046,10 ---</span>
</pre>
<center><a href="../bytecode/Watchpoint.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGenerator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
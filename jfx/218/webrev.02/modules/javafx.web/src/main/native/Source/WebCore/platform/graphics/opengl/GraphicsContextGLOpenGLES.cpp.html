<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/opengl/GraphicsContextGLOpenGLES.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Apple Inc. All rights reserved.
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  * Copyright (C) 2012 ChangSeok Oh &lt;shivamidow@gmail.com&gt;
  5  * Copyright (C) 2012 Research In Motion Limited. All rights reserved.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 20  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 21  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 24  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;GraphicsContextGLOpenGL.h&quot;
 31 
 32 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(OPENGL_ES) &amp;&amp; !PLATFORM(IOS_FAMILY)
 33 
 34 #include &quot;ExtensionsGLOpenGLES.h&quot;
 35 #include &quot;IntRect.h&quot;
 36 #include &quot;IntSize.h&quot;
 37 #include &quot;NotImplemented.h&quot;
 38 
 39 #include &lt;ANGLE/ShaderLang.h&gt;
 40 
 41 namespace WebCore {
 42 
 43 void GraphicsContextGLOpenGL::releaseShaderCompiler()
 44 {
 45     makeContextCurrent();
 46     ::glReleaseShaderCompiler();
 47 }
 48 
 49 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, void* data)
 50 {
 51     makeContextCurrent();
 52 
 53     auto attributes = contextAttributes();
 54 
 55     // FIXME: remove the two glFlush calls when the driver bug is fixed, i.e.,
 56     // all previous rendering calls should be done before reading pixels.
 57     ::glFlush();
 58     if (attributes.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 59         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 60         ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
 61         ::glFlush();
 62     }
 63 
 64     ::glReadPixels(x, y, width, height, format, type, data);
 65 
 66     if (attributes.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 67         ::glBindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
 68 }
 69 
 70 void GraphicsContextGLOpenGL::readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels)
 71 {
 72     ::glReadPixels(x, y, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
 73     int totalBytes = width * height * 4;
 74     if (isGLES2Compliant()) {
 75         for (int i = 0; i &lt; totalBytes; i += 4)
 76             std::swap(pixels[i], pixels[i + 2]); // Convert to BGRA.
 77     }
 78 }
 79 
 80 bool GraphicsContextGLOpenGL::reshapeFBOs(const IntSize&amp; size)
 81 {
 82     const int width = size.width();
 83     const int height = size.height();
 84     GLuint colorFormat = 0;
 85     auto attributes = contextAttributes();
 86 
 87     if (attributes.alpha) {
 88         m_internalColorFormat = GL_RGBA;
 89         colorFormat = GL_RGBA;
 90     } else {
 91         m_internalColorFormat = GL_RGB;
 92         colorFormat = GL_RGB;
 93     }
 94 
 95     // We don&#39;t allow the logic where stencil is required and depth is not.
 96     // See GraphicsContextGLOpenGL::validateAttributes.
 97     bool supportPackedDepthStencilBuffer = (attributes.stencil || attributes.depth) &amp;&amp; getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;);
 98 
 99     // Resize regular FBO.
100     bool mustRestoreFBO = false;
101     if (m_state.boundFBO != m_fbo) {
102         mustRestoreFBO = true;
103         ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
104     }
105 
106     ASSERT(m_texture);
107     ::glBindTexture(GL_TEXTURE_2D, m_texture);
108     ::glTexImage2D(GL_TEXTURE_2D, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
109     ::glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_texture, 0);
110 
111 #if USE(COORDINATED_GRAPHICS)
112     if (m_compositorTexture) {
113         ::glBindTexture(GL_TEXTURE_2D, m_compositorTexture);
114         ::glTexImage2D(GL_TEXTURE_2D, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
115         ::glBindTexture(GL_TEXTURE_2D, 0);
116     }
117 
118     ::glBindTexture(GL_TEXTURE_2D, m_intermediateTexture);
119     ::glTexImage2D(GL_TEXTURE_2D, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
120     ::glBindTexture(GL_TEXTURE_2D, 0);
121 #endif
122 
123     ExtensionsGLOpenGLES&amp; extensions = static_cast&lt;ExtensionsGLOpenGLES&amp;&gt;(getExtensions());
124     if (extensions.isImagination() &amp;&amp; attributes.antialias) {
125         GLint maxSampleCount;
126         ::glGetIntegerv(ExtensionsGL::MAX_SAMPLES_IMG, &amp;maxSampleCount);
127         GLint sampleCount = std::min(8, maxSampleCount);
128 
129         extensions.framebufferTexture2DMultisampleIMG(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_texture, 0, sampleCount);
130 
131         if (attributes.stencil || attributes.depth) {
132             // Use a 24 bit depth buffer where we know we have it.
133             if (supportPackedDepthStencilBuffer) {
134                 ::glBindRenderbuffer(GL_RENDERBUFFER, m_depthStencilBuffer);
135                 extensions.renderbufferStorageMultisample(GL_RENDERBUFFER, sampleCount, GL_DEPTH24_STENCIL8_OES, width, height);
136                 if (attributes.stencil)
137                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
138                 if (attributes.depth)
139                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
140             } else {
141                 if (attributes.stencil) {
142                     ::glBindRenderbuffer(GL_RENDERBUFFER, m_stencilBuffer);
143                     extensions.renderbufferStorageMultisample(GL_RENDERBUFFER, sampleCount, GL_STENCIL_INDEX8, width, height);
144                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_stencilBuffer);
145                 }
146                 if (attributes.depth) {
147                     ::glBindRenderbuffer(GL_RENDERBUFFER, m_depthBuffer);
148                     extensions.renderbufferStorageMultisample(GL_RENDERBUFFER, sampleCount, GL_DEPTH_COMPONENT16, width, height);
149                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthBuffer);
150                 }
151             }
152             ::glBindRenderbuffer(GL_RENDERBUFFER, 0);
153         }
154     } else {
155         if (attributes.stencil || attributes.depth) {
156             // Use a 24 bit depth buffer where we know we have it.
157             if (supportPackedDepthStencilBuffer) {
158                 ::glBindRenderbuffer(GL_RENDERBUFFER, m_depthStencilBuffer);
159                 ::glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, width, height);
160                 if (attributes.stencil)
161                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
162                 if (attributes.depth)
163                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
164             } else {
165                 if (attributes.stencil) {
166                     ::glBindRenderbuffer(GL_RENDERBUFFER, m_stencilBuffer);
167                     ::glRenderbufferStorage(GL_RENDERBUFFER, GL_STENCIL_INDEX8, width, height);
168                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_stencilBuffer);
169                 }
170                 if (attributes.depth) {
171                     ::glBindRenderbuffer(GL_RENDERBUFFER, m_depthBuffer);
172                     ::glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, width, height);
173                     ::glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthBuffer);
174                 }
175             }
176             ::glBindRenderbuffer(GL_RENDERBUFFER, 0);
177         }
178     }
179     if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
180         // FIXME: cleanup
181         notImplemented();
182     }
183 
184     return mustRestoreFBO;
185 }
186 
187 void GraphicsContextGLOpenGL::resolveMultisamplingIfNecessary(const IntRect&amp;)
188 {
189     // FIXME: We don&#39;t support antialiasing yet.
190     notImplemented();
191 }
192 
193 void GraphicsContextGLOpenGL::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
194 {
195     makeContextCurrent();
196     ::glRenderbufferStorage(target, internalformat, width, height);
197 }
198 
199 void GraphicsContextGLOpenGL::getIntegerv(GCGLenum pname, GCGLint* value)
200 {
201     makeContextCurrent();
202     ::glGetIntegerv(pname, value);
203 }
204 
205 void GraphicsContextGLOpenGL::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType, GCGLint* range, GCGLint* precision)
206 {
207     ASSERT(range);
208     ASSERT(precision);
209 
210     makeContextCurrent();
211     ::glGetShaderPrecisionFormat(shaderType, precisionType, range, precision);
212 }
213 
214 bool GraphicsContextGLOpenGL::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
215 {
216     if (width &amp;&amp; height &amp;&amp; !pixels) {
217         synthesizeGLError(INVALID_VALUE);
218         return false;
219     }
220 
221     texImage2DDirect(target, level, internalformat, width, height, border, format, type, pixels);
222     return true;
223 }
224 
225 void GraphicsContextGLOpenGL::validateAttributes()
226 {
227     validateDepthStencil(&quot;GL_OES_packed_depth_stencil&quot;);
228 
229     auto attributes = contextAttributes();
230 
231     if (attributes.antialias &amp;&amp; !getExtensions().supports(&quot;GL_IMG_multisampled_render_to_texture&quot;)) {
232         attributes.antialias = false;
233         setContextAttributes(attributes);
234     }
235 }
236 
237 void GraphicsContextGLOpenGL::depthRange(GCGLclampf zNear, GCGLclampf zFar)
238 {
239     makeContextCurrent();
240     ::glDepthRangef(zNear, zFar);
241 }
242 
243 void GraphicsContextGLOpenGL::clearDepth(GCGLclampf depth)
244 {
245     makeContextCurrent();
246     ::glClearDepthf(depth);
247 }
248 
249 #if !PLATFORM(GTK)
250 ExtensionsGL&amp; GraphicsContextGLOpenGL::getExtensions()
251 {
252     if (!m_extensions)
253         m_extensions = makeUnique&lt;ExtensionsGLOpenGLES&gt;(this, isGLES2Compliant());
254     return *m_extensions;
255 }
256 #endif
257 
258 #if PLATFORM(WIN) &amp;&amp; USE(CA)
259 RefPtr&lt;GraphicsContextGLOpenGL&gt; GraphicsContextGLOpenGL::create(GraphicsContextGLAttributes attributes, HostWindow* hostWindow, GraphicsContextGLOpenGL::Destination destination)
260 {
261     // This implementation doesn&#39;t currently support rendering directly to the HostWindow.
262     if (destination == Destination::DirectlyToHostWindow)
263         return nullptr;
264 
265     static bool initialized = false;
266     static bool success = true;
267     if (!initialized) {
268 #if !USE(OPENGL_ES)
269         success = initializeOpenGLShims();
270 #endif
271         initialized = true;
272     }
273     if (!success)
274         return nullptr;
275 
276     return adoptRef(new GraphicsContextGLOpenGL(attributes, hostWindow, renderStyle));
277 }
278 
279 GraphicsContextGLOpenGL::GraphicsContextGLOpenGL(GraphicsContextGLAttributes attributes, HostWindow*, GraphicsContextGLOpenGL::Destination destination, GraphicsContextGLOpenGL* sharedContext)
280     : GraphicsContextGL(attributes, destination, sharedContext)
281     , m_compiler(isGLES2Compliant() ? SH_ESSL_OUTPUT : SH_GLSL_COMPATIBILITY_OUTPUT)
282     , m_private(makeUnique&lt;GraphicsContextGLOpenGLPrivate&gt;(this, destination))
283 {
284     ASSERT_UNUSED(sharedContext, !sharedContext);
285     makeContextCurrent();
286 
287     validateAttributes();
288     attributes = contextAttributes(); // They may have changed during validation.
289 
290     if (destination == Destination::Offscreen) {
291         // Create a texture to render into.
292         ::glGenTextures(1, &amp;m_texture);
293         ::glBindTexture(GL_TEXTURE_2D, m_texture);
294         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
295         ::glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
296         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
297         ::glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
298         ::glBindTexture(GL_TEXTURE_2D, 0);
299 
300         // Create an FBO.
301         ::glGenFramebuffers(1, &amp;m_fbo);
302         ::glBindFramebuffer(GL_FRAMEBUFFER, m_fbo);
303 
304         m_state.boundFBO = m_fbo;
305         if (!attributes.antialias &amp;&amp; (attributes.stencil || attributes.depth))
306             ::glGenRenderbuffers(1, &amp;m_depthStencilBuffer);
307 
308         // Create a multisample FBO.
309         if (attributes.antialias) {
310             ::glGenFramebuffers(1, &amp;m_multisampleFBO);
311             ::glBindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
312             m_state.boundFBO = m_multisampleFBO;
313             ::glGenRenderbuffers(1, &amp;m_multisampleColorBuffer);
314             if (attributes.stencil || attributes.depth)
315                 ::glGenRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
316         }
317     }
318 
319     // ANGLE initialization.
320     ShBuiltInResources ANGLEResources;
321     ShInitBuiltInResources(&amp;ANGLEResources);
322 
323     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_ATTRIBS, &amp;ANGLEResources.MaxVertexAttribs);
324     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_UNIFORM_VECTORS, &amp;ANGLEResources.MaxVertexUniformVectors);
325     getIntegerv(GraphicsContextGLOpenGL::MAX_VARYING_VECTORS, &amp;ANGLEResources.MaxVaryingVectors);
326     getIntegerv(GraphicsContextGLOpenGL::MAX_VERTEX_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxVertexTextureImageUnits);
327     getIntegerv(GraphicsContextGLOpenGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxCombinedTextureImageUnits);
328     getIntegerv(GraphicsContextGLOpenGL::MAX_TEXTURE_IMAGE_UNITS, &amp;ANGLEResources.MaxTextureImageUnits);
329     getIntegerv(GraphicsContextGLOpenGL::MAX_FRAGMENT_UNIFORM_VECTORS, &amp;ANGLEResources.MaxFragmentUniformVectors);
330 
331     // Always set to 1 for OpenGL ES.
332     ANGLEResources.MaxDrawBuffers = 1;
333 
334     GCGLint range[2], precision;
335     getShaderPrecisionFormat(GraphicsContextGLOpenGL::FRAGMENT_SHADER, GraphicsContextGLOpenGL::HIGH_FLOAT, range, &amp;precision);
336     ANGLEResources.FragmentPrecisionHigh = (range[0] || range[1] || precision);
337 
338     m_compiler.setResources(ANGLEResources);
339 
340 #if !USE(OPENGL_ES)
341     ::glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
342     ::glEnable(GL_POINT_SPRITE);
343 #endif
344 
345     ::glClearColor(0, 0, 0, 0);
346 }
347 
348 GraphicsContextGLOpenGL::~GraphicsContextGLOpenGL()
349 {
350     makeContextCurrent();
351     ::glDeleteTextures(1, &amp;m_texture);
352 
353     auto attributes = contextAttributes();
354 
355     if (attributes.antialias) {
356         ::glDeleteRenderbuffers(1, &amp;m_multisampleColorBuffer);
357         if (attributes.stencil || attributes.depth)
358             ::glDeleteRenderbuffers(1, &amp;m_multisampleDepthStencilBuffer);
359         ::glDeleteFramebuffers(1, &amp;m_multisampleFBO);
360     } else {
361         if (attributes.stencil || attributes.depth)
362             ::glDeleteRenderbuffers(1, &amp;m_depthStencilBuffer);
363     }
364     ::glDeleteFramebuffers(1, &amp;m_fbo);
365 }
366 
367 void GraphicsContextGLOpenGL::setContextLostCallback(std::unique_ptr&lt;ContextLostCallback&gt;)
368 {
369 }
370 
371 void GraphicsContextGLOpenGL::setErrorMessageCallback(std::unique_ptr&lt;ErrorMessageCallback&gt;)
372 {
373 }
374 
375 bool GraphicsContextGLOpenGL::makeContextCurrent()
376 {
377     if (!m_private)
378         return false;
379     return m_private-&gt;makeContextCurrent();
380 }
381 
382 void GraphicsContextGLOpenGL::checkGPUStatus()
383 {
384 }
385 
386 PlatformGraphicsContextGL GraphicsContextGLOpenGL::platformGraphicsContextGL()
387 {
388     return m_private-&gt;platformContext();
389 }
390 
391 PlatformGLObject GraphicsContextGLOpenGL::platformTexture() const
392 {
393     return m_texture;
394 }
395 
396 bool GraphicsContextGLOpenGL::isGLES2Compliant() const
397 {
398 #if USE(OPENGL_ES)
399     return true;
400 #else
401     return false;
402 #endif
403 }
404 
405 PlatformLayer* GraphicsContextGLOpenGL::platformLayer() const
406 {
407     return m_webGLLayer-&gt;platformLayer();
408 }
409 #endif
410 
411 }
412 
413 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(OPENGL_ES) &amp;&amp; !PLATFORM(IOS_FAMILY)
    </pre>
  </body>
</html>
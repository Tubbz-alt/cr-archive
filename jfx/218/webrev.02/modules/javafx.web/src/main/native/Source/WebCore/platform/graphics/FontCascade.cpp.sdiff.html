<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCascade.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
  41 #include &lt;wtf/text/AtomStringHash.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
<span class="line-removed">  44 #if PLATFORM(WIN)</span>
<span class="line-removed">  45 #include &quot;UniscribeController.h&quot;</span>
<span class="line-removed">  46 #endif</span>
<span class="line-removed">  47 </span>
  48 namespace WebCore {
  49 
  50 using namespace WTF::Unicode;
  51 
  52 static bool useBackslashAsYenSignForFamily(const AtomString&amp; family)
  53 {
  54     if (family.isEmpty())
  55         return false;
  56     static const auto set = makeNeverDestroyed([] {
  57         HashSet&lt;AtomString&gt; set;
  58         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  59             unsigned nameLength = strlen(name);
  60             set.add(AtomString { name, nameLength, AtomString::ConstructFromLiteral });
  61             unsigned unicodeNameLength = unicodeName.size();
  62             set.add(AtomString { unicodeName.begin(), unicodeNameLength });
  63         };
  64         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  65         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  66         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  67         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
</pre>
<hr />
<pre>
 252     auto addResult = fontCascadeCache().add(hash, nullptr);
 253     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 254         return addResult.iterator-&gt;value-&gt;fonts.get();
 255 
 256     auto&amp; newEntry = addResult.iterator-&gt;value;
 257     newEntry = makeUnique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));
 258     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 259 
 260     static const unsigned unreferencedPruneInterval = 50;
 261     static const int maximumEntries = 400;
 262     static unsigned pruneCounter;
 263     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 264     if (!(++pruneCounter % unreferencedPruneInterval))
 265         pruneUnreferencedEntriesFromFontCascadeCache();
 266     // Prevent pathological growth.
 267     if (fontCascadeCache().size() &gt; maximumEntries)
 268         fontCascadeCache().remove(fontCascadeCache().random());
 269     return glyphs;
 270 }
 271 












 272 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 273 {
 274     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 275     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 276     m_enableKerning = computeEnableKerning();
 277     m_requiresShaping = computeRequiresShaping();
 278 }
 279 
<span class="line-modified"> 280 float FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer) const</span>
 281 {
 282     if (codePathToUse != Complex)
<span class="line-modified"> 283         return getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer);</span>
 284     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 285 }
 286 
 287 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 288 {
 289     unsigned destination = to.valueOr(run.length());
 290     GlyphBuffer glyphBuffer;
<span class="line-modified"> 291     float startX = point.x() + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);</span>
 292     // We couldn&#39;t generate any glyphs for the run. Give up.
 293     if (glyphBuffer.isEmpty())
 294         return 0;
 295     // Draw the glyph buffer now at the starting point returned in startX.
<span class="line-modified"> 296     FloatPoint startPoint(startX, point.y());</span>
 297     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
<span class="line-modified"> 298     return startPoint.x() - startX;</span>
 299 }
 300 
 301 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const
 302 {
 303     if (isLoadingCustomFonts())
 304         return;
 305 
 306     unsigned destination = to.valueOr(run.length());
 307     if (codePath(run, from, to) != Complex)
 308         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 309     else
 310         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 311 }
 312 
 313 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 314 {
 315     ASSERT(!context.paintingDisabled());
 316     unsigned destination = to.valueOr(run.length());
 317 
 318     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 319     CodePath codePathToUse = codePath(run);
 320     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 321         codePathToUse = Complex;
 322 
 323     GlyphBuffer glyphBuffer;
<span class="line-modified"> 324     float startX = glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer);</span>
 325     // We couldn&#39;t generate any glyphs for the run. Give up.
 326     if (glyphBuffer.isEmpty())
 327         return nullptr;
 328 
 329     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = makeUnique&lt;DisplayList::DisplayList&gt;();
 330     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
 331         return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());
 332     });
 333 
<span class="line-removed"> 334     FloatPoint startPoint(startX, 0);</span>
 335     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 336     return displayList;
 337 }
 338 
 339 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 340 {
 341     ASSERT(from &lt;= to);
 342     ASSERT(to &lt;= run.length());
 343 
 344     if (!run.length())
 345         return 0;
 346 
 347     float offsetBeforeRange = 0;
 348     float offsetAfterRange = 0;
 349     float totalWidth = 0;
 350 
 351     auto codePathToUse = codePath(run);
 352     if (codePathToUse == Complex) {
<span class="line-removed"> 353 #if PLATFORM(WIN)</span>
<span class="line-removed"> 354         UniscribeController it(this, run);</span>
<span class="line-removed"> 355         it.advance(from);</span>
<span class="line-removed"> 356         offsetBeforeRange = it.runWidthSoFar();</span>
<span class="line-removed"> 357         it.advance(to);</span>
<span class="line-removed"> 358         offsetAfterRange = it.runWidthSoFar();</span>
<span class="line-removed"> 359         it.advance(to);</span>
<span class="line-removed"> 360         totalWidth = it.runWidthSoFar();</span>
<span class="line-removed"> 361 #else</span>
 362         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 363         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetBeforeRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 366         offsetAfterRange = complexIterator.runWidthSoFar();
 367         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 368         totalWidth = complexIterator.runWidthSoFar();
<span class="line-removed"> 369 #endif</span>
 370     } else {
 371         WidthIterator simpleIterator(this, run, fallbackFonts);
 372         simpleIterator.advance(from, nullptr);
 373         offsetBeforeRange = simpleIterator.runWidthSoFar();
 374         simpleIterator.advance(to, nullptr);
 375         offsetAfterRange = simpleIterator.runWidthSoFar();
 376         simpleIterator.advance(run.length(), nullptr);
 377         totalWidth = simpleIterator.runWidthSoFar();
 378     }
 379 
 380     if (outWidthBeforeRange)
 381         *outWidthBeforeRange = offsetBeforeRange;
 382 
 383     if (outWidthAfterRange)
 384         *outWidthAfterRange = totalWidth - offsetAfterRange;
 385 
 386     return offsetAfterRange - offsetBeforeRange;
 387 }
 388 
 389 float FontCascade::width(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
</pre>
<hr />
<pre>
 413     float result;
 414     if (codePathToUse == Complex)
 415         result = floatWidthForComplexText(run, fallbackFonts, glyphOverflow);
 416     else
 417         result = floatWidthForSimpleText(run, fallbackFonts, glyphOverflow);
 418 
 419     if (cacheEntry &amp;&amp; fallbackFonts-&gt;isEmpty())
 420         *cacheEntry = result;
 421     return result;
 422 }
 423 
 424 float FontCascade::widthForSimpleText(StringView text) const
 425 {
 426     if (text.isNull() || text.isEmpty())
 427         return 0;
 428     ASSERT(codePath(TextRun(text)) != FontCascade::Complex);
 429     float* cacheEntry = m_fonts-&gt;widthCache().add(text, std::numeric_limits&lt;float&gt;::quiet_NaN());
 430     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 431         return *cacheEntry;
 432 

 433     Vector&lt;GlyphBufferGlyph, 16&gt; glyphs;
 434     Vector&lt;GlyphBufferAdvance, 16&gt; advances;
 435     bool hasKerningOrLigatures = enableKerning() || requiresShaping();
 436     float runWidth = 0;
 437     auto&amp; font = primaryFont();
 438     for (unsigned i = 0; i &lt; text.length(); ++i) {
 439         auto glyph = glyphDataForCharacter(text[i], false).glyph;
 440         auto glyphWidth = font.widthForGlyph(glyph);
 441         runWidth += glyphWidth;
 442         if (!hasKerningOrLigatures)
 443             continue;
<span class="line-modified"> 444         glyphs.append(glyph);</span>
<span class="line-removed"> 445         advances.append(FloatSize(glyphWidth, 0));</span>
 446     }
 447     if (hasKerningOrLigatures) {
<span class="line-modified"> 448         font.applyTransforms(&amp;glyphs[0], &amp;advances[0], glyphs.size(), enableKerning(), requiresShaping());</span>
 449         // This is needed only to match the result of the slow path. Same glyph widths but different floating point arithmentics can
 450         // produce different run width.
 451         float runWidthDifferenceWithTransformApplied = -runWidth;
<span class="line-modified"> 452         for (auto&amp; advance : advances)</span>
<span class="line-modified"> 453             runWidthDifferenceWithTransformApplied += advance.width();</span>
 454         runWidth += runWidthDifferenceWithTransformApplied;
 455     }
 456 
 457     if (cacheEntry)
 458         *cacheEntry = runWidth;
 459     return runWidth;
 460 }
 461 
 462 GlyphData FontCascade::glyphDataForCharacter(UChar32 c, bool mirror, FontVariant variant) const
 463 {
 464     if (variant == AutoVariant) {
 465         if (m_fontDescription.variantCaps() == FontVariantCaps::Small) {
 466             UChar32 upperC = u_toupper(c);
 467             if (upperC != c) {
 468                 c = upperC;
 469                 variant = SmallCapsVariant;
 470             } else
 471                 variant = NormalVariant;
 472         } else
 473             variant = NormalVariant;
</pre>
<hr />
<pre>
1380     it.advance(to, &amp;glyphBuffer);
1381 
1382     if (glyphBuffer.isEmpty())
1383         return 0;
1384 
1385     float afterWidth = it.m_runWidthSoFar;
1386 
1387     if (run.rtl()) {
1388         float finalRoundingWidth = it.m_finalRoundingWidth;
1389         it.advance(run.length(), &amp;localGlyphBuffer);
1390         initialAdvance = finalRoundingWidth + it.m_runWidthSoFar - afterWidth;
1391     } else
1392         initialAdvance = beforeWidth;
1393 
1394     if (run.rtl())
1395         glyphBuffer.reverse(0, glyphBuffer.size());
1396 
1397     return initialAdvance;
1398 }
1399 
<span class="line-modified">1400 #if !PLATFORM(WIN)</span>
<span class="line-removed">1401 float FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const</span>
1402 {
<span class="line-modified">1403     float initialAdvance;</span>
1404 
1405     ComplexTextController controller(*this, run, false, 0, forTextEmphasis);
1406     GlyphBuffer dummyGlyphBuffer;
1407     controller.advance(from, &amp;dummyGlyphBuffer);
1408     controller.advance(to, &amp;glyphBuffer);
1409 
1410     if (glyphBuffer.isEmpty())
<span class="line-modified">1411         return 0;</span>
1412 
1413     if (run.rtl()) {
1414         // Exploit the fact that the sum of the paint advances is equal to
1415         // the sum of the layout advances.
<span class="line-modified">1416         initialAdvance = controller.totalWidth();</span>
1417         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<span class="line-modified">1418             initialAdvance -= dummyGlyphBuffer.advanceAt(i).width();</span>
1419         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
<span class="line-modified">1420             initialAdvance -= glyphBuffer.advanceAt(i).width();</span>
1421         glyphBuffer.reverse(0, glyphBuffer.size());
1422     } else {
<span class="line-modified">1423         initialAdvance = dummyGlyphBuffer.initialAdvance().width();</span>
1424         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<span class="line-modified">1425             initialAdvance += dummyGlyphBuffer.advanceAt(i).width();</span>
1426     }
1427 
1428     return initialAdvance;
1429 }
<span class="line-removed">1430 #endif</span>
1431 
1432 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1433 {
1434     GlyphBuffer glyphBuffer;
1435     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1436 
1437     if (glyphBuffer.isEmpty())
1438         return;
1439 
1440     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1441 }
1442 
1443 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1444 {
1445     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1446     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1447     // (in which case &quot;font&quot; will be a fallback font).
1448     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1449 }
1450 
1451 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1452 {
1453     // Draw each contiguous run of glyphs that use the same font data.
1454     const Font* fontData = glyphBuffer.fontAt(0);
<span class="line-modified">1455 #if PLATFORM(WIN)</span>
<span class="line-removed">1456     FloatPoint startPoint(point.x() + glyphBuffer.initialAdvance().width(), point.y() + glyphBuffer.initialAdvance().height());</span>
<span class="line-removed">1457 #else</span>
<span class="line-removed">1458     // FIXME: Why do we subtract the initial advance&#39;s height but not its width???</span>
<span class="line-removed">1459     // We should use the line above from Windows instead.</span>
<span class="line-removed">1460     FloatPoint startPoint(point.x(), point.y() - glyphBuffer.initialAdvance().height());</span>
<span class="line-removed">1461 #endif</span>
1462     float nextX = startPoint.x() + glyphBuffer.advanceAt(0).width();
1463     float nextY = startPoint.y() + glyphBuffer.advanceAt(0).height();
1464     unsigned lastFrom = 0;
1465     unsigned nextGlyph = 1;
1466     while (nextGlyph &lt; glyphBuffer.size()) {
1467         const Font* nextFontData = glyphBuffer.fontAt(nextGlyph);
1468 
1469         if (nextFontData != fontData) {
1470             if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1471                 context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1472 
1473             lastFrom = nextGlyph;
1474             fontData = nextFontData;
1475             startPoint.setX(nextX);
1476             startPoint.setY(nextY);
1477         }
1478         nextX += glyphBuffer.advanceAt(nextGlyph).width();
1479         nextY += glyphBuffer.advanceAt(nextGlyph).height();
1480         nextGlyph++;
1481     }
</pre>
<hr />
<pre>
1528 
1529     drawGlyphBuffer(context, markBuffer, startPoint, CustomFontNotReadyAction::DoNotPaintIfFontNotReady);
1530 }
1531 
1532 float FontCascade::floatWidthForSimpleText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1533 {
1534     WidthIterator it(this, run, fallbackFonts, glyphOverflow);
1535     GlyphBuffer glyphBuffer;
1536     it.advance(run.length(), (enableKerning() || requiresShaping()) ? &amp;glyphBuffer : nullptr);
1537 
1538     if (glyphOverflow) {
1539         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-it.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1540         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(it.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1541         glyphOverflow-&gt;left = ceilf(it.firstGlyphOverflow());
1542         glyphOverflow-&gt;right = ceilf(it.lastGlyphOverflow());
1543     }
1544 
1545     return it.m_runWidthSoFar;
1546 }
1547 
<span class="line-removed">1548 #if !PLATFORM(WIN)</span>
1549 float FontCascade::floatWidthForComplexText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1550 {
1551     ComplexTextController controller(*this, run, true, fallbackFonts);
1552     if (glyphOverflow) {
1553         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-controller.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1554         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(controller.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1555         glyphOverflow-&gt;left = std::max&lt;int&gt;(0, ceilf(-controller.minGlyphBoundingBoxX()));
<span class="line-modified">1556         glyphOverflow-&gt;right = std::max&lt;int&gt;(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalWidth()));</span>
1557     }
<span class="line-modified">1558     return controller.totalWidth();</span>
1559 }
<span class="line-removed">1560 #endif</span>
1561 
1562 void FontCascade::adjustSelectionRectForSimpleText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1563 {
1564     GlyphBuffer glyphBuffer;
1565     WidthIterator it(this, run);
1566     it.advance(from, &amp;glyphBuffer);
1567     float beforeWidth = it.m_runWidthSoFar;
1568     it.advance(to, &amp;glyphBuffer);
1569     float afterWidth = it.m_runWidthSoFar;
1570     float totalWidth = -1;
1571 
1572     if (run.rtl()) {
1573         it.advance(run.length(), &amp;glyphBuffer);
1574         totalWidth = it.m_runWidthSoFar;
1575         selectionRect.move(totalWidth - afterWidth, 0);
1576     } else
1577         selectionRect.move(beforeWidth, 0);
1578     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1579 }
1580 
<span class="line-removed">1581 #if !PLATFORM(WIN)</span>
1582 void FontCascade::adjustSelectionRectForComplexText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1583 {
1584     ComplexTextController controller(*this, run);
1585     controller.advance(from);
1586     float beforeWidth = controller.runWidthSoFar();
1587     controller.advance(to);
1588     float afterWidth = controller.runWidthSoFar();
1589 
1590     if (run.rtl())
<span class="line-modified">1591         selectionRect.move(controller.totalWidth() - afterWidth, 0);</span>
1592     else
1593         selectionRect.move(beforeWidth, 0);
1594     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1595 }
<span class="line-removed">1596 #endif</span>
1597 
1598 int FontCascade::offsetForPositionForSimpleText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1599 {
1600     float delta = x;
1601 
1602     WidthIterator it(this, run);
1603     GlyphBuffer localGlyphBuffer;
1604     unsigned offset;
1605     if (run.rtl()) {
1606         delta -= floatWidthForSimpleText(run);
1607         while (1) {
1608             offset = it.m_currentCharacter;
1609             float w;
1610             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1611                 break;
1612             delta += w;
1613             if (includePartialGlyphs) {
1614                 if (delta - w / 2 &gt;= 0)
1615                     break;
1616             } else {
</pre>
<hr />
<pre>
1621     } else {
1622         while (1) {
1623             offset = it.m_currentCharacter;
1624             float w;
1625             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1626                 break;
1627             delta -= w;
1628             if (includePartialGlyphs) {
1629                 if (delta + w / 2 &lt;= 0)
1630                     break;
1631             } else {
1632                 if (delta &lt;= 0)
1633                     break;
1634             }
1635         }
1636     }
1637 
1638     return offset;
1639 }
1640 
<span class="line-removed">1641 #if !PLATFORM(WIN)</span>
1642 int FontCascade::offsetForPositionForComplexText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1643 {
1644     ComplexTextController controller(*this, run);
1645     return controller.offsetForPosition(x, includePartialGlyphs);
1646 }
<span class="line-removed">1647 #endif</span>
1648 
1649 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1650 // FIXME: Unify this with the macOS and iOS implementation.
1651 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1652 {
1653     UChar32 baseCharacter;
1654     size_t baseCharacterLength = 0;
1655     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1656     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1657 
1658     if (!baseCharacterGlyphData.glyph)
1659         return nullptr;
1660     return baseCharacterGlyphData.font;
1661 }
1662 #endif
1663 
1664 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1665 {
1666     GlyphBuffer glyphBuffer;
<span class="line-modified">1667     float initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);</span>
1668 
1669     if (glyphBuffer.isEmpty())
1670         return;
1671 
<span class="line-modified">1672     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));</span>
1673 }
1674 
1675 struct GlyphIterationState {
1676     FloatPoint startingPoint;
1677     FloatPoint currentPoint;
1678     float y1;
1679     float y2;
1680     float minX;
1681     float maxX;
1682 };
1683 
1684 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
1685 {
1686     if ((p1.y() &lt; y &amp;&amp; p2.y() &gt; y) || (p1.y() &gt; y &amp;&amp; p2.y() &lt; y))
1687         return p1.x() + (y - p1.y()) * (p2.x() - p1.x()) / (p2.y() - p1.y());
1688     return WTF::nullopt;
1689 }
1690 
1691 static void updateX(GlyphIterationState&amp; state, float x)
1692 {
1693     state.minX = std::min(state.minX, x);
1694     state.maxX = std::max(state.maxX, x);
1695 }
1696 
1697 // This function is called by CGPathApply and is therefore invoked for each
1698 // contour in a glyph. This function models each contours as a straight line
1699 // and calculates the intersections between each pseudo-contour and
1700 // two horizontal lines (the upper and lower bounds of an underline) found in
1701 // GlyphIterationState::y1 and GlyphIterationState::y2. It keeps track of the
1702 // leftmost and rightmost intersection in GlyphIterationState::minX and
1703 // GlyphIterationState::maxX.
1704 static void findPathIntersections(GlyphIterationState&amp; state, const PathElement&amp; element)
1705 {
1706     bool doIntersection = false;
1707     FloatPoint point = FloatPoint();
1708     switch (element.type) {
<span class="line-modified">1709     case PathElementMoveToPoint:</span>
1710         state.startingPoint = element.points[0];
1711         state.currentPoint = element.points[0];
1712         break;
<span class="line-modified">1713     case PathElementAddLineToPoint:</span>
1714         doIntersection = true;
1715         point = element.points[0];
1716         break;
<span class="line-modified">1717     case PathElementAddQuadCurveToPoint:</span>
1718         doIntersection = true;
1719         point = element.points[1];
1720         break;
<span class="line-modified">1721     case PathElementAddCurveToPoint:</span>
1722         doIntersection = true;
1723         point = element.points[2];
1724         break;
<span class="line-modified">1725     case PathElementCloseSubpath:</span>
1726         doIntersection = true;
1727         point = state.startingPoint;
1728         break;
1729     }
1730     if (!doIntersection)
1731         return;
1732     if (auto intersectionPoint = findIntersectionPoint(state.y1, state.currentPoint, point))
1733         updateX(state, *intersectionPoint);
1734     if (auto intersectionPoint = findIntersectionPoint(state.y2, state.currentPoint, point))
1735         updateX(state, *intersectionPoint);
1736     if ((state.currentPoint.y() &gt;= state.y1 &amp;&amp; state.currentPoint.y() &lt;= state.y2)
1737         || (state.currentPoint.y() &lt;= state.y1 &amp;&amp; state.currentPoint.y() &gt;= state.y2))
1738         updateX(state, state.currentPoint.x());
1739     state.currentPoint = point;
1740 }
1741 
1742 class GlyphToPathTranslator {
1743 public:
1744     GlyphToPathTranslator(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, const FloatPoint&amp; textOrigin)
1745         : m_index(0)
</pre>
<hr />
<pre>
1790 void GlyphToPathTranslator::advance()
1791 {
1792     GlyphBufferAdvance advance = m_glyphBuffer.advanceAt(m_index);
1793     m_translation.translate(FloatSize(advance.width(), advance.height()));
1794     ++m_index;
1795     if (m_index &lt; m_glyphBuffer.size())
1796         m_fontData = m_glyphBuffer.fontAt(m_index);
1797 }
1798 
1799 DashArray FontCascade::dashesForIntersectionsWithRect(const TextRun&amp; run, const FloatPoint&amp; textOrigin, const FloatRect&amp; lineExtents) const
1800 {
1801     if (isLoadingCustomFonts())
1802         return DashArray();
1803 
1804     GlyphBuffer glyphBuffer;
1805     glyphBuffer.saveOffsetsInString();
1806     float deltaX;
1807     if (codePath(run) != FontCascade::Complex)
1808         deltaX = getGlyphsAndAdvancesForSimpleText(run, 0, run.length(), glyphBuffer);
1809     else
<span class="line-modified">1810         deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer);</span>
1811 
1812     if (!glyphBuffer.size())
1813         return DashArray();
1814 
1815     FloatPoint origin = FloatPoint(textOrigin.x() + deltaX, textOrigin.y());
1816     GlyphToPathTranslator translator(run, glyphBuffer, origin);
1817     DashArray result;
1818     for (unsigned index = 0; translator.containsMorePaths(); ++index, translator.advance()) {
1819         GlyphIterationState info = { FloatPoint(0, 0), FloatPoint(0, 0), lineExtents.y(), lineExtents.y() + lineExtents.height(), lineExtents.x() + lineExtents.width(), lineExtents.x() };
1820         const Font* localFont = glyphBuffer.fontAt(index);
1821         if (!localFont) {
1822             // The advances will get all messed up if we do anything other than bail here.
1823             result.clear();
1824             break;
1825         }
1826         switch (translator.underlineType()) {
1827         case GlyphUnderlineType::SkipDescenders: {
1828             Path path = translator.path();
1829             path.apply([&amp;](const PathElement&amp; element) {
1830                 findPathIntersections(info, element);
</pre>
</td>
<td>
<hr />
<pre>
  24 #include &quot;config.h&quot;
  25 #include &quot;FontCascade.h&quot;
  26 
  27 #include &quot;CharacterProperties.h&quot;
  28 #include &quot;ComplexTextController.h&quot;
  29 #include &quot;DisplayListRecorder.h&quot;
  30 #include &quot;FloatRect.h&quot;
  31 #include &quot;FontCache.h&quot;
  32 #include &quot;GlyphBuffer.h&quot;
  33 #include &quot;GraphicsContext.h&quot;
  34 #include &quot;LayoutRect.h&quot;
  35 #include &quot;SurrogatePairAwareTextIterator.h&quot;
  36 #include &quot;TextRun.h&quot;
  37 #include &quot;WidthIterator.h&quot;
  38 #include &lt;wtf/MainThread.h&gt;
  39 #include &lt;wtf/MathExtras.h&gt;
  40 #include &lt;wtf/NeverDestroyed.h&gt;
  41 #include &lt;wtf/text/AtomStringHash.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 




  44 namespace WebCore {
  45 
  46 using namespace WTF::Unicode;
  47 
  48 static bool useBackslashAsYenSignForFamily(const AtomString&amp; family)
  49 {
  50     if (family.isEmpty())
  51         return false;
  52     static const auto set = makeNeverDestroyed([] {
  53         HashSet&lt;AtomString&gt; set;
  54         auto add = [&amp;set] (const char* name, std::initializer_list&lt;UChar&gt; unicodeName) {
  55             unsigned nameLength = strlen(name);
  56             set.add(AtomString { name, nameLength, AtomString::ConstructFromLiteral });
  57             unsigned unicodeNameLength = unicodeName.size();
  58             set.add(AtomString { unicodeName.begin(), unicodeNameLength });
  59         };
  60         add(&quot;MS PGothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  61         add(&quot;MS PMincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0xFF30, 0x660E, 0x671D });
  62         add(&quot;MS Gothic&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x30B4, 0x30B7, 0x30C3, 0x30AF });
  63         add(&quot;MS Mincho&quot;, { 0xFF2D, 0xFF33, 0x0020, 0x660E, 0x671D });
</pre>
<hr />
<pre>
 248     auto addResult = fontCascadeCache().add(hash, nullptr);
 249     if (!addResult.isNewEntry &amp;&amp; keysMatch(addResult.iterator-&gt;value-&gt;key, key))
 250         return addResult.iterator-&gt;value-&gt;fonts.get();
 251 
 252     auto&amp; newEntry = addResult.iterator-&gt;value;
 253     newEntry = makeUnique&lt;FontCascadeCacheEntry&gt;(WTFMove(key), FontCascadeFonts::create(WTFMove(fontSelector)));
 254     Ref&lt;FontCascadeFonts&gt; glyphs = newEntry-&gt;fonts.get();
 255 
 256     static const unsigned unreferencedPruneInterval = 50;
 257     static const int maximumEntries = 400;
 258     static unsigned pruneCounter;
 259     // Referenced FontCascadeFonts would exist anyway so pruning them saves little memory.
 260     if (!(++pruneCounter % unreferencedPruneInterval))
 261         pruneUnreferencedEntriesFromFontCascadeCache();
 262     // Prevent pathological growth.
 263     if (fontCascadeCache().size() &gt; maximumEntries)
 264         fontCascadeCache().remove(fontCascadeCache().random());
 265     return glyphs;
 266 }
 267 
<span class="line-added"> 268 bool FontCascade::isCurrent(const FontSelector&amp; fontSelector) const</span>
<span class="line-added"> 269 {</span>
<span class="line-added"> 270     if (!m_fonts)</span>
<span class="line-added"> 271         return false;</span>
<span class="line-added"> 272     if (m_fonts-&gt;generation() != FontCache::singleton().generation())</span>
<span class="line-added"> 273         return false;</span>
<span class="line-added"> 274     if (m_fonts-&gt;fontSelectorVersion() != fontSelector.version())</span>
<span class="line-added"> 275         return false;</span>
<span class="line-added"> 276 </span>
<span class="line-added"> 277     return true;</span>
<span class="line-added"> 278 }</span>
<span class="line-added"> 279 </span>
 280 void FontCascade::update(RefPtr&lt;FontSelector&gt;&amp;&amp; fontSelector) const
 281 {
 282     m_fonts = retrieveOrAddCachedFonts(m_fontDescription, WTFMove(fontSelector));
 283     m_useBackslashAsYenSymbol = useBackslashAsYenSignForFamily(firstFamily());
 284     m_enableKerning = computeEnableKerning();
 285     m_requiresShaping = computeRequiresShaping();
 286 }
 287 
<span class="line-modified"> 288 FloatSize FontCascade::glyphBufferForTextRun(CodePath codePathToUse, const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer) const</span>
 289 {
 290     if (codePathToUse != Complex)
<span class="line-modified"> 291         return { getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer), 0 };</span>
 292     return getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer);
 293 }
 294 
 295 float FontCascade::drawText(GraphicsContext&amp; context, const TextRun&amp; run, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 296 {
 297     unsigned destination = to.valueOr(run.length());
 298     GlyphBuffer glyphBuffer;
<span class="line-modified"> 299     FloatPoint startPoint = point + glyphBufferForTextRun(codePath(run, from, to), run, from, destination, glyphBuffer);</span>
 300     // We couldn&#39;t generate any glyphs for the run. Give up.
 301     if (glyphBuffer.isEmpty())
 302         return 0;
 303     // Draw the glyph buffer now at the starting point returned in startX.
<span class="line-modified"> 304     float oldStartX = startPoint.x();</span>
 305     drawGlyphBuffer(context, glyphBuffer, startPoint, customFontNotReadyAction);
<span class="line-modified"> 306     return startPoint.x() - oldStartX;</span>
 307 }
 308 
 309 void FontCascade::drawEmphasisMarks(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, Optional&lt;unsigned&gt; to) const
 310 {
 311     if (isLoadingCustomFonts())
 312         return;
 313 
 314     unsigned destination = to.valueOr(run.length());
 315     if (codePath(run, from, to) != Complex)
 316         drawEmphasisMarksForSimpleText(context, run, mark, point, from, destination);
 317     else
 318         drawEmphasisMarksForComplexText(context, run, mark, point, from, destination);
 319 }
 320 
 321 std::unique_ptr&lt;DisplayList::DisplayList&gt; FontCascade::displayListForTextRun(GraphicsContext&amp; context, const TextRun&amp; run, unsigned from, Optional&lt;unsigned&gt; to, CustomFontNotReadyAction customFontNotReadyAction) const
 322 {
 323     ASSERT(!context.paintingDisabled());
 324     unsigned destination = to.valueOr(run.length());
 325 
 326     // FIXME: Use the fast code path once it handles partial runs with kerning and ligatures. See http://webkit.org/b/100050
 327     CodePath codePathToUse = codePath(run);
 328     if (codePathToUse != Complex &amp;&amp; (enableKerning() || requiresShaping()) &amp;&amp; (from || destination != run.length()))
 329         codePathToUse = Complex;
 330 
 331     GlyphBuffer glyphBuffer;
<span class="line-modified"> 332     FloatPoint startPoint = toFloatPoint(glyphBufferForTextRun(codePathToUse, run, from, destination, glyphBuffer));</span>
 333     // We couldn&#39;t generate any glyphs for the run. Give up.
 334     if (glyphBuffer.isEmpty())
 335         return nullptr;
 336 
 337     std::unique_ptr&lt;DisplayList::DisplayList&gt; displayList = makeUnique&lt;DisplayList::DisplayList&gt;();
 338     GraphicsContext recordingContext([&amp;](GraphicsContext&amp; displayListContext) {
 339         return makeUnique&lt;DisplayList::Recorder&gt;(displayListContext, *displayList, context.state(), FloatRect(), AffineTransform());
 340     });
 341 

 342     drawGlyphBuffer(recordingContext, glyphBuffer, startPoint, customFontNotReadyAction);
 343     return displayList;
 344 }
 345 
 346 float FontCascade::widthOfTextRange(const TextRun&amp; run, unsigned from, unsigned to, HashSet&lt;const Font*&gt;* fallbackFonts, float* outWidthBeforeRange, float* outWidthAfterRange) const
 347 {
 348     ASSERT(from &lt;= to);
 349     ASSERT(to &lt;= run.length());
 350 
 351     if (!run.length())
 352         return 0;
 353 
 354     float offsetBeforeRange = 0;
 355     float offsetAfterRange = 0;
 356     float totalWidth = 0;
 357 
 358     auto codePathToUse = codePath(run);
 359     if (codePathToUse == Complex) {









 360         ComplexTextController complexIterator(*this, run, false, fallbackFonts);
 361         complexIterator.advance(from, nullptr, IncludePartialGlyphs, fallbackFonts);
 362         offsetBeforeRange = complexIterator.runWidthSoFar();
 363         complexIterator.advance(to, nullptr, IncludePartialGlyphs, fallbackFonts);
 364         offsetAfterRange = complexIterator.runWidthSoFar();
 365         complexIterator.advance(run.length(), nullptr, IncludePartialGlyphs, fallbackFonts);
 366         totalWidth = complexIterator.runWidthSoFar();

 367     } else {
 368         WidthIterator simpleIterator(this, run, fallbackFonts);
 369         simpleIterator.advance(from, nullptr);
 370         offsetBeforeRange = simpleIterator.runWidthSoFar();
 371         simpleIterator.advance(to, nullptr);
 372         offsetAfterRange = simpleIterator.runWidthSoFar();
 373         simpleIterator.advance(run.length(), nullptr);
 374         totalWidth = simpleIterator.runWidthSoFar();
 375     }
 376 
 377     if (outWidthBeforeRange)
 378         *outWidthBeforeRange = offsetBeforeRange;
 379 
 380     if (outWidthAfterRange)
 381         *outWidthAfterRange = totalWidth - offsetAfterRange;
 382 
 383     return offsetAfterRange - offsetBeforeRange;
 384 }
 385 
 386 float FontCascade::width(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
</pre>
<hr />
<pre>
 410     float result;
 411     if (codePathToUse == Complex)
 412         result = floatWidthForComplexText(run, fallbackFonts, glyphOverflow);
 413     else
 414         result = floatWidthForSimpleText(run, fallbackFonts, glyphOverflow);
 415 
 416     if (cacheEntry &amp;&amp; fallbackFonts-&gt;isEmpty())
 417         *cacheEntry = result;
 418     return result;
 419 }
 420 
 421 float FontCascade::widthForSimpleText(StringView text) const
 422 {
 423     if (text.isNull() || text.isEmpty())
 424         return 0;
 425     ASSERT(codePath(TextRun(text)) != FontCascade::Complex);
 426     float* cacheEntry = m_fonts-&gt;widthCache().add(text, std::numeric_limits&lt;float&gt;::quiet_NaN());
 427     if (cacheEntry &amp;&amp; !std::isnan(*cacheEntry))
 428         return *cacheEntry;
 429 
<span class="line-added"> 430     GlyphBuffer glyphBuffer;</span>
 431     Vector&lt;GlyphBufferGlyph, 16&gt; glyphs;
 432     Vector&lt;GlyphBufferAdvance, 16&gt; advances;
 433     bool hasKerningOrLigatures = enableKerning() || requiresShaping();
 434     float runWidth = 0;
 435     auto&amp; font = primaryFont();
 436     for (unsigned i = 0; i &lt; text.length(); ++i) {
 437         auto glyph = glyphDataForCharacter(text[i], false).glyph;
 438         auto glyphWidth = font.widthForGlyph(glyph);
 439         runWidth += glyphWidth;
 440         if (!hasKerningOrLigatures)
 441             continue;
<span class="line-modified"> 442         glyphBuffer.add(glyph, &amp;font, glyphWidth);</span>

 443     }
 444     if (hasKerningOrLigatures) {
<span class="line-modified"> 445         font.applyTransforms(glyphBuffer, 0, enableKerning(), requiresShaping(), fontDescription().locale());</span>
 446         // This is needed only to match the result of the slow path. Same glyph widths but different floating point arithmentics can
 447         // produce different run width.
 448         float runWidthDifferenceWithTransformApplied = -runWidth;
<span class="line-modified"> 449         for (size_t i = 0; i &lt; glyphBuffer.size(); ++i)</span>
<span class="line-modified"> 450             runWidthDifferenceWithTransformApplied += glyphBuffer.advanceAt(i).width();</span>
 451         runWidth += runWidthDifferenceWithTransformApplied;
 452     }
 453 
 454     if (cacheEntry)
 455         *cacheEntry = runWidth;
 456     return runWidth;
 457 }
 458 
 459 GlyphData FontCascade::glyphDataForCharacter(UChar32 c, bool mirror, FontVariant variant) const
 460 {
 461     if (variant == AutoVariant) {
 462         if (m_fontDescription.variantCaps() == FontVariantCaps::Small) {
 463             UChar32 upperC = u_toupper(c);
 464             if (upperC != c) {
 465                 c = upperC;
 466                 variant = SmallCapsVariant;
 467             } else
 468                 variant = NormalVariant;
 469         } else
 470             variant = NormalVariant;
</pre>
<hr />
<pre>
1377     it.advance(to, &amp;glyphBuffer);
1378 
1379     if (glyphBuffer.isEmpty())
1380         return 0;
1381 
1382     float afterWidth = it.m_runWidthSoFar;
1383 
1384     if (run.rtl()) {
1385         float finalRoundingWidth = it.m_finalRoundingWidth;
1386         it.advance(run.length(), &amp;localGlyphBuffer);
1387         initialAdvance = finalRoundingWidth + it.m_runWidthSoFar - afterWidth;
1388     } else
1389         initialAdvance = beforeWidth;
1390 
1391     if (run.rtl())
1392         glyphBuffer.reverse(0, glyphBuffer.size());
1393 
1394     return initialAdvance;
1395 }
1396 
<span class="line-modified">1397 FloatSize FontCascade::getGlyphsAndAdvancesForComplexText(const TextRun&amp; run, unsigned from, unsigned to, GlyphBuffer&amp; glyphBuffer, ForTextEmphasisOrNot forTextEmphasis) const</span>

1398 {
<span class="line-modified">1399     FloatSize initialAdvance;</span>
1400 
1401     ComplexTextController controller(*this, run, false, 0, forTextEmphasis);
1402     GlyphBuffer dummyGlyphBuffer;
1403     controller.advance(from, &amp;dummyGlyphBuffer);
1404     controller.advance(to, &amp;glyphBuffer);
1405 
1406     if (glyphBuffer.isEmpty())
<span class="line-modified">1407         return { };</span>
1408 
1409     if (run.rtl()) {
1410         // Exploit the fact that the sum of the paint advances is equal to
1411         // the sum of the layout advances.
<span class="line-modified">1412         initialAdvance = controller.totalAdvance();</span>
1413         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<span class="line-modified">1414             initialAdvance -= toFloatSize(dummyGlyphBuffer.advanceAt(i));</span>
1415         for (unsigned i = 0; i &lt; glyphBuffer.size(); ++i)
<span class="line-modified">1416             initialAdvance -= toFloatSize(glyphBuffer.advanceAt(i));</span>
1417         glyphBuffer.reverse(0, glyphBuffer.size());
1418     } else {
<span class="line-modified">1419         initialAdvance = toFloatSize(dummyGlyphBuffer.initialAdvance());</span>
1420         for (unsigned i = 0; i &lt; dummyGlyphBuffer.size(); ++i)
<span class="line-modified">1421             initialAdvance += toFloatSize(dummyGlyphBuffer.advanceAt(i));</span>
1422     }
1423 
1424     return initialAdvance;
1425 }

1426 
1427 void FontCascade::drawEmphasisMarksForSimpleText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1428 {
1429     GlyphBuffer glyphBuffer;
1430     float initialAdvance = getGlyphsAndAdvancesForSimpleText(run, from, to, glyphBuffer, ForTextEmphasis);
1431 
1432     if (glyphBuffer.isEmpty())
1433         return;
1434 
1435     drawEmphasisMarks(context, glyphBuffer, mark, FloatPoint(point.x() + initialAdvance, point.y()));
1436 }
1437 
1438 inline bool shouldDrawIfLoading(const Font&amp; font, FontCascade::CustomFontNotReadyAction customFontNotReadyAction)
1439 {
1440     // Don&#39;t draw anything while we are using custom fonts that are in the process of loading,
1441     // except if the &#39;customFontNotReadyAction&#39; argument is set to UseFallbackIfFontNotReady
1442     // (in which case &quot;font&quot; will be a fallback font).
1443     return !font.isInterstitial() || font.visibility() == Font::Visibility::Visible || customFontNotReadyAction == FontCascade::CustomFontNotReadyAction::UseFallbackIfFontNotReady;
1444 }
1445 
1446 void FontCascade::drawGlyphBuffer(GraphicsContext&amp; context, const GlyphBuffer&amp; glyphBuffer, FloatPoint&amp; point, CustomFontNotReadyAction customFontNotReadyAction) const
1447 {
1448     // Draw each contiguous run of glyphs that use the same font data.
1449     const Font* fontData = glyphBuffer.fontAt(0);
<span class="line-modified">1450     FloatPoint startPoint = point;</span>






1451     float nextX = startPoint.x() + glyphBuffer.advanceAt(0).width();
1452     float nextY = startPoint.y() + glyphBuffer.advanceAt(0).height();
1453     unsigned lastFrom = 0;
1454     unsigned nextGlyph = 1;
1455     while (nextGlyph &lt; glyphBuffer.size()) {
1456         const Font* nextFontData = glyphBuffer.fontAt(nextGlyph);
1457 
1458         if (nextFontData != fontData) {
1459             if (shouldDrawIfLoading(*fontData, customFontNotReadyAction))
1460                 context.drawGlyphs(*fontData, glyphBuffer, lastFrom, nextGlyph - lastFrom, startPoint, m_fontDescription.fontSmoothing());
1461 
1462             lastFrom = nextGlyph;
1463             fontData = nextFontData;
1464             startPoint.setX(nextX);
1465             startPoint.setY(nextY);
1466         }
1467         nextX += glyphBuffer.advanceAt(nextGlyph).width();
1468         nextY += glyphBuffer.advanceAt(nextGlyph).height();
1469         nextGlyph++;
1470     }
</pre>
<hr />
<pre>
1517 
1518     drawGlyphBuffer(context, markBuffer, startPoint, CustomFontNotReadyAction::DoNotPaintIfFontNotReady);
1519 }
1520 
1521 float FontCascade::floatWidthForSimpleText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1522 {
1523     WidthIterator it(this, run, fallbackFonts, glyphOverflow);
1524     GlyphBuffer glyphBuffer;
1525     it.advance(run.length(), (enableKerning() || requiresShaping()) ? &amp;glyphBuffer : nullptr);
1526 
1527     if (glyphOverflow) {
1528         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-it.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1529         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(it.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1530         glyphOverflow-&gt;left = ceilf(it.firstGlyphOverflow());
1531         glyphOverflow-&gt;right = ceilf(it.lastGlyphOverflow());
1532     }
1533 
1534     return it.m_runWidthSoFar;
1535 }
1536 

1537 float FontCascade::floatWidthForComplexText(const TextRun&amp; run, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1538 {
1539     ComplexTextController controller(*this, run, true, fallbackFonts);
1540     if (glyphOverflow) {
1541         glyphOverflow-&gt;top = std::max&lt;int&gt;(glyphOverflow-&gt;top, ceilf(-controller.minGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().ascent()));
1542         glyphOverflow-&gt;bottom = std::max&lt;int&gt;(glyphOverflow-&gt;bottom, ceilf(controller.maxGlyphBoundingBoxY()) - (glyphOverflow-&gt;computeBounds ? 0 : fontMetrics().descent()));
1543         glyphOverflow-&gt;left = std::max&lt;int&gt;(0, ceilf(-controller.minGlyphBoundingBoxX()));
<span class="line-modified">1544         glyphOverflow-&gt;right = std::max&lt;int&gt;(0, ceilf(controller.maxGlyphBoundingBoxX() - controller.totalAdvance().width()));</span>
1545     }
<span class="line-modified">1546     return controller.totalAdvance().width();</span>
1547 }

1548 
1549 void FontCascade::adjustSelectionRectForSimpleText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1550 {
1551     GlyphBuffer glyphBuffer;
1552     WidthIterator it(this, run);
1553     it.advance(from, &amp;glyphBuffer);
1554     float beforeWidth = it.m_runWidthSoFar;
1555     it.advance(to, &amp;glyphBuffer);
1556     float afterWidth = it.m_runWidthSoFar;
1557     float totalWidth = -1;
1558 
1559     if (run.rtl()) {
1560         it.advance(run.length(), &amp;glyphBuffer);
1561         totalWidth = it.m_runWidthSoFar;
1562         selectionRect.move(totalWidth - afterWidth, 0);
1563     } else
1564         selectionRect.move(beforeWidth, 0);
1565     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1566 }
1567 

1568 void FontCascade::adjustSelectionRectForComplexText(const TextRun&amp; run, LayoutRect&amp; selectionRect, unsigned from, unsigned to) const
1569 {
1570     ComplexTextController controller(*this, run);
1571     controller.advance(from);
1572     float beforeWidth = controller.runWidthSoFar();
1573     controller.advance(to);
1574     float afterWidth = controller.runWidthSoFar();
1575 
1576     if (run.rtl())
<span class="line-modified">1577         selectionRect.move(controller.totalAdvance().width() - afterWidth, 0);</span>
1578     else
1579         selectionRect.move(beforeWidth, 0);
1580     selectionRect.setWidth(LayoutUnit::fromFloatCeil(afterWidth - beforeWidth));
1581 }

1582 
1583 int FontCascade::offsetForPositionForSimpleText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1584 {
1585     float delta = x;
1586 
1587     WidthIterator it(this, run);
1588     GlyphBuffer localGlyphBuffer;
1589     unsigned offset;
1590     if (run.rtl()) {
1591         delta -= floatWidthForSimpleText(run);
1592         while (1) {
1593             offset = it.m_currentCharacter;
1594             float w;
1595             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1596                 break;
1597             delta += w;
1598             if (includePartialGlyphs) {
1599                 if (delta - w / 2 &gt;= 0)
1600                     break;
1601             } else {
</pre>
<hr />
<pre>
1606     } else {
1607         while (1) {
1608             offset = it.m_currentCharacter;
1609             float w;
1610             if (!it.advanceOneCharacter(w, localGlyphBuffer))
1611                 break;
1612             delta -= w;
1613             if (includePartialGlyphs) {
1614                 if (delta + w / 2 &lt;= 0)
1615                     break;
1616             } else {
1617                 if (delta &lt;= 0)
1618                     break;
1619             }
1620         }
1621     }
1622 
1623     return offset;
1624 }
1625 

1626 int FontCascade::offsetForPositionForComplexText(const TextRun&amp; run, float x, bool includePartialGlyphs) const
1627 {
1628     ComplexTextController controller(*this, run);
1629     return controller.offsetForPosition(x, includePartialGlyphs);
1630 }

1631 
1632 #if !PLATFORM(COCOA) &amp;&amp; !USE(HARFBUZZ)
1633 // FIXME: Unify this with the macOS and iOS implementation.
1634 const Font* FontCascade::fontForCombiningCharacterSequence(const UChar* characters, size_t length) const
1635 {
1636     UChar32 baseCharacter;
1637     size_t baseCharacterLength = 0;
1638     U16_NEXT(characters, baseCharacterLength, length, baseCharacter);
1639     GlyphData baseCharacterGlyphData = glyphDataForCharacter(baseCharacter, false, NormalVariant);
1640 
1641     if (!baseCharacterGlyphData.glyph)
1642         return nullptr;
1643     return baseCharacterGlyphData.font;
1644 }
1645 #endif
1646 
1647 void FontCascade::drawEmphasisMarksForComplexText(GraphicsContext&amp; context, const TextRun&amp; run, const AtomString&amp; mark, const FloatPoint&amp; point, unsigned from, unsigned to) const
1648 {
1649     GlyphBuffer glyphBuffer;
<span class="line-modified">1650     auto initialAdvance = getGlyphsAndAdvancesForComplexText(run, from, to, glyphBuffer, ForTextEmphasis);</span>
1651 
1652     if (glyphBuffer.isEmpty())
1653         return;
1654 
<span class="line-modified">1655     drawEmphasisMarks(context, glyphBuffer, mark, point + initialAdvance);</span>
1656 }
1657 
1658 struct GlyphIterationState {
1659     FloatPoint startingPoint;
1660     FloatPoint currentPoint;
1661     float y1;
1662     float y2;
1663     float minX;
1664     float maxX;
1665 };
1666 
1667 static Optional&lt;float&gt; findIntersectionPoint(float y, FloatPoint p1, FloatPoint p2)
1668 {
1669     if ((p1.y() &lt; y &amp;&amp; p2.y() &gt; y) || (p1.y() &gt; y &amp;&amp; p2.y() &lt; y))
1670         return p1.x() + (y - p1.y()) * (p2.x() - p1.x()) / (p2.y() - p1.y());
1671     return WTF::nullopt;
1672 }
1673 
1674 static void updateX(GlyphIterationState&amp; state, float x)
1675 {
1676     state.minX = std::min(state.minX, x);
1677     state.maxX = std::max(state.maxX, x);
1678 }
1679 
1680 // This function is called by CGPathApply and is therefore invoked for each
1681 // contour in a glyph. This function models each contours as a straight line
1682 // and calculates the intersections between each pseudo-contour and
1683 // two horizontal lines (the upper and lower bounds of an underline) found in
1684 // GlyphIterationState::y1 and GlyphIterationState::y2. It keeps track of the
1685 // leftmost and rightmost intersection in GlyphIterationState::minX and
1686 // GlyphIterationState::maxX.
1687 static void findPathIntersections(GlyphIterationState&amp; state, const PathElement&amp; element)
1688 {
1689     bool doIntersection = false;
1690     FloatPoint point = FloatPoint();
1691     switch (element.type) {
<span class="line-modified">1692     case PathElement::Type::MoveToPoint:</span>
1693         state.startingPoint = element.points[0];
1694         state.currentPoint = element.points[0];
1695         break;
<span class="line-modified">1696     case PathElement::Type::AddLineToPoint:</span>
1697         doIntersection = true;
1698         point = element.points[0];
1699         break;
<span class="line-modified">1700     case PathElement::Type::AddQuadCurveToPoint:</span>
1701         doIntersection = true;
1702         point = element.points[1];
1703         break;
<span class="line-modified">1704     case PathElement::Type::AddCurveToPoint:</span>
1705         doIntersection = true;
1706         point = element.points[2];
1707         break;
<span class="line-modified">1708     case PathElement::Type::CloseSubpath:</span>
1709         doIntersection = true;
1710         point = state.startingPoint;
1711         break;
1712     }
1713     if (!doIntersection)
1714         return;
1715     if (auto intersectionPoint = findIntersectionPoint(state.y1, state.currentPoint, point))
1716         updateX(state, *intersectionPoint);
1717     if (auto intersectionPoint = findIntersectionPoint(state.y2, state.currentPoint, point))
1718         updateX(state, *intersectionPoint);
1719     if ((state.currentPoint.y() &gt;= state.y1 &amp;&amp; state.currentPoint.y() &lt;= state.y2)
1720         || (state.currentPoint.y() &lt;= state.y1 &amp;&amp; state.currentPoint.y() &gt;= state.y2))
1721         updateX(state, state.currentPoint.x());
1722     state.currentPoint = point;
1723 }
1724 
1725 class GlyphToPathTranslator {
1726 public:
1727     GlyphToPathTranslator(const TextRun&amp; textRun, const GlyphBuffer&amp; glyphBuffer, const FloatPoint&amp; textOrigin)
1728         : m_index(0)
</pre>
<hr />
<pre>
1773 void GlyphToPathTranslator::advance()
1774 {
1775     GlyphBufferAdvance advance = m_glyphBuffer.advanceAt(m_index);
1776     m_translation.translate(FloatSize(advance.width(), advance.height()));
1777     ++m_index;
1778     if (m_index &lt; m_glyphBuffer.size())
1779         m_fontData = m_glyphBuffer.fontAt(m_index);
1780 }
1781 
1782 DashArray FontCascade::dashesForIntersectionsWithRect(const TextRun&amp; run, const FloatPoint&amp; textOrigin, const FloatRect&amp; lineExtents) const
1783 {
1784     if (isLoadingCustomFonts())
1785         return DashArray();
1786 
1787     GlyphBuffer glyphBuffer;
1788     glyphBuffer.saveOffsetsInString();
1789     float deltaX;
1790     if (codePath(run) != FontCascade::Complex)
1791         deltaX = getGlyphsAndAdvancesForSimpleText(run, 0, run.length(), glyphBuffer);
1792     else
<span class="line-modified">1793         deltaX = getGlyphsAndAdvancesForComplexText(run, 0, run.length(), glyphBuffer).width();</span>
1794 
1795     if (!glyphBuffer.size())
1796         return DashArray();
1797 
1798     FloatPoint origin = FloatPoint(textOrigin.x() + deltaX, textOrigin.y());
1799     GlyphToPathTranslator translator(run, glyphBuffer, origin);
1800     DashArray result;
1801     for (unsigned index = 0; translator.containsMorePaths(); ++index, translator.advance()) {
1802         GlyphIterationState info = { FloatPoint(0, 0), FloatPoint(0, 0), lineExtents.y(), lineExtents.y() + lineExtents.height(), lineExtents.x() + lineExtents.width(), lineExtents.x() };
1803         const Font* localFont = glyphBuffer.fontAt(index);
1804         if (!localFont) {
1805             // The advances will get all messed up if we do anything other than bail here.
1806             result.clear();
1807             break;
1808         }
1809         switch (translator.underlineType()) {
1810         case GlyphUnderlineType::SkipDescenders: {
1811             Path path = translator.path();
1812             path.apply([&amp;](const PathElement&amp; element) {
1813                 findPathIntersections(info, element);
</pre>
</td>
</tr>
</table>
<center><a href="FontCache.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
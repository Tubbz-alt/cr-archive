<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineTextBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LayoutDisallowedScope.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 49 
 50     virtual ~InlineTextBox();
 51 
 52     RenderText&amp; renderer() const { return downcast&lt;RenderText&gt;(InlineBox::renderer()); }
 53     const RenderStyle&amp; lineStyle() const { return isFirstLine() ? renderer().firstLineStyle() : renderer().style(); }
 54 
 55     InlineTextBox* prevTextBox() const { return m_prevTextBox; }
 56     InlineTextBox* nextTextBox() const { return m_nextTextBox; }
 57     void setNextTextBox(InlineTextBox* n) { m_nextTextBox = n; }
 58     void setPreviousTextBox(InlineTextBox* p) { m_prevTextBox = p; }
 59 
 60     bool hasTextContent() const;
 61 
 62     // These functions do not account for combined text. For combined text this box will always have len() == 1
 63     // regardless of whether the resulting composition is the empty string. Use hasTextContent() if you want to
 64     // know whether this box has text content.
 65     //
 66     // FIXME: These accessors should ASSERT(!isDirty()). See https://bugs.webkit.org/show_bug.cgi?id=97264
 67     // Note len() == 1 for combined text regardless of whether the composition is empty. Use hasTextContent() to
 68     unsigned start() const { return m_start; }
<span class="line-modified"> 69     unsigned end() const { return m_len ? m_start + m_len - 1 : m_start; }</span>
 70     unsigned len() const { return m_len; }
 71 
 72     void setStart(unsigned start) { m_start = start; }
 73     void setLen(unsigned len) { m_len = len; }
 74 
 75     void offsetRun(int d) { ASSERT(!isDirty()); ASSERT(d &gt; 0 || m_start &gt;= static_cast&lt;unsigned&gt;(-d)); m_start += d; }
 76 
 77     unsigned short truncation() const { return m_truncation; }
 78 
 79     void markDirty(bool dirty = true) final;
 80 
 81     using InlineBox::hasHyphen;
 82     using InlineBox::setHasHyphen;
 83     using InlineBox::canHaveLeadingExpansion;
 84     using InlineBox::setCanHaveLeadingExpansion;
 85     using InlineBox::canHaveTrailingExpansion;
 86     using InlineBox::setCanHaveTrailingExpansion;
 87     using InlineBox::forceTrailingExpansion;
 88     using InlineBox::setForceTrailingExpansion;
 89     using InlineBox::forceLeadingExpansion;
</pre>
<hr />
<pre>
104     LayoutUnit logicalRightVisualOverflow() const { return logicalOverflowRect().maxX(); }
105 
106     virtual void dirtyOwnLineBoxes() { dirtyLineBoxes(); }
107 
108 #if ENABLE(TREE_DEBUGGING)
109     void outputLineBox(WTF::TextStream&amp;, bool mark, int depth) const final;
110     const char* boxName() const final;
111 #endif
112 
113 private:
114     LayoutUnit selectionTop() const;
115     LayoutUnit selectionBottom() const;
116     LayoutUnit selectionHeight() const;
117 
118 public:
119     FloatRect calculateBoundaries() const override { return FloatRect(x(), y(), width(), height()); }
120 
121     virtual LayoutRect localSelectionRect(unsigned startPos, unsigned endPos) const;
122     bool isSelected(unsigned startPosition, unsigned endPosition) const;
123     std::pair&lt;unsigned, unsigned&gt; selectionStartEnd() const;

124 
125 protected:
126     void paint(PaintInfo&amp;, const LayoutPoint&amp;, LayoutUnit lineTop, LayoutUnit lineBottom) override;
127     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction) override;
128 
129     unsigned clampedOffset(unsigned) const;
130 
131 private:
132     void deleteLine() final;
133     void extractLine() final;
134     void attachLine() final;
135 



136 public:
137     RenderObject::SelectionState selectionState() final;
138 
139 private:
140     void clearTruncation() final { m_truncation = cNoTruncation; }
141     float placeEllipsisBox(bool flowIsLTR, float visibleLeftEdge, float visibleRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox) final;
142 
143 public:
144     bool isLineBreak() const final;
145 
146 private:
147     bool isInlineTextBox() const final { return true; }
148 
149 public:
150     int caretMinOffset() const final;
151     int caretMaxOffset() const final;
152 
153 private:
154     float textPos() const; // returns the x position relative to the left start of the text line.
155 
156 public:
157     virtual int offsetForPosition(float x, bool includePartialGlyphs = true) const;
158     virtual float positionForOffset(unsigned offset) const;
159 
160     bool hasMarkers() const;
161     FloatRect calculateUnionOfAllDocumentMarkerBounds() const;
162     FloatRect calculateDocumentMarkerBounds(const MarkedText&amp;) const;
163 
164 private:
165     struct MarkedTextStyle;
166     struct StyledMarkedText;
167 
168     enum class TextPaintPhase { Background, Foreground, Decoration };
169 
170     Vector&lt;MarkedText&gt; collectMarkedTextsForDraggedContent();
171     Vector&lt;MarkedText&gt; collectMarkedTextsForDocumentMarkers(TextPaintPhase) const;

172 
173     MarkedTextStyle computeStyleForUnmarkedMarkedText(const PaintInfo&amp;) const;
174     StyledMarkedText resolveStyleForMarkedText(const MarkedText&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
175     Vector&lt;StyledMarkedText&gt; subdivideAndResolveStyle(const Vector&lt;MarkedText&gt;&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
176 
177     using MarkedTextStylesEqualityFunction = bool (*)(const MarkedTextStyle&amp;, const MarkedTextStyle&amp;);
178     Vector&lt;StyledMarkedText&gt; coalesceAdjacentMarkedTexts(const Vector&lt;StyledMarkedText&gt;&amp;, MarkedTextStylesEqualityFunction);
179 
180     FloatPoint textOriginFromBoxRect(const FloatRect&amp;) const;
181 
182     void paintMarkedTexts(PaintInfo&amp;, TextPaintPhase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp;, const FloatRect&amp; decorationClipOutRect = { });
183 
184     void paintPlatformDocumentMarker(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin, const MarkedText&amp;);
185     void paintPlatformDocumentMarkers(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin);
186 
187     void paintCompositionBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin);
188     void paintCompositionUnderlines(PaintInfo&amp;, const FloatPoint&amp; boxOrigin) const;
189     void paintCompositionUnderline(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp;) const;
190 
191     void paintMarkedTextBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const Color&amp;, unsigned clampedStartOffset, unsigned clampedEndOffset);
</pre>
<hr />
<pre>
196     const FontCascade&amp; lineFont() const;
197 
198     String text(bool ignoreCombinedText = false, bool ignoreHyphen = false) const; // The effective text for the run.
199     TextRun createTextRun(bool ignoreCombinedText = false, bool ignoreHyphen = false) const;
200 
201     ExpansionBehavior expansionBehavior() const;
202 
203     void behavesLikeText() const = delete;
204 
205     InlineTextBox* m_prevTextBox { nullptr }; // The previous box that also uses our RenderObject
206     InlineTextBox* m_nextTextBox { nullptr }; // The next box that also uses our RenderObject
207 
208     unsigned m_start { 0 };
209     unsigned short m_len { 0 };
210 
211     // Where to truncate when text overflow is applied. We use special constants to
212     // denote no truncation (the whole run paints) and full truncation (nothing paints at all).
213     unsigned short m_truncation { cNoTruncation };
214 };
215 


216 } // namespace WebCore
217 
218 SPECIALIZE_TYPE_TRAITS_INLINE_BOX(InlineTextBox, isInlineTextBox())
</pre>
</td>
<td>
<hr />
<pre>
 49 
 50     virtual ~InlineTextBox();
 51 
 52     RenderText&amp; renderer() const { return downcast&lt;RenderText&gt;(InlineBox::renderer()); }
 53     const RenderStyle&amp; lineStyle() const { return isFirstLine() ? renderer().firstLineStyle() : renderer().style(); }
 54 
 55     InlineTextBox* prevTextBox() const { return m_prevTextBox; }
 56     InlineTextBox* nextTextBox() const { return m_nextTextBox; }
 57     void setNextTextBox(InlineTextBox* n) { m_nextTextBox = n; }
 58     void setPreviousTextBox(InlineTextBox* p) { m_prevTextBox = p; }
 59 
 60     bool hasTextContent() const;
 61 
 62     // These functions do not account for combined text. For combined text this box will always have len() == 1
 63     // regardless of whether the resulting composition is the empty string. Use hasTextContent() if you want to
 64     // know whether this box has text content.
 65     //
 66     // FIXME: These accessors should ASSERT(!isDirty()). See https://bugs.webkit.org/show_bug.cgi?id=97264
 67     // Note len() == 1 for combined text regardless of whether the composition is empty. Use hasTextContent() to
 68     unsigned start() const { return m_start; }
<span class="line-modified"> 69     unsigned end() const { return m_start + m_len; }</span>
 70     unsigned len() const { return m_len; }
 71 
 72     void setStart(unsigned start) { m_start = start; }
 73     void setLen(unsigned len) { m_len = len; }
 74 
 75     void offsetRun(int d) { ASSERT(!isDirty()); ASSERT(d &gt; 0 || m_start &gt;= static_cast&lt;unsigned&gt;(-d)); m_start += d; }
 76 
 77     unsigned short truncation() const { return m_truncation; }
 78 
 79     void markDirty(bool dirty = true) final;
 80 
 81     using InlineBox::hasHyphen;
 82     using InlineBox::setHasHyphen;
 83     using InlineBox::canHaveLeadingExpansion;
 84     using InlineBox::setCanHaveLeadingExpansion;
 85     using InlineBox::canHaveTrailingExpansion;
 86     using InlineBox::setCanHaveTrailingExpansion;
 87     using InlineBox::forceTrailingExpansion;
 88     using InlineBox::setForceTrailingExpansion;
 89     using InlineBox::forceLeadingExpansion;
</pre>
<hr />
<pre>
104     LayoutUnit logicalRightVisualOverflow() const { return logicalOverflowRect().maxX(); }
105 
106     virtual void dirtyOwnLineBoxes() { dirtyLineBoxes(); }
107 
108 #if ENABLE(TREE_DEBUGGING)
109     void outputLineBox(WTF::TextStream&amp;, bool mark, int depth) const final;
110     const char* boxName() const final;
111 #endif
112 
113 private:
114     LayoutUnit selectionTop() const;
115     LayoutUnit selectionBottom() const;
116     LayoutUnit selectionHeight() const;
117 
118 public:
119     FloatRect calculateBoundaries() const override { return FloatRect(x(), y(), width(), height()); }
120 
121     virtual LayoutRect localSelectionRect(unsigned startPos, unsigned endPos) const;
122     bool isSelected(unsigned startPosition, unsigned endPosition) const;
123     std::pair&lt;unsigned, unsigned&gt; selectionStartEnd() const;
<span class="line-added">124     std::pair&lt;unsigned, unsigned&gt; highlightStartEnd(SelectionRangeData&amp;) const;</span>
125 
126 protected:
127     void paint(PaintInfo&amp;, const LayoutPoint&amp;, LayoutUnit lineTop, LayoutUnit lineBottom) override;
128     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction) override;
129 
130     unsigned clampedOffset(unsigned) const;
131 
132 private:
133     void deleteLine() final;
134     void extractLine() final;
135     void attachLine() final;
136 
<span class="line-added">137     RenderObject::SelectionState verifySelectionState(RenderObject::SelectionState, SelectionRangeData&amp;) const;</span>
<span class="line-added">138     std::pair&lt;unsigned, unsigned&gt; clampedStartEndForState(unsigned, unsigned, RenderObject::SelectionState) const;</span>
<span class="line-added">139 </span>
140 public:
141     RenderObject::SelectionState selectionState() final;
142 
143 private:
144     void clearTruncation() final { m_truncation = cNoTruncation; }
145     float placeEllipsisBox(bool flowIsLTR, float visibleLeftEdge, float visibleRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox) final;
146 
147 public:
148     bool isLineBreak() const final;
149 
150 private:
151     bool isInlineTextBox() const final { return true; }
152 
153 public:
154     int caretMinOffset() const final;
155     int caretMaxOffset() const final;
156 
157 private:
158     float textPos() const; // returns the x position relative to the left start of the text line.
159 
160 public:
161     virtual int offsetForPosition(float x, bool includePartialGlyphs = true) const;
162     virtual float positionForOffset(unsigned offset) const;
163 
164     bool hasMarkers() const;
165     FloatRect calculateUnionOfAllDocumentMarkerBounds() const;
166     FloatRect calculateDocumentMarkerBounds(const MarkedText&amp;) const;
167 
168 private:
169     struct MarkedTextStyle;
170     struct StyledMarkedText;
171 
172     enum class TextPaintPhase { Background, Foreground, Decoration };
173 
174     Vector&lt;MarkedText&gt; collectMarkedTextsForDraggedContent();
175     Vector&lt;MarkedText&gt; collectMarkedTextsForDocumentMarkers(TextPaintPhase) const;
<span class="line-added">176     Vector&lt;MarkedText&gt; collectMarkedTextsForHighlights(TextPaintPhase) const;</span>
177 
178     MarkedTextStyle computeStyleForUnmarkedMarkedText(const PaintInfo&amp;) const;
179     StyledMarkedText resolveStyleForMarkedText(const MarkedText&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
180     Vector&lt;StyledMarkedText&gt; subdivideAndResolveStyle(const Vector&lt;MarkedText&gt;&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
181 
182     using MarkedTextStylesEqualityFunction = bool (*)(const MarkedTextStyle&amp;, const MarkedTextStyle&amp;);
183     Vector&lt;StyledMarkedText&gt; coalesceAdjacentMarkedTexts(const Vector&lt;StyledMarkedText&gt;&amp;, MarkedTextStylesEqualityFunction);
184 
185     FloatPoint textOriginFromBoxRect(const FloatRect&amp;) const;
186 
187     void paintMarkedTexts(PaintInfo&amp;, TextPaintPhase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp;, const FloatRect&amp; decorationClipOutRect = { });
188 
189     void paintPlatformDocumentMarker(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin, const MarkedText&amp;);
190     void paintPlatformDocumentMarkers(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin);
191 
192     void paintCompositionBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin);
193     void paintCompositionUnderlines(PaintInfo&amp;, const FloatPoint&amp; boxOrigin) const;
194     void paintCompositionUnderline(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp;) const;
195 
196     void paintMarkedTextBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const Color&amp;, unsigned clampedStartOffset, unsigned clampedEndOffset);
</pre>
<hr />
<pre>
201     const FontCascade&amp; lineFont() const;
202 
203     String text(bool ignoreCombinedText = false, bool ignoreHyphen = false) const; // The effective text for the run.
204     TextRun createTextRun(bool ignoreCombinedText = false, bool ignoreHyphen = false) const;
205 
206     ExpansionBehavior expansionBehavior() const;
207 
208     void behavesLikeText() const = delete;
209 
210     InlineTextBox* m_prevTextBox { nullptr }; // The previous box that also uses our RenderObject
211     InlineTextBox* m_nextTextBox { nullptr }; // The next box that also uses our RenderObject
212 
213     unsigned m_start { 0 };
214     unsigned short m_len { 0 };
215 
216     // Where to truncate when text overflow is applied. We use special constants to
217     // denote no truncation (the whole run paints) and full truncation (nothing paints at all).
218     unsigned short m_truncation { cNoTruncation };
219 };
220 
<span class="line-added">221 LayoutRect snappedSelectionRect(const LayoutRect&amp;, float logicalRight, float selectionTop, float selectionHeight, bool isHorizontal);</span>
<span class="line-added">222 </span>
223 } // namespace WebCore
224 
225 SPECIALIZE_TYPE_TRAITS_INLINE_BOX(InlineTextBox, isInlineTextBox())
</pre>
</td>
</tr>
</table>
<center><a href="InlineTextBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LayoutDisallowedScope.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
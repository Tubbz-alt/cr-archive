<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LazyClassStructure.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LiteralParser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/LiteralParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 50,11 ***</span>
  }
  
  template &lt;typename CharType&gt;
  bool LiteralParser&lt;CharType&gt;::tryJSONPParse(Vector&lt;JSONPData&gt;&amp; results, bool needsFullSourceInfo)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (m_lexer.next() != TokIdentifier)
          return false;
      do {
          Vector&lt;JSONPPathEntry&gt; path;
<span class="line-new-header">--- 50,11 ---</span>
  }
  
  template &lt;typename CharType&gt;
  bool LiteralParser&lt;CharType&gt;::tryJSONPParse(Vector&lt;JSONPData&gt;&amp; results, bool needsFullSourceInfo)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (m_lexer.next() != TokIdentifier)
          return false;
      do {
          Vector&lt;JSONPPathEntry&gt; path;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,11 ***</span>
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const LChar* characters, size_t length)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      if (!length)
          return vm.propertyNames-&gt;emptyIdentifier;
      if (characters[0] &gt;= MaximumCachableCharacter)
          return Identifier::fromString(vm, characters, length);
  
<span class="line-new-header">--- 134,11 ---</span>
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const LChar* characters, size_t length)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      if (!length)
          return vm.propertyNames-&gt;emptyIdentifier;
      if (characters[0] &gt;= MaximumCachableCharacter)
          return Identifier::fromString(vm, characters, length);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,11 ***</span>
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const UChar* characters, size_t length)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      if (!length)
          return vm.propertyNames-&gt;emptyIdentifier;
      if (characters[0] &gt;= MaximumCachableCharacter)
          return Identifier::fromString(vm, characters, length);
  
<span class="line-new-header">--- 155,11 ---</span>
  }
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE const Identifier LiteralParser&lt;CharType&gt;::makeIdentifier(const UChar* characters, size_t length)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      if (!length)
          return vm.propertyNames-&gt;emptyIdentifier;
      if (characters[0] &gt;= MaximumCachableCharacter)
          return Identifier::fromString(vm, characters, length);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,11 ***</span>
  };
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE TokenType LiteralParser&lt;CharType&gt;::Lexer::lex(LiteralParserToken&lt;CharType&gt;&amp; token)
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      m_currentTokenID++;
  #endif
  
      while (m_ptr &lt; m_end &amp;&amp; isJSONWhiteSpace(*m_ptr))
          ++m_ptr;
<span class="line-new-header">--- 436,11 ---</span>
  };
  
  template &lt;typename CharType&gt;
  ALWAYS_INLINE TokenType LiteralParser&lt;CharType&gt;::Lexer::lex(LiteralParserToken&lt;CharType&gt;&amp; token)
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      m_currentTokenID++;
  #endif
  
      while (m_ptr &lt; m_end &amp;&amp; isJSONWhiteSpace(*m_ptr))
          ++m_ptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 818,11 ***</span>
  }
  
  template &lt;typename CharType&gt;
  JSValue LiteralParser&lt;CharType&gt;::parse(ParserState initialState)
  {
<span class="line-modified">!     VM&amp; vm = m_exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ParserState state = initialState;
      MarkedArgumentBuffer objectStack;
      JSValue lastValue;
      Vector&lt;ParserState, 16, UnsafeVectorOverflow&gt; stateStack;
<span class="line-new-header">--- 818,11 ---</span>
  }
  
  template &lt;typename CharType&gt;
  JSValue LiteralParser&lt;CharType&gt;::parse(ParserState initialState)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ParserState state = initialState;
      MarkedArgumentBuffer objectStack;
      JSValue lastValue;
      Vector&lt;ParserState, 16, UnsafeVectorOverflow&gt; stateStack;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 830,11 ***</span>
      HashSet&lt;JSObject*&gt; visitedUnderscoreProto;
      while (1) {
          switch(state) {
              startParseArray:
              case StartParseArray: {
<span class="line-modified">!                 JSArray* array = constructEmptyArray(m_exec, 0);</span>
                  RETURN_IF_EXCEPTION(scope, JSValue());
                  objectStack.appendWithCrashOnOverflow(array);
              }
              doParseArrayStartExpression:
              FALLTHROUGH;
<span class="line-new-header">--- 830,11 ---</span>
      HashSet&lt;JSObject*&gt; visitedUnderscoreProto;
      while (1) {
          switch(state) {
              startParseArray:
              case StartParseArray: {
<span class="line-modified">!                 JSArray* array = constructEmptyArray(m_globalObject, 0);</span>
                  RETURN_IF_EXCEPTION(scope, JSValue());
                  objectStack.appendWithCrashOnOverflow(array);
              }
              doParseArrayStartExpression:
              FALLTHROUGH;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 853,11 ***</span>
                  stateStack.append(DoParseArrayEndExpression);
                  goto startParseExpression;
              }
              case DoParseArrayEndExpression: {
                  JSArray* array = asArray(objectStack.last());
<span class="line-modified">!                 array-&gt;putDirectIndex(m_exec, array-&gt;length(), lastValue);</span>
                  RETURN_IF_EXCEPTION(scope, JSValue());
  
                  if (m_lexer.currentToken()-&gt;type == TokComma)
                      goto doParseArrayStartExpression;
  
<span class="line-new-header">--- 853,11 ---</span>
                  stateStack.append(DoParseArrayEndExpression);
                  goto startParseExpression;
              }
              case DoParseArrayEndExpression: {
                  JSArray* array = asArray(objectStack.last());
<span class="line-modified">!                 array-&gt;putDirectIndex(m_globalObject, array-&gt;length(), lastValue);</span>
                  RETURN_IF_EXCEPTION(scope, JSValue());
  
                  if (m_lexer.currentToken()-&gt;type == TokComma)
                      goto doParseArrayStartExpression;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,11 ***</span>
                  lastValue = objectStack.takeLast();
                  break;
              }
              startParseObject:
              case StartParseObject: {
<span class="line-modified">!                 JSObject* object = constructEmptyObject(m_exec);</span>
                  objectStack.appendWithCrashOnOverflow(object);
  
                  TokenType type = m_lexer.next();
                  if (type == TokString || (m_mode != StrictJSON &amp;&amp; type == TokIdentifier)) {
                      typename Lexer::LiteralParserTokenPtr identifierToken = m_lexer.currentToken();
<span class="line-new-header">--- 870,11 ---</span>
                  lastValue = objectStack.takeLast();
                  break;
              }
              startParseObject:
              case StartParseObject: {
<span class="line-modified">!                 JSObject* object = constructEmptyObject(m_globalObject);</span>
                  objectStack.appendWithCrashOnOverflow(object);
  
                  TokenType type = m_lexer.next();
                  if (type == TokString || (m_mode != StrictJSON &amp;&amp; type == TokIdentifier)) {
                      typename Lexer::LiteralParserTokenPtr identifierToken = m_lexer.currentToken();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 931,16 ***</span>
                  if (m_mode != StrictJSON &amp;&amp; ident == vm.propertyNames-&gt;underscoreProto) {
                      if (!visitedUnderscoreProto.add(object).isNewEntry) {
                          m_parseErrorMessage = &quot;Attempted to redefine __proto__ property&quot;_s;
                          return JSValue();
                      }
<span class="line-modified">!                     CodeBlock* codeBlock = m_exec-&gt;codeBlock();</span>
<span class="line-modified">!                     PutPropertySlot slot(object, codeBlock ? codeBlock-&gt;isStrictMode() : false);</span>
<span class="line-removed">-                     objectStack.last().put(m_exec, ident, lastValue, slot);</span>
                  } else {
                      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!                         object-&gt;putDirectIndex(m_exec, index.value(), lastValue);</span>
                      else
                          object-&gt;putDirect(vm, ident, lastValue);
                  }
                  RETURN_IF_EXCEPTION(scope, JSValue());
                  if (m_lexer.currentToken()-&gt;type == TokComma)
<span class="line-new-header">--- 931,15 ---</span>
                  if (m_mode != StrictJSON &amp;&amp; ident == vm.propertyNames-&gt;underscoreProto) {
                      if (!visitedUnderscoreProto.add(object).isNewEntry) {
                          m_parseErrorMessage = &quot;Attempted to redefine __proto__ property&quot;_s;
                          return JSValue();
                      }
<span class="line-modified">!                     PutPropertySlot slot(object, m_nullOrCodeBlock ? m_nullOrCodeBlock-&gt;isStrictMode() : false);</span>
<span class="line-modified">!                     objectStack.last().put(m_globalObject, ident, lastValue, slot);</span>
                  } else {
                      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!                         object-&gt;putDirectIndex(m_globalObject, index.value(), lastValue);</span>
                      else
                          object-&gt;putDirect(vm, ident, lastValue);
                  }
                  RETURN_IF_EXCEPTION(scope, JSValue());
                  if (m_lexer.currentToken()-&gt;type == TokComma)
</pre>
<center><a href="LazyClassStructure.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LiteralParser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
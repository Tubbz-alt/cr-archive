<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../parser/HTMLTreeBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaControlElements.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/shadow/MediaControlElements.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
  40 #include &quot;FullscreenManager.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLHeadingElement.h&quot;
  43 #include &quot;HTMLLIElement.h&quot;
  44 #include &quot;HTMLUListElement.h&quot;
  45 #include &quot;HTMLVideoElement.h&quot;
  46 #include &quot;ImageBuffer.h&quot;
  47 #include &quot;LocalizedStrings.h&quot;
  48 #include &quot;Logging.h&quot;
  49 #include &quot;MediaControls.h&quot;
  50 #include &quot;MouseEvent.h&quot;

  51 #include &quot;Page.h&quot;
  52 #include &quot;PageGroup.h&quot;
  53 #include &quot;RenderLayer.h&quot;
  54 #include &quot;RenderMediaControlElements.h&quot;
  55 #include &quot;RenderSlider.h&quot;
  56 #include &quot;RenderTheme.h&quot;
  57 #include &quot;RenderVideo.h&quot;
  58 #include &quot;RenderView.h&quot;
  59 #include &quot;Settings.h&quot;
  60 #include &quot;ShadowRoot.h&quot;

  61 #include &quot;TextTrackList.h&quot;
  62 #include &quot;VTTRegionList.h&quot;
  63 #include &lt;wtf/IsoMallocInlines.h&gt;
  64 #include &lt;wtf/Language.h&gt;
  65 
  66 namespace WebCore {
  67 
  68 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelElement);
  69 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelEnclosureElement);
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayEnclosureElement);
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineContainerElement);
  72 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderContainerElement);
  73 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlStatusDisplayElement);
  74 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelMuteButtonElement);
  75 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderMuteButtonElement);
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPlayButtonElement);
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
</pre>
<hr />
<pre>
 176 {
 177     if (m_transitionTimer.isActive())
 178         m_transitionTimer.stop();
 179 }
 180 
 181 void MediaControlPanelElement::transitionTimerFired()
 182 {
 183     if (!m_opaque)
 184         hide();
 185 
 186     stopTimer();
 187 }
 188 
 189 void MediaControlPanelElement::setPosition(const LayoutPoint&amp; position)
 190 {
 191     double left = position.x();
 192     double top = position.y();
 193 
 194     // Set the left and top to control the panel&#39;s position; this depends on it being absolute positioned.
 195     // Set the margin to zero since the position passed in will already include the effect of the margin.
<span class="line-modified"> 196     setInlineStyleProperty(CSSPropertyLeft, left, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified"> 197     setInlineStyleProperty(CSSPropertyTop, top, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified"> 198     setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified"> 199     setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSPrimitiveValue::CSS_PX);</span>
 200 
 201     classList().add(&quot;dragged&quot;);
 202 }
 203 
 204 void MediaControlPanelElement::resetPosition()
 205 {
 206     removeInlineStyleProperty(CSSPropertyLeft);
 207     removeInlineStyleProperty(CSSPropertyTop);
 208     removeInlineStyleProperty(CSSPropertyMarginLeft);
 209     removeInlineStyleProperty(CSSPropertyMarginTop);
 210 
 211     classList().remove(&quot;dragged&quot;);
 212 
 213     m_cumulativeDragOffset.setX(0);
 214     m_cumulativeDragOffset.setY(0);
 215 }
 216 
 217 void MediaControlPanelElement::makeOpaque()
 218 {
 219     if (m_opaque)
 220         return;
 221 
 222     double duration = RenderTheme::singleton().mediaControlsFadeInDuration();
 223 
 224     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<span class="line-modified"> 225     setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSPrimitiveValue::CSS_S);</span>
<span class="line-modified"> 226     setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSPrimitiveValue::CSS_NUMBER);</span>
 227 
 228     m_opaque = true;
 229 
 230     if (m_isDisplayed)
 231         show();
 232 }
 233 
 234 void MediaControlPanelElement::makeTransparent()
 235 {
 236     if (!m_opaque)
 237         return;
 238 
 239     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 240 
 241     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<span class="line-modified"> 242     setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSPrimitiveValue::CSS_S);</span>
<span class="line-modified"> 243     setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSPrimitiveValue::CSS_NUMBER);</span>
 244 
 245     m_opaque = false;
 246     startTimer();
 247 }
 248 
 249 void MediaControlPanelElement::defaultEventHandler(Event&amp; event)
 250 {
 251     MediaControlDivElement::defaultEventHandler(event);
 252 
 253     if (is&lt;MouseEvent&gt;(event)) {
 254         LayoutPoint location = downcast&lt;MouseEvent&gt;(event).absoluteLocation();
 255         if (event.type() == eventNames().mousedownEvent &amp;&amp; event.target() == this) {
 256             startDrag(location);
 257             event.setDefaultHandled();
 258         } else if (event.type() == eventNames().mousemoveEvent &amp;&amp; m_isBeingDragged)
 259             continueDrag(location);
 260         else if (event.type() == eventNames().mouseupEvent &amp;&amp; m_isBeingDragged) {
 261             continueDrag(location);
 262             endDrag();
 263             event.setDefaultHandled();
</pre>
<hr />
<pre>
1108 
1109 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1110 {
1111     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1112 }
1113 
1114 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1115 {
1116     return one.data()-&gt;isPositionedAbove(two.data());
1117 };
1118 
1119 void MediaControlTextTrackContainerElement::updateDisplay()
1120 {
1121     if (!mediaController()-&gt;closedCaptionsVisible())
1122         removeChildren();
1123 
1124     auto mediaElement = parentMediaElement(this);
1125     // 1. If the media element is an audio element, or is another playback
1126     // mechanism with no rendering area, abort these steps. There is nothing to
1127     // render.
<span class="line-modified">1128     if (!mediaElement || !mediaElement-&gt;isVideo())</span>
1129         return;
1130 
1131     // 2. Let video be the media element or other playback mechanism.
1132     HTMLVideoElement&amp; video = downcast&lt;HTMLVideoElement&gt;(*mediaElement);
1133 
1134     // 3. Let output be an empty list of absolutely positioned CSS block boxes.
<span class="line-removed">1135     Vector&lt;RefPtr&lt;HTMLDivElement&gt;&gt; output;</span>
1136 
1137     // 4. If the user agent is exposing a user interface for video, add to
1138     // output one or more completely transparent positioned CSS block boxes that
1139     // cover the same region as the user interface.
1140 
1141     // 5. If the last time these rules were run, the user agent was not exposing
1142     // a user interface for video, but now it is, let reset be true. Otherwise,
1143     // let reset be false.
1144 
1145     // There is nothing to be done explicitly for 4th and 5th steps, as
1146     // everything is handled through CSS. The caption box is on top of the
1147     // controls box, in a container set with the -webkit-box display property.
1148 
1149     // 6. Let tracks be the subset of video&#39;s list of text tracks that have as
1150     // their rules for updating the text track rendering these rules for
1151     // updating the display of WebVTT text tracks, and whose text track mode is
1152     // showing or showing by default.
1153     // 7. Let cues be an empty list of text track cues.
1154     // 8. For each track track in tracks, append to cues all the cues from
1155     // track&#39;s list of cues that have their text track cue active flag set.
1156     CueList activeCues = video.currentlyActiveCues();
1157 
1158     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1159     // text track cue display state has a set of CSS boxes, then add those boxes
1160     // to output, and remove cue from cues.
1161 
1162     // There is nothing explicitly to be done here, as all the caching occurs
1163     // within the TextTrackCue instance itself. If parameters of the cue change,
1164     // the display tree is cleared.
1165 
1166     // If the number of CSS boxes in the output is less than the number of cues
1167     // we wish to render (e.g., we are adding another cue in a set of roll-up
1168     // cues), remove all the existing CSS boxes representing the cues and re-add
1169     // them so that the new cue is at the bottom.
1170     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1171     // traverse all children just to check if there are less children than cues.
1172     if (countChildNodes() &lt; activeCues.size())
1173         removeChildren();
1174 
1175     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
<span class="line-modified">1176         if (!is&lt;VTTCue&gt;(cueInterval.data()))</span>
<span class="line-modified">1177             return true;</span>
<span class="line-removed">1178 </span>
<span class="line-removed">1179         Ref&lt;VTTCue&gt; cue = downcast&lt;VTTCue&gt;(*cueInterval.data());</span>
<span class="line-removed">1180 </span>
<span class="line-removed">1181         return !cue-&gt;isRenderable()</span>
<span class="line-removed">1182             || !cue-&gt;track()</span>
1183             || !cue-&gt;track()-&gt;isRendered()
1184             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1185             || !cue-&gt;isActive()
<span class="line-modified">1186             || cue-&gt;text().isEmpty();</span>
1187     });
1188 
1189     // Sort the active cues for the appropriate display order. For example, for roll-up
1190     // or paint-on captions, we need to add the cues in reverse chronological order,
1191     // so that the newest captions appear at the bottom.
1192     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1193 
<span class="line-modified">1194     // 10. For each text track cue cue in cues that has not yet had</span>
<span class="line-modified">1195     // corresponding CSS boxes added to output, in text track cue order, run the</span>
<span class="line-modified">1196     // following substeps:</span>
<span class="line-modified">1197     for (size_t i = 0; i &lt; activeCues.size(); ++i) {</span>
<span class="line-modified">1198         if (!mediaController()-&gt;closedCaptionsVisible())</span>
<span class="line-modified">1199             continue;</span>
<span class="line-modified">1200 </span>
<span class="line-modified">1201         RefPtr&lt;VTTCue&gt; cue = downcast&lt;VTTCue&gt;(activeCues[i].data());</span>
<span class="line-modified">1202 </span>
<span class="line-modified">1203         DEBUG_LOG(LOGIDENTIFIER, &quot;adding and positioning cue &quot;, i, &quot;: \&quot;&quot;, cue-&gt;text(), &quot;\&quot;, start=&quot;, cue-&gt;startTime(), &quot;, end=&quot;, cue-&gt;endTime(), &quot;, line=&quot;, cue-&gt;line());</span>
<span class="line-modified">1204         Ref&lt;VTTCueBox&gt; displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);</span>
<span class="line-modified">1205         RefPtr&lt;VTTRegion&gt; region = cue-&gt;track()-&gt;regions()-&gt;getRegionById(cue-&gt;regionId());</span>
<span class="line-modified">1206         if (!region) {</span>
<span class="line-removed">1207             // If cue has an empty text track cue region identifier or there is no</span>
<span class="line-removed">1208             // WebVTT region whose region identifier is identical to cue&#39;s text</span>
<span class="line-removed">1209             // track cue region identifier, run the following substeps:</span>
<span class="line-removed">1210             if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {</span>
<span class="line-removed">1211                 // Note: the display tree of a cue is removed when the active flag of the cue is unset.</span>
<span class="line-removed">1212                 appendChild(displayBox);</span>
<span class="line-removed">1213                 cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>
1214             }
<span class="line-removed">1215         } else {</span>
<span class="line-removed">1216             // Let region be the WebVTT region whose region identifier</span>
<span class="line-removed">1217             // matches the text track cue region identifier of cue.</span>
<span class="line-removed">1218             Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();</span>
<span class="line-removed">1219 </span>
<span class="line-removed">1220             // Append the region to the viewport, if it was not already.</span>
<span class="line-removed">1221             if (!contains(regionNode.ptr()))</span>
<span class="line-removed">1222                 appendChild(region-&gt;getDisplayTree());</span>
<span class="line-removed">1223 </span>
<span class="line-removed">1224             region-&gt;appendTextTrackCueBox(WTFMove(displayBox));</span>
1225         }
1226     }
1227 
1228     // 11. Return output.
1229     if (hasChildNodes()) {
1230         show();
1231         updateTextTrackRepresentation();
1232     } else {
1233         hide();
1234         clearTextTrackRepresentation();
1235     }
1236 }
1237 



























1238 void MediaControlTextTrackContainerElement::updateActiveCuesFontSize()
1239 {
1240     if (!document().page())
1241         return;
1242 
1243     auto mediaElement = parentMediaElement(this);
1244     if (!mediaElement)
1245         return;
1246 
1247     float smallestDimension = std::min(m_videoDisplaySize.size().height(), m_videoDisplaySize.size().width());
1248     float fontScale = document().page()-&gt;group().captionPreferences().captionFontSizeScaleAndImportance(m_fontSizeIsImportant);
1249     m_fontSize = lroundf(smallestDimension * fontScale);
1250 
1251     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues()) {
1252         RefPtr&lt;TextTrackCue&gt; cue = activeCue.data();
<span class="line-modified">1253         if (!cue-&gt;isRenderable())</span>
<span class="line-modified">1254             continue;</span>
<span class="line-removed">1255 </span>
<span class="line-removed">1256         toVTTCue(cue.get())-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>
1257     }
<span class="line-removed">1258 </span>
1259 }
1260 
1261 void MediaControlTextTrackContainerElement::updateTextStrokeStyle()
1262 {
1263     if (!document().page())
1264         return;
1265 
1266     auto mediaElement = parentMediaElement(this);
1267     if (!mediaElement)
1268         return;
1269 
1270     String language;
1271 
1272     // FIXME: Since it is possible to have more than one text track enabled, the following code may not find the correct language.
1273     // The default UI only allows a user to enable one track at a time, so it should be OK for now, but we should consider doing
1274     // this differently, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169875&gt;.
1275     if (auto* tracks = mediaElement-&gt;textTracks()) {
1276         for (unsigned i = 0; i &lt; tracks-&gt;length(); ++i) {
1277             auto track = tracks-&gt;item(i);
1278             if (track &amp;&amp; track-&gt;mode() == TextTrack::Mode::Showing) {
1279                 language = track-&gt;validBCP47Language();
1280                 break;
1281             }
1282         }
1283     }
1284 
1285     float strokeWidth;
1286     bool important;
1287 
1288     // FIXME: find a way to set this property in the stylesheet like the other user style preferences, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169874&gt;.
1289     if (document().page()-&gt;group().captionPreferences().captionStrokeWidthForFont(m_fontSize, language, strokeWidth, important))
<span class="line-modified">1290         setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSPrimitiveValue::CSS_PX, important);</span>
1291 }
1292 
1293 void MediaControlTextTrackContainerElement::updateTimerFired()
1294 {
1295     if (!document().page())
1296         return;
1297 







1298     if (m_textTrackRepresentation)
1299         updateStyleForTextTrackRepresentation();
1300 
1301     updateActiveCuesFontSize();
1302     updateDisplay();
1303     updateTextStrokeStyle();
1304 }
1305 
1306 void MediaControlTextTrackContainerElement::updateTextTrackRepresentation()
1307 {
1308     auto mediaElement = parentMediaElement(this);
1309     if (!mediaElement)
1310         return;
1311 
1312     if (!mediaElement-&gt;requiresTextTrackRepresentation()) {
1313         if (m_textTrackRepresentation) {
1314             clearTextTrackRepresentation();
<span class="line-modified">1315             updateSizes(true);</span>
1316         }
1317         return;
1318     }
1319 
1320     if (!m_textTrackRepresentation) {
1321         m_textTrackRepresentation = TextTrackRepresentation::create(*this);
1322         if (document().page())
1323             m_textTrackRepresentation-&gt;setContentScale(document().page()-&gt;deviceScaleFactor());
1324         m_updateTextTrackRepresentationStyle = true;
1325         mediaElement-&gt;setTextTrackRepresentation(m_textTrackRepresentation.get());
1326     }
1327 
1328     m_textTrackRepresentation-&gt;update();
1329     updateStyleForTextTrackRepresentation();
1330 }
1331 
1332 void MediaControlTextTrackContainerElement::clearTextTrackRepresentation()
1333 {
1334     if (!m_textTrackRepresentation)
1335         return;
1336 
1337     m_textTrackRepresentation = nullptr;
1338     m_updateTextTrackRepresentationStyle = true;
1339     if (auto mediaElement = parentMediaElement(this))
1340         mediaElement-&gt;setTextTrackRepresentation(nullptr);
1341     updateStyleForTextTrackRepresentation();
1342     updateActiveCuesFontSize();
1343 }
1344 
1345 void MediaControlTextTrackContainerElement::updateStyleForTextTrackRepresentation()
1346 {
1347     if (!m_updateTextTrackRepresentationStyle)
1348         return;

1349     m_updateTextTrackRepresentationStyle = false;
1350 
1351     if (m_textTrackRepresentation) {
<span class="line-modified">1352         setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">1353         setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSPrimitiveValue::CSS_PX);</span>
1354         setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
<span class="line-modified">1355         setInlineStyleProperty(CSSPropertyLeft, 0, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">1356         setInlineStyleProperty(CSSPropertyTop, 0, CSSPrimitiveValue::CSS_PX);</span>
1357         return;
1358     }
1359 
1360     removeInlineStyleProperty(CSSPropertyPosition);
1361     removeInlineStyleProperty(CSSPropertyWidth);
1362     removeInlineStyleProperty(CSSPropertyHeight);
1363     removeInlineStyleProperty(CSSPropertyLeft);
1364     removeInlineStyleProperty(CSSPropertyTop);
1365 }
1366 
1367 void MediaControlTextTrackContainerElement::enteredFullscreen()
1368 {
1369     if (hasChildNodes())
1370         updateTextTrackRepresentation();
<span class="line-modified">1371     updateSizes(true);</span>
1372 }
1373 
1374 void MediaControlTextTrackContainerElement::exitedFullscreen()
1375 {
1376     clearTextTrackRepresentation();
<span class="line-modified">1377     updateSizes(true);</span>
1378 }
1379 
<span class="line-modified">1380 void MediaControlTextTrackContainerElement::updateSizes(bool forceUpdate)</span>
1381 {
1382     auto mediaElement = parentMediaElement(this);
1383     if (!mediaElement)
1384         return;
1385 
1386     if (!document().page())
1387         return;
1388 
1389     IntRect videoBox;
1390     if (m_textTrackRepresentation) {
1391         videoBox = m_textTrackRepresentation-&gt;bounds();
1392         float deviceScaleFactor = document().page()-&gt;deviceScaleFactor();
1393         videoBox.setWidth(videoBox.width() * deviceScaleFactor);
1394         videoBox.setHeight(videoBox.height() * deviceScaleFactor);
1395     } else {
1396         if (!is&lt;RenderVideo&gt;(mediaElement-&gt;renderer()))
1397             return;
1398         videoBox = downcast&lt;RenderVideo&gt;(*mediaElement-&gt;renderer()).videoBox();
1399     }
1400 
<span class="line-modified">1401     if (!forceUpdate &amp;&amp; m_videoDisplaySize == videoBox)</span>
1402         return;
1403 
1404     m_videoDisplaySize = videoBox;
1405     m_updateTextTrackRepresentationStyle = true;
1406     mediaElement-&gt;syncTextTrackBounds();
1407 
1408     // FIXME (121170): This function is called during layout, and should lay out the text tracks immediately.
1409     m_updateTimer.startOneShot(0_s);
1410 }
1411 
1412 RefPtr&lt;Image&gt; MediaControlTextTrackContainerElement::createTextTrackRepresentationImage()
1413 {
1414     if (!hasChildNodes())
1415         return nullptr;
1416 
1417     RefPtr&lt;Frame&gt; frame = document().frame();
1418     if (!frame)
1419         return nullptr;
1420 
1421     document().updateLayout();
1422 
1423     auto* renderer = this-&gt;renderer();
1424     if (!renderer)
1425         return nullptr;
1426 
1427     if (!renderer-&gt;hasLayer())
1428         return nullptr;
1429 
1430     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*renderer).layer();
1431 
1432     float deviceScaleFactor = 1;
1433     if (Page* page = document().page())
1434         deviceScaleFactor = page-&gt;deviceScaleFactor();
1435 
1436     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1437 
1438     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">1439     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), Unaccelerated, deviceScaleFactor));</span>
1440     if (!buffer)
1441         return nullptr;
1442 
1443     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1444 
1445     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1446 }
1447 
1448 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1449 {
1450     if (hasChildNodes())
1451         updateTextTrackRepresentation();
1452     updateSizes();
1453 }
1454 
1455 #if !RELEASE_LOG_DISABLED
1456 const Logger&amp; MediaControlTextTrackContainerElement::logger() const
1457 {
1458     return document().logger();
1459 }
</pre>
</td>
<td>
<hr />
<pre>
  31 #include &quot;MediaControlElements.h&quot;
  32 
  33 #if ENABLE(VIDEO)
  34 
  35 #include &quot;DOMTokenList.h&quot;
  36 #include &quot;ElementChildIterator.h&quot;
  37 #include &quot;EventHandler.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
  40 #include &quot;FullscreenManager.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLHeadingElement.h&quot;
  43 #include &quot;HTMLLIElement.h&quot;
  44 #include &quot;HTMLUListElement.h&quot;
  45 #include &quot;HTMLVideoElement.h&quot;
  46 #include &quot;ImageBuffer.h&quot;
  47 #include &quot;LocalizedStrings.h&quot;
  48 #include &quot;Logging.h&quot;
  49 #include &quot;MediaControls.h&quot;
  50 #include &quot;MouseEvent.h&quot;
<span class="line-added">  51 #include &quot;PODInterval.h&quot;</span>
  52 #include &quot;Page.h&quot;
  53 #include &quot;PageGroup.h&quot;
  54 #include &quot;RenderLayer.h&quot;
  55 #include &quot;RenderMediaControlElements.h&quot;
  56 #include &quot;RenderSlider.h&quot;
  57 #include &quot;RenderTheme.h&quot;
  58 #include &quot;RenderVideo.h&quot;
  59 #include &quot;RenderView.h&quot;
  60 #include &quot;Settings.h&quot;
  61 #include &quot;ShadowRoot.h&quot;
<span class="line-added">  62 #include &quot;TextTrackCueGeneric.h&quot;</span>
  63 #include &quot;TextTrackList.h&quot;
  64 #include &quot;VTTRegionList.h&quot;
  65 #include &lt;wtf/IsoMallocInlines.h&gt;
  66 #include &lt;wtf/Language.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelElement);
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelEnclosureElement);
  72 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayEnclosureElement);
  73 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlTimelineContainerElement);
  74 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderContainerElement);
  75 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlStatusDisplayElement);
  76 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPanelMuteButtonElement);
  77 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlVolumeSliderMuteButtonElement);
  78 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlPlayButtonElement);
  79 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlOverlayPlayButtonElement);
  80 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekForwardButtonElement);
  81 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlSeekBackButtonElement);
  82 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaControlRewindButtonElement);
</pre>
<hr />
<pre>
 178 {
 179     if (m_transitionTimer.isActive())
 180         m_transitionTimer.stop();
 181 }
 182 
 183 void MediaControlPanelElement::transitionTimerFired()
 184 {
 185     if (!m_opaque)
 186         hide();
 187 
 188     stopTimer();
 189 }
 190 
 191 void MediaControlPanelElement::setPosition(const LayoutPoint&amp; position)
 192 {
 193     double left = position.x();
 194     double top = position.y();
 195 
 196     // Set the left and top to control the panel&#39;s position; this depends on it being absolute positioned.
 197     // Set the margin to zero since the position passed in will already include the effect of the margin.
<span class="line-modified"> 198     setInlineStyleProperty(CSSPropertyLeft, left, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 199     setInlineStyleProperty(CSSPropertyTop, top, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 200     setInlineStyleProperty(CSSPropertyMarginLeft, 0.0, CSSUnitType::CSS_PX);</span>
<span class="line-modified"> 201     setInlineStyleProperty(CSSPropertyMarginTop, 0.0, CSSUnitType::CSS_PX);</span>
 202 
 203     classList().add(&quot;dragged&quot;);
 204 }
 205 
 206 void MediaControlPanelElement::resetPosition()
 207 {
 208     removeInlineStyleProperty(CSSPropertyLeft);
 209     removeInlineStyleProperty(CSSPropertyTop);
 210     removeInlineStyleProperty(CSSPropertyMarginLeft);
 211     removeInlineStyleProperty(CSSPropertyMarginTop);
 212 
 213     classList().remove(&quot;dragged&quot;);
 214 
 215     m_cumulativeDragOffset.setX(0);
 216     m_cumulativeDragOffset.setY(0);
 217 }
 218 
 219 void MediaControlPanelElement::makeOpaque()
 220 {
 221     if (m_opaque)
 222         return;
 223 
 224     double duration = RenderTheme::singleton().mediaControlsFadeInDuration();
 225 
 226     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<span class="line-modified"> 227     setInlineStyleProperty(CSSPropertyTransitionDuration, duration, CSSUnitType::CSS_S);</span>
<span class="line-modified"> 228     setInlineStyleProperty(CSSPropertyOpacity, 1.0, CSSUnitType::CSS_NUMBER);</span>
 229 
 230     m_opaque = true;
 231 
 232     if (m_isDisplayed)
 233         show();
 234 }
 235 
 236 void MediaControlPanelElement::makeTransparent()
 237 {
 238     if (!m_opaque)
 239         return;
 240 
 241     Seconds duration = RenderTheme::singleton().mediaControlsFadeOutDuration();
 242 
 243     setInlineStyleProperty(CSSPropertyTransitionProperty, CSSPropertyOpacity);
<span class="line-modified"> 244     setInlineStyleProperty(CSSPropertyTransitionDuration, duration.value(), CSSUnitType::CSS_S);</span>
<span class="line-modified"> 245     setInlineStyleProperty(CSSPropertyOpacity, 0.0, CSSUnitType::CSS_NUMBER);</span>
 246 
 247     m_opaque = false;
 248     startTimer();
 249 }
 250 
 251 void MediaControlPanelElement::defaultEventHandler(Event&amp; event)
 252 {
 253     MediaControlDivElement::defaultEventHandler(event);
 254 
 255     if (is&lt;MouseEvent&gt;(event)) {
 256         LayoutPoint location = downcast&lt;MouseEvent&gt;(event).absoluteLocation();
 257         if (event.type() == eventNames().mousedownEvent &amp;&amp; event.target() == this) {
 258             startDrag(location);
 259             event.setDefaultHandled();
 260         } else if (event.type() == eventNames().mousemoveEvent &amp;&amp; m_isBeingDragged)
 261             continueDrag(location);
 262         else if (event.type() == eventNames().mouseupEvent &amp;&amp; m_isBeingDragged) {
 263             continueDrag(location);
 264             endDrag();
 265             event.setDefaultHandled();
</pre>
<hr />
<pre>
1110 
1111 RenderPtr&lt;RenderElement&gt; MediaControlTextTrackContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
1112 {
1113     return createRenderer&lt;RenderTextTrackContainerElement&gt;(*this, WTFMove(style));
1114 }
1115 
1116 static bool compareCueIntervalForDisplay(const CueInterval&amp; one, const CueInterval&amp; two)
1117 {
1118     return one.data()-&gt;isPositionedAbove(two.data());
1119 };
1120 
1121 void MediaControlTextTrackContainerElement::updateDisplay()
1122 {
1123     if (!mediaController()-&gt;closedCaptionsVisible())
1124         removeChildren();
1125 
1126     auto mediaElement = parentMediaElement(this);
1127     // 1. If the media element is an audio element, or is another playback
1128     // mechanism with no rendering area, abort these steps. There is nothing to
1129     // render.
<span class="line-modified">1130     if (!mediaElement || !mediaElement-&gt;isVideo() || m_videoDisplaySize.size().isEmpty())</span>
1131         return;
1132 
1133     // 2. Let video be the media element or other playback mechanism.
1134     HTMLVideoElement&amp; video = downcast&lt;HTMLVideoElement&gt;(*mediaElement);
1135 
1136     // 3. Let output be an empty list of absolutely positioned CSS block boxes.

1137 
1138     // 4. If the user agent is exposing a user interface for video, add to
1139     // output one or more completely transparent positioned CSS block boxes that
1140     // cover the same region as the user interface.
1141 
1142     // 5. If the last time these rules were run, the user agent was not exposing
1143     // a user interface for video, but now it is, let reset be true. Otherwise,
1144     // let reset be false.
1145 
1146     // There is nothing to be done explicitly for 4th and 5th steps, as
1147     // everything is handled through CSS. The caption box is on top of the
1148     // controls box, in a container set with the -webkit-box display property.
1149 
1150     // 6. Let tracks be the subset of video&#39;s list of text tracks that have as
1151     // their rules for updating the text track rendering these rules for
1152     // updating the display of WebVTT text tracks, and whose text track mode is
1153     // showing or showing by default.
1154     // 7. Let cues be an empty list of text track cues.
1155     // 8. For each track track in tracks, append to cues all the cues from
1156     // track&#39;s list of cues that have their text track cue active flag set.
1157     CueList activeCues = video.currentlyActiveCues();
1158 
1159     // 9. If reset is false, then, for each text track cue cue in cues: if cue&#39;s
1160     // text track cue display state has a set of CSS boxes, then add those boxes
1161     // to output, and remove cue from cues.
1162 
1163     // There is nothing explicitly to be done here, as all the caching occurs
1164     // within the TextTrackCue instance itself. If parameters of the cue change,
1165     // the display tree is cleared.
1166 
1167     // If the number of CSS boxes in the output is less than the number of cues
1168     // we wish to render (e.g., we are adding another cue in a set of roll-up
1169     // cues), remove all the existing CSS boxes representing the cues and re-add
1170     // them so that the new cue is at the bottom.
1171     // FIXME: Calling countChildNodes() here is inefficient. We don&#39;t need to
1172     // traverse all children just to check if there are less children than cues.
1173     if (countChildNodes() &lt; activeCues.size())
1174         removeChildren();
1175 
1176     activeCues.removeAllMatching([] (CueInterval&amp; cueInterval) {
<span class="line-modified">1177         RefPtr&lt;TextTrackCue&gt; cue = cueInterval.data();</span>
<span class="line-modified">1178         return !cue-&gt;track()</span>





1179             || !cue-&gt;track()-&gt;isRendered()
1180             || cue-&gt;track()-&gt;mode() == TextTrack::Mode::Disabled
1181             || !cue-&gt;isActive()
<span class="line-modified">1182             || !cue-&gt;isRenderable();</span>
1183     });
1184 
1185     // Sort the active cues for the appropriate display order. For example, for roll-up
1186     // or paint-on captions, we need to add the cues in reverse chronological order,
1187     // so that the newest captions appear at the bottom.
1188     std::sort(activeCues.begin(), activeCues.end(), &amp;compareCueIntervalForDisplay);
1189 
<span class="line-modified">1190     if (mediaController()-&gt;closedCaptionsVisible()) {</span>
<span class="line-modified">1191         // 10. For each text track cue cue in cues that has not yet had</span>
<span class="line-modified">1192         // corresponding CSS boxes added to output, in text track cue order, run the</span>
<span class="line-modified">1193         // following substeps:</span>
<span class="line-modified">1194         for (auto&amp; interval : activeCues) {</span>
<span class="line-modified">1195             auto cue = interval.data();</span>
<span class="line-modified">1196             cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>
<span class="line-modified">1197             if (is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue))</span>
<span class="line-modified">1198                 processActiveVTTCue(*toVTTCue(cue));</span>
<span class="line-modified">1199             else {</span>
<span class="line-modified">1200                 auto displayBox = cue-&gt;getDisplayTree(m_videoDisplaySize.size(), m_fontSize);</span>
<span class="line-modified">1201                 if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.get()))</span>
<span class="line-modified">1202                     appendChild(*displayBox);</span>







1203             }










1204         }
1205     }
1206 
1207     // 11. Return output.
1208     if (hasChildNodes()) {
1209         show();
1210         updateTextTrackRepresentation();
1211     } else {
1212         hide();
1213         clearTextTrackRepresentation();
1214     }
1215 }
1216 
<span class="line-added">1217 void MediaControlTextTrackContainerElement::processActiveVTTCue(VTTCue&amp; cue)</span>
<span class="line-added">1218 {</span>
<span class="line-added">1219     ASSERT(is&lt;VTTCue&gt;(cue) || is&lt;TextTrackCueGeneric&gt;(cue));</span>
<span class="line-added">1220 </span>
<span class="line-added">1221     DEBUG_LOG(LOGIDENTIFIER, &quot;adding and positioning cue: \&quot;&quot;, cue.text(), &quot;\&quot;, start=&quot;, cue.startTime(), &quot;, end=&quot;, cue.endTime(), &quot;, line=&quot;, cue.line());</span>
<span class="line-added">1222     Ref&lt;TextTrackCueBox&gt; displayBox = *cue.getDisplayTree(m_videoDisplaySize.size(), m_fontSize);</span>
<span class="line-added">1223 </span>
<span class="line-added">1224     if (auto region = cue.track()-&gt;regions()-&gt;getRegionById(cue.regionId())) {</span>
<span class="line-added">1225         // Let region be the WebVTT region whose region identifier</span>
<span class="line-added">1226         // matches the text track cue region identifier of cue.</span>
<span class="line-added">1227         Ref&lt;HTMLDivElement&gt; regionNode = region-&gt;getDisplayTree();</span>
<span class="line-added">1228 </span>
<span class="line-added">1229         if (!contains(regionNode.ptr()))</span>
<span class="line-added">1230             appendChild(region-&gt;getDisplayTree());</span>
<span class="line-added">1231 </span>
<span class="line-added">1232         region-&gt;appendTextTrackCueBox(WTFMove(displayBox));</span>
<span class="line-added">1233     } else {</span>
<span class="line-added">1234         // If cue has an empty text track cue region identifier or there is no</span>
<span class="line-added">1235         // WebVTT region whose region identifier is identical to cue&#39;s text</span>
<span class="line-added">1236         // track cue region identifier, run the following substeps:</span>
<span class="line-added">1237         if (displayBox-&gt;hasChildNodes() &amp;&amp; !contains(displayBox.ptr())) {</span>
<span class="line-added">1238             // Note: the display tree of a cue is removed when the active flag of the cue is unset.</span>
<span class="line-added">1239             appendChild(displayBox);</span>
<span class="line-added">1240         }</span>
<span class="line-added">1241     }</span>
<span class="line-added">1242 }</span>
<span class="line-added">1243 </span>
1244 void MediaControlTextTrackContainerElement::updateActiveCuesFontSize()
1245 {
1246     if (!document().page())
1247         return;
1248 
1249     auto mediaElement = parentMediaElement(this);
1250     if (!mediaElement)
1251         return;
1252 
1253     float smallestDimension = std::min(m_videoDisplaySize.size().height(), m_videoDisplaySize.size().width());
1254     float fontScale = document().page()-&gt;group().captionPreferences().captionFontSizeScaleAndImportance(m_fontSizeIsImportant);
1255     m_fontSize = lroundf(smallestDimension * fontScale);
1256 
1257     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues()) {
1258         RefPtr&lt;TextTrackCue&gt; cue = activeCue.data();
<span class="line-modified">1259         if (cue-&gt;isRenderable())</span>
<span class="line-modified">1260             cue-&gt;setFontSize(m_fontSize, m_videoDisplaySize.size(), m_fontSizeIsImportant);</span>


1261     }

1262 }
1263 
1264 void MediaControlTextTrackContainerElement::updateTextStrokeStyle()
1265 {
1266     if (!document().page())
1267         return;
1268 
1269     auto mediaElement = parentMediaElement(this);
1270     if (!mediaElement)
1271         return;
1272 
1273     String language;
1274 
1275     // FIXME: Since it is possible to have more than one text track enabled, the following code may not find the correct language.
1276     // The default UI only allows a user to enable one track at a time, so it should be OK for now, but we should consider doing
1277     // this differently, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169875&gt;.
1278     if (auto* tracks = mediaElement-&gt;textTracks()) {
1279         for (unsigned i = 0; i &lt; tracks-&gt;length(); ++i) {
1280             auto track = tracks-&gt;item(i);
1281             if (track &amp;&amp; track-&gt;mode() == TextTrack::Mode::Showing) {
1282                 language = track-&gt;validBCP47Language();
1283                 break;
1284             }
1285         }
1286     }
1287 
1288     float strokeWidth;
1289     bool important;
1290 
1291     // FIXME: find a way to set this property in the stylesheet like the other user style preferences, see &lt;https://bugs.webkit.org/show_bug.cgi?id=169874&gt;.
1292     if (document().page()-&gt;group().captionPreferences().captionStrokeWidthForFont(m_fontSize, language, strokeWidth, important))
<span class="line-modified">1293         setInlineStyleProperty(CSSPropertyStrokeWidth, strokeWidth, CSSUnitType::CSS_PX, important);</span>
1294 }
1295 
1296 void MediaControlTextTrackContainerElement::updateTimerFired()
1297 {
1298     if (!document().page())
1299         return;
1300 
<span class="line-added">1301     auto mediaElement = parentMediaElement(this);</span>
<span class="line-added">1302     if (!mediaElement)</span>
<span class="line-added">1303         return;</span>
<span class="line-added">1304 </span>
<span class="line-added">1305     for (auto&amp; activeCue : mediaElement-&gt;currentlyActiveCues())</span>
<span class="line-added">1306         activeCue.data()-&gt;recalculateStyles();</span>
<span class="line-added">1307 </span>
1308     if (m_textTrackRepresentation)
1309         updateStyleForTextTrackRepresentation();
1310 
1311     updateActiveCuesFontSize();
1312     updateDisplay();
1313     updateTextStrokeStyle();
1314 }
1315 
1316 void MediaControlTextTrackContainerElement::updateTextTrackRepresentation()
1317 {
1318     auto mediaElement = parentMediaElement(this);
1319     if (!mediaElement)
1320         return;
1321 
1322     if (!mediaElement-&gt;requiresTextTrackRepresentation()) {
1323         if (m_textTrackRepresentation) {
1324             clearTextTrackRepresentation();
<span class="line-modified">1325             updateSizes(ForceUpdate::Yes);</span>
1326         }
1327         return;
1328     }
1329 
1330     if (!m_textTrackRepresentation) {
1331         m_textTrackRepresentation = TextTrackRepresentation::create(*this);
1332         if (document().page())
1333             m_textTrackRepresentation-&gt;setContentScale(document().page()-&gt;deviceScaleFactor());
1334         m_updateTextTrackRepresentationStyle = true;
1335         mediaElement-&gt;setTextTrackRepresentation(m_textTrackRepresentation.get());
1336     }
1337 
1338     m_textTrackRepresentation-&gt;update();
1339     updateStyleForTextTrackRepresentation();
1340 }
1341 
1342 void MediaControlTextTrackContainerElement::clearTextTrackRepresentation()
1343 {
1344     if (!m_textTrackRepresentation)
1345         return;
1346 
1347     m_textTrackRepresentation = nullptr;
1348     m_updateTextTrackRepresentationStyle = true;
1349     if (auto mediaElement = parentMediaElement(this))
1350         mediaElement-&gt;setTextTrackRepresentation(nullptr);
1351     updateStyleForTextTrackRepresentation();
1352     updateActiveCuesFontSize();
1353 }
1354 
1355 void MediaControlTextTrackContainerElement::updateStyleForTextTrackRepresentation()
1356 {
1357     if (!m_updateTextTrackRepresentationStyle)
1358         return;
<span class="line-added">1359 </span>
1360     m_updateTextTrackRepresentationStyle = false;
1361 
1362     if (m_textTrackRepresentation) {
<span class="line-modified">1363         setInlineStyleProperty(CSSPropertyWidth, m_videoDisplaySize.size().width(), CSSUnitType::CSS_PX);</span>
<span class="line-modified">1364         setInlineStyleProperty(CSSPropertyHeight, m_videoDisplaySize.size().height(), CSSUnitType::CSS_PX);</span>
1365         setInlineStyleProperty(CSSPropertyPosition, CSSValueAbsolute);
<span class="line-modified">1366         setInlineStyleProperty(CSSPropertyLeft, 0, CSSUnitType::CSS_PX);</span>
<span class="line-modified">1367         setInlineStyleProperty(CSSPropertyTop, 0, CSSUnitType::CSS_PX);</span>
1368         return;
1369     }
1370 
1371     removeInlineStyleProperty(CSSPropertyPosition);
1372     removeInlineStyleProperty(CSSPropertyWidth);
1373     removeInlineStyleProperty(CSSPropertyHeight);
1374     removeInlineStyleProperty(CSSPropertyLeft);
1375     removeInlineStyleProperty(CSSPropertyTop);
1376 }
1377 
1378 void MediaControlTextTrackContainerElement::enteredFullscreen()
1379 {
1380     if (hasChildNodes())
1381         updateTextTrackRepresentation();
<span class="line-modified">1382     updateSizes(ForceUpdate::Yes);</span>
1383 }
1384 
1385 void MediaControlTextTrackContainerElement::exitedFullscreen()
1386 {
1387     clearTextTrackRepresentation();
<span class="line-modified">1388     updateSizes(ForceUpdate::Yes);</span>
1389 }
1390 
<span class="line-modified">1391 void MediaControlTextTrackContainerElement::updateSizes(ForceUpdate force)</span>
1392 {
1393     auto mediaElement = parentMediaElement(this);
1394     if (!mediaElement)
1395         return;
1396 
1397     if (!document().page())
1398         return;
1399 
1400     IntRect videoBox;
1401     if (m_textTrackRepresentation) {
1402         videoBox = m_textTrackRepresentation-&gt;bounds();
1403         float deviceScaleFactor = document().page()-&gt;deviceScaleFactor();
1404         videoBox.setWidth(videoBox.width() * deviceScaleFactor);
1405         videoBox.setHeight(videoBox.height() * deviceScaleFactor);
1406     } else {
1407         if (!is&lt;RenderVideo&gt;(mediaElement-&gt;renderer()))
1408             return;
1409         videoBox = downcast&lt;RenderVideo&gt;(*mediaElement-&gt;renderer()).videoBox();
1410     }
1411 
<span class="line-modified">1412     if (force == ForceUpdate::No &amp;&amp; m_videoDisplaySize == videoBox)</span>
1413         return;
1414 
1415     m_videoDisplaySize = videoBox;
1416     m_updateTextTrackRepresentationStyle = true;
1417     mediaElement-&gt;syncTextTrackBounds();
1418 
1419     // FIXME (121170): This function is called during layout, and should lay out the text tracks immediately.
1420     m_updateTimer.startOneShot(0_s);
1421 }
1422 
1423 RefPtr&lt;Image&gt; MediaControlTextTrackContainerElement::createTextTrackRepresentationImage()
1424 {
1425     if (!hasChildNodes())
1426         return nullptr;
1427 
1428     RefPtr&lt;Frame&gt; frame = document().frame();
1429     if (!frame)
1430         return nullptr;
1431 
1432     document().updateLayout();
1433 
1434     auto* renderer = this-&gt;renderer();
1435     if (!renderer)
1436         return nullptr;
1437 
1438     if (!renderer-&gt;hasLayer())
1439         return nullptr;
1440 
1441     RenderLayer* layer = downcast&lt;RenderLayerModelObject&gt;(*renderer).layer();
1442 
1443     float deviceScaleFactor = 1;
1444     if (Page* page = document().page())
1445         deviceScaleFactor = page-&gt;deviceScaleFactor();
1446 
1447     IntRect paintingRect = IntRect(IntPoint(), layer-&gt;size());
1448 
1449     // FIXME (149422): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">1450     std::unique_ptr&lt;ImageBuffer&gt; buffer(ImageBuffer::create(paintingRect.size(), RenderingMode::Unaccelerated, deviceScaleFactor));</span>
1451     if (!buffer)
1452         return nullptr;
1453 
1454     layer-&gt;paint(buffer-&gt;context(), paintingRect, LayoutSize(), { PaintBehavior::FlattenCompositingLayers, PaintBehavior::Snapshotting }, nullptr, RenderLayer::paintLayerPaintingCompositingAllPhasesFlags());
1455 
1456     return ImageBuffer::sinkIntoImage(WTFMove(buffer));
1457 }
1458 
1459 void MediaControlTextTrackContainerElement::textTrackRepresentationBoundsChanged(const IntRect&amp;)
1460 {
1461     if (hasChildNodes())
1462         updateTextTrackRepresentation();
1463     updateSizes();
1464 }
1465 
1466 #if !RELEASE_LOG_DISABLED
1467 const Logger&amp; MediaControlTextTrackContainerElement::logger() const
1468 {
1469     return document().logger();
1470 }
</pre>
</td>
</tr>
</table>
<center><a href="../parser/HTMLTreeBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaControlElements.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
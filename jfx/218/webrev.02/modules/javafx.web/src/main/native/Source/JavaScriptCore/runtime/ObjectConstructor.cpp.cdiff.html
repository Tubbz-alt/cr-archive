<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NumberPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectConstructor.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ObjectConstructor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,25 ***</span>
  #include &quot;StackVisitor.h&quot;
  #include &quot;Symbol.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorAssign(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIs(ExecState*);</span>
  
  }
  
  #include &quot;ObjectConstructor.lut.h&quot;
  
<span class="line-new-header">--- 38,25 ---</span>
  #include &quot;StackVisitor.h&quot;
  #include &quot;Symbol.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorAssign(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorValues(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorCreate(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSeal(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIs(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;ObjectConstructor.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,21 ***</span>
    fromEntries               JSBuiltin                                   DontEnum|Function 1
  @end
  */
  
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState*);</span>
  
  ObjectConstructor::ObjectConstructor(VM&amp; vm, Structure* structure)
      : InternalFunction(vm, structure, callObjectConstructor, constructWithObjectConstructor)
  {
  }
  
  void ObjectConstructor::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, ObjectPrototype* objectPrototype)
  {
<span class="line-modified">!     Base::finishCreation(vm, vm.propertyNames-&gt;Object.string(), NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);</span>
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, objectPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
  
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().createPrivateName(), objectConstructorCreate, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
<span class="line-new-header">--- 91,21 ---</span>
    fromEntries               JSBuiltin                                   DontEnum|Function 1
  @end
  */
  
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callObjectConstructor(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(JSGlobalObject*, CallFrame*);</span>
  
  ObjectConstructor::ObjectConstructor(VM&amp; vm, Structure* structure)
      : InternalFunction(vm, structure, callObjectConstructor, constructWithObjectConstructor)
  {
  }
  
  void ObjectConstructor::finishCreation(VM&amp; vm, JSGlobalObject* globalObject, ObjectPrototype* objectPrototype)
  {
<span class="line-modified">!     Base::finishCreation(vm, vm.propertyNames-&gt;Object.string(), NameAdditionMode::WithoutStructureTransition);</span>
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;prototype, objectPrototype, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
  
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().createPrivateName(), objectConstructorCreate, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,204 ***</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getPrototypeOfPrivateName(), objectConstructorGetPrototypeOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getOwnPropertyNamesPrivateName(), objectConstructorGetOwnPropertyNames, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
  }
  
  // ES 19.1.1.1 Object([value])
<span class="line-modified">! static ALWAYS_INLINE JSObject* constructObject(ExecState* exec, JSValue newTarget)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     ObjectConstructor* objectConstructor = jsCast&lt;ObjectConstructor*&gt;(exec-&gt;jsCallee());</span>
<span class="line-removed">-     JSGlobalObject* globalObject = objectConstructor-&gt;globalObject(vm);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We need to check newTarget condition in this caller side instead of InternalFunction::createSubclassStructure side.
      // Since if we found this condition is met, we should not fall into the type conversion in the step 3.
  
      // 1. If NewTarget is neither undefined nor the active function, then
      if (newTarget &amp;&amp; newTarget != objectConstructor) {
          // a. Return ? OrdinaryCreateFromConstructor(NewTarget, &quot;%ObjectPrototype%&quot;).
<span class="line-modified">!         Structure* objectStructure = InternalFunction::createSubclassStructure(exec, newTarget, globalObject-&gt;objectStructureForObjectConstructor());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         return constructEmptyObject(exec, objectStructure);</span>
      }
  
      // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
<span class="line-modified">!     ArgList args(exec);</span>
<span class="line-modified">!     JSValue arg = args.at(0);</span>
<span class="line-modified">!     if (arg.isUndefinedOrNull())</span>
<span class="line-removed">-         return constructEmptyObject(exec, globalObject-&gt;objectStructureForObjectConstructor());</span>
  
      // 3. Return ToObject(value).
<span class="line-modified">!     RELEASE_AND_RETURN(scope, arg.toObject(exec, globalObject));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(constructObject(exec, exec-&gt;newTarget()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callObjectConstructor(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(constructObject(exec, JSValue()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(object-&gt;getPrototype(vm, exec)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue objectValue = exec-&gt;argument(0);</span>
      if (objectValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Cannot set prototype of undefined or null&quot;_s);</span>
  
<span class="line-modified">!     JSValue protoValue = exec-&gt;argument(1);</span>
      if (!protoValue.isObject() &amp;&amp; !protoValue.isNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Prototype value can only be an object or null&quot;_s);</span>
  
<span class="line-modified">!     JSObject* object = objectValue.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      bool shouldThrowIfCantSet = true;
<span class="line-modified">!     bool didSetPrototype = object-&gt;setPrototype(vm, exec, protoValue, shouldThrowIfCantSet);</span>
      EXCEPTION_ASSERT_UNUSED(didSetPrototype, scope.exception() || didSetPrototype);
      return JSValue::encode(objectValue);
  }
  
<span class="line-modified">! JSValue objectConstructorGetOwnPropertyDescriptor(ExecState* exec, JSObject* object, const Identifier&amp; propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor))</span>
          RELEASE_AND_RETURN(scope, jsUndefined());
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSObject* result = constructObjectFromPropertyDescriptor(exec, descriptor);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !result);
      if (!result)
          return jsUndefined();
      return result;
  }
  
<span class="line-modified">! JSValue objectConstructorGetOwnPropertyDescriptors(ExecState* exec, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSObject* descriptors = constructEmptyObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      for (auto&amp; propertyName : properties) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, descriptor);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (!didGetDescriptor)
              continue;
  
<span class="line-modified">!         JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(exec, descriptor);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !fromDescriptor);
          if (!fromDescriptor)
              return jsUndefined();
  
          PutPropertySlot slot(descriptors);
<span class="line-modified">!         descriptors-&gt;putOwnDataPropertyMayBeIndex(exec, propertyName, fromDescriptor, slot);</span>
          scope.assertNoException();
      }
  
      return descriptors;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptor(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(exec, object, propertyName)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptors(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptors(exec, object)));</span>
  }
  
  // FIXME: Use the enumeration cache.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Include)));</span>
  }
  
  // FIXME: Use the enumeration cache.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertySymbols(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Symbols, DontEnumPropertiesMode::Include)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorKeys(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = exec-&gt;argument(0).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorAssign(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue targetValue = exec-&gt;argument(0);</span>
      if (targetValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Object.assign requires that input parameter not be null or undefined&quot;_s);</span>
<span class="line-modified">!     JSObject* target = targetValue.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // FIXME: Extend this for non JSFinalObject. For example, we would like to use this fast path for function objects too.
      // https://bugs.webkit.org/show_bug.cgi?id=185358
      bool targetCanPerformFastPut = jsDynamicCast&lt;JSFinalObject*&gt;(vm, target) &amp;&amp; target-&gt;canPerformFastPutInlineExcludingProto(vm);
  
      Vector&lt;RefPtr&lt;UniquedStringImpl&gt;, 8&gt; properties;
      MarkedArgumentBuffer values;
<span class="line-modified">!     unsigned argsCount = exec-&gt;argumentCount();</span>
      for (unsigned i = 1; i &lt; argsCount; ++i) {
<span class="line-modified">!         JSValue sourceValue = exec-&gt;uncheckedArgument(i);</span>
          if (sourceValue.isUndefinedOrNull())
              continue;
<span class="line-modified">!         JSObject* source = sourceValue.toObject(exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (targetCanPerformFastPut) {
              if (!source-&gt;staticPropertiesReified(vm)) {
<span class="line-modified">!                 source-&gt;reifyAllStaticProperties(exec);</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
  
              auto canPerformFastPropertyEnumerationForObjectAssign = [] (Structure* structure) {
                  if (structure-&gt;typeInfo().overridesGetOwnPropertySlot())
<span class="line-new-header">--- 113,202 ---</span>
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getPrototypeOfPrivateName(), objectConstructorGetPrototypeOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
      JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().getOwnPropertyNamesPrivateName(), objectConstructorGetOwnPropertyNames, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
  }
  
  // ES 19.1.1.1 Object([value])
<span class="line-modified">! static ALWAYS_INLINE JSObject* constructObjectWithNewTarget(JSGlobalObject* globalObject, CallFrame* callFrame, JSValue newTarget)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     ObjectConstructor* objectConstructor = jsCast&lt;ObjectConstructor*&gt;(callFrame-&gt;jsCallee());</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // We need to check newTarget condition in this caller side instead of InternalFunction::createSubclassStructure side.
      // Since if we found this condition is met, we should not fall into the type conversion in the step 3.
  
      // 1. If NewTarget is neither undefined nor the active function, then
      if (newTarget &amp;&amp; newTarget != objectConstructor) {
          // a. Return ? OrdinaryCreateFromConstructor(NewTarget, &quot;%ObjectPrototype%&quot;).
<span class="line-modified">!         Structure* objectStructure = InternalFunction::createSubclassStructure(globalObject, objectConstructor, newTarget, globalObject-&gt;objectStructureForObjectConstructor());</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         return constructEmptyObject(vm, objectStructure);</span>
      }
  
      // 2. If value is null, undefined or not supplied, return ObjectCreate(%ObjectPrototype%).
<span class="line-modified">!     JSValue argument = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     if (argument.isUndefinedOrNull())</span>
<span class="line-modified">!         return constructEmptyObject(vm, globalObject-&gt;objectStructureForObjectConstructor());</span>
  
      // 3. Return ToObject(value).
<span class="line-modified">!     RELEASE_AND_RETURN(scope, argument.toObject(globalObject));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL constructWithObjectConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(constructObjectWithNewTarget(globalObject, callFrame, callFrame-&gt;newTarget()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callObjectConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(constructObjectWithNewTarget(globalObject, callFrame, JSValue()));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(object-&gt;getPrototype(vm, globalObject)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue objectValue = callFrame-&gt;argument(0);</span>
      if (objectValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Cannot set prototype of undefined or null&quot;_s);</span>
  
<span class="line-modified">!     JSValue protoValue = callFrame-&gt;argument(1);</span>
      if (!protoValue.isObject() &amp;&amp; !protoValue.isNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Prototype value can only be an object or null&quot;_s);</span>
  
<span class="line-modified">!     JSObject* object = objectValue.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      bool shouldThrowIfCantSet = true;
<span class="line-modified">!     bool didSetPrototype = object-&gt;setPrototype(vm, globalObject, protoValue, shouldThrowIfCantSet);</span>
      EXCEPTION_ASSERT_UNUSED(didSetPrototype, scope.exception() || didSetPrototype);
      return JSValue::encode(objectValue);
  }
  
<span class="line-modified">! JSValue objectConstructorGetOwnPropertyDescriptor(JSGlobalObject* globalObject, JSObject* object, const Identifier&amp; propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertyDescriptor descriptor;
<span class="line-modified">!     if (!object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor))</span>
          RELEASE_AND_RETURN(scope, jsUndefined());
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSObject* result = constructObjectFromPropertyDescriptor(globalObject, descriptor);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !result);
      if (!result)
          return jsUndefined();
      return result;
  }
  
<span class="line-modified">! JSValue objectConstructorGetOwnPropertyDescriptors(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSObject* descriptors = constructEmptyObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      for (auto&amp; propertyName : properties) {
          PropertyDescriptor descriptor;
<span class="line-modified">!         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, descriptor);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (!didGetDescriptor)
              continue;
  
<span class="line-modified">!         JSObject* fromDescriptor = constructObjectFromPropertyDescriptor(globalObject, descriptor);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !fromDescriptor);
          if (!fromDescriptor)
              return jsUndefined();
  
          PutPropertySlot slot(descriptors);
<span class="line-modified">!         descriptors-&gt;putOwnDataPropertyMayBeIndex(globalObject, propertyName, fromDescriptor, slot);</span>
          scope.assertNoException();
      }
  
      return descriptors;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(globalObject, object, propertyName)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyDescriptors(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptors(globalObject, object)));</span>
  }
  
  // FIXME: Use the enumeration cache.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertyNames(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Include)));</span>
  }
  
  // FIXME: Use the enumeration cache.
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorGetOwnPropertySymbols(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Symbols, DontEnumPropertiesMode::Include)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = callFrame-&gt;argument(0).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, object, PropertyNameMode::Strings, DontEnumPropertiesMode::Exclude)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorAssign(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue targetValue = callFrame-&gt;argument(0);</span>
      if (targetValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Object.assign requires that input parameter not be null or undefined&quot;_s);</span>
<span class="line-modified">!     JSObject* target = targetValue.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // FIXME: Extend this for non JSFinalObject. For example, we would like to use this fast path for function objects too.
      // https://bugs.webkit.org/show_bug.cgi?id=185358
      bool targetCanPerformFastPut = jsDynamicCast&lt;JSFinalObject*&gt;(vm, target) &amp;&amp; target-&gt;canPerformFastPutInlineExcludingProto(vm);
  
      Vector&lt;RefPtr&lt;UniquedStringImpl&gt;, 8&gt; properties;
      MarkedArgumentBuffer values;
<span class="line-modified">!     unsigned argsCount = callFrame-&gt;argumentCount();</span>
      for (unsigned i = 1; i &lt; argsCount; ++i) {
<span class="line-modified">!         JSValue sourceValue = callFrame-&gt;uncheckedArgument(i);</span>
          if (sourceValue.isUndefinedOrNull())
              continue;
<span class="line-modified">!         JSObject* source = sourceValue.toObject(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          if (targetCanPerformFastPut) {
              if (!source-&gt;staticPropertiesReified(vm)) {
<span class="line-modified">!                 source-&gt;reifyAllStaticProperties(globalObject);</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
  
              auto canPerformFastPropertyEnumerationForObjectAssign = [] (Structure* structure) {
                  if (structure-&gt;typeInfo().overridesGetOwnPropertySlot())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,31 ***</span>
          // [[GetOwnPropertyNames]], [[Get]] etc. could modify target object and invalidate this assumption.
          // For example, [[Get]] of source object could configure setter to target object. So disable the fast path.
          targetCanPerformFastPut = false;
  
          PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!         source-&gt;methodTable(vm)-&gt;getOwnPropertyNames(source, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          auto assign = [&amp;] (PropertyName propertyName) {
              PropertySlot slot(source, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!             bool hasProperty = source-&gt;methodTable(vm)-&gt;getOwnPropertySlot(source, exec, propertyName, slot);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (!hasProperty)
                  return;
              if (slot.attributes() &amp; PropertyAttribute::DontEnum)
                  return;
  
              JSValue value;
              if (LIKELY(!slot.isTaintedByOpaqueObject()))
<span class="line-modified">!                 value = slot.getValue(exec, propertyName);</span>
              else
<span class="line-modified">!                 value = source-&gt;get(exec, propertyName);</span>
              RETURN_IF_EXCEPTION(scope, void());
  
              PutPropertySlot putPropertySlot(target, true);
<span class="line-modified">!             target-&gt;putInline(exec, propertyName, value, putPropertySlot);</span>
          };
  
          // First loop is for strings. Second loop is for symbols to keep standardized order requirement in the spec.
          // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
          bool foundSymbol = false;
<span class="line-new-header">--- 370,31 ---</span>
          // [[GetOwnPropertyNames]], [[Get]] etc. could modify target object and invalidate this assumption.
          // For example, [[Get]] of source object could configure setter to target object. So disable the fast path.
          targetCanPerformFastPut = false;
  
          PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!         source-&gt;methodTable(vm)-&gt;getOwnPropertyNames(source, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          auto assign = [&amp;] (PropertyName propertyName) {
              PropertySlot slot(source, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!             bool hasProperty = source-&gt;methodTable(vm)-&gt;getOwnPropertySlot(source, globalObject, propertyName, slot);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (!hasProperty)
                  return;
              if (slot.attributes() &amp; PropertyAttribute::DontEnum)
                  return;
  
              JSValue value;
              if (LIKELY(!slot.isTaintedByOpaqueObject()))
<span class="line-modified">!                 value = slot.getValue(globalObject, propertyName);</span>
              else
<span class="line-modified">!                 value = source-&gt;get(globalObject, propertyName);</span>
              RETURN_IF_EXCEPTION(scope, void());
  
              PutPropertySlot putPropertySlot(target, true);
<span class="line-modified">!             target-&gt;putInline(globalObject, propertyName, value, putPropertySlot);</span>
          };
  
          // First loop is for strings. Second loop is for symbols to keep standardized order requirement in the spec.
          // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
          bool foundSymbol = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,46 ***</span>
          }
      }
      return JSValue::encode(target);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorValues(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue targetValue = exec-&gt;argument(0);</span>
      if (targetValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Object.values requires that input parameter not be null or undefined&quot;_s);</span>
<span class="line-modified">!     JSObject* target = targetValue.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSArray* values = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyNameArray properties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned index = 0;
      auto addValue = [&amp;] (PropertyName propertyName) {
          PropertySlot slot(target, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!         bool hasProperty = target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, exec, propertyName, slot);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (!hasProperty)
              return;
          if (slot.attributes() &amp; PropertyAttribute::DontEnum)
              return;
  
          JSValue value;
          if (LIKELY(!slot.isTaintedByOpaqueObject()))
<span class="line-modified">!             value = slot.getValue(exec, propertyName);</span>
          else
<span class="line-modified">!             value = target-&gt;get(exec, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         values-&gt;putDirectIndex(exec, index++, value);</span>
      };
  
      for (unsigned i = 0, numProperties = properties.size(); i &lt; numProperties; i++) {
          const auto&amp; propertyName = properties[i];
          if (propertyName.isSymbol())
<span class="line-new-header">--- 422,46 ---</span>
          }
      }
      return JSValue::encode(target);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorValues(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue targetValue = callFrame-&gt;argument(0);</span>
      if (targetValue.isUndefinedOrNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Object.values requires that input parameter not be null or undefined&quot;_s);</span>
<span class="line-modified">!     JSObject* target = targetValue.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     JSArray* values = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertyNameArray properties(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
<span class="line-modified">!     target-&gt;methodTable(vm)-&gt;getOwnPropertyNames(target, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      unsigned index = 0;
      auto addValue = [&amp;] (PropertyName propertyName) {
          PropertySlot slot(target, PropertySlot::InternalMethodType::GetOwnProperty);
<span class="line-modified">!         bool hasProperty = target-&gt;methodTable(vm)-&gt;getOwnPropertySlot(target, globalObject, propertyName, slot);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (!hasProperty)
              return;
          if (slot.attributes() &amp; PropertyAttribute::DontEnum)
              return;
  
          JSValue value;
          if (LIKELY(!slot.isTaintedByOpaqueObject()))
<span class="line-modified">!             value = slot.getValue(globalObject, propertyName);</span>
          else
<span class="line-modified">!             value = target-&gt;get(globalObject, propertyName);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         values-&gt;putDirectIndex(globalObject, index++, value);</span>
      };
  
      for (unsigned i = 0, numProperties = properties.size(); i &lt; numProperties; i++) {
          const auto&amp; propertyName = properties[i];
          if (propertyName.isSymbol())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 477,83 ***</span>
  }
  
  
  // ES6 6.2.4.5 ToPropertyDescriptor
  // https://tc39.github.io/ecma262/#sec-topropertydescriptor
<span class="line-modified">! bool toPropertyDescriptor(ExecState* exec, JSValue in, PropertyDescriptor&amp; desc)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!in.isObject()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Property description must be an object.&quot;_s);</span>
          return false;
      }
      JSObject* description = asObject(in);
  
<span class="line-modified">!     bool hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;enumerable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(exec, vm.propertyNames-&gt;enumerable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setEnumerable(value.toBoolean(exec));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;configurable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(exec, vm.propertyNames-&gt;configurable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setConfigurable(value.toBoolean(exec));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
      JSValue value;
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;value);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(exec, vm.propertyNames-&gt;value);</span>
          RETURN_IF_EXCEPTION(scope, false);
          desc.setValue(value);
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;writable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(exec, vm.propertyNames-&gt;writable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setWritable(value.toBoolean(exec));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;get);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue get = description-&gt;get(exec, vm.propertyNames-&gt;get);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!get.isUndefined()) {
              CallData callData;
              if (getCallData(vm, get, callData) == CallType::None) {
<span class="line-modified">!                 throwTypeError(exec, scope, &quot;Getter must be a function.&quot;_s);</span>
                  return false;
              }
          }
          desc.setGetter(get);
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(exec, vm.propertyNames-&gt;set);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue set = description-&gt;get(exec, vm.propertyNames-&gt;set);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!set.isUndefined()) {
              CallData callData;
              if (getCallData(vm, set, callData) == CallType::None) {
<span class="line-modified">!                 throwTypeError(exec, scope, &quot;Setter must be a function.&quot;_s);</span>
                  return false;
              }
          }
          desc.setSetter(set);
      } else
<span class="line-new-header">--- 475,83 ---</span>
  }
  
  
  // ES6 6.2.4.5 ToPropertyDescriptor
  // https://tc39.github.io/ecma262/#sec-topropertydescriptor
<span class="line-modified">! bool toPropertyDescriptor(JSGlobalObject* globalObject, JSValue in, PropertyDescriptor&amp; desc)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!in.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Property description must be an object.&quot;_s);</span>
          return false;
      }
      JSObject* description = asObject(in);
  
<span class="line-modified">!     bool hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;enumerable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(globalObject, vm.propertyNames-&gt;enumerable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setEnumerable(value.toBoolean(globalObject));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;configurable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(globalObject, vm.propertyNames-&gt;configurable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setConfigurable(value.toBoolean(globalObject));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
      JSValue value;
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;value);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(globalObject, vm.propertyNames-&gt;value);</span>
          RETURN_IF_EXCEPTION(scope, false);
          desc.setValue(value);
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;writable);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue value = description-&gt;get(globalObject, vm.propertyNames-&gt;writable);</span>
          RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!         desc.setWritable(value.toBoolean(globalObject));</span>
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;get);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue get = description-&gt;get(globalObject, vm.propertyNames-&gt;get);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!get.isUndefined()) {
              CallData callData;
              if (getCallData(vm, get, callData) == CallType::None) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, &quot;Getter must be a function.&quot;_s);</span>
                  return false;
              }
          }
          desc.setGetter(get);
      } else
          RETURN_IF_EXCEPTION(scope, false);
  
<span class="line-modified">!     hasProperty = description-&gt;hasProperty(globalObject, vm.propertyNames-&gt;set);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty) {
<span class="line-modified">!         JSValue set = description-&gt;get(globalObject, vm.propertyNames-&gt;set);</span>
          RETURN_IF_EXCEPTION(scope, false);
          if (!set.isUndefined()) {
              CallData callData;
              if (getCallData(vm, set, callData) == CallType::None) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, &quot;Setter must be a function.&quot;_s);</span>
                  return false;
              }
          }
          desc.setSetter(set);
      } else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,49 ***</span>
  
      if (!desc.isAccessorDescriptor())
          return true;
  
      if (desc.value()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Invalid property.  &#39;value&#39; present on property with getter or setter.&quot;_s);</span>
          return false;
      }
  
      if (desc.writablePresent()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Invalid property.  &#39;writable&#39; present on property with getter or setter.&quot;_s);</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!exec-&gt;argument(0).isObject())</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);</span>
<span class="line-modified">!     JSObject* obj = asObject(exec-&gt;argument(0));</span>
<span class="line-modified">!     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      PropertyDescriptor descriptor;
<span class="line-modified">!     auto success = toPropertyDescriptor(exec, exec-&gt;argument(2), descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() == success);
      if (!success)
          return JSValue::encode(jsNull());
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      scope.assertNoException();
<span class="line-modified">!     obj-&gt;methodTable(vm)-&gt;defineOwnProperty(obj, exec, propertyName, descriptor, true);</span>
      RELEASE_AND_RETURN(scope, JSValue::encode(obj));
  }
  
<span class="line-modified">! static JSValue defineProperties(ExecState* exec, JSObject* object, JSObject* properties)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      PropertyNameArray propertyNames(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     asObject(properties)-&gt;methodTable(vm)-&gt;getOwnPropertyNames(asObject(properties), exec, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));</span>
      RETURN_IF_EXCEPTION(scope, { });
      size_t numProperties = propertyNames.size();
      Vector&lt;PropertyDescriptor&gt; descriptors;
      MarkedArgumentBuffer markBuffer;
  #define RETURN_IF_EXCEPTION_CLEARING_OVERFLOW(value) do { \
<span class="line-new-header">--- 559,49 ---</span>
  
      if (!desc.isAccessorDescriptor())
          return true;
  
      if (desc.value()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid property.  &#39;value&#39; present on property with getter or setter.&quot;_s);</span>
          return false;
      }
  
      if (desc.writablePresent()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid property.  &#39;writable&#39; present on property with getter or setter.&quot;_s);</span>
          return false;
      }
      return true;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!callFrame-&gt;argument(0).isObject())</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Properties can only be defined on Objects.&quot;_s);</span>
<span class="line-modified">!     JSObject* obj = asObject(callFrame-&gt;argument(0));</span>
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      PropertyDescriptor descriptor;
<span class="line-modified">!     auto success = toPropertyDescriptor(globalObject, callFrame-&gt;argument(2), descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() == success);
      if (!success)
          return JSValue::encode(jsNull());
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      scope.assertNoException();
<span class="line-modified">!     obj-&gt;methodTable(vm)-&gt;defineOwnProperty(obj, globalObject, propertyName, descriptor, true);</span>
      RELEASE_AND_RETURN(scope, JSValue::encode(obj));
  }
  
<span class="line-modified">! static JSValue defineProperties(JSGlobalObject* globalObject, JSObject* object, JSObject* properties)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      PropertyNameArray propertyNames(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     asObject(properties)-&gt;methodTable(vm)-&gt;getOwnPropertyNames(asObject(properties), globalObject, propertyNames, EnumerationMode(DontEnumPropertiesMode::Exclude));</span>
      RETURN_IF_EXCEPTION(scope, { });
      size_t numProperties = propertyNames.size();
      Vector&lt;PropertyDescriptor&gt; descriptors;
      MarkedArgumentBuffer markBuffer;
  #define RETURN_IF_EXCEPTION_CLEARING_OVERFLOW(value) do { \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 611,14 ***</span>
          markBuffer.overflowCheckNotNeeded(); \
          return value; \
      } \
  } while (false)
      for (size_t i = 0; i &lt; numProperties; i++) {
<span class="line-modified">!         JSValue prop = properties-&gt;get(exec, propertyNames[i]);</span>
          RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
          PropertyDescriptor descriptor;
<span class="line-modified">!         toPropertyDescriptor(exec, prop, descriptor);</span>
          RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
          descriptors.append(descriptor);
          // Ensure we mark all the values that we&#39;re accumulating
          if (descriptor.isDataDescriptor() &amp;&amp; descriptor.value())
              markBuffer.append(descriptor.value());
<span class="line-new-header">--- 609,14 ---</span>
          markBuffer.overflowCheckNotNeeded(); \
          return value; \
      } \
  } while (false)
      for (size_t i = 0; i &lt; numProperties; i++) {
<span class="line-modified">!         JSValue prop = properties-&gt;get(globalObject, propertyNames[i]);</span>
          RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
          PropertyDescriptor descriptor;
<span class="line-modified">!         toPropertyDescriptor(globalObject, prop, descriptor);</span>
          RETURN_IF_EXCEPTION_CLEARING_OVERFLOW({ });
          descriptors.append(descriptor);
          // Ensure we mark all the values that we&#39;re accumulating
          if (descriptor.isDataDescriptor() &amp;&amp; descriptor.value())
              markBuffer.append(descriptor.value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 633,68 ***</span>
  #undef RETURN_IF_EXCEPTION_CLEARING_OVERFLOW
      for (size_t i = 0; i &lt; numProperties; i++) {
          auto&amp; propertyName = propertyNames[i];
          ASSERT(!propertyName.isPrivateName());
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, exec, propertyName, descriptors[i], true);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!exec-&gt;argument(0).isObject())</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Properties can only be defined on Objects.&quot;_s);</span>
<span class="line-modified">!     JSObject* targetObj = asObject(exec-&gt;argument(0));</span>
<span class="line-modified">!     JSObject* props = exec-&gt;argument(1).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !props);
      if (UNLIKELY(!props))
          return encodedJSValue();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, targetObj, props)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorCreate(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue proto = exec-&gt;argument(0);</span>
      if (!proto.isObject() &amp;&amp; !proto.isNull())
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
      JSObject* newObject = proto.isObject()
<span class="line-modified">!         ? constructEmptyObject(exec, asObject(proto))</span>
<span class="line-modified">!         : constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
<span class="line-modified">!     if (exec-&gt;argument(1).isUndefined())</span>
          return JSValue::encode(newObject);
<span class="line-modified">!     JSObject* properties = exec-&gt;uncheckedArgument(1).toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(exec, newObject, properties)));</span>
  }
  
  enum class IntegrityLevel {
      Sealed,
      Frozen
  };
  
  template&lt;IntegrityLevel level&gt;
<span class="line-modified">! bool setIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)</span>
  {
      // See https://tc39.github.io/ecma262/#sec-setintegritylevel.
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     bool success = object-&gt;methodTable(vm)-&gt;preventExtensions(object, exec);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (UNLIKELY(!success))
          return false;
  
      PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      PropertyNameArray::const_iterator end = properties.end();
      for (PropertyNameArray::const_iterator iter = properties.begin(); iter != end; ++iter) {
          auto&amp; propertyName = *iter;
<span class="line-new-header">--- 631,68 ---</span>
  #undef RETURN_IF_EXCEPTION_CLEARING_OVERFLOW
      for (size_t i = 0; i &lt; numProperties; i++) {
          auto&amp; propertyName = propertyNames[i];
          ASSERT(!propertyName.isPrivateName());
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, globalObject, propertyName, descriptors[i], true);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorDefineProperties(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (!callFrame-&gt;argument(0).isObject())</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Properties can only be defined on Objects.&quot;_s);</span>
<span class="line-modified">!     JSObject* targetObj = asObject(callFrame-&gt;argument(0));</span>
<span class="line-modified">!     JSObject* props = callFrame-&gt;argument(1).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !props);
      if (UNLIKELY(!props))
          return encodedJSValue();
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(globalObject, targetObj, props)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorCreate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue proto = callFrame-&gt;argument(0);</span>
      if (!proto.isObject() &amp;&amp; !proto.isNull())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Object prototype may only be an Object or null.&quot;_s);</span>
      JSObject* newObject = proto.isObject()
<span class="line-modified">!         ? constructEmptyObject(globalObject, asObject(proto))</span>
<span class="line-modified">!         : constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
<span class="line-modified">!     if (callFrame-&gt;argument(1).isUndefined())</span>
          return JSValue::encode(newObject);
<span class="line-modified">!     JSObject* properties = callFrame-&gt;uncheckedArgument(1).toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(defineProperties(globalObject, newObject, properties)));</span>
  }
  
  enum class IntegrityLevel {
      Sealed,
      Frozen
  };
  
  template&lt;IntegrityLevel level&gt;
<span class="line-modified">! bool setIntegrityLevel(JSGlobalObject* globalObject, VM&amp; vm, JSObject* object)</span>
  {
      // See https://tc39.github.io/ecma262/#sec-setintegritylevel.
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     bool success = object-&gt;methodTable(vm)-&gt;preventExtensions(object, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, false);
      if (UNLIKELY(!success))
          return false;
  
      PropertyNameArray properties(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, properties, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, false);
  
      PropertyNameArray::const_iterator end = properties.end();
      for (PropertyNameArray::const_iterator iter = properties.begin(); iter != end; ++iter) {
          auto&amp; propertyName = *iter;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,57 ***</span>
  
          PropertyDescriptor desc;
          if (level == IntegrityLevel::Sealed)
              desc.setConfigurable(false);
          else {
<span class="line-modified">!             bool hasPropertyDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!hasPropertyDescriptor)
                  continue;
  
              if (desc.isDataDescriptor())
                  desc.setWritable(false);
  
              desc.setConfigurable(false);
          }
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, exec, propertyName, desc, true);</span>
          RETURN_IF_EXCEPTION(scope, false);
      }
      return true;
  }
  
  template&lt;IntegrityLevel level&gt;
<span class="line-modified">! bool testIntegrityLevel(ExecState* exec, VM&amp; vm, JSObject* object)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Assert: Type(O) is Object.
      // 2. Assert: level is either &quot;sealed&quot; or &quot;frozen&quot;.
  
      // 3. Let status be ?IsExtensible(O).
<span class="line-modified">!     bool status = object-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 4. If status is true, return false.
      if (status)
          return false;
  
      // 6. Let keys be ? O.[[OwnPropertyKeys]]().
      PropertyNameArray keys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, keys, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. For each element k of keys, do
      PropertyNameArray::const_iterator end = keys.end();
      for (PropertyNameArray::const_iterator iter = keys.begin(); iter != end; ++iter) {
          auto&amp; propertyName = *iter;
          ASSERT(!propertyName.isPrivateName());
  
          // a. Let currentDesc be ? O.[[GetOwnProperty]](k)
          PropertyDescriptor desc;
<span class="line-modified">!         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(exec, propertyName, desc);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // b. If currentDesc is not undefined, then
          if (!didGetDescriptor)
              continue;
<span class="line-new-header">--- 700,57 ---</span>
  
          PropertyDescriptor desc;
          if (level == IntegrityLevel::Sealed)
              desc.setConfigurable(false);
          else {
<span class="line-modified">!             bool hasPropertyDescriptor = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, desc);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (!hasPropertyDescriptor)
                  continue;
  
              if (desc.isDataDescriptor())
                  desc.setWritable(false);
  
              desc.setConfigurable(false);
          }
  
<span class="line-modified">!         object-&gt;methodTable(vm)-&gt;defineOwnProperty(object, globalObject, propertyName, desc, true);</span>
          RETURN_IF_EXCEPTION(scope, false);
      }
      return true;
  }
  
  template&lt;IntegrityLevel level&gt;
<span class="line-modified">! bool testIntegrityLevel(JSGlobalObject* globalObject, VM&amp; vm, JSObject* object)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Assert: Type(O) is Object.
      // 2. Assert: level is either &quot;sealed&quot; or &quot;frozen&quot;.
  
      // 3. Let status be ?IsExtensible(O).
<span class="line-modified">!     bool status = object-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 4. If status is true, return false.
      if (status)
          return false;
  
      // 6. Let keys be ? O.[[OwnPropertyKeys]]().
      PropertyNameArray keys(vm, PropertyNameMode::StringsAndSymbols, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, keys, EnumerationMode(DontEnumPropertiesMode::Include));</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. For each element k of keys, do
      PropertyNameArray::const_iterator end = keys.end();
      for (PropertyNameArray::const_iterator iter = keys.begin(); iter != end; ++iter) {
          auto&amp; propertyName = *iter;
          ASSERT(!propertyName.isPrivateName());
  
          // a. Let currentDesc be ? O.[[GetOwnProperty]](k)
          PropertyDescriptor desc;
<span class="line-modified">!         bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(globalObject, propertyName, desc);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // b. If currentDesc is not undefined, then
          if (!didGetDescriptor)
              continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 768,146 ***</span>
      }
  
      return true;
  }
  
<span class="line-modified">! JSObject* objectConstructorSeal(ExecState* exec, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
          object-&gt;seal(vm);
          return object;
      }
  
<span class="line-modified">!     bool success = setIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(exec, vm, object);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.seal&quot;_s);</span>
          return nullptr;
      }
  
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSeal(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. If Type(O) is not Object, return O.
<span class="line-modified">!     JSValue obj = exec-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(obj);
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(exec, asObject(obj))));</span>
  }
  
<span class="line-modified">! JSObject* objectConstructorFreeze(ExecState* exec, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
          object-&gt;freeze(vm);
          return object;
      }
  
<span class="line-modified">!     bool success = setIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(exec, vm, object);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Unable to prevent extension in Object.freeze&quot;_s);</span>
          return nullptr;
      }
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      // 1. If Type(O) is not Object, return O.
<span class="line-modified">!     JSValue obj = exec-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(obj);
<span class="line-modified">!     JSObject* result = objectConstructorFreeze(exec, asObject(obj));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue argument = exec-&gt;argument(0);</span>
      if (!argument.isObject())
          return JSValue::encode(argument);
      JSObject* object = asObject(argument);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;preventExtensions(object, exec);</span>
      return JSValue::encode(object);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      // 1. If Type(O) is not Object, return true.
<span class="line-modified">!     JSValue obj = exec-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(true));
      JSObject* object = asObject(obj);
  
      // Quick check for final objects.
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType()))
          return JSValue::encode(jsBoolean(object-&gt;isSealed(vm)));
  
      // 2. Return ? TestIntegrityLevel(O, &quot;sealed&quot;).
<span class="line-modified">!     return JSValue::encode(jsBoolean(testIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(exec, vm, object)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      // 1. If Type(O) is not Object, return true.
<span class="line-modified">!     JSValue obj = exec-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(true));
      JSObject* object = asObject(obj);
  
      // Quick check for final objects.
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType()))
          return JSValue::encode(jsBoolean(object-&gt;isFrozen(vm)));
  
      // 2. Return ? TestIntegrityLevel(O, &quot;frozen&quot;).
<span class="line-modified">!     return JSValue::encode(jsBoolean(testIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(exec, vm, object)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue obj = exec-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(false));
      JSObject* object = asObject(obj);
<span class="line-modified">!     bool isExtensible = object-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(isExtensible));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIs(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsBoolean(sameValue(exec, exec-&gt;argument(0), exec-&gt;argument(1))));</span>
  }
  
<span class="line-modified">! JSArray* ownPropertyKeys(ExecState* exec, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
      bool isObjectKeys = propertyNameMode == PropertyNameMode::Strings &amp;&amp; dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude;
      // We attempt to look up own property keys cache in Object.keys case.
      if (isObjectKeys) {
          if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
              if (auto* immutableButterfly = object-&gt;structure(vm)-&gt;cachedOwnKeys()) {
<span class="line-new-header">--- 766,150 ---</span>
      }
  
      return true;
  }
  
<span class="line-modified">! JSObject* objectConstructorSeal(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
          object-&gt;seal(vm);
          return object;
      }
  
<span class="line-modified">!     bool success = setIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(globalObject, vm, object);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Unable to prevent extension in Object.seal&quot;_s);</span>
          return nullptr;
      }
  
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorSeal(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. If Type(O) is not Object, return O.
<span class="line-modified">!     JSValue obj = callFrame-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(obj);
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorSeal(globalObject, asObject(obj))));</span>
  }
  
<span class="line-modified">! JSObject* objectConstructorFreeze(JSGlobalObject* globalObject, JSObject* object)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType())) {
          object-&gt;freeze(vm);
          return object;
      }
  
<span class="line-modified">!     bool success = setIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(globalObject, vm, object);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Unable to prevent extension in Object.freeze&quot;_s);</span>
          return nullptr;
      }
      return object;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorFreeze(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      // 1. If Type(O) is not Object, return O.
<span class="line-modified">!     JSValue obj = callFrame-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(obj);
<span class="line-modified">!     JSObject* result = objectConstructorFreeze(globalObject, asObject(obj));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorPreventExtensions(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue argument = callFrame-&gt;argument(0);</span>
      if (!argument.isObject())
          return JSValue::encode(argument);
      JSObject* object = asObject(argument);
<span class="line-modified">!     bool status = object-&gt;methodTable(vm)-&gt;preventExtensions(object, globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     if (UNLIKELY(!status))</span>
<span class="line-added">+         return throwVMTypeError(globalObject, scope, &quot;Unable to prevent extension in Object.preventExtensions&quot;_s);</span>
      return JSValue::encode(object);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsSealed(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      // 1. If Type(O) is not Object, return true.
<span class="line-modified">!     JSValue obj = callFrame-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(true));
      JSObject* object = asObject(obj);
  
      // Quick check for final objects.
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType()))
          return JSValue::encode(jsBoolean(object-&gt;isSealed(vm)));
  
      // 2. Return ? TestIntegrityLevel(O, &quot;sealed&quot;).
<span class="line-modified">!     return JSValue::encode(jsBoolean(testIntegrityLevel&lt;IntegrityLevel::Sealed&gt;(globalObject, vm, object)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsFrozen(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      // 1. If Type(O) is not Object, return true.
<span class="line-modified">!     JSValue obj = callFrame-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(true));
      JSObject* object = asObject(obj);
  
      // Quick check for final objects.
      if (jsDynamicCast&lt;JSFinalObject*&gt;(vm, object) &amp;&amp; !hasIndexedProperties(object-&gt;indexingType()))
          return JSValue::encode(jsBoolean(object-&gt;isFrozen(vm)));
  
      // 2. Return ? TestIntegrityLevel(O, &quot;frozen&quot;).
<span class="line-modified">!     return JSValue::encode(jsBoolean(testIntegrityLevel&lt;IntegrityLevel::Frozen&gt;(globalObject, vm, object)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIsExtensible(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue obj = callFrame-&gt;argument(0);</span>
      if (!obj.isObject())
          return JSValue::encode(jsBoolean(false));
      JSObject* object = asObject(obj);
<span class="line-modified">!     bool isExtensible = object-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(isExtensible));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL objectConstructorIs(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsBoolean(sameValue(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1))));</span>
  }
  
<span class="line-modified">! JSArray* ownPropertyKeys(JSGlobalObject* globalObject, JSObject* object, PropertyNameMode propertyNameMode, DontEnumPropertiesMode dontEnumPropertiesMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      bool isObjectKeys = propertyNameMode == PropertyNameMode::Strings &amp;&amp; dontEnumPropertiesMode == DontEnumPropertiesMode::Exclude;
      // We attempt to look up own property keys cache in Object.keys case.
      if (isObjectKeys) {
          if (LIKELY(!globalObject-&gt;isHavingABadTime())) {
              if (auto* immutableButterfly = object-&gt;structure(vm)-&gt;cachedOwnKeys()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,11 ***</span>
              }
          }
      }
  
      PropertyNameArray properties(vm, propertyNameMode, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, exec, properties, EnumerationMode(dontEnumPropertiesMode));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (propertyNameMode != PropertyNameMode::StringsAndSymbols) {
          ASSERT(propertyNameMode == PropertyNameMode::Strings || propertyNameMode == PropertyNameMode::Symbols);
          if (properties.size() &lt; MIN_SPARSE_ARRAY_INDEX) {
<span class="line-new-header">--- 918,11 ---</span>
              }
          }
      }
  
      PropertyNameArray properties(vm, propertyNameMode, PrivateSymbolMode::Exclude);
<span class="line-modified">!     object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, globalObject, properties, EnumerationMode(dontEnumPropertiesMode));</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (propertyNameMode != PropertyNameMode::StringsAndSymbols) {
          ASSERT(propertyNameMode == PropertyNameMode::Strings || propertyNameMode == PropertyNameMode::Symbols);
          if (properties.size() &lt; MIN_SPARSE_ARRAY_INDEX) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 964,25 ***</span>
                  return keys;
              }
          }
      }
  
<span class="line-modified">!     JSArray* keys = constructEmptyArray(exec, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned index = 0;
<span class="line-modified">!     auto pushDirect = [&amp;] (ExecState* exec, JSArray* array, JSValue value) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(exec, index++, value);</span>
      };
  
      switch (propertyNameMode) {
      case PropertyNameMode::Strings: {
          size_t numProperties = properties.size();
          for (size_t i = 0; i &lt; numProperties; i++) {
              const auto&amp; identifier = properties[i];
              ASSERT(!identifier.isSymbol());
<span class="line-modified">!             pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
          break;
      }
  
<span class="line-new-header">--- 966,25 ---</span>
                  return keys;
              }
          }
      }
  
<span class="line-modified">!     JSArray* keys = constructEmptyArray(globalObject, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      unsigned index = 0;
<span class="line-modified">!     auto pushDirect = [&amp;] (JSGlobalObject* globalObject, JSArray* array, JSValue value) {</span>
<span class="line-modified">!         array-&gt;putDirectIndex(globalObject, index++, value);</span>
      };
  
      switch (propertyNameMode) {
      case PropertyNameMode::Strings: {
          size_t numProperties = properties.size();
          for (size_t i = 0; i &lt; numProperties; i++) {
              const auto&amp; identifier = properties[i];
              ASSERT(!identifier.isSymbol());
<span class="line-modified">!             pushDirect(globalObject, keys, jsOwnedString(vm, identifier.string()));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,11 ***</span>
          size_t numProperties = properties.size();
          for (size_t i = 0; i &lt; numProperties; i++) {
              const auto&amp; identifier = properties[i];
              ASSERT(identifier.isSymbol());
              ASSERT(!identifier.isPrivateName());
<span class="line-modified">!             pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
          break;
      }
  
<span class="line-new-header">--- 992,11 ---</span>
          size_t numProperties = properties.size();
          for (size_t i = 0; i &lt; numProperties; i++) {
              const auto&amp; identifier = properties[i];
              ASSERT(identifier.isSymbol());
              ASSERT(!identifier.isPrivateName());
<span class="line-modified">!             pushDirect(globalObject, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1007,17 ***</span>
                  ASSERT(!identifier.isPrivateName());
                  propertySymbols.append(identifier);
                  continue;
              }
  
<span class="line-modified">!             pushDirect(exec, keys, jsOwnedString(vm, identifier.string()));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
  
          // To ensure the order defined in the spec (9.1.12), we append symbols at the last elements of keys.
          for (const auto&amp; identifier : propertySymbols) {
<span class="line-modified">!             pushDirect(exec, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
  
          break;
      }
<span class="line-new-header">--- 1009,17 ---</span>
                  ASSERT(!identifier.isPrivateName());
                  propertySymbols.append(identifier);
                  continue;
              }
  
<span class="line-modified">!             pushDirect(globalObject, keys, jsOwnedString(vm, identifier.string()));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
  
          // To ensure the order defined in the spec (9.1.12), we append symbols at the last elements of keys.
          for (const auto&amp; identifier : propertySymbols) {
<span class="line-modified">!             pushDirect(globalObject, keys, Symbol::create(vm, static_cast&lt;SymbolImpl&amp;&gt;(*identifier.impl())));</span>
              RETURN_IF_EXCEPTION(scope, nullptr);
          }
  
          break;
      }
</pre>
<center><a href="NumberPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ObjectConstructor.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/GenericEventQueue.cpp
@@ -34,35 +34,34 @@
 #include "Timer.h"
 #include <wtf/MainThread.h>
 
 namespace WebCore {
 
-GenericEventQueue::GenericEventQueue(EventTarget& owner)
-    : m_owner(owner)
-    , m_isClosed(false)
+MainThreadGenericEventQueue::MainThreadGenericEventQueue(EventTarget& owner)
+    : ActiveDOMObject(owner.scriptExecutionContext())
+    , m_owner(owner)
+    , m_taskQueue(makeUniqueRef<GenericTaskQueue<Timer>>())
 {
 }
 
-GenericEventQueue::~GenericEventQueue() = default;
-
-void GenericEventQueue::enqueueEvent(RefPtr<Event>&& event)
+void MainThreadGenericEventQueue::enqueueEvent(RefPtr<Event>&& event)
 {
     if (m_isClosed)
         return;
 
     if (event->target() == &m_owner)
         event->setTarget(nullptr);
 
     m_pendingEvents.append(WTFMove(event));
 
-    if (m_isSuspended)
+    if (isSuspendedOrPausedByClient())
         return;
 
-    m_taskQueue.enqueueTask(std::bind(&GenericEventQueue::dispatchOneEvent, this));
+    m_taskQueue->enqueueTask(std::bind(&MainThreadGenericEventQueue::dispatchOneEvent, this));
 }
 
-void GenericEventQueue::dispatchOneEvent()
+void MainThreadGenericEventQueue::dispatchOneEvent()
 {
     ASSERT(!m_pendingEvents.isEmpty());
 
     Ref<EventTarget> protect(m_owner);
     RefPtr<Event> event = m_pendingEvents.takeFirst();
@@ -71,53 +70,91 @@
         "An attempt to dispatch an event on a stopped target by EventTargetInterface=%d (nodeName=%s target=%p owner=%p)",
         m_owner.eventTargetInterface(), m_owner.isNode() ? static_cast<Node&>(m_owner).nodeName().ascii().data() : "", &target, &m_owner);
     target.dispatchEvent(*event);
 }
 
-void GenericEventQueue::close()
+void MainThreadGenericEventQueue::close()
 {
     m_isClosed = true;
 
-    m_taskQueue.close();
+    m_taskQueue->close();
     m_pendingEvents.clear();
 }
 
-void GenericEventQueue::cancelAllEvents()
+void MainThreadGenericEventQueue::cancelAllEvents()
 {
-    m_taskQueue.cancelAllTasks();
+    m_taskQueue->cancelAllTasks();
     m_pendingEvents.clear();
 }
 
-bool GenericEventQueue::hasPendingEvents() const
+bool MainThreadGenericEventQueue::hasPendingEvents() const
 {
     return !m_pendingEvents.isEmpty();
 }
 
-bool GenericEventQueue::hasPendingEventsOfType(const AtomString& type) const
+bool MainThreadGenericEventQueue::hasPendingEventsOfType(const AtomString& type) const
 {
     for (auto& event : m_pendingEvents) {
         if (event->type() == type)
             return true;
     }
 
     return false;
 }
 
-void GenericEventQueue::suspend()
+void MainThreadGenericEventQueue::setPaused(bool shouldPause)
+{
+    if (m_isPausedByClient == shouldPause)
+        return;
+
+    m_isPausedByClient = shouldPause;
+    if (shouldPause)
+        m_taskQueue->cancelAllTasks();
+    else
+        rescheduleAllEventsIfNeeded();
+}
+
+void MainThreadGenericEventQueue::suspend(ReasonForSuspension)
 {
-    ASSERT(!m_isSuspended);
+    if (m_isSuspended)
+        return;
+
     m_isSuspended = true;
-    m_taskQueue.cancelAllTasks();
+    m_taskQueue->cancelAllTasks();
 }
 
-void GenericEventQueue::resume()
+void MainThreadGenericEventQueue::resume()
 {
     if (!m_isSuspended)
         return;
 
     m_isSuspended = false;
+    rescheduleAllEventsIfNeeded();
+}
+
+void MainThreadGenericEventQueue::rescheduleAllEventsIfNeeded()
+{
+    if (isSuspendedOrPausedByClient())
+        return;
 
     for (unsigned i = 0; i < m_pendingEvents.size(); ++i)
-        m_taskQueue.enqueueTask(std::bind(&GenericEventQueue::dispatchOneEvent, this));
+        m_taskQueue->enqueueTask(std::bind(&MainThreadGenericEventQueue::dispatchOneEvent, this));
+}
+
+void MainThreadGenericEventQueue::stop()
+{
+    close();
+}
+
+const char* MainThreadGenericEventQueue::activeDOMObjectName() const
+{
+    return "MainThreadGenericEventQueue";
+}
+
+UniqueRef<MainThreadGenericEventQueue> MainThreadGenericEventQueue::create(EventTarget& eventTarget)
+{
+    auto eventQueue = makeUniqueRef<MainThreadGenericEventQueue>(eventTarget);
+    eventQueue->suspendIfNeeded();
+    return eventQueue;
 }
 
 }

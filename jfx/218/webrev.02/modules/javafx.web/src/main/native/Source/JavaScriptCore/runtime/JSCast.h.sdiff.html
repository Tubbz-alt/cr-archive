<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCast.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallee.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCell.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSCast.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 namespace JSC {
 31 
 32 template&lt;typename To, typename From&gt;
 33 inline To jsCast(From* from)
 34 {
 35     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 36     ASSERT_WITH_SECURITY_IMPLICATION(!from || from-&gt;JSCell::inherits(from-&gt;JSCell::vm(), std::remove_pointer&lt;To&gt;::type::info()));
 37     return static_cast&lt;To&gt;(from);
 38 }
 39 
 40 template&lt;typename To&gt;
 41 inline To jsCast(JSValue from)
 42 {
 43     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to is a subclass of JSCell&quot;);
 44     ASSERT_WITH_SECURITY_IMPLICATION(from.isCell() &amp;&amp; from.asCell()-&gt;JSCell::inherits(from.asCell()-&gt;vm(), std::remove_pointer&lt;To&gt;::type::info()));
 45     return static_cast&lt;To&gt;(from.asCell());
 46 }
 47 
 48 // Specific type overloads.
 49 #define FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(macro) \
<span class="line-modified"> 50     macro(JSFixedArray, JSType::JSFixedArrayType, JSType::JSFixedArrayType) \</span>


 51     macro(JSObject, FirstObjectType, LastObjectType) \
 52     macro(JSFinalObject, JSType::FinalObjectType, JSType::FinalObjectType) \
 53     macro(JSFunction, JSType::JSFunctionType, JSType::JSFunctionType) \
 54     macro(InternalFunction, JSType::InternalFunctionType, JSType::InternalFunctionType) \
 55     macro(JSArray, JSType::ArrayType, JSType::DerivedArrayType) \
 56     macro(JSArrayBuffer, JSType::ArrayBufferType, JSType::ArrayBufferType) \
 57     macro(JSArrayBufferView, FirstTypedArrayType, LastTypedArrayType) \

 58     macro(JSSet, JSType::JSSetType, JSType::JSSetType) \
 59     macro(JSMap, JSType::JSMapType, JSType::JSMapType) \
 60     macro(JSWeakSet, JSType::JSWeakSetType, JSType::JSWeakSetType) \
 61     macro(JSWeakMap, JSType::JSWeakMapType, JSType::JSWeakMapType) \
 62     macro(NumberObject, JSType::NumberObjectType, JSType::NumberObjectType) \
 63     macro(ProxyObject, JSType::ProxyObjectType, JSType::ProxyObjectType) \
 64     macro(RegExpObject, JSType::RegExpObjectType, JSType::RegExpObjectType) \
<span class="line-modified"> 65     macro(WebAssemblyToJSCallee, JSType::WebAssemblyToJSCalleeType, JSType::WebAssemblyToJSCalleeType) \</span>
 66     macro(DirectArguments, JSType::DirectArgumentsType, JSType::DirectArgumentsType) \
 67     macro(ScopedArguments, JSType::ScopedArgumentsType, JSType::ScopedArgumentsType) \
 68     macro(ClonedArguments, JSType::ClonedArgumentsType, JSType::ClonedArgumentsType) \
 69     macro(JSGlobalObject, JSType::GlobalObjectType, JSType::GlobalObjectType) \
 70     macro(JSGlobalLexicalEnvironment, JSType::GlobalLexicalEnvironmentType, JSType::GlobalLexicalEnvironmentType) \
 71     macro(JSSegmentedVariableObject, JSType::GlobalObjectType, JSType::GlobalLexicalEnvironmentType) \
 72     macro(JSModuleEnvironment, JSType::ModuleEnvironmentType, JSType::ModuleEnvironmentType) \
 73     macro(JSLexicalEnvironment, JSType::LexicalEnvironmentType, JSType::ModuleEnvironmentType) \
 74     macro(JSSymbolTableObject, JSType::GlobalObjectType, JSType::ModuleEnvironmentType) \
 75     macro(JSScope, JSType::GlobalObjectType, JSType::WithScopeType) \

 76 
 77 
 78 // Forward declare the classes because they may not already exist.
 79 #define FORWARD_DECLARE_OVERLOAD_CLASS(className, jsType, op) class className;
 80 FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(FORWARD_DECLARE_OVERLOAD_CLASS)
 81 #undef FORWARD_DECLARE_OVERLOAD_CLASS
 82 
 83 namespace JSCastingHelpers {
 84 
 85 template&lt;bool isFinal&gt;
 86 struct FinalTypeDispatcher {
 87     template&lt;typename Target, typename From&gt;
 88     static inline bool inheritsGeneric(VM&amp; vm, From* from)
 89     {
 90         static_assert(!std::is_same&lt;JSObject*, Target*&gt;::value, &quot;This ensures our overloads work&quot;);
 91         static_assert(std::is_base_of&lt;JSCell, Target&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 92         // Do not use inherits&lt;Target&gt;(vm) since inherits&lt;T&gt; depends on this function.
 93         return from-&gt;JSCell::inherits(vm, Target::info());
 94     }
 95 };
</pre>
</td>
<td>
<hr />
<pre>
 30 namespace JSC {
 31 
 32 template&lt;typename To, typename From&gt;
 33 inline To jsCast(From* from)
 34 {
 35     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 36     ASSERT_WITH_SECURITY_IMPLICATION(!from || from-&gt;JSCell::inherits(from-&gt;JSCell::vm(), std::remove_pointer&lt;To&gt;::type::info()));
 37     return static_cast&lt;To&gt;(from);
 38 }
 39 
 40 template&lt;typename To&gt;
 41 inline To jsCast(JSValue from)
 42 {
 43     static_assert(std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;To&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to is a subclass of JSCell&quot;);
 44     ASSERT_WITH_SECURITY_IMPLICATION(from.isCell() &amp;&amp; from.asCell()-&gt;JSCell::inherits(from.asCell()-&gt;vm(), std::remove_pointer&lt;To&gt;::type::info()));
 45     return static_cast&lt;To&gt;(from.asCell());
 46 }
 47 
 48 // Specific type overloads.
 49 #define FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(macro) \
<span class="line-modified"> 50     macro(JSImmutableButterfly, JSType::JSImmutableButterflyType, JSType::JSImmutableButterflyType) \</span>
<span class="line-added"> 51     macro(JSArrayIterator, JSType::JSArrayIteratorType, JSType::JSArrayIteratorType) \</span>
<span class="line-added"> 52     macro(JSStringIterator, JSType::JSStringIteratorType, JSType::JSStringIteratorType) \</span>
 53     macro(JSObject, FirstObjectType, LastObjectType) \
 54     macro(JSFinalObject, JSType::FinalObjectType, JSType::FinalObjectType) \
 55     macro(JSFunction, JSType::JSFunctionType, JSType::JSFunctionType) \
 56     macro(InternalFunction, JSType::InternalFunctionType, JSType::InternalFunctionType) \
 57     macro(JSArray, JSType::ArrayType, JSType::DerivedArrayType) \
 58     macro(JSArrayBuffer, JSType::ArrayBufferType, JSType::ArrayBufferType) \
 59     macro(JSArrayBufferView, FirstTypedArrayType, LastTypedArrayType) \
<span class="line-added"> 60     macro(JSPromise, JSType::JSPromiseType, JSType::JSPromiseType) \</span>
 61     macro(JSSet, JSType::JSSetType, JSType::JSSetType) \
 62     macro(JSMap, JSType::JSMapType, JSType::JSMapType) \
 63     macro(JSWeakSet, JSType::JSWeakSetType, JSType::JSWeakSetType) \
 64     macro(JSWeakMap, JSType::JSWeakMapType, JSType::JSWeakMapType) \
 65     macro(NumberObject, JSType::NumberObjectType, JSType::NumberObjectType) \
 66     macro(ProxyObject, JSType::ProxyObjectType, JSType::ProxyObjectType) \
 67     macro(RegExpObject, JSType::RegExpObjectType, JSType::RegExpObjectType) \
<span class="line-modified"> 68     macro(JSWebAssemblyModule, JSType::WebAssemblyModuleType, JSType::WebAssemblyModuleType) \</span>
 69     macro(DirectArguments, JSType::DirectArgumentsType, JSType::DirectArgumentsType) \
 70     macro(ScopedArguments, JSType::ScopedArgumentsType, JSType::ScopedArgumentsType) \
 71     macro(ClonedArguments, JSType::ClonedArgumentsType, JSType::ClonedArgumentsType) \
 72     macro(JSGlobalObject, JSType::GlobalObjectType, JSType::GlobalObjectType) \
 73     macro(JSGlobalLexicalEnvironment, JSType::GlobalLexicalEnvironmentType, JSType::GlobalLexicalEnvironmentType) \
 74     macro(JSSegmentedVariableObject, JSType::GlobalObjectType, JSType::GlobalLexicalEnvironmentType) \
 75     macro(JSModuleEnvironment, JSType::ModuleEnvironmentType, JSType::ModuleEnvironmentType) \
 76     macro(JSLexicalEnvironment, JSType::LexicalEnvironmentType, JSType::ModuleEnvironmentType) \
 77     macro(JSSymbolTableObject, JSType::GlobalObjectType, JSType::ModuleEnvironmentType) \
 78     macro(JSScope, JSType::GlobalObjectType, JSType::WithScopeType) \
<span class="line-added"> 79     macro(StringObject, JSType::StringObjectType, JSType::DerivedStringObjectType) \</span>
 80 
 81 
 82 // Forward declare the classes because they may not already exist.
 83 #define FORWARD_DECLARE_OVERLOAD_CLASS(className, jsType, op) class className;
 84 FOR_EACH_JS_DYNAMIC_CAST_JS_TYPE_OVERLOAD(FORWARD_DECLARE_OVERLOAD_CLASS)
 85 #undef FORWARD_DECLARE_OVERLOAD_CLASS
 86 
 87 namespace JSCastingHelpers {
 88 
 89 template&lt;bool isFinal&gt;
 90 struct FinalTypeDispatcher {
 91     template&lt;typename Target, typename From&gt;
 92     static inline bool inheritsGeneric(VM&amp; vm, From* from)
 93     {
 94         static_assert(!std::is_same&lt;JSObject*, Target*&gt;::value, &quot;This ensures our overloads work&quot;);
 95         static_assert(std::is_base_of&lt;JSCell, Target&gt;::value &amp;&amp; std::is_base_of&lt;JSCell, typename std::remove_pointer&lt;From&gt;::type&gt;::value, &quot;JS casting expects that the types you are casting to/from are subclasses of JSCell&quot;);
 96         // Do not use inherits&lt;Target&gt;(vm) since inherits&lt;T&gt; depends on this function.
 97         return from-&gt;JSCell::inherits(vm, Target::info());
 98     }
 99 };
</pre>
</td>
</tr>
</table>
<center><a href="JSCallee.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSCell.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGPathData.cpp
@@ -50,12 +50,12 @@
     Path path;
     auto& style = renderer->style();
     SVGLengthContext lengthContext(&element);
     float r = lengthContext.valueForLength(style.svgStyle().r());
     if (r > 0) {
-        float cx = lengthContext.valueForLength(style.svgStyle().cx(), LengthModeWidth);
-        float cy = lengthContext.valueForLength(style.svgStyle().cy(), LengthModeHeight);
+        float cx = lengthContext.valueForLength(style.svgStyle().cx(), SVGLengthMode::Width);
+        float cy = lengthContext.valueForLength(style.svgStyle().cy(), SVGLengthMode::Height);
         path.addEllipse(FloatRect(cx - r, cy - r, r * 2, r * 2));
     }
     return path;
 }
 
@@ -65,21 +65,21 @@
     if (!renderer)
         return { };
 
     auto& style = renderer->style();
     SVGLengthContext lengthContext(&element);
-    float rx = lengthContext.valueForLength(style.svgStyle().rx(), LengthModeWidth);
+    float rx = lengthContext.valueForLength(style.svgStyle().rx(), SVGLengthMode::Width);
     if (rx <= 0)
         return { };
 
-    float ry = lengthContext.valueForLength(style.svgStyle().ry(), LengthModeHeight);
+    float ry = lengthContext.valueForLength(style.svgStyle().ry(), SVGLengthMode::Height);
     if (ry <= 0)
         return { };
 
     Path path;
-    float cx = lengthContext.valueForLength(style.svgStyle().cx(), LengthModeWidth);
-    float cy = lengthContext.valueForLength(style.svgStyle().cy(), LengthModeHeight);
+    float cx = lengthContext.valueForLength(style.svgStyle().cx(), SVGLengthMode::Width);
+    float cy = lengthContext.valueForLength(style.svgStyle().cy(), SVGLengthMode::Height);
     path.addEllipse(FloatRect(cx - rx, cy - ry, rx * 2, ry * 2));
     return path;
 }
 
 static Path pathFromLineElement(const SVGElement& element)
@@ -136,34 +136,34 @@
     if (!renderer)
         return { };
 
     auto& style = renderer->style();
     SVGLengthContext lengthContext(&element);
-    float width = lengthContext.valueForLength(style.width(), LengthModeWidth);
+    float width = lengthContext.valueForLength(style.width(), SVGLengthMode::Width);
     if (width <= 0)
         return { };
 
-    float height = lengthContext.valueForLength(style.height(), LengthModeHeight);
+    float height = lengthContext.valueForLength(style.height(), SVGLengthMode::Height);
     if (height <= 0)
         return { };
 
     Path path;
-    float x = lengthContext.valueForLength(style.svgStyle().x(), LengthModeWidth);
-    float y = lengthContext.valueForLength(style.svgStyle().y(), LengthModeHeight);
-    float rx = lengthContext.valueForLength(style.svgStyle().rx(), LengthModeWidth);
-    float ry = lengthContext.valueForLength(style.svgStyle().ry(), LengthModeHeight);
+    float x = lengthContext.valueForLength(style.svgStyle().x(), SVGLengthMode::Width);
+    float y = lengthContext.valueForLength(style.svgStyle().y(), SVGLengthMode::Height);
+    float rx = lengthContext.valueForLength(style.svgStyle().rx(), SVGLengthMode::Width);
+    float ry = lengthContext.valueForLength(style.svgStyle().ry(), SVGLengthMode::Height);
     bool hasRx = rx > 0;
     bool hasRy = ry > 0;
     if (hasRx || hasRy) {
         if (!hasRx)
             rx = ry;
         else if (!hasRy)
             ry = rx;
         // FIXME: We currently enforce using beziers here, as at least on CoreGraphics/Lion, as
         // the native method uses a different line dash origin, causing svg/custom/dashOrigin.svg to fail.
         // See bug https://bugs.webkit.org/show_bug.cgi?id=79932 which tracks this issue.
-        path.addRoundedRect(FloatRect(x, y, width, height), FloatSize(rx, ry), Path::PreferBezierRoundedRect);
+        path.addRoundedRect(FloatRect(x, y, width, height), FloatSize(rx, ry), Path::RoundedRectStrategy::PreferBezier);
         return path;
     }
 
     path.addRect(FloatRect(x, y, width, height));
     return path;

diff a/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.h b/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/CanvasBase.h
@@ -23,23 +23,24 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "IntSize.h"
 #include <wtf/HashSet.h>
 #include <wtf/TypeCasts.h>
 
 namespace WebCore {
 
 class AffineTransform;
 class CanvasBase;
 class CanvasRenderingContext;
 class Element;
 class GraphicsContext;
+class GraphicsContextStateSaver;
 class Image;
 class ImageBuffer;
-class IntSize;
 class FloatRect;
 class ScriptExecutionContext;
 class SecurityOrigin;
 
 class CanvasObserver {
@@ -62,53 +63,72 @@
 
     virtual bool isHTMLCanvasElement() const { return false; }
     virtual bool isOffscreenCanvas() const { return false; }
     virtual bool isCustomPaintCanvas() const { return false; }
 
-    virtual unsigned width() const = 0;
-    virtual unsigned height() const = 0;
-    virtual const IntSize& size() const  = 0;
-    virtual void setSize(const IntSize&) = 0;
+    virtual unsigned width() const { return m_size.width(); }
+    virtual unsigned height() const { return m_size.height(); }
+    const IntSize& size() const { return m_size; }
+
+    ImageBuffer* buffer() const;
+
+    virtual AffineTransform baseTransform() const;
+
+    void makeRenderingResultsAvailable();
+
+    size_t memoryCost() const;
+    size_t externalMemoryCost() const;
 
     void setOriginClean() { m_originClean = true; }
     void setOriginTainted() { m_originClean = false; }
     bool originClean() const { return m_originClean; }
 
     virtual SecurityOrigin* securityOrigin() const { return nullptr; }
     ScriptExecutionContext* scriptExecutionContext() const { return canvasBaseScriptExecutionContext();  }
 
-    CanvasRenderingContext* renderingContext() const;
+    virtual CanvasRenderingContext* renderingContext() const = 0;
 
     void addObserver(CanvasObserver&);
     void removeObserver(CanvasObserver&);
     void notifyObserversCanvasChanged(const FloatRect&);
     void notifyObserversCanvasResized();
     void notifyObserversCanvasDestroyed(); // Must be called in destruction before clearing m_context.
 
     HashSet<Element*> cssCanvasClients() const;
 
-    virtual GraphicsContext* drawingContext() const = 0;
-    virtual GraphicsContext* existingDrawingContext() const = 0;
+    virtual GraphicsContext* drawingContext() const;
+    virtual GraphicsContext* existingDrawingContext() const;
 
-    virtual void makeRenderingResultsAvailable() = 0;
     virtual void didDraw(const FloatRect&) = 0;
 
-    virtual AffineTransform baseTransform() const = 0;
     virtual Image* copiedImage() const = 0;
-
     bool callTracingActive() const;
 
 protected:
-    CanvasBase();
+    explicit CanvasBase(IntSize);
 
     virtual ScriptExecutionContext* canvasBaseScriptExecutionContext() const = 0;
 
-    std::unique_ptr<CanvasRenderingContext> m_context;
+    virtual void setSize(const IntSize& size) { m_size = size; }
+
+    std::unique_ptr<ImageBuffer> setImageBuffer(std::unique_ptr<ImageBuffer>&&) const;
+    virtual bool hasCreatedImageBuffer() const { return false; }
+    static size_t activePixelMemory();
+
+    void resetGraphicsContextState() const;
 
 private:
+    virtual void createImageBuffer() const { }
+
+    mutable IntSize m_size;
+    mutable Lock m_imageBufferAssignmentLock;
+    mutable std::unique_ptr<ImageBuffer> m_imageBuffer;
+    mutable size_t m_imageBufferCost { 0 };
+    mutable std::unique_ptr<GraphicsContextStateSaver> m_contextStateSaver;
+
     bool m_originClean { true };
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     bool m_didNotifyObserversCanvasDestroyed { false };
 #endif
     HashSet<CanvasObserver*> m_observers;
 };
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByStatus.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GetByStatus.h&quot;
 28 
 29 #include &quot;BytecodeStructs.h&quot;
 30 #include &quot;CacheableIdentifierInlines.h&quot;
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;ComplexGetStatus.h&quot;
 33 #include &quot;GetterSetterAccessCase.h&quot;
 34 #include &quot;ICStatusUtils.h&quot;
 35 #include &quot;InterpreterInlines.h&quot;
 36 #include &quot;IntrinsicGetterAccessCase.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;JSScope.h&quot;
 39 #include &quot;LLIntData.h&quot;
 40 #include &quot;LowLevelInterpreter.h&quot;
 41 #include &quot;ModuleNamespaceAccessCase.h&quot;
 42 #include &quot;PolymorphicAccess.h&quot;
 43 #include &quot;StructureStubInfo.h&quot;
 44 #include &lt;wtf/ListDump.h&gt;
 45 
 46 namespace JSC {
 47 namespace DOMJIT {
 48 class GetterSetter;
 49 }
 50 
 51 bool GetByStatus::appendVariant(const GetByIdVariant&amp; variant)
 52 {
 53     return appendICStatusVariant(m_variants, variant);
 54 }
 55 
 56 GetByStatus GetByStatus::computeFromLLInt(CodeBlock* profiledBlock, BytecodeIndex bytecodeIndex)
 57 {
 58     VM&amp; vm = profiledBlock-&gt;vm();
 59 
 60     auto instruction = profiledBlock-&gt;instructions().at(bytecodeIndex.offset());
 61 
 62     StructureID structureID;
 63     const Identifier* identifier = nullptr;
 64     switch (instruction-&gt;opcodeID()) {
 65     case op_get_by_id: {
 66         auto&amp; metadata = instruction-&gt;as&lt;OpGetById&gt;().metadata(profiledBlock);
 67         // FIXME: We should not just bail if we see a get_by_id_proto_load.
 68         // https://bugs.webkit.org/show_bug.cgi?id=158039
 69         if (metadata.m_modeMetadata.mode != GetByIdMode::Default)
 70             return GetByStatus(NoInformation, false);
 71         structureID = metadata.m_modeMetadata.defaultMode.structureID;
 72 
 73         identifier = &amp;(profiledBlock-&gt;identifier(instruction-&gt;as&lt;OpGetById&gt;().m_property));
 74         break;
 75     }
 76     case op_get_by_id_direct:
 77         structureID = instruction-&gt;as&lt;OpGetByIdDirect&gt;().metadata(profiledBlock).m_structureID;
 78         identifier = &amp;(profiledBlock-&gt;identifier(instruction-&gt;as&lt;OpGetByIdDirect&gt;().m_property));
 79         break;
 80     case op_try_get_by_id: {
 81         // FIXME: We should not just bail if we see a try_get_by_id.
 82         // https://bugs.webkit.org/show_bug.cgi?id=158039
 83         return GetByStatus(NoInformation, false);
 84     }
 85 
 86     case op_get_by_val:
 87         return GetByStatus(NoInformation, false);
 88 
 89     default: {
 90         ASSERT_NOT_REACHED();
 91         return GetByStatus(NoInformation, false);
 92     }
 93     }
 94 
 95     if (!structureID)
 96         return GetByStatus(NoInformation, false);
 97 
 98     Structure* structure = vm.heap.structureIDTable().get(structureID);
 99 
100     if (structure-&gt;takesSlowPathInDFGForImpureProperty())
101         return GetByStatus(NoInformation, false);
102 
103     unsigned attributes;
104     PropertyOffset offset = structure-&gt;getConcurrently(identifier-&gt;impl(), attributes);
105     if (!isValidOffset(offset))
106         return GetByStatus(NoInformation, false);
107     if (attributes &amp; PropertyAttribute::CustomAccessorOrValue)
108         return GetByStatus(NoInformation, false);
109 
110     GetByStatus result(Simple, false);
111     result.appendVariant(GetByIdVariant(nullptr, StructureSet(structure), offset));
112     return result;
113 }
114 
115 GetByStatus GetByStatus::computeFor(CodeBlock* profiledBlock, ICStatusMap&amp; map, BytecodeIndex bytecodeIndex, ExitFlag didExit, CallLinkStatus::ExitSiteData callExitSiteData)
116 {
117     ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
118 
119     GetByStatus result;
120 
121 #if ENABLE(DFG_JIT)
122     result = computeForStubInfoWithoutExitSiteFeedback(
123         locker, profiledBlock, map.get(CodeOrigin(bytecodeIndex)).stubInfo, callExitSiteData);
124 
125     if (didExit)
126         return result.slowVersion();
127 #else
128     UNUSED_PARAM(map);
129     UNUSED_PARAM(didExit);
130     UNUSED_PARAM(callExitSiteData);
131 #endif
132 
133     if (!result)
134         return computeFromLLInt(profiledBlock, bytecodeIndex);
135 
136     return result;
137 }
138 
139 #if ENABLE(JIT)
140 GetByStatus::GetByStatus(StubInfoSummary summary, StructureStubInfo&amp; stubInfo)
141     : m_wasSeenInJIT(true)
142 {
143     switch (summary) {
144     case StubInfoSummary::NoInformation:
145         m_state = NoInformation;
146         return;
147     case StubInfoSummary::Simple:
148     case StubInfoSummary::MakesCalls:
149         RELEASE_ASSERT_NOT_REACHED();
150         return;
151     case StubInfoSummary::TakesSlowPath:
152         m_state = stubInfo.tookSlowPath ? ObservedTakesSlowPath : LikelyTakesSlowPath;
153         return;
154     case StubInfoSummary::TakesSlowPathAndMakesCalls:
155         m_state = stubInfo.tookSlowPath ? ObservedSlowPathAndMakesCalls : MakesCalls;
156         return;
157     }
158     RELEASE_ASSERT_NOT_REACHED();
159 }
160 
161 GetByStatus::GetByStatus(const ModuleNamespaceAccessCase&amp; accessCase)
162     : m_moduleNamespaceData(Box&lt;ModuleNamespaceData&gt;::create(ModuleNamespaceData { accessCase.moduleNamespaceObject(), accessCase.moduleEnvironment(), accessCase.scopeOffset(), accessCase.identifier() }))
163     , m_state(ModuleNamespace)
164     , m_wasSeenInJIT(true)
165 {
166 }
167 
168 GetByStatus GetByStatus::computeForStubInfoWithoutExitSiteFeedback(
169     const ConcurrentJSLocker&amp; locker, CodeBlock* profiledBlock, StructureStubInfo* stubInfo, CallLinkStatus::ExitSiteData callExitSiteData)
170 {
171     StubInfoSummary summary = StructureStubInfo::summary(profiledBlock-&gt;vm(), stubInfo);
172     if (!isInlineable(summary))
173         return GetByStatus(summary, *stubInfo);
174 
175     // Finally figure out if we can derive an access strategy.
176     GetByStatus result;
177     result.m_state = Simple;
178     result.m_wasSeenInJIT = true; // This is interesting for bytecode dumping only.
179     switch (stubInfo-&gt;cacheType()) {
180     case CacheType::Unset:
181         return GetByStatus(NoInformation);
182 
183     case CacheType::GetByIdSelf: {
184         Structure* structure = stubInfo-&gt;u.byIdSelf.baseObjectStructure.get();
185         if (structure-&gt;takesSlowPathInDFGForImpureProperty())
186             return GetByStatus(JSC::slowVersion(summary), *stubInfo);
187         CacheableIdentifier identifier = stubInfo-&gt;getByIdSelfIdentifier();
188         UniquedStringImpl* uid = identifier.uid();
189         RELEASE_ASSERT(uid);
190         GetByIdVariant variant(WTFMove(identifier));
191         unsigned attributes;
192         variant.m_offset = structure-&gt;getConcurrently(uid, attributes);
193         if (!isValidOffset(variant.m_offset))
194             return GetByStatus(JSC::slowVersion(summary), *stubInfo);
195         if (attributes &amp; PropertyAttribute::CustomAccessorOrValue)
196             return GetByStatus(JSC::slowVersion(summary), *stubInfo);
197 
198         variant.m_structureSet.add(structure);
199         bool didAppend = result.appendVariant(variant);
200         ASSERT_UNUSED(didAppend, didAppend);
201         return result;
202     }
203 
204     case CacheType::Stub: {
205         PolymorphicAccess* list = stubInfo-&gt;u.stub;
206         if (list-&gt;size() == 1) {
207             const AccessCase&amp; access = list-&gt;at(0);
208             switch (access.type()) {
209             case AccessCase::ModuleNamespaceLoad:
210                 return GetByStatus(access.as&lt;ModuleNamespaceAccessCase&gt;());
211             default:
212                 break;
213             }
214         }
215 
216         for (unsigned listIndex = 0; listIndex &lt; list-&gt;size(); ++listIndex) {
217             const AccessCase&amp; access = list-&gt;at(listIndex);
218             if (access.viaProxy())
219                 return GetByStatus(JSC::slowVersion(summary), *stubInfo);
220 
221             if (access.usesPolyProto())
222                 return GetByStatus(JSC::slowVersion(summary), *stubInfo);
223 
224             if (!access.requiresIdentifierNameMatch()) {
225                 // FIXME: We could use this for indexed loads in the future. This is pretty solid profiling
226                 // information, and probably better than ArrayProfile when it&#39;s available.
227                 // https://bugs.webkit.org/show_bug.cgi?id=204215
228                 return GetByStatus(JSC::slowVersion(summary), *stubInfo);
229             }
230 
231             Structure* structure = access.structure();
232             if (!structure) {
233                 // The null structure cases arise due to array.length and string.length. We have no way
234                 // of creating a GetByIdVariant for those, and we don&#39;t really have to since the DFG
235                 // handles those cases in FixupPhase using value profiling. That&#39;s a bit awkward - we
236                 // shouldn&#39;t have to use value profiling to discover something that the AccessCase
237                 // could have told us. But, it works well enough. So, our only concern here is to not
238                 // crash on null structure.
239                 return GetByStatus(JSC::slowVersion(summary), *stubInfo);
240             }
241 
242             ComplexGetStatus complexGetStatus = ComplexGetStatus::computeFor(
243                 structure, access.conditionSet(), access.uid());
244 
245             switch (complexGetStatus.kind()) {
246             case ComplexGetStatus::ShouldSkip:
247                 continue;
248 
249             case ComplexGetStatus::TakesSlowPath:
250                 return GetByStatus(JSC::slowVersion(summary), *stubInfo);
251 
252             case ComplexGetStatus::Inlineable: {
253                 std::unique_ptr&lt;CallLinkStatus&gt; callLinkStatus;
254                 JSFunction* intrinsicFunction = nullptr;
255                 FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
256                 std::unique_ptr&lt;DOMAttributeAnnotation&gt; domAttribute;
257                 bool haveDOMAttribute = false;
258 
259                 switch (access.type()) {
260                 case AccessCase::Load:
261                 case AccessCase::GetGetter:
262                 case AccessCase::Miss: {
263                     break;
264                 }
265                 case AccessCase::IntrinsicGetter: {
266                     intrinsicFunction = access.as&lt;IntrinsicGetterAccessCase&gt;().intrinsicFunction();
267                     break;
268                 }
269                 case AccessCase::Getter: {
270                     callLinkStatus = makeUnique&lt;CallLinkStatus&gt;();
271                     if (CallLinkInfo* callLinkInfo = access.as&lt;GetterSetterAccessCase&gt;().callLinkInfo()) {
272                         *callLinkStatus = CallLinkStatus::computeFor(
273                             locker, profiledBlock, *callLinkInfo, callExitSiteData);
274                     }
275                     break;
276                 }
277                 case AccessCase::CustomAccessorGetter: {
278                     customAccessorGetter = access.as&lt;GetterSetterAccessCase&gt;().customAccessor();
279                     if (!access.as&lt;GetterSetterAccessCase&gt;().domAttribute())
280                         return GetByStatus(JSC::slowVersion(summary), *stubInfo);
281                     domAttribute = WTF::makeUnique&lt;DOMAttributeAnnotation&gt;(*access.as&lt;GetterSetterAccessCase&gt;().domAttribute());
282                     haveDOMAttribute = true;
283                     result.m_state = Custom;
284                     break;
285                 }
286                 default: {
287                     // FIXME: It would be totally sweet to support more of these at some point in the
288                     // future. https://bugs.webkit.org/show_bug.cgi?id=133052
289                     return GetByStatus(JSC::slowVersion(summary), *stubInfo);
290                 } }
291 
292                 ASSERT((AccessCase::Miss == access.type() || access.isCustom()) == (access.offset() == invalidOffset));
293                 GetByIdVariant variant(access.identifier(), StructureSet(structure), complexGetStatus.offset(),
294                     complexGetStatus.conditionSet(), WTFMove(callLinkStatus),
295                     intrinsicFunction,
296                     customAccessorGetter,
297                     WTFMove(domAttribute));
298 
299                 if (!result.appendVariant(variant))
300                     return GetByStatus(JSC::slowVersion(summary), *stubInfo);
301 
302                 if (haveDOMAttribute) {
303                     // Give up when custom accesses are not merged into one.
304                     if (result.numVariants() != 1)
305                         return GetByStatus(JSC::slowVersion(summary), *stubInfo);
306                 } else {
307                     // Give up when custom access and simple access are mixed.
308                     if (result.m_state == Custom)
309                         return GetByStatus(JSC::slowVersion(summary), *stubInfo);
310                 }
311                 break;
312             } }
313         }
314 
315         return result;
316     }
317 
318     default:
319         return GetByStatus(JSC::slowVersion(summary), *stubInfo);
320     }
321 
322     RELEASE_ASSERT_NOT_REACHED();
323     return GetByStatus();
324 }
325 
326 GetByStatus GetByStatus::computeFor(
327     CodeBlock* profiledBlock, ICStatusMap&amp; baselineMap,
328     ICStatusContextStack&amp; icContextStack, CodeOrigin codeOrigin)
329 {
330     BytecodeIndex bytecodeIndex = codeOrigin.bytecodeIndex();
331     CallLinkStatus::ExitSiteData callExitSiteData = CallLinkStatus::computeExitSiteData(profiledBlock, bytecodeIndex);
332     ExitFlag didExit = hasBadCacheExitSite(profiledBlock, bytecodeIndex);
333 
334     for (ICStatusContext* context : icContextStack) {
335         ICStatus status = context-&gt;get(codeOrigin);
336 
337         auto bless = [&amp;] (const GetByStatus&amp; result) -&gt; GetByStatus {
338             if (!context-&gt;isInlined(codeOrigin)) {
339                 // Merge with baseline result, which also happens to contain exit data for both
340                 // inlined and not-inlined.
341                 GetByStatus baselineResult = computeFor(
342                     profiledBlock, baselineMap, bytecodeIndex, didExit,
343                     callExitSiteData);
344                 baselineResult.merge(result);
345                 return baselineResult;
346             }
347             if (didExit.isSet(ExitFromInlined))
348                 return result.slowVersion();
349             return result;
350         };
351 
352         if (status.stubInfo) {
353             GetByStatus result;
354             {
355                 ConcurrentJSLocker locker(context-&gt;optimizedCodeBlock-&gt;m_lock);
356                 result = computeForStubInfoWithoutExitSiteFeedback(
357                     locker, context-&gt;optimizedCodeBlock, status.stubInfo, callExitSiteData);
358             }
359             if (result.isSet())
360                 return bless(result);
361         }
362 
363         if (status.getStatus)
364             return bless(*status.getStatus);
365     }
366 
367     return computeFor(profiledBlock, baselineMap, bytecodeIndex, didExit, callExitSiteData);
368 }
369 
370 GetByStatus GetByStatus::computeFor(const StructureSet&amp; set, UniquedStringImpl* uid)
371 {
372     // For now we only handle the super simple self access case. We could handle the
373     // prototype case in the future.
374     //
375     // Note that this code is also used for GetByIdDirect since this function only looks
376     // into direct properties. When supporting prototype chains, we should split this for
377     // GetById and GetByIdDirect.
378 
379     if (set.isEmpty())
380         return GetByStatus();
381 
382     if (parseIndex(*uid))
383         return GetByStatus(LikelyTakesSlowPath);
384 
385     GetByStatus result;
386     result.m_state = Simple;
387     result.m_wasSeenInJIT = false;
388     for (unsigned i = 0; i &lt; set.size(); ++i) {
389         Structure* structure = set[i];
390         if (structure-&gt;typeInfo().overridesGetOwnPropertySlot() &amp;&amp; structure-&gt;typeInfo().type() != GlobalObjectType)
391             return GetByStatus(LikelyTakesSlowPath);
392 
393         if (!structure-&gt;propertyAccessesAreCacheable())
394             return GetByStatus(LikelyTakesSlowPath);
395 
396         unsigned attributes;
397         PropertyOffset offset = structure-&gt;getConcurrently(uid, attributes);
398         if (!isValidOffset(offset))
399             return GetByStatus(LikelyTakesSlowPath); // It&#39;s probably a prototype lookup. Give up on life for now, even though we could totally be way smarter about it.
400         if (attributes &amp; PropertyAttribute::Accessor)
401             return GetByStatus(MakesCalls); // We could be smarter here, like strength-reducing this to a Call.
402         if (attributes &amp; PropertyAttribute::CustomAccessorOrValue)
403             return GetByStatus(LikelyTakesSlowPath);
404 
405         if (!result.appendVariant(GetByIdVariant(nullptr, structure, offset)))
406             return GetByStatus(LikelyTakesSlowPath);
407     }
408 
409     return result;
410 }
411 #endif // ENABLE(JIT)
412 
413 bool GetByStatus::makesCalls() const
414 {
415     switch (m_state) {
416     case NoInformation:
417     case LikelyTakesSlowPath:
418     case ObservedTakesSlowPath:
419     case Custom:
420     case ModuleNamespace:
421         return false;
422     case Simple:
423         for (unsigned i = m_variants.size(); i--;) {
424             if (m_variants[i].callLinkStatus())
425                 return true;
426         }
427         return false;
428     case MakesCalls:
429     case ObservedSlowPathAndMakesCalls:
430         return true;
431     }
432     RELEASE_ASSERT_NOT_REACHED();
433 
434     return false;
435 }
436 
437 GetByStatus GetByStatus::slowVersion() const
438 {
439     if (observedStructureStubInfoSlowPath())
440         return GetByStatus(makesCalls() ? ObservedSlowPathAndMakesCalls : ObservedTakesSlowPath, wasSeenInJIT());
441     return GetByStatus(makesCalls() ? MakesCalls : LikelyTakesSlowPath, wasSeenInJIT());
442 }
443 
444 void GetByStatus::merge(const GetByStatus&amp; other)
445 {
446     if (other.m_state == NoInformation)
447         return;
448 
449     auto mergeSlow = [&amp;] () {
450         if (observedStructureStubInfoSlowPath() || other.observedStructureStubInfoSlowPath())
451             *this = GetByStatus((makesCalls() || other.makesCalls()) ? ObservedSlowPathAndMakesCalls : ObservedTakesSlowPath);
452         else
453             *this = GetByStatus((makesCalls() || other.makesCalls()) ? MakesCalls : LikelyTakesSlowPath);
454     };
455 
456     switch (m_state) {
457     case NoInformation:
458         *this = other;
459         return;
460 
461     case Simple:
462     case Custom:
463         if (m_state != other.m_state)
464             return mergeSlow();
465 
466         for (const GetByIdVariant&amp; otherVariant : other.m_variants) {
467             if (!appendVariant(otherVariant))
468                 return mergeSlow();
469         }
470         return;
471 
472     case ModuleNamespace:
473         if (other.m_state != ModuleNamespace)
474             return mergeSlow();
475 
476         if (m_moduleNamespaceData-&gt;m_moduleNamespaceObject != other.m_moduleNamespaceData-&gt;m_moduleNamespaceObject)
477             return mergeSlow();
478 
479         if (m_moduleNamespaceData-&gt;m_moduleEnvironment != other.m_moduleNamespaceData-&gt;m_moduleEnvironment)
480             return mergeSlow();
481 
482         if (m_moduleNamespaceData-&gt;m_scopeOffset != other.m_moduleNamespaceData-&gt;m_scopeOffset)
483             return mergeSlow();
484 
485         return;
486 
487     case LikelyTakesSlowPath:
488     case ObservedTakesSlowPath:
489     case MakesCalls:
490     case ObservedSlowPathAndMakesCalls:
491         return mergeSlow();
492     }
493 
494     RELEASE_ASSERT_NOT_REACHED();
495 }
496 
497 void GetByStatus::filter(const StructureSet&amp; set)
498 {
499     if (m_state != Simple)
500         return;
501     filterICStatusVariants(m_variants, set);
502     if (m_variants.isEmpty())
503         m_state = NoInformation;
504 }
505 
506 void GetByStatus::visitAggregate(SlotVisitor&amp; visitor)
507 {
508     if (isModuleNamespace())
509         m_moduleNamespaceData-&gt;m_identifier.visitAggregate(visitor);
510     for (GetByIdVariant&amp; variant : m_variants)
511         variant.visitAggregate(visitor);
512 }
513 
514 void GetByStatus::markIfCheap(SlotVisitor&amp; visitor)
515 {
516     for (GetByIdVariant&amp; variant : m_variants)
517         variant.markIfCheap(visitor);
518 }
519 
520 bool GetByStatus::finalize(VM&amp; vm)
521 {
522     for (GetByIdVariant&amp; variant : m_variants) {
523         if (!variant.finalize(vm))
524             return false;
525     }
526     if (isModuleNamespace()) {
527         if (m_moduleNamespaceData-&gt;m_moduleNamespaceObject &amp;&amp; !vm.heap.isMarked(m_moduleNamespaceData-&gt;m_moduleNamespaceObject))
528             return false;
529         if (m_moduleNamespaceData-&gt;m_moduleEnvironment &amp;&amp; !vm.heap.isMarked(m_moduleNamespaceData-&gt;m_moduleEnvironment))
530             return false;
531     }
532     return true;
533 }
534 
535 CacheableIdentifier GetByStatus::singleIdentifier() const
536 {
537     if (isModuleNamespace())
538         return m_moduleNamespaceData-&gt;m_identifier;
539 
540     if (m_variants.isEmpty())
541         return nullptr;
542 
543     CacheableIdentifier result = m_variants.first().identifier();
544     if (!result)
545         return nullptr;
546     for (size_t i = 1; i &lt; m_variants.size(); ++i) {
547         CacheableIdentifier identifier = m_variants[i].identifier();
548         if (!identifier)
549             return nullptr;
550         if (identifier != result)
551             return nullptr;
552     }
553     return result;
554 }
555 
556 void GetByStatus::dump(PrintStream&amp; out) const
557 {
558     out.print(&quot;(&quot;);
559     switch (m_state) {
560     case NoInformation:
561         out.print(&quot;NoInformation&quot;);
562         break;
563     case Simple:
564         out.print(&quot;Simple&quot;);
565         break;
566     case Custom:
567         out.print(&quot;Custom&quot;);
568         break;
569     case ModuleNamespace:
570         out.print(&quot;ModuleNamespace&quot;);
571         break;
572     case LikelyTakesSlowPath:
573         out.print(&quot;LikelyTakesSlowPath&quot;);
574         break;
575     case ObservedTakesSlowPath:
576         out.print(&quot;ObservedTakesSlowPath&quot;);
577         break;
578     case MakesCalls:
579         out.print(&quot;MakesCalls&quot;);
580         break;
581     case ObservedSlowPathAndMakesCalls:
582         out.print(&quot;ObservedSlowPathAndMakesCalls&quot;);
583         break;
584     }
585     out.print(&quot;, &quot;, listDump(m_variants), &quot;, seenInJIT = &quot;, m_wasSeenInJIT, &quot;)&quot;);
586 }
587 
588 } // namespace JSC
589 
    </pre>
  </body>
</html>
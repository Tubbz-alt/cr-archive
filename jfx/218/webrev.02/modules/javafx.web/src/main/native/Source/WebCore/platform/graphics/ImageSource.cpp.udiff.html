<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImagePaintingOptions.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageSource.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,12 +29,10 @@</span>
  #include &quot;BitmapImage.h&quot;
  #include &quot;ImageDecoder.h&quot;
  #include &quot;ImageObserver.h&quot;
  #include &quot;Logging.h&quot;
  #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="udiff-line-removed">- #include &lt;wtf/MainThread.h&gt;</span>
<span class="udiff-line-removed">- #include &lt;wtf/RunLoop.h&gt;</span>
  #include &lt;wtf/SystemTracing.h&gt;
  #include &lt;wtf/URL.h&gt;
  
  #if USE(DIRECT2D)
  #include &quot;GraphicsContext.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -45,36 +43,33 @@</span>
  
  ImageSource::ImageSource(BitmapImage* image, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
      : m_image(image)
      , m_alphaOption(alphaOption)
      , m_gammaAndColorProfileOption(gammaAndColorProfileOption)
<span class="udiff-line-added">+     , m_runLoop(RunLoop::current())</span>
  {
<span class="udiff-line-removed">-     ASSERT(isMainThread());</span>
  }
  
  ImageSource::ImageSource(NativeImagePtr&amp;&amp; nativeImage)
<span class="udiff-line-added">+     : m_runLoop(RunLoop::current())</span>
  {
<span class="udiff-line-removed">-     ASSERT(isMainThread());</span>
<span class="udiff-line-removed">- </span>
      m_frameCount = 1;
      m_encodedDataStatus = EncodedDataStatus::Complete;
      growFrames();
  
      setNativeImage(WTFMove(nativeImage));
  
      m_decodedSize = m_frames[0].frameBytes();
  
<span class="udiff-line-removed">-     // The assumption is the memory image will be displayed with the default</span>
<span class="udiff-line-removed">-     // orientation. So set m_sizeRespectingOrientation to be the same as m_size.</span>
      m_size = m_frames[0].size();
<span class="udiff-line-modified-removed">-     m_sizeRespectingOrientation = m_size;</span>
<span class="udiff-line-modified-added">+     m_orientation = ImageOrientation(ImageOrientation::None);</span>
  }
  
  ImageSource::~ImageSource()
  {
      ASSERT(!hasAsyncDecodingQueue());
<span class="udiff-line-modified-removed">-     ASSERT(isMainThread());</span>
<span class="udiff-line-modified-added">+     ASSERT(&amp;m_runLoop == &amp;RunLoop::current());</span>
  }
  
  bool ImageSource::ensureDecoderAvailable(SharedBuffer* data)
  {
      if (!data || isDecoderAvailable())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -348,12 +343,15 @@</span>
  void ImageSource::startAsyncDecodingQueue()
  {
      if (hasAsyncDecodingQueue() || !isDecoderAvailable())
          return;
  
<span class="udiff-line-added">+     // Async decoding is only enabled for HTMLImageElement and CSS background images.</span>
<span class="udiff-line-added">+     ASSERT(isMainThread());</span>
<span class="udiff-line-added">+ </span>
      // We need to protect this, m_decodingQueue and m_decoder from being deleted while we are in the decoding loop.
<span class="udiff-line-modified-removed">-     decodingQueue().dispatch([protectedThis = makeRef(*this), protectedDecodingQueue = makeRef(decodingQueue()), protectedFrameRequestQueue = makeRef(frameRequestQueue()), protectedDecoder = makeRef(*m_decoder), sourceURL = sourceURL().string().isolatedCopy()] {</span>
<span class="udiff-line-modified-added">+     decodingQueue().dispatch([protectedThis = makeRef(*this), protectedDecodingQueue = makeRef(decodingQueue()), protectedFrameRequestQueue = makeRef(frameRequestQueue()), protectedDecoder = makeRef(*m_decoder), sourceURL = sourceURL().string().isolatedCopy()] () mutable {</span>
          ImageFrameRequest frameRequest;
          Seconds minDecodingDuration = protectedThis-&gt;frameDecodingDurationForTesting();
  
          while (protectedFrameRequestQueue-&gt;dequeue(frameRequest)) {
              TraceScope tracingScope(AsyncImageDecodeStart, AsyncImageDecodeEnd);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,21 +371,24 @@</span>
  
              // Pretend as if the decoding takes minDecodingDuration.
              if (minDecodingDuration &gt; 0_s)
                  sleep(minDecodingDuration - (MonotonicTime::now() - startingTime));
  
<span class="udiff-line-modified-removed">-             // Update the cached frames on the main thread to avoid updating the MemoryCache from a different thread.</span>
<span class="udiff-line-modified-added">+             // Update the cached frames on the creation thread to avoid updating the MemoryCache from a different thread.</span>
              callOnMainThread([protectedThis = protectedThis.copyRef(), protectedQueue = protectedDecodingQueue.copyRef(), protectedDecoder = protectedDecoder.copyRef(), sourceURL = sourceURL.isolatedCopy(), nativeImage = WTFMove(nativeImage), frameRequest] () mutable {
                  // The queue may have been closed if after we got the frame NativeImage, stopAsyncDecodingQueue() was called.
                  if (protectedQueue.ptr() == protectedThis-&gt;m_decodingQueue &amp;&amp; protectedDecoder.ptr() == protectedThis-&gt;m_decoder) {
                      ASSERT(protectedThis-&gt;m_frameCommitQueue.first() == frameRequest);
                      protectedThis-&gt;m_frameCommitQueue.removeFirst();
                      protectedThis-&gt;cacheNativeImageAtIndexAsync(WTFMove(nativeImage), frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions, frameRequest.decodingStatus);
                  } else
                      LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld will not cached]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
              });
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         // Ensure destruction happens on creation thread.</span>
<span class="udiff-line-added">+         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedQueue = WTFMove(protectedDecodingQueue), protectedDecoder = WTFMove(protectedDecoder)] () mutable { });</span>
      });
  }
  
  void ImageSource::requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const Optional&lt;IntSize&gt;&amp; sizeForDrawing)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -557,24 +558,31 @@</span>
  Optional&lt;IntPoint&gt; ImageSource::hotSpot()
  {
      return metadata&lt;Optional&lt;IntPoint&gt;, (&amp;ImageDecoder::hotSpot)&gt;(WTF::nullopt, &amp;m_hotSpot);
  }
  
<span class="udiff-line-modified-removed">- IntSize ImageSource::size()</span>
<span class="udiff-line-modified-added">+ ImageOrientation ImageSource::orientation()</span>
  {
<span class="udiff-line-added">+     return frameMetadataAtIndexCacheIfNeeded&lt;ImageOrientation&gt;(0, (&amp;ImageFrame::orientation), &amp;m_orientation, ImageFrame::Caching::Metadata);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ IntSize ImageSource::size(ImageOrientation orientation)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     IntSize size;</span>
  #if !USE(CG)
      // It&#39;s possible that we have decoded the metadata, but not frame contents yet. In that case ImageDecoder claims to
      // have the size available, but the frame cache is empty. Return the decoder size without caching in such case.
      if (m_frames.isEmpty() &amp;&amp; isDecoderAvailable())
<span class="udiff-line-modified-removed">-         return m_decoder-&gt;size();</span>
<span class="udiff-line-modified-added">+         size = m_decoder-&gt;size();</span>
<span class="udiff-line-added">+     else</span>
  #endif
<span class="udiff-line-modified-removed">-     return frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::size), &amp;m_size, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+         size = frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::size), &amp;m_size, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>
  
<span class="udiff-line-modified-removed">- IntSize ImageSource::sizeRespectingOrientation()</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     return frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::sizeRespectingOrientation), &amp;m_sizeRespectingOrientation, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>
<span class="udiff-line-modified-added">+     if (orientation == ImageOrientation::FromImage)</span>
<span class="udiff-line-modified-added">+         orientation = this-&gt;orientation();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     return orientation.usesWidthAsHeight() ? size.transposedSize() : size;</span>
  }
  
  Color ImageSource::singlePixelSolidColor()
  {
      if (!m_singlePixelSolidColor &amp;&amp; (size() != IntSize(1, 1) || frameCount() != 1))
</pre>
<center><a href="ImagePaintingOptions.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageSource.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
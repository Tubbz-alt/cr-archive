<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ElementRareData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008, 2009, 2010, 2014, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008 David Smith &lt;catfish.man@gmail.com&gt;
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CustomElementReactionQueue.h&quot;
 25 #include &quot;DOMTokenList.h&quot;
 26 #include &quot;DatasetDOMStringMap.h&quot;
 27 #include &quot;IntersectionObserver.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 28 #include &quot;KeyframeEffectStack.h&quot;</span>
 29 #include &quot;NamedNodeMap.h&quot;
 30 #include &quot;NodeRareData.h&quot;
 31 #include &quot;PseudoElement.h&quot;
 32 #include &quot;RenderElement.h&quot;
 33 #include &quot;ResizeObserver.h&quot;
 34 #include &quot;ShadowRoot.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &quot;SpaceSplitString.h&quot;</span>
 36 #include &quot;StylePropertyMap.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 inline IntSize defaultMinimumSizeForResizing()
 41 {
 42     return IntSize(LayoutUnit::max(), LayoutUnit::max());
 43 }
 44 
 45 class ElementRareData : public NodeRareData {
 46 public:
 47     explicit ElementRareData();
 48     ~ElementRareData();
 49 
 50     void setBeforePseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 51     void setAfterPseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp;);
 52 
 53     PseudoElement* beforePseudoElement() const { return m_beforePseudoElement.get(); }
 54     PseudoElement* afterPseudoElement() const { return m_afterPseudoElement.get(); }
 55 
 56     void resetComputedStyle();
 57     void resetStyleRelations();
 58 
 59     Optional&lt;int&gt; tabIndex() const { return m_tabIndexWasSetExplicitly ? Optional&lt;int&gt; { m_tabIndex } : WTF::nullopt; }
 60     void setTabIndexExplicitly(int index) { m_tabIndex = index; m_tabIndexWasSetExplicitly = true; }
 61     bool tabIndexSetExplicitly() const { return m_tabIndexWasSetExplicitly; }
 62     void clearTabIndexExplicitly() { m_tabIndex = 0; m_tabIndexWasSetExplicitly = false; }
 63 
 64 #if ENABLE(FULLSCREEN_API)
 65     bool containsFullScreenElement() { return m_containsFullScreenElement; }
 66     void setContainsFullScreenElement(bool value) { m_containsFullScreenElement = value; }
 67 #endif
 68 
 69     unsigned childIndex() const { return m_childIndex; }
 70     void setChildIndex(unsigned index) { m_childIndex = index; }
 71     static ptrdiff_t childIndexMemoryOffset() { return OBJECT_OFFSETOF(ElementRareData, m_childIndex); }
 72 
 73     void clearShadowRoot() { m_shadowRoot = nullptr; }
 74     ShadowRoot* shadowRoot() const { return m_shadowRoot.get(); }
 75     void setShadowRoot(RefPtr&lt;ShadowRoot&gt;&amp;&amp; shadowRoot) { m_shadowRoot = WTFMove(shadowRoot); }
 76 
 77     CustomElementReactionQueue* customElementReactionQueue() { return m_customElementReactionQueue.get(); }
 78     void setCustomElementReactionQueue(std::unique_ptr&lt;CustomElementReactionQueue&gt;&amp;&amp; queue) { m_customElementReactionQueue = WTFMove(queue); }
 79 
 80     NamedNodeMap* attributeMap() const { return m_attributeMap.get(); }
 81     void setAttributeMap(std::unique_ptr&lt;NamedNodeMap&gt; attributeMap) { m_attributeMap = WTFMove(attributeMap); }
 82 
 83     RenderStyle* computedStyle() const { return m_computedStyle.get(); }
 84     void setComputedStyle(std::unique_ptr&lt;RenderStyle&gt; computedStyle) { m_computedStyle = WTFMove(computedStyle); }
 85 
 86     DOMTokenList* classList() const { return m_classList.get(); }
 87     void setClassList(std::unique_ptr&lt;DOMTokenList&gt; classList) { m_classList = WTFMove(classList); }
 88 
 89     DatasetDOMStringMap* dataset() const { return m_dataset.get(); }
 90     void setDataset(std::unique_ptr&lt;DatasetDOMStringMap&gt; dataset) { m_dataset = WTFMove(dataset); }
 91 
 92     LayoutSize minimumSizeForResizing() const { return m_minimumSizeForResizing; }
 93     void setMinimumSizeForResizing(LayoutSize size) { m_minimumSizeForResizing = size; }
 94 
 95     IntPoint savedLayerScrollPosition() const { return m_savedLayerScrollPosition; }
 96     void setSavedLayerScrollPosition(IntPoint position) { m_savedLayerScrollPosition = position; }
 97 
 98     bool hasPendingResources() const { return m_hasPendingResources; }
 99     void setHasPendingResources(bool has) { m_hasPendingResources = has; }
100 
101     bool hasCSSAnimation() const { return m_hasCSSAnimation; }
102     void setHasCSSAnimation(bool value) { m_hasCSSAnimation = value; }
103 
<a name="3" id="anc3"></a><span class="line-added">104     KeyframeEffectStack* keyframeEffectStack() { return m_keyframeEffectStack.get(); }</span>
<span class="line-added">105     void setKeyframeEffectStack(std::unique_ptr&lt;KeyframeEffectStack&gt;&amp;&amp; keyframeEffectStack) { m_keyframeEffectStack = WTFMove(keyframeEffectStack); }</span>
<span class="line-added">106 </span>
107     bool hasElementIdentifier() const { return m_hasElementIdentifier; }
108     void setHasElementIdentifier(bool value) { m_hasElementIdentifier = value; }
109 
<a name="4" id="anc4"></a><span class="line-added">110     DOMTokenList* partList() const { return m_partList.get(); }</span>
<span class="line-added">111     void setPartList(std::unique_ptr&lt;DOMTokenList&gt; partList) { m_partList = WTFMove(partList); }</span>
<span class="line-added">112 </span>
<span class="line-added">113     const SpaceSplitString&amp; partNames() const { return m_partNames; }</span>
<span class="line-added">114     void setPartNames(SpaceSplitString&amp;&amp; partNames) { m_partNames = WTFMove(partNames); }</span>
<span class="line-added">115 </span>
116 #if ENABLE(INTERSECTION_OBSERVER)
117     IntersectionObserverData* intersectionObserverData() { return m_intersectionObserverData.get(); }
118     void setIntersectionObserverData(std::unique_ptr&lt;IntersectionObserverData&gt;&amp;&amp; data) { m_intersectionObserverData = WTFMove(data); }
119 #endif
120 
121 #if ENABLE(RESIZE_OBSERVER)
122     ResizeObserverData* resizeObserverData() { return m_resizeObserverData.get(); }
123     void setResizeObserverData(std::unique_ptr&lt;ResizeObserverData&gt;&amp;&amp; data) { m_resizeObserverData = WTFMove(data); }
124 #endif
125 
126 #if ENABLE(CSS_TYPED_OM)
127     StylePropertyMap* attributeStyleMap() { return m_attributeStyleMap.get(); }
128     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp; map) { m_attributeStyleMap = WTFMove(map); }
129 #endif
130 
131 #if DUMP_NODE_STATISTICS
132     OptionSet&lt;UseType&gt; useTypes() const
133     {
134         auto result = NodeRareData::useTypes();
135         if (m_tabIndexWasSetExplicitly)
136             result.add(UseType::TabIndex);
137         if (m_minimumSizeForResizing != defaultMinimumSizeForResizing())
138             result.add(UseType::MinimumSize);
139         if (!m_savedLayerScrollPosition.isZero())
140             result.add(UseType::ScrollingPosition);
141         if (m_computedStyle)
142             result.add(UseType::ComputedStyle);
143         if (m_dataset)
144             result.add(UseType::Dataset);
145         if (m_classList)
146             result.add(UseType::ClassList);
147         if (m_shadowRoot)
148             result.add(UseType::ShadowRoot);
149         if (m_customElementReactionQueue)
150             result.add(UseType::CustomElementQueue);
151         if (m_attributeMap)
152             result.add(UseType::AttributeMap);
153         if (m_intersectionObserverData)
154             result.add(UseType::InteractionObserver);
155 #if ENABLE(RESIZE_OBSERVER)
156         if (m_resizeObserverData)
157             result.add(UseType::ResizeObserver);
158 #endif
159         if (m_beforePseudoElement || m_afterPseudoElement)
160             result.add(UseType::PseudoElements);
161         return result;
162     }
163 #endif
164 
165 private:
166     int m_tabIndex;
167     unsigned short m_childIndex;
168     unsigned m_tabIndexWasSetExplicitly : 1;
169 #if ENABLE(FULLSCREEN_API)
170     unsigned m_containsFullScreenElement : 1;
171 #endif
172     unsigned m_hasPendingResources : 1;
173     unsigned m_hasCSSAnimation : 1;
174     unsigned m_hasElementIdentifier : 1;
175 
176     LayoutSize m_minimumSizeForResizing;
177     IntPoint m_savedLayerScrollPosition;
178     std::unique_ptr&lt;RenderStyle&gt; m_computedStyle;
179 
180     std::unique_ptr&lt;DatasetDOMStringMap&gt; m_dataset;
181     std::unique_ptr&lt;DOMTokenList&gt; m_classList;
182     RefPtr&lt;ShadowRoot&gt; m_shadowRoot;
183     std::unique_ptr&lt;CustomElementReactionQueue&gt; m_customElementReactionQueue;
184     std::unique_ptr&lt;NamedNodeMap&gt; m_attributeMap;
185 #if ENABLE(INTERSECTION_OBSERVER)
186     std::unique_ptr&lt;IntersectionObserverData&gt; m_intersectionObserverData;
187 #endif
188 
189 #if ENABLE(RESIZE_OBSERVER)
190     std::unique_ptr&lt;ResizeObserverData&gt; m_resizeObserverData;
191 #endif
192 
<a name="5" id="anc5"></a><span class="line-added">193     std::unique_ptr&lt;KeyframeEffectStack&gt; m_keyframeEffectStack;</span>
<span class="line-added">194 </span>
195     RefPtr&lt;PseudoElement&gt; m_beforePseudoElement;
196     RefPtr&lt;PseudoElement&gt; m_afterPseudoElement;
197 
198 #if ENABLE(CSS_TYPED_OM)
199     RefPtr&lt;StylePropertyMap&gt; m_attributeStyleMap;
200 #endif
201 
<a name="6" id="anc6"></a><span class="line-added">202     std::unique_ptr&lt;DOMTokenList&gt; m_partList;</span>
<span class="line-added">203     SpaceSplitString m_partNames;</span>
<span class="line-added">204 </span>
205     void releasePseudoElement(PseudoElement*);
206 };
207 
208 inline ElementRareData::ElementRareData()
209     : NodeRareData(Type::Element)
210     , m_tabIndex(0)
211     , m_childIndex(0)
212     , m_tabIndexWasSetExplicitly(false)
213 #if ENABLE(FULLSCREEN_API)
214     , m_containsFullScreenElement(false)
215 #endif
216     , m_hasPendingResources(false)
217     , m_hasCSSAnimation(false)
218     , m_hasElementIdentifier(false)
219     , m_minimumSizeForResizing(defaultMinimumSizeForResizing())
220 {
221 }
222 
223 inline ElementRareData::~ElementRareData()
224 {
225     ASSERT(!m_shadowRoot);
226     ASSERT(!m_beforePseudoElement);
227     ASSERT(!m_afterPseudoElement);
228 }
229 
230 inline void ElementRareData::setBeforePseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp; pseudoElement)
231 {
232     ASSERT(!m_beforePseudoElement || !pseudoElement);
233     m_beforePseudoElement = WTFMove(pseudoElement);
234 }
235 
236 inline void ElementRareData::setAfterPseudoElement(RefPtr&lt;PseudoElement&gt;&amp;&amp; pseudoElement)
237 {
238     ASSERT(!m_afterPseudoElement || !pseudoElement);
239     m_afterPseudoElement = WTFMove(pseudoElement);
240 }
241 
242 inline void ElementRareData::resetComputedStyle()
243 {
244     m_computedStyle = nullptr;
245 }
246 
247 inline void ElementRareData::resetStyleRelations()
248 {
249     setChildIndex(0);
250 }
251 
252 } // namespace WebCore
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
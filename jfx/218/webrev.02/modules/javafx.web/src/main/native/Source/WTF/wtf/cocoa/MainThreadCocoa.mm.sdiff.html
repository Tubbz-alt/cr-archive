<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/cocoa/MainThreadCocoa.mm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MachSendRight.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryFootprintCocoa.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/cocoa/MainThreadCocoa.mm</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #import &lt;wtf/SchedulePair.h&gt;
 40 #import &lt;wtf/Threading.h&gt;
 41 
 42 #if USE(WEB_THREAD)
 43 #include &lt;wtf/ios/WebCoreThread.h&gt;
 44 #endif
 45 
 46 @interface JSWTFMainThreadCaller : NSObject
 47 - (void)call;
 48 @end
 49 
 50 @implementation JSWTFMainThreadCaller
 51 
 52 - (void)call
 53 {
 54     WTF::dispatchFunctionsFromMainThread();
 55 }
 56 
 57 @end
 58 


 59 namespace WTF {
 60 







 61 static JSWTFMainThreadCaller* staticMainThreadCaller;
 62 static bool isTimerPosted; // This is only accessed on the main thread.
<span class="line-modified"> 63 static bool mainThreadEstablishedAsPthreadMain { false };</span>


 64 static pthread_t mainThreadPthread { nullptr };
 65 static NSThread* mainThreadNSThread { nullptr };
 66 
<span class="line-removed"> 67 #if USE(WEB_THREAD)</span>
 68 static Thread* sApplicationUIThread;
 69 static Thread* sWebThread;
 70 #endif
 71 
 72 void initializeMainThreadPlatform()
<span class="line-removed"> 73 {</span>
<span class="line-removed"> 74     ASSERT(!staticMainThreadCaller);</span>
<span class="line-removed"> 75     staticMainThreadCaller = [[JSWTFMainThreadCaller alloc] init];</span>
<span class="line-removed"> 76 </span>
<span class="line-removed"> 77 #if !USE(WEB_THREAD)</span>
<span class="line-removed"> 78     mainThreadEstablishedAsPthreadMain = false;</span>
<span class="line-removed"> 79     mainThreadPthread = pthread_self();</span>
<span class="line-removed"> 80     mainThreadNSThread = [NSThread currentThread];</span>
<span class="line-removed"> 81 #else</span>
<span class="line-removed"> 82     mainThreadEstablishedAsPthreadMain = true;</span>
<span class="line-removed"> 83     ASSERT(!mainThreadPthread);</span>
<span class="line-removed"> 84     ASSERT(!mainThreadNSThread);</span>
<span class="line-removed"> 85 #endif</span>
<span class="line-removed"> 86 }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88 #if !USE(WEB_THREAD)</span>
<span class="line-removed"> 89 void initializeMainThreadToProcessMainThreadPlatform()</span>
 90 {
 91     if (!pthread_main_np())
<span class="line-modified"> 92         NSLog(@&quot;WebKit Threading Violation - initial use of WebKit from a secondary thread.&quot;);</span>

 93 
 94     ASSERT(!staticMainThreadCaller);
 95     staticMainThreadCaller = [[JSWTFMainThreadCaller alloc] init];
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97     mainThreadEstablishedAsPthreadMain = true;</span>
<span class="line-removed"> 98     mainThreadPthread = 0;</span>
<span class="line-removed"> 99     mainThreadNSThread = nil;</span>
100 }
<span class="line-removed">101 #endif // !USE(WEB_THREAD)</span>
102 
103 static void timerFired(CFRunLoopTimerRef timer, void*)
104 {
105     CFRelease(timer);
106     isTimerPosted = false;
107 
108     @autoreleasepool {
109         WTF::dispatchFunctionsFromMainThread();
110     }
111 }
112 
113 static void postTimer()
114 {
115     ASSERT(isMainThread());
116 
117     if (isTimerPosted)
118         return;
119 
120     isTimerPosted = true;
121     CFRunLoopAddTimer(CFRunLoopGetCurrent(), CFRunLoopTimerCreate(0, 0, 0, 0, 0, timerFired, 0), kCFRunLoopCommonModes);
122 }
123 
124 void scheduleDispatchFunctionsOnMainThread()
125 {
126     ASSERT(staticMainThreadCaller);
127 

128     if (isWebThread()) {
129         postTimer();
130         return;
131     }
<span class="line-modified">132     </span>
<span class="line-modified">133     if (mainThreadEstablishedAsPthreadMain) {</span>
<span class="line-modified">134         ASSERT(!mainThreadNSThread);</span>
<span class="line-modified">135         [staticMainThreadCaller performSelectorOnMainThread:@selector(call) withObject:nil waitUntilDone:NO];</span>




136         return;
137     }

138 
<span class="line-modified">139     ASSERT(mainThreadNSThread);</span>
<span class="line-removed">140     [staticMainThreadCaller performSelector:@selector(call) onThread:mainThreadNSThread withObject:nil waitUntilDone:NO];</span>
141 }
142 
143 void dispatchAsyncOnMainThreadWithWebThreadLockIfNeeded(void (^block)())
144 {
145 #if USE(WEB_THREAD)
146     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
147         dispatch_async(dispatch_get_main_queue(), ^{
148             WebCoreWebThreadLock();
149             block();
150         });
151         return;
152     }
153 #endif
154     dispatch_async(dispatch_get_main_queue(), block);
155 }
156 
157 void callOnWebThreadOrDispatchAsyncOnMainThread(void (^block)())
158 {
159 #if USE(WEB_THREAD)
160     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
161         WebCoreWebThreadRun(block);
162         return;
163     }
164 #endif
165     dispatch_async(dispatch_get_main_queue(), block);
166 }
167 
168 #if USE(WEB_THREAD)

169 static bool webThreadIsUninitializedOrLockedOrDisabled()
170 {
171     return !WebCoreWebThreadIsLockedOrDisabled || WebCoreWebThreadIsLockedOrDisabled();
172 }
173 
174 bool isMainThread()
175 {
176     return (isWebThread() || pthread_main_np()) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
177 }
178 
<span class="line-removed">179 bool isMainThreadIfInitialized()</span>
<span class="line-removed">180 {</span>
<span class="line-removed">181     return isMainThread();</span>
<span class="line-removed">182 }</span>
<span class="line-removed">183 </span>
<span class="line-removed">184 bool isMainThreadInitialized()</span>
<span class="line-removed">185 {</span>
<span class="line-removed">186     return true;</span>
<span class="line-removed">187 }</span>
<span class="line-removed">188 </span>
189 bool isUIThread()
190 {
191     return pthread_main_np();
192 }
193 
194 // Keep in mind that isWebThread can be called even when destroying the current thread.
195 bool isWebThread()
196 {
197     return pthread_equal(pthread_self(), mainThreadPthread);
198 }
199 
200 void initializeApplicationUIThread()
201 {
202     ASSERT(pthread_main_np());
203     sApplicationUIThread = &amp;Thread::current();
204 }
205 
<span class="line-modified">206 void initializeWebThreadPlatform()</span>
207 {
<span class="line-modified">208     ASSERT(!pthread_main_np());</span>
<span class="line-modified">209 </span>
<span class="line-modified">210     mainThreadEstablishedAsPthreadMain = false;</span>
<span class="line-modified">211     mainThreadPthread = pthread_self();</span>
<span class="line-modified">212     mainThreadNSThread = [NSThread currentThread];</span>
<span class="line-modified">213 </span>
<span class="line-modified">214     sWebThread = &amp;Thread::current();</span>
215 }
216 
<span class="line-modified">217 bool canAccessThreadLocalDataForThread(Thread&amp; thread)</span>
218 {
219     Thread&amp; currentThread = Thread::current();
220     if (&amp;thread == &amp;currentThread)
221         return true;
222 
223     if (&amp;thread == sWebThread || &amp;thread == sApplicationUIThread)
224         return (&amp;currentThread == sWebThread || &amp;currentThread == sApplicationUIThread) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
225 
226     return false;
227 }
<span class="line-removed">228 #else</span>
<span class="line-removed">229 bool isMainThread()</span>
<span class="line-removed">230 {</span>
<span class="line-removed">231     if (mainThreadEstablishedAsPthreadMain) {</span>
<span class="line-removed">232         ASSERT(!mainThreadPthread);</span>
<span class="line-removed">233         return pthread_main_np();</span>
<span class="line-removed">234     }</span>
<span class="line-removed">235 </span>
<span class="line-removed">236     ASSERT(mainThreadPthread);</span>
<span class="line-removed">237     return pthread_equal(pthread_self(), mainThreadPthread);</span>
<span class="line-removed">238 }</span>
239 
<span class="line-modified">240 bool isMainThreadIfInitialized()</span>
<span class="line-removed">241 {</span>
<span class="line-removed">242     if (mainThreadEstablishedAsPthreadMain)</span>
<span class="line-removed">243         return pthread_main_np();</span>
<span class="line-removed">244     return pthread_equal(pthread_self(), mainThreadPthread);</span>
<span class="line-removed">245 }</span>
246 
<span class="line-modified">247 bool isMainThreadInitialized()</span>
248 {
<span class="line-modified">249     return mainThreadEstablishedAsPthreadMain || mainThreadPthread;</span>
250 }
251 
252 #endif // USE(WEB_THREAD)
253 
254 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
 39 #import &lt;wtf/SchedulePair.h&gt;
 40 #import &lt;wtf/Threading.h&gt;
 41 
 42 #if USE(WEB_THREAD)
 43 #include &lt;wtf/ios/WebCoreThread.h&gt;
 44 #endif
 45 
 46 @interface JSWTFMainThreadCaller : NSObject
 47 - (void)call;
 48 @end
 49 
 50 @implementation JSWTFMainThreadCaller
 51 
 52 - (void)call
 53 {
 54     WTF::dispatchFunctionsFromMainThread();
 55 }
 56 
 57 @end
 58 
<span class="line-added"> 59 #define LOG_CHANNEL_PREFIX Log</span>
<span class="line-added"> 60 </span>
 61 namespace WTF {
 62 
<span class="line-added"> 63 #if RELEASE_LOG_DISABLED</span>
<span class="line-added"> 64 WTFLogChannel LogThreading = { WTFLogChannelState::On, &quot;Threading&quot;, WTFLogLevel::Error };</span>
<span class="line-added"> 65 #else</span>
<span class="line-added"> 66 WTFLogChannel LogThreading = { WTFLogChannelState::On, &quot;Threading&quot;, WTFLogLevel::Error, LOG_CHANNEL_WEBKIT_SUBSYSTEM, OS_LOG_DEFAULT };</span>
<span class="line-added"> 67 #endif</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 </span>
 70 static JSWTFMainThreadCaller* staticMainThreadCaller;
 71 static bool isTimerPosted; // This is only accessed on the main thread.
<span class="line-modified"> 72 </span>
<span class="line-added"> 73 #if USE(WEB_THREAD)</span>
<span class="line-added"> 74 // When the Web thread is enabled, we consider it to be the main thread, not pthread main.</span>
 75 static pthread_t mainThreadPthread { nullptr };
 76 static NSThread* mainThreadNSThread { nullptr };
 77 

 78 static Thread* sApplicationUIThread;
 79 static Thread* sWebThread;
 80 #endif
 81 
 82 void initializeMainThreadPlatform()

















 83 {
 84     if (!pthread_main_np())
<span class="line-modified"> 85         RELEASE_LOG_FAULT(Threading, &quot;WebKit Threading Violation - initial use of WebKit from a secondary thread.&quot;);</span>
<span class="line-added"> 86     ASSERT(pthread_main_np());</span>
 87 
 88     ASSERT(!staticMainThreadCaller);
 89     staticMainThreadCaller = [[JSWTFMainThreadCaller alloc] init];




 90 }

 91 
 92 static void timerFired(CFRunLoopTimerRef timer, void*)
 93 {
 94     CFRelease(timer);
 95     isTimerPosted = false;
 96 
 97     @autoreleasepool {
 98         WTF::dispatchFunctionsFromMainThread();
 99     }
100 }
101 
102 static void postTimer()
103 {
104     ASSERT(isMainThread());
105 
106     if (isTimerPosted)
107         return;
108 
109     isTimerPosted = true;
110     CFRunLoopAddTimer(CFRunLoopGetCurrent(), CFRunLoopTimerCreate(0, 0, 0, 0, 0, timerFired, 0), kCFRunLoopCommonModes);
111 }
112 
113 void scheduleDispatchFunctionsOnMainThread()
114 {
115     ASSERT(staticMainThreadCaller);
116 
<span class="line-added">117 #if USE(WEB_THREAD)</span>
118     if (isWebThread()) {
119         postTimer();
120         return;
121     }
<span class="line-modified">122 </span>
<span class="line-modified">123     if (mainThreadPthread) {</span>
<span class="line-modified">124         [staticMainThreadCaller performSelector:@selector(call) onThread:mainThreadNSThread withObject:nil waitUntilDone:NO];</span>
<span class="line-modified">125         return;</span>
<span class="line-added">126     }</span>
<span class="line-added">127 #else</span>
<span class="line-added">128     if (isMainThread()) {</span>
<span class="line-added">129         postTimer();</span>
130         return;
131     }
<span class="line-added">132 #endif</span>
133 
<span class="line-modified">134     [staticMainThreadCaller performSelectorOnMainThread:@selector(call) withObject:nil waitUntilDone:NO];</span>

135 }
136 
137 void dispatchAsyncOnMainThreadWithWebThreadLockIfNeeded(void (^block)())
138 {
139 #if USE(WEB_THREAD)
140     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
141         dispatch_async(dispatch_get_main_queue(), ^{
142             WebCoreWebThreadLock();
143             block();
144         });
145         return;
146     }
147 #endif
148     dispatch_async(dispatch_get_main_queue(), block);
149 }
150 
151 void callOnWebThreadOrDispatchAsyncOnMainThread(void (^block)())
152 {
153 #if USE(WEB_THREAD)
154     if (WebCoreWebThreadIsEnabled &amp;&amp; WebCoreWebThreadIsEnabled()) {
155         WebCoreWebThreadRun(block);
156         return;
157     }
158 #endif
159     dispatch_async(dispatch_get_main_queue(), block);
160 }
161 
162 #if USE(WEB_THREAD)
<span class="line-added">163 </span>
164 static bool webThreadIsUninitializedOrLockedOrDisabled()
165 {
166     return !WebCoreWebThreadIsLockedOrDisabled || WebCoreWebThreadIsLockedOrDisabled();
167 }
168 
169 bool isMainThread()
170 {
171     return (isWebThread() || pthread_main_np()) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
172 }
173 










174 bool isUIThread()
175 {
176     return pthread_main_np();
177 }
178 
179 // Keep in mind that isWebThread can be called even when destroying the current thread.
180 bool isWebThread()
181 {
182     return pthread_equal(pthread_self(), mainThreadPthread);
183 }
184 
185 void initializeApplicationUIThread()
186 {
187     ASSERT(pthread_main_np());
188     sApplicationUIThread = &amp;Thread::current();
189 }
190 
<span class="line-modified">191 void initializeWebThread()</span>
192 {
<span class="line-modified">193     static std::once_flag initializeKey;</span>
<span class="line-modified">194     std::call_once(initializeKey, [] {</span>
<span class="line-modified">195         ASSERT(!pthread_main_np());</span>
<span class="line-modified">196         mainThreadPthread = pthread_self();</span>
<span class="line-modified">197         mainThreadNSThread = [NSThread currentThread];</span>
<span class="line-modified">198         sWebThread = &amp;Thread::current();</span>
<span class="line-modified">199     });</span>
200 }
201 
<span class="line-modified">202 bool canCurrentThreadAccessThreadLocalData(Thread&amp; thread)</span>
203 {
204     Thread&amp; currentThread = Thread::current();
205     if (&amp;thread == &amp;currentThread)
206         return true;
207 
208     if (&amp;thread == sWebThread || &amp;thread == sApplicationUIThread)
209         return (&amp;currentThread == sWebThread || &amp;currentThread == sApplicationUIThread) &amp;&amp; webThreadIsUninitializedOrLockedOrDisabled();
210 
211     return false;
212 }











213 
<span class="line-modified">214 #else</span>





215 
<span class="line-modified">216 bool isMainThread()</span>
217 {
<span class="line-modified">218     return pthread_main_np();</span>
219 }
220 
221 #endif // USE(WEB_THREAD)
222 
223 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="MachSendRight.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MemoryFootprintCocoa.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
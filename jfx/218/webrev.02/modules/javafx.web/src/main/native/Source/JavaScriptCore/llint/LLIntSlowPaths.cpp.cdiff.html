<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LLIntPCRanges.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,12 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;LLIntSlowPaths.h&quot;
  
  #include &quot;ArrayConstructor.h&quot;
  #include &quot;CallFrame.h&quot;
<span class="line-modified">! #include &quot;CommonSlowPaths.h&quot;</span>
  #include &quot;Error.h&quot;
  #include &quot;ErrorHandlingScope.h&quot;
  #include &quot;EvalCodeBlock.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;ExceptionFuzz.h&quot;
<span class="line-new-header">--- 25,14 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;LLIntSlowPaths.h&quot;
  
  #include &quot;ArrayConstructor.h&quot;
<span class="line-added">+ #include &quot;BytecodeGenerator.h&quot;</span>
  #include &quot;CallFrame.h&quot;
<span class="line-modified">! #include &quot;CheckpointOSRExitSideState.h&quot;</span>
<span class="line-added">+ #include &quot;CommonSlowPathsInlines.h&quot;</span>
  #include &quot;Error.h&quot;
  #include &quot;ErrorHandlingScope.h&quot;
  #include &quot;EvalCodeBlock.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;ExceptionFuzz.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
  #include &quot;ModuleProgramCodeBlock.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;ObjectPropertyConditionSet.h&quot;
  #include &quot;OpcodeInlines.h&quot;
  #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">! #include &quot;ProtoCallFrame.h&quot;</span>
  #include &quot;RegExpObject.h&quot;
  #include &quot;ShadowChicken.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;VMInlines.h&quot;
<span class="line-new-header">--- 64,11 ---</span>
  #include &quot;ModuleProgramCodeBlock.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  #include &quot;ObjectPropertyConditionSet.h&quot;
  #include &quot;OpcodeInlines.h&quot;
  #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">! #include &quot;ProtoCallFrameInlines.h&quot;</span>
  #include &quot;RegExpObject.h&quot;
  #include &quot;ShadowChicken.h&quot;
  #include &quot;StructureRareDataInlines.h&quot;
  #include &quot;SuperSampler.h&quot;
  #include &quot;VMInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,59 ***</span>
  #include &lt;wtf/StringPrintStream.h&gt;
  
  namespace JSC { namespace LLInt {
  
  #define LLINT_BEGIN_NO_SET_PC() \
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();      \</span>
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec); \</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm)
  
  #ifndef NDEBUG
  #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">!         exec-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #else
  #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         exec-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #endif
  
  #define LLINT_BEGIN()                           \
      LLINT_BEGIN_NO_SET_PC();                    \
      LLINT_SET_PC_FOR_STUBS()
  
<span class="line-modified">! inline JSValue getNonConstantOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;uncheckedR(operand.offset()).jsValue(); }</span>
<span class="line-modified">! inline JSValue getOperand(ExecState* exec, const VirtualRegister&amp; operand) { return exec-&gt;r(operand.offset()).jsValue(); }</span>
  
  #define LLINT_RETURN_TWO(first, second) do {       \
          return encodeResult(first, second);        \
      } while (false)
  
<span class="line-modified">! #define LLINT_END_IMPL() LLINT_RETURN_TWO(pc, 0)</span>
  
  #define LLINT_THROW(exceptionToThrow) do {                        \
<span class="line-modified">!         throwException(exec, throwScope, exceptionToThrow);       \</span>
<span class="line-modified">!         pc = returnToThrow(exec);                                 \</span>
          LLINT_END_IMPL();                                         \
      } while (false)
  
  #define LLINT_CHECK_EXCEPTION() do {                    \
<span class="line-modified">!         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;LLIntSlowPaths&quot;, pc);    \</span>
          if (UNLIKELY(throwScope.exception())) {         \
<span class="line-modified">!             pc = returnToThrow(exec);                   \</span>
              LLINT_END_IMPL();                           \
          }                                               \
      } while (false)
  
  #define LLINT_END() do {                        \
          LLINT_CHECK_EXCEPTION();                \
          LLINT_END_IMPL();                       \
      } while (false)
  
  #define JUMP_OFFSET(targetOffset) \
<span class="line-modified">!     ((targetOffset) ? (targetOffset) : exec-&gt;codeBlock()-&gt;outOfLineJumpOffset(pc))</span>
  
  #define JUMP_TO(target) do { \
          pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + (target)); \
      } while (false)
  
<span class="line-new-header">--- 76,61 ---</span>
  #include &lt;wtf/StringPrintStream.h&gt;
  
  namespace JSC { namespace LLInt {
  
  #define LLINT_BEGIN_NO_SET_PC() \
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \</span>
<span class="line-modified">!     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \</span>
<span class="line-added">+     VM&amp; vm = codeBlock-&gt;vm(); \</span>
<span class="line-added">+     SlowPathFrameTracer tracer(vm, callFrame); \</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm)
  
  #ifndef NDEBUG
  #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         codeBlock-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">!         callFrame-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #else
  #define LLINT_SET_PC_FOR_STUBS() do { \
<span class="line-modified">!         callFrame-&gt;setCurrentVPC(pc); \</span>
      } while (false)
  #endif
  
  #define LLINT_BEGIN()                           \
      LLINT_BEGIN_NO_SET_PC();                    \
      LLINT_SET_PC_FOR_STUBS()
  
<span class="line-modified">! inline JSValue getNonConstantOperand(CallFrame* callFrame, VirtualRegister operand) { return callFrame-&gt;uncheckedR(operand).jsValue(); }</span>
<span class="line-modified">! inline JSValue getOperand(CallFrame* callFrame, VirtualRegister operand) { return callFrame-&gt;r(operand).jsValue(); }</span>
  
  #define LLINT_RETURN_TWO(first, second) do {       \
          return encodeResult(first, second);        \
      } while (false)
  
<span class="line-modified">! #define LLINT_END_IMPL() LLINT_RETURN_TWO(pc, nullptr)</span>
  
  #define LLINT_THROW(exceptionToThrow) do {                        \
<span class="line-modified">!         throwException(globalObject, throwScope, exceptionToThrow);       \</span>
<span class="line-modified">!         pc = returnToThrow(vm);                                 \</span>
          LLINT_END_IMPL();                                         \
      } while (false)
  
  #define LLINT_CHECK_EXCEPTION() do {                    \
<span class="line-modified">!         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;LLIntSlowPaths&quot;, pc);    \</span>
          if (UNLIKELY(throwScope.exception())) {         \
<span class="line-modified">!             pc = returnToThrow(vm);                   \</span>
              LLINT_END_IMPL();                           \
          }                                               \
      } while (false)
  
  #define LLINT_END() do {                        \
          LLINT_CHECK_EXCEPTION();                \
          LLINT_END_IMPL();                       \
      } while (false)
  
  #define JUMP_OFFSET(targetOffset) \
<span class="line-modified">!     ((targetOffset) ? (targetOffset) : codeBlock-&gt;outOfLineJumpOffset(pc))</span>
  
  #define JUMP_TO(target) do { \
          pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + (target)); \
      } while (false)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 141,54 ***</span>
      } while (false)
  
  #define LLINT_RETURN(value) do {                \
          JSValue __r_returnValue = (value);      \
          LLINT_CHECK_EXCEPTION();                \
<span class="line-modified">!         exec-&gt;uncheckedR(bytecode.m_dst) = __r_returnValue;          \</span>
          LLINT_END_IMPL();                       \
      } while (false)
  
  #define LLINT_RETURN_PROFILED(value) do {               \
          JSValue __rp_returnValue = (value);                     \
          LLINT_CHECK_EXCEPTION();                                \
<span class="line-modified">!         exec-&gt;uncheckedR(bytecode.m_dst) = __rp_returnValue;                         \</span>
          LLINT_PROFILE_VALUE(__rp_returnValue);          \
          LLINT_END_IMPL();                                       \
      } while (false)
  
  #define LLINT_PROFILE_VALUE(value) do { \
<span class="line-modified">!         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_END_IMPL(exec, callTarget, callTargetTag) \</span>
<span class="line-modified">!     LLINT_RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))</span>
  
<span class="line-modified">! #define LLINT_CALL_THROW(exec, exceptionToThrow) do {                   \</span>
<span class="line-modified">!         ExecState* __ct_exec = (exec);                                  \</span>
<span class="line-modified">!         throwException(__ct_exec, throwScope, exceptionToThrow);        \</span>
<span class="line-modified">!         LLINT_CALL_END_IMPL(0, callToThrow(__ct_exec), ExceptionHandlerPtrTag);                 \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_CHECK_EXCEPTION(exec, execCallee) do {               \</span>
<span class="line-modified">!         ExecState* __cce_exec = (exec);                                 \</span>
<span class="line-modified">!         ExecState* __cce_execCallee = (execCallee);                     \</span>
<span class="line-removed">-         doExceptionFuzzingIfEnabled(__cce_exec, throwScope, &quot;LLIntSlowPaths/call&quot;, nullptr); \</span>
          if (UNLIKELY(throwScope.exception()))                           \
<span class="line-modified">!             LLINT_CALL_END_IMPL(0, callToThrow(__cce_execCallee), ExceptionHandlerPtrTag); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_RETURN(exec, execCallee, callTarget, callTargetTag) do { \</span>
<span class="line-modified">!         ExecState* __cr_exec = (exec);                                  \</span>
<span class="line-modified">!         ExecState* __cr_execCallee = (execCallee);                      \</span>
<span class="line-modified">!         void* __cr_callTarget = (callTarget);                           \</span>
<span class="line-modified">!         LLINT_CALL_CHECK_EXCEPTION(__cr_exec, __cr_execCallee);         \</span>
<span class="line-modified">!         LLINT_CALL_END_IMPL(__cr_execCallee, __cr_callTarget, callTargetTag); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_RETURN_CALLEE_FRAME(execCallee) do {                      \</span>
<span class="line-modified">!         ExecState* __rcf_exec = (execCallee);                           \</span>
<span class="line-modified">!         LLINT_RETURN_TWO(pc, __rcf_exec);                               \</span>
      } while (false)
  
  #if LLINT_TRACING
  
  template&lt;typename... Types&gt;
<span class="line-new-header">--- 145,53 ---</span>
      } while (false)
  
  #define LLINT_RETURN(value) do {                \
          JSValue __r_returnValue = (value);      \
          LLINT_CHECK_EXCEPTION();                \
<span class="line-modified">!         callFrame-&gt;uncheckedR(bytecode.m_dst) = __r_returnValue;          \</span>
          LLINT_END_IMPL();                       \
      } while (false)
  
  #define LLINT_RETURN_PROFILED(value) do {               \
          JSValue __rp_returnValue = (value);                     \
          LLINT_CHECK_EXCEPTION();                                \
<span class="line-modified">!         callFrame-&gt;uncheckedR(bytecode.m_dst) = __rp_returnValue;                         \</span>
          LLINT_PROFILE_VALUE(__rp_returnValue);          \
          LLINT_END_IMPL();                                       \
      } while (false)
  
  #define LLINT_PROFILE_VALUE(value) do { \
<span class="line-modified">!         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_END_IMPL(callFrame, callTarget, callTargetTag) \</span>
<span class="line-modified">!     LLINT_RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (callFrame))</span>
  
<span class="line-modified">! #define LLINT_CALL_THROW(globalObject, exceptionToThrow) do {                   \</span>
<span class="line-modified">!         JSGlobalObject* __ct_globalObject = (globalObject);                                  \</span>
<span class="line-modified">!         throwException(__ct_globalObject, throwScope, exceptionToThrow);        \</span>
<span class="line-modified">!         LLINT_CALL_END_IMPL(nullptr, callToThrow(vm), ExceptionHandlerPtrTag);                 \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_CHECK_EXCEPTION(globalObject) do {               \</span>
<span class="line-modified">!         JSGlobalObject* __cce_globalObject = (globalObject);                                 \</span>
<span class="line-modified">!         doExceptionFuzzingIfEnabled(__cce_globalObject, throwScope, &quot;LLIntSlowPaths/call&quot;, nullptr); \</span>
          if (UNLIKELY(throwScope.exception()))                           \
<span class="line-modified">!             LLINT_CALL_END_IMPL(nullptr, callToThrow(vm), ExceptionHandlerPtrTag); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_CALL_RETURN(globalObject, calleeFrame, callTarget, callTargetTag) do { \</span>
<span class="line-modified">!         JSGlobalObject* __cr_globalObject = (globalObject); \</span>
<span class="line-modified">!         CallFrame* __cr_calleeFrame = (calleeFrame); \</span>
<span class="line-modified">!         void* __cr_callTarget = (callTarget); \</span>
<span class="line-modified">!         LLINT_CALL_CHECK_EXCEPTION(__cr_globalObject);         \</span>
<span class="line-modified">!         LLINT_CALL_END_IMPL(__cr_calleeFrame, __cr_callTarget, callTargetTag); \</span>
      } while (false)
  
<span class="line-modified">! #define LLINT_RETURN_CALLEE_FRAME(calleeFrame) do { \</span>
<span class="line-modified">!         CallFrame* __rcf_calleeFrame = (calleeFrame); \</span>
<span class="line-modified">!         LLINT_RETURN_TWO(pc, __rcf_calleeFrame); \</span>
      } while (false)
  
  #if LLINT_TRACING
  
  template&lt;typename... Types&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,34 ***</span>
  template&lt;typename... Types&gt; void slowPathLogLn(const Types&amp;...) { }
  template&lt;typename... Types&gt; void slowPathLogF(const char*, const Types&amp;...) { }
  
  #endif // LLINT_TRACING
  
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType llint_trace_operand(ExecState* exec, const Instruction* pc, int fromWhere, int operand)</span>
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
      LLINT_BEGIN();
      dataLogF(
          &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d\n&quot;,
          &amp;Thread::current(),
<span class="line-modified">!         exec-&gt;codeBlock(),</span>
<span class="line-modified">!         exec,</span>
<span class="line-modified">!         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
          pc-&gt;opcodeID(),
          fromWhere,
          operand);
      LLINT_END();
  }
  
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType llint_trace_value(ExecState* exec, const Instruction* pc, int fromWhere, VirtualRegister operand)</span>
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
<span class="line-modified">!     JSValue value = getOperand(exec, operand);</span>
      union {
          struct {
              uint32_t tag;
              uint32_t payload;
          } bits;
<span class="line-new-header">--- 223,34 ---</span>
  template&lt;typename... Types&gt; void slowPathLogLn(const Types&amp;...) { }
  template&lt;typename... Types&gt; void slowPathLogF(const char*, const Types&amp;...) { }
  
  #endif // LLINT_TRACING
  
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType llint_trace_operand(CallFrame* callFrame, const Instruction* pc, int fromWhere, int operand)</span>
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
      LLINT_BEGIN();
      dataLogF(
          &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d\n&quot;,
          &amp;Thread::current(),
<span class="line-modified">!         callFrame-&gt;codeBlock(),</span>
<span class="line-modified">!         globalObject,</span>
<span class="line-modified">!         static_cast&lt;intptr_t&gt;(callFrame-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
          pc-&gt;opcodeID(),
          fromWhere,
          operand);
      LLINT_END();
  }
  
<span class="line-modified">! extern &quot;C&quot; SlowPathReturnType llint_trace_value(CallFrame* callFrame, const Instruction* pc, int fromWhere, VirtualRegister operand)</span>
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
<span class="line-modified">!     JSValue value = getOperand(callFrame, operand);</span>
      union {
          struct {
              uint32_t tag;
              uint32_t payload;
          } bits;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,13 ***</span>
      } u;
      u.asValue = JSValue::encode(value);
      dataLogF(
          &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d: %08x:%08x: %s\n&quot;,
          &amp;Thread::current(),
<span class="line-modified">!         exec-&gt;codeBlock(),</span>
<span class="line-modified">!         exec,</span>
<span class="line-modified">!         static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
          pc-&gt;opcodeID(),
          fromWhere,
          operand.offset(),
          u.bits.tag,
          u.bits.payload,
<span class="line-new-header">--- 258,13 ---</span>
      } u;
      u.asValue = JSValue::encode(value);
      dataLogF(
          &quot;&lt;%p&gt; %p / %p: executing bc#%zu, op#%u: Trace(%d): %d: %08x:%08x: %s\n&quot;,
          &amp;Thread::current(),
<span class="line-modified">!         callFrame-&gt;codeBlock(),</span>
<span class="line-modified">!         callFrame,</span>
<span class="line-modified">!         static_cast&lt;intptr_t&gt;(callFrame-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
          pc-&gt;opcodeID(),
          fromWhere,
          operand.offset(),
          u.bits.tag,
          u.bits.payload,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,73 ***</span>
  LLINT_SLOW_PATH_DECL(trace_prologue)
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
<span class="line-modified">!     dataLogF(&quot;&lt;%p&gt; %p / %p: in prologue of &quot;, &amp;Thread::current(), exec-&gt;codeBlock(), exec);</span>
<span class="line-modified">!     dataLog(exec-&gt;codeBlock(), &quot;\n&quot;);</span>
      LLINT_END_IMPL();
  }
  
<span class="line-modified">! static void traceFunctionPrologue(ExecState* exec, const char* comment, CodeSpecializationKind kind)</span>
  {
      if (!Options::traceLLIntExecution())
          return;
  
<span class="line-modified">!     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
      FunctionExecutable* executable = callee-&gt;jsExecutable();
      CodeBlock* codeBlock = executable-&gt;codeBlockFor(kind);
<span class="line-modified">!     dataLogF(&quot;&lt;%p&gt; %p / %p: in %s of &quot;, &amp;Thread::current(), codeBlock, exec, comment);</span>
      dataLog(codeBlock);
      dataLogF(&quot; function %p, executable %p; numVars = %u, numParameters = %u, numCalleeLocals = %u, caller = %p.\n&quot;,
<span class="line-modified">!         callee, executable, codeBlock-&gt;numVars(), codeBlock-&gt;numParameters(), codeBlock-&gt;numCalleeLocals(), exec-&gt;callerFrame());</span>
  }
  
  LLINT_SLOW_PATH_DECL(trace_prologue_function_for_call)
  {
<span class="line-modified">!     traceFunctionPrologue(exec, &quot;call prologue&quot;, CodeForCall);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_prologue_function_for_construct)
  {
<span class="line-modified">!     traceFunctionPrologue(exec, &quot;construct prologue&quot;, CodeForConstruct);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_arityCheck_for_call)
  {
<span class="line-modified">!     traceFunctionPrologue(exec, &quot;call arity check&quot;, CodeForCall);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_arityCheck_for_construct)
  {
<span class="line-modified">!     traceFunctionPrologue(exec, &quot;construct arity check&quot;, CodeForConstruct);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace)
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
      OpcodeID opcodeID = pc-&gt;opcodeID();
      dataLogF(&quot;&lt;%p&gt; %p / %p: executing bc#%zu, %s, pc = %p\n&quot;,
              &amp;Thread::current(),
<span class="line-modified">!             exec-&gt;codeBlock(),</span>
<span class="line-modified">!             exec,</span>
<span class="line-modified">!             static_cast&lt;intptr_t&gt;(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc)),</span>
              pc-&gt;name(),
              pc);
      if (opcodeID == op_enter) {
<span class="line-modified">!         dataLogF(&quot;Frame will eventually return to %p\n&quot;, exec-&gt;returnPC().value());</span>
<span class="line-modified">!         *removeCodePtrTag&lt;volatile char*&gt;(exec-&gt;returnPC().value());</span>
      }
      if (opcodeID == op_ret) {
<span class="line-modified">!         dataLogF(&quot;Will be returning to %p\n&quot;, exec-&gt;returnPC().value());</span>
<span class="line-modified">!         dataLogF(&quot;The new cfr will be %p\n&quot;, exec-&gt;callerFrame());</span>
      }
      LLINT_END_IMPL();
  }
  
  enum EntryKind { Prologue, ArityCheck };
<span class="line-new-header">--- 275,75 ---</span>
  LLINT_SLOW_PATH_DECL(trace_prologue)
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-modified">!     dataLogF(&quot;&lt;%p&gt; %p / %p: in prologue of &quot;, &amp;Thread::current(), codeBlock, callFrame);</span>
<span class="line-added">+     dataLog(codeBlock, &quot;\n&quot;);</span>
      LLINT_END_IMPL();
  }
  
<span class="line-modified">! static void traceFunctionPrologue(CallFrame* callFrame, const char* comment, CodeSpecializationKind kind)</span>
  {
      if (!Options::traceLLIntExecution())
          return;
  
<span class="line-modified">!     JSFunction* callee = jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee());</span>
      FunctionExecutable* executable = callee-&gt;jsExecutable();
      CodeBlock* codeBlock = executable-&gt;codeBlockFor(kind);
<span class="line-modified">!     dataLogF(&quot;&lt;%p&gt; %p / %p: in %s of &quot;, &amp;Thread::current(), codeBlock, callFrame, comment);</span>
      dataLog(codeBlock);
      dataLogF(&quot; function %p, executable %p; numVars = %u, numParameters = %u, numCalleeLocals = %u, caller = %p.\n&quot;,
<span class="line-modified">!         callee, executable, codeBlock-&gt;numVars(), codeBlock-&gt;numParameters(), codeBlock-&gt;numCalleeLocals(), callFrame-&gt;callerFrame());</span>
  }
  
  LLINT_SLOW_PATH_DECL(trace_prologue_function_for_call)
  {
<span class="line-modified">!     traceFunctionPrologue(callFrame, &quot;call prologue&quot;, CodeForCall);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_prologue_function_for_construct)
  {
<span class="line-modified">!     traceFunctionPrologue(callFrame, &quot;construct prologue&quot;, CodeForConstruct);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_arityCheck_for_call)
  {
<span class="line-modified">!     traceFunctionPrologue(callFrame, &quot;call arity check&quot;, CodeForCall);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace_arityCheck_for_construct)
  {
<span class="line-modified">!     traceFunctionPrologue(callFrame, &quot;construct arity check&quot;, CodeForConstruct);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(trace)
  {
      if (!Options::traceLLIntExecution())
          LLINT_END_IMPL();
  
<span class="line-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
      OpcodeID opcodeID = pc-&gt;opcodeID();
      dataLogF(&quot;&lt;%p&gt; %p / %p: executing bc#%zu, %s, pc = %p\n&quot;,
              &amp;Thread::current(),
<span class="line-modified">!             codeBlock,</span>
<span class="line-modified">!             callFrame,</span>
<span class="line-modified">!             static_cast&lt;intptr_t&gt;(codeBlock-&gt;bytecodeOffset(pc)),</span>
              pc-&gt;name(),
              pc);
      if (opcodeID == op_enter) {
<span class="line-modified">!         dataLogF(&quot;Frame will eventually return to %p\n&quot;, callFrame-&gt;returnPC().value());</span>
<span class="line-modified">!         *removeCodePtrTag&lt;volatile char*&gt;(callFrame-&gt;returnPC().value());</span>
      }
      if (opcodeID == op_ret) {
<span class="line-modified">!         dataLogF(&quot;Will be returning to %p\n&quot;, callFrame-&gt;returnPC().value());</span>
<span class="line-modified">!         dataLogF(&quot;The new cfr will be %p\n&quot;, callFrame-&gt;callerFrame());</span>
      }
      LLINT_END_IMPL();
  }
  
  enum EntryKind { Prologue, ArityCheck };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 363,135 ***</span>
  
      return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
  }
  
  // Returns true if we should try to OSR.
<span class="line-modified">! inline bool jitCompileAndSetHeuristics(CodeBlock* codeBlock, ExecState* exec, unsigned loopOSREntryBytecodeOffset = 0)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
      ASSERT(VM::canUseJIT());
  
      codeBlock-&gt;updateAllValueProfilePredictions();
  
      if (!codeBlock-&gt;checkIfJITThresholdReached()) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLogF(&quot;    JIT threshold should be lifted.\n&quot;);</span>
          return false;
      }
  
      JITWorklist::ensureGlobalWorklist().poll(vm);
  
      switch (codeBlock-&gt;jitType()) {
      case JITType::BaselineJIT: {
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLogF(&quot;    Code was already compiled.\n&quot;);</span>
          codeBlock-&gt;jitSoon();
          return true;
      }
      case JITType::InterpreterThunk: {
<span class="line-modified">!         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeOffset);</span>
          return codeBlock-&gt;jitType() == JITType::BaselineJIT;
      }
      default:
          dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
          return false;
      }
  }
  
<span class="line-modified">! static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char *name, EntryKind kind)</span>
  {
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-modified">!             *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,</span>
<span class="line-removed">-             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      if (!shouldJIT(codeBlock)) {
          codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified">!         LLINT_RETURN_TWO(0, 0);</span>
      }
<span class="line-modified">!     if (!jitCompileAndSetHeuristics(codeBlock, exec))</span>
<span class="line-modified">!         LLINT_RETURN_TWO(0, 0);</span>
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;OSR entry&quot;, (&quot;in prologue&quot;));
  
      if (kind == Prologue)
<span class="line-modified">!         LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;executableAddress(), 0);</span>
      ASSERT(kind == ArityCheck);
<span class="line-modified">!     LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;addressForCall(MustCheckArity).executableAddress(), 0);</span>
  }
  #else // ENABLE(JIT)
<span class="line-modified">! static SlowPathReturnType entryOSR(ExecState* exec, const Instruction*, CodeBlock* codeBlock, const char*, EntryKind)</span>
  {
      codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified">!     LLINT_RETURN_TWO(0, exec);</span>
  }
  #endif // ENABLE(JIT)
  
  LLINT_SLOW_PATH_DECL(entry_osr)
  {
<span class="line-modified">!     return entryOSR(exec, pc, exec-&gt;codeBlock(), &quot;entry_osr&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_call)
  {
<span class="line-modified">!     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct)
  {
<span class="line-modified">!     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_call_arityCheck)
  {
<span class="line-modified">!     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call_arityCheck&quot;, ArityCheck);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct_arityCheck)
  {
<span class="line-modified">!     return entryOSR(exec, pc, jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct_arityCheck&quot;, ArityCheck);</span>
  }
  
  LLINT_SLOW_PATH_DECL(loop_osr)
  {
      LLINT_BEGIN_NO_SET_PC();
      UNUSED_PARAM(throwScope);
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
  #if ENABLE(JIT)
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-removed">-         dataLog(</span>
              *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
<span class="line-modified">!             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     unsigned loopOSREntryBytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);</span>
  
      if (!shouldJIT(codeBlock)) {
          codeBlock-&gt;dontJITAnytimeSoon();
          LLINT_RETURN_TWO(0, 0);
      }
  
<span class="line-modified">!     if (!jitCompileAndSetHeuristics(codeBlock, exec, loopOSREntryBytecodeOffset))</span>
          LLINT_RETURN_TWO(0, 0);
  
<span class="line-modified">!     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at bc#&quot;, loopOSREntryBytecodeOffset));</span>
  
      ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);
  
      const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
<span class="line-modified">!     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeOffset);</span>
      ASSERT(codeLocation);
  
      void* jumpTarget = codeLocation.executableAddress();
      ASSERT(jumpTarget);
  
<span class="line-modified">!     LLINT_RETURN_TWO(jumpTarget, exec-&gt;topOfFrame());</span>
  #else // ENABLE(JIT)
      UNUSED_PARAM(pc);
      codeBlock-&gt;dontJITAnytimeSoon();
      LLINT_RETURN_TWO(0, 0);
  #endif // ENABLE(JIT)
<span class="line-new-header">--- 368,134 ---</span>
  
      return VM::canUseJIT() &amp;&amp; Options::useBaselineJIT();
  }
  
  // Returns true if we should try to OSR.
<span class="line-modified">! inline bool jitCompileAndSetHeuristics(VM&amp; vm, CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex = BytecodeIndex(0))</span>
  {
      DeferGCForAWhile deferGC(vm.heap); // My callers don&#39;t set top callframe, so we don&#39;t want to GC here at all.
      ASSERT(VM::canUseJIT());
  
      codeBlock-&gt;updateAllValueProfilePredictions();
  
      if (!codeBlock-&gt;checkIfJITThresholdReached()) {
          CODEBLOCK_LOG_EVENT(codeBlock, &quot;delayJITCompile&quot;, (&quot;threshold not reached, counter = &quot;, codeBlock-&gt;llintExecuteCounter()));
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    JIT threshold should be lifted.&quot;);</span>
          return false;
      }
  
      JITWorklist::ensureGlobalWorklist().poll(vm);
  
      switch (codeBlock-&gt;jitType()) {
      case JITType::BaselineJIT: {
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    Code was already compiled.&quot;);</span>
          codeBlock-&gt;jitSoon();
          return true;
      }
      case JITType::InterpreterThunk: {
<span class="line-modified">!         JITWorklist::ensureGlobalWorklist().compileLater(codeBlock, loopOSREntryBytecodeIndex);</span>
          return codeBlock-&gt;jitType() == JITType::BaselineJIT;
      }
      default:
          dataLog(&quot;Unexpected code block in LLInt: &quot;, *codeBlock, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
          return false;
      }
  }
  
<span class="line-modified">! static SlowPathReturnType entryOSR(CodeBlock* codeBlock, const char *name, EntryKind kind)</span>
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         *codeBlock, &quot;: Entered &quot;, name, &quot; with executeCounter = &quot;,</span>
<span class="line-modified">!         codeBlock-&gt;llintExecuteCounter());</span>
  
      if (!shouldJIT(codeBlock)) {
          codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified">!         LLINT_RETURN_TWO(nullptr, nullptr);</span>
      }
<span class="line-modified">!     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-modified">!     if (!jitCompileAndSetHeuristics(vm, codeBlock))</span>
<span class="line-added">+         LLINT_RETURN_TWO(nullptr, nullptr);</span>
  
      CODEBLOCK_LOG_EVENT(codeBlock, &quot;OSR entry&quot;, (&quot;in prologue&quot;));
  
      if (kind == Prologue)
<span class="line-modified">!         LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;executableAddress(), nullptr);</span>
      ASSERT(kind == ArityCheck);
<span class="line-modified">!     LLINT_RETURN_TWO(codeBlock-&gt;jitCode()-&gt;addressForCall(MustCheckArity).executableAddress(), nullptr);</span>
  }
  #else // ENABLE(JIT)
<span class="line-modified">! static SlowPathReturnType entryOSR(CodeBlock* codeBlock, const char*, EntryKind)</span>
  {
      codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-modified">!     LLINT_RETURN_TWO(nullptr, nullptr);</span>
  }
  #endif // ENABLE(JIT)
  
  LLINT_SLOW_PATH_DECL(entry_osr)
  {
<span class="line-modified">!     UNUSED_PARAM(pc);</span>
<span class="line-added">+     return entryOSR(callFrame-&gt;codeBlock(), &quot;entry_osr&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_call)
  {
<span class="line-modified">!     UNUSED_PARAM(pc);</span>
<span class="line-added">+     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct)
  {
<span class="line-modified">!     UNUSED_PARAM(pc);</span>
<span class="line-added">+     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct&quot;, Prologue);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_call_arityCheck)
  {
<span class="line-modified">!     UNUSED_PARAM(pc);</span>
<span class="line-added">+     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForCall(), &quot;entry_osr_function_for_call_arityCheck&quot;, ArityCheck);</span>
  }
  
  LLINT_SLOW_PATH_DECL(entry_osr_function_for_construct_arityCheck)
  {
<span class="line-modified">!     UNUSED_PARAM(pc);</span>
<span class="line-added">+     return entryOSR(jsCast&lt;JSFunction*&gt;(callFrame-&gt;jsCallee())-&gt;jsExecutable()-&gt;codeBlockForConstruct(), &quot;entry_osr_function_for_construct_arityCheck&quot;, ArityCheck);</span>
  }
  
  LLINT_SLOW_PATH_DECL(loop_osr)
  {
      LLINT_BEGIN_NO_SET_PC();
      UNUSED_PARAM(throwScope);
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
  
  #if ENABLE(JIT)
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
              *codeBlock, &quot;: Entered loop_osr with executeCounter = &quot;,
<span class="line-modified">!             codeBlock-&gt;llintExecuteCounter());</span>
  
<span class="line-modified">!     auto loopOSREntryBytecodeIndex = BytecodeIndex(codeBlock-&gt;bytecodeOffset(pc));</span>
  
      if (!shouldJIT(codeBlock)) {
          codeBlock-&gt;dontJITAnytimeSoon();
          LLINT_RETURN_TWO(0, 0);
      }
  
<span class="line-modified">!     if (!jitCompileAndSetHeuristics(vm, codeBlock, loopOSREntryBytecodeIndex))</span>
          LLINT_RETURN_TWO(0, 0);
  
<span class="line-modified">!     CODEBLOCK_LOG_EVENT(codeBlock, &quot;osrEntry&quot;, (&quot;at &quot;, loopOSREntryBytecodeIndex));</span>
  
      ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);
  
      const JITCodeMap&amp; codeMap = codeBlock-&gt;jitCodeMap();
<span class="line-modified">!     CodeLocationLabel&lt;JSEntryPtrTag&gt; codeLocation = codeMap.find(loopOSREntryBytecodeIndex);</span>
      ASSERT(codeLocation);
  
      void* jumpTarget = codeLocation.executableAddress();
      ASSERT(jumpTarget);
  
<span class="line-modified">!     LLINT_RETURN_TWO(jumpTarget, callFrame-&gt;topOfFrame());</span>
  #else // ENABLE(JIT)
      UNUSED_PARAM(pc);
      codeBlock-&gt;dontJITAnytimeSoon();
      LLINT_RETURN_TWO(0, 0);
  #endif // ENABLE(JIT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,21 ***</span>
  
  LLINT_SLOW_PATH_DECL(replace)
  {
      LLINT_BEGIN_NO_SET_PC();
      UNUSED_PARAM(throwScope);
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
  #if ENABLE(JIT)
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-modified">!             *codeBlock, &quot;: Entered replace with executeCounter = &quot;,</span>
<span class="line-removed">-             codeBlock-&gt;llintExecuteCounter(), &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      if (shouldJIT(codeBlock))
<span class="line-modified">!         jitCompileAndSetHeuristics(codeBlock, exec);</span>
      else
          codeBlock-&gt;dontJITAnytimeSoon();
      LLINT_END_IMPL();
  #else // ENABLE(JIT)
      codeBlock-&gt;dontJITAnytimeSoon();
<span class="line-new-header">--- 503,19 ---</span>
  
  LLINT_SLOW_PATH_DECL(replace)
  {
      LLINT_BEGIN_NO_SET_PC();
      UNUSED_PARAM(throwScope);
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
  
  #if ENABLE(JIT)
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         *codeBlock, &quot;: Entered replace with executeCounter = &quot;,</span>
<span class="line-modified">!         codeBlock-&gt;llintExecuteCounter());</span>
  
      if (shouldJIT(codeBlock))
<span class="line-modified">!         jitCompileAndSetHeuristics(vm, codeBlock);</span>
      else
          codeBlock-&gt;dontJITAnytimeSoon();
      LLINT_END_IMPL();
  #else // ENABLE(JIT)
      codeBlock-&gt;dontJITAnytimeSoon();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,22 ***</span>
  #endif // ENABLE(JIT)
  }
  
  LLINT_SLOW_PATH_DECL(stack_check)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     // It&#39;s ok to create the NativeCallFrameTracer here before we</span>
      // convertToStackOverflowFrame() because this function is always called
      // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified">!     NativeCallFrameTracer tracer(vm, exec);</span>
  
      LLINT_SET_PC_FOR_STUBS();
  
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     slowPathLogF(&quot;Checking stack height with exec = %p.\n&quot;, exec);</span>
      slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
      if (codeBlock) {
          slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
          slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
      }
<span class="line-new-header">--- 523,23 ---</span>
  #endif // ENABLE(JIT)
  }
  
  LLINT_SLOW_PATH_DECL(stack_check)
  {
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-added">+     VM&amp; vm = codeBlock-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     // It&#39;s ok to create the SlowPathFrameTracer here before we</span>
      // convertToStackOverflowFrame() because this function is always called
      // after the frame has been propulated with a proper CodeBlock and callee.
<span class="line-modified">!     SlowPathFrameTracer tracer(vm, callFrame);</span>
  
      LLINT_SET_PC_FOR_STUBS();
  
<span class="line-modified">!     slowPathLogF(&quot;Checking stack height with callFrame = %p.\n&quot;, callFrame);</span>
      slowPathLog(&quot;CodeBlock = &quot;, codeBlock, &quot;\n&quot;);
      if (codeBlock) {
          slowPathLogF(&quot;Num callee registers = %u.\n&quot;, codeBlock-&gt;numCalleeLocals());
          slowPathLogF(&quot;Num vars = %u.\n&quot;, codeBlock-&gt;numVars());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,114 ***</span>
  
      // For JIT enabled builds which uses the C stack, the stack is not growable.
      // Hence, if we get here, then we know a stack overflow is imminent. So, just
      // throw the StackOverflowError unconditionally.
  #if ENABLE(C_LOOP)
<span class="line-modified">!     Register* topOfFrame = exec-&gt;topOfFrame();</span>
<span class="line-modified">!     if (LIKELY(topOfFrame &lt; reinterpret_cast&lt;Register*&gt;(exec))) {</span>
          ASSERT(!vm.interpreter-&gt;cloopStack().containsAddress(topOfFrame));
          if (LIKELY(vm.ensureStackCapacityFor(topOfFrame)))
              LLINT_RETURN_TWO(pc, 0);
      }
  #endif
  
<span class="line-modified">!     exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     throwStackOverflowError(exec, throwScope);</span>
<span class="line-modified">!     pc = returnToThrow(exec);</span>
<span class="line-modified">!     LLINT_RETURN_TWO(pc, exec);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_object)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewObject&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     LLINT_RETURN(constructEmptyObject(exec, metadata.m_objectAllocationProfile.structure()));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_array)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArray&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     LLINT_RETURN(constructArrayNegativeIndexed(exec, &amp;metadata.m_arrayAllocationProfile, bitwise_cast&lt;JSValue*&gt;(&amp;exec-&gt;uncheckedR(bytecode.m_argv)), bytecode.m_argc));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_array_with_size)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayWithSize&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     LLINT_RETURN(constructArrayWithSizeQuirk(exec, &amp;metadata.m_arrayAllocationProfile, exec-&gt;lexicalGlobalObject(), getOperand(exec, bytecode.m_length)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_regexp)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified">!     RegExp* regExp = jsCast&lt;RegExp*&gt;(getOperand(exec, bytecode.m_regexp));</span>
      ASSERT(regExp-&gt;isValid());
<span class="line-modified">!     LLINT_RETURN(RegExpObject::create(vm, exec-&gt;lexicalGlobalObject()-&gt;regExpStructure(), regExp));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_instanceof)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified">!     JSValue proto = getOperand(exec, bytecode.m_prototype);</span>
<span class="line-modified">!     LLINT_RETURN(jsBoolean(JSObject::defaultHasInstance(exec, value, proto)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_instanceof_custom)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified">!     JSValue constructor = getOperand(exec, bytecode.m_constructor);</span>
<span class="line-modified">!     JSValue hasInstanceValue = getOperand(exec, bytecode.m_hasInstanceValue);</span>
  
      ASSERT(constructor.isObject());
<span class="line-modified">!     ASSERT(hasInstanceValue != exec-&gt;lexicalGlobalObject()-&gt;functionProtoHasInstanceSymbolFunction() || !constructor.getObject()-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
  
<span class="line-modified">!     JSValue result = jsBoolean(constructor.getObject()-&gt;hasInstance(exec, value, hasInstanceValue));</span>
      LLINT_RETURN(result);
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_try_get_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpTryGetById&gt;();
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::VMInquiry);
  
<span class="line-modified">!     baseValue.getPropertySlot(exec, ident, slot);</span>
      JSValue result = slot.getPureResult();
  
      LLINT_RETURN_PROFILED(result);
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_id_direct)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::GetOwnProperty);
  
<span class="line-modified">!     bool found = baseValue.getOwnPropertySlot(exec, ident, slot);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     JSValue result = found ? slot.getValue(exec, ident) : jsUndefined();</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; slot.isCacheable()) {</span>
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(exec);</span>
          {
              StructureID oldStructureID = metadata.m_structureID;
              if (oldStructureID) {
                  Structure* a = vm.heap.structureIDTable().get(oldStructureID);
                  Structure* b = baseValue.asCell()-&gt;structure(vm);
<span class="line-new-header">--- 554,112 ---</span>
  
      // For JIT enabled builds which uses the C stack, the stack is not growable.
      // Hence, if we get here, then we know a stack overflow is imminent. So, just
      // throw the StackOverflowError unconditionally.
  #if ENABLE(C_LOOP)
<span class="line-modified">!     Register* topOfFrame = callFrame-&gt;topOfFrame();</span>
<span class="line-modified">!     if (LIKELY(topOfFrame &lt; reinterpret_cast&lt;Register*&gt;(callFrame))) {</span>
          ASSERT(!vm.interpreter-&gt;cloopStack().containsAddress(topOfFrame));
          if (LIKELY(vm.ensureStackCapacityFor(topOfFrame)))
              LLINT_RETURN_TWO(pc, 0);
      }
  #endif
  
<span class="line-modified">!     callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
      ErrorHandlingScope errorScope(vm);
<span class="line-modified">!     throwStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified">!     pc = returnToThrow(vm);</span>
<span class="line-modified">!     LLINT_RETURN_TWO(pc, callFrame);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_object)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewObject&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     LLINT_RETURN(constructEmptyObject(vm, metadata.m_objectAllocationProfile.structure()));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_array)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArray&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     LLINT_RETURN(constructArrayNegativeIndexed(globalObject, &amp;metadata.m_arrayAllocationProfile, bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;uncheckedR(bytecode.m_argv)), bytecode.m_argc));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_array_with_size)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewArrayWithSize&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     LLINT_RETURN(constructArrayWithSizeQuirk(globalObject, &amp;metadata.m_arrayAllocationProfile, getOperand(callFrame, bytecode.m_length)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_regexp)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewRegexp&gt;();
<span class="line-modified">!     RegExp* regExp = jsCast&lt;RegExp*&gt;(getOperand(callFrame, bytecode.m_regexp));</span>
      ASSERT(regExp-&gt;isValid());
<span class="line-modified">!     LLINT_RETURN(RegExpObject::create(vm, globalObject-&gt;regExpStructure(), regExp));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_instanceof)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpInstanceof&gt;();
<span class="line-modified">!     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified">!     JSValue proto = getOperand(callFrame, bytecode.m_prototype);</span>
<span class="line-modified">!     LLINT_RETURN(jsBoolean(JSObject::defaultHasInstance(globalObject, value, proto)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_instanceof_custom)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpInstanceofCustom&gt;();
<span class="line-modified">!     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified">!     JSValue constructor = getOperand(callFrame, bytecode.m_constructor);</span>
<span class="line-modified">!     JSValue hasInstanceValue = getOperand(callFrame, bytecode.m_hasInstanceValue);</span>
  
      ASSERT(constructor.isObject());
<span class="line-modified">!     ASSERT(hasInstanceValue != globalObject-&gt;functionProtoHasInstanceSymbolFunction() || !constructor.getObject()-&gt;structure(vm)-&gt;typeInfo().implementsDefaultHasInstance());</span>
  
<span class="line-modified">!     JSValue result = jsBoolean(constructor.getObject()-&gt;hasInstance(globalObject, value, hasInstanceValue));</span>
      LLINT_RETURN(result);
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_try_get_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpTryGetById&gt;();
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::VMInquiry);
  
<span class="line-modified">!     baseValue.getPropertySlot(globalObject, ident, slot);</span>
      JSValue result = slot.getPureResult();
  
      LLINT_RETURN_PROFILED(result);
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_id_direct)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByIdDirect&gt;();
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::GetOwnProperty);
  
<span class="line-modified">!     bool found = baseValue.getOwnPropertySlot(globalObject, ident, slot);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     JSValue result = found ? slot.getValue(globalObject, ident) : jsUndefined();</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; slot.isCacheable() &amp;&amp; !slot.isUnset()) {</span>
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
          {
              StructureID oldStructureID = metadata.m_structureID;
              if (oldStructureID) {
                  Structure* a = vm.heap.structureIDTable().get(oldStructureID);
                  Structure* b = baseValue.asCell()-&gt;structure(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 690,13 ***</span>
  
      LLINT_RETURN_PROFILED(result);
  }
  
  
<span class="line-modified">! static void setupGetByIdPrototypeCache(ExecState* exec, VM&amp; vm, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
  {
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      Structure* structure = baseCell-&gt;structure(vm);
  
      if (structure-&gt;typeInfo().prohibitsPropertyCaching())
          return;
  
<span class="line-new-header">--- 691,12 ---</span>
  
      LLINT_RETURN_PROFILED(result);
  }
  
  
<span class="line-modified">! static void setupGetByIdPrototypeCache(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Instruction* pc, OpGetById::Metadata&amp; metadata, JSCell* baseCell, PropertySlot&amp; slot, const Identifier&amp; ident)</span>
  {
      Structure* structure = baseCell-&gt;structure(vm);
  
      if (structure-&gt;typeInfo().prohibitsPropertyCaching())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,15 ***</span>
          if (structure-&gt;hasBeenFlattenedBefore())
              return;
          structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
      }
  
      ObjectPropertyConditionSet conditions;
      if (slot.isUnset())
<span class="line-modified">!         conditions = generateConditionsForPropertyMiss(vm, codeBlock, exec, structure, ident.impl());</span>
      else
<span class="line-modified">!         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, exec, structure, slot.slotBase(), ident.impl());</span>
  
      if (!conditions.isValid())
          return;
  
      unsigned bytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
<span class="line-new-header">--- 707,17 ---</span>
          if (structure-&gt;hasBeenFlattenedBefore())
              return;
          structure-&gt;flattenDictionaryStructure(vm, jsCast&lt;JSObject*&gt;(baseCell));
      }
  
<span class="line-added">+     prepareChainForCaching(globalObject, baseCell, slot);</span>
<span class="line-added">+ </span>
      ObjectPropertyConditionSet conditions;
      if (slot.isUnset())
<span class="line-modified">!         conditions = generateConditionsForPropertyMiss(vm, codeBlock, globalObject, structure, ident.impl());</span>
      else
<span class="line-modified">!         conditions = generateConditionsForPrototypePropertyHit(vm, codeBlock, globalObject, structure, slot.slotBase(), ident.impl());</span>
  
      if (!conditions.isValid())
          return;
  
      unsigned bytecodeOffset = codeBlock-&gt;bytecodeOffset(pc);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 751,23 ***</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
  
<span class="line-modified">!     JSValue result = baseValue.get(exec, ident, slot);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     exec-&gt;uncheckedR(bytecode.m_dst) = result;</span>
  
      if (!LLINT_ALWAYS_ACCESS_SLOW
          &amp;&amp; baseValue.isCell()
<span class="line-modified">!         &amp;&amp; slot.isCacheable()) {</span>
          {
              StructureID oldStructureID;
              switch (metadata.m_modeMetadata.mode) {
              case GetByIdMode::Default:
                  oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
<span class="line-new-header">--- 753,23 ---</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
      PropertySlot slot(baseValue, PropertySlot::PropertySlot::InternalMethodType::Get);
  
<span class="line-modified">!     JSValue result = baseValue.get(globalObject, ident, slot);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     callFrame-&gt;uncheckedR(bytecode.m_dst) = result;</span>
  
      if (!LLINT_ALWAYS_ACCESS_SLOW
          &amp;&amp; baseValue.isCell()
<span class="line-modified">!         &amp;&amp; slot.isCacheable()</span>
<span class="line-added">+         &amp;&amp; !slot.isUnset()) {</span>
          {
              StructureID oldStructureID;
              switch (metadata.m_modeMetadata.mode) {
              case GetByIdMode::Default:
                  oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,15 ***</span>
              if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
                  metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
                  metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
                  vm.heap.writeBarrier(codeBlock);
              }
<span class="line-modified">!         } else if (UNLIKELY(metadata.m_modeMetadata.hitCountForLLIntCaching &amp;&amp; (slot.isValue() || slot.isUnset()))) {</span>
              ASSERT(slot.slotBase() != baseValue);
  
              if (!(--metadata.m_modeMetadata.hitCountForLLIntCaching))
<span class="line-modified">!                 setupGetByIdPrototypeCache(exec, vm, pc, metadata, baseCell, slot, ident);</span>
          }
      } else if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; isJSArray(baseValue) &amp;&amp; ident == vm.propertyNames-&gt;length) {
          {
              ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
              metadata.m_modeMetadata.setArrayLengthMode();
<span class="line-new-header">--- 807,15 ---</span>
              if (structure-&gt;propertyAccessesAreCacheable() &amp;&amp; !structure-&gt;needImpurePropertyWatchpoint()) {
                  metadata.m_modeMetadata.defaultMode.structureID = structure-&gt;id();
                  metadata.m_modeMetadata.defaultMode.cachedOffset = slot.cachedOffset();
                  vm.heap.writeBarrier(codeBlock);
              }
<span class="line-modified">!         } else if (UNLIKELY(metadata.m_modeMetadata.hitCountForLLIntCaching &amp;&amp; slot.isValue())) {</span>
              ASSERT(slot.slotBase() != baseValue);
  
              if (!(--metadata.m_modeMetadata.hitCountForLLIntCaching))
<span class="line-modified">!                 setupGetByIdPrototypeCache(globalObject, vm, codeBlock, pc, metadata, baseCell, slot, ident);</span>
          }
      } else if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; isJSArray(baseValue) &amp;&amp; ident == vm.propertyNames-&gt;length) {
          {
              ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
              metadata.m_modeMetadata.setArrayLengthMode();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,26 ***</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
  
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
      PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
      if (bytecode.m_flags &amp; PutByIdIsDirect)
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, exec, asObject(baseValue), ident, getOperand(exec, bytecode.m_value), slot);</span>
      else
<span class="line-modified">!         baseValue.putInline(exec, ident, getOperand(exec, bytecode.m_value), slot);</span>
      LLINT_CHECK_EXCEPTION();
  
      if (!LLINT_ALWAYS_ACCESS_SLOW
          &amp;&amp; baseValue.isCell()
<span class="line-modified">!         &amp;&amp; slot.isCacheablePut()) {</span>
<span class="line-modified">! </span>
          {
              StructureID oldStructureID = metadata.m_oldStructureID;
              if (oldStructureID) {
                  Structure* a = vm.heap.structureIDTable().get(oldStructureID);
                  Structure* b = baseValue.asCell()-&gt;structure(vm);
<span class="line-new-header">--- 830,27 ---</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
  
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
      PutPropertySlot slot(baseValue, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-added">+ </span>
<span class="line-added">+     Structure* oldStructure = baseValue.isCell() ? baseValue.asCell()-&gt;structure(vm) : nullptr;</span>
      if (bytecode.m_flags &amp; PutByIdIsDirect)
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, globalObject, asObject(baseValue), ident, getOperand(callFrame, bytecode.m_value), slot);</span>
      else
<span class="line-modified">!         baseValue.putInline(globalObject, ident, getOperand(callFrame, bytecode.m_value), slot);</span>
      LLINT_CHECK_EXCEPTION();
  
      if (!LLINT_ALWAYS_ACCESS_SLOW
          &amp;&amp; baseValue.isCell()
<span class="line-modified">!         &amp;&amp; slot.isCacheablePut()</span>
<span class="line-modified">!         &amp;&amp; oldStructure-&gt;propertyAccessesAreCacheable()) {</span>
          {
              StructureID oldStructureID = metadata.m_oldStructureID;
              if (oldStructureID) {
                  Structure* a = vm.heap.structureIDTable().get(oldStructureID);
                  Structure* b = baseValue.asCell()-&gt;structure(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,38 ***</span>
          metadata.m_offset = 0;
          metadata.m_newStructureID = 0;
          metadata.m_structureChain.clear();
  
          JSCell* baseCell = baseValue.asCell();
<span class="line-modified">!         Structure* structure = baseCell-&gt;structure(vm);</span>
  
<span class="line-modified">!         if (!structure-&gt;isUncacheableDictionary() &amp;&amp; !structure-&gt;typeInfo().prohibitsPropertyCaching() &amp;&amp; baseCell == slot.base()) {</span>
              if (slot.type() == PutPropertySlot::NewProperty) {
                  GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<span class="line-modified">!                 if (!structure-&gt;isDictionary() &amp;&amp; structure-&gt;previousID()-&gt;outOfLineCapacity() == structure-&gt;outOfLineCapacity()) {</span>
<span class="line-modified">!                     ASSERT(structure-&gt;previousID()-&gt;transitionWatchpointSetHasBeenInvalidated());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                     bool sawPolyProto = false;</span>
<span class="line-modified">!                     auto result = normalizePrototypeChain(exec, baseCell, sawPolyProto);</span>
<span class="line-modified">!                     if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {</span>
<span class="line-modified">!                         ASSERT(structure-&gt;previousID()-&gt;isObject());</span>
<span class="line-modified">!                         metadata.m_oldStructureID = structure-&gt;previousID()-&gt;id();</span>
<span class="line-modified">!                         metadata.m_offset = slot.cachedOffset();</span>
<span class="line-modified">!                         metadata.m_newStructureID = structure-&gt;id();</span>
<span class="line-modified">!                         if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {</span>
<span class="line-modified">!                             StructureChain* chain = structure-&gt;prototypeChain(exec, asObject(baseCell));</span>
<span class="line-modified">!                             ASSERT(chain);</span>
<span class="line-modified">!                             metadata.m_structureChain.set(vm, codeBlock, chain);</span>
                          }
<span class="line-removed">-                         vm.heap.writeBarrier(codeBlock);</span>
                      }
                  }
              } else {
<span class="line-modified">!                 structure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
                  {
                      ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">!                     metadata.m_oldStructureID = structure-&gt;id();</span>
                      metadata.m_offset = slot.cachedOffset();
                  }
                  vm.heap.writeBarrier(codeBlock);
              }
          }
<span class="line-new-header">--- 869,48 ---</span>
          metadata.m_offset = 0;
          metadata.m_newStructureID = 0;
          metadata.m_structureChain.clear();
  
          JSCell* baseCell = baseValue.asCell();
<span class="line-modified">!         Structure* newStructure = baseCell-&gt;structure(vm);</span>
  
<span class="line-modified">!         if (newStructure-&gt;propertyAccessesAreCacheable() &amp;&amp; baseCell == slot.base()) {</span>
              if (slot.type() == PutPropertySlot::NewProperty) {
                  GCSafeConcurrentJSLocker locker(codeBlock-&gt;m_lock, vm.heap);
<span class="line-modified">!                 if (!newStructure-&gt;isDictionary() &amp;&amp; newStructure-&gt;previousID()-&gt;outOfLineCapacity() == newStructure-&gt;outOfLineCapacity()) {</span>
<span class="line-modified">!                     ASSERT(oldStructure == newStructure-&gt;previousID());</span>
<span class="line-modified">!                     if (oldStructure == newStructure-&gt;previousID()) {</span>
<span class="line-modified">!                         ASSERT(oldStructure-&gt;transitionWatchpointSetHasBeenInvalidated());</span>
<span class="line-modified">! </span>
<span class="line-modified">!                         bool sawPolyProto = false;</span>
<span class="line-modified">!                         auto result = normalizePrototypeChain(globalObject, baseCell, sawPolyProto);</span>
<span class="line-modified">!                         if (result != InvalidPrototypeChain &amp;&amp; !sawPolyProto) {</span>
<span class="line-modified">!                             ASSERT(oldStructure-&gt;isObject());</span>
<span class="line-modified">!                             metadata.m_oldStructureID = oldStructure-&gt;id();</span>
<span class="line-modified">!                             metadata.m_offset = slot.cachedOffset();</span>
<span class="line-modified">!                             metadata.m_newStructureID = newStructure-&gt;id();</span>
<span class="line-modified">!                             if (!(bytecode.m_flags &amp; PutByIdIsDirect)) {</span>
<span class="line-modified">!                                 StructureChain* chain = newStructure-&gt;prototypeChain(globalObject, asObject(baseCell));</span>
<span class="line-added">+                                 ASSERT(chain);</span>
<span class="line-added">+                                 metadata.m_structureChain.set(vm, codeBlock, chain);</span>
<span class="line-added">+                             }</span>
<span class="line-added">+                             vm.heap.writeBarrier(codeBlock);</span>
                          }
                      }
                  }
              } else {
<span class="line-modified">!                 // This assert helps catch bugs if we accidentally forget to disable caching</span>
<span class="line-added">+                 // when we transition then store to an existing property. This is common among</span>
<span class="line-added">+                 // paths that reify lazy properties. If we reify a lazy property and forget</span>
<span class="line-added">+                 // to disable caching, we may come down this path. The Replace IC does not</span>
<span class="line-added">+                 // know how to model these types of structure transitions (or any structure</span>
<span class="line-added">+                 // transition for that matter).</span>
<span class="line-added">+                 RELEASE_ASSERT(newStructure == oldStructure);</span>
<span class="line-added">+                 newStructure-&gt;didCachePropertyReplacement(vm, slot.cachedOffset());</span>
                  {
                      ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
<span class="line-modified">!                     metadata.m_oldStructureID = newStructure-&gt;id();</span>
                      metadata.m_offset = slot.cachedOffset();
                  }
                  vm.heap.writeBarrier(codeBlock);
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,47 ***</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSObject* baseObject = getOperand(exec, bytecode.m_base).toObject(exec);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, codeBlock-&gt;identifier(bytecode.m_property));</span>
      LLINT_CHECK_EXCEPTION();
      if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
<span class="line-modified">!         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
      LLINT_RETURN(jsBoolean(couldDelete));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, ExecState* exec, OpGetByVal bytecode)</span>
  {
<span class="line-removed">-     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-removed">-     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return result;
              }
          }
      }
  
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(exec);</span>
          ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
  
          if (isJSString(baseValue)) {
              if (asString(baseValue)-&gt;canGetIndex(i)) {
                  scope.release();
<span class="line-modified">!                 return asString(baseValue)-&gt;getIndex(exec, i);</span>
              }
              arrayProfile-&gt;setOutOfBounds();
          } else if (baseValue.isObject()) {
              JSObject* object = asObject(baseValue);
              if (object-&gt;canGetIndexQuickly(i))
<span class="line-new-header">--- 921,44 ---</span>
  
  LLINT_SLOW_PATH_DECL(slow_path_del_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     JSObject* baseObject = getOperand(callFrame, bytecode.m_base).toObject(globalObject);</span>
      LLINT_CHECK_EXCEPTION();
<span class="line-modified">!     bool couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, codeBlock-&gt;identifier(bytecode.m_property));</span>
      LLINT_CHECK_EXCEPTION();
      if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())
<span class="line-modified">!         LLINT_THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
      LLINT_RETURN(jsBoolean(couldDelete));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSValue getByVal(VM&amp; vm, JSGlobalObject* globalObject, CodeBlock* codeBlock, JSValue baseValue, JSValue subscript, OpGetByVal bytecode)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
          Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
          if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">!             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
              RETURN_IF_EXCEPTION(scope, JSValue());
              if (existingAtomString) {
                  if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
                      return result;
              }
          }
      }
  
      if (subscript.isUInt32()) {
          uint32_t i = subscript.asUInt32();
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
          ArrayProfile* arrayProfile = &amp;metadata.m_arrayProfile;
  
          if (isJSString(baseValue)) {
              if (asString(baseValue)-&gt;canGetIndex(i)) {
                  scope.release();
<span class="line-modified">!                 return asString(baseValue)-&gt;getIndex(globalObject, i);</span>
              }
              arrayProfile-&gt;setOutOfBounds();
          } else if (baseValue.isObject()) {
              JSObject* object = asObject(baseValue);
              if (object-&gt;canGetIndexQuickly(i))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 966,622 ***</span>
              if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i))
                  arrayProfile-&gt;setOutOfBounds();
          }
  
          scope.release();
<span class="line-modified">!         return baseValue.get(exec, i);</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      scope.release();
<span class="line-modified">!     return baseValue.get(exec, property);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
<span class="line-modified">!     LLINT_RETURN_PROFILED(getByVal(vm, exec, bytecode));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified">!     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
<span class="line-modified">!     JSValue value = getOperand(exec, bytecode.m_value);</span>
<span class="line-modified">!     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
  
      if (LIKELY(subscript.isUInt32())) {
          uint32_t i = subscript.asUInt32();
          if (baseValue.isObject()) {
              JSObject* object = asObject(baseValue);
              if (object-&gt;canSetIndexQuickly(i, value))
                  object-&gt;setIndexQuickly(vm, i, value);
              else
<span class="line-modified">!                 object-&gt;methodTable(vm)-&gt;putByIndex(object, exec, i, value, isStrictMode);</span>
              LLINT_END();
          }
<span class="line-modified">!         baseValue.putByIndex(exec, i, value, isStrictMode);</span>
          LLINT_END();
      }
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      LLINT_CHECK_EXCEPTION();
      PutPropertySlot slot(baseValue, isStrictMode);
<span class="line-modified">!     baseValue.put(exec, property, value, slot);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutByValDirect&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified">!     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
<span class="line-modified">!     JSValue value = getOperand(exec, bytecode.m_value);</span>
      RELEASE_ASSERT(baseValue.isObject());
      JSObject* baseObject = asObject(baseValue);
<span class="line-modified">!     bool isStrictMode = exec-&gt;codeBlock()-&gt;isStrictMode();</span>
      if (LIKELY(subscript.isUInt32())) {
          // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
          ASSERT(isIndex(subscript.asUInt32()));
<span class="line-modified">!         baseObject-&gt;putDirectIndex(exec, subscript.asUInt32(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
          LLINT_END();
      }
  
      if (subscript.isDouble()) {
          double subscriptAsDouble = subscript.asDouble();
          uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
          if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
<span class="line-modified">!             baseObject-&gt;putDirectIndex(exec, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              LLINT_END();
          }
      }
  
      // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      if (UNLIKELY(throwScope.exception()))
          LLINT_END();
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(property))
<span class="line-modified">!         baseObject-&gt;putDirectIndex(exec, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
      else {
          PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, exec, baseObject, property, value, slot);</span>
      }
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_del_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(exec, bytecode.m_base);</span>
<span class="line-modified">!     JSObject* baseObject = baseValue.toObject(exec);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
  
      bool couldDelete;
  
      uint32_t i;
      if (subscript.getUInt32(i))
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);</span>
      else {
          LLINT_CHECK_EXCEPTION();
<span class="line-modified">!         auto property = subscript.toPropertyKey(exec);</span>
          LLINT_CHECK_EXCEPTION();
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);</span>
      }
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified">!         LLINT_THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
  
      LLINT_RETURN(jsBoolean(couldDelete));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
      ASSERT(getter.isObject());
  
<span class="line-modified">!     baseObj-&gt;putGetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(getter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
      ASSERT(setter.isObject());
  
<span class="line-modified">!     baseObj-&gt;putSetter(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), asObject(setter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_setter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObject = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(exec, bytecode.m_getter);</span>
<span class="line-modified">!     JSValue setter = getNonConstantOperand(exec, bytecode.m_setter);</span>
      ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">!     GetterSetter* accessor = GetterSetter::create(vm, exec-&gt;lexicalGlobalObject(), getter, setter);</span>
  
<span class="line-modified">!     CommonSlowPaths::putDirectAccessorWithReify(vm, exec, baseObject, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property), accessor, bytecode.m_attributes);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
<span class="line-modified">!     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
      ASSERT(getter.isObject());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     baseObj-&gt;putGetter(exec, property, asObject(getter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(exec, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(exec, bytecode.m_base));</span>
<span class="line-modified">!     JSValue subscript = getOperand(exec, bytecode.m_property);</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue setter = getNonConstantOperand(exec, bytecode.m_accessor);</span>
      ASSERT(setter.isObject());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(exec);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     baseObj-&gt;putSetter(exec, property, asObject(setter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jtrue)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">!     LLINT_BRANCH(getOperand(exec, bytecode.m_condition).toBoolean(exec));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jfalse)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">!     LLINT_BRANCH(!getOperand(exec, bytecode.m_condition).toBoolean(exec));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jless)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJless&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnless)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnless&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLess&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jgreater)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJgreater&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jngreater)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJngreater&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLess&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jlesseq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJlesseq&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnlesseq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnlesseq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLessEq&lt;true&gt;(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jgreatereq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJgreatereq&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jngreatereq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJngreatereq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLessEq&lt;false&gt;(exec, getOperand(exec, bytecode.m_rhs), getOperand(exec, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jeq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJeq&gt;();
<span class="line-modified">!     LLINT_BRANCH(JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jneq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJneq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!JSValue::equal(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jstricteq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJstricteq&gt;();
<span class="line-modified">!     LLINT_BRANCH(JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnstricteq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnstricteq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!JSValue::strictEqual(exec, getOperand(exec, bytecode.m_lhs), getOperand(exec, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_imm)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchImm&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
      ASSERT(scrutinee.isDouble());
      double value = scrutinee.asDouble();
      int32_t intValue = static_cast&lt;int32_t&gt;(value);
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">!     if (value == intValue) {</span>
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
          JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue(intValue, defaultOffset));
<span class="line-modified">!     } else</span>
          JUMP_TO(defaultOffset);
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_char)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchChar&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
      ASSERT(scrutinee.isString());
      JSString* string = asString(scrutinee);
      ASSERT(string-&gt;length() == 1);
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">!     StringImpl* impl = string-&gt;value(exec).impl();</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_string)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(exec, bytecode.m_scrutinee);</span>
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
      if (!scrutinee.isString())
          JUMP_TO(defaultOffset);
      else {
<span class="line-modified">!         StringImpl* scrutineeStringImpl = asString(scrutinee)-&gt;value(exec).impl();</span>
  
          LLINT_CHECK_EXCEPTION();
  
<span class="line-removed">-         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">- </span>
          JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(scrutineeStringImpl, defaultOffset));
      }
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating function!\n&quot;);
      LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating function!\n&quot;);
      LLINT_RETURN(JSGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewAsyncFunc&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating async function!\n&quot;);
      LLINT_RETURN(JSAsyncFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFunc&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating async generator function!\n&quot;);
      LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewFuncExp&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_generator_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewGeneratorFuncExp&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSGeneratorFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewAsyncFuncExp&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSAsyncFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFuncExp&gt;();
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_set_function_name)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     JSFunction* func = jsCast&lt;JSFunction*&gt;(getNonConstantOperand(exec, bytecode.m_function));</span>
<span class="line-modified">!     JSValue name = getOperand(exec, bytecode.m_name);</span>
<span class="line-modified">!     func-&gt;setFunctionName(exec, name);</span>
      LLINT_END();
  }
  
<span class="line-modified">! static SlowPathReturnType handleHostCall(ExecState* execCallee, JSValue callee, CodeSpecializationKind kind)</span>
  {
      slowPathLog(&quot;Performing host call.\n&quot;);
  
<span class="line-modified">!     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     execCallee-&gt;setCodeBlock(0);</span>
<span class="line-modified">!     execCallee-&gt;clearReturnPC();</span>
  
      if (kind == CodeForCall) {
          CallData callData;
          CallType callType = getCallData(vm, callee, callData);
  
          ASSERT(callType != CallType::JS);
  
          if (callType == CallType::Host) {
<span class="line-modified">!             NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified">!             execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">!             vm.hostCallReturnValue = JSValue::decode(callData.native.function(execCallee));</span>
<span class="line-modified">!             LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
          }
  
          slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
  
          ASSERT(callType == CallType::None);
<span class="line-modified">!         LLINT_CALL_THROW(exec, createNotAFunctionError(exec, callee));</span>
      }
  
      ASSERT(kind == CodeForConstruct);
  
      ConstructData constructData;
      ConstructType constructType = getConstructData(vm, callee, constructData);
  
      ASSERT(constructType != ConstructType::JS);
  
      if (constructType == ConstructType::Host) {
<span class="line-modified">!         NativeCallFrameTracer tracer(vm, execCallee);</span>
<span class="line-modified">!         execCallee-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">!         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(execCallee));</span>
<span class="line-modified">!         LLINT_CALL_RETURN(execCallee, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
      }
  
      slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
  
      ASSERT(constructType == ConstructType::None);
<span class="line-modified">!     LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));</span>
  }
  
<span class="line-modified">! inline SlowPathReturnType setUpCall(ExecState* execCallee, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)</span>
  {
<span class="line-modified">!     ExecState* exec = execCallee-&gt;callerFrame();</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, exec-&gt;currentVPC());</span>
  
      JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
      if (!calleeAsFunctionCell) {
          if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
              MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
              ASSERT(!!codePtr);
  
              if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
<span class="line-removed">-                 CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">- </span>
                  ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
                  callLinkInfo-&gt;link(vm, callerCodeBlock, internalFunction, codePtr);
              }
  
              assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">!             LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);</span>
          }
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, handleHostCall(execCallee, calleeAsValue, kind));</span>
      }
      JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
      JSScope* scope = callee-&gt;scopeUnchecked();
      ExecutableBase* executable = callee-&gt;executable();
  
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
<span class="line-modified">!     CodeBlock* codeBlock = 0;</span>
      if (executable-&gt;isHostFunction())
          codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
      else {
          FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
  
          if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
<span class="line-modified">!             LLINT_CALL_THROW(exec, createNotAConstructorError(exec, callee));</span>
  
<span class="line-modified">!         CodeBlock** codeBlockSlot = execCallee-&gt;addressOfCodeBlock();</span>
          Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
          EXCEPTION_ASSERT(throwScope.exception() == error);
          if (UNLIKELY(error))
<span class="line-modified">!             LLINT_CALL_THROW(exec, error);</span>
          codeBlock = *codeBlockSlot;
          ASSERT(codeBlock);
          ArityCheckMode arity;
<span class="line-modified">!         if (execCallee-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
              arity = MustCheckArity;
          else
              arity = ArityCheckNotRequired;
          codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
      }
  
      ASSERT(!!codePtr);
  
      if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
<span class="line-removed">-         CodeBlock* callerCodeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">- </span>
          ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
          callLinkInfo-&gt;link(vm, callerCodeBlock, callee, codePtr);
          if (codeBlock)
<span class="line-modified">!             codeBlock-&gt;linkIncomingCall(exec, callLinkInfo);</span>
      }
  
      assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">!     LLINT_CALL_RETURN(exec, execCallee, codePtr.executableAddress(), JSEntryPtrTag);</span>
  }
  
  template&lt;typename Op&gt;
<span class="line-modified">! inline SlowPathReturnType genericCall(ExecState* exec, Op&amp;&amp; bytecode, CodeSpecializationKind kind)</span>
  {
      // This needs to:
      // - Set up a call frame.
      // - Figure out what to call and compile it if necessary.
      // - If possible, link the call&#39;s inline cache.
      // - Return a tuple of machine code address to call and the new call frame.
  
<span class="line-modified">!     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);</span>
  
<span class="line-modified">!     ExecState* execCallee = exec - bytecode.m_argv;</span>
  
<span class="line-modified">!     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">!     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">!     execCallee-&gt;setCallerFrame(exec);</span>
  
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     return setUpCall(execCallee, kind, calleeAsValue, &amp;metadata.m_callLinkInfo);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpCall&gt;(), CodeForCall));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpTailCall&gt;(), CodeForCall));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_construct)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, genericCall(exec, pc-&gt;as&lt;OpConstruct&gt;(), CodeForConstruct));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_varargs)
  {
      LLINT_BEGIN();
<span class="line-new-header">--- 976,634 ---</span>
              if (!skipMarkingOutOfBounds &amp;&amp; !CommonSlowPaths::canAccessArgumentIndexQuickly(*object, i))
                  arrayProfile-&gt;setOutOfBounds();
          }
  
          scope.release();
<span class="line-modified">!         return baseValue.get(globalObject, i);</span>
      }
  
<span class="line-modified">!     baseValue.requireObjectCoercible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
      scope.release();
<span class="line-modified">!     return baseValue.get(globalObject, property);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetByVal&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-added">+     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (subscript.isString() || subscript.isSymbol()) {</span>
<span class="line-added">+         auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-added">+         if (metadata.m_seenIdentifiers.count() &lt;= Options::getByValICMaxNumberOfIdentifiers()) {</span>
<span class="line-added">+             const UniquedStringImpl* impl = nullptr;</span>
<span class="line-added">+             if (subscript.isSymbol())</span>
<span class="line-added">+                 impl = &amp;jsCast&lt;Symbol*&gt;(subscript)-&gt;privateName().uid();</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 JSString* string = asString(subscript);</span>
<span class="line-added">+                 if (auto* maybeUID = string-&gt;tryGetValueImpl()) {</span>
<span class="line-added">+                     if (maybeUID-&gt;isAtom())</span>
<span class="line-added">+                         impl = static_cast&lt;const UniquedStringImpl*&gt;(maybeUID);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             metadata.m_seenIdentifiers.observe(impl);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     LLINT_RETURN_PROFILED(getByVal(vm, globalObject, codeBlock, baseValue, subscript, bytecode));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_val)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutByVal&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">!     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-modified">!     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
<span class="line-modified">!     bool isStrictMode = codeBlock-&gt;isStrictMode();</span>
  
      if (LIKELY(subscript.isUInt32())) {
          uint32_t i = subscript.asUInt32();
          if (baseValue.isObject()) {
              JSObject* object = asObject(baseValue);
              if (object-&gt;canSetIndexQuickly(i, value))
                  object-&gt;setIndexQuickly(vm, i, value);
              else
<span class="line-modified">!                 object-&gt;methodTable(vm)-&gt;putByIndex(object, globalObject, i, value, isStrictMode);</span>
              LLINT_END();
          }
<span class="line-modified">!         baseValue.putByIndex(globalObject, i, value, isStrictMode);</span>
          LLINT_END();
      }
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      LLINT_CHECK_EXCEPTION();
      PutPropertySlot slot(baseValue, isStrictMode);
<span class="line-modified">!     baseValue.put(globalObject, property, value, slot);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_by_val_direct)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutByValDirect&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">!     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
<span class="line-modified">!     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
      RELEASE_ASSERT(baseValue.isObject());
      JSObject* baseObject = asObject(baseValue);
<span class="line-modified">!     bool isStrictMode = codeBlock-&gt;isStrictMode();</span>
      if (LIKELY(subscript.isUInt32())) {
          // Despite its name, JSValue::isUInt32 will return true only for positive boxed int32_t; all those values are valid array indices.
          ASSERT(isIndex(subscript.asUInt32()));
<span class="line-modified">!         baseObject-&gt;putDirectIndex(globalObject, subscript.asUInt32(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
          LLINT_END();
      }
  
      if (subscript.isDouble()) {
          double subscriptAsDouble = subscript.asDouble();
          uint32_t subscriptAsUInt32 = static_cast&lt;uint32_t&gt;(subscriptAsDouble);
          if (subscriptAsDouble == subscriptAsUInt32 &amp;&amp; isIndex(subscriptAsUInt32)) {
<span class="line-modified">!             baseObject-&gt;putDirectIndex(globalObject, subscriptAsUInt32, value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
              LLINT_END();
          }
      }
  
      // Don&#39;t put to an object if toString threw an exception.
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      if (UNLIKELY(throwScope.exception()))
          LLINT_END();
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(property))
<span class="line-modified">!         baseObject-&gt;putDirectIndex(globalObject, index.value(), value, 0, isStrictMode ? PutDirectIndexShouldThrow : PutDirectIndexShouldNotThrow);</span>
      else {
          PutPropertySlot slot(baseObject, isStrictMode);
<span class="line-modified">!         CommonSlowPaths::putDirectWithReify(vm, globalObject, baseObject, property, value, slot);</span>
      }
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_del_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     JSValue baseValue = getOperand(callFrame, bytecode.m_base);</span>
<span class="line-modified">!     JSObject* baseObject = baseValue.toObject(globalObject);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
  
      bool couldDelete;
  
      uint32_t i;
      if (subscript.getUInt32(i))
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);</span>
      else {
          LLINT_CHECK_EXCEPTION();
<span class="line-modified">!         auto property = subscript.toPropertyKey(globalObject);</span>
          LLINT_CHECK_EXCEPTION();
<span class="line-modified">!         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);</span>
      }
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())</span>
<span class="line-modified">!         LLINT_THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
  
      LLINT_RETURN(jsBoolean(couldDelete));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
      ASSERT(getter.isObject());
  
<span class="line-modified">!     baseObj-&gt;putGetter(globalObject, codeBlock-&gt;identifier(bytecode.m_property), asObject(getter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
      ASSERT(setter.isObject());
  
<span class="line-modified">!     baseObj-&gt;putSetter(globalObject, codeBlock-&gt;identifier(bytecode.m_property), asObject(setter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_setter_by_id)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObject = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_getter);</span>
<span class="line-modified">!     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_setter);</span>
      ASSERT(getter.isObject() || setter.isObject());
<span class="line-modified">!     GetterSetter* accessor = GetterSetter::create(vm, globalObject, getter, setter);</span>
  
<span class="line-modified">!     CommonSlowPaths::putDirectAccessorWithReify(vm, globalObject, baseObject, codeBlock-&gt;identifier(bytecode.m_property), accessor, bytecode.m_attributes);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_getter_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
<span class="line-modified">!     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue getter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
      ASSERT(getter.isObject());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     baseObj-&gt;putGetter(globalObject, property, asObject(getter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_setter_by_val)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     ASSERT(getNonConstantOperand(callFrame, bytecode.m_base).isObject());</span>
<span class="line-modified">!     JSObject* baseObj = asObject(getNonConstantOperand(callFrame, bytecode.m_base));</span>
<span class="line-modified">!     JSValue subscript = getOperand(callFrame, bytecode.m_property);</span>
  
      unsigned options = bytecode.m_attributes;
  
<span class="line-modified">!     JSValue setter = getNonConstantOperand(callFrame, bytecode.m_accessor);</span>
      ASSERT(setter.isObject());
  
<span class="line-modified">!     auto property = subscript.toPropertyKey(globalObject);</span>
      LLINT_CHECK_EXCEPTION();
  
<span class="line-modified">!     baseObj-&gt;putSetter(globalObject, property, asObject(setter), options);</span>
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jtrue)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJtrue&gt;();
<span class="line-modified">!     LLINT_BRANCH(getOperand(callFrame, bytecode.m_condition).toBoolean(globalObject));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jfalse)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJfalse&gt;();
<span class="line-modified">!     LLINT_BRANCH(!getOperand(callFrame, bytecode.m_condition).toBoolean(globalObject));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jless)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJless&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLess&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnless)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnless&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLess&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jgreater)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJgreater&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLess&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jngreater)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJngreater&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLess&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jlesseq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJlesseq&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLessEq&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnlesseq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnlesseq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLessEq&lt;true&gt;(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jgreatereq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJgreatereq&gt;();
<span class="line-modified">!     LLINT_BRANCH(jsLessEq&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jngreatereq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJngreatereq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!jsLessEq&lt;false&gt;(globalObject, getOperand(callFrame, bytecode.m_rhs), getOperand(callFrame, bytecode.m_lhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jeq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJeq&gt;();
<span class="line-modified">!     LLINT_BRANCH(JSValue::equal(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jneq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJneq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!JSValue::equal(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jstricteq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJstricteq&gt;();
<span class="line-modified">!     LLINT_BRANCH(JSValue::strictEqual(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_jnstricteq)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpJnstricteq&gt;();
<span class="line-modified">!     LLINT_BRANCH(!JSValue::strictEqual(globalObject, getOperand(callFrame, bytecode.m_lhs), getOperand(callFrame, bytecode.m_rhs)));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_imm)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchImm&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
      ASSERT(scrutinee.isDouble());
      double value = scrutinee.asDouble();
      int32_t intValue = static_cast&lt;int32_t&gt;(value);
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">!     if (value == intValue)</span>
          JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue(intValue, defaultOffset));
<span class="line-modified">!     else</span>
          JUMP_TO(defaultOffset);
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_char)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchChar&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
      ASSERT(scrutinee.isString());
      JSString* string = asString(scrutinee);
      ASSERT(string-&gt;length() == 1);
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
<span class="line-modified">!     StringImpl* impl = string-&gt;value(globalObject).impl();</span>
      JUMP_TO(codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex).offsetForValue((*impl)[0], defaultOffset));
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_switch_string)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSwitchString&gt;();
<span class="line-modified">!     JSValue scrutinee = getOperand(callFrame, bytecode.m_scrutinee);</span>
      int defaultOffset = JUMP_OFFSET(bytecode.m_defaultOffset);
      if (!scrutinee.isString())
          JUMP_TO(defaultOffset);
      else {
<span class="line-modified">!         StringImpl* scrutineeStringImpl = asString(scrutinee)-&gt;value(globalObject).impl();</span>
  
          LLINT_CHECK_EXCEPTION();
  
          JUMP_TO(codeBlock-&gt;stringSwitchJumpTable(bytecode.m_tableIndex).offsetForValue(scrutineeStringImpl, defaultOffset));
      }
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewFunc&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating function!\n&quot;);
      LLINT_RETURN(JSFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_generator_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewGeneratorFunc&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating function!\n&quot;);
      LLINT_RETURN(JSGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewAsyncFunc&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating async function!\n&quot;);
      LLINT_RETURN(JSAsyncFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFunc&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      slowPathLogF(&quot;Creating async generator function!\n&quot;);
      LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, codeBlock-&gt;functionDecl(bytecode.m_functionDecl), scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewFuncExp&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_generator_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewGeneratorFuncExp&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSGeneratorFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewAsyncFuncExp&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSAsyncFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_new_async_generator_func_exp)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpNewAsyncGeneratorFuncExp&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      FunctionExecutable* executable = codeBlock-&gt;functionExpr(bytecode.m_functionDecl);
  
      LLINT_RETURN(JSAsyncGeneratorFunction::create(vm, executable, scope));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_set_function_name)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpSetFunctionName&gt;();
<span class="line-modified">!     JSFunction* func = jsCast&lt;JSFunction*&gt;(getNonConstantOperand(callFrame, bytecode.m_function));</span>
<span class="line-modified">!     JSValue name = getOperand(callFrame, bytecode.m_name);</span>
<span class="line-modified">!     func-&gt;setFunctionName(globalObject, name);</span>
      LLINT_END();
  }
  
<span class="line-modified">! static SlowPathReturnType handleHostCall(CallFrame* calleeFrame, JSValue callee, CodeSpecializationKind kind)</span>
  {
      slowPathLog(&quot;Performing host call.\n&quot;);
  
<span class="line-modified">!     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">!     CodeBlock* callerCodeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     JSGlobalObject* globalObject = callerCodeBlock-&gt;globalObject();</span>
<span class="line-added">+     VM&amp; vm = callerCodeBlock-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     calleeFrame-&gt;setCodeBlock(nullptr);</span>
<span class="line-modified">!     calleeFrame-&gt;clearReturnPC();</span>
  
      if (kind == CodeForCall) {
          CallData callData;
          CallType callType = getCallData(vm, callee, callData);
  
          ASSERT(callType != CallType::JS);
  
          if (callType == CallType::Host) {
<span class="line-modified">!             SlowPathFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">!             calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">!             vm.hostCallReturnValue = JSValue::decode(callData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
<span class="line-modified">!             LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
          }
  
          slowPathLog(&quot;Call callee is not a function: &quot;, callee, &quot;\n&quot;);
  
          ASSERT(callType == CallType::None);
<span class="line-modified">!         LLINT_CALL_THROW(globalObject, createNotAFunctionError(globalObject, callee));</span>
      }
  
      ASSERT(kind == CodeForConstruct);
  
      ConstructData constructData;
      ConstructType constructType = getConstructData(vm, callee, constructData);
  
      ASSERT(constructType != ConstructType::JS);
  
      if (constructType == ConstructType::Host) {
<span class="line-modified">!         SlowPathFrameTracer tracer(vm, calleeFrame);</span>
<span class="line-modified">!         calleeFrame-&gt;setCallee(asObject(callee));</span>
<span class="line-modified">!         vm.hostCallReturnValue = JSValue::decode(constructData.native.function(asObject(callee)-&gt;globalObject(vm), calleeFrame));</span>
<span class="line-modified">!         LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
      }
  
      slowPathLog(&quot;Constructor callee is not a function: &quot;, callee, &quot;\n&quot;);
  
      ASSERT(constructType == ConstructType::None);
<span class="line-modified">!     LLINT_CALL_THROW(globalObject, createNotAConstructorError(globalObject, callee));</span>
  }
  
<span class="line-modified">! inline SlowPathReturnType setUpCall(CallFrame* calleeFrame, CodeSpecializationKind kind, JSValue calleeAsValue, LLIntCallLinkInfo* callLinkInfo = nullptr)</span>
  {
<span class="line-modified">!     CallFrame* callFrame = calleeFrame-&gt;callerFrame();</span>
<span class="line-modified">!     CodeBlock* callerCodeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     JSGlobalObject* globalObject = callerCodeBlock-&gt;globalObject();</span>
<span class="line-added">+     VM&amp; vm = callerCodeBlock-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     slowPathLogF(&quot;Performing call with recorded PC = %p\n&quot;, callFrame-&gt;currentVPC());</span>
  
      JSCell* calleeAsFunctionCell = getJSFunction(calleeAsValue);
      if (!calleeAsFunctionCell) {
          if (auto* internalFunction = jsDynamicCast&lt;InternalFunction*&gt;(vm, calleeAsValue)) {
              MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr = vm.getCTIInternalFunctionTrampolineFor(kind);
              ASSERT(!!codePtr);
  
              if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
                  ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
                  callLinkInfo-&gt;link(vm, callerCodeBlock, internalFunction, codePtr);
              }
  
              assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">!             LLINT_CALL_RETURN(globalObject, calleeFrame, codePtr.executableAddress(), JSEntryPtrTag);</span>
          }
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, handleHostCall(calleeFrame, calleeAsValue, kind));</span>
      }
      JSFunction* callee = jsCast&lt;JSFunction*&gt;(calleeAsFunctionCell);
      JSScope* scope = callee-&gt;scopeUnchecked();
      ExecutableBase* executable = callee-&gt;executable();
  
      MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; codePtr;
<span class="line-modified">!     CodeBlock* codeBlock = nullptr;</span>
      if (executable-&gt;isHostFunction())
          codePtr = executable-&gt;entrypointFor(kind, MustCheckArity);
      else {
          FunctionExecutable* functionExecutable = static_cast&lt;FunctionExecutable*&gt;(executable);
  
          if (!isCall(kind) &amp;&amp; functionExecutable-&gt;constructAbility() == ConstructAbility::CannotConstruct)
<span class="line-modified">!             LLINT_CALL_THROW(globalObject, createNotAConstructorError(globalObject, callee));</span>
  
<span class="line-modified">!         CodeBlock** codeBlockSlot = calleeFrame-&gt;addressOfCodeBlock();</span>
          Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, callee, scope, kind, *codeBlockSlot);
          EXCEPTION_ASSERT(throwScope.exception() == error);
          if (UNLIKELY(error))
<span class="line-modified">!             LLINT_CALL_THROW(globalObject, error);</span>
          codeBlock = *codeBlockSlot;
          ASSERT(codeBlock);
          ArityCheckMode arity;
<span class="line-modified">!         if (calleeFrame-&gt;argumentCountIncludingThis() &lt; static_cast&lt;size_t&gt;(codeBlock-&gt;numParameters()))</span>
              arity = MustCheckArity;
          else
              arity = ArityCheckNotRequired;
          codePtr = functionExecutable-&gt;entrypointFor(kind, arity);
      }
  
      ASSERT(!!codePtr);
  
      if (!LLINT_ALWAYS_ACCESS_SLOW &amp;&amp; callLinkInfo) {
          ConcurrentJSLocker locker(callerCodeBlock-&gt;m_lock);
          callLinkInfo-&gt;link(vm, callerCodeBlock, callee, codePtr);
          if (codeBlock)
<span class="line-modified">!             codeBlock-&gt;linkIncomingCall(callFrame, callLinkInfo);</span>
      }
  
      assertIsTaggedWith(codePtr.executableAddress(), JSEntryPtrTag);
<span class="line-modified">!     LLINT_CALL_RETURN(globalObject, calleeFrame, codePtr.executableAddress(), JSEntryPtrTag);</span>
  }
  
  template&lt;typename Op&gt;
<span class="line-modified">! inline SlowPathReturnType genericCall(CodeBlock* codeBlock, CallFrame* callFrame, Op&amp;&amp; bytecode, CodeSpecializationKind kind)</span>
  {
      // This needs to:
      // - Set up a call frame.
      // - Figure out what to call and compile it if necessary.
      // - If possible, link the call&#39;s inline cache.
      // - Return a tuple of machine code address to call and the new call frame.
  
<span class="line-modified">!     JSValue calleeAsValue = getOperand(callFrame, bytecode.m_callee);</span>
  
<span class="line-modified">!     CallFrame* calleeFrame = callFrame - bytecode.m_argv;</span>
  
<span class="line-modified">!     calleeFrame-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">!     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">!     calleeFrame-&gt;setCallerFrame(callFrame);</span>
  
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     return setUpCall(calleeFrame, kind, calleeAsValue, &amp;metadata.m_callLinkInfo);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
<span class="line-added">+     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpCall&gt;(), CodeForCall));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
<span class="line-added">+     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpTailCall&gt;(), CodeForCall));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_construct)
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
<span class="line-added">+     RELEASE_AND_RETURN(throwScope, genericCall(codeBlock, callFrame, pc-&gt;as&lt;OpConstruct&gt;(), CodeForConstruct));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_varargs)
  {
      LLINT_BEGIN();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1593,39 ***</span>
      int firstVarArg;
      switch (pc-&gt;opcodeID()) {
      case op_call_varargs: {
          auto bytecode = pc-&gt;as&lt;OpCallVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(exec, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      case op_tail_call_varargs: {
          auto bytecode = pc-&gt;as&lt;OpTailCallVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(exec, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      case op_construct_varargs: {
          auto bytecode = pc-&gt;as&lt;OpConstructVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(exec, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
<span class="line-modified">!     unsigned length = sizeFrameForVarargs(exec, vm, arguments, numUsedStackSlots, firstVarArg);</span>
<span class="line-modified">!     LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
  
<span class="line-modified">!     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, length + 1);</span>
      vm.varargsLength = length;
<span class="line-modified">!     vm.newCallFrameReturnValue = execCallee;</span>
  
<span class="line-modified">!     LLINT_RETURN_CALLEE_FRAME(execCallee);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_forward_arguments)
  {
      LLINT_BEGIN();
<span class="line-new-header">--- 1615,39 ---</span>
      int firstVarArg;
      switch (pc-&gt;opcodeID()) {
      case op_call_varargs: {
          auto bytecode = pc-&gt;as&lt;OpCallVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      case op_tail_call_varargs: {
          auto bytecode = pc-&gt;as&lt;OpTailCallVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      case op_construct_varargs: {
          auto bytecode = pc-&gt;as&lt;OpConstructVarargs&gt;();
          numUsedStackSlots = -bytecode.m_firstFree.offset();
<span class="line-modified">!         arguments = getOperand(callFrame, bytecode.m_arguments);</span>
          firstVarArg = bytecode.m_firstVarArg;
          break;
      }
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
<span class="line-modified">!     unsigned length = sizeFrameForVarargs(globalObject, callFrame, vm, arguments, numUsedStackSlots, firstVarArg);</span>
<span class="line-modified">!     LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
  
<span class="line-modified">!     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);</span>
      vm.varargsLength = length;
<span class="line-modified">!     vm.newCallFrameReturnValue = calleeFrame;</span>
  
<span class="line-modified">!     LLINT_RETURN_CALLEE_FRAME(calleeFrame);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_size_frame_for_forward_arguments)
  {
      LLINT_BEGIN();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1633,200 ***</span>
      // - Set up a call frame with the same arguments as the current frame.
  
      auto bytecode = pc-&gt;as&lt;OpTailCallForwardArguments&gt;();
      unsigned numUsedStackSlots = -bytecode.m_firstFree.offset();
  
<span class="line-modified">!     unsigned arguments = sizeFrameForForwardArguments(exec, vm, numUsedStackSlots);</span>
<span class="line-modified">!     LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
  
<span class="line-modified">!     ExecState* execCallee = calleeFrameForVarargs(exec, numUsedStackSlots, arguments + 1);</span>
  
      vm.varargsLength = arguments;
<span class="line-modified">!     vm.newCallFrameReturnValue = execCallee;</span>
  
<span class="line-modified">!     LLINT_RETURN_CALLEE_FRAME(execCallee);</span>
  }
  
  enum class SetArgumentsWith {
      Object,
      CurrentArguments
  };
  
  template&lt;typename Op&gt;
<span class="line-modified">! inline SlowPathReturnType varargsSetup(ExecState* exec, const Instruction* pc, CodeSpecializationKind kind, SetArgumentsWith set)</span>
  {
      LLINT_BEGIN_NO_SET_PC();
      // This needs to:
      // - Figure out what to call and compile it if necessary.
      // - Return a tuple of machine code address to call and the new call frame.
  
      auto bytecode = pc-&gt;as&lt;Op&gt;();
<span class="line-modified">!     JSValue calleeAsValue = getOperand(exec, bytecode.m_callee);</span>
  
<span class="line-modified">!     ExecState* execCallee = vm.newCallFrameReturnValue;</span>
  
      if (set == SetArgumentsWith::Object) {
<span class="line-modified">!         setupVarargsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), getOperand(exec, bytecode.m_arguments), bytecode.m_firstVarArg, vm.varargsLength);</span>
<span class="line-modified">!         LLINT_CALL_CHECK_EXCEPTION(exec, exec);</span>
      } else
<span class="line-modified">!         setupForwardArgumentsFrameAndSetThis(exec, execCallee, getOperand(exec, bytecode.m_thisValue), vm.varargsLength);</span>
  
<span class="line-modified">!     execCallee-&gt;setCallerFrame(exec);</span>
<span class="line-modified">!     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">!     exec-&gt;setCurrentVPC(pc);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, kind, calleeAsValue));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpTailCallVarargs&gt;(exec, pc, CodeForCall, SetArgumentsWith::Object);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call_forward_arguments)
  {
<span class="line-modified">!     return varargsSetup&lt;OpTailCallForwardArguments&gt;(exec, pc, CodeForCall, SetArgumentsWith::CurrentArguments);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_construct_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpConstructVarargs&gt;(exec, pc, CodeForConstruct, SetArgumentsWith::Object);</span>
  }
  
<span class="line-modified">! inline SlowPathReturnType commonCallEval(ExecState* exec, const Instruction* pc, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; returnPoint)</span>
  {
      LLINT_BEGIN_NO_SET_PC();
      auto bytecode = pc-&gt;as&lt;OpCallEval&gt;();
<span class="line-modified">!     JSValue calleeAsValue = getNonConstantOperand(exec, bytecode.m_callee);</span>
  
<span class="line-modified">!     ExecState* execCallee = exec - bytecode.m_argv;</span>
  
<span class="line-modified">!     execCallee-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">!     execCallee-&gt;setCallerFrame(exec);</span>
<span class="line-modified">!     execCallee-&gt;uncheckedR(CallFrameSlot::callee) = calleeAsValue;</span>
<span class="line-modified">!     execCallee-&gt;setReturnPC(returnPoint.executableAddress());</span>
<span class="line-modified">!     execCallee-&gt;setCodeBlock(0);</span>
<span class="line-modified">!     exec-&gt;setCurrentVPC(pc);</span>
  
      if (!isHostFunction(calleeAsValue, globalFuncEval))
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, setUpCall(execCallee, CodeForCall, calleeAsValue));</span>
  
<span class="line-modified">!     vm.hostCallReturnValue = eval(execCallee);</span>
<span class="line-modified">!     LLINT_CALL_RETURN(exec, execCallee, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval)
  {
<span class="line-modified">!     return commonCallEval(exec, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide16)
  {
<span class="line-modified">!     return commonCallEval(exec, pc, LLInt::getWide16CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide32)
  {
<span class="line-modified">!     return commonCallEval(exec, pc, LLInt::getWide32CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_strcat)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">!     LLINT_RETURN(jsStringFromRegisterArray(exec, &amp;exec-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     LLINT_RETURN(getOperand(exec, bytecode.m_src).toPrimitive(exec));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_throw)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
<span class="line-modified">!     LLINT_THROW(getOperand(exec, bytecode.m_value));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_handle_traps)
  {
      LLINT_BEGIN_NO_SET_PC();
      ASSERT(vm.needTrapHandling());
<span class="line-modified">!     vm.handleTraps(exec);</span>
      UNUSED_PARAM(pc);
<span class="line-modified">!     LLINT_RETURN_TWO(throwScope.exception(), exec);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_debug)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
<span class="line-modified">!     vm.interpreter-&gt;debug(exec, bytecode.m_debugHookType);</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
  {
<span class="line-modified">!     LLINT_BEGIN_NO_SET_PC();</span>
<span class="line-modified">!     UNUSED_PARAM(throwScope);</span>
<span class="line-modified">!     genericUnwind(vm, exec);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_var);</span>
<span class="line-modified">!     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));</span>
  
      // ModuleVar is always converted to ClosureVar for get_from_scope.
      ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
  
<span class="line-modified">!     LLINT_RETURN(scope-&gt;getPropertySlot(exec, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
          if (!found) {
              if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">!                 return throwException(exec, throwScope, createUndefinedVariableError(exec, ident));</span>
              return jsUndefined();
          }
  
          JSValue result = JSValue();
          if (scope-&gt;isGlobalLexicalEnvironment()) {
              // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">!             result = slot.getValue(exec, ident);</span>
              if (result == jsTDZValue())
<span class="line-modified">!                 return throwException(exec, throwScope, createTDZError(exec));</span>
          }
  
<span class="line-modified">!         CommonSlowPaths::tryCacheGetFromScopeGlobal(exec, vm, bytecode, scope, slot, ident);</span>
  
          if (!result)
<span class="line-modified">!             return slot.getValue(exec, ident);</span>
          return result;
      }));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_to_scope)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">-     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">!     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(exec, bytecode.m_scope));</span>
<span class="line-modified">!     JSValue value = getOperand(exec, bytecode.m_value);</span>
      if (metadata.m_getPutInfo.resolveType() == LocalClosureVar) {
          JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
          environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
  
          // Have to do this *after* the write, because if this puts the set into IsWatched, then we need
<span class="line-new-header">--- 1655,200 ---</span>
      // - Set up a call frame with the same arguments as the current frame.
  
      auto bytecode = pc-&gt;as&lt;OpTailCallForwardArguments&gt;();
      unsigned numUsedStackSlots = -bytecode.m_firstFree.offset();
  
<span class="line-modified">!     unsigned arguments = sizeFrameForForwardArguments(globalObject, callFrame, vm, numUsedStackSlots);</span>
<span class="line-modified">!     LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
  
<span class="line-modified">!     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, arguments + 1);</span>
  
      vm.varargsLength = arguments;
<span class="line-modified">!     vm.newCallFrameReturnValue = calleeFrame;</span>
  
<span class="line-modified">!     LLINT_RETURN_CALLEE_FRAME(calleeFrame);</span>
  }
  
  enum class SetArgumentsWith {
      Object,
      CurrentArguments
  };
  
  template&lt;typename Op&gt;
<span class="line-modified">! inline SlowPathReturnType varargsSetup(CallFrame* callFrame, const Instruction* pc, CodeSpecializationKind kind, SetArgumentsWith set)</span>
  {
      LLINT_BEGIN_NO_SET_PC();
<span class="line-added">+ </span>
      // This needs to:
      // - Figure out what to call and compile it if necessary.
      // - Return a tuple of machine code address to call and the new call frame.
  
      auto bytecode = pc-&gt;as&lt;Op&gt;();
<span class="line-modified">!     JSValue calleeAsValue = getOperand(callFrame, bytecode.m_callee);</span>
  
<span class="line-modified">!     CallFrame* calleeFrame = vm.newCallFrameReturnValue;</span>
  
      if (set == SetArgumentsWith::Object) {
<span class="line-modified">!         setupVarargsFrameAndSetThis(globalObject, callFrame, calleeFrame, getOperand(callFrame, bytecode.m_thisValue), getOperand(callFrame, bytecode.m_arguments), bytecode.m_firstVarArg, vm.varargsLength);</span>
<span class="line-modified">!         LLINT_CALL_CHECK_EXCEPTION(globalObject);</span>
      } else
<span class="line-modified">!         setupForwardArgumentsFrameAndSetThis(globalObject, callFrame, calleeFrame, getOperand(callFrame, bytecode.m_thisValue), vm.varargsLength);</span>
  
<span class="line-modified">!     calleeFrame-&gt;setCallerFrame(callFrame);</span>
<span class="line-modified">!     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">!     callFrame-&gt;setCurrentVPC(pc);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(throwScope, setUpCall(calleeFrame, kind, calleeAsValue));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpCallVarargs&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::Object);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpTailCallVarargs&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::Object);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_tail_call_forward_arguments)
  {
<span class="line-modified">!     return varargsSetup&lt;OpTailCallForwardArguments&gt;(callFrame, pc, CodeForCall, SetArgumentsWith::CurrentArguments);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_construct_varargs)
  {
<span class="line-modified">!     return varargsSetup&lt;OpConstructVarargs&gt;(callFrame, pc, CodeForConstruct, SetArgumentsWith::Object);</span>
  }
  
<span class="line-modified">! inline SlowPathReturnType commonCallEval(CallFrame* callFrame, const Instruction* pc, MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; returnPoint)</span>
  {
      LLINT_BEGIN_NO_SET_PC();
      auto bytecode = pc-&gt;as&lt;OpCallEval&gt;();
<span class="line-modified">!     JSValue calleeAsValue = getNonConstantOperand(callFrame, bytecode.m_callee);</span>
  
<span class="line-modified">!     CallFrame* calleeFrame = callFrame - bytecode.m_argv;</span>
  
<span class="line-modified">!     calleeFrame-&gt;setArgumentCountIncludingThis(bytecode.m_argc);</span>
<span class="line-modified">!     calleeFrame-&gt;setCallerFrame(callFrame);</span>
<span class="line-modified">!     calleeFrame-&gt;uncheckedR(VirtualRegister(CallFrameSlot::callee)) = calleeAsValue;</span>
<span class="line-modified">!     calleeFrame-&gt;setReturnPC(returnPoint.executableAddress());</span>
<span class="line-modified">!     calleeFrame-&gt;setCodeBlock(nullptr);</span>
<span class="line-modified">!     callFrame-&gt;setCurrentVPC(pc);</span>
  
      if (!isHostFunction(calleeAsValue, globalFuncEval))
<span class="line-modified">!         RELEASE_AND_RETURN(throwScope, setUpCall(calleeFrame, CodeForCall, calleeAsValue));</span>
  
<span class="line-modified">!     vm.hostCallReturnValue = eval(globalObject, calleeFrame);</span>
<span class="line-modified">!     LLINT_CALL_RETURN(globalObject, calleeFrame, LLInt::getCodePtr(getHostCallReturnValue), CFunctionPtrTag);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval)
  {
<span class="line-modified">!     return commonCallEval(callFrame, pc, LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide16)
  {
<span class="line-modified">!     return commonCallEval(callFrame, pc, LLInt::getWide16CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_call_eval_wide32)
  {
<span class="line-modified">!     return commonCallEval(callFrame, pc, LLInt::getWide32CodePtr&lt;JSEntryPtrTag&gt;(llint_generic_return_point));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_strcat)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">!     LLINT_RETURN(jsStringFromRegisterArray(globalObject, &amp;callFrame-&gt;uncheckedR(bytecode.m_src), bytecode.m_count));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_to_primitive)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">!     LLINT_RETURN(getOperand(callFrame, bytecode.m_src).toPrimitive(globalObject));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_throw)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpThrow&gt;();
<span class="line-modified">!     LLINT_THROW(getOperand(callFrame, bytecode.m_value));</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_handle_traps)
  {
      LLINT_BEGIN_NO_SET_PC();
      ASSERT(vm.needTrapHandling());
<span class="line-modified">!     vm.handleTraps(globalObject, callFrame);</span>
      UNUSED_PARAM(pc);
<span class="line-modified">!     LLINT_RETURN_TWO(throwScope.exception(), globalObject);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_debug)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpDebug&gt;();
<span class="line-modified">!     vm.interpreter-&gt;debug(callFrame, bytecode.m_debugHookType);</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_handle_exception)
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-modified">!     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-modified">!     genericUnwind(vm, callFrame);</span>
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_get_from_scope)
  {
      LLINT_BEGIN();
      auto bytecode = pc-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);</span>
<span class="line-modified">!     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(callFrame, bytecode.m_scope));</span>
  
      // ModuleVar is always converted to ClosureVar for get_from_scope.
      ASSERT(metadata.m_getPutInfo.resolveType() != ModuleVar);
  
<span class="line-modified">!     LLINT_RETURN(scope-&gt;getPropertySlot(globalObject, ident, [&amp;] (bool found, PropertySlot&amp; slot) -&gt; JSValue {</span>
          if (!found) {
              if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound)
<span class="line-modified">!                 return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, ident));</span>
              return jsUndefined();
          }
  
          JSValue result = JSValue();
          if (scope-&gt;isGlobalLexicalEnvironment()) {
              // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
<span class="line-modified">!             result = slot.getValue(globalObject, ident);</span>
              if (result == jsTDZValue())
<span class="line-modified">!                 return throwException(globalObject, throwScope, createTDZError(globalObject));</span>
          }
  
<span class="line-modified">!         CommonSlowPaths::tryCacheGetFromScopeGlobal(globalObject, codeBlock, vm, bytecode, scope, slot, ident);</span>
  
          if (!result)
<span class="line-modified">!             return slot.getValue(globalObject, ident);</span>
          return result;
      }));
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_put_to_scope)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpPutToScope&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
      const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">!     JSObject* scope = jsCast&lt;JSObject*&gt;(getNonConstantOperand(callFrame, bytecode.m_scope));</span>
<span class="line-modified">!     JSValue value = getOperand(callFrame, bytecode.m_value);</span>
      if (metadata.m_getPutInfo.resolveType() == LocalClosureVar) {
          JSLexicalEnvironment* environment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
          environment-&gt;variableAt(ScopeOffset(metadata.m_operand)).set(vm, environment, value);
  
          // Have to do this *after* the write, because if this puts the set into IsWatched, then we need
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1835,124 ***</span>
          if (metadata.m_watchpointSet)
              metadata.m_watchpointSet-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
          LLINT_END();
      }
  
<span class="line-modified">!     bool hasProperty = scope-&gt;hasProperty(exec, ident);</span>
      LLINT_CHECK_EXCEPTION();
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
          &amp;&amp; !isInitialization(metadata.m_getPutInfo.initializationMode())) {
          // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
          PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, exec, ident, slot);</span>
<span class="line-modified">!         if (slot.getValue(exec, ident) == jsTDZValue())</span>
<span class="line-modified">!             LLINT_THROW(createTDZError(exec));</span>
      }
  
      if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty)
<span class="line-modified">!         LLINT_THROW(createUndefinedVariableError(exec, ident));</span>
  
      PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(metadata.m_getPutInfo.initializationMode()));
<span class="line-modified">!     scope-&gt;methodTable(vm)-&gt;put(scope, exec, ident, value, slot);</span>
  
<span class="line-modified">!     CommonSlowPaths::tryCachePutToScopeGlobal(exec, codeBlock, bytecode, scope, slot, ident);</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
  {
      LLINT_BEGIN();
      RELEASE_ASSERT(!!throwScope.exception());
  
      if (isTerminatedExecutionException(vm, throwScope.exception()))
          LLINT_RETURN_TWO(pc, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)));
<span class="line-modified">!     LLINT_RETURN_TWO(pc, 0);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_prologue)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
<span class="line-modified">!     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      ShadowChicken* shadowChicken = vm.shadowChicken();
      RELEASE_ASSERT(shadowChicken);
<span class="line-modified">!     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::prologue(exec-&gt;jsCallee(), exec, exec-&gt;callerFrame(), scope));</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_tail)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpLogShadowChickenTail&gt;();
<span class="line-modified">!     JSValue thisValue = getNonConstantOperand(exec, bytecode.m_thisValue);</span>
<span class="line-modified">!     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
  
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-     CallSiteIndex callSiteIndex(exec-&gt;codeBlock()-&gt;bytecodeOffset(pc));</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     CallSiteIndex callSiteIndex(pc);</span>
<span class="line-removed">- #endif</span>
      ShadowChicken* shadowChicken = vm.shadowChicken();
      RELEASE_ASSERT(shadowChicken);
<span class="line-modified">!     shadowChicken-&gt;log(vm, exec, ShadowChicken::Packet::tail(exec, thisValue, scope, exec-&gt;codeBlock(), callSiteIndex));</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
  {
      LLINT_BEGIN();
  
<span class="line-modified">!     exec-&gt;codeBlock()-&gt;ensureCatchLivenessIsComputedForBytecodeOffset(exec-&gt;bytecodeOffset());</span>
  
      auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified">!     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
<span class="line-modified">!         profile.m_buckets[0] = JSValue::encode(exec-&gt;uncheckedR(profile.m_operand).jsValue());</span>
      });
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
  {
      // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
      // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">!     UNUSED_PARAM(exec);</span>
      g_superSamplerCount++;
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
  {
      // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
      // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">!     UNUSED_PARAM(exec);</span>
      g_superSamplerCount--;
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_out_of_line_jump_target)
  {
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed">-     pc = codeBlock-&gt;outOfLineJumpTarget(pc);</span>
      LLINT_END_IMPL();
  }
  
  extern &quot;C&quot; SlowPathReturnType llint_throw_stack_overflow_error(VM* vm, ProtoCallFrame* protoFrame)
  {
<span class="line-modified">!     ExecState* exec = vm-&gt;topCallFrame;</span>
      auto scope = DECLARE_THROW_SCOPE(*vm);
<span class="line-modified">! </span>
<span class="line-modified">!     if (!exec)</span>
<span class="line-modified">!         exec = protoFrame-&gt;callee()-&gt;globalObject(*vm)-&gt;globalExec();</span>
<span class="line-modified">!     throwStackOverflowError(exec, scope);</span>
      return encodeResult(0, 0);
  }
  
  #if ENABLE(C_LOOP)
  extern &quot;C&quot; SlowPathReturnType llint_stack_check_at_vm_entry(VM* vm, Register* newTopOfStack)
<span class="line-new-header">--- 1857,237 ---</span>
          if (metadata.m_watchpointSet)
              metadata.m_watchpointSet-&gt;touch(vm, &quot;Executed op_put_scope&lt;LocalClosureVar&gt;&quot;);
          LLINT_END();
      }
  
<span class="line-modified">!     bool hasProperty = scope-&gt;hasProperty(globalObject, ident);</span>
      LLINT_CHECK_EXCEPTION();
      if (hasProperty
          &amp;&amp; scope-&gt;isGlobalLexicalEnvironment()
          &amp;&amp; !isInitialization(metadata.m_getPutInfo.initializationMode())) {
          // When we can&#39;t statically prove we need a TDZ check, we must perform the check on the slow path.
          PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!         JSGlobalLexicalEnvironment::getOwnPropertySlot(scope, globalObject, ident, slot);</span>
<span class="line-modified">!         if (slot.getValue(globalObject, ident) == jsTDZValue())</span>
<span class="line-modified">!             LLINT_THROW(createTDZError(globalObject));</span>
      }
  
      if (metadata.m_getPutInfo.resolveMode() == ThrowIfNotFound &amp;&amp; !hasProperty)
<span class="line-modified">!         LLINT_THROW(createUndefinedVariableError(globalObject, ident));</span>
  
      PutPropertySlot slot(scope, codeBlock-&gt;isStrictMode(), PutPropertySlot::UnknownContext, isInitialization(metadata.m_getPutInfo.initializationMode()));
<span class="line-modified">!     scope-&gt;methodTable(vm)-&gt;put(scope, globalObject, ident, value, slot);</span>
  
<span class="line-modified">!     CommonSlowPaths::tryCachePutToScopeGlobal(globalObject, codeBlock, bytecode, scope, slot, ident);</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
  {
      LLINT_BEGIN();
<span class="line-added">+     UNUSED_PARAM(globalObject);</span>
      RELEASE_ASSERT(!!throwScope.exception());
  
      if (isTerminatedExecutionException(vm, throwScope.exception()))
          LLINT_RETURN_TWO(pc, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)));
<span class="line-modified">!     LLINT_RETURN_TWO(pc, nullptr);</span>
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_prologue)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpLogShadowChickenPrologue&gt;();
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
      ShadowChicken* shadowChicken = vm.shadowChicken();
      RELEASE_ASSERT(shadowChicken);
<span class="line-modified">!     shadowChicken-&gt;log(vm, callFrame, ShadowChicken::Packet::prologue(callFrame-&gt;jsCallee(), callFrame, callFrame-&gt;callerFrame(), scope));</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_log_shadow_chicken_tail)
  {
      LLINT_BEGIN();
  
      auto bytecode = pc-&gt;as&lt;OpLogShadowChickenTail&gt;();
<span class="line-modified">!     JSValue thisValue = getNonConstantOperand(callFrame, bytecode.m_thisValue);</span>
<span class="line-modified">!     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallSiteIndex callSiteIndex(BytecodeIndex(codeBlock-&gt;bytecodeOffset(pc)));</span>
  
      ShadowChicken* shadowChicken = vm.shadowChicken();
      RELEASE_ASSERT(shadowChicken);
<span class="line-modified">!     shadowChicken-&gt;log(vm, callFrame, ShadowChicken::Packet::tail(callFrame, thisValue, scope, codeBlock, callSiteIndex));</span>
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_profile_catch)
  {
      LLINT_BEGIN();
  
<span class="line-modified">!     codeBlock-&gt;ensureCatchLivenessIsComputedForBytecodeIndex(callFrame-&gt;bytecodeIndex());</span>
  
      auto bytecode = pc-&gt;as&lt;OpCatch&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">!     metadata.m_buffer-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
<span class="line-modified">!         profile.m_buckets[0] = JSValue::encode(callFrame-&gt;uncheckedR(profile.m_operand).jsValue());</span>
      });
  
      LLINT_END();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_super_sampler_begin)
  {
      // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
      // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">!     UNUSED_PARAM(callFrame);</span>
      g_superSamplerCount++;
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_super_sampler_end)
  {
      // FIXME: It seems like we should be able to do this in asm but llint doesn&#39;t seem to like global variables.
      // See: https://bugs.webkit.org/show_bug.cgi?id=179438
<span class="line-modified">!     UNUSED_PARAM(callFrame);</span>
      g_superSamplerCount--;
      LLINT_END_IMPL();
  }
  
  LLINT_SLOW_PATH_DECL(slow_path_out_of_line_jump_target)
  {
<span class="line-modified">!     pc = callFrame-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);</span>
      LLINT_END_IMPL();
  }
  
<span class="line-added">+ template&lt;typename Opcode&gt;</span>
<span class="line-added">+ static void handleVarargsCheckpoint(VM&amp; vm, CallFrame* callFrame, JSGlobalObject* globalObject, const Opcode&amp; bytecode, CheckpointOSRExitSideState&amp; sideState)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     unsigned argumentCountIncludingThis = sideState.tmps[Opcode::argCountIncludingThis].asUInt32();</span>
<span class="line-added">+     unsigned firstVarArg = bytecode.m_firstVarArg;</span>
<span class="line-added">+ </span>
<span class="line-added">+     MarkedArgumentBuffer args;</span>
<span class="line-added">+     args.fill(argumentCountIncludingThis - 1, [&amp;] (JSValue* buffer) {</span>
<span class="line-added">+         loadVarargs(globalObject, buffer, callFrame-&gt;r(bytecode.m_arguments).jsValue(), firstVarArg, argumentCountIncludingThis - 1);</span>
<span class="line-added">+     });</span>
<span class="line-added">+     if (args.hasOverflowed()) {</span>
<span class="line-added">+         throwStackOverflowError(globalObject, scope);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSValue result;</span>
<span class="line-added">+     if (Opcode::opcodeID != op_construct_varargs)</span>
<span class="line-added">+         result = call(globalObject, getOperand(callFrame, bytecode.m_callee), getOperand(callFrame, bytecode.m_thisValue), args, &quot;&quot;);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         result = construct(globalObject, getOperand(callFrame, bytecode.m_callee), getOperand(callFrame, bytecode.m_thisValue), args, &quot;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+     callFrame-&gt;uncheckedR(bytecode.m_dst) = result;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline SlowPathReturnType dispatchToNextInstruction(CodeBlock* codeBlock, InstructionStream::Ref pc)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RELEASE_ASSERT(!codeBlock-&gt;vm().exceptionForInspection());</span>
<span class="line-added">+     if (Options::forceOSRExitToLLInt() || codeBlock-&gt;jitType() == JITType::InterpreterThunk) {</span>
<span class="line-added">+         const Instruction* nextPC = pc.next().ptr();</span>
<span class="line-added">+         auto nextBytecode = LLInt::getCodePtr&lt;JSEntryPtrTag&gt;(*pc.next().ptr());</span>
<span class="line-added">+         return encodeResult(nextPC, nextBytecode.executableAddress());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(JIT)</span>
<span class="line-added">+     ASSERT(codeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="line-added">+     BytecodeIndex nextBytecodeIndex = pc.next().index();</span>
<span class="line-added">+     auto nextBytecode = codeBlock-&gt;jitCodeMap().find(nextBytecodeIndex);</span>
<span class="line-added">+     return encodeResult(nullptr, nextBytecode.executableAddress());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern &quot;C&quot; SlowPathReturnType slow_path_checkpoint_osr_exit_from_inlined_call(CallFrame* callFrame, EncodedJSValue result)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Since all our calling checkpoints do right now is move result into our dest we can just do that here and return.</span>
<span class="line-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-added">+     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = vm.findCheckpointOSRSideState(callFrame);</span>
<span class="line-added">+     BytecodeIndex bytecodeIndex = sideState-&gt;bytecodeIndex;</span>
<span class="line-added">+     auto pc = codeBlock-&gt;instructions().at(bytecodeIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto opcode = pc-&gt;opcodeID();</span>
<span class="line-added">+     switch (opcode) {</span>
<span class="line-added">+     case op_call_varargs: {</span>
<span class="line-added">+         callFrame-&gt;uncheckedR(pc-&gt;as&lt;OpCallVarargs&gt;().m_dst) = JSValue::decode(result);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case op_construct_varargs: {</span>
<span class="line-added">+         callFrame-&gt;uncheckedR(pc-&gt;as&lt;OpConstructVarargs&gt;().m_dst) = JSValue::decode(result);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // op_tail_call_varargs should never return if the thing it was calling was inlined.</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return dispatchToNextInstruction(codeBlock, pc);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern &quot;C&quot; SlowPathReturnType slow_path_checkpoint_osr_exit(CallFrame* callFrame, EncodedJSValue /* needed for cCall2 in CLoop */)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
<span class="line-added">+     VM&amp; vm = codeBlock-&gt;vm();</span>
<span class="line-added">+     SlowPathFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSGlobalObject* globalObject = codeBlock-&gt;globalObject();</span>
<span class="line-added">+ </span>
<span class="line-added">+     std::unique_ptr&lt;CheckpointOSRExitSideState&gt; sideState = vm.findCheckpointOSRSideState(callFrame);</span>
<span class="line-added">+     BytecodeIndex bytecodeIndex = sideState-&gt;bytecodeIndex;</span>
<span class="line-added">+     ASSERT(bytecodeIndex.checkpoint());</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto pc = codeBlock-&gt;instructions().at(bytecodeIndex);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto opcode = pc-&gt;opcodeID();</span>
<span class="line-added">+     switch (opcode) {</span>
<span class="line-added">+     case op_call_varargs:</span>
<span class="line-added">+         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpCallVarargs&gt;(), *sideState.get());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case op_construct_varargs:</span>
<span class="line-added">+         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpConstructVarargs&gt;(), *sideState.get());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case op_tail_call_varargs:</span>
<span class="line-added">+         ASSERT_WITH_MESSAGE(pc.next()-&gt;opcodeID() == op_ret || pc.next()-&gt;opcodeID() == op_jmp, &quot;We strongly assume all tail calls are followed by an op_ret (or sometimes a jmp to a ret).&quot;);</span>
<span class="line-added">+         handleVarargsCheckpoint(vm, callFrame, globalObject, pc-&gt;as&lt;OpTailCallVarargs&gt;(), *sideState.get());</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (UNLIKELY(scope.exception()))</span>
<span class="line-added">+         return encodeResult(returnToThrow(vm), 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return dispatchToNextInstruction(codeBlock, pc);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  extern &quot;C&quot; SlowPathReturnType llint_throw_stack_overflow_error(VM* vm, ProtoCallFrame* protoFrame)
  {
<span class="line-modified">!     CallFrame* callFrame = vm-&gt;topCallFrame;</span>
      auto scope = DECLARE_THROW_SCOPE(*vm);
<span class="line-modified">!     JSGlobalObject* globalObject = nullptr;</span>
<span class="line-modified">!     if (callFrame)</span>
<span class="line-modified">!         globalObject = callFrame-&gt;lexicalGlobalObject(*vm);</span>
<span class="line-modified">!     else</span>
<span class="line-added">+         globalObject = protoFrame-&gt;callee()-&gt;globalObject(*vm);</span>
<span class="line-added">+     throwStackOverflowError(globalObject, scope);</span>
      return encodeResult(0, 0);
  }
  
  #if ENABLE(C_LOOP)
  extern &quot;C&quot; SlowPathReturnType llint_stack_check_at_vm_entry(VM* vm, Register* newTopOfStack)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1960,13 ***</span>
      bool success = vm-&gt;ensureStackCapacityFor(newTopOfStack);
      return encodeResult(reinterpret_cast&lt;void*&gt;(success), 0);
  }
  #endif
  
<span class="line-modified">! extern &quot;C&quot; void llint_write_barrier_slow(ExecState* exec, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.heap.writeBarrier(cell);
  }
  
  extern &quot;C&quot; NO_RETURN_DUE_TO_CRASH void llint_crash()
  {
<span class="line-new-header">--- 2095,13 ---</span>
      bool success = vm-&gt;ensureStackCapacityFor(newTopOfStack);
      return encodeResult(reinterpret_cast&lt;void*&gt;(success), 0);
  }
  #endif
  
<span class="line-modified">! extern &quot;C&quot; void llint_write_barrier_slow(CallFrame* callFrame, JSCell* cell)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;codeBlock()-&gt;vm();</span>
      vm.heap.writeBarrier(cell);
  }
  
  extern &quot;C&quot; NO_RETURN_DUE_TO_CRASH void llint_crash()
  {
</pre>
<center><a href="LLIntPCRanges.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntSlowPaths.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
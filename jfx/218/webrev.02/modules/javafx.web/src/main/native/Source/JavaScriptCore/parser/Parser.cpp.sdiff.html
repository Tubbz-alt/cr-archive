<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;Parser.h&quot;
  25 
  26 #include &quot;ASTBuilder.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;DebuggerParseData.h&quot;
  29 #include &quot;JSCInlines.h&quot;
  30 #include &quot;VM.h&quot;
  31 #include &lt;utility&gt;

  32 #include &lt;wtf/SetForScope.h&gt;
  33 #include &lt;wtf/StringPrintStream.h&gt;
  34 
  35 #define updateErrorMessage(shouldPrintToken, ...) do {\
  36     propagateError(); \
  37     logError(shouldPrintToken, __VA_ARGS__); \
  38 } while (0)
  39 
  40 #define propagateError() do { if (UNLIKELY(hasError())) return 0; } while (0)
  41 #define internalFailWithMessage(shouldPrintToken, ...) do { updateErrorMessage(shouldPrintToken, __VA_ARGS__); return 0; } while (0)
  42 #define handleErrorToken() do { if (m_token.m_type == EOFTOK || m_token.m_type &amp; ErrorTokenFlag) { failDueToUnexpectedToken(); } } while (0)
  43 #define failWithMessage(...) do { { handleErrorToken(); updateErrorMessage(true, __VA_ARGS__); } return 0; } while (0)
  44 #define failWithStackOverflow() do { updateErrorMessage(false, &quot;Stack exhausted&quot;); m_hasStackOverflow = true; return 0; } while (0)
  45 #define failIfFalse(cond, ...) do { if (!(cond)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  46 #define failIfTrue(cond, ...) do { if (cond) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  47 #define failIfTrueIfStrict(cond, ...) do { if ((cond) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  48 #define failIfFalseIfStrict(cond, ...) do { if ((!(cond)) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  49 #define consumeOrFail(tokenType, ...) do { if (!consume(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  50 #define consumeOrFailWithFlags(tokenType, flags, ...) do { if (!consume(tokenType, flags)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  51 #define matchOrFail(tokenType, ...) do { if (!match(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
</pre>
<hr />
<pre>
 109     StringPrintStream stream;
 110     printUnexpectedTokenText(stream);
 111     setErrorMessage(stream.toStringWithLatin1Fallback());
 112 }
 113 
 114 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 115 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 116 {
 117     if (hasError())
 118         return;
 119     StringPrintStream stream;
 120     if (shouldPrintToken) {
 121         printUnexpectedTokenText(stream);
 122         stream.print(&quot;. &quot;);
 123     }
 124     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 125     setErrorMessage(stream.toStringWithLatin1Fallback());
 126 }
 127 
 128 template &lt;typename LexerType&gt;
<span class="line-modified"> 129 Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKind, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
 130     : m_vm(vm)
 131     , m_source(&amp;source)
 132     , m_hasStackOverflow(false)
 133     , m_allowsIn(true)
 134     , m_statementDepth(0)
<span class="line-removed"> 135     , m_sourceElements(0)</span>
 136     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 137     , m_scriptMode(scriptMode)
 138     , m_superBinding(superBinding)
<span class="line-modified"> 139     , m_defaultConstructorKind(defaultConstructorKind)</span>
 140     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 141     , m_debuggerParseData(debuggerParseData)
 142 {
 143     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
 144     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 145     m_token.m_location.line = source.firstLine().oneBasedInt();
 146     m_token.m_location.startOffset = source.startOffset();
 147     m_token.m_location.endOffset = source.startOffset();
 148     m_token.m_location.lineStartOffset = source.startOffset();
 149     m_functionCache = vm.addSourceProviderCache(source.provider());
 150     m_expressionErrorClassifier = nullptr;
 151 
 152     ScopeRef scope = pushScope();
 153     scope-&gt;setSourceParseMode(parseMode);
 154     scope-&gt;setIsEvalContext(isEvalContext);
 155     if (isEvalContext)
 156         scope-&gt;setEvalContextType(evalContextType);
 157 
 158     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 159         scope-&gt;setConstructorKind(ConstructorKind::Extends);
</pre>
<hr />
<pre>
 191 
 192 private:
 193     ScopeRef m_scope;
 194     bool m_oldValue;
 195 };
 196 
 197 struct DepthManager : private SetForScope&lt;int&gt; {
 198 public:
 199     DepthManager(int* depth)
 200         : SetForScope&lt;int&gt;(*depth, *depth)
 201     {
 202     }
 203 };
 204 
 205 template &lt;typename LexerType&gt;
 206 Parser&lt;LexerType&gt;::~Parser()
 207 {
 208 }
 209 
 210 template &lt;typename LexerType&gt;
<span class="line-modified"> 211 String Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)</span>
 212 {
<span class="line-removed"> 213     String parseError = String();</span>
<span class="line-removed"> 214 </span>
 215     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
 216     ScopeRef scope = currentScope();
 217     scope-&gt;setIsLexicalScope();
 218     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 219 

 220     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 221     if (m_lexer-&gt;isReparsingFunction()) {
 222         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 223         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
<span class="line-modified"> 224             m_parameters = createGeneratorParameters(context, functionInfo.parameterCount);</span>


 225         else
<span class="line-modified"> 226             m_parameters = parseFunctionParameters(context, parseMode, functionInfo);</span>
 227 
 228         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 229             // The only way we could have an error wile reparsing is if we run out of stack space.
 230             RELEASE_ASSERT(match(ARROWFUNCTION));
 231             next();
 232             isArrowFunctionBodyExpression = !match(OPENBRACE);
 233         }
 234     }
 235 
 236     if (!calleeName.isNull())
 237         scope-&gt;declareCallee(&amp;calleeName);
 238 
 239     if (m_lexer-&gt;isReparsingFunction())
 240         m_statementDepth--;
 241 
 242     SourceElements* sourceElements = nullptr;
 243     // The only way we can error this early is if we reparse a function and we run out of stack space.
 244     if (!hasError()) {
 245         if (isAsyncFunctionWrapperParseMode(parseMode))
 246             sourceElements = parseAsyncFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 247         else if (isArrowFunctionBodyExpression)
 248             sourceElements = parseArrowFunctionSingleExpressionBodySourceElements(context);
 249         else if (isModuleParseMode(parseMode))
 250             sourceElements = parseModuleSourceElements(context, parseMode);
 251         else if (isGeneratorWrapperParseMode(parseMode))
 252             sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
 253         else if (isAsyncGeneratorWrapperParseMode(parseMode))
 254             sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 255         else if (parsingContext == ParsingContext::FunctionConstructor)
 256             sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
<span class="line-modified"> 257         else</span>



 258             sourceElements = parseSourceElements(context, CheckForStrictMode);
 259     }
 260 
 261     bool validEnding = consume(EOFTOK);
<span class="line-modified"> 262     if (!sourceElements || !validEnding) {</span>
<span class="line-modified"> 263         if (hasError())</span>
<span class="line-removed"> 264             parseError = m_errorMessage;</span>
<span class="line-removed"> 265         else</span>
<span class="line-removed"> 266             parseError = &quot;Parser error&quot;_s;</span>
<span class="line-removed"> 267     }</span>
 268 
 269     IdentifierSet capturedVariables;
 270     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 271     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 272     scope-&gt;getCapturedVars(capturedVariables);
 273 
 274     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 275     for (auto&amp; entry : capturedVariables)
 276         varDeclarations.markVariableAsCaptured(entry);
 277 
 278     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
 279         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 280             context.propagateArgumentsUse();
 281     }
 282 
 283     CodeFeatures features = context.features();
 284     if (scope-&gt;strictMode())
 285         features |= StrictModeFeature;
 286     if (scope-&gt;shadowsArguments())
 287         features |= ShadowsArgumentsFeature;
 288     if (m_seenTaggedTemplate)
 289         features |= NoEvalCacheFeature;
 290 
<span class="line-modified"> 291 #ifndef NDEBUG</span>
 292     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 293         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 294         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 295         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 296             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
 297             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {
 298                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 299                 dataLog(m_source-&gt;view());
 300                 CRASH();
 301             }
 302         }
 303     }
<span class="line-modified"> 304 #endif // NDEBUG</span>
<span class="line-removed"> 305     didFinishParsing(sourceElements, scope-&gt;takeFunctionDeclarations(), varDeclarations, WTFMove(sloppyModeHoistedFunctions), features, context.numConstants());</span>
 306 
<span class="line-modified"> 307     return parseError;</span>
<span class="line-removed"> 308 }</span>
<span class="line-removed"> 309 </span>
<span class="line-removed"> 310 template &lt;typename LexerType&gt;</span>
<span class="line-removed"> 311 void Parser&lt;LexerType&gt;::didFinishParsing(SourceElements* sourceElements, DeclarationStacks::FunctionStack&amp;&amp; funcStack,</span>
<span class="line-removed"> 312     VariableEnvironment&amp; varDeclarations, UniquedStringImplPtrSet&amp;&amp; sloppyModeHoistedFunctions, CodeFeatures features, int numConstants)</span>
<span class="line-removed"> 313 {</span>
<span class="line-removed"> 314     m_sourceElements = sourceElements;</span>
<span class="line-removed"> 315     m_funcDeclarations = WTFMove(funcStack);</span>
<span class="line-removed"> 316     m_varDeclarations.swap(varDeclarations);</span>
<span class="line-removed"> 317     m_features = features;</span>
<span class="line-removed"> 318     m_sloppyModeHoistedFunctions = WTFMove(sloppyModeHoistedFunctions);</span>
<span class="line-removed"> 319     m_numConstants = numConstants;</span>
 320 }
 321 
 322 template &lt;typename LexerType&gt;
<span class="line-modified"> 323 bool Parser&lt;LexerType&gt;::isArrowFunctionParameters()</span>
 324 {
 325     if (match(OPENPAREN)) {
<span class="line-modified"> 326         SavePoint saveArrowFunctionPoint = createSavePoint();</span>
 327         next();
 328         bool isArrowFunction = false;
 329         if (match(CLOSEPAREN)) {
 330             next();
 331             isArrowFunction = match(ARROWFUNCTION);
 332         } else {
 333             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 334             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 335             AutoPopScopeRef fakeScope(this, pushScope());
 336             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 337 
 338             unsigned parametersCount = 0;
 339             bool isArrowFunctionParameterList = true;
 340             bool isMethod = false;
 341             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 342             propagateError();
 343             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 344         }
<span class="line-modified"> 345         restoreSavePoint(saveArrowFunctionPoint);</span>
 346         return isArrowFunction;
 347     }
 348 
 349     if (matchSpecIdentifier()) {
<span class="line-modified"> 350         SavePoint saveArrowFunctionPoint = createSavePoint();</span>

 351         next();
 352         bool isArrowFunction = match(ARROWFUNCTION);
<span class="line-modified"> 353         restoreSavePoint(saveArrowFunctionPoint);</span>
 354         return isArrowFunction;
 355     }
 356 
 357     return false;
 358 }
 359 
 360 template &lt;typename LexerType&gt;
 361 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 362 {
 363     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 364 }
 365 
 366 template &lt;typename LexerType&gt;
 367 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 368 {
 369     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 370     TreeSourceElements sourceElements = context.createSourceElements();
 371     const Identifier* directive = 0;
 372     unsigned directiveLiteralLength = 0;
<span class="line-modified"> 373     auto savePoint = createSavePoint();</span>
 374     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 375 
 376     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 377         if (shouldCheckForUseStrict) {
 378             if (directive) {
 379                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
 380                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {
 381                     setStrictMode();
 382                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 383                     if (!isValidStrictMode()) {
 384                         if (m_parserState.lastFunctionName) {
 385                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)
 386                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
 387                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)
 388                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 389                         }
 390                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))
 391                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
 392                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))
 393                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 394                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 395                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 396                     }
 397                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
<span class="line-modified"> 398                     restoreSavePoint(savePoint);</span>
 399                     propagateError();
 400                     continue;
 401                 }
 402 
 403                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 404                 // see if the next statement we parse is also a directive.
 405                 directive = nullptr;
 406             } else {
 407                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 408                 // is only allowed as the first statement, or after a sequence of directives before it, but
 409                 // not after non-directive statements.
 410                 shouldCheckForUseStrict = false;
 411             }
 412         }
 413         context.appendStatement(sourceElements, statement);
 414     }
 415 
 416     propagateError();
 417     return sourceElements;
 418 }
 419 
 420 template &lt;typename LexerType&gt;
 421 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 422 {
 423     TreeSourceElements sourceElements = context.createSourceElements();
 424     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 425 
 426     while (true) {
 427         TreeStatement statement = 0;
 428         switch (m_token.m_type) {
<span class="line-modified"> 429         case EXPORT:</span>
 430             statement = parseExportDeclaration(context);
 431             if (statement)
 432                 recordPauseLocation(context.breakpointLocation(statement));
 433             break;
 434 
 435         case IMPORT: {
<span class="line-modified"> 436             SavePoint savePoint = createSavePoint();</span>
 437             next();
 438             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
<span class="line-modified"> 439             restoreSavePoint(savePoint);</span>
 440             if (isImportDeclaration) {
 441                 statement = parseImportDeclaration(context);
 442                 if (statement)
 443                     recordPauseLocation(context.breakpointLocation(statement));
 444                 break;
 445             }
 446 
 447             // This is `import(&quot;...&quot;)` call or `import.meta` meta property case.
 448             FALLTHROUGH;
 449         }
 450 
 451         default: {
 452             const Identifier* directive = 0;
 453             unsigned directiveLiteralLength = 0;
 454             if (parseMode == SourceParseMode::ModuleAnalyzeMode) {
 455                 if (!parseStatementListItem(syntaxChecker, directive, &amp;directiveLiteralLength))
 456                     goto end;
 457                 continue;
 458             }
 459             statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength);
</pre>
<hr />
<pre>
 663 template &lt;typename LexerType&gt;
 664 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 665 {
 666     // The grammar is documented here:
 667     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 668     DepthManager statementDepth(&amp;m_statementDepth);
 669     m_statementDepth++;
 670     failIfStackOverflow();
 671     TreeStatement result = 0;
 672     bool shouldSetEndOffset = true;
 673     bool shouldSetPauseLocation = false;
 674 
 675     switch (m_token.m_type) {
 676     case CONSTTOKEN:
 677         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 678         shouldSetPauseLocation = true;
 679         break;
 680     case LET: {
 681         bool shouldParseVariableDeclaration = true;
 682         if (!strictMode()) {
<span class="line-modified"> 683             SavePoint savePoint = createSavePoint();</span>
 684             next();
 685             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 686             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 687             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 688             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 689             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 690             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 691                 shouldParseVariableDeclaration = false;
<span class="line-modified"> 692             restoreSavePoint(savePoint);</span>
 693         }
 694         if (shouldParseVariableDeclaration)
 695             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 696         else {
 697             bool allowFunctionDeclarationAsStatement = true;
 698             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 699         }
 700         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 701         break;
 702     }
 703     case CLASSTOKEN:
 704         result = parseClassDeclaration(context);
 705         break;
 706     case FUNCTION:
 707         result = parseFunctionDeclaration(context);
 708         break;
 709     case IDENT:
 710         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
 711             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 712             // but could be mistakenly parsed as an AsyncFunctionExpression.
<span class="line-modified"> 713             SavePoint savePoint = createSavePoint();</span>
 714             next();
 715             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 716                 result = parseAsyncFunctionDeclaration(context);
 717                 break;
 718             }
<span class="line-modified"> 719             restoreSavePoint(savePoint);</span>
 720         }
 721         FALLTHROUGH;
 722     case AWAIT:
 723     case YIELD: {
 724         // This is a convenient place to notice labeled statements
 725         // (even though we also parse them as normal statements)
 726         // because we allow the following type of code in sloppy mode:
 727         // ``` function foo() { label: function bar() { } } ```
 728         bool allowFunctionDeclarationAsStatement = true;
 729         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 730         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 731         break;
 732     }
 733     default:
 734         m_statementDepth--; // parseStatement() increments the depth.
 735         result = parseStatement(context, directive, directiveLiteralLength);
 736         shouldSetEndOffset = false;
 737         break;
 738     }
 739 
</pre>
<hr />
<pre>
 922         semanticFailIfTrue(isEvalOrArguments(&amp;name), &quot;Cannot destructure to a parameter name &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 923         if (m_parserState.lastFunctionName &amp;&amp; name == *m_parserState.lastFunctionName)
 924             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; as it shadows the name of a strict mode function&quot;);
 925         semanticFailureDueToKeyword(&quot;parameter name&quot;);
 926         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 927             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 928         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 929     }
 930     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 931         // It&#39;s not always an error to define a duplicate parameter.
 932         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 933         // We note this value now so we can check it later.
 934         if (duplicateIdentifier)
 935             *duplicateIdentifier = &amp;name;
 936     }
 937 
 938     return true;
 939 }
 940 
 941 template &lt;typename LexerType&gt;
<span class="line-modified"> 942 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, JSToken token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)</span>
 943 {
 944     ASSERT(!name.isNull());
 945 
 946     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
 947 
 948     switch (kind) {
 949     case DestructuringKind::DestructureToVariables: {
 950         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 951         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 952         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 953             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 954         break;
 955     }
 956 
 957     case DestructuringKind::DestructureToLet:
 958     case DestructuringKind::DestructureToConst:
 959     case DestructuringKind::DestructureToCatchParameters: {
 960         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 961         if (declarationResult != DeclarationResult::Valid) {
 962             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
</pre>
<hr />
<pre>
1038         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1039         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1040     }
1041 
1042     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1043         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1044         if (isEvalOrArguments &amp;&amp; strictMode())
1045             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1046         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1047     }
1048 
1049     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1050 }
1051 
1052 template &lt;typename LexerType&gt;
1053 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1054 {
1055     TreeDestructuringPattern assignmentTarget = 0;
1056 
1057     if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">1058         SavePoint savePoint = createSavePoint();</span>
1059         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1060         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1061             return assignmentTarget;
<span class="line-modified">1062         restoreSavePoint(savePoint);</span>
1063     }
1064 
1065     JSTextPosition startPosition = tokenStartPosition();
1066     auto element = parseMemberExpression(context);
1067 
1068     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1069 
1070     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1071         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1072         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1073     }
1074 
1075     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1076 }
1077 
1078 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1079 {
1080     switch (kind) {
1081     case DestructuringKind::DestructureToLet:
1082     case DestructuringKind::DestructureToConst:
</pre>
<hr />
<pre>
1217                     if (kind == DestructuringKind::DestructureToExpressions) {
1218                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;
1219                         if (isEvalOrArguments &amp;&amp; strictMode())
1220                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1221                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1222                     }
1223                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1224                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1225                 }
1226             } else {
1227                 JSTokenType tokenType = m_token.m_type;
1228                 switch (m_token.m_type) {
1229                 case DOUBLE:
1230                 case INTEGER:
1231                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
1232                     break;
1233                 case STRING:
1234                     propertyName = m_token.m_data.ident;
1235                     wasString = true;
1236                     break;



1237                 case OPENBRACKET:
1238                     next();
1239                     propertyExpression = parseAssignmentExpression(context);
1240                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1241                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1242                     break;
1243                 default:
1244                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1245                         if (kind == DestructuringKind::DestructureToExpressions)
1246                             return 0;
1247                         failWithMessage(&quot;Expected a property name&quot;);
1248                     }
1249                     propertyName = m_token.m_data.ident;
1250                     break;
1251                 }
1252                 next();
1253                 if (!consume(COLON)) {
1254                     if (kind == DestructuringKind::DestructureToExpressions)
1255                         return 0;
1256                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
</pre>
<hr />
<pre>
1427         TreeStatement statement = parseStatement(context, unused);
1428         endLoop();
1429         failIfFalse(statement, &quot;Expected statement as body of for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1430         gatherLexicalVariablesIfNecessary();
1431         TreeStatement result;
1432         if (isOfEnumeration)
1433             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1434         else {
1435             ASSERT(!isAwaitFor);
1436             if (isVarDeclaraton &amp;&amp; forInInitializer)
1437                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1438             else
1439                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1440         }
1441         popLexicalScopeIfNecessary();
1442         return result;
1443     }
1444 
1445     if (!match(SEMICOLON)) {
1446         if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">1447             SavePoint savePoint = createSavePoint();</span>
1448             declsStart = tokenStartPosition();
1449             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1450             declsEnd = lastTokenEndPosition();
1451             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
1452                 goto enumerationLoop;
1453             pattern = TreeDestructuringPattern(0);
<span class="line-modified">1454             restoreSavePoint(savePoint);</span>
1455         }
1456         m_allowsIn = false;
1457         declsStart = tokenStartPosition();
1458         decls = parseExpression(context);
1459         declsEnd = lastTokenEndPosition();
1460         m_allowsIn = true;
1461         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1462         recordPauseLocation(context.breakpointLocation(decls));
1463     }
1464 
1465     if (match(SEMICOLON)) {
1466     standardForLoop:
1467         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1468         // Standard for loop
1469         if (decls)
1470             recordPauseLocation(context.breakpointLocation(decls));
1471         next();
1472         TreeExpression condition = 0;
1473         failIfTrue(forLoopConstDoesNotHaveInitializer &amp;&amp; isConstDeclaration, &quot;const variables in for loops must have initializers&quot;);
1474 
</pre>
<hr />
<pre>
2023     int start = tokenLine();
2024 
2025     TreeStatement function = 0;
2026     if (!isAsync)
2027         function = parseFunctionDeclaration(context);
2028     else
2029         function = parseAsyncFunctionDeclaration(context);
2030     propagateError();
2031     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2032     TreeSourceElements sourceElements = context.createSourceElements();
2033     context.appendStatement(sourceElements, function);
2034     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2035     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2036     return result;
2037 }
2038 
2039 template &lt;typename LexerType&gt;
2040 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2041 {
2042     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
<span class="line-modified">2043     SavePoint savePoint = createSavePoint();</span>
2044     next();
2045     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2046         const bool isAsync = true;
2047         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2048         return true;
2049     }
<span class="line-modified">2050     restoreSavePoint(savePoint);</span>
2051     return false;
2052 }
2053 
2054 template &lt;typename LexerType&gt;
2055 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2056 {
2057 #define failIfDuplicateIfViolation() \
2058     if (duplicateParameter) {\
2059         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2060         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2061         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2062         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
2063         semanticFailIfTrue(isMethod, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in a method&quot;);\
2064     }
2065 
2066     bool hasDefaultParameterValues = false;
2067     bool hasDestructuringPattern = false;
2068     bool isRestParameter = false;
2069     const Identifier* duplicateParameter = nullptr;
2070     unsigned restParameterStart = 0;
</pre>
<hr />
<pre>
2095         failIfDuplicateIfViolation();
2096         if (isRestParameter || defaultValue || hasDestructuringPattern)
2097             currentScope()-&gt;setHasNonSimpleParameterList();
2098         context.appendParameter(list, parameter, defaultValue);
2099         if (!isRestParameter) {
2100             restParameterStart++;
2101             if (!hasDefaultParameterValues)
2102                 parameterCount++;
2103         }
2104     } while (!isRestParameter &amp;&amp; consume(COMMA));
2105 
2106     return true;
2107 #undef failIfDuplicateIfViolation
2108 }
2109 
2110 template &lt;typename LexerType&gt;
2111 template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
2112     TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
2113     ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
2114 {

2115     bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
2116     if (!isArrowFunctionBodyExpression) {
2117         next();
2118         if (match(CLOSEBRACE)) {
2119             unsigned endColumn = tokenColumn();
2120             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2121             return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2122         }
2123     }
2124 
2125     DepthManager statementDepth(&amp;m_statementDepth);
2126     m_statementDepth = 0;
2127     if (bodyType == ArrowFunctionBodyExpression) {
2128         if (m_debuggerParseData)
2129             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse body of this arrow function&quot;);
2130         else
2131             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse body of this arrow function&quot;);
2132     } else {
2133         if (m_debuggerParseData)
2134             failIfFalse(parseSourceElements(context, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
</pre>
<hr />
<pre>
2147     case SourceParseMode::SetterMode:
2148     case SourceParseMode::NormalFunctionMode:
2149     case SourceParseMode::MethodMode:
2150     case SourceParseMode::GeneratorBodyMode:
2151     case SourceParseMode::GeneratorWrapperFunctionMode:
2152     case SourceParseMode::GeneratorWrapperMethodMode:
2153         return &quot;a &quot;;
2154     case SourceParseMode::ArrowFunctionMode:
2155     case SourceParseMode::AsyncFunctionMode:
2156     case SourceParseMode::AsyncFunctionBodyMode:
2157     case SourceParseMode::AsyncMethodMode:
2158     case SourceParseMode::AsyncArrowFunctionBodyMode:
2159     case SourceParseMode::AsyncArrowFunctionMode:
2160     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2161     case SourceParseMode::AsyncGeneratorBodyMode:
2162     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2163         return &quot;an &quot;;
2164     case SourceParseMode::ProgramMode:
2165     case SourceParseMode::ModuleAnalyzeMode:
2166     case SourceParseMode::ModuleEvaluateMode:

2167         RELEASE_ASSERT_NOT_REACHED();
2168         return &quot;&quot;;
2169     }
2170     RELEASE_ASSERT_NOT_REACHED();
2171     return nullptr;
2172 }
2173 
2174 static const char* stringForFunctionMode(SourceParseMode mode)
2175 {
2176     switch (mode) {
2177     case SourceParseMode::GetterMode:
2178         return &quot;getter&quot;;
2179     case SourceParseMode::SetterMode:
2180         return &quot;setter&quot;;
2181     case SourceParseMode::NormalFunctionMode:
2182         return &quot;function&quot;;
2183     case SourceParseMode::MethodMode:
2184         return &quot;method&quot;;
2185     case SourceParseMode::GeneratorBodyMode:
2186         return &quot;generator&quot;;
</pre>
<hr />
<pre>
2188     case SourceParseMode::GeneratorWrapperMethodMode:
2189         return &quot;generator function&quot;;
2190     case SourceParseMode::ArrowFunctionMode:
2191         return &quot;arrow function&quot;;
2192     case SourceParseMode::AsyncFunctionMode:
2193     case SourceParseMode::AsyncFunctionBodyMode:
2194         return &quot;async function&quot;;
2195     case SourceParseMode::AsyncMethodMode:
2196         return &quot;async method&quot;;
2197     case SourceParseMode::AsyncArrowFunctionBodyMode:
2198     case SourceParseMode::AsyncArrowFunctionMode:
2199         return &quot;async arrow function&quot;;
2200     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2201     case SourceParseMode::AsyncGeneratorBodyMode:
2202         return &quot;async generator function&quot;;
2203     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2204         return &quot;async generator method&quot;;
2205     case SourceParseMode::ProgramMode:
2206     case SourceParseMode::ModuleAnalyzeMode:
2207     case SourceParseMode::ModuleEvaluateMode:

2208         RELEASE_ASSERT_NOT_REACHED();
2209         return &quot;&quot;;
2210     }
2211     RELEASE_ASSERT_NOT_REACHED();
2212     return nullptr;
2213 }
2214 
2215 template &lt;typename LexerType&gt; template &lt;class TreeBuilder, class FunctionInfoType&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::parseFunctionParameters(TreeBuilder&amp; context, SourceParseMode mode, FunctionInfoType&amp; functionInfo)
2216 {
2217     RELEASE_ASSERT(!(SourceParseModeSet(SourceParseMode::ProgramMode, SourceParseMode::ModuleAnalyzeMode, SourceParseMode::ModuleEvaluateMode).contains(mode)));
2218     TreeFormalParameterList parameterList = context.createFormalParameterList();
2219     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Parameters);
2220 
2221     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2222         if (!matchSpecIdentifier() &amp;&amp; !match(OPENPAREN)) {
2223             semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2224             failWithMessage(&quot;Expected an arrow function input parameter&quot;);
2225         } else {
2226             if (match(OPENPAREN)) {
2227                 next();
</pre>
<hr />
<pre>
2413     };
2414 
2415     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
2416 
2417     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2418         startLocation = tokenLocation();
2419         functionInfo.startLine = tokenLine();
2420         startColumn = tokenColumn();
2421 
2422         parametersStart = m_token.m_location.startOffset;
2423         functionInfo.startOffset = parametersStart;
2424         functionInfo.parametersStartColumn = startColumn;
2425 
2426         if (loadCachedFunction())
2427             return true;
2428 
2429         {
2430             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2431             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2432             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
<span class="line-modified">2433             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));</span>
2434             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2435             propagateError();
2436         }
2437 
2438         matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
2439 
2440         if (m_lexer-&gt;hasLineTerminatorBeforeToken())
2441             failDueToUnexpectedToken();
2442 
2443         ASSERT(constructorKind == ConstructorKind::None);
2444 
2445         // Check if arrow body start with {. If it true it mean that arrow function is Fat arrow function
2446         // and we need use common approach to parse function body
2447         next();
2448         functionBodyType = match(OPENBRACE) ? ArrowFunctionBodyBlock : ArrowFunctionBodyExpression;
2449     } else {
2450         // http://ecma-international.org/ecma-262/6.0/#sec-function-definitions
2451         // FunctionExpression :
2452         //     function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
2453         //
</pre>
<hr />
<pre>
2501         parametersStart = m_token.m_location.startOffset;
2502         functionInfo.startOffset = parametersStart;
2503 
2504         if (loadCachedFunction())
2505             return true;
2506         {
2507             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2508             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2509             propagateError();
2510         }
2511 
2512         matchOrFail(OPENBRACE, &quot;Expected an opening &#39;{&#39; at the start of a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2513 
2514         // If the code is invoked from function constructor, we need to ensure that parameters are only composed by the string offered as parameters.
2515         if (UNLIKELY(functionConstructorParametersEndPosition))
2516             semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
2517 
2518         // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
2519         // Set ConstructorKind to None for non-constructor methods of classes.
2520 
<span class="line-modified">2521         if (m_defaultConstructorKind != ConstructorKind::None) {</span>
<span class="line-modified">2522             constructorKind = m_defaultConstructorKind;</span>
<span class="line-modified">2523             expectedSuperBinding = m_defaultConstructorKind == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;</span>
2524         }
2525 
2526         functionBodyType = StandardFunctionBodyBlock;
2527     }
2528 
2529     functionScope-&gt;setConstructorKind(constructorKind);
2530     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2531 
2532     m_parserState.lastFunctionName = lastFunctionName;
<span class="line-modified">2533     ParserState oldState = internalSaveParserState();</span>
2534 
2535     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
2536     // This loop collects the set of capture candidates that aren&#39;t
2537     // part of the set of this function&#39;s declared parameters. We will
2538     // figure out which parameters are captured for this function when
2539     // we actually generate code for it. For now, we just propagate to
2540     // our parent scopes which variables we might have closed over that
2541     // belong to them. This is necessary for correctness when using
2542     // the source provider cache because we can&#39;t close over a variable
2543     // that we don&#39;t claim to close over. The source provider cache must
2544     // know this information to properly cache this function.
2545     // This might work itself out nicer if we declared a different
2546     // Scope struct for the parameters (because they are indeed implemented
2547     // as their own scope).
2548     UniquedStringImplPtrSet nonLocalCapturesFromParameterExpressions;
2549     functionScope-&gt;forEachUsedVariable([&amp;] (UniquedStringImpl* impl) {
2550         if (!functionScope-&gt;hasDeclaredParameter(impl)) {
2551             nonLocalCapturesFromParameterExpressions.add(impl);
2552             if (TreeBuilder::NeedsFreeVariableInfo)
2553                 parentScope-&gt;addClosedVariableCandidateUnconditionally(impl);
</pre>
<hr />
<pre>
2566 
2567         generatorBodyScope-&gt;setSourceParseMode(innerParseMode);
2568         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
2569         generatorBodyScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2570 
2571         // Disallow &#39;use strict&#39; directives in the implicit inner function if
2572         // needed.
2573         if (functionScope-&gt;hasNonSimpleParameterList())
2574             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2575 
2576         functionInfo.body = performParsingFunctionBody();
2577 
2578         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2579         if  (generatorBodyScope-&gt;strictMode())
2580             functionScope-&gt;setStrictMode();
2581 
2582         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2583     } else
2584         functionInfo.body = performParsingFunctionBody();
2585 
<span class="line-modified">2586     restoreParserState(oldState);</span>
2587     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2588     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2589     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2590         ASSERT(functionInfo.name);
2591         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
2592         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2593         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2594     }
2595 
2596     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2597     functionInfo.endOffset = m_token.m_data.offset;
2598 
2599     if (functionBodyType == ArrowFunctionBodyExpression) {
2600         location = locationBeforeLastToken();
2601         functionInfo.endOffset = location.endOffset;
2602     } else {
2603         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2604         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2605     }
2606 
</pre>
<hr />
<pre>
2627         }
2628         functionScope-&gt;fillParametersForSourceProviderCache(parameters, nonLocalCapturesFromParameterExpressions);
2629         newInfo = SourceProviderCacheItem::create(parameters);
2630     }
2631 
2632     bool functionScopeWasStrictMode = functionScope-&gt;strictMode();
2633 
2634     popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2635 
2636     if (functionBodyType != ArrowFunctionBodyExpression) {
2637         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2638         next();
2639     } else {
2640         // We need to lex the last token again because the last token is lexed under the different context because of the following possibilities.
2641         // 1. which may have different strict mode.
2642         // 2. which may not build strings for tokens.
2643         // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
2644         // So we only check TreeBuilder&#39;s type here.
2645         ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
2646         if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
<span class="line-modified">2647             lexCurrentTokenAgainUnderCurrentContext();</span>
2648     }
2649 
2650     if (newInfo)
2651         m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
2652 
2653     functionInfo.endLine = m_lastTokenEndPosition.line;
2654     return true;
2655 }
2656 
2657 static NO_RETURN_DUE_TO_CRASH FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
2658 static FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;ASTBuilder&gt;&amp; info) { return info.body; }
2659 
2660 template &lt;typename LexerType&gt;
2661 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2662 {
2663     ASSERT(match(FUNCTION));
2664     JSTokenLocation location(tokenLocation());
2665     unsigned functionKeywordStart = tokenStart();
2666     next();
2667     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
</pre>
<hr />
<pre>
2835 
2836     ASSERT_WITH_MESSAGE(requirements != FunctionNameRequirements::Unnamed, &quot;Currently, there is no caller that uses FunctionNameRequirements::Unnamed for class syntax.&quot;);
2837     ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !info.className), &quot;When specifying FunctionNameRequirements::None, we need to initialize info.className with the default value in the caller side.&quot;);
2838     if (match(IDENT)) {
2839         info.className = m_token.m_data.ident;
2840         next();
2841         failIfTrue(classScope-&gt;declareLexicalVariable(info.className, true) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, info.className-&gt;impl(), &quot;&#39; is not a valid class name&quot;);
2842     } else if (requirements == FunctionNameRequirements::Named) {
2843         if (match(OPENBRACE))
2844             semanticFail(&quot;Class statements must have a name&quot;);
2845         semanticFailureDueToKeyword(&quot;class name&quot;);
2846         failDueToUnexpectedToken();
2847     }
2848     ASSERT(info.className);
2849 
2850     TreeExpression parentClass = 0;
2851     if (consume(EXTENDS)) {
2852         parentClass = parseMemberExpression(context);
2853         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2854     }

2855     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2856 
2857     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2858 
2859     TreeExpression constructor = 0;
2860     TreePropertyList classElements = 0;
2861     TreePropertyList classElementsTail = 0;

2862     while (!match(CLOSEBRACE)) {
2863         if (match(SEMICOLON)) {
2864             next();
2865             continue;
2866         }
2867 
2868         JSTokenLocation methodLocation(tokenLocation());
2869         unsigned methodStart = tokenStart();
2870 
2871         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2872         ClassElementTag tag = ClassElementTag::Instance;

2873         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
<span class="line-modified">2874             SavePoint savePoint = createSavePoint();</span>
2875             next();
2876             if (match(OPENPAREN)) {
2877                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
<span class="line-modified">2878                 restoreSavePoint(savePoint);</span>
2879             } else
2880                 tag = ClassElementTag::Static;
2881         }
2882 
2883         // FIXME: Figure out a way to share more code with parseProperty.
2884         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;
2885         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2886         TreeExpression computedPropertyName = 0;
2887         bool isGetter = false;
2888         bool isSetter = false;
2889         SourceParseMode parseMode = SourceParseMode::MethodMode;
2890         if (consume(TIMES))
2891             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2892 
2893 parseMethod:
2894         switch (m_token.m_type) {
2895         namedKeyword:
2896         case STRING:
2897             ident = m_token.m_data.ident;
2898             ASSERT(ident);
2899             next();
2900             break;





2901         case IDENT:
2902             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
2903                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2904                     ident = m_token.m_data.ident;
2905                     next();
<span class="line-modified">2906                     if (match(OPENPAREN) || match(COLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())</span>

2907                         break;
2908                     if (UNLIKELY(consume(TIMES)))
2909                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2910                     else
2911                         parseMode = SourceParseMode::AsyncMethodMode;
2912                     goto parseMethod;
2913                 }
2914             }
2915             FALLTHROUGH;
2916         case AWAIT:
2917             ident = m_token.m_data.ident;
2918             ASSERT(ident);
2919             next();
<span class="line-modified">2920             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(OPENBRACKET))) {</span>
2921                 isGetter = *ident == propertyNames.get;
2922                 isSetter = *ident == propertyNames.set;
2923             }
2924             break;
2925         case DOUBLE:
2926         case INTEGER:
2927             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
2928             ASSERT(ident);
2929             next();
2930             break;
2931         case OPENBRACKET:
2932             next();
2933             computedPropertyName = parseAssignmentExpression(context);

2934             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2935             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2936             break;
2937         default:
2938             if (m_token.m_type &amp; KeywordTokenFlag)
2939                 goto namedKeyword;
2940             failDueToUnexpectedToken();
2941         }
2942 
2943         TreeProperty property;
2944         const bool alwaysStrictInsideClass = true;
2945         if (isGetter || isSetter) {
<span class="line-modified">2946             property = parseGetterSetter(context, alwaysStrictInsideClass, isGetter ? PropertyNode::Getter : PropertyNode::Setter,</span>
<span class="line-modified">2947                 methodStart, ConstructorKind::None, tag);</span>

2948             failIfFalse(property, &quot;Cannot parse this method&quot;);




























2949         } else {
2950             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2951             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2952             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2953                 isConstructor = false;
2954                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);
2955                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);
2956             }
2957 
2958             methodInfo.name = isConstructor ? info.className : ident;
2959             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2960 
2961             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2962             if (isConstructor) {
2963                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2964                 constructor = method;
2965                 continue;
2966             }
2967 
2968             // FIXME: Syntax error when super() is called
2969             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
2970                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
2971 
2972             if (computedPropertyName) {
<span class="line-modified">2973                 property = context.createProperty(computedPropertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed),</span>
<span class="line-removed">2974                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);</span>
2975             } else {
<span class="line-modified">2976                 property = context.createProperty(methodInfo.name, method, PropertyNode::Constant,</span>
<span class="line-removed">2977                     PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);</span>
2978             }
2979         }
2980 
2981         if (classElementsTail)
2982             classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
2983         else
2984             classElements = classElementsTail = context.createPropertyList(methodLocation, property);
2985     }
2986 
2987     info.endOffset = tokenLocation().endOffset - 1;
2988     consumeOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a class body&quot;);
2989 
2990     auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
2991     popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
2992     return classExpression;
2993 }
2994 



































































2995 struct LabelInfo {
2996     LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
2997     : m_ident(ident)
2998     , m_start(start)
2999     , m_end(end)
3000     {
3001     }
3002 
3003     const Identifier* m_ident;
3004     JSTextPosition m_start;
3005     JSTextPosition m_end;
3006 };
3007 
3008 template &lt;typename LexerType&gt;
3009 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context, bool allowFunctionDeclarationAsStatement)
3010 {
3011 
3012     /* Expression and Label statements are ambiguous at LL(1), so we have a
3013      * special case that looks for a colon as the next character in the input.
3014      */
</pre>
<hr />
<pre>
3362     const Identifier* localName = m_token.m_data.ident;
3363     const Identifier* exportedName = localName;
3364     next();
3365 
3366     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3367         next();
3368         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3369         exportedName = m_token.m_data.ident;
3370         next();
3371     }
3372 
3373     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3374     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3375     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3376 }
3377 
3378 template &lt;typename LexerType&gt;
3379 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3380 {
3381     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
<span class="line-modified">3382     ASSERT(match(EXPORT));</span>
3383     JSTokenLocation exportLocation(tokenLocation());
3384     next();
3385 
3386     switch (m_token.m_type) {
3387     case TIMES: {
3388         // export * FromClause ;
3389         next();
3390 
3391         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);
3392         next();
3393         auto moduleName = parseModuleName(context);
3394         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3395         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3396 
3397         return context.createExportAllDeclaration(exportLocation, moduleName);
3398     }
3399 
3400     case DEFAULT: {
3401         // export default HoistableDeclaration[Default]
3402         // export default ClassDeclaration[Default]
3403         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3404 
3405         next();
3406 
3407         TreeStatement result = 0;
3408         bool isFunctionOrClassDeclaration = false;
3409         const Identifier* localName = nullptr;
3410 
3411         bool startsWithFunction = match(FUNCTION);
3412         if (startsWithFunction || match(CLASSTOKEN)) {
<span class="line-modified">3413             SavePoint savePoint = createSavePoint();</span>
3414             isFunctionOrClassDeclaration = true;
3415             next();
3416 
3417             // ES6 Generators
3418             if (startsWithFunction &amp;&amp; match(TIMES))
3419                 next();
3420             if (match(IDENT))
3421                 localName = m_token.m_data.ident;
<span class="line-modified">3422             restoreSavePoint(savePoint);</span>
3423         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
<span class="line-modified">3424             SavePoint savePoint = createSavePoint();</span>
3425             next();
3426             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3427                 next();
3428                 if (match(IDENT))
3429                     localName = m_token.m_data.ident;
3430                 isFunctionOrClassDeclaration = true;
3431             }
<span class="line-modified">3432             restoreSavePoint(savePoint);</span>
3433         }
3434 
3435         if (!localName)
3436             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
3437 
3438         if (isFunctionOrClassDeclaration) {
3439             if (startsWithFunction) {
3440                 ASSERT(match(FUNCTION));
3441                 DepthManager statementDepth(&amp;m_statementDepth);
3442                 m_statementDepth = 1;
3443                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3444             } else if (match(CLASSTOKEN)) {
3445                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3446             } else {
3447                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
3448                 next();
3449                 DepthManager statementDepth(&amp;m_statementDepth);
3450                 m_statementDepth = 1;
3451                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3452             }
</pre>
<hr />
<pre>
3658 template &lt;typename LexerType&gt;
3659 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3660 {
3661     ASSERT(!hasError());
3662 
3663     failIfStackOverflow();
3664 
3665     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3666         return parseYieldExpression(context);
3667 
3668     JSTextPosition start = tokenStartPosition();
3669     JSTokenLocation location(tokenLocation());
3670     int initialAssignmentCount = m_parserState.assignmentCount;
3671     int initialNonLHSCount = m_parserState.nonLHSCount;
3672     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3673     bool wasOpenParen = match(OPENPAREN);
3674     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3675     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3676     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3677     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
<span class="line-modified">3678     SavePoint savePoint = createSavePoint();</span>
3679     size_t usedVariablesSize = 0;
3680 
3681     if (wasOpenParen) {
3682         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3683         currentScope()-&gt;pushUsedVariableSet();
3684     }
3685 
3686     TreeExpression lhs = parseConditionalExpression(context);
3687 
3688     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3689         bool isArrowFunctionToken = match(ARROWFUNCTION);
3690         if (!lhs || isArrowFunctionToken) {
<span class="line-modified">3691             SavePointWithError errorRestorationSavePoint = createSavePointForError();</span>
<span class="line-removed">3692             restoreSavePoint(savePoint);</span>
3693             bool isAsyncArrow = false;
3694             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
3695                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3696                     next();
3697                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3698                 }
3699             }
<span class="line-modified">3700             if (isArrowFunctionParameters()) {</span>
3701                 if (wasOpenParen)
3702                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3703                 return parseArrowFunctionExpression(context, isAsyncArrow);
3704             }
3705             if (isArrowFunctionToken)
3706                 propagateError();
<span class="line-modified">3707             restoreSavePointWithError(errorRestorationSavePoint);</span>
3708             if (isArrowFunctionToken)
3709                 failDueToUnexpectedToken();
3710         }
3711     }
3712 
3713     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3714         propagateError();
3715 
3716     if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
<span class="line-modified">3717         SavePointWithError expressionErrorLocation = createSavePointForError();</span>
<span class="line-removed">3718         restoreSavePoint(savePoint);</span>
3719         auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
3720         if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
<span class="line-modified">3721             restoreSavePointWithError(expressionErrorLocation);</span>
3722             return 0;
3723         }
3724         failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
3725         consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
3726         auto rhs = parseAssignmentExpression(context);
3727         if (!rhs)
3728             propagateError();
3729         return context.createDestructuringAssignment(location, pattern, rhs);
3730     }
3731 
3732     failIfFalse(lhs, &quot;Cannot parse expression&quot;);
3733     if (initialNonLHSCount != m_parserState.nonLHSCount) {
3734         if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3735             semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3736 
3737         return lhs;
3738     }
3739 
3740     int assignmentStack = 0;
3741     Operator op;
</pre>
<hr />
<pre>
3766         start = tokenStartPosition();
3767         m_parserState.assignmentCount++;
3768         next(TreeBuilder::DontBuildStrings);
3769         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
3770             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);
3771             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);
3772             m_parserState.lastIdentifier = 0;
3773         }
3774         lhs = parseAssignmentExpression(context);
3775         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3776         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3777             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3778                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3779             break;
3780         }
3781     }
3782 end:
3783     if (hadAssignment)
3784         m_parserState.nonLHSCount++;
3785 
<span class="line-removed">3786     if (!TreeBuilder::CreatesAST)</span>
<span class="line-removed">3787         return lhs;</span>
<span class="line-removed">3788 </span>
3789     while (assignmentStack)
3790         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3791 
3792     return lhs;
3793 }
3794 
3795 template &lt;typename LexerType&gt;
3796 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseYieldExpression(TreeBuilder&amp; context)
3797 {
3798     // YieldExpression[In] :
3799     //     yield
3800     //     yield [no LineTerminator here] AssignmentExpression[?In, Yield]
3801     //     yield [no LineTerminator here] * AssignmentExpression[?In, Yield]
3802 
3803     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions
3804     failIfFalse(currentScope()-&gt;isGenerator() &amp;&amp; !currentScope()-&gt;isArrowFunctionBoundary(), &quot;Cannot use yield expression out of generator&quot;);
3805 
3806     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
3807     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
3808 
3809     JSTokenLocation location(tokenLocation());
3810     JSTextPosition divotStart = tokenStartPosition();
3811     ASSERT(match(YIELD));
<span class="line-modified">3812     SavePoint savePoint = createSavePoint();</span>
3813     next();
3814     if (m_lexer-&gt;hasLineTerminatorBeforeToken())
3815         return context.createYield(location);
3816 
3817     bool delegate = consume(TIMES);
3818     JSTextPosition argumentStart = tokenStartPosition();
3819     TreeExpression argument = parseAssignmentExpression(context);
3820     if (!argument) {
<span class="line-modified">3821         restoreSavePoint(savePoint);</span>
3822         next();
3823         return context.createYield(location);
3824     }
3825     return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
3826 }
3827 
3828 template &lt;typename LexerType&gt;
3829 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
3830 {
3831     ASSERT(match(AWAIT));
3832     ASSERT(currentScope()-&gt;isAsyncFunction());
<span class="line-modified">3833     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use await expression within parameters&quot;);</span>
3834     JSTokenLocation location(tokenLocation());
3835     JSTextPosition divotStart = tokenStartPosition();
3836     next();
3837     JSTextPosition argumentStart = tokenStartPosition();
3838     ExpressionErrorClassifier classifier(this);
3839     TreeExpression argument = parseUnaryExpression(context);
3840     failIfFalse(argument, &quot;Failed to parse await expression&quot;);
3841     return context.createAwait(location, argument, divotStart, argumentStart, lastTokenEndPosition());
3842 }
3843 
3844 template &lt;typename LexerType&gt;
3845 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
3846 {
3847     JSTokenLocation location(tokenLocation());
3848     TreeExpression cond = parseBinaryExpression(context);
3849     failIfFalse(cond, &quot;Cannot parse expression&quot;);
3850     if (!match(QUESTION))
3851         return cond;
3852     m_parserState.nonTrivialExpressionCount++;
3853     m_parserState.nonLHSCount++;
</pre>
<hr />
<pre>
3956         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
3957         context.operatorStackPop(operatorStackDepth);
3958     }
3959     return context.popOperandStack(operandStackDepth);
3960 }
3961 
3962 template &lt;typename LexerType&gt;
3963 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
3964 {
3965     SourceParseMode parseMode = SourceParseMode::MethodMode;
3966     bool wasIdent = false;
3967 
3968     if (consume(TIMES))
3969         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
3970 
3971 parseProperty:
3972     switch (m_token.m_type) {
3973     case IDENT:
3974         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
3975             if (parseMode == SourceParseMode::MethodMode) {
<span class="line-modified">3976                 SavePoint savePoint = createSavePoint();</span>
3977                 next();
3978 
3979                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
<span class="line-modified">3980                     restoreSavePoint(savePoint);</span>
3981                     wasIdent = true;
3982                     goto namedProperty;
3983                 }
3984 
3985                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
3986                 if (UNLIKELY(consume(TIMES)))
3987                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
3988                 else
3989                     parseMode = SourceParseMode::AsyncMethodMode;
3990                 goto parseProperty;
3991             }
3992         }
3993         FALLTHROUGH;
3994     case YIELD:
3995     case AWAIT:
3996         wasIdent = true;
3997         FALLTHROUGH;
3998     case STRING: {
3999 namedProperty:
4000         const Identifier* ident = m_token.m_data.ident;
4001         unsigned getterOrSetterStartOffset = tokenStart();
4002         JSToken identToken = m_token;
4003 
4004         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
<span class="line-modified">4005             nextExpectIdentifier(LexerFlagsIgnoreReservedWords);</span>
4006         else
<span class="line-modified">4007             nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
4008 
4009         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
4010             next();
4011             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
4012             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4013             context.setEndOffset(node, m_lexer-&gt;currentOffset());
4014             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;
4015             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
4016         }
4017 
4018         if (match(OPENPAREN)) {
4019             auto method = parsePropertyMethod(context, ident, parseMode);
4020             propagateError();
4021             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4022         }
4023         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4024 
4025         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
4026 
4027         if (match(COMMA) || match(CLOSEBRACE)) {
</pre>
<hr />
<pre>
4049     }
4050     case DOUBLE:
4051     case INTEGER: {
4052         double propertyName = m_token.m_data.doubleValue;
4053         next();
4054 
4055         if (match(OPENPAREN)) {
4056             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);
4057             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4058             propagateError();
4059             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4060         }
4061         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4062 
4063         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4064         TreeExpression node = parseAssignmentExpression(context);
4065         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4066         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4067         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4068     }

















4069     case OPENBRACKET: {
4070         next();
4071         auto propertyName = parseAssignmentExpression(context);
4072         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4073         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4074 
4075         if (match(OPENPAREN)) {
4076             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);
4077             propagateError();
4078             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4079         }
4080         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4081 
4082         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4083         TreeExpression node = parseAssignmentExpression(context);
4084         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4085         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4086         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4087     }
4088     case DOTDOTDOT: {
</pre>
<hr />
<pre>
4117 template &lt;typename LexerType&gt;
4118 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4119     ConstructorKind constructorKind, ClassElementTag tag)
4120 {
4121     const Identifier* stringPropertyName = 0;
4122     double numericPropertyName = 0;
4123     TreeExpression computedPropertyName = 0;
4124 
4125     JSTokenLocation location(tokenLocation());
4126 
4127     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4128         stringPropertyName = m_token.m_data.ident;
4129         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,
4130             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
4131         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,
4132             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4133         next();
4134     } else if (match(DOUBLE) || match(INTEGER)) {
4135         numericPropertyName = m_token.m_data.doubleValue;
4136         next();



4137     } else if (match(OPENBRACKET)) {
4138         next();
4139         computedPropertyName = parseAssignmentExpression(context);
4140         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4141         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4142     } else
4143         failDueToUnexpectedToken();
4144 
4145     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4146     if (type &amp; PropertyNode::Getter) {
4147         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4148         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4149     } else {
4150         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4151         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4152     }
4153 
4154     if (stringPropertyName)
4155         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4156 
</pre>
<hr />
<pre>
4185 template &lt;typename LexerType&gt;
4186 void Parser&lt;LexerType&gt;::recordFunctionEntryLocation(const JSTextPosition&amp; position)
4187 {
4188     if (LIKELY(!m_debuggerParseData))
4189         return;
4190 
4191     m_debuggerParseData-&gt;pausePositions.appendEntry(position);
4192 }
4193 
4194 template &lt;typename LexerType&gt;
4195 void Parser&lt;LexerType&gt;::recordFunctionLeaveLocation(const JSTextPosition&amp; position)
4196 {
4197     if (LIKELY(!m_debuggerParseData))
4198         return;
4199 
4200     m_debuggerParseData-&gt;pausePositions.appendLeave(position);
4201 }
4202 
4203 template &lt;typename LexerType&gt;
4204 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
<span class="line-removed">4205 {</span>
<span class="line-removed">4206     SavePoint savePoint = createSavePoint();</span>
<span class="line-removed">4207     consumeOrFailWithFlags(OPENBRACE, TreeBuilder::DontBuildStrings, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);</span>
<span class="line-removed">4208 </span>
<span class="line-removed">4209     int oldNonLHSCount = m_parserState.nonLHSCount;</span>
<span class="line-removed">4210 </span>
<span class="line-removed">4211     JSTokenLocation location(tokenLocation());</span>
<span class="line-removed">4212     if (match(CLOSEBRACE)) {</span>
<span class="line-removed">4213         next();</span>
<span class="line-removed">4214         return context.createObjectLiteral(location);</span>
<span class="line-removed">4215     }</span>
<span class="line-removed">4216 </span>
<span class="line-removed">4217     TreeProperty property = parseProperty(context, false);</span>
<span class="line-removed">4218     failIfFalse(property, &quot;Cannot parse object literal property&quot;);</span>
<span class="line-removed">4219 </span>
<span class="line-removed">4220     if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {</span>
<span class="line-removed">4221         restoreSavePoint(savePoint);</span>
<span class="line-removed">4222         return parseStrictObjectLiteral(context);</span>
<span class="line-removed">4223     }</span>
<span class="line-removed">4224 </span>
<span class="line-removed">4225     bool seenUnderscoreProto = false;</span>
<span class="line-removed">4226     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))</span>
<span class="line-removed">4227         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;</span>
<span class="line-removed">4228 </span>
<span class="line-removed">4229     TreePropertyList propertyList = context.createPropertyList(location, property);</span>
<span class="line-removed">4230     TreePropertyList tail = propertyList;</span>
<span class="line-removed">4231     while (match(COMMA)) {</span>
<span class="line-removed">4232         next(TreeBuilder::DontBuildStrings);</span>
<span class="line-removed">4233         if (match(CLOSEBRACE))</span>
<span class="line-removed">4234             break;</span>
<span class="line-removed">4235         JSTokenLocation propertyLocation(tokenLocation());</span>
<span class="line-removed">4236         property = parseProperty(context, false);</span>
<span class="line-removed">4237         failIfFalse(property, &quot;Cannot parse object literal property&quot;);</span>
<span class="line-removed">4238         if (context.getType(property) &amp; (PropertyNode::Getter | PropertyNode::Setter)) {</span>
<span class="line-removed">4239             restoreSavePoint(savePoint);</span>
<span class="line-removed">4240             return parseStrictObjectLiteral(context);</span>
<span class="line-removed">4241         }</span>
<span class="line-removed">4242         if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property)) {</span>
<span class="line-removed">4243             if (*context.getName(property) == m_vm.propertyNames-&gt;underscoreProto) {</span>
<span class="line-removed">4244                 semanticFailIfTrue(seenUnderscoreProto, &quot;Attempted to redefine __proto__ property&quot;);</span>
<span class="line-removed">4245                 seenUnderscoreProto = true;</span>
<span class="line-removed">4246             }</span>
<span class="line-removed">4247         }</span>
<span class="line-removed">4248         tail = context.createPropertyList(propertyLocation, property, tail);</span>
<span class="line-removed">4249     }</span>
<span class="line-removed">4250 </span>
<span class="line-removed">4251     location = tokenLocation();</span>
<span class="line-removed">4252     handleProductionOrFail2(CLOSEBRACE, &quot;}&quot;, &quot;end&quot;, &quot;object literal&quot;);</span>
<span class="line-removed">4253 </span>
<span class="line-removed">4254     m_parserState.nonLHSCount = oldNonLHSCount;</span>
<span class="line-removed">4255 </span>
<span class="line-removed">4256     return context.createObjectLiteral(location, propertyList);</span>
<span class="line-removed">4257 }</span>
<span class="line-removed">4258 </span>
<span class="line-removed">4259 template &lt;typename LexerType&gt;</span>
<span class="line-removed">4260 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseStrictObjectLiteral(TreeBuilder&amp; context)</span>
4261 {
4262     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4263 
4264     int oldNonLHSCount = m_parserState.nonLHSCount;
4265 
4266     JSTokenLocation location(tokenLocation());
4267     if (match(CLOSEBRACE)) {
4268         next();
4269         return context.createObjectLiteral(location);
4270     }
4271 
4272     TreeProperty property = parseProperty(context, true);
4273     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4274 
4275     bool seenUnderscoreProto = false;
4276     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
4277         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;
4278 
4279     TreePropertyList propertyList = context.createPropertyList(location, property);
4280     TreePropertyList tail = propertyList;
</pre>
<hr />
<pre>
4481 }
4482 
4483 template &lt;class LexerType&gt;
4484 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::createResolveAndUseVariable(TreeBuilder&amp; context, const Identifier* ident, bool isEval, const JSTextPosition&amp; start, const JSTokenLocation&amp; location)
4485 {
4486     currentScope()-&gt;useVariable(ident, isEval);
4487     m_parserState.lastIdentifier = ident;
4488     return context.createResolve(location, *ident, start, lastTokenEndPosition());
4489 }
4490 
4491 template &lt;typename LexerType&gt;
4492 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
4493 {
4494     failIfStackOverflow();
4495     switch (m_token.m_type) {
4496     case FUNCTION:
4497         return parseFunctionExpression(context);
4498     case CLASSTOKEN:
4499         return parseClassExpression(context);
4500     case OPENBRACE:
<span class="line-removed">4501         if (strictMode())</span>
<span class="line-removed">4502             return parseStrictObjectLiteral(context);</span>
4503         return parseObjectLiteral(context);
4504     case OPENBRACKET:
4505         return parseArrayLiteral(context);
4506     case OPENPAREN: {
4507         next();
4508         int oldNonLHSCount = m_parserState.nonLHSCount;
4509         TreeExpression result = parseExpression(context);
4510         m_parserState.nonLHSCount = oldNonLHSCount;
4511         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4512         return result;
4513     }
4514     case THISTOKEN: {
4515         JSTokenLocation location(tokenLocation());
4516         next();
4517         if (currentScope()-&gt;isArrowFunction())
4518             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4519         return context.createThisExpr(location);
4520     }
4521     case AWAIT:
4522         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
<span class="line-modified">4523             failIfFalse(m_parserState.allowAwait, &quot;Cannot use await expression within parameters&quot;);</span>
4524         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4525             return parseAwaitExpression(context);
4526 
4527         goto identifierExpression;
4528     case IDENT: {
4529         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4530             JSTextPosition start = tokenStartPosition();
4531             const Identifier* ident = m_token.m_data.ident;
4532             JSTokenLocation location(tokenLocation());
4533             next();
4534             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4535                 return parseAsyncFunctionExpression(context);
4536 
4537             // Avoid using variable if it is an arrow function parameter
4538             if (UNLIKELY(match(ARROWFUNCTION)))
4539                 return 0;
4540 
4541             const bool isEval = false;
4542             return createResolveAndUseVariable(context, ident, isEval, start, location);
4543         }


4544     identifierExpression:
4545         JSTextPosition start = tokenStartPosition();
4546         const Identifier* ident = m_token.m_data.ident;


4547         JSTokenLocation location(tokenLocation());
4548         next();
4549 
4550         // Avoid using variable if it is an arrow function parameter
4551         if (UNLIKELY(match(ARROWFUNCTION)))
4552             return 0;
4553 
4554         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);
4555     }
4556     case BIGINT: {
4557         const Identifier* ident = m_token.m_data.bigIntString;
4558         uint8_t radix = m_token.m_data.radix;
4559         JSTokenLocation location(tokenLocation());
4560         next();
4561         return context.createBigInt(location, ident, radix);
4562     }
4563     case STRING: {
4564         const Identifier* ident = m_token.m_data.ident;
4565         JSTokenLocation location(tokenLocation());
4566         next();
</pre>
<hr />
<pre>
4721     int newCount = 0;
4722     JSTokenLocation startLocation = tokenLocation();
4723     JSTokenLocation lastNewTokenLocation;
4724     while (match(NEW)) {
4725         lastNewTokenLocation = tokenLocation();
4726         next();
4727         newCount++;
4728     }
4729     JSTokenLocation location = tokenLocation();
4730 
4731     bool baseIsSuper = match(SUPER);
4732     bool previousBaseWasSuper = false;
4733     bool baseIsImport = match(IMPORT);
4734     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4735 
4736     bool baseIsNewTarget = false;
4737     if (newCount &amp;&amp; match(DOT)) {
4738         next();
4739         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
4740             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">4741             semanticFailIfFalse(currentScope()-&gt;isFunction() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is only valid inside functions&quot;);</span>



4742             baseIsNewTarget = true;
4743             if (currentScope()-&gt;isArrowFunction()) {
<span class="line-modified">4744                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext, &quot;new.target is not valid inside arrow functions in global code&quot;);</span>
4745                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4746             }
4747             ASSERT(lastNewTokenLocation.line);
4748             base = context.createNewTargetExpr(lastNewTokenLocation);
4749             newCount--;
4750             next();
4751         } else {
4752             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4753             failDueToUnexpectedToken();
4754         }
4755     }
4756 
4757     bool baseIsAsyncKeyword = false;
4758 
4759     if (baseIsSuper) {
4760         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">4761         semanticFailIfFalse(currentScope()-&gt;isFunction() || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);</span>


4762         base = context.createSuperExpr(location);
4763         next();

4764         ScopeRef functionScope = currentFunctionScope();
4765         if (!functionScope-&gt;setNeedsSuperBinding()) {
4766             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4767             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4768             // inside of the constructor or method.
4769             if (!m_lexer-&gt;isReparsingFunction()) {
4770                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4771                     ? functionScope-&gt;expectedSuperBinding()
4772                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
<span class="line-modified">4773                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded, &quot;super is not valid in this context&quot;);</span>
4774             }
4775         }
4776     } else if (baseIsImport) {
4777         next();
4778         JSTextPosition expressionEnd = lastTokenEndPosition();
4779         if (consume(DOT)) {
4780             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {
4781                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
4782                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));
4783                 next();
4784             } else {
4785                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4786                 failDueToUnexpectedToken();
4787             }
4788         } else {
4789             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4790             TreeExpression expr = parseAssignmentExpression(context);
4791             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4792             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4793             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
</pre>
<hr />
<pre>
4803                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4804                 failDueToUnexpectedToken();
4805             }
4806             baseIsAsyncKeyword = true;
4807         }
4808     }
4809 
4810     failIfFalse(base, &quot;Cannot parse base expression&quot;);
4811 
4812     do {
4813         TreeExpression optionalChainBase = 0;
4814         JSTokenLocation optionalChainLocation;
4815         JSTokenType type = m_token.m_type;
4816 
4817         if (match(QUESTIONDOT)) {
4818             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
4819             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
4820             optionalChainBase = base;
4821             optionalChainLocation = tokenLocation();
4822 
<span class="line-modified">4823             SavePoint savePoint = createSavePoint();</span>
4824             next();
4825             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
4826                 type = m_token.m_type;
4827             else {
4828                 type = DOT;
<span class="line-modified">4829                 restoreSavePoint(savePoint);</span>
4830             }
4831         }
4832 
4833         while (true) {
4834             location = tokenLocation();
4835             switch (type) {
4836             case OPENBRACKET: {
4837                 m_parserState.nonTrivialExpressionCount++;
4838                 JSTextPosition expressionEnd = lastTokenEndPosition();
4839                 next();
4840                 int nonLHSCount = m_parserState.nonLHSCount;
4841                 int initialAssignments = m_parserState.assignmentCount;
4842                 TreeExpression property = parseExpression(context);
4843                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);
4844                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());
4845 
4846                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4847                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4848 
4849                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);
4850                 m_parserState.nonLHSCount = nonLHSCount;
4851                 break;
4852             }
4853             case OPENPAREN: {


4854                 m_parserState.nonTrivialExpressionCount++;
4855                 int nonLHSCount = m_parserState.nonLHSCount;
4856                 if (newCount) {
4857                     newCount--;
4858                     JSTextPosition expressionEnd = lastTokenEndPosition();
4859                     TreeArguments arguments = parseArguments(context);
4860                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4861                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());
4862                 } else {
4863                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
4864                     JSTextPosition expressionEnd = lastTokenEndPosition();
4865                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;
4866                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);
4867 
4868                     TreeArguments arguments = parseArguments(context);
4869 
4870                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {
4871                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
4872                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4873                         failDueToUnexpectedToken();
</pre>
<hr />
<pre>
4889                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);
4890                             }
4891                         }
4892                         if (currentScope()-&gt;isArrowFunction())
4893                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();
4894                     }
4895 
4896                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);
4897                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,
4898                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);
4899 
4900                     if (isOptionalCall)
4901                         optionalChainBase = base;
4902                 }
4903                 m_parserState.nonLHSCount = nonLHSCount;
4904                 break;
4905             }
4906             case DOT: {
4907                 m_parserState.nonTrivialExpressionCount++;
4908                 JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">4909                 nextExpectIdentifier(LexerFlagsIgnoreReservedWords | TreeBuilder::DontBuildKeywords);</span>
4910                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
4911                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
4912                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4913                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4914                 next();
4915                 break;
4916             }
4917             case BACKQUOTE: {
4918                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);
4919                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);
4920                 JSTextPosition expressionEnd = lastTokenEndPosition();
4921                 int nonLHSCount = m_parserState.nonLHSCount;
4922                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);
4923                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);
4924                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());
4925                 m_parserState.nonLHSCount = nonLHSCount;
4926                 m_seenTaggedTemplate = true;
4927                 break;
4928             }
4929             default:
</pre>
<hr />
<pre>
4987         return &quot;delete&quot;;
4988     }
4989     RELEASE_ASSERT_NOT_REACHED();
4990     return &quot;error&quot;;
4991 }
4992 
4993 template &lt;typename LexerType&gt;
4994 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
4995 {
4996     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
4997     AllowInOverride allowInOverride(this);
4998     int tokenStackDepth = 0;
4999     bool hasPrefixUpdateOp = false;
5000     unsigned lastOperator = 0;
5001 
5002     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
5003         return parseAwaitExpression(context);
5004 
5005     JSTokenLocation location(tokenLocation());
5006 





5007     while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">5008         switch (m_token.m_type) {</span>
<span class="line-modified">5009         case PLUSPLUS:</span>
<span class="line-removed">5010         case MINUSMINUS:</span>
<span class="line-removed">5011         case AUTOPLUSPLUS:</span>
<span class="line-removed">5012         case AUTOMINUSMINUS:</span>
<span class="line-removed">5013             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
5014             hasPrefixUpdateOp = true;
<span class="line-removed">5015             break;</span>
<span class="line-removed">5016         default:</span>
<span class="line-removed">5017             semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-removed">5018             break;</span>
<span class="line-removed">5019         }</span>
5020         lastOperator = m_token.m_type;
5021         m_parserState.nonLHSCount++;
5022         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
5023         next();
5024         m_parserState.nonTrivialExpressionCount++;
5025     }
5026     JSTextPosition subExprStart = tokenStartPosition();
5027     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
5028     TreeExpression expr = parseMemberExpression(context);
5029     if (!expr) {
5030         if (lastOperator)
5031             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
5032         failWithMessage(&quot;Cannot parse member expression&quot;);
5033     }


5034     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {
5035         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);
5036         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);
5037     }
5038     bool isEvalOrArguments = false;
5039     if (strictMode()) {
5040         if (context.isResolve(expr))
5041             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;
5042     }
5043     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5044     switch (m_token.m_type) {
5045     case PLUSPLUS:
5046         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5047         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);
5048         m_parserState.nonTrivialExpressionCount++;
5049         m_parserState.nonLHSCount++;
5050         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5051         m_parserState.assignmentCount++;
5052         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5053         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5054         next();
5055         break;
5056     case MINUSMINUS:
5057         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5058         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);
5059         m_parserState.nonTrivialExpressionCount++;
5060         m_parserState.nonLHSCount++;
5061         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5062         m_parserState.assignmentCount++;
5063         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
5064         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5065         next();
5066         break;
5067     default:
5068         break;
5069     }
5070 
5071     JSTextPosition end = lastTokenEndPosition();
5072     while (tokenStackDepth) {
<span class="line-modified">5073         switch (context.unaryTokenStackLastType(tokenStackDepth)) {</span>


5074         case EXCLAMATION:
5075             expr = context.createLogicalNot(location, expr);
5076             break;
5077         case TILDE:
5078             expr = context.makeBitwiseNotNode(location, expr);
5079             break;
5080         case MINUS:
5081             expr = context.makeNegateNode(location, expr);
5082             break;
5083         case PLUS:
5084             expr = context.createUnaryPlus(location, expr);
5085             break;
5086         case PLUSPLUS:
5087         case AUTOPLUSPLUS:
<span class="line-modified">5088             expr = context.makePrefixNode(location, expr, OpPlusPlus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);</span>

5089             m_parserState.assignmentCount++;
5090             break;
5091         case MINUSMINUS:
5092         case AUTOMINUSMINUS:
<span class="line-modified">5093             expr = context.makePrefixNode(location, expr, OpMinusMinus, context.unaryTokenStackLastStart(tokenStackDepth), subExprStart + 1, end);</span>

5094             m_parserState.assignmentCount++;
5095             break;
5096         case TYPEOF:
5097             expr = context.makeTypeOfNode(location, expr);
5098             break;
5099         case VOIDTOKEN:
5100             expr = context.createVoid(location, expr);
5101             break;
5102         case DELETETOKEN:
5103             failIfTrueIfStrict(context.isResolve(expr), &quot;Cannot delete unqualified property &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5104             expr = context.makeDeleteNode(location, expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
5105             break;
5106         default:
5107             // If we get here something has gone horribly horribly wrong
5108             CRASH();
5109         }
<span class="line-removed">5110         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);</span>
5111         context.unaryTokenStackRemoveLast(tokenStackDepth);
5112     }
5113     return expr;
5114 }
5115 
5116 template &lt;typename LexerType&gt; void Parser&lt;LexerType&gt;::printUnexpectedTokenText(WTF::PrintStream&amp; out)
5117 {
5118     switch (m_token.m_type) {
5119     case EOFTOK:
5120         out.print(&quot;Unexpected end of script&quot;);
5121         return;
5122     case UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK:
5123     case UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5124         out.print(&quot;Incomplete unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5125         return;
5126     case UNTERMINATED_MULTILINE_COMMENT_ERRORTOK:
5127         out.print(&quot;Unterminated multiline comment&quot;);
5128         return;
5129     case UNTERMINATED_NUMERIC_LITERAL_ERRORTOK:
5130         out.print(&quot;Unterminated numeric literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
</pre>
</td>
<td>
<hr />
<pre>
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;Parser.h&quot;
  25 
  26 #include &quot;ASTBuilder.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;DebuggerParseData.h&quot;
  29 #include &quot;JSCInlines.h&quot;
  30 #include &quot;VM.h&quot;
  31 #include &lt;utility&gt;
<span class="line-added">  32 #include &lt;wtf/Scope.h&gt;</span>
  33 #include &lt;wtf/SetForScope.h&gt;
  34 #include &lt;wtf/StringPrintStream.h&gt;
  35 
  36 #define updateErrorMessage(shouldPrintToken, ...) do {\
  37     propagateError(); \
  38     logError(shouldPrintToken, __VA_ARGS__); \
  39 } while (0)
  40 
  41 #define propagateError() do { if (UNLIKELY(hasError())) return 0; } while (0)
  42 #define internalFailWithMessage(shouldPrintToken, ...) do { updateErrorMessage(shouldPrintToken, __VA_ARGS__); return 0; } while (0)
  43 #define handleErrorToken() do { if (m_token.m_type == EOFTOK || m_token.m_type &amp; ErrorTokenFlag) { failDueToUnexpectedToken(); } } while (0)
  44 #define failWithMessage(...) do { { handleErrorToken(); updateErrorMessage(true, __VA_ARGS__); } return 0; } while (0)
  45 #define failWithStackOverflow() do { updateErrorMessage(false, &quot;Stack exhausted&quot;); m_hasStackOverflow = true; return 0; } while (0)
  46 #define failIfFalse(cond, ...) do { if (!(cond)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  47 #define failIfTrue(cond, ...) do { if (cond) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  48 #define failIfTrueIfStrict(cond, ...) do { if ((cond) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  49 #define failIfFalseIfStrict(cond, ...) do { if ((!(cond)) &amp;&amp; strictMode()) internalFailWithMessage(false, __VA_ARGS__); } while (0)
  50 #define consumeOrFail(tokenType, ...) do { if (!consume(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  51 #define consumeOrFailWithFlags(tokenType, flags, ...) do { if (!consume(tokenType, flags)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
  52 #define matchOrFail(tokenType, ...) do { if (!match(tokenType)) { handleErrorToken(); internalFailWithMessage(true, __VA_ARGS__); } } while (0)
</pre>
<hr />
<pre>
 110     StringPrintStream stream;
 111     printUnexpectedTokenText(stream);
 112     setErrorMessage(stream.toStringWithLatin1Fallback());
 113 }
 114 
 115 template &lt;typename LexerType&gt; template &lt;typename... Args&gt;
 116 void Parser&lt;LexerType&gt;::logError(bool shouldPrintToken, Args&amp;&amp;... args)
 117 {
 118     if (hasError())
 119         return;
 120     StringPrintStream stream;
 121     if (shouldPrintToken) {
 122         printUnexpectedTokenText(stream);
 123         stream.print(&quot;. &quot;);
 124     }
 125     stream.print(std::forward&lt;Args&gt;(args)..., &quot;.&quot;);
 126     setErrorMessage(stream.toStringWithLatin1Fallback());
 127 }
 128 
 129 template &lt;typename LexerType&gt;
<span class="line-modified"> 130 Parser&lt;LexerType&gt;::Parser(VM&amp; vm, const SourceCode&amp; source, JSParserBuiltinMode builtinMode, JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding, ConstructorKind defaultConstructorKindForTopLevelFunction, DerivedContextType derivedContextType, bool isEvalContext, EvalContextType evalContextType, DebuggerParseData* debuggerParseData)</span>
 131     : m_vm(vm)
 132     , m_source(&amp;source)
 133     , m_hasStackOverflow(false)
 134     , m_allowsIn(true)
 135     , m_statementDepth(0)

 136     , m_parsingBuiltin(builtinMode == JSParserBuiltinMode::Builtin)
 137     , m_scriptMode(scriptMode)
 138     , m_superBinding(superBinding)
<span class="line-modified"> 139     , m_defaultConstructorKindForTopLevelFunction(defaultConstructorKindForTopLevelFunction)</span>
 140     , m_immediateParentAllowsFunctionDeclarationInStatement(false)
 141     , m_debuggerParseData(debuggerParseData)
 142 {
 143     m_lexer = makeUnique&lt;LexerType&gt;(vm, builtinMode, scriptMode);
 144     m_lexer-&gt;setCode(source, &amp;m_parserArena);
 145     m_token.m_location.line = source.firstLine().oneBasedInt();
 146     m_token.m_location.startOffset = source.startOffset();
 147     m_token.m_location.endOffset = source.startOffset();
 148     m_token.m_location.lineStartOffset = source.startOffset();
 149     m_functionCache = vm.addSourceProviderCache(source.provider());
 150     m_expressionErrorClassifier = nullptr;
 151 
 152     ScopeRef scope = pushScope();
 153     scope-&gt;setSourceParseMode(parseMode);
 154     scope-&gt;setIsEvalContext(isEvalContext);
 155     if (isEvalContext)
 156         scope-&gt;setEvalContextType(evalContextType);
 157 
 158     if (derivedContextType == DerivedContextType::DerivedConstructorContext) {
 159         scope-&gt;setConstructorKind(ConstructorKind::Extends);
</pre>
<hr />
<pre>
 191 
 192 private:
 193     ScopeRef m_scope;
 194     bool m_oldValue;
 195 };
 196 
 197 struct DepthManager : private SetForScope&lt;int&gt; {
 198 public:
 199     DepthManager(int* depth)
 200         : SetForScope&lt;int&gt;(*depth, *depth)
 201     {
 202     }
 203 };
 204 
 205 template &lt;typename LexerType&gt;
 206 Parser&lt;LexerType&gt;::~Parser()
 207 {
 208 }
 209 
 210 template &lt;typename LexerType&gt;
<span class="line-modified"> 211 Expected&lt;typename Parser&lt;LexerType&gt;::ParseInnerResult, String&gt; Parser&lt;LexerType&gt;::parseInner(const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
 212 {


 213     ASTBuilder context(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, const_cast&lt;SourceCode*&gt;(m_source));
 214     ScopeRef scope = currentScope();
 215     scope-&gt;setIsLexicalScope();
 216     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Body);
 217 
<span class="line-added"> 218     FunctionParameters* parameters = nullptr;</span>
 219     bool isArrowFunctionBodyExpression = parseMode == SourceParseMode::AsyncArrowFunctionBodyMode &amp;&amp; !match(OPENBRACE);
 220     if (m_lexer-&gt;isReparsingFunction()) {
 221         ParserFunctionInfo&lt;ASTBuilder&gt; functionInfo;
 222         if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
<span class="line-modified"> 223             parameters = createGeneratorParameters(context, functionInfo.parameterCount);</span>
<span class="line-added"> 224         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode)</span>
<span class="line-added"> 225             parameters = context.createFormalParameterList();</span>
 226         else
<span class="line-modified"> 227             parameters = parseFunctionParameters(context, parseMode, functionInfo);</span>
 228 
 229         if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !hasError()) {
 230             // The only way we could have an error wile reparsing is if we run out of stack space.
 231             RELEASE_ASSERT(match(ARROWFUNCTION));
 232             next();
 233             isArrowFunctionBodyExpression = !match(OPENBRACE);
 234         }
 235     }
 236 
 237     if (!calleeName.isNull())
 238         scope-&gt;declareCallee(&amp;calleeName);
 239 
 240     if (m_lexer-&gt;isReparsingFunction())
 241         m_statementDepth--;
 242 
 243     SourceElements* sourceElements = nullptr;
 244     // The only way we can error this early is if we reparse a function and we run out of stack space.
 245     if (!hasError()) {
 246         if (isAsyncFunctionWrapperParseMode(parseMode))
 247             sourceElements = parseAsyncFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 248         else if (isArrowFunctionBodyExpression)
 249             sourceElements = parseArrowFunctionSingleExpressionBodySourceElements(context);
 250         else if (isModuleParseMode(parseMode))
 251             sourceElements = parseModuleSourceElements(context, parseMode);
 252         else if (isGeneratorWrapperParseMode(parseMode))
 253             sourceElements = parseGeneratorFunctionSourceElements(context, calleeName, CheckForStrictMode);
 254         else if (isAsyncGeneratorWrapperParseMode(parseMode))
 255             sourceElements = parseAsyncGeneratorFunctionSourceElements(context, parseMode, isArrowFunctionBodyExpression, CheckForStrictMode);
 256         else if (parsingContext == ParsingContext::FunctionConstructor)
 257             sourceElements = parseSingleFunction(context, functionConstructorParametersEndPosition);
<span class="line-modified"> 258         else if (parseMode == SourceParseMode::InstanceFieldInitializerMode) {</span>
<span class="line-added"> 259             ASSERT(instanceFieldLocations &amp;&amp; !instanceFieldLocations-&gt;isEmpty());</span>
<span class="line-added"> 260             sourceElements = parseInstanceFieldInitializerSourceElements(context, *instanceFieldLocations);</span>
<span class="line-added"> 261         } else</span>
 262             sourceElements = parseSourceElements(context, CheckForStrictMode);
 263     }
 264 
 265     bool validEnding = consume(EOFTOK);
<span class="line-modified"> 266     if (!sourceElements || !validEnding)</span>
<span class="line-modified"> 267         return makeUnexpected(hasError() ? m_errorMessage : &quot;Parser error&quot;_s);</span>




 268 
 269     IdentifierSet capturedVariables;
 270     UniquedStringImplPtrSet sloppyModeHoistedFunctions;
 271     scope-&gt;getSloppyModeHoistedFunctions(sloppyModeHoistedFunctions);
 272     scope-&gt;getCapturedVars(capturedVariables);
 273 
 274     VariableEnvironment&amp; varDeclarations = scope-&gt;declaredVariables();
 275     for (auto&amp; entry : capturedVariables)
 276         varDeclarations.markVariableAsCaptured(entry);
 277 
 278     if (isGeneratorWrapperParseMode(parseMode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(parseMode)) {
 279         if (scope-&gt;usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 280             context.propagateArgumentsUse();
 281     }
 282 
 283     CodeFeatures features = context.features();
 284     if (scope-&gt;strictMode())
 285         features |= StrictModeFeature;
 286     if (scope-&gt;shadowsArguments())
 287         features |= ShadowsArgumentsFeature;
 288     if (m_seenTaggedTemplate)
 289         features |= NoEvalCacheFeature;
 290 
<span class="line-modified"> 291 #if ASSERT_ENABLED</span>
 292     if (m_parsingBuiltin &amp;&amp; isProgramParseMode(parseMode)) {
 293         VariableEnvironment&amp; lexicalVariables = scope-&gt;lexicalVariables();
 294         const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates = scope-&gt;closedVariableCandidates();
 295         for (UniquedStringImpl* candidate : closedVariableCandidates) {
 296             // FIXME: We allow async to leak because it appearing as a closed variable is a side effect of trying to parse async arrow functions.
 297             if (!lexicalVariables.contains(candidate) &amp;&amp; !varDeclarations.contains(candidate) &amp;&amp; !candidate-&gt;isSymbol() &amp;&amp; candidate != m_vm.propertyNames-&gt;async.impl()) {
 298                 dataLog(&quot;Bad global capture in builtin: &#39;&quot;, candidate, &quot;&#39;\n&quot;);
 299                 dataLog(m_source-&gt;view());
 300                 CRASH();
 301             }
 302         }
 303     }
<span class="line-modified"> 304 #endif // ASSERT_ENABLED</span>

 305 
<span class="line-modified"> 306     return ParseInnerResult { parameters, sourceElements, scope-&gt;takeFunctionDeclarations(), WTFMove(varDeclarations), WTFMove(sloppyModeHoistedFunctions), features, context.numConstants() };</span>












 307 }
 308 
 309 template &lt;typename LexerType&gt;
<span class="line-modified"> 310 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::isArrowFunctionParameters(TreeBuilder&amp; context)</span>
 311 {
 312     if (match(OPENPAREN)) {
<span class="line-modified"> 313         SavePoint saveArrowFunctionPoint = createSavePoint(context);</span>
 314         next();
 315         bool isArrowFunction = false;
 316         if (match(CLOSEPAREN)) {
 317             next();
 318             isArrowFunction = match(ARROWFUNCTION);
 319         } else {
 320             SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 321             // We make fake scope, otherwise parseFormalParameters will add variable to current scope that lead to errors
 322             AutoPopScopeRef fakeScope(this, pushScope());
 323             fakeScope-&gt;setSourceParseMode(SourceParseMode::ArrowFunctionMode);
 324 
 325             unsigned parametersCount = 0;
 326             bool isArrowFunctionParameterList = true;
 327             bool isMethod = false;
 328             isArrowFunction = parseFormalParameters(syntaxChecker, syntaxChecker.createFormalParameterList(), isArrowFunctionParameterList, isMethod, parametersCount) &amp;&amp; consume(CLOSEPAREN) &amp;&amp; match(ARROWFUNCTION);
 329             propagateError();
 330             popScope(fakeScope, syntaxChecker.NeedsFreeVariableInfo);
 331         }
<span class="line-modified"> 332         restoreSavePoint(context, saveArrowFunctionPoint);</span>
 333         return isArrowFunction;
 334     }
 335 
 336     if (matchSpecIdentifier()) {
<span class="line-modified"> 337         semanticFailIfTrue(!m_parserState.allowAwait &amp;&amp; match(AWAIT), &quot;Cannot use &#39;await&#39; as a parameter name in an async function&quot;);</span>
<span class="line-added"> 338         SavePoint saveArrowFunctionPoint = createSavePoint(context);</span>
 339         next();
 340         bool isArrowFunction = match(ARROWFUNCTION);
<span class="line-modified"> 341         restoreSavePoint(context, saveArrowFunctionPoint);</span>
 342         return isArrowFunction;
 343     }
 344 
 345     return false;
 346 }
 347 
 348 template &lt;typename LexerType&gt;
 349 bool Parser&lt;LexerType&gt;::allowAutomaticSemicolon()
 350 {
 351     return match(CLOSEBRACE) || match(EOFTOK) || m_lexer-&gt;hasLineTerminatorBeforeToken();
 352 }
 353 
 354 template &lt;typename LexerType&gt;
 355 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseSourceElements(TreeBuilder&amp; context, SourceElementsMode mode)
 356 {
 357     const unsigned lengthOfUseStrictLiteral = 12; // &quot;use strict&quot;.length
 358     TreeSourceElements sourceElements = context.createSourceElements();
 359     const Identifier* directive = 0;
 360     unsigned directiveLiteralLength = 0;
<span class="line-modified"> 361     auto savePoint = createSavePoint(context);</span>
 362     bool shouldCheckForUseStrict = mode == CheckForStrictMode;
 363 
 364     while (TreeStatement statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength)) {
 365         if (shouldCheckForUseStrict) {
 366             if (directive) {
 367                 // &quot;use strict&quot; must be the exact literal without escape sequences or line continuation.
 368                 if (directiveLiteralLength == lengthOfUseStrictLiteral &amp;&amp; m_vm.propertyNames-&gt;useStrictIdentifier == *directive) {
 369                     setStrictMode();
 370                     shouldCheckForUseStrict = false; // We saw &quot;use strict&quot;, there is no need to keep checking for it.
 371                     if (!isValidStrictMode()) {
 372                         if (m_parserState.lastFunctionName) {
 373                             if (m_vm.propertyNames-&gt;arguments == *m_parserState.lastFunctionName)
 374                                 semanticFail(&quot;Cannot name a function &#39;arguments&#39; in strict mode&quot;);
 375                             if (m_vm.propertyNames-&gt;eval == *m_parserState.lastFunctionName)
 376                                 semanticFail(&quot;Cannot name a function &#39;eval&#39; in strict mode&quot;);
 377                         }
 378                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;arguments))
 379                             semanticFail(&quot;Cannot declare a variable named &#39;arguments&#39; in strict mode&quot;);
 380                         if (hasDeclaredVariable(m_vm.propertyNames-&gt;eval))
 381                             semanticFail(&quot;Cannot declare a variable named &#39;eval&#39; in strict mode&quot;);
 382                         semanticFailIfTrue(currentScope()-&gt;hasNonSimpleParameterList(), &quot;&#39;use strict&#39; directive not allowed inside a function with a non-simple parameter list&quot;);
 383                         semanticFailIfFalse(isValidStrictMode(), &quot;Invalid parameters or function name in strict mode&quot;);
 384                     }
 385                     // Since strict mode is changed, restoring lexer state by calling next() may cause errors.
<span class="line-modified"> 386                     restoreSavePoint(context, savePoint);</span>
 387                     propagateError();
 388                     continue;
 389                 }
 390 
 391                 // We saw a directive, but it wasn&#39;t &quot;use strict&quot;. We reset our state to
 392                 // see if the next statement we parse is also a directive.
 393                 directive = nullptr;
 394             } else {
 395                 // We saw a statement that wasn&#39;t in the form of a directive. The spec says that &quot;use strict&quot;
 396                 // is only allowed as the first statement, or after a sequence of directives before it, but
 397                 // not after non-directive statements.
 398                 shouldCheckForUseStrict = false;
 399             }
 400         }
 401         context.appendStatement(sourceElements, statement);
 402     }
 403 
 404     propagateError();
 405     return sourceElements;
 406 }
 407 
 408 template &lt;typename LexerType&gt;
 409 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseModuleSourceElements(TreeBuilder&amp; context, SourceParseMode parseMode)
 410 {
 411     TreeSourceElements sourceElements = context.createSourceElements();
 412     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
 413 
 414     while (true) {
 415         TreeStatement statement = 0;
 416         switch (m_token.m_type) {
<span class="line-modified"> 417         case EXPORT_:</span>
 418             statement = parseExportDeclaration(context);
 419             if (statement)
 420                 recordPauseLocation(context.breakpointLocation(statement));
 421             break;
 422 
 423         case IMPORT: {
<span class="line-modified"> 424             SavePoint savePoint = createSavePoint(context);</span>
 425             next();
 426             bool isImportDeclaration = !match(OPENPAREN) &amp;&amp; !match(DOT);
<span class="line-modified"> 427             restoreSavePoint(context, savePoint);</span>
 428             if (isImportDeclaration) {
 429                 statement = parseImportDeclaration(context);
 430                 if (statement)
 431                     recordPauseLocation(context.breakpointLocation(statement));
 432                 break;
 433             }
 434 
 435             // This is `import(&quot;...&quot;)` call or `import.meta` meta property case.
 436             FALLTHROUGH;
 437         }
 438 
 439         default: {
 440             const Identifier* directive = 0;
 441             unsigned directiveLiteralLength = 0;
 442             if (parseMode == SourceParseMode::ModuleAnalyzeMode) {
 443                 if (!parseStatementListItem(syntaxChecker, directive, &amp;directiveLiteralLength))
 444                     goto end;
 445                 continue;
 446             }
 447             statement = parseStatementListItem(context, directive, &amp;directiveLiteralLength);
</pre>
<hr />
<pre>
 651 template &lt;typename LexerType&gt;
 652 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseStatementListItem(TreeBuilder&amp; context, const Identifier*&amp; directive, unsigned* directiveLiteralLength)
 653 {
 654     // The grammar is documented here:
 655     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-statements
 656     DepthManager statementDepth(&amp;m_statementDepth);
 657     m_statementDepth++;
 658     failIfStackOverflow();
 659     TreeStatement result = 0;
 660     bool shouldSetEndOffset = true;
 661     bool shouldSetPauseLocation = false;
 662 
 663     switch (m_token.m_type) {
 664     case CONSTTOKEN:
 665         result = parseVariableDeclaration(context, DeclarationType::ConstDeclaration);
 666         shouldSetPauseLocation = true;
 667         break;
 668     case LET: {
 669         bool shouldParseVariableDeclaration = true;
 670         if (!strictMode()) {
<span class="line-modified"> 671             SavePoint savePoint = createSavePoint(context);</span>
 672             next();
 673             // Intentionally use `isIdentifierOrAnyContextualKeyword(m_token)` and don&#39;t use `matchSpecIdentifier()`.
 674             // We would like to fall into parseVariableDeclaration path even if &quot;yield&quot; is not treated as an Identifier.
 675             // For example, under a generator context, matchSpecIdentifier() for &quot;yield&quot; returns `false`.
 676             // But we would like to enter parseVariableDeclaration and raise an error under the context of parseVariableDeclaration
 677             // to raise consistent errors between &quot;var&quot;, &quot;const&quot; and &quot;let&quot;.
 678             if (!isIdentifierOrAnyContextualKeyword(m_token) &amp;&amp; !match(OPENBRACE) &amp;&amp; !match(OPENBRACKET))
 679                 shouldParseVariableDeclaration = false;
<span class="line-modified"> 680             restoreSavePoint(context, savePoint);</span>
 681         }
 682         if (shouldParseVariableDeclaration)
 683             result = parseVariableDeclaration(context, DeclarationType::LetDeclaration);
 684         else {
 685             bool allowFunctionDeclarationAsStatement = true;
 686             result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 687         }
 688         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 689         break;
 690     }
 691     case CLASSTOKEN:
 692         result = parseClassDeclaration(context);
 693         break;
 694     case FUNCTION:
 695         result = parseFunctionDeclaration(context);
 696         break;
 697     case IDENT:
 698         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
 699             // Eagerly parse as AsyncFunctionDeclaration. This is the uncommon case,
 700             // but could be mistakenly parsed as an AsyncFunctionExpression.
<span class="line-modified"> 701             SavePoint savePoint = createSavePoint(context);</span>
 702             next();
 703             if (UNLIKELY(match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())) {
 704                 result = parseAsyncFunctionDeclaration(context);
 705                 break;
 706             }
<span class="line-modified"> 707             restoreSavePoint(context, savePoint);</span>
 708         }
 709         FALLTHROUGH;
 710     case AWAIT:
 711     case YIELD: {
 712         // This is a convenient place to notice labeled statements
 713         // (even though we also parse them as normal statements)
 714         // because we allow the following type of code in sloppy mode:
 715         // ``` function foo() { label: function bar() { } } ```
 716         bool allowFunctionDeclarationAsStatement = true;
 717         result = parseExpressionOrLabelStatement(context, allowFunctionDeclarationAsStatement);
 718         shouldSetPauseLocation = !context.shouldSkipPauseLocation(result);
 719         break;
 720     }
 721     default:
 722         m_statementDepth--; // parseStatement() increments the depth.
 723         result = parseStatement(context, directive, directiveLiteralLength);
 724         shouldSetEndOffset = false;
 725         break;
 726     }
 727 
</pre>
<hr />
<pre>
 910         semanticFailIfTrue(isEvalOrArguments(&amp;name), &quot;Cannot destructure to a parameter name &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 911         if (m_parserState.lastFunctionName &amp;&amp; name == *m_parserState.lastFunctionName)
 912             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; as it shadows the name of a strict mode function&quot;);
 913         semanticFailureDueToKeyword(&quot;parameter name&quot;);
 914         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; hasDeclaredParameter(name))
 915             semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode as it has already been declared&quot;);
 916         semanticFail(&quot;Cannot declare a parameter named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 917     }
 918     if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration) {
 919         // It&#39;s not always an error to define a duplicate parameter.
 920         // It&#39;s only an error when there are default parameter values or destructuring parameters.
 921         // We note this value now so we can check it later.
 922         if (duplicateIdentifier)
 923             *duplicateIdentifier = &amp;name;
 924     }
 925 
 926     return true;
 927 }
 928 
 929 template &lt;typename LexerType&gt;
<span class="line-modified"> 930 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::createBindingPattern(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier&amp; name, const JSToken&amp; token, AssignmentContext bindingContext, const Identifier** duplicateIdentifier)</span>
 931 {
 932     ASSERT(!name.isNull());
 933 
 934     ASSERT(name.impl()-&gt;isAtom() || name.impl()-&gt;isSymbol());
 935 
 936     switch (kind) {
 937     case DestructuringKind::DestructureToVariables: {
 938         DeclarationResultMask declarationResult = declareVariable(&amp;name);
 939         failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot declare a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
 940         if (declarationResult &amp; DeclarationResult::InvalidDuplicateDeclaration)
 941             internalFailWithMessage(false, &quot;Cannot declare a var variable that shadows a let/const/class variable: &#39;&quot;, name.impl(), &quot;&#39;&quot;);
 942         break;
 943     }
 944 
 945     case DestructuringKind::DestructureToLet:
 946     case DestructuringKind::DestructureToConst:
 947     case DestructuringKind::DestructureToCatchParameters: {
 948         DeclarationResultMask declarationResult = declareVariable(&amp;name, kind == DestructuringKind::DestructureToConst ? DeclarationType::ConstDeclaration : DeclarationType::LetDeclaration);
 949         if (declarationResult != DeclarationResult::Valid) {
 950             failIfTrueIfStrict(declarationResult &amp; DeclarationResult::InvalidStrictMode, &quot;Cannot destructure to a variable named &#39;&quot;, name.impl(), &quot;&#39; in strict mode&quot;);
</pre>
<hr />
<pre>
1026         reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1027         semanticFail(&quot;Invalid destructuring assignment target&quot;);
1028     }
1029 
1030     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1031         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1032         if (isEvalOrArguments &amp;&amp; strictMode())
1033             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1034         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1035     }
1036 
1037     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1038 }
1039 
1040 template &lt;typename LexerType&gt;
1041 template &lt;class TreeBuilder&gt; TreeDestructuringPattern Parser&lt;LexerType&gt;::parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind kind, ExportType exportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth)
1042 {
1043     TreeDestructuringPattern assignmentTarget = 0;
1044 
1045     if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">1046         SavePoint savePoint = createSavePoint(context);</span>
1047         assignmentTarget = parseDestructuringPattern(context, kind, exportType, duplicateIdentifier, hasDestructuringPattern, bindingContext, depth);
1048         if (assignmentTarget &amp;&amp; !match(DOT) &amp;&amp; !match(OPENBRACKET) &amp;&amp; !match(OPENPAREN) &amp;&amp; !match(BACKQUOTE))
1049             return assignmentTarget;
<span class="line-modified">1050         restoreSavePoint(context, savePoint);</span>
1051     }
1052 
1053     JSTextPosition startPosition = tokenStartPosition();
1054     auto element = parseMemberExpression(context);
1055 
1056     semanticFailIfFalse(element &amp;&amp; context.isAssignmentLocation(element), &quot;Invalid destructuring assignment target&quot;);
1057 
1058     if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(element)) {
1059         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier || m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier;
1060         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
1061     }
1062 
1063     return createAssignmentElement(context, element, startPosition, lastTokenEndPosition());
1064 }
1065 
1066 static const char* destructuringKindToVariableKindName(DestructuringKind kind)
1067 {
1068     switch (kind) {
1069     case DestructuringKind::DestructureToLet:
1070     case DestructuringKind::DestructureToConst:
</pre>
<hr />
<pre>
1205                     if (kind == DestructuringKind::DestructureToExpressions) {
1206                         bool isEvalOrArguments = m_vm.propertyNames-&gt;eval == *propertyName || m_vm.propertyNames-&gt;arguments == *propertyName;
1207                         if (isEvalOrArguments &amp;&amp; strictMode())
1208                             reclassifyExpressionError(ErrorIndicatesPattern, ErrorIndicatesNothing);
1209                         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, propertyName-&gt;impl(), &quot;&#39; in strict mode&quot;);
1210                     }
1211                     semanticFailIfTrue(isDisallowedIdentifierAwait(identifierToken), &quot;Cannot use &#39;await&#39; as a &quot;, destructuringKindToVariableKindName(kind), &quot; &quot;, disallowedIdentifierAwaitReason());
1212                     innerPattern = createBindingPattern(context, kind, exportType, *propertyName, identifierToken, bindingContext, duplicateIdentifier);
1213                 }
1214             } else {
1215                 JSTokenType tokenType = m_token.m_type;
1216                 switch (m_token.m_type) {
1217                 case DOUBLE:
1218                 case INTEGER:
1219                     propertyName = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
1220                     break;
1221                 case STRING:
1222                     propertyName = m_token.m_data.ident;
1223                     wasString = true;
1224                     break;
<span class="line-added">1225                 case BIGINT:</span>
<span class="line-added">1226                     propertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">1227                     break;</span>
1228                 case OPENBRACKET:
1229                     next();
1230                     propertyExpression = parseAssignmentExpression(context);
1231                     failIfFalse(propertyExpression, &quot;Cannot parse computed property name&quot;);
1232                     matchOrFail(CLOSEBRACKET, &quot;Expected &#39;]&#39; to end end a computed property name&quot;);
1233                     break;
1234                 default:
1235                     if (m_token.m_type != RESERVED &amp;&amp; m_token.m_type != RESERVED_IF_STRICT &amp;&amp; !(m_token.m_type &amp; KeywordTokenFlag)) {
1236                         if (kind == DestructuringKind::DestructureToExpressions)
1237                             return 0;
1238                         failWithMessage(&quot;Expected a property name&quot;);
1239                     }
1240                     propertyName = m_token.m_data.ident;
1241                     break;
1242                 }
1243                 next();
1244                 if (!consume(COLON)) {
1245                     if (kind == DestructuringKind::DestructureToExpressions)
1246                         return 0;
1247                     semanticFailIfTrue(tokenType == RESERVED, &quot;Cannot use abbreviated destructuring syntax for reserved name &#39;&quot;, propertyName-&gt;impl(), &quot;&#39;&quot;);
</pre>
<hr />
<pre>
1418         TreeStatement statement = parseStatement(context, unused);
1419         endLoop();
1420         failIfFalse(statement, &quot;Expected statement as body of for-&quot;, isOfEnumeration ? &quot;of&quot; : &quot;in&quot;, &quot; statement&quot;);
1421         gatherLexicalVariablesIfNecessary();
1422         TreeStatement result;
1423         if (isOfEnumeration)
1424             result = context.createForOfLoop(isAwaitFor, location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1425         else {
1426             ASSERT(!isAwaitFor);
1427             if (isVarDeclaraton &amp;&amp; forInInitializer)
1428                 result = context.createForInLoop(location, decls, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1429             else
1430                 result = context.createForInLoop(location, forInTarget, expr, statement, declLocation, declsStart, inLocation, exprEnd, startLine, endLine, *lexicalVariables);
1431         }
1432         popLexicalScopeIfNecessary();
1433         return result;
1434     }
1435 
1436     if (!match(SEMICOLON)) {
1437         if (match(OPENBRACE) || match(OPENBRACKET)) {
<span class="line-modified">1438             SavePoint savePoint = createSavePoint(context);</span>
1439             declsStart = tokenStartPosition();
1440             pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::DeclarationStatement);
1441             declsEnd = lastTokenEndPosition();
1442             if (pattern &amp;&amp; (match(INTOKEN) || matchContextualKeyword(m_vm.propertyNames-&gt;of)))
1443                 goto enumerationLoop;
1444             pattern = TreeDestructuringPattern(0);
<span class="line-modified">1445             restoreSavePoint(context, savePoint);</span>
1446         }
1447         m_allowsIn = false;
1448         declsStart = tokenStartPosition();
1449         decls = parseExpression(context);
1450         declsEnd = lastTokenEndPosition();
1451         m_allowsIn = true;
1452         failIfFalse(decls, &quot;Cannot parse for loop declarations&quot;);
1453         recordPauseLocation(context.breakpointLocation(decls));
1454     }
1455 
1456     if (match(SEMICOLON)) {
1457     standardForLoop:
1458         failIfFalse(!isAwaitFor, &quot;Unexpected a &#39;;&#39; in for-await-of header&quot;);
1459         // Standard for loop
1460         if (decls)
1461             recordPauseLocation(context.breakpointLocation(decls));
1462         next();
1463         TreeExpression condition = 0;
1464         failIfTrue(forLoopConstDoesNotHaveInitializer &amp;&amp; isConstDeclaration, &quot;const variables in for loops must have initializers&quot;);
1465 
</pre>
<hr />
<pre>
2014     int start = tokenLine();
2015 
2016     TreeStatement function = 0;
2017     if (!isAsync)
2018         function = parseFunctionDeclaration(context);
2019     else
2020         function = parseAsyncFunctionDeclaration(context);
2021     propagateError();
2022     failIfFalse(function, &quot;Expected valid function statement after &#39;function&#39; keyword&quot;);
2023     TreeSourceElements sourceElements = context.createSourceElements();
2024     context.appendStatement(sourceElements, function);
2025     TreeStatement result = context.createBlockStatement(location, sourceElements, start, m_lastTokenEndPosition.line, currentScope()-&gt;finalizeLexicalEnvironment(), currentScope()-&gt;takeFunctionDeclarations());
2026     popScope(blockScope, TreeBuilder::NeedsFreeVariableInfo);
2027     return result;
2028 }
2029 
2030 template &lt;typename LexerType&gt;
2031 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement)
2032 {
2033     ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
<span class="line-modified">2034     SavePoint savePoint = createSavePoint(context);</span>
2035     next();
2036     if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
2037         const bool isAsync = true;
2038         result = parseFunctionDeclarationStatement(context, isAsync, parentAllowsFunctionDeclarationAsStatement);
2039         return true;
2040     }
<span class="line-modified">2041     restoreSavePoint(context, savePoint);</span>
2042     return false;
2043 }
2044 
2045 template &lt;typename LexerType&gt;
2046 template &lt;class TreeBuilder&gt; bool Parser&lt;LexerType&gt;::parseFormalParameters(TreeBuilder&amp; context, TreeFormalParameterList list, bool isArrowFunction, bool isMethod, unsigned&amp; parameterCount)
2047 {
2048 #define failIfDuplicateIfViolation() \
2049     if (duplicateParameter) {\
2050         semanticFailIfTrue(hasDefaultParameterValues, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with default parameter values&quot;);\
2051         semanticFailIfTrue(hasDestructuringPattern, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with destructuring parameters&quot;);\
2052         semanticFailIfTrue(isRestParameter, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in function with a rest parameter&quot;);\
2053         semanticFailIfTrue(isArrowFunction, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in an arrow function&quot;);\
2054         semanticFailIfTrue(isMethod, &quot;Duplicate parameter &#39;&quot;, duplicateParameter-&gt;impl(), &quot;&#39; not allowed in a method&quot;);\
2055     }
2056 
2057     bool hasDefaultParameterValues = false;
2058     bool hasDestructuringPattern = false;
2059     bool isRestParameter = false;
2060     const Identifier* duplicateParameter = nullptr;
2061     unsigned restParameterStart = 0;
</pre>
<hr />
<pre>
2086         failIfDuplicateIfViolation();
2087         if (isRestParameter || defaultValue || hasDestructuringPattern)
2088             currentScope()-&gt;setHasNonSimpleParameterList();
2089         context.appendParameter(list, parameter, defaultValue);
2090         if (!isRestParameter) {
2091             restParameterStart++;
2092             if (!hasDefaultParameterValues)
2093                 parameterCount++;
2094         }
2095     } while (!isRestParameter &amp;&amp; consume(COMMA));
2096 
2097     return true;
2098 #undef failIfDuplicateIfViolation
2099 }
2100 
2101 template &lt;typename LexerType&gt;
2102 template &lt;class TreeBuilder&gt; TreeFunctionBody Parser&lt;LexerType&gt;::parseFunctionBody(
2103     TreeBuilder&amp; context, SyntaxChecker&amp; syntaxChecker, const JSTokenLocation&amp; startLocation, int startColumn, int functionKeywordStart, int functionNameStart, int parametersStart,
2104     ConstructorKind constructorKind, SuperBinding superBinding, FunctionBodyType bodyType, unsigned parameterCount, SourceParseMode parseMode)
2105 {
<span class="line-added">2106     SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, bodyType == StandardFunctionBodyBlock ? false : m_parserState.isParsingClassFieldInitializer);</span>
2107     bool isArrowFunctionBodyExpression = bodyType == ArrowFunctionBodyExpression;
2108     if (!isArrowFunctionBodyExpression) {
2109         next();
2110         if (match(CLOSEBRACE)) {
2111             unsigned endColumn = tokenColumn();
2112             SuperBinding functionSuperBinding = adjustSuperBindingForBaseConstructor(constructorKind, superBinding, currentScope());
2113             return context.createFunctionMetadata(startLocation, tokenLocation(), startColumn, endColumn, functionKeywordStart, functionNameStart, parametersStart, strictMode(), constructorKind, functionSuperBinding, parameterCount, parseMode, isArrowFunctionBodyExpression);
2114         }
2115     }
2116 
2117     DepthManager statementDepth(&amp;m_statementDepth);
2118     m_statementDepth = 0;
2119     if (bodyType == ArrowFunctionBodyExpression) {
2120         if (m_debuggerParseData)
2121             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(context), &quot;Cannot parse body of this arrow function&quot;);
2122         else
2123             failIfFalse(parseArrowFunctionSingleExpressionBodySourceElements(syntaxChecker), &quot;Cannot parse body of this arrow function&quot;);
2124     } else {
2125         if (m_debuggerParseData)
2126             failIfFalse(parseSourceElements(context, CheckForStrictMode), bodyType == StandardFunctionBodyBlock ? &quot;Cannot parse body of this function&quot; : &quot;Cannot parse body of this arrow function&quot;);
</pre>
<hr />
<pre>
2139     case SourceParseMode::SetterMode:
2140     case SourceParseMode::NormalFunctionMode:
2141     case SourceParseMode::MethodMode:
2142     case SourceParseMode::GeneratorBodyMode:
2143     case SourceParseMode::GeneratorWrapperFunctionMode:
2144     case SourceParseMode::GeneratorWrapperMethodMode:
2145         return &quot;a &quot;;
2146     case SourceParseMode::ArrowFunctionMode:
2147     case SourceParseMode::AsyncFunctionMode:
2148     case SourceParseMode::AsyncFunctionBodyMode:
2149     case SourceParseMode::AsyncMethodMode:
2150     case SourceParseMode::AsyncArrowFunctionBodyMode:
2151     case SourceParseMode::AsyncArrowFunctionMode:
2152     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2153     case SourceParseMode::AsyncGeneratorBodyMode:
2154     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2155         return &quot;an &quot;;
2156     case SourceParseMode::ProgramMode:
2157     case SourceParseMode::ModuleAnalyzeMode:
2158     case SourceParseMode::ModuleEvaluateMode:
<span class="line-added">2159     case SourceParseMode::InstanceFieldInitializerMode:</span>
2160         RELEASE_ASSERT_NOT_REACHED();
2161         return &quot;&quot;;
2162     }
2163     RELEASE_ASSERT_NOT_REACHED();
2164     return nullptr;
2165 }
2166 
2167 static const char* stringForFunctionMode(SourceParseMode mode)
2168 {
2169     switch (mode) {
2170     case SourceParseMode::GetterMode:
2171         return &quot;getter&quot;;
2172     case SourceParseMode::SetterMode:
2173         return &quot;setter&quot;;
2174     case SourceParseMode::NormalFunctionMode:
2175         return &quot;function&quot;;
2176     case SourceParseMode::MethodMode:
2177         return &quot;method&quot;;
2178     case SourceParseMode::GeneratorBodyMode:
2179         return &quot;generator&quot;;
</pre>
<hr />
<pre>
2181     case SourceParseMode::GeneratorWrapperMethodMode:
2182         return &quot;generator function&quot;;
2183     case SourceParseMode::ArrowFunctionMode:
2184         return &quot;arrow function&quot;;
2185     case SourceParseMode::AsyncFunctionMode:
2186     case SourceParseMode::AsyncFunctionBodyMode:
2187         return &quot;async function&quot;;
2188     case SourceParseMode::AsyncMethodMode:
2189         return &quot;async method&quot;;
2190     case SourceParseMode::AsyncArrowFunctionBodyMode:
2191     case SourceParseMode::AsyncArrowFunctionMode:
2192         return &quot;async arrow function&quot;;
2193     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2194     case SourceParseMode::AsyncGeneratorBodyMode:
2195         return &quot;async generator function&quot;;
2196     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2197         return &quot;async generator method&quot;;
2198     case SourceParseMode::ProgramMode:
2199     case SourceParseMode::ModuleAnalyzeMode:
2200     case SourceParseMode::ModuleEvaluateMode:
<span class="line-added">2201     case SourceParseMode::InstanceFieldInitializerMode:</span>
2202         RELEASE_ASSERT_NOT_REACHED();
2203         return &quot;&quot;;
2204     }
2205     RELEASE_ASSERT_NOT_REACHED();
2206     return nullptr;
2207 }
2208 
2209 template &lt;typename LexerType&gt; template &lt;class TreeBuilder, class FunctionInfoType&gt; typename TreeBuilder::FormalParameterList Parser&lt;LexerType&gt;::parseFunctionParameters(TreeBuilder&amp; context, SourceParseMode mode, FunctionInfoType&amp; functionInfo)
2210 {
2211     RELEASE_ASSERT(!(SourceParseModeSet(SourceParseMode::ProgramMode, SourceParseMode::ModuleAnalyzeMode, SourceParseMode::ModuleEvaluateMode).contains(mode)));
2212     TreeFormalParameterList parameterList = context.createFormalParameterList();
2213     SetForScope&lt;FunctionParsePhase&gt; functionParsePhasePoisoner(m_parserState.functionParsePhase, FunctionParsePhase::Parameters);
2214 
2215     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2216         if (!matchSpecIdentifier() &amp;&amp; !match(OPENPAREN)) {
2217             semanticFailureDueToKeyword(stringForFunctionMode(mode), &quot; name&quot;);
2218             failWithMessage(&quot;Expected an arrow function input parameter&quot;);
2219         } else {
2220             if (match(OPENPAREN)) {
2221                 next();
</pre>
<hr />
<pre>
2407     };
2408 
2409     SyntaxChecker syntaxChecker(const_cast&lt;VM&amp;&gt;(m_vm), m_lexer.get());
2410 
2411     if (UNLIKELY((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(mode)))) {
2412         startLocation = tokenLocation();
2413         functionInfo.startLine = tokenLine();
2414         startColumn = tokenColumn();
2415 
2416         parametersStart = m_token.m_location.startOffset;
2417         functionInfo.startOffset = parametersStart;
2418         functionInfo.parametersStartColumn = startColumn;
2419 
2420         if (loadCachedFunction())
2421             return true;
2422 
2423         {
2424             // Parse formal parameters with [+Yield] parameterization, in order to ban YieldExpressions
2425             // in ArrowFormalParameters, per ES6 #sec-arrow-function-definitions-static-semantics-early-errors.
2426             Scope::MaybeParseAsGeneratorForScope parseAsGenerator(functionScope, parentScope-&gt;isGenerator());
<span class="line-modified">2427             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !parentScope-&gt;isAsyncFunction() &amp;&amp; !isAsyncFunctionParseMode(mode));</span>
2428             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2429             propagateError();
2430         }
2431 
2432         matchOrFail(ARROWFUNCTION, &quot;Expected a &#39;=&gt;&#39; after arrow function parameter declaration&quot;);
2433 
2434         if (m_lexer-&gt;hasLineTerminatorBeforeToken())
2435             failDueToUnexpectedToken();
2436 
2437         ASSERT(constructorKind == ConstructorKind::None);
2438 
2439         // Check if arrow body start with {. If it true it mean that arrow function is Fat arrow function
2440         // and we need use common approach to parse function body
2441         next();
2442         functionBodyType = match(OPENBRACE) ? ArrowFunctionBodyBlock : ArrowFunctionBodyExpression;
2443     } else {
2444         // http://ecma-international.org/ecma-262/6.0/#sec-function-definitions
2445         // FunctionExpression :
2446         //     function BindingIdentifieropt ( FormalParameters ) { FunctionBody }
2447         //
</pre>
<hr />
<pre>
2495         parametersStart = m_token.m_location.startOffset;
2496         functionInfo.startOffset = parametersStart;
2497 
2498         if (loadCachedFunction())
2499             return true;
2500         {
2501             SetForScope&lt;bool&gt; overrideAllowAwait(m_parserState.allowAwait, !isAsyncFunctionParseMode(mode));
2502             parseFunctionParameters(syntaxChecker, mode, functionInfo);
2503             propagateError();
2504         }
2505 
2506         matchOrFail(OPENBRACE, &quot;Expected an opening &#39;{&#39; at the start of a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2507 
2508         // If the code is invoked from function constructor, we need to ensure that parameters are only composed by the string offered as parameters.
2509         if (UNLIKELY(functionConstructorParametersEndPosition))
2510             semanticFailIfFalse(lastTokenEndPosition().offset == *functionConstructorParametersEndPosition, &quot;Parameters should match arguments offered as parameters in Function constructor&quot;);
2511 
2512         // BytecodeGenerator emits code to throw TypeError when a class constructor is &quot;call&quot;ed.
2513         // Set ConstructorKind to None for non-constructor methods of classes.
2514 
<span class="line-modified">2515         if (parentScope-&gt;isGlobalCodeScope() &amp;&amp; m_defaultConstructorKindForTopLevelFunction != ConstructorKind::None) {</span>
<span class="line-modified">2516             constructorKind = m_defaultConstructorKindForTopLevelFunction;</span>
<span class="line-modified">2517             expectedSuperBinding = m_defaultConstructorKindForTopLevelFunction == ConstructorKind::Extends ? SuperBinding::Needed : SuperBinding::NotNeeded;</span>
2518         }
2519 
2520         functionBodyType = StandardFunctionBodyBlock;
2521     }
2522 
2523     functionScope-&gt;setConstructorKind(constructorKind);
2524     functionScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2525 
2526     m_parserState.lastFunctionName = lastFunctionName;
<span class="line-modified">2527     ParserState oldState = internalSaveParserState(context);</span>
2528 
2529     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
2530     // This loop collects the set of capture candidates that aren&#39;t
2531     // part of the set of this function&#39;s declared parameters. We will
2532     // figure out which parameters are captured for this function when
2533     // we actually generate code for it. For now, we just propagate to
2534     // our parent scopes which variables we might have closed over that
2535     // belong to them. This is necessary for correctness when using
2536     // the source provider cache because we can&#39;t close over a variable
2537     // that we don&#39;t claim to close over. The source provider cache must
2538     // know this information to properly cache this function.
2539     // This might work itself out nicer if we declared a different
2540     // Scope struct for the parameters (because they are indeed implemented
2541     // as their own scope).
2542     UniquedStringImplPtrSet nonLocalCapturesFromParameterExpressions;
2543     functionScope-&gt;forEachUsedVariable([&amp;] (UniquedStringImpl* impl) {
2544         if (!functionScope-&gt;hasDeclaredParameter(impl)) {
2545             nonLocalCapturesFromParameterExpressions.add(impl);
2546             if (TreeBuilder::NeedsFreeVariableInfo)
2547                 parentScope-&gt;addClosedVariableCandidateUnconditionally(impl);
</pre>
<hr />
<pre>
2560 
2561         generatorBodyScope-&gt;setSourceParseMode(innerParseMode);
2562         generatorBodyScope-&gt;setConstructorKind(ConstructorKind::None);
2563         generatorBodyScope-&gt;setExpectedSuperBinding(expectedSuperBinding);
2564 
2565         // Disallow &#39;use strict&#39; directives in the implicit inner function if
2566         // needed.
2567         if (functionScope-&gt;hasNonSimpleParameterList())
2568             generatorBodyScope-&gt;setHasNonSimpleParameterList();
2569 
2570         functionInfo.body = performParsingFunctionBody();
2571 
2572         // When a generator has a &quot;use strict&quot; directive, a generator function wrapping it should be strict mode.
2573         if  (generatorBodyScope-&gt;strictMode())
2574             functionScope-&gt;setStrictMode();
2575 
2576         popScope(generatorBodyScope, TreeBuilder::NeedsFreeVariableInfo);
2577     } else
2578         functionInfo.body = performParsingFunctionBody();
2579 
<span class="line-modified">2580     restoreParserState(context, oldState);</span>
2581     failIfFalse(functionInfo.body, &quot;Cannot parse the body of this &quot;, stringForFunctionMode(mode));
2582     context.setEndOffset(functionInfo.body, m_lexer-&gt;currentOffset());
2583     if (functionScope-&gt;strictMode() &amp;&amp; requirements != FunctionNameRequirements::Unnamed) {
2584         ASSERT(functionInfo.name);
2585         RELEASE_ASSERT(SourceParseModeSet(SourceParseMode::NormalFunctionMode, SourceParseMode::MethodMode, SourceParseMode::ArrowFunctionMode, SourceParseMode::GeneratorBodyMode, SourceParseMode::GeneratorWrapperFunctionMode).contains(mode) || isAsyncFunctionOrAsyncGeneratorWrapperParseMode(mode));
2586         semanticFailIfTrue(m_vm.propertyNames-&gt;arguments == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2587         semanticFailIfTrue(m_vm.propertyNames-&gt;eval == *functionInfo.name, &quot;&#39;&quot;, functionInfo.name-&gt;impl(), &quot;&#39; is not a valid function name in strict mode&quot;);
2588     }
2589 
2590     JSTokenLocation location = JSTokenLocation(m_token.m_location);
2591     functionInfo.endOffset = m_token.m_data.offset;
2592 
2593     if (functionBodyType == ArrowFunctionBodyExpression) {
2594         location = locationBeforeLastToken();
2595         functionInfo.endOffset = location.endOffset;
2596     } else {
2597         recordFunctionEntryLocation(JSTextPosition(startLocation.line, startLocation.startOffset, startLocation.lineStartOffset));
2598         recordFunctionLeaveLocation(JSTextPosition(location.line, location.startOffset, location.lineStartOffset));
2599     }
2600 
</pre>
<hr />
<pre>
2621         }
2622         functionScope-&gt;fillParametersForSourceProviderCache(parameters, nonLocalCapturesFromParameterExpressions);
2623         newInfo = SourceProviderCacheItem::create(parameters);
2624     }
2625 
2626     bool functionScopeWasStrictMode = functionScope-&gt;strictMode();
2627 
2628     popScope(functionScope, TreeBuilder::NeedsFreeVariableInfo);
2629 
2630     if (functionBodyType != ArrowFunctionBodyExpression) {
2631         matchOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a &quot;, stringForFunctionMode(mode), &quot; body&quot;);
2632         next();
2633     } else {
2634         // We need to lex the last token again because the last token is lexed under the different context because of the following possibilities.
2635         // 1. which may have different strict mode.
2636         // 2. which may not build strings for tokens.
2637         // But (1) is not possible because we do not recognize the string literal in ArrowFunctionBodyExpression as directive and this is correct in terms of the spec (`value =&gt; &quot;use strict&quot;`).
2638         // So we only check TreeBuilder&#39;s type here.
2639         ASSERT_UNUSED(functionScopeWasStrictMode, functionScopeWasStrictMode == currentScope()-&gt;strictMode());
2640         if (!std::is_same&lt;TreeBuilder, SyntaxChecker&gt;::value)
<span class="line-modified">2641             lexCurrentTokenAgainUnderCurrentContext(context);</span>
2642     }
2643 
2644     if (newInfo)
2645         m_functionCache-&gt;add(functionInfo.startOffset, WTFMove(newInfo));
2646 
2647     functionInfo.endLine = m_lastTokenEndPosition.line;
2648     return true;
2649 }
2650 
2651 static NO_RETURN_DUE_TO_CRASH FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;SyntaxChecker&gt;&amp;) { RELEASE_ASSERT_NOT_REACHED(); }
2652 static FunctionMetadataNode* getMetadata(ParserFunctionInfo&lt;ASTBuilder&gt;&amp; info) { return info.body; }
2653 
2654 template &lt;typename LexerType&gt;
2655 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseFunctionDeclaration(TreeBuilder&amp; context, ExportType exportType, DeclarationDefaultContext declarationDefaultContext, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2656 {
2657     ASSERT(match(FUNCTION));
2658     JSTokenLocation location(tokenLocation());
2659     unsigned functionKeywordStart = tokenStart();
2660     next();
2661     SourceParseMode parseMode = SourceParseMode::NormalFunctionMode;
</pre>
<hr />
<pre>
2829 
2830     ASSERT_WITH_MESSAGE(requirements != FunctionNameRequirements::Unnamed, &quot;Currently, there is no caller that uses FunctionNameRequirements::Unnamed for class syntax.&quot;);
2831     ASSERT_WITH_MESSAGE(!(requirements == FunctionNameRequirements::None &amp;&amp; !info.className), &quot;When specifying FunctionNameRequirements::None, we need to initialize info.className with the default value in the caller side.&quot;);
2832     if (match(IDENT)) {
2833         info.className = m_token.m_data.ident;
2834         next();
2835         failIfTrue(classScope-&gt;declareLexicalVariable(info.className, true) &amp; DeclarationResult::InvalidStrictMode, &quot;&#39;&quot;, info.className-&gt;impl(), &quot;&#39; is not a valid class name&quot;);
2836     } else if (requirements == FunctionNameRequirements::Named) {
2837         if (match(OPENBRACE))
2838             semanticFail(&quot;Class statements must have a name&quot;);
2839         semanticFailureDueToKeyword(&quot;class name&quot;);
2840         failDueToUnexpectedToken();
2841     }
2842     ASSERT(info.className);
2843 
2844     TreeExpression parentClass = 0;
2845     if (consume(EXTENDS)) {
2846         parentClass = parseMemberExpression(context);
2847         failIfFalse(parentClass, &quot;Cannot parse the parent class name&quot;);
2848     }
<span class="line-added">2849     classScope-&gt;setIsClassScope();</span>
2850     const ConstructorKind constructorKind = parentClass ? ConstructorKind::Extends : ConstructorKind::Base;
2851 
2852     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of a class body&quot;);
2853 
2854     TreeExpression constructor = 0;
2855     TreePropertyList classElements = 0;
2856     TreePropertyList classElementsTail = 0;
<span class="line-added">2857     unsigned numComputedFields = 0;</span>
2858     while (!match(CLOSEBRACE)) {
2859         if (match(SEMICOLON)) {
2860             next();
2861             continue;
2862         }
2863 
2864         JSTokenLocation methodLocation(tokenLocation());
2865         unsigned methodStart = tokenStart();
2866 
2867         // For backwards compatibility, &quot;static&quot; is a non-reserved keyword in non-strict mode.
2868         ClassElementTag tag = ClassElementTag::Instance;
<span class="line-added">2869         auto type = PropertyNode::Constant;</span>
2870         if (match(RESERVED_IF_STRICT) &amp;&amp; *m_token.m_data.ident == m_vm.propertyNames-&gt;staticKeyword) {
<span class="line-modified">2871             SavePoint savePoint = createSavePoint(context);</span>
2872             next();
2873             if (match(OPENPAREN)) {
2874                 // Reparse &quot;static()&quot; as a method named &quot;static&quot;.
<span class="line-modified">2875                 restoreSavePoint(context, savePoint);</span>
2876             } else
2877                 tag = ClassElementTag::Static;
2878         }
2879 
2880         // FIXME: Figure out a way to share more code with parseProperty.
2881         const CommonIdentifiers&amp; propertyNames = *m_vm.propertyNames;
2882         const Identifier* ident = &amp;propertyNames.nullIdentifier;
2883         TreeExpression computedPropertyName = 0;
2884         bool isGetter = false;
2885         bool isSetter = false;
2886         SourceParseMode parseMode = SourceParseMode::MethodMode;
2887         if (consume(TIMES))
2888             parseMode = SourceParseMode::GeneratorWrapperMethodMode;
2889 
2890 parseMethod:
2891         switch (m_token.m_type) {
2892         namedKeyword:
2893         case STRING:
2894             ident = m_token.m_data.ident;
2895             ASSERT(ident);
2896             next();
2897             break;
<span class="line-added">2898         case BIGINT:</span>
<span class="line-added">2899             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">2900             ASSERT(ident);</span>
<span class="line-added">2901             next();</span>
<span class="line-added">2902             break;</span>
2903         case IDENT:
2904             if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
2905                 if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode)) {
2906                     ident = m_token.m_data.ident;
2907                     next();
<span class="line-modified">2908                     // We match SEMICOLON as a special case for a field called &#39;async&#39; without initializer.</span>
<span class="line-added">2909                     if (match(OPENPAREN) || match(COLON) || match(SEMICOLON) || match(EQUAL) || m_lexer-&gt;hasLineTerminatorBeforeToken())</span>
2910                         break;
2911                     if (UNLIKELY(consume(TIMES)))
2912                         parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
2913                     else
2914                         parseMode = SourceParseMode::AsyncMethodMode;
2915                     goto parseMethod;
2916                 }
2917             }
2918             FALLTHROUGH;
2919         case AWAIT:
2920             ident = m_token.m_data.ident;
2921             ASSERT(ident);
2922             next();
<span class="line-modified">2923             if (parseMode == SourceParseMode::MethodMode &amp;&amp; (matchIdentifierOrKeyword() || match(STRING) || match(DOUBLE) || match(INTEGER) || match(BIGINT) || match(OPENBRACKET))) {</span>
2924                 isGetter = *ident == propertyNames.get;
2925                 isSetter = *ident == propertyNames.set;
2926             }
2927             break;
2928         case DOUBLE:
2929         case INTEGER:
2930             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);
2931             ASSERT(ident);
2932             next();
2933             break;
2934         case OPENBRACKET:
2935             next();
2936             computedPropertyName = parseAssignmentExpression(context);
<span class="line-added">2937             type = static_cast&lt;PropertyNode::Type&gt;(type | PropertyNode::Computed);</span>
2938             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
2939             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
2940             break;
2941         default:
2942             if (m_token.m_type &amp; KeywordTokenFlag)
2943                 goto namedKeyword;
2944             failDueToUnexpectedToken();
2945         }
2946 
2947         TreeProperty property;
2948         const bool alwaysStrictInsideClass = true;
2949         if (isGetter || isSetter) {
<span class="line-modified">2950             type = static_cast&lt;PropertyNode::Type&gt;(type &amp; ~PropertyNode::Constant);</span>
<span class="line-modified">2951             type = static_cast&lt;PropertyNode::Type&gt;(type | (isGetter ? PropertyNode::Getter : PropertyNode::Setter));</span>
<span class="line-added">2952             property = parseGetterSetter(context, alwaysStrictInsideClass, type, methodStart, ConstructorKind::None, tag);</span>
2953             failIfFalse(property, &quot;Cannot parse this method&quot;);
<span class="line-added">2954         } else if (Options::useClassFields() &amp;&amp; !match(OPENPAREN) &amp;&amp; tag == ClassElementTag::Instance &amp;&amp; parseMode == SourceParseMode::MethodMode) {</span>
<span class="line-added">2955             ASSERT(!isGetter &amp;&amp; !isSetter);</span>
<span class="line-added">2956             if (ident)</span>
<span class="line-added">2957                 semanticFailIfTrue(*ident == propertyNames.constructor, &quot;Cannot declare class field named &#39;constructor&#39;&quot;);</span>
<span class="line-added">2958 </span>
<span class="line-added">2959             if (computedPropertyName) {</span>
<span class="line-added">2960                 ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);</span>
<span class="line-added">2961                 DeclarationResultMask declarationResult = classScope-&gt;declareLexicalVariable(ident, true);</span>
<span class="line-added">2962                 ASSERT_UNUSED(declarationResult, declarationResult == DeclarationResult::Valid);</span>
<span class="line-added">2963                 classScope-&gt;useVariable(ident, false);</span>
<span class="line-added">2964                 classScope-&gt;addClosedVariableCandidateUnconditionally(ident-&gt;impl());</span>
<span class="line-added">2965             }</span>
<span class="line-added">2966 </span>
<span class="line-added">2967             TreeExpression initializer = 0;</span>
<span class="line-added">2968             if (consume(EQUAL)) {</span>
<span class="line-added">2969                 SetForScope&lt;bool&gt; overrideParsingClassFieldInitializer(m_parserState.isParsingClassFieldInitializer, true);</span>
<span class="line-added">2970                 classScope-&gt;setExpectedSuperBinding(SuperBinding::Needed);</span>
<span class="line-added">2971                 initializer = parseAssignmentExpression(context);</span>
<span class="line-added">2972                 classScope-&gt;setExpectedSuperBinding(SuperBinding::NotNeeded);</span>
<span class="line-added">2973                 failIfFalse(initializer, &quot;Cannot parse initializer for class field&quot;);</span>
<span class="line-added">2974                 classScope-&gt;markLastUsedVariablesSetAsCaptured();</span>
<span class="line-added">2975             }</span>
<span class="line-added">2976             failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a class field&quot;);</span>
<span class="line-added">2977             auto inferName = initializer ? InferName::Allowed : InferName::Disallowed;</span>
<span class="line-added">2978             if (computedPropertyName)</span>
<span class="line-added">2979                 property = context.createProperty(ident, computedPropertyName, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, tag);</span>
<span class="line-added">2980             else</span>
<span class="line-added">2981                 property = context.createProperty(ident, initializer, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::NotNeeded, inferName, tag);</span>
2982         } else {
2983             ParserFunctionInfo&lt;TreeBuilder&gt; methodInfo;
2984             bool isConstructor = tag == ClassElementTag::Instance &amp;&amp; *ident == propertyNames.constructor;
2985             if (isAsyncMethodParseMode(parseMode) || isAsyncGeneratorMethodParseMode(parseMode) || isGeneratorMethodParseMode(parseMode)) {
2986                 isConstructor = false;
2987                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;prototype, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;prototype&#39;&quot;);
2988                 semanticFailIfTrue(*ident == m_vm.propertyNames-&gt;constructor, &quot;Cannot declare &quot;, stringArticleForFunctionMode(parseMode), stringForFunctionMode(parseMode), &quot; named &#39;constructor&#39;&quot;);
2989             }
2990 
2991             methodInfo.name = isConstructor ? info.className : ident;
2992             failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, parseMode, false, isConstructor ? constructorKind : ConstructorKind::None, SuperBinding::Needed, methodStart, methodInfo, FunctionDefinitionType::Method)), &quot;Cannot parse this method&quot;);
2993 
2994             TreeExpression method = context.createMethodDefinition(methodLocation, methodInfo);
2995             if (isConstructor) {
2996                 semanticFailIfTrue(constructor, &quot;Cannot declare multiple constructors in a single class&quot;);
2997                 constructor = method;
2998                 continue;
2999             }
3000 
3001             // FIXME: Syntax error when super() is called
3002             semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; methodInfo.name &amp;&amp; *methodInfo.name == propertyNames.prototype,
3003                 &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
3004 
3005             if (computedPropertyName) {
<span class="line-modified">3006                 property = context.createProperty(computedPropertyName, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, tag);</span>

3007             } else {
<span class="line-modified">3008                 property = context.createProperty(methodInfo.name, method, type, PropertyNode::Unknown, alwaysStrictInsideClass, SuperBinding::Needed, InferName::Allowed, tag);</span>

3009             }
3010         }
3011 
3012         if (classElementsTail)
3013             classElementsTail = context.createPropertyList(methodLocation, property, classElementsTail);
3014         else
3015             classElements = classElementsTail = context.createPropertyList(methodLocation, property);
3016     }
3017 
3018     info.endOffset = tokenLocation().endOffset - 1;
3019     consumeOrFail(CLOSEBRACE, &quot;Expected a closing &#39;}&#39; after a class body&quot;);
3020 
3021     auto classExpression = context.createClassExpr(location, info, classScope-&gt;finalizeLexicalEnvironment(), constructor, parentClass, classElements);
3022     popScope(classScope, TreeBuilder::NeedsFreeVariableInfo);
3023     return classExpression;
3024 }
3025 
<span class="line-added">3026 template &lt;typename LexerType&gt;</span>
<span class="line-added">3027 template &lt;class TreeBuilder&gt; TreeSourceElements Parser&lt;LexerType&gt;::parseInstanceFieldInitializerSourceElements(TreeBuilder&amp; context, const Vector&lt;JSTextPosition&gt;&amp; instanceFieldLocations)</span>
<span class="line-added">3028 {</span>
<span class="line-added">3029     TreeSourceElements sourceElements = context.createSourceElements();</span>
<span class="line-added">3030     currentScope()-&gt;setIsClassScope();</span>
<span class="line-added">3031 </span>
<span class="line-added">3032     unsigned numComputedFields = 0;</span>
<span class="line-added">3033     for (auto location : instanceFieldLocations) {</span>
<span class="line-added">3034         // We don&#39;t need to worry about hasLineTerminatorBeforeToken</span>
<span class="line-added">3035         // on class fields, so we set this value to false.</span>
<span class="line-added">3036         LexerState lexerState { location.offset, static_cast&lt;unsigned&gt;(location.lineStartOffset), static_cast&lt;unsigned&gt;(location.line), static_cast&lt;unsigned&gt;(location.line), false };</span>
<span class="line-added">3037         restoreLexerState(lexerState);</span>
<span class="line-added">3038 </span>
<span class="line-added">3039         JSTokenLocation fieldLocation = tokenLocation();</span>
<span class="line-added">3040         const Identifier* ident = nullptr;</span>
<span class="line-added">3041         TreeExpression computedPropertyName = 0;</span>
<span class="line-added">3042         DefineFieldNode::Type type = DefineFieldNode::Type::Name;</span>
<span class="line-added">3043         switch (m_token.m_type) {</span>
<span class="line-added">3044         case STRING:</span>
<span class="line-added">3045         case IDENT:</span>
<span class="line-added">3046         namedKeyword:</span>
<span class="line-added">3047             ident = m_token.m_data.ident;</span>
<span class="line-added">3048             ASSERT(ident);</span>
<span class="line-added">3049             next();</span>
<span class="line-added">3050             break;</span>
<span class="line-added">3051         case BIGINT:</span>
<span class="line-added">3052             ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">3053             ASSERT(ident);</span>
<span class="line-added">3054             next();</span>
<span class="line-added">3055             break;</span>
<span class="line-added">3056         case DOUBLE:</span>
<span class="line-added">3057         case INTEGER:</span>
<span class="line-added">3058             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), m_token.m_data.doubleValue);</span>
<span class="line-added">3059             ASSERT(ident);</span>
<span class="line-added">3060             next();</span>
<span class="line-added">3061             break;</span>
<span class="line-added">3062         case OPENBRACKET:</span>
<span class="line-added">3063             next();</span>
<span class="line-added">3064             computedPropertyName = parseAssignmentExpression(context);</span>
<span class="line-added">3065             failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);</span>
<span class="line-added">3066             handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);</span>
<span class="line-added">3067             ident = &amp;m_parserArena.identifierArena().makeNumericIdentifier(m_vm, numComputedFields++);</span>
<span class="line-added">3068             type = DefineFieldNode::Type::ComputedName;</span>
<span class="line-added">3069             break;</span>
<span class="line-added">3070         default:</span>
<span class="line-added">3071             if (m_token.m_type &amp; KeywordTokenFlag)</span>
<span class="line-added">3072                 goto namedKeyword;</span>
<span class="line-added">3073             failDueToUnexpectedToken();</span>
<span class="line-added">3074         }</span>
<span class="line-added">3075 </span>
<span class="line-added">3076         // Only valid class fields are handled in this function.</span>
<span class="line-added">3077         ASSERT(match(EQUAL) || match(SEMICOLON) || match(CLOSEBRACE) || m_lexer-&gt;hasLineTerminatorBeforeToken());</span>
<span class="line-added">3078 </span>
<span class="line-added">3079         TreeExpression initializer = 0;</span>
<span class="line-added">3080         if (consume(EQUAL))</span>
<span class="line-added">3081             initializer = parseAssignmentExpression(context);</span>
<span class="line-added">3082 </span>
<span class="line-added">3083         TreeStatement defineField = context.createDefineField(fieldLocation, ident, initializer, type);</span>
<span class="line-added">3084         context.appendStatement(sourceElements, defineField);</span>
<span class="line-added">3085     }</span>
<span class="line-added">3086 </span>
<span class="line-added">3087     ASSERT(!hasError());</span>
<span class="line-added">3088     // Trick parseInner() into believing we&#39;ve parsed the entire SourceCode, in order to prevent it from producing an error.</span>
<span class="line-added">3089     m_token.m_type = EOFTOK;</span>
<span class="line-added">3090     return sourceElements;</span>
<span class="line-added">3091 }</span>
<span class="line-added">3092 </span>
3093 struct LabelInfo {
3094     LabelInfo(const Identifier* ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
3095     : m_ident(ident)
3096     , m_start(start)
3097     , m_end(end)
3098     {
3099     }
3100 
3101     const Identifier* m_ident;
3102     JSTextPosition m_start;
3103     JSTextPosition m_end;
3104 };
3105 
3106 template &lt;typename LexerType&gt;
3107 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExpressionOrLabelStatement(TreeBuilder&amp; context, bool allowFunctionDeclarationAsStatement)
3108 {
3109 
3110     /* Expression and Label statements are ambiguous at LL(1), so we have a
3111      * special case that looks for a colon as the next character in the input.
3112      */
</pre>
<hr />
<pre>
3460     const Identifier* localName = m_token.m_data.ident;
3461     const Identifier* exportedName = localName;
3462     next();
3463 
3464     if (matchContextualKeyword(m_vm.propertyNames-&gt;as)) {
3465         next();
3466         failIfFalse(matchIdentifierOrKeyword(), &quot;Expected an exported name for the export declaration&quot;);
3467         exportedName = m_token.m_data.ident;
3468         next();
3469     }
3470 
3471     semanticFailIfFalse(exportName(*exportedName), &quot;Cannot export a duplicate name &#39;&quot;, exportedName-&gt;impl(), &quot;&#39;&quot;);
3472     maybeExportedLocalNames.append(std::make_pair(localName, exportedName));
3473     return context.createExportSpecifier(specifierLocation, *localName, *exportedName);
3474 }
3475 
3476 template &lt;typename LexerType&gt;
3477 template &lt;class TreeBuilder&gt; TreeStatement Parser&lt;LexerType&gt;::parseExportDeclaration(TreeBuilder&amp; context)
3478 {
3479     // http://www.ecma-international.org/ecma-262/6.0/#sec-exports
<span class="line-modified">3480     ASSERT(match(EXPORT_));</span>
3481     JSTokenLocation exportLocation(tokenLocation());
3482     next();
3483 
3484     switch (m_token.m_type) {
3485     case TIMES: {
3486         // export * FromClause ;
3487         next();
3488 
3489         failIfFalse(matchContextualKeyword(m_vm.propertyNames-&gt;from), &quot;Expected &#39;from&#39; before exported module name&quot;);
3490         next();
3491         auto moduleName = parseModuleName(context);
3492         failIfFalse(moduleName, &quot;Cannot parse the &#39;from&#39; clause&quot;);
3493         failIfFalse(autoSemiColon(), &quot;Expected a &#39;;&#39; following a targeted export declaration&quot;);
3494 
3495         return context.createExportAllDeclaration(exportLocation, moduleName);
3496     }
3497 
3498     case DEFAULT: {
3499         // export default HoistableDeclaration[Default]
3500         // export default ClassDeclaration[Default]
3501         // export default [lookahead not-in {function, class}] AssignmentExpression[In] ;
3502 
3503         next();
3504 
3505         TreeStatement result = 0;
3506         bool isFunctionOrClassDeclaration = false;
3507         const Identifier* localName = nullptr;
3508 
3509         bool startsWithFunction = match(FUNCTION);
3510         if (startsWithFunction || match(CLASSTOKEN)) {
<span class="line-modified">3511             SavePoint savePoint = createSavePoint(context);</span>
3512             isFunctionOrClassDeclaration = true;
3513             next();
3514 
3515             // ES6 Generators
3516             if (startsWithFunction &amp;&amp; match(TIMES))
3517                 next();
3518             if (match(IDENT))
3519                 localName = m_token.m_data.ident;
<span class="line-modified">3520             restoreSavePoint(context, savePoint);</span>
3521         } else if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
<span class="line-modified">3522             SavePoint savePoint = createSavePoint(context);</span>
3523             next();
3524             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken()) {
3525                 next();
3526                 if (match(IDENT))
3527                     localName = m_token.m_data.ident;
3528                 isFunctionOrClassDeclaration = true;
3529             }
<span class="line-modified">3530             restoreSavePoint(context, savePoint);</span>
3531         }
3532 
3533         if (!localName)
3534             localName = &amp;m_vm.propertyNames-&gt;starDefaultPrivateName;
3535 
3536         if (isFunctionOrClassDeclaration) {
3537             if (startsWithFunction) {
3538                 ASSERT(match(FUNCTION));
3539                 DepthManager statementDepth(&amp;m_statementDepth);
3540                 m_statementDepth = 1;
3541                 result = parseFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3542             } else if (match(CLASSTOKEN)) {
3543                 result = parseClassDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3544             } else {
3545                 ASSERT(matchContextualKeyword(m_vm.propertyNames-&gt;async));
3546                 next();
3547                 DepthManager statementDepth(&amp;m_statementDepth);
3548                 m_statementDepth = 1;
3549                 result = parseAsyncFunctionDeclaration(context, ExportType::NotExported, DeclarationDefaultContext::ExportDefault);
3550             }
</pre>
<hr />
<pre>
3756 template &lt;typename LexerType&gt;
3757 template &lt;typename TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAssignmentExpression(TreeBuilder&amp; context, ExpressionErrorClassifier&amp; classifier)
3758 {
3759     ASSERT(!hasError());
3760 
3761     failIfStackOverflow();
3762 
3763     if (match(YIELD) &amp;&amp; !isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()))
3764         return parseYieldExpression(context);
3765 
3766     JSTextPosition start = tokenStartPosition();
3767     JSTokenLocation location(tokenLocation());
3768     int initialAssignmentCount = m_parserState.assignmentCount;
3769     int initialNonLHSCount = m_parserState.nonLHSCount;
3770     bool maybeAssignmentPattern = match(OPENBRACE) || match(OPENBRACKET);
3771     bool wasOpenParen = match(OPENPAREN);
3772     // Do not use matchSpecIdentifier() here since it is slower than isIdentifierOrKeyword.
3773     // Whether spec identifier is will be validated by isArrowFunctionParameters().
3774     bool wasIdentifierOrKeyword = isIdentifierOrKeyword(m_token);
3775     bool maybeValidArrowFunctionStart = wasOpenParen || wasIdentifierOrKeyword;
<span class="line-modified">3776     SavePoint savePoint = createSavePoint(context);</span>
3777     size_t usedVariablesSize = 0;
3778 
3779     if (wasOpenParen) {
3780         usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
3781         currentScope()-&gt;pushUsedVariableSet();
3782     }
3783 
3784     TreeExpression lhs = parseConditionalExpression(context);
3785 
3786     if (maybeValidArrowFunctionStart &amp;&amp; !match(EOFTOK)) {
3787         bool isArrowFunctionToken = match(ARROWFUNCTION);
3788         if (!lhs || isArrowFunctionToken) {
<span class="line-modified">3789             SavePointWithError errorRestorationSavePoint = swapSavePointForError(context, savePoint);</span>

3790             bool isAsyncArrow = false;
3791             if (UNLIKELY(classifier.indicatesPossibleAsyncArrowFunction())) {
3792                 if (matchContextualKeyword(m_vm.propertyNames-&gt;async)) {
3793                     next();
3794                     isAsyncArrow = !m_lexer-&gt;hasLineTerminatorBeforeToken();
3795                 }
3796             }
<span class="line-modified">3797             if (isArrowFunctionParameters(context)) {</span>
3798                 if (wasOpenParen)
3799                     currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
3800                 return parseArrowFunctionExpression(context, isAsyncArrow);
3801             }
3802             if (isArrowFunctionToken)
3803                 propagateError();
<span class="line-modified">3804             restoreSavePointWithError(context, errorRestorationSavePoint);</span>
3805             if (isArrowFunctionToken)
3806                 failDueToUnexpectedToken();
3807         }
3808     }
3809 
3810     if (!lhs &amp;&amp; (!maybeAssignmentPattern || !classifier.indicatesPossiblePattern()))
3811         propagateError();
3812 
3813     if (maybeAssignmentPattern &amp;&amp; (!lhs || (context.isObjectOrArrayLiteral(lhs) &amp;&amp; match(EQUAL)))) {
<span class="line-modified">3814         SavePointWithError expressionErrorLocation = swapSavePointForError(context, savePoint);</span>

3815         auto pattern = tryParseDestructuringPatternExpression(context, AssignmentContext::AssignmentExpression);
3816         if (classifier.indicatesPossiblePattern() &amp;&amp; (!pattern || !match(EQUAL))) {
<span class="line-modified">3817             restoreSavePointWithError(context, expressionErrorLocation);</span>
3818             return 0;
3819         }
3820         failIfFalse(pattern, &quot;Cannot parse assignment pattern&quot;);
3821         consumeOrFail(EQUAL, &quot;Expected &#39;=&#39; following assignment pattern&quot;);
3822         auto rhs = parseAssignmentExpression(context);
3823         if (!rhs)
3824             propagateError();
3825         return context.createDestructuringAssignment(location, pattern, rhs);
3826     }
3827 
3828     failIfFalse(lhs, &quot;Cannot parse expression&quot;);
3829     if (initialNonLHSCount != m_parserState.nonLHSCount) {
3830         if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3831             semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3832 
3833         return lhs;
3834     }
3835 
3836     int assignmentStack = 0;
3837     Operator op;
</pre>
<hr />
<pre>
3862         start = tokenStartPosition();
3863         m_parserState.assignmentCount++;
3864         next(TreeBuilder::DontBuildStrings);
3865         if (strictMode() &amp;&amp; m_parserState.lastIdentifier &amp;&amp; context.isResolve(lhs)) {
3866             failIfTrueIfStrict(m_vm.propertyNames-&gt;eval == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;eval&#39; in strict mode&quot;);
3867             failIfTrueIfStrict(m_vm.propertyNames-&gt;arguments == *m_parserState.lastIdentifier, &quot;Cannot modify &#39;arguments&#39; in strict mode&quot;);
3868             m_parserState.lastIdentifier = 0;
3869         }
3870         lhs = parseAssignmentExpression(context);
3871         failIfFalse(lhs, &quot;Cannot parse the right hand side of an assignment expression&quot;);
3872         if (initialNonLHSCount != m_parserState.nonLHSCount) {
3873             if (m_token.m_type &gt;= EQUAL &amp;&amp; m_token.m_type &lt;= OREQUAL)
3874                 semanticFail(&quot;Left hand side of operator &#39;&quot;, getToken(), &quot;&#39; must be a reference&quot;);
3875             break;
3876         }
3877     }
3878 end:
3879     if (hadAssignment)
3880         m_parserState.nonLHSCount++;
3881 



3882     while (assignmentStack)
3883         lhs = context.createAssignment(location, assignmentStack, lhs, initialAssignmentCount, m_parserState.assignmentCount, lastTokenEndPosition());
3884 
3885     return lhs;
3886 }
3887 
3888 template &lt;typename LexerType&gt;
3889 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseYieldExpression(TreeBuilder&amp; context)
3890 {
3891     // YieldExpression[In] :
3892     //     yield
3893     //     yield [no LineTerminator here] AssignmentExpression[?In, Yield]
3894     //     yield [no LineTerminator here] * AssignmentExpression[?In, Yield]
3895 
3896     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions
3897     failIfFalse(currentScope()-&gt;isGenerator() &amp;&amp; !currentScope()-&gt;isArrowFunctionBoundary(), &quot;Cannot use yield expression out of generator&quot;);
3898 
3899     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
3900     failIfTrue(m_parserState.functionParsePhase == FunctionParsePhase::Parameters, &quot;Cannot use yield expression within parameters&quot;);
3901 
3902     JSTokenLocation location(tokenLocation());
3903     JSTextPosition divotStart = tokenStartPosition();
3904     ASSERT(match(YIELD));
<span class="line-modified">3905     SavePoint savePoint = createSavePoint(context);</span>
3906     next();
3907     if (m_lexer-&gt;hasLineTerminatorBeforeToken())
3908         return context.createYield(location);
3909 
3910     bool delegate = consume(TIMES);
3911     JSTextPosition argumentStart = tokenStartPosition();
3912     TreeExpression argument = parseAssignmentExpression(context);
3913     if (!argument) {
<span class="line-modified">3914         restoreSavePoint(context, savePoint);</span>
3915         next();
3916         return context.createYield(location);
3917     }
3918     return context.createYield(location, argument, delegate, divotStart, argumentStart, lastTokenEndPosition());
3919 }
3920 
3921 template &lt;typename LexerType&gt;
3922 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseAwaitExpression(TreeBuilder&amp; context)
3923 {
3924     ASSERT(match(AWAIT));
3925     ASSERT(currentScope()-&gt;isAsyncFunction());
<span class="line-modified">3926     ASSERT(m_parserState.functionParsePhase != FunctionParsePhase::Parameters);</span>
3927     JSTokenLocation location(tokenLocation());
3928     JSTextPosition divotStart = tokenStartPosition();
3929     next();
3930     JSTextPosition argumentStart = tokenStartPosition();
3931     ExpressionErrorClassifier classifier(this);
3932     TreeExpression argument = parseUnaryExpression(context);
3933     failIfFalse(argument, &quot;Failed to parse await expression&quot;);
3934     return context.createAwait(location, argument, divotStart, argumentStart, lastTokenEndPosition());
3935 }
3936 
3937 template &lt;typename LexerType&gt;
3938 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseConditionalExpression(TreeBuilder&amp; context)
3939 {
3940     JSTokenLocation location(tokenLocation());
3941     TreeExpression cond = parseBinaryExpression(context);
3942     failIfFalse(cond, &quot;Cannot parse expression&quot;);
3943     if (!match(QUESTION))
3944         return cond;
3945     m_parserState.nonTrivialExpressionCount++;
3946     m_parserState.nonLHSCount++;
</pre>
<hr />
<pre>
4049         context.appendBinaryOperation(location, operandStackDepth, operatorStackDepth, lhs, rhs);
4050         context.operatorStackPop(operatorStackDepth);
4051     }
4052     return context.popOperandStack(operandStackDepth);
4053 }
4054 
4055 template &lt;typename LexerType&gt;
4056 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseProperty(TreeBuilder&amp; context, bool complete)
4057 {
4058     SourceParseMode parseMode = SourceParseMode::MethodMode;
4059     bool wasIdent = false;
4060 
4061     if (consume(TIMES))
4062         parseMode = SourceParseMode::GeneratorWrapperMethodMode;
4063 
4064 parseProperty:
4065     switch (m_token.m_type) {
4066     case IDENT:
4067         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4068             if (parseMode == SourceParseMode::MethodMode) {
<span class="line-modified">4069                 SavePoint savePoint = createSavePoint(context);</span>
4070                 next();
4071 
4072                 if (match(COLON) || match(OPENPAREN) || match(COMMA) || match(CLOSEBRACE)) {
<span class="line-modified">4073                     restoreSavePoint(context, savePoint);</span>
4074                     wasIdent = true;
4075                     goto namedProperty;
4076                 }
4077 
4078                 failIfTrue(m_lexer-&gt;hasLineTerminatorBeforeToken(), &quot;Expected a property name following keyword &#39;async&#39;&quot;);
4079                 if (UNLIKELY(consume(TIMES)))
4080                     parseMode = SourceParseMode::AsyncGeneratorWrapperMethodMode;
4081                 else
4082                     parseMode = SourceParseMode::AsyncMethodMode;
4083                 goto parseProperty;
4084             }
4085         }
4086         FALLTHROUGH;
4087     case YIELD:
4088     case AWAIT:
4089         wasIdent = true;
4090         FALLTHROUGH;
4091     case STRING: {
4092 namedProperty:
4093         const Identifier* ident = m_token.m_data.ident;
4094         unsigned getterOrSetterStartOffset = tokenStart();
4095         JSToken identToken = m_token;
4096 
4097         if (complete || (wasIdent &amp;&amp; !isGeneratorMethodParseMode(parseMode)  &amp;&amp; (*ident == m_vm.propertyNames-&gt;get || *ident == m_vm.propertyNames-&gt;set)))
<span class="line-modified">4098             nextExpectIdentifier(LexerFlags::IgnoreReservedWords);</span>
4099         else
<span class="line-modified">4100             nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);</span>
4101 
4102         if (!isGeneratorMethodParseMode(parseMode) &amp;&amp; !isAsyncMethodParseMode(parseMode) &amp;&amp; match(COLON)) {
4103             next();
4104             TreeExpression node = parseAssignmentExpressionOrPropagateErrorClass(context);
4105             failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4106             context.setEndOffset(node, m_lexer-&gt;currentOffset());
4107             InferName inferName = ident &amp;&amp; *ident == m_vm.propertyNames-&gt;underscoreProto ? InferName::Disallowed : InferName::Allowed;
4108             return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, inferName, ClassElementTag::No);
4109         }
4110 
4111         if (match(OPENPAREN)) {
4112             auto method = parsePropertyMethod(context, ident, parseMode);
4113             propagateError();
4114             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::KnownDirect, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4115         }
4116         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4117 
4118         failIfFalse(wasIdent, &quot;Expected an identifier as property name&quot;);
4119 
4120         if (match(COMMA) || match(CLOSEBRACE)) {
</pre>
<hr />
<pre>
4142     }
4143     case DOUBLE:
4144     case INTEGER: {
4145         double propertyName = m_token.m_data.doubleValue;
4146         next();
4147 
4148         if (match(OPENPAREN)) {
4149             const Identifier&amp; ident = m_parserArena.identifierArena().makeNumericIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), propertyName);
4150             auto method = parsePropertyMethod(context, &amp;ident, parseMode);
4151             propagateError();
4152             return context.createProperty(&amp;ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);
4153         }
4154         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4155 
4156         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4157         TreeExpression node = parseAssignmentExpression(context);
4158         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4159         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4160         return context.createProperty(const_cast&lt;VM&amp;&gt;(m_vm), m_parserArena, propertyName, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4161     }
<span class="line-added">4162     case BIGINT: {</span>
<span class="line-added">4163         const Identifier* ident = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">4164         next();</span>
<span class="line-added">4165 </span>
<span class="line-added">4166         if (match(OPENPAREN)) {</span>
<span class="line-added">4167             auto method = parsePropertyMethod(context, ident, parseMode);</span>
<span class="line-added">4168             propagateError();</span>
<span class="line-added">4169             return context.createProperty(ident, method, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::Needed, InferName::Allowed, ClassElementTag::No);</span>
<span class="line-added">4170         }</span>
<span class="line-added">4171         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);</span>
<span class="line-added">4172 </span>
<span class="line-added">4173         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);</span>
<span class="line-added">4174         TreeExpression node = parseAssignmentExpression(context);</span>
<span class="line-added">4175         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);</span>
<span class="line-added">4176         context.setEndOffset(node, m_lexer-&gt;currentOffset());</span>
<span class="line-added">4177         return context.createProperty(ident, node, PropertyNode::Constant, PropertyNode::Unknown, complete, SuperBinding::NotNeeded, InferName::Allowed, ClassElementTag::No);</span>
<span class="line-added">4178     }</span>
4179     case OPENBRACKET: {
4180         next();
4181         auto propertyName = parseAssignmentExpression(context);
4182         failIfFalse(propertyName, &quot;Cannot parse computed property name&quot;);
4183         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4184 
4185         if (match(OPENPAREN)) {
4186             auto method = parsePropertyMethod(context, &amp;m_vm.propertyNames-&gt;nullIdentifier, parseMode);
4187             propagateError();
4188             return context.createProperty(propertyName, method, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::KnownDirect, complete, SuperBinding::Needed, ClassElementTag::No);
4189         }
4190         failIfTrue(parseMode != SourceParseMode::MethodMode, &quot;Expected a parenthesis for argument list&quot;);
4191 
4192         consumeOrFail(COLON, &quot;Expected &#39;:&#39; after property name&quot;);
4193         TreeExpression node = parseAssignmentExpression(context);
4194         failIfFalse(node, &quot;Cannot parse expression for property declaration&quot;);
4195         context.setEndOffset(node, m_lexer-&gt;currentOffset());
4196         return context.createProperty(propertyName, node, static_cast&lt;PropertyNode::Type&gt;(PropertyNode::Constant | PropertyNode::Computed), PropertyNode::Unknown, complete, SuperBinding::NotNeeded, ClassElementTag::No);
4197     }
4198     case DOTDOTDOT: {
</pre>
<hr />
<pre>
4227 template &lt;typename LexerType&gt;
4228 template &lt;class TreeBuilder&gt; TreeProperty Parser&lt;LexerType&gt;::parseGetterSetter(TreeBuilder&amp; context, bool strict, PropertyNode::Type type, unsigned getterOrSetterStartOffset,
4229     ConstructorKind constructorKind, ClassElementTag tag)
4230 {
4231     const Identifier* stringPropertyName = 0;
4232     double numericPropertyName = 0;
4233     TreeExpression computedPropertyName = 0;
4234 
4235     JSTokenLocation location(tokenLocation());
4236 
4237     if (matchSpecIdentifier() || match(STRING) || m_token.m_type &amp; KeywordTokenFlag) {
4238         stringPropertyName = m_token.m_data.ident;
4239         semanticFailIfTrue(tag == ClassElementTag::Static &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;prototype,
4240             &quot;Cannot declare a static method named &#39;prototype&#39;&quot;);
4241         semanticFailIfTrue(tag == ClassElementTag::Instance &amp;&amp; *stringPropertyName == m_vm.propertyNames-&gt;constructor,
4242             &quot;Cannot declare a getter or setter named &#39;constructor&#39;&quot;);
4243         next();
4244     } else if (match(DOUBLE) || match(INTEGER)) {
4245         numericPropertyName = m_token.m_data.doubleValue;
4246         next();
<span class="line-added">4247     } else if (match(BIGINT)) {</span>
<span class="line-added">4248         stringPropertyName = &amp;m_parserArena.identifierArena().makeBigIntDecimalIdentifier(const_cast&lt;VM&amp;&gt;(m_vm), *m_token.m_data.bigIntString, m_token.m_data.radix);</span>
<span class="line-added">4249         next();</span>
4250     } else if (match(OPENBRACKET)) {
4251         next();
4252         computedPropertyName = parseAssignmentExpression(context);
4253         failIfFalse(computedPropertyName, &quot;Cannot parse computed property name&quot;);
4254         handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;computed property name&quot;);
4255     } else
4256         failDueToUnexpectedToken();
4257 
4258     ParserFunctionInfo&lt;TreeBuilder&gt; info;
4259     if (type &amp; PropertyNode::Getter) {
4260         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for getter definition&quot;);
4261         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::GetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse getter definition&quot;);
4262     } else {
4263         failIfFalse(match(OPENPAREN), &quot;Expected a parameter list for setter definition&quot;);
4264         failIfFalse((parseFunctionInfo(context, FunctionNameRequirements::Unnamed, SourceParseMode::SetterMode, false, constructorKind, SuperBinding::Needed, getterOrSetterStartOffset, info, FunctionDefinitionType::Method)), &quot;Cannot parse setter definition&quot;);
4265     }
4266 
4267     if (stringPropertyName)
4268         return context.createGetterOrSetterProperty(location, type, strict, stringPropertyName, info, tag);
4269 
</pre>
<hr />
<pre>
4298 template &lt;typename LexerType&gt;
4299 void Parser&lt;LexerType&gt;::recordFunctionEntryLocation(const JSTextPosition&amp; position)
4300 {
4301     if (LIKELY(!m_debuggerParseData))
4302         return;
4303 
4304     m_debuggerParseData-&gt;pausePositions.appendEntry(position);
4305 }
4306 
4307 template &lt;typename LexerType&gt;
4308 void Parser&lt;LexerType&gt;::recordFunctionLeaveLocation(const JSTextPosition&amp; position)
4309 {
4310     if (LIKELY(!m_debuggerParseData))
4311         return;
4312 
4313     m_debuggerParseData-&gt;pausePositions.appendLeave(position);
4314 }
4315 
4316 template &lt;typename LexerType&gt;
4317 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseObjectLiteral(TreeBuilder&amp; context)
























































4318 {
4319     consumeOrFail(OPENBRACE, &quot;Expected opening &#39;{&#39; at the start of an object literal&quot;);
4320 
4321     int oldNonLHSCount = m_parserState.nonLHSCount;
4322 
4323     JSTokenLocation location(tokenLocation());
4324     if (match(CLOSEBRACE)) {
4325         next();
4326         return context.createObjectLiteral(location);
4327     }
4328 
4329     TreeProperty property = parseProperty(context, true);
4330     failIfFalse(property, &quot;Cannot parse object literal property&quot;);
4331 
4332     bool seenUnderscoreProto = false;
4333     if (shouldCheckPropertyForUnderscoreProtoDuplicate(context, property))
4334         seenUnderscoreProto = *context.getName(property) == m_vm.propertyNames-&gt;underscoreProto;
4335 
4336     TreePropertyList propertyList = context.createPropertyList(location, property);
4337     TreePropertyList tail = propertyList;
</pre>
<hr />
<pre>
4538 }
4539 
4540 template &lt;class LexerType&gt;
4541 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::createResolveAndUseVariable(TreeBuilder&amp; context, const Identifier* ident, bool isEval, const JSTextPosition&amp; start, const JSTokenLocation&amp; location)
4542 {
4543     currentScope()-&gt;useVariable(ident, isEval);
4544     m_parserState.lastIdentifier = ident;
4545     return context.createResolve(location, *ident, start, lastTokenEndPosition());
4546 }
4547 
4548 template &lt;typename LexerType&gt;
4549 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parsePrimaryExpression(TreeBuilder&amp; context)
4550 {
4551     failIfStackOverflow();
4552     switch (m_token.m_type) {
4553     case FUNCTION:
4554         return parseFunctionExpression(context);
4555     case CLASSTOKEN:
4556         return parseClassExpression(context);
4557     case OPENBRACE:


4558         return parseObjectLiteral(context);
4559     case OPENBRACKET:
4560         return parseArrayLiteral(context);
4561     case OPENPAREN: {
4562         next();
4563         int oldNonLHSCount = m_parserState.nonLHSCount;
4564         TreeExpression result = parseExpression(context);
4565         m_parserState.nonLHSCount = oldNonLHSCount;
4566         handleProductionOrFail(CLOSEPAREN, &quot;)&quot;, &quot;end&quot;, &quot;compound expression&quot;);
4567         return result;
4568     }
4569     case THISTOKEN: {
4570         JSTokenLocation location(tokenLocation());
4571         next();
4572         if (currentScope()-&gt;isArrowFunction())
4573             currentScope()-&gt;setInnerArrowFunctionUsesThis();
4574         return context.createThisExpr(location);
4575     }
4576     case AWAIT:
4577         if (m_parserState.functionParsePhase == FunctionParsePhase::Parameters)
<span class="line-modified">4578             semanticFailIfFalse(m_parserState.allowAwait, &quot;Cannot use &#39;await&#39; within a parameter default expression&quot;);</span>
4579         else if (currentFunctionScope()-&gt;isAsyncFunctionBoundary())
4580             return parseAwaitExpression(context);
4581 
4582         goto identifierExpression;
4583     case IDENT: {
4584         if (UNLIKELY(*m_token.m_data.ident == m_vm.propertyNames-&gt;async &amp;&amp; !m_token.m_data.escaped)) {
4585             JSTextPosition start = tokenStartPosition();
4586             const Identifier* ident = m_token.m_data.ident;
4587             JSTokenLocation location(tokenLocation());
4588             next();
4589             if (match(FUNCTION) &amp;&amp; !m_lexer-&gt;hasLineTerminatorBeforeToken())
4590                 return parseAsyncFunctionExpression(context);
4591 
4592             // Avoid using variable if it is an arrow function parameter
4593             if (UNLIKELY(match(ARROWFUNCTION)))
4594                 return 0;
4595 
4596             const bool isEval = false;
4597             return createResolveAndUseVariable(context, ident, isEval, start, location);
4598         }
<span class="line-added">4599         if (UNLIKELY(m_parserState.isParsingClassFieldInitializer))</span>
<span class="line-added">4600             failIfTrue(*m_token.m_data.ident == m_vm.propertyNames-&gt;arguments, &quot;Cannot reference &#39;arguments&#39; in class field initializer&quot;);</span>
4601     identifierExpression:
4602         JSTextPosition start = tokenStartPosition();
4603         const Identifier* ident = m_token.m_data.ident;
<span class="line-added">4604         if (UNLIKELY(currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext))</span>
<span class="line-added">4605             failIfTrue(*ident == m_vm.propertyNames-&gt;arguments, &quot;arguments is not valid in this context&quot;);</span>
4606         JSTokenLocation location(tokenLocation());
4607         next();
4608 
4609         // Avoid using variable if it is an arrow function parameter
4610         if (UNLIKELY(match(ARROWFUNCTION)))
4611             return 0;
4612 
4613         return createResolveAndUseVariable(context, ident, *ident == m_vm.propertyNames-&gt;eval, start, location);
4614     }
4615     case BIGINT: {
4616         const Identifier* ident = m_token.m_data.bigIntString;
4617         uint8_t radix = m_token.m_data.radix;
4618         JSTokenLocation location(tokenLocation());
4619         next();
4620         return context.createBigInt(location, ident, radix);
4621     }
4622     case STRING: {
4623         const Identifier* ident = m_token.m_data.ident;
4624         JSTokenLocation location(tokenLocation());
4625         next();
</pre>
<hr />
<pre>
4780     int newCount = 0;
4781     JSTokenLocation startLocation = tokenLocation();
4782     JSTokenLocation lastNewTokenLocation;
4783     while (match(NEW)) {
4784         lastNewTokenLocation = tokenLocation();
4785         next();
4786         newCount++;
4787     }
4788     JSTokenLocation location = tokenLocation();
4789 
4790     bool baseIsSuper = match(SUPER);
4791     bool previousBaseWasSuper = false;
4792     bool baseIsImport = match(IMPORT);
4793     semanticFailIfTrue((baseIsSuper || baseIsImport) &amp;&amp; newCount, &quot;Cannot use new with &quot;, getToken());
4794 
4795     bool baseIsNewTarget = false;
4796     if (newCount &amp;&amp; match(DOT)) {
4797         next();
4798         if (matchContextualKeyword(m_vm.propertyNames-&gt;target)) {
4799             ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">4800             ScopeRef classScope = closestClassScopeOrTopLevelScope();</span>
<span class="line-added">4801             bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();</span>
<span class="line-added">4802             bool isFunctionEvalContextType = closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::FunctionEvalContext || closestOrdinaryFunctionScope-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext;</span>
<span class="line-added">4803             semanticFailIfFalse(currentScope()-&gt;isFunction() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is only valid inside functions&quot;);</span>
4804             baseIsNewTarget = true;
4805             if (currentScope()-&gt;isArrowFunction()) {
<span class="line-modified">4806                 semanticFailIfFalse(!closestOrdinaryFunctionScope-&gt;isGlobalCodeScope() || isFunctionEvalContextType || isClassFieldInitializer, &quot;new.target is not valid inside arrow functions in global code&quot;);</span>
4807                 currentScope()-&gt;setInnerArrowFunctionUsesNewTarget();
4808             }
4809             ASSERT(lastNewTokenLocation.line);
4810             base = context.createNewTargetExpr(lastNewTokenLocation);
4811             newCount--;
4812             next();
4813         } else {
4814             failIfTrue(match(IDENT), &quot;\&quot;new.\&quot; can only followed with target&quot;);
4815             failDueToUnexpectedToken();
4816         }
4817     }
4818 
4819     bool baseIsAsyncKeyword = false;
4820 
4821     if (baseIsSuper) {
4822         ScopeRef closestOrdinaryFunctionScope = closestParentOrdinaryFunctionNonLexicalScope();
<span class="line-modified">4823         ScopeRef classScope = closestClassScopeOrTopLevelScope();</span>
<span class="line-added">4824         bool isClassFieldInitializer = classScope.index() &gt; closestOrdinaryFunctionScope.index();</span>
<span class="line-added">4825         semanticFailIfFalse(currentScope()-&gt;isFunction() || isClassFieldInitializer || (closestOrdinaryFunctionScope-&gt;isEvalContext() &amp;&amp; closestOrdinaryFunctionScope-&gt;expectedSuperBinding() == SuperBinding::Needed), &quot;super is not valid in this context&quot;);</span>
4826         base = context.createSuperExpr(location);
4827         next();
<span class="line-added">4828         failIfTrue(match(OPENPAREN) &amp;&amp; currentScope()-&gt;evalContextType() == EvalContextType::InstanceFieldEvalContext, &quot;super call is not valid in this context&quot;);</span>
4829         ScopeRef functionScope = currentFunctionScope();
4830         if (!functionScope-&gt;setNeedsSuperBinding()) {
4831             // It unnecessary to check of using super during reparsing one more time. Also it can lead to syntax error
4832             // in case of arrow function because during reparsing we don&#39;t know whether we currently parse the arrow function
4833             // inside of the constructor or method.
4834             if (!m_lexer-&gt;isReparsingFunction()) {
4835                 SuperBinding functionSuperBinding = !functionScope-&gt;isArrowFunction() &amp;&amp; !closestOrdinaryFunctionScope-&gt;isEvalContext()
4836                     ? functionScope-&gt;expectedSuperBinding()
4837                     : closestOrdinaryFunctionScope-&gt;expectedSuperBinding();
<span class="line-modified">4838                 semanticFailIfTrue(functionSuperBinding == SuperBinding::NotNeeded &amp;&amp; !isClassFieldInitializer, &quot;super is not valid in this context&quot;);</span>
4839             }
4840         }
4841     } else if (baseIsImport) {
4842         next();
4843         JSTextPosition expressionEnd = lastTokenEndPosition();
4844         if (consume(DOT)) {
4845             if (matchContextualKeyword(m_vm.propertyNames-&gt;builtinNames().metaPublicName())) {
4846                 semanticFailIfFalse(m_scriptMode == JSParserScriptMode::Module, &quot;import.meta is only valid inside modules&quot;);
4847                 base = context.createImportMetaExpr(location, createResolveAndUseVariable(context, &amp;m_vm.propertyNames-&gt;metaPrivateName, false, expressionStart, location));
4848                 next();
4849             } else {
4850                 failIfTrue(match(IDENT), &quot;\&quot;import.\&quot; can only followed with meta&quot;);
4851                 failDueToUnexpectedToken();
4852             }
4853         } else {
4854             consumeOrFail(OPENPAREN, &quot;import call expects exactly one argument&quot;);
4855             TreeExpression expr = parseAssignmentExpression(context);
4856             failIfFalse(expr, &quot;Cannot parse expression&quot;);
4857             consumeOrFail(CLOSEPAREN, &quot;import call expects exactly one argument&quot;);
4858             base = context.createImportExpr(location, expr, expressionStart, expressionEnd, lastTokenEndPosition());
</pre>
<hr />
<pre>
4868                 forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4869                 failDueToUnexpectedToken();
4870             }
4871             baseIsAsyncKeyword = true;
4872         }
4873     }
4874 
4875     failIfFalse(base, &quot;Cannot parse base expression&quot;);
4876 
4877     do {
4878         TreeExpression optionalChainBase = 0;
4879         JSTokenLocation optionalChainLocation;
4880         JSTokenType type = m_token.m_type;
4881 
4882         if (match(QUESTIONDOT)) {
4883             semanticFailIfTrue(newCount, &quot;Cannot call constructor in an optional chain&quot;);
4884             semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as the base of an optional chain&quot;);
4885             optionalChainBase = base;
4886             optionalChainLocation = tokenLocation();
4887 
<span class="line-modified">4888             SavePoint savePoint = createSavePoint(context);</span>
4889             next();
4890             if (match(OPENBRACKET) || match(OPENPAREN) || match(BACKQUOTE))
4891                 type = m_token.m_type;
4892             else {
4893                 type = DOT;
<span class="line-modified">4894                 restoreSavePoint(context, savePoint);</span>
4895             }
4896         }
4897 
4898         while (true) {
4899             location = tokenLocation();
4900             switch (type) {
4901             case OPENBRACKET: {
4902                 m_parserState.nonTrivialExpressionCount++;
4903                 JSTextPosition expressionEnd = lastTokenEndPosition();
4904                 next();
4905                 int nonLHSCount = m_parserState.nonLHSCount;
4906                 int initialAssignments = m_parserState.assignmentCount;
4907                 TreeExpression property = parseExpression(context);
4908                 failIfFalse(property, &quot;Cannot parse subscript expression&quot;);
4909                 base = context.createBracketAccess(startLocation, base, property, initialAssignments != m_parserState.assignmentCount, expressionStart, expressionEnd, tokenEndPosition());
4910 
4911                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4912                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4913 
4914                 handleProductionOrFail(CLOSEBRACKET, &quot;]&quot;, &quot;end&quot;, &quot;subscript expression&quot;);
4915                 m_parserState.nonLHSCount = nonLHSCount;
4916                 break;
4917             }
4918             case OPENPAREN: {
<span class="line-added">4919                 if (baseIsSuper)</span>
<span class="line-added">4920                     failIfTrue(m_parserState.isParsingClassFieldInitializer, &quot;super call is not valid in class field initializer context&quot;);</span>
4921                 m_parserState.nonTrivialExpressionCount++;
4922                 int nonLHSCount = m_parserState.nonLHSCount;
4923                 if (newCount) {
4924                     newCount--;
4925                     JSTextPosition expressionEnd = lastTokenEndPosition();
4926                     TreeArguments arguments = parseArguments(context);
4927                     failIfFalse(arguments, &quot;Cannot parse call arguments&quot;);
4928                     base = context.createNewExpr(location, base, arguments, expressionStart, expressionEnd, lastTokenEndPosition());
4929                 } else {
4930                     size_t usedVariablesSize = currentScope()-&gt;currentUsedVariablesSize();
4931                     JSTextPosition expressionEnd = lastTokenEndPosition();
4932                     Optional&lt;CallOrApplyDepthScope&gt; callOrApplyDepthScope;
4933                     recordCallOrApplyDepth&lt;TreeBuilder&gt;(this, m_vm, callOrApplyDepthScope, base);
4934 
4935                     TreeArguments arguments = parseArguments(context);
4936 
4937                     if (baseIsAsyncKeyword &amp;&amp; (!arguments || match(ARROWFUNCTION))) {
4938                         currentScope()-&gt;revertToPreviousUsedVariables(usedVariablesSize);
4939                         forceClassifyExpressionError(ErrorIndicatesAsyncArrowFunction);
4940                         failDueToUnexpectedToken();
</pre>
<hr />
<pre>
4956                                 semanticFailIfTrue(functionConstructorKind != ConstructorKind::Extends, &quot;super is not valid in this context&quot;);
4957                             }
4958                         }
4959                         if (currentScope()-&gt;isArrowFunction())
4960                             functionScope-&gt;setInnerArrowFunctionUsesSuperCall();
4961                     }
4962 
4963                     bool isOptionalCall = optionalChainLocation.endOffset == static_cast&lt;unsigned&gt;(expressionEnd.offset);
4964                     base = context.makeFunctionCallNode(startLocation, base, previousBaseWasSuper, arguments, expressionStart,
4965                         expressionEnd, lastTokenEndPosition(), callOrApplyDepthScope ? callOrApplyDepthScope-&gt;distanceToInnermostChild() : 0, isOptionalCall);
4966 
4967                     if (isOptionalCall)
4968                         optionalChainBase = base;
4969                 }
4970                 m_parserState.nonLHSCount = nonLHSCount;
4971                 break;
4972             }
4973             case DOT: {
4974                 m_parserState.nonTrivialExpressionCount++;
4975                 JSTextPosition expressionEnd = lastTokenEndPosition();
<span class="line-modified">4976                 nextExpectIdentifier(TreeBuilder::DontBuildKeywords | LexerFlags::IgnoreReservedWords);</span>
4977                 matchOrFail(IDENT, &quot;Expected a property name after &quot;, optionalChainBase ? &quot;&#39;?.&#39;&quot; : &quot;&#39;.&#39;&quot;);
4978                 base = context.createDotAccess(startLocation, base, m_token.m_data.ident, expressionStart, expressionEnd, tokenEndPosition());
4979                 if (UNLIKELY(baseIsSuper &amp;&amp; currentScope()-&gt;isArrowFunction()))
4980                     currentFunctionScope()-&gt;setInnerArrowFunctionUsesSuperProperty();
4981                 next();
4982                 break;
4983             }
4984             case BACKQUOTE: {
4985                 semanticFailIfTrue(optionalChainBase, &quot;Cannot use tagged templates in an optional chain&quot;);
4986                 semanticFailIfTrue(baseIsSuper, &quot;Cannot use super as tag for tagged templates&quot;);
4987                 JSTextPosition expressionEnd = lastTokenEndPosition();
4988                 int nonLHSCount = m_parserState.nonLHSCount;
4989                 typename TreeBuilder::TemplateLiteral templateLiteral = parseTemplateLiteral(context, LexerType::RawStringsBuildMode::BuildRawStrings);
4990                 failIfFalse(templateLiteral, &quot;Cannot parse template literal&quot;);
4991                 base = context.createTaggedTemplate(startLocation, base, templateLiteral, expressionStart, expressionEnd, lastTokenEndPosition());
4992                 m_parserState.nonLHSCount = nonLHSCount;
4993                 m_seenTaggedTemplate = true;
4994                 break;
4995             }
4996             default:
</pre>
<hr />
<pre>
5054         return &quot;delete&quot;;
5055     }
5056     RELEASE_ASSERT_NOT_REACHED();
5057     return &quot;error&quot;;
5058 }
5059 
5060 template &lt;typename LexerType&gt;
5061 template &lt;class TreeBuilder&gt; TreeExpression Parser&lt;LexerType&gt;::parseUnaryExpression(TreeBuilder&amp; context)
5062 {
5063     typename TreeBuilder::UnaryExprContext unaryExprContext(context);
5064     AllowInOverride allowInOverride(this);
5065     int tokenStackDepth = 0;
5066     bool hasPrefixUpdateOp = false;
5067     unsigned lastOperator = 0;
5068 
5069     if (UNLIKELY(match(AWAIT) &amp;&amp; currentFunctionScope()-&gt;isAsyncFunctionBoundary()))
5070         return parseAwaitExpression(context);
5071 
5072     JSTokenLocation location(tokenLocation());
5073 
<span class="line-added">5074     int oldTokenStackDepth = context.unaryTokenStackDepth();</span>
<span class="line-added">5075     makeScopeExit([&amp;] {</span>
<span class="line-added">5076         ASSERT_UNUSED(oldTokenStackDepth, oldTokenStackDepth &lt;= context.unaryTokenStackDepth());</span>
<span class="line-added">5077     });</span>
<span class="line-added">5078 </span>
5079     while (isUnaryOp(m_token.m_type)) {
<span class="line-modified">5080         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(true, lastOperator), &quot; operator requires a reference expression&quot;);</span>
<span class="line-modified">5081         if (isUpdateOp(m_token.m_type))</span>




5082             hasPrefixUpdateOp = true;





5083         lastOperator = m_token.m_type;
5084         m_parserState.nonLHSCount++;
5085         context.appendUnaryToken(tokenStackDepth, m_token.m_type, tokenStartPosition());
5086         next();
5087         m_parserState.nonTrivialExpressionCount++;
5088     }
5089     JSTextPosition subExprStart = tokenStartPosition();
5090     ASSERT(subExprStart.offset &gt;= subExprStart.lineStartOffset);
5091     TreeExpression expr = parseMemberExpression(context);
5092     if (!expr) {
5093         if (lastOperator)
5094             failWithMessage(&quot;Cannot parse subexpression of &quot;, operatorString(true, lastOperator), &quot;operator&quot;);
5095         failWithMessage(&quot;Cannot parse member expression&quot;);
5096     }
<span class="line-added">5097     if constexpr (std::is_same_v&lt;TreeBuilder, ASTBuilder&gt;)</span>
<span class="line-added">5098         ASSERT(oldTokenStackDepth + tokenStackDepth == context.unaryTokenStackDepth());</span>
5099     if (isUpdateOp(static_cast&lt;JSTokenType&gt;(lastOperator))) {
5100         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come after a prefix operator&quot;);
5101         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Prefix &quot;, lastOperator == PLUSPLUS ? &quot;++&quot; : &quot;--&quot;, &quot; operator applied to value that is not a reference&quot;);
5102     }
5103     bool isEvalOrArguments = false;
5104     if (strictMode()) {
5105         if (context.isResolve(expr))
5106             isEvalOrArguments = *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;eval || *m_parserState.lastIdentifier == m_vm.propertyNames-&gt;arguments;
5107     }
5108     failIfTrueIfStrict(isEvalOrArguments &amp;&amp; hasPrefixUpdateOp, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5109     switch (m_token.m_type) {
5110     case PLUSPLUS:
5111         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5112         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix ++ operator applied to value that is not a reference&quot;);
5113         m_parserState.nonTrivialExpressionCount++;
5114         m_parserState.nonLHSCount++;
5115         expr = context.makePostfixNode(location, expr, OpPlusPlus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5116         m_parserState.assignmentCount++;
5117         failIfTrueIfStrict(isEvalOrArguments, &quot;Cannot modify &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5118         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5119         next();
5120         break;
5121     case MINUSMINUS:
5122         semanticFailIfTrue(context.isMetaProperty(expr), metaPropertyName(context, expr), &quot; can&#39;t come before a postfix operator&quot;);
5123         semanticFailIfFalse(isSimpleAssignmentTarget(context, expr), &quot;Postfix -- operator applied to value that is not a reference&quot;);
5124         m_parserState.nonTrivialExpressionCount++;
5125         m_parserState.nonLHSCount++;
5126         expr = context.makePostfixNode(location, expr, OpMinusMinus, subExprStart, lastTokenEndPosition(), tokenEndPosition());
5127         m_parserState.assignmentCount++;
5128         failIfTrueIfStrict(isEvalOrArguments, &quot;&#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; cannot be modified in strict mode&quot;);
5129         semanticFailIfTrue(hasPrefixUpdateOp, &quot;The &quot;, operatorString(false, lastOperator), &quot; operator requires a reference expression&quot;);
5130         next();
5131         break;
5132     default:
5133         break;
5134     }
5135 
5136     JSTextPosition end = lastTokenEndPosition();
5137     while (tokenStackDepth) {
<span class="line-modified">5138         subExprStart = context.unaryTokenStackLastStart(tokenStackDepth);</span>
<span class="line-added">5139         auto tokenType = context.unaryTokenStackLastType(tokenStackDepth);</span>
<span class="line-added">5140         switch (tokenType) {</span>
5141         case EXCLAMATION:
5142             expr = context.createLogicalNot(location, expr);
5143             break;
5144         case TILDE:
5145             expr = context.makeBitwiseNotNode(location, expr);
5146             break;
5147         case MINUS:
5148             expr = context.makeNegateNode(location, expr);
5149             break;
5150         case PLUS:
5151             expr = context.createUnaryPlus(location, expr);
5152             break;
5153         case PLUSPLUS:
5154         case AUTOPLUSPLUS:
<span class="line-modified">5155             ASSERT(isSimpleAssignmentTarget(context, expr));</span>
<span class="line-added">5156             expr = context.makePrefixNode(location, expr, OpPlusPlus, subExprStart, subExprStart + 2, end);</span>
5157             m_parserState.assignmentCount++;
5158             break;
5159         case MINUSMINUS:
5160         case AUTOMINUSMINUS:
<span class="line-modified">5161             ASSERT(isSimpleAssignmentTarget(context, expr));</span>
<span class="line-added">5162             expr = context.makePrefixNode(location, expr, OpMinusMinus, subExprStart, subExprStart + 2, end);</span>
5163             m_parserState.assignmentCount++;
5164             break;
5165         case TYPEOF:
5166             expr = context.makeTypeOfNode(location, expr);
5167             break;
5168         case VOIDTOKEN:
5169             expr = context.createVoid(location, expr);
5170             break;
5171         case DELETETOKEN:
5172             failIfTrueIfStrict(context.isResolve(expr), &quot;Cannot delete unqualified property &#39;&quot;, m_parserState.lastIdentifier-&gt;impl(), &quot;&#39; in strict mode&quot;);
5173             expr = context.makeDeleteNode(location, expr, context.unaryTokenStackLastStart(tokenStackDepth), end, end);
5174             break;
5175         default:
5176             // If we get here something has gone horribly horribly wrong
5177             CRASH();
5178         }

5179         context.unaryTokenStackRemoveLast(tokenStackDepth);
5180     }
5181     return expr;
5182 }
5183 
5184 template &lt;typename LexerType&gt; void Parser&lt;LexerType&gt;::printUnexpectedTokenText(WTF::PrintStream&amp; out)
5185 {
5186     switch (m_token.m_type) {
5187     case EOFTOK:
5188         out.print(&quot;Unexpected end of script&quot;);
5189         return;
5190     case UNTERMINATED_IDENTIFIER_ESCAPE_ERRORTOK:
5191     case UNTERMINATED_IDENTIFIER_UNICODE_ESCAPE_ERRORTOK:
5192         out.print(&quot;Incomplete unicode escape in identifier: &#39;&quot;, getToken(), &quot;&#39;&quot;);
5193         return;
5194     case UNTERMINATED_MULTILINE_COMMENT_ERRORTOK:
5195         out.print(&quot;Unterminated multiline comment&quot;);
5196         return;
5197     case UNTERMINATED_NUMERIC_LITERAL_ERRORTOK:
5198         out.print(&quot;Unterminated numeric literal &#39;&quot;, getToken(), &quot;&#39;&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="Nodes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../style/WillChangeData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGImage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 
 38 RenderSVGEllipse::RenderSVGEllipse(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 39     : RenderSVGShape(element, WTFMove(style))
 40     , m_usePathFallback(false)
 41 {
 42 }
 43 
 44 RenderSVGEllipse::~RenderSVGEllipse() = default;
 45 
 46 void RenderSVGEllipse::updateShapeFromElement()
 47 {
 48     // Before creating a new object we need to clear the cached bounding box
 49     // to avoid using garbage.
 50     m_fillBoundingBox = FloatRect();
 51     m_strokeBoundingBox = FloatRect();
 52     m_center = FloatPoint();
 53     m_radii = FloatSize();
 54 
 55     calculateRadiiAndCenter();
 56 
<span class="line-modified"> 57     // Element is invalid if either dimension is negative.</span>
<span class="line-modified"> 58     if (m_radii.width() &lt; 0 || m_radii.height() &lt; 0)</span>
 59         return;
 60 
<span class="line-modified"> 61     // Spec: &quot;A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 62     if (!m_radii.isEmpty()) {</span>
<span class="line-modified"> 63         if (hasNonScalingStroke()) {</span>
<span class="line-modified"> 64             // Fallback to RenderSVGShape if shape has a non-scaling stroke.</span>
<span class="line-modified"> 65             RenderSVGShape::updateShapeFromElement();</span>
<span class="line-removed"> 66             m_usePathFallback = true;</span>
<span class="line-removed"> 67             return;</span>
<span class="line-removed"> 68         }</span>
<span class="line-removed"> 69         m_usePathFallback = false;</span>
 70     }
 71 


 72     m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
 73     m_strokeBoundingBox = m_fillBoundingBox;
 74     if (style().svgStyle().hasStroke())
 75         m_strokeBoundingBox.inflate(strokeWidth() / 2);
 76 }
 77 
 78 void RenderSVGEllipse::calculateRadiiAndCenter()
 79 {
 80     SVGLengthContext lengthContext(&amp;graphicsElement());
 81     m_center = FloatPoint(
<span class="line-modified"> 82         lengthContext.valueForLength(style().svgStyle().cx(), LengthModeWidth),</span>
<span class="line-modified"> 83         lengthContext.valueForLength(style().svgStyle().cy(), LengthModeHeight));</span>
 84     if (is&lt;SVGCircleElement&gt;(graphicsElement())) {
 85         float radius = lengthContext.valueForLength(style().svgStyle().r());
 86         m_radii = FloatSize(radius, radius);
 87         return;
 88     }
 89 
 90     ASSERT(is&lt;SVGEllipseElement&gt;(graphicsElement()));



 91     m_radii = FloatSize(
<span class="line-modified"> 92         lengthContext.valueForLength(style().svgStyle().rx(), LengthModeWidth),</span>
<span class="line-modified"> 93         lengthContext.valueForLength(style().svgStyle().ry(), LengthModeHeight));</span>
 94 }
 95 
 96 void RenderSVGEllipse::fillShape(GraphicsContext&amp; context) const
 97 {
 98     if (m_usePathFallback) {
 99         RenderSVGShape::fillShape(context);
100         return;
101     }
102     context.fillEllipse(m_fillBoundingBox);
103 }
104 
105 void RenderSVGEllipse::strokeShape(GraphicsContext&amp; context) const
106 {
107     if (!style().hasVisibleStroke())
108         return;
109     if (m_usePathFallback) {
110         RenderSVGShape::strokeShape(context);
111         return;
112     }
113     context.strokeEllipse(m_fillBoundingBox);
</pre>
</td>
<td>
<hr />
<pre>
 37 
 38 RenderSVGEllipse::RenderSVGEllipse(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 39     : RenderSVGShape(element, WTFMove(style))
 40     , m_usePathFallback(false)
 41 {
 42 }
 43 
 44 RenderSVGEllipse::~RenderSVGEllipse() = default;
 45 
 46 void RenderSVGEllipse::updateShapeFromElement()
 47 {
 48     // Before creating a new object we need to clear the cached bounding box
 49     // to avoid using garbage.
 50     m_fillBoundingBox = FloatRect();
 51     m_strokeBoundingBox = FloatRect();
 52     m_center = FloatPoint();
 53     m_radii = FloatSize();
 54 
 55     calculateRadiiAndCenter();
 56 
<span class="line-modified"> 57     // Spec: &quot;A negative value is illegal. A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 58     if (m_radii.isEmpty())</span>
 59         return;
 60 
<span class="line-modified"> 61     if (hasNonScalingStroke()) {</span>
<span class="line-modified"> 62         // Fallback to RenderSVGShape if shape has a non-scaling stroke.</span>
<span class="line-modified"> 63         RenderSVGShape::updateShapeFromElement();</span>
<span class="line-modified"> 64         m_usePathFallback = true;</span>
<span class="line-modified"> 65         return;</span>




 66     }
 67 
<span class="line-added"> 68     m_usePathFallback = false;</span>
<span class="line-added"> 69 </span>
 70     m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
 71     m_strokeBoundingBox = m_fillBoundingBox;
 72     if (style().svgStyle().hasStroke())
 73         m_strokeBoundingBox.inflate(strokeWidth() / 2);
 74 }
 75 
 76 void RenderSVGEllipse::calculateRadiiAndCenter()
 77 {
 78     SVGLengthContext lengthContext(&amp;graphicsElement());
 79     m_center = FloatPoint(
<span class="line-modified"> 80         lengthContext.valueForLength(style().svgStyle().cx(), SVGLengthMode::Width),</span>
<span class="line-modified"> 81         lengthContext.valueForLength(style().svgStyle().cy(), SVGLengthMode::Height));</span>
 82     if (is&lt;SVGCircleElement&gt;(graphicsElement())) {
 83         float radius = lengthContext.valueForLength(style().svgStyle().r());
 84         m_radii = FloatSize(radius, radius);
 85         return;
 86     }
 87 
 88     ASSERT(is&lt;SVGEllipseElement&gt;(graphicsElement()));
<span class="line-added"> 89 </span>
<span class="line-added"> 90     Length rx = style().svgStyle().rx();</span>
<span class="line-added"> 91     Length ry = style().svgStyle().ry();</span>
 92     m_radii = FloatSize(
<span class="line-modified"> 93         lengthContext.valueForLength(rx.isAuto() ? ry : rx, SVGLengthMode::Width),</span>
<span class="line-modified"> 94         lengthContext.valueForLength(ry.isAuto() ? rx : ry, SVGLengthMode::Height));</span>
 95 }
 96 
 97 void RenderSVGEllipse::fillShape(GraphicsContext&amp; context) const
 98 {
 99     if (m_usePathFallback) {
100         RenderSVGShape::fillShape(context);
101         return;
102     }
103     context.fillEllipse(m_fillBoundingBox);
104 }
105 
106 void RenderSVGEllipse::strokeShape(GraphicsContext&amp; context) const
107 {
108     if (!style().hasVisibleStroke())
109         return;
110     if (m_usePathFallback) {
111         RenderSVGShape::strokeShape(context);
112         return;
113     }
114     context.strokeEllipse(m_fillBoundingBox);
</pre>
</td>
</tr>
</table>
<center><a href="../style/WillChangeData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGImage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NameNodeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;ProcessingInstruction.h&quot;
  62 #include &quot;ProgressEvent.h&quot;
  63 #include &quot;Range.h&quot;
  64 #include &quot;RenderBlock.h&quot;
  65 #include &quot;RenderBox.h&quot;
  66 #include &quot;RenderTextControl.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;SVGElement.h&quot;
  69 #include &quot;ScopedEventQueue.h&quot;
  70 #include &quot;ScriptDisallowedScope.h&quot;
  71 #include &quot;StorageEvent.h&quot;
  72 #include &quot;StyleResolver.h&quot;
  73 #include &quot;StyleSheetContents.h&quot;
  74 #include &quot;TemplateContentDocumentFragment.h&quot;
  75 #include &quot;TextEvent.h&quot;
  76 #include &quot;TouchEvent.h&quot;
  77 #include &quot;WheelEvent.h&quot;
  78 #include &quot;XMLNSNames.h&quot;
  79 #include &quot;XMLNames.h&quot;

  80 #include &lt;wtf/IsoMallocInlines.h&gt;
  81 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  82 #include &lt;wtf/SHA1.h&gt;
  83 #include &lt;wtf/Variant.h&gt;
  84 #include &lt;wtf/text/CString.h&gt;
  85 #include &lt;wtf/text/StringBuilder.h&gt;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(Node);
  90 
  91 using namespace HTMLNames;
  92 
  93 #if DUMP_NODE_STATISTICS
  94 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  95 {
  96     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  97     return liveNodes;
  98 }
  99 
</pre>
<hr />
<pre>
 346 #if DUMP_NODE_STATISTICS
 347     liveNodeSet().remove(this);
 348 #endif
 349 
 350     RELEASE_ASSERT(!renderer());
 351     ASSERT(!parentNode());
 352     ASSERT(!m_previous);
 353     ASSERT(!m_next);
 354 
 355     if (hasRareData())
 356         clearRareData();
 357 
 358     if (!isContainerNode())
 359         willBeDeletedFrom(document());
 360 
 361     if (hasEventTargetData())
 362         clearEventTargetData();
 363 
 364     document().decrementReferencingNodeCount();
 365 
<span class="line-modified"> 366 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (!ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS))</span>
 367     for (auto* document : Document::allDocuments()) {
 368         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
 369         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
 370         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
 371     }
 372 #endif
 373 }
 374 
 375 void Node::willBeDeletedFrom(Document&amp; document)
 376 {
 377     if (hasEventTargetData()) {
 378         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 379 #if ENABLE(TOUCH_EVENTS)
 380 #if PLATFORM(IOS_FAMILY)
 381         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 382 #endif
 383         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 384 #endif
 385     }
 386 
</pre>
<hr />
<pre>
 652             // Care must be taken to get the next node before removing the current node.
 653             node = NodeTraversal::nextPostOrder(*node);
 654             text-&gt;remove();
 655             continue;
 656         }
 657 
 658         // Merge text nodes.
 659         while (Node* nextSibling = node-&gt;nextSibling()) {
 660             if (nextSibling-&gt;nodeType() != TEXT_NODE)
 661                 break;
 662             Ref&lt;Text&gt; nextText = downcast&lt;Text&gt;(*nextSibling);
 663 
 664             // Remove empty text nodes.
 665             if (!nextText-&gt;length()) {
 666                 nextText-&gt;remove();
 667                 continue;
 668             }
 669 
 670             // Both non-empty text nodes. Merge them.
 671             unsigned offset = text-&gt;length();
<span class="line-modified"> 672             text-&gt;appendData(nextText-&gt;data());</span>

 673             document().textNodesMerged(nextText, offset);




 674             nextText-&gt;remove();
 675         }
 676 
 677         node = NodeTraversal::nextPostOrder(*node);
 678     }
 679 }
 680 
 681 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 682 {
 683     if (UNLIKELY(isShadowRoot()))
 684         return Exception { NotSupportedError };
 685     return cloneNode(deep);
 686 }
 687 
 688 const AtomString&amp; Node::prefix() const
 689 {
 690     // For nodes other than elements and attributes, the prefix is always null
 691     return nullAtom();
 692 }
 693 
</pre>
<hr />
<pre>
1112         // but if the element is draggable then dragging should take priority over selection.
1113         if (style.userDrag() == UserDrag::Element &amp;&amp; style.userSelect() == UserSelect::None)
1114             return false;
1115     }
1116     return parentOrShadowHostNode() ? parentOrShadowHostNode()-&gt;canStartSelection() : true;
1117 }
1118 
1119 Element* Node::shadowHost() const
1120 {
1121     if (ShadowRoot* root = containingShadowRoot())
1122         return root-&gt;host();
1123     return nullptr;
1124 }
1125 
1126 ShadowRoot* Node::containingShadowRoot() const
1127 {
1128     ContainerNode&amp; root = treeScope().rootNode();
1129     return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
1130 }
1131 
<span class="line-modified">1132 #if !ASSERT_DISABLED</span>
1133 // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
1134 static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
1135 {
1136     return A.isInShadowTree()
1137         &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
1138         &amp;&amp; (A.containingShadowRoot()-&gt;mode() != ShadowRootMode::Open || isClosedShadowHiddenUsingSpecDefinition(*A.shadowHost(), B));
1139 }
1140 #endif
1141 
1142 // http://w3c.github.io/webcomponents/spec/shadow/#dfn-unclosed-node
1143 bool Node::isClosedShadowHidden(const Node&amp; otherNode) const
1144 {
1145     // Use Vector instead of HashSet since we expect the number of ancestor tree scopes to be small.
1146     Vector&lt;TreeScope*, 8&gt; ancestorScopesOfThisNode;
1147 
1148     for (auto* scope = &amp;treeScope(); scope; scope = scope-&gt;parentTreeScope())
1149         ancestorScopesOfThisNode.append(scope);
1150 
1151     for (auto* treeScopeThatCanAccessOtherNode = &amp;otherNode.treeScope(); treeScopeThatCanAccessOtherNode; treeScopeThatCanAccessOtherNode = treeScopeThatCanAccessOtherNode-&gt;parentTreeScope()) {
1152         for (auto* scope : ancestorScopesOfThisNode) {
</pre>
<hr />
<pre>
1592     sha1.computeHash(digest);
1593     return digest;
1594 }
1595 
1596 static inline unsigned short compareDetachedElementsPosition(Node&amp; firstNode, Node&amp; secondNode)
1597 {
1598     // If the 2 nodes are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,
1599     // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or
1600     // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent. Whether to return
1601     // DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is implemented by comparing cryptographic
1602     // hashes of Node pointers.
1603     // See step 3 in https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
1604     SHA1::Digest firstHash = hashPointer(&amp;firstNode);
1605     SHA1::Digest secondHash = hashPointer(&amp;secondNode);
1606 
1607     unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
1608 
1609     return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
1610 }
1611 








1612 unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
1613 {
1614     if (&amp;otherNode == this)
1615         return DOCUMENT_POSITION_EQUIVALENT;
1616 
1617     Attr* attr1 = is&lt;Attr&gt;(*this) ? downcast&lt;Attr&gt;(this) : nullptr;
1618     Attr* attr2 = is&lt;Attr&gt;(otherNode) ? &amp;downcast&lt;Attr&gt;(otherNode) : nullptr;
1619 
1620     Node* start1 = attr1 ? attr1-&gt;ownerElement() : this;
1621     Node* start2 = attr2 ? attr2-&gt;ownerElement() : &amp;otherNode;
1622 
1623     // If either of start1 or start2 is null, then we are disconnected, since one of the nodes is
1624     // an orphaned attribute node.
1625     if (!start1 || !start2)
1626         return compareDetachedElementsPosition(*this, otherNode);
1627 
1628     Vector&lt;Node*, 16&gt; chain1;
1629     Vector&lt;Node*, 16&gt; chain2;
1630     if (attr1)
1631         chain1.append(attr1);
</pre>
<hr />
<pre>
1636         // We are comparing two attributes on the same node. Crawl our attribute map and see which one we hit first.
1637         Element* owner1 = attr1-&gt;ownerElement();
1638         owner1-&gt;synchronizeAllAttributes();
1639         for (const Attribute&amp; attribute : owner1-&gt;attributesIterator()) {
1640             // If neither of the two determining nodes is a child node and nodeType is the same for both determining nodes, then an
1641             // implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of
1642             // the same nodeType are inserted into or removed from the direct container. This would be the case, for example,
1643             // when comparing two attributes of the same element, and inserting or removing additional attributes might change
1644             // the order between existing attributes.
1645             if (attr1-&gt;qualifiedName() == attribute.name())
1646                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_FOLLOWING;
1647             if (attr2-&gt;qualifiedName() == attribute.name())
1648                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_PRECEDING;
1649         }
1650 
1651         ASSERT_NOT_REACHED();
1652         return DOCUMENT_POSITION_DISCONNECTED;
1653     }
1654 
1655     // If one node is in the document and the other is not, we must be disconnected.
<span class="line-modified">1656     // If the nodes have different owning documents, they must be disconnected.  Note that we avoid</span>
<span class="line-modified">1657     // comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="line-removed">1658     if (start1-&gt;isConnected() != start2-&gt;isConnected() || &amp;start1-&gt;treeScope() != &amp;start2-&gt;treeScope())</span>
1659         return compareDetachedElementsPosition(*this, otherNode);
1660 
1661     // We need to find a common ancestor container, and then compare the indices of the two immediate children.
1662     Node* current;
1663     for (current = start1; current; current = current-&gt;parentNode())
1664         chain1.append(current);
1665     for (current = start2; current; current = current-&gt;parentNode())
1666         chain2.append(current);
1667 
1668     unsigned index1 = chain1.size();
1669     unsigned index2 = chain2.size();
1670 
1671     // If the two elements don&#39;t have a common root, they&#39;re not in the same tree.
1672     if (chain1[index1 - 1] != chain2[index2 - 1])
1673         return compareDetachedElementsPosition(*this, otherNode);
1674 
1675     // Walk the two chains backwards and look for the first difference.
1676     for (unsigned i = std::min(index1, index2); i; --i) {
1677         Node* child1 = chain1[--index1];
1678         Node* child2 = chain2[--index2];
</pre>
<hr />
<pre>
1889             showSubTreeAcrossFrame(shadowRoot, markedNode, indent + &quot;\t&quot;);
1890     }
1891     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
1892         showSubTreeAcrossFrame(child, markedNode, indent + &quot;\t&quot;);
1893 }
1894 
1895 void Node::showTreeForThisAcrossFrame() const
1896 {
1897     Node* rootNode = const_cast&lt;Node*&gt;(this);
1898     while (parentOrShadowHostOrFrameOwner(rootNode))
1899         rootNode = parentOrShadowHostOrFrameOwner(rootNode);
1900     showSubTreeAcrossFrame(rootNode, this, &quot;&quot;);
1901 }
1902 
1903 #endif // ENABLE(TREE_DEBUGGING)
1904 
1905 // --------
1906 
1907 void NodeListsNodeData::invalidateCaches()
1908 {
<span class="line-modified">1909     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="line-modified">1910         atomicName.value-&gt;invalidateCache();</span>
1911 
1912     for (auto&amp; collection : m_cachedCollections)
1913         collection.value-&gt;invalidateCache();
1914 
1915     for (auto&amp; tagCollection : m_tagCollectionNSCache)
1916         tagCollection.value-&gt;invalidateCache();
1917 }
1918 
1919 void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
1920 {
<span class="line-modified">1921     for (auto&amp; atomicName : m_atomicNameCaches)</span>
<span class="line-modified">1922         atomicName.value-&gt;invalidateCacheForAttribute(attrName);</span>
1923 
1924     for (auto&amp; collection : m_cachedCollections)
1925         collection.value-&gt;invalidateCacheForAttribute(attrName);
1926 }
1927 
1928 void Node::getSubresourceURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1929 {
1930     addSubresourceAttributeURLs(urls);
1931 }
1932 
1933 Element* Node::enclosingLinkEventParentOrSelf()
1934 {
1935     for (Node* node = this; node; node = node-&gt;parentInComposedTree()) {
1936         // For imagemaps, the enclosing link element is the associated area element not the image itself.
1937         // So we don&#39;t let images be the enclosing link element, even though isLink sometimes returns
1938         // true for them.
1939         if (node-&gt;isLink() &amp;&amp; !is&lt;HTMLImageElement&gt;(*node))
1940             return downcast&lt;Element&gt;(node);
1941     }
1942 
</pre>
<hr />
<pre>
2071             oldDocument.didRemoveTouchEventHandler(*this);
2072             newDocument.didAddTouchEventHandler(*this);
2073 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2074             oldDocument.removeTouchEventListener(*this);
2075             newDocument.addTouchEventListener(*this);
2076 #endif
2077         }
2078 
2079 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2080         unsigned numGestureEventListeners = 0;
2081         for (auto&amp; name : eventNames().gestureEventNames())
2082             numGestureEventListeners += eventListeners(name).size();
2083 
2084         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2085             oldDocument.removeTouchEventHandler(*this);
2086             newDocument.addTouchEventHandler(*this);
2087         }
2088 #endif
2089     }
2090 
<span class="line-modified">2091 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
2092 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2093     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2094     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2095 #endif
2096 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2097     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2098 #endif
2099 #endif
2100 
2101     if (is&lt;Element&gt;(*this))
2102         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2103 }
2104 
2105 static inline bool tryAddEventListener(Node* targetNode, const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)
2106 {
2107     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2108         return false;
2109 
2110     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2111     if (eventNames().isWheelEventType(eventType))
2112         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
2113     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2114         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2115 
2116 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2117     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="line-modified">2118         targetNode-&gt;document().domWindow()-&gt;incrementScrollEventListenersCount();</span>


2119 
2120 #if ENABLE(TOUCH_EVENTS)
2121     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2122         targetNode-&gt;document().addTouchEventListener(*targetNode);
2123 #endif
2124 #endif // PLATFORM(IOS_FAMILY)
2125 
2126 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2127     if (eventNames().isGestureEventType(eventType))
2128         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2129 #endif
2130 
2131     return true;
2132 }
2133 
2134 bool Node::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
2135 {
2136     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2137 }
2138 
2139 static inline bool tryRemoveEventListener(Node* targetNode, const AtomString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)
2140 {
2141     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2142         return false;
2143 
2144     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2145     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2146     if (eventNames().isWheelEventType(eventType))
2147         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
2148     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2149         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2150 
2151 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2152     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent)</span>
<span class="line-modified">2153         targetNode-&gt;document().domWindow()-&gt;decrementScrollEventListenersCount();</span>


2154 
2155 #if ENABLE(TOUCH_EVENTS)
2156     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2157         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2158 #endif
2159 #endif // PLATFORM(IOS_FAMILY)
2160 
2161 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2162     if (eventNames().isGestureEventType(eventType))
2163         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2164 #endif
2165 
2166     return true;
2167 }
2168 
2169 bool Node::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2170 {
2171     return tryRemoveEventListener(this, eventType, listener, options);
2172 }
2173 
</pre>
<hr />
<pre>
2411         }
2412     } else if (eventType == eventNames().clickEvent) {
2413         dispatchDOMActivateEvent(event);
2414 #if ENABLE(CONTEXT_MENUS)
2415     } else if (eventType == eventNames().contextmenuEvent) {
2416         if (Frame* frame = document().frame())
2417             if (Page* page = frame-&gt;page())
2418                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2419 #endif
2420     } else if (eventType == eventNames().textInputEvent) {
2421         if (is&lt;TextEvent&gt;(event)) {
2422             if (Frame* frame = document().frame())
2423                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2424         }
2425 #if ENABLE(PAN_SCROLLING)
2426     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2427         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2428             if (enclosingLinkEventParentOrSelf())
2429                 return;
2430 






2431             RenderObject* renderer = this-&gt;renderer();
2432             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2433                 renderer = renderer-&gt;parent();
2434 
2435             if (renderer) {
2436                 if (Frame* frame = document().frame())
2437                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2438             }
2439         }
2440 #endif
2441     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2442         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2443         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2444         Node* startNode = this;
2445         while (startNode &amp;&amp; !startNode-&gt;renderer())
2446             startNode = startNode-&gt;parentOrShadowHostNode();
2447 
2448         if (startNode &amp;&amp; startNode-&gt;renderer())
2449             if (Frame* frame = document().frame())
2450                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
</pre>
<hr />
<pre>
2506 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2507 // delete a Node at each deref call site.
2508 void Node::removedLastRef()
2509 {
2510     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
2511 
2512     // An explicit check for Document here is better than a virtual function since it is
2513     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2514     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2515     if (is&lt;Document&gt;(*this)) {
2516         downcast&lt;Document&gt;(*this).removedLastRef();
2517         return;
2518     }
2519 
2520     // Now it is time to detach the SVGElement from all its properties. These properties
2521     // may outlive the SVGElement. The only difference after the detach is no commit will
2522     // be carried out unless these properties are attached to another owner.
2523     if (is&lt;SVGElement&gt;(*this))
2524         downcast&lt;SVGElement&gt;(*this).detachAllProperties();
2525 
<span class="line-modified">2526 #ifndef NDEBUG</span>
2527     m_deletionHasBegun = true;
2528 #endif
2529     delete this;
2530 }
2531 
2532 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2533 {
2534     auto range = Range::create(document());
2535     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2536     range-&gt;absoluteTextRects(rects);
2537 }
2538 
2539 unsigned Node::connectedSubframeCount() const
2540 {
2541     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2542 }
2543 
2544 void Node::incrementConnectedSubframeCount(unsigned amount)
2545 {
2546     ASSERT(isContainerNode());
</pre>
</td>
<td>
<hr />
<pre>
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;ProcessingInstruction.h&quot;
  62 #include &quot;ProgressEvent.h&quot;
  63 #include &quot;Range.h&quot;
  64 #include &quot;RenderBlock.h&quot;
  65 #include &quot;RenderBox.h&quot;
  66 #include &quot;RenderTextControl.h&quot;
  67 #include &quot;RenderView.h&quot;
  68 #include &quot;SVGElement.h&quot;
  69 #include &quot;ScopedEventQueue.h&quot;
  70 #include &quot;ScriptDisallowedScope.h&quot;
  71 #include &quot;StorageEvent.h&quot;
  72 #include &quot;StyleResolver.h&quot;
  73 #include &quot;StyleSheetContents.h&quot;
  74 #include &quot;TemplateContentDocumentFragment.h&quot;
  75 #include &quot;TextEvent.h&quot;
  76 #include &quot;TouchEvent.h&quot;
  77 #include &quot;WheelEvent.h&quot;
  78 #include &quot;XMLNSNames.h&quot;
  79 #include &quot;XMLNames.h&quot;
<span class="line-added">  80 #include &lt;JavaScriptCore/HeapInlines.h&gt;</span>
  81 #include &lt;wtf/IsoMallocInlines.h&gt;
  82 #include &lt;wtf/RefCountedLeakCounter.h&gt;
  83 #include &lt;wtf/SHA1.h&gt;
  84 #include &lt;wtf/Variant.h&gt;
  85 #include &lt;wtf/text/CString.h&gt;
  86 #include &lt;wtf/text/StringBuilder.h&gt;
  87 
  88 namespace WebCore {
  89 
  90 WTF_MAKE_ISO_ALLOCATED_IMPL(Node);
  91 
  92 using namespace HTMLNames;
  93 
  94 #if DUMP_NODE_STATISTICS
  95 static HashSet&lt;Node*&gt;&amp; liveNodeSet()
  96 {
  97     static NeverDestroyed&lt;HashSet&lt;Node*&gt;&gt; liveNodes;
  98     return liveNodes;
  99 }
 100 
</pre>
<hr />
<pre>
 347 #if DUMP_NODE_STATISTICS
 348     liveNodeSet().remove(this);
 349 #endif
 350 
 351     RELEASE_ASSERT(!renderer());
 352     ASSERT(!parentNode());
 353     ASSERT(!m_previous);
 354     ASSERT(!m_next);
 355 
 356     if (hasRareData())
 357         clearRareData();
 358 
 359     if (!isContainerNode())
 360         willBeDeletedFrom(document());
 361 
 362     if (hasEventTargetData())
 363         clearEventTargetData();
 364 
 365     document().decrementReferencingNodeCount();
 366 
<span class="line-modified"> 367 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY) &amp;&amp; (ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS))</span>
 368     for (auto* document : Document::allDocuments()) {
 369         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventListenersContain(*this));
 370         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventHandlersContain(*this));
 371         ASSERT_WITH_SECURITY_IMPLICATION(!document-&gt;touchEventTargetsContain(*this));
 372     }
 373 #endif
 374 }
 375 
 376 void Node::willBeDeletedFrom(Document&amp; document)
 377 {
 378     if (hasEventTargetData()) {
 379         document.didRemoveWheelEventHandler(*this, EventHandlerRemoval::All);
 380 #if ENABLE(TOUCH_EVENTS)
 381 #if PLATFORM(IOS_FAMILY)
 382         document.removeTouchEventListener(*this, EventHandlerRemoval::All);
 383 #endif
 384         document.didRemoveTouchEventHandler(*this, EventHandlerRemoval::All);
 385 #endif
 386     }
 387 
</pre>
<hr />
<pre>
 653             // Care must be taken to get the next node before removing the current node.
 654             node = NodeTraversal::nextPostOrder(*node);
 655             text-&gt;remove();
 656             continue;
 657         }
 658 
 659         // Merge text nodes.
 660         while (Node* nextSibling = node-&gt;nextSibling()) {
 661             if (nextSibling-&gt;nodeType() != TEXT_NODE)
 662                 break;
 663             Ref&lt;Text&gt; nextText = downcast&lt;Text&gt;(*nextSibling);
 664 
 665             // Remove empty text nodes.
 666             if (!nextText-&gt;length()) {
 667                 nextText-&gt;remove();
 668                 continue;
 669             }
 670 
 671             // Both non-empty text nodes. Merge them.
 672             unsigned offset = text-&gt;length();
<span class="line-modified"> 673 </span>
<span class="line-added"> 674             // Update start/end for any affected Ranges before appendData since modifying contents might trigger mutation events that modify ordering.</span>
 675             document().textNodesMerged(nextText, offset);
<span class="line-added"> 676 </span>
<span class="line-added"> 677             // FIXME: DOM spec requires contents to be replaced all at once (see https://dom.spec.whatwg.org/#dom-node-normalize).</span>
<span class="line-added"> 678             // Appending once per sibling may trigger mutation events too many times.</span>
<span class="line-added"> 679             text-&gt;appendData(nextText-&gt;data());</span>
 680             nextText-&gt;remove();
 681         }
 682 
 683         node = NodeTraversal::nextPostOrder(*node);
 684     }
 685 }
 686 
 687 ExceptionOr&lt;Ref&lt;Node&gt;&gt; Node::cloneNodeForBindings(bool deep)
 688 {
 689     if (UNLIKELY(isShadowRoot()))
 690         return Exception { NotSupportedError };
 691     return cloneNode(deep);
 692 }
 693 
 694 const AtomString&amp; Node::prefix() const
 695 {
 696     // For nodes other than elements and attributes, the prefix is always null
 697     return nullAtom();
 698 }
 699 
</pre>
<hr />
<pre>
1118         // but if the element is draggable then dragging should take priority over selection.
1119         if (style.userDrag() == UserDrag::Element &amp;&amp; style.userSelect() == UserSelect::None)
1120             return false;
1121     }
1122     return parentOrShadowHostNode() ? parentOrShadowHostNode()-&gt;canStartSelection() : true;
1123 }
1124 
1125 Element* Node::shadowHost() const
1126 {
1127     if (ShadowRoot* root = containingShadowRoot())
1128         return root-&gt;host();
1129     return nullptr;
1130 }
1131 
1132 ShadowRoot* Node::containingShadowRoot() const
1133 {
1134     ContainerNode&amp; root = treeScope().rootNode();
1135     return is&lt;ShadowRoot&gt;(root) ? downcast&lt;ShadowRoot&gt;(&amp;root) : nullptr;
1136 }
1137 
<span class="line-modified">1138 #if ASSERT_ENABLED</span>
1139 // https://dom.spec.whatwg.org/#concept-closed-shadow-hidden
1140 static bool isClosedShadowHiddenUsingSpecDefinition(const Node&amp; A, const Node&amp; B)
1141 {
1142     return A.isInShadowTree()
1143         &amp;&amp; !A.rootNode().containsIncludingShadowDOM(&amp;B)
1144         &amp;&amp; (A.containingShadowRoot()-&gt;mode() != ShadowRootMode::Open || isClosedShadowHiddenUsingSpecDefinition(*A.shadowHost(), B));
1145 }
1146 #endif
1147 
1148 // http://w3c.github.io/webcomponents/spec/shadow/#dfn-unclosed-node
1149 bool Node::isClosedShadowHidden(const Node&amp; otherNode) const
1150 {
1151     // Use Vector instead of HashSet since we expect the number of ancestor tree scopes to be small.
1152     Vector&lt;TreeScope*, 8&gt; ancestorScopesOfThisNode;
1153 
1154     for (auto* scope = &amp;treeScope(); scope; scope = scope-&gt;parentTreeScope())
1155         ancestorScopesOfThisNode.append(scope);
1156 
1157     for (auto* treeScopeThatCanAccessOtherNode = &amp;otherNode.treeScope(); treeScopeThatCanAccessOtherNode; treeScopeThatCanAccessOtherNode = treeScopeThatCanAccessOtherNode-&gt;parentTreeScope()) {
1158         for (auto* scope : ancestorScopesOfThisNode) {
</pre>
<hr />
<pre>
1598     sha1.computeHash(digest);
1599     return digest;
1600 }
1601 
1602 static inline unsigned short compareDetachedElementsPosition(Node&amp; firstNode, Node&amp; secondNode)
1603 {
1604     // If the 2 nodes are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,
1605     // DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or
1606     // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent. Whether to return
1607     // DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is implemented by comparing cryptographic
1608     // hashes of Node pointers.
1609     // See step 3 in https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
1610     SHA1::Digest firstHash = hashPointer(&amp;firstNode);
1611     SHA1::Digest secondHash = hashPointer(&amp;secondNode);
1612 
1613     unsigned short direction = memcmp(firstHash.data(), secondHash.data(), SHA1::hashSize) &gt; 0 ? Node::DOCUMENT_POSITION_PRECEDING : Node::DOCUMENT_POSITION_FOLLOWING;
1614 
1615     return Node::DOCUMENT_POSITION_DISCONNECTED | Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | direction;
1616 }
1617 
<span class="line-added">1618 bool areNodesConnectedInSameTreeScope(const Node* a, const Node* b)</span>
<span class="line-added">1619 {</span>
<span class="line-added">1620     if (!a || !b)</span>
<span class="line-added">1621         return false;</span>
<span class="line-added">1622     // Note that we avoid comparing Attr nodes here, since they return false from isConnected() all the time (which seems like a bug).</span>
<span class="line-added">1623     return a-&gt;isConnected() == b-&gt;isConnected() &amp;&amp; &amp;a-&gt;treeScope() == &amp;b-&gt;treeScope();</span>
<span class="line-added">1624 }</span>
<span class="line-added">1625 </span>
1626 unsigned short Node::compareDocumentPosition(Node&amp; otherNode)
1627 {
1628     if (&amp;otherNode == this)
1629         return DOCUMENT_POSITION_EQUIVALENT;
1630 
1631     Attr* attr1 = is&lt;Attr&gt;(*this) ? downcast&lt;Attr&gt;(this) : nullptr;
1632     Attr* attr2 = is&lt;Attr&gt;(otherNode) ? &amp;downcast&lt;Attr&gt;(otherNode) : nullptr;
1633 
1634     Node* start1 = attr1 ? attr1-&gt;ownerElement() : this;
1635     Node* start2 = attr2 ? attr2-&gt;ownerElement() : &amp;otherNode;
1636 
1637     // If either of start1 or start2 is null, then we are disconnected, since one of the nodes is
1638     // an orphaned attribute node.
1639     if (!start1 || !start2)
1640         return compareDetachedElementsPosition(*this, otherNode);
1641 
1642     Vector&lt;Node*, 16&gt; chain1;
1643     Vector&lt;Node*, 16&gt; chain2;
1644     if (attr1)
1645         chain1.append(attr1);
</pre>
<hr />
<pre>
1650         // We are comparing two attributes on the same node. Crawl our attribute map and see which one we hit first.
1651         Element* owner1 = attr1-&gt;ownerElement();
1652         owner1-&gt;synchronizeAllAttributes();
1653         for (const Attribute&amp; attribute : owner1-&gt;attributesIterator()) {
1654             // If neither of the two determining nodes is a child node and nodeType is the same for both determining nodes, then an
1655             // implementation-dependent order between the determining nodes is returned. This order is stable as long as no nodes of
1656             // the same nodeType are inserted into or removed from the direct container. This would be the case, for example,
1657             // when comparing two attributes of the same element, and inserting or removing additional attributes might change
1658             // the order between existing attributes.
1659             if (attr1-&gt;qualifiedName() == attribute.name())
1660                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_FOLLOWING;
1661             if (attr2-&gt;qualifiedName() == attribute.name())
1662                 return DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | DOCUMENT_POSITION_PRECEDING;
1663         }
1664 
1665         ASSERT_NOT_REACHED();
1666         return DOCUMENT_POSITION_DISCONNECTED;
1667     }
1668 
1669     // If one node is in the document and the other is not, we must be disconnected.
<span class="line-modified">1670     // If the nodes have different owning documents, they must be disconnected.</span>
<span class="line-modified">1671     if (!areNodesConnectedInSameTreeScope(start1, start2))</span>

1672         return compareDetachedElementsPosition(*this, otherNode);
1673 
1674     // We need to find a common ancestor container, and then compare the indices of the two immediate children.
1675     Node* current;
1676     for (current = start1; current; current = current-&gt;parentNode())
1677         chain1.append(current);
1678     for (current = start2; current; current = current-&gt;parentNode())
1679         chain2.append(current);
1680 
1681     unsigned index1 = chain1.size();
1682     unsigned index2 = chain2.size();
1683 
1684     // If the two elements don&#39;t have a common root, they&#39;re not in the same tree.
1685     if (chain1[index1 - 1] != chain2[index2 - 1])
1686         return compareDetachedElementsPosition(*this, otherNode);
1687 
1688     // Walk the two chains backwards and look for the first difference.
1689     for (unsigned i = std::min(index1, index2); i; --i) {
1690         Node* child1 = chain1[--index1];
1691         Node* child2 = chain2[--index2];
</pre>
<hr />
<pre>
1902             showSubTreeAcrossFrame(shadowRoot, markedNode, indent + &quot;\t&quot;);
1903     }
1904     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
1905         showSubTreeAcrossFrame(child, markedNode, indent + &quot;\t&quot;);
1906 }
1907 
1908 void Node::showTreeForThisAcrossFrame() const
1909 {
1910     Node* rootNode = const_cast&lt;Node*&gt;(this);
1911     while (parentOrShadowHostOrFrameOwner(rootNode))
1912         rootNode = parentOrShadowHostOrFrameOwner(rootNode);
1913     showSubTreeAcrossFrame(rootNode, this, &quot;&quot;);
1914 }
1915 
1916 #endif // ENABLE(TREE_DEBUGGING)
1917 
1918 // --------
1919 
1920 void NodeListsNodeData::invalidateCaches()
1921 {
<span class="line-modified">1922     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="line-modified">1923         atomName.value-&gt;invalidateCache();</span>
1924 
1925     for (auto&amp; collection : m_cachedCollections)
1926         collection.value-&gt;invalidateCache();
1927 
1928     for (auto&amp; tagCollection : m_tagCollectionNSCache)
1929         tagCollection.value-&gt;invalidateCache();
1930 }
1931 
1932 void NodeListsNodeData::invalidateCachesForAttribute(const QualifiedName&amp; attrName)
1933 {
<span class="line-modified">1934     for (auto&amp; atomName : m_atomNameCaches)</span>
<span class="line-modified">1935         atomName.value-&gt;invalidateCacheForAttribute(attrName);</span>
1936 
1937     for (auto&amp; collection : m_cachedCollections)
1938         collection.value-&gt;invalidateCacheForAttribute(attrName);
1939 }
1940 
1941 void Node::getSubresourceURLs(ListHashSet&lt;URL&gt;&amp; urls) const
1942 {
1943     addSubresourceAttributeURLs(urls);
1944 }
1945 
1946 Element* Node::enclosingLinkEventParentOrSelf()
1947 {
1948     for (Node* node = this; node; node = node-&gt;parentInComposedTree()) {
1949         // For imagemaps, the enclosing link element is the associated area element not the image itself.
1950         // So we don&#39;t let images be the enclosing link element, even though isLink sometimes returns
1951         // true for them.
1952         if (node-&gt;isLink() &amp;&amp; !is&lt;HTMLImageElement&gt;(*node))
1953             return downcast&lt;Element&gt;(node);
1954     }
1955 
</pre>
<hr />
<pre>
2084             oldDocument.didRemoveTouchEventHandler(*this);
2085             newDocument.didAddTouchEventHandler(*this);
2086 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2087             oldDocument.removeTouchEventListener(*this);
2088             newDocument.addTouchEventListener(*this);
2089 #endif
2090         }
2091 
2092 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2093         unsigned numGestureEventListeners = 0;
2094         for (auto&amp; name : eventNames().gestureEventNames())
2095             numGestureEventListeners += eventListeners(name).size();
2096 
2097         for (unsigned i = 0; i &lt; numGestureEventListeners; ++i) {
2098             oldDocument.removeTouchEventHandler(*this);
2099             newDocument.addTouchEventHandler(*this);
2100         }
2101 #endif
2102     }
2103 
<span class="line-modified">2104 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
2105 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
2106     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventListenersContain(*this));
2107     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventHandlersContain(*this));
2108 #endif
2109 #if ENABLE(TOUCH_EVENTS) &amp;&amp; ENABLE(IOS_GESTURE_EVENTS)
2110     ASSERT_WITH_SECURITY_IMPLICATION(!oldDocument.touchEventTargetsContain(*this));
2111 #endif
2112 #endif
2113 
2114     if (is&lt;Element&gt;(*this))
2115         downcast&lt;Element&gt;(*this).didMoveToNewDocument(oldDocument, newDocument);
2116 }
2117 
2118 static inline bool tryAddEventListener(Node* targetNode, const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const EventTarget::AddEventListenerOptions&amp; options)
2119 {
2120     if (!targetNode-&gt;EventTarget::addEventListener(eventType, listener.copyRef(), options))
2121         return false;
2122 
2123     targetNode-&gt;document().addListenerTypeIfNeeded(eventType);
2124     if (eventNames().isWheelEventType(eventType))
2125         targetNode-&gt;document().didAddWheelEventHandler(*targetNode);
2126     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2127         targetNode-&gt;document().didAddTouchEventHandler(*targetNode);
2128 
2129 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2130     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="line-modified">2131         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="line-added">2132             window-&gt;incrementScrollEventListenersCount();</span>
<span class="line-added">2133     }</span>
2134 
2135 #if ENABLE(TOUCH_EVENTS)
2136     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2137         targetNode-&gt;document().addTouchEventListener(*targetNode);
2138 #endif
2139 #endif // PLATFORM(IOS_FAMILY)
2140 
2141 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2142     if (eventNames().isGestureEventType(eventType))
2143         targetNode-&gt;document().addTouchEventHandler(*targetNode);
2144 #endif
2145 
2146     return true;
2147 }
2148 
2149 bool Node::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
2150 {
2151     return tryAddEventListener(this, eventType, WTFMove(listener), options);
2152 }
2153 
2154 static inline bool tryRemoveEventListener(Node* targetNode, const AtomString&amp; eventType, EventListener&amp; listener, const EventTarget::ListenerOptions&amp; options)
2155 {
2156     if (!targetNode-&gt;EventTarget::removeEventListener(eventType, listener, options))
2157         return false;
2158 
2159     // FIXME: Notify Document that the listener has vanished. We need to keep track of a number of
2160     // listeners for each type, not just a bool - see https://bugs.webkit.org/show_bug.cgi?id=33861
2161     if (eventNames().isWheelEventType(eventType))
2162         targetNode-&gt;document().didRemoveWheelEventHandler(*targetNode);
2163     else if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2164         targetNode-&gt;document().didRemoveTouchEventHandler(*targetNode);
2165 
2166 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">2167     if (targetNode == &amp;targetNode-&gt;document() &amp;&amp; eventType == eventNames().scrollEvent) {</span>
<span class="line-modified">2168         if (auto* window = targetNode-&gt;document().domWindow())</span>
<span class="line-added">2169             window-&gt;decrementScrollEventListenersCount();</span>
<span class="line-added">2170     }</span>
2171 
2172 #if ENABLE(TOUCH_EVENTS)
2173     if (eventNames().isTouchRelatedEventType(targetNode-&gt;document(), eventType))
2174         targetNode-&gt;document().removeTouchEventListener(*targetNode);
2175 #endif
2176 #endif // PLATFORM(IOS_FAMILY)
2177 
2178 #if ENABLE(IOS_GESTURE_EVENTS) &amp;&amp; ENABLE(TOUCH_EVENTS)
2179     if (eventNames().isGestureEventType(eventType))
2180         targetNode-&gt;document().removeTouchEventHandler(*targetNode);
2181 #endif
2182 
2183     return true;
2184 }
2185 
2186 bool Node::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
2187 {
2188     return tryRemoveEventListener(this, eventType, listener, options);
2189 }
2190 
</pre>
<hr />
<pre>
2428         }
2429     } else if (eventType == eventNames().clickEvent) {
2430         dispatchDOMActivateEvent(event);
2431 #if ENABLE(CONTEXT_MENUS)
2432     } else if (eventType == eventNames().contextmenuEvent) {
2433         if (Frame* frame = document().frame())
2434             if (Page* page = frame-&gt;page())
2435                 page-&gt;contextMenuController().handleContextMenuEvent(event);
2436 #endif
2437     } else if (eventType == eventNames().textInputEvent) {
2438         if (is&lt;TextEvent&gt;(event)) {
2439             if (Frame* frame = document().frame())
2440                 frame-&gt;eventHandler().defaultTextInputEventHandler(downcast&lt;TextEvent&gt;(event));
2441         }
2442 #if ENABLE(PAN_SCROLLING)
2443     } else if (eventType == eventNames().mousedownEvent &amp;&amp; is&lt;MouseEvent&gt;(event)) {
2444         if (downcast&lt;MouseEvent&gt;(event).button() == MiddleButton) {
2445             if (enclosingLinkEventParentOrSelf())
2446                 return;
2447 
<span class="line-added">2448             // Avoid that canBeScrolledAndHasScrollableArea changes render tree</span>
<span class="line-added">2449             // structure.</span>
<span class="line-added">2450             // FIXME: We should avoid synchronous layout if possible. We can</span>
<span class="line-added">2451             // remove this synchronous layout if we avoid synchronous layout in</span>
<span class="line-added">2452             // RenderTextControlSingleLine::scrollHeight</span>
<span class="line-added">2453             document().updateLayoutIgnorePendingStylesheets();</span>
2454             RenderObject* renderer = this-&gt;renderer();
2455             while (renderer &amp;&amp; (!is&lt;RenderBox&gt;(*renderer) || !downcast&lt;RenderBox&gt;(*renderer).canBeScrolledAndHasScrollableArea()))
2456                 renderer = renderer-&gt;parent();
2457 
2458             if (renderer) {
2459                 if (Frame* frame = document().frame())
2460                     frame-&gt;eventHandler().startPanScrolling(downcast&lt;RenderBox&gt;(*renderer));
2461             }
2462         }
2463 #endif
2464     } else if (eventNames().isWheelEventType(eventType) &amp;&amp; is&lt;WheelEvent&gt;(event)) {
2465         // If we don&#39;t have a renderer, send the wheel event to the first node we find with a renderer.
2466         // This is needed for &lt;option&gt; and &lt;optgroup&gt; elements so that &lt;select&gt;s get a wheel scroll.
2467         Node* startNode = this;
2468         while (startNode &amp;&amp; !startNode-&gt;renderer())
2469             startNode = startNode-&gt;parentOrShadowHostNode();
2470 
2471         if (startNode &amp;&amp; startNode-&gt;renderer())
2472             if (Frame* frame = document().frame())
2473                 frame-&gt;eventHandler().defaultWheelEventHandler(startNode, downcast&lt;WheelEvent&gt;(event));
</pre>
<hr />
<pre>
2529 // It&#39;s important not to inline removedLastRef, because we don&#39;t want to inline the code to
2530 // delete a Node at each deref call site.
2531 void Node::removedLastRef()
2532 {
2533     ASSERT(m_refCountAndParentBit == s_refCountIncrement);
2534 
2535     // An explicit check for Document here is better than a virtual function since it is
2536     // faster for non-Document nodes, and because the call to removedLastRef that is inlined
2537     // at all deref call sites is smaller if it&#39;s a non-virtual function.
2538     if (is&lt;Document&gt;(*this)) {
2539         downcast&lt;Document&gt;(*this).removedLastRef();
2540         return;
2541     }
2542 
2543     // Now it is time to detach the SVGElement from all its properties. These properties
2544     // may outlive the SVGElement. The only difference after the detach is no commit will
2545     // be carried out unless these properties are attached to another owner.
2546     if (is&lt;SVGElement&gt;(*this))
2547         downcast&lt;SVGElement&gt;(*this).detachAllProperties();
2548 
<span class="line-modified">2549 #if ASSERT_ENABLED</span>
2550     m_deletionHasBegun = true;
2551 #endif
2552     delete this;
2553 }
2554 
2555 void Node::textRects(Vector&lt;IntRect&gt;&amp; rects) const
2556 {
2557     auto range = Range::create(document());
2558     range-&gt;selectNodeContents(const_cast&lt;Node&amp;&gt;(*this));
2559     range-&gt;absoluteTextRects(rects);
2560 }
2561 
2562 unsigned Node::connectedSubframeCount() const
2563 {
2564     return hasRareData() ? rareData()-&gt;connectedSubframeCount() : 0;
2565 }
2566 
2567 void Node::incrementConnectedSubframeCount(unsigned amount)
2568 {
2569     ASSERT(isContainerNode());
</pre>
</td>
</tr>
</table>
<center><a href="NameNodeList.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Node.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
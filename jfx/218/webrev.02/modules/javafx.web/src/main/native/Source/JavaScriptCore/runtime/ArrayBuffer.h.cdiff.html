<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBufferView.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,14 ***</span>
  
  #pragma once
  
  #include &quot;ArrayBufferSharingMode.h&quot;
  #include &quot;GCIncomingRefCounted.h&quot;
  #include &quot;Weak.h&quot;
  #include &lt;wtf/CagedPtr.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-modified">! #include &lt;wtf/Function.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
<span class="line-new-header">--- 25,16 ---</span>
  
  #pragma once
  
  #include &quot;ArrayBufferSharingMode.h&quot;
  #include &quot;GCIncomingRefCounted.h&quot;
<span class="line-added">+ #include &quot;Watchpoint.h&quot;</span>
  #include &quot;Weak.h&quot;
  #include &lt;wtf/CagedPtr.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-modified">! #include &lt;wtf/PackedRefPtr.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/SharedTask.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadSafeRefCounted.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,11 ***</span>
  class VM;
  class ArrayBuffer;
  class ArrayBufferView;
  class JSArrayBuffer;
  
<span class="line-modified">! typedef Function&lt;void(void*)&gt; ArrayBufferDestructorFunction;</span>
  
  class SharedArrayBufferContents : public ThreadSafeRefCounted&lt;SharedArrayBufferContents&gt; {
  public:
      SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp;);
      ~SharedArrayBufferContents();
<span class="line-new-header">--- 44,12 ---</span>
  class VM;
  class ArrayBuffer;
  class ArrayBufferView;
  class JSArrayBuffer;
  
<span class="line-modified">! using ArrayBufferDestructorFunction = RefPtr&lt;SharedTask&lt;void(void*)&gt;&gt;;</span>
<span class="line-added">+ using PackedArrayBufferDestructorFunction = PackedRefPtr&lt;SharedTask&lt;void(void*)&gt;&gt;;</span>
  
  class SharedArrayBufferContents : public ThreadSafeRefCounted&lt;SharedArrayBufferContents&gt; {
  public:
      SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp;);
      ~SharedArrayBufferContents();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,11 ***</span>
      void* data() const { return m_data.getMayBeNull(m_sizeInBytes); }
  
  private:
      using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
      DataType m_data;
<span class="line-modified">!     ArrayBufferDestructorFunction m_destructor;</span>
      unsigned m_sizeInBytes;
  };
  
  class ArrayBufferContents {
      WTF_MAKE_NONCOPYABLE(ArrayBufferContents);
<span class="line-new-header">--- 57,11 ---</span>
      void* data() const { return m_data.getMayBeNull(m_sizeInBytes); }
  
  private:
      using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
      DataType m_data;
<span class="line-modified">!     PackedArrayBufferDestructorFunction m_destructor;</span>
      unsigned m_sizeInBytes;
  };
  
  class ArrayBufferContents {
      WTF_MAKE_NONCOPYABLE(ArrayBufferContents);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,14 ***</span>
      void makeShared();
      void transferTo(ArrayBufferContents&amp;);
      void copyTo(ArrayBufferContents&amp;);
      void shareWith(ArrayBufferContents&amp;);
  
<span class="line-removed">-     ArrayBufferDestructorFunction m_destructor;</span>
<span class="line-removed">-     RefPtr&lt;SharedArrayBufferContents&gt; m_shared;</span>
      using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
      DataType m_data;
      unsigned m_sizeInBytes;
  };
  
  class ArrayBuffer : public GCIncomingRefCounted&lt;ArrayBuffer&gt; {
  public:
<span class="line-new-header">--- 99,14 ---</span>
      void makeShared();
      void transferTo(ArrayBufferContents&amp;);
      void copyTo(ArrayBufferContents&amp;);
      void shareWith(ArrayBufferContents&amp;);
  
      using DataType = CagedPtr&lt;Gigacage::Primitive, void, tagCagedPtr&gt;;
      DataType m_data;
<span class="line-added">+     PackedArrayBufferDestructorFunction m_destructor;</span>
<span class="line-added">+     PackedRefPtr&lt;SharedArrayBufferContents&gt; m_shared;</span>
      unsigned m_sizeInBytes;
  };
  
  class ArrayBuffer : public GCIncomingRefCounted&lt;ArrayBuffer&gt; {
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,12 ***</span>
      inline bool isShared() const;
      inline ArrayBufferSharingMode sharingMode() const { return isShared() ? ArrayBufferSharingMode::Shared : ArrayBufferSharingMode::Default; }
  
      inline size_t gcSizeEstimateInBytes() const;
  
<span class="line-modified">!     JS_EXPORT_PRIVATE Ref&lt;ArrayBuffer&gt; slice(double begin, double end) const;</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE Ref&lt;ArrayBuffer&gt; slice(double begin) const;</span>
  
      inline void pin();
      inline void unpin();
      inline void pinAndLock();
      inline bool isLocked();
<span class="line-new-header">--- 133,12 ---</span>
      inline bool isShared() const;
      inline ArrayBufferSharingMode sharingMode() const { return isShared() ? ArrayBufferSharingMode::Shared : ArrayBufferSharingMode::Default; }
  
      inline size_t gcSizeEstimateInBytes() const;
  
<span class="line-modified">!     JS_EXPORT_PRIVATE RefPtr&lt;ArrayBuffer&gt; slice(double begin, double end) const;</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE RefPtr&lt;ArrayBuffer&gt; slice(double begin) const;</span>
  
      inline void pin();
      inline void unpin();
      inline void pinAndLock();
      inline bool isLocked();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,35 ***</span>
      JS_EXPORT_PRIVATE bool transferTo(VM&amp;, ArrayBufferContents&amp;);
      JS_EXPORT_PRIVATE bool shareWith(ArrayBufferContents&amp;);
  
      void neuter(VM&amp;);
      bool isNeutered() { return !m_contents.m_data; }
  
      static ptrdiff_t offsetOfData() { return OBJECT_OFFSETOF(ArrayBuffer, m_contents) + OBJECT_OFFSETOF(ArrayBufferContents, m_data); }
  
      ~ArrayBuffer() { }
  
  private:
      static Ref&lt;ArrayBuffer&gt; create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
      static Ref&lt;ArrayBuffer&gt; createInternal(ArrayBufferContents&amp;&amp;, const void*, unsigned);
      static RefPtr&lt;ArrayBuffer&gt; tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
      ArrayBuffer(ArrayBufferContents&amp;&amp;);
<span class="line-modified">!     Ref&lt;ArrayBuffer&gt; sliceImpl(unsigned begin, unsigned end) const;</span>
      inline unsigned clampIndex(double index) const;
      static inline unsigned clampValue(double x, unsigned left, unsigned right);
  
<span class="line-modified">!     void notifyIncommingReferencesOfTransfer(VM&amp;);</span>
  
      ArrayBufferContents m_contents;
      Checked&lt;unsigned&gt; m_pinCount;
      bool m_isWasmMemory;
      // m_locked == true means that some API user fetched m_contents directly from a TypedArray object,
      // the buffer is backed by a WebAssembly.Memory, or is a SharedArrayBuffer.
      bool m_locked;
<span class="line-removed">- </span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     Weak&lt;JSArrayBuffer&gt; m_wrapper;</span>
  };
  
  void* ArrayBuffer::data()
  {
      return m_contents.data();
<span class="line-new-header">--- 149,39 ---</span>
      JS_EXPORT_PRIVATE bool transferTo(VM&amp;, ArrayBufferContents&amp;);
      JS_EXPORT_PRIVATE bool shareWith(ArrayBufferContents&amp;);
  
      void neuter(VM&amp;);
      bool isNeutered() { return !m_contents.m_data; }
<span class="line-added">+     InlineWatchpointSet&amp; neuteringWatchpointSet() { return m_neuteringWatchpointSet; }</span>
  
      static ptrdiff_t offsetOfData() { return OBJECT_OFFSETOF(ArrayBuffer, m_contents) + OBJECT_OFFSETOF(ArrayBufferContents, m_data); }
  
      ~ArrayBuffer() { }
  
<span class="line-added">+     JS_EXPORT_PRIVATE static Ref&lt;SharedTask&lt;void(void*)&gt;&gt; primitiveGigacageDestructor();</span>
<span class="line-added">+ </span>
  private:
      static Ref&lt;ArrayBuffer&gt; create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
      static Ref&lt;ArrayBuffer&gt; createInternal(ArrayBufferContents&amp;&amp;, const void*, unsigned);
      static RefPtr&lt;ArrayBuffer&gt; tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy);
      ArrayBuffer(ArrayBufferContents&amp;&amp;);
<span class="line-modified">!     RefPtr&lt;ArrayBuffer&gt; sliceImpl(unsigned begin, unsigned end) const;</span>
      inline unsigned clampIndex(double index) const;
      static inline unsigned clampValue(double x, unsigned left, unsigned right);
  
<span class="line-modified">!     void notifyNeutering(VM&amp;);</span>
  
      ArrayBufferContents m_contents;
<span class="line-added">+     InlineWatchpointSet m_neuteringWatchpointSet { IsWatched };</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     Weak&lt;JSArrayBuffer&gt; m_wrapper;</span>
<span class="line-added">+ private:</span>
      Checked&lt;unsigned&gt; m_pinCount;
      bool m_isWasmMemory;
      // m_locked == true means that some API user fetched m_contents directly from a TypedArray object,
      // the buffer is backed by a WebAssembly.Memory, or is a SharedArrayBuffer.
      bool m_locked;
  };
  
  void* ArrayBuffer::data()
  {
      return m_contents.data();
</pre>
<center><a href="ArrayBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayBufferView.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
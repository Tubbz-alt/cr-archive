<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingState.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,131 ***</span>
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingState);
  
<span class="line-modified">! FloatingState::FloatItem::FloatItem(const Box&amp; layoutBox, const FloatingState&amp; floatingState)</span>
      : m_layoutBox(makeWeakPtr(layoutBox))
<span class="line-modified">!     , m_absoluteDisplayBox(FormattingContext::mapBoxToAncestor(floatingState.layoutState(), layoutBox, downcast&lt;Container&gt;(floatingState.root())))</span>
  {
  }
  
<span class="line-modified">! FloatingState::FloatingState(LayoutState&amp; layoutState, const Box&amp; formattingContextRoot)</span>
<span class="line-modified">!     : m_layoutState(layoutState)</span>
<span class="line-modified">!     , m_formattingContextRoot(makeWeakPtr(formattingContextRoot))</span>
  {
  }
  
<span class="line-modified">! #ifndef NDEBUG</span>
<span class="line-modified">! static bool belongsToThisFloatingContext(const Box&amp; layoutBox, const Box&amp; floatingStateRoot)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     auto&amp; formattingContextRoot = layoutBox.formattingContextRoot();</span>
<span class="line-removed">-     if (&amp;formattingContextRoot == &amp;floatingStateRoot)</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Maybe the layout box belongs to an inline formatting context that inherits the floating state from the parent (block) formatting context.</span>
<span class="line-removed">-     if (!formattingContextRoot.establishesInlineFormattingContext())</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return &amp;formattingContextRoot.formattingContextRoot() == &amp;floatingStateRoot;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- void FloatingState::remove(const Box&amp; layoutBox)</span>
  {
<span class="line-removed">-     for (size_t index = 0; index &lt; m_floats.size(); ++index) {</span>
<span class="line-removed">-         if (m_floats[index] == layoutBox) {</span>
<span class="line-removed">-             m_floats.remove(index);</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ASSERT_NOT_REACHED();</span>
  }
  
<span class="line-modified">! void FloatingState::append(const Box&amp; layoutBox)</span>
  {
      ASSERT(is&lt;Container&gt;(*m_formattingContextRoot));
<span class="line-removed">-     ASSERT(belongsToThisFloatingContext(layoutBox, *m_formattingContextRoot));</span>
<span class="line-removed">-     ASSERT(is&lt;Container&gt;(*m_formattingContextRoot));</span>
  
<span class="line-removed">-     auto newFloatItem = FloatItem { layoutBox, *this };</span>
      if (m_floats.isEmpty())
<span class="line-modified">!         return m_floats.append(newFloatItem);</span>
  
<span class="line-modified">!     auto&amp; displayBox = m_layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-removed">-     auto isLeftPositioned = layoutBox.isLeftFloatingPositioned();</span>
      // When adding a new float item to the list, we have to ensure that it is definitely the left(right)-most item.
      // Normally it is, but negative horizontal margins can push the float box beyond another float box.
      // Float items in m_floats list should stay in horizontal position order (left/right edge) on the same vertical position.
<span class="line-modified">!     auto hasNegativeHorizontalMargin = (isLeftPositioned &amp;&amp; displayBox.marginStart() &lt; 0) || (!isLeftPositioned &amp;&amp; displayBox.marginEnd() &lt; 0);</span>
      if (!hasNegativeHorizontalMargin)
<span class="line-modified">!         return m_floats.append(newFloatItem);</span>
  
      for (int i = m_floats.size() - 1; i &gt;= 0; --i) {
          auto&amp; floatItem = m_floats[i];
          if (isLeftPositioned != floatItem.isLeftPositioned())
              continue;
<span class="line-modified">!         if (newFloatItem.rectWithMargin().top() &lt; floatItem.rectWithMargin().bottom())</span>
              continue;
<span class="line-modified">!         if ((isLeftPositioned &amp;&amp; newFloatItem.rectWithMargin().right() &gt;= floatItem.rectWithMargin().right())</span>
<span class="line-modified">!             || (!isLeftPositioned &amp;&amp; newFloatItem.rectWithMargin().left() &lt;= floatItem.rectWithMargin().left()))</span>
<span class="line-modified">!             return m_floats.insert(i + 1, newFloatItem);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return m_floats.insert(0, newFloatItem);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- FloatingState::Constraints FloatingState::constraints(PositionInContextRoot verticalPosition, const Box&amp; formattingContextRoot) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (isEmpty())</span>
<span class="line-removed">-         return { };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // 1. Convert vertical position if this floating context is inherited.</span>
<span class="line-removed">-     // 2. Find the inner left/right floats at verticalPosition.</span>
<span class="line-removed">-     // 3. Convert left/right positions back to formattingContextRoot&#39;s cooridnate system.</span>
<span class="line-removed">-     auto coordinateMappingIsRequired = &amp;root() != &amp;formattingContextRoot;</span>
<span class="line-removed">-     auto adjustedPosition = Point { 0, verticalPosition };</span>
<span class="line-removed">-     LayoutSize adjustingDelta;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (coordinateMappingIsRequired) {</span>
<span class="line-removed">-         adjustedPosition = FormattingContext::mapPointToAncestor(m_layoutState, adjustedPosition, downcast&lt;Container&gt;(formattingContextRoot), downcast&lt;Container&gt;(root()));</span>
<span class="line-removed">-         adjustingDelta = { adjustedPosition.x, adjustedPosition.y - verticalPosition };</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Constraints constraints;</span>
<span class="line-removed">-     for (int index = m_floats.size() - 1; index &gt;= 0; --index) {</span>
<span class="line-removed">-         auto&amp; floatItem = m_floats[index];</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (constraints.left &amp;&amp; floatItem.isLeftPositioned())</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (constraints.right &amp;&amp; !floatItem.isLeftPositioned())</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto rect = floatItem.rectWithMargin();</span>
<span class="line-removed">-         if (!(rect.top() &lt;= adjustedPosition.y &amp;&amp; adjustedPosition.y &lt; rect.bottom()))</span>
<span class="line-removed">-             continue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (floatItem.isLeftPositioned())</span>
<span class="line-removed">-             constraints.left = PointInContextRoot { rect.right(), rect.bottom() };</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             constraints.right = PointInContextRoot { rect.left(), rect.bottom() };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (constraints.left &amp;&amp; constraints.right)</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (coordinateMappingIsRequired) {</span>
<span class="line-removed">-         if (constraints.left)</span>
<span class="line-removed">-             constraints.left-&gt;move(-adjustingDelta);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (constraints.right)</span>
<span class="line-removed">-             constraints.right-&gt;move(-adjustingDelta);</span>
      }
<span class="line-modified">!     return constraints;</span>
  }
  
<span class="line-modified">! Optional&lt;PositionInContextRoot&gt; FloatingState::bottom(const Box&amp; formattingContextRoot, Clear type) const</span>
  {
      if (m_floats.isEmpty())
          return { };
  
      // TODO: Currently this is only called once for each formatting context root with floats per layout.
<span class="line-new-header">--- 37,59 ---</span>
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(FloatingState);
  
<span class="line-modified">! FloatingState::FloatItem::FloatItem(const Box&amp; layoutBox, Display::Box absoluteDisplayBox)</span>
      : m_layoutBox(makeWeakPtr(layoutBox))
<span class="line-modified">!     , m_position(layoutBox.isLeftFloatingPositioned() ? Position::Left : Position::Right)</span>
<span class="line-added">+     , m_absoluteDisplayBox(absoluteDisplayBox)</span>
  {
  }
  
<span class="line-modified">! FloatingState::FloatItem::FloatItem(Position position, Display::Box absoluteDisplayBox)</span>
<span class="line-modified">!     : m_position(position)</span>
<span class="line-modified">!     , m_absoluteDisplayBox(absoluteDisplayBox)</span>
  {
  }
  
<span class="line-modified">! FloatingState::FloatingState(LayoutState&amp; layoutState, const Container&amp; formattingContextRoot)</span>
<span class="line-modified">!     : m_layoutState(layoutState)</span>
<span class="line-modified">!     , m_formattingContextRoot(makeWeakPtr(formattingContextRoot))</span>
  {
  }
  
<span class="line-modified">! void FloatingState::append(FloatItem floatItem)</span>
  {
      ASSERT(is&lt;Container&gt;(*m_formattingContextRoot));
  
      if (m_floats.isEmpty())
<span class="line-modified">!         return m_floats.append(floatItem);</span>
  
<span class="line-modified">!     auto isLeftPositioned = floatItem.isLeftPositioned();</span>
      // When adding a new float item to the list, we have to ensure that it is definitely the left(right)-most item.
      // Normally it is, but negative horizontal margins can push the float box beyond another float box.
      // Float items in m_floats list should stay in horizontal position order (left/right edge) on the same vertical position.
<span class="line-modified">!     auto horizontalMargin = floatItem.horizontalMargin();</span>
<span class="line-added">+     auto hasNegativeHorizontalMargin = (isLeftPositioned &amp;&amp; horizontalMargin.start &lt; 0) || (!isLeftPositioned &amp;&amp; horizontalMargin.end &lt; 0);</span>
      if (!hasNegativeHorizontalMargin)
<span class="line-modified">!         return m_floats.append(floatItem);</span>
  
      for (int i = m_floats.size() - 1; i &gt;= 0; --i) {
          auto&amp; floatItem = m_floats[i];
          if (isLeftPositioned != floatItem.isLeftPositioned())
              continue;
<span class="line-modified">!         if (floatItem.rectWithMargin().top() &lt; floatItem.rectWithMargin().bottom())</span>
              continue;
<span class="line-modified">!         if ((isLeftPositioned &amp;&amp; floatItem.rectWithMargin().right() &gt;= floatItem.rectWithMargin().right())</span>
<span class="line-modified">!             || (!isLeftPositioned &amp;&amp; floatItem.rectWithMargin().left() &lt;= floatItem.rectWithMargin().left()))</span>
<span class="line-modified">!             return m_floats.insert(i + 1, floatItem);</span>
      }
<span class="line-modified">!     return m_floats.insert(0, floatItem);</span>
  }
  
<span class="line-modified">! Optional&lt;PositionInContextRoot&gt; FloatingState::bottom(const Container&amp; formattingContextRoot, Clear type) const</span>
  {
      if (m_floats.isEmpty())
          return { };
  
      // TODO: Currently this is only called once for each formatting context root with floats per layout.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,11 ***</span>
          bottom = PositionInContextRoot { floatsBottom };
      }
      return bottom;
  }
  
<span class="line-modified">! Optional&lt;PositionInContextRoot&gt; FloatingState::top(const Box&amp; formattingContextRoot) const</span>
  {
      if (m_floats.isEmpty())
          return { };
  
      Optional&lt;PositionInContextRoot&gt; top;
<span class="line-new-header">--- 112,11 ---</span>
          bottom = PositionInContextRoot { floatsBottom };
      }
      return bottom;
  }
  
<span class="line-modified">! Optional&lt;PositionInContextRoot&gt; FloatingState::top(const Container&amp; formattingContextRoot) const</span>
  {
      if (m_floats.isEmpty())
          return { };
  
      Optional&lt;PositionInContextRoot&gt; top;
</pre>
<center><a href="FloatingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingState.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
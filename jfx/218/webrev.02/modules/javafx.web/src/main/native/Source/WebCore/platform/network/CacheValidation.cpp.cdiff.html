<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/CacheValidation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlobRegistryImpl.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheValidation.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/CacheValidation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 311,12 ***</span>
                  }
                  bool ok;
                  double maxStale = directives[i].second.toDouble(&amp;ok);
                  if (ok)
                      result.maxStale = Seconds { maxStale };
<span class="line-modified">!             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;immutable&quot;))</span>
                  result.immutable = true;
          }
      }
  
      if (!result.noCache) {
          // Handle Pragma: no-cache
<span class="line-new-header">--- 311,22 ---</span>
                  }
                  bool ok;
                  double maxStale = directives[i].second.toDouble(&amp;ok);
                  if (ok)
                      result.maxStale = Seconds { maxStale };
<span class="line-modified">!             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;immutable&quot;)) {</span>
                  result.immutable = true;
<span class="line-added">+             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;stale-while-revalidate&quot;)) {</span>
<span class="line-added">+                 if (result.staleWhileRevalidate) {</span>
<span class="line-added">+                     // First stale-while-revalidate directive wins if there are multiple ones.</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 bool ok;</span>
<span class="line-added">+                 double staleWhileRevalidate = directives[i].second.toDouble(&amp;ok);</span>
<span class="line-added">+                 if (ok)</span>
<span class="line-added">+                     result.staleWhileRevalidate = Seconds { staleWhileRevalidate };</span>
<span class="line-added">+             }</span>
          }
      }
  
      if (!result.noCache) {
          // Handle Pragma: no-cache
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,19 ***</span>
      return result;
  }
  
  static String cookieRequestHeaderFieldValue(const NetworkStorageSession&amp; session, const ResourceRequest&amp; request)
  {
<span class="line-modified">!     return session.cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
  }
  
<span class="line-modified">! static String cookieRequestHeaderFieldValue(const CookieJar* cookieJar, const PAL::SessionID&amp; sessionID, const ResourceRequest&amp; request)</span>
  {
      if (!cookieJar)
          return { };
  
<span class="line-modified">!     return cookieJar-&gt;cookieRequestHeaderFieldValue(sessionID, request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
  }
  
  static String headerValueForVary(const ResourceRequest&amp; request, const String&amp; headerName, Function&lt;String()&gt;&amp;&amp; cookieRequestHeaderFieldValueFunction)
  {
      // Explicit handling for cookies is needed because they are added magically by the networking layer.
<span class="line-new-header">--- 338,19 ---</span>
      return result;
  }
  
  static String cookieRequestHeaderFieldValue(const NetworkStorageSession&amp; session, const ResourceRequest&amp; request)
  {
<span class="line-modified">!     return session.cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No, ShouldAskITP::Yes).first;</span>
  }
  
<span class="line-modified">! static String cookieRequestHeaderFieldValue(const CookieJar* cookieJar, const ResourceRequest&amp; request)</span>
  {
      if (!cookieJar)
          return { };
  
<span class="line-modified">!     return cookieJar-&gt;cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
  }
  
  static String headerValueForVary(const ResourceRequest&amp; request, const String&amp; headerName, Function&lt;String()&gt;&amp;&amp; cookieRequestHeaderFieldValueFunction)
  {
      // Explicit handling for cookies is needed because they are added magically by the networking layer.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,24 ***</span>
          varyingRequestHeaders.append(std::make_pair(headerName, headerValue));
      }
      return varyingRequestHeaders;
  }
  
<span class="line-modified">! Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(NetworkStorageSession&amp; storageSession, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
  {
      return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(storageSession, request);</span>
          });
      });
  }
  
<span class="line-modified">! Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(const CookieJar* cookieJar, const ResourceRequest&amp; request, const ResourceResponse&amp; response, const PAL::SessionID&amp; sessionID)</span>
  {
      return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(cookieJar, sessionID, request);</span>
          });
      });
  }
  
  static bool verifyVaryingRequestHeadersInternal(const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, Function&lt;String(const String&amp;)&gt;&amp;&amp; headerValueForVary)
<span class="line-new-header">--- 376,26 ---</span>
          varyingRequestHeaders.append(std::make_pair(headerName, headerValue));
      }
      return varyingRequestHeaders;
  }
  
<span class="line-modified">! Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(NetworkStorageSession* storageSession, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
  {
<span class="line-added">+     if (!storageSession)</span>
<span class="line-added">+         return { };</span>
      return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(*storageSession, request);</span>
          });
      });
  }
  
<span class="line-modified">! Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(const CookieJar* cookieJar, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
  {
      return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(cookieJar, request);</span>
          });
      });
  }
  
  static bool verifyVaryingRequestHeadersInternal(const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, Function&lt;String(const String&amp;)&gt;&amp;&amp; headerValueForVary)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,24 ***</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! bool verifyVaryingRequestHeaders(NetworkStorageSession&amp; storageSession, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
  {
      return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(storageSession, request);</span>
          });
      });
  }
  
<span class="line-modified">! bool verifyVaryingRequestHeaders(const CookieJar* cookieJar, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request, const PAL::SessionID&amp; sessionID)</span>
  {
      return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(cookieJar, sessionID, request);</span>
          });
      });
  }
  
  // http://tools.ietf.org/html/rfc7231#page-48
<span class="line-new-header">--- 408,26 ---</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! bool verifyVaryingRequestHeaders(NetworkStorageSession* storageSession, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
  {
<span class="line-added">+     if (!storageSession)</span>
<span class="line-added">+         return false;</span>
      return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(*storageSession, request);</span>
          });
      });
  }
  
<span class="line-modified">! bool verifyVaryingRequestHeaders(const CookieJar* cookieJar, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
  {
      return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
          return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">!             return cookieRequestHeaderFieldValue(cookieJar, request);</span>
          });
      });
  }
  
  // http://tools.ietf.org/html/rfc7231#page-48
</pre>
<center><a href="BlobRegistryImpl.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheValidation.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
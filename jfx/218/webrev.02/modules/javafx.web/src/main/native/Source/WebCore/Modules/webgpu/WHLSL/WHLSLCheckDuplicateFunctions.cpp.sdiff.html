<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLCheckDuplicateFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLASTDumper.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLCheckTextureReferences.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLCheckDuplicateFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
105         static bool equal(const DuplicateFunctionKey&amp; a, const DuplicateFunctionKey&amp; b)
106         {
107             return a == b;
108         }
109 
110         static const bool safeToCompareToEmptyOrDeleted = false;
111     };
112 
113     struct Traits : public WTF::SimpleClassHashTraits&lt;DuplicateFunctionKey&gt; {
114         static const bool hasIsEmptyValueFunction = true;
115         static bool isEmptyValue(const DuplicateFunctionKey&amp; key) { return key.isEmptyValue(); }
116     };
117 
118 private:
119     const AST::FunctionDeclaration* m_function { nullptr };
120 };
121 
122 Expected&lt;void, Error&gt; checkDuplicateFunctions(const Program&amp; program)
123 {
124     auto passesStaticChecks = [&amp;] (const AST::FunctionDeclaration&amp; function) -&gt; Expected&lt;void, Error&gt; {
<span class="line-modified">125         if (function.name() == &quot;operator&amp;[]&quot; &amp;&amp; function.parameters().size() == 2</span>
<span class="line-removed">126             &amp;&amp; is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[0]-&gt;type()))) {</span>
<span class="line-removed">127             auto&amp; type = static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[1]-&gt;type());</span>
<span class="line-removed">128             if (is&lt;AST::TypeReference&gt;(type)) {</span>
<span class="line-removed">129                 // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198161 Shouldn&#39;t we already know whether the types have been resolved by now?</span>
<span class="line-removed">130                 if (auto* resolvedType = downcast&lt;AST::TypeReference&gt;(type).maybeResolvedType()) {</span>
<span class="line-removed">131                     if (is&lt;AST::NativeTypeDeclaration&gt;(*resolvedType)) {</span>
<span class="line-removed">132                         auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(*resolvedType);</span>
<span class="line-removed">133                         if (nativeTypeDeclaration.name() == &quot;uint&quot;)</span>
<span class="line-removed">134                             return makeUnexpected(Error(&quot;Cannot define array reference ander.&quot;));</span>
<span class="line-removed">135                     }</span>
<span class="line-removed">136                 }</span>
<span class="line-removed">137             }</span>
<span class="line-removed">138         } else if (function.name() == &quot;operator.length&quot; &amp;&amp; function.parameters().size() == 1</span>
<span class="line-removed">139             &amp;&amp; (is&lt;AST::ArrayReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[0]-&gt;type()))</span>
<span class="line-removed">140             || is&lt;AST::ArrayType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[0]-&gt;type()))))</span>
<span class="line-removed">141             return makeUnexpected(Error(&quot;Cannot define operator.length for an array.&quot;));</span>
<span class="line-removed">142         else if (function.name() == &quot;operator==&quot;</span>
143             &amp;&amp; function.parameters().size() == 2
144             &amp;&amp; is&lt;AST::ReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[0]-&gt;type()))
145             &amp;&amp; is&lt;AST::ReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[1]-&gt;type()))
146             &amp;&amp; matches(*function.parameters()[0]-&gt;type(), *function.parameters()[1]-&gt;type()))
147             return makeUnexpected(Error(&quot;Cannot define operator== on two reference types.&quot;));
148         else if (function.isCast() &amp;&amp; function.parameters().isEmpty()) {
149             auto&amp; unifyNode = function.type().unifyNode();
150             if (is&lt;AST::NamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(unifyNode))) {
151                 auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(unifyNode));
152                 if (nativeTypeDeclaration.isOpaqueType())
153                     return makeUnexpected(Error(&quot;Cannot define a cast on an opaque type.&quot;));
154             }
155         }
156 
157         return { };
158     };
159 
160     HashSet&lt;DuplicateFunctionKey, DuplicateFunctionKey::Hash, DuplicateFunctionKey::Traits&gt; functions;
161 
162     auto add = [&amp;] (const AST::FunctionDeclaration&amp; function) -&gt; Expected&lt;void, Error&gt; {
</pre>
</td>
<td>
<hr />
<pre>
105         static bool equal(const DuplicateFunctionKey&amp; a, const DuplicateFunctionKey&amp; b)
106         {
107             return a == b;
108         }
109 
110         static const bool safeToCompareToEmptyOrDeleted = false;
111     };
112 
113     struct Traits : public WTF::SimpleClassHashTraits&lt;DuplicateFunctionKey&gt; {
114         static const bool hasIsEmptyValueFunction = true;
115         static bool isEmptyValue(const DuplicateFunctionKey&amp; key) { return key.isEmptyValue(); }
116     };
117 
118 private:
119     const AST::FunctionDeclaration* m_function { nullptr };
120 };
121 
122 Expected&lt;void, Error&gt; checkDuplicateFunctions(const Program&amp; program)
123 {
124     auto passesStaticChecks = [&amp;] (const AST::FunctionDeclaration&amp; function) -&gt; Expected&lt;void, Error&gt; {
<span class="line-modified">125         if (function.name() == &quot;operator==&quot;</span>

















126             &amp;&amp; function.parameters().size() == 2
127             &amp;&amp; is&lt;AST::ReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[0]-&gt;type()))
128             &amp;&amp; is&lt;AST::ReferenceType&gt;(static_cast&lt;const AST::UnnamedType&amp;&gt;(*function.parameters()[1]-&gt;type()))
129             &amp;&amp; matches(*function.parameters()[0]-&gt;type(), *function.parameters()[1]-&gt;type()))
130             return makeUnexpected(Error(&quot;Cannot define operator== on two reference types.&quot;));
131         else if (function.isCast() &amp;&amp; function.parameters().isEmpty()) {
132             auto&amp; unifyNode = function.type().unifyNode();
133             if (is&lt;AST::NamedType&gt;(unifyNode) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(unifyNode))) {
134                 auto&amp; nativeTypeDeclaration = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(unifyNode));
135                 if (nativeTypeDeclaration.isOpaqueType())
136                     return makeUnexpected(Error(&quot;Cannot define a cast on an opaque type.&quot;));
137             }
138         }
139 
140         return { };
141     };
142 
143     HashSet&lt;DuplicateFunctionKey, DuplicateFunctionKey::Hash, DuplicateFunctionKey::Traits&gt; functions;
144 
145     auto add = [&amp;] (const AST::FunctionDeclaration&amp; function) -&gt; Expected&lt;void, Error&gt; {
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLASTDumper.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLCheckTextureReferences.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOMGForOSREntryPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOpcodeOrigin.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOMGPlan.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,22 ***</span>
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMachineThreads.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
<span class="line-removed">- #include &quot;WasmValidate.h&quot;</span>
  #include &quot;WasmWorklist.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadMessage.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmOMGPlanInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
  OMGPlan::OMGPlan(Context* context, Ref&lt;Module&gt;&amp;&amp; module, uint32_t functionIndex, MemoryMode mode, CompletionTask&amp;&amp; task)
      : Base(context, makeRef(const_cast&lt;ModuleInformation&amp;&gt;(module-&gt;moduleInformation())), WTFMove(task))
      , m_module(WTFMove(module))
<span class="line-new-header">--- 38,21 ---</span>
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMachineThreads.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmSignatureInlines.h&quot;
  #include &quot;WasmWorklist.h&quot;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/ThreadMessage.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace WasmOMGPlanInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
  OMGPlan::OMGPlan(Context* context, Ref&lt;Module&gt;&amp;&amp; module, uint32_t functionIndex, MemoryMode mode, CompletionTask&amp;&amp; task)
      : Base(context, makeRef(const_cast&lt;ModuleInformation&amp;&gt;(module-&gt;moduleInformation())), WTFMove(task))
      , m_module(WTFMove(module))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,16 ***</span>
      const uint32_t functionIndexSpace = m_functionIndex + m_module-&gt;moduleInformation().importFunctionCount();
      ASSERT(functionIndexSpace &lt; m_module-&gt;moduleInformation().functionIndexSpaceSize());
  
      SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
<span class="line-removed">-     ASSERT(validateFunction(function.data.data(), function.data.size(), signature, m_moduleInformation.get()));</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedCalls;
      unsigned osrEntryScratchBufferSize;
      CompilationContext context;
<span class="line-modified">!     auto parseAndCompileResult = parseAndCompile(context, function.data.data(), function.data.size(), signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGMode, m_functionIndex, UINT32_MAX);</span>
  
      if (UNLIKELY(!parseAndCompileResult)) {
          fail(holdLock(m_lock), makeString(parseAndCompileResult.error(), &quot;when trying to tier up &quot;, String::number(m_functionIndex)));
          return;
      }
<span class="line-new-header">--- 74,15 ---</span>
      const uint32_t functionIndexSpace = m_functionIndex + m_module-&gt;moduleInformation().importFunctionCount();
      ASSERT(functionIndexSpace &lt; m_module-&gt;moduleInformation().functionIndexSpaceSize());
  
      SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
  
      Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedCalls;
      unsigned osrEntryScratchBufferSize;
      CompilationContext context;
<span class="line-modified">!     auto parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::OMGMode, m_functionIndex, UINT32_MAX);</span>
  
      if (UNLIKELY(!parseAndCompileResult)) {
          fail(holdLock(m_lock), makeString(parseAndCompileResult.error(), &quot;when trying to tier up &quot;, String::number(m_functionIndex)));
          return;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,34 ***</span>
          Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));
          return;
      }
  
      omgEntrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
<span class="line-modified">!         FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMG function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
          WTFMove(context.wasmEntrypointByproducts));
  
      omgEntrypoint.calleeSaveRegisters = WTFMove(parseAndCompileResult.value()-&gt;entrypoint.calleeSaveRegisters);
  
      MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
      {
          ASSERT(m_codeBlock.ptr() == m_module-&gt;codeBlockFor(mode()));
          Ref&lt;OMGCallee&gt; callee = OMGCallee::create(WTFMove(omgEntrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(unlinkedCalls));
          MacroAssembler::repatchPointer(parseAndCompileResult.value()-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));
<span class="line-modified">!         ASSERT(!m_codeBlock-&gt;m_optimizedCallees[m_functionIndex]);</span>
          entrypoint = callee-&gt;entrypoint();
  
          // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we
          // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they
          // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release
          // the lock our code is ready to be published too.
          LockHolder holder(m_codeBlock-&gt;m_lock);
<span class="line-modified">!         m_codeBlock-&gt;m_optimizedCallees[m_functionIndex] = callee.copyRef();</span>
          {
<span class="line-modified">!             BBQCallee&amp; bbqCallee = *static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[m_functionIndex].get());</span>
<span class="line-modified">!             auto locker = holdLock(bbqCallee.tierUpCount()-&gt;getLock());</span>
<span class="line-modified">!             bbqCallee.setReplacement(callee.copyRef());</span>
<span class="line-modified">!             bbqCallee.tierUpCount()-&gt;m_compilationStatusForOMG = TierUpCount::CompilationStatus::Compiled;</span>
          }
          for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {
              MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
              if (call.functionIndexSpace &lt; m_module-&gt;moduleInformation().importFunctionCount())
                  entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();
<span class="line-new-header">--- 93,41 ---</span>
          Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));
          return;
      }
  
      omgEntrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(
<span class="line-modified">!         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::OMGMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly OMG function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
          WTFMove(context.wasmEntrypointByproducts));
  
      omgEntrypoint.calleeSaveRegisters = WTFMove(parseAndCompileResult.value()-&gt;entrypoint.calleeSaveRegisters);
  
      MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
      {
          ASSERT(m_codeBlock.ptr() == m_module-&gt;codeBlockFor(mode()));
          Ref&lt;OMGCallee&gt; callee = OMGCallee::create(WTFMove(omgEntrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(unlinkedCalls));
          MacroAssembler::repatchPointer(parseAndCompileResult.value()-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));
<span class="line-modified">!         ASSERT(!m_codeBlock-&gt;m_omgCallees[m_functionIndex]);</span>
          entrypoint = callee-&gt;entrypoint();
  
          // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we
          // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they
          // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release
          // the lock our code is ready to be published too.
          LockHolder holder(m_codeBlock-&gt;m_lock);
<span class="line-modified">!         m_codeBlock-&gt;m_omgCallees[m_functionIndex] = callee.copyRef();</span>
          {
<span class="line-modified">!             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[m_functionIndex].get()) {</span>
<span class="line-modified">!                 auto locker = holdLock(bbqCallee-&gt;tierUpCount()-&gt;getLock());</span>
<span class="line-modified">!                 bbqCallee-&gt;setReplacement(callee.copyRef());</span>
<span class="line-modified">!                 bbqCallee-&gt;tierUpCount()-&gt;m_compilationStatusForOMG = TierUpCount::CompilationStatus::Compiled;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="line-added">+                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(m_functionIndex).get();</span>
<span class="line-added">+                 auto locker = holdLock(llintCallee.tierUpCounter().m_lock);</span>
<span class="line-added">+                 llintCallee.setReplacement(callee.copyRef());</span>
<span class="line-added">+                 llintCallee.tierUpCounter().m_compilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="line-added">+             }</span>
          }
          for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {
              MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;
              if (call.functionIndexSpace &lt; m_module-&gt;moduleInformation().importFunctionCount())
                  entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,18 ***</span>
              }
          };
  
          for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {
              repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);
<span class="line-modified">!             if (OMGCallee* replacementCallee = static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[i].get())-&gt;replacement())</span>
<span class="line-modified">!                 repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-modified">!             if (OMGForOSREntryCallee* osrEntryCallee = static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[i].get())-&gt;osrEntryCallee())</span>
<span class="line-modified">!                 repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
          }
      }
  
<span class="line-modified">!     dataLogLnIf(WasmOMGPlanInternal::verbose, &quot;Finished OMG &quot;, m_functionIndex, &quot; with tier up count at: &quot;, static_cast&lt;BBQCallee*&gt;(m_codeBlock-&gt;m_callees[m_functionIndex].get())-&gt;tierUpCount()-&gt;count());</span>
      complete(holdLock(m_lock));
  }
  
  } } // namespace JSC::Wasm
  
<span class="line-new-header">--- 158,27 ---</span>
              }
          };
  
          for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {
              repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);
<span class="line-modified">!             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="line-modified">!                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(i).get();</span>
<span class="line-modified">!                 if (JITCallee* replacementCallee = llintCallee.replacement())</span>
<span class="line-modified">!                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())</span>
<span class="line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[i].get()) {</span>
<span class="line-added">+                 if (OMGCallee* replacementCallee = bbqCallee-&gt;replacement())</span>
<span class="line-added">+                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+                 if (OMGForOSREntryCallee* osrEntryCallee = bbqCallee-&gt;osrEntryCallee())</span>
<span class="line-added">+                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">+             }</span>
          }
      }
  
<span class="line-modified">!     dataLogLnIf(WasmOMGPlanInternal::verbose, &quot;Finished OMG &quot;, m_functionIndex);</span>
      complete(holdLock(m_lock));
  }
  
  } } // namespace JSC::Wasm
  
</pre>
<center><a href="WasmOMGForOSREntryPlan.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOpcodeOrigin.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
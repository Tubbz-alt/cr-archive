<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Path.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PathTraversalState.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;PathTraversalState.h&quot;
 23 
 24 #include &lt;wtf/MathExtras.h&gt;
 25 #include &lt;wtf/Vector.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 static const float kPathSegmentLengthTolerance = 0.00001f;
 30 
 31 static inline FloatPoint midPoint(const FloatPoint&amp; first, const FloatPoint&amp; second)
 32 {
 33     return FloatPoint((first.x() + second.x()) / 2.0f, (first.y() + second.y()) / 2.0f);
 34 }
 35 
 36 static inline float distanceLine(const FloatPoint&amp; start, const FloatPoint&amp; end)
 37 {
<span class="line-modified"> 38     float dx = end.x() - start.x();</span>
<span class="line-removed"> 39     float dy = end.y() - start.y();</span>
<span class="line-removed"> 40     return sqrtf(dx * dx + dy * dy);</span>
 41 }
 42 
 43 struct QuadraticBezier {
 44     QuadraticBezier() { }
 45     QuadraticBezier(const FloatPoint&amp; s, const FloatPoint&amp; c, const FloatPoint&amp; e)
 46         : start(s)
 47         , control(c)
 48         , end(e)
 49     {
 50     }
 51 
 52     bool operator==(const QuadraticBezier&amp; rhs) const
 53     {
 54         return start == rhs.start
 55             &amp;&amp; control == rhs.control
 56             &amp;&amp; end == rhs.end;
 57     }
 58 
 59     float approximateDistance() const
 60     {
</pre>
<hr />
<pre>
226 
227     ASSERT(m_action == Action::VectorAtLength);
228 
229     if (m_totalLength &gt;= m_desiredLength) {
230         float slope = FloatPoint(m_current - m_previous).slopeAngleRadians();
231         float offset = m_desiredLength - m_totalLength;
232         m_current.move(offset * cosf(slope), offset * sinf(slope));
233 
234         if (!m_isZeroVector &amp;&amp; !m_desiredLength)
235             m_isZeroVector = true;
236         else {
237             m_success = true;
238             m_normalAngle = rad2deg(slope);
239         }
240     }
241 
242     m_previous = m_current;
243     return m_success;
244 }
245 
<span class="line-modified">246 bool PathTraversalState::appendPathElement(PathElementType type, const FloatPoint* points)</span>
247 {
248     switch (type) {
<span class="line-modified">249     case PathElementMoveToPoint:</span>
250         moveTo(points[0]);
251         break;
<span class="line-modified">252     case PathElementAddLineToPoint:</span>
253         lineTo(points[0]);
254         break;
<span class="line-modified">255     case PathElementAddQuadCurveToPoint:</span>
256         quadraticBezierTo(points[0], points[1]);
257         break;
<span class="line-modified">258     case PathElementAddCurveToPoint:</span>
259         cubicBezierTo(points[0], points[1], points[2]);
260         break;
<span class="line-modified">261     case PathElementCloseSubpath:</span>
262         closeSubpath();
263         break;
264     }
265 
266     return finalizeAppendPathElement();
267 }
268 
<span class="line-modified">269 bool PathTraversalState::processPathElement(PathElementType type, const FloatPoint* points)</span>
270 {
271     if (m_success)
272         return true;
273 
274     if (m_isZeroVector) {
275         PathTraversalState traversalState(*this);
276         m_success = traversalState.appendPathElement(type, points);
277         m_normalAngle = traversalState.m_normalAngle;
278         return m_success;
279     }
280 
281     return appendPathElement(type, points);
282 }
283 
284 }
285 
</pre>
</td>
<td>
<hr />
<pre>
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;PathTraversalState.h&quot;
 23 
 24 #include &lt;wtf/MathExtras.h&gt;
 25 #include &lt;wtf/Vector.h&gt;
 26 
 27 namespace WebCore {
 28 
 29 static const float kPathSegmentLengthTolerance = 0.00001f;
 30 
 31 static inline FloatPoint midPoint(const FloatPoint&amp; first, const FloatPoint&amp; second)
 32 {
 33     return FloatPoint((first.x() + second.x()) / 2.0f, (first.y() + second.y()) / 2.0f);
 34 }
 35 
 36 static inline float distanceLine(const FloatPoint&amp; start, const FloatPoint&amp; end)
 37 {
<span class="line-modified"> 38     return std::hypot(end.x() - start.x(), end.y() - start.y());</span>


 39 }
 40 
 41 struct QuadraticBezier {
 42     QuadraticBezier() { }
 43     QuadraticBezier(const FloatPoint&amp; s, const FloatPoint&amp; c, const FloatPoint&amp; e)
 44         : start(s)
 45         , control(c)
 46         , end(e)
 47     {
 48     }
 49 
 50     bool operator==(const QuadraticBezier&amp; rhs) const
 51     {
 52         return start == rhs.start
 53             &amp;&amp; control == rhs.control
 54             &amp;&amp; end == rhs.end;
 55     }
 56 
 57     float approximateDistance() const
 58     {
</pre>
<hr />
<pre>
224 
225     ASSERT(m_action == Action::VectorAtLength);
226 
227     if (m_totalLength &gt;= m_desiredLength) {
228         float slope = FloatPoint(m_current - m_previous).slopeAngleRadians();
229         float offset = m_desiredLength - m_totalLength;
230         m_current.move(offset * cosf(slope), offset * sinf(slope));
231 
232         if (!m_isZeroVector &amp;&amp; !m_desiredLength)
233             m_isZeroVector = true;
234         else {
235             m_success = true;
236             m_normalAngle = rad2deg(slope);
237         }
238     }
239 
240     m_previous = m_current;
241     return m_success;
242 }
243 
<span class="line-modified">244 bool PathTraversalState::appendPathElement(PathElement::Type type, const FloatPoint* points)</span>
245 {
246     switch (type) {
<span class="line-modified">247     case PathElement::Type::MoveToPoint:</span>
248         moveTo(points[0]);
249         break;
<span class="line-modified">250     case PathElement::Type::AddLineToPoint:</span>
251         lineTo(points[0]);
252         break;
<span class="line-modified">253     case PathElement::Type::AddQuadCurveToPoint:</span>
254         quadraticBezierTo(points[0], points[1]);
255         break;
<span class="line-modified">256     case PathElement::Type::AddCurveToPoint:</span>
257         cubicBezierTo(points[0], points[1], points[2]);
258         break;
<span class="line-modified">259     case PathElement::Type::CloseSubpath:</span>
260         closeSubpath();
261         break;
262     }
263 
264     return finalizeAppendPathElement();
265 }
266 
<span class="line-modified">267 bool PathTraversalState::processPathElement(PathElement::Type type, const FloatPoint* points)</span>
268 {
269     if (m_success)
270         return true;
271 
272     if (m_isZeroVector) {
273         PathTraversalState traversalState(*this);
274         m_success = traversalState.appendPathElement(type, points);
275         m_normalAngle = traversalState.m_normalAngle;
276         return m_success;
277     }
278 
279     return appendPathElement(type, points);
280 }
281 
282 }
283 
</pre>
</td>
</tr>
</table>
<center><a href="Path.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PathTraversalState.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
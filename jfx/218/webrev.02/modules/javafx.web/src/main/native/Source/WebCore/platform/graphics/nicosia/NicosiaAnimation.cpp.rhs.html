<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/nicosia/NicosiaAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies)
  3 
  4  This library is free software; you can redistribute it and/or
  5  modify it under the terms of the GNU Library General Public
  6  License as published by the Free Software Foundation; either
  7  version 2 of the License, or (at your option) any later version.
  8 
  9  This library is distributed in the hope that it will be useful,
 10  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  Library General Public License for more details.
 13 
 14  You should have received a copy of the GNU Library General Public License
 15  along with this library; see the file COPYING.LIB.  If not, write to
 16  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;NicosiaAnimation.h&quot;
 22 
 23 #include &quot;LayoutSize.h&quot;
 24 
 25 namespace Nicosia {
 26 
 27 using namespace WebCore;
 28 
 29 static RefPtr&lt;FilterOperation&gt; blendFunc(FilterOperation* fromOp, FilterOperation&amp; toOp, double progress, const FloatSize&amp;, bool blendToPassthrough = false)
 30 {
 31     return toOp.blend(fromOp, progress, blendToPassthrough);
 32 }
 33 
 34 static FilterOperations applyFilterAnimation(const FilterOperations&amp; from, const FilterOperations&amp; to, double progress, const FloatSize&amp; boxSize)
 35 {
 36     // First frame of an animation.
 37     if (!progress)
 38         return from;
 39 
 40     // Last frame of an animation.
 41     if (progress == 1)
 42         return to;
 43 
 44     if (!from.isEmpty() &amp;&amp; !to.isEmpty() &amp;&amp; !from.operationsMatch(to))
 45         return to;
 46 
 47     FilterOperations result;
 48 
 49     size_t fromSize = from.operations().size();
 50     size_t toSize = to.operations().size();
 51     size_t size = std::max(fromSize, toSize);
 52     for (size_t i = 0; i &lt; size; i++) {
 53         RefPtr&lt;FilterOperation&gt; fromOp = (i &lt; fromSize) ? from.operations()[i].get() : nullptr;
 54         RefPtr&lt;FilterOperation&gt; toOp = (i &lt; toSize) ? to.operations()[i].get() : nullptr;
 55         RefPtr&lt;FilterOperation&gt; blendedOp = toOp ? blendFunc(fromOp.get(), *toOp, progress, boxSize) : (fromOp ? blendFunc(nullptr, *fromOp, progress, boxSize, true) : nullptr);
 56         if (blendedOp)
 57             result.operations().append(blendedOp);
 58         else {
 59             auto identityOp = PassthroughFilterOperation::create();
 60             if (progress &gt; 0.5)
 61                 result.operations().append(toOp ? toOp : WTFMove(identityOp));
 62             else
 63                 result.operations().append(fromOp ? fromOp : WTFMove(identityOp));
 64         }
 65     }
 66 
 67     return result;
 68 }
 69 
 70 static bool shouldReverseAnimationValue(WebCore::Animation::AnimationDirection direction, int loopCount)
 71 {
 72     return (direction == WebCore::Animation::AnimationDirectionAlternate &amp;&amp; loopCount &amp; 1)
 73         || (direction == WebCore::Animation::AnimationDirectionAlternateReverse &amp;&amp; !(loopCount &amp; 1))
 74         || direction == WebCore::Animation::AnimationDirectionReverse;
 75 }
 76 
 77 static double normalizedAnimationValue(double runningTime, double duration, WebCore::Animation::AnimationDirection direction, double iterationCount)
 78 {
 79     if (!duration)
 80         return 0;
 81 
 82     const int loopCount = runningTime / duration;
 83     const double lastFullLoop = duration * double(loopCount);
 84     const double remainder = runningTime - lastFullLoop;
 85     // Ignore remainder when we&#39;ve reached the end of animation.
 86     const double normalized = (loopCount == iterationCount) ? 1.0 : (remainder / duration);
 87 
 88     return shouldReverseAnimationValue(direction, loopCount) ? 1 - normalized : normalized;
 89 }
 90 
 91 static double normalizedAnimationValueForFillsForwards(double iterationCount, WebCore::Animation::AnimationDirection direction)
 92 {
 93     if (direction == WebCore::Animation::AnimationDirectionNormal)
 94         return 1;
 95     if (direction == WebCore::Animation::AnimationDirectionReverse)
 96         return 0;
 97     return shouldReverseAnimationValue(direction, iterationCount) ? 1 : 0;
 98 }
 99 
100 static float applyOpacityAnimation(float fromOpacity, float toOpacity, double progress)
101 {
102     // Optimization: special case the edge values (0 and 1).
103     if (progress == 1.0)
104         return toOpacity;
105 
106     if (!progress)
107         return fromOpacity;
108 
109     return fromOpacity + progress * (toOpacity - fromOpacity);
110 }
111 
112 static TransformationMatrix applyTransformAnimation(const TransformOperations&amp; from, const TransformOperations&amp; to, double progress, const FloatSize&amp; boxSize, bool listsMatch)
113 {
114     TransformationMatrix matrix;
115 
116     // First frame of an animation.
117     if (!progress) {
118         from.apply(boxSize, matrix);
119         return matrix;
120     }
121 
122     // Last frame of an animation.
123     if (progress == 1) {
124         to.apply(boxSize, matrix);
125         return matrix;
126     }
127 
128     // If we have incompatible operation lists, we blend the resulting matrices.
129     if (!listsMatch) {
130         TransformationMatrix fromMatrix;
131         to.apply(boxSize, matrix);
132         from.apply(boxSize, fromMatrix);
133         matrix.blend(fromMatrix, progress);
134         return matrix;
135     }
136 
137     // Animation to &quot;-webkit-transform: none&quot;.
138     if (!to.size()) {
139         TransformOperations blended(from);
140         for (auto&amp; operation : blended.operations())
141             operation-&gt;blend(nullptr, progress, true)-&gt;apply(matrix, boxSize);
142         return matrix;
143     }
144 
145     // Animation from &quot;-webkit-transform: none&quot;.
146     if (!from.size()) {
147         TransformOperations blended(to);
148         for (auto&amp; operation : blended.operations())
149             operation-&gt;blend(nullptr, 1 - progress, true)-&gt;apply(matrix, boxSize);
150         return matrix;
151     }
152 
153     // Normal animation with a matching operation list.
154     TransformOperations blended(to);
155     for (size_t i = 0; i &lt; blended.operations().size(); ++i)
156         blended.operations()[i]-&gt;blend(from.at(i), progress, !from.at(i))-&gt;apply(matrix, boxSize);
157     return matrix;
158 }
159 
160 static const TimingFunction&amp; timingFunctionForAnimationValue(const AnimationValue&amp; animationValue, const Animation&amp; animation)
161 {
162     if (animationValue.timingFunction())
163         return *animationValue.timingFunction();
164     if (animation.timingFunction())
165         return *animation.timingFunction();
166     return CubicBezierTimingFunction::defaultTimingFunction();
167 }
168 
169 Animation::Animation(const String&amp; name, const KeyframeValueList&amp; keyframes, const FloatSize&amp; boxSize, const WebCore::Animation&amp; animation, bool listsMatch, MonotonicTime startTime, Seconds pauseTime, AnimationState state)
170     : m_name(name.isSafeToSendToAnotherThread() ? name : name.isolatedCopy())
171     , m_keyframes(keyframes)
172     , m_boxSize(boxSize)
173     , m_timingFunction(animation.timingFunction()-&gt;clone())
174     , m_iterationCount(animation.iterationCount())
175     , m_duration(animation.duration())
176     , m_direction(animation.direction())
177     , m_fillsForwards(animation.fillsForwards())
178     , m_listsMatch(listsMatch)
179     , m_startTime(startTime)
180     , m_pauseTime(pauseTime)
181     , m_totalRunningTime(0_s)
182     , m_lastRefreshedTime(m_startTime)
183     , m_state(state)
184 {
185 }
186 
187 Animation::Animation(const Animation&amp; other)
188     : m_name(other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy())
189     , m_keyframes(other.m_keyframes)
190     , m_boxSize(other.m_boxSize)
191     , m_timingFunction(other.m_timingFunction-&gt;clone())
192     , m_iterationCount(other.m_iterationCount)
193     , m_duration(other.m_duration)
194     , m_direction(other.m_direction)
195     , m_fillsForwards(other.m_fillsForwards)
196     , m_listsMatch(other.m_listsMatch)
197     , m_startTime(other.m_startTime)
198     , m_pauseTime(other.m_pauseTime)
199     , m_totalRunningTime(other.m_totalRunningTime)
200     , m_lastRefreshedTime(other.m_lastRefreshedTime)
201     , m_state(other.m_state)
202 {
203 }
204 
<a name="1" id="anc1"></a><span class="line-added">205 Animation&amp; Animation::operator=(const Animation&amp; other)</span>
<span class="line-added">206 {</span>
<span class="line-added">207     m_name = other.m_name.isSafeToSendToAnotherThread() ? other.m_name : other.m_name.isolatedCopy();</span>
<span class="line-added">208     m_keyframes = other.m_keyframes;</span>
<span class="line-added">209     m_boxSize = other.m_boxSize;</span>
<span class="line-added">210     m_timingFunction = other.m_timingFunction-&gt;clone();</span>
<span class="line-added">211     m_iterationCount = other.m_iterationCount;</span>
<span class="line-added">212     m_duration = other.m_duration;</span>
<span class="line-added">213     m_direction = other.m_direction;</span>
<span class="line-added">214     m_fillsForwards = other.m_fillsForwards;</span>
<span class="line-added">215     m_listsMatch = other.m_listsMatch;</span>
<span class="line-added">216     m_startTime = other.m_startTime;</span>
<span class="line-added">217     m_pauseTime = other.m_pauseTime;</span>
<span class="line-added">218     m_totalRunningTime = other.m_totalRunningTime;</span>
<span class="line-added">219     m_lastRefreshedTime = other.m_lastRefreshedTime;</span>
<span class="line-added">220     m_state = other.m_state;</span>
<span class="line-added">221     return *this;</span>
<span class="line-added">222 }</span>
<span class="line-added">223 </span>
224 void Animation::apply(ApplicationResult&amp; applicationResults, MonotonicTime time)
225 {
<a name="2" id="anc2"></a><span class="line-modified">226     // Even when m_state == AnimationState::Stopped &amp;&amp; !m_fillsForwards, we should calculate the last value to avoid a flash.</span>
<span class="line-modified">227     // CoordinatedGraphicsScene will soon remove the stopped animation and update the value instead of this function.</span>
228 
229     Seconds totalRunningTime = computeTotalRunningTime(time);
230     double normalizedValue = normalizedAnimationValue(totalRunningTime.seconds(), m_duration, m_direction, m_iterationCount);
231 
232     if (m_iterationCount != WebCore::Animation::IterationCountInfinite &amp;&amp; totalRunningTime.seconds() &gt;= m_duration * m_iterationCount) {
233         m_state = AnimationState::Stopped;
234         m_pauseTime = 0_s;
<a name="3" id="anc3"></a><span class="line-modified">235         normalizedValue = normalizedAnimationValueForFillsForwards(m_iterationCount, m_direction);</span>

236     }
237 
238     applicationResults.hasRunningAnimations |= (m_state == AnimationState::Playing);
239 
240     if (!normalizedValue) {
241         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), 0);
242         return;
243     }
244 
245     if (normalizedValue == 1.0) {
246         applyInternal(applicationResults, m_keyframes.at(m_keyframes.size() - 2), m_keyframes.at(m_keyframes.size() - 1), 1);
247         return;
248     }
249     if (m_keyframes.size() == 2) {
250         auto&amp; timingFunction = timingFunctionForAnimationValue(m_keyframes.at(0), *this);
251         normalizedValue = timingFunction.transformTime(normalizedValue, m_duration);
252         applyInternal(applicationResults, m_keyframes.at(0), m_keyframes.at(1), normalizedValue);
253         return;
254     }
255 
256     for (size_t i = 0; i &lt; m_keyframes.size() - 1; ++i) {
257         const AnimationValue&amp; from = m_keyframes.at(i);
258         const AnimationValue&amp; to = m_keyframes.at(i + 1);
259         if (from.keyTime() &gt; normalizedValue || to.keyTime() &lt; normalizedValue)
260             continue;
261 
262         normalizedValue = (normalizedValue - from.keyTime()) / (to.keyTime() - from.keyTime());
263         auto&amp; timingFunction = timingFunctionForAnimationValue(from, *this);
264         normalizedValue = timingFunction.transformTime(normalizedValue, m_duration);
265         applyInternal(applicationResults, from, to, normalizedValue);
266         break;
267     }
268 }
269 
270 void Animation::applyKeepingInternalState(ApplicationResult&amp; applicationResults, MonotonicTime time)
271 {
272     MonotonicTime oldLastRefreshedTime = m_lastRefreshedTime;
273     Seconds oldTotalRunningTime = m_totalRunningTime;
274     AnimationState oldState = m_state;
275 
276     apply(applicationResults, time);
277 
278     m_lastRefreshedTime = oldLastRefreshedTime;
279     m_totalRunningTime = oldTotalRunningTime;
280     m_state = oldState;
281 }
282 
283 void Animation::pause(Seconds time)
284 {
285     m_state = AnimationState::Paused;
286     m_pauseTime = time;
287 }
288 
289 void Animation::resume()
290 {
291     m_state = AnimationState::Playing;
292     // FIXME: This seems wrong. m_totalRunningTime is cleared.
293     // https://bugs.webkit.org/show_bug.cgi?id=183113
294     m_pauseTime = 0_s;
295     m_totalRunningTime = m_pauseTime;
296     m_lastRefreshedTime = MonotonicTime::now();
297 }
298 
299 Seconds Animation::computeTotalRunningTime(MonotonicTime time)
300 {
301     if (m_state == AnimationState::Paused)
302         return m_pauseTime;
303 
304     MonotonicTime oldLastRefreshedTime = m_lastRefreshedTime;
305     m_lastRefreshedTime = time;
306     m_totalRunningTime += m_lastRefreshedTime - oldLastRefreshedTime;
307     return m_totalRunningTime;
308 }
309 
<a name="4" id="anc4"></a>




310 void Animation::applyInternal(ApplicationResult&amp; applicationResults, const AnimationValue&amp; from, const AnimationValue&amp; to, float progress)
311 {
312     switch (m_keyframes.property()) {
313     case AnimatedPropertyTransform:
314         applicationResults.transform = applyTransformAnimation(static_cast&lt;const TransformAnimationValue&amp;&gt;(from).value(), static_cast&lt;const TransformAnimationValue&amp;&gt;(to).value(), progress, m_boxSize, m_listsMatch);
315         return;
316     case AnimatedPropertyOpacity:
317         applicationResults.opacity = applyOpacityAnimation((static_cast&lt;const FloatAnimationValue&amp;&gt;(from).value()), (static_cast&lt;const FloatAnimationValue&amp;&gt;(to).value()), progress);
318         return;
319     case AnimatedPropertyFilter:
320         applicationResults.filters = applyFilterAnimation(static_cast&lt;const FilterAnimationValue&amp;&gt;(from).value(), static_cast&lt;const FilterAnimationValue&amp;&gt;(to).value(), progress, m_boxSize);
321         return;
322     default:
323         ASSERT_NOT_REACHED();
324     }
325 }
326 
327 void Animations::add(const Animation&amp; animation)
328 {
329     // Remove the old state if we are resuming a paused animation.
330     remove(animation.name(), animation.keyframes().property());
331 
332     m_animations.append(animation);
333 }
334 
335 void Animations::remove(const String&amp; name)
336 {
337     m_animations.removeAllMatching([&amp;name] (const Animation&amp; animation) {
338         return animation.name() == name;
339     });
340 }
341 
342 void Animations::remove(const String&amp; name, AnimatedPropertyID property)
343 {
344     m_animations.removeAllMatching([&amp;name, property] (const Animation&amp; animation) {
345         return animation.name() == name &amp;&amp; animation.keyframes().property() == property;
346     });
347 }
348 
349 void Animations::pause(const String&amp; name, Seconds offset)
350 {
351     for (auto&amp; animation : m_animations) {
352         if (animation.name() == name)
353             animation.pause(offset);
354     }
355 }
356 
357 void Animations::suspend(MonotonicTime time)
358 {
359     // FIXME: This seems wrong. `pause` takes time offset (Seconds), not MonotonicTime.
360     // https://bugs.webkit.org/show_bug.cgi?id=183112
361     for (auto&amp; animation : m_animations)
362         animation.pause(time.secondsSinceEpoch());
363 }
364 
365 void Animations::resume()
366 {
367     for (auto&amp; animation : m_animations)
368         animation.resume();
369 }
370 
371 void Animations::apply(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
372 {
373     for (auto&amp; animation : m_animations)
374         animation.apply(applicationResults, time);
375 }
376 
377 void Animations::applyKeepingInternalState(Animation::ApplicationResult&amp; applicationResults, MonotonicTime time)
378 {
379     for (auto&amp; animation : m_animations)
380         animation.applyKeepingInternalState(applicationResults, time);
381 }
382 
383 bool Animations::hasActiveAnimationsOfType(AnimatedPropertyID type) const
384 {
385     return std::any_of(m_animations.begin(), m_animations.end(),
386         [&amp;type](const Animation&amp; animation) {
<a name="5" id="anc5"></a><span class="line-modified">387             return animation.keyframes().property() == type;</span>
388         });
389 }
390 
391 bool Animations::hasRunningAnimations() const
392 {
393     return std::any_of(m_animations.begin(), m_animations.end(),
394         [](const Animation&amp; animation) {
395             return animation.state() == Animation::AnimationState::Playing;
396         });
397 }
398 
<a name="6" id="anc6"></a>









399 } // namespace Nicosia
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
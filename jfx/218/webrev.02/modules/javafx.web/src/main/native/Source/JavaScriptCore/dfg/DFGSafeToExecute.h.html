<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGGraph.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 
 34 // This phase is used to determine if a node can safely run at a new location.
 35 // It is important to note that returning false does not mean it&#39;s definitely
 36 // wrong to run the node at the new location. In other words, returning false
 37 // does not imply moving the node would be invalid only that this phase could
 38 // not prove it is valid. Thus, it is always ok to return false.
 39 
 40 template&lt;typename AbstractStateType&gt;
 41 class SafeToExecuteEdge {
 42 public:
 43     SafeToExecuteEdge(AbstractStateType&amp; state)
 44         : m_state(state)
 45     {
 46     }
 47 
 48     void operator()(Node*, Edge edge)
 49     {
 50         m_maySeeEmptyChild |= !!(m_state.forNode(edge).m_type &amp; SpecEmpty);
 51 
 52         switch (edge.useKind()) {
 53         case UntypedUse:
 54         case Int32Use:
 55         case DoubleRepUse:
 56         case DoubleRepRealUse:
 57         case Int52RepUse:
 58         case NumberUse:
 59         case RealNumberUse:
 60         case BooleanUse:
 61         case CellUse:
 62         case CellOrOtherUse:
 63         case ObjectUse:
 64         case ArrayUse:
 65         case FunctionUse:
 66         case FinalObjectUse:
 67         case RegExpObjectUse:
 68         case PromiseObjectUse:
 69         case ProxyObjectUse:
 70         case DerivedArrayUse:
 71         case DateObjectUse:
 72         case MapObjectUse:
 73         case SetObjectUse:
 74         case WeakMapObjectUse:
 75         case WeakSetObjectUse:
 76         case DataViewObjectUse:
 77         case ObjectOrOtherUse:
 78         case StringIdentUse:
 79         case StringUse:
 80         case StringOrOtherUse:
 81         case SymbolUse:
 82         case BigIntUse:
 83         case StringObjectUse:
 84         case StringOrStringObjectUse:
 85         case NotStringVarUse:
 86         case NotSymbolUse:
 87         case NotCellUse:
 88         case OtherUse:
 89         case MiscUse:
 90         case AnyIntUse:
 91         case DoubleRepAnyIntUse:
 92             return;
 93 
 94         case KnownInt32Use:
 95             if (m_state.forNode(edge).m_type &amp; ~SpecInt32Only)
 96                 m_result = false;
 97             return;
 98 
 99         case KnownBooleanUse:
100             if (m_state.forNode(edge).m_type &amp; ~SpecBoolean)
101                 m_result = false;
102             return;
103 
104         case KnownCellUse:
105             if (m_state.forNode(edge).m_type &amp; ~SpecCell)
106                 m_result = false;
107             return;
108 
109         case KnownStringUse:
110             if (m_state.forNode(edge).m_type &amp; ~SpecString)
111                 m_result = false;
112             return;
113 
114         case KnownPrimitiveUse:
115             if (m_state.forNode(edge).m_type &amp; ~(SpecHeapTop &amp; ~SpecObject))
116                 m_result = false;
117             return;
118 
119         case KnownOtherUse:
120             if (m_state.forNode(edge).m_type &amp; ~SpecOther)
121                 m_result = false;
122             return;
123 
124         case LastUseKind:
125             RELEASE_ASSERT_NOT_REACHED();
126             break;
127         }
128         RELEASE_ASSERT_NOT_REACHED();
129     }
130 
131     bool result() const { return m_result; }
132     bool maySeeEmptyChild() const { return m_maySeeEmptyChild; }
133 private:
134     AbstractStateType&amp; m_state;
135     bool m_result { true };
136     bool m_maySeeEmptyChild { false };
137 };
138 
139 // Determines if it&#39;s safe to execute a node within the given abstract state. This may
140 // return false conservatively. If it returns true, then you can hoist the given node
141 // up to the given point and expect that it will not crash. It also guarantees that the
142 // node will not produce a malformed JSValue or object pointer when executed in the
143 // given state. But this doesn&#39;t guarantee that the node will produce the result you
144 // wanted. For example, you may have a GetByOffset from a prototype that only makes
145 // semantic sense if you&#39;ve also checked that some nearer prototype doesn&#39;t also have
146 // a property of the same name. This could still return true even if that check hadn&#39;t
147 // been performed in the given abstract state. That&#39;s fine though: the load can still
148 // safely execute before that check, so long as that check continues to guard any
149 // user-observable things done to the loaded value.
150 template&lt;typename AbstractStateType&gt;
151 bool safeToExecute(AbstractStateType&amp; state, Graph&amp; graph, Node* node, bool ignoreEmptyChildren = false)
152 {
153     SafeToExecuteEdge&lt;AbstractStateType&gt; safeToExecuteEdge(state);
154     DFG_NODE_DO_TO_CHILDREN(graph, node, safeToExecuteEdge);
155     if (!safeToExecuteEdge.result())
156         return false;
157 
158     if (!ignoreEmptyChildren &amp;&amp; safeToExecuteEdge.maySeeEmptyChild()) {
159         // We conservatively assume if the empty value flows into a node,
160         // it might not be able to handle it (e.g, crash). In general, the bytecode generator
161         // emits code in such a way that most node types don&#39;t need to worry about the empty value
162         // because they will never see it. However, code motion has to consider the empty
163         // value so it does not insert/move nodes to a place where they will crash. E.g, the
164         // type check hoisting phase needs to insert CheckStructureOrEmpty instead of CheckStructure
165         // for hoisted structure checks because it can not guarantee that a particular local is not
166         // the empty value.
167         switch (node-&gt;op()) {
168         case CheckNotEmpty:
169         case CheckStructureOrEmpty:
170         case CheckArrayOrEmpty:
171             break;
172         default:
173             return false;
174         }
175     }
176 
177     // NOTE: This can lie when it comes to effectful nodes, because it knows that they aren&#39;t going to
178     // get hoisted anyway. Sometimes this is convenient so we can avoid branching on some internal
179     // state of the node (like what some child&#39;s UseKind might be). However, nodes that are obviously
180     // always effectful, we return false for, to make auditing the &quot;return true&quot; cases easier.
181 
182     switch (node-&gt;op()) {
183     // FIXME: Audit these:
184     // https://bugs.webkit.org/show_bug.cgi?id=207075
185     case JSConstant:
186     case DoubleConstant:
187     case Int52Constant:
188     case LazyJSConstant:
189     case Identity:
190     case IdentityWithProfile:
191     case GetCallee:
192     case GetArgumentCountIncludingThis:
193     case GetRestLength:
194     case GetLocal:
195     case GetStack:
196     case ExitOK:
197     case Phantom:
198     case ArithBitNot:
199     case ArithBitAnd:
200     case ArithBitOr:
201     case ArithBitXor:
202     case ArithBitLShift:
203     case ArithBitRShift:
204     case BitURShift:
205     case ValueToInt32:
206     case UInt32ToNumber:
207     case DoubleAsInt32:
208     case ArithAdd:
209     case ArithClz32:
210     case ArithSub:
211     case ArithNegate:
212     case ArithMul:
213     case ArithIMul:
214     case ArithDiv:
215     case ArithMod:
216     case ArithAbs:
217     case ArithMin:
218     case ArithMax:
219     case ArithPow:
220     case ArithRandom:
221     case ArithSqrt:
222     case ArithFRound:
223     case ArithRound:
224     case ArithFloor:
225     case ArithCeil:
226     case ArithTrunc:
227     case ArithUnary:
228     case TryGetById: // FIXME: Audit this: https://bugs.webkit.org/show_bug.cgi?id=163834
229     case CheckStructure:
230     case CheckStructureOrEmpty:
231     case GetExecutable:
232     case CallDOMGetter:
233     case CallDOM:
234     case CheckSubClass:
235     case CheckArray:
236     case CheckArrayOrEmpty:
237     case GetScope:
238     case SkipScope:
239     case GetGlobalObject:
240     case GetGlobalThis:
241     case GetClosureVar:
242     case GetGlobalVar:
243     case GetGlobalLexicalVariable:
244     case CheckCell:
245     case CheckNotEmpty:
246     case AssertNotEmpty:
247     case CheckIdent:
248     case CompareLess:
249     case CompareLessEq:
250     case CompareGreater:
251     case CompareGreaterEq:
252     case CompareBelow:
253     case CompareBelowEq:
254     case CompareEq:
255     case CompareStrictEq:
256     case CompareEqPtr:
257     case SameValue:
258     case CheckTypeInfoFlags:
259     case ParseInt:
260     case OverridesHasInstance:
261     case IsEmpty:
262     case IsUndefined:
263     case IsUndefinedOrNull:
264     case IsBoolean:
265     case IsNumber:
266     case NumberIsInteger:
267     case IsObject:
268     case IsObjectOrNull:
269     case IsFunction:
270     case IsCellWithType:
271     case IsTypedArrayView:
272     case TypeOf:
273     case LogicalNot:
274     case ToString:
275     case NumberToStringWithValidRadixConstant:
276     case StrCat:
277     case CallStringConstructor:
278     case MakeRope:
279     case GetFromArguments:
280     case GetArgument:
281     case StringFromCharCode:
282     case ExtractOSREntryLocal:
283     case ExtractCatchLocal:
284     case CheckInBounds:
285     case ConstantStoragePointer:
286     case Check:
287     case CheckVarargs:
288     case ValueRep:
289     case DoubleRep:
290     case Int52Rep:
291     case BooleanToNumber:
292     case FiatInt52:
293     case HasIndexedProperty:
294     case GetEnumeratorStructurePname:
295     case GetEnumeratorGenericPname:
296     case ToIndexString:
297     case CheckStructureImmediate:
298     case GetMyArgumentByVal:
299     case GetMyArgumentByValOutOfBounds:
300     case GetPrototypeOf:
301     case StringReplace:
302     case StringReplaceRegExp:
303     case GetRegExpObjectLastIndex:
304     case MapHash:
305     case NormalizeMapKey:
306     case StringSlice:
307     case ToLowerCase:
308     case GetMapBucket:
309     case GetMapBucketHead:
310     case GetMapBucketNext:
311     case LoadKeyFromMapBucket:
312     case LoadValueFromMapBucket:
313     case ExtractValueFromWeakMapGet:
314     case WeakMapGet:
315     case AtomicsIsLockFree:
316     case MatchStructure:
317     case DateGetInt32OrNaN:
318     case DateGetTime:
319     case DataViewGetInt:
320     case DataViewGetFloat:
321         return true;
322 
323     case GetButterfly:
324         return state.forNode(node-&gt;child1()).isType(SpecObject);
325 
326     case ArraySlice:
327     case ArrayIndexOf: {
328         // You could plausibly move this code around as long as you proved the
329         // incoming array base structure is an original array at the hoisted location.
330         // Instead of doing that extra work, we just conservatively return false.
331         return false;
332     }
333 
334     case GetGetter:
335     case GetSetter: {
336         if (!state.forNode(node-&gt;child1()).isType(SpecCell))
337             return false;
338         StructureAbstractValue&amp; value = state.forNode(node-&gt;child1()).m_structure;
339         if (value.isInfinite() || value.size() != 1)
340             return false;
341 
342         return value[0].get() == graph.m_vm.getterSetterStructure;
343     }
344 
345     case BottomValue:
346         // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
347         // compiling this node.
348         return false;
349 
350     case StoreBarrier:
351     case FencedStoreBarrier:
352     case PutStructure:
353     case NukeStructureAndSetButterfly:
354         // We conservatively assume that these cannot be put anywhere, which forces the compiler to
355         // keep them exactly where they were. This is sort of overkill since the clobberize effects
356         // already force these things to be ordered precisely. I&#39;m just not confident enough in my
357         // effect based memory model to rely solely on that right now.
358         return false;
359 
360     case FilterCallLinkStatus:
361     case FilterGetByStatus:
362     case FilterPutByIdStatus:
363     case FilterInByIdStatus:
364         // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
365         // to capture &quot;profiling&quot; at the point in control flow here the user put them.
366         return false;
367 
368     case GetByVal:
369     case GetIndexedPropertyStorage:
370     case GetArrayLength:
371     case GetVectorLength:
372     case ArrayPop:
373     case StringCharAt:
374     case StringCharCodeAt:
375     case StringCodePointAt:
376         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
377 
378     case ArrayPush:
379         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
380 
381     case CheckNeutered:
382     case GetTypedArrayByteOffset:
383         return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
384 
385     case PutByValDirect:
386     case PutByVal:
387     case PutByValAlias:
388         return node-&gt;arrayMode().modeForPut().alreadyChecked(
389             graph, node, state.forNode(graph.varArgChild(node, 0)));
390 
391     case AllocatePropertyStorage:
392     case ReallocatePropertyStorage:
393         return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
394             RegisteredStructureSet(node-&gt;transition()-&gt;previous));
395 
396     case GetGetterSetterByOffset: {
397         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.
398         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))
399             return false;
400 
401         StorageAccessData&amp; data = node-&gt;storageAccessData();
402         auto* uid = graph.identifiers()[data.identifierNumber];
403         PropertyOffset desiredOffset = data.offset;
404         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
405         if (value.isInfinite())
406             return false;
407         for (unsigned i = value.size(); i--;) {
408             Structure* thisStructure = value[i].get();
409             if (thisStructure-&gt;isUncacheableDictionary())
410                 return false;
411             unsigned attributes = 0;
412             PropertyOffset checkOffset = thisStructure-&gt;getConcurrently(uid, attributes);
413             if (checkOffset != desiredOffset || !(attributes &amp; PropertyAttribute::Accessor))
414                 return false;
415         }
416         return true;
417     }
418 
419     case GetByOffset:
420     case PutByOffset: {
421         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.
422         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))
423             return false;
424 
425         StorageAccessData&amp; data = node-&gt;storageAccessData();
426         PropertyOffset offset = data.offset;
427         // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
428         // know anything about inferred types. But if we have a proof derived from watching a
429         // structure that has a type proof, then the next case below will deal with it.
430         if (state.structureClobberState() == StructuresAreWatched) {
431             if (JSObject* knownBase = node-&gt;child2()-&gt;dynamicCastConstant&lt;JSObject*&gt;(graph.m_vm)) {
432                 if (graph.isSafeToLoad(knownBase, offset))
433                     return true;
434             }
435         }
436 
437         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
438         if (value.isInfinite())
439             return false;
440         for (unsigned i = value.size(); i--;) {
441             Structure* thisStructure = value[i].get();
442             if (thisStructure-&gt;isUncacheableDictionary())
443                 return false;
444             if (!thisStructure-&gt;isValidOffset(offset))
445                 return false;
446         }
447         return true;
448     }
449 
450     case MultiGetByOffset: {
451         // We can&#39;t always guarantee that the MultiGetByOffset is safe to execute if it
452         // contains loads from prototypes. If the load requires a check in IR, which is rare, then
453         // we currently claim that we don&#39;t know if it&#39;s safe to execute because finding that
454         // check in the abstract state would be hard. If the load requires watchpoints, we just
455         // check if we&#39;re not in a clobbered state (i.e. in between a side effect and an
456         // invalidation point).
457         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
458             GetByOffsetMethod method = getCase.method();
459             switch (method.kind()) {
460             case GetByOffsetMethod::Invalid:
461                 RELEASE_ASSERT_NOT_REACHED();
462                 break;
463             case GetByOffsetMethod::Constant: // OK because constants are always safe to execute.
464             case GetByOffsetMethod::Load: // OK because the MultiGetByOffset has its own checks for loading from self.
465                 break;
466             case GetByOffsetMethod::LoadFromPrototype:
467                 // Only OK if the state isn&#39;t clobbered. That&#39;s almost always the case.
468                 if (state.structureClobberState() != StructuresAreWatched)
469                     return false;
470                 if (!graph.isSafeToLoad(method.prototype()-&gt;cast&lt;JSObject*&gt;(), method.offset()))
471                     return false;
472                 break;
473             }
474         }
475         return true;
476     }
477 
478     case ToThis:
479     case CreateThis:
480     case CreatePromise:
481     case CreateGenerator:
482     case CreateAsyncGenerator:
483     case ObjectCreate:
484     case ObjectKeys:
485     case SetLocal:
486     case SetCallee:
487     case PutStack:
488     case KillStack:
489     case MovHint:
490     case ZombieHint:
491     case Upsilon:
492     case Phi:
493     case Flush:
494     case SetArgumentDefinitely:
495     case SetArgumentMaybe:
496     case SetArgumentCountIncludingThis:
497     case PhantomLocal:
498     case DeleteById:
499     case DeleteByVal:
500     case GetById:
501     case GetByIdWithThis:
502     case GetByValWithThis:
503     case GetByIdFlush:
504     case GetByIdDirect:
505     case GetByIdDirectFlush:
506     case PutById:
507     case PutByIdFlush:
508     case PutByIdWithThis:
509     case PutByValWithThis:
510     case PutByIdDirect:
511     case PutGetterById:
512     case PutSetterById:
513     case PutGetterSetterById:
514     case PutGetterByVal:
515     case PutSetterByVal:
516     case DefineDataProperty:
517     case DefineAccessorProperty:
518     case Arrayify:
519     case ArrayifyToStructure:
520     case PutClosureVar:
521     case PutGlobalVariable:
522     case CheckBadCell:
523     case RegExpExec:
524     case RegExpExecNonGlobalOrSticky:
525     case RegExpTest:
526     case RegExpMatchFast:
527     case RegExpMatchFastGlobal:
528     case Call:
529     case DirectCall:
530     case TailCallInlinedCaller:
531     case DirectTailCallInlinedCaller:
532     case Construct:
533     case DirectConstruct:
534     case CallVarargs:
535     case CallEval:
536     case TailCallVarargsInlinedCaller:
537     case TailCallForwardVarargsInlinedCaller:
538     case ConstructVarargs:
539     case VarargsLength:
540     case LoadVarargs:
541     case CallForwardVarargs:
542     case ConstructForwardVarargs:
543     case NewObject:
544     case NewPromise:
545     case NewGenerator:
546     case NewAsyncGenerator:
547     case NewArray:
548     case NewArrayWithSize:
549     case NewArrayBuffer:
550     case NewArrayWithSpread:
551     case NewArrayIterator:
552     case Spread:
553     case NewRegexp:
554     case NewSymbol:
555     case ProfileType:
556     case ProfileControlFlow:
557     case InstanceOf:
558     case InstanceOfCustom:
559     case CallObjectConstructor:
560     case ToPrimitive:
561     case ToPropertyKey:
562     case ToNumber:
563     case ToNumeric:
564     case ToObject:
565     case NumberToStringWithRadix:
566     case SetFunctionName:
567     case NewStringObject:
568     case InByVal:
569     case InById:
570     case HasOwnProperty:
571     case PushWithScope:
572     case CreateActivation:
573     case CreateDirectArguments:
574     case CreateScopedArguments:
575     case CreateClonedArguments:
576     case CreateArgumentsButterfly:
577     case PutToArguments:
578     case NewFunction:
579     case NewGeneratorFunction:
580     case NewAsyncGeneratorFunction:
581     case NewAsyncFunction:
582     case Jump:
583     case Branch:
584     case Switch:
585     case EntrySwitch:
586     case Return:
587     case TailCall:
588     case DirectTailCall:
589     case TailCallVarargs:
590     case TailCallForwardVarargs:
591     case Throw:
592     case ThrowStaticError:
593     case CountExecution:
594     case SuperSamplerBegin:
595     case SuperSamplerEnd:
596     case ForceOSRExit:
597     case CPUIntrinsic:
598     case CheckTraps:
599     case LogShadowChickenPrologue:
600     case LogShadowChickenTail:
601     case NewTypedArray:
602     case Unreachable:
603     case ClearCatchLocals:
604     case CheckTierUpInLoop:
605     case CheckTierUpAtReturn:
606     case CheckTierUpAndOSREnter:
607     case LoopHint:
608     case InvalidationPoint:
609     case NotifyWrite:
610     case MultiPutByOffset:
611     case GetEnumerableLength:
612     case HasGenericProperty:
613     case HasStructureProperty:
614     case GetDirectPname:
615     case GetPropertyEnumerator:
616     case PhantomNewObject:
617     case PhantomNewFunction:
618     case PhantomNewGeneratorFunction:
619     case PhantomNewAsyncGeneratorFunction:
620     case PhantomNewAsyncFunction:
621     case PhantomNewArrayIterator:
622     case PhantomCreateActivation:
623     case PhantomNewRegexp:
624     case PutHint:
625     case MaterializeNewObject:
626     case MaterializeCreateActivation:
627     case MaterializeNewInternalFieldObject:
628     case PhantomDirectArguments:
629     case PhantomCreateRest:
630     case PhantomSpread:
631     case PhantomNewArrayWithSpread:
632     case PhantomNewArrayBuffer:
633     case PhantomClonedArguments:
634     case ForwardVarargs:
635     case CreateRest:
636     case SetRegExpObjectLastIndex:
637     case RecordRegExpCachedResult:
638     case GetDynamicVar:
639     case PutDynamicVar:
640     case ResolveScopeForHoistingFuncDeclInEval:
641     case ResolveScope:
642     case StringValueOf:
643     case WeakSetAdd:
644     case WeakMapSet:
645     case AtomicsAdd:
646     case AtomicsAnd:
647     case AtomicsCompareExchange:
648     case AtomicsExchange:
649     case AtomicsLoad:
650     case AtomicsOr:
651     case AtomicsStore:
652     case AtomicsSub:
653     case AtomicsXor:
654     case InitializeEntrypointArguments:
655     case ValueNegate:
656     case GetInternalField:
657     case PutInternalField:
658     case DataViewSet:
659     case SetAdd:
660     case MapSet:
661         return false;
662 
663     case Inc:
664     case Dec:
665         return node-&gt;child1().useKind() != UntypedUse;
666 
667     case ValueBitAnd:
668     case ValueBitXor:
669     case ValueBitOr:
670     case ValueBitLShift:
671     case ValueBitRShift:
672     case ValueAdd:
673     case ValueSub:
674     case ValueMul:
675     case ValueDiv:
676     case ValueMod:
677     case ValuePow:
678         return node-&gt;isBinaryUseKind(BigIntUse);
679 
680     case ValueBitNot:
681         return node-&gt;child1().useKind() == BigIntUse;
682 
683     case LastNodeType:
684         RELEASE_ASSERT_NOT_REACHED();
685         return false;
686     }
687 
688     RELEASE_ASSERT_NOT_REACHED();
689     return false;
690 }
691 
692 } } // namespace JSC::DFG
693 
694 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
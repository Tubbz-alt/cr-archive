<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineCallFrame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceOfAccessCase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeBlockHash.h&quot;
 30 #include &quot;CodeOrigin.h&quot;
 31 #include &quot;ValueRecovery.h&quot;
 32 #include &quot;WriteBarrier.h&quot;
 33 #include &lt;wtf/PrintStream.h&gt;
 34 #include &lt;wtf/StdLibExtras.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 
 39 struct InlineCallFrame;
<span class="line-modified"> 40 class ExecState;</span>
 41 class JSFunction;
 42 
 43 struct InlineCallFrame {
 44     enum Kind {
 45         Call,
 46         Construct,
 47         TailCall,
 48         CallVarargs,
 49         ConstructVarargs,
 50         TailCallVarargs,
 51 
 52         // For these, the stackOffset incorporates the argument count plus the true return PC
 53         // slot.
 54         GetterCall,
 55         SetterCall
 56     };
 57 
 58     static CallMode callModeFor(Kind kind)
 59     {
 60         switch (kind) {
</pre>
<hr />
<pre>
162             *callerCallKind = static_cast&lt;Kind&gt;(callKind);
163 
164         return codeOrigin;
165     }
166 
167     CodeOrigin* getCallerSkippingTailCalls(Kind* callerCallKind = nullptr)
168     {
169         return computeCallerSkippingTailCalls(this, callerCallKind);
170     }
171 
172     InlineCallFrame* getCallerInlineFrameSkippingTailCalls()
173     {
174         CodeOrigin* caller = getCallerSkippingTailCalls();
175         return caller ? caller-&gt;inlineCallFrame() : nullptr;
176     }
177 
178     Vector&lt;ValueRecovery&gt; argumentsWithFixup; // Includes &#39;this&#39; and arity fixups.
179     WriteBarrier&lt;CodeBlock&gt; baselineCodeBlock;
180     CodeOrigin directCaller;
181 
<span class="line-modified">182     unsigned argumentCountIncludingThis { 0 }; // Do not include fixups.</span>

183     signed stackOffset : 28;
184     unsigned kind : 3; // real type is Kind
185     bool isClosureCall : 1; // If false then we know that callee/scope are constants and the DFG won&#39;t treat them as variables, i.e. they have to be recovered manually.
186     VirtualRegister argumentCountRegister; // Only set when we inline a varargs call.
187 
188     ValueRecovery calleeRecovery;
189 
190     // There is really no good notion of a &quot;default&quot; set of values for
191     // InlineCallFrame&#39;s fields. This constructor is here just to reduce confusion if
192     // we forgot to initialize explicitly.
193     InlineCallFrame()
<span class="line-modified">194         : stackOffset(0)</span>


195         , kind(Call)
196         , isClosureCall(false)
197     {
198     }
199 
200     bool isVarargs() const
201     {
202         return isVarargs(static_cast&lt;Kind&gt;(kind));
203     }
204 
205     CodeSpecializationKind specializationKind() const { return specializationKindFor(static_cast&lt;Kind&gt;(kind)); }
206 
207     JSFunction* calleeConstant() const;
208 
209     // Get the callee given a machine call frame to which this InlineCallFrame belongs.
<span class="line-modified">210     JSFunction* calleeForCallFrame(ExecState*) const;</span>
211 
212     CString inferredName() const;
213     CodeBlockHash hash() const;
214     CString hashAsStringIfPossible() const;
215 
216     void setStackOffset(signed offset)
217     {
218         stackOffset = offset;
219         RELEASE_ASSERT(static_cast&lt;signed&gt;(stackOffset) == offset);
220     }
221 






222     ptrdiff_t callerFrameOffset() const { return stackOffset * sizeof(Register) + CallFrame::callerFrameOffset(); }
223     ptrdiff_t returnPCOffset() const { return stackOffset * sizeof(Register) + CallFrame::returnPCOffset(); }
224 
225     bool isStrictMode() const { return baselineCodeBlock-&gt;isStrictMode(); }
226 
227     void dumpBriefFunctionInformation(PrintStream&amp;) const;
228     void dump(PrintStream&amp;) const;
229     void dumpInContext(PrintStream&amp;, DumpContext*) const;
230 
231     MAKE_PRINT_METHOD(InlineCallFrame, dumpBriefFunctionInformation, briefFunctionInformation);
232 
233 };
234 
235 inline CodeBlock* baselineCodeBlockForInlineCallFrame(InlineCallFrame* inlineCallFrame)
236 {
237     RELEASE_ASSERT(inlineCallFrame);
238     return inlineCallFrame-&gt;baselineCodeBlock.get();
239 }
240 
241 inline CodeBlock* baselineCodeBlockForOriginAndBaselineCodeBlock(const CodeOrigin&amp; codeOrigin, CodeBlock* baselineCodeBlock)
242 {
<span class="line-modified">243     ASSERT(baselineCodeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
244     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
245     if (inlineCallFrame)
246         return baselineCodeBlockForInlineCallFrame(inlineCallFrame);
247     return baselineCodeBlock;
248 }
249 
<span class="line-modified">250 // This function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame</span>
251 template &lt;typename Function&gt;
<span class="line-modified">252 inline void CodeOrigin::walkUpInlineStack(const Function&amp; function)</span>
253 {
254     CodeOrigin codeOrigin = *this;
255     while (true) {
256         function(codeOrigin);
257         auto* inlineCallFrame = codeOrigin.inlineCallFrame();
258         if (!inlineCallFrame)
259             break;
260         codeOrigin = inlineCallFrame-&gt;directCaller;
261     }
262 }
263 
<span class="line-modified">264 ALWAYS_INLINE VirtualRegister remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>






















265 {
266     if (inlineCallFrame)
<span class="line-modified">267         return VirtualRegister(reg.offset() + inlineCallFrame-&gt;stackOffset);</span>
<span class="line-modified">268     return reg;</span>





269 }
270 
271 } // namespace JSC
272 
273 namespace WTF {
274 
275 void printInternal(PrintStream&amp;, JSC::InlineCallFrame::Kind);
276 
277 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CodeBlock.h&quot;
 29 #include &quot;CodeBlockHash.h&quot;
 30 #include &quot;CodeOrigin.h&quot;
 31 #include &quot;ValueRecovery.h&quot;
 32 #include &quot;WriteBarrier.h&quot;
 33 #include &lt;wtf/PrintStream.h&gt;
 34 #include &lt;wtf/StdLibExtras.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 
 39 struct InlineCallFrame;
<span class="line-modified"> 40 class CallFrame;</span>
 41 class JSFunction;
 42 
 43 struct InlineCallFrame {
 44     enum Kind {
 45         Call,
 46         Construct,
 47         TailCall,
 48         CallVarargs,
 49         ConstructVarargs,
 50         TailCallVarargs,
 51 
 52         // For these, the stackOffset incorporates the argument count plus the true return PC
 53         // slot.
 54         GetterCall,
 55         SetterCall
 56     };
 57 
 58     static CallMode callModeFor(Kind kind)
 59     {
 60         switch (kind) {
</pre>
<hr />
<pre>
162             *callerCallKind = static_cast&lt;Kind&gt;(callKind);
163 
164         return codeOrigin;
165     }
166 
167     CodeOrigin* getCallerSkippingTailCalls(Kind* callerCallKind = nullptr)
168     {
169         return computeCallerSkippingTailCalls(this, callerCallKind);
170     }
171 
172     InlineCallFrame* getCallerInlineFrameSkippingTailCalls()
173     {
174         CodeOrigin* caller = getCallerSkippingTailCalls();
175         return caller ? caller-&gt;inlineCallFrame() : nullptr;
176     }
177 
178     Vector&lt;ValueRecovery&gt; argumentsWithFixup; // Includes &#39;this&#39; and arity fixups.
179     WriteBarrier&lt;CodeBlock&gt; baselineCodeBlock;
180     CodeOrigin directCaller;
181 
<span class="line-modified">182     unsigned argumentCountIncludingThis : 22; // Do not include fixups.</span>
<span class="line-added">183     unsigned tmpOffset : 10;</span>
184     signed stackOffset : 28;
185     unsigned kind : 3; // real type is Kind
186     bool isClosureCall : 1; // If false then we know that callee/scope are constants and the DFG won&#39;t treat them as variables, i.e. they have to be recovered manually.
187     VirtualRegister argumentCountRegister; // Only set when we inline a varargs call.
188 
189     ValueRecovery calleeRecovery;
190 
191     // There is really no good notion of a &quot;default&quot; set of values for
192     // InlineCallFrame&#39;s fields. This constructor is here just to reduce confusion if
193     // we forgot to initialize explicitly.
194     InlineCallFrame()
<span class="line-modified">195         : argumentCountIncludingThis(0)</span>
<span class="line-added">196         , tmpOffset(0)</span>
<span class="line-added">197         , stackOffset(0)</span>
198         , kind(Call)
199         , isClosureCall(false)
200     {
201     }
202 
203     bool isVarargs() const
204     {
205         return isVarargs(static_cast&lt;Kind&gt;(kind));
206     }
207 
208     CodeSpecializationKind specializationKind() const { return specializationKindFor(static_cast&lt;Kind&gt;(kind)); }
209 
210     JSFunction* calleeConstant() const;
211 
212     // Get the callee given a machine call frame to which this InlineCallFrame belongs.
<span class="line-modified">213     JSFunction* calleeForCallFrame(CallFrame*) const;</span>
214 
215     CString inferredName() const;
216     CodeBlockHash hash() const;
217     CString hashAsStringIfPossible() const;
218 
219     void setStackOffset(signed offset)
220     {
221         stackOffset = offset;
222         RELEASE_ASSERT(static_cast&lt;signed&gt;(stackOffset) == offset);
223     }
224 
<span class="line-added">225     void setTmpOffset(unsigned offset)</span>
<span class="line-added">226     {</span>
<span class="line-added">227         tmpOffset = offset;</span>
<span class="line-added">228         RELEASE_ASSERT(static_cast&lt;unsigned&gt;(tmpOffset) == offset);</span>
<span class="line-added">229     }</span>
<span class="line-added">230 </span>
231     ptrdiff_t callerFrameOffset() const { return stackOffset * sizeof(Register) + CallFrame::callerFrameOffset(); }
232     ptrdiff_t returnPCOffset() const { return stackOffset * sizeof(Register) + CallFrame::returnPCOffset(); }
233 
234     bool isStrictMode() const { return baselineCodeBlock-&gt;isStrictMode(); }
235 
236     void dumpBriefFunctionInformation(PrintStream&amp;) const;
237     void dump(PrintStream&amp;) const;
238     void dumpInContext(PrintStream&amp;, DumpContext*) const;
239 
240     MAKE_PRINT_METHOD(InlineCallFrame, dumpBriefFunctionInformation, briefFunctionInformation);
241 
242 };
243 
244 inline CodeBlock* baselineCodeBlockForInlineCallFrame(InlineCallFrame* inlineCallFrame)
245 {
246     RELEASE_ASSERT(inlineCallFrame);
247     return inlineCallFrame-&gt;baselineCodeBlock.get();
248 }
249 
250 inline CodeBlock* baselineCodeBlockForOriginAndBaselineCodeBlock(const CodeOrigin&amp; codeOrigin, CodeBlock* baselineCodeBlock)
251 {
<span class="line-modified">252     ASSERT(JITCode::isBaselineCode(baselineCodeBlock-&gt;jitType()));</span>
253     auto* inlineCallFrame = codeOrigin.inlineCallFrame();
254     if (inlineCallFrame)
255         return baselineCodeBlockForInlineCallFrame(inlineCallFrame);
256     return baselineCodeBlock;
257 }
258 
<span class="line-modified">259 // These function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame</span>
260 template &lt;typename Function&gt;
<span class="line-modified">261 inline void CodeOrigin::walkUpInlineStack(const Function&amp; function) const</span>
262 {
263     CodeOrigin codeOrigin = *this;
264     while (true) {
265         function(codeOrigin);
266         auto* inlineCallFrame = codeOrigin.inlineCallFrame();
267         if (!inlineCallFrame)
268             break;
269         codeOrigin = inlineCallFrame-&gt;directCaller;
270     }
271 }
272 
<span class="line-modified">273 inline bool CodeOrigin::inlineStackContainsActiveCheckpoint() const</span>
<span class="line-added">274 {</span>
<span class="line-added">275     bool result = false;</span>
<span class="line-added">276     walkUpInlineStack([&amp;] (CodeOrigin origin) {</span>
<span class="line-added">277         if (origin.bytecodeIndex().checkpoint())</span>
<span class="line-added">278             result = true;</span>
<span class="line-added">279     });</span>
<span class="line-added">280     return result;</span>
<span class="line-added">281 }</span>
<span class="line-added">282 </span>
<span class="line-added">283 ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, Operand operand)</span>
<span class="line-added">284 {</span>
<span class="line-added">285     if (inlineCallFrame)</span>
<span class="line-added">286         return operand.isTmp() ? Operand::tmp(operand.value() + inlineCallFrame-&gt;tmpOffset) : operand.virtualRegister() + inlineCallFrame-&gt;stackOffset;</span>
<span class="line-added">287     return operand;</span>
<span class="line-added">288 }</span>
<span class="line-added">289 </span>
<span class="line-added">290 ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>
<span class="line-added">291 {</span>
<span class="line-added">292     return remapOperand(inlineCallFrame, Operand(reg));</span>
<span class="line-added">293 }</span>
<span class="line-added">294 </span>
<span class="line-added">295 ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, Operand operand)</span>
296 {
297     if (inlineCallFrame)
<span class="line-modified">298         return operand.isTmp() ? Operand::tmp(operand.value() - inlineCallFrame-&gt;tmpOffset) : Operand(operand.virtualRegister() - inlineCallFrame-&gt;stackOffset);</span>
<span class="line-modified">299     return operand;</span>
<span class="line-added">300 }</span>
<span class="line-added">301 </span>
<span class="line-added">302 ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>
<span class="line-added">303 {</span>
<span class="line-added">304     return unmapOperand(inlineCallFrame, Operand(reg));</span>
305 }
306 
307 } // namespace JSC
308 
309 namespace WTF {
310 
311 void printInternal(PrintStream&amp;, JSC::InlineCallFrame::Kind);
312 
313 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="InlineCallFrame.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceOfAccessCase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
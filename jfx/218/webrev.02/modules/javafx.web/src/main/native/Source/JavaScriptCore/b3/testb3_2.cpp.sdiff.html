<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_2.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="testb3_1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_3.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/testb3_2.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2548 }
2549 
2550 static void testBitAndNotNot(int64_t a, int64_t b)
2551 {
2552     Procedure proc;
2553     BasicBlock* root = proc.addBlock();
2554     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
2555     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
2556     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2557     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2558     root-&gt;appendNewControlValue(
2559         proc, Return, Origin(),
2560         root-&gt;appendNew&lt;Value&gt;(
2561             proc, BitAnd, Origin(),
2562             notA,
2563             notB));
2564 
2565     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a &amp; ~b));
2566 }
2567 


















2568 static void testBitAndNotImm(int64_t a, int64_t b)
2569 {
2570     Procedure proc;
2571     BasicBlock* root = proc.addBlock();
2572     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
2573     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2574     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
2575     root-&gt;appendNewControlValue(
2576         proc, Return, Origin(),
2577         root-&gt;appendNew&lt;Value&gt;(
2578             proc, BitAnd, Origin(),
2579             notA,
2580             cstB));
2581 
<span class="line-modified">2582     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a &amp; b));</span>

















2583 }
2584 
2585 static void testBitAndImms(int64_t a, int64_t b)
2586 {
2587     Procedure proc;
2588     BasicBlock* root = proc.addBlock();
2589     root-&gt;appendNewControlValue(
2590         proc, Return, Origin(),
2591         root-&gt;appendNew&lt;Value&gt;(
2592             proc, BitAnd, Origin(),
2593             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
2594             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
2595 
2596     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a &amp; b));
2597 }
2598 
2599 static void testBitAndArgImm(int64_t a, int64_t b)
2600 {
2601     Procedure proc;
2602     BasicBlock* root = proc.addBlock();
</pre>
<hr />
<pre>
2977         Procedure proc;
2978         BasicBlock* root = proc.addBlock();
2979         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
2980         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
2981         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
2982         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
2983             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
2984         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
2985             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
2986         root-&gt;appendNewControlValue(
2987             proc, Return, Origin(),
2988             root-&gt;appendNew&lt;Value&gt;(
2989                 proc, BitOr, Origin(),
2990                 andAB,
2991                 andAC));
2992 
2993         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) | (a &amp; c)));
2994     }
2995 }
2996 




























2997 static void testBitOrAndSameArgs(int64_t a, int64_t b)
2998 {
2999     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
3000     // ((a &amp; b) | a)
3001     // ((b &amp; a) | a)
3002     // (a | (a &amp; b))
3003     // (a | (b &amp; a))
3004     for (int i = 0; i &lt; 4; ++i) {
3005         Procedure proc;
3006         BasicBlock* root = proc.addBlock();
3007         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3008         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
3009         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
3010             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
3011         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), andAB, argA)
3012             : root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argA, andAB);
3013         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
3014 
3015         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) | a));
3016     }
3017 }
3018 






















3019 static void testBitOrNotNot(int64_t a, int64_t b)
3020 {
3021     Procedure proc;
3022     BasicBlock* root = proc.addBlock();
3023     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3024     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
3025     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3026     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3027     root-&gt;appendNewControlValue(
3028         proc, Return, Origin(),
3029         root-&gt;appendNew&lt;Value&gt;(
3030             proc, BitOr, Origin(),
3031             notA,
3032             notB));
3033 
3034     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | ~b));
3035 }
3036 


















3037 static void testBitOrNotImm(int64_t a, int64_t b)
3038 {
3039     Procedure proc;
3040     BasicBlock* root = proc.addBlock();
3041     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3042     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3043     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
3044     root-&gt;appendNewControlValue(
3045         proc, Return, Origin(),
3046         root-&gt;appendNew&lt;Value&gt;(
3047             proc, BitOr, Origin(),
3048             notA,
3049             cstB));
3050 
3051     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | b));
3052 }
3053 

















3054 static void testBitOrImms(int64_t a, int64_t b)
3055 {
3056     Procedure proc;
3057     BasicBlock* root = proc.addBlock();
3058     root-&gt;appendNewControlValue(
3059         proc, Return, Origin(),
3060         root-&gt;appendNew&lt;Value&gt;(
3061             proc, BitOr, Origin(),
3062             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
3063             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
3064 
3065     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a | b));
3066 }
3067 
3068 static void testBitOrArgImm(int64_t a, int64_t b)
3069 {
3070     Procedure proc;
3071     BasicBlock* root = proc.addBlock();
3072     root-&gt;appendNewControlValue(
3073         proc, Return, Origin(),
</pre>
<hr />
<pre>
3270     RUN(testBitAndImmArg32(42, 0xffff));
3271     RUN(testBitAndImmArg32(40000, 0xffff));
3272     RUN(testBitAndImmArg32(-40000, 0xffff));
3273     RUN(testBitAndBitAndArgImmImm32(2, 7, 3));
3274     RUN(testBitAndBitAndArgImmImm32(1, 6, 6));
3275     RUN(testBitAndBitAndArgImmImm32(0xffff, 24, 7));
3276     RUN(testBitAndImmBitAndArgImm32(7, 2, 3));
3277     RUN(testBitAndImmBitAndArgImm32(6, 1, 6));
3278     RUN(testBitAndImmBitAndArgImm32(24, 0xffff, 7));
3279     RUN_BINARY(testBitAndWithMaskReturnsBooleans, int64Operands(), int64Operands());
3280     RUN_UNARY(testBitAndArgDouble, floatingPointOperands&lt;double&gt;());
3281     RUN_BINARY(testBitAndArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3282     RUN_BINARY(testBitAndArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3283     RUN_BINARY(testBitAndImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3284     RUN_UNARY(testBitAndArgFloat, floatingPointOperands&lt;float&gt;());
3285     RUN_BINARY(testBitAndArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3286     RUN_BINARY(testBitAndArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3287     RUN_BINARY(testBitAndImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3288     RUN_BINARY(testBitAndArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3289     RUN_BINARY(testBitAndNotNot, int64Operands(), int64Operands());

3290     RUN_BINARY(testBitAndNotImm, int64Operands(), int64Operands());

3291 
3292     RUN(testBitOrArgs(43, 43));
3293     RUN(testBitOrArgs(43, 0));
3294     RUN(testBitOrArgs(10, 3));
3295     RUN(testBitOrArgs(42, 0xffffffffffffffff));
3296     RUN(testBitOrSameArg(43));
3297     RUN(testBitOrSameArg(0));
3298     RUN(testBitOrSameArg(3));
3299     RUN(testBitOrSameArg(0xffffffffffffffff));
3300     RUN(testBitOrImms(43, 43));
3301     RUN(testBitOrImms(43, 0));
3302     RUN(testBitOrImms(10, 3));
3303     RUN(testBitOrImms(42, 0xffffffffffffffff));
3304     RUN(testBitOrArgImm(43, 43));
3305     RUN(testBitOrArgImm(43, 0));
3306     RUN(testBitOrArgImm(10, 3));
3307     RUN(testBitOrArgImm(42, 0xffffffffffffffff));
3308     RUN(testBitOrImmArg(43, 43));
3309     RUN(testBitOrImmArg(43, 0));
3310     RUN(testBitOrImmArg(10, 3));
</pre>
<hr />
<pre>
3334     RUN(testBitOrImmArg32(43, 43));
3335     RUN(testBitOrImmArg32(43, 0));
3336     RUN(testBitOrImmArg32(10, 3));
3337     RUN(testBitOrImmArg32(42, 0xffffffff));
3338     RUN(testBitOrBitOrArgImmImm32(2, 7, 3));
3339     RUN(testBitOrBitOrArgImmImm32(1, 6, 6));
3340     RUN(testBitOrBitOrArgImmImm32(0xffff, 24, 7));
3341     RUN(testBitOrImmBitOrArgImm32(7, 2, 3));
3342     RUN(testBitOrImmBitOrArgImm32(6, 1, 6));
3343     RUN(testBitOrImmBitOrArgImm32(24, 0xffff, 7));
3344     RUN_UNARY(testBitOrArgDouble, floatingPointOperands&lt;double&gt;());
3345     RUN_BINARY(testBitOrArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3346     RUN_BINARY(testBitOrArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3347     RUN_BINARY(testBitOrImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3348     RUN_UNARY(testBitOrArgFloat, floatingPointOperands&lt;float&gt;());
3349     RUN_BINARY(testBitOrArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3350     RUN_BINARY(testBitOrArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3351     RUN_BINARY(testBitOrImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3352     RUN_BINARY(testBitOrArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3353     RUN_TERNARY(testBitOrAndAndArgs, int64Operands(), int64Operands(), int64Operands());

3354     RUN_BINARY(testBitOrAndSameArgs, int64Operands(), int64Operands());

3355     RUN_BINARY(testBitOrNotNot, int64Operands(), int64Operands());

3356     RUN_BINARY(testBitOrNotImm, int64Operands(), int64Operands());

3357 
3358     RUN_BINARY(testBitXorArgs, int64Operands(), int64Operands());
3359     RUN_UNARY(testBitXorSameArg, int64Operands());
3360     RUN_BINARY(testBitXorImms, int64Operands(), int64Operands());
3361     RUN_BINARY(testBitXorArgImm, int64Operands(), int64Operands());
3362     RUN_BINARY(testBitXorImmArg, int64Operands(), int64Operands());
3363     RUN(testBitXorBitXorArgImmImm(2, 7, 3));
3364     RUN(testBitXorBitXorArgImmImm(1, 6, 6));
3365     RUN(testBitXorBitXorArgImmImm(0xffff, 24, 7));
3366     RUN(testBitXorImmBitXorArgImm(7, 2, 3));
3367     RUN(testBitXorImmBitXorArgImm(6, 1, 6));
3368     RUN(testBitXorImmBitXorArgImm(24, 0xffff, 7));
3369     RUN(testBitXorArgs32(43, 43));
3370     RUN(testBitXorArgs32(43, 0));
3371     RUN(testBitXorArgs32(10, 3));
3372     RUN(testBitXorArgs32(42, 0xffffffff));
3373     RUN(testBitXorSameArg32(43));
3374     RUN(testBitXorSameArg32(0));
3375     RUN(testBitXorSameArg32(3));
3376     RUN(testBitXorSameArg32(0xffffffff));
3377     RUN(testBitXorImms32(43, 43));
3378     RUN(testBitXorImms32(43, 0));
3379     RUN(testBitXorImms32(10, 3));
3380     RUN(testBitXorImms32(42, 0xffffffff));
3381     RUN(testBitXorArgImm32(43, 43));
3382     RUN(testBitXorArgImm32(43, 0));
3383     RUN(testBitXorArgImm32(10, 3));
3384     RUN(testBitXorArgImm32(42, 0xffffffff));
3385     RUN(testBitXorImmArg32(43, 43));
3386     RUN(testBitXorImmArg32(43, 0));
3387     RUN(testBitXorImmArg32(10, 3));
3388     RUN(testBitXorImmArg32(42, 0xffffffff));
3389     RUN(testBitXorBitXorArgImmImm32(2, 7, 3));
3390     RUN(testBitXorBitXorArgImmImm32(1, 6, 6));
3391     RUN(testBitXorBitXorArgImmImm32(0xffff, 24, 7));
3392     RUN(testBitXorImmBitXorArgImm32(7, 2, 3));
3393     RUN(testBitXorImmBitXorArgImm32(6, 1, 6));
3394     RUN(testBitXorImmBitXorArgImm32(24, 0xffff, 7));
3395     RUN_TERNARY(testBitXorAndAndArgs, int64Operands(), int64Operands(), int64Operands());

3396     RUN_BINARY(testBitXorAndSameArgs, int64Operands(), int64Operands());

3397 
3398     RUN_UNARY(testBitNotArg, int64Operands());
3399     RUN_UNARY(testBitNotImm, int64Operands());
3400     RUN_UNARY(testBitNotMem, int64Operands());
3401     RUN_UNARY(testBitNotArg32, int32Operands());
3402     RUN_UNARY(testBitNotImm32, int32Operands());
3403     RUN_UNARY(testBitNotMem32, int32Operands());
3404     RUN_BINARY(testNotOnBooleanAndBranch32, int32Operands(), int32Operands());
3405     RUN_BINARY(testBitNotOnBooleanAndBranch32, int32Operands(), int32Operands());
3406 
3407     RUN_BINARY(testBitXorTreeArgs, int64Operands(), int64Operands());
3408     RUN_BINARY(testBitXorTreeArgsEven, int64Operands(), int64Operands());
3409     RUN_BINARY(testBitXorTreeArgImm, int64Operands(), int64Operands());
3410     RUN_UNARY(testBitAndTreeArg32, int32Operands());
3411     RUN_UNARY(testBitOrTreeArg32, int32Operands());
3412 }
3413 
3414 #endif // ENABLE(B3_JIT)
</pre>
</td>
<td>
<hr />
<pre>
2548 }
2549 
2550 static void testBitAndNotNot(int64_t a, int64_t b)
2551 {
2552     Procedure proc;
2553     BasicBlock* root = proc.addBlock();
2554     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
2555     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
2556     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2557     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2558     root-&gt;appendNewControlValue(
2559         proc, Return, Origin(),
2560         root-&gt;appendNew&lt;Value&gt;(
2561             proc, BitAnd, Origin(),
2562             notA,
2563             notB));
2564 
2565     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a &amp; ~b));
2566 }
2567 
<span class="line-added">2568 static void testBitAndNotNot32(int32_t a, int32_t b)</span>
<span class="line-added">2569 {</span>
<span class="line-added">2570     Procedure proc;</span>
<span class="line-added">2571     BasicBlock* root = proc.addBlock();</span>
<span class="line-added">2572     Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">2573     Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added">2574     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">2575     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">2576     root-&gt;appendNewControlValue(</span>
<span class="line-added">2577         proc, Return, Origin(),</span>
<span class="line-added">2578         root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added">2579             proc, BitAnd, Origin(),</span>
<span class="line-added">2580             notA,</span>
<span class="line-added">2581             notB));</span>
<span class="line-added">2582 </span>
<span class="line-added">2583     CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b), (~a &amp; ~b));</span>
<span class="line-added">2584 }</span>
<span class="line-added">2585 </span>
2586 static void testBitAndNotImm(int64_t a, int64_t b)
2587 {
2588     Procedure proc;
2589     BasicBlock* root = proc.addBlock();
2590     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
2591     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
2592     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
2593     root-&gt;appendNewControlValue(
2594         proc, Return, Origin(),
2595         root-&gt;appendNew&lt;Value&gt;(
2596             proc, BitAnd, Origin(),
2597             notA,
2598             cstB));
2599 
<span class="line-modified">2600     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a), (~a &amp; b));</span>
<span class="line-added">2601 }</span>
<span class="line-added">2602 </span>
<span class="line-added">2603 static void testBitAndNotImm32(int32_t a, int32_t b)</span>
<span class="line-added">2604 {</span>
<span class="line-added">2605     Procedure proc;</span>
<span class="line-added">2606     BasicBlock* root = proc.addBlock();</span>
<span class="line-added">2607     Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">2608     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">2609     Value* cstB = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);</span>
<span class="line-added">2610     root-&gt;appendNewControlValue(</span>
<span class="line-added">2611         proc, Return, Origin(),</span>
<span class="line-added">2612         root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added">2613             proc, BitAnd, Origin(),</span>
<span class="line-added">2614             notA,</span>
<span class="line-added">2615             cstB));</span>
<span class="line-added">2616 </span>
<span class="line-added">2617     CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a), (~a &amp; b));</span>
2618 }
2619 
2620 static void testBitAndImms(int64_t a, int64_t b)
2621 {
2622     Procedure proc;
2623     BasicBlock* root = proc.addBlock();
2624     root-&gt;appendNewControlValue(
2625         proc, Return, Origin(),
2626         root-&gt;appendNew&lt;Value&gt;(
2627             proc, BitAnd, Origin(),
2628             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
2629             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
2630 
2631     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a &amp; b));
2632 }
2633 
2634 static void testBitAndArgImm(int64_t a, int64_t b)
2635 {
2636     Procedure proc;
2637     BasicBlock* root = proc.addBlock();
</pre>
<hr />
<pre>
3012         Procedure proc;
3013         BasicBlock* root = proc.addBlock();
3014         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3015         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
3016         Value* argC = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2);
3017         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
3018             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
3019         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)
3020             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);
3021         root-&gt;appendNewControlValue(
3022             proc, Return, Origin(),
3023             root-&gt;appendNew&lt;Value&gt;(
3024                 proc, BitOr, Origin(),
3025                 andAB,
3026                 andAC));
3027 
3028         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b, c), ((a &amp; b) | (a &amp; c)));
3029     }
3030 }
3031 
<span class="line-added">3032 static void testBitOrAndAndArgs32(int32_t a, int32_t b, int32_t c)</span>
<span class="line-added">3033 {</span>
<span class="line-added">3034     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):</span>
<span class="line-added">3035     // ((a &amp; b) | (a &amp; c))</span>
<span class="line-added">3036     // ((a &amp; b) | (c &amp; a))</span>
<span class="line-added">3037     // ((b &amp; a) | (a &amp; c))</span>
<span class="line-added">3038     // ((b &amp; a) | (c &amp; a))</span>
<span class="line-added">3039     for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-added">3040         Procedure proc;</span>
<span class="line-added">3041         BasicBlock* root = proc.addBlock();</span>
<span class="line-added">3042         Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">3043         Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added">3044         Value* argC = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR2));</span>
<span class="line-added">3045         Value* andAB = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)</span>
<span class="line-added">3046             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);</span>
<span class="line-added">3047         Value* andAC = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argC)</span>
<span class="line-added">3048             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argC, argA);</span>
<span class="line-added">3049         root-&gt;appendNewControlValue(</span>
<span class="line-added">3050             proc, Return, Origin(),</span>
<span class="line-added">3051             root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added">3052                 proc, BitOr, Origin(),</span>
<span class="line-added">3053                 andAB,</span>
<span class="line-added">3054                 andAC));</span>
<span class="line-added">3055 </span>
<span class="line-added">3056         CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b, c), ((a &amp; b) | (a &amp; c)));</span>
<span class="line-added">3057     }</span>
<span class="line-added">3058 }</span>
<span class="line-added">3059 </span>
3060 static void testBitOrAndSameArgs(int64_t a, int64_t b)
3061 {
3062     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):
3063     // ((a &amp; b) | a)
3064     // ((b &amp; a) | a)
3065     // (a | (a &amp; b))
3066     // (a | (b &amp; a))
3067     for (int i = 0; i &lt; 4; ++i) {
3068         Procedure proc;
3069         BasicBlock* root = proc.addBlock();
3070         Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3071         Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
3072         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)
3073             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);
3074         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), andAB, argA)
3075             : root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argA, andAB);
3076         root-&gt;appendNewControlValue(proc, Return, Origin(), result);
3077 
3078         CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), ((a &amp; b) | a));
3079     }
3080 }
3081 
<span class="line-added">3082 static void testBitOrAndSameArgs32(int32_t a, int32_t b)</span>
<span class="line-added">3083 {</span>
<span class="line-added">3084     // We want to check every possible ordering of arguments (to properly check every path in B3ReduceStrength):</span>
<span class="line-added">3085     // ((a &amp; b) | a)</span>
<span class="line-added">3086     // ((b &amp; a) | a)</span>
<span class="line-added">3087     // (a | (a &amp; b))</span>
<span class="line-added">3088     // (a | (b &amp; a))</span>
<span class="line-added">3089     for (int i = 0; i &lt; 4; ++i) {</span>
<span class="line-added">3090         Procedure proc;</span>
<span class="line-added">3091         BasicBlock* root = proc.addBlock();</span>
<span class="line-added">3092         Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">3093         Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added">3094         Value* andAB = i &amp; 1 ? root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argA, argB)</span>
<span class="line-added">3095             : root-&gt;appendNew&lt;Value&gt;(proc, BitAnd, Origin(), argB, argA);</span>
<span class="line-added">3096         Value* result = i &amp; 2 ? root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), andAB, argA)</span>
<span class="line-added">3097             : root-&gt;appendNew&lt;Value&gt;(proc, BitOr, Origin(), argA, andAB);</span>
<span class="line-added">3098         root-&gt;appendNewControlValue(proc, Return, Origin(), result);</span>
<span class="line-added">3099 </span>
<span class="line-added">3100         CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b), ((a &amp; b) | a));</span>
<span class="line-added">3101     }</span>
<span class="line-added">3102 }</span>
<span class="line-added">3103 </span>
3104 static void testBitOrNotNot(int64_t a, int64_t b)
3105 {
3106     Procedure proc;
3107     BasicBlock* root = proc.addBlock();
3108     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3109     Value* argB = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1);
3110     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3111     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3112     root-&gt;appendNewControlValue(
3113         proc, Return, Origin(),
3114         root-&gt;appendNew&lt;Value&gt;(
3115             proc, BitOr, Origin(),
3116             notA,
3117             notB));
3118 
3119     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | ~b));
3120 }
3121 
<span class="line-added">3122 static void testBitOrNotNot32(int32_t a, int32_t b)</span>
<span class="line-added">3123 {</span>
<span class="line-added">3124     Procedure proc;</span>
<span class="line-added">3125     BasicBlock* root = proc.addBlock();</span>
<span class="line-added">3126     Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">3127     Value* argB = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR1));</span>
<span class="line-added">3128     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">3129     Value* notB = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argB, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">3130     root-&gt;appendNewControlValue(</span>
<span class="line-added">3131         proc, Return, Origin(),</span>
<span class="line-added">3132         root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added">3133             proc, BitOr, Origin(),</span>
<span class="line-added">3134             notA,</span>
<span class="line-added">3135             notB));</span>
<span class="line-added">3136 </span>
<span class="line-added">3137     CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a, b), (~a | ~b));</span>
<span class="line-added">3138 }</span>
<span class="line-added">3139 </span>
3140 static void testBitOrNotImm(int64_t a, int64_t b)
3141 {
3142     Procedure proc;
3143     BasicBlock* root = proc.addBlock();
3144     Value* argA = root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0);
3145     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), -1));
3146     Value* cstB = root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b);
3147     root-&gt;appendNewControlValue(
3148         proc, Return, Origin(),
3149         root-&gt;appendNew&lt;Value&gt;(
3150             proc, BitOr, Origin(),
3151             notA,
3152             cstB));
3153 
3154     CHECK_EQ(compileAndRun&lt;int64_t&gt;(proc, a, b), (~a | b));
3155 }
3156 
<span class="line-added">3157 static void testBitOrNotImm32(int32_t a, int32_t b)</span>
<span class="line-added">3158 {</span>
<span class="line-added">3159     Procedure proc;</span>
<span class="line-added">3160     BasicBlock* root = proc.addBlock();</span>
<span class="line-added">3161     Value* argA = root-&gt;appendNew&lt;Value&gt;(proc, Trunc, Origin(), root-&gt;appendNew&lt;ArgumentRegValue&gt;(proc, Origin(), GPRInfo::argumentGPR0));</span>
<span class="line-added">3162     Value* notA = root-&gt;appendNew&lt;Value&gt;(proc, BitXor, Origin(), argA, root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), -1));</span>
<span class="line-added">3163     Value* cstB = root-&gt;appendNew&lt;Const32Value&gt;(proc, Origin(), b);</span>
<span class="line-added">3164     root-&gt;appendNewControlValue(</span>
<span class="line-added">3165         proc, Return, Origin(),</span>
<span class="line-added">3166         root-&gt;appendNew&lt;Value&gt;(</span>
<span class="line-added">3167             proc, BitOr, Origin(),</span>
<span class="line-added">3168             notA,</span>
<span class="line-added">3169             cstB));</span>
<span class="line-added">3170 </span>
<span class="line-added">3171     CHECK_EQ(compileAndRun&lt;int32_t&gt;(proc, a), (~a | b));</span>
<span class="line-added">3172 }</span>
<span class="line-added">3173 </span>
3174 static void testBitOrImms(int64_t a, int64_t b)
3175 {
3176     Procedure proc;
3177     BasicBlock* root = proc.addBlock();
3178     root-&gt;appendNewControlValue(
3179         proc, Return, Origin(),
3180         root-&gt;appendNew&lt;Value&gt;(
3181             proc, BitOr, Origin(),
3182             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), a),
3183             root-&gt;appendNew&lt;Const64Value&gt;(proc, Origin(), b)));
3184 
3185     CHECK(compileAndRun&lt;int64_t&gt;(proc) == (a | b));
3186 }
3187 
3188 static void testBitOrArgImm(int64_t a, int64_t b)
3189 {
3190     Procedure proc;
3191     BasicBlock* root = proc.addBlock();
3192     root-&gt;appendNewControlValue(
3193         proc, Return, Origin(),
</pre>
<hr />
<pre>
3390     RUN(testBitAndImmArg32(42, 0xffff));
3391     RUN(testBitAndImmArg32(40000, 0xffff));
3392     RUN(testBitAndImmArg32(-40000, 0xffff));
3393     RUN(testBitAndBitAndArgImmImm32(2, 7, 3));
3394     RUN(testBitAndBitAndArgImmImm32(1, 6, 6));
3395     RUN(testBitAndBitAndArgImmImm32(0xffff, 24, 7));
3396     RUN(testBitAndImmBitAndArgImm32(7, 2, 3));
3397     RUN(testBitAndImmBitAndArgImm32(6, 1, 6));
3398     RUN(testBitAndImmBitAndArgImm32(24, 0xffff, 7));
3399     RUN_BINARY(testBitAndWithMaskReturnsBooleans, int64Operands(), int64Operands());
3400     RUN_UNARY(testBitAndArgDouble, floatingPointOperands&lt;double&gt;());
3401     RUN_BINARY(testBitAndArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3402     RUN_BINARY(testBitAndArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3403     RUN_BINARY(testBitAndImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3404     RUN_UNARY(testBitAndArgFloat, floatingPointOperands&lt;float&gt;());
3405     RUN_BINARY(testBitAndArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3406     RUN_BINARY(testBitAndArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3407     RUN_BINARY(testBitAndImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3408     RUN_BINARY(testBitAndArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3409     RUN_BINARY(testBitAndNotNot, int64Operands(), int64Operands());
<span class="line-added">3410     RUN_BINARY(testBitAndNotNot32, int32Operands(), int32Operands());</span>
3411     RUN_BINARY(testBitAndNotImm, int64Operands(), int64Operands());
<span class="line-added">3412     RUN_BINARY(testBitAndNotImm32, int32Operands(), int32Operands());</span>
3413 
3414     RUN(testBitOrArgs(43, 43));
3415     RUN(testBitOrArgs(43, 0));
3416     RUN(testBitOrArgs(10, 3));
3417     RUN(testBitOrArgs(42, 0xffffffffffffffff));
3418     RUN(testBitOrSameArg(43));
3419     RUN(testBitOrSameArg(0));
3420     RUN(testBitOrSameArg(3));
3421     RUN(testBitOrSameArg(0xffffffffffffffff));
3422     RUN(testBitOrImms(43, 43));
3423     RUN(testBitOrImms(43, 0));
3424     RUN(testBitOrImms(10, 3));
3425     RUN(testBitOrImms(42, 0xffffffffffffffff));
3426     RUN(testBitOrArgImm(43, 43));
3427     RUN(testBitOrArgImm(43, 0));
3428     RUN(testBitOrArgImm(10, 3));
3429     RUN(testBitOrArgImm(42, 0xffffffffffffffff));
3430     RUN(testBitOrImmArg(43, 43));
3431     RUN(testBitOrImmArg(43, 0));
3432     RUN(testBitOrImmArg(10, 3));
</pre>
<hr />
<pre>
3456     RUN(testBitOrImmArg32(43, 43));
3457     RUN(testBitOrImmArg32(43, 0));
3458     RUN(testBitOrImmArg32(10, 3));
3459     RUN(testBitOrImmArg32(42, 0xffffffff));
3460     RUN(testBitOrBitOrArgImmImm32(2, 7, 3));
3461     RUN(testBitOrBitOrArgImmImm32(1, 6, 6));
3462     RUN(testBitOrBitOrArgImmImm32(0xffff, 24, 7));
3463     RUN(testBitOrImmBitOrArgImm32(7, 2, 3));
3464     RUN(testBitOrImmBitOrArgImm32(6, 1, 6));
3465     RUN(testBitOrImmBitOrArgImm32(24, 0xffff, 7));
3466     RUN_UNARY(testBitOrArgDouble, floatingPointOperands&lt;double&gt;());
3467     RUN_BINARY(testBitOrArgsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3468     RUN_BINARY(testBitOrArgImmDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3469     RUN_BINARY(testBitOrImmsDouble, floatingPointOperands&lt;double&gt;(), floatingPointOperands&lt;double&gt;());
3470     RUN_UNARY(testBitOrArgFloat, floatingPointOperands&lt;float&gt;());
3471     RUN_BINARY(testBitOrArgsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3472     RUN_BINARY(testBitOrArgImmFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3473     RUN_BINARY(testBitOrImmsFloat, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3474     RUN_BINARY(testBitOrArgsFloatWithUselessDoubleConversion, floatingPointOperands&lt;float&gt;(), floatingPointOperands&lt;float&gt;());
3475     RUN_TERNARY(testBitOrAndAndArgs, int64Operands(), int64Operands(), int64Operands());
<span class="line-added">3476     RUN_TERNARY(testBitOrAndAndArgs32, int32Operands(), int32Operands(), int32Operands());</span>
3477     RUN_BINARY(testBitOrAndSameArgs, int64Operands(), int64Operands());
<span class="line-added">3478     RUN_BINARY(testBitOrAndSameArgs32, int32Operands(), int32Operands());</span>
3479     RUN_BINARY(testBitOrNotNot, int64Operands(), int64Operands());
<span class="line-added">3480     RUN_BINARY(testBitOrNotNot32, int32Operands(), int32Operands());</span>
3481     RUN_BINARY(testBitOrNotImm, int64Operands(), int64Operands());
<span class="line-added">3482     RUN_BINARY(testBitOrNotImm32, int32Operands(), int32Operands());</span>
3483 
3484     RUN_BINARY(testBitXorArgs, int64Operands(), int64Operands());
3485     RUN_UNARY(testBitXorSameArg, int64Operands());
3486     RUN_BINARY(testBitXorImms, int64Operands(), int64Operands());
3487     RUN_BINARY(testBitXorArgImm, int64Operands(), int64Operands());
3488     RUN_BINARY(testBitXorImmArg, int64Operands(), int64Operands());
3489     RUN(testBitXorBitXorArgImmImm(2, 7, 3));
3490     RUN(testBitXorBitXorArgImmImm(1, 6, 6));
3491     RUN(testBitXorBitXorArgImmImm(0xffff, 24, 7));
3492     RUN(testBitXorImmBitXorArgImm(7, 2, 3));
3493     RUN(testBitXorImmBitXorArgImm(6, 1, 6));
3494     RUN(testBitXorImmBitXorArgImm(24, 0xffff, 7));
3495     RUN(testBitXorArgs32(43, 43));
3496     RUN(testBitXorArgs32(43, 0));
3497     RUN(testBitXorArgs32(10, 3));
3498     RUN(testBitXorArgs32(42, 0xffffffff));
3499     RUN(testBitXorSameArg32(43));
3500     RUN(testBitXorSameArg32(0));
3501     RUN(testBitXorSameArg32(3));
3502     RUN(testBitXorSameArg32(0xffffffff));
3503     RUN(testBitXorImms32(43, 43));
3504     RUN(testBitXorImms32(43, 0));
3505     RUN(testBitXorImms32(10, 3));
3506     RUN(testBitXorImms32(42, 0xffffffff));
3507     RUN(testBitXorArgImm32(43, 43));
3508     RUN(testBitXorArgImm32(43, 0));
3509     RUN(testBitXorArgImm32(10, 3));
3510     RUN(testBitXorArgImm32(42, 0xffffffff));
3511     RUN(testBitXorImmArg32(43, 43));
3512     RUN(testBitXorImmArg32(43, 0));
3513     RUN(testBitXorImmArg32(10, 3));
3514     RUN(testBitXorImmArg32(42, 0xffffffff));
3515     RUN(testBitXorBitXorArgImmImm32(2, 7, 3));
3516     RUN(testBitXorBitXorArgImmImm32(1, 6, 6));
3517     RUN(testBitXorBitXorArgImmImm32(0xffff, 24, 7));
3518     RUN(testBitXorImmBitXorArgImm32(7, 2, 3));
3519     RUN(testBitXorImmBitXorArgImm32(6, 1, 6));
3520     RUN(testBitXorImmBitXorArgImm32(24, 0xffff, 7));
3521     RUN_TERNARY(testBitXorAndAndArgs, int64Operands(), int64Operands(), int64Operands());
<span class="line-added">3522     RUN_TERNARY(testBitXorAndAndArgs32, int32Operands(), int32Operands(), int32Operands());</span>
3523     RUN_BINARY(testBitXorAndSameArgs, int64Operands(), int64Operands());
<span class="line-added">3524     RUN_BINARY(testBitXorAndSameArgs32, int32Operands(), int32Operands());</span>
3525 
3526     RUN_UNARY(testBitNotArg, int64Operands());
3527     RUN_UNARY(testBitNotImm, int64Operands());
3528     RUN_UNARY(testBitNotMem, int64Operands());
3529     RUN_UNARY(testBitNotArg32, int32Operands());
3530     RUN_UNARY(testBitNotImm32, int32Operands());
3531     RUN_UNARY(testBitNotMem32, int32Operands());
3532     RUN_BINARY(testNotOnBooleanAndBranch32, int32Operands(), int32Operands());
3533     RUN_BINARY(testBitNotOnBooleanAndBranch32, int32Operands(), int32Operands());
3534 
3535     RUN_BINARY(testBitXorTreeArgs, int64Operands(), int64Operands());
3536     RUN_BINARY(testBitXorTreeArgsEven, int64Operands(), int64Operands());
3537     RUN_BINARY(testBitXorTreeArgImm, int64Operands(), int64Operands());
3538     RUN_UNARY(testBitAndTreeArg32, int32Operands());
3539     RUN_UNARY(testBitOrTreeArg32, int32Operands());
3540 }
3541 
3542 #endif // ENABLE(B3_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="testb3_1.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="testb3_3.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
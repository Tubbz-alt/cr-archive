<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../offlineasm/x86.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Keywords.table.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ASTBuilder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 105     typedef TemplateStringNode* TemplateString;
 106     typedef TemplateStringListNode* TemplateStringList;
 107     typedef TemplateLiteralNode* TemplateLiteral;
 108     typedef FunctionParameters* FormalParameterList;
 109     typedef FunctionMetadataNode* FunctionBody;
 110     typedef ClassExprNode* ClassExpression;
 111     typedef ModuleNameNode* ModuleName;
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
<span class="line-modified"> 125     static const bool CreatesAST = true;</span>
<span class="line-modified"> 126     static const bool NeedsFreeVariableInfo = true;</span>
<span class="line-modified"> 127     static const bool CanUseFunctionCache = true;</span>
<span class="line-modified"> 128     static const int  DontBuildKeywords = 0;</span>
<span class="line-modified"> 129     static const int  DontBuildStrings = 0;</span>
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
</pre>
<hr />
<pre>
 183     {
 184         auto* node = new (m_parserArena) ImportNode(location, expr);
 185         setExceptionLocation(node, start, divot, end);
 186         return node;
 187     }
 188     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 189     {
 190         usesNewTarget();
 191         return new (m_parserArena) NewTargetNode(location);
 192     }
 193     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 194     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 195     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 196     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 197     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 198     {
 199         if (m_vm.propertyNames-&gt;arguments == ident)
 200             usesArguments();
 201 
 202         if (ident.isSymbol()) {
<span class="line-modified"> 203             if (BytecodeIntrinsicNode::EmitterType emitter = m_vm.bytecodeIntrinsicRegistry().lookup(ident))</span>
<span class="line-modified"> 204                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, emitter, ident, nullptr, start, start, end);</span>

 205         }
 206 
 207         return new (m_parserArena) ResolveNode(location, ident, start);
 208     }
 209     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 210     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 211 
 212     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 213     {
 214         if (elisions)
 215             incConstants();
 216         return new (m_parserArena) ArrayNode(location, elisions);
 217     }
 218 
 219     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 220     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 221     {
 222         if (elisions)
 223             incConstants();
 224         return new (m_parserArena) ArrayNode(location, elisions, elems);
</pre>
<hr />
<pre>
 387     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 388     {
 389         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 390     }
 391 
 392     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 393     {
 394         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 395         setExceptionLocation(node, start, divot, end);
 396         return node;
 397     }
 398 
 399     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 400     {
 401         ASSERT(argument);
 402         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
 403         setExceptionLocation(node, start, divot, end);
 404         return node;
 405     }
 406 





 407     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 408         ExpressionNode* parentClass, PropertyListNode* classElements)
 409     {
 410         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 411         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 412     }
 413 
 414     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 415     {
 416         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 417             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 418         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 419         return result;
 420     }
 421 
 422     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 423     {
 424         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 425         if (!name.isNull())
 426             result-&gt;metadata()-&gt;setEcmaName(name);
</pre>
<hr />
<pre>
 509     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 510     {
 511         if (inferName == InferName::Allowed) {
 512             if (node-&gt;isBaseFuncExprNode()) {
 513                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 514                 metadata-&gt;setEcmaName(*propertyName);
 515             } else if (node-&gt;isClassExprNode())
 516                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 517         }
 518         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 519     }
 520     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 521     {
 522         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 523     }
 524     PropertyNode* createProperty(VM&amp; vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 525     {
 526         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 527     }
 528     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }

 529     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 530     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 531 
 532     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 533     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 534     ElementNode* createElementList(ArgumentListNode* elems)
 535     {
 536         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 537         ElementNode* tail = head;
 538         elems = elems-&gt;m_next;
 539         while (elems) {
 540             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 541             elems = elems-&gt;m_next;
 542         }
 543         return head;
 544     }
 545 
 546     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 547     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 548     {
</pre>
<hr />
<pre>
 903         tokenStackDepth++;
 904         m_unaryTokenStack.append(std::make_pair(type, start));
 905     }
 906 
 907     int unaryTokenStackLastType(int&amp;)
 908     {
 909         return m_unaryTokenStack.last().first;
 910     }
 911 
 912     const JSTextPosition&amp; unaryTokenStackLastStart(int&amp;)
 913     {
 914         return m_unaryTokenStack.last().second;
 915     }
 916 
 917     void unaryTokenStackRemoveLast(int&amp; tokenStackDepth)
 918     {
 919         tokenStackDepth--;
 920         m_unaryTokenStack.removeLast();
 921     }
 922 










 923     void assignmentStackAppend(int&amp; assignmentStackDepth, ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int assignmentCount, Operator op)
 924     {
 925         assignmentStackDepth++;
 926         ASSERT(start.offset &gt;= start.lineStartOffset);
 927         ASSERT(divot.offset &gt;= divot.lineStartOffset);
 928         m_assignmentInfoStack.append(AssignmentInfo(node, start, divot, assignmentCount, op));
 929     }
 930 
 931     ExpressionNode* createAssignment(const JSTokenLocation&amp; location, int&amp; assignmentStackDepth, ExpressionNode* rhs, int initialAssignmentCount, int currentAssignmentCount, const JSTextPosition&amp; lastTokenEnd)
 932     {
 933         AssignmentInfo&amp; info = m_assignmentInfoStack.last();
 934         ExpressionNode* result = makeAssignNode(location, info.m_node, info.m_op, rhs, info.m_initAssignments != initialAssignmentCount, info.m_initAssignments != currentAssignmentCount, info.m_start, info.m_divot + 1, lastTokenEnd);
 935         m_assignmentInfoStack.removeLast();
 936         assignmentStackDepth--;
 937         return result;
 938     }
 939 
 940     const Identifier* getName(const Property&amp; property) const { return property-&gt;name(); }
 941     PropertyNode::Type getType(const Property&amp; property) const { return property-&gt;type(); }
 942 
</pre>
<hr />
<pre>
1367     if (expr1-&gt;isOptionalChain()) {
1368         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr1);
1369         if (!optionalChain-&gt;expr()-&gt;isDeleteNode()) {
1370             constexpr bool hasAbsorbedOptionalChain = true;
1371             return new (m_parserArena) CoalesceNode(location, optionalChain-&gt;expr(), expr2, hasAbsorbedOptionalChain);
1372         }
1373     }
1374     constexpr bool hasAbsorbedOptionalChain = false;
1375     return new (m_parserArena) CoalesceNode(location, expr1, expr2, hasAbsorbedOptionalChain);
1376 }
1377 
1378 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall)
1379 {
1380     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1381     if (func-&gt;isSuperNode())
1382         usesSuperCall();
1383 
1384     if (func-&gt;isBytecodeIntrinsicNode()) {
1385         ASSERT(!isOptionalCall);
1386         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
<span class="line-modified">1387         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant)</span>
<span class="line-modified">1388             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;emitter(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);</span>
1389     }
1390 
1391     if (func-&gt;isOptionalChain()) {
1392         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(func);
1393         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1394             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1395             // We must take care to preserve our `this` value in cases like `a?.b?.()` and `(a?.b)()`, respectively.
1396             if (isOptionalCall)
1397                 return makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall);
1398             optionalChain-&gt;setExpr(makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall));
1399             return optionalChain;
1400         }
1401     }
1402 
1403     if (!func-&gt;isLocation())
1404         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1405     if (func-&gt;isResolveNode()) {
1406         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1407         const Identifier&amp; identifier = resolve-&gt;identifier();
1408         if (identifier == m_vm.propertyNames-&gt;eval) {
</pre>
</td>
<td>
<hr />
<pre>
 105     typedef TemplateStringNode* TemplateString;
 106     typedef TemplateStringListNode* TemplateStringList;
 107     typedef TemplateLiteralNode* TemplateLiteral;
 108     typedef FunctionParameters* FormalParameterList;
 109     typedef FunctionMetadataNode* FunctionBody;
 110     typedef ClassExprNode* ClassExpression;
 111     typedef ModuleNameNode* ModuleName;
 112     typedef ImportSpecifierNode* ImportSpecifier;
 113     typedef ImportSpecifierListNode* ImportSpecifierList;
 114     typedef ExportSpecifierNode* ExportSpecifier;
 115     typedef ExportSpecifierListNode* ExportSpecifierList;
 116     typedef StatementNode* Statement;
 117     typedef ClauseListNode* ClauseList;
 118     typedef CaseClauseNode* Clause;
 119     typedef std::pair&lt;ExpressionNode*, BinaryOpInfo&gt; BinaryOperand;
 120     typedef DestructuringPatternNode* DestructuringPattern;
 121     typedef ArrayPatternNode* ArrayPattern;
 122     typedef ObjectPatternNode* ObjectPattern;
 123     typedef BindingNode* BindingPattern;
 124     typedef AssignmentElementNode* AssignmentElement;
<span class="line-modified"> 125     static constexpr bool CreatesAST = true;</span>
<span class="line-modified"> 126     static constexpr bool NeedsFreeVariableInfo = true;</span>
<span class="line-modified"> 127     static constexpr bool CanUseFunctionCache = true;</span>
<span class="line-modified"> 128     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildKeywords = { };</span>
<span class="line-modified"> 129     static constexpr OptionSet&lt;LexerFlags&gt; DontBuildStrings = { };</span>
 130 
 131     ExpressionNode* makeBinaryNode(const JSTokenLocation&amp;, int token, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;, std::pair&lt;ExpressionNode*, BinaryOpInfo&gt;);
 132     ExpressionNode* makeFunctionCallNode(const JSTokenLocation&amp;, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall);
 133 
 134     JSC::SourceElements* createSourceElements() { return new (m_parserArena) JSC::SourceElements(); }
 135 
 136     int features() const { return m_scope.m_features; }
 137     int numConstants() const { return m_scope.m_numConstants; }
 138 
 139     ExpressionNode* makeAssignNode(const JSTokenLocation&amp;, ExpressionNode* left, Operator, ExpressionNode* right, bool leftHasAssignments, bool rightHasAssignments, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 140     ExpressionNode* makePrefixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 141     ExpressionNode* makePostfixNode(const JSTokenLocation&amp;, ExpressionNode*, Operator, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 142     ExpressionNode* makeTypeOfNode(const JSTokenLocation&amp;, ExpressionNode*);
 143     ExpressionNode* makeDeleteNode(const JSTokenLocation&amp;, ExpressionNode*, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end);
 144     ExpressionNode* makeNegateNode(const JSTokenLocation&amp;, ExpressionNode*);
 145     ExpressionNode* makeBitwiseNotNode(const JSTokenLocation&amp;, ExpressionNode*);
 146     ExpressionNode* makePowNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 147     ExpressionNode* makeMultNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 148     ExpressionNode* makeDivNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
 149     ExpressionNode* makeModNode(const JSTokenLocation&amp;, ExpressionNode* left, ExpressionNode* right, bool rightHasAssignments);
</pre>
<hr />
<pre>
 183     {
 184         auto* node = new (m_parserArena) ImportNode(location, expr);
 185         setExceptionLocation(node, start, divot, end);
 186         return node;
 187     }
 188     ExpressionNode* createNewTargetExpr(const JSTokenLocation location)
 189     {
 190         usesNewTarget();
 191         return new (m_parserArena) NewTargetNode(location);
 192     }
 193     ExpressionNode* createImportMetaExpr(const JSTokenLocation&amp; location, ExpressionNode* expr) { return new (m_parserArena) ImportMetaNode(location, expr); }
 194     bool isMetaProperty(ExpressionNode* node) { return node-&gt;isMetaProperty(); }
 195     bool isNewTarget(ExpressionNode* node) { return node-&gt;isNewTarget(); }
 196     bool isImportMeta(ExpressionNode* node) { return node-&gt;isImportMeta(); }
 197     ExpressionNode* createResolve(const JSTokenLocation&amp; location, const Identifier&amp; ident, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 198     {
 199         if (m_vm.propertyNames-&gt;arguments == ident)
 200             usesArguments();
 201 
 202         if (ident.isSymbol()) {
<span class="line-modified"> 203             auto entry = m_vm.bytecodeIntrinsicRegistry().lookup(ident);</span>
<span class="line-modified"> 204             if (entry)</span>
<span class="line-added"> 205                 return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Constant, location, entry.value(), ident, nullptr, start, start, end);</span>
 206         }
 207 
 208         return new (m_parserArena) ResolveNode(location, ident, start);
 209     }
 210     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location) { return new (m_parserArena) ObjectLiteralNode(location); }
 211     ExpressionNode* createObjectLiteral(const JSTokenLocation&amp; location, PropertyListNode* properties) { return new (m_parserArena) ObjectLiteralNode(location, properties); }
 212 
 213     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions)
 214     {
 215         if (elisions)
 216             incConstants();
 217         return new (m_parserArena) ArrayNode(location, elisions);
 218     }
 219 
 220     ExpressionNode* createArray(const JSTokenLocation&amp; location, ElementNode* elems) { return new (m_parserArena) ArrayNode(location, elems); }
 221     ExpressionNode* createArray(const JSTokenLocation&amp; location, int elisions, ElementNode* elems)
 222     {
 223         if (elisions)
 224             incConstants();
 225         return new (m_parserArena) ArrayNode(location, elisions, elems);
</pre>
<hr />
<pre>
 388     YieldExprNode* createYield(const JSTokenLocation&amp; location)
 389     {
 390         return new (m_parserArena) YieldExprNode(location, nullptr, /* delegate */ false);
 391     }
 392 
 393     YieldExprNode* createYield(const JSTokenLocation&amp; location, ExpressionNode* argument, bool delegate, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 394     {
 395         YieldExprNode* node = new (m_parserArena) YieldExprNode(location, argument, delegate);
 396         setExceptionLocation(node, start, divot, end);
 397         return node;
 398     }
 399 
 400     AwaitExprNode* createAwait(const JSTokenLocation&amp; location, ExpressionNode* argument, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, const JSTextPosition&amp; end)
 401     {
 402         ASSERT(argument);
 403         AwaitExprNode* node = new (m_parserArena) AwaitExprNode(location, argument);
 404         setExceptionLocation(node, start, divot, end);
 405         return node;
 406     }
 407 
<span class="line-added"> 408     DefineFieldNode* createDefineField(const JSTokenLocation&amp; location, const Identifier* ident, ExpressionNode* initializer, DefineFieldNode::Type type)</span>
<span class="line-added"> 409     {</span>
<span class="line-added"> 410         return new (m_parserArena) DefineFieldNode(location, ident, initializer, type);</span>
<span class="line-added"> 411     }</span>
<span class="line-added"> 412 </span>
 413     ClassExprNode* createClassExpr(const JSTokenLocation&amp; location, const ParserClassInfo&lt;ASTBuilder&gt;&amp; classInfo, VariableEnvironment&amp; classEnvironment, ExpressionNode* constructor,
 414         ExpressionNode* parentClass, PropertyListNode* classElements)
 415     {
 416         SourceCode source = m_sourceCode-&gt;subExpression(classInfo.startOffset, classInfo.endOffset, classInfo.startLine, classInfo.startColumn);
 417         return new (m_parserArena) ClassExprNode(location, *classInfo.className, source, classEnvironment, constructor, parentClass, classElements);
 418     }
 419 
 420     ExpressionNode* createFunctionExpr(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo)
 421     {
 422         FuncExprNode* result = new (m_parserArena) FuncExprNode(location, *functionInfo.name, functionInfo.body,
 423             m_sourceCode-&gt;subExpression(functionInfo.startOffset, functionInfo.endOffset, functionInfo.startLine, functionInfo.parametersStartColumn));
 424         functionInfo.body-&gt;setLoc(functionInfo.startLine, functionInfo.endLine, location.startOffset, location.lineStartOffset);
 425         return result;
 426     }
 427 
 428     ExpressionNode* createGeneratorFunctionBody(const JSTokenLocation&amp; location, const ParserFunctionInfo&lt;ASTBuilder&gt;&amp; functionInfo, const Identifier&amp; name)
 429     {
 430         FuncExprNode* result = static_cast&lt;FuncExprNode*&gt;(createFunctionExpr(location, functionInfo));
 431         if (!name.isNull())
 432             result-&gt;metadata()-&gt;setEcmaName(name);
</pre>
<hr />
<pre>
 515     PropertyNode* createProperty(const Identifier* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, InferName inferName, ClassElementTag tag)
 516     {
 517         if (inferName == InferName::Allowed) {
 518             if (node-&gt;isBaseFuncExprNode()) {
 519                 auto metadata = static_cast&lt;BaseFuncExprNode*&gt;(node)-&gt;metadata();
 520                 metadata-&gt;setEcmaName(*propertyName);
 521             } else if (node-&gt;isClassExprNode())
 522                 static_cast&lt;ClassExprNode*&gt;(node)-&gt;setEcmaName(*propertyName);
 523         }
 524         return new (m_parserArena) PropertyNode(*propertyName, node, type, putType, superBinding, tag);
 525     }
 526     PropertyNode* createProperty(ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 527     {
 528         return new (m_parserArena) PropertyNode(node, type, putType, superBinding, tag);
 529     }
 530     PropertyNode* createProperty(VM&amp; vm, ParserArena&amp; parserArena, double propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag)
 531     {
 532         return new (m_parserArena) PropertyNode(parserArena.identifierArena().makeNumericIdentifier(vm, propertyName), node, type, putType, superBinding, tag);
 533     }
 534     PropertyNode* createProperty(ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(propertyName, node, type, putType, superBinding, tag); }
<span class="line-added"> 535     PropertyNode* createProperty(const Identifier* identifier, ExpressionNode* propertyName, ExpressionNode* node, PropertyNode::Type type, PropertyNode::PutType putType, bool, SuperBinding superBinding, ClassElementTag tag) { return new (m_parserArena) PropertyNode(*identifier, propertyName, node, type, putType, superBinding, tag); }</span>
 536     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property) { return new (m_parserArena) PropertyListNode(location, property); }
 537     PropertyListNode* createPropertyList(const JSTokenLocation&amp; location, PropertyNode* property, PropertyListNode* tail) { return new (m_parserArena) PropertyListNode(location, property, tail); }
 538 
 539     ElementNode* createElementList(int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elisions, expr); }
 540     ElementNode* createElementList(ElementNode* elems, int elisions, ExpressionNode* expr) { return new (m_parserArena) ElementNode(elems, elisions, expr); }
 541     ElementNode* createElementList(ArgumentListNode* elems)
 542     {
 543         ElementNode* head = new (m_parserArena) ElementNode(0, elems-&gt;m_expr);
 544         ElementNode* tail = head;
 545         elems = elems-&gt;m_next;
 546         while (elems) {
 547             tail = new (m_parserArena) ElementNode(tail, 0, elems-&gt;m_expr);
 548             elems = elems-&gt;m_next;
 549         }
 550         return head;
 551     }
 552 
 553     FormalParameterList createFormalParameterList() { return new (m_parserArena) FunctionParameters(); }
 554     void appendParameter(FormalParameterList list, DestructuringPattern pattern, ExpressionNode* defaultValue)
 555     {
</pre>
<hr />
<pre>
 910         tokenStackDepth++;
 911         m_unaryTokenStack.append(std::make_pair(type, start));
 912     }
 913 
 914     int unaryTokenStackLastType(int&amp;)
 915     {
 916         return m_unaryTokenStack.last().first;
 917     }
 918 
 919     const JSTextPosition&amp; unaryTokenStackLastStart(int&amp;)
 920     {
 921         return m_unaryTokenStack.last().second;
 922     }
 923 
 924     void unaryTokenStackRemoveLast(int&amp; tokenStackDepth)
 925     {
 926         tokenStackDepth--;
 927         m_unaryTokenStack.removeLast();
 928     }
 929 
<span class="line-added"> 930     int unaryTokenStackDepth() const</span>
<span class="line-added"> 931     {</span>
<span class="line-added"> 932         return m_unaryTokenStack.size();</span>
<span class="line-added"> 933     }</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935     void setUnaryTokenStackDepth(int oldDepth)</span>
<span class="line-added"> 936     {</span>
<span class="line-added"> 937         m_unaryTokenStack.shrink(oldDepth);</span>
<span class="line-added"> 938     }</span>
<span class="line-added"> 939 </span>
 940     void assignmentStackAppend(int&amp; assignmentStackDepth, ExpressionNode* node, const JSTextPosition&amp; start, const JSTextPosition&amp; divot, int assignmentCount, Operator op)
 941     {
 942         assignmentStackDepth++;
 943         ASSERT(start.offset &gt;= start.lineStartOffset);
 944         ASSERT(divot.offset &gt;= divot.lineStartOffset);
 945         m_assignmentInfoStack.append(AssignmentInfo(node, start, divot, assignmentCount, op));
 946     }
 947 
 948     ExpressionNode* createAssignment(const JSTokenLocation&amp; location, int&amp; assignmentStackDepth, ExpressionNode* rhs, int initialAssignmentCount, int currentAssignmentCount, const JSTextPosition&amp; lastTokenEnd)
 949     {
 950         AssignmentInfo&amp; info = m_assignmentInfoStack.last();
 951         ExpressionNode* result = makeAssignNode(location, info.m_node, info.m_op, rhs, info.m_initAssignments != initialAssignmentCount, info.m_initAssignments != currentAssignmentCount, info.m_start, info.m_divot + 1, lastTokenEnd);
 952         m_assignmentInfoStack.removeLast();
 953         assignmentStackDepth--;
 954         return result;
 955     }
 956 
 957     const Identifier* getName(const Property&amp; property) const { return property-&gt;name(); }
 958     PropertyNode::Type getType(const Property&amp; property) const { return property-&gt;type(); }
 959 
</pre>
<hr />
<pre>
1384     if (expr1-&gt;isOptionalChain()) {
1385         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(expr1);
1386         if (!optionalChain-&gt;expr()-&gt;isDeleteNode()) {
1387             constexpr bool hasAbsorbedOptionalChain = true;
1388             return new (m_parserArena) CoalesceNode(location, optionalChain-&gt;expr(), expr2, hasAbsorbedOptionalChain);
1389         }
1390     }
1391     constexpr bool hasAbsorbedOptionalChain = false;
1392     return new (m_parserArena) CoalesceNode(location, expr1, expr2, hasAbsorbedOptionalChain);
1393 }
1394 
1395 ExpressionNode* ASTBuilder::makeFunctionCallNode(const JSTokenLocation&amp; location, ExpressionNode* func, bool previousBaseWasSuper, ArgumentsNode* args, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotEnd, size_t callOrApplyChildDepth, bool isOptionalCall)
1396 {
1397     ASSERT(divot.offset &gt;= divot.lineStartOffset);
1398     if (func-&gt;isSuperNode())
1399         usesSuperCall();
1400 
1401     if (func-&gt;isBytecodeIntrinsicNode()) {
1402         ASSERT(!isOptionalCall);
1403         BytecodeIntrinsicNode* intrinsic = static_cast&lt;BytecodeIntrinsicNode*&gt;(func);
<span class="line-modified">1404         if (intrinsic-&gt;type() == BytecodeIntrinsicNode::Type::Constant &amp;&amp; intrinsic-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter)</span>
<span class="line-modified">1405             return new (m_parserArena) BytecodeIntrinsicNode(BytecodeIntrinsicNode::Type::Function, location, intrinsic-&gt;entry(), intrinsic-&gt;identifier(), args, divot, divotStart, divotEnd);</span>
1406     }
1407 
1408     if (func-&gt;isOptionalChain()) {
1409         OptionalChainNode* optionalChain = static_cast&lt;OptionalChainNode*&gt;(func);
1410         if (optionalChain-&gt;expr()-&gt;isLocation()) {
1411             ASSERT(!optionalChain-&gt;expr()-&gt;isResolveNode());
1412             // We must take care to preserve our `this` value in cases like `a?.b?.()` and `(a?.b)()`, respectively.
1413             if (isOptionalCall)
1414                 return makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall);
1415             optionalChain-&gt;setExpr(makeFunctionCallNode(location, optionalChain-&gt;expr(), previousBaseWasSuper, args, divotStart, divot, divotEnd, callOrApplyChildDepth, isOptionalCall));
1416             return optionalChain;
1417         }
1418     }
1419 
1420     if (!func-&gt;isLocation())
1421         return new (m_parserArena) FunctionCallValueNode(location, func, args, divot, divotStart, divotEnd);
1422     if (func-&gt;isResolveNode()) {
1423         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(func);
1424         const Identifier&amp; identifier = resolve-&gt;identifier();
1425         if (identifier == m_vm.propertyNames-&gt;eval) {
</pre>
</td>
</tr>
</table>
<center><a href="../offlineasm/x86.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Keywords.table.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
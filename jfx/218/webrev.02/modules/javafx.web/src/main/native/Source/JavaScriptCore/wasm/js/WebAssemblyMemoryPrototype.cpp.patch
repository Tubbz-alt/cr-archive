diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryPrototype.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryPrototype.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryPrototype.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyMemoryPrototype.cpp
@@ -33,12 +33,12 @@
 #include "JSCInlines.h"
 #include "JSWebAssemblyMemory.h"
 #include "JSWebAssemblyHelpers.h"
 
 namespace JSC {
-static EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncGrow(ExecState*);
-static EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncBuffer(ExecState*);
+static EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncGrow(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncBuffer(JSGlobalObject*, CallFrame*);
 }
 
 #include "WebAssemblyMemoryPrototype.lut.h"
 
 
@@ -51,48 +51,48 @@
  grow   webAssemblyMemoryProtoFuncGrow   Function 1
  buffer webAssemblyMemoryProtoFuncBuffer Accessor 0
 @end
 */
 
-ALWAYS_INLINE JSWebAssemblyMemory* getMemory(ExecState* exec, VM& vm, JSValue value)
+ALWAYS_INLINE JSWebAssemblyMemory* getMemory(JSGlobalObject* globalObject, VM& vm, JSValue value)
 {
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     JSWebAssemblyMemory* memory = jsDynamicCast<JSWebAssemblyMemory*>(vm, value);
     if (!memory) {
-        throwException(exec, throwScope,
-            createTypeError(exec, "WebAssembly.Memory.prototype.buffer getter called with non WebAssembly.Memory |this| value"_s));
+        throwException(globalObject, throwScope,
+            createTypeError(globalObject, "WebAssembly.Memory.prototype.buffer getter called with non WebAssembly.Memory |this| value"_s));
         return nullptr;
     }
     return memory;
 }
 
-EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncGrow(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncGrow(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
-    JSWebAssemblyMemory* memory = getMemory(exec, vm, exec->thisValue());
+    JSWebAssemblyMemory* memory = getMemory(globalObject, vm, callFrame->thisValue());
     RETURN_IF_EXCEPTION(throwScope, { });
 
-    uint32_t delta = toNonWrappingUint32(exec, exec->argument(0));
+    uint32_t delta = toNonWrappingUint32(globalObject, callFrame->argument(0));
     RETURN_IF_EXCEPTION(throwScope, { });
 
-    Wasm::PageCount result = memory->grow(vm, exec, delta);
+    Wasm::PageCount result = memory->grow(vm, globalObject, delta);
     RETURN_IF_EXCEPTION(throwScope, { });
 
     return JSValue::encode(jsNumber(result.pageCount()));
 }
 
-EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncBuffer(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL webAssemblyMemoryProtoFuncBuffer(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
-    JSWebAssemblyMemory* memory = getMemory(exec, vm, exec->thisValue());
+    JSWebAssemblyMemory* memory = getMemory(globalObject, vm, callFrame->thisValue());
     RETURN_IF_EXCEPTION(throwScope, { });
-    return JSValue::encode(memory->buffer(exec->vm(), exec->lexicalGlobalObject()));
+    return JSValue::encode(memory->buffer(globalObject->vm(), globalObject));
 }
 
 WebAssemblyMemoryPrototype* WebAssemblyMemoryPrototype::create(VM& vm, JSGlobalObject*, Structure* structure)
 {
     auto* object = new (NotNull, allocateCell<WebAssemblyMemoryPrototype>(vm.heap)) WebAssemblyMemoryPrototype(vm, structure);

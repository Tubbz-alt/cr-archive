diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h
@@ -39,16 +39,20 @@
 
 class ResourceResponse;
 
 bool isScriptAllowedByNosniff(const ResourceResponse&);
 
-// Do not use this class directly, use the class ResponseResponse instead
+enum class UsedLegacyTLS : bool { No, Yes };
+
+// Do not use this class directly, use the class ResourceResponse instead
 class ResourceResponseBase {
     WTF_MAKE_FAST_ALLOCATED;
 public:
     enum class Type : uint8_t { Basic, Cors, Default, Error, Opaque, Opaqueredirect };
+    static constexpr unsigned bitWidthOfType = 3;
     enum class Tainting : uint8_t { Basic, Cors, Opaque, Opaqueredirect };
+    static constexpr unsigned bitWidthOfTainting = 2;
 
     static bool isRedirectionStatusCode(int code) { return code == 301 || code == 302 || code == 303 || code == 307 || code == 308; }
 
     struct CrossThreadData {
         CrossThreadData(const CrossThreadData&) = delete;
@@ -66,10 +70,11 @@
         HTTPHeaderMap httpHeaderFields;
         NetworkLoadMetrics networkLoadMetrics;
         Type type;
         Tainting tainting;
         bool isRedirected;
+        bool isRangeRequested;
     };
 
     CrossThreadData crossThreadData() const;
     static ResourceResponse fromCrossThreadData(CrossThreadData&&);
 
@@ -124,27 +129,29 @@
     WEBCORE_EXPORT bool isAttachment() const;
     WEBCORE_EXPORT bool isAttachmentWithFilename() const;
     WEBCORE_EXPORT String suggestedFilename() const;
     WEBCORE_EXPORT static String sanitizeSuggestedFilename(const String&);
 
-    WEBCORE_EXPORT void includeCertificateInfo() const;
+    WEBCORE_EXPORT void includeCertificateInfo(UsedLegacyTLS = UsedLegacyTLS::No) const;
     const Optional<CertificateInfo>& certificateInfo() const { return m_certificateInfo; };
+    bool usedLegacyTLS() const { return m_usedLegacyTLS == UsedLegacyTLS::Yes; }
 
     // These functions return parsed values of the corresponding response headers.
     WEBCORE_EXPORT bool cacheControlContainsNoCache() const;
     WEBCORE_EXPORT bool cacheControlContainsNoStore() const;
     WEBCORE_EXPORT bool cacheControlContainsMustRevalidate() const;
     WEBCORE_EXPORT bool cacheControlContainsImmutable() const;
     WEBCORE_EXPORT bool hasCacheValidatorFields() const;
     WEBCORE_EXPORT Optional<Seconds> cacheControlMaxAge() const;
+    WEBCORE_EXPORT Optional<Seconds> cacheControlStaleWhileRevalidate() const;
     WEBCORE_EXPORT Optional<WallTime> date() const;
     WEBCORE_EXPORT Optional<Seconds> age() const;
     WEBCORE_EXPORT Optional<WallTime> expires() const;
     WEBCORE_EXPORT Optional<WallTime> lastModified() const;
     const ParsedContentRange& contentRange() const;
 
-    enum class Source : uint8_t { Unknown, Network, DiskCache, DiskCacheAfterValidation, MemoryCache, MemoryCacheAfterValidation, ServiceWorker, ApplicationCache };
+    enum class Source : uint8_t { Unknown, Network, DiskCache, DiskCacheAfterValidation, MemoryCache, MemoryCacheAfterValidation, ServiceWorker, ApplicationCache, DOMCache, InspectorOverride };
     WEBCORE_EXPORT Source source() const;
     void setSource(Source source)
     {
         ASSERT(source != Source::Unknown);
         m_source = source;
@@ -178,10 +185,13 @@
     static bool compare(const ResourceResponse&, const ResourceResponse&);
 
     template<class Encoder> void encode(Encoder&) const;
     template<class Decoder> static bool decode(Decoder&, ResourceResponseBase&);
 
+    bool isRangeRequested() const { return m_isRangeRequested; }
+    void setAsRangeRequested() { m_isRangeRequested = true; }
+
 protected:
     enum InitLevel {
         Uninitialized,
         CommonFieldsOnly,
         AllFields
@@ -236,13 +246,15 @@
 
 private:
     Source m_source { Source::Unknown };
     Type m_type { Type::Default };
     Tainting m_tainting { Tainting::Basic };
+    bool m_isRangeRequested { false };
 
 protected:
-    int m_httpStatusCode { 0 };
+    short m_httpStatusCode { 0 };
+    mutable UsedLegacyTLS m_usedLegacyTLS { UsedLegacyTLS::No };
 };
 
 inline bool operator==(const ResourceResponse& a, const ResourceResponse& b) { return ResourceResponseBase::compare(a, b); }
 inline bool operator!=(const ResourceResponse& a, const ResourceResponse& b) { return !(a == b); }
 
@@ -271,10 +283,12 @@
     encoder << m_certificateInfo;
     encoder.encodeEnum(m_source);
     encoder.encodeEnum(m_type);
     encoder.encodeEnum(m_tainting);
     encoder << m_isRedirected;
+    encoder << m_usedLegacyTLS;
+    encoder << m_isRangeRequested;
 }
 
 template<class Decoder>
 bool ResourceResponseBase::decode(Decoder& decoder, ResourceResponseBase& response)
 {
@@ -283,10 +297,12 @@
     if (!decoder.decode(responseIsNull))
         return false;
     if (responseIsNull)
         return true;
 
+    response.m_isNull = false;
+
     if (!decoder.decode(response.m_url))
         return false;
     if (!decoder.decode(response.m_mimeType))
         return false;
     int64_t expectedContentLength;
@@ -316,11 +332,16 @@
         return false;
     bool isRedirected = false;
     if (!decoder.decode(isRedirected))
         return false;
     response.m_isRedirected = isRedirected;
-    response.m_isNull = false;
+    if (!decoder.decode(response.m_usedLegacyTLS))
+        return false;
+    bool isRangeRequested = false;
+    if (!decoder.decode(isRangeRequested))
+        return false;
+    response.m_isRangeRequested = isRangeRequested;
 
     return true;
 }
 
 } // namespace WebCore

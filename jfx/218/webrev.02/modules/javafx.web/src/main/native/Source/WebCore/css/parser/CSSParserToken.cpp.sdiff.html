<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserToken.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserSelector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserToken.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserToken.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSParserToken.h&quot;
 32 
 33 #include &quot;CSSMarkup.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyParser.h&quot;
 36 #include &lt;limits.h&gt;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 template&lt;typename CharacterType&gt;
<span class="line-modified"> 43 CSSPrimitiveValue::UnitType cssPrimitiveValueUnitFromTrie(const CharacterType* data, unsigned length)</span>
 44 {
 45     ASSERT(data);
 46     ASSERT(length);
 47     switch (length) {
 48     case 1:
 49         switch (toASCIILower(data[0])) {


 50         case &#39;s&#39;:
<span class="line-modified"> 51             return CSSPrimitiveValue::UnitType::CSS_S;</span>
 52         }
 53         break;
 54     case 2:
 55         switch (toASCIILower(data[0])) {
 56         case &#39;c&#39;:
 57             switch (toASCIILower(data[1])) {
 58             case &#39;h&#39;:
<span class="line-modified"> 59                 return CSSPrimitiveValue::UnitType::CSS_CHS;</span>
 60             case &#39;m&#39;:
<span class="line-modified"> 61                 return CSSPrimitiveValue::UnitType::CSS_CM;</span>
 62             }
 63             break;
 64         case &#39;e&#39;:
 65             switch (toASCIILower(data[1])) {
 66             case &#39;m&#39;:
<span class="line-modified"> 67                 return CSSPrimitiveValue::UnitType::CSS_EMS;</span>
 68             case &#39;x&#39;:
<span class="line-modified"> 69                 return CSSPrimitiveValue::UnitType::CSS_EXS;</span>
 70             }
 71             break;
 72         case &#39;f&#39;:
 73             if (toASCIILower(data[1]) == &#39;r&#39;)
<span class="line-modified"> 74                 return CSSPrimitiveValue::UnitType::CSS_FR;</span>
 75             break;
 76         case &#39;h&#39;:
 77             if (toASCIILower(data[1]) == &#39;z&#39;)
<span class="line-modified"> 78                 return CSSPrimitiveValue::UnitType::CSS_HZ;</span>
 79             break;
 80         case &#39;i&#39;:
 81             if (toASCIILower(data[1]) == &#39;n&#39;)
<span class="line-modified"> 82                 return CSSPrimitiveValue::UnitType::CSS_IN;</span>
 83             break;
 84         case &#39;m&#39;:
 85             switch (toASCIILower(data[1])) {
 86             case &#39;m&#39;:
<span class="line-modified"> 87                 return CSSPrimitiveValue::UnitType::CSS_MM;</span>
 88             case &#39;s&#39;:
<span class="line-modified"> 89                 return CSSPrimitiveValue::UnitType::CSS_MS;</span>
 90             }
 91             break;
 92         case &#39;p&#39;:
 93             switch (toASCIILower(data[1])) {
 94             case &#39;c&#39;:
<span class="line-modified"> 95                 return CSSPrimitiveValue::UnitType::CSS_PC;</span>
 96             case &#39;t&#39;:
<span class="line-modified"> 97                 return CSSPrimitiveValue::UnitType::CSS_PT;</span>
 98             case &#39;x&#39;:
<span class="line-modified"> 99                 return CSSPrimitiveValue::UnitType::CSS_PX;</span>
100             }
101             break;
102         case &#39;v&#39;:
103             switch (toASCIILower(data[1])) {
104             case &#39;h&#39;:
<span class="line-modified">105                 return CSSPrimitiveValue::UnitType::CSS_VH;</span>
106             case &#39;w&#39;:
<span class="line-modified">107                 return CSSPrimitiveValue::UnitType::CSS_VW;</span>
108             }
109             break;
110         }
111         break;
112     case 3:
113         switch (toASCIILower(data[0])) {
114         case &#39;d&#39;:
115             switch (toASCIILower(data[1])) {
116             case &#39;e&#39;:
117                 if (toASCIILower(data[2]) == &#39;g&#39;)
<span class="line-modified">118                     return CSSPrimitiveValue::UnitType::CSS_DEG;</span>
119                 break;
120             case &#39;p&#39;:
121                 if (toASCIILower(data[2]) == &#39;i&#39;)
<span class="line-modified">122                     return CSSPrimitiveValue::UnitType::CSS_DPI;</span>
123                 break;
124             }
125         break;
126         case &#39;k&#39;:
127             if (toASCIILower(data[1]) == &#39;h&#39; &amp;&amp; toASCIILower(data[2]) == &#39;z&#39;)
<span class="line-modified">128                 return CSSPrimitiveValue::UnitType::CSS_KHZ;</span>
129             break;
130         case &#39;r&#39;:
131             switch (toASCIILower(data[1])) {
132             case &#39;a&#39;:
133                 if (toASCIILower(data[2]) == &#39;d&#39;)
<span class="line-modified">134                     return CSSPrimitiveValue::UnitType::CSS_RAD;</span>
135                 break;
136             case &#39;e&#39;:
137                 if (toASCIILower(data[2]) == &#39;m&#39;)
<span class="line-modified">138                     return CSSPrimitiveValue::UnitType::CSS_REMS;</span>
139                 break;
140             }
141         break;
142     }
143     break;
144     case 4:
145         switch (toASCIILower(data[0])) {
146         case &#39;d&#39;:
147             switch (toASCIILower(data[1])) {
148             case &#39;p&#39;:
149                 switch (toASCIILower(data[2])) {
150                 case &#39;c&#39;:
151                     if (toASCIILower(data[3]) == &#39;m&#39;)
<span class="line-modified">152                         return CSSPrimitiveValue::UnitType::CSS_DPCM;</span>
153                     break;
154                 case &#39;p&#39;:
155                     if (toASCIILower(data[3]) == &#39;x&#39;)
<span class="line-modified">156                         return CSSPrimitiveValue::UnitType::CSS_DPPX;</span>
157                     break;
158                 }
159             break;
160         }
161         break;
162         case &#39;g&#39;:
163             if (toASCIILower(data[1]) == &#39;r&#39; &amp;&amp; toASCIILower(data[2]) == &#39;a&#39; &amp;&amp; toASCIILower(data[3]) == &#39;d&#39;)
<span class="line-modified">164                 return CSSPrimitiveValue::UnitType::CSS_GRAD;</span>
165             break;
166         case &#39;t&#39;:
167             if (toASCIILower(data[1]) == &#39;u&#39; &amp;&amp; toASCIILower(data[2]) == &#39;r&#39; &amp;&amp; toASCIILower(data[3]) == &#39;n&#39;)
<span class="line-modified">168                 return CSSPrimitiveValue::UnitType::CSS_TURN;</span>
169             break;
170         case &#39;v&#39;:
171             switch (toASCIILower(data[1])) {
172             case &#39;m&#39;:
173                 switch (toASCIILower(data[2])) {
174                 case &#39;a&#39;:
175                     if (toASCIILower(data[3]) == &#39;x&#39;)
<span class="line-modified">176                         return CSSPrimitiveValue::UnitType::CSS_VMAX;</span>
177                     break;
178                 case &#39;i&#39;:
179                     if (toASCIILower(data[3]) == &#39;n&#39;)
<span class="line-modified">180                         return CSSPrimitiveValue::UnitType::CSS_VMIN;</span>
181                     break;
182                 }
183                 break;
184             }
185             break;
186         }
187         break;
188     case 5:
189         switch (toASCIILower(data[0])) {
190         case &#39;_&#39;:
191             if (toASCIILower(data[1]) == &#39;_&#39; &amp;&amp; toASCIILower(data[2]) == &#39;q&#39; &amp;&amp; toASCIILower(data[3]) == &#39;e&#39; &amp;&amp; toASCIILower(data[4]) == &#39;m&#39;)
<span class="line-modified">192                 return CSSPrimitiveValue::UnitType::CSS_QUIRKY_EMS;</span>
193             break;
194         }
195         break;
196     }
<span class="line-modified">197     return CSSPrimitiveValue::UnitType::CSS_UNKNOWN;</span>
198 }
199 
<span class="line-modified">200 static CSSPrimitiveValue::UnitType stringToUnitType(StringView stringView)</span>
201 {
202     if (stringView.is8Bit())
203         return cssPrimitiveValueUnitFromTrie(stringView.characters8(), stringView.length());
204     return cssPrimitiveValueUnitFromTrie(stringView.characters16(), stringView.length());
205 }
206 
207 CSSParserToken::CSSParserToken(CSSParserTokenType type, BlockType blockType)
208     : m_type(type)
209     , m_blockType(blockType)
210 {
211 }
212 
213 // Just a helper used for Delimiter tokens.
214 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar c)
215     : m_type(type)
216     , m_blockType(NotBlock)
217     , m_delimiter(c)
218 {
219     ASSERT(m_type == DelimiterToken);
220 }
221 
222 CSSParserToken::CSSParserToken(CSSParserTokenType type, StringView value, BlockType blockType)
223     : m_type(type)
224     , m_blockType(blockType)
225 {
226     initValueFromStringView(value);
227     m_id = -1;
228 }
229 
230 CSSParserToken::CSSParserToken(CSSParserTokenType type, double numericValue, NumericValueType numericValueType, NumericSign sign)
231     : m_type(type)
232     , m_blockType(NotBlock)
233     , m_numericValueType(numericValueType)
234     , m_numericSign(sign)
<span class="line-modified">235     , m_unit(static_cast&lt;unsigned&gt;(CSSPrimitiveValue::UnitType::CSS_NUMBER))</span>
236 {
237     ASSERT(type == NumberToken);
238     m_numericValue = numericValue;
239 }
240 
241 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar32 start, UChar32 end)
242     : m_type(UnicodeRangeToken)
243     , m_blockType(NotBlock)
244 {
245     ASSERT_UNUSED(type, type == UnicodeRangeToken);
246     m_unicodeRange.start = start;
247     m_unicodeRange.end = end;
248 }
249 
250 CSSParserToken::CSSParserToken(HashTokenType type, StringView value)
251     : m_type(HashToken)
252     , m_blockType(NotBlock)
253     , m_hashTokenType(type)
254 {
255     initValueFromStringView(value);
256 }
257 
258 void CSSParserToken::convertToDimensionWithUnit(StringView unit)
259 {
260     ASSERT(m_type == NumberToken);
261     m_type = DimensionToken;
262     initValueFromStringView(unit);
263     m_unit = static_cast&lt;unsigned&gt;(stringToUnitType(unit));
264 }
265 
266 void CSSParserToken::convertToPercentage()
267 {
268     ASSERT(m_type == NumberToken);
269     m_type = PercentageToken;
<span class="line-modified">270     m_unit = static_cast&lt;unsigned&gt;(CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
271 }
272 
273 UChar CSSParserToken::delimiter() const
274 {
275     ASSERT(m_type == DelimiterToken);
276     return m_delimiter;
277 }
278 
279 NumericSign CSSParserToken::numericSign() const
280 {
281     // This is valid for DimensionToken and PercentageToken, but only used
282     // in &lt;an+b&gt; parsing on NumberTokens.
283     ASSERT(m_type == NumberToken);
284     return static_cast&lt;NumericSign&gt;(m_numericSign);
285 }
286 
287 NumericValueType CSSParserToken::numericValueType() const
288 {
289     ASSERT(m_type == NumberToken || m_type == PercentageToken || m_type == DimensionToken);
290     return static_cast&lt;NumericValueType&gt;(m_numericValueType);
</pre>
<hr />
<pre>
402     case HashToken:
403         builder.append(&#39;#&#39;);
404         serializeIdentifier(value().toString(), builder, (getHashTokenType() == HashTokenUnrestricted));
405         break;
406     case UrlToken:
407         builder.appendLiteral(&quot;url(&quot;);
408         serializeIdentifier(value().toString(), builder);
409         builder.append(&#39;)&#39;);
410         break;
411     case DelimiterToken:
412         if (delimiter() == &#39;\\&#39;) {
413             builder.appendLiteral(&quot;\\\n&quot;);
414             break;
415         }
416         builder.append(delimiter());
417         break;
418     case NumberToken:
419         // These won&#39;t properly preserve the NumericValueType flag
420         if (m_numericSign == PlusSign)
421             builder.append(&#39;+&#39;);
<span class="line-modified">422         builder.appendFixedPrecisionNumber(numericValue());</span>
423         break;
424     case PercentageToken:
<span class="line-modified">425         builder.appendFixedPrecisionNumber(numericValue());</span>
<span class="line-removed">426         builder.append(&#39;%&#39;);</span>
427         break;
428     case DimensionToken:
429         // This will incorrectly serialize e.g. 4e3e2 as 4000e2
<span class="line-modified">430         builder.appendFixedPrecisionNumber(numericValue());</span>
431         serializeIdentifier(value().toString(), builder);
432         break;
433     case UnicodeRangeToken:
434         builder.appendLiteral(&quot;U+&quot;);
<span class="line-modified">435         appendUnsignedAsHex(unicodeRangeStart(), builder);</span>
436         builder.append(&#39;-&#39;);
<span class="line-modified">437         appendUnsignedAsHex(unicodeRangeEnd(), builder);</span>
438         break;
439     case StringToken:
440         serializeString(value().toString(), builder);
441         break;
442 
443     case IncludeMatchToken:
444         builder.appendLiteral(&quot;~=&quot;);
445         break;
446     case DashMatchToken:
447         builder.appendLiteral(&quot;|=&quot;);
448         break;
449     case PrefixMatchToken:
450         builder.appendLiteral(&quot;^=&quot;);
451         break;
452     case SuffixMatchToken:
453         builder.appendLiteral(&quot;$=&quot;);
454         break;
455     case SubstringMatchToken:
456         builder.appendLiteral(&quot;*=&quot;);
457         break;
</pre>
</td>
<td>
<hr />
<pre>
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;CSSParserToken.h&quot;
 32 
 33 #include &quot;CSSMarkup.h&quot;
 34 #include &quot;CSSPrimitiveValue.h&quot;
 35 #include &quot;CSSPropertyParser.h&quot;
 36 #include &lt;limits.h&gt;
 37 #include &lt;wtf/HexNumber.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 template&lt;typename CharacterType&gt;
<span class="line-modified"> 43 CSSUnitType cssPrimitiveValueUnitFromTrie(const CharacterType* data, unsigned length)</span>
 44 {
 45     ASSERT(data);
 46     ASSERT(length);
 47     switch (length) {
 48     case 1:
 49         switch (toASCIILower(data[0])) {
<span class="line-added"> 50         case &#39;q&#39;:</span>
<span class="line-added"> 51             return CSSUnitType::CSS_Q;</span>
 52         case &#39;s&#39;:
<span class="line-modified"> 53             return CSSUnitType::CSS_S;</span>
 54         }
 55         break;
 56     case 2:
 57         switch (toASCIILower(data[0])) {
 58         case &#39;c&#39;:
 59             switch (toASCIILower(data[1])) {
 60             case &#39;h&#39;:
<span class="line-modified"> 61                 return CSSUnitType::CSS_CHS;</span>
 62             case &#39;m&#39;:
<span class="line-modified"> 63                 return CSSUnitType::CSS_CM;</span>
 64             }
 65             break;
 66         case &#39;e&#39;:
 67             switch (toASCIILower(data[1])) {
 68             case &#39;m&#39;:
<span class="line-modified"> 69                 return CSSUnitType::CSS_EMS;</span>
 70             case &#39;x&#39;:
<span class="line-modified"> 71                 return CSSUnitType::CSS_EXS;</span>
 72             }
 73             break;
 74         case &#39;f&#39;:
 75             if (toASCIILower(data[1]) == &#39;r&#39;)
<span class="line-modified"> 76                 return CSSUnitType::CSS_FR;</span>
 77             break;
 78         case &#39;h&#39;:
 79             if (toASCIILower(data[1]) == &#39;z&#39;)
<span class="line-modified"> 80                 return CSSUnitType::CSS_HZ;</span>
 81             break;
 82         case &#39;i&#39;:
 83             if (toASCIILower(data[1]) == &#39;n&#39;)
<span class="line-modified"> 84                 return CSSUnitType::CSS_IN;</span>
 85             break;
 86         case &#39;m&#39;:
 87             switch (toASCIILower(data[1])) {
 88             case &#39;m&#39;:
<span class="line-modified"> 89                 return CSSUnitType::CSS_MM;</span>
 90             case &#39;s&#39;:
<span class="line-modified"> 91                 return CSSUnitType::CSS_MS;</span>
 92             }
 93             break;
 94         case &#39;p&#39;:
 95             switch (toASCIILower(data[1])) {
 96             case &#39;c&#39;:
<span class="line-modified"> 97                 return CSSUnitType::CSS_PC;</span>
 98             case &#39;t&#39;:
<span class="line-modified"> 99                 return CSSUnitType::CSS_PT;</span>
100             case &#39;x&#39;:
<span class="line-modified">101                 return CSSUnitType::CSS_PX;</span>
102             }
103             break;
104         case &#39;v&#39;:
105             switch (toASCIILower(data[1])) {
106             case &#39;h&#39;:
<span class="line-modified">107                 return CSSUnitType::CSS_VH;</span>
108             case &#39;w&#39;:
<span class="line-modified">109                 return CSSUnitType::CSS_VW;</span>
110             }
111             break;
112         }
113         break;
114     case 3:
115         switch (toASCIILower(data[0])) {
116         case &#39;d&#39;:
117             switch (toASCIILower(data[1])) {
118             case &#39;e&#39;:
119                 if (toASCIILower(data[2]) == &#39;g&#39;)
<span class="line-modified">120                     return CSSUnitType::CSS_DEG;</span>
121                 break;
122             case &#39;p&#39;:
123                 if (toASCIILower(data[2]) == &#39;i&#39;)
<span class="line-modified">124                     return CSSUnitType::CSS_DPI;</span>
125                 break;
126             }
127         break;
128         case &#39;k&#39;:
129             if (toASCIILower(data[1]) == &#39;h&#39; &amp;&amp; toASCIILower(data[2]) == &#39;z&#39;)
<span class="line-modified">130                 return CSSUnitType::CSS_KHZ;</span>
131             break;
132         case &#39;r&#39;:
133             switch (toASCIILower(data[1])) {
134             case &#39;a&#39;:
135                 if (toASCIILower(data[2]) == &#39;d&#39;)
<span class="line-modified">136                     return CSSUnitType::CSS_RAD;</span>
137                 break;
138             case &#39;e&#39;:
139                 if (toASCIILower(data[2]) == &#39;m&#39;)
<span class="line-modified">140                     return CSSUnitType::CSS_REMS;</span>
141                 break;
142             }
143         break;
144     }
145     break;
146     case 4:
147         switch (toASCIILower(data[0])) {
148         case &#39;d&#39;:
149             switch (toASCIILower(data[1])) {
150             case &#39;p&#39;:
151                 switch (toASCIILower(data[2])) {
152                 case &#39;c&#39;:
153                     if (toASCIILower(data[3]) == &#39;m&#39;)
<span class="line-modified">154                         return CSSUnitType::CSS_DPCM;</span>
155                     break;
156                 case &#39;p&#39;:
157                     if (toASCIILower(data[3]) == &#39;x&#39;)
<span class="line-modified">158                         return CSSUnitType::CSS_DPPX;</span>
159                     break;
160                 }
161             break;
162         }
163         break;
164         case &#39;g&#39;:
165             if (toASCIILower(data[1]) == &#39;r&#39; &amp;&amp; toASCIILower(data[2]) == &#39;a&#39; &amp;&amp; toASCIILower(data[3]) == &#39;d&#39;)
<span class="line-modified">166                 return CSSUnitType::CSS_GRAD;</span>
167             break;
168         case &#39;t&#39;:
169             if (toASCIILower(data[1]) == &#39;u&#39; &amp;&amp; toASCIILower(data[2]) == &#39;r&#39; &amp;&amp; toASCIILower(data[3]) == &#39;n&#39;)
<span class="line-modified">170                 return CSSUnitType::CSS_TURN;</span>
171             break;
172         case &#39;v&#39;:
173             switch (toASCIILower(data[1])) {
174             case &#39;m&#39;:
175                 switch (toASCIILower(data[2])) {
176                 case &#39;a&#39;:
177                     if (toASCIILower(data[3]) == &#39;x&#39;)
<span class="line-modified">178                         return CSSUnitType::CSS_VMAX;</span>
179                     break;
180                 case &#39;i&#39;:
181                     if (toASCIILower(data[3]) == &#39;n&#39;)
<span class="line-modified">182                         return CSSUnitType::CSS_VMIN;</span>
183                     break;
184                 }
185                 break;
186             }
187             break;
188         }
189         break;
190     case 5:
191         switch (toASCIILower(data[0])) {
192         case &#39;_&#39;:
193             if (toASCIILower(data[1]) == &#39;_&#39; &amp;&amp; toASCIILower(data[2]) == &#39;q&#39; &amp;&amp; toASCIILower(data[3]) == &#39;e&#39; &amp;&amp; toASCIILower(data[4]) == &#39;m&#39;)
<span class="line-modified">194                 return CSSUnitType::CSS_QUIRKY_EMS;</span>
195             break;
196         }
197         break;
198     }
<span class="line-modified">199     return CSSUnitType::CSS_UNKNOWN;</span>
200 }
201 
<span class="line-modified">202 static CSSUnitType stringToUnitType(StringView stringView)</span>
203 {
204     if (stringView.is8Bit())
205         return cssPrimitiveValueUnitFromTrie(stringView.characters8(), stringView.length());
206     return cssPrimitiveValueUnitFromTrie(stringView.characters16(), stringView.length());
207 }
208 
209 CSSParserToken::CSSParserToken(CSSParserTokenType type, BlockType blockType)
210     : m_type(type)
211     , m_blockType(blockType)
212 {
213 }
214 
215 // Just a helper used for Delimiter tokens.
216 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar c)
217     : m_type(type)
218     , m_blockType(NotBlock)
219     , m_delimiter(c)
220 {
221     ASSERT(m_type == DelimiterToken);
222 }
223 
224 CSSParserToken::CSSParserToken(CSSParserTokenType type, StringView value, BlockType blockType)
225     : m_type(type)
226     , m_blockType(blockType)
227 {
228     initValueFromStringView(value);
229     m_id = -1;
230 }
231 
232 CSSParserToken::CSSParserToken(CSSParserTokenType type, double numericValue, NumericValueType numericValueType, NumericSign sign)
233     : m_type(type)
234     , m_blockType(NotBlock)
235     , m_numericValueType(numericValueType)
236     , m_numericSign(sign)
<span class="line-modified">237     , m_unit(static_cast&lt;unsigned&gt;(CSSUnitType::CSS_NUMBER))</span>
238 {
239     ASSERT(type == NumberToken);
240     m_numericValue = numericValue;
241 }
242 
243 CSSParserToken::CSSParserToken(CSSParserTokenType type, UChar32 start, UChar32 end)
244     : m_type(UnicodeRangeToken)
245     , m_blockType(NotBlock)
246 {
247     ASSERT_UNUSED(type, type == UnicodeRangeToken);
248     m_unicodeRange.start = start;
249     m_unicodeRange.end = end;
250 }
251 
252 CSSParserToken::CSSParserToken(HashTokenType type, StringView value)
253     : m_type(HashToken)
254     , m_blockType(NotBlock)
255     , m_hashTokenType(type)
256 {
257     initValueFromStringView(value);
258 }
259 
260 void CSSParserToken::convertToDimensionWithUnit(StringView unit)
261 {
262     ASSERT(m_type == NumberToken);
263     m_type = DimensionToken;
264     initValueFromStringView(unit);
265     m_unit = static_cast&lt;unsigned&gt;(stringToUnitType(unit));
266 }
267 
268 void CSSParserToken::convertToPercentage()
269 {
270     ASSERT(m_type == NumberToken);
271     m_type = PercentageToken;
<span class="line-modified">272     m_unit = static_cast&lt;unsigned&gt;(CSSUnitType::CSS_PERCENTAGE);</span>
273 }
274 
275 UChar CSSParserToken::delimiter() const
276 {
277     ASSERT(m_type == DelimiterToken);
278     return m_delimiter;
279 }
280 
281 NumericSign CSSParserToken::numericSign() const
282 {
283     // This is valid for DimensionToken and PercentageToken, but only used
284     // in &lt;an+b&gt; parsing on NumberTokens.
285     ASSERT(m_type == NumberToken);
286     return static_cast&lt;NumericSign&gt;(m_numericSign);
287 }
288 
289 NumericValueType CSSParserToken::numericValueType() const
290 {
291     ASSERT(m_type == NumberToken || m_type == PercentageToken || m_type == DimensionToken);
292     return static_cast&lt;NumericValueType&gt;(m_numericValueType);
</pre>
<hr />
<pre>
404     case HashToken:
405         builder.append(&#39;#&#39;);
406         serializeIdentifier(value().toString(), builder, (getHashTokenType() == HashTokenUnrestricted));
407         break;
408     case UrlToken:
409         builder.appendLiteral(&quot;url(&quot;);
410         serializeIdentifier(value().toString(), builder);
411         builder.append(&#39;)&#39;);
412         break;
413     case DelimiterToken:
414         if (delimiter() == &#39;\\&#39;) {
415             builder.appendLiteral(&quot;\\\n&quot;);
416             break;
417         }
418         builder.append(delimiter());
419         break;
420     case NumberToken:
421         // These won&#39;t properly preserve the NumericValueType flag
422         if (m_numericSign == PlusSign)
423             builder.append(&#39;+&#39;);
<span class="line-modified">424         builder.append(numericValue());</span>
425         break;
426     case PercentageToken:
<span class="line-modified">427         builder.append(numericValue(), &#39;%&#39;);</span>

428         break;
429     case DimensionToken:
430         // This will incorrectly serialize e.g. 4e3e2 as 4000e2
<span class="line-modified">431         builder.append(numericValue());</span>
432         serializeIdentifier(value().toString(), builder);
433         break;
434     case UnicodeRangeToken:
435         builder.appendLiteral(&quot;U+&quot;);
<span class="line-modified">436         builder.append(hex(unicodeRangeStart()));</span>
437         builder.append(&#39;-&#39;);
<span class="line-modified">438         builder.append(hex(unicodeRangeEnd()));</span>
439         break;
440     case StringToken:
441         serializeString(value().toString(), builder);
442         break;
443 
444     case IncludeMatchToken:
445         builder.appendLiteral(&quot;~=&quot;);
446         break;
447     case DashMatchToken:
448         builder.appendLiteral(&quot;|=&quot;);
449         break;
450     case PrefixMatchToken:
451         builder.appendLiteral(&quot;^=&quot;);
452         break;
453     case SuffixMatchToken:
454         builder.appendLiteral(&quot;$=&quot;);
455         break;
456     case SubstringMatchToken:
457         builder.appendLiteral(&quot;*=&quot;);
458         break;
</pre>
</td>
</tr>
</table>
<center><a href="CSSParserSelector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParserToken.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
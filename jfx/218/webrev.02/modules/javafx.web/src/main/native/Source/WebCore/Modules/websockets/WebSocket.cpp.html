<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WebSocket.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc.  All rights reserved.
  3  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;WebSocket.h&quot;
 34 
 35 #include &quot;Blob.h&quot;
 36 #include &quot;CloseEvent.h&quot;
 37 #include &quot;ContentSecurityPolicy.h&quot;
 38 #include &quot;DOMWindow.h&quot;
 39 #include &quot;Document.h&quot;
 40 #include &quot;Event.h&quot;
 41 #include &quot;EventListener.h&quot;
 42 #include &quot;EventNames.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;Logging.h&quot;
 46 #include &quot;MessageEvent.h&quot;
 47 #include &quot;ResourceLoadObserver.h&quot;
 48 #include &quot;ScriptController.h&quot;
 49 #include &quot;ScriptExecutionContext.h&quot;
 50 #include &quot;SecurityOrigin.h&quot;
 51 #include &quot;SocketProvider.h&quot;
 52 #include &quot;ThreadableWebSocketChannel.h&quot;
 53 #include &quot;WebSocketChannel.h&quot;
 54 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 55 #include &lt;JavaScriptCore/ArrayBufferView.h&gt;
 56 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 57 #include &lt;wtf/HashSet.h&gt;
 58 #include &lt;wtf/HexNumber.h&gt;
 59 #include &lt;wtf/IsoMallocInlines.h&gt;
 60 #include &lt;wtf/NeverDestroyed.h&gt;
 61 #include &lt;wtf/RunLoop.h&gt;
 62 #include &lt;wtf/StdLibExtras.h&gt;
 63 #include &lt;wtf/text/CString.h&gt;
 64 #include &lt;wtf/text/StringBuilder.h&gt;
 65 
 66 #if USE(WEB_THREAD)
 67 #include &quot;WebCoreThreadRun.h&quot;
 68 #endif
 69 
 70 namespace WebCore {
 71 
 72 WTF_MAKE_ISO_ALLOCATED_IMPL(WebSocket);
 73 
 74 const size_t maxReasonSizeInBytes = 123;
 75 
 76 static inline bool isValidProtocolCharacter(UChar character)
 77 {
 78     // Hybi-10 says &quot;(Subprotocol string must consist of) characters in the range U+0021 to U+007E not including
 79     // separator characters as defined in [RFC2616].&quot;
 80     const UChar minimumProtocolCharacter = &#39;!&#39;; // U+0021.
 81     const UChar maximumProtocolCharacter = &#39;~&#39;; // U+007E.
 82     return character &gt;= minimumProtocolCharacter &amp;&amp; character &lt;= maximumProtocolCharacter
 83         &amp;&amp; character != &#39;&quot;&#39; &amp;&amp; character != &#39;(&#39; &amp;&amp; character != &#39;)&#39; &amp;&amp; character != &#39;,&#39; &amp;&amp; character != &#39;/&#39;
 84         &amp;&amp; !(character &gt;= &#39;:&#39; &amp;&amp; character &lt;= &#39;@&#39;) // U+003A - U+0040 (&#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;@&#39;).
 85         &amp;&amp; !(character &gt;= &#39;[&#39; &amp;&amp; character &lt;= &#39;]&#39;) // U+005B - U+005D (&#39;[&#39;, &#39;\\&#39;, &#39;]&#39;).
 86         &amp;&amp; character != &#39;{&#39; &amp;&amp; character != &#39;}&#39;;
 87 }
 88 
 89 static bool isValidProtocolString(StringView protocol)
 90 {
 91     if (protocol.isEmpty())
 92         return false;
 93     for (auto codeUnit : protocol.codeUnits()) {
 94         if (!isValidProtocolCharacter(codeUnit))
 95             return false;
 96     }
 97     return true;
 98 }
 99 
100 static String encodeProtocolString(const String&amp; protocol)
101 {
102     StringBuilder builder;
103     for (size_t i = 0; i &lt; protocol.length(); i++) {
104         if (protocol[i] &lt; 0x20 || protocol[i] &gt; 0x7E) {
105             builder.appendLiteral(&quot;\\u&quot;);
106             builder.append(hex(protocol[i], 4));
107         } else if (protocol[i] == 0x5c)
108             builder.appendLiteral(&quot;\\\\&quot;);
109         else
110             builder.append(protocol[i]);
111     }
112     return builder.toString();
113 }
114 
115 static String joinStrings(const Vector&lt;String&gt;&amp; strings, const char* separator)
116 {
117     StringBuilder builder;
118     for (size_t i = 0; i &lt; strings.size(); ++i) {
119         if (i)
120             builder.append(separator);
121         builder.append(strings[i]);
122     }
123     return builder.toString();
124 }
125 
126 static unsigned saturateAdd(unsigned a, unsigned b)
127 {
128     if (std::numeric_limits&lt;unsigned&gt;::max() - a &lt; b)
129         return std::numeric_limits&lt;unsigned&gt;::max();
130     return a + b;
131 }
132 
133 const char* WebSocket::subprotocolSeparator()
134 {
135     return &quot;, &quot;;
136 }
137 
138 WebSocket::WebSocket(ScriptExecutionContext&amp; context)
139     : ActiveDOMObject(&amp;context)
140     , m_subprotocol(emptyString())
141     , m_extensions(emptyString())
142     , m_resumeTimer(*this, &amp;WebSocket::resumeTimerFired)
143 {
144     LockHolder lock(allActiveWebSocketsMutex());
145 
146     allActiveWebSockets(lock).add(this);
147 }
148 
149 WebSocket::~WebSocket()
150 {
151     {
152         LockHolder lock(allActiveWebSocketsMutex());
153 
154         allActiveWebSockets(lock).remove(this);
155     }
156 
157     if (m_channel)
158         m_channel-&gt;disconnect();
159 }
160 
161 ExceptionOr&lt;Ref&lt;WebSocket&gt;&gt; WebSocket::create(ScriptExecutionContext&amp; context, const String&amp; url)
162 {
163     return create(context, url, Vector&lt;String&gt; { });
164 }
165 
166 ExceptionOr&lt;Ref&lt;WebSocket&gt;&gt; WebSocket::create(ScriptExecutionContext&amp; context, const String&amp; url, const Vector&lt;String&gt;&amp; protocols)
167 {
168     if (url.isNull())
169         return Exception { SyntaxError };
170 
171     auto socket = adoptRef(*new WebSocket(context));
172     socket-&gt;suspendIfNeeded();
173 
174     auto result = socket-&gt;connect(context.completeURL(url), protocols);
175     if (result.hasException())
176         return result.releaseException();
177 
178     return socket;
179 }
180 
181 ExceptionOr&lt;Ref&lt;WebSocket&gt;&gt; WebSocket::create(ScriptExecutionContext&amp; context, const String&amp; url, const String&amp; protocol)
182 {
183     return create(context, url, Vector&lt;String&gt; { 1, protocol });
184 }
185 
186 HashSet&lt;WebSocket*&gt;&amp; WebSocket::allActiveWebSockets(const LockHolder&amp;)
187 {
188     static NeverDestroyed&lt;HashSet&lt;WebSocket*&gt;&gt; activeWebSockets;
189     return activeWebSockets;
190 }
191 
192 Lock&amp; WebSocket::allActiveWebSocketsMutex()
193 {
194     static Lock mutex;
195     return mutex;
196 }
197 
198 ExceptionOr&lt;void&gt; WebSocket::connect(const String&amp; url)
199 {
200     return connect(url, Vector&lt;String&gt; { });
201 }
202 
203 ExceptionOr&lt;void&gt; WebSocket::connect(const String&amp; url, const String&amp; protocol)
204 {
205     return connect(url, Vector&lt;String&gt; { 1, protocol });
206 }
207 
208 void WebSocket::failAsynchronously()
209 {
210     m_pendingActivity = makePendingActivity(*this);
211 
212     // We must block this connection. Instead of throwing an exception, we indicate this
213     // using the error event. But since this code executes as part of the WebSocket&#39;s
214     // constructor, we have to wait until the constructor has completed before firing the
215     // event; otherwise, users can&#39;t connect to the event.
216 
217     scriptExecutionContext()-&gt;postTask([this, protectedThis = makeRef(*this)](auto&amp;) {
218         this-&gt;dispatchOrQueueErrorEvent();
219         this-&gt;stop();
220     });
221 }
222 
223 ExceptionOr&lt;void&gt; WebSocket::connect(const String&amp; url, const Vector&lt;String&gt;&amp; protocols)
224 {
225     LOG(Network, &quot;WebSocket %p connect() url=&#39;%s&#39;&quot;, this, url.utf8().data());
226     m_url = URL(URL(), url);
227 
228     ASSERT(scriptExecutionContext());
229     auto&amp; context = *scriptExecutionContext();
230 
231     if (!m_url.isValid()) {
232         context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Invalid url for WebSocket &quot; + m_url.stringCenterEllipsizedToLength());
233         m_state = CLOSED;
234         return Exception { SyntaxError };
235     }
236 
237     if (!m_url.protocolIs(&quot;ws&quot;) &amp;&amp; !m_url.protocolIs(&quot;wss&quot;)) {
238         context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Wrong url scheme for WebSocket &quot; + m_url.stringCenterEllipsizedToLength());
239         m_state = CLOSED;
240         return Exception { SyntaxError };
241     }
242     if (m_url.hasFragmentIdentifier()) {
243         context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;URL has fragment component &quot; + m_url.stringCenterEllipsizedToLength());
244         m_state = CLOSED;
245         return Exception { SyntaxError };
246     }
247 
248     ASSERT(context.contentSecurityPolicy());
249     auto&amp; contentSecurityPolicy = *context.contentSecurityPolicy();
250 
251     contentSecurityPolicy.upgradeInsecureRequestIfNeeded(m_url, ContentSecurityPolicy::InsecureRequestType::Load);
252 
253     if (!portAllowed(m_url)) {
254         String message;
255         if (m_url.port())
256             message = makeString(&quot;WebSocket port &quot;, static_cast&lt;unsigned&gt;(m_url.port().value()), &quot; blocked&quot;);
257         else
258             message = &quot;WebSocket without port blocked&quot;_s;
259         context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, message);
260         m_state = CLOSED;
261         return Exception { SecurityError };
262     }
263 
264     // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
265     if (!context.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !contentSecurityPolicy.allowConnectToSource(m_url)) {
266         m_state = CLOSED;
267 
268         // FIXME: Should this be throwing an exception?
269         return Exception { SecurityError };
270     }
271 
272     if (auto* provider = context.socketProvider())
273         m_channel = ThreadableWebSocketChannel::create(*scriptExecutionContext(), *this, *provider);
274 
275     // Every ScriptExecutionContext should have a SocketProvider.
276     RELEASE_ASSERT(m_channel);
277 
278     // FIXME: There is a disagreement about restriction of subprotocols between WebSocket API and hybi-10 protocol
279     // draft. The former simply says &quot;only characters in the range U+0021 to U+007E are allowed,&quot; while the latter
280     // imposes a stricter rule: &quot;the elements MUST be non-empty strings with characters as defined in [RFC2616],
281     // and MUST all be unique strings.&quot;
282     //
283     // Here, we throw SyntaxError if the given protocols do not meet the latter criteria. This behavior does not
284     // comply with WebSocket API specification, but it seems to be the only reasonable way to handle this conflict.
285     for (auto&amp; protocol : protocols) {
286         if (!isValidProtocolString(protocol)) {
287             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;Wrong protocol for WebSocket &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
288             m_state = CLOSED;
289             return Exception { SyntaxError };
290         }
291     }
292     HashSet&lt;String&gt; visited;
293     for (auto&amp; protocol : protocols) {
294         if (!visited.add(protocol).isNewEntry) {
295             context.addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;WebSocket protocols contain duplicates: &#39;&quot; + encodeProtocolString(protocol) + &quot;&#39;&quot;);
296             m_state = CLOSED;
297             return Exception { SyntaxError };
298         }
299     }
300 
301     RunLoop::main().dispatch([targetURL = m_url.isolatedCopy(), mainFrameURL = context.url().isolatedCopy()]() {
302         ResourceLoadObserver::shared().logWebSocketLoading(targetURL, mainFrameURL);
303     });
304 
305     if (is&lt;Document&gt;(context)) {
306         Document&amp; document = downcast&lt;Document&gt;(context);
307         RefPtr&lt;Frame&gt; frame = document.frame();
308         // FIXME: make the mixed content check equivalent to the non-document mixed content check currently in WorkerThreadableWebSocketChannel::Bridge::connect()
309         if (!frame || !frame-&gt;loader().mixedContentChecker().canRunInsecureContent(document.securityOrigin(), m_url)) {
310             failAsynchronously();
311             return { };
312         }
313     }
314 
315     String protocolString;
316     if (!protocols.isEmpty())
317         protocolString = joinStrings(protocols, subprotocolSeparator());
318 
319     if (m_channel-&gt;connect(m_url, protocolString) == ThreadableWebSocketChannel::ConnectStatus::KO) {
320         failAsynchronously();
321         return { };
322     }
323 
324     m_pendingActivity = makePendingActivity(*this);
325 
326     return { };
327 }
328 
329 ExceptionOr&lt;void&gt; WebSocket::send(const String&amp; message)
330 {
331     LOG(Network, &quot;WebSocket %p send() Sending String &#39;%s&#39;&quot;, this, message.utf8().data());
332     if (m_state == CONNECTING)
333         return Exception { InvalidStateError };
334     // No exception is raised if the connection was once established but has subsequently been closed.
335     if (m_state == CLOSING || m_state == CLOSED) {
336         size_t payloadSize = message.utf8().length();
337         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, payloadSize);
338         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, getFramingOverhead(payloadSize));
339         return { };
340     }
341     ASSERT(m_channel);
342     m_channel-&gt;send(message);
343     return { };
344 }
345 
346 ExceptionOr&lt;void&gt; WebSocket::send(ArrayBuffer&amp; binaryData)
347 {
348     LOG(Network, &quot;WebSocket %p send() Sending ArrayBuffer %p&quot;, this, &amp;binaryData);
349     if (m_state == CONNECTING)
350         return Exception { InvalidStateError };
351     if (m_state == CLOSING || m_state == CLOSED) {
352         unsigned payloadSize = binaryData.byteLength();
353         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, payloadSize);
354         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, getFramingOverhead(payloadSize));
355         return { };
356     }
357     ASSERT(m_channel);
358     m_channel-&gt;send(binaryData, 0, binaryData.byteLength());
359     return { };
360 }
361 
362 ExceptionOr&lt;void&gt; WebSocket::send(ArrayBufferView&amp; arrayBufferView)
363 {
364     LOG(Network, &quot;WebSocket %p send() Sending ArrayBufferView %p&quot;, this, &amp;arrayBufferView);
365 
366     if (m_state == CONNECTING)
367         return Exception { InvalidStateError };
368     if (m_state == CLOSING || m_state == CLOSED) {
369         unsigned payloadSize = arrayBufferView.byteLength();
370         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, payloadSize);
371         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, getFramingOverhead(payloadSize));
372         return { };
373     }
374     ASSERT(m_channel);
375     m_channel-&gt;send(*arrayBufferView.unsharedBuffer(), arrayBufferView.byteOffset(), arrayBufferView.byteLength());
376     return { };
377 }
378 
379 ExceptionOr&lt;void&gt; WebSocket::send(Blob&amp; binaryData)
380 {
381     LOG(Network, &quot;WebSocket %p send() Sending Blob &#39;%s&#39;&quot;, this, binaryData.url().stringCenterEllipsizedToLength().utf8().data());
382     if (m_state == CONNECTING)
383         return Exception { InvalidStateError };
384     if (m_state == CLOSING || m_state == CLOSED) {
385         unsigned payloadSize = static_cast&lt;unsigned&gt;(binaryData.size());
386         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, payloadSize);
387         m_bufferedAmountAfterClose = saturateAdd(m_bufferedAmountAfterClose, getFramingOverhead(payloadSize));
388         return { };
389     }
390     ASSERT(m_channel);
391     m_channel-&gt;send(binaryData);
392     return { };
393 }
394 
395 ExceptionOr&lt;void&gt; WebSocket::close(Optional&lt;unsigned short&gt; optionalCode, const String&amp; reason)
396 {
397     int code = optionalCode ? optionalCode.value() : static_cast&lt;int&gt;(WebSocketChannel::CloseEventCodeNotSpecified);
398     if (code == WebSocketChannel::CloseEventCodeNotSpecified)
399         LOG(Network, &quot;WebSocket %p close() without code and reason&quot;, this);
400     else {
401         LOG(Network, &quot;WebSocket %p close() code=%d reason=&#39;%s&#39;&quot;, this, code, reason.utf8().data());
402         if (!(code == WebSocketChannel::CloseEventCodeNormalClosure || (WebSocketChannel::CloseEventCodeMinimumUserDefined &lt;= code &amp;&amp; code &lt;= WebSocketChannel::CloseEventCodeMaximumUserDefined)))
403             return Exception { InvalidAccessError };
404         CString utf8 = reason.utf8(StrictConversionReplacingUnpairedSurrogatesWithFFFD);
405         if (utf8.length() &gt; maxReasonSizeInBytes) {
406             scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;WebSocket close message is too long.&quot;_s);
407             return Exception { SyntaxError };
408         }
409     }
410 
411     if (m_state == CLOSING || m_state == CLOSED)
412         return { };
413     if (m_state == CONNECTING) {
414         m_state = CLOSING;
415         m_channel-&gt;fail(&quot;WebSocket is closed before the connection is established.&quot;);
416         return { };
417     }
418     m_state = CLOSING;
419     if (m_channel)
420         m_channel-&gt;close(code, reason);
421     return { };
422 }
423 
424 RefPtr&lt;ThreadableWebSocketChannel&gt; WebSocket::channel() const
425 {
426     return m_channel;
427 }
428 
429 const URL&amp; WebSocket::url() const
430 {
431     return m_url;
432 }
433 
434 WebSocket::State WebSocket::readyState() const
435 {
436     return m_state;
437 }
438 
439 unsigned WebSocket::bufferedAmount() const
440 {
441     return saturateAdd(m_bufferedAmount, m_bufferedAmountAfterClose);
442 }
443 
444 String WebSocket::protocol() const
445 {
446     return m_subprotocol;
447 }
448 
449 String WebSocket::extensions() const
450 {
451     return m_extensions;
452 }
453 
454 String WebSocket::binaryType() const
455 {
456     switch (m_binaryType) {
457     case BinaryType::Blob:
458         return &quot;blob&quot;_s;
459     case BinaryType::ArrayBuffer:
460         return &quot;arraybuffer&quot;_s;
461     }
462     ASSERT_NOT_REACHED();
463     return String();
464 }
465 
466 ExceptionOr&lt;void&gt; WebSocket::setBinaryType(const String&amp; binaryType)
467 {
468     if (binaryType == &quot;blob&quot;) {
469         m_binaryType = BinaryType::Blob;
470         return { };
471     }
472     if (binaryType == &quot;arraybuffer&quot;) {
473         m_binaryType = BinaryType::ArrayBuffer;
474         return { };
475     }
476     scriptExecutionContext()-&gt;addConsoleMessage(MessageSource::JS, MessageLevel::Error, &quot;&#39;&quot; + binaryType + &quot;&#39; is not a valid value for binaryType; binaryType remains unchanged.&quot;);
477     return Exception { SyntaxError };
478 }
479 
480 EventTargetInterface WebSocket::eventTargetInterface() const
481 {
482     return WebSocketEventTargetInterfaceType;
483 }
484 
485 ScriptExecutionContext* WebSocket::scriptExecutionContext() const
486 {
487     return ActiveDOMObject::scriptExecutionContext();
488 }
489 
490 void WebSocket::contextDestroyed()
491 {
492     LOG(Network, &quot;WebSocket %p contextDestroyed()&quot;, this);
493     ASSERT(!m_channel);
494     ASSERT(m_state == CLOSED);
495     ActiveDOMObject::contextDestroyed();
496 }
497 
498 void WebSocket::suspend(ReasonForSuspension reason)
499 {
500     if (m_resumeTimer.isActive())
501         m_resumeTimer.stop();
502 
503     m_shouldDelayEventFiring = true;
504 
505     if (m_channel) {
506         if (reason == ReasonForSuspension::BackForwardCache) {
507             // This will cause didClose() to be called.
508             m_channel-&gt;fail(&quot;WebSocket is closed due to suspension.&quot;);
509         } else
510             m_channel-&gt;suspend();
511     }
512 }
513 
514 void WebSocket::resume()
515 {
516     if (m_channel)
517         m_channel-&gt;resume();
518     else if (!m_pendingEvents.isEmpty() &amp;&amp; !m_resumeTimer.isActive()) {
519         // Fire the pending events in a timer as we are not allowed to execute arbitrary JS from resume().
520         m_resumeTimer.startOneShot(0_s);
521     }
522 
523     m_shouldDelayEventFiring = false;
524 }
525 
526 void WebSocket::resumeTimerFired()
527 {
528     Ref&lt;WebSocket&gt; protectedThis(*this);
529 
530     ASSERT(!m_pendingEvents.isEmpty());
531 
532     // Check m_shouldDelayEventFiring when iterating in case firing an event causes
533     // suspend() to be called.
534     while (!m_pendingEvents.isEmpty() &amp;&amp; !m_shouldDelayEventFiring)
535         dispatchEvent(m_pendingEvents.takeFirst());
536 }
537 
538 void WebSocket::stop()
539 {
540     if (m_channel)
541         m_channel-&gt;disconnect();
542     m_channel = nullptr;
543     m_state = CLOSED;
544     m_pendingEvents.clear();
545     ActiveDOMObject::stop();
546     m_pendingActivity = nullptr;
547 }
548 
549 const char* WebSocket::activeDOMObjectName() const
550 {
551     return &quot;WebSocket&quot;;
552 }
553 
554 void WebSocket::didConnect()
555 {
556     LOG(Network, &quot;WebSocket %p didConnect()&quot;, this);
557     if (m_state != CONNECTING) {
558         didClose(0, ClosingHandshakeIncomplete, WebSocketChannel::CloseEventCodeAbnormalClosure, emptyString());
559         return;
560     }
561     ASSERT(scriptExecutionContext());
562     m_state = OPEN;
563     m_subprotocol = m_channel-&gt;subprotocol();
564     m_extensions = m_channel-&gt;extensions();
565     dispatchEvent(Event::create(eventNames().openEvent, Event::CanBubble::No, Event::IsCancelable::No));
566 }
567 
568 void WebSocket::didReceiveMessage(const String&amp; msg)
569 {
570     LOG(Network, &quot;WebSocket %p didReceiveMessage() Text message &#39;%s&#39;&quot;, this, msg.utf8().data());
571     if (m_state != OPEN)
572         return;
573     ASSERT(scriptExecutionContext());
574     dispatchEvent(MessageEvent::create(msg, SecurityOrigin::create(m_url)-&gt;toString()));
575 }
576 
577 void WebSocket::didReceiveBinaryData(Vector&lt;uint8_t&gt;&amp;&amp; binaryData)
578 {
579     LOG(Network, &quot;WebSocket %p didReceiveBinaryData() %u byte binary message&quot;, this, static_cast&lt;unsigned&gt;(binaryData.size()));
580     switch (m_binaryType) {
581     case BinaryType::Blob:
582         // FIXME: We just received the data from NetworkProcess, and are sending it back. This is inefficient.
583         dispatchEvent(MessageEvent::create(Blob::create(WTFMove(binaryData), emptyString()), SecurityOrigin::create(m_url)-&gt;toString()));
584         break;
585     case BinaryType::ArrayBuffer:
586         dispatchEvent(MessageEvent::create(ArrayBuffer::create(binaryData.data(), binaryData.size()), SecurityOrigin::create(m_url)-&gt;toString()));
587         break;
588     }
589 }
590 
591 void WebSocket::didReceiveMessageError()
592 {
593     LOG(Network, &quot;WebSocket %p didReceiveErrorMessage()&quot;, this);
594     m_state = CLOSED;
595     ASSERT(scriptExecutionContext());
596     dispatchOrQueueErrorEvent();
597 }
598 
599 void WebSocket::didUpdateBufferedAmount(unsigned bufferedAmount)
600 {
601     LOG(Network, &quot;WebSocket %p didUpdateBufferedAmount() New bufferedAmount is %u&quot;, this, bufferedAmount);
602     if (m_state == CLOSED)
603         return;
604     m_bufferedAmount = bufferedAmount;
605 }
606 
607 void WebSocket::didStartClosingHandshake()
608 {
609     LOG(Network, &quot;WebSocket %p didStartClosingHandshake()&quot;, this);
610     m_state = CLOSING;
611 }
612 
613 void WebSocket::didClose(unsigned unhandledBufferedAmount, ClosingHandshakeCompletionStatus closingHandshakeCompletion, unsigned short code, const String&amp; reason)
614 {
615     LOG(Network, &quot;WebSocket %p didClose()&quot;, this);
616     if (!m_channel)
617         return;
618     bool wasClean = m_state == CLOSING &amp;&amp; !unhandledBufferedAmount &amp;&amp; closingHandshakeCompletion == ClosingHandshakeComplete &amp;&amp; code != WebSocketChannel::CloseEventCodeAbnormalClosure;
619     m_state = CLOSED;
620     m_bufferedAmount = unhandledBufferedAmount;
621     ASSERT(scriptExecutionContext());
622 
623     dispatchOrQueueEvent(CloseEvent::create(wasClean, code, reason));
624 
625     if (m_channel) {
626         m_channel-&gt;disconnect();
627         m_channel = nullptr;
628     }
629     m_pendingActivity = nullptr;
630 }
631 
632 void WebSocket::didUpgradeURL()
633 {
634     ASSERT(m_url.protocolIs(&quot;ws&quot;));
635     m_url.setProtocol(&quot;wss&quot;);
636 }
637 
638 size_t WebSocket::getFramingOverhead(size_t payloadSize)
639 {
640     static const size_t hybiBaseFramingOverhead = 2; // Every frame has at least two-byte header.
641     static const size_t hybiMaskingKeyLength = 4; // Every frame from client must have masking key.
642     static const size_t minimumPayloadSizeWithTwoByteExtendedPayloadLength = 126;
643     static const size_t minimumPayloadSizeWithEightByteExtendedPayloadLength = 0x10000;
644     size_t overhead = hybiBaseFramingOverhead + hybiMaskingKeyLength;
645     if (payloadSize &gt;= minimumPayloadSizeWithEightByteExtendedPayloadLength)
646         overhead += 8;
647     else if (payloadSize &gt;= minimumPayloadSizeWithTwoByteExtendedPayloadLength)
648         overhead += 2;
649     return overhead;
650 }
651 
652 void WebSocket::dispatchOrQueueErrorEvent()
653 {
654     if (m_dispatchedErrorEvent)
655         return;
656 
657     m_dispatchedErrorEvent = true;
658     dispatchOrQueueEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
659 }
660 
661 void WebSocket::dispatchOrQueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
662 {
663     if (m_shouldDelayEventFiring)
664         m_pendingEvents.append(WTFMove(event));
665     else
666         dispatchEvent(event);
667 }
668 
669 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2009, 2011 Google Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;WorkerGlobalScope.h&quot;
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;CSSValueList.h&quot;</span>
<span class="line-added"> 32 #include &quot;CSSValuePool.h&quot;</span>
 33 #include &quot;ContentSecurityPolicy.h&quot;
 34 #include &quot;Crypto.h&quot;
 35 #include &quot;IDBConnectionProxy.h&quot;
 36 #include &quot;ImageBitmapOptions.h&quot;
 37 #include &quot;InspectorInstrumentation.h&quot;
<a name="2" id="anc2"></a>
 38 #include &quot;Performance.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScheduledAction.h&quot;
 41 #include &quot;ScriptSourceCode.h&quot;
 42 #include &quot;SecurityOrigin.h&quot;
 43 #include &quot;SecurityOriginPolicy.h&quot;
 44 #include &quot;ServiceWorkerGlobalScope.h&quot;
 45 #include &quot;SocketProvider.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 46 #include &quot;WorkerEventLoop.h&quot;</span>
 47 #include &quot;WorkerInspectorController.h&quot;
 48 #include &quot;WorkerLoaderProxy.h&quot;
 49 #include &quot;WorkerLocation.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 50 #include &quot;WorkerMessagingProxy.h&quot;</span>
 51 #include &quot;WorkerNavigator.h&quot;
 52 #include &quot;WorkerReportingProxy.h&quot;
<a name="5" id="anc5"></a><span class="line-added"> 53 #include &quot;WorkerSWClientConnection.h&quot;</span>
 54 #include &quot;WorkerScriptLoader.h&quot;
 55 #include &quot;WorkerThread.h&quot;
 56 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 57 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 
 60 namespace WebCore {
 61 using namespace Inspector;
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(WorkerGlobalScope);
 64 
<a name="6" id="anc6"></a><span class="line-modified"> 65 WorkerGlobalScope::WorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, WorkerThread&amp; thread, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy* connectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 66     : m_url(params.scriptURL)</span>
<span class="line-modified"> 67     , m_identifier(params.identifier)</span>
<span class="line-modified"> 68     , m_userAgent(params.userAgent)</span>
 69     , m_thread(thread)
 70     , m_script(makeUnique&lt;WorkerScriptController&gt;(this))
 71     , m_inspectorController(makeUnique&lt;WorkerInspectorController&gt;(*this))
<a name="7" id="anc7"></a><span class="line-modified"> 72     , m_isOnline(params.isOnline)</span>
<span class="line-modified"> 73     , m_shouldBypassMainWorldContentSecurityPolicy(params.shouldBypassMainWorldContentSecurityPolicy)</span>


 74     , m_topOrigin(WTFMove(topOrigin))
 75 #if ENABLE(INDEXED_DATABASE)
 76     , m_connectionProxy(connectionProxy)
 77 #endif
 78     , m_socketProvider(socketProvider)
<a name="8" id="anc8"></a><span class="line-modified"> 79     , m_performance(Performance::create(this, params.timeOrigin))</span>
<span class="line-modified"> 80     , m_referrerPolicy(params.referrerPolicy)</span>
 81 {
 82 #if !ENABLE(INDEXED_DATABASE)
 83     UNUSED_PARAM(connectionProxy);
 84 #endif
 85 
 86     if (m_topOrigin-&gt;hasUniversalAccess())
 87         origin-&gt;grantUniversalAccess();
 88     if (m_topOrigin-&gt;needsStorageAccessFromFileURLsQuirk())
 89         origin-&gt;grantStorageAccessFromFileURLsQuirk();
 90 
 91     setSecurityOriginPolicy(SecurityOriginPolicy::create(WTFMove(origin)));
 92     setContentSecurityPolicy(makeUnique&lt;ContentSecurityPolicy&gt;(URL { m_url }, *this));
 93 }
 94 
 95 WorkerGlobalScope::~WorkerGlobalScope()
 96 {
 97     ASSERT(thread().thread() == &amp;Thread::current());
 98     // We need to remove from the contexts map very early in the destructor so that calling postTask() on this WorkerGlobalScope from another thread is safe.
 99     removeFromContextsMap();
100 
101     m_performance = nullptr;
102     m_crypto = nullptr;
103 
104     // Notify proxy that we are going away. This can free the WorkerThread object, so do not access it after this.
105     thread().workerReportingProxy().workerGlobalScopeDestroyed();
106 }
107 
<a name="9" id="anc9"></a><span class="line-added">108 EventLoopTaskGroup&amp; WorkerGlobalScope::eventLoop()</span>
<span class="line-added">109 {</span>
<span class="line-added">110     ASSERT(isContextThread());</span>
<span class="line-added">111     if (UNLIKELY(!m_defaultTaskGroup)) {</span>
<span class="line-added">112         m_eventLoop = WorkerEventLoop::create(*this);</span>
<span class="line-added">113         m_defaultTaskGroup = makeUnique&lt;EventLoopTaskGroup&gt;(*m_eventLoop);</span>
<span class="line-added">114         if (activeDOMObjectsAreStopped())</span>
<span class="line-added">115             m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();</span>
<span class="line-added">116     }</span>
<span class="line-added">117     return *m_defaultTaskGroup;</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
120 String WorkerGlobalScope::origin() const
121 {
122     auto* securityOrigin = this-&gt;securityOrigin();
123     return securityOrigin ? securityOrigin-&gt;toString() : emptyString();
124 }
125 
126 void WorkerGlobalScope::prepareForTermination()
127 {
128 #if ENABLE(INDEXED_DATABASE)
129     stopIndexedDatabase();
130 #endif
131 
<a name="10" id="anc10"></a><span class="line-added">132     if (m_defaultTaskGroup)</span>
<span class="line-added">133         m_defaultTaskGroup-&gt;stopAndDiscardAllTasks();</span>
134     stopActiveDOMObjects();
135 
136     if (m_cacheStorageConnection)
137         m_cacheStorageConnection-&gt;clearPendingRequests();
138 
139     m_inspectorController-&gt;workerTerminating();
140 
141     // Event listeners would keep DOMWrapperWorld objects alive for too long. Also, they have references to JS objects,
142     // which become dangling once Heap is destroyed.
143     removeAllEventListeners();
144 
145     // MicrotaskQueue and RejectedPromiseTracker reference Heap.
<a name="11" id="anc11"></a><span class="line-modified">146     if (m_eventLoop)</span>
<span class="line-added">147         m_eventLoop-&gt;clearMicrotaskQueue();</span>
148     removeRejectedPromiseTracker();
149 }
150 
151 void WorkerGlobalScope::removeAllEventListeners()
152 {
153     EventTarget::removeAllEventListeners();
154     m_performance-&gt;removeAllEventListeners();
155     m_performance-&gt;removeAllObservers();
156 }
157 
158 bool WorkerGlobalScope::isSecureContext() const
159 {
160     if (!RuntimeEnabledFeatures::sharedFeatures().secureContextChecksEnabled())
161         return true;
162 
163     return securityOrigin() &amp;&amp; securityOrigin()-&gt;isPotentiallyTrustworthy();
164 }
165 
166 void WorkerGlobalScope::applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders)
167 {
168     contentSecurityPolicy()-&gt;didReceiveHeaders(contentSecurityPolicyResponseHeaders, String { });
169 }
170 
<a name="12" id="anc12"></a><span class="line-modified">171 URL WorkerGlobalScope::completeURL(const String&amp; url, ForceUTF8) const</span>
172 {
173     // Always return a null URL when passed a null string.
174     // FIXME: Should we change the URL constructor to have this behavior?
175     if (url.isNull())
176         return URL();
177     // Always use UTF-8 in Workers.
178     return URL(m_url, url);
179 }
180 
181 String WorkerGlobalScope::userAgent(const URL&amp;) const
182 {
183     return m_userAgent;
184 }
185 
186 void WorkerGlobalScope::disableEval(const String&amp; errorMessage)
187 {
188     m_script-&gt;disableEval(errorMessage);
189 }
190 
191 void WorkerGlobalScope::disableWebAssembly(const String&amp; errorMessage)
192 {
193     m_script-&gt;disableWebAssembly(errorMessage);
194 }
195 
196 SocketProvider* WorkerGlobalScope::socketProvider()
197 {
198     return m_socketProvider.get();
199 }
200 
201 #if ENABLE(INDEXED_DATABASE)
202 
203 IDBClient::IDBConnectionProxy* WorkerGlobalScope::idbConnectionProxy()
204 {
205 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
206     return m_connectionProxy.get();
207 #else
208     return nullptr;
209 #endif
210 }
211 
212 void WorkerGlobalScope::stopIndexedDatabase()
213 {
214 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)
215     if (m_connectionProxy)
216         m_connectionProxy-&gt;forgetActivityForCurrentThread();
217 #endif
218 }
219 
<a name="13" id="anc13"></a><span class="line-added">220 void WorkerGlobalScope::suspend()</span>
<span class="line-added">221 {</span>
<span class="line-added">222 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)</span>
<span class="line-added">223     if (m_connectionProxy)</span>
<span class="line-added">224         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), true);</span>
<span class="line-added">225 #endif</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void WorkerGlobalScope::resume()</span>
<span class="line-added">229 {</span>
<span class="line-added">230 #if ENABLE(INDEXED_DATABASE_IN_WORKERS)</span>
<span class="line-added">231     if (m_connectionProxy)</span>
<span class="line-added">232         m_connectionProxy-&gt;setContextSuspended(*scriptExecutionContext(), false);</span>
<span class="line-added">233 #endif</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
236 #endif // ENABLE(INDEXED_DATABASE)
237 
238 WorkerLocation&amp; WorkerGlobalScope::location() const
239 {
240     if (!m_location)
241         m_location = WorkerLocation::create(m_url);
242     return *m_location;
243 }
244 
245 void WorkerGlobalScope::close()
246 {
247     if (m_closing)
248         return;
249 
250     // Let current script run to completion but prevent future script evaluations.
251     // After m_closing is set, all the tasks in the queue continue to be fetched but only
252     // tasks with isCleanupTask()==true will be executed.
253     m_closing = true;
254     postTask({ ScriptExecutionContext::Task::CleanupTask, [] (ScriptExecutionContext&amp; context) {
255         ASSERT_WITH_SECURITY_IMPLICATION(is&lt;WorkerGlobalScope&gt;(context));
256         WorkerGlobalScope&amp; workerGlobalScope = downcast&lt;WorkerGlobalScope&gt;(context);
257         // Notify parent that this context is closed. Parent is responsible for calling WorkerThread::stop().
258         workerGlobalScope.thread().workerReportingProxy().workerGlobalScopeClosed();
259     } });
260 }
261 
262 WorkerNavigator&amp; WorkerGlobalScope::navigator()
263 {
264     if (!m_navigator)
265         m_navigator = WorkerNavigator::create(*this, m_userAgent, m_isOnline);
266     return *m_navigator;
267 }
268 
269 void WorkerGlobalScope::setIsOnline(bool isOnline)
270 {
271     m_isOnline = isOnline;
272     if (m_navigator)
273         m_navigator-&gt;setIsOnline(isOnline);
274 }
275 
276 void WorkerGlobalScope::postTask(Task&amp;&amp; task)
277 {
278     thread().runLoop().postTask(WTFMove(task));
279 }
280 
<a name="14" id="anc14"></a><span class="line-modified">281 ExceptionOr&lt;int&gt; WorkerGlobalScope::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
282 {
283     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
284     if (action-&gt;type() == ScheduledAction::Type::Code) {
285         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
286             return 0;
287     }
288 
289     action-&gt;addArguments(WTFMove(arguments));
290 
291     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), true);
292 }
293 
294 void WorkerGlobalScope::clearTimeout(int timeoutId)
295 {
296     DOMTimer::removeById(*this, timeoutId);
297 }
298 
<a name="15" id="anc15"></a><span class="line-modified">299 ExceptionOr&lt;int&gt; WorkerGlobalScope::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
300 {
301     // FIXME: Should this check really happen here? Or should it happen when code is about to eval?
302     if (action-&gt;type() == ScheduledAction::Type::Code) {
303         if (!contentSecurityPolicy()-&gt;allowEval(&amp;state))
304             return 0;
305     }
306 
307     action-&gt;addArguments(WTFMove(arguments));
308 
309     return DOMTimer::install(*this, WTFMove(action), Seconds::fromMilliseconds(timeout), false);
310 }
311 
312 void WorkerGlobalScope::clearInterval(int timeoutId)
313 {
314     DOMTimer::removeById(*this, timeoutId);
315 }
316 
317 ExceptionOr&lt;void&gt; WorkerGlobalScope::importScripts(const Vector&lt;String&gt;&amp; urls)
318 {
319     ASSERT(contentSecurityPolicy());
320 
321     Vector&lt;URL&gt; completedURLs;
322     completedURLs.reserveInitialCapacity(urls.size());
323     for (auto&amp; entry : urls) {
324         URL url = completeURL(entry);
325         if (!url.isValid())
326             return Exception { SyntaxError };
327         completedURLs.uncheckedAppend(WTFMove(url));
328     }
329 
330     FetchOptions::Cache cachePolicy = FetchOptions::Cache::Default;
331 
332 #if ENABLE(SERVICE_WORKER)
333     bool isServiceWorkerGlobalScope = is&lt;ServiceWorkerGlobalScope&gt;(*this);
334     if (isServiceWorkerGlobalScope) {
335         // FIXME: We need to add support for the &#39;imported scripts updated&#39; flag as per:
336         // https://w3c.github.io/ServiceWorker/#importscripts
337         auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(*this);
338         auto&amp; registration = serviceWorkerGlobalScope.registration();
339         if (registration.updateViaCache() == ServiceWorkerUpdateViaCache::None || registration.needsUpdate())
340             cachePolicy = FetchOptions::Cache::NoCache;
341     }
342 #endif
343 
344     for (auto&amp; url : completedURLs) {
345         // FIXME: Convert this to check the isolated world&#39;s Content Security Policy once webkit.org/b/104520 is solved.
346         bool shouldBypassMainWorldContentSecurityPolicy = this-&gt;shouldBypassMainWorldContentSecurityPolicy();
347         if (!shouldBypassMainWorldContentSecurityPolicy &amp;&amp; !contentSecurityPolicy()-&gt;allowScriptFromSource(url))
348             return Exception { NetworkError };
349 
350         auto scriptLoader = WorkerScriptLoader::create();
351         auto cspEnforcement = shouldBypassMainWorldContentSecurityPolicy ? ContentSecurityPolicyEnforcement::DoNotEnforce : ContentSecurityPolicyEnforcement::EnforceScriptSrcDirective;
352         if (auto exception = scriptLoader-&gt;loadSynchronously(this, url, FetchOptions::Mode::NoCors, cachePolicy, cspEnforcement, resourceRequestIdentifier()))
353             return WTFMove(*exception);
354 
355         InspectorInstrumentation::scriptImported(*this, scriptLoader-&gt;identifier(), scriptLoader-&gt;script());
356 
357         NakedPtr&lt;JSC::Exception&gt; exception;
358         m_script-&gt;evaluate(ScriptSourceCode(scriptLoader-&gt;script(), URL(scriptLoader-&gt;responseURL())), exception);
359         if (exception) {
360             m_script-&gt;setException(exception);
361             return { };
362         }
363     }
364 
365     return { };
366 }
367 
368 EventTarget* WorkerGlobalScope::errorEventTarget()
369 {
370     return this;
371 }
372 
373 void WorkerGlobalScope::logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp;)
374 {
375     thread().workerReportingProxy().postExceptionToWorkerObject(errorMessage, lineNumber, columnNumber, sourceURL);
376 }
377 
378 void WorkerGlobalScope::addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; message)
379 {
380     if (!isContextThread()) {
381         postTask(AddConsoleMessageTask(message-&gt;source(), message-&gt;level(), message-&gt;message()));
382         return;
383     }
384 
385     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
386 }
387 
388 void WorkerGlobalScope::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier)
389 {
390     addMessage(source, level, message, { }, 0, 0, nullptr, nullptr, requestIdentifier);
391 }
392 
<a name="16" id="anc16"></a><span class="line-modified">393 void WorkerGlobalScope::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* state, unsigned long requestIdentifier)</span>
394 {
395     if (!isContextThread()) {
396         postTask(AddConsoleMessageTask(source, level, messageText));
397         return;
398     }
399 
400     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
401     if (callStack)
402         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
403     else
404         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, sourceURL, lineNumber, columnNumber, state, requestIdentifier);
405     InspectorInstrumentation::addMessageToConsole(*this, WTFMove(message));
406 }
407 
408 bool WorkerGlobalScope::isContextThread() const
409 {
410     return thread().thread() == &amp;Thread::current();
411 }
412 
413 bool WorkerGlobalScope::isJSExecutionForbidden() const
414 {
415     return m_script-&gt;isExecutionForbidden();
416 }
417 
<a name="17" id="anc17"></a>




418 #if ENABLE(WEB_CRYPTO)
419 
420 class CryptoBufferContainer : public ThreadSafeRefCounted&lt;CryptoBufferContainer&gt; {
421 public:
422     static Ref&lt;CryptoBufferContainer&gt; create() { return adoptRef(*new CryptoBufferContainer); }
423     Vector&lt;uint8_t&gt;&amp; buffer() { return m_buffer; }
424 
425 private:
426     Vector&lt;uint8_t&gt; m_buffer;
427 };
428 
<a name="18" id="anc18"></a><span class="line-added">429 class CryptoBooleanContainer : public ThreadSafeRefCounted&lt;CryptoBooleanContainer&gt; {</span>
<span class="line-added">430 public:</span>
<span class="line-added">431     static Ref&lt;CryptoBooleanContainer&gt; create() { return adoptRef(*new CryptoBooleanContainer); }</span>
<span class="line-added">432     bool boolean() const { return m_boolean; }</span>
<span class="line-added">433     void setBoolean(bool boolean) { m_boolean = boolean; }</span>
<span class="line-added">434 </span>
<span class="line-added">435 private:</span>
<span class="line-added">436     std::atomic&lt;bool&gt; m_boolean { false };</span>
<span class="line-added">437 };</span>
<span class="line-added">438 </span>
439 bool WorkerGlobalScope::wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey)
440 {
<a name="19" id="anc19"></a><span class="line-modified">441     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);</span>
<span class="line-modified">442     auto resultContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">443     auto doneContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">444     auto wrappedKeyContainer = CryptoBufferContainer::create();</span>
<span class="line-modified">445     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), key, wrappedKeyContainer = wrappedKeyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">446         resultContainer-&gt;setBoolean(context.wrapCryptoKey(key, wrappedKeyContainer-&gt;buffer()));</span>
<span class="line-modified">447         doneContainer-&gt;setBoolean(true);</span>
<span class="line-added">448         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {</span>
449             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<a name="20" id="anc20"></a><span class="line-modified">450         }, WorkerRunLoop::defaultMode());</span>
451     });
452 
453     auto waitResult = MessageQueueMessageReceived;
<a name="21" id="anc21"></a><span class="line-modified">454     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)</span>
455         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
456 
<a name="22" id="anc22"></a><span class="line-modified">457     if (doneContainer-&gt;boolean())</span>
<span class="line-modified">458         wrappedKey.swap(wrappedKeyContainer-&gt;buffer());</span>
<span class="line-modified">459     return resultContainer-&gt;boolean();</span>
460 }
461 
462 bool WorkerGlobalScope::unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key)
463 {
<a name="23" id="anc23"></a><span class="line-modified">464     Ref&lt;WorkerGlobalScope&gt; protectedThis(*this);</span>
<span class="line-modified">465     auto resultContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">466     auto doneContainer = CryptoBooleanContainer::create();</span>
<span class="line-modified">467     auto keyContainer = CryptoBufferContainer::create();</span>
<span class="line-modified">468     m_thread.workerLoaderProxy().postTaskToLoader([resultContainer = resultContainer.copyRef(), wrappedKey, keyContainer = keyContainer.copyRef(), doneContainer = doneContainer.copyRef(), workerMessagingProxy = makeRef(downcast&lt;WorkerMessagingProxy&gt;(m_thread.workerLoaderProxy()))](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">469         resultContainer-&gt;setBoolean(context.unwrapCryptoKey(wrappedKey, keyContainer-&gt;buffer()));</span>
<span class="line-modified">470         doneContainer-&gt;setBoolean(true);</span>
<span class="line-added">471         workerMessagingProxy-&gt;postTaskForModeToWorkerGlobalScope([](ScriptExecutionContext&amp; context) {</span>
472             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
<a name="24" id="anc24"></a><span class="line-modified">473         }, WorkerRunLoop::defaultMode());</span>
474     });
475 
476     auto waitResult = MessageQueueMessageReceived;
<a name="25" id="anc25"></a><span class="line-modified">477     while (!doneContainer-&gt;boolean() &amp;&amp; waitResult != MessageQueueTerminated)</span>
478         waitResult = m_thread.runLoop().runInMode(this, WorkerRunLoop::defaultMode());
479 
<a name="26" id="anc26"></a><span class="line-modified">480     if (doneContainer-&gt;boolean())</span>
<span class="line-modified">481         key.swap(keyContainer-&gt;buffer());</span>
<span class="line-modified">482     return resultContainer-&gt;boolean();</span>
483 }
484 
485 #endif // ENABLE(WEB_CRYPTO)
486 
487 Crypto&amp; WorkerGlobalScope::crypto()
488 {
489     if (!m_crypto)
490         m_crypto = Crypto::create(this);
491     return *m_crypto;
492 }
493 
494 Performance&amp; WorkerGlobalScope::performance() const
495 {
496     return *m_performance;
497 }
498 
499 WorkerCacheStorageConnection&amp; WorkerGlobalScope::cacheStorageConnection()
500 {
501     if (!m_cacheStorageConnection)
502         m_cacheStorageConnection = WorkerCacheStorageConnection::create(*this);
503     return *m_cacheStorageConnection;
504 }
505 
<a name="27" id="anc27"></a><span class="line-added">506 MessagePortChannelProvider&amp; WorkerGlobalScope::messagePortChannelProvider()</span>
<span class="line-added">507 {</span>
<span class="line-added">508     if (!m_messagePortChannelProvider)</span>
<span class="line-added">509         m_messagePortChannelProvider = makeUnique&lt;WorkerMessagePortChannelProvider&gt;(*this);</span>
<span class="line-added">510     return *m_messagePortChannelProvider;</span>
<span class="line-added">511 }</span>
<span class="line-added">512 </span>
<span class="line-added">513 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">514 WorkerSWClientConnection&amp; WorkerGlobalScope::swClientConnection()</span>
<span class="line-added">515 {</span>
<span class="line-added">516     if (!m_swClientConnection)</span>
<span class="line-added">517         m_swClientConnection = WorkerSWClientConnection::create(*this);</span>
<span class="line-added">518     return *m_swClientConnection;</span>
<span class="line-added">519 }</span>
<span class="line-added">520 #endif</span>
<span class="line-added">521 </span>
522 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
523 {
524     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), WTFMove(promise));
525 }
526 
527 void WorkerGlobalScope::createImageBitmap(ImageBitmap::Source&amp;&amp; source, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
528 {
529     ImageBitmap::createPromise(*this, WTFMove(source), WTFMove(options), sx, sy, sw, sh, WTFMove(promise));
530 }
531 
<a name="28" id="anc28"></a><span class="line-added">532 CSSValuePool&amp; WorkerGlobalScope::cssValuePool()</span>
<span class="line-added">533 {</span>
<span class="line-added">534     if (!m_cssValuePool)</span>
<span class="line-added">535         m_cssValuePool = makeUnique&lt;CSSValuePool&gt;();</span>
<span class="line-added">536     return *m_cssValuePool;</span>
<span class="line-added">537 }</span>
<span class="line-added">538 </span>
<span class="line-added">539 ReferrerPolicy WorkerGlobalScope::referrerPolicy() const</span>
<span class="line-added">540 {</span>
<span class="line-added">541     return m_referrerPolicy;</span>
<span class="line-added">542 }</span>
<span class="line-added">543 </span>
544 } // namespace WebCore
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
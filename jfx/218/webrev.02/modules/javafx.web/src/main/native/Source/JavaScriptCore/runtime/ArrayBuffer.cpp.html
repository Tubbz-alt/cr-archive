<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ArrayBuffer.h&quot;
 28 
 29 #include &quot;JSArrayBufferView.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &lt;wtf/Gigacage.h&gt;
 32 
 33 namespace JSC {
 34 
 35 Ref&lt;SharedTask&lt;void(void*)&gt;&gt; ArrayBuffer::primitiveGigacageDestructor()
 36 {
 37     static LazyNeverDestroyed&lt;Ref&lt;SharedTask&lt;void(void*)&gt;&gt;&gt; destructor;
 38     static std::once_flag onceKey;
 39     std::call_once(onceKey, [&amp;] {
 40         destructor.construct(createSharedTask&lt;void(void*)&gt;([] (void* p) { Gigacage::free(Gigacage::Primitive, p); }));
 41     });
 42     return destructor.get().copyRef();
 43 }
 44 
 45 SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
 46     : m_data(data, size)
 47     , m_destructor(WTFMove(destructor))
 48     , m_sizeInBytes(size)
 49 {
 50 }
 51 
 52 SharedArrayBufferContents::~SharedArrayBufferContents()
 53 {
 54     if (m_destructor) {
 55         // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698
 56         m_destructor-&gt;run(m_data.getUnsafe());
 57     }
 58 }
 59 
 60 ArrayBufferContents::ArrayBufferContents()
 61 {
 62     reset();
 63 }
 64 
 65 ArrayBufferContents::ArrayBufferContents(ArrayBufferContents&amp;&amp; other)
 66 {
 67     reset();
 68     other.transferTo(*this);
 69 }
 70 
 71 ArrayBufferContents::ArrayBufferContents(void* data, unsigned sizeInBytes, ArrayBufferDestructorFunction&amp;&amp; destructor)
 72     : m_data(data, sizeInBytes)
 73     , m_sizeInBytes(sizeInBytes)
 74 {
 75     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
 76     m_destructor = WTFMove(destructor);
 77 }
 78 
 79 ArrayBufferContents&amp; ArrayBufferContents::operator=(ArrayBufferContents&amp;&amp; other)
 80 {
 81     other.transferTo(*this);
 82     return *this;
 83 }
 84 
 85 ArrayBufferContents::~ArrayBufferContents()
 86 {
 87     destroy();
 88 }
 89 
 90 void ArrayBufferContents::clear()
 91 {
 92     destroy();
 93     reset();
 94 }
 95 
 96 void ArrayBufferContents::destroy()
 97 {
 98     if (m_destructor) {
 99         // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698
100         m_destructor-&gt;run(m_data.getUnsafe());
101     }
102 }
103 
104 void ArrayBufferContents::reset()
105 {
106     m_data = nullptr;
107     m_destructor = nullptr;
108     m_shared = nullptr;
109     m_sizeInBytes = 0;
110 }
111 
112 void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
113 {
114     // Do not allow 31-bit overflow of the total size.
115     if (numElements) {
116         unsigned totalSize = numElements * elementByteSize;
117         if (totalSize / numElements != elementByteSize || totalSize &gt; MAX_ARRAY_BUFFER_SIZE) {
118             reset();
119             return;
120         }
121     }
122     size_t sizeInBytes = static_cast&lt;size_t&gt;(numElements) * static_cast&lt;size_t&gt;(elementByteSize);
123     size_t allocationSize = sizeInBytes;
124     if (!allocationSize)
125         allocationSize = 1; // Make sure malloc actually allocates something, but not too much. We use null to mean that the buffer is neutered.
126 
127     void* data = Gigacage::tryMalloc(Gigacage::Primitive, allocationSize);
128     m_data = DataType(data, sizeInBytes);
129     if (!data) {
130         reset();
131         return;
132     }
133 
134     if (policy == ZeroInitialize)
135         memset(data, 0, allocationSize);
136 
137     m_sizeInBytes = sizeInBytes;
138     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
139     m_destructor = ArrayBuffer::primitiveGigacageDestructor();
140 }
141 
142 void ArrayBufferContents::makeShared()
143 {
144     m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
145     m_destructor = nullptr;
146 }
147 
148 void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
149 {
150     other.clear();
151     other.m_data = m_data;
152     other.m_sizeInBytes = m_sizeInBytes;
153     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
154     other.m_destructor = WTFMove(m_destructor);
155     other.m_shared = m_shared;
156     reset();
157 }
158 
159 void ArrayBufferContents::copyTo(ArrayBufferContents&amp; other)
160 {
161     ASSERT(!other.m_data);
162     other.tryAllocate(m_sizeInBytes, sizeof(char), ArrayBufferContents::DontInitialize);
163     if (!other.m_data)
164         return;
165     memcpy(other.data(), data(), m_sizeInBytes);
166     other.m_sizeInBytes = m_sizeInBytes;
167     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
168 }
169 
170 void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
171 {
172     ASSERT(!other.m_data);
173     ASSERT(m_shared);
174     other.m_data = m_data;
175     other.m_destructor = nullptr;
176     other.m_shared = m_shared;
177     other.m_sizeInBytes = m_sizeInBytes;
178     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
179 }
180 
181 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
182 {
183     auto buffer = tryCreate(numElements, elementByteSize);
184     if (!buffer)
185         CRASH();
186     return buffer.releaseNonNull();
187 }
188 
189 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBuffer&amp; other)
190 {
191     return ArrayBuffer::create(other.data(), other.byteLength());
192 }
193 
194 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(const void* source, unsigned byteLength)
195 {
196     auto buffer = tryCreate(source, byteLength);
197     if (!buffer)
198         CRASH();
199     return buffer.releaseNonNull();
200 }
201 
202 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBufferContents&amp;&amp; contents)
203 {
204     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
205 }
206 
207 // FIXME: We cannot use this except if the memory comes from the cage.
208 // Current this is only used from:
209 // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
210 //   from the cage.
211 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
212 {
213     return createFromBytes(data, byteLength, ArrayBuffer::primitiveGigacageDestructor());
214 }
215 
216 // FIXME: We cannot use this except if the memory comes from the cage.
217 // Currently this is only used from:
218 // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
219 //   longer caged, or we could introduce a new set of typed array types that are uncaged and get accessed
220 //   differently.
221 // - WebAssembly. Wasm should allocate from the cage.
222 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createFromBytes(const void* data, unsigned byteLength, ArrayBufferDestructorFunction&amp;&amp; destructor)
223 {
224     if (data &amp;&amp; !Gigacage::isCaged(Gigacage::Primitive, data))
225         Gigacage::disablePrimitiveGigacage();
226 
227     ArrayBufferContents contents(const_cast&lt;void*&gt;(data), byteLength, WTFMove(destructor));
228     return create(WTFMove(contents));
229 }
230 
231 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize)
232 {
233     return tryCreate(numElements, elementByteSize, ArrayBufferContents::ZeroInitialize);
234 }
235 
236 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(ArrayBuffer&amp; other)
237 {
238     return tryCreate(other.data(), other.byteLength());
239 }
240 
241 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(const void* source, unsigned byteLength)
242 {
243     ArrayBufferContents contents;
244     contents.tryAllocate(byteLength, 1, ArrayBufferContents::DontInitialize);
245     if (!contents.m_data)
246         return nullptr;
247     return createInternal(WTFMove(contents), source, byteLength);
248 }
249 
250 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createUninitialized(unsigned numElements, unsigned elementByteSize)
251 {
252     return create(numElements, elementByteSize, ArrayBufferContents::DontInitialize);
253 }
254 
255 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreateUninitialized(unsigned numElements, unsigned elementByteSize)
256 {
257     return tryCreate(numElements, elementByteSize, ArrayBufferContents::DontInitialize);
258 }
259 
260 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy policy)
261 {
262     auto buffer = tryCreate(numElements, elementByteSize, policy);
263     if (!buffer)
264         CRASH();
265     return buffer.releaseNonNull();
266 }
267 
268 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createInternal(ArrayBufferContents&amp;&amp; contents, const void* source, unsigned byteLength)
269 {
270     ASSERT(!byteLength || source);
271     auto buffer = adoptRef(*new ArrayBuffer(WTFMove(contents)));
272     memcpy(buffer-&gt;data(), source, byteLength);
273     return buffer;
274 }
275 
276 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy policy)
277 {
278     ArrayBufferContents contents;
279     contents.tryAllocate(numElements, elementByteSize, policy);
280     if (!contents.m_data)
281         return nullptr;
282     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
283 }
284 
285 ArrayBuffer::ArrayBuffer(ArrayBufferContents&amp;&amp; contents)
286     : m_contents(WTFMove(contents))
287     , m_pinCount(0)
288     , m_isWasmMemory(false)
289     , m_locked(false)
290 {
291 }
292 
293 unsigned ArrayBuffer::clampValue(double x, unsigned left, unsigned right)
294 {
295     ASSERT(left &lt;= right);
296     if (x &lt; left)
297         x = left;
298     if (right &lt; x)
299         x = right;
300     return x;
301 }
302 
303 unsigned ArrayBuffer::clampIndex(double index) const
304 {
305     unsigned currentLength = byteLength();
306     if (index &lt; 0)
307         index = currentLength + index;
308     return clampValue(index, 0, currentLength);
309 }
310 
311 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const
312 {
313     return sliceImpl(clampIndex(begin), clampIndex(end));
314 }
315 
316 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const
317 {
318     return sliceImpl(clampIndex(begin), byteLength());
319 }
320 
321 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const
322 {
323     unsigned size = begin &lt;= end ? end - begin : 0;
324     auto result = ArrayBuffer::tryCreate(static_cast&lt;const char*&gt;(data()) + begin, size);
325     if (result)
326         result-&gt;setSharingMode(sharingMode());
327     return result;
328 }
329 
330 void ArrayBuffer::makeShared()
331 {
332     m_contents.makeShared();
333     m_locked = true;
334 }
335 
336 void ArrayBuffer::makeWasmMemory()
337 {
338     m_locked = true;
339     m_isWasmMemory = true;
340 }
341 
342 void ArrayBuffer::setSharingMode(ArrayBufferSharingMode newSharingMode)
343 {
344     if (newSharingMode == sharingMode())
345         return;
346     RELEASE_ASSERT(!isShared()); // Cannot revert sharing.
347     RELEASE_ASSERT(newSharingMode == ArrayBufferSharingMode::Shared);
348     makeShared();
349 }
350 
351 bool ArrayBuffer::shareWith(ArrayBufferContents&amp; result)
352 {
353     if (!m_contents.m_data || !isShared()) {
354         result.m_data = nullptr;
355         return false;
356     }
357 
358     m_contents.shareWith(result);
359     return true;
360 }
361 
362 bool ArrayBuffer::transferTo(VM&amp; vm, ArrayBufferContents&amp; result)
363 {
364     Ref&lt;ArrayBuffer&gt; protect(*this);
365 
366     if (!m_contents.m_data) {
367         result.m_data = nullptr;
368         return false;
369     }
370 
371     if (isShared()) {
372         m_contents.shareWith(result);
373         return true;
374     }
375 
376     bool isNeuterable = !m_pinCount &amp;&amp; !m_locked;
377 
378     if (!isNeuterable) {
379         m_contents.copyTo(result);
380         if (!result.m_data)
381             return false;
382         return true;
383     }
384 
385     m_contents.transferTo(result);
386     notifyNeutering(vm);
387     return true;
388 }
389 
390 // We allow neutering wasm memory ArrayBuffers even though they are locked.
391 void ArrayBuffer::neuter(VM&amp; vm)
392 {
393     ASSERT(isWasmMemory());
394     ArrayBufferContents unused;
395     m_contents.transferTo(unused);
396     notifyNeutering(vm);
397 }
398 
399 void ArrayBuffer::notifyNeutering(VM&amp; vm)
400 {
401     for (size_t i = numberOfIncomingReferences(); i--;) {
402         JSCell* cell = incomingReferenceAt(i);
403         if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
404             view-&gt;neuter();
405     }
406     m_neuteringWatchpointSet.fireAll(vm, &quot;Array buffer was neutered&quot;);
407 }
408 
409 ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
410 {
411     ASSERT(buffer-&gt;isLocked());
412     if (buffer-&gt;isShared())
413         return &quot;Cannot transfer a SharedArrayBuffer&quot;_s;
414     if (buffer-&gt;isWasmMemory())
415         return &quot;Cannot transfer a WebAssembly.Memory&quot;_s;
416     return &quot;Cannot transfer an ArrayBuffer whose backing store has been accessed by the JavaScriptCore C API&quot;_s;
417 }
418 
419 } // namespace JSC
420 
    </pre>
  </body>
</html>
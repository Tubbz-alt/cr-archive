<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAtTailAbstractState.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
 31 #include &quot;DFGAbstractValue.h&quot;
 32 #include &quot;DFGBasicBlock.h&quot;
 33 #include &quot;DFGBlockMap.h&quot;
 34 #include &quot;DFGGraph.h&quot;
 35 #include &quot;DFGNodeFlowProjection.h&quot;
 36 
 37 namespace JSC { namespace DFG {
 38 
 39 class AtTailAbstractState {
 40 public:
 41     AtTailAbstractState(Graph&amp;);
 42 
 43     ~AtTailAbstractState();
 44 
 45     explicit operator bool() const { return true; }
 46 
 47     void initializeTo(BasicBlock* block)
 48     {
 49         m_block = block;
 50     }
 51 
 52     void createValueForNode(NodeFlowProjection);
 53 
 54     AbstractValue&amp; fastForward(AbstractValue&amp; value) { return value; }
 55 
 56     AbstractValue&amp; forNode(NodeFlowProjection);
 57     AbstractValue&amp; forNode(Edge edge) { return forNode(edge.node()); }
 58 
 59     ALWAYS_INLINE AbstractValue&amp; forNodeWithoutFastForward(NodeFlowProjection node)
 60     {
 61         return forNode(node);
 62     }
 63 
 64     ALWAYS_INLINE AbstractValue&amp; forNodeWithoutFastForward(Edge edge)
 65     {
 66         return forNode(edge);
 67     }
 68 
 69     ALWAYS_INLINE void fastForwardAndFilterUnproven(AbstractValue&amp; value, SpeculatedType type)
 70     {
 71         value.filter(type);
 72     }
 73 
 74     ALWAYS_INLINE void clearForNode(NodeFlowProjection node)
 75     {
 76         forNode(node).clear();
 77     }
 78 
 79     ALWAYS_INLINE void clearForNode(Edge edge)
 80     {
 81         clearForNode(edge.node());
 82     }
 83 
 84     template&lt;typename... Arguments&gt;
 85     ALWAYS_INLINE void setForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
 86     {
 87         forNode(node).set(m_graph, std::forward&lt;Arguments&gt;(arguments)...);
 88     }
 89 
 90     template&lt;typename... Arguments&gt;
 91     ALWAYS_INLINE void setForNode(Edge edge, Arguments&amp;&amp;... arguments)
 92     {
 93         setForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
 94     }
 95 
 96     template&lt;typename... Arguments&gt;
 97     ALWAYS_INLINE void setTypeForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
 98     {
 99         forNode(node).setType(m_graph, std::forward&lt;Arguments&gt;(arguments)...);
100     }
101 
102     template&lt;typename... Arguments&gt;
103     ALWAYS_INLINE void setTypeForNode(Edge edge, Arguments&amp;&amp;... arguments)
104     {
105         setTypeForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
106     }
107 
108     template&lt;typename... Arguments&gt;
109     ALWAYS_INLINE void setNonCellTypeForNode(NodeFlowProjection node, Arguments&amp;&amp;... arguments)
110     {
111         forNode(node).setNonCellType(std::forward&lt;Arguments&gt;(arguments)...);
112     }
113 
114     template&lt;typename... Arguments&gt;
115     ALWAYS_INLINE void setNonCellTypeForNode(Edge edge, Arguments&amp;&amp;... arguments)
116     {
117         setNonCellTypeForNode(edge.node(), std::forward&lt;Arguments&gt;(arguments)...);
118     }
119 
120     ALWAYS_INLINE void makeBytecodeTopForNode(NodeFlowProjection node)
121     {
122         forNode(node).makeBytecodeTop();
123     }
124 
125     ALWAYS_INLINE void makeBytecodeTopForNode(Edge edge)
126     {
127         makeBytecodeTopForNode(edge.node());
128     }
129 
130     ALWAYS_INLINE void makeHeapTopForNode(NodeFlowProjection node)
131     {
132         forNode(node).makeHeapTop();
133     }
134 
135     ALWAYS_INLINE void makeHeapTopForNode(Edge edge)
136     {
137         makeHeapTopForNode(edge.node());
138     }
139 
140     unsigned numberOfArguments() const { return m_block-&gt;valuesAtTail.numberOfArguments(); }
141     unsigned numberOfLocals() const { return m_block-&gt;valuesAtTail.numberOfLocals(); }
<a name="1" id="anc1"></a><span class="line-modified">142     AbstractValue&amp; operand(Operand operand) { return m_block-&gt;valuesAtTail.operand(operand); }</span>

143     AbstractValue&amp; local(size_t index) { return m_block-&gt;valuesAtTail.local(index); }
144     AbstractValue&amp; argument(size_t index) { return m_block-&gt;valuesAtTail.argument(index); }
145 
146     void clobberStructures()
147     {
148         UNREACHABLE_FOR_PLATFORM();
149     }
150 
151     void observeInvalidationPoint()
152     {
153         UNREACHABLE_FOR_PLATFORM();
154     }
155 
156     BasicBlock* block() const { return m_block; }
157 
158     bool isValid() { return m_block-&gt;cfaDidFinish; }
159 
160     StructureClobberState structureClobberState() const { return m_block-&gt;cfaStructureClobberStateAtTail; }
161 
162     void setClobberState(AbstractInterpreterClobberState) { }
163     void mergeClobberState(AbstractInterpreterClobberState) { }
164     void setStructureClobberState(StructureClobberState state) { RELEASE_ASSERT(state == m_block-&gt;cfaStructureClobberStateAtTail); }
165     void setIsValid(bool isValid) { m_block-&gt;cfaDidFinish = isValid; }
166     void setBranchDirection(BranchDirection) { }
<a name="2" id="anc2"></a><span class="line-modified">167     void setShouldTryConstantFolding(bool) { }</span>
168 
169     void trustEdgeProofs() { m_trustEdgeProofs = true; }
170     void dontTrustEdgeProofs() { m_trustEdgeProofs = false; }
171     void setProofStatus(Edge&amp; edge, ProofStatus status)
172     {
173         if (m_trustEdgeProofs)
174             edge.setProofStatus(status);
175     }
176 
177 private:
178     Graph&amp; m_graph;
179     BlockMap&lt;HashMap&lt;NodeFlowProjection, AbstractValue&gt;&gt; m_valuesAtTailMap;
180     BasicBlock* m_block { nullptr };
181     bool m_trustEdgeProofs { false };
182 };
183 
184 } } // namespace JSC::DFG
185 
186 #endif // ENABLE(DFG_JIT)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
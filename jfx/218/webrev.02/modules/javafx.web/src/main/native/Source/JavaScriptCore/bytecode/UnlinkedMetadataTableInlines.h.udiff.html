<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedMetadataTable.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedModuleProgramCodeBlock.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -29,25 +29,26 @@</span>
  #include &quot;UnlinkedMetadataTable.h&quot;
  #include &lt;wtf/FastMalloc.h&gt;
  
  namespace JSC {
  
<span class="udiff-line-added">+ </span>
  ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable()
      : m_hasMetadata(false)
      , m_isFinalized(false)
      , m_isLinked(false)
      , m_is32Bit(false)
<span class="udiff-line-modified-removed">-     , m_rawBuffer(static_cast&lt;uint8_t*&gt;(fastZeroedMalloc(sizeof(LinkingData) + s_offset32TableSize)))</span>
<span class="udiff-line-modified-added">+     , m_rawBuffer(static_cast&lt;uint8_t*&gt;(MetadataTableMalloc::zeroedMalloc(sizeof(LinkingData) + s_offset32TableSize)))</span>
  {
  }
  
  ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable(bool is32Bit)
      : m_hasMetadata(false)
      , m_isFinalized(false)
      , m_isLinked(false)
      , m_is32Bit(is32Bit)
<span class="udiff-line-modified-removed">-     , m_rawBuffer(static_cast&lt;uint8_t*&gt;(fastZeroedMalloc(sizeof(LinkingData) + (is32Bit ? s_offset16TableSize + s_offset32TableSize : s_offset16TableSize))))</span>
<span class="udiff-line-modified-added">+     , m_rawBuffer(static_cast&lt;uint8_t*&gt;(MetadataTableMalloc::zeroedMalloc(sizeof(LinkingData) + (is32Bit ? s_offset16TableSize + s_offset32TableSize : s_offset16TableSize))))</span>
  {
  }
  
  ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable(EmptyTag)
      : m_hasMetadata(false)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -60,11 +61,11 @@</span>
  
  ALWAYS_INLINE UnlinkedMetadataTable::~UnlinkedMetadataTable()
  {
      ASSERT(!m_isLinked);
      if (m_hasMetadata || !m_isFinalized)
<span class="udiff-line-modified-removed">-         fastFree(m_rawBuffer);</span>
<span class="udiff-line-modified-added">+         MetadataTableMalloc::free(m_rawBuffer);</span>
  }
  
  ALWAYS_INLINE unsigned UnlinkedMetadataTable::addEntry(OpcodeID opcodeID)
  {
      ASSERT(!m_isFinalized &amp;&amp; opcodeID &lt; s_offsetTableEntries - 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,11 +87,14 @@</span>
  {
      ASSERT(m_isFinalized);
  
      // In this case, we return the size of the table minus the offset table,
      // which was already accounted for in the UnlinkedCodeBlock.
<span class="udiff-line-modified-removed">-     size_t result = totalSize();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     // Be careful not to touch m_rawBuffer if this metadataTable is not owning it.</span>
<span class="udiff-line-added">+     // It is possible that, m_rawBuffer is realloced in the other thread while we are accessing here.</span>
<span class="udiff-line-added">+     size_t result = metadataTable.totalSize();</span>
      if (metadataTable.buffer() == buffer()) {
          ASSERT(m_isLinked);
          if (m_is32Bit)
              return result - (s_offset16TableSize + s_offset32TableSize);
          return result - s_offset16TableSize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -108,13 +112,13 @@</span>
      unsigned totalSize = this-&gt;totalSize();
      unsigned offsetTableSize = this-&gt;offsetTableSize();
      uint8_t* buffer;
      if (!m_isLinked) {
          m_isLinked = true;
<span class="udiff-line-modified-removed">-         m_rawBuffer = buffer = reinterpret_cast&lt;uint8_t*&gt;(fastRealloc(m_rawBuffer, sizeof(LinkingData) + totalSize));</span>
<span class="udiff-line-modified-added">+         m_rawBuffer = buffer = reinterpret_cast&lt;uint8_t*&gt;(MetadataTableMalloc::realloc(m_rawBuffer, sizeof(LinkingData) + totalSize));</span>
      } else {
<span class="udiff-line-modified-removed">-         buffer = reinterpret_cast&lt;uint8_t*&gt;(fastMalloc(sizeof(LinkingData) + totalSize));</span>
<span class="udiff-line-modified-added">+         buffer = reinterpret_cast&lt;uint8_t*&gt;(MetadataTableMalloc::malloc(sizeof(LinkingData) + totalSize));</span>
          memcpy(buffer, m_rawBuffer, sizeof(LinkingData) + offsetTableSize);
      }
      memset(buffer + sizeof(LinkingData) + offsetTableSize, 0, totalSize - offsetTableSize);
      return adoptRef(*new (buffer + sizeof(LinkingData)) MetadataTable(*this));
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -126,12 +130,12 @@</span>
          return;
  
      if (metadataTable.buffer() == buffer()) {
          ASSERT(m_isLinked);
          m_isLinked = false;
<span class="udiff-line-modified-removed">-         m_rawBuffer = static_cast&lt;uint8_t*&gt;(fastRealloc(m_rawBuffer, sizeof(LinkingData) + offsetTableSize()));</span>
<span class="udiff-line-modified-added">+         m_rawBuffer = static_cast&lt;uint8_t*&gt;(MetadataTableMalloc::realloc(m_rawBuffer, sizeof(LinkingData) + offsetTableSize()));</span>
          return;
      }
<span class="udiff-line-modified-removed">-     fastFree(&amp;metadataTable.linkingData());</span>
<span class="udiff-line-modified-added">+     MetadataTableMalloc::free(&amp;metadataTable.linkingData());</span>
  }
  
  } // namespace JSC
</pre>
<center><a href="UnlinkedMetadataTable.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedModuleProgramCodeBlock.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
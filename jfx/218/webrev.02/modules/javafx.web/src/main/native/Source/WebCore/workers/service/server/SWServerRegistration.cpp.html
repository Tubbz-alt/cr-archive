<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerRegistration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWServerRegistration.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Logging.h&quot;
 32 #include &quot;SWServer.h&quot;
 33 #include &quot;SWServerToContextConnection.h&quot;
 34 #include &quot;SWServerWorker.h&quot;
 35 #include &quot;ServiceWorkerTypes.h&quot;
 36 #include &quot;ServiceWorkerUpdateViaCache.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static ServiceWorkerRegistrationIdentifier generateServiceWorkerRegistrationIdentifier()
 41 {
 42     return ServiceWorkerRegistrationIdentifier::generate();
 43 }
 44 
 45 SWServerRegistration::SWServerRegistration(SWServer&amp; server, const ServiceWorkerRegistrationKey&amp; key, ServiceWorkerUpdateViaCache updateViaCache, const URL&amp; scopeURL, const URL&amp; scriptURL)
 46     : m_identifier(generateServiceWorkerRegistrationIdentifier())
 47     , m_registrationKey(key)
 48     , m_updateViaCache(updateViaCache)
 49     , m_scopeURL(scopeURL)
 50     , m_scriptURL(scriptURL)
 51     , m_server(server)
 52     , m_creationTime(MonotonicTime::now())
 53     , m_softUpdateTimer { *this, &amp;SWServerRegistration::softUpdate }
 54 {
 55     m_scopeURL.removeFragmentIdentifier();
 56 }
 57 
 58 SWServerRegistration::~SWServerRegistration()
 59 {
 60     ASSERT(!m_preInstallationWorker || !m_preInstallationWorker-&gt;isRunning());
 61     ASSERT(!m_installingWorker || !m_installingWorker-&gt;isRunning());
 62     ASSERT(!m_waitingWorker || !m_waitingWorker-&gt;isRunning());
 63     ASSERT(!m_activeWorker || !m_activeWorker-&gt;isRunning());
 64 }
 65 
 66 SWServerWorker* SWServerRegistration::getNewestWorker()
 67 {
 68     if (m_installingWorker)
 69         return m_installingWorker.get();
 70     if (m_waitingWorker)
 71         return m_waitingWorker.get();
 72 
 73     return m_activeWorker.get();
 74 }
 75 
 76 void SWServerRegistration::setPreInstallationWorker(SWServerWorker* worker)
 77 {
 78     m_preInstallationWorker = worker;
 79 }
 80 
 81 void SWServerRegistration::updateRegistrationState(ServiceWorkerRegistrationState state, SWServerWorker* worker)
 82 {
 83     LOG(ServiceWorker, &quot;(%p) Updating registration state to %i with worker %p&quot;, this, (int)state, worker);
 84 
 85     switch (state) {
 86     case ServiceWorkerRegistrationState::Installing:
 87         ASSERT(!m_installingWorker || !m_installingWorker-&gt;isRunning() || m_waitingWorker == m_installingWorker);
 88         m_installingWorker = worker;
 89         break;
 90     case ServiceWorkerRegistrationState::Waiting:
 91         ASSERT(!m_waitingWorker || !m_waitingWorker-&gt;isRunning() || m_activeWorker == m_waitingWorker);
 92         m_waitingWorker = worker;
 93         break;
 94     case ServiceWorkerRegistrationState::Active:
 95         ASSERT(!m_activeWorker || !m_activeWorker-&gt;isRunning());
 96         m_activeWorker = worker;
 97         break;
 98     };
 99 
100     Optional&lt;ServiceWorkerData&gt; serviceWorkerData;
101     if (worker)
102         serviceWorkerData = worker-&gt;data();
103 
104     forEachConnection([&amp;](auto&amp; connection) {
105         connection.updateRegistrationStateInClient(this-&gt;identifier(), state, serviceWorkerData);
106     });
107 }
108 
109 void SWServerRegistration::updateWorkerState(SWServerWorker&amp; worker, ServiceWorkerState state)
110 {
111     LOG(ServiceWorker, &quot;Updating worker %p state to %i (%p)&quot;, &amp;worker, (int)state, this);
112 
113     worker.setState(state);
114 }
115 
116 void SWServerRegistration::setUpdateViaCache(ServiceWorkerUpdateViaCache updateViaCache)
117 {
118     m_updateViaCache = updateViaCache;
119     forEachConnection([&amp;](auto&amp; connection) {
120         connection.setRegistrationUpdateViaCache(this-&gt;identifier(), updateViaCache);
121     });
122 }
123 
124 void SWServerRegistration::setLastUpdateTime(WallTime time)
125 {
126     m_lastUpdateTime = time;
127     forEachConnection([&amp;](auto&amp; connection) {
128         connection.setRegistrationLastUpdateTime(this-&gt;identifier(), time);
129     });
130 }
131 
132 void SWServerRegistration::fireUpdateFoundEvent()
133 {
134     forEachConnection([&amp;](auto&amp; connection) {
135         connection.fireUpdateFoundEvent(this-&gt;identifier());
136     });
137 }
138 
139 void SWServerRegistration::forEachConnection(const WTF::Function&lt;void(SWServer::Connection&amp;)&gt;&amp; apply)
140 {
141     for (auto connectionIdentifierWithClients : m_connectionsWithClientRegistrations.values()) {
142         if (auto* connection = m_server.connection(connectionIdentifierWithClients))
143             apply(*connection);
144     }
145 }
146 
147 ServiceWorkerRegistrationData SWServerRegistration::data() const
148 {
149     Optional&lt;ServiceWorkerData&gt; installingWorkerData;
150     if (m_installingWorker)
151         installingWorkerData = m_installingWorker-&gt;data();
152 
153     Optional&lt;ServiceWorkerData&gt; waitingWorkerData;
154     if (m_waitingWorker)
155         waitingWorkerData = m_waitingWorker-&gt;data();
156 
157     Optional&lt;ServiceWorkerData&gt; activeWorkerData;
158     if (m_activeWorker)
159         activeWorkerData = m_activeWorker-&gt;data();
160 
161     return { m_registrationKey, identifier(), m_scopeURL, m_updateViaCache, m_lastUpdateTime, WTFMove(installingWorkerData), WTFMove(waitingWorkerData), WTFMove(activeWorkerData) };
162 }
163 
164 void SWServerRegistration::addClientServiceWorkerRegistration(SWServerConnectionIdentifier connectionIdentifier)
165 {
166     m_connectionsWithClientRegistrations.add(connectionIdentifier);
167 }
168 
169 void SWServerRegistration::removeClientServiceWorkerRegistration(SWServerConnectionIdentifier connectionIdentifier)
170 {
171     m_connectionsWithClientRegistrations.remove(connectionIdentifier);
172 }
173 
174 void SWServerRegistration::addClientUsingRegistration(const ServiceWorkerClientIdentifier&amp; clientIdentifier)
175 {
176     auto addResult = m_clientsUsingRegistration.ensure(clientIdentifier.serverConnectionIdentifier, [] {
177         return HashSet&lt;DocumentIdentifier&gt; { };
178     }).iterator-&gt;value.add(clientIdentifier.contextIdentifier);
179     ASSERT_UNUSED(addResult, addResult.isNewEntry);
180 }
181 
182 void SWServerRegistration::removeClientUsingRegistration(const ServiceWorkerClientIdentifier&amp; clientIdentifier)
183 {
184     auto iterator = m_clientsUsingRegistration.find(clientIdentifier.serverConnectionIdentifier);
185     ASSERT(iterator != m_clientsUsingRegistration.end());
186     if (iterator == m_clientsUsingRegistration.end())
187         return;
188 
189     bool wasRemoved = iterator-&gt;value.remove(clientIdentifier.contextIdentifier);
190     ASSERT_UNUSED(wasRemoved, wasRemoved);
191 
192     if (iterator-&gt;value.isEmpty())
193         m_clientsUsingRegistration.remove(iterator);
194 
195     handleClientUnload();
196 }
197 
198 // https://w3c.github.io/ServiceWorker/#notify-controller-change
199 void SWServerRegistration::notifyClientsOfControllerChange()
200 {
201     ASSERT(activeWorker());
202 
203     for (auto&amp; item : m_clientsUsingRegistration) {
204         if (auto* connection = m_server.connection(item.key))
205             connection-&gt;notifyClientsOfControllerChange(item.value, activeWorker()-&gt;data());
206     }
207 }
208 
209 void SWServerRegistration::unregisterServerConnection(SWServerConnectionIdentifier serverConnectionIdentifier)
210 {
211     m_connectionsWithClientRegistrations.removeAll(serverConnectionIdentifier);
212     m_clientsUsingRegistration.remove(serverConnectionIdentifier);
213 }
214 
215 // https://w3c.github.io/ServiceWorker/#try-clear-registration-algorithm
216 bool SWServerRegistration::tryClear()
217 {
218     if (hasClientsUsingRegistration())
219         return false;
220 
221     if (installingWorker() &amp;&amp; installingWorker()-&gt;hasPendingEvents())
222         return false;
223     if (waitingWorker() &amp;&amp; waitingWorker()-&gt;hasPendingEvents())
224         return false;
225     if (activeWorker() &amp;&amp; activeWorker()-&gt;hasPendingEvents())
226         return false;
227 
228     clear();
229     return true;
230 }
231 
232 // https://w3c.github.io/ServiceWorker/#clear-registration
233 void SWServerRegistration::clear()
234 {
235     if (m_preInstallationWorker) {
236         ASSERT(m_preInstallationWorker-&gt;state() == ServiceWorkerState::Redundant);
237         m_preInstallationWorker-&gt;terminate();
238         m_preInstallationWorker = nullptr;
239     }
240 
241     RefPtr&lt;SWServerWorker&gt; installingWorker = this-&gt;installingWorker();
242     if (installingWorker) {
243         installingWorker-&gt;terminate();
244         updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
245     }
246     RefPtr&lt;SWServerWorker&gt; waitingWorker = this-&gt;waitingWorker();
247     if (waitingWorker) {
248         waitingWorker-&gt;terminate();
249         updateRegistrationState(ServiceWorkerRegistrationState::Waiting, nullptr);
250     }
251     RefPtr&lt;SWServerWorker&gt; activeWorker = this-&gt;activeWorker();
252     if (activeWorker) {
253         activeWorker-&gt;terminate();
254         updateRegistrationState(ServiceWorkerRegistrationState::Active, nullptr);
255     }
256 
257     if (installingWorker)
258         updateWorkerState(*installingWorker, ServiceWorkerState::Redundant);
259     if (waitingWorker)
260         updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
261     if (activeWorker)
262         updateWorkerState(*activeWorker, ServiceWorkerState::Redundant);
263 
264     // Remove scope to registration map[scopeString].
265     m_server.removeRegistration(identifier());
266 }
267 
268 // https://w3c.github.io/ServiceWorker/#try-activate-algorithm
269 void SWServerRegistration::tryActivate()
270 {
271     // If registration&#39;s waiting worker is null, return.
272     if (!waitingWorker())
273         return;
274     // If registration&#39;s active worker is not null and registration&#39;s active worker&#39;s state is activating, return.
275     if (activeWorker() &amp;&amp; activeWorker()-&gt;state() == ServiceWorkerState::Activating)
276         return;
277 
278     // Invoke Activate with registration if either of the following is true:
279     // - registration&#39;s active worker is null.
280     // - The result of running Service Worker Has No Pending Events with registration&#39;s active worker is true,
281     //   and no service worker client is using registration or registration&#39;s waiting worker&#39;s skip waiting flag is set.
282     if (!activeWorker() || (!activeWorker()-&gt;hasPendingEvents() &amp;&amp; (!hasClientsUsingRegistration() || waitingWorker()-&gt;isSkipWaitingFlagSet())))
283         activate();
284 }
285 
286 // https://w3c.github.io/ServiceWorker/#activate
287 void SWServerRegistration::activate()
288 {
289     // If registration&#39;s waiting worker is null, abort these steps.
290     if (!waitingWorker())
291         return;
292 
293     // If registration&#39;s active worker is not null, then:
294     if (auto* worker = activeWorker()) {
295         // Terminate registration&#39;s active worker.
296         worker-&gt;terminate();
297         // Run the Update Worker State algorithm passing registration&#39;s active worker and redundant as the arguments.
298         updateWorkerState(*worker, ServiceWorkerState::Redundant);
299     }
300     // Run the Update Registration State algorithm passing registration, &quot;active&quot; and registration&#39;s waiting worker as the arguments.
301     updateRegistrationState(ServiceWorkerRegistrationState::Active, waitingWorker());
302     // Run the Update Registration State algorithm passing registration, &quot;waiting&quot; and null as the arguments.
303     updateRegistrationState(ServiceWorkerRegistrationState::Waiting, nullptr);
304     // Run the Update Worker State algorithm passing registration&#39;s active worker and activating as the arguments.
305     updateWorkerState(*activeWorker(), ServiceWorkerState::Activating);
306     // FIXME: For each service worker client whose creation URL matches registration&#39;s scope url...
307 
308     // The registration now has an active worker so we need to check if there are any ready promises that were waiting for this.
309     m_server.resolveRegistrationReadyRequests(*this);
310 
311     // For each service worker client who is using registration:
312     // - Set client&#39;s active worker to registration&#39;s active worker.
313 
314     // - Invoke Notify Controller Change algorithm with client as the argument.
315     notifyClientsOfControllerChange();
316 
317     // FIXME: Invoke Run Service Worker algorithm with activeWorker as the argument.
318 
319     // Queue a task to fire the activate event.
320     ASSERT(activeWorker());
321     m_server.fireActivateEvent(*activeWorker());
322 }
323 
324 // https://w3c.github.io/ServiceWorker/#activate (post activate event steps).
325 void SWServerRegistration::didFinishActivation(ServiceWorkerIdentifier serviceWorkerIdentifier)
326 {
327     if (!activeWorker() || activeWorker()-&gt;identifier() != serviceWorkerIdentifier)
328         return;
329 
330     // Run the Update Worker State algorithm passing registration&#39;s active worker and activated as the arguments.
331     updateWorkerState(*activeWorker(), ServiceWorkerState::Activated);
332 }
333 
334 // https://w3c.github.io/ServiceWorker/#on-client-unload-algorithm
335 void SWServerRegistration::handleClientUnload()
336 {
337     if (hasClientsUsingRegistration())
338         return;
339     if (isUnregistered() &amp;&amp; tryClear())
340         return;
341     tryActivate();
342 }
343 
344 bool SWServerRegistration::isUnregistered() const
345 {
346     return m_server.getRegistration(key()) != this;
347 }
348 
349 void SWServerRegistration::controlClient(ServiceWorkerClientIdentifier identifier)
350 {
351     ASSERT(activeWorker());
352 
353     addClientUsingRegistration(identifier);
354 
355     HashSet&lt;DocumentIdentifier&gt; identifiers;
356     identifiers.add(identifier.contextIdentifier);
357     m_server.connection(identifier.serverConnectionIdentifier)-&gt;notifyClientsOfControllerChange(identifiers, activeWorker()-&gt;data());
358 }
359 
360 bool SWServerRegistration::shouldSoftUpdate(const FetchOptions&amp; options) const
361 {
362     if (options.mode == FetchOptions::Mode::Navigate)
363         return true;
364 
365     return WebCore::isNonSubresourceRequest(options.destination) &amp;&amp; isStale();
366 }
367 
368 void SWServerRegistration::softUpdate()
369 {
370     m_server.softUpdate(*this);
371 }
372 
373 void SWServerRegistration::scheduleSoftUpdate()
374 {
375     // To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying
376     // as long as soft update requests keep coming. This seems to match Chrome&#39;s behavior.
377     if (m_softUpdateTimer.isActive())
378         return;
379 
380     RELEASE_LOG(ServiceWorker, &quot;SWServerRegistration::softUpdateIfNeeded&quot;);
381     m_softUpdateTimer.startOneShot(softUpdateDelay);
382 }
383 
384 } // namespace WebCore
385 
386 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
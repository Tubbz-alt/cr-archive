<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/SWClientConnection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FetchEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SWClientConnection.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/SWClientConnection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWClientConnection.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;MessageEvent.h&quot;
<span class="line-removed"> 34 #include &quot;Microtasks.h&quot;</span>
 35 #include &quot;SWContextManager.h&quot;
 36 #include &quot;ServiceWorkerContainer.h&quot;
 37 #include &quot;ServiceWorkerFetchResult.h&quot;

 38 #include &quot;ServiceWorkerJobData.h&quot;
 39 #include &quot;ServiceWorkerRegistration.h&quot;
 40 #include &lt;wtf/CrossThreadCopier.h&gt;
 41 
 42 namespace WebCore {
 43 


















 44 SWClientConnection::SWClientConnection() = default;
 45 
 46 SWClientConnection::~SWClientConnection() = default;
 47 
 48 void SWClientConnection::scheduleJob(DocumentOrWorkerIdentifier contextIdentifier, const ServiceWorkerJobData&amp; jobData)
 49 {
<span class="line-removed"> 50     ASSERT(isMainThread());</span>
<span class="line-removed"> 51 </span>
 52     auto addResult = m_scheduledJobSources.add(jobData.identifier().jobIdentifier, contextIdentifier);
 53     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 54 
 55     scheduleJobInServer(jobData);
 56 }
 57 
<span class="line-modified"> 58 void SWClientConnection::failedFetchingScript(ServiceWorkerJobIdentifier jobIdentifier, const ServiceWorkerRegistrationKey&amp; registrationKey, const ResourceError&amp; error)</span>
<span class="line-removed"> 59 {</span>
<span class="line-removed"> 60     ASSERT(isMainThread());</span>
<span class="line-removed"> 61 </span>
<span class="line-removed"> 62     finishFetchingScriptInServer({ { serverConnectionIdentifier(), jobIdentifier }, registrationKey, { }, { }, { },  error });</span>
<span class="line-removed"> 63 }</span>
<span class="line-removed"> 64 </span>
<span class="line-removed"> 65 bool SWClientConnection::postTaskForJob(ServiceWorkerJobIdentifier jobIdentifier, IsJobComplete isJobComplete, WTF::Function&lt;void(ServiceWorkerJob&amp;)&gt;&amp;&amp; task)</span>
 66 {
 67     ASSERT(isMainThread());
 68 
 69     auto iterator = m_scheduledJobSources.find(jobIdentifier);
 70     if (iterator == m_scheduledJobSources.end()) {
 71         LOG_ERROR(&quot;Job %s was not found&quot;, jobIdentifier.loggingString().utf8().data());
 72         return false;
 73     }
<span class="line-modified"> 74     auto isPosted = ScriptExecutionContext::postTaskTo(iterator-&gt;value, [jobIdentifier, task = WTFMove(task)] (ScriptExecutionContext&amp; context) mutable {</span>
 75         if (auto* container = context.serviceWorkerContainer()) {
 76             if (auto* job = container-&gt;job(jobIdentifier))
 77                 task(*job);
 78         }
 79     });
 80     if (isJobComplete == IsJobComplete::Yes)
 81         m_scheduledJobSources.remove(iterator);
 82     return isPosted;
 83 }
 84 
 85 void SWClientConnection::jobRejectedInServer(ServiceWorkerJobIdentifier jobIdentifier, const ExceptionData&amp; exceptionData)
 86 {
 87     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [exceptionData = exceptionData.isolatedCopy()] (auto&amp; job) {
 88         job.failedWithException(exceptionData.toException());
 89     });
 90 }
 91 
 92 void SWClientConnection::registrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, ServiceWorkerRegistrationData&amp;&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 93 {
 94     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::Yes, [registrationData = registrationData.isolatedCopy(), shouldNotifyWhenResolved] (auto&amp; job) mutable {
 95         job.resolvedWithRegistration(WTFMove(registrationData), shouldNotifyWhenResolved);
 96     });
 97 
 98     if (!isPosted &amp;&amp; shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
 99         didResolveRegistrationPromise(registrationData.key);
100 }
101 
102 void SWClientConnection::unregistrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, bool unregistrationResult)
103 {
104     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [unregistrationResult] (auto&amp; job) {
105         job.resolvedWithUnregistrationResult(unregistrationResult);
106     });
107 }
108 
109 void SWClientConnection::startScriptFetchForServer(ServiceWorkerJobIdentifier jobIdentifier, const ServiceWorkerRegistrationKey&amp; registrationKey, FetchOptions::Cache cachePolicy)
110 {
111     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::No, [cachePolicy] (auto&amp; job) {
112         job.startScriptFetch(cachePolicy);
113     });
114     if (!isPosted)
<span class="line-modified">115         failedFetchingScript(jobIdentifier, registrationKey, ResourceError { errorDomainWebKitInternal, 0, { }, makeString(&quot;Failed to fetch script for service worker with scope &quot;, registrationKey.scope().string()) });</span>
116 }
117 
118 
119 void SWClientConnection::postMessageToServiceWorkerClient(DocumentIdentifier destinationContextIdentifier, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
120 {
121     ASSERT(isMainThread());
122 
123     // FIXME: destinationContextIdentifier can only identify a Document at the moment.
124     auto* destinationDocument = Document::allDocumentsMap().get(destinationContextIdentifier);
125     if (!destinationDocument)
126         return;
127 
<span class="line-modified">128     destinationDocument-&gt;postTask([message = WTFMove(message), sourceData = WTFMove(sourceData), sourceOrigin = WTFMove(sourceOrigin)](auto&amp; context) mutable {</span>
<span class="line-modified">129         if (auto* container = context.serviceWorkerContainer())</span>
<span class="line-removed">130             container-&gt;postMessage(WTFMove(message), WTFMove(sourceData), WTFMove(sourceOrigin));</span>
<span class="line-removed">131     });</span>
132 }
133 
134 void SWClientConnection::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)
135 {
136     ASSERT(isMainThread());
137 
138     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state, &amp;serviceWorkerData] (auto&amp; workerThread) {
139         workerThread.thread().runLoop().postTask([identifier, state, serviceWorkerData = crossThreadCopy(serviceWorkerData)](ScriptExecutionContext&amp; context) mutable {
140             if (auto* container = context.serviceWorkerContainer())
141                 container-&gt;updateRegistrationState(identifier, state, WTFMove(serviceWorkerData));
142         });
143     });
144 
145     for (auto* document : Document::allDocuments()) {
<span class="line-modified">146         document-&gt;postTask([identifier, state, serviceWorkerData, document](auto&amp;) {</span>
<span class="line-modified">147             if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-removed">148                 container-&gt;updateRegistrationState(identifier, state, serviceWorkerData);</span>
<span class="line-removed">149         });</span>
150     }
151 }
152 
153 void SWClientConnection::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)
154 {
155     ASSERT(isMainThread());
156 
157     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state] (auto&amp; workerThread) {
158         workerThread.thread().runLoop().postTask([identifier, state](ScriptExecutionContext&amp; context) {
<span class="line-modified">159             if (auto* serviceWorker = context.serviceWorker(identifier))</span>
<span class="line-modified">160                 serviceWorker-&gt;updateState(state);</span>
161         });
162     });
163 
164     for (auto* document : Document::allDocuments()) {
<span class="line-modified">165         document-&gt;postTask([identifier, document, state](auto&amp;) {</span>
<span class="line-modified">166             if (auto* serviceWorker = document-&gt;serviceWorker(identifier))</span>
<span class="line-removed">167                 serviceWorker-&gt;updateState(state);</span>
<span class="line-removed">168         });</span>
169     }
170 }
171 
172 void SWClientConnection::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
173 {
174     ASSERT(isMainThread());
175 
176     SWContextManager::singleton().forEachServiceWorkerThread([identifier] (auto&amp; workerThread) {
177         workerThread.thread().runLoop().postTask([identifier](ScriptExecutionContext&amp; context) {
178             if (auto* container = context.serviceWorkerContainer())
<span class="line-modified">179                 container-&gt;fireUpdateFoundEvent(identifier);</span>
180         });
181     });
182 
183     for (auto* document : Document::allDocuments()) {
<span class="line-modified">184         document-&gt;postTask([document, identifier](auto&amp;) {</span>
<span class="line-modified">185             if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-removed">186                 container-&gt;fireUpdateFoundEvent(identifier);</span>
<span class="line-removed">187         });</span>
188     }
189 }
190 
191 void SWClientConnection::setRegistrationLastUpdateTime(ServiceWorkerRegistrationIdentifier identifier, WallTime lastUpdateTime)
192 {
193     ASSERT(isMainThread());
194 
195     SWContextManager::singleton().forEachServiceWorkerThread([identifier, lastUpdateTime] (auto&amp; workerThread) {
196         workerThread.thread().runLoop().postTask([identifier, lastUpdateTime](ScriptExecutionContext&amp; context) {
197             if (auto* container = context.serviceWorkerContainer()) {
198                 if (auto* registration = container-&gt;registration(identifier))
199                     registration-&gt;setLastUpdateTime(lastUpdateTime);
200             }
201         });
202     });
203 
204     for (auto* document : Document::allDocuments()) {
205         if (auto* container = document-&gt;serviceWorkerContainer()) {
206             if (auto* registration = container-&gt;registration(identifier))
207                 registration-&gt;setLastUpdateTime(lastUpdateTime);
</pre>
<hr />
<pre>
224 
225     for (auto* document : Document::allDocuments()) {
226         if (auto* container = document-&gt;serviceWorkerContainer()) {
227             if (auto* registration = container-&gt;registration(identifier))
228                 registration-&gt;setUpdateViaCache(updateViaCache);
229         }
230     }
231 }
232 
233 void SWClientConnection::notifyClientsOfControllerChange(const HashSet&lt;DocumentIdentifier&gt;&amp; contextIdentifiers, ServiceWorkerData&amp;&amp; newController)
234 {
235     ASSERT(isMainThread());
236     ASSERT(!contextIdentifiers.isEmpty());
237 
238     for (auto&amp; clientIdentifier : contextIdentifiers) {
239         // FIXME: Support worker contexts.
240         auto* client = Document::allDocumentsMap().get(clientIdentifier);
241         if (!client)
242             continue;
243 
<span class="line-modified">244         client-&gt;postTask([client, contextIdentifiers, newController = WTFMove(newController)](auto&amp;) {</span>
<span class="line-modified">245             ASSERT(!client-&gt;activeServiceWorker() || client-&gt;activeServiceWorker()-&gt;identifier() != newController.identifier);</span>
<span class="line-modified">246             client-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*client, ServiceWorkerData { newController }));</span>
<span class="line-removed">247             if (auto* container = client-&gt;serviceWorkerContainer())</span>
<span class="line-removed">248                 container-&gt;fireControllerChangeEvent();</span>
<span class="line-removed">249         });</span>
250     }
251 }
252 
253 void SWClientConnection::clearPendingJobs()
254 {
255     ASSERT(isMainThread());
256 
257     auto jobSources = WTFMove(m_scheduledJobSources);
258     for (auto&amp; keyValue : jobSources) {
<span class="line-modified">259         ScriptExecutionContext::postTaskTo(keyValue.value, [identifier = keyValue.key] (auto&amp; context) {</span>
260             if (auto* container = context.serviceWorkerContainer()) {
261                 if (auto* job = container-&gt;job(identifier))
262                     job-&gt;failedWithException(Exception { TypeError, &quot;Internal error&quot;_s });
263             }
264         });
265     }
266 }
267 








268 } // namespace WebCore
269 
270 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWClientConnection.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Document.h&quot;
 32 #include &quot;ExceptionData.h&quot;
 33 #include &quot;MessageEvent.h&quot;

 34 #include &quot;SWContextManager.h&quot;
 35 #include &quot;ServiceWorkerContainer.h&quot;
 36 #include &quot;ServiceWorkerFetchResult.h&quot;
<span class="line-added"> 37 #include &quot;ServiceWorkerGlobalScope.h&quot;</span>
 38 #include &quot;ServiceWorkerJobData.h&quot;
 39 #include &quot;ServiceWorkerRegistration.h&quot;
 40 #include &lt;wtf/CrossThreadCopier.h&gt;
 41 
 42 namespace WebCore {
 43 
<span class="line-added"> 44 static bool dispatchToContextThreadIfNecessary(const DocumentOrWorkerIdentifier&amp; contextIdentifier, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp; task)</span>
<span class="line-added"> 45 {</span>
<span class="line-added"> 46     RELEASE_ASSERT(isMainThread());</span>
<span class="line-added"> 47     bool wasPosted = false;</span>
<span class="line-added"> 48     switchOn(contextIdentifier, [&amp;] (DocumentIdentifier identifier) {</span>
<span class="line-added"> 49         auto* document = Document::allDocumentsMap().get(identifier);</span>
<span class="line-added"> 50         if (!document)</span>
<span class="line-added"> 51             return;</span>
<span class="line-added"> 52         task(*document);</span>
<span class="line-added"> 53         wasPosted = true;</span>
<span class="line-added"> 54     }, [&amp;](ServiceWorkerIdentifier identifier) {</span>
<span class="line-added"> 55         wasPosted = SWContextManager::singleton().postTaskToServiceWorker(identifier, [task = WTFMove(task)](auto&amp; scope) mutable {</span>
<span class="line-added"> 56             task(scope);</span>
<span class="line-added"> 57         });</span>
<span class="line-added"> 58     });</span>
<span class="line-added"> 59     return wasPosted;</span>
<span class="line-added"> 60 }</span>
<span class="line-added"> 61 </span>
 62 SWClientConnection::SWClientConnection() = default;
 63 
 64 SWClientConnection::~SWClientConnection() = default;
 65 
 66 void SWClientConnection::scheduleJob(DocumentOrWorkerIdentifier contextIdentifier, const ServiceWorkerJobData&amp; jobData)
 67 {


 68     auto addResult = m_scheduledJobSources.add(jobData.identifier().jobIdentifier, contextIdentifier);
 69     ASSERT_UNUSED(addResult, addResult.isNewEntry);
 70 
 71     scheduleJobInServer(jobData);
 72 }
 73 
<span class="line-modified"> 74 bool SWClientConnection::postTaskForJob(ServiceWorkerJobIdentifier jobIdentifier, IsJobComplete isJobComplete, Function&lt;void(ServiceWorkerJob&amp;)&gt;&amp;&amp; task)</span>







 75 {
 76     ASSERT(isMainThread());
 77 
 78     auto iterator = m_scheduledJobSources.find(jobIdentifier);
 79     if (iterator == m_scheduledJobSources.end()) {
 80         LOG_ERROR(&quot;Job %s was not found&quot;, jobIdentifier.loggingString().utf8().data());
 81         return false;
 82     }
<span class="line-modified"> 83     auto isPosted = dispatchToContextThreadIfNecessary(iterator-&gt;value, [jobIdentifier, task = WTFMove(task)] (ScriptExecutionContext&amp; context) mutable {</span>
 84         if (auto* container = context.serviceWorkerContainer()) {
 85             if (auto* job = container-&gt;job(jobIdentifier))
 86                 task(*job);
 87         }
 88     });
 89     if (isJobComplete == IsJobComplete::Yes)
 90         m_scheduledJobSources.remove(iterator);
 91     return isPosted;
 92 }
 93 
 94 void SWClientConnection::jobRejectedInServer(ServiceWorkerJobIdentifier jobIdentifier, const ExceptionData&amp; exceptionData)
 95 {
 96     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [exceptionData = exceptionData.isolatedCopy()] (auto&amp; job) {
 97         job.failedWithException(exceptionData.toException());
 98     });
 99 }
100 
101 void SWClientConnection::registrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, ServiceWorkerRegistrationData&amp;&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
102 {
103     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::Yes, [registrationData = registrationData.isolatedCopy(), shouldNotifyWhenResolved] (auto&amp; job) mutable {
104         job.resolvedWithRegistration(WTFMove(registrationData), shouldNotifyWhenResolved);
105     });
106 
107     if (!isPosted &amp;&amp; shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes)
108         didResolveRegistrationPromise(registrationData.key);
109 }
110 
111 void SWClientConnection::unregistrationJobResolvedInServer(ServiceWorkerJobIdentifier jobIdentifier, bool unregistrationResult)
112 {
113     postTaskForJob(jobIdentifier, IsJobComplete::Yes, [unregistrationResult] (auto&amp; job) {
114         job.resolvedWithUnregistrationResult(unregistrationResult);
115     });
116 }
117 
118 void SWClientConnection::startScriptFetchForServer(ServiceWorkerJobIdentifier jobIdentifier, const ServiceWorkerRegistrationKey&amp; registrationKey, FetchOptions::Cache cachePolicy)
119 {
120     bool isPosted = postTaskForJob(jobIdentifier, IsJobComplete::No, [cachePolicy] (auto&amp; job) {
121         job.startScriptFetch(cachePolicy);
122     });
123     if (!isPosted)
<span class="line-modified">124         finishFetchingScriptInServer(serviceWorkerFetchError({ serverConnectionIdentifier(), jobIdentifier }, ServiceWorkerRegistrationKey { registrationKey}, ResourceError { errorDomainWebKitInternal, 0, { }, makeString(&quot;Failed to fetch script for service worker with scope &quot;, registrationKey.scope().string()) }));</span>
125 }
126 
127 
128 void SWClientConnection::postMessageToServiceWorkerClient(DocumentIdentifier destinationContextIdentifier, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerData&amp;&amp; sourceData, String&amp;&amp; sourceOrigin)
129 {
130     ASSERT(isMainThread());
131 
132     // FIXME: destinationContextIdentifier can only identify a Document at the moment.
133     auto* destinationDocument = Document::allDocumentsMap().get(destinationContextIdentifier);
134     if (!destinationDocument)
135         return;
136 
<span class="line-modified">137     if (auto* container = destinationDocument-&gt;ensureServiceWorkerContainer())</span>
<span class="line-modified">138         container-&gt;postMessage(WTFMove(message), WTFMove(sourceData), WTFMove(sourceOrigin));</span>


139 }
140 
141 void SWClientConnection::updateRegistrationState(ServiceWorkerRegistrationIdentifier identifier, ServiceWorkerRegistrationState state, const Optional&lt;ServiceWorkerData&gt;&amp; serviceWorkerData)
142 {
143     ASSERT(isMainThread());
144 
145     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state, &amp;serviceWorkerData] (auto&amp; workerThread) {
146         workerThread.thread().runLoop().postTask([identifier, state, serviceWorkerData = crossThreadCopy(serviceWorkerData)](ScriptExecutionContext&amp; context) mutable {
147             if (auto* container = context.serviceWorkerContainer())
148                 container-&gt;updateRegistrationState(identifier, state, WTFMove(serviceWorkerData));
149         });
150     });
151 
152     for (auto* document : Document::allDocuments()) {
<span class="line-modified">153         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">154             container-&gt;updateRegistrationState(identifier, state, serviceWorkerData);</span>


155     }
156 }
157 
158 void SWClientConnection::updateWorkerState(ServiceWorkerIdentifier identifier, ServiceWorkerState state)
159 {
160     ASSERT(isMainThread());
161 
162     SWContextManager::singleton().forEachServiceWorkerThread([identifier, state] (auto&amp; workerThread) {
163         workerThread.thread().runLoop().postTask([identifier, state](ScriptExecutionContext&amp; context) {
<span class="line-modified">164             if (auto* container = context.serviceWorkerContainer())</span>
<span class="line-modified">165                 container-&gt;updateWorkerState(identifier, state);</span>
166         });
167     });
168 
169     for (auto* document : Document::allDocuments()) {
<span class="line-modified">170         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">171             container-&gt;updateWorkerState(identifier, state);</span>


172     }
173 }
174 
175 void SWClientConnection::fireUpdateFoundEvent(ServiceWorkerRegistrationIdentifier identifier)
176 {
177     ASSERT(isMainThread());
178 
179     SWContextManager::singleton().forEachServiceWorkerThread([identifier] (auto&amp; workerThread) {
180         workerThread.thread().runLoop().postTask([identifier](ScriptExecutionContext&amp; context) {
181             if (auto* container = context.serviceWorkerContainer())
<span class="line-modified">182                 container-&gt;queueTaskToFireUpdateFoundEvent(identifier);</span>
183         });
184     });
185 
186     for (auto* document : Document::allDocuments()) {
<span class="line-modified">187         if (auto* container = document-&gt;serviceWorkerContainer())</span>
<span class="line-modified">188             container-&gt;queueTaskToFireUpdateFoundEvent(identifier);</span>


189     }
190 }
191 
192 void SWClientConnection::setRegistrationLastUpdateTime(ServiceWorkerRegistrationIdentifier identifier, WallTime lastUpdateTime)
193 {
194     ASSERT(isMainThread());
195 
196     SWContextManager::singleton().forEachServiceWorkerThread([identifier, lastUpdateTime] (auto&amp; workerThread) {
197         workerThread.thread().runLoop().postTask([identifier, lastUpdateTime](ScriptExecutionContext&amp; context) {
198             if (auto* container = context.serviceWorkerContainer()) {
199                 if (auto* registration = container-&gt;registration(identifier))
200                     registration-&gt;setLastUpdateTime(lastUpdateTime);
201             }
202         });
203     });
204 
205     for (auto* document : Document::allDocuments()) {
206         if (auto* container = document-&gt;serviceWorkerContainer()) {
207             if (auto* registration = container-&gt;registration(identifier))
208                 registration-&gt;setLastUpdateTime(lastUpdateTime);
</pre>
<hr />
<pre>
225 
226     for (auto* document : Document::allDocuments()) {
227         if (auto* container = document-&gt;serviceWorkerContainer()) {
228             if (auto* registration = container-&gt;registration(identifier))
229                 registration-&gt;setUpdateViaCache(updateViaCache);
230         }
231     }
232 }
233 
234 void SWClientConnection::notifyClientsOfControllerChange(const HashSet&lt;DocumentIdentifier&gt;&amp; contextIdentifiers, ServiceWorkerData&amp;&amp; newController)
235 {
236     ASSERT(isMainThread());
237     ASSERT(!contextIdentifiers.isEmpty());
238 
239     for (auto&amp; clientIdentifier : contextIdentifiers) {
240         // FIXME: Support worker contexts.
241         auto* client = Document::allDocumentsMap().get(clientIdentifier);
242         if (!client)
243             continue;
244 
<span class="line-modified">245         client-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*client, WTFMove(newController)));</span>
<span class="line-modified">246         if (auto* container = client-&gt;serviceWorkerContainer())</span>
<span class="line-modified">247             container-&gt;queueTaskToDispatchControllerChangeEvent();</span>



248     }
249 }
250 
251 void SWClientConnection::clearPendingJobs()
252 {
253     ASSERT(isMainThread());
254 
255     auto jobSources = WTFMove(m_scheduledJobSources);
256     for (auto&amp; keyValue : jobSources) {
<span class="line-modified">257         dispatchToContextThreadIfNecessary(keyValue.value, [identifier = keyValue.key] (auto&amp; context) {</span>
258             if (auto* container = context.serviceWorkerContainer()) {
259                 if (auto* job = container-&gt;job(identifier))
260                     job-&gt;failedWithException(Exception { TypeError, &quot;Internal error&quot;_s });
261             }
262         });
263     }
264 }
265 
<span class="line-added">266 void SWClientConnection::registerServiceWorkerClients()</span>
<span class="line-added">267 {</span>
<span class="line-added">268     for (auto* document : Document::allDocuments()) {</span>
<span class="line-added">269         auto controllingServiceWorkerRegistrationIdentifier = document-&gt;activeServiceWorker() ? makeOptional&lt;ServiceWorkerRegistrationIdentifier&gt;(document-&gt;activeServiceWorker()-&gt;registrationIdentifier()) : WTF::nullopt;</span>
<span class="line-added">270         registerServiceWorkerClient(document-&gt;topOrigin(), ServiceWorkerClientData::from(*document, *this), controllingServiceWorkerRegistrationIdentifier, document-&gt;userAgent(document-&gt;url()));</span>
<span class="line-added">271     }</span>
<span class="line-added">272 }</span>
<span class="line-added">273 </span>
274 } // namespace WebCore
275 
276 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="FetchEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SWClientConnection.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
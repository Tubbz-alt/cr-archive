<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Crypto.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMTimer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMTimer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -159,51 +159,47 @@</span>
  };
  
  bool NestedTimersMap::isTrackingNestedTimers = false;
  
  DOMTimer::DOMTimer(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds interval, bool singleShot)
<span class="udiff-line-modified-removed">-     : SuspendableTimer(context)</span>
<span class="udiff-line-modified-added">+     : SuspendableTimerBase(&amp;context)</span>
      , m_nestingLevel(context.timerNestingLevel())
      , m_action(WTFMove(action))
      , m_originalInterval(interval)
      , m_throttleState(Undetermined)
      , m_currentTimerInterval(intervalClampedToMinimum())
      , m_userGestureTokenToForward(UserGestureIndicator::currentUserGesture())
  {
<span class="udiff-line-removed">-     RefPtr&lt;DOMTimer&gt; reference = adoptRef(this);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.</span>
<span class="udiff-line-removed">-     do {</span>
<span class="udiff-line-removed">-         m_timeoutId = context.circularSequentialID();</span>
<span class="udiff-line-removed">-     } while (!context.addTimeout(m_timeoutId, *this));</span>
<span class="udiff-line-removed">- </span>
      if (singleShot)
          startOneShot(m_currentTimerInterval);
      else
          startRepeating(m_currentTimerInterval);
  }
  
  DOMTimer::~DOMTimer() = default;
  
  int DOMTimer::install(ScriptExecutionContext&amp; context, std::unique_ptr&lt;ScheduledAction&gt; action, Seconds timeout, bool singleShot)
  {
<span class="udiff-line-modified-removed">-     // DOMTimer constructor passes ownership of the initial ref on the object to the constructor.</span>
<span class="udiff-line-removed">-     // This reference will be released automatically when a one-shot timer fires, when the context</span>
<span class="udiff-line-removed">-     // is destroyed, or if explicitly cancelled by removeById.</span>
<span class="udiff-line-removed">-     DOMTimer* timer = new DOMTimer(context, WTFMove(action), timeout, singleShot);</span>
<span class="udiff-line-modified-added">+     Ref&lt;DOMTimer&gt; timer = adoptRef(*new DOMTimer(context, WTFMove(action), timeout, singleShot));</span>
      timer-&gt;suspendIfNeeded();
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Keep asking for the next id until we&#39;re given one that we don&#39;t already have.</span>
<span class="udiff-line-added">+     do {</span>
<span class="udiff-line-added">+         timer-&gt;m_timeoutId = context.circularSequentialID();</span>
<span class="udiff-line-added">+     } while (!context.addTimeout(timer-&gt;m_timeoutId, timer.get()));</span>
<span class="udiff-line-added">+ </span>
      InspectorInstrumentation::didInstallTimer(context, timer-&gt;m_timeoutId, timeout, singleShot);
  
      // Keep track of nested timer installs.
      if (NestedTimersMap* nestedTimers = NestedTimersMap::instanceForContext(context))
<span class="udiff-line-modified-removed">-         nestedTimers-&gt;add(timer-&gt;m_timeoutId, *timer);</span>
<span class="udiff-line-modified-added">+         nestedTimers-&gt;add(timer-&gt;m_timeoutId, timer.get());</span>
  #if PLATFORM(IOS_FAMILY)
      if (is&lt;Document&gt;(context)) {
          auto&amp; document = downcast&lt;Document&gt;(context);
<span class="udiff-line-modified-removed">-         document.contentChangeObserver().didInstallDOMTimer(*timer, timeout, singleShot);</span>
<span class="udiff-line-modified-added">+         document.contentChangeObserver().didInstallDOMTimer(timer.get(), timeout, singleShot);</span>
          if (DeferDOMTimersForScope::isDeferring())
<span class="udiff-line-modified-removed">-             document.domTimerHoldingTank().add(*timer);</span>
<span class="udiff-line-modified-added">+             document.domTimerHoldingTank().add(timer.get());</span>
      }
  #endif
      return timer-&gt;m_timeoutId;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -285,11 +281,11 @@</span>
  void DOMTimer::fired()
  {
      // Retain this - if the timer is cancelled while this function is on the stack (implicitly and always
      // for one-shot timers, or if removeById is called on itself from within an interval timer fire) then
      // wait unit the end of this function to delete DOMTimer.
<span class="udiff-line-modified-removed">-     RefPtr&lt;DOMTimer&gt; reference = this;</span>
<span class="udiff-line-modified-added">+     Ref&lt;DOMTimer&gt; protectedThis(*this);</span>
  
      ASSERT(scriptExecutionContext());
      ScriptExecutionContext&amp; context = *scriptExecutionContext();
  
  #if PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,24 +308,24 @@</span>
      ASSERT(!context.activeDOMObjectsAreSuspended());
      UserGestureIndicator gestureIndicator(m_userGestureTokenToForward);
      // Only the first execution of a multi-shot timer should get an affirmative user gesture indicator.
      m_userGestureTokenToForward = nullptr;
  
<span class="udiff-line-modified-removed">-     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());</span>
<span class="udiff-line-modified-added">+     InspectorInstrumentation::willFireTimer(context, m_timeoutId, !repeatInterval());</span>
  
      // Simple case for non-one-shot timers.
      if (isActive()) {
          if (m_nestingLevel &lt; maxTimerNestingLevel) {
              m_nestingLevel++;
              updateTimerIntervalIfNecessary();
          }
  
          m_action-&gt;execute(context);
  
<span class="udiff-line-modified-removed">-         InspectorInstrumentation::didFireTimer(cookie);</span>
<span class="udiff-line-removed">-         updateThrottlingStateIfNecessary(fireState);</span>
<span class="udiff-line-modified-added">+         InspectorInstrumentation::didFireTimer(context);</span>
  
<span class="udiff-line-added">+         updateThrottlingStateIfNecessary(fireState);</span>
          return;
      }
  
      context.removeTimeout(m_timeoutId);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -341,11 +337,11 @@</span>
  #if PLATFORM(IOS_FAMILY)
      ContentChangeObserver::DOMTimerScope observingScope(is&lt;Document&gt;(context) ? &amp;downcast&lt;Document&gt;(context) : nullptr, *this);
  #endif
      m_action-&gt;execute(context);
  
<span class="udiff-line-modified-removed">-     InspectorInstrumentation::didFireTimer(cookie);</span>
<span class="udiff-line-modified-added">+     InspectorInstrumentation::didFireTimer(context);</span>
  
      // Check if we should throttle nested single-shot timers.
      if (nestedTimers) {
          for (auto&amp; idAndTimer : *nestedTimers) {
              auto&amp; timer = idAndTimer.value;
</pre>
<center><a href="Crypto.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMTimer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
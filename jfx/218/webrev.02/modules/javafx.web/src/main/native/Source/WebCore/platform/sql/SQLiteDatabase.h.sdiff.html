<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/sql/SQLiteDatabase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteDatabase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteStatement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/sql/SQLiteDatabase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 
 48 class SQLiteDatabase {
 49     WTF_MAKE_FAST_ALLOCATED;
 50     WTF_MAKE_NONCOPYABLE(SQLiteDatabase);
 51     friend class SQLiteTransaction;
 52 public:
 53     WEBCORE_EXPORT SQLiteDatabase();
 54     WEBCORE_EXPORT ~SQLiteDatabase();
 55 
 56     enum class OpenMode { ReadOnly, ReadWrite, ReadWriteCreate };
 57     WEBCORE_EXPORT bool open(const String&amp; filename, OpenMode = OpenMode::ReadWriteCreate);
 58     bool isOpen() const { return m_db; }
 59     WEBCORE_EXPORT void close();
 60 
 61     void updateLastChangesCount();
 62 
 63     WEBCORE_EXPORT bool executeCommand(const String&amp;);
 64     bool returnsAtLeastOneResult(const String&amp;);
 65 
 66     WEBCORE_EXPORT bool tableExists(const String&amp;);
<span class="line-modified"> 67     void clearAllTables();</span>
 68     WEBCORE_EXPORT int runVacuumCommand();
 69     int runIncrementalVacuumCommand();
 70 
 71     bool transactionInProgress() const { return m_transactionInProgress; }
 72 
 73     // Aborts the current database operation. This is thread safe.
 74     void interrupt();
 75 
 76     int64_t lastInsertRowID();
 77     int lastChanges();
 78 
 79     void setBusyTimeout(int ms);
 80     void setBusyHandler(int(*)(void*, int));
 81 
 82     void setFullsync(bool);
 83 
 84     // Gets/sets the maximum size in bytes
 85     // Depending on per-database attributes, the size will only be settable in units that are the page size of the database, which is established at creation
 86     // These chunks will never be anything other than 512, 1024, 2048, 4096, 8192, 16384, or 32768 bytes in size.
 87     // setMaximumSize() will round the size down to the next smallest chunk if the passed size doesn&#39;t align.
</pre>
<hr />
<pre>
108         ASSERT(m_sharable || m_openingThread == &amp;Thread::current() || !m_db);
109 #endif
110         return m_db;
111     }
112 
113     void setAuthorizer(DatabaseAuthorizer&amp;);
114 
115     Lock&amp; databaseMutex() { return m_lockingMutex; }
116     bool isAutoCommitOn() const;
117 
118     // The SQLite AUTO_VACUUM pragma can be either NONE, FULL, or INCREMENTAL.
119     // NONE - SQLite does not do any vacuuming
120     // FULL - SQLite moves all empty pages to the end of the DB file and truncates
121     //        the file to remove those pages after every transaction. This option
122     //        requires SQLite to store additional information about each page in
123     //        the database file.
124     // INCREMENTAL - SQLite stores extra information for each page in the database
125     //               file, but removes the empty pages only when PRAGMA INCREMANTAL_VACUUM
126     //               is called.
127     enum AutoVacuumPragma { AutoVacuumNone = 0, AutoVacuumFull = 1, AutoVacuumIncremental = 2 };
<span class="line-modified">128     bool turnOnIncrementalAutoVacuum();</span>
129 
130     WEBCORE_EXPORT void setCollationFunction(const String&amp; collationName, WTF::Function&lt;int(int, const void*, int, const void*)&gt;&amp;&amp;);
131     void removeCollationFunction(const String&amp; collationName);
132 
133     // Set this flag to allow access from multiple threads.  Not all multi-threaded accesses are safe!
134     // See http://www.sqlite.org/cvstrac/wiki?p=MultiThreading for more info.
<span class="line-modified">135 #ifndef NDEBUG</span>
136     WEBCORE_EXPORT void disableThreadingChecks();
137 #else
<span class="line-modified">138     WEBCORE_EXPORT void disableThreadingChecks() {}</span>
139 #endif
140 
141     WEBCORE_EXPORT static void setIsDatabaseOpeningForbidden(bool);
142 
143 private:
144     static int authorizerFunction(void*, int, const char*, const char*, const char*, const char*);
145 
146     void enableAuthorizer(bool enable);
147     void useWALJournalMode();
148 
149     int pageSize();
150 
151     void overrideUnauthorizedFunctions();
152 
153     sqlite3* m_db { nullptr };
154     int m_pageSize { -1 };
155 
156     bool m_transactionInProgress { false };
<span class="line-modified">157 #ifndef NDEBUG</span>
158     bool m_sharable { false };
159 #endif
160 
161     bool m_useWAL { false };
162 
163     Lock m_authorizerLock;
164     RefPtr&lt;DatabaseAuthorizer&gt; m_authorizer;
165 
166     Lock m_lockingMutex;
167     RefPtr&lt;Thread&gt; m_openingThread { nullptr };
168 
169     Lock m_databaseClosingMutex;
170 
171     int m_openError { SQLITE_ERROR };
172     CString m_openErrorMessage;
173 
174     int m_lastChangesCount { 0 };
175 };
176 
177 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 47 
 48 class SQLiteDatabase {
 49     WTF_MAKE_FAST_ALLOCATED;
 50     WTF_MAKE_NONCOPYABLE(SQLiteDatabase);
 51     friend class SQLiteTransaction;
 52 public:
 53     WEBCORE_EXPORT SQLiteDatabase();
 54     WEBCORE_EXPORT ~SQLiteDatabase();
 55 
 56     enum class OpenMode { ReadOnly, ReadWrite, ReadWriteCreate };
 57     WEBCORE_EXPORT bool open(const String&amp; filename, OpenMode = OpenMode::ReadWriteCreate);
 58     bool isOpen() const { return m_db; }
 59     WEBCORE_EXPORT void close();
 60 
 61     void updateLastChangesCount();
 62 
 63     WEBCORE_EXPORT bool executeCommand(const String&amp;);
 64     bool returnsAtLeastOneResult(const String&amp;);
 65 
 66     WEBCORE_EXPORT bool tableExists(const String&amp;);
<span class="line-modified"> 67     WEBCORE_EXPORT void clearAllTables();</span>
 68     WEBCORE_EXPORT int runVacuumCommand();
 69     int runIncrementalVacuumCommand();
 70 
 71     bool transactionInProgress() const { return m_transactionInProgress; }
 72 
 73     // Aborts the current database operation. This is thread safe.
 74     void interrupt();
 75 
 76     int64_t lastInsertRowID();
 77     int lastChanges();
 78 
 79     void setBusyTimeout(int ms);
 80     void setBusyHandler(int(*)(void*, int));
 81 
 82     void setFullsync(bool);
 83 
 84     // Gets/sets the maximum size in bytes
 85     // Depending on per-database attributes, the size will only be settable in units that are the page size of the database, which is established at creation
 86     // These chunks will never be anything other than 512, 1024, 2048, 4096, 8192, 16384, or 32768 bytes in size.
 87     // setMaximumSize() will round the size down to the next smallest chunk if the passed size doesn&#39;t align.
</pre>
<hr />
<pre>
108         ASSERT(m_sharable || m_openingThread == &amp;Thread::current() || !m_db);
109 #endif
110         return m_db;
111     }
112 
113     void setAuthorizer(DatabaseAuthorizer&amp;);
114 
115     Lock&amp; databaseMutex() { return m_lockingMutex; }
116     bool isAutoCommitOn() const;
117 
118     // The SQLite AUTO_VACUUM pragma can be either NONE, FULL, or INCREMENTAL.
119     // NONE - SQLite does not do any vacuuming
120     // FULL - SQLite moves all empty pages to the end of the DB file and truncates
121     //        the file to remove those pages after every transaction. This option
122     //        requires SQLite to store additional information about each page in
123     //        the database file.
124     // INCREMENTAL - SQLite stores extra information for each page in the database
125     //               file, but removes the empty pages only when PRAGMA INCREMANTAL_VACUUM
126     //               is called.
127     enum AutoVacuumPragma { AutoVacuumNone = 0, AutoVacuumFull = 1, AutoVacuumIncremental = 2 };
<span class="line-modified">128     WEBCORE_EXPORT bool turnOnIncrementalAutoVacuum();</span>
129 
130     WEBCORE_EXPORT void setCollationFunction(const String&amp; collationName, WTF::Function&lt;int(int, const void*, int, const void*)&gt;&amp;&amp;);
131     void removeCollationFunction(const String&amp; collationName);
132 
133     // Set this flag to allow access from multiple threads.  Not all multi-threaded accesses are safe!
134     // See http://www.sqlite.org/cvstrac/wiki?p=MultiThreading for more info.
<span class="line-modified">135 #if ASSERT_ENABLED</span>
136     WEBCORE_EXPORT void disableThreadingChecks();
137 #else
<span class="line-modified">138     void disableThreadingChecks() { }</span>
139 #endif
140 
141     WEBCORE_EXPORT static void setIsDatabaseOpeningForbidden(bool);
142 
143 private:
144     static int authorizerFunction(void*, int, const char*, const char*, const char*, const char*);
145 
146     void enableAuthorizer(bool enable);
147     void useWALJournalMode();
148 
149     int pageSize();
150 
151     void overrideUnauthorizedFunctions();
152 
153     sqlite3* m_db { nullptr };
154     int m_pageSize { -1 };
155 
156     bool m_transactionInProgress { false };
<span class="line-modified">157 #if ASSERT_ENABLED</span>
158     bool m_sharable { false };
159 #endif
160 
161     bool m_useWAL { false };
162 
163     Lock m_authorizerLock;
164     RefPtr&lt;DatabaseAuthorizer&gt; m_authorizer;
165 
166     Lock m_lockingMutex;
167     RefPtr&lt;Thread&gt; m_openingThread { nullptr };
168 
169     Lock m_databaseClosingMutex;
170 
171     int m_openError { SQLITE_ERROR };
172     CString m_openErrorMessage;
173 
174     int m_lastChangesCount { 0 };
175 };
176 
177 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="SQLiteDatabase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteStatement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
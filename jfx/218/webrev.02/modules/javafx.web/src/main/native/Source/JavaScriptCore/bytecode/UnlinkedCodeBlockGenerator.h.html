<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlockGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #pragma once
 28 
 29 #include &quot;UnlinkedCodeBlock.h&quot;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace JSC {
 33 
 34 // FIXME: Create UnlinkedCodeBlock inside UnlinkedCodeBlockGenerator.
 35 // https://bugs.webkit.org/show_bug.cgi?id=207212
 36 class UnlinkedCodeBlockGenerator {
 37     WTF_MAKE_FAST_ALLOCATED;
 38     WTF_MAKE_NONCOPYABLE(UnlinkedCodeBlockGenerator)
 39 public:
 40     UnlinkedCodeBlockGenerator(VM&amp; vm, UnlinkedCodeBlock* codeBlock)
 41         : m_vm(vm)
 42         , m_codeBlock(vm, codeBlock)
 43     {
 44     }
 45 
 46     VM&amp; vm() { return m_vm; }
 47 
 48     bool isConstructor() const { return m_codeBlock-&gt;isConstructor(); }
 49     ConstructorKind constructorKind() const { return m_codeBlock-&gt;constructorKind(); }
 50     SuperBinding superBinding() const { return m_codeBlock-&gt;superBinding(); }
 51     JSParserScriptMode scriptMode() const { return m_codeBlock-&gt;scriptMode(); }
 52     NeedsClassFieldInitializer needsClassFieldInitializer() const { return m_codeBlock-&gt;needsClassFieldInitializer(); }
 53     bool isStrictMode() const { return m_codeBlock-&gt;isStrictMode(); }
 54     bool usesEval() const { return m_codeBlock-&gt;usesEval(); }
 55     SourceParseMode parseMode() const { return m_codeBlock-&gt;parseMode(); }
 56     bool isArrowFunction() { return m_codeBlock-&gt;isArrowFunction(); }
 57     DerivedContextType derivedContextType() const { return m_codeBlock-&gt;derivedContextType(); }
 58     EvalContextType evalContextType() const { return m_codeBlock-&gt;evalContextType(); }
 59     bool isArrowFunctionContext() const { return m_codeBlock-&gt;isArrowFunctionContext(); }
 60     bool isClassContext() const { return m_codeBlock-&gt;isClassContext(); }
 61     int numCalleeLocals() const { return m_codeBlock-&gt;m_numCalleeLocals; }
 62     int numVars() const { return m_codeBlock-&gt;m_numVars; }
 63     unsigned numParameters() const { return m_codeBlock-&gt;numParameters(); }
 64     VirtualRegister thisRegister() const { return m_codeBlock-&gt;thisRegister(); }
 65     VirtualRegister scopeRegister() const { return m_codeBlock-&gt;scopeRegister(); }
 66     bool wasCompiledWithDebuggingOpcodes() const { return m_codeBlock-&gt;wasCompiledWithDebuggingOpcodes(); }
 67     bool hasCheckpoints() const { return m_codeBlock-&gt;hasCheckpoints(); }
 68     bool hasTailCalls() const { return m_codeBlock-&gt;hasTailCalls(); }
 69 
 70     // Updating UnlinkedCodeBlock.
 71     void setHasCheckpoints() { m_codeBlock-&gt;setHasCheckpoints(); }
 72     void setHasTailCalls() { m_codeBlock-&gt;setHasTailCalls(); }
 73     void setNumCalleeLocals(int numCalleeLocals) { m_codeBlock-&gt;m_numCalleeLocals = numCalleeLocals; }
 74     void setNumVars(int numVars) { m_codeBlock-&gt;m_numVars = numVars; }
 75     void setThisRegister(VirtualRegister thisRegister) { m_codeBlock-&gt;setThisRegister(thisRegister); }
 76     void setScopeRegister(VirtualRegister thisRegister) { m_codeBlock-&gt;setScopeRegister(thisRegister); }
 77     void setNumParameters(int newValue) { m_codeBlock-&gt;setNumParameters(newValue); }
 78 
 79     UnlinkedMetadataTable&amp; metadata() { return m_codeBlock-&gt;metadata(); }
 80     void addExpressionInfo(unsigned instructionOffset, int divot, int startOffset, int endOffset, unsigned line, unsigned column);
 81     void addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot);
 82     void addOpProfileControlFlowBytecodeOffset(InstructionStream::Offset offset)
 83     {
 84         m_opProfileControlFlowBytecodeOffsets.append(offset);
 85     }
 86 
 87     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
 88     void addJumpTarget(unsigned jumpTarget) { m_jumpTargets.append(jumpTarget); }
 89     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
 90     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
 91 
 92     size_t numberOfSwitchJumpTables() const { return m_switchJumpTables.size(); }
 93     UnlinkedSimpleJumpTable&amp; addSwitchJumpTable() { m_switchJumpTables.append(UnlinkedSimpleJumpTable()); return m_switchJumpTables.last(); }
 94     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { return m_switchJumpTables[tableIndex]; }
 95 
 96     size_t numberOfStringSwitchJumpTables() const { return m_stringSwitchJumpTables.size(); }
 97     UnlinkedStringJumpTable&amp; addStringSwitchJumpTable() { m_stringSwitchJumpTables.append(UnlinkedStringJumpTable()); return m_stringSwitchJumpTables.last(); }
 98     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { return m_stringSwitchJumpTables[tableIndex]; }
 99 
100     size_t numberOfExceptionHandlers() const { return m_exceptionHandlers.size(); }
101     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { return m_exceptionHandlers[index]; }
102     void addExceptionHandler(const UnlinkedHandlerInfo&amp; handler) { m_exceptionHandlers.append(handler); }
103     UnlinkedHandlerInfo* handlerForBytecodeIndex(BytecodeIndex, RequiredHandler = RequiredHandler::AnyHandler);
104     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
105 
106     BitVector&amp; bitVector(size_t i) { return m_bitVectors[i]; }
107     unsigned addBitVector(BitVector&amp;&amp; bitVector)
108     {
109         m_bitVectors.append(WTFMove(bitVector));
110         return m_bitVectors.size() - 1;
111     }
112 
113     unsigned numberOfConstantIdentifierSets() const { return m_constantIdentifierSets.size(); }
114     const Vector&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { return m_constantIdentifierSets; }
115     void addSetConstant(IdentifierSet&amp; set)
116     {
117         ASSERT(m_vm.heap.isDeferred());
118         unsigned result = m_constantRegisters.size();
119         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());
120         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);
121         m_constantIdentifierSets.append(ConstantIdentifierSetEntry(set, result));
122     }
123 
124     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()]; }
125     const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }
126     ALWAYS_INLINE JSValue getConstant(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()].get(); }
127     const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }
128 
129     unsigned addConstant(JSValue v, SourceCodeRepresentation sourceCodeRepresentation = SourceCodeRepresentation::Other)
130     {
131         ASSERT(m_vm.heap.isDeferred());
132         unsigned result = m_constantRegisters.size();
133         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());
134         m_constantRegisters.last().setWithoutWriteBarrier(v);
135         m_constantsSourceCodeRepresentation.append(sourceCodeRepresentation);
136         return result;
137     }
138     unsigned addConstant(LinkTimeConstant linkTimeConstant)
139     {
140         ASSERT(m_vm.heap.isDeferred());
141         unsigned result = m_constantRegisters.size();
142         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());
143         m_constantRegisters.last().setWithoutWriteBarrier(jsNumber(static_cast&lt;int32_t&gt;(linkTimeConstant)));
144         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::LinkTimeConstant);
145         return result;
146     }
147 
148     unsigned addFunctionDecl(UnlinkedFunctionExecutable* n)
149     {
150         ASSERT(m_vm.heap.isDeferred());
151         unsigned size = m_functionDecls.size();
152         m_functionDecls.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());
153         m_functionDecls.last().setWithoutWriteBarrier(n);
154         return size;
155     }
156 
157     unsigned addFunctionExpr(UnlinkedFunctionExecutable* n)
158     {
159         unsigned size = m_functionExprs.size();
160         m_functionExprs.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());
161         m_functionExprs.last().setWithoutWriteBarrier(n);
162         return size;
163     }
164 
165     size_t numberOfIdentifiers() const { return m_identifiers.size(); }
166     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
167     void addIdentifier(const Identifier&amp; i) { return m_identifiers.append(i); }
168 
169     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
170     void addOutOfLineJumpTarget(InstructionStream::Offset, int target);
171     int outOfLineJumpOffset(InstructionStream::Offset);
172     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
173     {
174         return outOfLineJumpOffset(instruction.offset());
175     }
176     OutOfLineJumpTargets replaceOutOfLineJumpTargets()
177     {
178         OutOfLineJumpTargets newJumpTargets;
179         std::swap(m_outOfLineJumpTargets, newJumpTargets);
180         return newJumpTargets;
181     }
182 
183     size_t metadataSizeInBytes() { return m_codeBlock-&gt;metadataSizeInBytes(); }
184 
185     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
186 
187     void applyModification(BytecodeRewriter&amp;, InstructionStreamWriter&amp;);
188 
189     void finalize(std::unique_ptr&lt;InstructionStream&gt;);
190 
191     void dump(PrintStream&amp;) const;
192 
193 private:
194     VM&amp; m_vm;
195     Strong&lt;UnlinkedCodeBlock&gt; m_codeBlock;
196     // In non-RareData.
197     Vector&lt;InstructionStream::Offset&gt; m_jumpTargets;
198     Vector&lt;Identifier&gt; m_identifiers;
199     Vector&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;
200     Vector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;
201     Vector&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt; m_functionDecls;
202     Vector&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt; m_functionExprs;
203     Vector&lt;ExpressionRangeInfo&gt; m_expressionInfo;
204     OutOfLineJumpTargets m_outOfLineJumpTargets;
205     // In RareData.
206     Vector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;
207     Vector&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;
208     Vector&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;
209     Vector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;
210     HashMap&lt;unsigned, UnlinkedCodeBlock::RareData::TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
211     Vector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;
212     Vector&lt;BitVector&gt; m_bitVectors;
213     Vector&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;
214 };
215 
216 } // namespace JSC
    </pre>
  </body>
</html>
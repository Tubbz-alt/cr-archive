<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SMILTimeContainer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGSMILElement.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 243,11 ***</span>
      });
  }
  
  void SVGSMILElement::reset()
  {
<span class="line-modified">!     clearAnimatedType(m_targetElement);</span>
  
      m_activeState = Inactive;
      m_isWaitingForFirstInterval = true;
      m_intervalBegin = SMILTime::unresolved();
      m_intervalEnd = SMILTime::unresolved();
<span class="line-new-header">--- 243,11 ---</span>
      });
  }
  
  void SVGSMILElement::reset()
  {
<span class="line-modified">!     stopAnimation(m_targetElement);</span>
  
      m_activeState = Inactive;
      m_isWaitingForFirstInterval = true;
      m_intervalBegin = SMILTime::unresolved();
      m_intervalEnd = SMILTime::unresolved();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,11 ***</span>
      } else
          m_attributeName = attributeName;
  
      // Only clear the animated type, if we had a target before.
      if (m_targetElement)
<span class="line-modified">!         clearAnimatedType(m_targetElement);</span>
  }
  
  void SVGSMILElement::setTargetElement(SVGElement* target)
  {
      if (m_timeContainer &amp;&amp; hasValidAttributeName()) {
<span class="line-new-header">--- 608,11 ---</span>
      } else
          m_attributeName = attributeName;
  
      // Only clear the animated type, if we had a target before.
      if (m_targetElement)
<span class="line-modified">!         stopAnimation(m_targetElement);</span>
  }
  
  void SVGSMILElement::setTargetElement(SVGElement* target)
  {
      if (m_timeContainer &amp;&amp; hasValidAttributeName()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,11 ***</span>
              m_timeContainer-&gt;schedule(this, target, m_attributeName);
      }
  
      if (m_targetElement) {
          // Clear values that may depend on the previous target.
<span class="line-modified">!         clearAnimatedType(m_targetElement);</span>
          disconnectConditions();
      }
  
      // If the animation state is not Inactive, always reset to a clear state before leaving the old target element.
      if (m_activeState != Inactive)
<span class="line-new-header">--- 622,11 ---</span>
              m_timeContainer-&gt;schedule(this, target, m_attributeName);
      }
  
      if (m_targetElement) {
          // Clear values that may depend on the previous target.
<span class="line-modified">!         stopAnimation(m_targetElement);</span>
          disconnectConditions();
      }
  
      // If the animation state is not Inactive, always reset to a clear state before leaving the old target element.
      if (m_activeState != Inactive)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1068,13 ***</span>
  {
      // Animation does not contribute during the active time if it is past its repeating duration and has fill=remove.
      return (m_activeState == Active &amp;&amp; (fill() == FillFreeze || elapsed &lt;= m_intervalBegin + repeatingDuration())) || m_activeState == Frozen;
  }
  
<span class="line-modified">! bool SVGSMILElement::progress(SMILTime elapsed, SVGSMILElement* resultElement, bool seekToTime)</span>
  {
<span class="line-removed">-     ASSERT(resultElement);</span>
      ASSERT(m_timeContainer);
      ASSERT(m_isWaitingForFirstInterval || m_intervalBegin.isFinite());
  
      if (!m_intervalBegin.isFinite()) {
          ASSERT(m_activeState == Inactive);
<span class="line-new-header">--- 1068,12 ---</span>
  {
      // Animation does not contribute during the active time if it is past its repeating duration and has fill=remove.
      return (m_activeState == Active &amp;&amp; (fill() == FillFreeze || elapsed &lt;= m_intervalBegin + repeatingDuration())) || m_activeState == Frozen;
  }
  
<span class="line-modified">! bool SVGSMILElement::progress(SMILTime elapsed, SVGSMILElement&amp; firstAnimation, bool seekToTime)</span>
  {
      ASSERT(m_timeContainer);
      ASSERT(m_isWaitingForFirstInterval || m_intervalBegin.isFinite());
  
      if (!m_intervalBegin.isFinite()) {
          ASSERT(m_activeState == Inactive);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1083,13 ***</span>
      }
  
      if (elapsed &lt; m_intervalBegin) {
          ASSERT(m_activeState != Active);
          if (m_activeState == Frozen) {
<span class="line-modified">!             if (this == resultElement)</span>
<span class="line-modified">!                 resetAnimatedType();</span>
<span class="line-modified">!             updateAnimation(m_lastPercent, m_lastRepeat, resultElement);</span>
          }
          m_nextProgressTime = m_intervalBegin;
          return false;
      }
  
<span class="line-new-header">--- 1082,13 ---</span>
      }
  
      if (elapsed &lt; m_intervalBegin) {
          ASSERT(m_activeState != Active);
          if (m_activeState == Frozen) {
<span class="line-modified">!             if (this == &amp;firstAnimation)</span>
<span class="line-modified">!                 startAnimation();</span>
<span class="line-modified">!             updateAnimation(m_lastPercent, m_lastRepeat);</span>
          }
          m_nextProgressTime = m_intervalBegin;
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1116,28 ***</span>
  
      ActiveState oldActiveState = m_activeState;
      m_activeState = determineActiveState(elapsed);
      bool animationIsContributing = isContributing(elapsed);
  
<span class="line-removed">-     // Only reset the animated type to the base value once for the lowest priority animation that animates and contributes to a particular element/attribute pair.</span>
<span class="line-removed">-     if (this == resultElement &amp;&amp; animationIsContributing)</span>
<span class="line-removed">-         resetAnimatedType();</span>
<span class="line-removed">- </span>
      if (animationIsContributing) {
          if (oldActiveState == Inactive)
              startedActiveInterval();
  
<span class="line-modified">!         updateAnimation(percent, repeat, resultElement);</span>
          m_lastPercent = percent;
          m_lastRepeat = repeat;
      }
  
      if (oldActiveState == Active &amp;&amp; m_activeState != Active) {
          smilEndEventSender().dispatchEventSoon(*this);
          endedActiveInterval();
          if (m_activeState != Frozen)
<span class="line-modified">!             clearAnimatedType(m_targetElement);</span>
      } else if (oldActiveState != Active &amp;&amp; m_activeState == Active)
          smilBeginEventSender().dispatchEventSoon(*this);
  
      // Triggering all the pending events if the animation timeline is changed.
      if (seekToTime) {
<span class="line-new-header">--- 1115,28 ---</span>
  
      ActiveState oldActiveState = m_activeState;
      m_activeState = determineActiveState(elapsed);
      bool animationIsContributing = isContributing(elapsed);
  
      if (animationIsContributing) {
<span class="line-added">+         // Only start the animation of the lowest priority animation that animates and contributes to a particular element/attribute pair.</span>
<span class="line-added">+         if (this == &amp;firstAnimation)</span>
<span class="line-added">+             startAnimation();</span>
<span class="line-added">+ </span>
          if (oldActiveState == Inactive)
              startedActiveInterval();
  
<span class="line-modified">!         updateAnimation(percent, repeat);</span>
          m_lastPercent = percent;
          m_lastRepeat = repeat;
      }
  
      if (oldActiveState == Active &amp;&amp; m_activeState != Active) {
          smilEndEventSender().dispatchEventSoon(*this);
          endedActiveInterval();
          if (m_activeState != Frozen)
<span class="line-modified">!             stopAnimation(m_targetElement);</span>
      } else if (oldActiveState != Active &amp;&amp; m_activeState == Active)
          smilBeginEventSender().dispatchEventSoon(*this);
  
      // Triggering all the pending events if the animation timeline is changed.
      if (seekToTime) {
</pre>
<center><a href="SMILTimeContainer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGSMILElement.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
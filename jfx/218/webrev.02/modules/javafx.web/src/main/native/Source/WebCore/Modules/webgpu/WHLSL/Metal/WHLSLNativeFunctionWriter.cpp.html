<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLNativeFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLNativeFunctionWriter.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;NotImplemented.h&quot;
 32 #include &quot;WHLSLAddressSpace.h&quot;
 33 #include &quot;WHLSLArrayType.h&quot;
 34 #include &quot;WHLSLEnumerationDefinition.h&quot;
 35 #include &quot;WHLSLInferTypes.h&quot;
 36 #include &quot;WHLSLIntrinsics.h&quot;
 37 #include &quot;WHLSLNamedType.h&quot;
 38 #include &quot;WHLSLNativeFunctionDeclaration.h&quot;
 39 #include &quot;WHLSLNativeTypeDeclaration.h&quot;
 40 #include &quot;WHLSLPointerType.h&quot;
 41 #include &quot;WHLSLStructureDefinition.h&quot;
 42 #include &quot;WHLSLTypeDefinition.h&quot;
 43 #include &quot;WHLSLTypeNamer.h&quot;
 44 #include &quot;WHLSLUnnamedType.h&quot;
 45 #include &quot;WHLSLVariableDeclaration.h&quot;
 46 #include &lt;wtf/text/StringBuilder.h&gt;
 47 
 48 namespace WebCore {
 49 
 50 namespace WHLSL {
 51 
 52 namespace Metal {
 53 
 54 static String mapFunctionName(String&amp; functionName)
 55 {
 56     if (functionName == &quot;ddx&quot;)
 57         return &quot;dfdx&quot;_str;
 58     if (functionName == &quot;ddy&quot;)
 59         return &quot;dfdy&quot;_str;
 60     if (functionName == &quot;asint&quot;)
 61         return &quot;as_type&lt;int32_t&gt;&quot;_str;
 62     if (functionName == &quot;asuint&quot;)
 63         return &quot;as_type&lt;uint32_t&gt;&quot;_str;
 64     if (functionName == &quot;asfloat&quot;)
 65         return &quot;as_type&lt;float&gt;&quot;_str;
 66     return functionName;
 67 }
 68 
 69 static String atomicName(String input)
 70 {
 71     if (input == &quot;Add&quot;)
 72         return &quot;fetch_add&quot;_str;
 73     if (input == &quot;And&quot;)
 74         return &quot;fetch_and&quot;_str;
 75     if (input == &quot;Exchange&quot;)
 76         return &quot;exchange&quot;_str;
 77     if (input == &quot;Max&quot;)
 78         return &quot;fetch_max&quot;_str;
 79     if (input == &quot;Min&quot;)
 80         return &quot;fetch_min&quot;_str;
 81     if (input == &quot;Or&quot;)
 82         return &quot;fetch_or&quot;_str;
 83     ASSERT(input == &quot;Xor&quot;);
 84         return &quot;fetch_xor&quot;_str;
 85 }
 86 
 87 static int vectorLength(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
 88 {
 89     int vectorLength = 1;
 90     if (!nativeTypeDeclaration.typeArguments().isEmpty()) {
 91         ASSERT(nativeTypeDeclaration.typeArguments().size() == 2);
 92         ASSERT(WTF::holds_alternative&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]));
 93         vectorLength = WTF::get&lt;AST::ConstantExpression&gt;(nativeTypeDeclaration.typeArguments()[1]).integerLiteral().value();
 94     }
 95     return vectorLength;
 96 }
 97 
 98 static const char* vectorSuffix(int vectorLength)
 99 {
100     switch (vectorLength) {
101     case 1:
102         return &quot;&quot;;
103     case 2:
104         return &quot;2&quot;;
105     case 3:
106         return &quot;3&quot;;
107     default:
108         ASSERT(vectorLength == 4);
109         return &quot;4&quot;;
110     }
111 }
112 
113 enum class SampleType {
114     Sample,
115     SampleLevel,
116     SampleBias,
117     SampleGrad
118 };
119 
120 static Optional&lt;SampleType&gt; sampleType(const String&amp; functionName)
121 {
122     if (functionName == &quot;Sample&quot;)
123         return SampleType::Sample;
124     if (functionName == &quot;SampleLevel&quot;)
125         return SampleType::SampleLevel;
126     if (functionName == &quot;SampleBias&quot;)
127         return SampleType::SampleBias;
128     if (functionName == &quot;SampleGrad&quot;)
129         return SampleType::SampleGrad;
130     return WTF::nullopt;
131 }
132 
133 void inlineNativeFunction(StringBuilder&amp; stringBuilder, AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration, const Vector&lt;MangledVariableName&gt;&amp; args, MangledVariableName resultName, TypeNamer&amp; typeNamer)
134 {
135     auto asMatrixType = [&amp;] (AST::UnnamedType&amp; unnamedType) -&gt; AST::NativeTypeDeclaration* {
136         auto&amp; realType = unnamedType.unifyNode();
137         if (!realType.isNativeTypeDeclaration())
138             return nullptr;
139 
140         auto&amp; maybeMatrixType = downcast&lt;AST::NativeTypeDeclaration&gt;(realType);
141         if (maybeMatrixType.isMatrix())
142             return &amp;maybeMatrixType;
143 
144         return nullptr;
145     };
146 
147     if (nativeFunctionDeclaration.isCast()) {
148         auto&amp; returnType = nativeFunctionDeclaration.type();
149         auto metalReturnTypeName = typeNamer.mangledNameForType(returnType);
150 
151         if (!nativeFunctionDeclaration.parameters().size()) {
152             stringBuilder.append(metalReturnTypeName, &quot; { }&quot;);
153             return;
154         }
155 
156         if (nativeFunctionDeclaration.parameters().size() == 1) {
157             auto&amp; parameterType = *nativeFunctionDeclaration.parameters()[0]-&gt;type();
158 
159             auto isEnumerationDefinition = [] (auto&amp; type) {
160                 return is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(type));
161             };
162             auto&amp; unifiedReturnType = returnType.unifyNode();
163             if (isEnumerationDefinition(unifiedReturnType) &amp;&amp; !isEnumerationDefinition(parameterType.unifyNode())) {
164                 auto&amp; enumerationDefinition = downcast&lt;AST::EnumerationDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifiedReturnType));
165                 stringBuilder.append(&quot;static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;((&quot;);
166                 bool loopedOnce = false;
167                 bool hasZeroCase = false;
168                 for (auto&amp; member : enumerationDefinition.enumerationMembers()) {
169                     if (loopedOnce)
170                         stringBuilder.append(&quot; || &quot;);
171                     hasZeroCase |= !member.get().value();
172                     stringBuilder.append(args[0], &quot; == &quot;, member.get().value());
173                     loopedOnce = true;
174                 }
175                 ASSERT_UNUSED(hasZeroCase, hasZeroCase);
176 
177                 stringBuilder.append(&quot;) ? &quot;, args[0], &quot; : 0)&quot;);
178             } else
179                 stringBuilder.append(&quot;static_cast&lt;&quot;, metalReturnTypeName, &quot;&gt;(&quot;, args[0], &quot;)&quot;);
180 
181             return;
182         }
183 
184         if (auto* matrixType = asMatrixType(returnType)) {
185             // We&#39;re either constructing with all individual elements, or with
186             // vectors for each column.
187 
188             stringBuilder.append(&#39;(&#39;);
189             if (args.size() == matrixType-&gt;numberOfMatrixColumns()) {
190                 // Constructing with vectors for each column.
191                 for (size_t i = 0; i &lt; args.size(); ++i) {
192                     if (i)
193                         stringBuilder.append(&quot;, &quot;);
194                     stringBuilder.append(resultName, &quot;.columns[&quot;, i, &quot;] = &quot;, args[i]);
195                 }
196             } else {
197                 // Constructing with all elements.
198                 RELEASE_ASSERT(args.size() == matrixType-&gt;numberOfMatrixColumns() * matrixType-&gt;numberOfMatrixRows());
199 
200                 size_t argNumber = 0;
201                 for (size_t i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {
202                     for (size_t j = 0; j &lt; matrixType-&gt;numberOfMatrixRows(); ++j) {
203                         if (argNumber)
204                             stringBuilder.append(&quot;, &quot;);
205                         stringBuilder.append(resultName, &quot;.columns[&quot;, i, &quot;][&quot;, j, &quot;] = &quot;, args[argNumber]);
206                         ++argNumber;
207                     }
208                 }
209             }
210 
211             stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);
212             return;
213         }
214 
215         stringBuilder.append(metalReturnTypeName, &#39;(&#39;);
216         for (unsigned i = 0; i &lt; nativeFunctionDeclaration.parameters().size(); ++i) {
217             if (i)
218                 stringBuilder.append(&quot;, &quot;);
219             stringBuilder.append(args[i]);
220         }
221         stringBuilder.append(&#39;)&#39;);
222         return;
223     }
224 
225     if (nativeFunctionDeclaration.isOperator()) {
226         auto operatorName = nativeFunctionDeclaration.name().substring(&quot;operator&quot;_str.length());
227 
228         if (nativeFunctionDeclaration.parameters().size() == 1) {
229             // This is ok to do since the args to this function are all temps.
230             // So things like ++ and -- are ok to do.
231 
232             if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {
233                 stringBuilder.append(&#39;(&#39;);
234                 for (unsigned i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {
235                     if (i)
236                         stringBuilder.append(&quot;, &quot;);
237                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, operatorName, args[0], &#39;[&#39;, i, &#39;]&#39;);
238                 }
239                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);
240             } else
241                 stringBuilder.append(operatorName, args[0]);
242             return;
243         }
244 
245         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
246         if (auto* leftMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type())) {
247             if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
248                 // matrix &lt;op&gt; matrix
249                 stringBuilder.append(&#39;(&#39;);
250                 for (unsigned i = 0; i &lt; leftMatrix-&gt;numberOfMatrixColumns(); ++i) {
251                     if (i)
252                         stringBuilder.append(&quot;, &quot;);
253                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39;[&#39;, i, &quot;] &quot;, operatorName, &#39; &#39;, args[1], &#39;[&#39;, i, &#39;]&#39;);
254                 }
255                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);
256             } else {
257                 // matrix &lt;op&gt; scalar
258                 stringBuilder.append(&#39;(&#39;);
259                 for (unsigned i = 0; i &lt; leftMatrix-&gt;numberOfMatrixColumns(); ++i) {
260                     if (i)
261                         stringBuilder.append(&quot;, &quot;);
262                     stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39;[&#39;, i, &quot;] &quot;, operatorName, &#39; &#39;, args[1]);
263                 }
264                 stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);
265             }
266         } else if (auto* rightMatrix = asMatrixType(*nativeFunctionDeclaration.parameters()[1]-&gt;type())) {
267             ASSERT(!asMatrixType(*nativeFunctionDeclaration.parameters()[0]-&gt;type()));
268             // scalar &lt;op&gt; matrix
269             stringBuilder.append(&#39;(&#39;);
270             for (unsigned i = 0; i &lt; rightMatrix-&gt;numberOfMatrixColumns(); ++i) {
271                 if (i)
272                     stringBuilder.append(&quot;, &quot;);
273                 stringBuilder.append(resultName, &#39;[&#39;, i, &quot;] = &quot;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &#39;[&#39;, i, &#39;]&#39;);
274             }
275             stringBuilder.append(&quot;, &quot;, resultName, &#39;)&#39;);
276         } else {
277             // scalar &lt;op&gt; scalar
278             // vector &lt;op&gt; vector
279             // vector &lt;op&gt; scalar
280             // scalar &lt;op&gt; vector
281             stringBuilder.append(
282                 &#39;(&#39;, args[0], &#39; &#39;, operatorName, &#39; &#39;, args[1], &#39;)&#39;);
283         }
284 
285         return;
286     }
287 
288     if (nativeFunctionDeclaration.name() == &quot;cos&quot;
289         || nativeFunctionDeclaration.name() == &quot;sin&quot;
290         || nativeFunctionDeclaration.name() == &quot;tan&quot;
291         || nativeFunctionDeclaration.name() == &quot;acos&quot;
292         || nativeFunctionDeclaration.name() == &quot;asin&quot;
293         || nativeFunctionDeclaration.name() == &quot;atan&quot;
294         || nativeFunctionDeclaration.name() == &quot;cosh&quot;
295         || nativeFunctionDeclaration.name() == &quot;sinh&quot;
296         || nativeFunctionDeclaration.name() == &quot;tanh&quot;
297         || nativeFunctionDeclaration.name() == &quot;ceil&quot;
298         || nativeFunctionDeclaration.name() == &quot;exp&quot;
299         || nativeFunctionDeclaration.name() == &quot;floor&quot;
300         || nativeFunctionDeclaration.name() == &quot;log&quot;
301         || nativeFunctionDeclaration.name() == &quot;round&quot;
302         || nativeFunctionDeclaration.name() == &quot;trunc&quot;
303         || nativeFunctionDeclaration.name() == &quot;ddx&quot;
304         || nativeFunctionDeclaration.name() == &quot;ddy&quot;
305         || nativeFunctionDeclaration.name() == &quot;isnormal&quot;
306         || nativeFunctionDeclaration.name() == &quot;isfinite&quot;
307         || nativeFunctionDeclaration.name() == &quot;isinf&quot;
308         || nativeFunctionDeclaration.name() == &quot;isnan&quot;
309         || nativeFunctionDeclaration.name() == &quot;asint&quot;
310         || nativeFunctionDeclaration.name() == &quot;asuint&quot;
311         || nativeFunctionDeclaration.name() == &quot;asfloat&quot;
312         || nativeFunctionDeclaration.name() == &quot;length&quot;) {
313         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
314         stringBuilder.append(
315             mapFunctionName(nativeFunctionDeclaration.name()), &#39;(&#39;, args[0], &#39;)&#39;);
316         return;
317     }
318 
319     if (nativeFunctionDeclaration.name() == &quot;pow&quot; || nativeFunctionDeclaration.name() == &quot;atan2&quot;) {
320         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
321         stringBuilder.append(
322             nativeFunctionDeclaration.name(), &#39;(&#39;, args[0], &quot;, &quot;, args[1], &#39;)&#39;);
323         return;
324     }
325 
326     if (nativeFunctionDeclaration.name() == &quot;clamp&quot;) {
327         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
328 
329         if (auto* matrixType = asMatrixType(nativeFunctionDeclaration.type())) {
330             stringBuilder.append(&#39;(&#39;);
331             bool ranOnce = false;
332             for (unsigned i = 0; i &lt; matrixType-&gt;numberOfMatrixColumns(); ++i) {
333                 for (unsigned j = 0; j &lt; matrixType-&gt;numberOfMatrixRows(); ++j) {
334                     if (ranOnce)
335                         stringBuilder.append(&quot;, &quot;);
336                     ranOnce = true;
337                     stringBuilder.append(
338                         resultName, &#39;[&#39;, i, &quot;][&quot;, j, &quot;] = clamp(&quot;, args[0], &#39;[&#39;, i, &quot;][&quot;, j, &quot;], &quot;, args[1], &#39;[&#39;, i, &quot;][&quot;, j, &quot;], &quot;, args[2], &#39;[&#39;, i, &quot;][&quot;, j, &quot;])&quot;);
339                 }
340             }
341             stringBuilder.append(&quot;, &quot;, resultName, &quot;)&quot;);
342         } else {
343             stringBuilder.append(
344                 &quot;clamp(&quot;, args[0], &quot;, &quot;, args[1], &quot;, &quot;, args[2], &#39;)&#39;);
345         }
346         return;
347     }
348 
349     if (nativeFunctionDeclaration.name() == &quot;AllMemoryBarrierWithGroupSync&quot;) {
350         ASSERT(!nativeFunctionDeclaration.parameters().size());
351         stringBuilder.append(
352             &quot;(threadgroup_barrier(mem_flags::mem_device), threadgroup_barrier(mem_flags::mem_threadgroup), threadgroup_barrier(mem_flags::mem_texture))&quot;);
353         return;
354     }
355 
356     if (nativeFunctionDeclaration.name() == &quot;DeviceMemoryBarrierWithGroupSync&quot;) {
357         ASSERT(!nativeFunctionDeclaration.parameters().size());
358         stringBuilder.append(
359             &quot;threadgroup_barrier(mem_flags::mem_device)&quot;);
360         return;
361     }
362 
363     if (nativeFunctionDeclaration.name() == &quot;GroupMemoryBarrierWithGroupSync&quot;) {
364         ASSERT(!nativeFunctionDeclaration.parameters().size());
365         stringBuilder.append(
366             &quot;threadgroup_barrier(mem_flags::mem_threadgroup)&quot;);
367         return;
368     }
369 
370     if (nativeFunctionDeclaration.name().startsWith(&quot;Interlocked&quot;_str)) {
371         if (nativeFunctionDeclaration.name() == &quot;InterlockedCompareExchange&quot;) {
372             ASSERT(nativeFunctionDeclaration.parameters().size() == 4);
373             stringBuilder.append(
374                 &quot;(atomic_compare_exchange_weak_explicit(&quot;, args[0], &quot;, &amp;&quot;, args[1], &quot;, &quot;, args[2], &quot;, memory_order_relaxed, memory_order_relaxed), &quot;,
375                 &#39;*&#39;, args[3], &quot; = &quot;, args[1], &#39;)&#39;);
376             return;
377         }
378 
379         ASSERT(nativeFunctionDeclaration.parameters().size() == 3);
380         auto name = atomicName(nativeFunctionDeclaration.name().substring(&quot;Interlocked&quot;_str.length()));
381         stringBuilder.append(
382             &#39;*&#39;, args[2], &quot; = atomic_&quot;, name, &quot;_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed)&quot;);
383         return;
384     }
385 
386     if (auto sampleType = WHLSL::Metal::sampleType(nativeFunctionDeclaration.name())) {
387         size_t baseArgumentCount = 0;
388         switch (*sampleType) {
389         case SampleType::Sample:
390             baseArgumentCount = 3;
391             break;
392         case SampleType::SampleLevel:
393         case SampleType::SampleBias:
394             baseArgumentCount = 4;
395             break;
396         case SampleType::SampleGrad:
397             baseArgumentCount = 5;
398             break;
399         }
400         ASSERT(nativeFunctionDeclaration.parameters().size() == baseArgumentCount || nativeFunctionDeclaration.parameters().size() == baseArgumentCount + 1);
401 
402         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
403         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[2]-&gt;type()-&gt;unifyNode()));
404         auto locationVectorLength = vectorLength(locationType);
405         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
406         auto returnVectorLength = vectorLength(returnType);
407 
408         int argumentIndex = 0;
409         stringBuilder.append(args[argumentIndex], &quot;.sample(&quot;, args[argumentIndex + 1], &quot;, &quot;);
410         argumentIndex += 2;
411 
412         if (textureType.isTextureArray()) {
413             ASSERT(locationVectorLength &gt; 1);
414             stringBuilder.append(args[argumentIndex], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;, &quot;, args[argumentIndex], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1));
415             ++argumentIndex;
416         } else
417             stringBuilder.append(args[argumentIndex++]);
418 
419         switch (*sampleType) {
420         case SampleType::Sample:
421             break;
422         case SampleType::SampleLevel:
423             stringBuilder.append(&quot;, level(&quot;, args[argumentIndex++], &quot;)&quot;);
424             break;
425         case SampleType::SampleBias:
426             stringBuilder.append(&quot;, bias(&quot;, args[argumentIndex++], &quot;)&quot;);
427             break;
428         case SampleType::SampleGrad:
429             if (textureType.isCubeTexture())
430                 stringBuilder.append(&quot;, gradientcube(&quot;, args[argumentIndex], &quot;, &quot;, args[argumentIndex + 1], &quot;)&quot;);
431             else
432                 stringBuilder.append(&quot;, gradient2d(&quot;, args[argumentIndex], &quot;, &quot;, args[argumentIndex + 1], &quot;)&quot;);
433             argumentIndex += 2;
434             break;
435         }
436 
437         if (nativeFunctionDeclaration.parameters().size() == baseArgumentCount + 1)
438             stringBuilder.append(&quot;, &quot;, args[argumentIndex++]);
439         stringBuilder.append(&quot;)&quot;);
440         if (!textureType.isDepthTexture())
441             stringBuilder.append(&quot;.&quot;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));
442 
443         return;
444     }
445 
446     if (nativeFunctionDeclaration.name() == &quot;Load&quot;) {
447         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
448 
449         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
450         auto&amp; locationType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[1]-&gt;type()-&gt;unifyNode()));
451         auto locationVectorLength = vectorLength(locationType);
452         auto&amp; returnType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.type().unifyNode()));
453         auto returnVectorLength = vectorLength(returnType);
454         auto locationTypeName = typeNamer.mangledNameForType(locationType);
455 
456         stringBuilder.append(&#39;(&#39;, args[1], &quot; = &quot;);
457         if (textureType.isTextureArray()) {
458             ASSERT(locationVectorLength &gt; 1);
459             stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, &quot;, locationTypeName, &#39;(&#39;);
460             for (int i = 0; i &lt; locationVectorLength; ++i) {
461                 if (i)
462                     stringBuilder.append(&quot;, &quot;);
463                 stringBuilder.append(&#39;0&#39;);
464             }
465             stringBuilder.append(&quot;), &quot;, locationTypeName, &#39;(&#39;);
466 
467             String dimensions[] = { &quot;width&quot;_str, &quot;height&quot;_str, &quot;depth&quot;_str };
468             for (int i = 0; i &lt; locationVectorLength - 1; ++i) {
469                 if (i)
470                     stringBuilder.append(&quot;, &quot;);
471                 stringBuilder.append(
472                     args[0], &quot;.get_&quot;, dimensions[i], &quot;() - 1&quot;);
473             }
474             stringBuilder.append(
475                 args[0], &quot;.get_array_size() - 1))&quot;);
476         } else {
477             if (locationVectorLength == 1)
478                 stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, 0, &quot;, args[0], &quot;.get_width() - 1)&quot;);
479             else {
480                 stringBuilder.append(&quot;clamp(&quot;, args[1], &quot;, &quot;, locationTypeName, &quot;(0, 0&quot;);
481                 if (locationVectorLength &gt;= 3)
482                     stringBuilder.append(&quot;, 0&quot;);
483                 stringBuilder.append(&quot;), &quot;, locationTypeName, &#39;(&#39;, args[0], &quot;.get_width() - 1, &quot;, args[0], &quot;.get_height() - 1&quot;);
484                 if (locationVectorLength &gt;= 3)
485                     stringBuilder.append(&quot;, &quot;, args[0], &quot;.get_depth() - 1&quot;);
486                 stringBuilder.append(&quot;))&quot;);
487             }
488         }
489 
490         stringBuilder.append(&quot;, &quot;, args[0], &quot;.read(&quot;);
491 
492         if (textureType.isTextureArray()) {
493             ASSERT(locationVectorLength &gt; 1);
494             stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength - 1), &#39;(&#39;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(0, locationVectorLength - 1), &quot;), uint(&quot;, args[1], &#39;.&#39;, &quot;xyzw&quot;_str.substring(locationVectorLength - 1, 1), &#39;)&#39;);
495         } else
496             stringBuilder.append(&quot;uint&quot;, vectorSuffix(locationVectorLength), &#39;(&#39;, args[1], &#39;)&#39;);
497         stringBuilder.append(&#39;)&#39;);
498         if (!textureType.isDepthTexture())
499             stringBuilder.append(&#39;.&#39;, &quot;xyzw&quot;_str.substring(0, returnVectorLength));
500 
501         stringBuilder.append(&#39;)&#39;);
502 
503         return;
504     }
505 
506     if (nativeFunctionDeclaration.name() == &quot;load&quot;) {
507         ASSERT(nativeFunctionDeclaration.parameters().size() == 1);
508         stringBuilder.append(
509             &quot;atomic_load_explicit(&quot;, args[0], &quot;, memory_order_relaxed)&quot;);
510         return;
511     }
512 
513     if (nativeFunctionDeclaration.name() == &quot;store&quot;) {
514         ASSERT(nativeFunctionDeclaration.parameters().size() == 2);
515         stringBuilder.append(
516             &quot;atomic_store_explicit(&quot;, args[0], &quot;, &quot;, args[1], &quot;, memory_order_relaxed)&quot;);
517         return;
518     }
519 
520     if (nativeFunctionDeclaration.name() == &quot;GetDimensions&quot;) {
521         stringBuilder.append(&#39;(&#39;);
522 
523         auto&amp; textureType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(nativeFunctionDeclaration.parameters()[0]-&gt;type()-&gt;unifyNode()));
524 
525         size_t index = 1;
526         bool hasMipLevel = !textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1;
527         if (hasMipLevel)
528             ++index;
529         const MangledVariableName&amp; widthName = args[index];
530         ++index;
531         Optional&lt;MangledVariableName&gt; heightName;
532         if (textureType.textureDimension() &gt;= 2) {
533             heightName = args[index];
534             ++index;
535         }
536         Optional&lt;MangledVariableName&gt; depthName;
537         if (textureType.textureDimension() &gt;= 3) {
538             depthName = args[index];
539             ++index;
540         }
541         Optional&lt;MangledVariableName&gt; elementsName;
542         if (textureType.isTextureArray()) {
543             elementsName = args[index];
544             ++index;
545         }
546         Optional&lt;MangledVariableName&gt; numberOfLevelsName;
547         if (!textureType.isWritableTexture() &amp;&amp; textureType.textureDimension() != 1) {
548             numberOfLevelsName = args[index];
549             ++index;
550         }
551         ASSERT(index == nativeFunctionDeclaration.parameters().size());
552 
553         stringBuilder.append(
554             &#39;*&#39;, widthName, &quot; = &quot;, args[0], &quot;.get_width(&quot;);
555         if (hasMipLevel)
556             stringBuilder.append(args[1]);
557         stringBuilder.append(&#39;)&#39;);
558 
559         if (heightName) {
560             stringBuilder.append(
561                 &quot;, *&quot;, *heightName, &quot; = &quot;, args[0], &quot;.get_height(&quot;);
562             if (hasMipLevel)
563                 stringBuilder.append(args[1]);
564             stringBuilder.append(&#39;)&#39;);
565         }
566         if (depthName) {
567             stringBuilder.append(
568                 &quot;, *&quot;, *depthName, &quot; = &quot;, args[0], &quot;.get_depth(&quot;);
569             if (hasMipLevel)
570                 stringBuilder.append(args[1]);
571             stringBuilder.append(&#39;)&#39;);
572         }
573         if (elementsName) {
574             stringBuilder.append(
575                 &quot;, *&quot;, *elementsName, &quot; = &quot;, args[0], &quot;.get_array_size()&quot;);
576         }
577         if (numberOfLevelsName) {
578             stringBuilder.append(
579                 &quot;, *&quot;, *numberOfLevelsName, &quot; = &quot;, args[0], &quot;.get_num_mip_levels()&quot;);
580         }
581 
582         stringBuilder.append(&#39;)&#39;);
583         return;
584     }
585 
586     if (nativeFunctionDeclaration.name() == &quot;Gather&quot;) {
587         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
588         notImplemented();
589     }
590 
591     if (nativeFunctionDeclaration.name() == &quot;GatherRed&quot;) {
592         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
593         notImplemented();
594     }
595 
596     if (nativeFunctionDeclaration.name() == &quot;SampleCmp&quot;) {
597         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
598         notImplemented();
599     }
600 
601     if (nativeFunctionDeclaration.name() == &quot;SampleCmpLevelZero&quot;) {
602         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
603         notImplemented();
604     }
605 
606     if (nativeFunctionDeclaration.name() == &quot;Store&quot;) {
607         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
608         notImplemented();
609     }
610 
611     if (nativeFunctionDeclaration.name() == &quot;GatherAlpha&quot;) {
612         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
613         notImplemented();
614     }
615 
616     if (nativeFunctionDeclaration.name() == &quot;GatherBlue&quot;) {
617         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
618         notImplemented();
619     }
620 
621     if (nativeFunctionDeclaration.name() == &quot;GatherCmp&quot;) {
622         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
623         notImplemented();
624     }
625 
626     if (nativeFunctionDeclaration.name() == &quot;GatherCmpRed&quot;) {
627         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
628         notImplemented();
629     }
630 
631     if (nativeFunctionDeclaration.name() == &quot;GatherGreen&quot;) {
632         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195813 Implement this
633         notImplemented();
634     }
635 
636     ASSERT_NOT_REACHED();
637 }
638 
639 } // namespace Metal
640 
641 } // namespace WHLSL
642 
643 } // namespace WebCore
644 
645 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="URLHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UUID.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/URLParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 635             break;
 636         }
 637         appendToASCIIBuffer(byte);
 638         ++iterator;
 639     }
 640     while (!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))
 641         ++iterator;
 642     ASSERT((i == length) == iterator.atEnd());
 643     for (; i &lt; length; ++i) {
 644         ASSERT(m_didSeeSyntaxViolation);
 645         uint8_t byte = data[i];
 646         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 647             percentEncodeByte(byte);
 648         else
 649             appendToASCIIBuffer(byte);
 650     }
 651 }
 652 
 653 Optional&lt;uint16_t&gt; URLParser::defaultPortForProtocol(StringView scheme)
 654 {
<span class="line-modified"> 655     static const uint16_t ftpPort = 21;</span>
<span class="line-modified"> 656     static const uint16_t gopherPort = 70;</span>
<span class="line-modified"> 657     static const uint16_t httpPort = 80;</span>
<span class="line-modified"> 658     static const uint16_t httpsPort = 443;</span>
<span class="line-modified"> 659     static const uint16_t wsPort = 80;</span>
<span class="line-removed"> 660     static const uint16_t wssPort = 443;</span>
 661 
 662     auto length = scheme.length();
 663     if (!length)
 664         return WTF::nullopt;
 665     switch (scheme[0]) {
 666     case &#39;w&#39;:
 667         switch (length) {
 668         case 2:
 669             if (scheme[1] == &#39;s&#39;)
 670                 return wsPort;
 671             return WTF::nullopt;
 672         case 3:
 673             if (scheme[1] == &#39;s&#39;
 674                 &amp;&amp; scheme[2] == &#39;s&#39;)
 675                 return wssPort;
 676             return WTF::nullopt;
 677         default:
 678             return false;
 679         }
 680     case &#39;h&#39;:
 681         switch (length) {
 682         case 4:
 683             if (scheme[1] == &#39;t&#39;
 684                 &amp;&amp; scheme[2] == &#39;t&#39;
 685                 &amp;&amp; scheme[3] == &#39;p&#39;)
 686                 return httpPort;
 687             return WTF::nullopt;
 688         case 5:
 689             if (scheme[1] == &#39;t&#39;
 690                 &amp;&amp; scheme[2] == &#39;t&#39;
 691                 &amp;&amp; scheme[3] == &#39;p&#39;
 692                 &amp;&amp; scheme[4] == &#39;s&#39;)
 693                 return httpsPort;
 694             return WTF::nullopt;
 695         default:
 696             return WTF::nullopt;
 697         }
<span class="line-removed"> 698     case &#39;g&#39;:</span>
<span class="line-removed"> 699         if (length == 6</span>
<span class="line-removed"> 700             &amp;&amp; scheme[1] == &#39;o&#39;</span>
<span class="line-removed"> 701             &amp;&amp; scheme[2] == &#39;p&#39;</span>
<span class="line-removed"> 702             &amp;&amp; scheme[3] == &#39;h&#39;</span>
<span class="line-removed"> 703             &amp;&amp; scheme[4] == &#39;e&#39;</span>
<span class="line-removed"> 704             &amp;&amp; scheme[5] == &#39;r&#39;)</span>
<span class="line-removed"> 705             return gopherPort;</span>
<span class="line-removed"> 706         return WTF::nullopt;</span>
 707     case &#39;f&#39;:
 708         if (length == 3
 709             &amp;&amp; scheme[1] == &#39;t&#39;
 710             &amp;&amp; scheme[2] == &#39;p&#39;)
 711             return ftpPort;
 712         return WTF::nullopt;
 713     default:
 714         return WTF::nullopt;
 715     }
 716 }
 717 
 718 enum class Scheme {
 719 #if PLATFORM(JAVA)
 720     JAR,
 721 #endif
 722     WS,
 723     WSS,
 724     File,
 725     FTP,
<span class="line-removed"> 726     Gopher,</span>
 727     HTTP,
 728     HTTPS,
 729     NonSpecial
 730 };
 731 
 732 ALWAYS_INLINE static Scheme scheme(StringView scheme)
 733 {
 734     auto length = scheme.length();
 735     if (!length)
 736         return Scheme::NonSpecial;
 737     switch (scheme[0]) {
 738     case &#39;f&#39;:
 739         switch (length) {
 740         case 3:
 741             if (scheme[1] == &#39;t&#39;
 742                 &amp;&amp; scheme[2] == &#39;p&#39;)
 743                 return Scheme::FTP;
 744             return Scheme::NonSpecial;
 745         case 4:
 746             if (scheme[1] == &#39;i&#39;
 747                 &amp;&amp; scheme[2] == &#39;l&#39;
 748                 &amp;&amp; scheme[3] == &#39;e&#39;)
 749                 return Scheme::File;
 750             return Scheme::NonSpecial;
 751         default:
 752             return Scheme::NonSpecial;
 753         }
<span class="line-removed"> 754     case &#39;g&#39;:</span>
<span class="line-removed"> 755         if (length == 6</span>
<span class="line-removed"> 756             &amp;&amp; scheme[1] == &#39;o&#39;</span>
<span class="line-removed"> 757             &amp;&amp; scheme[2] == &#39;p&#39;</span>
<span class="line-removed"> 758             &amp;&amp; scheme[3] == &#39;h&#39;</span>
<span class="line-removed"> 759             &amp;&amp; scheme[4] == &#39;e&#39;</span>
<span class="line-removed"> 760             &amp;&amp; scheme[5] == &#39;r&#39;)</span>
<span class="line-removed"> 761             return Scheme::Gopher;</span>
<span class="line-removed"> 762         return Scheme::NonSpecial;</span>
 763     case &#39;h&#39;:
 764         switch (length) {
 765         case 4:
 766             if (scheme[1] == &#39;t&#39;
 767                 &amp;&amp; scheme[2] == &#39;t&#39;
 768                 &amp;&amp; scheme[3] == &#39;p&#39;)
 769                 return Scheme::HTTP;
 770             return Scheme::NonSpecial;
 771         case 5:
 772             if (scheme[1] == &#39;t&#39;
 773                 &amp;&amp; scheme[2] == &#39;t&#39;
 774                 &amp;&amp; scheme[3] == &#39;p&#39;
 775                 &amp;&amp; scheme[4] == &#39;s&#39;)
 776                 return Scheme::HTTPS;
 777             return Scheme::NonSpecial;
 778         default:
 779             return Scheme::NonSpecial;
 780         }
 781     case &#39;w&#39;:
 782         switch (length) {
</pre>
<hr />
<pre>
 915         FALLTHROUGH;
 916     case URLPart::SchemeEnd:
 917         m_url.m_isValid = base.m_isValid;
 918         m_url.m_protocolIsInHTTPFamily = base.m_protocolIsInHTTPFamily;
 919         m_url.m_schemeEnd = base.m_schemeEnd;
 920     }
 921     switch (scheme(StringView(m_asciiBuffer.data(), m_url.m_schemeEnd))) {
 922 #if PLATFORM(JAVA)
 923     case Scheme::JAR:
 924         break;
 925 #endif
 926     case Scheme::WS:
 927     case Scheme::WSS:
 928         nonUTF8QueryEncoding = nullptr;
 929         m_urlIsSpecial = true;
 930         return;
 931     case Scheme::File:
 932         m_urlIsFile = true;
 933         FALLTHROUGH;
 934     case Scheme::FTP:
<span class="line-removed"> 935     case Scheme::Gopher:</span>
 936     case Scheme::HTTP:
 937     case Scheme::HTTPS:
 938         m_urlIsSpecial = true;
 939         return;
 940     case Scheme::NonSpecial:
 941         m_urlIsSpecial = false;
 942         nonUTF8QueryEncoding = nullptr;
 943         return;
 944     }
 945     ASSERT_NOT_REACHED();
 946 }
 947 
 948 static const char dotASCIICode[2] = {&#39;2&#39;, &#39;e&#39;};
 949 
 950 template&lt;typename CharacterType&gt;
 951 ALWAYS_INLINE bool URLParser::isSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 952 {
 953     if (c.atEnd())
 954         return false;
 955     if (*c == &#39;.&#39;) {
</pre>
<hr />
<pre>
1165         if (base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1166             m_url = base;
1167             m_url.removeFragmentIdentifier();
1168         }
1169         return;
1170     }
1171 
1172     if (input.is8Bit()) {
1173         m_inputBegin = input.characters8();
1174         parse(input.characters8(), input.length(), base, nonUTF8QueryEncoding);
1175     } else {
1176         m_inputBegin = input.characters16();
1177         parse(input.characters16(), input.length(), base, nonUTF8QueryEncoding);
1178     }
1179 
1180     ASSERT(!m_url.m_isValid
1181         || m_didSeeSyntaxViolation == (m_url.string() != input)
1182         || (input.isAllSpecialCharacters&lt;isC0ControlOrSpace&gt;()
1183             &amp;&amp; m_url.m_string == base.m_string.left(base.m_queryEnd)));
1184     ASSERT(internalValuesConsistent(m_url));
<span class="line-modified">1185 #if !ASSERT_DISABLED</span>
1186     if (!m_didSeeSyntaxViolation) {
1187         // Force a syntax violation at the beginning to make sure we get the same result.
1188         URLParser parser(makeString(&quot; &quot;, input), base, nonUTF8QueryEncoding);
1189         URL parsed = parser.result();
1190         if (parsed.isValid())
1191             ASSERT(allValuesEqual(parser.result(), m_url));
1192     }
<span class="line-modified">1193 #endif</span>
1194 }
1195 
1196 template&lt;typename CharacterType&gt;
1197 void URLParser::parse(const CharacterType* input, const unsigned length, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1198 {
1199     URL_PARSER_LOG(&quot;Parsing URL &lt;%s&gt; base &lt;%s&gt;&quot;, String(input, length).utf8().data(), base.string().utf8().data());
1200     m_url = { };
1201     ASSERT(m_asciiBuffer.isEmpty());
1202 
1203     Vector&lt;UChar&gt; queryBuffer;
1204 
1205     unsigned endIndex = length;
1206     while (UNLIKELY(endIndex &amp;&amp; isC0ControlOrSpace(input[endIndex - 1]))) {
1207         syntaxViolation(CodePointIterator&lt;CharacterType&gt;(input, input));
1208         endIndex--;
1209     }
1210     CodePointIterator&lt;CharacterType&gt; c(input, input + endIndex);
1211     CodePointIterator&lt;CharacterType&gt; authorityOrHostBegin;
1212     CodePointIterator&lt;CharacterType&gt; queryBegin;
1213     while (UNLIKELY(!c.atEnd() &amp;&amp; isC0ControlOrSpace(*c))) {
</pre>
<hr />
<pre>
1296                     m_urlIsSpecial = true;
1297                     m_urlIsFile = true;
1298                     state = State::File;
1299                     ++c;
1300                     break;
1301                 case Scheme::WS:
1302                 case Scheme::WSS:
1303                     nonUTF8QueryEncoding = nullptr;
1304                     m_urlIsSpecial = true;
1305                     if (base.protocolIs(urlScheme))
1306                         state = State::SpecialRelativeOrAuthority;
1307                     else
1308                         state = State::SpecialAuthoritySlashes;
1309                     ++c;
1310                     break;
1311                 case Scheme::HTTP:
1312                 case Scheme::HTTPS:
1313                     m_url.m_protocolIsInHTTPFamily = true;
1314                     FALLTHROUGH;
1315                 case Scheme::FTP:
<span class="line-removed">1316                 case Scheme::Gopher:</span>
1317                     m_urlIsSpecial = true;
1318                     if (base.protocolIs(urlScheme))
1319                         state = State::SpecialRelativeOrAuthority;
1320                     else
1321                         state = State::SpecialAuthoritySlashes;
1322                     ++c;
1323                     break;
1324                 case Scheme::NonSpecial:
1325                     nonUTF8QueryEncoding = nullptr;
1326                     auto maybeSlash = c;
1327                     advance(maybeSlash);
1328                     if (!maybeSlash.atEnd() &amp;&amp; *maybeSlash == &#39;/&#39;) {
1329                         appendToASCIIBuffer(&#39;/&#39;);
1330                         c = maybeSlash;
1331                         state = State::PathOrAuthority;
1332                         ASSERT(*c == &#39;/&#39;);
1333                         ++c;
1334                         m_url.m_userStart = currentPosition(c);
1335                     } else {
1336                         ++c;
</pre>
<hr />
<pre>
2574             }
2575         } else {
2576             const UChar* characters = domain.characters16();
2577             ascii.reserveInitialCapacity(length);
2578             for (size_t i = 0; i &lt; length; ++i) {
2579                 if (UNLIKELY(isASCIIUpper(characters[i])))
2580                     syntaxViolation(iteratorForSyntaxViolationPosition);
2581                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2582             }
2583         }
2584         return ascii;
2585     }
2586 
2587     const size_t maxDomainLength = 64;
2588     UChar hostnameBuffer[maxDomainLength];
2589     UErrorCode error = U_ZERO_ERROR;
2590     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
2591     int32_t numCharactersConverted = uidna_nameToASCII(&amp;internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &amp;processingDetails, &amp;error);
2592 
2593     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
<span class="line-modified">2594 #if ASSERT_DISABLED</span>
<span class="line-removed">2595         UNUSED_PARAM(numCharactersConverted);</span>
<span class="line-removed">2596 #else</span>
2597         for (int32_t i = 0; i &lt; numCharactersConverted; ++i) {
2598             ASSERT(isASCII(hostnameBuffer[i]));
2599             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
2600         }
<span class="line-modified">2601 #endif</span>


2602         ascii.append(hostnameBuffer, numCharactersConverted);
2603         if (domain != StringView(ascii.data(), ascii.size()))
2604             syntaxViolation(iteratorForSyntaxViolationPosition);
2605         return ascii;
2606     }
2607     return WTF::nullopt;
2608 }
2609 
2610 bool URLParser::hasForbiddenHostCodePoint(const URLParser::LCharBuffer&amp; asciiDomain)
2611 {
2612     for (size_t i = 0; i &lt; asciiDomain.size(); ++i) {
2613         if (isForbiddenHostCodePoint(asciiDomain[i]))
2614             return true;
2615     }
2616     return false;
2617 }
2618 
2619 template&lt;typename CharacterType&gt;
2620 bool URLParser::parsePort(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2621 {
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 635             break;
 636         }
 637         appendToASCIIBuffer(byte);
 638         ++iterator;
 639     }
 640     while (!iterator.atEnd() &amp;&amp; isTabOrNewline(*iterator))
 641         ++iterator;
 642     ASSERT((i == length) == iterator.atEnd());
 643     for (; i &lt; length; ++i) {
 644         ASSERT(m_didSeeSyntaxViolation);
 645         uint8_t byte = data[i];
 646         if (shouldPercentEncodeQueryByte(byte, m_urlIsSpecial))
 647             percentEncodeByte(byte);
 648         else
 649             appendToASCIIBuffer(byte);
 650     }
 651 }
 652 
 653 Optional&lt;uint16_t&gt; URLParser::defaultPortForProtocol(StringView scheme)
 654 {
<span class="line-modified"> 655     static constexpr uint16_t ftpPort = 21;</span>
<span class="line-modified"> 656     static constexpr uint16_t httpPort = 80;</span>
<span class="line-modified"> 657     static constexpr uint16_t httpsPort = 443;</span>
<span class="line-modified"> 658     static constexpr uint16_t wsPort = 80;</span>
<span class="line-modified"> 659     static constexpr uint16_t wssPort = 443;</span>

 660 
 661     auto length = scheme.length();
 662     if (!length)
 663         return WTF::nullopt;
 664     switch (scheme[0]) {
 665     case &#39;w&#39;:
 666         switch (length) {
 667         case 2:
 668             if (scheme[1] == &#39;s&#39;)
 669                 return wsPort;
 670             return WTF::nullopt;
 671         case 3:
 672             if (scheme[1] == &#39;s&#39;
 673                 &amp;&amp; scheme[2] == &#39;s&#39;)
 674                 return wssPort;
 675             return WTF::nullopt;
 676         default:
 677             return false;
 678         }
 679     case &#39;h&#39;:
 680         switch (length) {
 681         case 4:
 682             if (scheme[1] == &#39;t&#39;
 683                 &amp;&amp; scheme[2] == &#39;t&#39;
 684                 &amp;&amp; scheme[3] == &#39;p&#39;)
 685                 return httpPort;
 686             return WTF::nullopt;
 687         case 5:
 688             if (scheme[1] == &#39;t&#39;
 689                 &amp;&amp; scheme[2] == &#39;t&#39;
 690                 &amp;&amp; scheme[3] == &#39;p&#39;
 691                 &amp;&amp; scheme[4] == &#39;s&#39;)
 692                 return httpsPort;
 693             return WTF::nullopt;
 694         default:
 695             return WTF::nullopt;
 696         }









 697     case &#39;f&#39;:
 698         if (length == 3
 699             &amp;&amp; scheme[1] == &#39;t&#39;
 700             &amp;&amp; scheme[2] == &#39;p&#39;)
 701             return ftpPort;
 702         return WTF::nullopt;
 703     default:
 704         return WTF::nullopt;
 705     }
 706 }
 707 
 708 enum class Scheme {
 709 #if PLATFORM(JAVA)
 710     JAR,
 711 #endif
 712     WS,
 713     WSS,
 714     File,
 715     FTP,

 716     HTTP,
 717     HTTPS,
 718     NonSpecial
 719 };
 720 
 721 ALWAYS_INLINE static Scheme scheme(StringView scheme)
 722 {
 723     auto length = scheme.length();
 724     if (!length)
 725         return Scheme::NonSpecial;
 726     switch (scheme[0]) {
 727     case &#39;f&#39;:
 728         switch (length) {
 729         case 3:
 730             if (scheme[1] == &#39;t&#39;
 731                 &amp;&amp; scheme[2] == &#39;p&#39;)
 732                 return Scheme::FTP;
 733             return Scheme::NonSpecial;
 734         case 4:
 735             if (scheme[1] == &#39;i&#39;
 736                 &amp;&amp; scheme[2] == &#39;l&#39;
 737                 &amp;&amp; scheme[3] == &#39;e&#39;)
 738                 return Scheme::File;
 739             return Scheme::NonSpecial;
 740         default:
 741             return Scheme::NonSpecial;
 742         }









 743     case &#39;h&#39;:
 744         switch (length) {
 745         case 4:
 746             if (scheme[1] == &#39;t&#39;
 747                 &amp;&amp; scheme[2] == &#39;t&#39;
 748                 &amp;&amp; scheme[3] == &#39;p&#39;)
 749                 return Scheme::HTTP;
 750             return Scheme::NonSpecial;
 751         case 5:
 752             if (scheme[1] == &#39;t&#39;
 753                 &amp;&amp; scheme[2] == &#39;t&#39;
 754                 &amp;&amp; scheme[3] == &#39;p&#39;
 755                 &amp;&amp; scheme[4] == &#39;s&#39;)
 756                 return Scheme::HTTPS;
 757             return Scheme::NonSpecial;
 758         default:
 759             return Scheme::NonSpecial;
 760         }
 761     case &#39;w&#39;:
 762         switch (length) {
</pre>
<hr />
<pre>
 895         FALLTHROUGH;
 896     case URLPart::SchemeEnd:
 897         m_url.m_isValid = base.m_isValid;
 898         m_url.m_protocolIsInHTTPFamily = base.m_protocolIsInHTTPFamily;
 899         m_url.m_schemeEnd = base.m_schemeEnd;
 900     }
 901     switch (scheme(StringView(m_asciiBuffer.data(), m_url.m_schemeEnd))) {
 902 #if PLATFORM(JAVA)
 903     case Scheme::JAR:
 904         break;
 905 #endif
 906     case Scheme::WS:
 907     case Scheme::WSS:
 908         nonUTF8QueryEncoding = nullptr;
 909         m_urlIsSpecial = true;
 910         return;
 911     case Scheme::File:
 912         m_urlIsFile = true;
 913         FALLTHROUGH;
 914     case Scheme::FTP:

 915     case Scheme::HTTP:
 916     case Scheme::HTTPS:
 917         m_urlIsSpecial = true;
 918         return;
 919     case Scheme::NonSpecial:
 920         m_urlIsSpecial = false;
 921         nonUTF8QueryEncoding = nullptr;
 922         return;
 923     }
 924     ASSERT_NOT_REACHED();
 925 }
 926 
 927 static const char dotASCIICode[2] = {&#39;2&#39;, &#39;e&#39;};
 928 
 929 template&lt;typename CharacterType&gt;
 930 ALWAYS_INLINE bool URLParser::isSingleDotPathSegment(CodePointIterator&lt;CharacterType&gt; c)
 931 {
 932     if (c.atEnd())
 933         return false;
 934     if (*c == &#39;.&#39;) {
</pre>
<hr />
<pre>
1144         if (base.isValid() &amp;&amp; !base.m_cannotBeABaseURL) {
1145             m_url = base;
1146             m_url.removeFragmentIdentifier();
1147         }
1148         return;
1149     }
1150 
1151     if (input.is8Bit()) {
1152         m_inputBegin = input.characters8();
1153         parse(input.characters8(), input.length(), base, nonUTF8QueryEncoding);
1154     } else {
1155         m_inputBegin = input.characters16();
1156         parse(input.characters16(), input.length(), base, nonUTF8QueryEncoding);
1157     }
1158 
1159     ASSERT(!m_url.m_isValid
1160         || m_didSeeSyntaxViolation == (m_url.string() != input)
1161         || (input.isAllSpecialCharacters&lt;isC0ControlOrSpace&gt;()
1162             &amp;&amp; m_url.m_string == base.m_string.left(base.m_queryEnd)));
1163     ASSERT(internalValuesConsistent(m_url));
<span class="line-modified">1164 #if ASSERT_ENABLED</span>
1165     if (!m_didSeeSyntaxViolation) {
1166         // Force a syntax violation at the beginning to make sure we get the same result.
1167         URLParser parser(makeString(&quot; &quot;, input), base, nonUTF8QueryEncoding);
1168         URL parsed = parser.result();
1169         if (parsed.isValid())
1170             ASSERT(allValuesEqual(parser.result(), m_url));
1171     }
<span class="line-modified">1172 #endif // ASSERT_ENABLED</span>
1173 }
1174 
1175 template&lt;typename CharacterType&gt;
1176 void URLParser::parse(const CharacterType* input, const unsigned length, const URL&amp; base, const URLTextEncoding* nonUTF8QueryEncoding)
1177 {
1178     URL_PARSER_LOG(&quot;Parsing URL &lt;%s&gt; base &lt;%s&gt;&quot;, String(input, length).utf8().data(), base.string().utf8().data());
1179     m_url = { };
1180     ASSERT(m_asciiBuffer.isEmpty());
1181 
1182     Vector&lt;UChar&gt; queryBuffer;
1183 
1184     unsigned endIndex = length;
1185     while (UNLIKELY(endIndex &amp;&amp; isC0ControlOrSpace(input[endIndex - 1]))) {
1186         syntaxViolation(CodePointIterator&lt;CharacterType&gt;(input, input));
1187         endIndex--;
1188     }
1189     CodePointIterator&lt;CharacterType&gt; c(input, input + endIndex);
1190     CodePointIterator&lt;CharacterType&gt; authorityOrHostBegin;
1191     CodePointIterator&lt;CharacterType&gt; queryBegin;
1192     while (UNLIKELY(!c.atEnd() &amp;&amp; isC0ControlOrSpace(*c))) {
</pre>
<hr />
<pre>
1275                     m_urlIsSpecial = true;
1276                     m_urlIsFile = true;
1277                     state = State::File;
1278                     ++c;
1279                     break;
1280                 case Scheme::WS:
1281                 case Scheme::WSS:
1282                     nonUTF8QueryEncoding = nullptr;
1283                     m_urlIsSpecial = true;
1284                     if (base.protocolIs(urlScheme))
1285                         state = State::SpecialRelativeOrAuthority;
1286                     else
1287                         state = State::SpecialAuthoritySlashes;
1288                     ++c;
1289                     break;
1290                 case Scheme::HTTP:
1291                 case Scheme::HTTPS:
1292                     m_url.m_protocolIsInHTTPFamily = true;
1293                     FALLTHROUGH;
1294                 case Scheme::FTP:

1295                     m_urlIsSpecial = true;
1296                     if (base.protocolIs(urlScheme))
1297                         state = State::SpecialRelativeOrAuthority;
1298                     else
1299                         state = State::SpecialAuthoritySlashes;
1300                     ++c;
1301                     break;
1302                 case Scheme::NonSpecial:
1303                     nonUTF8QueryEncoding = nullptr;
1304                     auto maybeSlash = c;
1305                     advance(maybeSlash);
1306                     if (!maybeSlash.atEnd() &amp;&amp; *maybeSlash == &#39;/&#39;) {
1307                         appendToASCIIBuffer(&#39;/&#39;);
1308                         c = maybeSlash;
1309                         state = State::PathOrAuthority;
1310                         ASSERT(*c == &#39;/&#39;);
1311                         ++c;
1312                         m_url.m_userStart = currentPosition(c);
1313                     } else {
1314                         ++c;
</pre>
<hr />
<pre>
2552             }
2553         } else {
2554             const UChar* characters = domain.characters16();
2555             ascii.reserveInitialCapacity(length);
2556             for (size_t i = 0; i &lt; length; ++i) {
2557                 if (UNLIKELY(isASCIIUpper(characters[i])))
2558                     syntaxViolation(iteratorForSyntaxViolationPosition);
2559                 ascii.uncheckedAppend(toASCIILower(characters[i]));
2560             }
2561         }
2562         return ascii;
2563     }
2564 
2565     const size_t maxDomainLength = 64;
2566     UChar hostnameBuffer[maxDomainLength];
2567     UErrorCode error = U_ZERO_ERROR;
2568     UIDNAInfo processingDetails = UIDNA_INFO_INITIALIZER;
2569     int32_t numCharactersConverted = uidna_nameToASCII(&amp;internationalDomainNameTranscoder(), StringView(domain).upconvertedCharacters(), domain.length(), hostnameBuffer, maxDomainLength, &amp;processingDetails, &amp;error);
2570 
2571     if (U_SUCCESS(error) &amp;&amp; !processingDetails.errors) {
<span class="line-modified">2572 #if ASSERT_ENABLED</span>


2573         for (int32_t i = 0; i &lt; numCharactersConverted; ++i) {
2574             ASSERT(isASCII(hostnameBuffer[i]));
2575             ASSERT(!isASCIIUpper(hostnameBuffer[i]));
2576         }
<span class="line-modified">2577 #else</span>
<span class="line-added">2578         UNUSED_PARAM(numCharactersConverted);</span>
<span class="line-added">2579 #endif // ASSERT_ENABLED</span>
2580         ascii.append(hostnameBuffer, numCharactersConverted);
2581         if (domain != StringView(ascii.data(), ascii.size()))
2582             syntaxViolation(iteratorForSyntaxViolationPosition);
2583         return ascii;
2584     }
2585     return WTF::nullopt;
2586 }
2587 
2588 bool URLParser::hasForbiddenHostCodePoint(const URLParser::LCharBuffer&amp; asciiDomain)
2589 {
2590     for (size_t i = 0; i &lt; asciiDomain.size(); ++i) {
2591         if (isForbiddenHostCodePoint(asciiDomain[i]))
2592             return true;
2593     }
2594     return false;
2595 }
2596 
2597 template&lt;typename CharacterType&gt;
2598 bool URLParser::parsePort(CodePointIterator&lt;CharacterType&gt;&amp; iterator)
2599 {
</pre>
</td>
</tr>
</table>
<center><a href="URLHelpers.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UUID.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
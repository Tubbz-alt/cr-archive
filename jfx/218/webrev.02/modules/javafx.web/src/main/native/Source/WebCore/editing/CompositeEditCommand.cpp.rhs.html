<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/CompositeEditCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;CompositeEditCommand.h&quot;
  28 
  29 #include &quot;AXObjectCache.h&quot;
  30 #include &quot;AppendNodeCommand.h&quot;
  31 #include &quot;ApplyStyleCommand.h&quot;
  32 #include &quot;BreakBlockquoteCommand.h&quot;
  33 #include &quot;DataTransfer.h&quot;
  34 #include &quot;DeleteFromTextNodeCommand.h&quot;
  35 #include &quot;DeleteSelectionCommand.h&quot;
  36 #include &quot;Document.h&quot;
  37 #include &quot;DocumentFragment.h&quot;
  38 #include &quot;DocumentMarkerController.h&quot;
  39 #include &quot;Editing.h&quot;
  40 #include &quot;Editor.h&quot;
  41 #include &quot;EditorInsertAction.h&quot;
  42 #include &quot;ElementTraversal.h&quot;
  43 #include &quot;Event.h&quot;
  44 #include &quot;Frame.h&quot;
  45 #include &quot;HTMLBRElement.h&quot;
  46 #include &quot;HTMLDivElement.h&quot;
  47 #include &quot;HTMLLIElement.h&quot;
  48 #include &quot;HTMLNames.h&quot;
  49 #include &quot;HTMLSpanElement.h&quot;
  50 #include &quot;InlineTextBox.h&quot;
  51 #include &quot;InsertIntoTextNodeCommand.h&quot;
  52 #include &quot;InsertLineBreakCommand.h&quot;
  53 #include &quot;InsertNodeBeforeCommand.h&quot;
  54 #include &quot;InsertParagraphSeparatorCommand.h&quot;
  55 #include &quot;InsertTextCommand.h&quot;
  56 #include &quot;MergeIdenticalElementsCommand.h&quot;
  57 #include &quot;NodeTraversal.h&quot;
  58 #include &quot;Range.h&quot;
  59 #include &quot;RemoveNodeCommand.h&quot;
  60 #include &quot;RemoveNodePreservingChildrenCommand.h&quot;
  61 #include &quot;RenderBlockFlow.h&quot;
  62 #include &quot;RenderText.h&quot;
  63 #include &quot;RenderedDocumentMarker.h&quot;
  64 #include &quot;ReplaceNodeWithSpanCommand.h&quot;
  65 #include &quot;ReplaceSelectionCommand.h&quot;
  66 #include &quot;ScopedEventQueue.h&quot;
  67 #include &quot;SetNodeAttributeCommand.h&quot;
  68 #include &quot;SplitElementCommand.h&quot;
  69 #include &quot;SplitTextNodeCommand.h&quot;
  70 #include &quot;SplitTextNodeContainingElementCommand.h&quot;
  71 #include &quot;StaticRange.h&quot;
  72 #include &quot;Text.h&quot;
  73 #include &quot;TextIterator.h&quot;
  74 #include &quot;VisibleUnits.h&quot;
  75 #include &quot;WrapContentsInDummySpanCommand.h&quot;
  76 #include &quot;markup.h&quot;
  77 
  78 namespace WebCore {
  79 
  80 using namespace HTMLNames;
  81 
  82 int AccessibilityUndoReplacedText::indexForVisiblePosition(const VisiblePosition&amp; position, RefPtr&lt;ContainerNode&gt;&amp; scope) const
  83 {
  84     if (position.deepEquivalent().isNull())
  85         return -1;
  86     return WebCore::indexForVisiblePosition(position, scope);
  87 }
  88 
  89 void AccessibilityUndoReplacedText::configureRangeDeletedByReapplyWithEndingSelection(const VisibleSelection&amp; selection)
  90 {
  91     if (!AXObjectCache::accessibilityEnabled())
  92         return;
  93     if (selection.isNone())
  94         return;
  95     m_rangeDeletedByReapply.endIndex.value = indexForVisiblePosition(selection.end(), m_rangeDeletedByReapply.endIndex.scope);
  96 }
  97 
  98 void AccessibilityUndoReplacedText::configureRangeDeletedByReapplyWithStartingSelection(const VisibleSelection&amp; selection)
  99 {
 100     if (!AXObjectCache::accessibilityEnabled())
 101         return;
 102     if (selection.isNone())
 103         return;
 104     if (m_rangeDeletedByReapply.startIndex.value == -1)
 105         m_rangeDeletedByReapply.startIndex.value = indexForVisiblePosition(selection.start(), m_rangeDeletedByReapply.startIndex.scope);
 106 }
 107 
 108 void AccessibilityUndoReplacedText::setRangeDeletedByUnapply(const VisiblePositionIndexRange&amp; range)
 109 {
 110     if (m_rangeDeletedByUnapply.isNull())
 111         m_rangeDeletedByUnapply = range;
 112 }
 113 
 114 void AccessibilityUndoReplacedText::captureTextForUnapply()
 115 {
 116     if (!AXObjectCache::accessibilityEnabled())
 117         return;
 118     m_replacedText = textDeletedByReapply();
 119 }
 120 
 121 void AccessibilityUndoReplacedText::captureTextForReapply()
 122 {
 123     if (!AXObjectCache::accessibilityEnabled())
 124         return;
 125     m_replacedText = textDeletedByUnapply();
 126 }
 127 
 128 static String stringForVisiblePositionIndexRange(const VisiblePositionIndexRange&amp; range)
 129 {
 130     if (range.isNull())
 131         return String();
 132     VisiblePosition start = visiblePositionForIndex(range.startIndex.value, range.startIndex.scope.get());
 133     VisiblePosition end = visiblePositionForIndex(range.endIndex.value, range.endIndex.scope.get());
 134     return AccessibilityObject::stringForVisiblePositionRange(VisiblePositionRange(start, end));
 135 }
 136 
 137 String AccessibilityUndoReplacedText::textDeletedByUnapply()
 138 {
 139     if (!AXObjectCache::accessibilityEnabled())
 140         return String();
 141     return stringForVisiblePositionIndexRange(m_rangeDeletedByUnapply);
 142 }
 143 
 144 String AccessibilityUndoReplacedText::textDeletedByReapply()
 145 {
 146     if (!AXObjectCache::accessibilityEnabled())
 147         return String();
 148     return stringForVisiblePositionIndexRange(m_rangeDeletedByReapply);
 149 }
 150 
 151 static void postTextStateChangeNotification(AXObjectCache* cache, const VisiblePosition&amp; position, const String&amp; deletedText, const String&amp; insertedText)
 152 {
 153     ASSERT(cache);
 154     auto* node = highestEditableRoot(position.deepEquivalent(), HasEditableAXRole);
 155     if (!node)
 156         return;
 157     if (insertedText.length() &amp;&amp; deletedText.length())
 158         cache-&gt;postTextReplacementNotification(node, AXTextEditTypeDelete, insertedText, AXTextEditTypeInsert, deletedText, position);
 159     else if (deletedText.length())
 160         cache-&gt;postTextStateChangeNotification(node, AXTextEditTypeInsert, deletedText, position);
 161     else if (insertedText.length())
 162         cache-&gt;postTextStateChangeNotification(node, AXTextEditTypeDelete, insertedText, position);
 163 }
 164 
 165 void AccessibilityUndoReplacedText::postTextStateChangeNotificationForUnapply(AXObjectCache* cache)
 166 {
 167     if (!cache)
 168         return;
 169     if (!AXObjectCache::accessibilityEnabled())
 170         return;
 171     if (m_rangeDeletedByUnapply.isNull())
 172         return;
 173     VisiblePosition position = visiblePositionForIndex(m_rangeDeletedByUnapply.endIndex.value, m_rangeDeletedByUnapply.endIndex.scope.get());
 174     if (position.isNull())
 175         return;
 176     postTextStateChangeNotification(cache, position, textDeletedByUnapply(), m_replacedText);
 177     m_replacedText = String();
 178 }
 179 
 180 void AccessibilityUndoReplacedText::postTextStateChangeNotificationForReapply(AXObjectCache* cache)
 181 {
 182     if (!cache)
 183         return;
 184     if (!AXObjectCache::accessibilityEnabled())
 185         return;
 186     if (m_rangeDeletedByReapply.isNull())
 187         return;
 188     VisiblePosition position = visiblePositionForIndex(m_rangeDeletedByReapply.startIndex.value, m_rangeDeletedByReapply.startIndex.scope.get());
 189     if (position.isNull())
 190         return;
 191     postTextStateChangeNotification(cache, position, textDeletedByReapply(), m_replacedText);
 192     m_replacedText = String();
 193 }
 194 
 195 Ref&lt;EditCommandComposition&gt; EditCommandComposition::create(Document&amp; document,
 196     const VisibleSelection&amp; startingSelection, const VisibleSelection&amp; endingSelection, EditAction editAction)
 197 {
 198     return adoptRef(*new EditCommandComposition(document, startingSelection, endingSelection, editAction));
 199 }
 200 
 201 EditCommandComposition::EditCommandComposition(Document&amp; document, const VisibleSelection&amp; startingSelection, const VisibleSelection&amp; endingSelection, EditAction editAction)
 202     : m_document(&amp;document)
 203     , m_startingSelection(startingSelection)
 204     , m_endingSelection(endingSelection)
 205     , m_startingRootEditableElement(startingSelection.rootEditableElement())
 206     , m_endingRootEditableElement(endingSelection.rootEditableElement())
 207     , m_editAction(editAction)
 208 {
 209     m_replacedText.configureRangeDeletedByReapplyWithStartingSelection(startingSelection);
 210 }
 211 
 212 void EditCommandComposition::unapply()
 213 {
 214     ASSERT(m_document);
 215     RefPtr&lt;Frame&gt; frame = m_document-&gt;frame();
 216     if (!frame)
 217         return;
 218 
 219     m_replacedText.captureTextForUnapply();
 220 
 221     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 222     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 223     // if one is necessary (like for the creation of VisiblePositions).
 224     m_document-&gt;updateLayoutIgnorePendingStylesheets();
 225 #if PLATFORM(IOS_FAMILY)
 226     // FIXME: Where should iPhone code deal with the composition?
 227     // Since editing commands don&#39;t save/restore the composition, undoing without fixing
 228     // up the composition will leave a stale, invalid composition, as in &lt;rdar://problem/6831637&gt;.
 229     // Desktop handles this in -[WebHTMLView _updateSelectionForInputManager], but the phone
 230     // goes another route.
 231     frame-&gt;editor().cancelComposition();
 232 #endif
 233 
 234     if (!frame-&gt;editor().willUnapplyEditing(*this))
 235         return;
 236 
 237     size_t size = m_commands.size();
 238     for (size_t i = size; i; --i)
 239         m_commands[i - 1]-&gt;doUnapply();
 240 
 241     frame-&gt;editor().unappliedEditing(*this);
 242 
 243     if (AXObjectCache::accessibilityEnabled())
 244         m_replacedText.postTextStateChangeNotificationForUnapply(m_document-&gt;existingAXObjectCache());
 245 }
 246 
 247 void EditCommandComposition::reapply()
 248 {
 249     ASSERT(m_document);
 250     RefPtr&lt;Frame&gt; frame = m_document-&gt;frame();
 251     if (!frame)
 252         return;
 253 
 254     m_replacedText.captureTextForReapply();
 255 
 256     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 257     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 258     // if one is necessary (like for the creation of VisiblePositions).
 259     m_document-&gt;updateLayoutIgnorePendingStylesheets();
 260 
 261     if (!frame-&gt;editor().willReapplyEditing(*this))
 262         return;
 263 
 264     for (auto&amp; command : m_commands)
 265         command-&gt;doReapply();
 266 
 267     frame-&gt;editor().reappliedEditing(*this);
 268 
 269     if (AXObjectCache::accessibilityEnabled())
 270         m_replacedText.postTextStateChangeNotificationForReapply(m_document-&gt;existingAXObjectCache());
 271 }
 272 
 273 void EditCommandComposition::append(SimpleEditCommand* command)
 274 {
 275     m_commands.append(command);
 276 }
 277 
 278 void EditCommandComposition::setStartingSelection(const VisibleSelection&amp; selection)
 279 {
 280     m_startingSelection = selection;
 281     m_startingRootEditableElement = selection.rootEditableElement();
 282     m_replacedText.configureRangeDeletedByReapplyWithStartingSelection(selection);
 283 }
 284 
 285 void EditCommandComposition::setEndingSelection(const VisibleSelection&amp; selection)
 286 {
 287     m_endingSelection = selection;
 288     m_endingRootEditableElement = selection.rootEditableElement();
 289     m_replacedText.configureRangeDeletedByReapplyWithEndingSelection(selection);
 290 }
 291 
 292 void EditCommandComposition::setRangeDeletedByUnapply(const VisiblePositionIndexRange&amp; range)
 293 {
 294     m_replacedText.setRangeDeletedByUnapply(range);
 295 }
 296 
 297 #ifndef NDEBUG
 298 void EditCommandComposition::getNodesInCommand(HashSet&lt;Node*&gt;&amp; nodes)
 299 {
 300     for (auto&amp; command : m_commands)
 301         command-&gt;getNodesInCommand(nodes);
 302 }
 303 #endif
 304 
 305 String EditCommandComposition::label() const
 306 {
 307     return undoRedoLabel(m_editAction);
 308 }
 309 
 310 CompositeEditCommand::CompositeEditCommand(Document&amp; document, EditAction editingAction)
 311     : EditCommand(document, editingAction)
 312 {
 313 }
 314 
 315 CompositeEditCommand::~CompositeEditCommand()
 316 {
 317     ASSERT(isTopLevelCommand() || !m_composition);
 318 }
 319 
 320 bool CompositeEditCommand::willApplyCommand()
 321 {
 322     return frame().editor().willApplyEditing(*this, targetRangesForBindings());
 323 }
 324 
 325 void CompositeEditCommand::apply()
 326 {
 327     if (!endingSelection().isContentRichlyEditable()) {
 328         switch (editingAction()) {
 329         case EditAction::TypingDeleteSelection:
 330         case EditAction::TypingDeleteBackward:
 331         case EditAction::TypingDeleteForward:
 332         case EditAction::TypingDeleteWordBackward:
 333         case EditAction::TypingDeleteWordForward:
 334         case EditAction::TypingDeleteLineBackward:
 335         case EditAction::TypingDeleteLineForward:
 336         case EditAction::TypingDeletePendingComposition:
 337         case EditAction::TypingDeleteFinalComposition:
 338         case EditAction::TypingInsertText:
 339         case EditAction::TypingInsertLineBreak:
 340         case EditAction::TypingInsertParagraph:
 341         case EditAction::TypingInsertPendingComposition:
 342         case EditAction::TypingInsertFinalComposition:
 343         case EditAction::Paste:
 344         case EditAction::DeleteByDrag:
 345         case EditAction::SetInlineWritingDirection:
 346         case EditAction::SetBlockWritingDirection:
 347         case EditAction::Cut:
 348         case EditAction::Unspecified:
 349         case EditAction::Insert:
 350         case EditAction::InsertReplacement:
 351         case EditAction::InsertFromDrop:
 352         case EditAction::Delete:
 353         case EditAction::Dictation:
 354             break;
 355         default:
 356             ASSERT_NOT_REACHED();
 357             return;
 358         }
 359     }
 360     ensureComposition();
 361 
 362     // Changes to the document may have been made since the last editing operation that require a layout, as in &lt;rdar://problem/5658603&gt;.
 363     // Low level operations, like RemoveNodeCommand, don&#39;t require a layout because the high level operations that use them perform one
 364     // if one is necessary (like for the creation of VisiblePositions).
 365     document().updateLayoutIgnorePendingStylesheets();
 366 
 367     if (!willApplyCommand())
 368         return;
 369 
 370     {
 371         EventQueueScope eventQueueScope;
 372         doApply();
 373     }
 374 
 375     didApplyCommand();
 376     setShouldRetainAutocorrectionIndicator(false);
 377 }
 378 
 379 void CompositeEditCommand::didApplyCommand()
 380 {
 381     frame().editor().appliedEditing(*this);
 382 }
 383 
 384 Vector&lt;RefPtr&lt;StaticRange&gt;&gt; CompositeEditCommand::targetRanges() const
 385 {
 386     ASSERT(!isEditingTextAreaOrTextInput());
 387     auto firstRange = frame().selection().selection().firstRange();
 388     if (!firstRange)
 389         return { };
 390 
 391     return { 1, StaticRange::createFromRange(*firstRange) };
 392 }
 393 
 394 Vector&lt;RefPtr&lt;StaticRange&gt;&gt; CompositeEditCommand::targetRangesForBindings() const
 395 {
 396     if (isEditingTextAreaOrTextInput())
 397         return { };
 398 
 399     return targetRanges();
 400 }
 401 
 402 RefPtr&lt;DataTransfer&gt; CompositeEditCommand::inputEventDataTransfer() const
 403 {
 404     return nullptr;
 405 }
 406 
 407 EditCommandComposition* CompositeEditCommand::composition() const
 408 {
 409     for (auto* command = this; command; command = command-&gt;parent()) {
 410         if (auto composition = command-&gt;m_composition) {
 411             ASSERT(!command-&gt;parent());
 412             return composition.get();
 413         }
 414     }
 415     return nullptr;
 416 }
 417 
 418 EditCommandComposition&amp; CompositeEditCommand::ensureComposition()
 419 {
 420     auto* command = this;
 421     while (auto* parent = command-&gt;parent())
 422         command = parent;
 423     if (!command-&gt;m_composition)
 424         command-&gt;m_composition = EditCommandComposition::create(document(), startingSelection(), endingSelection(), editingAction());
 425     return *command-&gt;m_composition;
 426 }
 427 
 428 bool CompositeEditCommand::isCreateLinkCommand() const
 429 {
 430     return false;
 431 }
 432 
 433 bool CompositeEditCommand::preservesTypingStyle() const
 434 {
 435     return false;
 436 }
 437 
 438 bool CompositeEditCommand::isTypingCommand() const
 439 {
 440     return false;
 441 }
 442 
 443 bool CompositeEditCommand::shouldRetainAutocorrectionIndicator() const
 444 {
 445     return false;
 446 }
 447 
 448 void CompositeEditCommand::setShouldRetainAutocorrectionIndicator(bool)
 449 {
 450 }
 451 
 452 String CompositeEditCommand::inputEventTypeName() const
 453 {
 454     return inputTypeNameForEditingAction(editingAction());
 455 }
 456 
 457 //
 458 // sugary-sweet convenience functions to help create and apply edit commands in composite commands
 459 //
 460 void CompositeEditCommand::applyCommandToComposite(Ref&lt;EditCommand&gt;&amp;&amp; command)
 461 {
 462     command-&gt;setParent(this);
 463     command-&gt;doApply();
 464     if (command-&gt;isSimpleEditCommand()) {
 465         command-&gt;setParent(nullptr);
 466         ensureComposition().append(toSimpleEditCommand(command.ptr()));
 467     }
 468     m_commands.append(WTFMove(command));
 469 }
 470 
 471 void CompositeEditCommand::applyCommandToComposite(Ref&lt;CompositeEditCommand&gt;&amp;&amp; command, const VisibleSelection&amp; selection)
 472 {
 473     command-&gt;setParent(this);
 474     if (selection != command-&gt;endingSelection()) {
 475         command-&gt;setStartingSelection(selection);
 476         command-&gt;setEndingSelection(selection);
 477     }
 478     command-&gt;doApply();
 479     m_commands.append(WTFMove(command));
 480 }
 481 
 482 void CompositeEditCommand::applyStyle(const EditingStyle* style, EditAction editingAction)
 483 {
 484     applyCommandToComposite(ApplyStyleCommand::create(document(), style, editingAction));
 485 }
 486 
 487 void CompositeEditCommand::applyStyle(const EditingStyle* style, const Position&amp; start, const Position&amp; end, EditAction editingAction)
 488 {
 489     applyCommandToComposite(ApplyStyleCommand::create(document(), style, start, end, editingAction));
 490 }
 491 
 492 void CompositeEditCommand::applyStyledElement(Ref&lt;Element&gt;&amp;&amp; element)
 493 {
 494     applyCommandToComposite(ApplyStyleCommand::create(WTFMove(element), false));
 495 }
 496 
 497 void CompositeEditCommand::removeStyledElement(Ref&lt;Element&gt;&amp;&amp; element)
 498 {
 499     applyCommandToComposite(ApplyStyleCommand::create(WTFMove(element), true));
 500 }
 501 
 502 void CompositeEditCommand::insertParagraphSeparator(bool useDefaultParagraphElement, bool pasteBlockqutoeIntoUnquotedArea)
 503 {
 504     applyCommandToComposite(InsertParagraphSeparatorCommand::create(document(), useDefaultParagraphElement, pasteBlockqutoeIntoUnquotedArea, editingAction()));
 505 }
 506 
 507 void CompositeEditCommand::insertLineBreak()
 508 {
 509     applyCommandToComposite(InsertLineBreakCommand::create(document()));
 510 }
 511 
 512 bool CompositeEditCommand::isRemovableBlock(const Node* node)
 513 {
 514     ASSERT(node);
 515     if (!is&lt;HTMLDivElement&gt;(*node))
 516         return false;
 517 
 518     Node* parentNode = node-&gt;parentNode();
 519     if (parentNode &amp;&amp; parentNode-&gt;firstChild() != parentNode-&gt;lastChild())
 520         return false;
 521 
 522     if (!downcast&lt;HTMLDivElement&gt;(*node).hasAttributes())
 523         return true;
 524 
 525     return false;
 526 }
 527 
 528 void CompositeEditCommand::insertNodeBefore(Ref&lt;Node&gt;&amp;&amp; insertChild, Node&amp; refChild, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 529 {
 530     applyCommandToComposite(InsertNodeBeforeCommand::create(WTFMove(insertChild), refChild, shouldAssumeContentIsAlwaysEditable, editingAction()));
 531 }
 532 
 533 void CompositeEditCommand::insertNodeAfter(Ref&lt;Node&gt;&amp;&amp; insertChild, Node&amp; refChild)
 534 {
 535     ContainerNode* parent = refChild.parentNode();
 536     if (!parent)
 537         return;
 538 
 539     ASSERT(!parent-&gt;isShadowRoot());
 540     if (parent-&gt;lastChild() == &amp;refChild)
 541         appendNode(WTFMove(insertChild), *parent);
 542     else {
 543         ASSERT(refChild.nextSibling());
 544         insertNodeBefore(WTFMove(insertChild), *refChild.nextSibling());
 545     }
 546 }
 547 
 548 void CompositeEditCommand::insertNodeAt(Ref&lt;Node&gt;&amp;&amp; insertChild, const Position&amp; editingPosition)
 549 {
 550     ASSERT(isEditablePosition(editingPosition));
 551     // For editing positions like [table, 0], insert before the table,
 552     // likewise for replaced elements, brs, etc.
 553     Position p = editingPosition.parentAnchoredEquivalent();
 554     Node* refChild = p.deprecatedNode();
 555     int offset = p.deprecatedEditingOffset();
 556 
 557     if (canHaveChildrenForEditing(*refChild)) {
 558         Node* child = refChild-&gt;firstChild();
 559         for (int i = 0; child &amp;&amp; i &lt; offset; i++)
 560             child = child-&gt;nextSibling();
 561         if (child)
 562             insertNodeBefore(WTFMove(insertChild), *child);
 563         else
 564             appendNode(WTFMove(insertChild), downcast&lt;ContainerNode&gt;(*refChild));
 565     } else if (caretMinOffset(*refChild) &gt;= offset)
 566         insertNodeBefore(WTFMove(insertChild), *refChild);
 567     else if (is&lt;Text&gt;(*refChild) &amp;&amp; caretMaxOffset(*refChild) &gt; offset) {
 568         splitTextNode(downcast&lt;Text&gt;(*refChild), offset);
 569 
 570         // Mutation events (bug 22634) from the text node insertion may have removed the refChild
 571         if (!refChild-&gt;isConnected())
 572             return;
 573         insertNodeBefore(WTFMove(insertChild), *refChild);
 574     } else
 575         insertNodeAfter(WTFMove(insertChild), *refChild);
 576 }
 577 
 578 void CompositeEditCommand::appendNode(Ref&lt;Node&gt;&amp;&amp; node, Ref&lt;ContainerNode&gt;&amp;&amp; parent)
 579 {
 580     ASSERT(canHaveChildrenForEditing(parent));
 581     applyCommandToComposite(AppendNodeCommand::create(WTFMove(parent), WTFMove(node), editingAction()));
 582 }
 583 
 584 void CompositeEditCommand::removeChildrenInRange(Node&amp; node, unsigned from, unsigned to)
 585 {
 586     Vector&lt;Ref&lt;Node&gt;&gt; children;
 587     Node* child = node.traverseToChildAt(from);
 588     for (unsigned i = from; child &amp;&amp; i &lt; to; i++, child = child-&gt;nextSibling())
 589         children.append(*child);
 590 
 591     for (auto&amp; child : children)
 592         removeNode(child);
 593 }
 594 
 595 void CompositeEditCommand::removeNode(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 596 {
 597     if (!node.nonShadowBoundaryParentNode())
 598         return;
 599     applyCommandToComposite(RemoveNodeCommand::create(node, shouldAssumeContentIsAlwaysEditable, editingAction()));
 600 }
 601 
 602 void CompositeEditCommand::removeNodePreservingChildren(Node&amp; node, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)
 603 {
 604     applyCommandToComposite(RemoveNodePreservingChildrenCommand::create(node, shouldAssumeContentIsAlwaysEditable, editingAction()));
 605 }
 606 
 607 void CompositeEditCommand::removeNodeAndPruneAncestors(Node&amp; node)
 608 {
 609     RefPtr&lt;ContainerNode&gt; parent = node.parentNode();
 610     removeNode(node);
 611     prune(parent.get());
 612 }
 613 
 614 void CompositeEditCommand::moveRemainingSiblingsToNewParent(Node* node, Node* pastLastNodeToMove, Element&amp; newParent)
 615 {
 616     NodeVector nodesToRemove;
 617     Ref&lt;Element&gt; protectedNewParent = newParent;
 618 
 619     for (; node &amp;&amp; node != pastLastNodeToMove; node = node-&gt;nextSibling())
 620         nodesToRemove.append(*node);
 621 
 622     for (auto&amp; nodeToRemove : nodesToRemove) {
 623         removeNode(nodeToRemove);
 624         appendNode(WTFMove(nodeToRemove), newParent);
 625     }
 626 }
 627 
 628 void CompositeEditCommand::updatePositionForNodeRemovalPreservingChildren(Position&amp; position, Node&amp; node)
 629 {
 630     int offset = (position.anchorType() == Position::PositionIsOffsetInAnchor) ? position.offsetInContainerNode() : 0;
 631     updatePositionForNodeRemoval(position, node);
 632     if (offset)
 633         position.moveToOffset(offset);
 634 }
 635 
 636 HTMLElement* CompositeEditCommand::replaceElementWithSpanPreservingChildrenAndAttributes(HTMLElement&amp; element)
 637 {
 638     // It would also be possible to implement all of ReplaceNodeWithSpanCommand
 639     // as a series of existing smaller edit commands.  Someone who wanted to
 640     // reduce the number of edit commands could do so here.
 641     auto command = ReplaceNodeWithSpanCommand::create(element);
 642     auto* commandPtr = command.ptr();
 643     applyCommandToComposite(WTFMove(command));
 644     // Returning a raw pointer here is OK because the command is retained by
 645     // applyCommandToComposite (thus retaining the span), and the span is also
 646     // in the DOM tree, and thus alive whie it has a parent.
 647     ASSERT(commandPtr-&gt;spanElement()-&gt;isConnected());
 648     return commandPtr-&gt;spanElement();
 649 }
 650 
 651 void CompositeEditCommand::prune(Node* node)
 652 {
 653     if (auto* highestNodeToRemove = highestNodeToRemoveInPruning(node))
 654         removeNode(*highestNodeToRemove);
 655 }
 656 
 657 void CompositeEditCommand::splitTextNode(Text&amp; node, unsigned offset)
 658 {
 659     applyCommandToComposite(SplitTextNodeCommand::create(node, offset));
 660 }
 661 
 662 void CompositeEditCommand::splitElement(Element&amp; element, Node&amp; atChild)
 663 {
 664     applyCommandToComposite(SplitElementCommand::create(element, atChild));
 665 }
 666 
 667 void CompositeEditCommand::mergeIdenticalElements(Element&amp; first, Element&amp; second)
 668 {
 669     Ref&lt;Element&gt; protectedFirst = first;
 670     Ref&lt;Element&gt; protectedSecond = second;
 671     ASSERT(!first.isDescendantOf(&amp;second) &amp;&amp; &amp;second != &amp;first);
 672     if (first.nextSibling() != &amp;second) {
 673         removeNode(second);
 674         insertNodeAfter(second, first);
 675     }
 676     applyCommandToComposite(MergeIdenticalElementsCommand::create(first, second));
 677 }
 678 
 679 void CompositeEditCommand::wrapContentsInDummySpan(Element&amp; element)
 680 {
 681     applyCommandToComposite(WrapContentsInDummySpanCommand::create(element));
 682 }
 683 
 684 void CompositeEditCommand::splitTextNodeContainingElement(Text&amp; text, unsigned offset)
 685 {
 686     applyCommandToComposite(SplitTextNodeContainingElementCommand::create(text, offset));
 687 }
 688 
 689 void CompositeEditCommand::inputText(const String&amp; text, bool selectInsertedText)
 690 {
 691     unsigned offset = 0;
 692     unsigned length = text.length();
 693 
 694     RefPtr&lt;ContainerNode&gt; scope;
 695     unsigned startIndex = indexForVisiblePosition(endingSelection().visibleStart(), scope);
 696 
 697     size_t newline;
 698     do {
 699         newline = text.find(&#39;\n&#39;, offset);
 700         if (newline != offset) {
 701             int substringLength = newline == notFound ? length - offset : newline - offset;
 702             applyCommandToComposite(InsertTextCommand::create(document(), text.substring(offset, substringLength), false));
 703         }
 704         if (newline != notFound) {
 705             VisiblePosition caret(endingSelection().visibleStart());
 706             if (enclosingNodeOfType(caret.deepEquivalent(), &amp;isMailBlockquote)) {
 707                 // FIXME: Breaking a blockquote when the caret is just after a space will collapse the
 708                 // space. Modify startIndex or length to compensate for this so that the ending selection
 709                 // will be positioned correctly.
 710                 // &lt;rdar://problem/9914462&gt; breaking a Mail blockquote just after a space collapses the space
 711                 if (caret.previous().characterAfter() == &#39; &#39;) {
 712                     if (!offset &amp;&amp; !startIndex)
 713                         startIndex--;
 714                     else if (!length)
 715                         length--;
 716                 }
 717                 applyCommandToComposite(BreakBlockquoteCommand::create(document()));
 718             } else
 719                 insertLineBreak();
 720         }
 721 
 722         offset = newline + 1;
 723     } while (newline != notFound &amp;&amp; offset != length);
 724 
 725     if (selectInsertedText)
 726         setEndingSelection(VisibleSelection(visiblePositionForIndex(startIndex, scope.get()), visiblePositionForIndex(startIndex + length, scope.get())));
 727 }
 728 
 729 void CompositeEditCommand::insertTextIntoNode(Text&amp; node, unsigned offset, const String&amp; text)
 730 {
 731     if (!text.isEmpty())
 732         applyCommandToComposite(InsertIntoTextNodeCommand::create(node, offset, text, editingAction()));
 733 }
 734 
 735 void CompositeEditCommand::deleteTextFromNode(Text&amp; node, unsigned offset, unsigned count)
 736 {
 737     applyCommandToComposite(DeleteFromTextNodeCommand::create(node, offset, count, editingAction()));
 738 }
 739 
 740 void CompositeEditCommand::replaceTextInNode(Text&amp; node, unsigned offset, unsigned count, const String&amp; replacementText)
 741 {
 742     applyCommandToComposite(DeleteFromTextNodeCommand::create(node, offset, count));
 743     if (!replacementText.isEmpty())
 744         applyCommandToComposite(InsertIntoTextNodeCommand::create(node, offset, replacementText, editingAction()));
 745 }
 746 
 747 Position CompositeEditCommand::replaceSelectedTextInNode(const String&amp; text)
 748 {
 749     Position start = endingSelection().start();
 750     Position end = endingSelection().end();
 751     if (start.containerNode() != end.containerNode() || !start.containerNode()-&gt;isTextNode() || isTabSpanTextNode(start.containerNode()))
 752         return Position();
 753 
 754     RefPtr&lt;Text&gt; textNode = start.containerText();
 755     replaceTextInNode(*textNode, start.offsetInContainerNode(), end.offsetInContainerNode() - start.offsetInContainerNode(), text);
 756 
 757     return Position(textNode.get(), start.offsetInContainerNode() + text.length());
 758 }
 759 
 760 static Vector&lt;RenderedDocumentMarker&gt; copyMarkers(const Vector&lt;RenderedDocumentMarker*&gt;&amp; markerPointers)
 761 {
 762     Vector&lt;RenderedDocumentMarker&gt; markers;
 763     markers.reserveInitialCapacity(markerPointers.size());
 764     for (auto&amp; markerPointer : markerPointers)
 765         markers.uncheckedAppend(*markerPointer);
 766 
 767     return markers;
 768 }
 769 
 770 void CompositeEditCommand::replaceTextInNodePreservingMarkers(Text&amp; node, unsigned offset, unsigned count, const String&amp; replacementText)
 771 {
 772     Ref&lt;Text&gt; protectedNode(node);
 773     DocumentMarkerController&amp; markerController = document().markers();
 774     auto markers = copyMarkers(markerController.markersInRange(Range::create(document(), &amp;node, offset, &amp;node, offset + count), DocumentMarker::allMarkers()));
 775     replaceTextInNode(node, offset, count, replacementText);
 776     auto newRange = Range::create(document(), &amp;node, offset, &amp;node, offset + replacementText.length());
 777     for (const auto&amp; marker : markers) {
 778 #if PLATFORM(IOS_FAMILY)
 779         if (marker.isDictation()) {
 780             markerController.addMarker(newRange, marker.type(), marker.description(), marker.alternatives(), marker.metadata());
 781             continue;
 782         }
 783 #endif
 784 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
 785         if (marker.type() == DocumentMarker::PlatformTextChecking) {
 786             if (!WTF::holds_alternative&lt;DocumentMarker::PlatformTextCheckingData&gt;(marker.data())) {
 787                 ASSERT_NOT_REACHED();
 788                 continue;
 789             }
 790 
 791             auto&amp; textCheckingData = WTF::get&lt;DocumentMarker::PlatformTextCheckingData&gt;(marker.data());
 792             markerController.addPlatformTextCheckingMarker(newRange, textCheckingData.key, textCheckingData.value);
 793             continue;
 794         }
 795 #endif
 796         markerController.addMarker(newRange, marker.type(), marker.description());
 797     }
 798 }
 799 
 800 Position CompositeEditCommand::positionOutsideTabSpan(const Position&amp; position)
 801 {
 802     if (!isTabSpanTextNode(position.anchorNode()))
 803         return position;
 804 
 805     switch (position.anchorType()) {
 806     case Position::PositionIsBeforeChildren:
 807     case Position::PositionIsAfterChildren:
 808         ASSERT_NOT_REACHED();
 809         return position;
 810     case Position::PositionIsOffsetInAnchor:
 811         break;
 812     case Position::PositionIsBeforeAnchor:
 813         return positionInParentBeforeNode(position.anchorNode());
 814     case Position::PositionIsAfterAnchor:
 815         return positionInParentAfterNode(position.anchorNode());
 816     }
 817 
 818     auto* tabSpan = tabSpanNode(position.containerNode());
 819 
 820     if (position.offsetInContainerNode() &lt;= caretMinOffset(*position.containerNode()))
 821         return positionInParentBeforeNode(tabSpan);
 822 
 823     if (position.offsetInContainerNode() &gt;= caretMaxOffset(*position.containerNode()))
 824         return positionInParentAfterNode(tabSpan);
 825 
 826     splitTextNodeContainingElement(downcast&lt;Text&gt;(*position.containerNode()), position.offsetInContainerNode());
 827     return positionInParentBeforeNode(tabSpan);
 828 }
 829 
 830 void CompositeEditCommand::insertNodeAtTabSpanPosition(Ref&lt;Node&gt;&amp;&amp; node, const Position&amp; pos)
 831 {
 832     // insert node before, after, or at split of tab span
 833     insertNodeAt(WTFMove(node), positionOutsideTabSpan(pos));
 834 }
 835 
 836 static EditAction deleteSelectionEditingActionForEditingAction(EditAction editingAction)
 837 {
 838     switch (editingAction) {
 839     case EditAction::Cut:
 840         return EditAction::Cut;
 841     default:
 842         return EditAction::Delete;
 843     }
 844 }
 845 
 846 void CompositeEditCommand::deleteSelection(bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup)
 847 {
 848     if (endingSelection().isRange())
 849         applyCommandToComposite(DeleteSelectionCommand::create(document(), smartDelete, mergeBlocksAfterDelete, replace, expandForSpecialElements, sanitizeMarkup, deleteSelectionEditingActionForEditingAction(editingAction())));
 850 }
 851 
 852 void CompositeEditCommand::deleteSelection(const VisibleSelection &amp;selection, bool smartDelete, bool mergeBlocksAfterDelete, bool replace, bool expandForSpecialElements, bool sanitizeMarkup)
 853 {
 854     if (selection.isRange())
 855         applyCommandToComposite(DeleteSelectionCommand::create(selection, smartDelete, mergeBlocksAfterDelete, replace, expandForSpecialElements, sanitizeMarkup));
 856 }
 857 
 858 void CompositeEditCommand::removeNodeAttribute(Element&amp; element, const QualifiedName&amp; attribute)
 859 {
 860     setNodeAttribute(element, attribute, nullAtom());
 861 }
 862 
 863 void CompositeEditCommand::setNodeAttribute(Element&amp; element, const QualifiedName&amp; attribute, const AtomString&amp; value)
 864 {
 865     applyCommandToComposite(SetNodeAttributeCommand::create(element, attribute, value));
 866 }
 867 
 868 static inline bool containsOnlyDeprecatedEditingWhitespace(const String&amp; text)
 869 {
 870     for (unsigned i = 0; i &lt; text.length(); ++i) {
 871         if (!deprecatedIsEditingWhitespace(text[i]))
 872             return false;
 873     }
 874     return true;
 875 }
 876 
 877 bool CompositeEditCommand::shouldRebalanceLeadingWhitespaceFor(const String&amp; text) const
 878 {
 879     return containsOnlyDeprecatedEditingWhitespace(text);
 880 }
 881 
 882 bool CompositeEditCommand::canRebalance(const Position&amp; position) const
 883 {
 884     Node* node = position.containerNode();
 885     if (position.anchorType() != Position::PositionIsOffsetInAnchor || !is&lt;Text&gt;(node))
 886         return false;
 887 
 888     Text&amp; textNode = downcast&lt;Text&gt;(*node);
 889     if (!textNode.length())
 890         return false;
 891 
 892     node-&gt;document().updateStyleIfNeeded();
 893 
 894     RenderObject* renderer = textNode.renderer();
 895     if (renderer &amp;&amp; !renderer-&gt;style().collapseWhiteSpace())
 896         return false;
 897 
 898     return true;
 899 }
 900 
 901 // FIXME: Doesn&#39;t go into text nodes that contribute adjacent text (siblings, cousins, etc).
 902 void CompositeEditCommand::rebalanceWhitespaceAt(const Position&amp; position)
 903 {
 904     Node* node = position.containerNode();
 905     if (!canRebalance(position))
 906         return;
 907 
 908     // If the rebalance is for the single offset, and neither text[offset] nor text[offset - 1] are some form of whitespace, do nothing.
 909     int offset = position.deprecatedEditingOffset();
 910     String text = downcast&lt;Text&gt;(*node).data();
 911     if (!deprecatedIsEditingWhitespace(text[offset])) {
 912         offset--;
 913         if (offset &lt; 0 || !deprecatedIsEditingWhitespace(text[offset]))
 914             return;
 915     }
 916 
 917     rebalanceWhitespaceOnTextSubstring(downcast&lt;Text&gt;(*node), position.offsetInContainerNode(), position.offsetInContainerNode());
 918 }
 919 
 920 void CompositeEditCommand::rebalanceWhitespaceOnTextSubstring(Text&amp; textNode, int startOffset, int endOffset)
 921 {
 922     String text = textNode.data();
 923     ASSERT(!text.isEmpty());
 924 
 925     // Set upstream and downstream to define the extent of the whitespace surrounding text[offset].
 926     int upstream = startOffset;
 927     while (upstream &gt; 0 &amp;&amp; deprecatedIsEditingWhitespace(text[upstream - 1]))
 928         upstream--;
 929 
 930     int downstream = endOffset;
 931     while ((unsigned)downstream &lt; text.length() &amp;&amp; deprecatedIsEditingWhitespace(text[downstream]))
 932         downstream++;
 933 
 934     int length = downstream - upstream;
 935     if (!length)
 936         return;
 937 
 938     VisiblePosition visibleUpstreamPos(Position(&amp;textNode, upstream));
 939     VisiblePosition visibleDownstreamPos(Position(&amp;textNode, downstream));
 940 
 941     String string = text.substring(upstream, length);
 942     String rebalancedString = stringWithRebalancedWhitespace(string,
 943     // FIXME: Because of the problem mentioned at the top of this function, we must also use nbsps at the start/end of the string because
 944     // this function doesn&#39;t get all surrounding whitespace, just the whitespace in the current text node.
 945                                                              isStartOfParagraph(visibleUpstreamPos) || upstream == 0,
 946                                                              isEndOfParagraph(visibleDownstreamPos) || (unsigned)downstream == text.length());
 947 
 948     if (string != rebalancedString)
 949         replaceTextInNodePreservingMarkers(textNode, upstream, length, rebalancedString);
 950 }
 951 
 952 void CompositeEditCommand::prepareWhitespaceAtPositionForSplit(Position&amp; position)
 953 {
 954     Node* node = position.deprecatedNode();
 955     if (!is&lt;Text&gt;(node))
 956         return;
 957     Text&amp; textNode = downcast&lt;Text&gt;(*node);
 958 
 959     if (!textNode.length())
 960         return;
 961     RenderObject* renderer = textNode.renderer();
 962     if (renderer &amp;&amp; !renderer-&gt;style().collapseWhiteSpace())
 963         return;
 964 
 965     // Delete collapsed whitespace so that inserting nbsps doesn&#39;t uncollapse it.
 966     Position upstreamPos = position.upstream();
 967     deleteInsignificantText(position.upstream(), position.downstream());
 968     position = upstreamPos.downstream();
 969 
 970     VisiblePosition visiblePos(position);
 971     VisiblePosition previousVisiblePos(visiblePos.previous());
 972     Position previous(previousVisiblePos.deepEquivalent());
 973 
 974     if (deprecatedIsCollapsibleWhitespace(previousVisiblePos.characterAfter()) &amp;&amp; is&lt;Text&gt;(*previous.deprecatedNode()) &amp;&amp; !is&lt;HTMLBRElement&gt;(*previous.deprecatedNode()))
 975         replaceTextInNodePreservingMarkers(downcast&lt;Text&gt;(*previous.deprecatedNode()), previous.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
 976     if (deprecatedIsCollapsibleWhitespace(visiblePos.characterAfter()) &amp;&amp; is&lt;Text&gt;(*position.deprecatedNode()) &amp;&amp; !is&lt;HTMLBRElement&gt;(*position.deprecatedNode()))
 977         replaceTextInNodePreservingMarkers(downcast&lt;Text&gt;(*position.deprecatedNode()), position.deprecatedEditingOffset(), 1, nonBreakingSpaceString());
 978 }
 979 
 980 void CompositeEditCommand::rebalanceWhitespace()
 981 {
 982     VisibleSelection selection = endingSelection();
 983     if (selection.isNone())
 984         return;
 985 
 986     rebalanceWhitespaceAt(selection.start());
 987     if (selection.isRange())
 988         rebalanceWhitespaceAt(selection.end());
 989 }
 990 
 991 void CompositeEditCommand::deleteInsignificantText(Text&amp; textNode, unsigned start, unsigned end)
 992 {
 993     if (start &gt;= end)
 994         return;
 995 
 996     document().updateLayout();
 997 
 998     RenderText* textRenderer = textNode.renderer();
 999     if (!textRenderer)
1000         return;
1001 
1002     Vector&lt;InlineTextBox*&gt; sortedTextBoxes;
1003     size_t sortedTextBoxesPosition = 0;
1004 
<a name="1" id="anc1"></a><span class="line-added">1005     textRenderer-&gt;ensureLineBoxes();</span>
1006     for (InlineTextBox* textBox = textRenderer-&gt;firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())
1007         sortedTextBoxes.append(textBox);
1008 
1009     // If there is mixed directionality text, the boxes can be out of order,
1010     // (like Arabic with embedded LTR), so sort them first.
1011     if (textRenderer-&gt;containsReversedText())
1012         std::sort(sortedTextBoxes.begin(), sortedTextBoxes.end(), InlineTextBox::compareByStart);
1013     InlineTextBox* box = sortedTextBoxes.isEmpty() ? 0 : sortedTextBoxes[sortedTextBoxesPosition];
1014 
1015     if (!box) {
1016         // whole text node is empty
1017         removeNode(textNode);
1018         return;
1019     }
1020 
1021     unsigned length = textNode.length();
1022     if (start &gt;= length || end &gt; length)
1023         return;
1024 
1025     unsigned removed = 0;
1026     InlineTextBox* prevBox = nullptr;
1027     String str;
1028 
1029     // This loop structure works to process all gaps preceding a box,
1030     // and also will look at the gap after the last box.
1031     while (prevBox || box) {
1032         unsigned gapStart = prevBox ? prevBox-&gt;start() + prevBox-&gt;len() : 0;
1033         if (end &lt; gapStart)
1034             // No more chance for any intersections
1035             break;
1036 
1037         unsigned gapEnd = box ? box-&gt;start() : length;
1038         bool indicesIntersect = start &lt;= gapEnd &amp;&amp; end &gt;= gapStart;
1039         int gapLen = gapEnd - gapStart;
1040         if (indicesIntersect &amp;&amp; gapLen &gt; 0) {
1041             gapStart = std::max(gapStart, start);
1042             gapEnd = std::min(gapEnd, end);
1043             if (str.isNull())
1044                 str = textNode.data().substring(start, end - start);
1045             // remove text in the gap
1046             str.remove(gapStart - start - removed, gapLen);
1047             removed += gapLen;
1048         }
1049 
1050         prevBox = box;
1051         if (box) {
1052             if (++sortedTextBoxesPosition &lt; sortedTextBoxes.size())
1053                 box = sortedTextBoxes[sortedTextBoxesPosition];
1054             else
1055                 box = nullptr;
1056         }
1057     }
1058 
1059     if (!str.isNull()) {
1060         // Replace the text between start and end with our pruned version.
1061         if (!str.isEmpty())
1062             replaceTextInNode(textNode, start, end - start, str);
1063         else {
1064             // Assert that we are not going to delete all of the text in the node.
1065             // If we were, that should have been done above with the call to
1066             // removeNode and return.
1067             ASSERT(start &gt; 0 || end - start &lt; textNode.length());
1068             deleteTextFromNode(textNode, start, end - start);
1069         }
1070     }
1071 }
1072 
1073 void CompositeEditCommand::deleteInsignificantText(const Position&amp; start, const Position&amp; end)
1074 {
1075     if (start.isNull() || end.isNull())
1076         return;
1077 
1078     if (comparePositions(start, end) &gt;= 0)
1079         return;
1080 
1081     Vector&lt;Ref&lt;Text&gt;&gt; nodes;
1082     for (Node* node = start.deprecatedNode(); node; node = NodeTraversal::next(*node)) {
1083         if (is&lt;Text&gt;(*node))
1084             nodes.append(downcast&lt;Text&gt;(*node));
1085         if (node == end.deprecatedNode())
1086             break;
1087     }
1088 
1089     for (auto&amp; textNode : nodes) {
1090         int startOffset = textNode.ptr() == start.deprecatedNode() ? start.deprecatedEditingOffset() : 0;
1091         int endOffset = textNode.ptr() == end.deprecatedNode() ? end.deprecatedEditingOffset() : static_cast&lt;int&gt;(textNode-&gt;length());
1092         deleteInsignificantText(textNode, startOffset, endOffset);
1093     }
1094 }
1095 
1096 void CompositeEditCommand::deleteInsignificantTextDownstream(const Position&amp; pos)
1097 {
1098     Position end = VisiblePosition(pos, VP_DEFAULT_AFFINITY).next().deepEquivalent().downstream();
1099     deleteInsignificantText(pos, end);
1100 }
1101 
1102 Ref&lt;Element&gt; CompositeEditCommand::appendBlockPlaceholder(Ref&lt;Element&gt;&amp;&amp; container)
1103 {
1104     document().updateLayoutIgnorePendingStylesheets();
1105 
1106     // Should assert isBlockFlow || isInlineFlow when deletion improves. See 4244964.
1107     ASSERT(container-&gt;renderer());
1108 
1109     auto placeholder = createBlockPlaceholderElement(document());
1110     appendNode(placeholder.copyRef(), WTFMove(container));
1111     return placeholder;
1112 }
1113 
1114 RefPtr&lt;Node&gt; CompositeEditCommand::insertBlockPlaceholder(const Position&amp; pos)
1115 {
1116     if (pos.isNull())
1117         return nullptr;
1118 
1119     // Should assert isBlockFlow || isInlineFlow when deletion improves.  See 4244964.
1120     ASSERT(pos.deprecatedNode()-&gt;renderer());
1121 
1122     auto placeholder = createBlockPlaceholderElement(document());
1123     insertNodeAt(placeholder.copyRef(), pos);
1124     return placeholder;
1125 }
1126 
1127 RefPtr&lt;Node&gt; CompositeEditCommand::addBlockPlaceholderIfNeeded(Element* container)
1128 {
1129     if (!container)
1130         return nullptr;
1131 
1132     document().updateLayoutIgnorePendingStylesheets();
1133 
1134     auto* renderer = container-&gt;renderer();
1135     if (!is&lt;RenderBlockFlow&gt;(renderer))
1136         return nullptr;
1137 
1138     // Append the placeholder to make sure it follows any unrendered blocks.
1139     auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer);
1140     if (!blockFlow.height() || (blockFlow.isListItem() &amp;&amp; !blockFlow.firstChild()))
1141         return appendBlockPlaceholder(*container);
1142 
1143     return nullptr;
1144 }
1145 
1146 // Assumes that the position is at a placeholder and does the removal without much checking.
1147 void CompositeEditCommand::removePlaceholderAt(const Position&amp; p)
1148 {
1149     ASSERT(lineBreakExistsAtPosition(p));
1150 
1151     // We are certain that the position is at a line break, but it may be a br or a preserved newline.
1152     if (is&lt;HTMLBRElement&gt;(*p.anchorNode())) {
1153         removeNode(*p.anchorNode());
1154         return;
1155     }
1156 
1157     deleteTextFromNode(downcast&lt;Text&gt;(*p.anchorNode()), p.offsetInContainerNode(), 1);
1158 }
1159 
1160 Ref&lt;HTMLElement&gt; CompositeEditCommand::insertNewDefaultParagraphElementAt(const Position&amp; position)
1161 {
1162     auto paragraphElement = createDefaultParagraphElement(document());
1163     paragraphElement-&gt;appendChild(HTMLBRElement::create(document()));
1164     insertNodeAt(paragraphElement.copyRef(), position);
1165     return paragraphElement;
1166 }
1167 
1168 // If the paragraph is not entirely within it&#39;s own block, create one and move the paragraph into
1169 // it, and return that block.  Otherwise return 0.
1170 RefPtr&lt;Node&gt; CompositeEditCommand::moveParagraphContentsToNewBlockIfNecessary(const Position&amp; pos)
1171 {
1172     if (pos.isNull())
1173         return nullptr;
1174 
1175     document().updateLayoutIgnorePendingStylesheets();
1176 
1177     // It&#39;s strange that this function is responsible for verifying that pos has not been invalidated
1178     // by an earlier call to this function.  The caller, applyBlockStyle, should do this.
1179     VisiblePosition visiblePos(pos, VP_DEFAULT_AFFINITY);
1180     VisiblePosition visibleParagraphStart(startOfParagraph(visiblePos));
1181     VisiblePosition visibleParagraphEnd = endOfParagraph(visiblePos);
1182     VisiblePosition next = visibleParagraphEnd.next();
1183     VisiblePosition visibleEnd = next.isNotNull() ? next : visibleParagraphEnd;
1184 
1185     Position upstreamStart = visibleParagraphStart.deepEquivalent().upstream();
1186     Position upstreamEnd = visibleEnd.deepEquivalent().upstream();
1187 
1188     // If there are no VisiblePositions in the same block as pos then
1189     // upstreamStart will be outside the paragraph
1190     if (comparePositions(pos, upstreamStart) &lt; 0)
1191         return nullptr;
1192 
1193     // Perform some checks to see if we need to perform work in this function.
1194     if (isBlock(upstreamStart.deprecatedNode())) {
1195         // If the block is the root editable element, always move content to a new block,
1196         // since it is illegal to modify attributes on the root editable element for editing.
1197         if (upstreamStart.deprecatedNode() == editableRootForPosition(upstreamStart)) {
1198             // If the block is the root editable element and it contains no visible content, create a new
1199             // block but don&#39;t try and move content into it, since there&#39;s nothing for moveParagraphs to move.
1200             if (!Position::hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderElement&gt;(*upstreamStart.deprecatedNode()-&gt;renderer())))
1201                 return insertNewDefaultParagraphElementAt(upstreamStart);
1202         } else if (isBlock(upstreamEnd.deprecatedNode())) {
1203             if (!upstreamEnd.deprecatedNode()-&gt;isDescendantOf(upstreamStart.deprecatedNode())) {
1204                 // If the paragraph end is a descendant of paragraph start, then we need to run
1205                 // the rest of this function. If not, we can bail here.
1206                 return nullptr;
1207             }
1208         } else if (enclosingBlock(upstreamEnd.deprecatedNode()) != upstreamStart.deprecatedNode()) {
1209             // The visibleEnd. If it is an ancestor of the paragraph start, then
1210             // we can bail as we have a full block to work with.
1211             if (upstreamStart.deprecatedNode()-&gt;isDescendantOf(enclosingBlock(upstreamEnd.deprecatedNode())))
1212                 return nullptr;
1213         } else if (isEndOfEditableOrNonEditableContent(visibleEnd)) {
1214             // At the end of the editable region. We can bail here as well.
1215             return nullptr;
1216         }
1217     }
1218 
1219     // If upstreamStart is not editable, then we can bail here.
1220     if (!isEditablePosition(upstreamStart))
1221         return nullptr;
1222     auto newBlock = insertNewDefaultParagraphElementAt(upstreamStart);
1223 
1224     bool endWasBr = visibleParagraphEnd.deepEquivalent().deprecatedNode()-&gt;hasTagName(brTag);
1225 
1226     moveParagraphs(visibleParagraphStart, visibleParagraphEnd, VisiblePosition(firstPositionInNode(newBlock.ptr())));
1227 
1228     if (newBlock-&gt;lastChild() &amp;&amp; newBlock-&gt;lastChild()-&gt;hasTagName(brTag) &amp;&amp; !endWasBr)
1229         removeNode(*newBlock-&gt;lastChild());
1230 
1231     return newBlock;
1232 }
1233 
1234 void CompositeEditCommand::pushAnchorElementDown(Element&amp; anchorElement)
1235 {
1236     ASSERT(anchorElement.isLink());
1237 
1238     setEndingSelection(VisibleSelection::selectionFromContentsOfNode(&amp;anchorElement));
1239     applyStyledElement(anchorElement);
1240     // Clones of anchorElement have been pushed down, now remove it.
1241     if (anchorElement.isConnected())
1242         removeNodePreservingChildren(anchorElement);
1243 }
1244 
1245 // Clone the paragraph between start and end under blockElement,
1246 // preserving the hierarchy up to outerNode.
1247 
1248 void CompositeEditCommand::cloneParagraphUnderNewElement(const Position&amp; start, const Position&amp; end, Node* passedOuterNode, Element* blockElement)
1249 {
1250     ASSERT(comparePositions(start, end) &lt;= 0);
1251 
1252     // First we clone the outerNode
1253     RefPtr&lt;Node&gt; lastNode;
1254     RefPtr&lt;Node&gt; outerNode = passedOuterNode;
1255 
1256     if (outerNode-&gt;isRootEditableElement()) {
1257         lastNode = blockElement;
1258     } else {
1259         lastNode = outerNode-&gt;cloneNode(isRenderedTable(outerNode.get()));
1260         appendNode(*lastNode, *blockElement);
1261     }
1262 
1263     if (start.deprecatedNode() != outerNode &amp;&amp; lastNode-&gt;isElementNode() &amp;&amp; start.anchorNode()-&gt;isDescendantOf(outerNode.get())) {
1264         Vector&lt;RefPtr&lt;Node&gt;&gt; ancestors;
1265 
1266         // Insert each node from innerNode to outerNode (excluded) in a list.
1267         for (Node* n = start.deprecatedNode(); n &amp;&amp; n != outerNode; n = n-&gt;parentNode())
1268             ancestors.append(n);
1269 
1270         // Clone every node between start.deprecatedNode() and outerBlock.
1271 
1272         for (size_t i = ancestors.size(); i != 0; --i) {
1273             Node* item = ancestors[i - 1].get();
1274             auto child = item-&gt;cloneNode(isRenderedTable(item));
1275             appendNode(child.copyRef(), downcast&lt;Element&gt;(*lastNode));
1276             lastNode = WTFMove(child);
1277         }
1278     }
1279 
1280     // Handle the case of paragraphs with more than one node,
1281     // cloning all the siblings until end.deprecatedNode() is reached.
1282 
1283     if (start.deprecatedNode() != end.deprecatedNode() &amp;&amp; !start.deprecatedNode()-&gt;isDescendantOf(end.deprecatedNode())) {
1284         // If end is not a descendant of outerNode we need to
1285         // find the first common ancestor to increase the scope
1286         // of our nextSibling traversal.
1287         while (!end.deprecatedNode()-&gt;isDescendantOf(outerNode.get())) {
1288             outerNode = outerNode-&gt;parentNode();
1289         }
1290 
1291         RefPtr&lt;Node&gt; startNode = start.deprecatedNode();
1292         for (RefPtr&lt;Node&gt; node = NodeTraversal::nextSkippingChildren(*startNode, outerNode.get()); node; node = NodeTraversal::nextSkippingChildren(*node, outerNode.get())) {
1293             // Move lastNode up in the tree as much as node was moved up in the
1294             // tree by NodeTraversal::nextSkippingChildren, so that the relative depth between
1295             // node and the original start node is maintained in the clone.
1296             while (startNode-&gt;parentNode() != node-&gt;parentNode()) {
1297                 startNode = startNode-&gt;parentNode();
1298                 lastNode = lastNode-&gt;parentNode();
1299             }
1300 
1301             auto clonedNode = node-&gt;cloneNode(true);
1302             insertNodeAfter(clonedNode.copyRef(), *lastNode);
1303             lastNode = WTFMove(clonedNode);
1304             if (node == end.deprecatedNode() || end.deprecatedNode()-&gt;isDescendantOf(*node))
1305                 break;
1306         }
1307     }
1308 }
1309 
1310 
1311 // There are bugs in deletion when it removes a fully selected table/list.
1312 // It expands and removes the entire table/list, but will let content
1313 // before and after the table/list collapse onto one line.
1314 // Deleting a paragraph will leave a placeholder. Remove it (and prune
1315 // empty or unrendered parents).
1316 
1317 void CompositeEditCommand::cleanupAfterDeletion(VisiblePosition destination)
1318 {
1319     VisiblePosition caretAfterDelete = endingSelection().visibleStart();
1320     if (!caretAfterDelete.equals(destination) &amp;&amp; isStartOfParagraph(caretAfterDelete) &amp;&amp; isEndOfParagraph(caretAfterDelete)) {
1321         // Note: We want the rightmost candidate.
1322         Position position = caretAfterDelete.deepEquivalent().downstream();
1323         Node* node = position.deprecatedNode();
1324         ASSERT(node);
1325         // Normally deletion will leave a br as a placeholder.
1326         if (is&lt;HTMLBRElement&gt;(*node))
1327             removeNodeAndPruneAncestors(*node);
1328         // If the selection to move was empty and in an empty block that
1329         // doesn&#39;t require a placeholder to prop itself open (like a bordered
1330         // div or an li), remove it during the move (the list removal code
1331         // expects this behavior).
1332         else if (isBlock(node)) {
1333             // If caret position after deletion and destination position coincides,
1334             // node should not be removed.
1335             if (!position.rendersInDifferentPosition(destination.deepEquivalent())) {
1336                 prune(node);
1337                 return;
1338             }
1339             removeNodeAndPruneAncestors(*node);
1340         }
1341         else if (lineBreakExistsAtPosition(position)) {
1342             // There is a preserved &#39;\n&#39; at caretAfterDelete.
1343             // We can safely assume this is a text node.
1344             Text&amp; textNode = downcast&lt;Text&gt;(*node);
1345             if (textNode.length() == 1)
1346                 removeNodeAndPruneAncestors(textNode);
1347             else
1348                 deleteTextFromNode(textNode, position.deprecatedEditingOffset(), 1);
1349         }
1350     }
1351 }
1352 
1353 // This is a version of moveParagraph that preserves style by keeping the original markup
1354 // It is currently used only by IndentOutdentCommand but it is meant to be used in the
1355 // future by several other commands such as InsertList and the align commands.
1356 // The blockElement parameter is the element to move the paragraph to,
1357 // outerNode is the top element of the paragraph hierarchy.
1358 
1359 void CompositeEditCommand::moveParagraphWithClones(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, Element* blockElement, Node* outerNode)
1360 {
1361     if (startOfParagraphToMove.isNull() || endOfParagraphToMove.isNull())
1362         return;
1363 
1364     ASSERT(outerNode);
1365     ASSERT(blockElement);
1366 
1367     VisiblePosition beforeParagraph = startOfParagraphToMove.previous();
1368     VisiblePosition afterParagraph(endOfParagraphToMove.next());
1369 
1370     // We upstream() the end and downstream() the start so that we don&#39;t include collapsed whitespace in the move.
1371     // When we paste a fragment, spaces after the end and before the start are treated as though they were rendered.
1372     Position start = startOfParagraphToMove.deepEquivalent().downstream();
1373     Position end = startOfParagraphToMove == endOfParagraphToMove ? start : endOfParagraphToMove.deepEquivalent().upstream();
1374 
1375     cloneParagraphUnderNewElement(start, end, outerNode, blockElement);
1376 
1377     setEndingSelection(VisibleSelection(start, end, DOWNSTREAM));
1378     deleteSelection(false, false, false, false);
1379 
1380     // There are bugs in deletion when it removes a fully selected table/list.
1381     // It expands and removes the entire table/list, but will let content
1382     // before and after the table/list collapse onto one line.
1383 
1384     cleanupAfterDeletion();
1385 
1386     // Add a br if pruning an empty block level element caused a collapse.  For example:
1387     // foo^
1388     // &lt;div&gt;bar&lt;/div&gt;
1389     // baz
1390     // Imagine moving &#39;bar&#39; to ^.  &#39;bar&#39; will be deleted and its div pruned.  That would
1391     // cause &#39;baz&#39; to collapse onto the line with &#39;foobar&#39; unless we insert a br.
1392     // Must recononicalize these two VisiblePositions after the pruning above.
1393     beforeParagraph = VisiblePosition(beforeParagraph.deepEquivalent());
1394     afterParagraph = VisiblePosition(afterParagraph.deepEquivalent());
1395 
1396     if (beforeParagraph.isNotNull() &amp;&amp; !isRenderedTable(beforeParagraph.deepEquivalent().deprecatedNode())
1397         &amp;&amp; ((!isEndOfParagraph(beforeParagraph) &amp;&amp; !isStartOfParagraph(beforeParagraph)) || beforeParagraph == afterParagraph)
1398         &amp;&amp; isEditablePosition(beforeParagraph.deepEquivalent())) {
1399         // FIXME: Trim text between beforeParagraph and afterParagraph if they aren&#39;t equal.
1400         insertNodeAt(HTMLBRElement::create(document()), beforeParagraph.deepEquivalent());
1401     }
1402 }
1403 
1404 
1405 // This moves a paragraph preserving its style.
1406 void CompositeEditCommand::moveParagraph(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, const VisiblePosition&amp; destination, bool preserveSelection, bool preserveStyle)
1407 {
1408     ASSERT(isStartOfParagraph(startOfParagraphToMove));
1409     ASSERT(isEndOfParagraph(endOfParagraphToMove));
1410     moveParagraphs(startOfParagraphToMove, endOfParagraphToMove, destination, preserveSelection, preserveStyle);
1411 }
1412 
1413 void CompositeEditCommand::moveParagraphs(const VisiblePosition&amp; startOfParagraphToMove, const VisiblePosition&amp; endOfParagraphToMove, const VisiblePosition&amp; destination, bool preserveSelection, bool preserveStyle)
1414 {
1415     if (startOfParagraphToMove == destination)
1416         return;
1417 
1418     int startIndex = -1;
1419     int endIndex = -1;
1420     int destinationIndex = -1;
1421     bool originalIsDirectional = endingSelection().isDirectional();
1422     if (preserveSelection &amp;&amp; !endingSelection().isNone()) {
1423         VisiblePosition visibleStart = endingSelection().visibleStart();
1424         VisiblePosition visibleEnd = endingSelection().visibleEnd();
1425 
1426         bool startAfterParagraph = comparePositions(visibleStart, endOfParagraphToMove) &gt; 0;
1427         bool endBeforeParagraph = comparePositions(visibleEnd, startOfParagraphToMove) &lt; 0;
1428 
1429         if (!startAfterParagraph &amp;&amp; !endBeforeParagraph) {
1430             bool startInParagraph = comparePositions(visibleStart, startOfParagraphToMove) &gt;= 0;
1431             bool endInParagraph = comparePositions(visibleEnd, endOfParagraphToMove) &lt;= 0;
1432 
1433             startIndex = 0;
1434             if (startInParagraph) {
1435                 auto startRange = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), visibleStart.deepEquivalent().parentAnchoredEquivalent());
1436                 startIndex = TextIterator::rangeLength(startRange.ptr(), true);
1437             }
1438 
1439             endIndex = 0;
1440             if (endInParagraph) {
1441                 auto endRange = Range::create(document(), startOfParagraphToMove.deepEquivalent().parentAnchoredEquivalent(), visibleEnd.deepEquivalent().parentAnchoredEquivalent());
1442                 endIndex = TextIterator::rangeLength(endRange.ptr(), true);
1443             }
1444         }
1445     }
1446 
1447     VisiblePosition beforeParagraph = startOfParagraphToMove.previous(CannotCrossEditingBoundary);
1448     VisiblePosition afterParagraph(endOfParagraphToMove.next(CannotCrossEditingBoundary));
1449 
1450     // We upstream() the end and downstream() the start so that we don&#39;t include collapsed whitespace in the move.
1451     // When we paste a fragment, spaces after the end and before the start are treated as though they were rendered.
1452     Position start = startOfParagraphToMove.deepEquivalent().downstream();
1453     Position end = endOfParagraphToMove.deepEquivalent().upstream();
1454 
1455     // start and end can&#39;t be used directly to create a Range; they are &quot;editing positions&quot;
1456     Position startRangeCompliant = start.parentAnchoredEquivalent();
1457     Position endRangeCompliant = end.parentAnchoredEquivalent();
1458     auto range = Range::create(document(), startRangeCompliant.deprecatedNode(), startRangeCompliant.deprecatedEditingOffset(), endRangeCompliant.deprecatedNode(), endRangeCompliant.deprecatedEditingOffset());
1459 
1460     // FIXME: This is an inefficient way to preserve style on nodes in the paragraph to move. It
1461     // shouldn&#39;t matter though, since moved paragraphs will usually be quite small.
1462     RefPtr&lt;DocumentFragment&gt; fragment;
1463     // This used to use a ternary for initialization, but that confused some versions of GCC, see bug 37912
1464     if (startOfParagraphToMove != endOfParagraphToMove)
1465         fragment = createFragmentFromMarkup(document(), serializePreservingVisualAppearance(range.get(), nullptr, AnnotateForInterchange::No, ConvertBlocksToInlines::Yes), emptyString());
1466 
1467     // A non-empty paragraph&#39;s style is moved when we copy and move it.  We don&#39;t move
1468     // anything if we&#39;re given an empty paragraph, but an empty paragraph can have style
1469     // too, &lt;div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt; for example.  Save it so that we can preserve it later.
1470     RefPtr&lt;EditingStyle&gt; styleInEmptyParagraph;
1471 #if !PLATFORM(IOS_FAMILY)
1472     if (startOfParagraphToMove == endOfParagraphToMove &amp;&amp; preserveStyle) {
1473 #else
1474     if (startOfParagraphToMove == endOfParagraphToMove &amp;&amp; preserveStyle &amp;&amp; isRichlyEditablePosition(destination.deepEquivalent())) {
1475 #endif
1476         styleInEmptyParagraph = EditingStyle::create(startOfParagraphToMove.deepEquivalent());
1477         styleInEmptyParagraph-&gt;mergeTypingStyle(document());
1478         // The moved paragraph should assume the block style of the destination.
1479         styleInEmptyParagraph-&gt;removeBlockProperties();
1480     }
1481 
1482     // FIXME (5098931): We should add a new insert action &quot;WebViewInsertActionMoved&quot; and call shouldInsertFragment here.
1483 
1484     setEndingSelection(VisibleSelection(start, end, DOWNSTREAM));
1485     frame().editor().clearMisspellingsAndBadGrammar(endingSelection());
1486     deleteSelection(false, false, false, false);
1487 
1488     ASSERT(destination.deepEquivalent().anchorNode()-&gt;isConnected());
1489     cleanupAfterDeletion(destination);
1490     ASSERT(destination.deepEquivalent().anchorNode()-&gt;isConnected());
1491 
1492     // Add a br if pruning an empty block level element caused a collapse. For example:
1493     // foo^
1494     // &lt;div&gt;bar&lt;/div&gt;
1495     // baz
1496     // Imagine moving &#39;bar&#39; to ^. &#39;bar&#39; will be deleted and its div pruned. That would
1497     // cause &#39;baz&#39; to collapse onto the line with &#39;foobar&#39; unless we insert a br.
1498     // Must recononicalize these two VisiblePositions after the pruning above.
1499     beforeParagraph = VisiblePosition(beforeParagraph.deepEquivalent());
1500     afterParagraph = VisiblePosition(afterParagraph.deepEquivalent());
1501     if (beforeParagraph.isNotNull() &amp;&amp; ((!isStartOfParagraph(beforeParagraph) &amp;&amp; !isEndOfParagraph(beforeParagraph)) || beforeParagraph == afterParagraph)) {
1502         // FIXME: Trim text between beforeParagraph and afterParagraph if they aren&#39;t equal.
1503         insertNodeAt(HTMLBRElement::create(document()), beforeParagraph.deepEquivalent());
1504         // Need an updateLayout here in case inserting the br has split a text node.
1505         document().updateLayoutIgnorePendingStylesheets();
1506     }
1507 
1508     RefPtr&lt;ContainerNode&gt; editableRoot = destination.rootEditableElement();
1509     if (!editableRoot)
1510         editableRoot = &amp;document();
1511 
1512     auto startToDestinationRange = Range::create(document(), firstPositionInNode(editableRoot.get()), destination.deepEquivalent().parentAnchoredEquivalent());
1513     destinationIndex = TextIterator::rangeLength(startToDestinationRange.ptr(), true);
1514 
1515     setEndingSelection(VisibleSelection(destination, originalIsDirectional));
1516     ASSERT(endingSelection().isCaretOrRange());
1517     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::SelectReplacement, ReplaceSelectionCommand::MovingParagraph };
1518     if (!preserveStyle)
1519         options.add(ReplaceSelectionCommand::MatchStyle);
1520     applyCommandToComposite(ReplaceSelectionCommand::create(document(), WTFMove(fragment), options));
1521 
1522     frame().editor().markMisspellingsAndBadGrammar(endingSelection());
1523 
1524     // If the selection is in an empty paragraph, restore styles from the old empty paragraph to the new empty paragraph.
1525     bool selectionIsEmptyParagraph = endingSelection().isCaret() &amp;&amp; isStartOfParagraph(endingSelection().visibleStart()) &amp;&amp; isEndOfParagraph(endingSelection().visibleStart());
1526     if (styleInEmptyParagraph &amp;&amp; selectionIsEmptyParagraph)
1527         applyStyle(styleInEmptyParagraph.get());
1528 
1529     if (preserveSelection &amp;&amp; startIndex != -1) {
1530         // Fragment creation (using createMarkup) incorrectly uses regular
1531         // spaces instead of nbsps for some spaces that were rendered (11475), which
1532         // causes spaces to be collapsed during the move operation.  This results
1533         // in a call to rangeFromLocationAndLength with a location past the end
1534         // of the document (which will return null).
1535         RefPtr&lt;Range&gt; start = TextIterator::rangeFromLocationAndLength(editableRoot.get(), destinationIndex + startIndex, 0, true);
1536         RefPtr&lt;Range&gt; end = TextIterator::rangeFromLocationAndLength(editableRoot.get(), destinationIndex + endIndex, 0, true);
1537         if (start &amp;&amp; end)
1538             setEndingSelection(VisibleSelection(start-&gt;startPosition(), end-&gt;startPosition(), DOWNSTREAM, originalIsDirectional));
1539     }
1540 }
1541 
1542 Optional&lt;VisibleSelection&gt; CompositeEditCommand::shouldBreakOutOfEmptyListItem() const
1543 {
1544     auto emptyListItem = enclosingEmptyListItem(endingSelection().visibleStart());
1545     if (!emptyListItem)
1546         return WTF::nullopt;
1547 
1548     auto listNode = emptyListItem-&gt;parentNode();
1549     // FIXME: Can&#39;t we do something better when the immediate parent wasn&#39;t a list node?
1550     if (!listNode
1551         || (!listNode-&gt;hasTagName(ulTag) &amp;&amp; !listNode-&gt;hasTagName(olTag))
1552         || !listNode-&gt;hasEditableStyle()
1553         || listNode == emptyListItem-&gt;rootEditableElement())
1554         return WTF::nullopt;
1555 
1556     return VisibleSelection(endingSelection().start().previous(BackwardDeletion), endingSelection().end());
1557 }
1558 
1559 // FIXME: Send an appropriate shouldDeleteRange call.
1560 bool CompositeEditCommand::breakOutOfEmptyListItem()
1561 {
1562     if (!shouldBreakOutOfEmptyListItem())
1563         return false;
1564 
1565     auto emptyListItem = enclosingEmptyListItem(endingSelection().visibleStart());
1566     auto listNode = emptyListItem-&gt;parentNode();
1567     auto style = EditingStyle::create(endingSelection().start());
1568     style-&gt;mergeTypingStyle(document());
1569 
1570     RefPtr&lt;Element&gt; newBlock;
1571     if (ContainerNode* blockEnclosingList = listNode-&gt;parentNode()) {
1572         if (is&lt;HTMLLIElement&gt;(*blockEnclosingList)) { // listNode is inside another list item
1573             if (visiblePositionAfterNode(*blockEnclosingList) == visiblePositionAfterNode(*listNode)) {
1574                 // If listNode appears at the end of the outer list item, then move listNode outside of this list item
1575                 // e.g. &lt;ul&gt;&lt;li&gt;hello &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; should become &lt;ul&gt;&lt;li&gt;hello&lt;/li&gt; &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/ul&gt; after this section
1576                 // If listNode does NOT appear at the end, then we should consider it as a regular paragraph.
1577                 // e.g. &lt;ul&gt;&lt;li&gt; &lt;ul&gt;&lt;li&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt; hello&lt;/li&gt;&lt;/ul&gt; should become &lt;ul&gt;&lt;li&gt; &lt;div&gt;&lt;br&gt;&lt;/div&gt; hello&lt;/li&gt;&lt;/ul&gt; at the end
1578                 splitElement(downcast&lt;HTMLLIElement&gt;(*blockEnclosingList), *listNode);
1579                 removeNodePreservingChildren(*listNode-&gt;parentNode());
1580                 newBlock = HTMLLIElement::create(document());
1581             }
1582             // If listNode does NOT appear at the end of the outer list item, then behave as if in a regular paragraph.
1583         } else if (blockEnclosingList-&gt;hasTagName(olTag) || blockEnclosingList-&gt;hasTagName(ulTag))
1584             newBlock = HTMLLIElement::create(document());
1585     }
1586     if (!newBlock)
1587         newBlock = createDefaultParagraphElement(document());
1588 
1589     RefPtr&lt;Node&gt; previousListNode = emptyListItem-&gt;isElementNode() ? ElementTraversal::previousSibling(*emptyListItem): emptyListItem-&gt;previousSibling();
1590     RefPtr&lt;Node&gt; nextListNode = emptyListItem-&gt;isElementNode() ? ElementTraversal::nextSibling(*emptyListItem): emptyListItem-&gt;nextSibling();
1591     if (isListItem(nextListNode.get()) || isListHTMLElement(nextListNode.get())) {
1592         // If emptyListItem follows another list item or nested list, split the list node.
1593         if (isListItem(previousListNode.get()) || isListHTMLElement(previousListNode.get()))
1594             splitElement(downcast&lt;Element&gt;(*listNode), *emptyListItem);
1595 
1596         // If emptyListItem is followed by other list item or nested list, then insert newBlock before the list node.
1597         // Because we have splitted the element, emptyListItem is the first element in the list node.
1598         // i.e. insert newBlock before ul or ol whose first element is emptyListItem
1599         insertNodeBefore(*newBlock, *listNode);
1600         removeNode(*emptyListItem);
1601     } else {
1602         // When emptyListItem does not follow any list item or nested list, insert newBlock after the enclosing list node.
1603         // Remove the enclosing node if emptyListItem is the only child; otherwise just remove emptyListItem.
1604         insertNodeAfter(*newBlock, *listNode);
1605         removeNode(isListItem(previousListNode.get()) || isListHTMLElement(previousListNode.get()) ? *emptyListItem : *listNode);
1606     }
1607 
1608     appendBlockPlaceholder(*newBlock);
1609     setEndingSelection(VisibleSelection(firstPositionInNode(newBlock.get()), DOWNSTREAM, endingSelection().isDirectional()));
1610 
1611     style-&gt;prepareToApplyAt(endingSelection().start());
1612     if (!style-&gt;isEmpty())
1613         applyStyle(style.ptr());
1614 
1615     return true;
1616 }
1617 
1618 // If the caret is in an empty quoted paragraph, and either there is nothing before that
1619 // paragraph, or what is before is unquoted, and the user presses delete, unquote that paragraph.
1620 bool CompositeEditCommand::breakOutOfEmptyMailBlockquotedParagraph()
1621 {
1622     if (!endingSelection().isCaret())
1623         return false;
1624 
1625     VisiblePosition caret(endingSelection().visibleStart());
1626     Node* highestBlockquote = highestEnclosingNodeOfType(caret.deepEquivalent(), &amp;isMailBlockquote);
1627     if (!highestBlockquote)
1628         return false;
1629 
1630     if (!isStartOfParagraph(caret) || !isEndOfParagraph(caret))
1631         return false;
1632 
1633     VisiblePosition previous(caret.previous(CannotCrossEditingBoundary));
1634     // Only move forward if there&#39;s nothing before the caret, or if there&#39;s unquoted content before it.
1635     if (enclosingNodeOfType(previous.deepEquivalent(), &amp;isMailBlockquote))
1636         return false;
1637 
1638     auto br = HTMLBRElement::create(document());
1639     auto* brPtr = br.ptr();
1640     // We want to replace this quoted paragraph with an unquoted one, so insert a br
1641     // to hold the caret before the highest blockquote.
1642     insertNodeBefore(WTFMove(br), *highestBlockquote);
1643     VisiblePosition atBR(positionBeforeNode(brPtr));
1644     // If the br we inserted collapsed, for example foo&lt;br&gt;&lt;blockquote&gt;...&lt;/blockquote&gt;, insert
1645     // a second one.
1646     if (!isStartOfParagraph(atBR))
1647         insertNodeBefore(HTMLBRElement::create(document()), *brPtr);
1648     setEndingSelection(VisibleSelection(atBR, endingSelection().isDirectional()));
1649 
1650     // If this is an empty paragraph there must be a line break here.
1651     if (!lineBreakExistsAtVisiblePosition(caret))
1652         return false;
1653 
1654     Position caretPos(caret.deepEquivalent().downstream());
1655     // A line break is either a br or a preserved newline.
1656     ASSERT(caretPos.deprecatedNode()-&gt;hasTagName(brTag) || (caretPos.deprecatedNode()-&gt;isTextNode() &amp;&amp; caretPos.deprecatedNode()-&gt;renderer()-&gt;style().preserveNewline()));
1657 
1658     if (caretPos.deprecatedNode()-&gt;hasTagName(brTag))
1659         removeNodeAndPruneAncestors(*caretPos.deprecatedNode());
1660     else if (is&lt;Text&gt;(*caretPos.deprecatedNode())) {
1661         ASSERT(caretPos.deprecatedEditingOffset() == 0);
1662         Text&amp; textNode = downcast&lt;Text&gt;(*caretPos.deprecatedNode());
1663         ContainerNode* parentNode = textNode.parentNode();
1664         // The preserved newline must be the first thing in the node, since otherwise the previous
1665         // paragraph would be quoted, and we verified that it wasn&#39;t above.
1666         deleteTextFromNode(textNode, 0, 1);
1667         prune(parentNode);
1668     }
1669 
1670     return true;
1671 }
1672 
1673 // Operations use this function to avoid inserting content into an anchor when at the start or the end of
1674 // that anchor, as in NSTextView.
1675 // FIXME: This is only an approximation of NSTextViews insertion behavior, which varies depending on how
1676 // the caret was made.
1677 Position CompositeEditCommand::positionAvoidingSpecialElementBoundary(const Position&amp; original)
1678 {
1679     if (original.isNull())
1680         return original;
1681 
1682     VisiblePosition visiblePos(original);
1683     Element* enclosingAnchor = enclosingAnchorElement(original);
1684     Position result = original;
1685 
1686     if (!enclosingAnchor)
1687         return result;
1688 
1689     // Don&#39;t avoid block level anchors, because that would insert content into the wrong paragraph.
1690     if (enclosingAnchor &amp;&amp; !isBlock(enclosingAnchor)) {
1691         VisiblePosition firstInAnchor(firstPositionInNode(enclosingAnchor));
1692         VisiblePosition lastInAnchor(lastPositionInNode(enclosingAnchor));
1693         // If visually just after the anchor, insert *inside* the anchor unless it&#39;s the last
1694         // VisiblePosition in the document, to match NSTextView.
1695         if (visiblePos == lastInAnchor) {
1696             // Make sure anchors are pushed down before avoiding them so that we don&#39;t
1697             // also avoid structural elements like lists and blocks (5142012).
1698             if (original.deprecatedNode() != enclosingAnchor &amp;&amp; original.deprecatedNode()-&gt;parentNode() != enclosingAnchor) {
1699                 pushAnchorElementDown(*enclosingAnchor);
1700                 enclosingAnchor = enclosingAnchorElement(original);
1701                 if (!enclosingAnchor)
1702                     return original;
1703             }
1704             // Don&#39;t insert outside an anchor if doing so would skip over a line break.  It would
1705             // probably be safe to move the line break so that we could still avoid the anchor here.
1706             Position downstream(visiblePos.deepEquivalent().downstream());
1707             if (lineBreakExistsAtVisiblePosition(visiblePos) &amp;&amp; downstream.deprecatedNode()-&gt;isDescendantOf(enclosingAnchor))
1708                 return original;
1709 
1710             result = positionInParentAfterNode(enclosingAnchor);
1711         }
1712         // If visually just before an anchor, insert *outside* the anchor unless it&#39;s the first
1713         // VisiblePosition in a paragraph, to match NSTextView.
1714         if (visiblePos == firstInAnchor) {
1715             // Make sure anchors are pushed down before avoiding them so that we don&#39;t
1716             // also avoid structural elements like lists and blocks (5142012).
1717             if (original.deprecatedNode() != enclosingAnchor &amp;&amp; original.deprecatedNode()-&gt;parentNode() != enclosingAnchor) {
1718                 pushAnchorElementDown(*enclosingAnchor);
1719                 enclosingAnchor = enclosingAnchorElement(original);
1720             }
1721             if (!enclosingAnchor)
1722                 return original;
1723 
1724             result = positionInParentBeforeNode(enclosingAnchor);
1725         }
1726     }
1727 
1728     if (result.isNull() || !editableRootForPosition(result))
1729         result = original;
1730 
1731     return result;
1732 }
1733 
1734 // Splits the tree parent by parent until we reach the specified ancestor. We use VisiblePositions
1735 // to determine if the split is necessary. Returns the last split node.
1736 RefPtr&lt;Node&gt; CompositeEditCommand::splitTreeToNode(Node&amp; start, Node&amp; end, bool shouldSplitAncestor)
1737 {
1738     ASSERT(&amp;start != &amp;end);
1739 
1740     RefPtr&lt;Node&gt; adjustedEnd = &amp;end;
1741     if (shouldSplitAncestor &amp;&amp; adjustedEnd-&gt;parentNode())
1742         adjustedEnd = adjustedEnd-&gt;parentNode();
1743 
1744     ASSERT(adjustedEnd);
1745     RefPtr&lt;Node&gt; node;
1746     for (node = &amp;start; node &amp;&amp; node-&gt;parentNode() != adjustedEnd; node = node-&gt;parentNode()) {
1747         if (!is&lt;Element&gt;(*node-&gt;parentNode()))
1748             break;
1749         // Do not split a node when doing so introduces an empty node.
1750         VisiblePosition positionInParent = firstPositionInNode(node-&gt;parentNode());
1751         VisiblePosition positionInNode = firstPositionInOrBeforeNode(node.get());
1752         if (positionInParent != positionInNode)
1753             splitElement(downcast&lt;Element&gt;(*node-&gt;parentNode()), *node);
1754     }
1755 
1756     return node;
1757 }
1758 
1759 Ref&lt;Element&gt; createBlockPlaceholderElement(Document&amp; document)
1760 {
1761     return HTMLBRElement::create(document);
1762 }
1763 
1764 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;ActivityStateChangeObserver.h&quot;
 31 #include &quot;ExceptionOr.h&quot;
 32 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 33 #include &quot;GraphicsContext3D.h&quot;</span>
 34 #include &quot;ImageBuffer.h&quot;
<a name="2" id="anc2"></a>
 35 #include &quot;Timer.h&quot;
 36 #include &quot;WebGLAny.h&quot;
 37 #include &quot;WebGLBuffer.h&quot;
 38 #include &quot;WebGLContextAttributes.h&quot;
 39 #include &quot;WebGLFramebuffer.h&quot;
 40 #include &quot;WebGLProgram.h&quot;
 41 #include &quot;WebGLRenderbuffer.h&quot;
 42 #include &quot;WebGLStateTracker.h&quot;
 43 #include &quot;WebGLTexture.h&quot;
 44 #include &quot;WebGLVertexArrayObjectOES.h&quot;
 45 #include &lt;JavaScriptCore/ConsoleTypes.h&gt;
 46 #include &lt;limits&gt;
 47 #include &lt;memory&gt;
 48 
 49 #if ENABLE(WEBGL2)
 50 #include &quot;WebGLVertexArrayObject.h&quot;
 51 #endif
 52 
 53 namespace WebCore {
 54 
 55 class ANGLEInstancedArrays;
 56 class EXTBlendMinMax;
 57 class EXTTextureFilterAnisotropic;
 58 class EXTShaderTextureLOD;
 59 class EXTsRGB;
 60 class EXTFragDepth;
 61 class HTMLImageElement;
 62 class ImageData;
 63 class IntSize;
 64 class OESStandardDerivatives;
 65 class OESTextureFloat;
 66 class OESTextureFloatLinear;
 67 class OESTextureHalfFloat;
 68 class OESTextureHalfFloatLinear;
 69 class OESVertexArrayObject;
 70 class OESElementIndexUint;
<a name="3" id="anc3"></a>
 71 class OffscreenCanvas;
<a name="4" id="anc4"></a>
 72 class WebGLActiveInfo;
 73 class WebGLContextGroup;
 74 class WebGLContextObject;
 75 class WebGLCompressedTextureASTC;
 76 class WebGLCompressedTextureATC;
<a name="5" id="anc5"></a>

 77 class WebGLCompressedTexturePVRTC;
 78 class WebGLCompressedTextureS3TC;
 79 class WebGLDebugRendererInfo;
 80 class WebGLDebugShaders;
 81 class WebGLDepthTexture;
 82 class WebGLDrawBuffers;
 83 class WebGLExtension;
 84 class WebGLLoseContext;
 85 class WebGLObject;
 86 class WebGLShader;
 87 class WebGLSharedObject;
 88 class WebGLShaderPrecisionFormat;
 89 class WebGLUniformLocation;
 90 
 91 #if ENABLE(VIDEO)
 92 class HTMLVideoElement;
 93 #endif
 94 
<a name="6" id="anc6"></a>
 95 using WebGLCanvas = WTF::Variant&lt;RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;OffscreenCanvas&gt;&gt;;
<a name="7" id="anc7"></a>


 96 
<a name="8" id="anc8"></a><span class="line-modified"> 97 class WebGLRenderingContextBase : public GraphicsContext3D::Client, public GPUBasedCanvasRenderingContext, private ActivityStateChangeObserver {</span>
 98     WTF_MAKE_ISO_ALLOCATED(WebGLRenderingContextBase);
 99 public:
100     static std::unique_ptr&lt;WebGLRenderingContextBase&gt; create(CanvasBase&amp;, WebGLContextAttributes&amp;, const String&amp;);
101     virtual ~WebGLRenderingContextBase();
102 
103     WebGLCanvas canvas();
104 
105     int drawingBufferWidth() const;
106     int drawingBufferHeight() const;
107 
<a name="9" id="anc9"></a><span class="line-modified">108     void activeTexture(GC3Denum texture);</span>
109     void attachShader(WebGLProgram*, WebGLShader*);
<a name="10" id="anc10"></a><span class="line-modified">110     void bindAttribLocation(WebGLProgram*, GC3Duint index, const String&amp; name);</span>
<span class="line-modified">111     void bindBuffer(GC3Denum target, WebGLBuffer*);</span>
<span class="line-modified">112     void bindFramebuffer(GC3Denum target, WebGLFramebuffer*);</span>
<span class="line-modified">113     void bindRenderbuffer(GC3Denum target, WebGLRenderbuffer*);</span>
<span class="line-modified">114     void bindTexture(GC3Denum target, WebGLTexture*);</span>
<span class="line-modified">115     void blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">116     void blendEquation(GC3Denum mode);</span>
<span class="line-modified">117     void blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha);</span>
<span class="line-modified">118     void blendFunc(GC3Denum sfactor, GC3Denum dfactor);</span>
<span class="line-modified">119     void blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha);</span>
120 
121     using BufferDataSource = WTF::Variant&lt;RefPtr&lt;ArrayBuffer&gt;, RefPtr&lt;ArrayBufferView&gt;&gt;;
<a name="11" id="anc11"></a><span class="line-modified">122     void bufferData(GC3Denum target, long long size, GC3Denum usage);</span>
<span class="line-modified">123     void bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp;, GC3Denum usage);</span>
<span class="line-modified">124     void bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp;);</span>
<span class="line-modified">125 </span>
<span class="line-modified">126     GC3Denum checkFramebufferStatus(GC3Denum target);</span>
<span class="line-modified">127     virtual void clear(GC3Dbitfield mask) = 0;</span>
<span class="line-modified">128     void clearColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha);</span>
<span class="line-modified">129     void clearDepth(GC3Dfloat);</span>
<span class="line-modified">130     void clearStencil(GC3Dint);</span>
<span class="line-modified">131     void colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha);</span>
132     void compileShader(WebGLShader*);
133 
<a name="12" id="anc12"></a><span class="line-modified">134     void compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data);</span>
<span class="line-modified">135     void compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data);</span>
136 
<a name="13" id="anc13"></a><span class="line-modified">137     void copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border);</span>
<span class="line-modified">138     void copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
139 
140     RefPtr&lt;WebGLBuffer&gt; createBuffer();
141     RefPtr&lt;WebGLFramebuffer&gt; createFramebuffer();
142     RefPtr&lt;WebGLProgram&gt; createProgram();
143     RefPtr&lt;WebGLRenderbuffer&gt; createRenderbuffer();
<a name="14" id="anc14"></a><span class="line-modified">144     RefPtr&lt;WebGLShader&gt; createShader(GC3Denum type);</span>
145     RefPtr&lt;WebGLTexture&gt; createTexture();
146 
<a name="15" id="anc15"></a><span class="line-modified">147     void cullFace(GC3Denum mode);</span>
148 
149     void deleteBuffer(WebGLBuffer*);
150     void deleteFramebuffer(WebGLFramebuffer*);
151     void deleteProgram(WebGLProgram*);
152     void deleteRenderbuffer(WebGLRenderbuffer*);
153     void deleteShader(WebGLShader*);
154     void deleteTexture(WebGLTexture*);
155 
<a name="16" id="anc16"></a><span class="line-modified">156     void depthFunc(GC3Denum);</span>
<span class="line-modified">157     void depthMask(GC3Dboolean);</span>
<span class="line-modified">158     void depthRange(GC3Dfloat zNear, GC3Dfloat zFar);</span>
159     void detachShader(WebGLProgram*, WebGLShader*);
<a name="17" id="anc17"></a><span class="line-modified">160     void disable(GC3Denum cap);</span>
<span class="line-modified">161     void disableVertexAttribArray(GC3Duint index);</span>
<span class="line-modified">162     void drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count);</span>
<span class="line-modified">163     void drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset);</span>
164 
<a name="18" id="anc18"></a><span class="line-modified">165     void enable(GC3Denum cap);</span>
<span class="line-modified">166     void enableVertexAttribArray(GC3Duint index);</span>
167     void finish();
168     void flush();
<a name="19" id="anc19"></a><span class="line-modified">169     void framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer*);</span>
<span class="line-modified">170     void framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture*, GC3Dint level);</span>
<span class="line-modified">171     void frontFace(GC3Denum mode);</span>
<span class="line-modified">172     void generateMipmap(GC3Denum target);</span>
173 
<a name="20" id="anc20"></a><span class="line-modified">174     RefPtr&lt;WebGLActiveInfo&gt; getActiveAttrib(WebGLProgram*, GC3Duint index);</span>
<span class="line-modified">175     RefPtr&lt;WebGLActiveInfo&gt; getActiveUniform(WebGLProgram*, GC3Duint index);</span>
176     Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; getAttachedShaders(WebGLProgram*);
<a name="21" id="anc21"></a><span class="line-modified">177     GC3Dint getAttribLocation(WebGLProgram*, const String&amp; name);</span>
<span class="line-modified">178     WebGLAny getBufferParameter(GC3Denum target, GC3Denum pname);</span>
179     Optional&lt;WebGLContextAttributes&gt; getContextAttributes();
<a name="22" id="anc22"></a><span class="line-modified">180     GC3Denum getError();</span>
181     virtual WebGLExtension* getExtension(const String&amp; name) = 0;
<a name="23" id="anc23"></a><span class="line-modified">182     virtual WebGLAny getFramebufferAttachmentParameter(GC3Denum target, GC3Denum attachment, GC3Denum pname) = 0;</span>
<span class="line-modified">183     virtual WebGLAny getParameter(GC3Denum pname) = 0;</span>
<span class="line-modified">184     WebGLAny getProgramParameter(WebGLProgram*, GC3Denum pname);</span>
185     String getProgramInfoLog(WebGLProgram*);
<a name="24" id="anc24"></a><span class="line-modified">186     WebGLAny getRenderbufferParameter(GC3Denum target, GC3Denum pname);</span>
<span class="line-modified">187     WebGLAny getShaderParameter(WebGLShader*, GC3Denum pname);</span>
188     String getShaderInfoLog(WebGLShader*);
<a name="25" id="anc25"></a><span class="line-modified">189     RefPtr&lt;WebGLShaderPrecisionFormat&gt; getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType);</span>
190     String getShaderSource(WebGLShader*);
191     virtual Optional&lt;Vector&lt;String&gt;&gt; getSupportedExtensions() = 0;
<a name="26" id="anc26"></a><span class="line-modified">192     WebGLAny getTexParameter(GC3Denum target, GC3Denum pname);</span>
193     WebGLAny getUniform(WebGLProgram*, const WebGLUniformLocation*);
194     RefPtr&lt;WebGLUniformLocation&gt; getUniformLocation(WebGLProgram*, const String&amp;);
<a name="27" id="anc27"></a><span class="line-modified">195     WebGLAny getVertexAttrib(GC3Duint index, GC3Denum pname);</span>
<span class="line-modified">196     long long getVertexAttribOffset(GC3Duint index, GC3Denum pname);</span>
197 
198     bool extensionIsEnabled(const String&amp;);
199 
200     bool isPreservingDrawingBuffer() const { return m_attributes.preserveDrawingBuffer; }
201     void setPreserveDrawingBuffer(bool value) { m_attributes.preserveDrawingBuffer = value; }
202 
203     bool preventBufferClearForInspector() const { return m_preventBufferClearForInspector; }
204     void setPreventBufferClearForInspector(bool value) { m_preventBufferClearForInspector = value; }
205 
<a name="28" id="anc28"></a><span class="line-modified">206     virtual void hint(GC3Denum target, GC3Denum mode) = 0;</span>
<span class="line-modified">207     GC3Dboolean isBuffer(WebGLBuffer*);</span>
208     bool isContextLost() const;
<a name="29" id="anc29"></a><span class="line-modified">209     GC3Dboolean isEnabled(GC3Denum cap);</span>
<span class="line-modified">210     GC3Dboolean isFramebuffer(WebGLFramebuffer*);</span>
<span class="line-modified">211     GC3Dboolean isProgram(WebGLProgram*);</span>
<span class="line-modified">212     GC3Dboolean isRenderbuffer(WebGLRenderbuffer*);</span>
<span class="line-modified">213     GC3Dboolean isShader(WebGLShader*);</span>
<span class="line-modified">214     GC3Dboolean isTexture(WebGLTexture*);</span>
<span class="line-modified">215 </span>
<span class="line-modified">216     void lineWidth(GC3Dfloat);</span>
217     void linkProgram(WebGLProgram*);
218     bool linkProgramWithoutInvalidatingAttribLocations(WebGLProgram*);
<a name="30" id="anc30"></a><span class="line-modified">219     void pixelStorei(GC3Denum pname, GC3Dint param);</span>
<span class="line-modified">220     void polygonOffset(GC3Dfloat factor, GC3Dfloat units);</span>
<span class="line-modified">221     void readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels);</span>
222     void releaseShaderCompiler();
<a name="31" id="anc31"></a><span class="line-modified">223     virtual void renderbufferStorage(GC3Denum target, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height) = 0;</span>
<span class="line-modified">224     void sampleCoverage(GC3Dfloat value, GC3Dboolean invert);</span>
<span class="line-modified">225     void scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
226     void shaderSource(WebGLShader*, const String&amp;);
<a name="32" id="anc32"></a><span class="line-modified">227     void stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">228     void stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask);</span>
<span class="line-modified">229     void stencilMask(GC3Duint);</span>
<span class="line-modified">230     void stencilMaskSeparate(GC3Denum face, GC3Duint mask);</span>
<span class="line-modified">231     void stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
<span class="line-modified">232     void stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass);</span>
233 
<a name="33" id="anc33"></a><span class="line-modified">234     void texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
235 
236 #if ENABLE(VIDEO)
237     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;, RefPtr&lt;HTMLVideoElement&gt;&gt;;
238 #else
239     using TexImageSource = WTF::Variant&lt;RefPtr&lt;ImageBitmap&gt;, RefPtr&lt;ImageData&gt;, RefPtr&lt;HTMLImageElement&gt;, RefPtr&lt;HTMLCanvasElement&gt;&gt;;
240 #endif
241 
<a name="34" id="anc34"></a><span class="line-modified">242     ExceptionOr&lt;void&gt; texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;);</span>
243 
<a name="35" id="anc35"></a><span class="line-modified">244     void texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param);</span>
<span class="line-modified">245     void texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param);</span>
246 
<a name="36" id="anc36"></a><span class="line-modified">247     void texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp;);</span>
<span class="line-modified">248     ExceptionOr&lt;void&gt; texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp;);</span>
249 
250     template &lt;class TypedArray, class DataType&gt;
251     class TypedList {
252     public:
253         using VariantType = Variant&lt;RefPtr&lt;TypedArray&gt;, Vector&lt;DataType&gt;&gt;;
254 
255         TypedList(VariantType&amp;&amp; variant)
256             : m_variant(WTFMove(variant))
257         {
258         }
259 
260         const DataType* data() const
261         {
262             return WTF::switchOn(m_variant,
263                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; const DataType* { return typedArray-&gt;data(); },
264                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; const DataType* { return vector.data(); }
265             );
266         }
267 
<a name="37" id="anc37"></a><span class="line-modified">268         GC3Dsizei length() const</span>
269         {
270             return WTF::switchOn(m_variant,
<a name="38" id="anc38"></a><span class="line-modified">271                 [] (const RefPtr&lt;TypedArray&gt;&amp; typedArray) -&gt; GC3Dsizei { return typedArray-&gt;length(); },</span>
<span class="line-modified">272                 [] (const Vector&lt;DataType&gt;&amp; vector) -&gt; GC3Dsizei { return vector.size(); }</span>
273             );
274         }
275 
276     private:
277         VariantType m_variant;
278     };
279 
280     using Float32List = TypedList&lt;Float32Array, float&gt;;
281     using Int32List = TypedList&lt;Int32Array, int&gt;;
282 
<a name="39" id="anc39"></a><span class="line-modified">283     void uniform1f(const WebGLUniformLocation*, GC3Dfloat x);</span>
<span class="line-modified">284     void uniform2f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">285     void uniform3f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">286     void uniform4f(const WebGLUniformLocation*, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
287 
<a name="40" id="anc40"></a><span class="line-modified">288     void uniform1i(const WebGLUniformLocation*, GC3Dint x);</span>
<span class="line-modified">289     void uniform2i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y);</span>
<span class="line-modified">290     void uniform3i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z);</span>
<span class="line-modified">291     void uniform4i(const WebGLUniformLocation*, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w);</span>
292 
293     void uniform1fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
294     void uniform2fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
295     void uniform3fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
296     void uniform4fv(const WebGLUniformLocation*, Float32List&amp;&amp;);
297 
298     void uniform1iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
299     void uniform2iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
300     void uniform3iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
301     void uniform4iv(const WebGLUniformLocation*, Int32List&amp;&amp;);
302 
<a name="41" id="anc41"></a><span class="line-modified">303     void uniformMatrix2fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">304     void uniformMatrix3fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
<span class="line-modified">305     void uniformMatrix4fv(const WebGLUniformLocation*, GC3Dboolean transpose, Float32List&amp;&amp;);</span>
306 
307     void useProgram(WebGLProgram*);
308     void validateProgram(WebGLProgram*);
309 
<a name="42" id="anc42"></a><span class="line-modified">310     void vertexAttrib1f(GC3Duint index, GC3Dfloat x);</span>
<span class="line-modified">311     void vertexAttrib2f(GC3Duint index, GC3Dfloat x, GC3Dfloat y);</span>
<span class="line-modified">312     void vertexAttrib3f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z);</span>
<span class="line-modified">313     void vertexAttrib4f(GC3Duint index, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w);</span>
314 
<a name="43" id="anc43"></a><span class="line-modified">315     void vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">316     void vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">317     void vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp;);</span>
<span class="line-modified">318     void vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp;);</span>
319 
<a name="44" id="anc44"></a><span class="line-modified">320     void vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized,</span>
<span class="line-modified">321         GC3Dsizei stride, long long offset);</span>
322 
<a name="45" id="anc45"></a><span class="line-modified">323     void viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height);</span>
324 
325     // WEBKIT_lose_context support
326     enum LostContextMode {
327         // Lost context occurred at the graphics system level.
328         RealLostContext,
329 
330         // Lost context provoked by WEBKIT_lose_context.
331         SyntheticLostContext
332     };
333     void forceLostContext(LostContextMode);
334     void forceRestoreContext();
335     void loseContextImpl(LostContextMode);
336     WEBCORE_EXPORT void simulateContextChanged();
337 
<a name="46" id="anc46"></a><span class="line-modified">338     GraphicsContext3D* graphicsContext3D() const { return m_context.get(); }</span>
339     WebGLContextGroup* contextGroup() const { return m_contextGroup.get(); }
340     PlatformLayer* platformLayer() const override;
341 
342     void reshape(int width, int height) override;
343 
344     void markLayerComposited() final;
345     void paintRenderingResultsToCanvas() override;
346     RefPtr&lt;ImageData&gt; paintRenderingResultsToImageData();
347 
348     void removeSharedObject(WebGLSharedObject&amp;);
349     void removeContextObject(WebGLContextObject&amp;);
350 
351     unsigned getMaxVertexAttribs() const { return m_maxVertexAttribs; }
352 
353     // Instanced Array helper functions.
<a name="47" id="anc47"></a><span class="line-modified">354     void drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">355     void drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount);</span>
<span class="line-modified">356     void vertexAttribDivisor(GC3Duint index, GC3Duint divisor);</span>
357 
358     // Used for testing only, from Internals.
359     WEBCORE_EXPORT void setFailNextGPUStatusCheck();
360 
<a name="48" id="anc48"></a><span class="line-modified">361     // GraphicsContext3D::Client</span>
362     void didComposite() override;
363     void forceContextLost() override;
364     void recycleContext() override;
365     void dispatchContextChangedNotification() override;
366 
<a name="49" id="anc49"></a>


367 protected:
368     WebGLRenderingContextBase(CanvasBase&amp;, WebGLContextAttributes);
<a name="50" id="anc50"></a><span class="line-modified">369     WebGLRenderingContextBase(CanvasBase&amp;, Ref&lt;GraphicsContext3D&gt;&amp;&amp;, WebGLContextAttributes);</span>
370 
371     friend class WebGLDrawBuffers;
372     friend class WebGLFramebuffer;
373     friend class WebGLObject;
374     friend class OESVertexArrayObject;
375     friend class WebGLDebugShaders;
376     friend class WebGLCompressedTextureASTC;
377     friend class WebGLCompressedTextureATC;
<a name="51" id="anc51"></a>

378     friend class WebGLCompressedTexturePVRTC;
379     friend class WebGLCompressedTextureS3TC;
380     friend class WebGLRenderingContextErrorMessageCallback;
381     friend class WebGLVertexArrayObjectOES;
382     friend class WebGLVertexArrayObject;
383     friend class WebGLVertexArrayObjectBase;
384 
385     virtual void initializeNewContext();
386     virtual void initializeVertexArrayObjects() = 0;
387     void setupFlags();
388 
389     // ActiveDOMObject
<a name="52" id="anc52"></a><span class="line-removed">390     bool hasPendingActivity() const override;</span>
391     void stop() override;
392     const char* activeDOMObjectName() const override;
<a name="53" id="anc53"></a><span class="line-modified">393     bool canSuspendForDocumentSuspension() const override;</span>

394 
395     void addSharedObject(WebGLSharedObject&amp;);
396     void addContextObject(WebGLContextObject&amp;);
397     void detachAndRemoveAllObjects();
398 
<a name="54" id="anc54"></a><span class="line-modified">399     void destroyGraphicsContext3D();</span>
400     void markContextChanged();
401     void markContextChangedAndNotifyCanvasObserver();
402 
403     void addActivityStateChangeObserverIfNecessary();
404     void removeActivityStateChangeObserver();
405 
406     // Query whether it is built on top of compliant GLES2 implementation.
407     bool isGLES2Compliant() { return m_isGLES2Compliant; }
408     // Query if the GL implementation is NPOT strict.
409     bool isGLES2NPOTStrict() { return m_isGLES2NPOTStrict; }
410     // Query if depth_stencil buffer is supported.
411     bool isDepthStencilSupported() { return m_isDepthStencilSupported; }
412 
413     // Helper to return the size in bytes of OpenGL data types
414     // like GL_FLOAT, GL_INT, etc.
<a name="55" id="anc55"></a><span class="line-modified">415     unsigned int sizeInBytes(GC3Denum type);</span>
416 
417     // Basic validation of count and offset against number of elements in element array buffer
<a name="56" id="anc56"></a><span class="line-modified">418     bool validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset);</span>
419 
420     // Conservative but quick index validation
<a name="57" id="anc57"></a><span class="line-modified">421     virtual bool validateIndexArrayConservative(GC3Denum type, unsigned&amp; numElementsRequired) = 0;</span>
422 
423     // Precise but slow index validation -- only done if conservative checks fail
<a name="58" id="anc58"></a><span class="line-modified">424     bool validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired);</span>
425     bool validateVertexAttributes(unsigned elementCount, unsigned primitiveCount = 0);
426 
427     bool validateWebGLObject(const char*, WebGLObject*);
428 
<a name="59" id="anc59"></a><span class="line-modified">429     bool validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount);</span>
<span class="line-modified">430     bool validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primcount);</span>
<span class="line-modified">431     bool validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName);</span>
432 
433     // Adds a compressed texture format.
<a name="60" id="anc60"></a><span class="line-modified">434     void addCompressedTextureFormat(GC3Denum);</span>
435 
436     RefPtr&lt;Image&gt; drawImageIntoBuffer(Image&amp;, int width, int height, int deviceScaleFactor);
437 
438 #if ENABLE(VIDEO)
439     RefPtr&lt;Image&gt; videoFrameToImage(HTMLVideoElement*, BackingStoreCopy);
440 #endif
441 
442     WebGLTexture::TextureExtensionFlag textureExtensionFlags() const;
443 
444     bool enableSupportedExtension(ASCIILiteral extensionNameLiteral);
445 
<a name="61" id="anc61"></a><span class="line-modified">446     RefPtr&lt;GraphicsContext3D&gt; m_context;</span>


447     RefPtr&lt;WebGLContextGroup&gt; m_contextGroup;
448 
449     // Dispatches a context lost event once it is determined that one is needed.
450     // This is used both for synthetic and real context losses. For real ones, it&#39;s
451     // likely that there&#39;s no JavaScript on the stack, but that might be dependent
452     // on how exactly the platform discovers that the context was lost. For better
453     // portability we always defer the dispatch of the event.
<a name="62" id="anc62"></a><span class="line-modified">454     Timer m_dispatchContextLostEventTimer;</span>

455     bool m_restoreAllowed { false };
<a name="63" id="anc63"></a><span class="line-modified">456     Timer m_restoreTimer;</span>
457 
458     bool m_needsUpdate;
459     bool m_markedCanvasDirty;
460     HashSet&lt;WebGLContextObject*&gt; m_contextObjects;
461 
462     // List of bound VBO&#39;s. Used to maintain info about sizes for ARRAY_BUFFER and stored values for ELEMENT_ARRAY_BUFFER
463     RefPtr&lt;WebGLBuffer&gt; m_boundArrayBuffer;
464     RefPtr&lt;WebGLBuffer&gt; m_boundCopyReadBuffer;
465     RefPtr&lt;WebGLBuffer&gt; m_boundCopyWriteBuffer;
466     RefPtr&lt;WebGLBuffer&gt; m_boundPixelPackBuffer;
467     RefPtr&lt;WebGLBuffer&gt; m_boundPixelUnpackBuffer;
468     RefPtr&lt;WebGLBuffer&gt; m_boundTransformFeedbackBuffer;
469     RefPtr&lt;WebGLBuffer&gt; m_boundUniformBuffer;
470 
471     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_defaultVertexArrayObject;
472     RefPtr&lt;WebGLVertexArrayObjectBase&gt; m_boundVertexArrayObject;
473 
474     void setBoundVertexArrayObject(WebGLVertexArrayObjectBase* arrayObject)
475     {
476         m_boundVertexArrayObject = arrayObject ? arrayObject : m_defaultVertexArrayObject;
477     }
478 
479     class VertexAttribValue {
480     public:
481         VertexAttribValue()
482         {
483             initValue();
484         }
485 
486         void initValue()
487         {
488             value[0] = 0.0f;
489             value[1] = 0.0f;
490             value[2] = 0.0f;
491             value[3] = 1.0f;
492         }
493 
<a name="64" id="anc64"></a><span class="line-modified">494         GC3Dfloat value[4];</span>
495     };
496     Vector&lt;VertexAttribValue&gt; m_vertexAttribValue;
497     unsigned m_maxVertexAttribs;
498     RefPtr&lt;WebGLBuffer&gt; m_vertexAttrib0Buffer;
499     long m_vertexAttrib0BufferSize { 0 };
<a name="65" id="anc65"></a><span class="line-modified">500     GC3Dfloat m_vertexAttrib0BufferValue[4];</span>
501     bool m_forceAttrib0BufferRefill { true };
502     bool m_vertexAttrib0UsedBefore { false };
503 
504     RefPtr&lt;WebGLProgram&gt; m_currentProgram;
505     RefPtr&lt;WebGLFramebuffer&gt; m_framebufferBinding;
506     RefPtr&lt;WebGLFramebuffer&gt; m_readFramebufferBinding;
507     RefPtr&lt;WebGLRenderbuffer&gt; m_renderbufferBinding;
508     struct TextureUnitState {
509         RefPtr&lt;WebGLTexture&gt; texture2DBinding;
510         RefPtr&lt;WebGLTexture&gt; textureCubeMapBinding;
511     };
512     Vector&lt;TextureUnitState&gt; m_textureUnits;
513     HashSet&lt;unsigned, DefaultHash&lt;unsigned&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;unsigned&gt;&gt; m_unrenderableTextureUnits;
514 
515     unsigned long m_activeTextureUnit;
516 
517     RefPtr&lt;WebGLTexture&gt; m_blackTexture2D;
518     RefPtr&lt;WebGLTexture&gt; m_blackTextureCubeMap;
519 
<a name="66" id="anc66"></a><span class="line-modified">520     Vector&lt;GC3Denum&gt; m_compressedTextureFormats;</span>
521 
522     // Fixed-size cache of reusable image buffers for video texImage2D calls.
523     class LRUImageBufferCache {
524     public:
525         LRUImageBufferCache(int capacity);
526         // The pointer returned is owned by the image buffer map.
527         ImageBuffer* imageBuffer(const IntSize&amp; size);
528     private:
529         void bubbleToFront(size_t idx);
530         Vector&lt;std::unique_ptr&lt;ImageBuffer&gt;&gt; m_buffers;
531     };
532     LRUImageBufferCache m_generatedImageCache { 0 };
533 
<a name="67" id="anc67"></a><span class="line-modified">534     GC3Dint m_maxTextureSize;</span>
<span class="line-modified">535     GC3Dint m_maxCubeMapTextureSize;</span>
<span class="line-modified">536     GC3Dint m_maxRenderbufferSize;</span>
<span class="line-modified">537     GC3Dint m_maxViewportDims[2] { 0, 0 };</span>
<span class="line-modified">538     GC3Dint m_maxTextureLevel;</span>
<span class="line-modified">539     GC3Dint m_maxCubeMapTextureLevel;</span>
540 
<a name="68" id="anc68"></a><span class="line-modified">541     GC3Dint m_maxDrawBuffers;</span>
<span class="line-modified">542     GC3Dint m_maxColorAttachments;</span>
<span class="line-modified">543     GC3Denum m_backDrawBuffer;</span>
544     bool m_drawBuffersWebGLRequirementsChecked;
545     bool m_drawBuffersSupported;
546 
<a name="69" id="anc69"></a><span class="line-modified">547     GC3Dint m_packAlignment;</span>
<span class="line-modified">548     GC3Dint m_unpackAlignment;</span>
549     bool m_unpackFlipY;
550     bool m_unpackPremultiplyAlpha;
<a name="70" id="anc70"></a><span class="line-modified">551     GC3Denum m_unpackColorspaceConversion;</span>
552     bool m_contextLost { false };
553     LostContextMode m_contextLostMode { SyntheticLostContext };
554     WebGLContextAttributes m_attributes;
555 
556     bool m_layerCleared;
<a name="71" id="anc71"></a><span class="line-modified">557     GC3Dfloat m_clearColor[4];</span>
558     bool m_scissorEnabled;
<a name="72" id="anc72"></a><span class="line-modified">559     GC3Dfloat m_clearDepth;</span>
<span class="line-modified">560     GC3Dint m_clearStencil;</span>
<span class="line-modified">561     GC3Dboolean m_colorMask[4];</span>
<span class="line-modified">562     GC3Dboolean m_depthMask;</span>
563 
564     bool m_stencilEnabled;
<a name="73" id="anc73"></a><span class="line-modified">565     GC3Duint m_stencilMask, m_stencilMaskBack;</span>
<span class="line-modified">566     GC3Dint m_stencilFuncRef, m_stencilFuncRefBack; // Note that these are the user specified values, not the internal clamped value.</span>
<span class="line-modified">567     GC3Duint m_stencilFuncMask, m_stencilFuncMaskBack;</span>
568 
569     bool m_isGLES2Compliant;
570     bool m_isGLES2NPOTStrict;
571     bool m_isDepthStencilSupported;
572     bool m_isRobustnessEXTSupported;
573 
574     bool m_synthesizedErrorsToConsole { true };
575     int m_numGLErrorsToConsoleAllowed;
576 
577     bool m_preventBufferClearForInspector { false };
578 
579     // A WebGLRenderingContext can be created in a state where it appears as
580     // a valid and active context, but will not execute any important operations
581     // until its load policy is completely resolved.
582     bool m_isPendingPolicyResolution { false };
583     bool m_hasRequestedPolicyResolution { false };
584     bool isContextLostOrPending();
585 
586     // Enabled extension objects.
587     // FIXME: Move some of these to WebGLRenderingContext, the ones not needed for WebGL2
588     std::unique_ptr&lt;EXTFragDepth&gt; m_extFragDepth;
589     std::unique_ptr&lt;EXTBlendMinMax&gt; m_extBlendMinMax;
590     std::unique_ptr&lt;EXTsRGB&gt; m_extsRGB;
591     std::unique_ptr&lt;EXTTextureFilterAnisotropic&gt; m_extTextureFilterAnisotropic;
592     std::unique_ptr&lt;EXTShaderTextureLOD&gt; m_extShaderTextureLOD;
593     std::unique_ptr&lt;OESTextureFloat&gt; m_oesTextureFloat;
594     std::unique_ptr&lt;OESTextureFloatLinear&gt; m_oesTextureFloatLinear;
595     std::unique_ptr&lt;OESTextureHalfFloat&gt; m_oesTextureHalfFloat;
596     std::unique_ptr&lt;OESTextureHalfFloatLinear&gt; m_oesTextureHalfFloatLinear;
597     std::unique_ptr&lt;OESStandardDerivatives&gt; m_oesStandardDerivatives;
598     std::unique_ptr&lt;OESVertexArrayObject&gt; m_oesVertexArrayObject;
599     std::unique_ptr&lt;OESElementIndexUint&gt; m_oesElementIndexUint;
600     std::unique_ptr&lt;WebGLLoseContext&gt; m_webglLoseContext;
601     std::unique_ptr&lt;WebGLDebugRendererInfo&gt; m_webglDebugRendererInfo;
602     std::unique_ptr&lt;WebGLDebugShaders&gt; m_webglDebugShaders;
603     std::unique_ptr&lt;WebGLCompressedTextureASTC&gt; m_webglCompressedTextureASTC;
604     std::unique_ptr&lt;WebGLCompressedTextureATC&gt; m_webglCompressedTextureATC;
<a name="74" id="anc74"></a>

605     std::unique_ptr&lt;WebGLCompressedTexturePVRTC&gt; m_webglCompressedTexturePVRTC;
606     std::unique_ptr&lt;WebGLCompressedTextureS3TC&gt; m_webglCompressedTextureS3TC;
607     std::unique_ptr&lt;WebGLDepthTexture&gt; m_webglDepthTexture;
608     std::unique_ptr&lt;WebGLDrawBuffers&gt; m_webglDrawBuffers;
609     std::unique_ptr&lt;ANGLEInstancedArrays&gt; m_angleInstancedArrays;
610 
611     // Helpers for getParameter and other similar functions.
<a name="75" id="anc75"></a><span class="line-modified">612     bool getBooleanParameter(GC3Denum);</span>
<span class="line-modified">613     Vector&lt;bool&gt; getBooleanArrayParameter(GC3Denum);</span>
<span class="line-modified">614     float getFloatParameter(GC3Denum);</span>
<span class="line-modified">615     int getIntParameter(GC3Denum);</span>
<span class="line-modified">616     unsigned getUnsignedIntParameter(GC3Denum);</span>
<span class="line-modified">617     long long getInt64Parameter(GC3Denum);</span>
<span class="line-modified">618     RefPtr&lt;Float32Array&gt; getWebGLFloatArrayParameter(GC3Denum);</span>
<span class="line-modified">619     RefPtr&lt;Int32Array&gt; getWebGLIntArrayParameter(GC3Denum);</span>
620 
621     // Clear the backbuffer if it was composited since the last operation.
622     // clearMask is set to the bitfield of any clear that would happen anyway at this time
623     // and the function returns true if that clear is now unnecessary.
<a name="76" id="anc76"></a><span class="line-modified">624     bool clearIfComposited(GC3Dbitfield clearMask = 0);</span>
625 
626     // Helper to restore state that clearing the framebuffer may destroy.
627     void restoreStateAfterClear();
628 
<a name="77" id="anc77"></a><span class="line-modified">629     void texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">630     void texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
<span class="line-modified">631     void texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalformat, GC3Denum format, GC3Denum type, const void* pixels);</span>
<span class="line-modified">632     void texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image*, GraphicsContext3D::ImageHtmlDomSource, bool flipY, bool premultiplyAlpha);</span>
633 
634     bool checkTextureCompleteness(const char*, bool);
635 
636     void createFallbackBlackTextures1x1();
637 
638     // Helper function for copyTex{Sub}Image, check whether the internalformat
639     // and the color buffer format of the current bound framebuffer combination
640     // is valid.
<a name="78" id="anc78"></a><span class="line-modified">641     bool isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,</span>
<span class="line-removed">642                                                         GC3Denum colorBufferFormat);</span>
643 
644     // Helper function to get the bound framebuffer&#39;s color buffer format.
<a name="79" id="anc79"></a><span class="line-modified">645     GC3Denum getBoundFramebufferColorFormat();</span>
646 
647     // Helper function to get the bound framebuffer&#39;s width.
648     int getBoundFramebufferWidth();
649 
650     // Helper function to get the bound framebuffer&#39;s height.
651     int getBoundFramebufferHeight();
652 
653     // Helper function to verify limits on the length of uniform and attribute locations.
654     bool validateLocationLength(const char* functionName, const String&amp;);
655 
656     // Helper function to check if size is non-negative.
657     // Generate GL error and return false for negative inputs; otherwise, return true.
<a name="80" id="anc80"></a><span class="line-modified">658     bool validateSize(const char* functionName, GC3Dint x, GC3Dint y);</span>
659 
660     // Helper function to check if all characters in the string belong to the
661     // ASCII subset as defined in GLSL ES 1.0 spec section 3.1.
662     bool validateString(const char* functionName, const String&amp;);
663 
664     // Helper function to check target and texture bound to the target.
665     // Generate GL errors and return 0 if target is invalid or texture bound is
666     // null.  Otherwise, return the texture bound to the target.
<a name="81" id="anc81"></a><span class="line-modified">667     RefPtr&lt;WebGLTexture&gt; validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap);</span>
668 
669     // Helper function to check input format/type for functions {copy}Tex{Sub}Image.
670     // Generates GL error and returns false if parameters are invalid.
<a name="82" id="anc82"></a><span class="line-modified">671     bool validateTexFuncFormatAndType(const char* functionName, GC3Denum internalformat, GC3Denum format, GC3Denum type, GC3Dint level);</span>
672 
673     // Helper function to check input level for functions {copy}Tex{Sub}Image.
674     // Generates GL error and returns false if level is invalid.
<a name="83" id="anc83"></a><span class="line-modified">675     bool validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level);</span>
676 
677     enum TexFuncValidationFunctionType {
678         TexImage,
679         TexSubImage,
680         CopyTexImage
681     };
682 
683     enum TexFuncValidationSourceType {
684         SourceArrayBufferView,
685         SourceImageBitmap,
686         SourceImageData,
687         SourceHTMLImageElement,
688         SourceHTMLCanvasElement,
689 #if ENABLE(VIDEO)
690         SourceHTMLVideoElement,
691 #endif
692     };
693 
694     // Helper function for tex{Sub}Image2D to check if the input format/type/level/target/width/height/border/xoffset/yoffset are valid.
695     // Otherwise, it would return quickly without doing other work.
<a name="84" id="anc84"></a><span class="line-modified">696     bool validateTexFunc(const char* functionName, TexFuncValidationFunctionType, TexFuncValidationSourceType, GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width,</span>
<span class="line-modified">697         GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset);</span>
698 
699     // Helper function to check input parameters for functions {copy}Tex{Sub}Image.
700     // Generates GL error and returns false if parameters are invalid.
701     bool validateTexFuncParameters(const char* functionName,
702         TexFuncValidationFunctionType,
<a name="85" id="anc85"></a><span class="line-modified">703         GC3Denum target, GC3Dint level,</span>
<span class="line-modified">704         GC3Denum internalformat,</span>
<span class="line-modified">705         GC3Dsizei width, GC3Dsizei height, GC3Dint border,</span>
<span class="line-modified">706         GC3Denum format, GC3Denum type);</span>
707 
708     enum NullDisposition {
709         NullAllowed,
710         NullNotAllowed
711     };
712 
713     // Helper function to validate that the given ArrayBufferView
714     // is of the correct type and contains enough data for the texImage call.
715     // Generates GL error and returns false if parameters are invalid.
<a name="86" id="anc86"></a><span class="line-modified">716     bool validateTexFuncData(const char* functionName, GC3Dint level,</span>
<span class="line-modified">717         GC3Dsizei width, GC3Dsizei height,</span>
<span class="line-modified">718         GC3Denum internalformat, GC3Denum format, GC3Denum type,</span>
719         ArrayBufferView* pixels,
720         NullDisposition);
721 
722     // Helper function to validate a given texture format is settable as in
723     // you can supply data to texImage2D, or call texImage2D, copyTexImage2D and
724     // copyTexSubImage2D.
725     // Generates GL error and returns false if the format is not settable.
<a name="87" id="anc87"></a><span class="line-modified">726     bool validateSettableTexInternalFormat(const char* functionName, GC3Denum format);</span>
727 
728     // Helper function to validate compressed texture data is correct size
729     // for the given format and dimensions.
<a name="88" id="anc88"></a><span class="line-modified">730     bool validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels);</span>
731 
732     // Helper function for validating compressed texture formats.
<a name="89" id="anc89"></a><span class="line-modified">733     bool validateCompressedTexFormat(GC3Denum format);</span>
734 
735     // Helper function to validate compressed texture dimensions are valid for
736     // the given format.
<a name="90" id="anc90"></a><span class="line-modified">737     bool validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format);</span>
738 
739     // Helper function to validate compressed texture dimensions are valid for
740     // the given format.
<a name="91" id="anc91"></a><span class="line-modified">741     bool validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,</span>
<span class="line-modified">742                                             GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture*);</span>
743 
744     // Helper function to validate mode for draw{Arrays/Elements}.
<a name="92" id="anc92"></a><span class="line-modified">745     bool validateDrawMode(const char* functionName, GC3Denum);</span>
746 
747     // Helper function to validate if front/back stencilMask and stencilFunc settings are the same.
748     bool validateStencilSettings(const char* functionName);
749 
750     // Helper function to validate stencil func.
<a name="93" id="anc93"></a><span class="line-modified">751     bool validateStencilFunc(const char* functionName, GC3Denum);</span>
752 
753     // Helper function for texParameterf and texParameteri.
<a name="94" id="anc94"></a><span class="line-modified">754     void texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat parami, GC3Dint paramf, bool isFloat);</span>
755 
756     // Helper function to print errors and warnings to console.
757     void printToConsole(MessageLevel, const String&amp;);
758 
759     // Helper function to validate input parameters for framebuffer functions.
760     // Generate GL error if parameters are illegal.
<a name="95" id="anc95"></a><span class="line-modified">761     virtual bool validateFramebufferFuncParameters(const char* functionName, GC3Denum target, GC3Denum attachment) = 0;</span>
762 
763     // Helper function to validate blend equation mode.
<a name="96" id="anc96"></a><span class="line-modified">764     virtual bool validateBlendEquation(const char* functionName, GC3Denum) = 0;</span>
765 
766     // Helper function to validate blend func factors.
<a name="97" id="anc97"></a><span class="line-modified">767     bool validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst);</span>
768 
769     // Helper function to validate a GL capability.
<a name="98" id="anc98"></a><span class="line-modified">770     virtual bool validateCapability(const char* functionName, GC3Denum) = 0;</span>
771 
772     // Helper function to validate input parameters for uniform functions.
<a name="99" id="anc99"></a><span class="line-modified">773     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">774     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, const Int32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">775     bool validateUniformParameters(const char* functionName, const WebGLUniformLocation*, void*, GC3Dsizei, GC3Dsizei mod);</span>
<span class="line-modified">776     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const Float32List&amp;, GC3Dsizei mod);</span>
<span class="line-modified">777     bool validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation*, GC3Dboolean transpose, const void*, GC3Dsizei, GC3Dsizei mod);</span>
778 
779     // Helper function to validate parameters for bufferData.
780     // Return the current bound buffer to target, or 0 if parameters are invalid.
<a name="100" id="anc100"></a><span class="line-modified">781     WebGLBuffer* validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage);</span>
782 
783     // Helper function for tex{Sub}Image2D to make sure image is ready.
784     ExceptionOr&lt;bool&gt; validateHTMLImageElement(const char* functionName, HTMLImageElement*);
785     ExceptionOr&lt;bool&gt; validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement*);
786 #if ENABLE(VIDEO)
787     ExceptionOr&lt;bool&gt; validateHTMLVideoElement(const char* functionName, HTMLVideoElement*);
788 #endif
789 
790     // Helper functions for vertexAttribNf{v}.
<a name="101" id="anc101"></a><span class="line-modified">791     void vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat, GC3Dfloat, GC3Dfloat, GC3Dfloat);</span>
<span class="line-modified">792     void vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp;, GC3Dsizei expectedSize);</span>
793 
794     // Helper function for delete* (deleteBuffer, deleteProgram, etc) functions.
795     // Return false if caller should return without further processing.
796     bool deleteObject(WebGLObject*);
797 
798     // Helper function for bind* (bindBuffer, bindTexture, etc) and useProgram.
799     // If the object has already been deleted, set deleted to true upon return.
800     // Return false if caller should return without further processing.
801     bool checkObjectToBeBound(const char* functionName, WebGLObject*, bool&amp; deleted);
802 
<a name="102" id="anc102"></a>

803     // Helpers for simulating vertexAttrib0.
804     void initVertexAttrib0();
<a name="103" id="anc103"></a><span class="line-modified">805     Optional&lt;bool&gt; simulateVertexAttrib0(GC3Duint numVertex);</span>
<span class="line-modified">806     bool validateSimulatedVertexAttrib0(GC3Duint numVertex);</span>
807     void restoreStatesAfterVertexAttrib0Simulation();
808 
<a name="104" id="anc104"></a><span class="line-modified">809     void dispatchContextLostEvent();</span>
<span class="line-removed">810     // Helper for restoration after context lost.</span>
<span class="line-removed">811     void maybeRestoreContext();</span>
<span class="line-removed">812 </span>
<span class="line-removed">813     // Wrapper for GraphicsContext3D::synthesizeGLError that sends a message to the JavaScript console.</span>
814     enum ConsoleDisplayPreference { DisplayInConsole, DontDisplayInConsole };
<a name="105" id="anc105"></a><span class="line-modified">815     void synthesizeGLError(GC3Denum, const char* functionName, const char* description, ConsoleDisplayPreference = DisplayInConsole);</span>
816 
817     String ensureNotNull(const String&amp;) const;
818 
819     // Enable or disable stencil test based on user setting and whether the current FBO has a stencil buffer.
820     void applyStencilTest();
821 
822     // Helper for enabling or disabling a capability.
<a name="106" id="anc106"></a><span class="line-modified">823     void enableOrDisable(GC3Denum capability, bool enable);</span>
824 
825     // Clamp the width and height to GL_MAX_VIEWPORT_DIMS.
826     IntSize clampedCanvasSize();
827 
<a name="107" id="anc107"></a><span class="line-modified">828     virtual GC3Dint getMaxDrawBuffers() = 0;</span>
<span class="line-modified">829     virtual GC3Dint getMaxColorAttachments() = 0;</span>
830 
<a name="108" id="anc108"></a><span class="line-modified">831     void setBackDrawBuffer(GC3Denum);</span>
832 
833     void restoreCurrentFramebuffer();
834     void restoreCurrentTexture2D();
835 
836     // Check if EXT_draw_buffers extension is supported and if it satisfies the WebGL requirements.
837     bool supportsDrawBuffers();
838 
<a name="109" id="anc109"></a>
839     OffscreenCanvas* offscreenCanvas();
<a name="110" id="anc110"></a>
840 
841     template &lt;typename T&gt; inline Optional&lt;T&gt; checkedAddAndMultiply(T value, T add, T multiply);
<a name="111" id="anc111"></a><span class="line-modified">842     template &lt;typename T&gt; unsigned getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n);</span>
843 
844 private:
<a name="112" id="anc112"></a><span class="line-modified">845     bool validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt;);</span>





846     void registerWithWebGLStateTracker();
847     void checkForContextLossHandling();
848 
849     void activityStateDidChange(OptionSet&lt;ActivityState::Flag&gt; oldActivityState, OptionSet&lt;ActivityState::Flag&gt; newActivityState) override;
850 
851     WebGLStateTracker::Token m_trackerToken;
852     Timer m_checkForContextLossHandlingTimer;
<a name="113" id="anc113"></a>
853 };
854 
855 template &lt;typename T&gt;
856 inline Optional&lt;T&gt; WebGLRenderingContextBase::checkedAddAndMultiply(T value, T add, T multiply)
857 {
858     Checked&lt;T, RecordOverflow&gt; checkedResult = Checked&lt;T&gt;(value);
859     checkedResult += Checked&lt;T&gt;(add);
860     checkedResult *= Checked&lt;T&gt;(multiply);
861     if (checkedResult.hasOverflowed())
862         return WTF::nullopt;
863 
864     return checkedResult.unsafeGet();
865 }
866 
867 template&lt;typename T&gt;
<a name="114" id="anc114"></a><span class="line-modified">868 inline unsigned WebGLRenderingContextBase::getMaxIndex(const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer, GC3Dintptr uoffset, GC3Dsizei n)</span>
869 {
870     unsigned maxIndex = 0;
871     T restartIndex = 0;
872 
873 #if ENABLE(WEBGL2)
874     // WebGL 2 spec enforces that GL_PRIMITIVE_RESTART_FIXED_INDEX is always enabled, so ignore the restart index.
875     if (isWebGL2())
876         restartIndex = std::numeric_limits&lt;T&gt;::max();
877 #endif
878 
879     // Make uoffset an element offset.
880     uoffset /= sizeof(T);
881     const T* p = static_cast&lt;const T*&gt;(elementArrayBuffer-&gt;data()) + uoffset;
882     while (n-- &gt; 0) {
883         if (*p != restartIndex &amp;&amp; *p &gt; maxIndex)
884             maxIndex = *p;
885         ++p;
886     }
887 
888     return maxIndex;
889 }
890 
891 } // namespace WebCore
892 
893 SPECIALIZE_TYPE_TRAITS_CANVASRENDERINGCONTEXT(WebCore::WebGLRenderingContextBase, isWebGL())
894 
895 #endif
<a name="115" id="anc115"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="115" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSClassRef.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSHeapFinalizerPrivate.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSContextRef.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006, 2007, 2013, 2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,11 ***</span>
  #endif
  
  #if OS(DARWIN)
  #include &lt;mach-o/dyld.h&gt;
  
<span class="line-modified">! static const int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0</span>
  #endif
  
  using namespace JSC;
  
  // From the API&#39;s perspective, a context group remains alive iff
<span class="line-new-header">--- 54,11 ---</span>
  #endif
  
  #if OS(DARWIN)
  #include &lt;mach-o/dyld.h&gt;
  
<span class="line-modified">! static constexpr int32_t webkitFirstVersionWithConcurrentGlobalContexts = 0x2100500; // 528.5.0</span>
  #endif
  
  using namespace JSC;
  
  // From the API&#39;s perspective, a context group remains alive iff
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
  //     OR
  //     (b) one of its contexts has been JSContextRetained
  
  JSContextGroupRef JSContextGroupCreate()
  {
<span class="line-removed">-     WTF::initializeMainThread();</span>
      initializeThreading();
      return toRef(&amp;VM::createContextGroup().leakRef());
  }
  
  JSContextGroupRef JSContextGroupRetain(JSContextGroupRef group)
<span class="line-new-header">--- 66,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,14 ***</span>
  
      JSLockHolder locker(&amp;vm);
      vm.deref();
  }
  
<span class="line-modified">! static bool internalScriptTimeoutCallback(ExecState* exec, void* callbackPtr, void* callbackData)</span>
  {
      JSShouldTerminateCallback callback = reinterpret_cast&lt;JSShouldTerminateCallback&gt;(callbackPtr);
<span class="line-modified">!     JSContextRef contextRef = toRef(exec);</span>
      ASSERT(callback);
      return callback(contextRef, callbackData);
  }
  
  void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
<span class="line-new-header">--- 84,14 ---</span>
  
      JSLockHolder locker(&amp;vm);
      vm.deref();
  }
  
<span class="line-modified">! static bool internalScriptTimeoutCallback(JSGlobalObject* globalObject, void* callbackPtr, void* callbackData)</span>
  {
      JSShouldTerminateCallback callback = reinterpret_cast&lt;JSShouldTerminateCallback&gt;(callbackPtr);
<span class="line-modified">!     JSContextRef contextRef = toRef(globalObject);</span>
      ASSERT(callback);
      return callback(contextRef, callbackData);
  }
  
  void JSContextGroupSetExecutionTimeLimit(JSContextGroupRef group, double limit, JSShouldTerminateCallback callback, void* callbackData)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
  
  // From the API&#39;s perspective, a global context remains alive iff it has been JSGlobalContextRetained.
  
  JSGlobalContextRef JSGlobalContextCreate(JSClassRef globalObjectClass)
  {
<span class="line-removed">-     WTF::initializeMainThread();</span>
      initializeThreading();
  
  #if OS(DARWIN)
      // If the application was linked before JSGlobalContextCreate was changed to use a unique VM,
      // we use a shared one for backwards compatibility.
<span class="line-new-header">--- 116,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,11 ***</span>
      return JSGlobalContextCreateInGroup(0, globalObjectClass);
  }
  
  JSGlobalContextRef JSGlobalContextCreateInGroup(JSContextGroupRef group, JSClassRef globalObjectClass)
  {
<span class="line-removed">-     WTF::initializeMainThread();</span>
      initializeThreading();
  
      Ref&lt;VM&gt; vm = group ? Ref&lt;VM&gt;(*toJS(group)) : VM::createContextGroup();
  
      JSLockHolder locker(vm.ptr());
<span class="line-new-header">--- 131,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,44 ***</span>
          JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
  #if ENABLE(REMOTE_INSPECTOR)
          if (JSRemoteInspectorGetInspectionEnabledByDefault())
              globalObject-&gt;setRemoteDebuggingEnabled(true);
  #endif
<span class="line-modified">!         return JSGlobalContextRetain(toGlobalRef(globalObject-&gt;globalExec()));</span>
      }
  
      JSGlobalObject* globalObject = JSCallbackObject&lt;JSGlobalObject&gt;::create(vm.get(), globalObjectClass, JSCallbackObject&lt;JSGlobalObject&gt;::createStructure(vm.get(), 0, jsNull()));
<span class="line-modified">!     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">-     JSValue prototype = globalObjectClass-&gt;prototype(exec);</span>
      if (!prototype)
          prototype = jsNull();
      globalObject-&gt;resetPrototype(vm.get(), prototype);
  #if ENABLE(REMOTE_INSPECTOR)
      if (JSRemoteInspectorGetInspectionEnabledByDefault())
          globalObject-&gt;setRemoteDebuggingEnabled(true);
  #endif
<span class="line-modified">!     return JSGlobalContextRetain(toGlobalRef(exec));</span>
  }
  
  JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     gcProtect(vm.vmEntryGlobalObject(exec));</span>
      vm.ref();
      return ctx;
  }
  
  void JSGlobalContextRelease(JSGlobalContextRef ctx)
  {
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     bool protectCountIsZero = vm.heap.unprotect(vm.vmEntryGlobalObject(exec));</span>
      if (protectCountIsZero)
          vm.heap.reportAbandonedObjectGraph();
      vm.deref();
  }
  
<span class="line-new-header">--- 143,43 ---</span>
          JSGlobalObject* globalObject = JSAPIGlobalObject::create(vm.get(), JSAPIGlobalObject::createStructure(vm.get(), jsNull()));
  #if ENABLE(REMOTE_INSPECTOR)
          if (JSRemoteInspectorGetInspectionEnabledByDefault())
              globalObject-&gt;setRemoteDebuggingEnabled(true);
  #endif
<span class="line-modified">!         return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
      }
  
      JSGlobalObject* globalObject = JSCallbackObject&lt;JSGlobalObject&gt;::create(vm.get(), globalObjectClass, JSCallbackObject&lt;JSGlobalObject&gt;::createStructure(vm.get(), 0, jsNull()));
<span class="line-modified">!     JSValue prototype = globalObjectClass-&gt;prototype(globalObject);</span>
      if (!prototype)
          prototype = jsNull();
      globalObject-&gt;resetPrototype(vm.get(), prototype);
  #if ENABLE(REMOTE_INSPECTOR)
      if (JSRemoteInspectorGetInspectionEnabledByDefault())
          globalObject-&gt;setRemoteDebuggingEnabled(true);
  #endif
<span class="line-modified">!     return JSGlobalContextRetain(toGlobalRef(globalObject));</span>
  }
  
  JSGlobalContextRef JSGlobalContextRetain(JSGlobalContextRef ctx)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     gcProtect(globalObject);</span>
      vm.ref();
      return ctx;
  }
  
  void JSGlobalContextRelease(JSGlobalContextRef ctx)
  {
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     bool protectCountIsZero = vm.heap.unprotect(globalObject);</span>
      if (protectCountIsZero)
          vm.heap.reportAbandonedObjectGraph();
      vm.deref();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,51 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     return toRef(jsCast&lt;JSObject*&gt;(exec-&gt;lexicalGlobalObject()-&gt;methodTable(vm)-&gt;toThis(exec-&gt;lexicalGlobalObject(), exec, NotStrictMode)));</span>
  }
  
  JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     return toRef(&amp;exec-&gt;vm());</span>
  }
  
  JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(exec);</span>
  
<span class="line-modified">!     return toGlobalRef(exec-&gt;lexicalGlobalObject()-&gt;globalExec());</span>
  }
  
  JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     String name = vm.vmEntryGlobalObject(exec)-&gt;name();</span>
      if (name.isNull())
          return 0;
  
      return OpaqueJSString::tryCreate(name).leakRef();
  }
<span class="line-new-header">--- 187,51 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     return toRef(jsCast&lt;JSObject*&gt;(globalObject-&gt;methodTable(vm)-&gt;toThis(globalObject, globalObject, NotStrictMode)));</span>
  }
  
  JSContextGroupRef JSContextGetGroup(JSContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     return toRef(&amp;globalObject-&gt;vm());</span>
  }
  
  JSGlobalContextRef JSContextGetGlobalContext(JSContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     JSLockHolder locker(globalObject);</span>
  
<span class="line-modified">!     return toGlobalRef(globalObject);</span>
  }
  
  JSStringRef JSGlobalContextCopyName(JSGlobalContextRef ctx)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     String name = globalObject-&gt;name();</span>
      if (name.isNull())
          return 0;
  
      return OpaqueJSString::tryCreate(name).leakRef();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 245,35 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     vm.vmEntryGlobalObject(exec)-&gt;setName(name ? name-&gt;string() : String());</span>
  }
  
  void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      JSObject* object = toJS(function);
      if (!object-&gt;isFunction(vm)) {
<span class="line-modified">!         *exception = toRef(createTypeError(exec));</span>
          return;
      }
  
<span class="line-modified">!     vm.vmEntryGlobalObject(exec)-&gt;setUnhandledRejectionCallback(vm, object);</span>
  }
  
  class BacktraceFunctor {
  public:
      BacktraceFunctor(StringBuilder&amp; builder, unsigned remainingCapacityForFrameCapture)
<span class="line-new-header">--- 241,35 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
<span class="line-modified">!     globalObject-&gt;setName(name ? name-&gt;string() : String());</span>
  }
  
  void JSGlobalContextSetUnhandledRejectionCallback(JSGlobalContextRef ctx, JSObjectRef function, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      JSObject* object = toJS(function);
      if (!object-&gt;isFunction(vm)) {
<span class="line-modified">!         *exception = toRef(createTypeError(globalObject));</span>
          return;
      }
  
<span class="line-modified">!     globalObject-&gt;setUnhandledRejectionCallback(vm, object);</span>
  }
  
  class BacktraceFunctor {
  public:
      BacktraceFunctor(StringBuilder&amp; builder, unsigned remainingCapacityForFrameCapture)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,19 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      StringBuilder builder;
      CallFrame* frame = vm.topCallFrame;
  
      ASSERT(maxStackSize);
      BacktraceFunctor functor(builder, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(functor);</span>
  
      return OpaqueJSString::tryCreate(builder.toString()).leakRef();
  }
  
  bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
<span class="line-new-header">--- 324,19 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return 0;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      StringBuilder builder;
      CallFrame* frame = vm.topCallFrame;
  
      ASSERT(maxStackSize);
      BacktraceFunctor functor(builder, maxStackSize);
<span class="line-modified">!     frame-&gt;iterate(vm, functor);</span>
  
      return OpaqueJSString::tryCreate(builder.toString()).leakRef();
  }
  
  bool JSGlobalContextGetRemoteInspectionEnabled(JSGlobalContextRef ctx)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 348,44 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return vm.vmEntryGlobalObject(exec)-&gt;remoteDebuggingEnabled();</span>
  }
  
  void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     vm.vmEntryGlobalObject(exec)-&gt;setRemoteDebuggingEnabled(enabled);</span>
  }
  
  bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
  {
  #if ENABLE(REMOTE_INSPECTOR)
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-removed">-     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
      return globalObject-&gt;inspectorController().includesNativeCallStackWhenReportingExceptions();
  #else
      UNUSED_PARAM(ctx);
      return false;
  #endif
<span class="line-new-header">--- 344,43 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return globalObject-&gt;remoteDebuggingEnabled();</span>
  }
  
  void JSGlobalContextSetRemoteInspectionEnabled(JSGlobalContextRef ctx, bool enabled)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     globalObject-&gt;setRemoteDebuggingEnabled(enabled);</span>
  }
  
  bool JSGlobalContextGetIncludesNativeCallStackWhenReportingExceptions(JSGlobalContextRef ctx)
  {
  #if ENABLE(REMOTE_INSPECTOR)
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
      return globalObject-&gt;inspectorController().includesNativeCallStackWhenReportingExceptions();
  #else
      UNUSED_PARAM(ctx);
      return false;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,15 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-removed">-     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
      globalObject-&gt;inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
  #else
      UNUSED_PARAM(ctx);
      UNUSED_PARAM(includesNativeCallStack);
  #endif
<span class="line-new-header">--- 392,14 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
      globalObject-&gt;inspectorController().setIncludesNativeCallStackWhenReportingExceptions(includesNativeCallStack);
  #else
      UNUSED_PARAM(ctx);
      UNUSED_PARAM(includesNativeCallStack);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,15 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return vm.vmEntryGlobalObject(exec)-&gt;inspectorDebuggable().targetRunLoop();</span>
  #else
      UNUSED_PARAM(ctx);
      return nullptr;
  #endif
  }
<span class="line-new-header">--- 412,15 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return globalObject-&gt;inspectorDebuggable().targetRunLoop();</span>
  #else
      UNUSED_PARAM(ctx);
      return nullptr;
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 437,15 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     vm.vmEntryGlobalObject(exec)-&gt;inspectorDebuggable().setTargetRunLoop(runLoop);</span>
  #else
      UNUSED_PARAM(ctx);
      UNUSED_PARAM(runLoop);
  #endif
  }
<span class="line-new-header">--- 431,15 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     globalObject-&gt;inspectorDebuggable().setTargetRunLoop(runLoop);</span>
  #else
      UNUSED_PARAM(ctx);
      UNUSED_PARAM(runLoop);
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,12 ***</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return &amp;vm.vmEntryGlobalObject(exec)-&gt;inspectorController();</span>
  }
  #endif
<span class="line-new-header">--- 451,12 ---</span>
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
  
<span class="line-modified">!     return &amp;globalObject-&gt;inspectorController();</span>
  }
  #endif
</pre>
<center><a href="JSClassRef.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSHeapFinalizerPrivate.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
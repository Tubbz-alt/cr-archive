<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/PrintContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
  3  * Copyright (C) 2007-2019 Apple Inc.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;PrintContext.h&quot;
 23 
 24 #include &quot;ElementTraversal.h&quot;
 25 #include &quot;GraphicsContext.h&quot;
 26 #include &quot;Frame.h&quot;
 27 #include &quot;FrameView.h&quot;
 28 #include &quot;LengthBox.h&quot;
 29 #include &quot;RenderView.h&quot;
 30 #include &quot;RuntimeEnabledFeatures.h&quot;
 31 #include &quot;StyleInheritedData.h&quot;
 32 #include &quot;StyleResolver.h&quot;
 33 #include &quot;StyleScope.h&quot;
 34 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 PrintContext::PrintContext(Frame* frame)
 39     : FrameDestructionObserver(frame)
 40 {
 41 }
 42 
 43 PrintContext::~PrintContext()
 44 {
 45     if (m_isPrinting)
 46         end();
 47 }
 48 
 49 void PrintContext::computePageRects(const FloatRect&amp; printRect, float headerHeight, float footerHeight, float userScaleFactor, float&amp; outPageHeight, bool allowHorizontalTiling)
 50 {
 51     if (!frame())
 52         return;
 53 
 54     auto&amp; frame = *this-&gt;frame();
 55     m_pageRects.clear();
 56     outPageHeight = 0;
 57 
 58     if (!frame.document() || !frame.view() || !frame.document()-&gt;renderView())
 59         return;
 60 
 61     if (userScaleFactor &lt;= 0) {
 62         LOG_ERROR(&quot;userScaleFactor has bad value %.2f&quot;, userScaleFactor);
 63         return;
 64     }
 65 
 66     RenderView* view = frame.document()-&gt;renderView();
 67     const IntRect&amp; documentRect = view-&gt;documentRect();
 68     FloatSize pageSize = frame.resizePageRectsKeepingRatio(FloatSize(printRect.width(), printRect.height()), FloatSize(documentRect.width(), documentRect.height()));
 69     float pageWidth = pageSize.width();
 70     float pageHeight = pageSize.height();
 71 
 72     outPageHeight = pageHeight; // this is the height of the page adjusted by margins
 73     pageHeight -= headerHeight + footerHeight;
 74 
 75     if (pageHeight &lt;= 0) {
 76         LOG_ERROR(&quot;pageHeight has bad value %.2f&quot;, pageHeight);
 77         return;
 78     }
 79 
 80     computePageRectsWithPageSizeInternal(FloatSize(pageWidth / userScaleFactor, pageHeight / userScaleFactor), allowHorizontalTiling);
 81 }
 82 
 83 FloatBoxExtent PrintContext::computedPageMargin(FloatBoxExtent printMargin)
 84 {
 85     if (!frame() || !frame()-&gt;document())
 86         return printMargin;
 87     if (!RuntimeEnabledFeatures::sharedFeatures().pageAtRuleSupportEnabled())
 88         return printMargin;
 89     // FIXME Currently no pseudo class is supported.
 90     auto style = frame()-&gt;document()-&gt;styleScope().resolver().styleForPage(0);
 91 
 92     float pixelToPointScaleFactor = 1 / CSSPrimitiveValue::conversionToCanonicalUnitsScaleFactor(CSSUnitType::CSS_PT);
 93     return { style-&gt;marginTop().isAuto() ? printMargin.top() : style-&gt;marginTop().value() * pixelToPointScaleFactor,
 94         style-&gt;marginRight().isAuto() ? printMargin.right() : style-&gt;marginRight().value() * pixelToPointScaleFactor,
 95         style-&gt;marginBottom().isAuto() ? printMargin.bottom() : style-&gt;marginBottom().value() * pixelToPointScaleFactor,
 96         style-&gt;marginLeft().isAuto() ? printMargin.left() : style-&gt;marginLeft().value() * pixelToPointScaleFactor };
 97 }
 98 
 99 FloatSize PrintContext::computedPageSize(FloatSize pageSize, FloatBoxExtent printMargin)
100 {
101     auto computedMargin = computedPageMargin(printMargin);
102     if (computedMargin == printMargin)
103         return pageSize;
104 
105     auto horizontalMarginDelta = (printMargin.left() - computedMargin.left()) + (printMargin.right() - computedMargin.right());
106     auto verticalMarginDelta = (printMargin.top() - computedMargin.top()) + (printMargin.bottom() - computedMargin.bottom());
107     return { pageSize.width() + horizontalMarginDelta, pageSize.height() + verticalMarginDelta };
108 }
109 
110 void PrintContext::computePageRectsWithPageSize(const FloatSize&amp; pageSizeInPixels, bool allowHorizontalTiling)
111 {
112     m_pageRects.clear();
113     computePageRectsWithPageSizeInternal(pageSizeInPixels, allowHorizontalTiling);
114 }
115 
116 void PrintContext::computePageRectsWithPageSizeInternal(const FloatSize&amp; pageSizeInPixels, bool allowInlineDirectionTiling)
117 {
118     if (!frame())
119         return;
120 
121     auto&amp; frame = *this-&gt;frame();
122     if (!frame.document() || !frame.view() || !frame.document()-&gt;renderView())
123         return;
124 
125     RenderView* view = frame.document()-&gt;renderView();
126 
127     IntRect docRect = view-&gt;documentRect();
128 
129     int pageWidth = pageSizeInPixels.width();
130     int pageHeight = pageSizeInPixels.height();
131 
132     bool isHorizontal = view-&gt;style().isHorizontalWritingMode();
133 
134     int docLogicalHeight = isHorizontal ? docRect.height() : docRect.width();
135     int pageLogicalHeight = isHorizontal ? pageHeight : pageWidth;
136     int pageLogicalWidth = isHorizontal ? pageWidth : pageHeight;
137 
138     int inlineDirectionStart;
139     int inlineDirectionEnd;
140     int blockDirectionStart;
141     int blockDirectionEnd;
142     if (isHorizontal) {
143         if (view-&gt;style().isFlippedBlocksWritingMode()) {
144             blockDirectionStart = docRect.maxY();
145             blockDirectionEnd = docRect.y();
146         } else {
147             blockDirectionStart = docRect.y();
148             blockDirectionEnd = docRect.maxY();
149         }
150         inlineDirectionStart = view-&gt;style().isLeftToRightDirection() ? docRect.x() : docRect.maxX();
151         inlineDirectionEnd = view-&gt;style().isLeftToRightDirection() ? docRect.maxX() : docRect.x();
152     } else {
153         if (view-&gt;style().isFlippedBlocksWritingMode()) {
154             blockDirectionStart = docRect.maxX();
155             blockDirectionEnd = docRect.x();
156         } else {
157             blockDirectionStart = docRect.x();
158             blockDirectionEnd = docRect.maxX();
159         }
160         inlineDirectionStart = view-&gt;style().isLeftToRightDirection() ? docRect.y() : docRect.maxY();
161         inlineDirectionEnd = view-&gt;style().isLeftToRightDirection() ? docRect.maxY() : docRect.y();
162     }
163 
164     unsigned pageCount = ceilf((float)docLogicalHeight / pageLogicalHeight);
165     for (unsigned i = 0; i &lt; pageCount; ++i) {
166         int pageLogicalTop = blockDirectionEnd &gt; blockDirectionStart ?
167                                 blockDirectionStart + i * pageLogicalHeight :
168                                 blockDirectionStart - (i + 1) * pageLogicalHeight;
169         if (allowInlineDirectionTiling) {
170             for (int currentInlinePosition = inlineDirectionStart;
171                  inlineDirectionEnd &gt; inlineDirectionStart ? currentInlinePosition &lt; inlineDirectionEnd : currentInlinePosition &gt; inlineDirectionEnd;
172                  currentInlinePosition += (inlineDirectionEnd &gt; inlineDirectionStart ? pageLogicalWidth : -pageLogicalWidth)) {
173                 int pageLogicalLeft = inlineDirectionEnd &gt; inlineDirectionStart ? currentInlinePosition : currentInlinePosition - pageLogicalWidth;
174                 IntRect pageRect(pageLogicalLeft, pageLogicalTop, pageLogicalWidth, pageLogicalHeight);
175                 if (!isHorizontal)
176                     pageRect = pageRect.transposedRect();
177                 m_pageRects.append(pageRect);
178             }
179         } else {
180             int pageLogicalLeft = inlineDirectionEnd &gt; inlineDirectionStart ? inlineDirectionStart : inlineDirectionStart - pageLogicalWidth;
181             IntRect pageRect(pageLogicalLeft, pageLogicalTop, pageLogicalWidth, pageLogicalHeight);
182             if (!isHorizontal)
183                 pageRect = pageRect.transposedRect();
184             m_pageRects.append(pageRect);
185         }
186     }
187 }
188 
189 void PrintContext::begin(float width, float height)
190 {
191     if (!frame())
192         return;
193 
194     auto&amp; frame = *this-&gt;frame();
195     // This function can be called multiple times to adjust printing parameters without going back to screen mode.
196     m_isPrinting = true;
197 
198     FloatSize originalPageSize = FloatSize(width, height);
199     FloatSize minLayoutSize = frame.resizePageRectsKeepingRatio(originalPageSize, FloatSize(width * minimumShrinkFactor(), height * minimumShrinkFactor()));
200 
201     // This changes layout, so callers need to make sure that they don&#39;t paint to screen while in printing mode.
202     frame.setPrinting(true, minLayoutSize, originalPageSize, maximumShrinkFactor() / minimumShrinkFactor(), AdjustViewSize);
203 }
204 
205 float PrintContext::computeAutomaticScaleFactor(const FloatSize&amp; availablePaperSize)
206 {
207     if (!frame())
208         return 1;
209 
210     auto&amp; frame = *this-&gt;frame();
211     if (!frame.view())
212         return 1;
213 
214     bool useViewWidth = true;
215     if (frame.document() &amp;&amp; frame.document()-&gt;renderView())
216         useViewWidth = frame.document()-&gt;renderView()-&gt;style().isHorizontalWritingMode();
217 
218     float viewLogicalWidth = useViewWidth ? frame.view()-&gt;contentsWidth() : frame.view()-&gt;contentsHeight();
219     if (viewLogicalWidth &lt; 1)
220         return 1;
221 
222     float maxShrinkToFitScaleFactor = 1 / maximumShrinkFactor();
223     float shrinkToFitScaleFactor = (useViewWidth ? availablePaperSize.width() : availablePaperSize.height()) / viewLogicalWidth;
224     return std::max(maxShrinkToFitScaleFactor, shrinkToFitScaleFactor);
225 }
226 
227 void PrintContext::spoolPage(GraphicsContext&amp; ctx, int pageNumber, float width)
228 {
229     if (!frame())
230         return;
231 
232     auto&amp; frame = *this-&gt;frame();
233     if (!frame.view())
234         return;
235 
236     // FIXME: Not correct for vertical text.
237     IntRect pageRect = m_pageRects[pageNumber];
238     float scale = width / pageRect.width();
239 
240     ctx.save();
241     ctx.scale(scale);
242     ctx.translate(-pageRect.x(), -pageRect.y());
243     ctx.clip(pageRect);
244     frame.view()-&gt;paintContents(ctx, pageRect);
245     outputLinkedDestinations(ctx, *frame.document(), pageRect);
246     ctx.restore();
247 }
248 
249 void PrintContext::spoolRect(GraphicsContext&amp; ctx, const IntRect&amp; rect)
250 {
251     if (!frame())
252         return;
253 
254     auto&amp; frame = *this-&gt;frame();
255     if (!frame.view())
256         return;
257 
258     // FIXME: Not correct for vertical text.
259     ctx.save();
260     ctx.translate(-rect.x(), -rect.y());
261     ctx.clip(rect);
262     frame.view()-&gt;paintContents(ctx, rect);
263     outputLinkedDestinations(ctx, *frame.document(), rect);
264     ctx.restore();
265 }
266 
267 void PrintContext::end()
268 {
269     if (!frame())
270         return;
271 
272     auto&amp; frame = *this-&gt;frame();
273     ASSERT(m_isPrinting);
274     m_isPrinting = false;
275     frame.setPrinting(false, FloatSize(), FloatSize(), 0, AdjustViewSize);
276     m_linkedDestinations = nullptr;
277 }
278 
279 static inline RenderBoxModelObject* enclosingBoxModelObject(RenderElement* renderer)
280 {
281     while (renderer &amp;&amp; !is&lt;RenderBoxModelObject&gt;(*renderer))
282         renderer = renderer-&gt;parent();
283     return downcast&lt;RenderBoxModelObject&gt;(renderer);
284 }
285 
286 int PrintContext::pageNumberForElement(Element* element, const FloatSize&amp; pageSizeInPixels)
287 {
288     // Make sure the element is not freed during the layout.
289     RefPtr&lt;Element&gt; elementRef(element);
290     element-&gt;document().updateLayout();
291 
292     auto* box = enclosingBoxModelObject(element-&gt;renderer());
293     if (!box)
294         return -1;
295 
296     Frame* frame = element-&gt;document().frame();
297     FloatRect pageRect(FloatPoint(0, 0), pageSizeInPixels);
298     PrintContext printContext(frame);
299     printContext.begin(pageRect.width(), pageRect.height());
300     FloatSize scaledPageSize = pageSizeInPixels;
301     scaledPageSize.scale(frame-&gt;view()-&gt;contentsSize().width() / pageRect.width());
302     printContext.computePageRectsWithPageSize(scaledPageSize, false);
303 
304     int top = roundToInt(box-&gt;offsetTop());
305     int left = roundToInt(box-&gt;offsetLeft());
306     size_t pageNumber = 0;
307     for (; pageNumber &lt; printContext.pageCount(); pageNumber++) {
308         const IntRect&amp; page = printContext.pageRect(pageNumber);
309         if (page.x() &lt;= left &amp;&amp; left &lt; page.maxX() &amp;&amp; page.y() &lt;= top &amp;&amp; top &lt; page.maxY())
310             return pageNumber;
311     }
312     return -1;
313 }
314 
315 void PrintContext::collectLinkedDestinations(Document&amp; document)
316 {
317     for (Element* child = document.documentElement(); child; child = ElementTraversal::next(*child)) {
318         String outAnchorName;
319         if (Element* element = child-&gt;findAnchorElementForLink(outAnchorName))
320             m_linkedDestinations-&gt;add(outAnchorName, *element);
321     }
322 }
323 
324 void PrintContext::outputLinkedDestinations(GraphicsContext&amp; graphicsContext, Document&amp; document, const IntRect&amp; pageRect)
325 {
326     if (!graphicsContext.supportsInternalLinks())
327         return;
328 
329     if (!m_linkedDestinations) {
330         m_linkedDestinations = makeUnique&lt;HashMap&lt;String, Ref&lt;Element&gt;&gt;&gt;();
331         collectLinkedDestinations(document);
332     }
333 
334     for (const auto&amp; it : *m_linkedDestinations) {
335         RenderElement* renderer = it.value-&gt;renderer();
336         if (!renderer)
337             continue;
338 
339         FloatPoint point = renderer-&gt;absoluteAnchorRect().minXMinYCorner();
340         point = point.expandedTo(FloatPoint());
341 
342         if (!pageRect.contains(roundedIntPoint(point)))
343             continue;
344 
345         graphicsContext.addDestinationAtPoint(it.key, point);
346     }
347 }
348 
349 String PrintContext::pageProperty(Frame* frame, const char* propertyName, int pageNumber)
350 {
351     ASSERT(frame);
352     ASSERT(frame-&gt;document());
353 
354     Ref&lt;Frame&gt; protectedFrame(*frame);
355 
356     auto&amp; document = *frame-&gt;document();
357     PrintContext printContext(frame);
358     printContext.begin(800); // Any width is OK here.
359     document.updateLayout();
360     auto style = document.styleScope().resolver().styleForPage(pageNumber);
361 
362     // Implement formatters for properties we care about.
363     if (!strcmp(propertyName, &quot;margin-left&quot;)) {
364         if (style-&gt;marginLeft().isAuto())
365             return &quot;auto&quot;_s;
366         return String::number(style-&gt;marginLeft().value());
367     }
368     if (!strcmp(propertyName, &quot;line-height&quot;))
369         return String::number(style-&gt;lineHeight().value());
370     if (!strcmp(propertyName, &quot;font-size&quot;))
371         return String::number(style-&gt;fontDescription().computedPixelSize());
372     if (!strcmp(propertyName, &quot;font-family&quot;))
373         return style-&gt;fontDescription().firstFamily();
374     if (!strcmp(propertyName, &quot;size&quot;))
375         return makeString(style-&gt;pageSize().width.value(), &#39; &#39;, style-&gt;pageSize().height.value());
376 
377     return makeString(&quot;pageProperty() unimplemented for: &quot;, propertyName);
378 }
379 
380 bool PrintContext::isPageBoxVisible(Frame* frame, int pageNumber)
381 {
382     return frame-&gt;document()-&gt;isPageBoxVisible(pageNumber);
383 }
384 
385 String PrintContext::pageSizeAndMarginsInPixels(Frame* frame, int pageNumber, int width, int height, int marginTop, int marginRight, int marginBottom, int marginLeft)
386 {
387     IntSize pageSize(width, height);
388     frame-&gt;document()-&gt;pageSizeAndMarginsInPixels(pageNumber, pageSize, marginTop, marginRight, marginBottom, marginLeft);
389 
390     return makeString(&#39;(&#39;, pageSize.width(), &quot;, &quot;, pageSize.height(), &quot;) &quot;, marginTop, &#39; &#39;, marginRight, &#39; &#39;, marginBottom, &#39; &#39;, marginLeft);
391 }
392 
393 bool PrintContext::beginAndComputePageRectsWithPageSize(Frame&amp; frame, const FloatSize&amp; pageSizeInPixels)
394 {
395     if (!frame.document() || !frame.view() || !frame.document()-&gt;renderView())
396         return false;
397 
398     frame.document()-&gt;updateLayout();
399 
400     begin(pageSizeInPixels.width(), pageSizeInPixels.height());
401     // Account for shrink-to-fit.
402     FloatSize scaledPageSize = pageSizeInPixels;
403     scaledPageSize.scale(frame.view()-&gt;contentsSize().width() / pageSizeInPixels.width());
404     computePageRectsWithPageSize(scaledPageSize, false);
405 
406     return true;
407 }
408 
409 int PrintContext::numberOfPages(Frame&amp; frame, const FloatSize&amp; pageSizeInPixels)
410 {
411     Ref&lt;Frame&gt; protectedFrame(frame);
412 
413     PrintContext printContext(&amp;frame);
414     if (!printContext.beginAndComputePageRectsWithPageSize(frame, pageSizeInPixels))
415         return -1;
416 
417     return printContext.pageCount();
418 }
419 
420 void PrintContext::spoolAllPagesWithBoundaries(Frame&amp; frame, GraphicsContext&amp; graphicsContext, const FloatSize&amp; pageSizeInPixels)
421 {
422     Ref&lt;Frame&gt; protectedFrame(frame);
423 
424     PrintContext printContext(&amp;frame);
425     if (!printContext.beginAndComputePageRectsWithPageSize(frame, pageSizeInPixels))
426         return;
427 
428     const float pageWidth = pageSizeInPixels.width();
429     const Vector&lt;IntRect&gt;&amp; pageRects = printContext.pageRects();
430     int totalHeight = pageRects.size() * (pageSizeInPixels.height() + 1) - 1;
431 
432     // Fill the whole background by white.
433     graphicsContext.setFillColor(Color(255, 255, 255));
434     graphicsContext.fillRect(FloatRect(0, 0, pageWidth, totalHeight));
435 
436     graphicsContext.save();
437 
438     int currentHeight = 0;
439     for (size_t pageIndex = 0; pageIndex &lt; pageRects.size(); pageIndex++) {
440         // Draw a line for a page boundary if this isn&#39;t the first page.
441         if (pageIndex &gt; 0) {
442 #if PLATFORM(COCOA)
443             int boundaryLineY = currentHeight;
444 #else
445             int boundaryLineY = currentHeight - 1;
446 #endif
447             graphicsContext.save();
448             graphicsContext.setStrokeColor(Color(0, 0, 255));
449             graphicsContext.setFillColor(Color(0, 0, 255));
450             graphicsContext.drawLine(IntPoint(0, boundaryLineY), IntPoint(pageWidth, boundaryLineY));
451             graphicsContext.restore();
452         }
453 
454         graphicsContext.save();
455         graphicsContext.translate(0, currentHeight);
456         printContext.spoolPage(graphicsContext, pageIndex, pageWidth);
457         graphicsContext.restore();
458 
459         currentHeight += pageSizeInPixels.height() + 1;
460     }
461 
462     graphicsContext.restore();
463 }
464 
465 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutResolver.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 65,18 ***</span>
      auto&amp; run = m_iterator.simpleRun();
      auto&amp; resolver = m_iterator.resolver();
      float baseline = computeBaselinePosition();
      FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
      FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
<span class="line-modified">!     bool moveLineBreakToBaseline = false;</span>
<span class="line-removed">-     if (run.start == run.end &amp;&amp; m_iterator != resolver.begin() &amp;&amp; m_iterator.inQuirksMode()) {</span>
<span class="line-removed">-         auto previousRun = m_iterator;</span>
<span class="line-removed">-         --previousRun;</span>
<span class="line-removed">-         moveLineBreakToBaseline = !previousRun.simpleRun().isEndOfLine;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (moveLineBreakToBaseline)</span>
<span class="line-removed">-         return FloatRect(FloatPoint(position.x(), baseline), FloatSize(size.width(), std::max&lt;float&gt;(0, resolver.m_ascent - resolver.m_baseline.toFloat())));</span>
      return FloatRect(position, size);
  }
  
  StringView RunResolver::Run::text() const
  {
<span class="line-new-header">--- 65,11 ---</span>
      auto&amp; run = m_iterator.simpleRun();
      auto&amp; resolver = m_iterator.resolver();
      float baseline = computeBaselinePosition();
      FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
      FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
<span class="line-modified">! </span>
      return FloatRect(position, size);
  }
  
  StringView RunResolver::Run::text() const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,14 ***</span>
      ASSERT(run.start != run.end);
      return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
  }
  
  RunResolver::Iterator::Iterator(const RunResolver&amp; resolver, unsigned runIndex, unsigned lineIndex)
<span class="line-modified">!     : m_resolver(resolver)</span>
      , m_runIndex(runIndex)
      , m_lineIndex(lineIndex)
  {
  }
  
  RunResolver::Iterator&amp; RunResolver::Iterator::advance()
  {
      if (simpleRun().isEndOfLine)
<span class="line-new-header">--- 104,16 ---</span>
      ASSERT(run.start != run.end);
      return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
  }
  
  RunResolver::Iterator::Iterator(const RunResolver&amp; resolver, unsigned runIndex, unsigned lineIndex)
<span class="line-modified">!     : m_layout(&amp;resolver.m_layout)</span>
<span class="line-added">+     , m_resolver(&amp;resolver)</span>
      , m_runIndex(runIndex)
      , m_lineIndex(lineIndex)
  {
<span class="line-added">+     ASSERT(&amp;resolver == &amp;m_layout-&gt;runResolver());</span>
  }
  
  RunResolver::Iterator&amp; RunResolver::Iterator::advance()
  {
      if (simpleRun().isEndOfLine)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 127,12 ***</span>
      return *this;
  }
  
  RunResolver::Iterator&amp; RunResolver::Iterator::advanceLines(unsigned lineCount)
  {
<span class="line-modified">!     unsigned runCount = m_resolver.m_layout.runCount();</span>
<span class="line-modified">!     if (runCount == m_resolver.m_layout.lineCount()) {</span>
          m_runIndex = std::min(runCount, m_runIndex + lineCount);
          m_lineIndex = m_runIndex;
          return *this;
      }
      unsigned target = m_lineIndex + lineCount;
<span class="line-new-header">--- 122,12 ---</span>
      return *this;
  }
  
  RunResolver::Iterator&amp; RunResolver::Iterator::advanceLines(unsigned lineCount)
  {
<span class="line-modified">!     unsigned runCount = layout().runCount();</span>
<span class="line-modified">!     if (runCount == layout().lineCount()) {</span>
          m_runIndex = std::min(runCount, m_runIndex + lineCount);
          m_lineIndex = m_runIndex;
          return *this;
      }
      unsigned target = m_lineIndex + lineCount;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,11 ***</span>
      , m_baseline(baselineFromFlow(flow))
      , m_borderAndPaddingBefore(flow.borderAndPaddingBefore())
      , m_ascent(flow.style().fontCascade().fontMetrics().ascent())
      , m_descent(flow.style().fontCascade().fontMetrics().descent())
      , m_visualOverflowOffset(visualOverflowForDecorations(flow.style(), nullptr).bottom)
<span class="line-removed">-     , m_inQuirksMode(flow.document().inQuirksMode())</span>
  {
  }
  
  unsigned RunResolver::adjustLineIndexForStruts(LayoutUnit y, IndexType type, unsigned lineIndexCandidate) const
  {
<span class="line-new-header">--- 145,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 301,12 ***</span>
      auto range = rangeForRenderer(renderer);
      if (range.begin() == range.end())
          return { end(), end() };
      auto it = range.begin();
      auto localEnd = (*it).start() + endOffset;
<span class="line-modified">!     // Advance to the first run with the start offset inside. Only the first node in a range can have a startOffset.</span>
<span class="line-modified">!     while (it != range.end() &amp;&amp; (*it).end() &lt;= startOffset)</span>
          ++it;
      if (it == range.end())
          return { end(), end() };
      auto rangeBegin = it;
      // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.
<span class="line-new-header">--- 295,14 ---</span>
      auto range = rangeForRenderer(renderer);
      if (range.begin() == range.end())
          return { end(), end() };
      auto it = range.begin();
      auto localEnd = (*it).start() + endOffset;
<span class="line-modified">!     // Advance to the first run before the start offset. Only the first node in a range can have a startOffset.</span>
<span class="line-modified">!     // Note that the start offset may coincide with the end of a run. The run is still considered so that we</span>
<span class="line-added">+     // can return an empty rect, which conforms to the behavior of Element.getClientRects().</span>
<span class="line-added">+     while (it != range.end() &amp;&amp; (*it).end() &lt; startOffset)</span>
          ++it;
      if (it == range.end())
          return { end(), end() };
      auto rangeBegin = it;
      // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.
</pre>
<center><a href="SimpleLineLayoutFunctions.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutResolver.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ShadowRoot.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Neither the name of Google Inc. nor the names of its
 12  * contributors may be used to endorse or promote products derived from
 13  * this software without specific prior written permission.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ShadowRoot.h&quot;
 30 
 31 #include &quot;CSSStyleSheet.h&quot;
 32 #include &quot;ElementTraversal.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;HTMLParserIdioms.h&quot;</span>
 34 #include &quot;HTMLSlotElement.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 36 #include &quot;NotImplemented.h&quot;</span>
<span class="line-added"> 37 #endif</span>
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;SlotAssignment.h&quot;
 41 #include &quot;StyleResolver.h&quot;
 42 #include &quot;StyleScope.h&quot;
 43 #include &quot;StyleSheetList.h&quot;
 44 #include &quot;markup.h&quot;
 45 #include &lt;wtf/IsoMallocInlines.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(ShadowRoot);
 50 
 51 struct SameSizeAsShadowRoot : public DocumentFragment, public TreeScope {
<a name="3" id="anc3"></a><span class="line-modified"> 52     bool flags[4];</span>
<span class="line-added"> 53     uint8_t mode;</span>
 54     void* styleScope;
 55     void* styleSheetList;
 56     void* host;
 57     void* slotAssignment;
<a name="4" id="anc4"></a><span class="line-added"> 58     Optional&lt;HashMap&lt;AtomString, AtomString&gt;&gt; partMappings;</span>
 59 };
 60 
 61 COMPILE_ASSERT(sizeof(ShadowRoot) == sizeof(SameSizeAsShadowRoot), shadowroot_should_stay_small);
 62 
<a name="5" id="anc5"></a><span class="line-modified"> 63 ShadowRoot::ShadowRoot(Document&amp; document, ShadowRootMode type, DelegatesFocus delegatesFocus)</span>
 64     : DocumentFragment(document, CreateShadowRoot)
 65     , TreeScope(*this, document)
<a name="6" id="anc6"></a><span class="line-added"> 66     , m_delegatesFocus(delegatesFocus == DelegatesFocus::Yes)</span>
 67     , m_type(type)
 68     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 69 {
 70 }
 71 
 72 
 73 ShadowRoot::ShadowRoot(Document&amp; document, std::unique_ptr&lt;SlotAssignment&gt;&amp;&amp; slotAssignment)
 74     : DocumentFragment(document, CreateShadowRoot)
 75     , TreeScope(*this, document)
 76     , m_type(ShadowRootMode::UserAgent)
 77     , m_styleScope(makeUnique&lt;Style::Scope&gt;(*this))
 78     , m_slotAssignment(WTFMove(slotAssignment))
 79 {
 80 }
 81 
 82 
 83 ShadowRoot::~ShadowRoot()
 84 {
 85     if (isConnected())
 86         document().didRemoveInDocumentShadowRoot(*this);
 87 
 88     if (m_styleSheetList)
 89         m_styleSheetList-&gt;detach();
 90 
 91     // We cannot let ContainerNode destructor call willBeDeletedFrom()
 92     // for this ShadowRoot instance because TreeScope destructor
 93     // clears Node::m_treeScope thus ContainerNode is no longer able
 94     // to access it Document reference after that.
 95     willBeDeletedFrom(document());
 96 
 97     ASSERT(!m_hasBegunDeletingDetachedChildren);
 98     m_hasBegunDeletingDetachedChildren = true;
 99 
100     // We must remove all of our children first before the TreeScope destructor
101     // runs so we don&#39;t go through Node::setTreeScopeRecursively for each child with a
102     // destructed tree scope in each descendant.
103     removeDetachedChildren();
104 }
105 
106 Node::InsertedIntoAncestorResult ShadowRoot::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
107 {
108     DocumentFragment::insertedIntoAncestor(insertionType, parentOfInsertedTree);
109     if (insertionType.connectedToDocument)
110         document().didInsertInDocumentShadowRoot(*this);
111     return InsertedIntoAncestorResult::Done;
112 }
113 
114 void ShadowRoot::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
115 {
116     DocumentFragment::removedFromAncestor(removalType, oldParentOfRemovedTree);
117     if (removalType.disconnectedFromDocument)
118         document().didRemoveInDocumentShadowRoot(*this);
119 }
120 
121 void ShadowRoot::childrenChanged(const ChildChange&amp; childChange)
122 {
123     DocumentFragment::childrenChanged(childChange);
124 
125     if (!m_host || m_type == ShadowRootMode::UserAgent)
126         return; // Don&#39;t support first-child, nth-of-type, etc... in UA shadow roots as an optimization.
127 
128     // FIXME: Avoid always invalidating style just for first-child, etc... as done in Element::childrenChanged.
129     switch (childChange.type) {
130     case ElementInserted:
131     case ElementRemoved:
132         m_host-&gt;invalidateStyleForSubtreeInternal();
133         break;
134     case TextInserted:
135     case TextRemoved:
136     case TextChanged:
137     case AllChildrenRemoved:
138     case NonContentsChildRemoved:
139     case NonContentsChildInserted:
140     case AllChildrenReplaced:
141         break;
142     }
143 }
144 
145 void ShadowRoot::moveShadowRootToNewParentScope(TreeScope&amp; newScope, Document&amp; newDocument)
146 {
147     setParentTreeScope(newScope);
148     moveShadowRootToNewDocument(newDocument);
149 }
150 
151 void ShadowRoot::moveShadowRootToNewDocument(Document&amp; newDocument)
152 {
153     setDocumentScope(newDocument);
154     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!parentTreeScope() || &amp;parentTreeScope()-&gt;documentScope() == &amp;newDocument);
155 
156     // Style scopes are document specific.
157     m_styleScope = makeUnique&lt;Style::Scope&gt;(*this);
158     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(&amp;m_styleScope-&gt;document() == &amp;newDocument);
159 }
160 
161 Style::Scope&amp; ShadowRoot::styleScope()
162 {
163     return *m_styleScope;
164 }
165 
166 StyleSheetList&amp; ShadowRoot::styleSheets()
167 {
168     if (!m_styleSheetList)
169         m_styleSheetList = StyleSheetList::create(*this);
170     return *m_styleSheetList;
171 }
172 
173 String ShadowRoot::innerHTML() const
174 {
175     return serializeFragment(*this, SerializedNodes::SubtreesOfChildren);
176 }
177 
178 ExceptionOr&lt;void&gt; ShadowRoot::setInnerHTML(const String&amp; markup)
179 {
180     auto fragment = createFragmentForInnerOuterHTML(*host(), markup, AllowScriptingContent);
181     if (fragment.hasException())
182         return fragment.releaseException();
183     return replaceChildrenWithFragment(*this, fragment.releaseReturnValue());
184 }
185 
186 bool ShadowRoot::childTypeAllowed(NodeType type) const
187 {
188     switch (type) {
189     case ELEMENT_NODE:
190     case PROCESSING_INSTRUCTION_NODE:
191     case COMMENT_NODE:
192     case TEXT_NODE:
193     case CDATA_SECTION_NODE:
194         return true;
195     default:
196         return false;
197     }
198 }
199 
200 void ShadowRoot::setResetStyleInheritance(bool value)
201 {
202     // If this was ever changed after initialization, child styles would need to be invalidated here.
203     m_resetStyleInheritance = value;
204 }
205 
206 Ref&lt;Node&gt; ShadowRoot::cloneNodeInternal(Document&amp;, CloningOperation)
207 {
208     RELEASE_ASSERT_NOT_REACHED();
209     return *static_cast&lt;Node*&gt;(nullptr); // ShadowRoots should never be cloned.
210 }
211 
212 void ShadowRoot::removeAllEventListeners()
213 {
214     DocumentFragment::removeAllEventListeners();
215     for (Node* node = firstChild(); node; node = NodeTraversal::next(*node))
216         node-&gt;removeAllEventListeners();
217 }
218 
219 
220 HTMLSlotElement* ShadowRoot::findAssignedSlot(const Node&amp; node)
221 {
222     ASSERT(node.parentNode() == host());
223     if (!m_slotAssignment)
224         return nullptr;
225     return m_slotAssignment-&gt;findAssignedSlot(node, *this);
226 }
227 
228 void ShadowRoot::renameSlotElement(HTMLSlotElement&amp; slot, const AtomString&amp; oldName, const AtomString&amp; newName)
229 {
230     ASSERT(m_slotAssignment);
231     return m_slotAssignment-&gt;renameSlotElement(slot, oldName, newName, *this);
232 }
233 
234 void ShadowRoot::addSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot)
235 {
236     ASSERT(&amp;slot.rootNode() == this);
237     if (!m_slotAssignment)
238         m_slotAssignment = makeUnique&lt;SlotAssignment&gt;();
239 
240     return m_slotAssignment-&gt;addSlotElementByName(name, slot, *this);
241 }
242 
243 void ShadowRoot::removeSlotElementByName(const AtomString&amp; name, HTMLSlotElement&amp; slot, ContainerNode&amp; oldParentOfRemovedTree)
244 {
245     ASSERT(m_slotAssignment);
246     return m_slotAssignment-&gt;removeSlotElementByName(name, slot, &amp;oldParentOfRemovedTree, *this);
247 }
248 
249 void ShadowRoot::slotFallbackDidChange(HTMLSlotElement&amp; slot)
250 {
251     ASSERT(&amp;slot.rootNode() == this);
252     return m_slotAssignment-&gt;slotFallbackDidChange(slot, *this);
253 }
254 
255 const Vector&lt;Node*&gt;* ShadowRoot::assignedNodesForSlot(const HTMLSlotElement&amp; slot)
256 {
257     if (!m_slotAssignment)
258         return nullptr;
259     return m_slotAssignment-&gt;assignedNodesForSlot(slot, *this);
260 }
261 
<a name="7" id="anc7"></a><span class="line-added">262 static Optional&lt;std::pair&lt;AtomString, AtomString&gt;&gt; parsePartMapping(StringView mappingString)</span>
<span class="line-added">263 {</span>
<span class="line-added">264     const auto end = mappingString.length();</span>
<span class="line-added">265 </span>
<span class="line-added">266     auto skipWhitespace = [&amp;](auto position) {</span>
<span class="line-added">267         while (position &lt; end &amp;&amp; isHTMLSpace(mappingString[position]))</span>
<span class="line-added">268             ++position;</span>
<span class="line-added">269         return position;</span>
<span class="line-added">270     };</span>
<span class="line-added">271 </span>
<span class="line-added">272     auto collectValue = [&amp;](auto position) {</span>
<span class="line-added">273         while (position &lt; end &amp;&amp; (!isHTMLSpace(mappingString[position]) &amp;&amp; mappingString[position] != &#39;:&#39;))</span>
<span class="line-added">274             ++position;</span>
<span class="line-added">275         return position;</span>
<span class="line-added">276     };</span>
<span class="line-added">277 </span>
<span class="line-added">278     size_t begin = 0;</span>
<span class="line-added">279     begin = skipWhitespace(begin);</span>
<span class="line-added">280 </span>
<span class="line-added">281     auto firstPartEnd = collectValue(begin);</span>
<span class="line-added">282     if (firstPartEnd == begin)</span>
<span class="line-added">283         return { };</span>
<span class="line-added">284 </span>
<span class="line-added">285     auto firstPart = mappingString.substring(begin, firstPartEnd - begin).toAtomString();</span>
<span class="line-added">286 </span>
<span class="line-added">287     begin = skipWhitespace(firstPartEnd);</span>
<span class="line-added">288     if (begin == end)</span>
<span class="line-added">289         return std::make_pair(firstPart, firstPart);</span>
<span class="line-added">290 </span>
<span class="line-added">291     if (mappingString[begin] != &#39;:&#39;)</span>
<span class="line-added">292         return { };</span>
<span class="line-added">293 </span>
<span class="line-added">294     begin = skipWhitespace(begin + 1);</span>
<span class="line-added">295 </span>
<span class="line-added">296     auto secondPartEnd = collectValue(begin);</span>
<span class="line-added">297     if (secondPartEnd == begin)</span>
<span class="line-added">298         return { };</span>
<span class="line-added">299 </span>
<span class="line-added">300     auto secondPart = mappingString.substring(begin, secondPartEnd - begin).toAtomString();</span>
<span class="line-added">301 </span>
<span class="line-added">302     begin = skipWhitespace(secondPartEnd);</span>
<span class="line-added">303     if (begin != end)</span>
<span class="line-added">304         return { };</span>
<span class="line-added">305 </span>
<span class="line-added">306     return std::make_pair(firstPart, secondPart);</span>
<span class="line-added">307 }</span>
<span class="line-added">308 </span>
<span class="line-added">309 static ShadowRoot::PartMappings parsePartMappingsList(StringView mappingsListString)</span>
<span class="line-added">310 {</span>
<span class="line-added">311     if (!RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="line-added">312         return { };</span>
<span class="line-added">313 </span>
<span class="line-added">314     ShadowRoot::PartMappings mappings;</span>
<span class="line-added">315 </span>
<span class="line-added">316     const auto end = mappingsListString.length();</span>
<span class="line-added">317 </span>
<span class="line-added">318     size_t begin = 0;</span>
<span class="line-added">319     while (begin &lt; end) {</span>
<span class="line-added">320         size_t mappingEnd = begin;</span>
<span class="line-added">321         while (mappingEnd &lt; end &amp;&amp; mappingsListString[mappingEnd] != &#39;,&#39;)</span>
<span class="line-added">322             ++mappingEnd;</span>
<span class="line-added">323 </span>
<span class="line-added">324         auto result = parsePartMapping(mappingsListString.substring(begin, mappingEnd - begin));</span>
<span class="line-added">325         if (result)</span>
<span class="line-added">326             mappings.add(result-&gt;first, Vector&lt;AtomString, 1&gt;()).iterator-&gt;value.append(result-&gt;second);</span>
<span class="line-added">327 </span>
<span class="line-added">328         if (mappingEnd == end)</span>
<span class="line-added">329             break;</span>
<span class="line-added">330 </span>
<span class="line-added">331         begin = mappingEnd + 1;</span>
<span class="line-added">332     }</span>
<span class="line-added">333 </span>
<span class="line-added">334     return mappings;</span>
<span class="line-added">335 }</span>
<span class="line-added">336 </span>
<span class="line-added">337 const ShadowRoot::PartMappings&amp; ShadowRoot::partMappings() const</span>
<span class="line-added">338 {</span>
<span class="line-added">339     if (!m_partMappings) {</span>
<span class="line-added">340         auto exportpartsValue = host()-&gt;attributeWithoutSynchronization(HTMLNames::exportpartsAttr);</span>
<span class="line-added">341         m_partMappings = parsePartMappingsList(exportpartsValue);</span>
<span class="line-added">342     }</span>
<span class="line-added">343 </span>
<span class="line-added">344     return *m_partMappings;</span>
<span class="line-added">345 }</span>
<span class="line-added">346 </span>
<span class="line-added">347 void ShadowRoot::invalidatePartMappings()</span>
<span class="line-added">348 {</span>
<span class="line-added">349     m_partMappings = { };</span>
<span class="line-added">350 }</span>
<span class="line-added">351 </span>
352 Vector&lt;ShadowRoot*&gt; assignedShadowRootsIfSlotted(const Node&amp; node)
353 {
354     Vector&lt;ShadowRoot*&gt; result;
355     for (auto* slot = node.assignedSlot(); slot; slot = slot-&gt;assignedSlot()) {
356         ASSERT(slot-&gt;containingShadowRoot());
357         result.append(slot-&gt;containingShadowRoot());
358     }
359     return result;
360 }
361 
<a name="8" id="anc8"></a><span class="line-added">362 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">363 HTMLVideoElement* ShadowRoot::pictureInPictureElement() const</span>
<span class="line-added">364 {</span>
<span class="line-added">365     notImplemented();</span>
<span class="line-added">366     return nullptr;</span>
<span class="line-added">367 }</span>
<span class="line-added">368 #endif</span>
<span class="line-added">369 </span>
370 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
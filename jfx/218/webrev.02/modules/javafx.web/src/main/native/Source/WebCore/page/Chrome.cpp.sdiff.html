<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/Chrome.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CaptionUserPreferencesMediaAF.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Chrome.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/Chrome.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 #include &quot;PageGroupLoadDeferrer.h&quot;
 45 #include &quot;PopupOpeningObserver.h&quot;
 46 #include &quot;RenderObject.h&quot;
 47 #include &quot;ResourceHandle.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;ShareData.h&quot;
 50 #include &quot;StorageNamespace.h&quot;
 51 #include &quot;WindowFeatures.h&quot;
 52 #include &lt;JavaScriptCore/VM.h&gt;
 53 #include &lt;wtf/SetForScope.h&gt;
 54 #include &lt;wtf/Vector.h&gt;
 55 
 56 #if ENABLE(INPUT_TYPE_COLOR)
 57 #include &quot;ColorChooser.h&quot;
 58 #endif
 59 
 60 #if ENABLE(DATALIST_ELEMENT)
 61 #include &quot;DataListSuggestionPicker.h&quot;
 62 #endif
 63 
<span class="line-modified"> 64 #if PLATFORM(MAC) &amp;&amp; ENABLE(GRAPHICS_CONTEXT_3D)</span>
<span class="line-modified"> 65 #include &quot;GraphicsContext3DManager.h&quot;</span>
 66 #endif
 67 
 68 namespace WebCore {
 69 
 70 using namespace HTMLNames;
 71 
 72 Chrome::Chrome(Page&amp; page, ChromeClient&amp; client)
 73     : m_page(page)
 74     , m_client(client)
 75 {
 76 }
 77 
 78 Chrome::~Chrome()
 79 {
 80     m_client.chromeDestroyed();
 81 }
 82 
 83 void Chrome::invalidateRootView(const IntRect&amp; updateRect)
 84 {
 85     m_client.invalidateRootView(updateRect);
</pre>
<hr />
<pre>
171     m_client.takeFocus(direction);
172 }
173 
174 void Chrome::focusedElementChanged(Element* element) const
175 {
176     m_client.focusedElementChanged(element);
177 }
178 
179 void Chrome::focusedFrameChanged(Frame* frame) const
180 {
181     m_client.focusedFrameChanged(frame);
182 }
183 
184 Page* Chrome::createWindow(Frame&amp; frame, const FrameLoadRequest&amp; request, const WindowFeatures&amp; features, const NavigationAction&amp; action) const
185 {
186     Page* newPage = m_client.createWindow(frame, request, features, action);
187     if (!newPage)
188         return nullptr;
189 
190     if (auto* oldSessionStorage = m_page.sessionStorage(false))
<span class="line-modified">191         newPage-&gt;setSessionStorage(oldSessionStorage-&gt;copy(newPage));</span>
192 
193     return newPage;
194 }
195 
196 void Chrome::show() const
197 {
198     m_client.show();
199 }
200 
201 bool Chrome::canRunModal() const
202 {
203     return m_client.canRunModal();
204 }
205 
206 void Chrome::runModal() const
207 {
208     // Defer callbacks in all the other pages in this group, so we don&#39;t try to run JavaScript
209     // in a way that could interact with this view.
210     PageGroupLoadDeferrer deferrer(m_page, false);
211 
</pre>
<hr />
<pre>
311 
312     notifyPopupOpeningObservers();
313     String displayPrompt = frame.displayStringModifiedByEncoding(prompt);
314 
315     bool ok = m_client.runJavaScriptPrompt(frame, displayPrompt, frame.displayStringModifiedByEncoding(defaultValue), result);
316     if (ok)
317         result = frame.displayStringModifiedByEncoding(result);
318 
319     return ok;
320 }
321 
322 void Chrome::setStatusbarText(Frame&amp; frame, const String&amp; status)
323 {
324     m_client.setStatusbarText(frame.displayStringModifiedByEncoding(status));
325 }
326 
327 void Chrome::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned modifierFlags)
328 {
329     if (result.innerNode() &amp;&amp; result.innerNode()-&gt;document().isDNSPrefetchEnabled())
330         m_page.mainFrame().loader().client().prefetchDNS(result.absoluteLinkURL().host().toString());
<span class="line-modified">331     m_client.mouseDidMoveOverElement(result, modifierFlags);</span>




332 
333     InspectorInstrumentation::mouseDidMoveOverElement(m_page, result, modifierFlags);
334 }
335 
<span class="line-modified">336 void Chrome::setToolTip(const HitTestResult&amp; result)</span>
337 {
338     // First priority is a potential toolTip representing a spelling or grammar error
<span class="line-modified">339     TextDirection toolTipDirection;</span>
<span class="line-removed">340     String toolTip = result.spellingToolTip(toolTipDirection);</span>
341 
342     // Next priority is a toolTip from a URL beneath the mouse (if preference is set to show those).
343     if (toolTip.isEmpty() &amp;&amp; m_page.settings().showsURLsInToolTips()) {
344         if (Element* element = result.innerNonSharedElement()) {
345             // Get tooltip representing form action, if relevant
346             if (is&lt;HTMLInputElement&gt;(*element)) {
347                 HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
348                 if (input.isSubmitButton()) {
349                     if (HTMLFormElement* form = input.form()) {
350                         toolTip = form-&gt;action();
351                         if (form-&gt;renderer())
352                             toolTipDirection = form-&gt;renderer()-&gt;style().direction();
353                         else
354                             toolTipDirection = TextDirection::LTR;
355                     }
356                 }
357             }
358         }
359 
360         // Get tooltip representing link&#39;s URL
</pre>
<hr />
<pre>
365             toolTipDirection = TextDirection::LTR;
366         }
367     }
368 
369     // Next we&#39;ll consider a tooltip for element with &quot;title&quot; attribute
370     if (toolTip.isEmpty())
371         toolTip = result.title(toolTipDirection);
372 
373     if (toolTip.isEmpty() &amp;&amp; m_page.settings().showsToolTipOverTruncatedText())
374         toolTip = result.innerTextIfTruncated(toolTipDirection);
375 
376     // Lastly, for &lt;input type=&quot;file&quot;&gt; that allow multiple files, we&#39;ll consider a tooltip for the selected filenames
377     if (toolTip.isEmpty()) {
378         if (Element* element = result.innerNonSharedElement()) {
379             if (is&lt;HTMLInputElement&gt;(*element)) {
380                 toolTip = downcast&lt;HTMLInputElement&gt;(*element).defaultToolTip();
381 
382                 // FIXME: We should obtain text direction of tooltip from
383                 // ChromeClient or platform. As of October 2011, all client
384                 // implementations don&#39;t use text direction information for
<span class="line-modified">385                 // ChromeClient::setToolTip. We&#39;ll work on tooltip text</span>
386                 // direction during bidi cleanup in form inputs.
387                 toolTipDirection = TextDirection::LTR;
388             }
389         }
390     }
<span class="line-removed">391 </span>
<span class="line-removed">392     m_client.setToolTip(toolTip, toolTipDirection);</span>
393 }
394 
395 bool Chrome::print(Frame&amp; frame)
396 {
397     // FIXME: This should have PageGroupLoadDeferrer, like runModal() or runJavaScriptAlert(), because it&#39;s no different from those.
398 
399     if (frame.document()-&gt;isSandboxed(SandboxModals)) {
400         frame.document()-&gt;domWindow()-&gt;printErrorMessage(&quot;Use of window.print is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
401         return false;
402     }
403 
404     m_client.print(frame);
405     return true;
406 }
407 
408 void Chrome::enableSuddenTermination()
409 {
410     m_client.enableSuddenTermination();
411 }
412 
</pre>
<hr />
<pre>
468 {
469     return m_client.overrideScreenSize();
470 }
471 
472 void Chrome::dispatchDisabledAdaptationsDidChange(const OptionSet&lt;DisabledAdaptations&gt;&amp; disabledAdaptations) const
473 {
474     m_client.dispatchDisabledAdaptationsDidChange(disabledAdaptations);
475 }
476 
477 void Chrome::dispatchViewportPropertiesDidChange(const ViewportArguments&amp; arguments) const
478 {
479 #if PLATFORM(IOS_FAMILY)
480     if (m_isDispatchViewportDataDidChangeSuppressed)
481         return;
482 #endif
483     m_client.dispatchViewportPropertiesDidChange(arguments);
484 }
485 
486 void Chrome::setCursor(const Cursor&amp; cursor)
487 {
<span class="line-removed">488 #if ENABLE(CURSOR_SUPPORT)</span>
489     m_client.setCursor(cursor);
<span class="line-removed">490 #else</span>
<span class="line-removed">491     UNUSED_PARAM(cursor);</span>
<span class="line-removed">492 #endif</span>
493 }
494 
495 void Chrome::setCursorHiddenUntilMouseMoves(bool hiddenUntilMouseMoves)
496 {
<span class="line-removed">497 #if ENABLE(CURSOR_SUPPORT)</span>
498     m_client.setCursorHiddenUntilMouseMoves(hiddenUntilMouseMoves);
<span class="line-removed">499 #else</span>
<span class="line-removed">500     UNUSED_PARAM(hiddenUntilMouseMoves);</span>
<span class="line-removed">501 #endif</span>
502 }
503 
504 PlatformDisplayID Chrome::displayID() const
505 {
506     return m_displayID;
507 }
508 
509 void Chrome::windowScreenDidChange(PlatformDisplayID displayID)
510 {
511     if (displayID == m_displayID)
512         return;
513 
514     m_displayID = displayID;
515 
516     for (Frame* frame = &amp;m_page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
517         if (frame-&gt;document())
518             frame-&gt;document()-&gt;windowScreenDidChange(displayID);
519     }
520 
<span class="line-modified">521 #if PLATFORM(MAC) &amp;&amp; ENABLE(GRAPHICS_CONTEXT_3D)</span>
<span class="line-modified">522     GraphicsContext3DManager::sharedManager().screenDidChange(displayID, this);</span>





523 #endif
524 }
525 
526 bool Chrome::selectItemWritingDirectionIsNatural()
527 {
528     return m_client.selectItemWritingDirectionIsNatural();
529 }
530 
531 bool Chrome::selectItemAlignmentFollowsMenuWritingDirection()
532 {
533     return m_client.selectItemAlignmentFollowsMenuWritingDirection();
534 }
535 
536 RefPtr&lt;PopupMenu&gt; Chrome::createPopupMenu(PopupMenuClient&amp; client) const
537 {
538     notifyPopupOpeningObservers();
539     return m_client.createPopupMenu(client);
540 }
541 
542 RefPtr&lt;SearchPopupMenu&gt; Chrome::createSearchPopupMenu(PopupMenuClient&amp; client) const
</pre>
</td>
<td>
<hr />
<pre>
 44 #include &quot;PageGroupLoadDeferrer.h&quot;
 45 #include &quot;PopupOpeningObserver.h&quot;
 46 #include &quot;RenderObject.h&quot;
 47 #include &quot;ResourceHandle.h&quot;
 48 #include &quot;Settings.h&quot;
 49 #include &quot;ShareData.h&quot;
 50 #include &quot;StorageNamespace.h&quot;
 51 #include &quot;WindowFeatures.h&quot;
 52 #include &lt;JavaScriptCore/VM.h&gt;
 53 #include &lt;wtf/SetForScope.h&gt;
 54 #include &lt;wtf/Vector.h&gt;
 55 
 56 #if ENABLE(INPUT_TYPE_COLOR)
 57 #include &quot;ColorChooser.h&quot;
 58 #endif
 59 
 60 #if ENABLE(DATALIST_ELEMENT)
 61 #include &quot;DataListSuggestionPicker.h&quot;
 62 #endif
 63 
<span class="line-modified"> 64 #if PLATFORM(MAC) &amp;&amp; ENABLE(GRAPHICS_CONTEXT_GL)</span>
<span class="line-modified"> 65 #include &quot;GraphicsContextGLOpenGLManager.h&quot;</span>
 66 #endif
 67 
 68 namespace WebCore {
 69 
 70 using namespace HTMLNames;
 71 
 72 Chrome::Chrome(Page&amp; page, ChromeClient&amp; client)
 73     : m_page(page)
 74     , m_client(client)
 75 {
 76 }
 77 
 78 Chrome::~Chrome()
 79 {
 80     m_client.chromeDestroyed();
 81 }
 82 
 83 void Chrome::invalidateRootView(const IntRect&amp; updateRect)
 84 {
 85     m_client.invalidateRootView(updateRect);
</pre>
<hr />
<pre>
171     m_client.takeFocus(direction);
172 }
173 
174 void Chrome::focusedElementChanged(Element* element) const
175 {
176     m_client.focusedElementChanged(element);
177 }
178 
179 void Chrome::focusedFrameChanged(Frame* frame) const
180 {
181     m_client.focusedFrameChanged(frame);
182 }
183 
184 Page* Chrome::createWindow(Frame&amp; frame, const FrameLoadRequest&amp; request, const WindowFeatures&amp; features, const NavigationAction&amp; action) const
185 {
186     Page* newPage = m_client.createWindow(frame, request, features, action);
187     if (!newPage)
188         return nullptr;
189 
190     if (auto* oldSessionStorage = m_page.sessionStorage(false))
<span class="line-modified">191         newPage-&gt;setSessionStorage(oldSessionStorage-&gt;copy(*newPage));</span>
192 
193     return newPage;
194 }
195 
196 void Chrome::show() const
197 {
198     m_client.show();
199 }
200 
201 bool Chrome::canRunModal() const
202 {
203     return m_client.canRunModal();
204 }
205 
206 void Chrome::runModal() const
207 {
208     // Defer callbacks in all the other pages in this group, so we don&#39;t try to run JavaScript
209     // in a way that could interact with this view.
210     PageGroupLoadDeferrer deferrer(m_page, false);
211 
</pre>
<hr />
<pre>
311 
312     notifyPopupOpeningObservers();
313     String displayPrompt = frame.displayStringModifiedByEncoding(prompt);
314 
315     bool ok = m_client.runJavaScriptPrompt(frame, displayPrompt, frame.displayStringModifiedByEncoding(defaultValue), result);
316     if (ok)
317         result = frame.displayStringModifiedByEncoding(result);
318 
319     return ok;
320 }
321 
322 void Chrome::setStatusbarText(Frame&amp; frame, const String&amp; status)
323 {
324     m_client.setStatusbarText(frame.displayStringModifiedByEncoding(status));
325 }
326 
327 void Chrome::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned modifierFlags)
328 {
329     if (result.innerNode() &amp;&amp; result.innerNode()-&gt;document().isDNSPrefetchEnabled())
330         m_page.mainFrame().loader().client().prefetchDNS(result.absoluteLinkURL().host().toString());
<span class="line-modified">331 </span>
<span class="line-added">332     String toolTip;</span>
<span class="line-added">333     TextDirection toolTipDirection;</span>
<span class="line-added">334     getToolTip(result, toolTip, toolTipDirection);</span>
<span class="line-added">335     m_client.mouseDidMoveOverElement(result, modifierFlags, toolTip, toolTipDirection);</span>
336 
337     InspectorInstrumentation::mouseDidMoveOverElement(m_page, result, modifierFlags);
338 }
339 
<span class="line-modified">340 void Chrome::getToolTip(const HitTestResult&amp; result, String&amp; toolTip, TextDirection&amp; toolTipDirection)</span>
341 {
342     // First priority is a potential toolTip representing a spelling or grammar error
<span class="line-modified">343     toolTip = result.spellingToolTip(toolTipDirection);</span>

344 
345     // Next priority is a toolTip from a URL beneath the mouse (if preference is set to show those).
346     if (toolTip.isEmpty() &amp;&amp; m_page.settings().showsURLsInToolTips()) {
347         if (Element* element = result.innerNonSharedElement()) {
348             // Get tooltip representing form action, if relevant
349             if (is&lt;HTMLInputElement&gt;(*element)) {
350                 HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*element);
351                 if (input.isSubmitButton()) {
352                     if (HTMLFormElement* form = input.form()) {
353                         toolTip = form-&gt;action();
354                         if (form-&gt;renderer())
355                             toolTipDirection = form-&gt;renderer()-&gt;style().direction();
356                         else
357                             toolTipDirection = TextDirection::LTR;
358                     }
359                 }
360             }
361         }
362 
363         // Get tooltip representing link&#39;s URL
</pre>
<hr />
<pre>
368             toolTipDirection = TextDirection::LTR;
369         }
370     }
371 
372     // Next we&#39;ll consider a tooltip for element with &quot;title&quot; attribute
373     if (toolTip.isEmpty())
374         toolTip = result.title(toolTipDirection);
375 
376     if (toolTip.isEmpty() &amp;&amp; m_page.settings().showsToolTipOverTruncatedText())
377         toolTip = result.innerTextIfTruncated(toolTipDirection);
378 
379     // Lastly, for &lt;input type=&quot;file&quot;&gt; that allow multiple files, we&#39;ll consider a tooltip for the selected filenames
380     if (toolTip.isEmpty()) {
381         if (Element* element = result.innerNonSharedElement()) {
382             if (is&lt;HTMLInputElement&gt;(*element)) {
383                 toolTip = downcast&lt;HTMLInputElement&gt;(*element).defaultToolTip();
384 
385                 // FIXME: We should obtain text direction of tooltip from
386                 // ChromeClient or platform. As of October 2011, all client
387                 // implementations don&#39;t use text direction information for
<span class="line-modified">388                 // ChromeClient::mouseDidMoveOverElement. We&#39;ll work on tooltip text</span>
389                 // direction during bidi cleanup in form inputs.
390                 toolTipDirection = TextDirection::LTR;
391             }
392         }
393     }


394 }
395 
396 bool Chrome::print(Frame&amp; frame)
397 {
398     // FIXME: This should have PageGroupLoadDeferrer, like runModal() or runJavaScriptAlert(), because it&#39;s no different from those.
399 
400     if (frame.document()-&gt;isSandboxed(SandboxModals)) {
401         frame.document()-&gt;domWindow()-&gt;printErrorMessage(&quot;Use of window.print is not allowed in a sandboxed frame when the allow-modals flag is not set.&quot;);
402         return false;
403     }
404 
405     m_client.print(frame);
406     return true;
407 }
408 
409 void Chrome::enableSuddenTermination()
410 {
411     m_client.enableSuddenTermination();
412 }
413 
</pre>
<hr />
<pre>
469 {
470     return m_client.overrideScreenSize();
471 }
472 
473 void Chrome::dispatchDisabledAdaptationsDidChange(const OptionSet&lt;DisabledAdaptations&gt;&amp; disabledAdaptations) const
474 {
475     m_client.dispatchDisabledAdaptationsDidChange(disabledAdaptations);
476 }
477 
478 void Chrome::dispatchViewportPropertiesDidChange(const ViewportArguments&amp; arguments) const
479 {
480 #if PLATFORM(IOS_FAMILY)
481     if (m_isDispatchViewportDataDidChangeSuppressed)
482         return;
483 #endif
484     m_client.dispatchViewportPropertiesDidChange(arguments);
485 }
486 
487 void Chrome::setCursor(const Cursor&amp; cursor)
488 {

489     m_client.setCursor(cursor);



490 }
491 
492 void Chrome::setCursorHiddenUntilMouseMoves(bool hiddenUntilMouseMoves)
493 {

494     m_client.setCursorHiddenUntilMouseMoves(hiddenUntilMouseMoves);



495 }
496 
497 PlatformDisplayID Chrome::displayID() const
498 {
499     return m_displayID;
500 }
501 
502 void Chrome::windowScreenDidChange(PlatformDisplayID displayID)
503 {
504     if (displayID == m_displayID)
505         return;
506 
507     m_displayID = displayID;
508 
509     for (Frame* frame = &amp;m_page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
510         if (frame-&gt;document())
511             frame-&gt;document()-&gt;windowScreenDidChange(displayID);
512     }
513 
<span class="line-modified">514 #if USE(REQUEST_ANIMATION_FRAME_DISPLAY_MONITOR)</span>
<span class="line-modified">515     m_page.renderingUpdateScheduler().windowScreenDidChange(displayID);</span>
<span class="line-added">516 #endif</span>
<span class="line-added">517     m_page.setNeedsRecalcStyleInAllFrames();</span>
<span class="line-added">518 </span>
<span class="line-added">519 #if PLATFORM(MAC) &amp;&amp; ENABLE(GRAPHICS_CONTEXT_GL)</span>
<span class="line-added">520     GraphicsContextGLOpenGLManager::sharedManager().screenDidChange(displayID, this);</span>
521 #endif
522 }
523 
524 bool Chrome::selectItemWritingDirectionIsNatural()
525 {
526     return m_client.selectItemWritingDirectionIsNatural();
527 }
528 
529 bool Chrome::selectItemAlignmentFollowsMenuWritingDirection()
530 {
531     return m_client.selectItemAlignmentFollowsMenuWritingDirection();
532 }
533 
534 RefPtr&lt;PopupMenu&gt; Chrome::createPopupMenu(PopupMenuClient&amp; client) const
535 {
536     notifyPopupOpeningObservers();
537     return m_client.createPopupMenu(client);
538 }
539 
540 RefPtr&lt;SearchPopupMenu&gt; Chrome::createSearchPopupMenu(PopupMenuClient&amp; client) const
</pre>
</td>
</tr>
</table>
<center><a href="CaptionUserPreferencesMediaAF.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Chrome.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
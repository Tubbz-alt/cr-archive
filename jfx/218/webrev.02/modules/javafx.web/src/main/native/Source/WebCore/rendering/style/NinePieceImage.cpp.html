<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/NinePieceImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
  3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2003-2017 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;NinePieceImage.h&quot;
 26 
 27 #include &quot;GraphicsContext.h&quot;
 28 #include &quot;ImageQualityController.h&quot;
 29 #include &quot;LengthFunctions.h&quot;
 30 #include &quot;RenderStyle.h&quot;
 31 #include &lt;wtf/NeverDestroyed.h&gt;
 32 #include &lt;wtf/PointerComparison.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 inline DataRef&lt;NinePieceImage::Data&gt;&amp; NinePieceImage::defaultData()
 38 {
 39     static NeverDestroyed&lt;DataRef&lt;Data&gt;&gt; data { Data::create() };
 40     return data.get();
 41 }
 42 
 43 inline DataRef&lt;NinePieceImage::Data&gt;&amp; NinePieceImage::defaultMaskData()
 44 {
 45     static NeverDestroyed&lt;DataRef&lt;Data&gt;&gt; maskData { Data::create() };
 46     auto&amp; data = maskData.get().access();
 47     data.imageSlices = LengthBox(0);
 48     data.fill = true;
 49     data.borderSlices = LengthBox();
 50     return maskData.get();
 51 }
 52 
 53 NinePieceImage::NinePieceImage(Type imageType)
 54     : m_data(imageType == Type::Normal ? defaultData() : defaultMaskData())
 55 {
 56 }
 57 
 58 NinePieceImage::NinePieceImage(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)
 59     : m_data(Data::create(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule))
 60 {
 61 }
 62 
 63 LayoutUnit NinePieceImage::computeSlice(Length length, LayoutUnit width, LayoutUnit slice, LayoutUnit extent)
 64 {
 65     if (length.isRelative())
 66         return LayoutUnit(length.value() * width);
 67     if (length.isAuto())
 68         return slice;
 69     return valueForLength(length, extent);
 70 }
 71 
 72 LayoutBoxExtent NinePieceImage::computeSlices(const LayoutSize&amp; size, const LengthBox&amp; lengths, int scaleFactor)
 73 {
 74     return {
 75         std::min(size.height(), valueForLength(lengths.top(), size.height())) * scaleFactor,
 76         std::min(size.width(), valueForLength(lengths.right(), size.width()))  * scaleFactor,
 77         std::min(size.height(), valueForLength(lengths.bottom(), size.height())) * scaleFactor,
 78         std::min(size.width(), valueForLength(lengths.left(), size.width()))  * scaleFactor
 79     };
 80 }
 81 
 82 LayoutBoxExtent NinePieceImage::computeSlices(const LayoutSize&amp; size, const LengthBox&amp; lengths, const FloatBoxExtent&amp; widths, const LayoutBoxExtent&amp; slices)
 83 {
 84     return {
 85         computeSlice(lengths.top(), LayoutUnit(widths.top()), slices.top(), size.height()),
 86         computeSlice(lengths.right(), LayoutUnit(widths.right()), slices.right(), size.width()),
 87         computeSlice(lengths.bottom(), LayoutUnit(widths.bottom()), slices.bottom(), size.height()),
 88         computeSlice(lengths.left(), LayoutUnit(widths.left()), slices.left(), size.width())
 89     };
 90 }
 91 
 92 void NinePieceImage::scaleSlicesIfNeeded(const LayoutSize&amp; size, LayoutBoxExtent&amp; slices, float deviceScaleFactor)
 93 {
 94     LayoutUnit width  = std::max(LayoutUnit(1 / deviceScaleFactor), slices.left() + slices.right());
 95     LayoutUnit height = std::max(LayoutUnit(1 / deviceScaleFactor), slices.top() + slices.bottom());
 96 
 97     float sliceScaleFactor = std::min((float)size.width() / width, (float)size.height() / height);
 98 
 99     if (sliceScaleFactor &gt;= 1)
100         return;
101 
102     // All slices are reduced by multiplying them by sliceScaleFactor.
103     slices.top()    *= sliceScaleFactor;
104     slices.right()  *= sliceScaleFactor;
105     slices.bottom() *= sliceScaleFactor;
106     slices.left()   *= sliceScaleFactor;
107 }
108 
109 bool NinePieceImage::isEmptyPieceRect(ImagePiece piece, const LayoutBoxExtent&amp; slices)
110 {
111     if (piece == MiddlePiece)
112         return false;
113 
114     auto horizontalSide = imagePieceHorizontalSide(piece);
115     auto verticalSide = imagePieceVerticalSide(piece);
116     return !((!horizontalSide || slices.at(*horizontalSide)) &amp;&amp; (!verticalSide || slices.at(*verticalSide)));
117 }
118 
119 bool NinePieceImage::isEmptyPieceRect(ImagePiece piece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects)
120 {
121     return destinationRects[piece].isEmpty() || sourceRects[piece].isEmpty();
122 }
123 
124 Vector&lt;FloatRect&gt; NinePieceImage::computeNineRects(const FloatRect&amp; outer, const LayoutBoxExtent&amp; slices, float deviceScaleFactor)
125 {
126     FloatRect inner = outer;
127     inner.move(slices.left(), slices.top());
128     inner.contract(slices.left() + slices.right(), slices.top() + slices.bottom());
129     ASSERT(outer.contains(inner));
130 
131     Vector&lt;FloatRect&gt; rects(MaxPiece);
132 
133     rects[TopLeftPiece] = snapRectToDevicePixels(LayoutUnit(outer.x()), LayoutUnit(outer.y()), slices.left(), slices.top(), deviceScaleFactor);
134     rects[BottomLeftPiece] = snapRectToDevicePixels(LayoutUnit(outer.x()), LayoutUnit(inner.maxY()), slices.left(), slices.bottom(), deviceScaleFactor);
135     rects[LeftPiece] = snapRectToDevicePixels(LayoutUnit(outer.x()), LayoutUnit(inner.y()), slices.left(), LayoutUnit(inner.height()), deviceScaleFactor);
136 
137     rects[TopRightPiece] = snapRectToDevicePixels(LayoutUnit(inner.maxX()), LayoutUnit(outer.y()), slices.right(), slices.top(), deviceScaleFactor);
138     rects[BottomRightPiece] = snapRectToDevicePixels(LayoutUnit(inner.maxX()), LayoutUnit(inner.maxY()), slices.right(), slices.bottom(), deviceScaleFactor);
139     rects[RightPiece] = snapRectToDevicePixels(LayoutUnit(inner.maxX()), LayoutUnit(inner.y()), slices.right(), LayoutUnit(inner.height()), deviceScaleFactor);
140 
141     rects[TopPiece] = snapRectToDevicePixels(LayoutUnit(inner.x()), LayoutUnit(outer.y()), LayoutUnit(inner.width()), slices.top(), deviceScaleFactor);
142     rects[BottomPiece] = snapRectToDevicePixels(LayoutUnit(inner.x()), LayoutUnit(inner.maxY()), LayoutUnit(inner.width()), slices.bottom(), deviceScaleFactor);
143 
144     rects[MiddlePiece] = snapRectToDevicePixels(LayoutUnit(inner.x()), LayoutUnit(inner.y()), LayoutUnit(inner.width()), LayoutUnit(inner.height()), deviceScaleFactor);
145     return rects;
146 }
147 
148 FloatSize NinePieceImage::computeSideTileScale(ImagePiece piece, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects)
149 {
150     ASSERT(!isCornerPiece(piece) &amp;&amp; !isMiddlePiece(piece));
151     if (isEmptyPieceRect(piece, destinationRects, sourceRects))
152         return FloatSize(1, 1);
153 
154     float scale;
155     if (isHorizontalPiece(piece))
156         scale = destinationRects[piece].height() / sourceRects[piece].height();
157     else
158         scale = destinationRects[piece].width() / sourceRects[piece].width();
159 
160     return FloatSize(scale, scale);
161 }
162 
163 FloatSize NinePieceImage::computeMiddleTileScale(const Vector&lt;FloatSize&gt;&amp; scales, const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule)
164 {
165     FloatSize scale(1, 1);
166     if (isEmptyPieceRect(MiddlePiece, destinationRects, sourceRects))
167         return scale;
168 
169     // Unlike the side pieces, the middle piece can have &quot;stretch&quot; specified in one axis but not the other.
170     // In fact the side pieces don&#39;t even use the scale factor unless they have a rule other than &quot;stretch&quot;.
171     if (hRule == NinePieceImageRule::Stretch)
172         scale.setWidth(destinationRects[MiddlePiece].width() / sourceRects[MiddlePiece].width());
173     else if (!isEmptyPieceRect(TopPiece, destinationRects, sourceRects))
174         scale.setWidth(scales[TopPiece].width());
175     else if (!isEmptyPieceRect(BottomPiece, destinationRects, sourceRects))
176         scale.setWidth(scales[BottomPiece].width());
177 
178     if (vRule == NinePieceImageRule::Stretch)
179         scale.setHeight(destinationRects[MiddlePiece].height() / sourceRects[MiddlePiece].height());
180     else if (!isEmptyPieceRect(LeftPiece, destinationRects, sourceRects))
181         scale.setHeight(scales[LeftPiece].height());
182     else if (!isEmptyPieceRect(RightPiece, destinationRects, sourceRects))
183         scale.setHeight(scales[RightPiece].height());
184 
185     return scale;
186 }
187 
188 Vector&lt;FloatSize&gt; NinePieceImage::computeTileScales(const Vector&lt;FloatRect&gt;&amp; destinationRects, const Vector&lt;FloatRect&gt;&amp; sourceRects, NinePieceImageRule hRule, NinePieceImageRule vRule)
189 {
190     Vector&lt;FloatSize&gt; scales(MaxPiece, FloatSize(1, 1));
191 
192     scales[TopPiece]    = computeSideTileScale(TopPiece,    destinationRects, sourceRects);
193     scales[RightPiece]  = computeSideTileScale(RightPiece,  destinationRects, sourceRects);
194     scales[BottomPiece] = computeSideTileScale(BottomPiece, destinationRects, sourceRects);
195     scales[LeftPiece]   = computeSideTileScale(LeftPiece,   destinationRects, sourceRects);
196 
197     scales[MiddlePiece] = computeMiddleTileScale(scales, destinationRects, sourceRects, hRule, vRule);
198     return scales;
199 }
200 
201 void NinePieceImage::paint(GraphicsContext&amp; graphicsContext, RenderElement* renderer, const RenderStyle&amp; style, const LayoutRect&amp; destination, const LayoutSize&amp; source, float deviceScaleFactor, CompositeOperator op) const
202 {
203     StyleImage* styleImage = image();
204     ASSERT(styleImage);
205     ASSERT(styleImage-&gt;isLoaded());
206 
207     LayoutBoxExtent sourceSlices = computeSlices(source, imageSlices(), styleImage-&gt;imageScaleFactor());
208     LayoutBoxExtent destinationSlices = computeSlices(destination.size(), borderSlices(), style.borderWidth(), sourceSlices);
209 
210     scaleSlicesIfNeeded(destination.size(), destinationSlices, deviceScaleFactor);
211 
212     Vector&lt;FloatRect&gt; destinationRects = computeNineRects(destination, destinationSlices, deviceScaleFactor);
213     Vector&lt;FloatRect&gt; sourceRects = computeNineRects(FloatRect(FloatPoint(), source), sourceSlices, deviceScaleFactor);
214     Vector&lt;FloatSize&gt; tileScales = computeTileScales(destinationRects, sourceRects, horizontalRule(), verticalRule());
215 
216     RefPtr&lt;Image&gt; image = styleImage-&gt;image(renderer, source);
217     if (!image)
218         return;
219 
220     InterpolationQualityMaintainer interpolationMaintainer(graphicsContext, ImageQualityController::interpolationQualityFromStyle(style));
221     for (ImagePiece piece = MinPiece; piece &lt; MaxPiece; ++piece) {
222         if ((piece == MiddlePiece &amp;&amp; !fill()) || isEmptyPieceRect(piece, destinationRects, sourceRects))
223             continue;
224 
225         if (isCornerPiece(piece)) {
226             graphicsContext.drawImage(*image, destinationRects[piece], sourceRects[piece], { op, ImageOrientation::FromImage });
227             continue;
228         }
229 
230         Image::TileRule hRule = isHorizontalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(horizontalRule()) : Image::StretchTile;
231         Image::TileRule vRule = isVerticalPiece(piece) ? static_cast&lt;Image::TileRule&gt;(verticalRule()) : Image::StretchTile;
232         graphicsContext.drawTiledImage(*image, destinationRects[piece], sourceRects[piece], tileScales[piece], hRule, vRule, { op, ImageOrientation::FromImage });
233     }
234 }
235 
236 inline NinePieceImage::Data::Data() = default;
237 
238 inline NinePieceImage::Data::Data(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)
239     : fill(fill)
240     , horizontalRule(horizontalRule)
241     , verticalRule(verticalRule)
242     , image(WTFMove(image))
243     , imageSlices(imageSlices)
244     , borderSlices(borderSlices)
245     , outset(outset)
246 {
247 }
248 
249 inline NinePieceImage::Data::Data(const Data&amp; other)
250     : RefCounted&lt;Data&gt;()
251     , fill(other.fill)
252     , horizontalRule(other.horizontalRule)
253     , verticalRule(other.verticalRule)
254     , image(other.image)
255     , imageSlices(other.imageSlices)
256     , borderSlices(other.borderSlices)
257     , outset(other.outset)
258 {
259 }
260 
261 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create()
262 {
263     return adoptRef(*new Data);
264 }
265 
266 inline Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::create(RefPtr&lt;StyleImage&gt;&amp;&amp; image, LengthBox imageSlices, bool fill, LengthBox borderSlices, LengthBox outset, NinePieceImageRule horizontalRule, NinePieceImageRule verticalRule)
267 {
268     return adoptRef(*new Data(WTFMove(image), imageSlices, fill, borderSlices, outset, horizontalRule, verticalRule));
269 }
270 
271 Ref&lt;NinePieceImage::Data&gt; NinePieceImage::Data::copy() const
272 {
273     return adoptRef(*new Data(*this));
274 }
275 
276 bool NinePieceImage::Data::operator==(const Data&amp; other) const
277 {
278     return arePointingToEqualData(image, other.image)
279         &amp;&amp; imageSlices == other.imageSlices
280         &amp;&amp; fill == other.fill
281         &amp;&amp; borderSlices == other.borderSlices
282         &amp;&amp; outset == other.outset
283         &amp;&amp; horizontalRule == other.horizontalRule
284         &amp;&amp; verticalRule == other.verticalRule;
285 }
286 
287 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const NinePieceImage&amp; image)
288 {
289     ts &lt;&lt; &quot;style-image &quot; &lt;&lt; image.image() &lt;&lt; &quot; slices &quot; &lt;&lt; image.imageSlices();
290     return ts;
291 }
292 
293 }
    </pre>
  </body>
</html>
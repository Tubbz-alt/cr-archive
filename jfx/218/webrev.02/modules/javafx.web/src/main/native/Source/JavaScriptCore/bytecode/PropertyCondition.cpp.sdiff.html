<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PreciseJumpTargetsInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyCondition.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 }
 38 
 39 void PropertyCondition::dumpInContext(PrintStream&amp; out, DumpContext* context) const
 40 {
 41     if (!*this) {
 42         out.print(&quot;&lt;invalid&gt;&quot;);
 43         return;
 44     }
 45 
 46     switch (m_header.type()) {
 47     case Presence:
 48         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; at &quot;, offset(), &quot; with attributes &quot;, attributes());
 49         return;
 50     case Absence:
 51     case AbsenceOfSetEffect:
 52         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
 53         return;
 54     case Equivalence:
 55         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with &quot;, inContext(requiredValue(), context));
 56         return;



 57     case HasPrototype:
 58         out.print(m_header.type(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
 59         return;
 60     }
 61     RELEASE_ASSERT_NOT_REACHED();
 62 }
 63 
 64 void PropertyCondition::dump(PrintStream&amp; out) const
 65 {
 66     dumpInContext(out, nullptr);
 67 }
 68 
 69 bool PropertyCondition::isStillValidAssumingImpurePropertyWatchpoint(
 70     Structure* structure, JSObject* base) const
 71 {
 72     if (PropertyConditionInternal::verbose) {
 73         dataLog(
 74             &quot;Determining validity of &quot;, *this, &quot; with structure &quot;, pointerDump(structure), &quot; and base &quot;,
 75             JSValue(base), &quot; assuming impure property watchpoints are set.\n&quot;);
 76     }
 77 
 78     if (!*this) {
 79         if (PropertyConditionInternal::verbose)
 80             dataLog(&quot;Invalid because unset.\n&quot;);
 81         return false;
 82     }
 83 
 84     switch (m_header.type()) {
 85     case Presence:
 86     case Absence:
 87     case AbsenceOfSetEffect:
 88     case Equivalence:

 89         if (!structure-&gt;propertyAccessesAreCacheable()) {
 90             if (PropertyConditionInternal::verbose)
 91                 dataLog(&quot;Invalid because property accesses are not cacheable.\n&quot;);
 92             return false;
 93         }
 94         break;
 95 
 96     case HasPrototype:
 97         if (!structure-&gt;prototypeQueriesAreCacheable()) {
 98             if (PropertyConditionInternal::verbose)
 99                 dataLog(&quot;Invalid because prototype queries are not cacheable.\n&quot;);
100             return false;
101         }
102         break;
103     }
104 
105     switch (m_header.type()) {
106     case Presence: {
107         unsigned currentAttributes;
108         PropertyOffset currentOffset = structure-&gt;getConcurrently(uid(), currentAttributes);
</pre>
<hr />
<pre>
231         if (currentOffset == invalidOffset) {
232             if (PropertyConditionInternal::verbose) {
233                 dataLog(
234                     &quot;Invalid because the base no long appears to have &quot;, uid(), &quot; on its structure: &quot;,
235                         RawPointer(base), &quot;\n&quot;);
236             }
237             return false;
238         }
239 
240         JSValue currentValue = base-&gt;getDirectConcurrently(structure, currentOffset);
241         if (currentValue != requiredValue()) {
242             if (PropertyConditionInternal::verbose) {
243                 dataLog(
244                     &quot;Invalid because the value is &quot;, currentValue, &quot; but we require &quot;, requiredValue(),
245                     &quot;\n&quot;);
246             }
247             return false;
248         }
249 
250         return true;
<span class="line-modified">251     } }</span>






252 
253     RELEASE_ASSERT_NOT_REACHED();
254     return false;
255 }
256 
257 bool PropertyCondition::validityRequiresImpurePropertyWatchpoint(Structure* structure) const
258 {
259     if (!*this)
260         return false;
261 
262     switch (m_header.type()) {
263     case Presence:
264     case Absence:
265     case Equivalence:

266         return structure-&gt;needImpurePropertyWatchpoint();
267     case AbsenceOfSetEffect:
268     case HasPrototype:
269         return false;
270     }
271 
272     RELEASE_ASSERT_NOT_REACHED();
273     return false;
274 }
275 
276 bool PropertyCondition::isStillValid(Structure* structure, JSObject* base) const
277 {
278     if (!isStillValidAssumingImpurePropertyWatchpoint(structure, base))
279         return false;
280 
281     // Currently we assume that an impure property can cause a property to appear, and can also
282     // &quot;shadow&quot; an existing JS property on the same object. Hence it affects both presence and
283     // absence. It doesn&#39;t affect AbsenceOfSetEffect because impure properties aren&#39;t ever setters.
284     switch (m_header.type()) {
285     case Absence:
286         if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure() || structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
287             return false;
288         break;
289     case Presence:
290     case Equivalence:

291         if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure())
292             return false;
293         break;
294     default:
295         break;
296     }
297 
298     return true;
299 }
300 
301 bool PropertyCondition::isWatchableWhenValid(
302     Structure* structure, WatchabilityEffort effort) const
303 {
304     if (structure-&gt;transitionWatchpointSetHasBeenInvalidated())
305         return false;
306 
307     switch (m_header.type()) {
308     case Equivalence: {
309         PropertyOffset offset = structure-&gt;getConcurrently(uid());
310 
</pre>
<hr />
<pre>
313         // also have verified that the Structure is a cacheable dictionary, which means we
314         // shouldn&#39;t have a TOCTOU race either.
315         RELEASE_ASSERT(offset != invalidOffset);
316 
317         WatchpointSet* set = nullptr;
318         switch (effort) {
319         case MakeNoChanges:
320             set = structure-&gt;propertyReplacementWatchpointSet(offset);
321             break;
322         case EnsureWatchability:
323             set = structure-&gt;ensurePropertyReplacementWatchpointSet(structure-&gt;vm(), offset);
324             break;
325         }
326 
327         if (!set || !set-&gt;isStillValid())
328             return false;
329 
330         break;
331     }
332 















333     default:
334         break;
335     }
336 
337     return true;
338 }
339 
340 bool PropertyCondition::isWatchableAssumingImpurePropertyWatchpoint(
341     Structure* structure, JSObject* base, WatchabilityEffort effort) const
342 {
343     return isStillValidAssumingImpurePropertyWatchpoint(structure, base)
344         &amp;&amp; isWatchableWhenValid(structure, effort);
345 }
346 
347 bool PropertyCondition::isWatchable(
348     Structure* structure, JSObject* base, WatchabilityEffort effort) const
349 {
350     return isStillValid(structure, base)
351         &amp;&amp; isWatchableWhenValid(structure, effort);
352 }
353 
<span class="line-removed">354 bool PropertyCondition::isStillLive(VM&amp; vm) const</span>
<span class="line-removed">355 {</span>
<span class="line-removed">356     if (hasPrototype() &amp;&amp; prototype() &amp;&amp; !vm.heap.isMarked(prototype()))</span>
<span class="line-removed">357         return false;</span>
<span class="line-removed">358 </span>
<span class="line-removed">359     if (hasRequiredValue()</span>
<span class="line-removed">360         &amp;&amp; requiredValue()</span>
<span class="line-removed">361         &amp;&amp; requiredValue().isCell()</span>
<span class="line-removed">362         &amp;&amp; !vm.heap.isMarked(requiredValue().asCell()))</span>
<span class="line-removed">363         return false;</span>
<span class="line-removed">364 </span>
<span class="line-removed">365     return true;</span>
<span class="line-removed">366 }</span>
<span class="line-removed">367 </span>
368 void PropertyCondition::validateReferences(const TrackedReferences&amp; tracked) const
369 {
370     if (hasPrototype())
371         tracked.check(prototype());
372 
373     if (hasRequiredValue())
374         tracked.check(requiredValue());
375 }
376 
377 bool PropertyCondition::isValidValueForAttributes(VM&amp; vm, JSValue value, unsigned attributes)
378 {
379     if (!value)
380         return false;
381     bool attributesClaimAccessor = !!(attributes &amp; PropertyAttribute::Accessor);
382     bool valueClaimsAccessor = !!jsDynamicCast&lt;GetterSetter*&gt;(vm, value);
383     return attributesClaimAccessor == valueClaimsAccessor;
384 }
385 
386 bool PropertyCondition::isValidValueForPresence(VM&amp; vm, JSValue value) const
387 {
</pre>
<hr />
<pre>
400 
401 } // namespace JSC
402 
403 namespace WTF {
404 
405 void printInternal(PrintStream&amp; out, JSC::PropertyCondition::Kind condition)
406 {
407     switch (condition) {
408     case JSC::PropertyCondition::Presence:
409         out.print(&quot;Presence&quot;);
410         return;
411     case JSC::PropertyCondition::Absence:
412         out.print(&quot;Absence&quot;);
413         return;
414     case JSC::PropertyCondition::AbsenceOfSetEffect:
415         out.print(&quot;Absence&quot;);
416         return;
417     case JSC::PropertyCondition::Equivalence:
418         out.print(&quot;Equivalence&quot;);
419         return;



420     case JSC::PropertyCondition::HasPrototype:
421         out.print(&quot;HasPrototype&quot;);
422         return;
423     }
424     RELEASE_ASSERT_NOT_REACHED();
425 }
426 
427 } // namespace WTF
</pre>
</td>
<td>
<hr />
<pre>
 37 }
 38 
 39 void PropertyCondition::dumpInContext(PrintStream&amp; out, DumpContext* context) const
 40 {
 41     if (!*this) {
 42         out.print(&quot;&lt;invalid&gt;&quot;);
 43         return;
 44     }
 45 
 46     switch (m_header.type()) {
 47     case Presence:
 48         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; at &quot;, offset(), &quot; with attributes &quot;, attributes());
 49         return;
 50     case Absence:
 51     case AbsenceOfSetEffect:
 52         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
 53         return;
 54     case Equivalence:
 55         out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with &quot;, inContext(requiredValue(), context));
 56         return;
<span class="line-added"> 57     case CustomFunctionEquivalence:</span>
<span class="line-added"> 58         out.print(m_header.type(), &quot; of &quot;, m_header.pointer());</span>
<span class="line-added"> 59         return;</span>
 60     case HasPrototype:
 61         out.print(m_header.type(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
 62         return;
 63     }
 64     RELEASE_ASSERT_NOT_REACHED();
 65 }
 66 
 67 void PropertyCondition::dump(PrintStream&amp; out) const
 68 {
 69     dumpInContext(out, nullptr);
 70 }
 71 
 72 bool PropertyCondition::isStillValidAssumingImpurePropertyWatchpoint(
 73     Structure* structure, JSObject* base) const
 74 {
 75     if (PropertyConditionInternal::verbose) {
 76         dataLog(
 77             &quot;Determining validity of &quot;, *this, &quot; with structure &quot;, pointerDump(structure), &quot; and base &quot;,
 78             JSValue(base), &quot; assuming impure property watchpoints are set.\n&quot;);
 79     }
 80 
 81     if (!*this) {
 82         if (PropertyConditionInternal::verbose)
 83             dataLog(&quot;Invalid because unset.\n&quot;);
 84         return false;
 85     }
 86 
 87     switch (m_header.type()) {
 88     case Presence:
 89     case Absence:
 90     case AbsenceOfSetEffect:
 91     case Equivalence:
<span class="line-added"> 92     case CustomFunctionEquivalence:</span>
 93         if (!structure-&gt;propertyAccessesAreCacheable()) {
 94             if (PropertyConditionInternal::verbose)
 95                 dataLog(&quot;Invalid because property accesses are not cacheable.\n&quot;);
 96             return false;
 97         }
 98         break;
 99 
100     case HasPrototype:
101         if (!structure-&gt;prototypeQueriesAreCacheable()) {
102             if (PropertyConditionInternal::verbose)
103                 dataLog(&quot;Invalid because prototype queries are not cacheable.\n&quot;);
104             return false;
105         }
106         break;
107     }
108 
109     switch (m_header.type()) {
110     case Presence: {
111         unsigned currentAttributes;
112         PropertyOffset currentOffset = structure-&gt;getConcurrently(uid(), currentAttributes);
</pre>
<hr />
<pre>
235         if (currentOffset == invalidOffset) {
236             if (PropertyConditionInternal::verbose) {
237                 dataLog(
238                     &quot;Invalid because the base no long appears to have &quot;, uid(), &quot; on its structure: &quot;,
239                         RawPointer(base), &quot;\n&quot;);
240             }
241             return false;
242         }
243 
244         JSValue currentValue = base-&gt;getDirectConcurrently(structure, currentOffset);
245         if (currentValue != requiredValue()) {
246             if (PropertyConditionInternal::verbose) {
247                 dataLog(
248                     &quot;Invalid because the value is &quot;, currentValue, &quot; but we require &quot;, requiredValue(),
249                     &quot;\n&quot;);
250             }
251             return false;
252         }
253 
254         return true;
<span class="line-modified">255     }</span>
<span class="line-added">256     case CustomFunctionEquivalence: {</span>
<span class="line-added">257         if (structure-&gt;staticPropertiesReified())</span>
<span class="line-added">258             return false;</span>
<span class="line-added">259         return !!structure-&gt;findPropertyHashEntry(uid());</span>
<span class="line-added">260     }</span>
<span class="line-added">261     }</span>
262 
263     RELEASE_ASSERT_NOT_REACHED();
264     return false;
265 }
266 
267 bool PropertyCondition::validityRequiresImpurePropertyWatchpoint(Structure* structure) const
268 {
269     if (!*this)
270         return false;
271 
272     switch (m_header.type()) {
273     case Presence:
274     case Absence:
275     case Equivalence:
<span class="line-added">276     case CustomFunctionEquivalence:</span>
277         return structure-&gt;needImpurePropertyWatchpoint();
278     case AbsenceOfSetEffect:
279     case HasPrototype:
280         return false;
281     }
282 
283     RELEASE_ASSERT_NOT_REACHED();
284     return false;
285 }
286 
287 bool PropertyCondition::isStillValid(Structure* structure, JSObject* base) const
288 {
289     if (!isStillValidAssumingImpurePropertyWatchpoint(structure, base))
290         return false;
291 
292     // Currently we assume that an impure property can cause a property to appear, and can also
293     // &quot;shadow&quot; an existing JS property on the same object. Hence it affects both presence and
294     // absence. It doesn&#39;t affect AbsenceOfSetEffect because impure properties aren&#39;t ever setters.
295     switch (m_header.type()) {
296     case Absence:
297         if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure() || structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
298             return false;
299         break;
300     case Presence:
301     case Equivalence:
<span class="line-added">302     case CustomFunctionEquivalence:</span>
303         if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure())
304             return false;
305         break;
306     default:
307         break;
308     }
309 
310     return true;
311 }
312 
313 bool PropertyCondition::isWatchableWhenValid(
314     Structure* structure, WatchabilityEffort effort) const
315 {
316     if (structure-&gt;transitionWatchpointSetHasBeenInvalidated())
317         return false;
318 
319     switch (m_header.type()) {
320     case Equivalence: {
321         PropertyOffset offset = structure-&gt;getConcurrently(uid());
322 
</pre>
<hr />
<pre>
325         // also have verified that the Structure is a cacheable dictionary, which means we
326         // shouldn&#39;t have a TOCTOU race either.
327         RELEASE_ASSERT(offset != invalidOffset);
328 
329         WatchpointSet* set = nullptr;
330         switch (effort) {
331         case MakeNoChanges:
332             set = structure-&gt;propertyReplacementWatchpointSet(offset);
333             break;
334         case EnsureWatchability:
335             set = structure-&gt;ensurePropertyReplacementWatchpointSet(structure-&gt;vm(), offset);
336             break;
337         }
338 
339         if (!set || !set-&gt;isStillValid())
340             return false;
341 
342         break;
343     }
344 
<span class="line-added">345     case CustomFunctionEquivalence: {</span>
<span class="line-added">346         // We just use the structure transition watchpoint for this. A structure S starts</span>
<span class="line-added">347         // off with a property P in the static property hash table. If S transitions to</span>
<span class="line-added">348         // S&#39;, either P remains in the static property table or not. If not, then we</span>
<span class="line-added">349         // are no longer valid. So the above check of transitionWatchpointSetHasBeenInvalidated</span>
<span class="line-added">350         // is sufficient.</span>
<span class="line-added">351         //</span>
<span class="line-added">352         // We could make this smarter in the future, since we sometimes reify static properties.</span>
<span class="line-added">353         // We could make this adapt to looking at the object&#39;s storage for such reified custom</span>
<span class="line-added">354         // functions, but we don&#39;t do that right now. We just allow this property condition to</span>
<span class="line-added">355         // invalidate and create an Equivalence watchpoint for the materialized property sometime</span>
<span class="line-added">356         // in the future.</span>
<span class="line-added">357         break;</span>
<span class="line-added">358     }</span>
<span class="line-added">359 </span>
360     default:
361         break;
362     }
363 
364     return true;
365 }
366 
367 bool PropertyCondition::isWatchableAssumingImpurePropertyWatchpoint(
368     Structure* structure, JSObject* base, WatchabilityEffort effort) const
369 {
370     return isStillValidAssumingImpurePropertyWatchpoint(structure, base)
371         &amp;&amp; isWatchableWhenValid(structure, effort);
372 }
373 
374 bool PropertyCondition::isWatchable(
375     Structure* structure, JSObject* base, WatchabilityEffort effort) const
376 {
377     return isStillValid(structure, base)
378         &amp;&amp; isWatchableWhenValid(structure, effort);
379 }
380 














381 void PropertyCondition::validateReferences(const TrackedReferences&amp; tracked) const
382 {
383     if (hasPrototype())
384         tracked.check(prototype());
385 
386     if (hasRequiredValue())
387         tracked.check(requiredValue());
388 }
389 
390 bool PropertyCondition::isValidValueForAttributes(VM&amp; vm, JSValue value, unsigned attributes)
391 {
392     if (!value)
393         return false;
394     bool attributesClaimAccessor = !!(attributes &amp; PropertyAttribute::Accessor);
395     bool valueClaimsAccessor = !!jsDynamicCast&lt;GetterSetter*&gt;(vm, value);
396     return attributesClaimAccessor == valueClaimsAccessor;
397 }
398 
399 bool PropertyCondition::isValidValueForPresence(VM&amp; vm, JSValue value) const
400 {
</pre>
<hr />
<pre>
413 
414 } // namespace JSC
415 
416 namespace WTF {
417 
418 void printInternal(PrintStream&amp; out, JSC::PropertyCondition::Kind condition)
419 {
420     switch (condition) {
421     case JSC::PropertyCondition::Presence:
422         out.print(&quot;Presence&quot;);
423         return;
424     case JSC::PropertyCondition::Absence:
425         out.print(&quot;Absence&quot;);
426         return;
427     case JSC::PropertyCondition::AbsenceOfSetEffect:
428         out.print(&quot;Absence&quot;);
429         return;
430     case JSC::PropertyCondition::Equivalence:
431         out.print(&quot;Equivalence&quot;);
432         return;
<span class="line-added">433     case JSC::PropertyCondition::CustomFunctionEquivalence:</span>
<span class="line-added">434         out.print(&quot;CustomFunctionEquivalence&quot;);</span>
<span class="line-added">435         return;</span>
436     case JSC::PropertyCondition::HasPrototype:
437         out.print(&quot;HasPrototype&quot;);
438         return;
439     }
440     RELEASE_ASSERT_NOT_REACHED();
441 }
442 
443 } // namespace WTF
</pre>
</td>
</tr>
</table>
<center><a href="PreciseJumpTargetsInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyCondition.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
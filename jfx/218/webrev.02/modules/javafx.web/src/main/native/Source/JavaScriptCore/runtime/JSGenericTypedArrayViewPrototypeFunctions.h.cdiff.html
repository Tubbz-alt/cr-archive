<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewPrototypeFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGenericTypedArrayViewInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalLexicalEnvironment.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewPrototypeFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,168 ***</span>
  namespace JSC {
  
  // This implements 22.2.4.7 TypedArraySpeciesCreate
  // Note, that this function throws.
  template&lt;typename Functor&gt;
<span class="line-modified">! inline JSArrayBufferView* speciesConstruct(ExecState* exec, JSObject* exemplar, MarkedArgumentBuffer&amp; args, const Functor&amp; defaultConstructor)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue constructor = exemplar-&gt;get(exec, vm.propertyNames-&gt;constructor);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (constructor.isUndefined())
          RELEASE_AND_RETURN(scope, defaultConstructor());
  
      if (!constructor.isObject()) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;constructor Property should not be null&quot;_s);</span>
          return nullptr;
      }
  
<span class="line-modified">!     JSValue species = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (species.isUndefinedOrNull())
          RELEASE_AND_RETURN(scope, defaultConstructor());
  
  
<span class="line-modified">!     JSValue result = construct(exec, species, args, &quot;species is not a constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result)) {
          if (view-&gt;type() == DataViewType) {
<span class="line-modified">!             throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
              return nullptr;
          }
  
          if (!view-&gt;isNeutered())
              return view;
  
<span class="line-modified">!         throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
          return nullptr;
      }
  
<span class="line-modified">!     throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
      return nullptr;
  }
  
<span class="line-modified">! inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)</span>
  {
<span class="line-removed">-     JSValue value = exec-&gt;argument(argument);</span>
      if (value.isUndefined())
          return undefinedValue;
  
<span class="line-modified">!     double indexDouble = value.toInteger(exec);</span>
      if (indexDouble &lt; 0) {
          indexDouble += length;
          return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
      }
      return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSet(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.22
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
  
<span class="line-modified">!     if (UNLIKELY(!exec-&gt;argumentCount()))</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned offset;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         double offsetNumber = exec-&gt;uncheckedArgument(1).toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (UNLIKELY(offsetNumber &lt; 0))
<span class="line-modified">!             return throwVMRangeError(exec, scope, &quot;Offset should not be negative&quot;);</span>
          offset = static_cast&lt;unsigned&gt;(std::min(offsetNumber, static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max())));
      } else
          offset = 0;
  
      if (UNLIKELY(thisObject-&gt;isNeutered()))
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     JSObject* sourceArray = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;uncheckedArgument(0));</span>
      if (UNLIKELY(!sourceArray))
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;First argument should be an object&quot;_s);</span>
  
      unsigned length;
      if (isTypedView(sourceArray-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {
          JSArrayBufferView* sourceView = jsCast&lt;JSArrayBufferView*&gt;(sourceArray);
          if (UNLIKELY(sourceView-&gt;isNeutered()))
<span class="line-modified">!             return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
          length = jsCast&lt;JSArrayBufferView*&gt;(sourceArray)-&gt;length();
      } else {
<span class="line-modified">!         JSValue lengthValue = sourceArray-&gt;get(exec, vm.propertyNames-&gt;length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!         length = lengthValue.toUInt32(exec);</span>
      }
  
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
<span class="line-modified">!     thisObject-&gt;set(exec, offset, sourceArray, 0, length, CopyType::Unobservable);</span>
      return JSValue::encode(jsUndefined());
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncCopyWithin(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.5
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      long length = thisObject-&gt;length();
<span class="line-modified">!     long to = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     long from = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     long final = argumentClampedIndexFromStartOrEnd(exec, 2, length, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (final &lt; from)
<span class="line-modified">!         return JSValue::encode(exec-&gt;thisValue());</span>
  
      long count = std::min(length - std::max(to, from), final - from);
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      memmove(array + to, array + from, count * thisObject-&gt;elementSize);
  
<span class="line-modified">!     return JSValue::encode(exec-&gt;thisValue());</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIncludes(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      unsigned length = thisObject-&gt;length();
  
      if (!length)
          return JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     JSValue valueToFind = exec-&gt;argument(0);</span>
  
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsBoolean(false));
<span class="line-new-header">--- 41,167 ---</span>
  namespace JSC {
  
  // This implements 22.2.4.7 TypedArraySpeciesCreate
  // Note, that this function throws.
  template&lt;typename Functor&gt;
<span class="line-modified">! inline JSArrayBufferView* speciesConstruct(JSGlobalObject* globalObject, JSObject* exemplar, MarkedArgumentBuffer&amp; args, const Functor&amp; defaultConstructor)</span>
  {
<span class="line-modified">!     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue constructor = exemplar-&gt;get(globalObject, vm.propertyNames-&gt;constructor);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (constructor.isUndefined())
          RELEASE_AND_RETURN(scope, defaultConstructor());
  
      if (!constructor.isObject()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;constructor Property should not be null&quot;_s);</span>
          return nullptr;
      }
  
<span class="line-modified">!     JSValue species = constructor.get(globalObject, vm.propertyNames-&gt;speciesSymbol);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (species.isUndefinedOrNull())
          RELEASE_AND_RETURN(scope, defaultConstructor());
  
  
<span class="line-modified">!     JSValue result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result)) {
          if (view-&gt;type() == DataViewType) {
<span class="line-modified">!             throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
              return nullptr;
          }
  
          if (!view-&gt;isNeutered())
              return view;
  
<span class="line-modified">!         throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
          return nullptr;
      }
  
<span class="line-modified">!     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
      return nullptr;
  }
  
<span class="line-modified">! inline unsigned argumentClampedIndexFromStartOrEnd(JSGlobalObject* globalObject, JSValue value, unsigned length, unsigned undefinedValue = 0)</span>
  {
      if (value.isUndefined())
          return undefinedValue;
  
<span class="line-modified">!     double indexDouble = value.toInteger(globalObject);</span>
      if (indexDouble &lt; 0) {
          indexDouble += length;
          return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
      }
      return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSet(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.22
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
  
<span class="line-modified">!     if (UNLIKELY(!callFrame-&gt;argumentCount()))</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned offset;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         double offsetNumber = callFrame-&gt;uncheckedArgument(1).toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (UNLIKELY(offsetNumber &lt; 0))
<span class="line-modified">!             return throwVMRangeError(globalObject, scope, &quot;Offset should not be negative&quot;);</span>
          offset = static_cast&lt;unsigned&gt;(std::min(offsetNumber, static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max())));
      } else
          offset = 0;
  
      if (UNLIKELY(thisObject-&gt;isNeutered()))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     JSObject* sourceArray = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;uncheckedArgument(0));</span>
      if (UNLIKELY(!sourceArray))
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;First argument should be an object&quot;_s);</span>
  
      unsigned length;
      if (isTypedView(sourceArray-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {
          JSArrayBufferView* sourceView = jsCast&lt;JSArrayBufferView*&gt;(sourceArray);
          if (UNLIKELY(sourceView-&gt;isNeutered()))
<span class="line-modified">!             return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
          length = jsCast&lt;JSArrayBufferView*&gt;(sourceArray)-&gt;length();
      } else {
<span class="line-modified">!         JSValue lengthValue = sourceArray-&gt;get(globalObject, vm.propertyNames-&gt;length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!         length = lengthValue.toUInt32(globalObject);</span>
      }
  
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      scope.release();
<span class="line-modified">!     thisObject-&gt;set(globalObject, offset, sourceArray, 0, length, CopyType::Unobservable);</span>
      return JSValue::encode(jsUndefined());
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncCopyWithin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.5
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      long length = thisObject-&gt;length();
<span class="line-modified">!     long to = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     long from = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     long final = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(2), length, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (final &lt; from)
<span class="line-modified">!         return JSValue::encode(callFrame-&gt;thisValue());</span>
  
      long count = std::min(length - std::max(to, from), final - from);
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      memmove(array + to, array + from, count * thisObject-&gt;elementSize);
  
<span class="line-modified">!     return JSValue::encode(callFrame-&gt;thisValue());</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIncludes(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      unsigned length = thisObject-&gt;length();
  
      if (!length)
          return JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     JSValue valueToFind = callFrame-&gt;argument(0);</span>
  
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsBoolean(false));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,30 ***</span>
  
      return JSValue::encode(jsBoolean(false));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIndexOf(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.13
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     if (!exec-&gt;argumentCount())</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!     JSValue valueToFind = exec-&gt;argument(0);</span>
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsNumber(-1));
<span class="line-new-header">--- 223,30 ---</span>
  
      return JSValue::encode(jsBoolean(false));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.13
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     if (!callFrame-&gt;argumentCount())</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!     JSValue valueToFind = callFrame-&gt;argument(0);</span>
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsNumber(-1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,69 ***</span>
  
      return JSValue::encode(jsNumber(-1));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncJoin(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // 22.2.3.14
      auto joinWithSeparator = [&amp;] (StringView separator) -&gt; EncodedJSValue {
<span class="line-modified">!         ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
          unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!         JSStringJoiner joiner(*exec, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">!             joiner.append(*exec, thisObject-&gt;getIndexQuickly(i));</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(*exec)));</span>
      };
  
<span class="line-modified">!     JSValue separatorValue = exec-&gt;argument(0);</span>
      if (separatorValue.isUndefined()) {
          const LChar* comma = reinterpret_cast&lt;const LChar*&gt;(&quot;,&quot;);
          return joinWithSeparator({ comma, 1 });
      }
  
<span class="line-modified">!     JSString* separatorString = separatorValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
<span class="line-modified">!     auto viewWithString = separatorString-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return joinWithSeparator(viewWithString.view);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncLastIndexOf(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.16
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     if (!exec-&gt;argumentCount())</span>
<span class="line-modified">!         return throwVMTypeError(exec, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!     JSValue valueToFind = exec-&gt;argument(0);</span>
  
      int index = length - 1;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         JSValue fromValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!         double fromDouble = fromValue.toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (fromDouble &lt; 0) {
              fromDouble += length;
              if (fromDouble &lt; 0)
                  return JSValue::encode(jsNumber(-1));
<span class="line-new-header">--- 260,69 ---</span>
  
      return JSValue::encode(jsNumber(-1));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncJoin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // 22.2.3.14
      auto joinWithSeparator = [&amp;] (StringView separator) -&gt; EncodedJSValue {
<span class="line-modified">!         ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
          unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!         JSStringJoiner joiner(globalObject, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          for (unsigned i = 0; i &lt; length; i++) {
<span class="line-modified">!             joiner.append(globalObject, thisObject-&gt;getIndexQuickly(i));</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(globalObject)));</span>
      };
  
<span class="line-modified">!     JSValue separatorValue = callFrame-&gt;argument(0);</span>
      if (separatorValue.isUndefined()) {
          const LChar* comma = reinterpret_cast&lt;const LChar*&gt;(&quot;,&quot;);
          return joinWithSeparator({ comma, 1 });
      }
  
<span class="line-modified">!     JSString* separatorString = separatorValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
<span class="line-modified">!     auto viewWithString = separatorString-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return joinWithSeparator(viewWithString.view);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncLastIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.16
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
<span class="line-modified">!     if (!callFrame-&gt;argumentCount())</span>
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);</span>
  
      unsigned length = thisObject-&gt;length();
  
<span class="line-modified">!     JSValue valueToFind = callFrame-&gt;argument(0);</span>
  
      int index = length - 1;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         JSValue fromValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!         double fromDouble = fromValue.toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (fromDouble &lt; 0) {
              fromDouble += length;
              if (fromDouble &lt; 0)
                  return JSValue::encode(jsNumber(-1));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,11 ***</span>
          if (fromDouble &lt; length)
              index = static_cast&lt;unsigned&gt;(fromDouble);
      }
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsNumber(-1));
  
<span class="line-new-header">--- 330,11 ---</span>
          if (fromDouble &lt; length)
              index = static_cast&lt;unsigned&gt;(fromDouble);
      }
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
      if (!targetOption)
          return JSValue::encode(jsNumber(-1));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,99 ***</span>
  
      return JSValue::encode(jsNumber(-1));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncBuffer(VM&amp;, ExecState* exec)</span>
  {
      // 22.2.3.3
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
  
<span class="line-modified">!     return JSValue::encode(thisObject-&gt;possiblySharedJSBuffer(exec));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncLength(VM&amp;, ExecState* exec)</span>
  {
      // 22.2.3.17
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;length()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteLength(VM&amp;, ExecState* exec)</span>
  {
      // 22.2.3.2
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;byteLength()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteOffset(VM&amp;, ExecState* exec)</span>
  {
      // 22.2.3.3
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;byteOffset()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncReverse(VM&amp; vm, ExecState* exec)</span>
  {
<span class="line-modified">! //    VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.21
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      std::reverse(array, array + thisObject-&gt;length());
  
      return JSValue::encode(thisObject);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSort(VM&amp; vm, ExecState* exec)</span>
  {
<span class="line-modified">! //    VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.25
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;argument(0));</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      thisObject-&gt;sort();
  
      return JSValue::encode(thisObject);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSlice(VM&amp; vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.26
<span class="line-removed">-     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      unsigned thisLength = thisObject-&gt;length();
  
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, thisLength);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, thisLength, thisLength);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // Clamp end to begin.
      end = std::max(begin, end);
  
      ASSERT(end &gt;= begin);
<span class="line-new-header">--- 349,98 ---</span>
  
      return JSValue::encode(jsNumber(-1));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncBuffer(VM&amp;, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // 22.2.3.3
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
  
<span class="line-modified">!     return JSValue::encode(thisObject-&gt;possiblySharedJSBuffer(globalObject));</span>
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
  {
      // 22.2.3.17
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;length()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
  {
      // 22.2.3.2
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;byteLength()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteOffset(VM&amp;, JSGlobalObject*, CallFrame* callFrame)</span>
  {
      // 22.2.3.3
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
  
      return JSValue::encode(jsNumber(thisObject-&gt;byteOffset()));
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncReverse(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">! //    VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.21
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
      std::reverse(array, array + thisObject-&gt;length());
  
      return JSValue::encode(thisObject);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSort(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">! //    VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.25
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;argument(0));</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      thisObject-&gt;sort();
  
      return JSValue::encode(thisObject);
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSlice(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.26
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      unsigned thisLength = thisObject-&gt;length();
  
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // Clamp end to begin.
      end = std::max(begin, end);
  
      ASSERT(end &gt;= begin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,91 ***</span>
  
      MarkedArgumentBuffer args;
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSArrayBufferView* result = speciesConstruct(exec, thisObject, args, [&amp;]() {</span>
<span class="line-modified">!         Structure* structure = callee-&gt;globalObject(vm)-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!         return ViewClass::createUninitialized(exec, structure, length);</span>
      });
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      ASSERT(!result-&gt;isNeutered());
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // We return early here since we don&#39;t allocate a backing store if length is 0 and memmove does not like nullptrs
      if (!length)
          return JSValue::encode(result);
  
      // The species constructor may return an array with any arbitrary length.
      length = std::min(length, result-&gt;length());
      switch (result-&gt;classInfo(vm)-&gt;typedArrayStorageType) {
      case TypeInt8:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt8Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeInt16:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt16Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeInt32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint8:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint8Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint8Clamped:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint8ClampedArray*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint16:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint16Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeFloat32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSFloat32Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeFloat64:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSFloat64Array*&gt;(result)-&gt;set(exec, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSubarrayCreate(VM&amp;vm, ExecState* exec)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.23
<span class="line-removed">-     JSFunction* callee = jsCast&lt;JSFunction*&gt;(exec-&gt;jsCallee());</span>
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(exec-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // Get the length here; later assert that the length didn&#39;t change.
      unsigned thisLength = thisObject-&gt;length();
  
      // I would assert that the arguments are integers here but that&#39;s not true since
      // https://tc39.github.io/ecma262/#sec-tointeger allows the result of the operation
      // to be +/- Infinity and -0.
<span class="line-modified">!     ASSERT(exec-&gt;argument(0).isNumber());</span>
<span class="line-modified">!     ASSERT(exec-&gt;argument(1).isUndefined() || exec-&gt;argument(1).isNumber());</span>
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, thisLength);</span>
      scope.assertNoException();
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, thisLength, thisLength);</span>
      scope.assertNoException();
  
      RELEASE_ASSERT(!thisObject-&gt;isNeutered());
  
      // Clamp end to begin.
<span class="line-new-header">--- 448,90 ---</span>
  
      MarkedArgumentBuffer args;
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSArrayBufferView* result = speciesConstruct(globalObject, thisObject, args, [&amp;]() {</span>
<span class="line-modified">!         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!         return ViewClass::createUninitialized(globalObject, structure, length);</span>
      });
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      ASSERT(!result-&gt;isNeutered());
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // We return early here since we don&#39;t allocate a backing store if length is 0 and memmove does not like nullptrs
      if (!length)
          return JSValue::encode(result);
  
      // The species constructor may return an array with any arbitrary length.
      length = std::min(length, result-&gt;length());
      switch (result-&gt;classInfo(vm)-&gt;typedArrayStorageType) {
      case TypeInt8:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeInt16:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeInt32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSInt32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint8:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint8Clamped:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint8ClampedArray*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint16:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeUint32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSUint32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeFloat32:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSFloat32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      case TypeFloat64:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSFloat64Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);</span>
          return JSValue::encode(result);
      default:
          RELEASE_ASSERT_NOT_REACHED();
      }
  }
  
  template&lt;typename ViewClass&gt;
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSubarrayCreate(VM&amp;vm, JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 22.2.3.23
  
<span class="line-modified">!     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());</span>
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      // Get the length here; later assert that the length didn&#39;t change.
      unsigned thisLength = thisObject-&gt;length();
  
      // I would assert that the arguments are integers here but that&#39;s not true since
      // https://tc39.github.io/ecma262/#sec-tointeger allows the result of the operation
      // to be +/- Infinity and -0.
<span class="line-modified">!     ASSERT(callFrame-&gt;argument(0).isNumber());</span>
<span class="line-modified">!     ASSERT(callFrame-&gt;argument(1).isUndefined() || callFrame-&gt;argument(1).isNumber());</span>
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);</span>
      scope.assertNoException();
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);</span>
      scope.assertNoException();
  
      RELEASE_ASSERT(!thisObject-&gt;isNeutered());
  
      // Clamp end to begin.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,33 ***</span>
      RefPtr&lt;ArrayBuffer&gt; arrayBuffer = thisObject-&gt;possiblySharedBuffer();
      RELEASE_ASSERT(thisLength == thisObject-&gt;length());
  
      unsigned newByteOffset = thisObject-&gt;byteOffset() + offset * ViewClass::elementSize;
  
<span class="line-modified">!     JSObject* defaultConstructor = callee-&gt;globalObject(vm)-&gt;typedArrayConstructor(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!     JSValue species = exec-&gt;uncheckedArgument(2);</span>
      if (species == defaultConstructor) {
<span class="line-modified">!         Structure* structure = callee-&gt;globalObject(vm)-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
  
          RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(
<span class="line-modified">!             exec, structure, WTFMove(arrayBuffer),</span>
              thisObject-&gt;byteOffset() + offset * ViewClass::elementSize,
              length)));
      }
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(vm.m_typedArrayController-&gt;toJS(exec, thisObject-&gt;globalObject(vm), arrayBuffer.get()));</span>
      args.append(jsNumber(newByteOffset));
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSObject* result = construct(exec, species, args, &quot;species is not a constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result))
          return JSValue::encode(result);
  
<span class="line-modified">!     throwTypeError(exec, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
      return JSValue::encode(JSValue());
  }
  
  } // namespace JSC
<span class="line-new-header">--- 544,33 ---</span>
      RefPtr&lt;ArrayBuffer&gt; arrayBuffer = thisObject-&gt;possiblySharedBuffer();
      RELEASE_ASSERT(thisLength == thisObject-&gt;length());
  
      unsigned newByteOffset = thisObject-&gt;byteOffset() + offset * ViewClass::elementSize;
  
<span class="line-modified">!     JSObject* defaultConstructor = globalObject-&gt;typedArrayConstructor(ViewClass::TypedArrayStorageType);</span>
<span class="line-modified">!     JSValue species = callFrame-&gt;uncheckedArgument(2);</span>
      if (species == defaultConstructor) {
<span class="line-modified">!         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);</span>
  
          RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(
<span class="line-modified">!             globalObject, structure, WTFMove(arrayBuffer),</span>
              thisObject-&gt;byteOffset() + offset * ViewClass::elementSize,
              length)));
      }
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(vm.m_typedArrayController-&gt;toJS(globalObject, thisObject-&gt;globalObject(vm), arrayBuffer.get()));</span>
      args.append(jsNumber(newByteOffset));
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSObject* result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result))
          return JSValue::encode(result);
  
<span class="line-modified">!     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);</span>
      return JSValue::encode(JSValue());
  }
  
  } // namespace JSC
</pre>
<center><a href="JSGenericTypedArrayViewInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGlobalLexicalEnvironment.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
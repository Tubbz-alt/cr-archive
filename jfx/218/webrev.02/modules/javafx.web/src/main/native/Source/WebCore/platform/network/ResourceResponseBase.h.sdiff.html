<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ResourceResponseBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SameSiteInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/ResourceResponseBase.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;CacheValidation.h&quot;
 30 #include &quot;CertificateInfo.h&quot;
 31 #include &quot;HTTPHeaderMap.h&quot;
 32 #include &quot;NetworkLoadMetrics.h&quot;
 33 #include &quot;ParsedContentRange.h&quot;
 34 #include &lt;wtf/Markable.h&gt;
 35 #include &lt;wtf/URL.h&gt;
 36 #include &lt;wtf/WallTime.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class ResourceResponse;
 41 
 42 bool isScriptAllowedByNosniff(const ResourceResponse&amp;);
 43 
<span class="line-modified"> 44 // Do not use this class directly, use the class ResponseResponse instead</span>


 45 class ResourceResponseBase {
 46     WTF_MAKE_FAST_ALLOCATED;
 47 public:
 48     enum class Type : uint8_t { Basic, Cors, Default, Error, Opaque, Opaqueredirect };

 49     enum class Tainting : uint8_t { Basic, Cors, Opaque, Opaqueredirect };

 50 
 51     static bool isRedirectionStatusCode(int code) { return code == 301 || code == 302 || code == 303 || code == 307 || code == 308; }
 52 
 53     struct CrossThreadData {
 54         CrossThreadData(const CrossThreadData&amp;) = delete;
 55         CrossThreadData&amp; operator=(const CrossThreadData&amp;) = delete;
 56         CrossThreadData() = default;
 57         CrossThreadData(CrossThreadData&amp;&amp;) = default;
 58 
 59         URL url;
 60         String mimeType;
 61         long long expectedContentLength;
 62         String textEncodingName;
 63         int httpStatusCode;
 64         String httpStatusText;
 65         String httpVersion;
 66         HTTPHeaderMap httpHeaderFields;
 67         NetworkLoadMetrics networkLoadMetrics;
 68         Type type;
 69         Tainting tainting;
 70         bool isRedirected;

 71     };
 72 
 73     CrossThreadData crossThreadData() const;
 74     static ResourceResponse fromCrossThreadData(CrossThreadData&amp;&amp;);
 75 
 76     bool isNull() const { return m_isNull; }
 77     WEBCORE_EXPORT bool isHTTP() const;
 78     WEBCORE_EXPORT bool isSuccessful() const;
 79 
 80     WEBCORE_EXPORT const URL&amp; url() const;
 81     WEBCORE_EXPORT void setURL(const URL&amp;);
 82 
 83     WEBCORE_EXPORT const String&amp; mimeType() const;
 84     WEBCORE_EXPORT void setMimeType(const String&amp; mimeType);
 85 
 86     WEBCORE_EXPORT long long expectedContentLength() const;
 87     WEBCORE_EXPORT void setExpectedContentLength(long long expectedContentLength);
 88 
 89     WEBCORE_EXPORT const String&amp; textEncodingName() const;
 90     WEBCORE_EXPORT void setTextEncodingName(const String&amp; name);
</pre>
<hr />
<pre>
109     String httpHeaderField(const String&amp; name) const;
110     WEBCORE_EXPORT String httpHeaderField(HTTPHeaderName) const;
111     WEBCORE_EXPORT void setHTTPHeaderField(const String&amp; name, const String&amp; value);
112     WEBCORE_EXPORT void setHTTPHeaderField(HTTPHeaderName, const String&amp; value);
113 
114     WEBCORE_EXPORT void addHTTPHeaderField(HTTPHeaderName, const String&amp; value);
115     WEBCORE_EXPORT void addHTTPHeaderField(const String&amp; name, const String&amp; value);
116 
117     // Instead of passing a string literal to any of these functions, just use a HTTPHeaderName instead.
118     template&lt;size_t length&gt; String httpHeaderField(const char (&amp;)[length]) const = delete;
119     template&lt;size_t length&gt; void setHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
120     template&lt;size_t length&gt; void addHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
121 
122     bool isMultipart() const { return mimeType() == &quot;multipart/x-mixed-replace&quot;; }
123 
124     WEBCORE_EXPORT bool isAttachment() const;
125     WEBCORE_EXPORT bool isAttachmentWithFilename() const;
126     WEBCORE_EXPORT String suggestedFilename() const;
127     WEBCORE_EXPORT static String sanitizeSuggestedFilename(const String&amp;);
128 
<span class="line-modified">129     WEBCORE_EXPORT void includeCertificateInfo() const;</span>
130     const Optional&lt;CertificateInfo&gt;&amp; certificateInfo() const { return m_certificateInfo; };

131 
132     // These functions return parsed values of the corresponding response headers.
133     WEBCORE_EXPORT bool cacheControlContainsNoCache() const;
134     WEBCORE_EXPORT bool cacheControlContainsNoStore() const;
135     WEBCORE_EXPORT bool cacheControlContainsMustRevalidate() const;
136     WEBCORE_EXPORT bool cacheControlContainsImmutable() const;
137     WEBCORE_EXPORT bool hasCacheValidatorFields() const;
138     WEBCORE_EXPORT Optional&lt;Seconds&gt; cacheControlMaxAge() const;

139     WEBCORE_EXPORT Optional&lt;WallTime&gt; date() const;
140     WEBCORE_EXPORT Optional&lt;Seconds&gt; age() const;
141     WEBCORE_EXPORT Optional&lt;WallTime&gt; expires() const;
142     WEBCORE_EXPORT Optional&lt;WallTime&gt; lastModified() const;
143     const ParsedContentRange&amp; contentRange() const;
144 
<span class="line-modified">145     enum class Source : uint8_t { Unknown, Network, DiskCache, DiskCacheAfterValidation, MemoryCache, MemoryCacheAfterValidation, ServiceWorker, ApplicationCache };</span>
146     WEBCORE_EXPORT Source source() const;
147     void setSource(Source source)
148     {
149         ASSERT(source != Source::Unknown);
150         m_source = source;
151     }
152 
153     // FIXME: This should be eliminated from ResourceResponse.
154     // Network loading metrics should be delivered via didFinishLoad
155     // and should not be part of the ResourceResponse.
156     NetworkLoadMetrics&amp; deprecatedNetworkLoadMetrics() const { return m_networkLoadMetrics; }
157 
158     // The ResourceResponse subclass may &quot;shadow&quot; this method to provide platform-specific memory usage information
159     unsigned memoryUsage() const
160     {
161         // average size, mostly due to URL and Header Map strings
162         return 1280;
163     }
164 
165     WEBCORE_EXPORT void setType(Type);
166     Type type() const { return m_type; }
167 
168     void setRedirected(bool isRedirected) { m_isRedirected = isRedirected; }
169     bool isRedirected() const { return m_isRedirected; }
170 
171     void setTainting(Tainting tainting) { m_tainting = tainting; }
172     Tainting tainting() const { return m_tainting; }
173 
174     static ResourceResponse filter(const ResourceResponse&amp;);
175 
176     WEBCORE_EXPORT static ResourceResponse syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL);
177 
178     static bool compare(const ResourceResponse&amp;, const ResourceResponse&amp;);
179 
180     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
181     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, ResourceResponseBase&amp;);
182 



183 protected:
184     enum InitLevel {
185         Uninitialized,
186         CommonFieldsOnly,
187         AllFields
188     };
189 
190     WEBCORE_EXPORT ResourceResponseBase();
191     WEBCORE_EXPORT ResourceResponseBase(const URL&amp;, const String&amp; mimeType, long long expectedLength, const String&amp; textEncodingName);
192 
193     WEBCORE_EXPORT void lazyInit(InitLevel) const;
194 
195     // The ResourceResponse subclass should shadow these functions to lazily initialize platform specific fields
196     void platformLazyInit(InitLevel) { }
197     CertificateInfo platformCertificateInfo() const { return CertificateInfo(); };
198     String platformSuggestedFileName() const { return String(); }
199 
200     static bool platformCompare(const ResourceResponse&amp;, const ResourceResponse&amp;) { return true; }
201 
202 private:
</pre>
<hr />
<pre>
221     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_date;
222     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_expires;
223     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_lastModified;
224     mutable ParsedContentRange m_contentRange;
225     mutable CacheControlDirectives m_cacheControlDirectives;
226 
227     mutable bool m_haveParsedCacheControlHeader : 1;
228     mutable bool m_haveParsedAgeHeader : 1;
229     mutable bool m_haveParsedDateHeader : 1;
230     mutable bool m_haveParsedExpiresHeader : 1;
231     mutable bool m_haveParsedLastModifiedHeader : 1;
232     mutable bool m_haveParsedContentRangeHeader : 1;
233     bool m_isRedirected : 1;
234 protected:
235     bool m_isNull : 1;
236 
237 private:
238     Source m_source { Source::Unknown };
239     Type m_type { Type::Default };
240     Tainting m_tainting { Tainting::Basic };

241 
242 protected:
<span class="line-modified">243     int m_httpStatusCode { 0 };</span>

244 };
245 
246 inline bool operator==(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return ResourceResponseBase::compare(a, b); }
247 inline bool operator!=(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return !(a == b); }
248 
249 template&lt;class Encoder&gt;
250 void ResourceResponseBase::encode(Encoder&amp; encoder) const
251 {
252     encoder &lt;&lt; m_isNull;
253     if (m_isNull)
254         return;
255     lazyInit(AllFields);
256 
257     encoder &lt;&lt; m_url;
258     encoder &lt;&lt; m_mimeType;
259     encoder &lt;&lt; static_cast&lt;int64_t&gt;(m_expectedContentLength);
260     encoder &lt;&lt; m_textEncodingName;
261     encoder &lt;&lt; m_httpStatusText;
262     encoder &lt;&lt; m_httpVersion;
263     encoder &lt;&lt; m_httpHeaderFields;
264 
265     // We don&#39;t want to put the networkLoadMetrics info
266     // into the disk cache, because we will never use the old info.
267     if (Encoder::isIPCEncoder)
268         encoder &lt;&lt; m_networkLoadMetrics;
269 
270     encoder &lt;&lt; m_httpStatusCode;
271     encoder &lt;&lt; m_certificateInfo;
272     encoder.encodeEnum(m_source);
273     encoder.encodeEnum(m_type);
274     encoder.encodeEnum(m_tainting);
275     encoder &lt;&lt; m_isRedirected;


276 }
277 
278 template&lt;class Decoder&gt;
279 bool ResourceResponseBase::decode(Decoder&amp; decoder, ResourceResponseBase&amp; response)
280 {
281     ASSERT(response.m_isNull);
282     bool responseIsNull;
283     if (!decoder.decode(responseIsNull))
284         return false;
285     if (responseIsNull)
286         return true;
287 


288     if (!decoder.decode(response.m_url))
289         return false;
290     if (!decoder.decode(response.m_mimeType))
291         return false;
292     int64_t expectedContentLength;
293     if (!decoder.decode(expectedContentLength))
294         return false;
295     response.m_expectedContentLength = expectedContentLength;
296     if (!decoder.decode(response.m_textEncodingName))
297         return false;
298     if (!decoder.decode(response.m_httpStatusText))
299         return false;
300     if (!decoder.decode(response.m_httpVersion))
301         return false;
302     if (!decoder.decode(response.m_httpHeaderFields))
303         return false;
304     // The networkLoadMetrics info is only send over IPC and not stored in disk cache.
305     if (Decoder::isIPCDecoder &amp;&amp; !decoder.decode(response.m_networkLoadMetrics))
306         return false;
307     if (!decoder.decode(response.m_httpStatusCode))
308         return false;
309     if (!decoder.decode(response.m_certificateInfo))
310         return false;
311     if (!decoder.decodeEnum(response.m_source))
312         return false;
313     if (!decoder.decodeEnum(response.m_type))
314         return false;
315     if (!decoder.decodeEnum(response.m_tainting))
316         return false;
317     bool isRedirected = false;
318     if (!decoder.decode(isRedirected))
319         return false;
320     response.m_isRedirected = isRedirected;
<span class="line-modified">321     response.m_isNull = false;</span>





322 
323     return true;
324 }
325 
326 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;CacheValidation.h&quot;
 30 #include &quot;CertificateInfo.h&quot;
 31 #include &quot;HTTPHeaderMap.h&quot;
 32 #include &quot;NetworkLoadMetrics.h&quot;
 33 #include &quot;ParsedContentRange.h&quot;
 34 #include &lt;wtf/Markable.h&gt;
 35 #include &lt;wtf/URL.h&gt;
 36 #include &lt;wtf/WallTime.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class ResourceResponse;
 41 
 42 bool isScriptAllowedByNosniff(const ResourceResponse&amp;);
 43 
<span class="line-modified"> 44 enum class UsedLegacyTLS : bool { No, Yes };</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46 // Do not use this class directly, use the class ResourceResponse instead</span>
 47 class ResourceResponseBase {
 48     WTF_MAKE_FAST_ALLOCATED;
 49 public:
 50     enum class Type : uint8_t { Basic, Cors, Default, Error, Opaque, Opaqueredirect };
<span class="line-added"> 51     static constexpr unsigned bitWidthOfType = 3;</span>
 52     enum class Tainting : uint8_t { Basic, Cors, Opaque, Opaqueredirect };
<span class="line-added"> 53     static constexpr unsigned bitWidthOfTainting = 2;</span>
 54 
 55     static bool isRedirectionStatusCode(int code) { return code == 301 || code == 302 || code == 303 || code == 307 || code == 308; }
 56 
 57     struct CrossThreadData {
 58         CrossThreadData(const CrossThreadData&amp;) = delete;
 59         CrossThreadData&amp; operator=(const CrossThreadData&amp;) = delete;
 60         CrossThreadData() = default;
 61         CrossThreadData(CrossThreadData&amp;&amp;) = default;
 62 
 63         URL url;
 64         String mimeType;
 65         long long expectedContentLength;
 66         String textEncodingName;
 67         int httpStatusCode;
 68         String httpStatusText;
 69         String httpVersion;
 70         HTTPHeaderMap httpHeaderFields;
 71         NetworkLoadMetrics networkLoadMetrics;
 72         Type type;
 73         Tainting tainting;
 74         bool isRedirected;
<span class="line-added"> 75         bool isRangeRequested;</span>
 76     };
 77 
 78     CrossThreadData crossThreadData() const;
 79     static ResourceResponse fromCrossThreadData(CrossThreadData&amp;&amp;);
 80 
 81     bool isNull() const { return m_isNull; }
 82     WEBCORE_EXPORT bool isHTTP() const;
 83     WEBCORE_EXPORT bool isSuccessful() const;
 84 
 85     WEBCORE_EXPORT const URL&amp; url() const;
 86     WEBCORE_EXPORT void setURL(const URL&amp;);
 87 
 88     WEBCORE_EXPORT const String&amp; mimeType() const;
 89     WEBCORE_EXPORT void setMimeType(const String&amp; mimeType);
 90 
 91     WEBCORE_EXPORT long long expectedContentLength() const;
 92     WEBCORE_EXPORT void setExpectedContentLength(long long expectedContentLength);
 93 
 94     WEBCORE_EXPORT const String&amp; textEncodingName() const;
 95     WEBCORE_EXPORT void setTextEncodingName(const String&amp; name);
</pre>
<hr />
<pre>
114     String httpHeaderField(const String&amp; name) const;
115     WEBCORE_EXPORT String httpHeaderField(HTTPHeaderName) const;
116     WEBCORE_EXPORT void setHTTPHeaderField(const String&amp; name, const String&amp; value);
117     WEBCORE_EXPORT void setHTTPHeaderField(HTTPHeaderName, const String&amp; value);
118 
119     WEBCORE_EXPORT void addHTTPHeaderField(HTTPHeaderName, const String&amp; value);
120     WEBCORE_EXPORT void addHTTPHeaderField(const String&amp; name, const String&amp; value);
121 
122     // Instead of passing a string literal to any of these functions, just use a HTTPHeaderName instead.
123     template&lt;size_t length&gt; String httpHeaderField(const char (&amp;)[length]) const = delete;
124     template&lt;size_t length&gt; void setHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
125     template&lt;size_t length&gt; void addHTTPHeaderField(const char (&amp;)[length], const String&amp;) = delete;
126 
127     bool isMultipart() const { return mimeType() == &quot;multipart/x-mixed-replace&quot;; }
128 
129     WEBCORE_EXPORT bool isAttachment() const;
130     WEBCORE_EXPORT bool isAttachmentWithFilename() const;
131     WEBCORE_EXPORT String suggestedFilename() const;
132     WEBCORE_EXPORT static String sanitizeSuggestedFilename(const String&amp;);
133 
<span class="line-modified">134     WEBCORE_EXPORT void includeCertificateInfo(UsedLegacyTLS = UsedLegacyTLS::No) const;</span>
135     const Optional&lt;CertificateInfo&gt;&amp; certificateInfo() const { return m_certificateInfo; };
<span class="line-added">136     bool usedLegacyTLS() const { return m_usedLegacyTLS == UsedLegacyTLS::Yes; }</span>
137 
138     // These functions return parsed values of the corresponding response headers.
139     WEBCORE_EXPORT bool cacheControlContainsNoCache() const;
140     WEBCORE_EXPORT bool cacheControlContainsNoStore() const;
141     WEBCORE_EXPORT bool cacheControlContainsMustRevalidate() const;
142     WEBCORE_EXPORT bool cacheControlContainsImmutable() const;
143     WEBCORE_EXPORT bool hasCacheValidatorFields() const;
144     WEBCORE_EXPORT Optional&lt;Seconds&gt; cacheControlMaxAge() const;
<span class="line-added">145     WEBCORE_EXPORT Optional&lt;Seconds&gt; cacheControlStaleWhileRevalidate() const;</span>
146     WEBCORE_EXPORT Optional&lt;WallTime&gt; date() const;
147     WEBCORE_EXPORT Optional&lt;Seconds&gt; age() const;
148     WEBCORE_EXPORT Optional&lt;WallTime&gt; expires() const;
149     WEBCORE_EXPORT Optional&lt;WallTime&gt; lastModified() const;
150     const ParsedContentRange&amp; contentRange() const;
151 
<span class="line-modified">152     enum class Source : uint8_t { Unknown, Network, DiskCache, DiskCacheAfterValidation, MemoryCache, MemoryCacheAfterValidation, ServiceWorker, ApplicationCache, DOMCache, InspectorOverride };</span>
153     WEBCORE_EXPORT Source source() const;
154     void setSource(Source source)
155     {
156         ASSERT(source != Source::Unknown);
157         m_source = source;
158     }
159 
160     // FIXME: This should be eliminated from ResourceResponse.
161     // Network loading metrics should be delivered via didFinishLoad
162     // and should not be part of the ResourceResponse.
163     NetworkLoadMetrics&amp; deprecatedNetworkLoadMetrics() const { return m_networkLoadMetrics; }
164 
165     // The ResourceResponse subclass may &quot;shadow&quot; this method to provide platform-specific memory usage information
166     unsigned memoryUsage() const
167     {
168         // average size, mostly due to URL and Header Map strings
169         return 1280;
170     }
171 
172     WEBCORE_EXPORT void setType(Type);
173     Type type() const { return m_type; }
174 
175     void setRedirected(bool isRedirected) { m_isRedirected = isRedirected; }
176     bool isRedirected() const { return m_isRedirected; }
177 
178     void setTainting(Tainting tainting) { m_tainting = tainting; }
179     Tainting tainting() const { return m_tainting; }
180 
181     static ResourceResponse filter(const ResourceResponse&amp;);
182 
183     WEBCORE_EXPORT static ResourceResponse syntheticRedirectResponse(const URL&amp; fromURL, const URL&amp; toURL);
184 
185     static bool compare(const ResourceResponse&amp;, const ResourceResponse&amp;);
186 
187     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
188     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, ResourceResponseBase&amp;);
189 
<span class="line-added">190     bool isRangeRequested() const { return m_isRangeRequested; }</span>
<span class="line-added">191     void setAsRangeRequested() { m_isRangeRequested = true; }</span>
<span class="line-added">192 </span>
193 protected:
194     enum InitLevel {
195         Uninitialized,
196         CommonFieldsOnly,
197         AllFields
198     };
199 
200     WEBCORE_EXPORT ResourceResponseBase();
201     WEBCORE_EXPORT ResourceResponseBase(const URL&amp;, const String&amp; mimeType, long long expectedLength, const String&amp; textEncodingName);
202 
203     WEBCORE_EXPORT void lazyInit(InitLevel) const;
204 
205     // The ResourceResponse subclass should shadow these functions to lazily initialize platform specific fields
206     void platformLazyInit(InitLevel) { }
207     CertificateInfo platformCertificateInfo() const { return CertificateInfo(); };
208     String platformSuggestedFileName() const { return String(); }
209 
210     static bool platformCompare(const ResourceResponse&amp;, const ResourceResponse&amp;) { return true; }
211 
212 private:
</pre>
<hr />
<pre>
231     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_date;
232     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_expires;
233     mutable Markable&lt;WallTime, WallTime::MarkableTraits&gt; m_lastModified;
234     mutable ParsedContentRange m_contentRange;
235     mutable CacheControlDirectives m_cacheControlDirectives;
236 
237     mutable bool m_haveParsedCacheControlHeader : 1;
238     mutable bool m_haveParsedAgeHeader : 1;
239     mutable bool m_haveParsedDateHeader : 1;
240     mutable bool m_haveParsedExpiresHeader : 1;
241     mutable bool m_haveParsedLastModifiedHeader : 1;
242     mutable bool m_haveParsedContentRangeHeader : 1;
243     bool m_isRedirected : 1;
244 protected:
245     bool m_isNull : 1;
246 
247 private:
248     Source m_source { Source::Unknown };
249     Type m_type { Type::Default };
250     Tainting m_tainting { Tainting::Basic };
<span class="line-added">251     bool m_isRangeRequested { false };</span>
252 
253 protected:
<span class="line-modified">254     short m_httpStatusCode { 0 };</span>
<span class="line-added">255     mutable UsedLegacyTLS m_usedLegacyTLS { UsedLegacyTLS::No };</span>
256 };
257 
258 inline bool operator==(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return ResourceResponseBase::compare(a, b); }
259 inline bool operator!=(const ResourceResponse&amp; a, const ResourceResponse&amp; b) { return !(a == b); }
260 
261 template&lt;class Encoder&gt;
262 void ResourceResponseBase::encode(Encoder&amp; encoder) const
263 {
264     encoder &lt;&lt; m_isNull;
265     if (m_isNull)
266         return;
267     lazyInit(AllFields);
268 
269     encoder &lt;&lt; m_url;
270     encoder &lt;&lt; m_mimeType;
271     encoder &lt;&lt; static_cast&lt;int64_t&gt;(m_expectedContentLength);
272     encoder &lt;&lt; m_textEncodingName;
273     encoder &lt;&lt; m_httpStatusText;
274     encoder &lt;&lt; m_httpVersion;
275     encoder &lt;&lt; m_httpHeaderFields;
276 
277     // We don&#39;t want to put the networkLoadMetrics info
278     // into the disk cache, because we will never use the old info.
279     if (Encoder::isIPCEncoder)
280         encoder &lt;&lt; m_networkLoadMetrics;
281 
282     encoder &lt;&lt; m_httpStatusCode;
283     encoder &lt;&lt; m_certificateInfo;
284     encoder.encodeEnum(m_source);
285     encoder.encodeEnum(m_type);
286     encoder.encodeEnum(m_tainting);
287     encoder &lt;&lt; m_isRedirected;
<span class="line-added">288     encoder &lt;&lt; m_usedLegacyTLS;</span>
<span class="line-added">289     encoder &lt;&lt; m_isRangeRequested;</span>
290 }
291 
292 template&lt;class Decoder&gt;
293 bool ResourceResponseBase::decode(Decoder&amp; decoder, ResourceResponseBase&amp; response)
294 {
295     ASSERT(response.m_isNull);
296     bool responseIsNull;
297     if (!decoder.decode(responseIsNull))
298         return false;
299     if (responseIsNull)
300         return true;
301 
<span class="line-added">302     response.m_isNull = false;</span>
<span class="line-added">303 </span>
304     if (!decoder.decode(response.m_url))
305         return false;
306     if (!decoder.decode(response.m_mimeType))
307         return false;
308     int64_t expectedContentLength;
309     if (!decoder.decode(expectedContentLength))
310         return false;
311     response.m_expectedContentLength = expectedContentLength;
312     if (!decoder.decode(response.m_textEncodingName))
313         return false;
314     if (!decoder.decode(response.m_httpStatusText))
315         return false;
316     if (!decoder.decode(response.m_httpVersion))
317         return false;
318     if (!decoder.decode(response.m_httpHeaderFields))
319         return false;
320     // The networkLoadMetrics info is only send over IPC and not stored in disk cache.
321     if (Decoder::isIPCDecoder &amp;&amp; !decoder.decode(response.m_networkLoadMetrics))
322         return false;
323     if (!decoder.decode(response.m_httpStatusCode))
324         return false;
325     if (!decoder.decode(response.m_certificateInfo))
326         return false;
327     if (!decoder.decodeEnum(response.m_source))
328         return false;
329     if (!decoder.decodeEnum(response.m_type))
330         return false;
331     if (!decoder.decodeEnum(response.m_tainting))
332         return false;
333     bool isRedirected = false;
334     if (!decoder.decode(isRedirected))
335         return false;
336     response.m_isRedirected = isRedirected;
<span class="line-modified">337     if (!decoder.decode(response.m_usedLegacyTLS))</span>
<span class="line-added">338         return false;</span>
<span class="line-added">339     bool isRangeRequested = false;</span>
<span class="line-added">340     if (!decoder.decode(isRangeRequested))</span>
<span class="line-added">341         return false;</span>
<span class="line-added">342     response.m_isRangeRequested = isRangeRequested;</span>
343 
344     return true;
345 }
346 
347 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ResourceResponseBase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SameSiteInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
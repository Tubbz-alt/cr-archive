<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/animation/KeyframeEffect.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;AnimationEffect.h&quot;
 29 #include &quot;CSSPropertyBlendingClient.h&quot;
 30 #include &quot;CompositeOperation.h&quot;
 31 #include &quot;CompositeOperationOrAuto.h&quot;
 32 #include &quot;EffectTiming.h&quot;
 33 #include &quot;Element.h&quot;
 34 #include &quot;IterationCompositeOperation.h&quot;
 35 #include &quot;KeyframeEffectOptions.h&quot;
 36 #include &quot;KeyframeList.h&quot;
 37 #include &quot;RenderStyle.h&quot;
 38 #include &quot;StyleProperties.h&quot;
 39 #include &quot;WebAnimationUtilities.h&quot;
 40 #include &lt;wtf/Ref.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 class Element;
 45 class FilterOperations;
 46 
 47 class KeyframeEffect : public AnimationEffect
 48     , public CSSPropertyBlendingClient {
 49 public:
 50     static ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; create(JSC::ExecState&amp;, Element*, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeEffectOptions&gt;&gt;&amp;&amp;);
 51     static ExceptionOr&lt;Ref&lt;KeyframeEffect&gt;&gt; create(JSC::ExecState&amp;, Ref&lt;KeyframeEffect&gt;&amp;&amp;);
 52     static Ref&lt;KeyframeEffect&gt; create(const Element&amp;);
 53     ~KeyframeEffect() { }
 54 
 55     bool isKeyframeEffect() const final { return true; }
 56 
 57     struct BasePropertyIndexedKeyframe {
 58         Variant&lt;std::nullptr_t, Vector&lt;Optional&lt;double&gt;&gt;, double&gt; offset = Vector&lt;Optional&lt;double&gt;&gt;();
 59         Variant&lt;Vector&lt;String&gt;, String&gt; easing = Vector&lt;String&gt;();
 60         Variant&lt;Vector&lt;CompositeOperationOrAuto&gt;, CompositeOperationOrAuto&gt; composite = Vector&lt;CompositeOperationOrAuto&gt;();
 61     };
 62 
 63     struct BaseKeyframe {
 64         MarkableDouble offset;
 65         String easing { &quot;linear&quot; };
 66         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
 67     };
 68 
 69     struct PropertyAndValues {
 70         CSSPropertyID property;
 71         Vector&lt;String&gt; values;
 72     };
 73 
 74     struct KeyframeLikeObject {
 75         BasePropertyIndexedKeyframe baseProperties;
 76         Vector&lt;PropertyAndValues&gt; propertiesAndValues;
 77     };
 78 
 79     struct ParsedKeyframe {
 80         MarkableDouble offset;
 81         double computedOffset;
 82         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
 83         String easing;
 84         RefPtr&lt;TimingFunction&gt; timingFunction;
 85         Ref&lt;MutableStyleProperties&gt; style;
 86         HashMap&lt;CSSPropertyID, String&gt; unparsedStyle;
 87 
 88         ParsedKeyframe()
 89             : style(MutableStyleProperties::create())
 90         {
 91         }
 92     };
 93 
 94     struct BaseComputedKeyframe {
 95         MarkableDouble offset;
 96         double computedOffset;
 97         String easing { &quot;linear&quot; };
 98         CompositeOperationOrAuto composite { CompositeOperationOrAuto::Auto };
 99     };
100 
101     Element* target() const { return m_target.get(); }
102     void setTarget(RefPtr&lt;Element&gt;&amp;&amp;);
103 
104     Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt; getKeyframes(JSC::ExecState&amp;);
105     ExceptionOr&lt;void&gt; setKeyframes(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;);
106 
107     IterationCompositeOperation iterationComposite() const { return m_iterationCompositeOperation; }
108     void setIterationComposite(IterationCompositeOperation iterationCompositeOperation) { m_iterationCompositeOperation = iterationCompositeOperation; }
109     CompositeOperation composite() const { return m_compositeOperation; }
110     void setComposite(CompositeOperation compositeOperation) { m_compositeOperation = compositeOperation; }
111 
112     void getAnimatedStyle(std::unique_ptr&lt;RenderStyle&gt;&amp; animatedStyle);
113     void apply(RenderStyle&amp;) override;
114     void invalidate() override;
115     void animationDidSeek() final;
116     void animationSuspensionStateDidChange(bool) final;
117     void applyPendingAcceleratedActions();
118     bool isRunningAccelerated() const { return m_lastRecordedAcceleratedAction != AcceleratedAction::Stop; }
119     bool hasPendingAcceleratedAction() const { return !m_pendingAcceleratedActions.isEmpty() &amp;&amp; isRunningAccelerated(); }
120 
121     RenderElement* renderer() const override;
122     const RenderStyle&amp; currentStyle() const override;
123     bool isAccelerated() const override { return m_shouldRunAccelerated; }
124     bool filterFunctionListsMatch() const override { return m_filterFunctionListsMatch; }
125     bool transformFunctionListsMatch() const override { return m_transformFunctionListsMatch; }
126 #if ENABLE(FILTERS_LEVEL_2)
127     bool backdropFilterFunctionListsMatch() const override { return m_backdropFilterFunctionListsMatch; }
128 #endif
129     bool colorFilterFunctionListsMatch() const override { return m_colorFilterFunctionListsMatch; }
130 
131     void computeDeclarativeAnimationBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle);
132     bool hasBlendingKeyframes() const { return m_blendingKeyframes.size(); }
133     const HashSet&lt;CSSPropertyID&gt;&amp; animatedProperties() const { return m_blendingKeyframes.properties(); }
134 
135     bool computeExtentOfTransformAnimation(LayoutRect&amp;) const;
136     bool computeTransformedExtentViaTransformList(const FloatRect&amp;, const RenderStyle&amp;, LayoutRect&amp;) const;
137     bool computeTransformedExtentViaMatrix(const FloatRect&amp;, const RenderStyle&amp;, LayoutRect&amp;) const;
138     bool forceLayoutIfNeeded();
139 
140 private:
141     KeyframeEffect(Element*);
142 
143     enum class AcceleratedAction : uint8_t { Play, Pause, Seek, Stop };
144 
145     void copyPropertiesFromSource(Ref&lt;KeyframeEffect&gt;&amp;&amp;);
146     ExceptionOr&lt;void&gt; processKeyframes(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;);
147     void addPendingAcceleratedAction(AcceleratedAction);
148     void updateAcceleratedAnimationState();
149     void setAnimatedPropertiesInStyle(RenderStyle&amp;, double);
150     TimingFunction* timingFunctionForKeyframeAtIndex(size_t);
151     Ref&lt;const Animation&gt; backingAnimationForCompositedRenderer() const;
152     void computedNeedsForcedLayout();
153     void computeStackingContextImpact();
154     void updateBlendingKeyframes(RenderStyle&amp;);
155     void computeCSSAnimationBlendingKeyframes();
156     void computeCSSTransitionBlendingKeyframes(const RenderStyle* oldStyle, const RenderStyle&amp; newStyle);
157     void computeShouldRunAccelerated();
158     void setBlendingKeyframes(KeyframeList&amp;);
159     void checkForMatchingTransformFunctionLists();
160     void checkForMatchingFilterFunctionLists();
161     void checkForMatchingColorFilterFunctionLists();
162     bool checkForMatchingFilterFunctionLists(CSSPropertyID, const std::function&lt;const FilterOperations&amp; (const RenderStyle&amp;)&gt;&amp;) const;
163 #if ENABLE(FILTERS_LEVEL_2)
164     void checkForMatchingBackdropFilterFunctionLists();
165 #endif
166 
167     KeyframeList m_blendingKeyframes { emptyString() };
168     Vector&lt;ParsedKeyframe&gt; m_parsedKeyframes;
169     Vector&lt;AcceleratedAction&gt; m_pendingAcceleratedActions;
170     RefPtr&lt;Element&gt; m_target;
171 
172     AcceleratedAction m_lastRecordedAcceleratedAction { AcceleratedAction::Stop };
173     IterationCompositeOperation m_iterationCompositeOperation { IterationCompositeOperation::Replace };
174     CompositeOperation m_compositeOperation { CompositeOperation::Replace };
175     bool m_shouldRunAccelerated { false };
176     bool m_needsForcedLayout { false };
177     bool m_triggersStackingContext { false };
178     bool m_transformFunctionListsMatch { false };
179     bool m_filterFunctionListsMatch { false };
180 #if ENABLE(FILTERS_LEVEL_2)
181     bool m_backdropFilterFunctionListsMatch { false };
182 #endif
183     bool m_colorFilterFunctionListsMatch { false };
184 };
185 
186 } // namespace WebCore
187 
188 SPECIALIZE_TYPE_TRAITS_ANIMATION_EFFECT(KeyframeEffect, isKeyframeEffect());
    </pre>
  </body>
</html>
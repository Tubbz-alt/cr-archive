<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingStateScrollingNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingTree.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 69,11 ***</span>
          IntPoint roundedPosition = roundedIntPoint(position);
  
          // Event regions are affected by page scale, so no need to map through scale.
          bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
              || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
<span class="line-modified">!         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent at &quot; &lt;&lt; wheelEvent.position() &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);</span>
  
          if (isSynchronousDispatchRegion)
              return true;
      }
      return false;
<span class="line-new-header">--- 69,11 ---</span>
          IntPoint roundedPosition = roundedIntPoint(position);
  
          // Event regions are affected by page scale, so no need to map through scale.
          bool isSynchronousDispatchRegion = m_treeState.eventTrackingRegions.trackingTypeForPoint(names.wheelEvent, roundedPosition) == TrackingType::Synchronous
              || m_treeState.eventTrackingRegions.trackingTypeForPoint(names.mousewheelEvent, roundedPosition) == TrackingType::Synchronous;
<span class="line-modified">!         LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\n\nScrollingTree::shouldHandleWheelEventSynchronously: wheelEvent &quot; &lt;&lt; wheelEvent &lt;&lt; &quot; mapped to content point &quot; &lt;&lt; position &lt;&lt; &quot;, in non-fast region &quot; &lt;&lt; isSynchronousDispatchRegion);</span>
  
          if (isSynchronousDispatchRegion)
              return true;
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,10 ***</span>
<span class="line-new-header">--- 138,11 ---</span>
      m_rootNode-&gt;wasScrolledByDelegatedScrolling(scrollPosition, layoutViewport);
  }
  
  void ScrollingTree::commitTreeState(std::unique_ptr&lt;ScrollingStateTree&gt; scrollingStateTree)
  {
<span class="line-added">+     SetForScope&lt;bool&gt; inCommitTreeState(m_inCommitTreeState, true);</span>
      LockHolder locker(m_treeMutex);
  
      bool rootStateNodeChanged = scrollingStateTree-&gt;hasNewRootStateNode();
  
      LOG(Scrolling, &quot;\nScrollingTree %p commitTreeState&quot;, this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 149,21 ***</span>
      auto* rootNode = scrollingStateTree-&gt;rootStateNode();
      if (rootNode
          &amp;&amp; (rootStateNodeChanged
              || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
              || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<span class="line-modified">!             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))) {</span>
          LockHolder lock(m_treeStateMutex);
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
              m_treeState.mainFrameScrollPosition = { };
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
              m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
              m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
      }
  
      // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
      // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
      HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
<span class="line-new-header">--- 150,25 ---</span>
      auto* rootNode = scrollingStateTree-&gt;rootStateNode();
      if (rootNode
          &amp;&amp; (rootStateNodeChanged
              || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion)
              || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer)
<span class="line-modified">!             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled)</span>
<span class="line-added">+             || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))) {</span>
          LockHolder lock(m_treeStateMutex);
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateScrollingNode::ScrolledContentsLayer))
              m_treeState.mainFrameScrollPosition = { };
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::EventTrackingRegion))
              m_treeState.eventTrackingRegions = scrollingStateTree-&gt;rootStateNode()-&gt;eventTrackingRegions();
  
          if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::AsyncFrameOrOverflowScrollingEnabled))
              m_asyncFrameOrOverflowScrollingEnabled = scrollingStateTree-&gt;rootStateNode()-&gt;asyncFrameOrOverflowScrollingEnabled();
<span class="line-added">+ </span>
<span class="line-added">+         if (rootStateNodeChanged || rootNode-&gt;hasChangedProperty(ScrollingStateFrameScrollingNode::IsMonitoringWheelEvents))</span>
<span class="line-added">+             m_isMonitoringWheelEvents = scrollingStateTree-&gt;rootStateNode()-&gt;isMonitoringWheelEvents();</span>
      }
  
      // unvisitedNodes starts with all nodes in the map; we remove nodes as we visit them. At the end, it&#39;s the unvisited nodes.
      // We can&#39;t use orphanNodes for this, because orphanNodes won&#39;t contain descendants of removed nodes.
      HashSet&lt;ScrollingNodeID&gt; unvisitedNodes;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 238,17 ***</span>
      }
  
      node-&gt;commitStateBeforeChildren(*stateNode);
  
      // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
<span class="line-modified">!     if (auto nodeChildren = node-&gt;children()) {</span>
<span class="line-modified">!         for (auto&amp; childScrollingNode : *nodeChildren) {</span>
<span class="line-modified">!             childScrollingNode-&gt;setParent(nullptr);</span>
<span class="line-removed">-             orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.get());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         nodeChildren-&gt;clear();</span>
      }
  
      // Now update the children if we have any.
      if (auto children = stateNode-&gt;children()) {
          for (auto&amp; child : *children)
              updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
<span class="line-new-header">--- 243,15 ---</span>
      }
  
      node-&gt;commitStateBeforeChildren(*stateNode);
  
      // Move all children into the orphanNodes map. Live ones will get added back as we recurse over children.
<span class="line-modified">!     for (auto&amp; childScrollingNode : node-&gt;children()) {</span>
<span class="line-modified">!         childScrollingNode-&gt;setParent(nullptr);</span>
<span class="line-modified">!         orphanNodes.add(childScrollingNode-&gt;scrollingNodeID(), childScrollingNode.ptr());</span>
      }
<span class="line-added">+     node-&gt;removeAllChildren();</span>
  
      // Now update the children if we have any.
      if (auto children = stateNode-&gt;children()) {
          for (auto&amp; child : *children)
              updateTreeFromStateNode(child.get(), orphanNodes, unvisitedNodes);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,18 ***</span>
      applyLayerPositionsRecursive(*m_rootNode);
  
      LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);
  }
  
<span class="line-modified">! void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; currNode)</span>
  {
<span class="line-modified">!     currNode.applyLayerPositions();</span>
  
<span class="line-modified">!     if (auto children = currNode.children()) {</span>
<span class="line-modified">!         for (auto&amp; child : *children)</span>
<span class="line-removed">-             applyLayerPositionsRecursive(*child);</span>
<span class="line-removed">-     }</span>
  }
  
  ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
  {
      if (!nodeID)
<span class="line-new-header">--- 283,16 ---</span>
      applyLayerPositionsRecursive(*m_rootNode);
  
      LOG(Scrolling, &quot;ScrollingTree %p applyLayerPositions - done\n&quot;, this);
  }
  
<span class="line-modified">! void ScrollingTree::applyLayerPositionsRecursive(ScrollingTreeNode&amp; node)</span>
  {
<span class="line-modified">!     node.applyLayerPositions();</span>
  
<span class="line-modified">!     for (auto&amp; child : node.children())</span>
<span class="line-modified">!         applyLayerPositionsRecursive(child.get());</span>
  }
  
  ScrollingTreeNode* ScrollingTree::nodeForID(ScrollingNodeID nodeID) const
  {
      if (!nodeID)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,19 ***</span>
  
  void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)
  {
      node.applyLayerPositions();
  
<span class="line-modified">!     if (!node.children())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; child : *node.children()) {</span>
          // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
          if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))
              continue;
  
<span class="line-modified">!         notifyRelatedNodesRecursive(*child);</span>
      }
  }
  
  void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
  {
<span class="line-new-header">--- 319,16 ---</span>
  
  void ScrollingTree::notifyRelatedNodesRecursive(ScrollingTreeNode&amp; node)
  {
      node.applyLayerPositions();
  
<span class="line-modified">!     for (auto&amp; child : node.children()) {</span>
          // Never need to cross frame boundaries, since scroll layer adjustments are isolated to each document.
          if (is&lt;ScrollingTreeFrameScrollingNode&gt;(child))
              continue;
  
<span class="line-modified">!         notifyRelatedNodesRecursive(child.get());</span>
      }
  }
  
  void ScrollingTree::setAsyncFrameOrOverflowScrollingEnabled(bool enabled)
  {
</pre>
<center><a href="ScrollingStateScrollingNode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
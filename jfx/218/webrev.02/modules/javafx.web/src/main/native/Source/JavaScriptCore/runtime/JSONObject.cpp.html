<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSONObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSONObject.h&quot;
 28 
 29 #include &quot;ArrayConstructor.h&quot;
 30 #include &quot;BigIntObject.h&quot;
 31 #include &quot;BooleanObject.h&quot;
 32 #include &quot;Error.h&quot;
 33 #include &quot;ExceptionHelpers.h&quot;
 34 #include &quot;JSArray.h&quot;
 35 #include &quot;JSArrayInlines.h&quot;
 36 #include &quot;JSGlobalObject.h&quot;
 37 #include &quot;LiteralParser.h&quot;
 38 #include &quot;Lookup.h&quot;
 39 #include &quot;ObjectConstructor.h&quot;
 40 #include &quot;JSCInlines.h&quot;
 41 #include &quot;PropertyNameArray.h&quot;
 42 #include &lt;wtf/MathExtras.h&gt;
 43 #include &lt;wtf/text/StringBuilder.h&gt;
 44 
 45 namespace JSC {
 46 
 47 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSONObject);
 48 
 49 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject*, CallFrame*);
 50 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject*, CallFrame*);
 51 
 52 }
 53 
 54 #include &quot;JSONObject.lut.h&quot;
 55 
 56 namespace JSC {
 57 
 58 JSONObject::JSONObject(VM&amp; vm, Structure* structure)
 59     : JSNonFinalObject(vm, structure)
 60 {
 61 }
 62 
 63 void JSONObject::finishCreation(VM&amp; vm)
 64 {
 65     Base::finishCreation(vm);
 66     ASSERT(inherits(vm, info()));
 67 
 68     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsNontrivialString(vm, &quot;JSON&quot;_s), PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 69 }
 70 
 71 // PropertyNameForFunctionCall objects must be on the stack, since the JSValue that they create is not marked.
 72 class PropertyNameForFunctionCall {
 73 public:
 74     PropertyNameForFunctionCall(const Identifier&amp;);
 75     PropertyNameForFunctionCall(unsigned);
 76 
 77     JSValue value(JSGlobalObject*) const;
 78 
 79 private:
 80     const Identifier* m_identifier;
 81     unsigned m_number;
 82     mutable JSValue m_value;
 83 };
 84 
 85 class Stringifier {
 86     WTF_MAKE_NONCOPYABLE(Stringifier);
 87     WTF_FORBID_HEAP_ALLOCATION;
 88 public:
 89     Stringifier(JSGlobalObject*, JSValue replacer, JSValue space);
 90     JSValue stringify(JSValue);
 91 
 92 private:
 93     class Holder {
 94     public:
 95         enum RootHolderTag { RootHolder };
 96         Holder(JSGlobalObject*, JSObject*);
 97         Holder(RootHolderTag, JSObject*);
 98 
 99         JSObject* object() const { return m_object; }
100         bool isArray() const { return m_isArray; }
101 
102         bool appendNextProperty(Stringifier&amp;, StringBuilder&amp;);
103 
104     private:
105         JSObject* m_object;
106         const bool m_isJSArray;
107         const bool m_isArray;
108         unsigned m_index { 0 };
109         unsigned m_size { 0 };
110         RefPtr&lt;PropertyNameArrayData&gt; m_propertyNames;
111     };
112 
113     friend class Holder;
114 
115     JSValue toJSON(JSValue, const PropertyNameForFunctionCall&amp;);
116     JSValue toJSONImpl(VM&amp;, JSValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp;);
117 
118     enum StringifyResult { StringifyFailed, StringifySucceeded, StringifyFailedDueToUndefinedOrSymbolValue };
119     StringifyResult appendStringifiedValue(StringBuilder&amp;, JSValue, const Holder&amp;, const PropertyNameForFunctionCall&amp;);
120 
121     bool willIndent() const;
122     void indent();
123     void unindent();
124     void startNewLine(StringBuilder&amp;) const;
125     bool isCallableReplacer() const { return m_replacerCallType != CallType::None; }
126 
127     JSGlobalObject* const m_globalObject;
128     JSValue m_replacer;
129     bool m_usingArrayReplacer { false };
130     PropertyNameArray m_arrayReplacerPropertyNames;
131     CallType m_replacerCallType { CallType::None };
132     CallData m_replacerCallData;
133     String m_gap;
134 
135     MarkedArgumentBuffer m_objectStack;
136     Vector&lt;Holder, 16, UnsafeVectorOverflow&gt; m_holderStack;
137     String m_repeatedGap;
138     String m_indent;
139 };
140 
141 // ------------------------------ helper functions --------------------------------
142 
143 static inline JSValue unwrapBoxedPrimitive(JSGlobalObject* globalObject, JSValue value)
144 {
145     VM&amp; vm = globalObject-&gt;vm();
146     if (!value.isObject())
147         return value;
148     JSObject* object = asObject(value);
149     if (object-&gt;inherits&lt;NumberObject&gt;(vm))
150         return jsNumber(object-&gt;toNumber(globalObject));
151     if (object-&gt;inherits&lt;StringObject&gt;(vm))
152         return object-&gt;toString(globalObject);
153     if (object-&gt;inherits&lt;BooleanObject&gt;(vm) || object-&gt;inherits&lt;BigIntObject&gt;(vm))
154         return jsCast&lt;JSWrapperObject*&gt;(object)-&gt;internalValue();
155 
156     // Do not unwrap SymbolObject to Symbol. It is not performed in the spec.
157     // http://www.ecma-international.org/ecma-262/6.0/#sec-serializejsonproperty
158     return value;
159 }
160 
161 static inline String gap(JSGlobalObject* globalObject, JSValue space)
162 {
163     VM&amp; vm = globalObject-&gt;vm();
164     auto scope = DECLARE_THROW_SCOPE(vm);
165 
166     const unsigned maxGapLength = 10;
167     space = unwrapBoxedPrimitive(globalObject, space);
168     RETURN_IF_EXCEPTION(scope, { });
169 
170     // If the space value is a number, create a gap string with that number of spaces.
171     if (space.isNumber()) {
172         double spaceCount = space.asNumber();
173         int count;
174         if (spaceCount &gt; maxGapLength)
175             count = maxGapLength;
176         else if (!(spaceCount &gt; 0))
177             count = 0;
178         else
179             count = static_cast&lt;int&gt;(spaceCount);
180         char spaces[maxGapLength];
181         for (int i = 0; i &lt; count; ++i)
182             spaces[i] = &#39; &#39;;
183         return String(spaces, count);
184     }
185 
186     // If the space value is a string, use it as the gap string, otherwise use no gap string.
187     String spaces = space.getString(globalObject);
188     RETURN_IF_EXCEPTION(scope, { });
189     if (spaces.length() &lt;= maxGapLength)
190         return spaces;
191     return spaces.substringSharingImpl(0, maxGapLength);
192 }
193 
194 // ------------------------------ PropertyNameForFunctionCall --------------------------------
195 
196 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(const Identifier&amp; identifier)
197     : m_identifier(&amp;identifier)
198 {
199 }
200 
201 inline PropertyNameForFunctionCall::PropertyNameForFunctionCall(unsigned number)
202     : m_identifier(0)
203     , m_number(number)
204 {
205 }
206 
207 JSValue PropertyNameForFunctionCall::value(JSGlobalObject* globalObject) const
208 {
209     if (!m_value) {
210         VM&amp; vm = globalObject-&gt;vm();
211         if (m_identifier)
212             m_value = jsString(vm, m_identifier-&gt;string());
213         else {
214             if (m_number &lt;= 9)
215                 return vm.smallStrings.singleCharacterString(m_number + &#39;0&#39;);
216             m_value = jsNontrivialString(vm, vm.numericStrings.add(m_number));
217         }
218     }
219     return m_value;
220 }
221 
222 // ------------------------------ Stringifier --------------------------------
223 
224 Stringifier::Stringifier(JSGlobalObject* globalObject, JSValue replacer, JSValue space)
225     : m_globalObject(globalObject)
226     , m_replacer(replacer)
227     , m_arrayReplacerPropertyNames(globalObject-&gt;vm(), PropertyNameMode::Strings, PrivateSymbolMode::Exclude)
228 {
229     VM&amp; vm = globalObject-&gt;vm();
230     auto scope = DECLARE_THROW_SCOPE(vm);
231 
232     if (m_replacer.isObject()) {
233         JSObject* replacerObject = asObject(m_replacer);
234 
235         m_replacerCallType = CallType::None;
236         if (!replacerObject-&gt;isCallable(vm, m_replacerCallType, m_replacerCallData)) {
237             bool isArrayReplacer = JSC::isArray(globalObject, replacerObject);
238             RETURN_IF_EXCEPTION(scope, );
239             if (isArrayReplacer) {
240                 m_usingArrayReplacer = true;
241                 unsigned length = toLength(globalObject, replacerObject);
242                 RETURN_IF_EXCEPTION(scope, );
243                 for (unsigned index = 0; index &lt; length; ++index) {
244                     JSValue name;
245                     if (isJSArray(replacerObject) &amp;&amp; replacerObject-&gt;canGetIndexQuickly(index))
246                         name = replacerObject-&gt;getIndexQuickly(index);
247                     else {
248                         name = replacerObject-&gt;get(globalObject, index);
249                         RETURN_IF_EXCEPTION(scope, );
250                     }
251                     if (name.isObject()) {
252                         auto* nameObject = jsCast&lt;JSObject*&gt;(name);
253                         if (!nameObject-&gt;inherits&lt;NumberObject&gt;(vm) &amp;&amp; !nameObject-&gt;inherits&lt;StringObject&gt;(vm))
254                             continue;
255                     } else if (!name.isNumber() &amp;&amp; !name.isString())
256                         continue;
257                     JSString* propertyNameString = name.toString(globalObject);
258                     RETURN_IF_EXCEPTION(scope, );
259                     auto propertyName = propertyNameString-&gt;toIdentifier(globalObject);
260                     RETURN_IF_EXCEPTION(scope, );
261                     m_arrayReplacerPropertyNames.add(WTFMove(propertyName));
262                 }
263             }
264         }
265     }
266 
267     scope.release();
268     m_gap = gap(globalObject, space);
269 }
270 
271 JSValue Stringifier::stringify(JSValue value)
272 {
273     VM&amp; vm = m_globalObject-&gt;vm();
274     auto scope = DECLARE_THROW_SCOPE(vm);
275 
276     PropertyNameForFunctionCall emptyPropertyName(vm.propertyNames-&gt;emptyIdentifier);
277 
278     // If the replacer is not callable, root object wrapper is non-user-observable.
279     // We can skip creating this wrapper object.
280     JSObject* object = nullptr;
281     if (isCallableReplacer()) {
282         object = constructEmptyObject(m_globalObject);
283         object-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, value);
284     }
285 
286     StringBuilder result(StringBuilder::OverflowHandler::RecordOverflow);
287     Holder root(Holder::RootHolder, object);
288     auto stringifyResult = appendStringifiedValue(result, value, root, emptyPropertyName);
289     RETURN_IF_EXCEPTION(scope, jsUndefined());
290     if (UNLIKELY(result.hasOverflowed())) {
291         throwOutOfMemoryError(m_globalObject, scope);
292         return jsUndefined();
293     }
294     if (UNLIKELY(stringifyResult != StringifySucceeded))
295         return jsUndefined();
296     RELEASE_AND_RETURN(scope, jsString(vm, result.toString()));
297 }
298 
299 ALWAYS_INLINE JSValue Stringifier::toJSON(JSValue baseValue, const PropertyNameForFunctionCall&amp; propertyName)
300 {
301     VM&amp; vm = m_globalObject-&gt;vm();
302     auto scope = DECLARE_THROW_SCOPE(vm);
303     scope.assertNoException();
304 
305     PropertySlot slot(baseValue, PropertySlot::InternalMethodType::Get);
306     bool hasProperty = baseValue.getPropertySlot(m_globalObject, vm.propertyNames-&gt;toJSON, slot);
307     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
308     if (!hasProperty)
309         return baseValue;
310 
311     JSValue toJSONFunction = slot.getValue(m_globalObject, vm.propertyNames-&gt;toJSON);
312     RETURN_IF_EXCEPTION(scope, { });
313     RELEASE_AND_RETURN(scope, toJSONImpl(vm, baseValue, toJSONFunction, propertyName));
314 }
315 
316 JSValue Stringifier::toJSONImpl(VM&amp; vm, JSValue baseValue, JSValue toJSONFunction, const PropertyNameForFunctionCall&amp; propertyName)
317 {
318     CallType callType;
319     CallData callData;
320     if (!toJSONFunction.isCallable(vm, callType, callData))
321         return baseValue;
322 
323     MarkedArgumentBuffer args;
324     args.append(propertyName.value(m_globalObject));
325     ASSERT(!args.hasOverflowed());
326     return call(m_globalObject, asObject(toJSONFunction), callType, callData, baseValue, args);
327 }
328 
329 Stringifier::StringifyResult Stringifier::appendStringifiedValue(StringBuilder&amp; builder, JSValue value, const Holder&amp; holder, const PropertyNameForFunctionCall&amp; propertyName)
330 {
331     VM&amp; vm = m_globalObject-&gt;vm();
332     auto scope = DECLARE_THROW_SCOPE(vm);
333 
334     // Call the toJSON function.
335     if (value.isObject() || value.isBigInt()) {
336         value = toJSON(value, propertyName);
337         RETURN_IF_EXCEPTION(scope, StringifyFailed);
338     }
339 
340     // Call the replacer function.
341     if (isCallableReplacer()) {
342         MarkedArgumentBuffer args;
343         args.append(propertyName.value(m_globalObject));
344         args.append(value);
345         ASSERT(!args.hasOverflowed());
346         ASSERT(holder.object());
347         value = call(m_globalObject, m_replacer, m_replacerCallType, m_replacerCallData, holder.object(), args);
348         RETURN_IF_EXCEPTION(scope, StringifyFailed);
349     }
350 
351     if ((value.isUndefined() || value.isSymbol()) &amp;&amp; !holder.isArray())
352         return StringifyFailedDueToUndefinedOrSymbolValue;
353 
354     if (value.isNull()) {
355         builder.appendLiteral(&quot;null&quot;);
356         return StringifySucceeded;
357     }
358 
359     value = unwrapBoxedPrimitive(m_globalObject, value);
360 
361     RETURN_IF_EXCEPTION(scope, StringifyFailed);
362 
363     if (value.isBoolean()) {
364         if (value.isTrue())
365             builder.appendLiteral(&quot;true&quot;);
366         else
367             builder.appendLiteral(&quot;false&quot;);
368         return StringifySucceeded;
369     }
370 
371     if (value.isString()) {
372         const String&amp; string = asString(value)-&gt;value(m_globalObject);
373         RETURN_IF_EXCEPTION(scope, StringifyFailed);
374         builder.appendQuotedJSONString(string);
375         return StringifySucceeded;
376     }
377 
378     if (value.isNumber()) {
379         if (value.isInt32())
380             builder.appendNumber(value.asInt32());
381         else {
382             double number = value.asNumber();
383             if (!std::isfinite(number))
384                 builder.appendLiteral(&quot;null&quot;);
385             else
386                 builder.appendNumber(number);
387         }
388         return StringifySucceeded;
389     }
390 
391     if (value.isBigInt()) {
392         throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize BigInt.&quot;_s);
393         return StringifyFailed;
394     }
395 
396     if (!value.isObject())
397         return StringifyFailed;
398 
399     JSObject* object = asObject(value);
400     if (object-&gt;isFunction(vm)) {
401         if (holder.isArray()) {
402             builder.appendLiteral(&quot;null&quot;);
403             return StringifySucceeded;
404         }
405         return StringifyFailedDueToUndefinedOrSymbolValue;
406     }
407 
408     if (UNLIKELY(builder.hasOverflowed()))
409         return StringifyFailed;
410 
411     // Handle cycle detection, and put the holder on the stack.
412     for (unsigned i = 0; i &lt; m_holderStack.size(); i++) {
413         if (m_holderStack[i].object() == object) {
414             throwTypeError(m_globalObject, scope, &quot;JSON.stringify cannot serialize cyclic structures.&quot;_s);
415             return StringifyFailed;
416         }
417     }
418 
419     bool holderStackWasEmpty = m_holderStack.isEmpty();
420     m_holderStack.append(Holder(m_globalObject, object));
421     m_objectStack.appendWithCrashOnOverflow(object);
422     RETURN_IF_EXCEPTION(scope, StringifyFailed);
423     if (!holderStackWasEmpty)
424         return StringifySucceeded;
425 
426     do {
427         while (m_holderStack.last().appendNextProperty(*this, builder))
428             RETURN_IF_EXCEPTION(scope, StringifyFailed);
429         RETURN_IF_EXCEPTION(scope, StringifyFailed);
430         if (UNLIKELY(builder.hasOverflowed()))
431             return StringifyFailed;
432         m_holderStack.removeLast();
433         m_objectStack.removeLast();
434     } while (!m_holderStack.isEmpty());
435     return StringifySucceeded;
436 }
437 
438 inline bool Stringifier::willIndent() const
439 {
440     return !m_gap.isEmpty();
441 }
442 
443 inline void Stringifier::indent()
444 {
445     // Use a single shared string, m_repeatedGap, so we don&#39;t keep allocating new ones as we indent and unindent.
446     unsigned newSize = m_indent.length() + m_gap.length();
447     if (newSize &gt; m_repeatedGap.length())
448         m_repeatedGap = makeString(m_repeatedGap, m_gap);
449     ASSERT(newSize &lt;= m_repeatedGap.length());
450     m_indent = m_repeatedGap.substringSharingImpl(0, newSize);
451 }
452 
453 inline void Stringifier::unindent()
454 {
455     ASSERT(m_indent.length() &gt;= m_gap.length());
456     m_indent = m_repeatedGap.substringSharingImpl(0, m_indent.length() - m_gap.length());
457 }
458 
459 inline void Stringifier::startNewLine(StringBuilder&amp; builder) const
460 {
461     if (m_gap.isEmpty())
462         return;
463     builder.append(&#39;\n&#39;);
464     builder.append(m_indent);
465 }
466 
467 inline Stringifier::Holder::Holder(JSGlobalObject* globalObject, JSObject* object)
468     : m_object(object)
469     , m_isJSArray(isJSArray(object))
470     , m_isArray(JSC::isArray(globalObject, object))
471 {
472 }
473 
474 inline Stringifier::Holder::Holder(RootHolderTag, JSObject* object)
475     : m_object(object)
476     , m_isJSArray(false)
477     , m_isArray(false)
478 {
479 }
480 
481 bool Stringifier::Holder::appendNextProperty(Stringifier&amp; stringifier, StringBuilder&amp; builder)
482 {
483     ASSERT(m_index &lt;= m_size);
484 
485     JSGlobalObject* globalObject = stringifier.m_globalObject;
486     VM&amp; vm = globalObject-&gt;vm();
487     auto scope = DECLARE_THROW_SCOPE(vm);
488 
489     // First time through, initialize.
490     if (!m_index) {
491         if (m_isArray) {
492             m_size = toLength(globalObject, m_object);
493             RETURN_IF_EXCEPTION(scope, false);
494             builder.append(&#39;[&#39;);
495         } else {
496             if (stringifier.m_usingArrayReplacer)
497                 m_propertyNames = stringifier.m_arrayReplacerPropertyNames.data();
498             else {
499                 PropertyNameArray objectPropertyNames(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude);
500                 m_object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(m_object, globalObject, objectPropertyNames, EnumerationMode());
501                 RETURN_IF_EXCEPTION(scope, false);
502                 m_propertyNames = objectPropertyNames.releaseData();
503             }
504             m_size = m_propertyNames-&gt;propertyNameVector().size();
505             builder.append(&#39;{&#39;);
506         }
507         stringifier.indent();
508     }
509     if (UNLIKELY(builder.hasOverflowed()))
510         return false;
511 
512     // Last time through, finish up and return false.
513     if (m_index == m_size) {
514         stringifier.unindent();
515         if (m_size &amp;&amp; builder[builder.length() - 1] != &#39;{&#39;)
516             stringifier.startNewLine(builder);
517         builder.append(m_isArray ? &#39;]&#39; : &#39;}&#39;);
518         return false;
519     }
520 
521     // Handle a single element of the array or object.
522     unsigned index = m_index++;
523     unsigned rollBackPoint = 0;
524     StringifyResult stringifyResult;
525     if (m_isArray) {
526         // Get the value.
527         JSValue value;
528         if (m_isJSArray &amp;&amp; m_object-&gt;canGetIndexQuickly(index))
529             value = m_object-&gt;getIndexQuickly(index);
530         else {
531             PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
532             bool hasProperty = m_object-&gt;getPropertySlot(globalObject, index, slot);
533             EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
534             if (hasProperty)
535                 value = slot.getValue(globalObject, index);
536             else
537                 value = jsUndefined();
538             RETURN_IF_EXCEPTION(scope, false);
539         }
540 
541         // Append the separator string.
542         if (index)
543             builder.append(&#39;,&#39;);
544         stringifier.startNewLine(builder);
545 
546         // Append the stringified value.
547         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, index);
548         ASSERT(stringifyResult != StringifyFailedDueToUndefinedOrSymbolValue);
549     } else {
550         // Get the value.
551         PropertySlot slot(m_object, PropertySlot::InternalMethodType::Get);
552         Identifier&amp; propertyName = m_propertyNames-&gt;propertyNameVector()[index];
553         bool hasProperty = m_object-&gt;getPropertySlot(globalObject, propertyName, slot);
554         EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
555         if (!hasProperty)
556             return true;
557         JSValue value = slot.getValue(globalObject, propertyName);
558         RETURN_IF_EXCEPTION(scope, false);
559 
560         rollBackPoint = builder.length();
561 
562         // Append the separator string.
563         if (builder[rollBackPoint - 1] != &#39;{&#39;)
564             builder.append(&#39;,&#39;);
565         stringifier.startNewLine(builder);
566 
567         // Append the property name.
568         builder.appendQuotedJSONString(propertyName.string());
569         builder.append(&#39;:&#39;);
570         if (stringifier.willIndent())
571             builder.append(&#39; &#39;);
572 
573         // Append the stringified value.
574         stringifyResult = stringifier.appendStringifiedValue(builder, value, *this, propertyName);
575     }
576     RETURN_IF_EXCEPTION(scope, false);
577 
578     // From this point on, no access to the this pointer or to any members, because the
579     // Holder object may have moved if the call to stringify pushed a new Holder onto
580     // m_holderStack.
581 
582     switch (stringifyResult) {
583         case StringifyFailed:
584             builder.appendLiteral(&quot;null&quot;);
585             break;
586         case StringifySucceeded:
587             break;
588         case StringifyFailedDueToUndefinedOrSymbolValue:
589             // This only occurs when get an undefined value or a symbol value for
590             // an object property. In this case we don&#39;t want the separator and
591             // property name that we already appended, so roll back.
592             builder.resize(rollBackPoint);
593             break;
594     }
595 
596     return true;
597 }
598 
599 // ------------------------------ JSONObject --------------------------------
600 
601 const ClassInfo JSONObject::s_info = { &quot;JSON&quot;, &amp;JSNonFinalObject::s_info, &amp;jsonTable, nullptr, CREATE_METHOD_TABLE(JSONObject) };
602 
603 /* Source for JSONObject.lut.h
604 @begin jsonTable
605   parse         JSONProtoFuncParse             DontEnum|Function 2
606   stringify     JSONProtoFuncStringify         DontEnum|Function 3
607 @end
608 */
609 
610 // ECMA 15.8
611 
612 class Walker {
613     WTF_MAKE_NONCOPYABLE(Walker);
614     WTF_FORBID_HEAP_ALLOCATION;
615 public:
616     Walker(JSGlobalObject* globalObject, JSObject* function, CallType callType, CallData callData)
617         : m_globalObject(globalObject)
618         , m_function(function)
619         , m_callType(callType)
620         , m_callData(callData)
621     {
622     }
623     JSValue walk(JSValue unfiltered);
624 private:
625     JSValue callReviver(JSObject* thisObj, JSValue property, JSValue unfiltered)
626     {
627         MarkedArgumentBuffer args;
628         args.append(property);
629         args.append(unfiltered);
630         ASSERT(!args.hasOverflowed());
631         return call(m_globalObject, m_function, m_callType, m_callData, thisObj, args);
632     }
633 
634     friend class Holder;
635 
636     JSGlobalObject* m_globalObject;
637     JSObject* m_function;
638     CallType m_callType;
639     CallData m_callData;
640 };
641 
642 // We clamp recursion well beyond anything reasonable.
643 static constexpr unsigned maximumFilterRecursion = 40000;
644 enum WalkerState { StateUnknown, ArrayStartState, ArrayStartVisitMember, ArrayEndVisitMember,
645                                  ObjectStartState, ObjectStartVisitMember, ObjectEndVisitMember };
646 NEVER_INLINE JSValue Walker::walk(JSValue unfiltered)
647 {
648     VM&amp; vm = m_globalObject-&gt;vm();
649     auto scope = DECLARE_THROW_SCOPE(vm);
650 
651     Vector&lt;PropertyNameArray, 16, UnsafeVectorOverflow&gt; propertyStack;
652     Vector&lt;uint32_t, 16, UnsafeVectorOverflow&gt; indexStack;
653     MarkedArgumentBuffer markedStack;
654     Vector&lt;unsigned, 16, UnsafeVectorOverflow&gt; arrayLengthStack;
655 
656     Vector&lt;WalkerState, 16, UnsafeVectorOverflow&gt; stateStack;
657     WalkerState state = StateUnknown;
658     JSValue inValue = unfiltered;
659     JSValue outValue = jsNull();
660 
661     while (1) {
662         switch (state) {
663             arrayStartState:
664             case ArrayStartState: {
665                 ASSERT(inValue.isObject());
666                 ASSERT(isArray(m_globalObject, inValue));
667                 EXCEPTION_ASSERT(!scope.exception());
668 
669                 if (markedStack.size() &gt; maximumFilterRecursion)
670                     return throwStackOverflowError(m_globalObject, scope);
671 
672                 JSObject* array = asObject(inValue);
673                 markedStack.appendWithCrashOnOverflow(array);
674                 unsigned length = toLength(m_globalObject, array);
675                 RETURN_IF_EXCEPTION(scope, { });
676                 arrayLengthStack.append(length);
677                 indexStack.append(0);
678             }
679             arrayStartVisitMember:
680             FALLTHROUGH;
681             case ArrayStartVisitMember: {
682                 JSObject* array = asObject(markedStack.last());
683                 uint32_t index = indexStack.last();
684                 unsigned arrayLength = arrayLengthStack.last();
685                 if (index == arrayLength) {
686                     outValue = array;
687                     markedStack.removeLast();
688                     arrayLengthStack.removeLast();
689                     indexStack.removeLast();
690                     break;
691                 }
692                 if (isJSArray(array) &amp;&amp; array-&gt;canGetIndexQuickly(index))
693                     inValue = array-&gt;getIndexQuickly(index);
694                 else {
695                     inValue = array-&gt;get(m_globalObject, index);
696                     RETURN_IF_EXCEPTION(scope, { });
697                 }
698 
699                 if (inValue.isObject()) {
700                     stateStack.append(ArrayEndVisitMember);
701                     goto stateUnknown;
702                 } else
703                     outValue = inValue;
704                 FALLTHROUGH;
705             }
706             case ArrayEndVisitMember: {
707                 JSObject* array = asObject(markedStack.last());
708                 JSValue filteredValue = callReviver(array, jsString(vm, String::number(indexStack.last())), outValue);
709                 RETURN_IF_EXCEPTION(scope, { });
710                 if (filteredValue.isUndefined())
711                     array-&gt;methodTable(vm)-&gt;deletePropertyByIndex(array, m_globalObject, indexStack.last());
712                 else
713                     array-&gt;putDirectIndex(m_globalObject, indexStack.last(), filteredValue, 0, PutDirectIndexShouldNotThrow);
714                 RETURN_IF_EXCEPTION(scope, { });
715                 indexStack.last()++;
716                 goto arrayStartVisitMember;
717             }
718             objectStartState:
719             case ObjectStartState: {
720                 ASSERT(inValue.isObject());
721                 ASSERT(!isJSArray(inValue));
722                 if (markedStack.size() &gt; maximumFilterRecursion)
723                     return throwStackOverflowError(m_globalObject, scope);
724 
725                 JSObject* object = asObject(inValue);
726                 markedStack.appendWithCrashOnOverflow(object);
727                 indexStack.append(0);
728                 propertyStack.append(PropertyNameArray(vm, PropertyNameMode::Strings, PrivateSymbolMode::Exclude));
729                 object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, m_globalObject, propertyStack.last(), EnumerationMode());
730                 RETURN_IF_EXCEPTION(scope, { });
731             }
732             objectStartVisitMember:
733             FALLTHROUGH;
734             case ObjectStartVisitMember: {
735                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
736                 uint32_t index = indexStack.last();
737                 PropertyNameArray&amp; properties = propertyStack.last();
738                 if (index == properties.size()) {
739                     outValue = object;
740                     markedStack.removeLast();
741                     indexStack.removeLast();
742                     propertyStack.removeLast();
743                     break;
744                 }
745                 inValue = object-&gt;get(m_globalObject, properties[index]);
746                 // The holder may be modified by the reviver function so any lookup may throw
747                 RETURN_IF_EXCEPTION(scope, { });
748 
749                 if (inValue.isObject()) {
750                     stateStack.append(ObjectEndVisitMember);
751                     goto stateUnknown;
752                 } else
753                     outValue = inValue;
754                 FALLTHROUGH;
755             }
756             case ObjectEndVisitMember: {
757                 JSObject* object = jsCast&lt;JSObject*&gt;(markedStack.last());
758                 Identifier prop = propertyStack.last()[indexStack.last()];
759                 PutPropertySlot slot(object);
760                 JSValue filteredValue = callReviver(object, jsString(vm, prop.string()), outValue);
761                 RETURN_IF_EXCEPTION(scope, { });
762                 if (filteredValue.isUndefined())
763                     object-&gt;methodTable(vm)-&gt;deleteProperty(object, m_globalObject, prop);
764                 else
765                     object-&gt;methodTable(vm)-&gt;put(object, m_globalObject, prop, filteredValue, slot);
766                 RETURN_IF_EXCEPTION(scope, { });
767                 indexStack.last()++;
768                 goto objectStartVisitMember;
769             }
770             stateUnknown:
771             case StateUnknown:
772                 if (!inValue.isObject()) {
773                     outValue = inValue;
774                     break;
775                 }
776                 bool valueIsArray = isArray(m_globalObject, inValue);
777                 RETURN_IF_EXCEPTION(scope, { });
778                 if (valueIsArray)
779                     goto arrayStartState;
780                 goto objectStartState;
781         }
782         if (stateStack.isEmpty())
783             break;
784 
785         state = stateStack.last();
786         stateStack.removeLast();
787     }
788     JSObject* finalHolder = constructEmptyObject(m_globalObject);
789     finalHolder-&gt;putDirect(vm, vm.propertyNames-&gt;emptyIdentifier, outValue);
790     RELEASE_AND_RETURN(scope, callReviver(finalHolder, jsEmptyString(vm), outValue));
791 }
792 
793 // ECMA-262 v5 15.12.2
794 EncodedJSValue JSC_HOST_CALL JSONProtoFuncParse(JSGlobalObject* globalObject, CallFrame* callFrame)
795 {
796     VM&amp; vm = globalObject-&gt;vm();
797     auto scope = DECLARE_THROW_SCOPE(vm);
798     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);
799     RETURN_IF_EXCEPTION(scope, { });
800     StringView view = viewWithString.view;
801 
802     JSValue unfiltered;
803     if (view.is8Bit()) {
804         LiteralParser&lt;LChar&gt; jsonParser(globalObject, view.characters8(), view.length(), StrictJSON);
805         unfiltered = jsonParser.tryLiteralParse();
806         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
807         if (!unfiltered) {
808             RETURN_IF_EXCEPTION(scope, { });
809             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));
810         }
811     } else {
812         LiteralParser&lt;UChar&gt; jsonParser(globalObject, view.characters16(), view.length(), StrictJSON);
813         unfiltered = jsonParser.tryLiteralParse();
814         EXCEPTION_ASSERT(!scope.exception() || !unfiltered);
815         if (!unfiltered) {
816             RETURN_IF_EXCEPTION(scope, { });
817             return throwVMError(globalObject, scope, createSyntaxError(globalObject, jsonParser.getErrorMessage()));
818         }
819     }
820 
821     if (callFrame-&gt;argumentCount() &lt; 2)
822         return JSValue::encode(unfiltered);
823 
824     JSValue function = callFrame-&gt;uncheckedArgument(1);
825     CallData callData;
826     CallType callType = getCallData(vm, function, callData);
827     if (callType == CallType::None)
828         return JSValue::encode(unfiltered);
829     scope.release();
830     Walker walker(globalObject, asObject(function), callType, callData);
831     return JSValue::encode(walker.walk(unfiltered));
832 }
833 
834 // ECMA-262 v5 15.12.3
835 EncodedJSValue JSC_HOST_CALL JSONProtoFuncStringify(JSGlobalObject* globalObject, CallFrame* callFrame)
836 {
837     VM&amp; vm = globalObject-&gt;vm();
838     auto scope = DECLARE_THROW_SCOPE(vm);
839 
840     Stringifier stringifier(globalObject, callFrame-&gt;argument(1), callFrame-&gt;argument(2));
841     RETURN_IF_EXCEPTION(scope, { });
842     RELEASE_AND_RETURN(scope, JSValue::encode(stringifier.stringify(callFrame-&gt;argument(0))));
843 }
844 
845 JSValue JSONParse(JSGlobalObject* globalObject, const String&amp; json)
846 {
847     if (json.isNull())
848         return JSValue();
849 
850     if (json.is8Bit()) {
851         LiteralParser&lt;LChar&gt; jsonParser(globalObject, json.characters8(), json.length(), StrictJSON);
852         return jsonParser.tryLiteralParse();
853     }
854 
855     LiteralParser&lt;UChar&gt; jsonParser(globalObject, json.characters16(), json.length(), StrictJSON);
856     return jsonParser.tryLiteralParse();
857 }
858 
859 String JSONStringify(JSGlobalObject* globalObject, JSValue value, JSValue space)
860 {
861     VM&amp; vm = globalObject-&gt;vm();
862     auto throwScope = DECLARE_THROW_SCOPE(vm);
863     Stringifier stringifier(globalObject, jsNull(), space);
864     RETURN_IF_EXCEPTION(throwScope, { });
865     JSValue result = stringifier.stringify(value);
866     if (UNLIKELY(throwScope.exception()) || result.isUndefinedOrNull())
867         return String();
868     return result.getString(globalObject);
869 }
870 
871 String JSONStringify(JSGlobalObject* globalObject, JSValue value, unsigned indent)
872 {
873     return JSONStringify(globalObject, value, jsNumber(indent));
874 }
875 
876 } // namespace JSC
    </pre>
  </body>
</html>
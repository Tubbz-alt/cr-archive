<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkingConstraintSolver.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MarkingConstraintSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MutatorState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkingConstraintSolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 44 
 45 MarkingConstraintSolver::~MarkingConstraintSolver()
 46 {
 47 }
 48 
 49 bool MarkingConstraintSolver::didVisitSomething() const
 50 {
 51     for (const VisitCounter&amp; visitCounter : m_visitCounters) {
 52         if (visitCounter.visitCount())
 53             return true;
 54     }
 55     return false;
 56 }
 57 
 58 void MarkingConstraintSolver::execute(SchedulerPreference preference, ScopedLambda&lt;Optional&lt;unsigned&gt;()&gt; pickNext)
 59 {
 60     m_pickNextIsStillActive = true;
 61     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 62 
 63     if (Options::useParallelMarkingConstraintSolver()) {
<span class="line-modified"> 64         if (Options::logGC())</span>
<span class="line-removed"> 65             dataLog(preference == ParallelWorkFirst ? &quot;P&quot; : &quot;N&quot;, &quot;&lt;&quot;);</span>
 66 
 67         m_heap.runFunctionInParallel(
 68             [&amp;] (SlotVisitor&amp; visitor) { runExecutionThread(visitor, preference, pickNext); });
 69 
<span class="line-modified"> 70         if (Options::logGC())</span>
<span class="line-removed"> 71             dataLog(&quot;&gt;&quot;);</span>
 72     } else
 73         runExecutionThread(m_mainVisitor, preference, pickNext);
 74 
 75     RELEASE_ASSERT(!m_pickNextIsStillActive);
 76     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 77 
 78     if (!m_toExecuteSequentially.isEmpty()) {
 79         for (unsigned indexToRun : m_toExecuteSequentially)
 80             execute(*m_set.m_set[indexToRun]);
 81         m_toExecuteSequentially.clear();
 82     }
 83 
 84     RELEASE_ASSERT(m_toExecuteInParallel.isEmpty());
 85 }
 86 
 87 void MarkingConstraintSolver::drain(BitVector&amp; unexecuted)
 88 {
 89     auto iter = unexecuted.begin();
 90     auto end = unexecuted.end();
 91     if (iter == end)
</pre>
</td>
<td>
<hr />
<pre>
 44 
 45 MarkingConstraintSolver::~MarkingConstraintSolver()
 46 {
 47 }
 48 
 49 bool MarkingConstraintSolver::didVisitSomething() const
 50 {
 51     for (const VisitCounter&amp; visitCounter : m_visitCounters) {
 52         if (visitCounter.visitCount())
 53             return true;
 54     }
 55     return false;
 56 }
 57 
 58 void MarkingConstraintSolver::execute(SchedulerPreference preference, ScopedLambda&lt;Optional&lt;unsigned&gt;()&gt; pickNext)
 59 {
 60     m_pickNextIsStillActive = true;
 61     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 62 
 63     if (Options::useParallelMarkingConstraintSolver()) {
<span class="line-modified"> 64         dataLogIf(Options::logGC(), preference == ParallelWorkFirst ? &quot;P&quot; : &quot;N&quot;, &quot;&lt;&quot;);</span>

 65 
 66         m_heap.runFunctionInParallel(
 67             [&amp;] (SlotVisitor&amp; visitor) { runExecutionThread(visitor, preference, pickNext); });
 68 
<span class="line-modified"> 69         dataLogIf(Options::logGC(), &quot;&gt;&quot;);</span>

 70     } else
 71         runExecutionThread(m_mainVisitor, preference, pickNext);
 72 
 73     RELEASE_ASSERT(!m_pickNextIsStillActive);
 74     RELEASE_ASSERT(!m_numThreadsThatMayProduceWork);
 75 
 76     if (!m_toExecuteSequentially.isEmpty()) {
 77         for (unsigned indexToRun : m_toExecuteSequentially)
 78             execute(*m_set.m_set[indexToRun]);
 79         m_toExecuteSequentially.clear();
 80     }
 81 
 82     RELEASE_ASSERT(m_toExecuteInParallel.isEmpty());
 83 }
 84 
 85 void MarkingConstraintSolver::drain(BitVector&amp; unexecuted)
 86 {
 87     auto iter = unexecuted.begin();
 88     auto end = unexecuted.end();
 89     if (iter == end)
</pre>
</td>
</tr>
</table>
<center><a href="MarkingConstraintSet.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MutatorState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
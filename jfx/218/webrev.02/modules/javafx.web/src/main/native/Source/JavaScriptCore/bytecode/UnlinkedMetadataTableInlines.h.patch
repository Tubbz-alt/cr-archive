diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTableInlines.h
@@ -29,25 +29,26 @@
 #include "UnlinkedMetadataTable.h"
 #include <wtf/FastMalloc.h>
 
 namespace JSC {
 
+
 ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable()
     : m_hasMetadata(false)
     , m_isFinalized(false)
     , m_isLinked(false)
     , m_is32Bit(false)
-    , m_rawBuffer(static_cast<uint8_t*>(fastZeroedMalloc(sizeof(LinkingData) + s_offset32TableSize)))
+    , m_rawBuffer(static_cast<uint8_t*>(MetadataTableMalloc::zeroedMalloc(sizeof(LinkingData) + s_offset32TableSize)))
 {
 }
 
 ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable(bool is32Bit)
     : m_hasMetadata(false)
     , m_isFinalized(false)
     , m_isLinked(false)
     , m_is32Bit(is32Bit)
-    , m_rawBuffer(static_cast<uint8_t*>(fastZeroedMalloc(sizeof(LinkingData) + (is32Bit ? s_offset16TableSize + s_offset32TableSize : s_offset16TableSize))))
+    , m_rawBuffer(static_cast<uint8_t*>(MetadataTableMalloc::zeroedMalloc(sizeof(LinkingData) + (is32Bit ? s_offset16TableSize + s_offset32TableSize : s_offset16TableSize))))
 {
 }
 
 ALWAYS_INLINE UnlinkedMetadataTable::UnlinkedMetadataTable(EmptyTag)
     : m_hasMetadata(false)
@@ -60,11 +61,11 @@
 
 ALWAYS_INLINE UnlinkedMetadataTable::~UnlinkedMetadataTable()
 {
     ASSERT(!m_isLinked);
     if (m_hasMetadata || !m_isFinalized)
-        fastFree(m_rawBuffer);
+        MetadataTableMalloc::free(m_rawBuffer);
 }
 
 ALWAYS_INLINE unsigned UnlinkedMetadataTable::addEntry(OpcodeID opcodeID)
 {
     ASSERT(!m_isFinalized && opcodeID < s_offsetTableEntries - 1);
@@ -86,11 +87,14 @@
 {
     ASSERT(m_isFinalized);
 
     // In this case, we return the size of the table minus the offset table,
     // which was already accounted for in the UnlinkedCodeBlock.
-    size_t result = totalSize();
+
+    // Be careful not to touch m_rawBuffer if this metadataTable is not owning it.
+    // It is possible that, m_rawBuffer is realloced in the other thread while we are accessing here.
+    size_t result = metadataTable.totalSize();
     if (metadataTable.buffer() == buffer()) {
         ASSERT(m_isLinked);
         if (m_is32Bit)
             return result - (s_offset16TableSize + s_offset32TableSize);
         return result - s_offset16TableSize;
@@ -108,13 +112,13 @@
     unsigned totalSize = this->totalSize();
     unsigned offsetTableSize = this->offsetTableSize();
     uint8_t* buffer;
     if (!m_isLinked) {
         m_isLinked = true;
-        m_rawBuffer = buffer = reinterpret_cast<uint8_t*>(fastRealloc(m_rawBuffer, sizeof(LinkingData) + totalSize));
+        m_rawBuffer = buffer = reinterpret_cast<uint8_t*>(MetadataTableMalloc::realloc(m_rawBuffer, sizeof(LinkingData) + totalSize));
     } else {
-        buffer = reinterpret_cast<uint8_t*>(fastMalloc(sizeof(LinkingData) + totalSize));
+        buffer = reinterpret_cast<uint8_t*>(MetadataTableMalloc::malloc(sizeof(LinkingData) + totalSize));
         memcpy(buffer, m_rawBuffer, sizeof(LinkingData) + offsetTableSize);
     }
     memset(buffer + sizeof(LinkingData) + offsetTableSize, 0, totalSize - offsetTableSize);
     return adoptRef(*new (buffer + sizeof(LinkingData)) MetadataTable(*this));
 }
@@ -126,12 +130,12 @@
         return;
 
     if (metadataTable.buffer() == buffer()) {
         ASSERT(m_isLinked);
         m_isLinked = false;
-        m_rawBuffer = static_cast<uint8_t*>(fastRealloc(m_rawBuffer, sizeof(LinkingData) + offsetTableSize()));
+        m_rawBuffer = static_cast<uint8_t*>(MetadataTableMalloc::realloc(m_rawBuffer, sizeof(LinkingData) + offsetTableSize()));
         return;
     }
-    fastFree(&metadataTable.linkingData());
+    MetadataTableMalloc::free(&metadataTable.linkingData());
 }
 
 } // namespace JSC

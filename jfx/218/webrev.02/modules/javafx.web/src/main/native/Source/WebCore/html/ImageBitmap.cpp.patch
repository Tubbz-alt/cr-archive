diff a/modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp
@@ -38,28 +38,34 @@
 #include "HTMLVideoElement.h"
 #include "ImageBitmapOptions.h"
 #include "ImageBuffer.h"
 #include "ImageData.h"
 #include "IntRect.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSImageBitmap.h"
 #include "LayoutSize.h"
+#if ENABLE(OFFSCREEN_CANVAS)
+#include "OffscreenCanvas.h"
+#endif
 #include "RenderElement.h"
 #include "SharedBuffer.h"
+#include "SuspendableTimer.h"
 #include "TypedOMCSSImageValue.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/Optional.h>
+#include <wtf/Scope.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/Variant.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
 
 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
-static RenderingMode bufferRenderingMode = Accelerated;
+static RenderingMode bufferRenderingMode = RenderingMode::Accelerated;
 #else
-static RenderingMode bufferRenderingMode = Unaccelerated;
+static RenderingMode bufferRenderingMode = RenderingMode::Unaccelerated;
 #endif
 
 Ref<ImageBitmap> ImageBitmap::create(IntSize size)
 {
     return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
@@ -198,20 +204,20 @@
 
 static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
 {
     switch (resizeQuality) {
     case ImageBitmapOptions::ResizeQuality::Pixelated:
-        return InterpolationNone;
+        return InterpolationQuality::DoNotInterpolate;
     case ImageBitmapOptions::ResizeQuality::Low:
-        return InterpolationDefault; // Low is the default.
+        return InterpolationQuality::Default; // Low is the default.
     case ImageBitmapOptions::ResizeQuality::Medium:
-        return InterpolationMedium;
+        return InterpolationQuality::Medium;
     case ImageBitmapOptions::ResizeQuality::High:
-        return InterpolationHigh;
+        return InterpolationQuality::High;
     }
     ASSERT_NOT_REACHED();
-    return InterpolationDefault;
+    return InterpolationQuality::Default;
 }
 
 // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
 
 // 7. Place input on an infinite transparent black grid plane, positioned so that its
@@ -338,16 +344,28 @@
     // 11. Resolve the promise with the new ImageBitmap object as the value.
 
     promise.resolve(WTFMove(imageBitmap));
 }
 
-void ImageBitmap::createPromise(ScriptExecutionContext&, RefPtr<HTMLCanvasElement>& canvasElement, ImageBitmapOptions&& options, Optional<IntRect> rect, ImageBitmap::Promise&& promise)
+void ImageBitmap::createPromise(ScriptExecutionContext& context, RefPtr<HTMLCanvasElement>& canvasElement, ImageBitmapOptions&& options, Optional<IntRect> rect, ImageBitmap::Promise&& promise)
+{
+    createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));
+}
+
+#if ENABLE(OFFSCREEN_CANVAS)
+void ImageBitmap::createPromise(ScriptExecutionContext& context, RefPtr<OffscreenCanvas>& canvasElement, ImageBitmapOptions&& options, Optional<IntRect> rect, ImageBitmap::Promise&& promise)
+{
+    createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));
+}
+#endif
+
+void ImageBitmap::createPromise(ScriptExecutionContext&, CanvasBase& canvas, ImageBitmapOptions&& options, Optional<IntRect> rect, ImageBitmap::Promise&& promise)
 {
     // 2. If the canvas element's bitmap has either a horizontal dimension or a vertical
     //    dimension equal to zero, then return a promise rejected with an "InvalidStateError"
     //    DOMException and abort these steps.
-    auto size = canvasElement->size();
+    auto size = canvas.size();
     if (!size.width() || !size.height()) {
         promise.reject(InvalidStateError, "Cannot create ImageBitmap from a canvas that has zero width or height");
         return;
     }
 
@@ -361,11 +379,11 @@
     }
 
     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
 
-    auto imageForRender = canvasElement->copiedImage();
+    auto imageForRender = canvas.copiedImage();
     if (!imageForRender) {
         promise.reject(InvalidStateError, "Cannot create ImageBitmap from canvas that can't be rendered");
         return;
     }
 
@@ -376,11 +394,11 @@
     auto imageBitmap = create(WTFMove(bitmapData));
 
     // 5. Set the origin-clean flag of the ImageBitmap object's bitmap to the same value as
     //    the origin-clean flag of the canvas element's bitmap.
 
-    imageBitmap->m_originClean = canvasElement->originClean();
+    imageBitmap->m_originClean = canvas.originClean();
 
     // 6. Return a new promise, but continue running these steps in parallel.
     // 7. Resolve the promise with the new ImageBitmap object as the value.
 
     promise.resolve(WTFMove(imageBitmap));
@@ -522,10 +540,11 @@
     long long m_expectedContentLength;
     URL m_sourceUrl;
 };
 
 class PendingImageBitmap final : public ActiveDOMObject, public FileReaderLoaderClient {
+    WTF_MAKE_FAST_ALLOCATED;
 public:
     static void fetch(ScriptExecutionContext& scriptExecutionContext, RefPtr<Blob>&& blob, ImageBitmapOptions&& options, Optional<IntRect> rect, ImageBitmap::Promise&& promise)
     {
         auto pendingImageBitmap = new PendingImageBitmap(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
         pendingImageBitmap->start(scriptExecutionContext);
@@ -537,30 +556,31 @@
         , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
         , m_blob(WTFMove(blob))
         , m_options(WTFMove(options))
         , m_rect(WTFMove(rect))
         , m_promise(WTFMove(promise))
+        , m_createImageBitmapTimer(&scriptExecutionContext, *this, &PendingImageBitmap::createImageBitmapAndResolvePromise)
     {
         suspendIfNeeded();
+        m_createImageBitmapTimer.suspendIfNeeded();
     }
 
     void start(ScriptExecutionContext& scriptExecutionContext)
     {
         m_blobLoader.start(&scriptExecutionContext, *m_blob);
     }
 
     // ActiveDOMObject
 
-    const char* activeDOMObjectName() const override
+    const char* activeDOMObjectName() const final
     {
         return "PendingImageBitmap";
     }
 
-    bool canSuspendForDocumentSuspension() const override
+    void stop() final
     {
-        // FIXME: Deal with suspension.
-        return false;
+        delete this;
     }
 
     // FileReaderLoaderClient
 
     void didStartLoading() override
@@ -571,35 +591,46 @@
     {
     }
 
     void didFinishLoading() override
     {
-        createImageBitmap(m_blobLoader.arrayBufferResult());
-        delete this;
+        createImageBitmapAndResolvePromiseSoon(m_blobLoader.arrayBufferResult());
     }
 
     void didFail(int) override
     {
-        createImageBitmap(nullptr);
-        delete this;
+        createImageBitmapAndResolvePromiseSoon(nullptr);
     }
 
-    void createImageBitmap(RefPtr<ArrayBuffer>&& arrayBuffer)
+    void createImageBitmapAndResolvePromiseSoon(RefPtr<ArrayBuffer>&& arrayBuffer)
     {
-        if (!arrayBuffer) {
+        ASSERT(!m_createImageBitmapTimer.isActive());
+        m_arrayBufferToProcess = WTFMove(arrayBuffer);
+        m_createImageBitmapTimer.startOneShot(0_s);
+    }
+
+    void createImageBitmapAndResolvePromise()
+    {
+        auto destroyOnExit = makeScopeExit([this] {
+            delete this;
+        });
+
+        if (!m_arrayBufferToProcess) {
             m_promise.reject(InvalidStateError, "An error occured reading the Blob argument to createImageBitmap");
             return;
         }
 
-        ImageBitmap::createFromBuffer(arrayBuffer.releaseNonNull(), m_blob->type(), m_blob->size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));
+        ImageBitmap::createFromBuffer(m_arrayBufferToProcess.releaseNonNull(), m_blob->type(), m_blob->size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));
     }
 
     FileReaderLoader m_blobLoader;
     RefPtr<Blob> m_blob;
     ImageBitmapOptions m_options;
     Optional<IntRect> m_rect;
     ImageBitmap::Promise m_promise;
+    SuspendableTimer m_createImageBitmapTimer;
+    RefPtr<ArrayBuffer> m_arrayBufferToProcess;
 };
 
 void ImageBitmap::createFromBuffer(
     Ref<ArrayBuffer>&& arrayBuffer,
     String mimeType,

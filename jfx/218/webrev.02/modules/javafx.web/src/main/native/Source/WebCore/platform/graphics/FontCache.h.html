<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2008 Apple Inc.  All rights reserved.
  3  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;FontDescription.h&quot;
 33 #include &quot;FontPlatformData.h&quot;
 34 #include &quot;FontTaggedSettings.h&quot;
 35 #include &quot;Timer.h&quot;
 36 #include &lt;array&gt;
 37 #include &lt;limits.h&gt;
 38 #include &lt;wtf/Forward.h&gt;
 39 #include &lt;wtf/ListHashSet.h&gt;
 40 #include &lt;wtf/RefPtr.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 #include &lt;wtf/WorkQueue.h&gt;
 43 #include &lt;wtf/text/AtomStringHash.h&gt;
 44 #include &lt;wtf/text/WTFString.h&gt;
 45 
 46 #if PLATFORM(COCOA)
 47 #include &quot;FontCacheCoreText.h&quot;
 48 #endif
 49 
 50 #if OS(WINDOWS)
 51 #include &lt;windows.h&gt;
 52 #include &lt;objidl.h&gt;
 53 #include &lt;mlang.h&gt;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 class FontCascade;
 59 class FontPlatformData;
 60 class FontSelector;
 61 class OpenTypeVerticalData;
 62 class Font;
 63 enum class IsForPlatformFont : uint8_t;
 64 
 65 #if PLATFORM(WIN)
 66 #if USE(IMLANG_FONT_LINK2)
 67 typedef IMLangFontLink2 IMLangFontLinkType;
 68 #else
 69 typedef IMLangFontLink IMLangFontLinkType;
 70 #endif
 71 #endif
 72 
 73 // This key contains the FontDescription fields other than family that matter when fetching FontDatas (platform fonts).
 74 struct FontDescriptionKey {
 75     FontDescriptionKey() = default;
 76 
 77     FontDescriptionKey(const FontDescription&amp; description)
 78         : m_size(description.computedPixelSize())
 79         , m_fontSelectionRequest(description.fontSelectionRequest())
 80         , m_flags(makeFlagsKey(description))
 81         , m_locale(description.locale())
 82         , m_featureSettings(description.featureSettings())
 83 #if ENABLE(VARIATION_FONTS)
 84         , m_variationSettings(description.variationSettings())
 85 #endif
 86     { }
 87 
 88     explicit FontDescriptionKey(WTF::HashTableDeletedValueType)
 89         : m_isDeletedValue(true)
 90     { }
 91 
 92     bool operator==(const FontDescriptionKey&amp; other) const
 93     {
 94         return m_isDeletedValue == other.m_isDeletedValue
 95             &amp;&amp; m_size == other.m_size
 96             &amp;&amp; m_fontSelectionRequest == other.m_fontSelectionRequest
 97             &amp;&amp; m_flags == other.m_flags
 98             &amp;&amp; m_locale == other.m_locale
 99 #if ENABLE(VARIATION_FONTS)
100             &amp;&amp; m_variationSettings == other.m_variationSettings
101 #endif
102             &amp;&amp; m_featureSettings == other.m_featureSettings;
103     }
104 
105     bool operator!=(const FontDescriptionKey&amp; other) const
106     {
107         return !(*this == other);
108     }
109 
110     bool isHashTableDeletedValue() const { return m_isDeletedValue; }
111 
112     inline unsigned computeHash() const
113     {
114         IntegerHasher hasher;
115         hasher.add(m_size);
116         hasher.add(m_fontSelectionRequest.weight);
117         hasher.add(m_fontSelectionRequest.width);
118         hasher.add(m_fontSelectionRequest.slope.valueOr(normalItalicValue()));
119         hasher.add(m_locale.existingHash());
120         for (unsigned flagItem : m_flags)
121             hasher.add(flagItem);
122         hasher.add(m_featureSettings.hash());
123 #if ENABLE(VARIATION_FONTS)
124         hasher.add(m_variationSettings.hash());
125 #endif
126         return hasher.hash();
127     }
128 
129 private:
130     static std::array&lt;unsigned, 2&gt; makeFlagsKey(const FontDescription&amp; description)
131     {
132         unsigned first = static_cast&lt;unsigned&gt;(description.script()) &lt;&lt; 14
133             | static_cast&lt;unsigned&gt;(description.shouldAllowUserInstalledFonts()) &lt;&lt; 13
134             | static_cast&lt;unsigned&gt;(description.fontStyleAxis() == FontStyleAxis::slnt) &lt;&lt; 12
135             | static_cast&lt;unsigned&gt;(description.opticalSizing()) &lt;&lt; 11
136             | static_cast&lt;unsigned&gt;(description.textRenderingMode()) &lt;&lt; 9
137             | static_cast&lt;unsigned&gt;(description.fontSynthesis()) &lt;&lt; 6
138             | static_cast&lt;unsigned&gt;(description.widthVariant()) &lt;&lt; 4
139             | static_cast&lt;unsigned&gt;(description.nonCJKGlyphOrientation()) &lt;&lt; 3
140             | static_cast&lt;unsigned&gt;(description.orientation()) &lt;&lt; 2
141             | static_cast&lt;unsigned&gt;(description.renderingMode());
142         unsigned second = static_cast&lt;unsigned&gt;(description.variantEastAsianRuby()) &lt;&lt; 27
143             | static_cast&lt;unsigned&gt;(description.variantEastAsianWidth()) &lt;&lt; 25
144             | static_cast&lt;unsigned&gt;(description.variantEastAsianVariant()) &lt;&lt; 22
145             | static_cast&lt;unsigned&gt;(description.variantAlternates()) &lt;&lt; 21
146             | static_cast&lt;unsigned&gt;(description.variantNumericSlashedZero()) &lt;&lt; 20
147             | static_cast&lt;unsigned&gt;(description.variantNumericOrdinal()) &lt;&lt; 19
148             | static_cast&lt;unsigned&gt;(description.variantNumericFraction()) &lt;&lt; 17
149             | static_cast&lt;unsigned&gt;(description.variantNumericSpacing()) &lt;&lt; 15
150             | static_cast&lt;unsigned&gt;(description.variantNumericFigure()) &lt;&lt; 13
151             | static_cast&lt;unsigned&gt;(description.variantCaps()) &lt;&lt; 10
152             | static_cast&lt;unsigned&gt;(description.variantPosition()) &lt;&lt; 8
153             | static_cast&lt;unsigned&gt;(description.variantContextualAlternates()) &lt;&lt; 6
154             | static_cast&lt;unsigned&gt;(description.variantHistoricalLigatures()) &lt;&lt; 4
155             | static_cast&lt;unsigned&gt;(description.variantDiscretionaryLigatures()) &lt;&lt; 2
156             | static_cast&lt;unsigned&gt;(description.variantCommonLigatures());
157         return {{ first, second }};
158     }
159 
160     // FontCascade::locale() is explicitly not included in this struct.
161     bool m_isDeletedValue { false };
162     unsigned m_size { 0 };
163     FontSelectionRequest m_fontSelectionRequest;
164     std::array&lt;unsigned, 2&gt; m_flags {{ 0, 0 }};
165     AtomString m_locale;
166     FontFeatureSettings m_featureSettings;
167 #if ENABLE(VARIATION_FONTS)
168     FontVariationSettings m_variationSettings;
169 #endif
170 };
171 
172 struct FontDescriptionKeyHash {
173     static unsigned hash(const FontDescriptionKey&amp; key)
174     {
175         return key.computeHash();
176     }
177 
178     static bool equal(const FontDescriptionKey&amp; a, const FontDescriptionKey&amp; b)
179     {
180         return a == b;
181     }
182 
183     static const bool safeToCompareToEmptyOrDeleted = true;
184 };
185 
186 class FontCache {
187     friend class WTF::NeverDestroyed&lt;FontCache&gt;;
188 
189     WTF_MAKE_NONCOPYABLE(FontCache); WTF_MAKE_FAST_ALLOCATED;
190 public:
191     WEBCORE_EXPORT static FontCache&amp; singleton();
192 
193     // These methods are implemented by the platform.
194     enum class PreferColoredFont : uint8_t { No, Yes };
195     RefPtr&lt;Font&gt; systemFallbackForCharacters(const FontDescription&amp;, const Font* originalFontData, IsForPlatformFont, PreferColoredFont, const UChar* characters, unsigned length);
196     Vector&lt;String&gt; systemFontFamilies();
197     void platformInit();
198 
199     static bool isSystemFontForbiddenForEditing(const String&amp;);
200 
201 #if PLATFORM(COCOA)
202     WEBCORE_EXPORT static void setFontWhitelist(const Vector&lt;String&gt;&amp;);
203 #endif
204 #if PLATFORM(WIN)
205     IMLangFontLinkType* getFontLinkInterface();
206     static void comInitialize();
207     static void comUninitialize();
208     static IMultiLanguage* getMultiLanguageInterface();
209 #endif
210 
211     // This function exists so CSSFontSelector can have a unified notion of preinstalled fonts and @font-face.
212     // It comes into play when you create an @font-face which shares a family name as a preinstalled font.
213     Vector&lt;FontSelectionCapabilities&gt; getFontSelectionCapabilitiesInFamily(const AtomString&amp;, AllowUserInstalledFonts);
214 
215     WEBCORE_EXPORT RefPtr&lt;Font&gt; fontForFamily(const FontDescription&amp;, const AtomString&amp;, const FontFeatureSettings* fontFaceFeatures = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);
216     WEBCORE_EXPORT Ref&lt;Font&gt; lastResortFallbackFont(const FontDescription&amp;);
217     WEBCORE_EXPORT Ref&lt;Font&gt; fontForPlatformData(const FontPlatformData&amp;);
218     RefPtr&lt;Font&gt; similarFont(const FontDescription&amp;, const AtomString&amp; family);
219 
220     void addClient(FontSelector&amp;);
221     void removeClient(FontSelector&amp;);
222 
223     unsigned short generation();
224     WEBCORE_EXPORT void invalidate();
225 
226     WEBCORE_EXPORT size_t fontCount();
227     WEBCORE_EXPORT size_t inactiveFontCount();
228     WEBCORE_EXPORT void purgeInactiveFontData(unsigned count = UINT_MAX);
229     void platformPurgeInactiveFontData();
230 
231 #if PLATFORM(WIN)
232     RefPtr&lt;Font&gt; fontFromDescriptionAndLogFont(const FontDescription&amp;, const LOGFONT&amp;, AtomString&amp; outFontFamilyName);
233 #endif
234 
235 #if ENABLE(OPENTYPE_VERTICAL)
236     RefPtr&lt;OpenTypeVerticalData&gt; verticalData(const FontPlatformData&amp;);
237 #endif
238 
239     std::unique_ptr&lt;FontPlatformData&gt; createFontPlatformDataForTesting(const FontDescription&amp;, const AtomString&amp; family);
240 
241     bool shouldMockBoldSystemFontForAccessibility() const { return m_shouldMockBoldSystemFontForAccessibility; }
242     void setShouldMockBoldSystemFontForAccessibility(bool shouldMockBoldSystemFontForAccessibility) { m_shouldMockBoldSystemFontForAccessibility = shouldMockBoldSystemFontForAccessibility; }
243 
244     struct PrewarmInformation {
245         Vector&lt;String&gt; seenFamilies;
246         Vector&lt;String&gt; fontNamesRequiringSystemFallback;
247 
248         bool isEmpty() const;
249         PrewarmInformation isolatedCopy() const;
250 
251         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
252         template&lt;class Decoder&gt; static Optional&lt;PrewarmInformation&gt; decode(Decoder&amp;);
253     };
254     PrewarmInformation collectPrewarmInformation() const;
255     void prewarm(const PrewarmInformation&amp;);
256     void prewarmGlobally();
257 
258 private:
259     FontCache();
260     ~FontCache() = delete;
261 
262     WEBCORE_EXPORT void purgeInactiveFontDataIfNeeded();
263 
264     // FIXME: This method should eventually be removed.
265     FontPlatformData* getCachedFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);
266 
267     // These methods are implemented by each platform.
268 #if PLATFORM(COCOA)
269     FontPlatformData* getCustomFallbackFont(const UInt32, const FontDescription&amp;);
270 #endif
271     WEBCORE_EXPORT std::unique_ptr&lt;FontPlatformData&gt; createFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities);
272 
273     static const AtomString&amp; alternateFamilyName(const AtomString&amp;);
274     static const AtomString&amp; platformAlternateFamilyName(const AtomString&amp;);
275 
276     Timer m_purgeTimer;
277 
278     bool m_shouldMockBoldSystemFontForAccessibility { false };
279 
280 #if PLATFORM(COCOA)
281     ListHashSet&lt;String&gt; m_seenFamiliesForPrewarming;
282     ListHashSet&lt;String&gt; m_fontNamesRequiringSystemFallbackForPrewarming;
283     RefPtr&lt;WorkQueue&gt; m_prewarmQueue;
284 
285     friend class ComplexTextController;
286 #endif
287     friend class Font;
288 };
289 
290 inline std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformDataForTesting(const FontDescription&amp; fontDescription, const AtomString&amp; family)
291 {
292     return createFontPlatformData(fontDescription, family, nullptr, { });
293 }
294 
295 #if !PLATFORM(COCOA) &amp;&amp; !USE(FREETYPE)
296 
297 inline void FontCache::platformPurgeInactiveFontData()
298 {
299 }
300 
301 #endif
302 
303 
304 inline bool FontCache::PrewarmInformation::isEmpty() const
305 {
306     return seenFamilies.isEmpty() &amp;&amp; fontNamesRequiringSystemFallback.isEmpty();
307 }
308 
309 inline FontCache::PrewarmInformation FontCache::PrewarmInformation::isolatedCopy() const
310 {
311     return { seenFamilies.isolatedCopy(), fontNamesRequiringSystemFallback.isolatedCopy() };
312 }
313 
314 template&lt;class Encoder&gt;
315 void FontCache::PrewarmInformation::encode(Encoder&amp; encoder) const
316 {
317     encoder &lt;&lt; seenFamilies;
318     encoder &lt;&lt; fontNamesRequiringSystemFallback;
319 }
320 
321 template&lt;class Decoder&gt;
322 Optional&lt;FontCache::PrewarmInformation&gt; FontCache::PrewarmInformation::decode(Decoder&amp; decoder)
323 {
324     PrewarmInformation prewarmInformation;
325     if (!decoder.decode(prewarmInformation.seenFamilies))
326         return { };
327     if (!decoder.decode(prewarmInformation.fontNamesRequiringSystemFallback))
328         return { };
329 
330     return prewarmInformation;
331 }
332 
333 }
    </pre>
  </body>
</html>
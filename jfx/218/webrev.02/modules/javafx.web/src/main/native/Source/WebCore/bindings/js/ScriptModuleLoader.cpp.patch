diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp
@@ -30,21 +30,21 @@
 #include "CachedScript.h"
 #include "CachedScriptFetcher.h"
 #include "Document.h"
 #include "Frame.h"
 #include "JSDOMBinding.h"
+#include "JSDOMPromiseDeferred.h"
 #include "LoadableModuleScript.h"
 #include "MIMETypeRegistry.h"
 #include "ModuleFetchFailureKind.h"
 #include "ModuleFetchParameters.h"
 #include "ScriptController.h"
 #include "ScriptSourceCode.h"
 #include "SubresourceIntegrity.h"
 #include "WebCoreJSClientData.h"
 #include <JavaScriptCore/Completion.h>
 #include <JavaScriptCore/JSInternalPromise.h>
-#include <JavaScriptCore/JSInternalPromiseDeferred.h>
 #include <JavaScriptCore/JSModuleRecord.h>
 #include <JavaScriptCore/JSScriptFetchParameters.h>
 #include <JavaScriptCore/JSScriptFetcher.h>
 #include <JavaScriptCore/JSSourceCode.h>
 #include <JavaScriptCore/JSString.h>
@@ -83,90 +83,90 @@
     if (!result.isValid())
         return makeUnexpected("Module name does not resolve to a valid URL."_s);
     return result;
 }
 
-JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject*, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)
+JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)
 {
-    JSC::VM& vm = exec->vm();
+    JSC::VM& vm = jsGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // We use a Symbol as a special purpose; It means this module is an inline module.
     // So there is no correct URL to retrieve the module source code. If the module name
     // value is a Symbol, it is used directly as a module key.
     if (moduleNameValue.isSymbol())
         return JSC::Identifier::fromUid(asSymbol(moduleNameValue)->privateName());
 
     if (!moduleNameValue.isString()) {
-        JSC::throwTypeError(exec, scope, "Importer module key is not a Symbol or a String."_s);
+        JSC::throwTypeError(jsGlobalObject, scope, "Importer module key is not a Symbol or a String."_s);
         return { };
     }
 
-    String specifier = asString(moduleNameValue)->value(exec);
+    String specifier = asString(moduleNameValue)->value(jsGlobalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     URL baseURL;
     if (isRootModule(importerModuleKey))
         baseURL = m_document.baseURL();
     else {
         ASSERT(importerModuleKey.isString());
-        URL importerModuleRequestURL(URL(), asString(importerModuleKey)->value(exec));
+        URL importerModuleRequestURL(URL(), asString(importerModuleKey)->value(jsGlobalObject));
         ASSERT_WITH_MESSAGE(importerModuleRequestURL.isValid(), "Invalid module referrer never starts importing dependent modules.");
 
         auto iterator = m_requestURLToResponseURLMap.find(importerModuleRequestURL);
         ASSERT_WITH_MESSAGE(iterator != m_requestURLToResponseURLMap.end(), "Module referrer must register itself to the map before starting importing dependent modules.");
         baseURL = iterator->value;
     }
 
     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
     if (!result) {
-        JSC::throwTypeError(exec, scope, result.error());
+        JSC::throwTypeError(jsGlobalObject, scope, result.error());
         return { };
     }
 
     return JSC::Identifier::fromString(vm, result->string());
 }
 
 static void rejectToPropagateNetworkError(DeferredPromise& deferred, ModuleFetchFailureKind failureKind, ASCIILiteral message)
 {
-    deferred.rejectWithCallback([&] (JSC::ExecState& state, JSDOMGlobalObject&) {
+    deferred.rejectWithCallback([&] (JSDOMGlobalObject& jsGlobalObject) {
         // We annotate exception with special private symbol. It allows us to distinguish these errors from the user thrown ones.
-        JSC::VM& vm = state.vm();
+        JSC::VM& vm = jsGlobalObject.vm();
         // FIXME: Propagate more descriptive error.
         // https://bugs.webkit.org/show_bug.cgi?id=167553
-        auto* error = JSC::createTypeError(&state, message);
+        auto* error = JSC::createTypeError(&jsGlobalObject, message);
         ASSERT(error);
         error->putDirect(vm, static_cast<JSVMClientData&>(*vm.clientData).builtinNames().failureKindPrivateName(), JSC::jsNumber(static_cast<int32_t>(failureKind)));
         return error;
     });
 }
 
-JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)
+JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)
 {
-    JSC::VM& vm = exec->vm();
+    JSC::VM& vm = jsGlobalObject->vm();
     ASSERT(JSC::jsDynamicCast<JSC::JSScriptFetcher*>(vm, scriptFetcher));
 
     auto& globalObject = *JSC::jsCast<JSDOMGlobalObject*>(jsGlobalObject);
-    auto* jsPromise = JSC::JSInternalPromiseDeferred::tryCreate(exec, &globalObject);
+    auto* jsPromise = JSC::JSInternalPromise::create(vm, globalObject.internalPromiseStructure());
     RELEASE_ASSERT(jsPromise);
     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
     if (moduleKeyValue.isSymbol()) {
         deferred->reject(TypeError, "Symbol module key should be already fulfilled with the inlined resource."_s);
-        return jsPromise->promise();
+        return jsPromise;
     }
 
     if (!moduleKeyValue.isString()) {
         deferred->reject(TypeError, "Module key is not Symbol or String."_s);
-        return jsPromise->promise();
+        return jsPromise;
     }
 
     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
 
-    URL completedURL(URL(), asString(moduleKeyValue)->value(exec));
+    URL completedURL(URL(), asString(moduleKeyValue)->value(jsGlobalObject));
     if (!completedURL.isValid()) {
         deferred->reject(TypeError, "Module key is a valid URL."_s);
-        return jsPromise->promise();
+        return jsPromise;
     }
 
     RefPtr<ModuleFetchParameters> topLevelFetchParameters;
     if (auto* scriptFetchParameters = JSC::jsDynamicCast<JSC::JSScriptFetchParameters*>(vm, parameters))
         topLevelFetchParameters = static_cast<ModuleFetchParameters*>(&scriptFetchParameters->parameters());
@@ -175,59 +175,58 @@
     m_loaders.add(loader.copyRef());
     if (!loader->load(m_document, completedURL)) {
         loader->clearClient();
         m_loaders.remove(WTFMove(loader));
         rejectToPropagateNetworkError(deferred.get(), ModuleFetchFailureKind::WasErrored, "Importing a module script failed."_s);
-        return jsPromise->promise();
+        return jsPromise;
     }
 
-    return jsPromise->promise();
+    return jsPromise;
 }
 
-URL ScriptModuleLoader::moduleURL(JSC::ExecState& state, JSC::JSValue moduleKeyValue)
+URL ScriptModuleLoader::moduleURL(JSC::JSGlobalObject& jsGlobalObject, JSC::JSValue moduleKeyValue)
 {
     if (moduleKeyValue.isSymbol())
         return m_document.url();
 
     ASSERT(moduleKeyValue.isString());
-    return URL(URL(), asString(moduleKeyValue)->value(&state));
+    return URL(URL(), asString(moduleKeyValue)->value(&jsGlobalObject));
 }
 
-JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject*, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)
+JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)
 {
-    JSC::VM& vm = exec->vm();
+    JSC::VM& vm = jsGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // FIXME: Currently, we only support JSModuleRecord.
     // Once the reflective part of the module loader is supported, we will handle arbitrary values.
     // https://whatwg.github.io/loader/#registry-prototype-provide
     auto* moduleRecord = JSC::jsDynamicCast<JSC::JSModuleRecord*>(vm, moduleRecordValue);
     if (!moduleRecord)
         return JSC::jsUndefined();
 
-    URL sourceURL = moduleURL(*exec, moduleKeyValue);
+    URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);
     if (!sourceURL.isValid())
-        return JSC::throwTypeError(exec, scope, "Module key is an invalid URL."_s);
+        return JSC::throwTypeError(jsGlobalObject, scope, "Module key is an invalid URL."_s);
 
     if (auto* frame = m_document.frame())
         return frame->script().evaluateModule(sourceURL, *moduleRecord);
     return JSC::jsUndefined();
 }
 
-static JSC::JSInternalPromise* rejectPromise(JSC::ExecState& state, JSDOMGlobalObject& globalObject, ExceptionCode ec, ASCIILiteral message)
+static JSC::JSInternalPromise* rejectPromise(JSDOMGlobalObject& globalObject, ExceptionCode ec, ASCIILiteral message)
 {
-    auto* jsPromise = JSC::JSInternalPromiseDeferred::tryCreate(&state, &globalObject);
+    auto* jsPromise = JSC::JSInternalPromise::create(globalObject.vm(), globalObject.internalPromiseStructure());
     RELEASE_ASSERT(jsPromise);
     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
     deferred->reject(ec, WTFMove(message));
-    return jsPromise->promise();
+    return jsPromise;
 }
 
-JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin& sourceOrigin)
+JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin& sourceOrigin)
 {
-    auto& state = *exec;
-    JSC::VM& vm = exec->vm();
+    JSC::VM& vm = jsGlobalObject->vm();
     auto& globalObject = *JSC::jsCast<JSDOMGlobalObject*>(jsGlobalObject);
 
     // If SourceOrigin and/or CachedScriptFetcher is null, we import the module with the default fetcher.
     // SourceOrigin can be null if the source code is not coupled with the script file.
     // The examples,
@@ -241,37 +240,37 @@
         baseURL = m_document.baseURL();
         scriptFetcher = CachedScriptFetcher::create(m_document.charset());
     } else {
         baseURL = URL(URL(), sourceOrigin.string());
         if (!baseURL.isValid())
-            return rejectPromise(state, globalObject, TypeError, "Importer module key is not a Symbol or a String."_s);
+            return rejectPromise(globalObject, TypeError, "Importer module key is not a Symbol or a String."_s);
 
         if (sourceOrigin.fetcher())
             scriptFetcher = sourceOrigin.fetcher();
         else
             scriptFetcher = CachedScriptFetcher::create(m_document.charset());
     }
     ASSERT(baseURL.isValid());
     ASSERT(scriptFetcher);
 
-    auto specifier = moduleName->value(exec);
+    auto specifier = moduleName->value(jsGlobalObject);
     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
     if (!result)
-        return rejectPromise(state, globalObject, TypeError, result.error());
+        return rejectPromise(globalObject, TypeError, result.error());
 
-    return JSC::importModule(exec, JSC::Identifier::fromString(vm, result->string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));
+    return JSC::importModule(jsGlobalObject, JSC::Identifier::fromString(vm, result->string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));
 }
 
-JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* globalObject, JSC::ExecState* exec, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)
+JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)
 {
-    auto& vm = exec->vm();
+    auto& vm = jsGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    URL sourceURL = moduleURL(*exec, moduleKeyValue);
+    URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);
     ASSERT(sourceURL.isValid());
 
-    auto* metaProperties = JSC::constructEmptyObject(exec, globalObject->nullPrototypeObjectStructure());
+    auto* metaProperties = JSC::constructEmptyObject(vm, jsGlobalObject->nullPrototypeObjectStructure());
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     metaProperties->putDirect(vm, JSC::Identifier::fromString(vm, "url"), JSC::jsString(vm, sourceURL.string()));
     RETURN_IF_EXCEPTION(scope, nullptr);
 
@@ -280,10 +279,11 @@
 
 void ScriptModuleLoader::notifyFinished(CachedModuleScriptLoader& loader, RefPtr<DeferredPromise> promise)
 {
     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
 
+    URL sourceURL = loader.sourceURL();
     if (!m_loaders.remove(&loader))
         return;
     loader.clearClient();
 
     auto& cachedScript = *loader.cachedScript();
@@ -311,18 +311,18 @@
         return;
     }
 
     if (auto* parameters = loader.parameters()) {
         if (!matchIntegrityMetadata(cachedScript, parameters->integrity())) {
-            promise->reject(TypeError, makeString("Cannot load script ", cachedScript.url().stringCenterEllipsizedToLength(), ". Failed integrity metadata check."));
+            promise->reject(TypeError, makeString("Cannot load script ", integrityMismatchDescription(cachedScript, parameters->integrity())));
             return;
         }
     }
 
-    m_requestURLToResponseURLMap.add(cachedScript.url(), cachedScript.response().url());
-    promise->resolveWithCallback([&] (JSC::ExecState& state, JSDOMGlobalObject&) {
-        return JSC::JSSourceCode::create(state.vm(),
+    m_requestURLToResponseURLMap.add(WTFMove(sourceURL), cachedScript.response().url());
+    promise->resolveWithCallback([&] (JSDOMGlobalObject& jsGlobalObject) {
+        return JSC::JSSourceCode::create(jsGlobalObject.vm(),
             JSC::SourceCode { ScriptSourceCode { &cachedScript, JSC::SourceProviderSourceType::Module, loader.scriptFetcher() }.jsSourceCode() });
     });
 }
 
 }

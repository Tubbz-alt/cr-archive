<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorShaderProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorOverlay.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorShaderProgram.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorShaderProgram.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorShaderProgram.h&quot;
 28 
<span class="line-removed"> 29 #if ENABLE(WEBGL)</span>
<span class="line-removed"> 30 </span>
<span class="line-removed"> 31 #include &quot;GraphicsContext3D.h&quot;</span>
<span class="line-removed"> 32 #include &quot;GraphicsTypes3D.h&quot;</span>
<span class="line-removed"> 33 #include &quot;HTMLCanvasElement.h&quot;</span>
 34 #include &quot;InspectorCanvas.h&quot;








 35 #include &quot;WebGLProgram.h&quot;
 36 #include &quot;WebGLRenderingContextBase.h&quot;
 37 #include &quot;WebGLShader.h&quot;
<span class="line-modified"> 38 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;</span>









 39 
 40 namespace WebCore {
 41 
 42 using namespace Inspector;
 43 

 44 Ref&lt;InspectorShaderProgram&gt; InspectorShaderProgram::create(WebGLProgram&amp; program, InspectorCanvas&amp; inspectorCanvas)
 45 {
 46     return adoptRef(*new InspectorShaderProgram(program, inspectorCanvas));
 47 }








 48 

 49 InspectorShaderProgram::InspectorShaderProgram(WebGLProgram&amp; program, InspectorCanvas&amp; inspectorCanvas)
 50     : m_identifier(&quot;program:&quot; + IdentifiersFactory::createIdentifier())

 51     , m_program(program)








 52     , m_canvas(inspectorCanvas)








 53 {



 54 }

 55 
<span class="line-modified"> 56 WebGLRenderingContextBase&amp; InspectorShaderProgram::context() const</span>

 57 {
<span class="line-modified"> 58     ASSERT(is&lt;WebGLRenderingContextBase&gt;(m_canvas.context()));</span>
<span class="line-modified"> 59     return downcast&lt;WebGLRenderingContextBase&gt;(m_canvas.context());</span>

 60 }

 61 
<span class="line-modified"> 62 WebGLShader* InspectorShaderProgram::shaderForType(const String&amp; protocolType)</span>

 63 {
<span class="line-modified"> 64     GC3Denum shaderType;</span>
<span class="line-modified"> 65     if (protocolType == &quot;vertex&quot;)</span>
<span class="line-modified"> 66         shaderType = GraphicsContext3D::VERTEX_SHADER;</span>
<span class="line-modified"> 67     else if (protocolType == &quot;fragment&quot;)</span>
<span class="line-modified"> 68         shaderType = GraphicsContext3D::FRAGMENT_SHADER;</span>
<span class="line-modified"> 69     else</span>



 70         return nullptr;

 71 
<span class="line-modified"> 72     return m_program.getAttachedShader(shaderType);</span>

 73 }

 74 
<span class="line-modified"> 75 } // namespace WebCore</span>























































 76 
<span class="line-modified"> 77 #endif // ENABLE(WEBGL)</span>


































































































</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorShaderProgram.h&quot;
 28 





 29 #include &quot;InspectorCanvas.h&quot;
<span class="line-added"> 30 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;</span>
<span class="line-added"> 31 #include &lt;wtf/Optional.h&gt;</span>
<span class="line-added"> 32 #include &lt;wtf/Ref.h&gt;</span>
<span class="line-added"> 33 #include &lt;wtf/Variant.h&gt;</span>
<span class="line-added"> 34 #include &lt;wtf/text/WTFString.h&gt;</span>
<span class="line-added"> 35 </span>
<span class="line-added"> 36 #if ENABLE(WEBGL)</span>
<span class="line-added"> 37 #include &quot;GraphicsContextGLOpenGL.h&quot;</span>
 38 #include &quot;WebGLProgram.h&quot;
 39 #include &quot;WebGLRenderingContextBase.h&quot;
 40 #include &quot;WebGLShader.h&quot;
<span class="line-modified"> 41 #endif</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 44 #include &quot;GPUShaderModule.h&quot;</span>
<span class="line-added"> 45 #include &quot;WHLSLPrepare.h&quot;</span>
<span class="line-added"> 46 #include &quot;WebGPUComputePipeline.h&quot;</span>
<span class="line-added"> 47 #include &quot;WebGPUPipeline.h&quot;</span>
<span class="line-added"> 48 #include &quot;WebGPURenderPipeline.h&quot;</span>
<span class="line-added"> 49 #include &quot;WebGPUShaderModule.h&quot;</span>
<span class="line-added"> 50 #endif</span>
 51 
 52 namespace WebCore {
 53 
 54 using namespace Inspector;
 55 
<span class="line-added"> 56 #if ENABLE(WEBGL)</span>
 57 Ref&lt;InspectorShaderProgram&gt; InspectorShaderProgram::create(WebGLProgram&amp; program, InspectorCanvas&amp; inspectorCanvas)
 58 {
 59     return adoptRef(*new InspectorShaderProgram(program, inspectorCanvas));
 60 }
<span class="line-added"> 61 #endif</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 64 Ref&lt;InspectorShaderProgram&gt; InspectorShaderProgram::create(WebGPUPipeline&amp; pipeline, InspectorCanvas&amp; inspectorCanvas)</span>
<span class="line-added"> 65 {</span>
<span class="line-added"> 66     return adoptRef(*new InspectorShaderProgram(pipeline, inspectorCanvas));</span>
<span class="line-added"> 67 }</span>
<span class="line-added"> 68 #endif</span>
 69 
<span class="line-added"> 70 #if ENABLE(WEBGL)</span>
 71 InspectorShaderProgram::InspectorShaderProgram(WebGLProgram&amp; program, InspectorCanvas&amp; inspectorCanvas)
 72     : m_identifier(&quot;program:&quot; + IdentifiersFactory::createIdentifier())
<span class="line-added"> 73     , m_canvas(inspectorCanvas)</span>
 74     , m_program(program)
<span class="line-added"> 75 {</span>
<span class="line-added"> 76     ASSERT(is&lt;WebGLRenderingContextBase&gt;(m_canvas.canvasContext()));</span>
<span class="line-added"> 77 }</span>
<span class="line-added"> 78 #endif</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80 #if ENABLE(WEBGPU)</span>
<span class="line-added"> 81 InspectorShaderProgram::InspectorShaderProgram(WebGPUPipeline&amp; pipeline, InspectorCanvas&amp; inspectorCanvas)</span>
<span class="line-added"> 82     : m_identifier(&quot;pipeline:&quot; + IdentifiersFactory::createIdentifier())</span>
 83     , m_canvas(inspectorCanvas)
<span class="line-added"> 84     , m_program(pipeline)</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     ASSERT(m_canvas.deviceContext());</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 #endif</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90 #if ENABLE(WEBGL)</span>
<span class="line-added"> 91 WebGLProgram* InspectorShaderProgram::program() const</span>
 92 {
<span class="line-added"> 93     if (auto* programWrapper = WTF::get_if&lt;std::reference_wrapper&lt;WebGLProgram&gt;&gt;(m_program))</span>
<span class="line-added"> 94         return &amp;programWrapper-&gt;get();</span>
<span class="line-added"> 95     return nullptr;</span>
 96 }
<span class="line-added"> 97 #endif</span>
 98 
<span class="line-modified"> 99 #if ENABLE(WEBGPU)</span>
<span class="line-added">100 WebGPUPipeline* InspectorShaderProgram::pipeline() const</span>
101 {
<span class="line-modified">102     if (auto* pipelineWrapper = WTF::get_if&lt;std::reference_wrapper&lt;WebGPUPipeline&gt;&gt;(m_program))</span>
<span class="line-modified">103         return &amp;pipelineWrapper-&gt;get();</span>
<span class="line-added">104     return nullptr;</span>
105 }
<span class="line-added">106 #endif</span>
107 
<span class="line-modified">108 #if ENABLE(WEBGL)</span>
<span class="line-added">109 static WebGLShader* shaderForType(WebGLProgram&amp; program, Inspector::Protocol::Canvas::ShaderType shaderType)</span>
110 {
<span class="line-modified">111     switch (shaderType) {</span>
<span class="line-modified">112     case Inspector::Protocol::Canvas::ShaderType::Fragment:</span>
<span class="line-modified">113         return program.getAttachedShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
<span class="line-modified">114 </span>
<span class="line-modified">115     case Inspector::Protocol::Canvas::ShaderType::Vertex:</span>
<span class="line-modified">116         return program.getAttachedShader(GraphicsContextGL::VERTEX_SHADER);</span>
<span class="line-added">117 </span>
<span class="line-added">118     // Compute shaders are a WebGPU concept.</span>
<span class="line-added">119     case Inspector::Protocol::Canvas::ShaderType::Compute:</span>
120         return nullptr;
<span class="line-added">121     }</span>
122 
<span class="line-modified">123     ASSERT_NOT_REACHED();</span>
<span class="line-added">124     return nullptr;</span>
125 }
<span class="line-added">126 #endif</span>
127 
<span class="line-modified">128 #if ENABLE(WEBGPU)</span>
<span class="line-added">129 static RefPtr&lt;WebGPUShaderModule&gt; shaderForType(WebGPUPipeline&amp; pipeline, Inspector::Protocol::Canvas::ShaderType shaderType)</span>
<span class="line-added">130 {</span>
<span class="line-added">131     switch (shaderType) {</span>
<span class="line-added">132     case Inspector::Protocol::Canvas::ShaderType::Compute:</span>
<span class="line-added">133         if (is&lt;WebGPUComputePipeline&gt;(pipeline))</span>
<span class="line-added">134             return downcast&lt;WebGPUComputePipeline&gt;(pipeline).computeShader();</span>
<span class="line-added">135         return nullptr;</span>
<span class="line-added">136 </span>
<span class="line-added">137     case Inspector::Protocol::Canvas::ShaderType::Fragment:</span>
<span class="line-added">138         if (is&lt;WebGPURenderPipeline&gt;(pipeline))</span>
<span class="line-added">139             return downcast&lt;WebGPURenderPipeline&gt;(pipeline).fragmentShader();</span>
<span class="line-added">140         return nullptr;</span>
<span class="line-added">141 </span>
<span class="line-added">142     case Inspector::Protocol::Canvas::ShaderType::Vertex:</span>
<span class="line-added">143         if (is&lt;WebGPURenderPipeline&gt;(pipeline))</span>
<span class="line-added">144             return downcast&lt;WebGPURenderPipeline&gt;(pipeline).vertexShader();</span>
<span class="line-added">145         return nullptr;</span>
<span class="line-added">146     }</span>
<span class="line-added">147 </span>
<span class="line-added">148     ASSERT_NOT_REACHED();</span>
<span class="line-added">149     return nullptr;</span>
<span class="line-added">150 }</span>
<span class="line-added">151 #endif</span>
<span class="line-added">152 </span>
<span class="line-added">153 String InspectorShaderProgram::requestShaderSource(Inspector::Protocol::Canvas::ShaderType shaderType)</span>
<span class="line-added">154 {</span>
<span class="line-added">155 #if !ENABLE(WEBGL) &amp;&amp; !ENABLE(WEBGPU)</span>
<span class="line-added">156     UNUSED_PARAM(shaderType);</span>
<span class="line-added">157 #endif</span>
<span class="line-added">158 </span>
<span class="line-added">159     return WTF::switchOn(m_program,</span>
<span class="line-added">160 #if ENABLE(WEBGL)</span>
<span class="line-added">161         [&amp;] (std::reference_wrapper&lt;WebGLProgram&gt; programWrapper) {</span>
<span class="line-added">162             auto&amp; program = programWrapper.get();</span>
<span class="line-added">163             if (auto* shader = shaderForType(program, shaderType))</span>
<span class="line-added">164                 return shader-&gt;getSource();</span>
<span class="line-added">165             return String();</span>
<span class="line-added">166         },</span>
<span class="line-added">167 #endif</span>
<span class="line-added">168 #if ENABLE(WEBGPU)</span>
<span class="line-added">169         [&amp;] (std::reference_wrapper&lt;WebGPUPipeline&gt; pipelineWrapper) {</span>
<span class="line-added">170             auto&amp; pipeline = pipelineWrapper.get();</span>
<span class="line-added">171             if (auto shader = shaderForType(pipeline, shaderType))</span>
<span class="line-added">172                 return shader-&gt;source();</span>
<span class="line-added">173             return String();</span>
<span class="line-added">174         },</span>
<span class="line-added">175 #endif</span>
<span class="line-added">176         [&amp;] (Monostate) {</span>
<span class="line-added">177 #if ENABLE(WEBGL) || ENABLE(WEBGPU)</span>
<span class="line-added">178             ASSERT_NOT_REACHED();</span>
<span class="line-added">179 #endif</span>
<span class="line-added">180             return String();</span>
<span class="line-added">181         }</span>
<span class="line-added">182     );</span>
<span class="line-added">183 }</span>
184 
<span class="line-modified">185 bool InspectorShaderProgram::updateShader(Inspector::Protocol::Canvas::ShaderType shaderType, const String&amp; source)</span>
<span class="line-added">186 {</span>
<span class="line-added">187 #if !ENABLE(WEBGL) &amp;&amp; !ENABLE(WEBGPU)</span>
<span class="line-added">188     UNUSED_PARAM(shaderType);</span>
<span class="line-added">189     UNUSED_PARAM(source);</span>
<span class="line-added">190 #endif</span>
<span class="line-added">191 </span>
<span class="line-added">192     return WTF::switchOn(m_program,</span>
<span class="line-added">193 #if ENABLE(WEBGL)</span>
<span class="line-added">194         [&amp;] (std::reference_wrapper&lt;WebGLProgram&gt; programWrapper) {</span>
<span class="line-added">195             auto&amp; program = programWrapper.get();</span>
<span class="line-added">196             if (auto* shader = shaderForType(program, shaderType)) {</span>
<span class="line-added">197                 if (auto* context = m_canvas.canvasContext()) {</span>
<span class="line-added">198                     if (is&lt;WebGLRenderingContextBase&gt;(context)) {</span>
<span class="line-added">199                         auto&amp; contextWebGLBase = downcast&lt;WebGLRenderingContextBase&gt;(*context);</span>
<span class="line-added">200                         contextWebGLBase.shaderSource(shader, source);</span>
<span class="line-added">201                         contextWebGLBase.compileShader(shader);</span>
<span class="line-added">202                         if (shader-&gt;isValid()) {</span>
<span class="line-added">203                             contextWebGLBase.linkProgramWithoutInvalidatingAttribLocations(&amp;program);</span>
<span class="line-added">204                             return true;</span>
<span class="line-added">205                         }</span>
<span class="line-added">206                     }</span>
<span class="line-added">207                 }</span>
<span class="line-added">208             }</span>
<span class="line-added">209             return false;</span>
<span class="line-added">210         },</span>
<span class="line-added">211 #endif</span>
<span class="line-added">212 #if ENABLE(WEBGPU)</span>
<span class="line-added">213         [&amp;] (std::reference_wrapper&lt;WebGPUPipeline&gt; pipelineWrapper) {</span>
<span class="line-added">214             auto&amp; pipeline = pipelineWrapper.get();</span>
<span class="line-added">215             if (auto* device = m_canvas.deviceContext()) {</span>
<span class="line-added">216                 if (pipeline.cloneShaderModules(*device)) {</span>
<span class="line-added">217                     if (auto shader = shaderForType(pipeline, shaderType)) {</span>
<span class="line-added">218                         shader-&gt;update(*device, source);</span>
<span class="line-added">219                         if (pipeline.recompile(*device))</span>
<span class="line-added">220                             return true;</span>
<span class="line-added">221                     }</span>
<span class="line-added">222                 }</span>
<span class="line-added">223             }</span>
<span class="line-added">224             return false;</span>
<span class="line-added">225         },</span>
<span class="line-added">226 #endif</span>
<span class="line-added">227         [&amp;] (Monostate) {</span>
<span class="line-added">228 #if ENABLE(WEBGL) || ENABLE(WEBGPU)</span>
<span class="line-added">229             ASSERT_NOT_REACHED();</span>
<span class="line-added">230 #endif</span>
<span class="line-added">231             return false;</span>
<span class="line-added">232         }</span>
<span class="line-added">233     );</span>
<span class="line-added">234 }</span>
<span class="line-added">235 </span>
<span class="line-added">236 Ref&lt;Inspector::Protocol::Canvas::ShaderProgram&gt; InspectorShaderProgram::buildObjectForShaderProgram()</span>
<span class="line-added">237 {</span>
<span class="line-added">238     bool sharesVertexFragmentShader = false;</span>
<span class="line-added">239 </span>
<span class="line-added">240     using ProgramTypeType = Optional&lt;Inspector::Protocol::Canvas::ProgramType&gt;;</span>
<span class="line-added">241     auto programType = WTF::switchOn(m_program,</span>
<span class="line-added">242 #if ENABLE(WEBGL)</span>
<span class="line-added">243         [&amp;] (std::reference_wrapper&lt;WebGLProgram&gt;) -&gt; ProgramTypeType {</span>
<span class="line-added">244             return Inspector::Protocol::Canvas::ProgramType::Render;</span>
<span class="line-added">245         },</span>
<span class="line-added">246 #endif</span>
<span class="line-added">247 #if ENABLE(WEBGPU)</span>
<span class="line-added">248         [&amp;] (std::reference_wrapper&lt;WebGPUPipeline&gt; pipelineWrapper) -&gt; ProgramTypeType {</span>
<span class="line-added">249             auto&amp; pipeline = pipelineWrapper.get();</span>
<span class="line-added">250             if (is&lt;WebGPUComputePipeline&gt;(pipeline))</span>
<span class="line-added">251                 return Inspector::Protocol::Canvas::ProgramType::Compute;</span>
<span class="line-added">252             if (is&lt;WebGPURenderPipeline&gt;(pipeline)) {</span>
<span class="line-added">253                 auto&amp; renderPipeline = downcast&lt;WebGPURenderPipeline&gt;(pipeline);</span>
<span class="line-added">254                 if (renderPipeline.vertexShader() == renderPipeline.fragmentShader())</span>
<span class="line-added">255                     sharesVertexFragmentShader = true;</span>
<span class="line-added">256                 return Inspector::Protocol::Canvas::ProgramType::Render;</span>
<span class="line-added">257             }</span>
<span class="line-added">258             return WTF::nullopt;</span>
<span class="line-added">259         },</span>
<span class="line-added">260 #endif</span>
<span class="line-added">261         [&amp;] (Monostate) -&gt; ProgramTypeType {</span>
<span class="line-added">262 #if ENABLE(WEBGL) || ENABLE(WEBGPU)</span>
<span class="line-added">263             ASSERT_NOT_REACHED();</span>
<span class="line-added">264 #endif</span>
<span class="line-added">265             return WTF::nullopt;</span>
<span class="line-added">266         }</span>
<span class="line-added">267     );</span>
<span class="line-added">268     if (!programType) {</span>
<span class="line-added">269         ASSERT_NOT_REACHED();</span>
<span class="line-added">270         programType = Inspector::Protocol::Canvas::ProgramType::Render;</span>
<span class="line-added">271     }</span>
<span class="line-added">272 </span>
<span class="line-added">273     auto payload = Inspector::Protocol::Canvas::ShaderProgram::create()</span>
<span class="line-added">274         .setProgramId(m_identifier)</span>
<span class="line-added">275         .setProgramType(programType.value())</span>
<span class="line-added">276         .setCanvasId(m_canvas.identifier())</span>
<span class="line-added">277         .release();</span>
<span class="line-added">278     if (sharesVertexFragmentShader)</span>
<span class="line-added">279         payload-&gt;setSharesVertexFragmentShader(true);</span>
<span class="line-added">280     return payload;</span>
<span class="line-added">281 }</span>
<span class="line-added">282 </span>
<span class="line-added">283 } // namespace WebCore</span>
</pre>
</td>
</tr>
</table>
<center><a href="InspectorOverlay.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorShaderProgram.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
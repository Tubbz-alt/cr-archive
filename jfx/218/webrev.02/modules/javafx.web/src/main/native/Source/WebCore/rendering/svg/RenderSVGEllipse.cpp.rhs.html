<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Google, Inc.
  3  * All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF SZEGED ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL UNIVERSITY OF SZEGED OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;RenderSVGEllipse.h&quot;
 29 
 30 #include &quot;SVGCircleElement.h&quot;
 31 #include &quot;SVGEllipseElement.h&quot;
 32 #include &lt;wtf/IsoMallocInlines.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSVGEllipse);
 37 
 38 RenderSVGEllipse::RenderSVGEllipse(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 39     : RenderSVGShape(element, WTFMove(style))
 40     , m_usePathFallback(false)
 41 {
 42 }
 43 
 44 RenderSVGEllipse::~RenderSVGEllipse() = default;
 45 
 46 void RenderSVGEllipse::updateShapeFromElement()
 47 {
 48     // Before creating a new object we need to clear the cached bounding box
 49     // to avoid using garbage.
 50     m_fillBoundingBox = FloatRect();
 51     m_strokeBoundingBox = FloatRect();
 52     m_center = FloatPoint();
 53     m_radii = FloatSize();
 54 
 55     calculateRadiiAndCenter();
 56 
<a name="1" id="anc1"></a><span class="line-modified"> 57     // Spec: &quot;A negative value is illegal. A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 58     if (m_radii.isEmpty())</span>
 59         return;
 60 
<a name="2" id="anc2"></a><span class="line-modified"> 61     if (hasNonScalingStroke()) {</span>
<span class="line-modified"> 62         // Fallback to RenderSVGShape if shape has a non-scaling stroke.</span>
<span class="line-modified"> 63         RenderSVGShape::updateShapeFromElement();</span>
<span class="line-modified"> 64         m_usePathFallback = true;</span>
<span class="line-modified"> 65         return;</span>




 66     }
 67 
<a name="3" id="anc3"></a><span class="line-added"> 68     m_usePathFallback = false;</span>
<span class="line-added"> 69 </span>
 70     m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
 71     m_strokeBoundingBox = m_fillBoundingBox;
 72     if (style().svgStyle().hasStroke())
 73         m_strokeBoundingBox.inflate(strokeWidth() / 2);
 74 }
 75 
 76 void RenderSVGEllipse::calculateRadiiAndCenter()
 77 {
 78     SVGLengthContext lengthContext(&amp;graphicsElement());
 79     m_center = FloatPoint(
<a name="4" id="anc4"></a><span class="line-modified"> 80         lengthContext.valueForLength(style().svgStyle().cx(), SVGLengthMode::Width),</span>
<span class="line-modified"> 81         lengthContext.valueForLength(style().svgStyle().cy(), SVGLengthMode::Height));</span>
 82     if (is&lt;SVGCircleElement&gt;(graphicsElement())) {
 83         float radius = lengthContext.valueForLength(style().svgStyle().r());
 84         m_radii = FloatSize(radius, radius);
 85         return;
 86     }
 87 
 88     ASSERT(is&lt;SVGEllipseElement&gt;(graphicsElement()));
<a name="5" id="anc5"></a><span class="line-added"> 89 </span>
<span class="line-added"> 90     Length rx = style().svgStyle().rx();</span>
<span class="line-added"> 91     Length ry = style().svgStyle().ry();</span>
 92     m_radii = FloatSize(
<a name="6" id="anc6"></a><span class="line-modified"> 93         lengthContext.valueForLength(rx.isAuto() ? ry : rx, SVGLengthMode::Width),</span>
<span class="line-modified"> 94         lengthContext.valueForLength(ry.isAuto() ? rx : ry, SVGLengthMode::Height));</span>
 95 }
 96 
 97 void RenderSVGEllipse::fillShape(GraphicsContext&amp; context) const
 98 {
 99     if (m_usePathFallback) {
100         RenderSVGShape::fillShape(context);
101         return;
102     }
103     context.fillEllipse(m_fillBoundingBox);
104 }
105 
106 void RenderSVGEllipse::strokeShape(GraphicsContext&amp; context) const
107 {
108     if (!style().hasVisibleStroke())
109         return;
110     if (m_usePathFallback) {
111         RenderSVGShape::strokeShape(context);
112         return;
113     }
114     context.strokeEllipse(m_fillBoundingBox);
115 }
116 
117 bool RenderSVGEllipse::shapeDependentStrokeContains(const FloatPoint&amp; point, PointCoordinateSpace pointCoordinateSpace)
118 {
119     // The optimized contains code below does not support non-smooth strokes so we need
120     // to fall back to RenderSVGShape::shapeDependentStrokeContains in these cases.
121     if (m_usePathFallback || !hasSmoothStroke()) {
122         if (!hasPath())
123             RenderSVGShape::updateShapeFromElement();
124         return RenderSVGShape::shapeDependentStrokeContains(point, pointCoordinateSpace);
125     }
126 
127     float halfStrokeWidth = strokeWidth() / 2;
128     FloatPoint center = FloatPoint(m_center.x() - point.x(), m_center.y() - point.y());
129 
130     // This works by checking if the point satisfies the ellipse equation,
131     // (x/rX)^2 + (y/rY)^2 &lt;= 1, for the outer but not the inner stroke.
132     float xrXOuter = center.x() / (m_radii.width() + halfStrokeWidth);
133     float yrYOuter = center.y() / (m_radii.height() + halfStrokeWidth);
134     if (xrXOuter * xrXOuter + yrYOuter * yrYOuter &gt; 1.0)
135         return false;
136 
137     float xrXInner = center.x() / (m_radii.width() - halfStrokeWidth);
138     float yrYInner = center.y() / (m_radii.height() - halfStrokeWidth);
139     return xrXInner * xrXInner + yrYInner * yrYInner &gt;= 1.0;
140 }
141 
142 bool RenderSVGEllipse::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
143 {
144     if (m_usePathFallback)
145         return RenderSVGShape::shapeDependentFillContains(point, fillRule);
146 
147     FloatPoint center = FloatPoint(m_center.x() - point.x(), m_center.y() - point.y());
148 
149     // This works by checking if the point satisfies the ellipse equation.
150     // (x/rX)^2 + (y/rY)^2 &lt;= 1
151     float xrX = center.x() / m_radii.width();
152     float yrY = center.y() / m_radii.height();
153     return xrX * xrX + yrY * yrY &lt;= 1.0;
154 }
155 
156 bool RenderSVGEllipse::isRenderingDisabled() const
157 {
158     // A radius of zero disables rendering of the element, and results in an empty bounding box.
159     return m_fillBoundingBox.isEmpty();
160 }
161 
162 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
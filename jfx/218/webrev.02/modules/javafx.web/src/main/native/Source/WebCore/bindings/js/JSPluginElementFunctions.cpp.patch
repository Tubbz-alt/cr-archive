diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp
@@ -63,11 +63,11 @@
 
     HTMLPlugInElement& pluginElement = downcast<HTMLPlugInElement>(element);
     return pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement->globalObject());
 }
 
-JSObject* pluginScriptObject(ExecState* exec, JSHTMLElement* jsHTMLElement)
+JSObject* pluginScriptObject(JSGlobalObject* lexicalGlobalObject, JSHTMLElement* jsHTMLElement)
 {
     HTMLElement& element = jsHTMLElement->wrapped();
     if (!is<HTMLPlugInElement>(element))
         return nullptr;
 
@@ -89,78 +89,78 @@
     // The plugin element holds an owning reference, so we don't have to.
     auto* instance = pluginElement.bindingsInstance();
     if (!instance || !instance->rootObject())
         return nullptr;
 
-    return instance->createRuntimeObject(exec);
+    return instance->createRuntimeObject(lexicalGlobalObject);
 }
 
-static EncodedJSValue pluginElementPropertyGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)
+static EncodedJSValue pluginElementPropertyGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = lexicalGlobalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     JSHTMLElement* thisObject = jsDynamicCast<JSHTMLElement*>(vm, JSValue::decode(thisValue));
     if (!thisObject)
-        return throwVMTypeError(exec, scope);
-    JSObject* scriptObject = pluginScriptObject(exec, thisObject);
+        return throwVMTypeError(lexicalGlobalObject, scope);
+    JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, thisObject);
     if (!scriptObject)
         return JSValue::encode(jsUndefined());
 
-    return JSValue::encode(scriptObject->get(exec, propertyName));
+    return JSValue::encode(scriptObject->get(lexicalGlobalObject, propertyName));
 }
 
-bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot& slot)
 {
     if (!element->globalObject()->world().isNormal()) {
-        JSC::JSValue proto = element->getPrototypeDirect(exec->vm());
-        if (proto.isObject() && JSC::jsCast<JSC::JSObject*>(asObject(proto))->hasProperty(exec, propertyName))
+        JSC::JSValue proto = element->getPrototypeDirect(lexicalGlobalObject->vm());
+        if (proto.isObject() && JSC::jsCast<JSC::JSObject*>(asObject(proto))->hasProperty(lexicalGlobalObject, propertyName))
             return false;
     }
 
-    JSObject* scriptObject = pluginScriptObject(exec, element);
+    JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);
     if (!scriptObject)
         return false;
 
-    if (!scriptObject->hasProperty(exec, propertyName))
+    if (!scriptObject->hasProperty(lexicalGlobalObject, propertyName))
         return false;
 
     slot.setCustom(element, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, pluginElementPropertyGetter);
     return true;
 }
 
-bool pluginElementCustomPut(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot& slot, bool& putResult)
+bool pluginElementCustomPut(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot& slot, bool& putResult)
 {
-    JSObject* scriptObject = pluginScriptObject(exec, element);
+    JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);
     if (!scriptObject)
         return false;
-    if (!scriptObject->hasProperty(exec, propertyName))
+    if (!scriptObject->hasProperty(lexicalGlobalObject, propertyName))
         return false;
-    putResult = scriptObject->methodTable(exec->vm())->put(scriptObject, exec, propertyName, value, slot);
+    putResult = scriptObject->methodTable(lexicalGlobalObject->vm())->put(scriptObject, lexicalGlobalObject, propertyName, value, slot);
     return true;
 }
 
-static EncodedJSValue JSC_HOST_CALL callPlugin(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL callPlugin(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)
 {
-    JSHTMLElement* element = jsCast<JSHTMLElement*>(exec->jsCallee());
+    JSHTMLElement* element = jsCast<JSHTMLElement*>(callFrame->jsCallee());
 
     // Get the plug-in script object.
-    JSObject* scriptObject = pluginScriptObject(exec, element);
+    JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);
     ASSERT(scriptObject);
 
-    size_t argumentCount = exec->argumentCount();
+    size_t argumentCount = callFrame->argumentCount();
     MarkedArgumentBuffer argumentList;
     for (size_t i = 0; i < argumentCount; i++)
-        argumentList.append(exec->argument(i));
+        argumentList.append(callFrame->argument(i));
     ASSERT(!argumentList.hasOverflowed());
 
     CallData callData;
-    CallType callType = getCallData(exec->vm(), scriptObject, callData);
+    CallType callType = getCallData(lexicalGlobalObject->vm(), scriptObject, callData);
     ASSERT(callType == CallType::Host);
 
     // Call the object.
-    JSValue result = call(exec, scriptObject, callType, callData, exec->thisValue(), argumentList);
+    JSValue result = call(lexicalGlobalObject, scriptObject, callType, callData, callFrame->thisValue(), argumentList);
     return JSValue::encode(result);
 }
 
 CallType pluginElementCustomGetCallData(JSHTMLElement* element, CallData& callData)
 {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockObjCExceptions.mm.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Bitmap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2010-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free Software
 16  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 17  *
 18  */
 19 
 20 #pragma once
 21 
 22 #include &lt;array&gt;
</pre>
<hr />
<pre>
 34 
 35     static_assert(sizeof(WordType) &lt;= sizeof(unsigned), &quot;WordType must not be bigger than unsigned&quot;);
 36 public:
 37     constexpr Bitmap();
 38 
 39     static constexpr size_t size()
 40     {
 41         return bitmapSize;
 42     }
 43 
 44     bool get(size_t, Dependency = Dependency()) const;
 45     void set(size_t);
 46     void set(size_t, bool);
 47     bool testAndSet(size_t);
 48     bool testAndClear(size_t);
 49     bool concurrentTestAndSet(size_t, Dependency = Dependency());
 50     bool concurrentTestAndClear(size_t, Dependency = Dependency());
 51     size_t nextPossiblyUnset(size_t) const;
 52     void clear(size_t);
 53     void clearAll();

 54     int64_t findRunOfZeros(size_t runLength) const;
 55     size_t count(size_t start = 0) const;
 56     size_t isEmpty() const;
 57     size_t isFull() const;
 58 
 59     void merge(const Bitmap&amp;);
 60     void filter(const Bitmap&amp;);
 61     void exclude(const Bitmap&amp;);
 62 
 63     void concurrentFilter(const Bitmap&amp;);
 64 
 65     bool subsumes(const Bitmap&amp;) const;
 66 
 67     template&lt;typename Func&gt;
 68     void forEachSetBit(const Func&amp;) const;
 69 
 70     size_t findBit(size_t startIndex, bool value) const;
 71 
 72     class iterator {
 73         WTF_MAKE_FAST_ALLOCATED;
</pre>
<hr />
<pre>
 85         }
 86 
 87         size_t operator*() const { return m_index; }
 88 
 89         iterator&amp; operator++()
 90         {
 91             m_index = m_bitmap-&gt;findBit(m_index + 1, true);
 92             return *this;
 93         }
 94 
 95         bool operator==(const iterator&amp; other) const
 96         {
 97             return m_index == other.m_index;
 98         }
 99 
100         bool operator!=(const iterator&amp; other) const
101         {
102             return !(*this == other);
103         }
104 






105     private:
106         const Bitmap* m_bitmap;
107         size_t m_index;
108     };
109 
110     // Use this to iterate over set bits.
111     iterator begin() const { return iterator(*this, findBit(0, true)); }
112     iterator end() const { return iterator(*this, bitmapSize); }
113 



114     void mergeAndClear(Bitmap&amp;);
115     void setAndClear(Bitmap&amp;);
116 
117     bool operator==(const Bitmap&amp;) const;
118     bool operator!=(const Bitmap&amp;) const;
119 
120     unsigned hash() const;
121 
122 private:
<span class="line-modified">123     static const unsigned wordSize = sizeof(WordType) * 8;</span>
<span class="line-modified">124     static const unsigned words = (bitmapSize + wordSize - 1) / wordSize;</span>
125 
126     // the literal &#39;1&#39; is of type signed int.  We want to use an unsigned
127     // version of the correct size when doing the calculations because if
128     // WordType is larger than int, &#39;1 &lt;&lt; 31&#39; will first be sign extended
129     // and then casted to unsigned, meaning that set(31) when WordType is
130     // a 64 bit unsigned int would give 0xffff8000
<span class="line-modified">131     static const WordType one = 1;</span>
132 
133     std::array&lt;WordType, words&gt; bits;
134 };
135 
136 template&lt;size_t bitmapSize, typename WordType&gt;
137 constexpr Bitmap&lt;bitmapSize, WordType&gt;::Bitmap()
138 {
139     clearAll();
140 }
141 
142 template&lt;size_t bitmapSize, typename WordType&gt;
143 inline bool Bitmap&lt;bitmapSize, WordType&gt;::get(size_t n, Dependency dependency) const
144 {
145     return !!(dependency.consume(this)-&gt;bits[n / wordSize] &amp; (one &lt;&lt; (n % wordSize)));
146 }
147 
148 template&lt;size_t bitmapSize, typename WordType&gt;
149 inline void Bitmap&lt;bitmapSize, WordType&gt;::set(size_t n)
150 {
151     bits[n / wordSize] |= (one &lt;&lt; (n % wordSize));
</pre>
<hr />
<pre>
207             if (!(value &amp; mask))
208                 return false;
209 
210             value &amp;= ~mask;
211             return true;
212         });
213 }
214 
215 template&lt;size_t bitmapSize, typename WordType&gt;
216 inline void Bitmap&lt;bitmapSize, WordType&gt;::clear(size_t n)
217 {
218     bits[n / wordSize] &amp;= ~(one &lt;&lt; (n % wordSize));
219 }
220 
221 template&lt;size_t bitmapSize, typename WordType&gt;
222 inline void Bitmap&lt;bitmapSize, WordType&gt;::clearAll()
223 {
224     memset(bits.data(), 0, sizeof(bits));
225 }
226 







227 template&lt;size_t bitmapSize, typename WordType&gt;
228 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::nextPossiblyUnset(size_t start) const
229 {
230     if (!~bits[start / wordSize])
231         return ((start / wordSize) + 1) * wordSize;
232     return start + 1;
233 }
234 
235 template&lt;size_t bitmapSize, typename WordType&gt;
236 inline int64_t Bitmap&lt;bitmapSize, WordType&gt;::findRunOfZeros(size_t runLength) const
237 {
238     if (!runLength)
239         runLength = 1;
240 
241     for (size_t i = 0; i &lt;= (bitmapSize - runLength) ; i++) {
242         bool found = true;
243         for (size_t j = i; j &lt;= (i + runLength - 1) ; j++) {
244             if (get(j)) {
245                 found = false;
246                 break;
</pre>
<hr />
<pre>
392         other.bits[i] = 0;
393     }
394 }
395 
396 template&lt;size_t bitmapSize, typename WordType&gt;
397 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator==(const Bitmap&amp; other) const
398 {
399     for (size_t i = 0; i &lt; words; ++i) {
400         if (bits[i] != other.bits[i])
401             return false;
402     }
403     return true;
404 }
405 
406 template&lt;size_t bitmapSize, typename WordType&gt;
407 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator!=(const Bitmap&amp; other) const
408 {
409     return !(*this == other);
410 }
411 













412 template&lt;size_t bitmapSize, typename WordType&gt;
413 inline unsigned Bitmap&lt;bitmapSize, WordType&gt;::hash() const
414 {
415     unsigned result = 0;
416     for (size_t i = 0; i &lt; words; ++i)
417         result ^= IntHash&lt;WordType&gt;::hash(bits[i]);
418     return result;
419 }
420 
421 } // namespace WTF
422 
423 using WTF::Bitmap;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2010-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Lesser General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Lesser General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Lesser General Public
 15  *  License along with this library; if not, write to the Free Software
 16  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 17  *
 18  */
 19 
 20 #pragma once
 21 
 22 #include &lt;array&gt;
</pre>
<hr />
<pre>
 34 
 35     static_assert(sizeof(WordType) &lt;= sizeof(unsigned), &quot;WordType must not be bigger than unsigned&quot;);
 36 public:
 37     constexpr Bitmap();
 38 
 39     static constexpr size_t size()
 40     {
 41         return bitmapSize;
 42     }
 43 
 44     bool get(size_t, Dependency = Dependency()) const;
 45     void set(size_t);
 46     void set(size_t, bool);
 47     bool testAndSet(size_t);
 48     bool testAndClear(size_t);
 49     bool concurrentTestAndSet(size_t, Dependency = Dependency());
 50     bool concurrentTestAndClear(size_t, Dependency = Dependency());
 51     size_t nextPossiblyUnset(size_t) const;
 52     void clear(size_t);
 53     void clearAll();
<span class="line-added"> 54     void invert();</span>
 55     int64_t findRunOfZeros(size_t runLength) const;
 56     size_t count(size_t start = 0) const;
 57     size_t isEmpty() const;
 58     size_t isFull() const;
 59 
 60     void merge(const Bitmap&amp;);
 61     void filter(const Bitmap&amp;);
 62     void exclude(const Bitmap&amp;);
 63 
 64     void concurrentFilter(const Bitmap&amp;);
 65 
 66     bool subsumes(const Bitmap&amp;) const;
 67 
 68     template&lt;typename Func&gt;
 69     void forEachSetBit(const Func&amp;) const;
 70 
 71     size_t findBit(size_t startIndex, bool value) const;
 72 
 73     class iterator {
 74         WTF_MAKE_FAST_ALLOCATED;
</pre>
<hr />
<pre>
 86         }
 87 
 88         size_t operator*() const { return m_index; }
 89 
 90         iterator&amp; operator++()
 91         {
 92             m_index = m_bitmap-&gt;findBit(m_index + 1, true);
 93             return *this;
 94         }
 95 
 96         bool operator==(const iterator&amp; other) const
 97         {
 98             return m_index == other.m_index;
 99         }
100 
101         bool operator!=(const iterator&amp; other) const
102         {
103             return !(*this == other);
104         }
105 
<span class="line-added">106         iterator&amp; operator=(bool value)</span>
<span class="line-added">107         {</span>
<span class="line-added">108             m_bitmap-&gt;set(m_index, value);</span>
<span class="line-added">109             return *this;</span>
<span class="line-added">110         }</span>
<span class="line-added">111 </span>
112     private:
113         const Bitmap* m_bitmap;
114         size_t m_index;
115     };
116 
117     // Use this to iterate over set bits.
118     iterator begin() const { return iterator(*this, findBit(0, true)); }
119     iterator end() const { return iterator(*this, bitmapSize); }
120 
<span class="line-added">121     iterator operator[](size_t);</span>
<span class="line-added">122     const iterator operator[](size_t) const;</span>
<span class="line-added">123 </span>
124     void mergeAndClear(Bitmap&amp;);
125     void setAndClear(Bitmap&amp;);
126 
127     bool operator==(const Bitmap&amp;) const;
128     bool operator!=(const Bitmap&amp;) const;
129 
130     unsigned hash() const;
131 
132 private:
<span class="line-modified">133     static constexpr unsigned wordSize = sizeof(WordType) * 8;</span>
<span class="line-modified">134     static constexpr unsigned words = (bitmapSize + wordSize - 1) / wordSize;</span>
135 
136     // the literal &#39;1&#39; is of type signed int.  We want to use an unsigned
137     // version of the correct size when doing the calculations because if
138     // WordType is larger than int, &#39;1 &lt;&lt; 31&#39; will first be sign extended
139     // and then casted to unsigned, meaning that set(31) when WordType is
140     // a 64 bit unsigned int would give 0xffff8000
<span class="line-modified">141     static constexpr WordType one = 1;</span>
142 
143     std::array&lt;WordType, words&gt; bits;
144 };
145 
146 template&lt;size_t bitmapSize, typename WordType&gt;
147 constexpr Bitmap&lt;bitmapSize, WordType&gt;::Bitmap()
148 {
149     clearAll();
150 }
151 
152 template&lt;size_t bitmapSize, typename WordType&gt;
153 inline bool Bitmap&lt;bitmapSize, WordType&gt;::get(size_t n, Dependency dependency) const
154 {
155     return !!(dependency.consume(this)-&gt;bits[n / wordSize] &amp; (one &lt;&lt; (n % wordSize)));
156 }
157 
158 template&lt;size_t bitmapSize, typename WordType&gt;
159 inline void Bitmap&lt;bitmapSize, WordType&gt;::set(size_t n)
160 {
161     bits[n / wordSize] |= (one &lt;&lt; (n % wordSize));
</pre>
<hr />
<pre>
217             if (!(value &amp; mask))
218                 return false;
219 
220             value &amp;= ~mask;
221             return true;
222         });
223 }
224 
225 template&lt;size_t bitmapSize, typename WordType&gt;
226 inline void Bitmap&lt;bitmapSize, WordType&gt;::clear(size_t n)
227 {
228     bits[n / wordSize] &amp;= ~(one &lt;&lt; (n % wordSize));
229 }
230 
231 template&lt;size_t bitmapSize, typename WordType&gt;
232 inline void Bitmap&lt;bitmapSize, WordType&gt;::clearAll()
233 {
234     memset(bits.data(), 0, sizeof(bits));
235 }
236 
<span class="line-added">237 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">238 inline void Bitmap&lt;bitmapSize, WordType&gt;::invert()</span>
<span class="line-added">239 {</span>
<span class="line-added">240     for (size_t i = 0; i &lt; words; ++i)</span>
<span class="line-added">241         bits[i] = ~bits[i];</span>
<span class="line-added">242 }</span>
<span class="line-added">243 </span>
244 template&lt;size_t bitmapSize, typename WordType&gt;
245 inline size_t Bitmap&lt;bitmapSize, WordType&gt;::nextPossiblyUnset(size_t start) const
246 {
247     if (!~bits[start / wordSize])
248         return ((start / wordSize) + 1) * wordSize;
249     return start + 1;
250 }
251 
252 template&lt;size_t bitmapSize, typename WordType&gt;
253 inline int64_t Bitmap&lt;bitmapSize, WordType&gt;::findRunOfZeros(size_t runLength) const
254 {
255     if (!runLength)
256         runLength = 1;
257 
258     for (size_t i = 0; i &lt;= (bitmapSize - runLength) ; i++) {
259         bool found = true;
260         for (size_t j = i; j &lt;= (i + runLength - 1) ; j++) {
261             if (get(j)) {
262                 found = false;
263                 break;
</pre>
<hr />
<pre>
409         other.bits[i] = 0;
410     }
411 }
412 
413 template&lt;size_t bitmapSize, typename WordType&gt;
414 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator==(const Bitmap&amp; other) const
415 {
416     for (size_t i = 0; i &lt; words; ++i) {
417         if (bits[i] != other.bits[i])
418             return false;
419     }
420     return true;
421 }
422 
423 template&lt;size_t bitmapSize, typename WordType&gt;
424 inline bool Bitmap&lt;bitmapSize, WordType&gt;::operator!=(const Bitmap&amp; other) const
425 {
426     return !(*this == other);
427 }
428 
<span class="line-added">429 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">430 inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) -&gt; iterator</span>
<span class="line-added">431 {</span>
<span class="line-added">432     ASSERT(index &lt; size());</span>
<span class="line-added">433     return iterator(*this, index);</span>
<span class="line-added">434 }</span>
<span class="line-added">435 </span>
<span class="line-added">436 template&lt;size_t bitmapSize, typename WordType&gt;</span>
<span class="line-added">437 inline auto Bitmap&lt;bitmapSize, WordType&gt;::operator[](size_t index) const -&gt; const iterator</span>
<span class="line-added">438 {</span>
<span class="line-added">439     return (*const_cast&lt;Bitmap&lt;bitmapSize, WordType&gt;*&gt;(this))[index];</span>
<span class="line-added">440 }</span>
<span class="line-added">441 </span>
442 template&lt;size_t bitmapSize, typename WordType&gt;
443 inline unsigned Bitmap&lt;bitmapSize, WordType&gt;::hash() const
444 {
445     unsigned result = 0;
446     for (size_t i = 0; i &lt; words; ++i)
447         result ^= IntHash&lt;WordType&gt;::hash(bits[i]);
448     return result;
449 }
450 
451 } // namespace WTF
452 
453 using WTF::Bitmap;
</pre>
</td>
</tr>
</table>
<center><a href="BitVector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BlockObjCExceptions.mm.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
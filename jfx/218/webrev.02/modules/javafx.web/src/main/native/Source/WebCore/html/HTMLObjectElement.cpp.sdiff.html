<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLObjectElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMeterElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLObjectElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLObjectElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 {
 70     ASSERT(hasTagName(objectTag));
 71 }
 72 
 73 Ref&lt;HTMLObjectElement&gt; HTMLObjectElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 74 {
 75     auto result = adoptRef(*new HTMLObjectElement(tagName, document, form));
 76     result-&gt;finishCreating();
 77     return result;
 78 }
 79 
 80 RenderWidget* HTMLObjectElement::renderWidgetLoadingPlugin() const
 81 {
 82     // Needs to load the plugin immediatedly because this function is called
 83     // when JavaScript code accesses the plugin.
 84     // FIXME: &lt;rdar://16893708&gt; Check if dispatching events here is safe.
 85     document().updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
 86     return renderWidget(); // This will return 0 if the renderer is not a RenderWidget.
 87 }
 88 





 89 bool HTMLObjectElement::isPresentationAttribute(const QualifiedName&amp; name) const
 90 {
 91     if (name == borderAttr)
 92         return true;
 93     return HTMLPlugInImageElement::isPresentationAttribute(name);
 94 }
 95 
 96 void HTMLObjectElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
 97 {
 98     if (name == borderAttr)
 99         applyBorderAttributeToStyle(value, style);
100     else
101         HTMLPlugInImageElement::collectStyleForPresentationAttribute(name, value, style);
102 }
103 
104 void HTMLObjectElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
105 {
106     bool invalidateRenderer = false;
107 
108     if (name == formAttr)
</pre>
</td>
<td>
<hr />
<pre>
 69 {
 70     ASSERT(hasTagName(objectTag));
 71 }
 72 
 73 Ref&lt;HTMLObjectElement&gt; HTMLObjectElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 74 {
 75     auto result = adoptRef(*new HTMLObjectElement(tagName, document, form));
 76     result-&gt;finishCreating();
 77     return result;
 78 }
 79 
 80 RenderWidget* HTMLObjectElement::renderWidgetLoadingPlugin() const
 81 {
 82     // Needs to load the plugin immediatedly because this function is called
 83     // when JavaScript code accesses the plugin.
 84     // FIXME: &lt;rdar://16893708&gt; Check if dispatching events here is safe.
 85     document().updateLayoutIgnorePendingStylesheets(Document::RunPostLayoutTasks::Synchronously);
 86     return renderWidget(); // This will return 0 if the renderer is not a RenderWidget.
 87 }
 88 
<span class="line-added"> 89 int HTMLObjectElement::defaultTabIndex() const</span>
<span class="line-added"> 90 {</span>
<span class="line-added"> 91     return 0;</span>
<span class="line-added"> 92 }</span>
<span class="line-added"> 93 </span>
 94 bool HTMLObjectElement::isPresentationAttribute(const QualifiedName&amp; name) const
 95 {
 96     if (name == borderAttr)
 97         return true;
 98     return HTMLPlugInImageElement::isPresentationAttribute(name);
 99 }
100 
101 void HTMLObjectElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
102 {
103     if (name == borderAttr)
104         applyBorderAttributeToStyle(value, style);
105     else
106         HTMLPlugInImageElement::collectStyleForPresentationAttribute(name, value, style);
107 }
108 
109 void HTMLObjectElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
110 {
111     bool invalidateRenderer = false;
112 
113     if (name == formAttr)
</pre>
</td>
</tr>
</table>
<center><a href="HTMLMeterElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLObjectElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../ServiceWorkerTypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWContextManager.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
      return *sharedManager;
  }
  
  void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
  {
<span class="line-modified">!     ASSERT(!m_connection);</span>
      m_connection = WTFMove(connection);
  }
  
  auto SWContextManager::connection() const -&gt; Connection*
  {
<span class="line-new-header">--- 40,11 ---</span>
      return *sharedManager;
  }
  
  void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
  {
<span class="line-modified">!     ASSERT(!m_connection || m_connection-&gt;isClosed());</span>
      m_connection = WTFMove(connection);
  }
  
  auto SWContextManager::connection() const -&gt; Connection*
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 57,20 ***</span>
      auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
      auto* threadProxy = serviceWorkerThreadProxy.ptr();
      auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage) {</span>
<span class="line-modified">!         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
      });
  }
  
<span class="line-modified">! void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage)</span>
  {
<span class="line-removed">-     connection()-&gt;serviceWorkerStartedWithMessage(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
      if (m_serviceWorkerCreationCallback)
          m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
  }
  
  ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
  {
      return m_workerMap.get(identifier);
<span class="line-new-header">--- 57,24 ---</span>
      auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
      auto* threadProxy = serviceWorkerThreadProxy.ptr();
      auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage, bool doesHandleFetch) {</span>
<span class="line-modified">!         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage, doesHandleFetch);</span>
      });
  }
  
<span class="line-modified">! void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage, bool doesHandleFetch)</span>
  {
      if (m_serviceWorkerCreationCallback)
          m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
<span class="line-added">+     if (!exceptionMessage.isEmpty()) {</span>
<span class="line-added">+         connection()-&gt;serviceWorkerFailedToStart(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     connection()-&gt;serviceWorkerStarted(jobDataIdentifier, serviceWorkerIdentifier, doesHandleFetch);</span>
  }
  
  ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
  {
      return m_workerMap.get(identifier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,46 ***</span>
      auto* serviceWorker = m_workerMap.get(destination);
      ASSERT(serviceWorker);
      ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
  
      // FIXME: We should pass valid MessagePortChannels.
<span class="line-modified">!     serviceWorker-&gt;thread().postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));</span>
  }
  
  void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
      if (!serviceWorker)
          return;
  
<span class="line-modified">!     serviceWorker-&gt;thread().fireInstallEvent();</span>
  }
  
  void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
      if (!serviceWorker)
          return;
  
<span class="line-modified">!     serviceWorker-&gt;thread().fireActivateEvent();</span>
  }
  
  void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
  {
      auto serviceWorker = m_workerMap.take(identifier);
      if (!serviceWorker) {
          if (completionHandler)
              completionHandler();
          return;
      }
  
<span class="line-modified">!     serviceWorker-&gt;setAsTerminatingOrTerminated();</span>
  
      m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
  
<span class="line-modified">!     auto&amp; thread = serviceWorker-&gt;thread();</span>
<span class="line-modified">!     thread.stop([this, identifier, serviceWorker = WTFMove(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {</span>
          m_pendingServiceWorkerTerminationRequests.remove(identifier);
  
          if (auto* connection = SWContextManager::singleton().connection())
              connection-&gt;workerTerminated(identifier);
  
<span class="line-new-header">--- 85,51 ---</span>
      auto* serviceWorker = m_workerMap.get(destination);
      ASSERT(serviceWorker);
      ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
  
      // FIXME: We should pass valid MessagePortChannels.
<span class="line-modified">!     serviceWorker-&gt;postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));</span>
  }
  
  void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
      if (!serviceWorker)
          return;
  
<span class="line-modified">!     serviceWorker-&gt;fireInstallEvent();</span>
  }
  
  void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
      if (!serviceWorker)
          return;
  
<span class="line-modified">!     serviceWorker-&gt;fireActivateEvent();</span>
  }
  
  void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
  {
      auto serviceWorker = m_workerMap.take(identifier);
      if (!serviceWorker) {
          if (completionHandler)
              completionHandler();
          return;
      }
<span class="line-added">+     stopWorker(*serviceWorker, timeout, WTFMove(completionHandler));</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void SWContextManager::stopWorker(ServiceWorkerThreadProxy&amp; serviceWorker, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto identifier = serviceWorker.identifier();</span>
<span class="line-added">+     serviceWorker.setAsTerminatingOrTerminated();</span>
  
      m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
  
<span class="line-modified">!     auto&amp; thread = serviceWorker.thread();</span>
<span class="line-modified">!     thread.stop([this, identifier, serviceWorker = makeRef(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {</span>
          m_pendingServiceWorkerTerminationRequests.remove(identifier);
  
          if (auto* connection = SWContextManager::singleton().connection())
              connection-&gt;workerTerminated(identifier);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 134,11 ***</span>
  }
  
  void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
  {
      for (auto&amp; workerThread : m_workerMap.values())
<span class="line-modified">!         apply(*workerThread);</span>
  }
  
  bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
<span class="line-new-header">--- 143,11 ---</span>
  }
  
  void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
  {
      for (auto&amp; workerThread : m_workerMap.values())
<span class="line-modified">!         apply(workerThread);</span>
  }
  
  bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
  {
      auto* serviceWorker = m_workerMap.get(identifier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,17 ***</span>
<span class="line-new-header">--- 162,25 ---</span>
  
  void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
  {
      UNUSED_PARAM(serviceWorkerIdentifier);
      RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to terminate service worker with identifier %s, killing the service worker process&quot;, serviceWorkerIdentifier.loggingString().utf8().data());
<span class="line-added">+     ASSERT_NOT_REACHED();</span>
      _exit(EXIT_FAILURE);
  }
  
  SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager&amp; manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
      : m_timeoutTimer([&amp;manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
  {
      m_timeoutTimer.startOneShot(timeout);
  }
  
<span class="line-added">+ void SWContextManager::stopAllServiceWorkers()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto serviceWorkers = WTFMove(m_workerMap);</span>
<span class="line-added">+     for (auto&amp; serviceWorker : serviceWorkers.values())</span>
<span class="line-added">+         stopWorker(serviceWorker, workerTerminationTimeout, [] { });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif
</pre>
<center><a href="../ServiceWorkerTypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWContextManager.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
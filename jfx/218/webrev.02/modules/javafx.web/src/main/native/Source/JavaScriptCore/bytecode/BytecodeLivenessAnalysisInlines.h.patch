diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeLivenessAnalysisInlines.h
@@ -31,39 +31,75 @@
 #include "InterpreterInlines.h"
 #include "Operations.h"
 
 namespace JSC {
 
-inline bool operandIsAlwaysLive(int operand)
+inline bool virtualRegisterIsAlwaysLive(VirtualRegister reg)
 {
-    return !VirtualRegister(operand).isLocal();
+    return !reg.isLocal();
 }
 
-inline bool operandThatIsNotAlwaysLiveIsLive(const FastBitVector& out, int operand)
+inline bool virtualRegisterThatIsNotAlwaysLiveIsLive(const FastBitVector& out, VirtualRegister reg)
 {
-    unsigned local = VirtualRegister(operand).toLocal();
+    unsigned local = reg.toLocal();
     if (local >= out.numBits())
         return false;
     return out[local];
 }
 
-inline bool operandIsLive(const FastBitVector& out, int operand)
+inline bool virtualRegisterIsLive(const FastBitVector& out, VirtualRegister operand)
 {
-    return operandIsAlwaysLive(operand) || operandThatIsNotAlwaysLiveIsLive(out, operand);
+    return virtualRegisterIsAlwaysLive(operand) || virtualRegisterThatIsNotAlwaysLiveIsLive(out, operand);
 }
 
 inline bool isValidRegisterForLiveness(VirtualRegister operand)
 {
     if (operand.isConstant())
         return false;
     return operand.isLocal();
 }
 
+template<typename CodeBlockType, typename DefFunctor>
+inline void BytecodeLivenessPropagation::stepOverInstructionDef(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph&, BytecodeIndex bytecodeIndex, const DefFunctor& def)
+{
+    auto* instruction = instructions.at(bytecodeIndex).ptr();
+    computeDefsForBytecodeIndex(
+        codeBlock, instruction,
+        [&] (VirtualRegister operand) {
+            if (isValidRegisterForLiveness(operand))
+                def(operand.toLocal());
+        });
+}
+
+template<typename CodeBlockType, typename UseFunctor>
+inline void BytecodeLivenessPropagation::stepOverInstructionUse(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph&, BytecodeIndex bytecodeIndex, const UseFunctor& use)
+{
+    auto* instruction = instructions.at(bytecodeIndex).ptr();
+    computeUsesForBytecodeIndex(
+        codeBlock, instruction,
+        [&] (VirtualRegister operand) {
+            if (isValidRegisterForLiveness(operand))
+                use(operand.toLocal());
+        });
+}
+
+template<typename CodeBlockType, typename UseFunctor>
+inline void BytecodeLivenessPropagation::stepOverInstructionUseInExceptionHandler(CodeBlockType* codeBlock, const InstructionStream&, BytecodeGraph& graph, BytecodeIndex bytecodeIndex, const UseFunctor& use)
+{
+    // If we have an exception handler, we want the live-in variables of the
+    // exception handler block to be included in the live-in of this particular bytecode.
+    if (auto* handler = codeBlock->handlerForBytecodeIndex(bytecodeIndex)) {
+        BytecodeBasicBlock* handlerBlock = graph.findBasicBlockWithLeaderOffset(handler->target);
+        ASSERT(handlerBlock);
+        handlerBlock->in().forEachSetBit(use);
+    }
+}
+
 // Simplified interface to bytecode use/def, which determines defs first and then uses, and includes
 // exception handlers in the uses.
 template<typename CodeBlockType, typename UseFunctor, typename DefFunctor>
-inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph& graph, InstructionStream::Offset bytecodeOffset, const UseFunctor& use, const DefFunctor& def)
+inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph& graph, BytecodeIndex bytecodeIndex, const UseFunctor& use, const DefFunctor& def)
 {
     // This abstractly execute the instruction in reverse. Instructions logically first use operands and
     // then define operands. This logical ordering is necessary for operations that use and def the same
     // operand, like:
     //
@@ -76,41 +112,20 @@
     //
     // Since this is a liveness analysis, this ordering ends up being particularly important: if we did
     // uses before defs, then the add operation above would appear to not have loc1 live, since we'd
     // first add it to the out set (the use), and then we'd remove it (the def).
 
-    auto* instruction = instructions.at(bytecodeOffset).ptr();
-    OpcodeID opcodeID = instruction->opcodeID();
-
-    computeDefsForBytecodeOffset(
-        codeBlock, opcodeID, instruction,
-        [&] (VirtualRegister operand) {
-            if (isValidRegisterForLiveness(operand))
-                def(operand.toLocal());
-        });
-
-    computeUsesForBytecodeOffset(
-        codeBlock, opcodeID, instruction,
-        [&] (VirtualRegister operand) {
-            if (isValidRegisterForLiveness(operand))
-                use(operand.toLocal());
-        });
-
-    // If we have an exception handler, we want the live-in variables of the
-    // exception handler block to be included in the live-in of this particular bytecode.
-    if (auto* handler = codeBlock->handlerForBytecodeOffset(bytecodeOffset)) {
-        BytecodeBasicBlock* handlerBlock = graph.findBasicBlockWithLeaderOffset(handler->target);
-        ASSERT(handlerBlock);
-        handlerBlock->in().forEachSetBit(use);
-    }
+    stepOverInstructionDef(codeBlock, instructions, graph, bytecodeIndex, def);
+    stepOverInstructionUseInExceptionHandler(codeBlock, instructions, graph, bytecodeIndex, use);
+    stepOverInstructionUse(codeBlock, instructions, graph, bytecodeIndex, use);
 }
 
 template<typename CodeBlockType>
-inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph& graph, InstructionStream::Offset bytecodeOffset, FastBitVector& out)
+inline void BytecodeLivenessPropagation::stepOverInstruction(CodeBlockType* codeBlock, const InstructionStream& instructions, BytecodeGraph& graph, BytecodeIndex bytecodeIndex, FastBitVector& out)
 {
     stepOverInstruction(
-        codeBlock, instructions, graph, bytecodeOffset,
+        codeBlock, instructions, graph, bytecodeIndex,
         [&] (unsigned bitIndex) {
             // This is the use functor, so we set the bit.
             out[bitIndex] = true;
         },
         [&] (unsigned bitIndex) {
@@ -118,73 +133,77 @@
             out[bitIndex] = false;
         });
 }
 
 template<typename CodeBlockType, typename Instructions>
-inline bool BytecodeLivenessPropagation::computeLocalLivenessForBytecodeOffset(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, BytecodeBasicBlock* block, unsigned targetOffset, FastBitVector& result)
+inline bool BytecodeLivenessPropagation::computeLocalLivenessForBytecodeIndex(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, BytecodeBasicBlock& block, BytecodeIndex targetIndex, FastBitVector& result)
 {
-    ASSERT(!block->isExitBlock());
-    ASSERT(!block->isEntryBlock());
+    ASSERT(!block.isExitBlock());
+    ASSERT(!block.isEntryBlock());
 
-    FastBitVector out = block->out();
+    FastBitVector out = block.out();
 
-    for (int i = block->offsets().size() - 1; i >= 0; i--) {
-        unsigned bytecodeOffset = block->offsets()[i];
-        if (targetOffset > bytecodeOffset)
+    unsigned cursor = block.totalLength();
+    for (unsigned i = block.delta().size(); i--;) {
+        cursor -= block.delta()[i];
+        BytecodeIndex bytecodeIndex = BytecodeIndex(block.leaderOffset() + cursor);
+        if (targetIndex.offset() > bytecodeIndex.offset())
             break;
-        stepOverInstruction(codeBlock, instructions, graph, bytecodeOffset, out);
+        stepOverInstruction(codeBlock, instructions, graph, bytecodeIndex, out);
     }
 
     return result.setAndCheck(out);
 }
 
 template<typename CodeBlockType, typename Instructions>
-inline bool BytecodeLivenessPropagation::computeLocalLivenessForBlock(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, BytecodeBasicBlock* block)
+inline bool BytecodeLivenessPropagation::computeLocalLivenessForBlock(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, BytecodeBasicBlock& block)
 {
-    if (block->isExitBlock() || block->isEntryBlock())
+    if (block.isExitBlock() || block.isEntryBlock())
         return false;
-    return computeLocalLivenessForBytecodeOffset(codeBlock, instructions, graph, block, block->leaderOffset(), block->in());
+    return computeLocalLivenessForBytecodeIndex(codeBlock, instructions, graph, block, BytecodeIndex(block.leaderOffset()), block.in());
 }
 
 template<typename CodeBlockType, typename Instructions>
-inline FastBitVector BytecodeLivenessPropagation::getLivenessInfoAtBytecodeOffset(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, unsigned bytecodeOffset)
+inline FastBitVector BytecodeLivenessPropagation::getLivenessInfoAtBytecodeIndex(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph, BytecodeIndex bytecodeIndex)
 {
-    BytecodeBasicBlock* block = graph.findBasicBlockForBytecodeOffset(bytecodeOffset);
+    BytecodeBasicBlock* block = graph.findBasicBlockForBytecodeOffset(bytecodeIndex.offset());
     ASSERT(block);
     ASSERT(!block->isEntryBlock());
     ASSERT(!block->isExitBlock());
     FastBitVector out;
     out.resize(block->out().numBits());
-    computeLocalLivenessForBytecodeOffset(codeBlock, instructions, graph, block, bytecodeOffset, out);
+    computeLocalLivenessForBytecodeIndex(codeBlock, instructions, graph, *block, bytecodeIndex, out);
     return out;
 }
 
 template<typename CodeBlockType, typename Instructions>
 inline void BytecodeLivenessPropagation::runLivenessFixpoint(CodeBlockType* codeBlock, const Instructions& instructions, BytecodeGraph& graph)
 {
     unsigned numberOfVariables = codeBlock->numCalleeLocals();
-    for (BytecodeBasicBlock* block : graph) {
-        block->in().resize(numberOfVariables);
-        block->out().resize(numberOfVariables);
-        block->in().clearAll();
-        block->out().clearAll();
+    for (BytecodeBasicBlock& block : graph) {
+        block.in().resize(numberOfVariables);
+        block.out().resize(numberOfVariables);
+        block.in().clearAll();
+        block.out().clearAll();
     }
 
     bool changed;
-    BytecodeBasicBlock* lastBlock = graph.last();
-    lastBlock->in().clearAll();
-    lastBlock->out().clearAll();
+    BytecodeBasicBlock& lastBlock = graph.last();
+    lastBlock.in().clearAll();
+    lastBlock.out().clearAll();
     FastBitVector newOut;
-    newOut.resize(lastBlock->out().numBits());
+    newOut.resize(lastBlock.out().numBits());
     do {
         changed = false;
-        for (std::unique_ptr<BytecodeBasicBlock>& block : graph.basicBlocksInReverseOrder()) {
+        for (BytecodeBasicBlock& block : graph.basicBlocksInReverseOrder()) {
             newOut.clearAll();
-            for (BytecodeBasicBlock* successor : block->successors())
-                newOut |= successor->in();
-            block->out() = newOut;
-            changed |= computeLocalLivenessForBlock(codeBlock, instructions, graph, block.get());
+            for (unsigned blockIndex : block.successors()) {
+                BytecodeBasicBlock& successor = graph[blockIndex];
+                newOut |= successor.in();
+            }
+            block.out() = newOut;
+            changed |= computeLocalLivenessForBlock(codeBlock, instructions, graph, block);
         }
     } while (changed);
 }
 
 } // namespace JSC

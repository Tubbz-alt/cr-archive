<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CCallHelpers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CCallHelpers.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffleData.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CCallHelpers.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 39,11 ***</span>
  #define POKE_ARGUMENT_OFFSET 4
  #else
  #define POKE_ARGUMENT_OFFSET 0
  #endif
  
<span class="line-modified">! class ExecState;</span>
  class Structure;
  namespace DFG {
  class RegisteredStructure;
  };
  
<span class="line-new-header">--- 39,11 ---</span>
  #define POKE_ARGUMENT_OFFSET 4
  #else
  #define POKE_ARGUMENT_OFFSET 0
  #endif
  
<span class="line-modified">! class CallFrame;</span>
  class Structure;
  namespace DFG {
  class RegisteredStructure;
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 87,11 ***</span>
  private:
  
      template&lt;unsigned NumberOfRegisters, typename RegType&gt;
      ALWAYS_INLINE void setupStubArgs(std::array&lt;RegType, NumberOfRegisters&gt; destinations, std::array&lt;RegType, NumberOfRegisters&gt; sources)
      {
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              RegisterSet set;
              for (RegType dest : destinations)
                  set.set(dest);
              ASSERT_WITH_MESSAGE(set.numberOfSetRegisters() == NumberOfRegisters, &quot;Destinations should not be aliased.&quot;);
          }
<span class="line-new-header">--- 87,11 ---</span>
  private:
  
      template&lt;unsigned NumberOfRegisters, typename RegType&gt;
      ALWAYS_INLINE void setupStubArgs(std::array&lt;RegType, NumberOfRegisters&gt; destinations, std::array&lt;RegType, NumberOfRegisters&gt; sources)
      {
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              RegisterSet set;
              for (RegType dest : destinations)
                  set.set(dest);
              ASSERT_WITH_MESSAGE(set.numberOfSetRegisters() == NumberOfRegisters, &quot;Destinations should not be aliased.&quot;);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,11 ***</span>
          for (unsigned i = 0; i &lt; NumberOfRegisters; ++i) {
              if (sources[i] != destinations[i])
                  pairs.append(std::make_pair(sources[i], destinations[i]));
          }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          auto numUniqueSources = [&amp;] () -&gt; unsigned {
              RegisterSet set;
              for (auto&amp; pair : pairs) {
                  RegType source = pair.first;
                  set.set(source);
<span class="line-new-header">--- 102,11 ---</span>
          for (unsigned i = 0; i &lt; NumberOfRegisters; ++i) {
              if (sources[i] != destinations[i])
                  pairs.append(std::make_pair(sources[i], destinations[i]));
          }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
          auto numUniqueSources = [&amp;] () -&gt; unsigned {
              RegisterSet set;
              for (auto&amp; pair : pairs) {
                  RegType source = pair.first;
                  set.set(source);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,47 ***</span>
      {
          marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
      }
  
  #else // USE(JSVALUE64)
<span class="line-modified">! #if CPU(X86)</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">-     ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);</span>
<span class="line-removed">-         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">-         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addStackArg(arg).addPoke(), args...);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">-     ALWAYS_INLINE std::enable_if_t&lt;sizeof(CURRENT_ARGUMENT_TYPE) &lt;= 4&gt;</span>
<span class="line-removed">-     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, GPRReg arg, Args... args)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         pokeForArgument(arg, numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">-         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg(), args...);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">-     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;</span>
<span class="line-removed">-     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, CellValue payload, Args... args)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         pokeForArgument(payload.gpr(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">-         pokeForArgument(TrustedImm32(JSValue::CellTag), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);</span>
<span class="line-removed">-         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke(), args...);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;</span>
<span class="line-removed">-     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;CURRENT_ARGUMENT_TYPE, EncodedJSValue&gt;::value&gt;</span>
<span class="line-removed">-     setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, JSValueRegs arg, Args... args)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         pokeForArgument(arg.payloadGPR(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke);</span>
<span class="line-removed">-         pokeForArgument(arg.tagGPR(), numGPRArgs, numFPRArgs, numCrossSources, extraGPRArgs, extraPoke + 1);</span>
<span class="line-removed">-         setupArgumentsImpl&lt;OperationType&gt;(argSourceRegs.addGPRArg().addPoke(), args...);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">- #elif CPU(ARM_THUMB2) || CPU(MIPS)</span>
  
      template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
      void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
      {
          static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
<span class="line-new-header">--- 410,11 ---</span>
      {
          marshallArgumentRegister&lt;OperationType&gt;(argSourceRegs, arg.gpr(), args...);
      }
  
  #else // USE(JSVALUE64)
<span class="line-modified">! #if CPU(ARM_THUMB2) || CPU(MIPS)</span>
  
      template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke, typename... Args&gt;
      void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs, FPRReg arg, Args... args)
      {
          static_assert(std::is_same&lt;CURRENT_ARGUMENT_TYPE, double&gt;::value, &quot;We should only be passing FPRRegs to a double&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,11 ***</span>
      // Base case; set up the argument registers.
      template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
      ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs)
      {
          static_assert(FunctionTraits&lt;OperationType&gt;::arity == numGPRArgs + numFPRArgs, &quot;One last sanity check&quot;);
<span class="line-modified">! #if USE(JSVALUE64) || CPU(X86)</span>
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == numGPRArgs + numFPRArgs + extraPoke, &quot;Check the CCall arity&quot;);
  #endif
          setupStubArgs&lt;numGPRSources, GPRReg&gt;(clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprDestinations), clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprSources));
  #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
          setupStubCrossArgs&lt;numCrossSources&gt;(argSourceRegs.crossDestinations, argSourceRegs.crossSources);
<span class="line-new-header">--- 631,11 ---</span>
      // Base case; set up the argument registers.
      template&lt;typename OperationType, unsigned numGPRArgs, unsigned numGPRSources, unsigned numFPRArgs, unsigned numFPRSources, unsigned numCrossSources, unsigned extraGPRArgs, unsigned extraPoke&gt;
      ALWAYS_INLINE void setupArgumentsImpl(ArgCollection&lt;numGPRArgs, numGPRSources, numFPRArgs, numFPRSources, numCrossSources, extraGPRArgs, extraPoke&gt; argSourceRegs)
      {
          static_assert(FunctionTraits&lt;OperationType&gt;::arity == numGPRArgs + numFPRArgs, &quot;One last sanity check&quot;);
<span class="line-modified">! #if USE(JSVALUE64)</span>
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == numGPRArgs + numFPRArgs + extraPoke, &quot;Check the CCall arity&quot;);
  #endif
          setupStubArgs&lt;numGPRSources, GPRReg&gt;(clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprDestinations), clampArrayToSize&lt;numGPRSources, GPRReg&gt;(argSourceRegs.gprSources));
  #if CPU(MIPS) || (CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP))
          setupStubCrossArgs&lt;numCrossSources&gt;(argSourceRegs.crossDestinations, argSourceRegs.crossSources);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 684,21 ***</span>
  public:
  
  #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;
  
      template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">!     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;FIRST_ARGUMENT_TYPE, ExecState*&gt;::value&gt; setupArguments(Args... args)</span>
      {
  #if USE(JSVALUE64)
          // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args) + 1, &quot;Basic sanity check&quot;);
  #endif
          setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), GPRInfo::callFrameRegister, args...);
      }
  
      template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">!     ALWAYS_INLINE std::enable_if_t&lt;!std::is_same&lt;FIRST_ARGUMENT_TYPE, ExecState*&gt;::value&gt; setupArguments(Args... args)</span>
      {
  #if USE(JSVALUE64)
          // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Basic sanity check&quot;);
  #endif
<span class="line-new-header">--- 648,21 ---</span>
  public:
  
  #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;
  
      template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">!     ALWAYS_INLINE std::enable_if_t&lt;std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)</span>
      {
  #if USE(JSVALUE64)
          // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args) + 1, &quot;Basic sanity check&quot;);
  #endif
          setupArgumentsImpl&lt;OperationType, 0, 0, 0, 0, 0, 0, 0&gt;(ArgCollection&lt;0, 0, 0, 0, 0, 0, 0&gt;(), GPRInfo::callFrameRegister, args...);
      }
  
      template&lt;typename OperationType, typename... Args&gt;
<span class="line-modified">!     ALWAYS_INLINE std::enable_if_t&lt;!std::is_same&lt;FIRST_ARGUMENT_TYPE, CallFrame*&gt;::value&gt; setupArguments(Args... args)</span>
      {
  #if USE(JSVALUE64)
          // This only really works for 64-bit since jsvalue regs mess things up for 32-bit...
          static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Basic sanity check&quot;);
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 758,11 ***</span>
              // parameters in case of arity fixup), plus the frame header size,
              // aligned
              GPRReg oldFrameSizeGPR = temp2;
              {
                  GPRReg argCountGPR = oldFrameSizeGPR;
<span class="line-modified">!                 load32(Address(framePointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), argCountGPR);</span>
  
                  {
                      GPRReg numParametersGPR = temp1;
                      {
                          GPRReg codeBlockGPR = numParametersGPR;
<span class="line-new-header">--- 722,11 ---</span>
              // parameters in case of arity fixup), plus the frame header size,
              // aligned
              GPRReg oldFrameSizeGPR = temp2;
              {
                  GPRReg argCountGPR = oldFrameSizeGPR;
<span class="line-modified">!                 load32(Address(framePointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), argCountGPR);</span>
  
                  {
                      GPRReg numParametersGPR = temp1;
                      {
                          GPRReg codeBlockGPR = numParametersGPR;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,11 ***</span>
              addPtr(framePointerRegister, oldFrameSizeGPR, newFramePointer);
  
              // The new frame size is just the number of arguments plus the
              // frame header size, aligned
              ASSERT(newFrameSizeGPR != newFramePointer);
<span class="line-modified">!             load32(Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)),</span>
                  newFrameSizeGPR);
              add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), newFrameSizeGPR);
              and32(TrustedImm32(-stackAlignmentRegisters()), newFrameSizeGPR);
              // We assume &lt; 2^28 arguments
              mul32(TrustedImm32(sizeof(Register)), newFrameSizeGPR, newFrameSizeGPR);
<span class="line-new-header">--- 751,11 ---</span>
              addPtr(framePointerRegister, oldFrameSizeGPR, newFramePointer);
  
              // The new frame size is just the number of arguments plus the
              // frame header size, aligned
              ASSERT(newFrameSizeGPR != newFramePointer);
<span class="line-modified">!             load32(Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)),</span>
                  newFrameSizeGPR);
              add32(TrustedImm32(stackAlignmentRegisters() + CallFrame::headerSizeInRegisters - 1), newFrameSizeGPR);
              and32(TrustedImm32(-stackAlignmentRegisters()), newFrameSizeGPR);
              // We assume &lt; 2^28 arguments
              mul32(TrustedImm32(sizeof(Register)), newFrameSizeGPR, newFrameSizeGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 810,11 ***</span>
          untagPtr(tempGPR, linkRegister);
  #endif
  #elif CPU(MIPS)
          loadPtr(Address(framePointerRegister, sizeof(void*)), returnAddressRegister);
          subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
<span class="line-modified">! #elif CPU(X86) || CPU(X86_64)</span>
          loadPtr(Address(framePointerRegister, sizeof(void*)), tempGPR);
          push(tempGPR);
          subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
  #else
          UNREACHABLE_FOR_PLATFORM();
<span class="line-new-header">--- 774,11 ---</span>
          untagPtr(tempGPR, linkRegister);
  #endif
  #elif CPU(MIPS)
          loadPtr(Address(framePointerRegister, sizeof(void*)), returnAddressRegister);
          subPtr(TrustedImm32(2 * sizeof(void*)), newFrameSizeGPR);
<span class="line-modified">! #elif CPU(X86_64)</span>
          loadPtr(Address(framePointerRegister, sizeof(void*)), tempGPR);
          push(tempGPR);
          subPtr(TrustedImm32(sizeof(void*)), newFrameSizeGPR);
  #else
          UNREACHABLE_FOR_PLATFORM();
</pre>
<center><a href="CCallHelpers.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffleData.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/FullscreenManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FocusEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FullscreenManager.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/FullscreenManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FullscreenManager.h&quot;
 28 
 29 #if ENABLE(FULLSCREEN_API)
 30 
 31 #include &quot;Chrome.h&quot;
 32 #include &quot;ChromeClient.h&quot;
<span class="line-removed"> 33 #include &quot;Document.h&quot;</span>
<span class="line-removed"> 34 #include &quot;Element.h&quot;</span>
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
<span class="line-modified"> 37 #include &quot;HTMLFrameOwnerElement.h&quot;</span>
 38 #include &quot;HTMLMediaElement.h&quot;
 39 #include &quot;Page.h&quot;
 40 #include &quot;QualifiedName.h&quot;
 41 #include &quot;RenderFullScreen.h&quot;
 42 #include &quot;RenderTreeBuilder.h&quot;
 43 #include &quot;Settings.h&quot;
 44 
 45 namespace WebCore {
 46 
 47 using namespace HTMLNames;
 48 
<span class="line-removed"> 49 static bool isAttributeOnAllOwners(const QualifiedName&amp; attribute, const QualifiedName&amp; prefixedAttribute, const HTMLFrameOwnerElement* owner)</span>
<span class="line-removed"> 50 {</span>
<span class="line-removed"> 51     if (!owner)</span>
<span class="line-removed"> 52         return true;</span>
<span class="line-removed"> 53     do {</span>
<span class="line-removed"> 54         if (!(owner-&gt;hasAttribute(attribute) || owner-&gt;hasAttribute(prefixedAttribute)))</span>
<span class="line-removed"> 55             return false;</span>
<span class="line-removed"> 56     } while ((owner = owner-&gt;document().ownerElement()));</span>
<span class="line-removed"> 57     return true;</span>
<span class="line-removed"> 58 }</span>
<span class="line-removed"> 59 </span>
 60 FullscreenManager::FullscreenManager(Document&amp; document)
 61     : m_document { document }
 62 {
 63 }
 64 
 65 FullscreenManager::~FullscreenManager() = default;
 66 
<span class="line-removed"> 67 bool FullscreenManager::fullscreenIsAllowedForElement(Element&amp; element) const</span>
<span class="line-removed"> 68 {</span>
<span class="line-removed"> 69     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, element.document().ownerElement());</span>
<span class="line-removed"> 70 }</span>
<span class="line-removed"> 71 </span>
 72 void FullscreenManager::requestFullscreenForElement(Element* element, FullscreenCheckType checkType)
 73 {
 74     if (!element)
 75         element = documentElement();
 76 
 77     auto failedPreflights = [this](auto element) mutable {
 78         m_fullscreenErrorEventTargetQueue.append(WTFMove(element));
 79         m_fullscreenTaskQueue.enqueueTask([this] {
 80             dispatchFullscreenChangeEvents();
 81         });
 82     };
 83 
 84     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire
 85     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s
 86     // node document:
 87 
 88     // This algorithm is not allowed to show a pop-up:
 89     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:
 90     //   - an activation behavior is currently being processed whose click event was trusted, or
 91     //   - the event listener for a trusted click event is being handled.
</pre>
<hr />
<pre>
127         // has requested fullscreen.
128         if (m_pendingFullscreenElement != element) {
129             failedPreflights(WTFMove(element));
130             return;
131         }
132 
133         // Don&#39;t allow fullscreen if document is hidden.
134         if (document().hidden()) {
135             failedPreflights(WTFMove(element));
136             return;
137         }
138 
139         // The context object is not in a document.
140         if (!element-&gt;isConnected()) {
141             failedPreflights(WTFMove(element));
142             return;
143         }
144 
145         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have
146         // the fullscreen enabled flag set.
<span class="line-modified">147         if (checkType == EnforceIFrameAllowFullscreenRequirement &amp;&amp; !fullscreenIsAllowedForElement(*element)) {</span>
148             failedPreflights(WTFMove(element));
149             return;
150         }
151 
152         // The context object&#39;s node document fullscreen element stack is not empty and its top element
153         // is not an ancestor of the context object.
154         if (!m_fullscreenElementStack.isEmpty() &amp;&amp; !m_fullscreenElementStack.last()-&gt;contains(element.get())) {
155             failedPreflights(WTFMove(element));
156             return;
157         }
158 
159         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.
160         bool descendentHasNonEmptyStack = false;
161         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
162             if (descendant-&gt;document()-&gt;fullscreenManager().fullscreenElement()) {
163                 descendentHasNonEmptyStack = true;
164                 break;
165             }
166         }
167         if (descendentHasNonEmptyStack) {
</pre>
<hr />
<pre>
330         }
331 
332         // Only exit out of full screen window mode if there are no remaining elements in the
333         // full screen stack.
334         if (!newTop) {
335             page-&gt;chrome().client().exitFullScreenForElement(fullscreenElement.get());
336             return;
337         }
338 
339         // Otherwise, notify the chrome of the new full screen element.
340         page-&gt;chrome().client().enterFullScreenForElement(*newTop);
341     });
342 }
343 
344 bool FullscreenManager::isFullscreenEnabled() const
345 {
346     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor
347     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.
348 
349     // Top-level browsing contexts are implied to have their allowFullscreen attribute set.
<span class="line-modified">350     return isAttributeOnAllOwners(allowfullscreenAttr, webkitallowfullscreenAttr, document().ownerElement());</span>
351 }
352 
353 static void unwrapFullscreenRenderer(RenderFullScreen* fullscreenRenderer, Element* fullscreenElement)
354 {
355     if (!fullscreenRenderer)
356         return;
357     bool requiresRenderTreeRebuild;
358     fullscreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);
359 
360     if (requiresRenderTreeRebuild &amp;&amp; fullscreenElement &amp;&amp; fullscreenElement-&gt;parentElement())
361         fullscreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();
362 }
363 
364 void FullscreenManager::willEnterFullscreen(Element&amp; element)
365 {
<span class="line-modified">366     if (!document().hasLivingRenderTree() || document().pageCacheState() != Document::NotInPageCache)</span>
367         return;
368 
369     // Protect against being called after the document has been removed from the page.
370     if (!page())
371         return;
372 
373     // If pending fullscreen element is unset or another element&#39;s was requested,
374     // issue a cancel fullscreen request to the client
375     if (m_pendingFullscreenElement != &amp;element) {
376         page()-&gt;chrome().client().exitFullScreenForElement(&amp;element);
377         return;
378     }
379 
380     ASSERT(page()-&gt;settings().fullScreenEnabled());
381 
382     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
383 
384     element.willBecomeFullscreenElement();
385 
386     ASSERT(&amp;element == m_pendingFullscreenElement);
387     m_pendingFullscreenElement = nullptr;
388     m_fullscreenElement = &amp;element;
389 
390 #if USE(NATIVE_FULLSCREEN_VIDEO)
<span class="line-modified">391     if (element.isMediaElement())</span>
392         return;
393 #endif
394 
395     // Create a placeholder block for a the full-screen element, to keep the page from reflowing
396     // when the element is removed from the normal flow. Only do this for a RenderBox, as only
397     // a box will have a frameRect. The placeholder will be created in setFullscreenRenderer()
398     // during layout.
399     auto renderer = m_fullscreenElement-&gt;renderer();
400     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);
401     if (shouldCreatePlaceholder) {
402         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();
403         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());
404     }
405 
406     if (m_fullscreenElement != documentElement() &amp;&amp; renderer)
407         RenderFullScreen::wrapExistingRenderer(*renderer, document());
408 
409     m_fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
410 
411     document().resolveStyle(Document::ResolveStyleType::Rebuild);
412     dispatchFullscreenChangeEvents();
413 }
414 
415 void FullscreenManager::didEnterFullscreen()
416 {
417     if (!m_fullscreenElement)
418         return;
419 
<span class="line-modified">420     if (!hasLivingRenderTree() || pageCacheState() != Document::NotInPageCache)</span>
421         return;
422 
423     m_fullscreenElement-&gt;didBecomeFullscreenElement();
424 }
425 
426 void FullscreenManager::willExitFullscreen()
427 {
428     auto fullscreenElement = fullscreenOrPendingElement();
429     if (!fullscreenElement)
430         return;
431 
<span class="line-modified">432     if (!hasLivingRenderTree() || pageCacheState() != Document::NotInPageCache)</span>
433         return;
434 
435     fullscreenElement-&gt;willStopBeingFullscreenElement();
436 }
437 
438 void FullscreenManager::didExitFullscreen()
439 {
440     auto fullscreenElement = fullscreenOrPendingElement();
441     if (!fullscreenElement)
442         return;
443 
<span class="line-modified">444     if (!hasLivingRenderTree() || pageCacheState() != Document::NotInPageCache)</span>
445         return;
446     fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
447 
448     m_areKeysEnabledInFullscreen = false;
449 
450     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
451 
452     m_fullscreenElement = nullptr;
453     m_pendingFullscreenElement = nullptr;
454     scheduleFullStyleRebuild();
455 
456     // When webkitCancelFullscreen is called, we call webkitExitFullscreen on the topDocument(). That
457     // means that the events will be queued there. So if we have no events here, start the timer on
458     // the exiting document.
459     bool eventTargetQueuesEmpty = m_fullscreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullscreenErrorEventTargetQueue.isEmpty();
460     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : document();
461 
462     exitingDocument.fullscreenManager().dispatchFullscreenChangeEvents();
463 }
464 
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FullscreenManager.h&quot;
 28 
 29 #if ENABLE(FULLSCREEN_API)
 30 
 31 #include &quot;Chrome.h&quot;
 32 #include &quot;ChromeClient.h&quot;


 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Frame.h&quot;
<span class="line-modified"> 35 #include &quot;HTMLIFrameElement.h&quot;</span>
 36 #include &quot;HTMLMediaElement.h&quot;
 37 #include &quot;Page.h&quot;
 38 #include &quot;QualifiedName.h&quot;
 39 #include &quot;RenderFullScreen.h&quot;
 40 #include &quot;RenderTreeBuilder.h&quot;
 41 #include &quot;Settings.h&quot;
 42 
 43 namespace WebCore {
 44 
 45 using namespace HTMLNames;
 46 











 47 FullscreenManager::FullscreenManager(Document&amp; document)
 48     : m_document { document }
 49 {
 50 }
 51 
 52 FullscreenManager::~FullscreenManager() = default;
 53 





 54 void FullscreenManager::requestFullscreenForElement(Element* element, FullscreenCheckType checkType)
 55 {
 56     if (!element)
 57         element = documentElement();
 58 
 59     auto failedPreflights = [this](auto element) mutable {
 60         m_fullscreenErrorEventTargetQueue.append(WTFMove(element));
 61         m_fullscreenTaskQueue.enqueueTask([this] {
 62             dispatchFullscreenChangeEvents();
 63         });
 64     };
 65 
 66     // 1. If any of the following conditions are true, terminate these steps and queue a task to fire
 67     // an event named fullscreenerror with its bubbles attribute set to true on the context object&#39;s
 68     // node document:
 69 
 70     // This algorithm is not allowed to show a pop-up:
 71     //   An algorithm is allowed to show a pop-up if, in the task in which the algorithm is running, either:
 72     //   - an activation behavior is currently being processed whose click event was trusted, or
 73     //   - the event listener for a trusted click event is being handled.
</pre>
<hr />
<pre>
109         // has requested fullscreen.
110         if (m_pendingFullscreenElement != element) {
111             failedPreflights(WTFMove(element));
112             return;
113         }
114 
115         // Don&#39;t allow fullscreen if document is hidden.
116         if (document().hidden()) {
117             failedPreflights(WTFMove(element));
118             return;
119         }
120 
121         // The context object is not in a document.
122         if (!element-&gt;isConnected()) {
123             failedPreflights(WTFMove(element));
124             return;
125         }
126 
127         // The context object&#39;s node document, or an ancestor browsing context&#39;s document does not have
128         // the fullscreen enabled flag set.
<span class="line-modified">129         if (checkType == EnforceIFrameAllowFullscreenRequirement &amp;&amp; !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Fullscreen, document())) {</span>
130             failedPreflights(WTFMove(element));
131             return;
132         }
133 
134         // The context object&#39;s node document fullscreen element stack is not empty and its top element
135         // is not an ancestor of the context object.
136         if (!m_fullscreenElementStack.isEmpty() &amp;&amp; !m_fullscreenElementStack.last()-&gt;contains(element.get())) {
137             failedPreflights(WTFMove(element));
138             return;
139         }
140 
141         // A descendant browsing context&#39;s document has a non-empty fullscreen element stack.
142         bool descendentHasNonEmptyStack = false;
143         for (Frame* descendant = frame() ? frame()-&gt;tree().traverseNext() : nullptr; descendant; descendant = descendant-&gt;tree().traverseNext()) {
144             if (descendant-&gt;document()-&gt;fullscreenManager().fullscreenElement()) {
145                 descendentHasNonEmptyStack = true;
146                 break;
147             }
148         }
149         if (descendentHasNonEmptyStack) {
</pre>
<hr />
<pre>
312         }
313 
314         // Only exit out of full screen window mode if there are no remaining elements in the
315         // full screen stack.
316         if (!newTop) {
317             page-&gt;chrome().client().exitFullScreenForElement(fullscreenElement.get());
318             return;
319         }
320 
321         // Otherwise, notify the chrome of the new full screen element.
322         page-&gt;chrome().client().enterFullScreenForElement(*newTop);
323     });
324 }
325 
326 bool FullscreenManager::isFullscreenEnabled() const
327 {
328     // 4. The fullscreenEnabled attribute must return true if the context object and all ancestor
329     // browsing context&#39;s documents have their fullscreen enabled flag set, or false otherwise.
330 
331     // Top-level browsing contexts are implied to have their allowFullscreen attribute set.
<span class="line-modified">332     return isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Fullscreen, document());</span>
333 }
334 
335 static void unwrapFullscreenRenderer(RenderFullScreen* fullscreenRenderer, Element* fullscreenElement)
336 {
337     if (!fullscreenRenderer)
338         return;
339     bool requiresRenderTreeRebuild;
340     fullscreenRenderer-&gt;unwrapRenderer(requiresRenderTreeRebuild);
341 
342     if (requiresRenderTreeRebuild &amp;&amp; fullscreenElement &amp;&amp; fullscreenElement-&gt;parentElement())
343         fullscreenElement-&gt;parentElement()-&gt;invalidateStyleAndRenderersForSubtree();
344 }
345 
346 void FullscreenManager::willEnterFullscreen(Element&amp; element)
347 {
<span class="line-modified">348     if (!document().hasLivingRenderTree() || document().backForwardCacheState() != Document::NotInBackForwardCache)</span>
349         return;
350 
351     // Protect against being called after the document has been removed from the page.
352     if (!page())
353         return;
354 
355     // If pending fullscreen element is unset or another element&#39;s was requested,
356     // issue a cancel fullscreen request to the client
357     if (m_pendingFullscreenElement != &amp;element) {
358         page()-&gt;chrome().client().exitFullScreenForElement(&amp;element);
359         return;
360     }
361 
362     ASSERT(page()-&gt;settings().fullScreenEnabled());
363 
364     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
365 
366     element.willBecomeFullscreenElement();
367 
368     ASSERT(&amp;element == m_pendingFullscreenElement);
369     m_pendingFullscreenElement = nullptr;
370     m_fullscreenElement = &amp;element;
371 
372 #if USE(NATIVE_FULLSCREEN_VIDEO)
<span class="line-modified">373     if (is&lt;HTMLMediaElement&gt;(element))</span>
374         return;
375 #endif
376 
377     // Create a placeholder block for a the full-screen element, to keep the page from reflowing
378     // when the element is removed from the normal flow. Only do this for a RenderBox, as only
379     // a box will have a frameRect. The placeholder will be created in setFullscreenRenderer()
380     // during layout.
381     auto renderer = m_fullscreenElement-&gt;renderer();
382     bool shouldCreatePlaceholder = is&lt;RenderBox&gt;(renderer);
383     if (shouldCreatePlaceholder) {
384         m_savedPlaceholderFrameRect = downcast&lt;RenderBox&gt;(*renderer).frameRect();
385         m_savedPlaceholderRenderStyle = RenderStyle::clonePtr(renderer-&gt;style());
386     }
387 
388     if (m_fullscreenElement != documentElement() &amp;&amp; renderer)
389         RenderFullScreen::wrapExistingRenderer(*renderer, document());
390 
391     m_fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(true);
392 
393     document().resolveStyle(Document::ResolveStyleType::Rebuild);
394     dispatchFullscreenChangeEvents();
395 }
396 
397 void FullscreenManager::didEnterFullscreen()
398 {
399     if (!m_fullscreenElement)
400         return;
401 
<span class="line-modified">402     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)</span>
403         return;
404 
405     m_fullscreenElement-&gt;didBecomeFullscreenElement();
406 }
407 
408 void FullscreenManager::willExitFullscreen()
409 {
410     auto fullscreenElement = fullscreenOrPendingElement();
411     if (!fullscreenElement)
412         return;
413 
<span class="line-modified">414     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)</span>
415         return;
416 
417     fullscreenElement-&gt;willStopBeingFullscreenElement();
418 }
419 
420 void FullscreenManager::didExitFullscreen()
421 {
422     auto fullscreenElement = fullscreenOrPendingElement();
423     if (!fullscreenElement)
424         return;
425 
<span class="line-modified">426     if (!hasLivingRenderTree() || backForwardCacheState() != Document::NotInBackForwardCache)</span>
427         return;
428     fullscreenElement-&gt;setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(false);
429 
430     m_areKeysEnabledInFullscreen = false;
431 
432     unwrapFullscreenRenderer(m_fullscreenRenderer.get(), m_fullscreenElement.get());
433 
434     m_fullscreenElement = nullptr;
435     m_pendingFullscreenElement = nullptr;
436     scheduleFullStyleRebuild();
437 
438     // When webkitCancelFullscreen is called, we call webkitExitFullscreen on the topDocument(). That
439     // means that the events will be queued there. So if we have no events here, start the timer on
440     // the exiting document.
441     bool eventTargetQueuesEmpty = m_fullscreenChangeEventTargetQueue.isEmpty() &amp;&amp; m_fullscreenErrorEventTargetQueue.isEmpty();
442     Document&amp; exitingDocument = eventTargetQueuesEmpty ? topDocument() : document();
443 
444     exitingDocument.fullscreenManager().dispatchFullscreenChangeEvents();
445 }
446 
</pre>
</td>
</tr>
</table>
<center><a href="FocusEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FullscreenManager.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
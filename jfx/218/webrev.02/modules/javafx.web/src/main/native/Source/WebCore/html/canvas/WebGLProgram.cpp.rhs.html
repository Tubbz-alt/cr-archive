<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLProgram.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;InspectorInstrumentation.h&quot;</span>
<span class="line-added"> 32 #include &quot;ScriptExecutionContext.h&quot;</span>
 33 #include &quot;WebGLContextGroup.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 #include &quot;WebGLShader.h&quot;
<a name="2" id="anc2"></a>
 36 #include &lt;wtf/Lock.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&amp; WebGLProgram::instances(const LockHolder&amp;)
 42 {
 43     static NeverDestroyed&lt;HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&gt; instances;
 44     return instances;
 45 }
 46 
 47 Lock&amp; WebGLProgram::instancesMutex()
 48 {
 49     static LazyNeverDestroyed&lt;Lock&gt; mutex;
 50     static std::once_flag initializeMutex;
 51     std::call_once(initializeMutex, [] {
 52         mutex.construct();
 53     });
 54     return mutex.get();
 55 }
 56 
 57 Ref&lt;WebGLProgram&gt; WebGLProgram::create(WebGLRenderingContextBase&amp; ctx)
 58 {
 59     return adoptRef(*new WebGLProgram(ctx));
 60 }
 61 
 62 WebGLProgram::WebGLProgram(WebGLRenderingContextBase&amp; ctx)
 63     : WebGLSharedObject(ctx)
<a name="3" id="anc3"></a><span class="line-added"> 64     , ContextDestructionObserver(ctx.scriptExecutionContext())</span>
 65 {
<a name="4" id="anc4"></a><span class="line-added"> 66     ASSERT(scriptExecutionContext());</span>
<span class="line-added"> 67 </span>
 68     {
 69         LockHolder lock(instancesMutex());
 70         instances(lock).add(this, &amp;ctx);
 71     }
 72 
<a name="5" id="anc5"></a><span class="line-modified"> 73     setObject(ctx.graphicsContextGL()-&gt;createProgram());</span>
 74 }
 75 
 76 WebGLProgram::~WebGLProgram()
 77 {
<a name="6" id="anc6"></a><span class="line-added"> 78     InspectorInstrumentation::willDestroyWebGLProgram(*this);</span>
<span class="line-added"> 79 </span>
 80     deleteObject(0);
 81 
 82     {
 83         LockHolder lock(instancesMutex());
 84         ASSERT(instances(lock).contains(this));
 85         instances(lock).remove(this);
 86     }
 87 }
 88 
<a name="7" id="anc7"></a><span class="line-modified"> 89 void WebGLProgram::contextDestroyed()</span>
<span class="line-added"> 90 {</span>
<span class="line-added"> 91     InspectorInstrumentation::willDestroyWebGLProgram(*this);</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     ContextDestructionObserver::contextDestroyed();</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96 void WebGLProgram::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject obj)</span>
 97 {
 98     context3d-&gt;deleteProgram(obj);
 99     if (m_vertexShader) {
100         m_vertexShader-&gt;onDetached(context3d);
101         m_vertexShader = nullptr;
102     }
103     if (m_fragmentShader) {
104         m_fragmentShader-&gt;onDetached(context3d);
105         m_fragmentShader = nullptr;
106     }
107 }
108 
109 unsigned WebGLProgram::numActiveAttribLocations()
110 {
111     cacheInfoIfNeeded();
112     return m_activeAttribLocations.size();
113 }
114 
<a name="8" id="anc8"></a><span class="line-modified">115 GCGLint WebGLProgram::getActiveAttribLocation(GCGLuint index)</span>
116 {
117     cacheInfoIfNeeded();
118     if (index &gt;= numActiveAttribLocations())
119         return -1;
120     return m_activeAttribLocations[index];
121 }
122 
123 bool WebGLProgram::isUsingVertexAttrib0()
124 {
125     cacheInfoIfNeeded();
126     for (unsigned ii = 0; ii &lt; numActiveAttribLocations(); ++ii) {
127         if (!getActiveAttribLocation(ii))
128             return true;
129     }
130     return false;
131 }
132 
133 bool WebGLProgram::getLinkStatus()
134 {
135     cacheInfoIfNeeded();
136     return m_linkStatus;
137 }
138 
139 void WebGLProgram::setLinkStatus(bool status)
140 {
141     cacheInfoIfNeeded();
142     m_linkStatus = status;
143 }
144 
145 void WebGLProgram::increaseLinkCount()
146 {
147     ++m_linkCount;
148     m_infoValid = false;
149 }
150 
<a name="9" id="anc9"></a><span class="line-modified">151 WebGLShader* WebGLProgram::getAttachedShader(GCGLenum type)</span>
152 {
153     switch (type) {
<a name="10" id="anc10"></a><span class="line-modified">154     case GraphicsContextGL::VERTEX_SHADER:</span>
155         return m_vertexShader.get();
<a name="11" id="anc11"></a><span class="line-modified">156     case GraphicsContextGL::FRAGMENT_SHADER:</span>
157         return m_fragmentShader.get();
158     default:
159         return 0;
160     }
161 }
162 
163 bool WebGLProgram::attachShader(WebGLShader* shader)
164 {
165     if (!shader || !shader-&gt;object())
166         return false;
167     switch (shader-&gt;getType()) {
<a name="12" id="anc12"></a><span class="line-modified">168     case GraphicsContextGL::VERTEX_SHADER:</span>
169         if (m_vertexShader)
170             return false;
171         m_vertexShader = shader;
172         return true;
<a name="13" id="anc13"></a><span class="line-modified">173     case GraphicsContextGL::FRAGMENT_SHADER:</span>
174         if (m_fragmentShader)
175             return false;
176         m_fragmentShader = shader;
177         return true;
178     default:
179         return false;
180     }
181 }
182 
183 bool WebGLProgram::detachShader(WebGLShader* shader)
184 {
185     if (!shader || !shader-&gt;object())
186         return false;
187     switch (shader-&gt;getType()) {
<a name="14" id="anc14"></a><span class="line-modified">188     case GraphicsContextGL::VERTEX_SHADER:</span>
189         if (m_vertexShader != shader)
190             return false;
191         m_vertexShader = nullptr;
192         return true;
<a name="15" id="anc15"></a><span class="line-modified">193     case GraphicsContextGL::FRAGMENT_SHADER:</span>
194         if (m_fragmentShader != shader)
195             return false;
196         m_fragmentShader = nullptr;
197         return true;
198     default:
199         return false;
200     }
201 }
202 
<a name="16" id="anc16"></a><span class="line-modified">203 void WebGLProgram::cacheActiveAttribLocations(GraphicsContextGLOpenGL* context3d)</span>
204 {
205     m_activeAttribLocations.clear();
206 
<a name="17" id="anc17"></a><span class="line-modified">207     GCGLint numAttribs = 0;</span>
<span class="line-modified">208     context3d-&gt;getProgramiv(object(), GraphicsContextGL::ACTIVE_ATTRIBUTES, &amp;numAttribs);</span>
209     m_activeAttribLocations.resize(static_cast&lt;size_t&gt;(numAttribs));
210     for (int i = 0; i &lt; numAttribs; ++i) {
<a name="18" id="anc18"></a><span class="line-modified">211         GraphicsContextGL::ActiveInfo info;</span>
212         context3d-&gt;getActiveAttribImpl(object(), i, info);
213         m_activeAttribLocations[i] = context3d-&gt;getAttribLocation(object(), info.name);
214     }
215 }
216 
217 void WebGLProgram::cacheInfoIfNeeded()
218 {
219     if (m_infoValid)
220         return;
221 
222     if (!object())
223         return;
224 
<a name="19" id="anc19"></a><span class="line-modified">225     GraphicsContextGLOpenGL* context = getAGraphicsContextGL();</span>
226     if (!context)
227         return;
<a name="20" id="anc20"></a><span class="line-modified">228     GCGLint linkStatus = 0;</span>
<span class="line-modified">229     context-&gt;getProgramiv(object(), GraphicsContextGL::LINK_STATUS, &amp;linkStatus);</span>
230     m_linkStatus = linkStatus;
231     if (m_linkStatus)
232         cacheActiveAttribLocations(context);
233     m_infoValid = true;
234 }
235 
236 }
237 
238 #endif // ENABLE(WEBGL)
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
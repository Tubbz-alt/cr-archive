<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMediaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMeterElement.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;ActiveDOMObject.h&quot;
<span class="line-removed">  31 #include &quot;ApplicationStateChangeListener.h&quot;</span>
  32 #include &quot;AutoplayEvent.h&quot;
  33 #include &quot;DeferrableTask.h&quot;
  34 #include &quot;GenericEventQueue.h&quot;
  35 #include &quot;HTMLElement.h&quot;
  36 #include &quot;HTMLMediaElementEnums.h&quot;
  37 #include &quot;MediaCanStartListener.h&quot;
  38 #include &quot;MediaControllerInterface.h&quot;
  39 #include &quot;MediaElementSession.h&quot;
  40 #include &quot;MediaPlayer.h&quot;
  41 #include &quot;MediaProducer.h&quot;
  42 #include &quot;VisibilityChangeClient.h&quot;
  43 #include &lt;wtf/Function.h&gt;
  44 #include &lt;wtf/LoggerHelper.h&gt;
  45 #include &lt;wtf/WeakPtr.h&gt;
  46 
  47 #if ENABLE(VIDEO_TRACK)
  48 #include &quot;AudioTrack.h&quot;
  49 #include &quot;CaptionUserPreferences.h&quot;
<span class="line-removed">  50 #include &quot;PODIntervalTree.h&quot;</span>
  51 #include &quot;TextTrack.h&quot;
  52 #include &quot;TextTrackCue.h&quot;
  53 #include &quot;VTTCue.h&quot;
  54 #include &quot;VideoTrack.h&quot;
  55 #endif
  56 
  57 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
  58 #include &quot;AudioSession.h&quot;
  59 #endif
  60 
  61 #if ENABLE(ENCRYPTED_MEDIA)
  62 #include &quot;CDMClient.h&quot;
  63 #endif
  64 
  65 #ifndef NDEBUG
  66 #include &lt;wtf/StringPrintStream.h&gt;
  67 #endif
  68 
  69 namespace PAL {
  70 class SleepDisabler;
</pre>
<hr />
<pre>
  89 class MediaControlsHost;
  90 class MediaElementAudioSourceNode;
  91 class MediaError;
  92 class MediaKeys;
  93 class MediaResourceLoader;
  94 class MediaSession;
  95 class MediaSource;
  96 class MediaStream;
  97 class RenderMedia;
  98 class ScriptController;
  99 class ScriptExecutionContext;
 100 class SourceBuffer;
 101 class TextTrackList;
 102 class TimeRanges;
 103 class VideoPlaybackQuality;
 104 class VideoTrackList;
 105 class VideoTrackPrivate;
 106 class WebKitMediaKeys;
 107 
 108 template&lt;typename&gt; class DOMPromiseDeferred;





 109 
 110 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 111 using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;</span>
<span class="line-removed"> 112 using CueInterval = CueIntervalTree::IntervalType;</span>
 113 using CueList = Vector&lt;CueInterval&gt;;
 114 #endif
 115 
 116 using MediaProvider = Optional&lt;Variant&lt;
 117 #if ENABLE(MEDIA_STREAM)
 118     RefPtr&lt;MediaStream&gt;,
 119 #endif
 120 #if ENABLE(MEDIA_SOURCE)
 121     RefPtr&lt;MediaSource&gt;,
 122 #endif
 123     RefPtr&lt;Blob&gt;&gt;&gt;;
 124 
 125 class HTMLMediaElement
 126     : public HTMLElement
 127     , public ActiveDOMObject
 128     , public MediaControllerInterface
 129     , public PlatformMediaSessionClient
 130     , private MediaCanStartListener
 131     , private MediaPlayerClient
 132     , private MediaProducer
 133     , private VisibilityChangeClient
<span class="line-removed"> 134     , private ApplicationStateChangeListener</span>
 135 #if ENABLE(VIDEO_TRACK)
 136     , private AudioTrackClient
 137     , private TextTrackClient
 138     , private VideoTrackClient
 139 #endif
 140 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 141     , private AudioSession::MutedStateObserver
 142 #endif
 143 #if ENABLE(ENCRYPTED_MEDIA)
 144     , private CDMClient
 145 #endif
 146 #if !RELEASE_LOG_DISABLED
 147     , private LoggerHelper
 148 #endif

 149 {
 150     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 151 public:
 152     using WeakValueType = HTMLElement::WeakValueType;
 153     using HTMLElement::weakPtrFactory;
 154 
 155     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 156 
 157     virtual bool isVideo() const { return false; }
 158     bool hasVideo() const override { return false; }
 159     bool hasAudio() const override;
 160 
 161     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 162 
 163     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 164 
<span class="line-removed"> 165     static bool isRunningDestructor();</span>
<span class="line-removed"> 166 </span>
 167     WEBCORE_EXPORT void rewind(double timeDelta);
 168     WEBCORE_EXPORT void returnToRealtime() override;
 169 
 170     // Eventually overloaded in HTMLVideoElement
 171     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 172 
 173     bool supportsScanning() const override;
 174 
 175     bool canSaveMediaData() const;
 176 
 177     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const override;
 178 
 179     PlatformLayer* platformLayer() const;
 180     bool isVideoLayerInline();
 181     void setPreparedToReturnVideoLayerToInline(bool);
 182     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 184     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 185 #ifdef __OBJC__
 186     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 187 #endif
<span class="line-modified"> 188     void setVideoFullscreenFrame(FloatRect);</span>
<span class="line-modified"> 189     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);</span>
<span class="line-modified"> 190     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }</span>
 191 #endif
 192 
 193     void scheduleCheckPlaybackTargetCompatability();
 194     void checkPlaybackTargetCompatablity();
 195     void scheduleResolvePendingPlayPromises();
 196     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 197     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 198     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 199     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 200     void scheduleNotifyAboutPlaying();
 201     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 202 
<span class="line-modified"> 203     MediaPlayerEnums::MovieLoadType movieLoadType() const;</span>
 204 
 205     bool inActiveDocument() const { return m_inActiveDocument; }
 206 
 207     Document* hostingDocument() const final { return &amp;document(); }
 208 
 209 // DOM API
 210 // error state
 211     WEBCORE_EXPORT MediaError* error() const;
 212 
 213     const URL&amp; currentSrc() const { return m_currentSrc; }
 214 
 215     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 216     void setSrcObject(MediaProvider&amp;&amp;);
 217 
 218     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);
 219     WEBCORE_EXPORT String crossOrigin() const;
 220 
 221 // network state
 222     using HTMLMediaElementEnums::NetworkState;
 223     WEBCORE_EXPORT NetworkState networkState() const;
</pre>
<hr />
<pre>
 328     void beginScanning(ScanDirection) override;
 329     void endScanning() override;
 330     double nextScanRate();
 331 
 332     WEBCORE_EXPORT bool canPlay() const override;
 333 
 334     double percentLoaded() const;
 335 
 336     bool shouldForceControlsDisplay() const;
 337 
 338 #if ENABLE(VIDEO_TRACK)
 339     ExceptionOr&lt;TextTrack&amp;&gt; addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language);
 340 
 341     AudioTrackList&amp; ensureAudioTracks();
 342     TextTrackList&amp; ensureTextTracks();
 343     VideoTrackList&amp; ensureVideoTracks();
 344     AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
 345     TextTrackList* textTracks() const { return m_textTracks.get(); }
 346     VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
 347 
<span class="line-modified"> 348     CueList currentlyActiveCues() const { return m_currentlyActiveCues; }</span>
 349 
 350     void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 351     void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
 352     void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 353     void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 354     void removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;, bool scheduleEvent = true);
 355     void removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 356     void forgetResourceSpecificTracks();
 357     void closeCaptionTracksChanged();
 358     void notifyMediaPlayerOfTextTrackChanges();
 359 
 360     virtual void didAddTextTrack(HTMLTrackElement&amp;);
 361     virtual void didRemoveTextTrack(HTMLTrackElement&amp;);
 362 
 363     void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) final;
 364     void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) final;
 365     void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) final;
 366     void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) final;
 367     void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) final;
 368     void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) final;
</pre>
<hr />
<pre>
 386 
 387     // AudioTrackClient
 388     void audioTrackEnabledChanged(AudioTrack&amp;) final;
 389 
 390     void textTrackReadyStateChanged(TextTrack*);
 391 
 392     // TextTrackClient
 393     void textTrackKindChanged(TextTrack&amp;) override;
 394     void textTrackModeChanged(TextTrack&amp;) override;
 395     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 396     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 397     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 398     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 399 
 400     // VideoTrackClient
 401     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 402 
 403     bool requiresTextTrackRepresentation() const;
 404     void setTextTrackRepresentation(TextTrackRepresentation*);
 405     void syncTextTrackBounds();


 406 #endif
 407 
 408 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 409     void webkitShowPlaybackTargetPicker();
 410     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;
 411     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;
 412 
 413     void wirelessRoutesAvailableDidChange() override;
 414     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 415     void setShouldPlayToPlaybackTarget(bool) override;

 416 #endif
 417     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 418     void setIsPlayingToWirelessTarget(bool);
 419     bool webkitCurrentPlaybackTargetIsWireless() const;
 420 
 421     void setPlayingOnSecondScreen(bool value);
 422     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 423 
 424     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 425 
 426     // EventTarget function.
 427     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 428     // causes an ambiguity error at compile time. This class&#39;s constructor
 429     // ensures that both implementations return document, so return the result
 430     // of one of them here.
 431     using HTMLElement::scriptExecutionContext;
 432 
 433     bool hasSingleSecurityOrigin() const { return !m_player || m_player-&gt;hasSingleSecurityOrigin(); }
 434     bool didPassCORSAccessCheck() const { return m_player &amp;&amp; m_player-&gt;didPassCORSAccessCheck(); }
 435     bool wouldTaintOrigin(const SecurityOrigin&amp; origin) const { return m_player &amp;&amp; m_player-&gt;wouldTaintOrigin(origin); }
</pre>
<hr />
<pre>
 439     void toggleStandardFullscreenState();
 440 
 441     using MediaPlayerEnums::VideoFullscreenMode;
 442     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 443     virtual void fullscreenModeChanged(VideoFullscreenMode);
 444 
 445     void enterFullscreen(VideoFullscreenMode);
 446     void enterFullscreen() override;
 447     WEBCORE_EXPORT void exitFullscreen();
 448     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 449 
 450     bool hasClosedCaptions() const override;
 451     bool closedCaptionsVisible() const override;
 452     void setClosedCaptionsVisible(bool) override;
 453 
 454     MediaControls* mediaControls() const;
 455 
 456     void sourceWasRemoved(HTMLSourceElement&amp;);
 457     void sourceWasAdded(HTMLSourceElement&amp;);
 458 
<span class="line-removed"> 459     void privateBrowsingStateDidChange(PAL::SessionID) override;</span>
<span class="line-removed"> 460 </span>
 461     // Media cache management.
 462     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 463     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 464     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 465     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 466     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 467     static void resetMediaEngines();
 468 
 469     bool isPlaying() const { return m_playing; }
 470 
 471     bool hasPendingActivity() const override;
 472 
 473 #if ENABLE(WEB_AUDIO)
 474     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 475     void setAudioSourceNode(MediaElementAudioSourceNode*);
 476 
 477     AudioSourceProvider* audioSourceProvider();
 478 #endif
 479 
 480     using HTMLMediaElementEnums::InvalidURLAction;
 481     bool isSafeToLoadURL(const URL&amp;, InvalidURLAction);
 482 
 483     const String&amp; mediaGroup() const;
 484     void setMediaGroup(const String&amp;);
 485 
 486     MediaController* controller() const;
 487     void setController(RefPtr&lt;MediaController&gt;&amp;&amp;);
 488 
 489     MediaController* controllerForBindings() const { return controller(); }
 490     void setControllerForBindings(MediaController*);
 491 
 492     void enteredOrExitedFullscreen() { configureMediaControls(); }
 493 
 494     unsigned long long fileSize() const;
 495 
<span class="line-modified"> 496     void mediaLoadingFailed(MediaPlayerEnums::NetworkState);</span>
<span class="line-modified"> 497     void mediaLoadingFailedFatally(MediaPlayerEnums::NetworkState);</span>
 498 
 499 #if ENABLE(MEDIA_SESSION)
 500     WEBCORE_EXPORT double playerVolume() const;
 501 
 502     const String&amp; kind() const { return m_kind; }
 503     void setKind(const String&amp; kind) { m_kind = kind; }
 504 
 505     MediaSession* session() const;
 506     void setSession(MediaSession*);
 507 
 508     void setShouldDuck(bool);
 509 
 510     static HTMLMediaElement* elementWithID(uint64_t);
 511     uint64_t elementID() const { return m_elementID; }
 512 #endif
 513 
 514     RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
 515 
<span class="line-modified"> 516     MediaPlayerEnums::Preload preloadValue() const { return m_preload; }</span>
 517     MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
 518 
 519 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 520     void pageScaleFactorChanged();
 521     void userInterfaceLayoutDirectionChanged();
 522     WEBCORE_EXPORT String getCurrentMediaControlsStatus();
 523 
 524     MediaControlsHost* mediaControlsHost() { return m_mediaControlsHost.get(); }
 525 #endif
 526 
 527     bool isDisablingSleep() const { return m_sleepDisabler.get(); }
 528 
 529     double maxBufferedTime() const;
 530 
 531     MediaProducer::MediaStateFlags mediaState() const override;
 532 
 533     void layoutSizeChanged();
 534     void visibilityDidChange();
 535 
 536     void allowsMediaDocumentInlinePlaybackChanged();
</pre>
<hr />
<pre>
 539     RenderMedia* renderer() const;
 540 
 541     void resetPlaybackSessionState();
 542     bool isVisibleInViewport() const;
 543     bool hasEverNotifiedAboutPlaying() const;
 544     void setShouldDelayLoadEvent(bool);
 545 
 546     bool hasEverHadAudio() const { return m_hasEverHadAudio; }
 547     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 548 
 549     double playbackStartedTime() const { return m_playbackStartedTime; }
 550 
 551     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 552 
 553     void isVisibleInViewportChanged();
 554     void updateRateChangeRestrictions();
 555 
 556     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 557 
 558 #if ENABLE(MEDIA_STREAM)
<span class="line-modified"> 559     void mediaStreamCaptureStarted() { resumeAutoplaying(); }</span>
 560     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 561 #endif
 562 
 563     bool supportsSeeking() const override;
 564 
 565 #if !RELEASE_LOG_DISABLED
 566     const Logger&amp; logger() const final { return *m_logger.get(); }
 567     const void* logIdentifier() const final { return m_logIdentifier; }
 568     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }
 569     WTFLogChannel&amp; logChannel() const final;
 570 #endif
 571 
 572     bool willLog(WTFLogLevel) const;
 573 
 574     bool isSuspended() const final;
 575 
 576     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 577     WEBCORE_EXPORT void willExitFullscreen();
 578 




 579     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 580 










 581 protected:
 582     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 583     virtual void finishInitialization();
 584     virtual ~HTMLMediaElement();
 585 
 586     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
 587     void finishParsingChildren() override;
 588     bool isURLAttribute(const Attribute&amp;) const override;
 589     void willAttachRenderers() override;
 590     void didAttachRenderers() override;
 591     void willDetachRenderers() override;
 592     void didDetachRenderers() override;
 593 
 594     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 595 
 596     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 597     DisplayMode displayMode() const { return m_displayMode; }
 598     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 599 
 600     bool isMediaElement() const final { return true; }
 601 
<span class="line-removed"> 602 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-removed"> 603     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }</span>
<span class="line-removed"> 604     void beginIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-removed"> 605     void endIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-removed"> 606 #endif</span>
<span class="line-removed"> 607 </span>
 608     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 609 
 610 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 611     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 612     void setMediaControlsDependOnPageScaleFactor(bool);
 613     void updateMediaControlsAfterPresentationModeChange();
 614 #endif
 615 
<span class="line-modified"> 616     void scheduleEvent(const AtomString&amp; eventName);</span>
 617 
 618 private:
 619     void createMediaPlayer();
 620 
 621     bool supportsFocus() const override;
 622     bool isMouseFocusable() const override;
 623     bool rendererIsNeeded(const RenderStyle&amp;) override;
 624     bool childShouldCreateRenderer(const Node&amp;) const override;
 625     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 626     void didFinishInsertingNode() override;
 627     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 628     void didRecalcStyle(Style::Change) override;
 629     bool isInteractiveContent() const override;
 630 
 631     void willBecomeFullscreenElement() override;
 632     void willStopBeingFullscreenElement() override;
 633 
 634     // ActiveDOMObject API.
 635     const char* activeDOMObjectName() const override;
<span class="line-removed"> 636     bool canSuspendForDocumentSuspension() const override;</span>
 637     void suspend(ReasonForSuspension) override;
 638     void resume() override;
 639     void stop() override;
 640     void stopWithoutDestroyingMediaPlayer();
 641     void contextDestroyed() override;
 642 
<span class="line-modified"> 643     void mediaVolumeDidChange() override;</span>
<span class="line-removed"> 644 </span>
<span class="line-removed"> 645     void visibilityStateChanged() override;</span>
 646 
 647     virtual void updateDisplayState() { }
 648 
<span class="line-modified"> 649     void setReadyState(MediaPlayerEnums::ReadyState);</span>
<span class="line-modified"> 650     void setNetworkState(MediaPlayerEnums::NetworkState);</span>
 651 
 652     double effectivePlaybackRate() const;
 653     double requestedPlaybackRate() const;
 654 
<span class="line-modified"> 655     void mediaPlayerNetworkStateChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 656     void mediaPlayerReadyStateChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 657     void mediaPlayerTimeChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 658     void mediaPlayerVolumeChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 659     void mediaPlayerMuteChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 660     void mediaPlayerDurationChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 661     void mediaPlayerRateChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 662     void mediaPlayerPlaybackStateChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 663     void mediaPlayerSawUnsupportedTracks(MediaPlayer*) override;</span>
<span class="line-modified"> 664     void mediaPlayerResourceNotSupported(MediaPlayer*) override;</span>
<span class="line-modified"> 665     void mediaPlayerRepaint(MediaPlayer*) override;</span>
<span class="line-modified"> 666     void mediaPlayerSizeChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 667     bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) override;</span>
<span class="line-modified"> 668     void mediaPlayerRenderingModeChanged(MediaPlayer*) override;</span>
<span class="line-modified"> 669     bool mediaPlayerAcceleratedCompositingEnabled() override;</span>
<span class="line-removed"> 670     void mediaPlayerEngineUpdated(MediaPlayer*) override;</span>
 671 
 672     void scheduleMediaEngineWasUpdated();
 673     void mediaEngineWasUpdated();
 674 
<span class="line-modified"> 675     void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) override;</span>
<span class="line-modified"> 676     void mediaPlayerCharacteristicChanged(MediaPlayer*) override;</span>
 677 
 678 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
<span class="line-modified"> 679     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const override;</span>
<span class="line-modified"> 680     bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) override;</span>
<span class="line-modified"> 681     String mediaPlayerMediaKeysStorageDirectory() const override;</span>
 682 #endif
 683 
 684 #if ENABLE(ENCRYPTED_MEDIA)
 685     void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
 686     void mediaPlayerWaitingForKeyChanged() final;
 687 
 688     void attemptToDecrypt();
 689     void attemptToResumePlaybackIfNecessary();
 690 
 691     // CDMClient
 692     void cdmClientAttemptToResumePlaybackIfNecessary() final;
 693 #endif
 694 
 695 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified"> 696     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) override;</span>
 697     void enqueuePlaybackTargetAvailabilityChangedEvent();
 698 
 699     using EventTarget::dispatchEvent;
 700     void dispatchEvent(Event&amp;) override;
 701 #endif
 702 
 703 #if ENABLE(MEDIA_SESSION)
 704     void setSessionInternal(MediaSession&amp;);
 705 #endif
 706 
 707     String mediaPlayerReferrer() const override;
 708     String mediaPlayerUserAgent() const override;
 709 
 710     void mediaPlayerEnterFullscreen() override;
 711     void mediaPlayerExitFullscreen() override;
 712     bool mediaPlayerIsFullscreen() const override;
 713     bool mediaPlayerIsFullscreenPermitted() const override;
 714     bool mediaPlayerIsVideo() const override;
 715     LayoutRect mediaPlayerContentBoxRect() const override;
 716     float mediaPlayerContentsScale() const override;
<span class="line-removed"> 717     void mediaPlayerSetSize(const IntSize&amp;) override;</span>
 718     void mediaPlayerPause() override;
 719     void mediaPlayerPlay() override;
 720     bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
<span class="line-removed"> 721     bool mediaPlayerIsPaused() const override;</span>
 722     bool mediaPlayerIsLooping() const override;
 723     CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
 724     RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
 725     bool mediaPlayerShouldUsePersistentCache() const override;
 726     const String&amp; mediaPlayerMediaCacheDirectory() const override;
 727 
 728 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified"> 729     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const override;</span>
 730 #endif
 731 
<span class="line-modified"> 732     void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) override;</span>
 733 
<span class="line-removed"> 734     void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command) override { didReceiveRemoteControlCommand(command, nullptr); }</span>
 735     String sourceApplicationIdentifier() const override;
 736     String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
 737     Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
 738 
 739 #if PLATFORM(IOS_FAMILY)
 740     String mediaPlayerNetworkInterfaceName() const override;
 741     bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
 742 #endif
 743 
<span class="line-removed"> 744     bool mediaPlayerIsInMediaDocument() const final;</span>
 745     void mediaPlayerEngineFailedToLoad() const final;
 746 
 747     double mediaPlayerRequestedPlaybackRate() const final;
 748     VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
 749     bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
 750     bool mediaPlayerShouldDisableSleep() const final { return shouldDisableSleep() == SleepType::Display; }
 751     bool mediaPlayerShouldCheckHardwareSupport() const final;
 752     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final;
 753 
 754 #if USE(GSTREAMER)
 755     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp;) final;
 756 #endif
 757 
 758     void pendingActionTimerFired();
 759     void progressEventTimerFired();
 760     void playbackProgressTimerFired();
 761     void scanTimerFired();
 762     void seekTask();
 763     void startPlaybackProgressTimer();
 764     void startProgressEventTimer();
</pre>
<hr />
<pre>
 775 
 776     void scheduleTimeupdateEvent(bool periodicEvent);
 777     virtual void scheduleResizeEvent() { }
 778     virtual void scheduleResizeEventIfSizeChanged() { }
 779 
 780     void selectMediaResource();
 781     void loadResource(const URL&amp;, ContentType&amp;, const String&amp; keySystem);
 782     void scheduleNextSourceChild();
 783     void loadNextSourceChild();
 784     void userCancelledLoad();
 785     void clearMediaPlayer();
 786     bool havePotentialSourceChild();
 787     void noneSupported();
 788     void cancelPendingEventsAndCallbacks();
 789     void waitForSourceChange();
 790     void prepareToPlay();
 791 
 792     URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
 793 
 794 #if ENABLE(VIDEO_TRACK)




 795     void updateActiveTextTrackCues(const MediaTime&amp;);
 796     HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
 797 
<span class="line-modified"> 798     enum ReconfigureMode {</span>
<span class="line-removed"> 799         Immediately,</span>
<span class="line-removed"> 800         AfterDelay,</span>
<span class="line-removed"> 801     };</span>
 802     void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
<span class="line-removed"> 803     void captionPreferencesChanged() override;</span>
 804     CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
 805 #endif
 806 
 807     // These &quot;internal&quot; functions do not check user gesture restrictions.
 808     void playInternal();
 809     void pauseInternal();
 810 
 811     void prepareForLoad();
 812     void allowVideoRendering();
 813 
 814     bool processingMediaPlayerCallback() const { return m_processingMediaPlayerCallback &gt; 0; }
 815     void beginProcessingMediaPlayerCallback() { ++m_processingMediaPlayerCallback; }
 816     void endProcessingMediaPlayerCallback() { ASSERT(m_processingMediaPlayerCallback); --m_processingMediaPlayerCallback; }
 817 
 818     void scheduleUpdatePlayState();
 819     void updatePlayState();
 820 
 821     void updateVolume();
 822     void setPlaying(bool);
 823     bool potentiallyPlaying() const;
 824     bool endedPlayback() const;
 825     bool stoppedDueToErrors() const;
 826     bool pausedForUserInteraction() const;
 827     bool couldPlayIfEnoughData() const;
 828     void dispatchPlayPauseEventsIfNeedsQuirks();
 829     SuccessOr&lt;MediaPlaybackDenialReason&gt; canTransitionFromAutoplayToPlay() const;
 830 
 831     void setAutoplayEventPlaybackState(AutoplayEventPlaybackState);
 832     void userDidInterfereWithAutoplay();
 833     void handleAutoplayEvent(AutoplayEvent);
 834 
 835     MediaTime minTimeSeekable() const;
 836     MediaTime maxTimeSeekable() const;
 837 
 838     // Pauses playback without changing any states or generating events
 839     void setPausedInternal(bool);

 840 
 841     void setPlaybackRateInternal(double);
 842 
 843     void mediaCanStart(Document&amp;) final;
 844 
 845     void invalidateCachedTime() const;
 846     void refreshCachedTime() const;
 847 
 848     bool hasMediaControls() const;
 849     bool createMediaControls();
 850     void configureMediaControls();
 851 
 852     void prepareMediaFragmentURI();
 853     void applyMediaFragmentURI();
 854 
 855     void changeNetworkStateFromLoadingToIdle();
 856 
 857     void removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);
 858 
 859     void updateMediaController();
 860     bool isBlocked() const;
 861     bool isBlockedOnMediaController() const;
 862     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
<span class="line-modified"> 863     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }</span>
 864 
 865     void updateSleepDisabling();
<span class="line-modified"> 866     enum class SleepType {</span>
<span class="line-removed"> 867         None,</span>
<span class="line-removed"> 868         Display,</span>
<span class="line-removed"> 869         System,</span>
<span class="line-removed"> 870     };</span>
 871     SleepType shouldDisableSleep() const;
 872 
 873 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 874     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 875     DOMWrapperWorld&amp; ensureIsolatedWorld();
 876     bool ensureMediaControlsInjectedScript();
 877 #endif
 878 
 879     PlatformMediaSession::MediaType mediaType() const override;
 880     PlatformMediaSession::MediaType presentationType() const override;
 881     PlatformMediaSession::DisplayType displayType() const override;
 882     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 883 
 884     void suspendPlayback() override;
 885     void resumeAutoplaying() override;
 886     void mayResumePlayback(bool shouldResume) override;
 887     uint64_t mediaSessionUniqueIdentifier() const final;
 888     String mediaSessionTitle() const override;
 889     double mediaSessionDuration() const override { return duration(); }
 890     double mediaSessionCurrentTime() const override { return currentTime(); }
</pre>
<hr />
<pre>
 895     bool canProduceAudio() const final;
 896     bool processingUserGestureForMedia() const final;
 897     bool hasMediaStreamSource() const final;
 898     void processIsSuspendedChanged() final;
 899 
 900     void pageMutedStateDidChange() override;
 901 
 902 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 903     void hardwareMutedStateDidChange(AudioSession*) final;
 904 #endif
 905 
 906     bool effectiveMuted() const;
 907     double effectiveVolume() const;
 908 
 909     void registerWithDocument(Document&amp;);
 910     void unregisterWithDocument(Document&amp;);
 911 
 912     void updateCaptionContainer();
 913     void ensureMediaControlsShadowRoot();
 914 
<span class="line-modified"> 915     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;</span>
 916     bool setupAndCallJS(const JSSetupFunction&amp;);
 917 
 918 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 919     void prepareForDocumentSuspension() final;
 920     void resumeFromDocumentSuspension() final;
 921 
 922     void scheduleUpdateMediaState();
 923     void updateMediaState();
 924     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 925 #endif
 926 
 927     bool isVideoTooSmallForInlinePlayback();
 928     void updateShouldAutoplay();
 929 
 930     void pauseAfterDetachedTask();
 931     void updatePlaybackControlsManager();
 932     void schedulePlaybackControlsManagerUpdate();
 933     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 934 
 935     void updateRenderer();
 936 
 937     void updatePageScaleFactorJSProperty();
 938     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 939     void setControllerJSProperty(const char*, JSC::JSValue);
 940 
 941     void addBehaviorRestrictionsOnEndIfNecessary();
 942     void handleSeekToPlaybackPosition(double);
 943     void seekToPlaybackPositionEndedTimerFired();
 944 
<span class="line-removed"> 945     void applicationWillResignActive() final;</span>
<span class="line-removed"> 946     void applicationDidBecomeActive() final;</span>
<span class="line-removed"> 947 </span>
 948     void setInActiveDocument(bool);
 949 
 950 #if !RELEASE_LOG_DISABLED
 951     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 952     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 953 #endif
 954 



 955     Timer m_progressEventTimer;
 956     Timer m_playbackProgressTimer;
 957     Timer m_scanTimer;
 958     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 959     Timer m_seekToPlaybackPositionEndedTimer;
 960     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 961     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 962     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 963     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
<span class="line-modified"> 964     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;</span>
 965     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 966     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 967     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 968     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 969     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 970     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 971     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 972     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 973     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 974     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
<span class="line-modified"> 975     GenericEventQueue m_asyncEventQueue;</span>
 976 #if PLATFORM(IOS_FAMILY)
 977     DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;
 978 #endif
 979 
 980     PlayPromiseVector m_pendingPlayPromises;
 981 
 982     double m_requestedPlaybackRate { 1 };
 983     double m_reportedPlaybackRate { 1 };
 984     double m_defaultPlaybackRate { 1 };
 985     bool m_webkitPreservesPitch { true };
 986     NetworkState m_networkState { NETWORK_EMPTY };
 987     ReadyState m_readyState { HAVE_NOTHING };
 988     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 989     URL m_currentSrc;
 990 
 991     RefPtr&lt;MediaError&gt; m_error;
 992 
 993     struct PendingSeek {
 994         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 995         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
</pre>
<hr />
<pre>
1019 
1020     // The last time a timeupdate event was sent in movie time.
1021     MediaTime m_lastTimeUpdateEventMovieTime;
1022 
1023     // Loading state.
1024     enum LoadState { WaitingForSource, LoadingFromSrcAttr, LoadingFromSourceElement };
1025     LoadState m_loadState { WaitingForSource };
1026     RefPtr&lt;HTMLSourceElement&gt; m_currentSourceNode;
1027     RefPtr&lt;HTMLSourceElement&gt; m_nextChildNodeToConsider;
1028 
1029     VideoFullscreenMode m_videoFullscreenMode { VideoFullscreenModeNone };
1030     bool m_videoFullscreenStandby { false };
1031     bool m_preparedForInline;
1032     WTF::Function&lt;void()&gt; m_preparedForInlineCompletionHandler;
1033 
1034     bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
1035 
1036 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
1037     RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
1038     FloatRect m_videoFullscreenFrame;
<span class="line-modified">1039     MediaPlayerEnums::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravityResizeAspect };</span>
1040 #endif
1041 
1042     RefPtr&lt;MediaPlayer&gt; m_player;
1043 
<span class="line-modified">1044     MediaPlayerEnums::Preload m_preload { MediaPlayer::Auto };</span>
1045 
1046     DisplayMode m_displayMode { Unknown };
1047 
1048     // Counter incremented while processing a callback from the media player, so we can avoid
1049     // calling the media engine recursively.
1050     int m_processingMediaPlayerCallback { 0 };
1051 
1052 #if ENABLE(MEDIA_SESSION)
1053     String m_kind;
1054     RefPtr&lt;MediaSession&gt; m_session;
1055     bool m_shouldDuck { false };
1056     uint64_t m_elementID;
1057 #endif
1058 
1059 #if ENABLE(MEDIA_SOURCE)
1060     RefPtr&lt;MediaSource&gt; m_mediaSource;
1061     unsigned m_droppedVideoFrames { 0 };
1062 #endif
1063 
1064     mutable MediaTime m_cachedTime;
</pre>
<hr />
<pre>
1124     bool m_isScrubbingRemotely : 1;
1125     bool m_waitingToEnterFullscreen : 1;
1126 
1127 #if ENABLE(VIDEO_TRACK)
1128     bool m_tracksAreReady : 1;
1129     bool m_haveVisibleTextTrack : 1;
1130     bool m_processingPreferenceChange : 1;
1131 
1132     AutoplayEventPlaybackState m_autoplayEventPlaybackState { AutoplayEventPlaybackState::None };
1133 
1134     String m_subtitleTrackLanguage;
1135     MediaTime m_lastTextTrackUpdateTime { -1, 1 };
1136 
1137     Optional&lt;CaptionUserPreferences::CaptionDisplayMode&gt; m_captionDisplayMode;
1138 
1139     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
1140     RefPtr&lt;TextTrackList&gt; m_textTracks;
1141     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
1142     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
1143 
<span class="line-modified">1144     CueIntervalTree m_cueTree;</span>

1145 
<span class="line-removed">1146     CueList m_currentlyActiveCues;</span>
1147     int m_ignoreTrackDisplayUpdate { 0 };
1148 
1149     bool m_requireCaptionPreferencesChangedCallbacks { false };
1150 #endif
1151 
1152 #if ENABLE(WEB_AUDIO)
1153     // This is a weak reference, since m_audioSourceNode holds a reference to us.
1154     // The value is set just after the MediaElementAudioSourceNode is created.
1155     // The value is cleared in MediaElementAudioSourceNode::~MediaElementAudioSourceNode().
1156     MediaElementAudioSourceNode* m_audioSourceNode { nullptr };
1157 #endif
1158 
1159     String m_mediaGroup;
1160     friend class MediaController;
1161     RefPtr&lt;MediaController&gt; m_mediaController;
1162 
1163     std::unique_ptr&lt;PAL::SleepDisabler&gt; m_sleepDisabler;
1164 
1165     WeakPtr&lt;const MediaResourceLoader&gt; m_lastMediaResourceLoaderForTesting;
1166 
1167     friend class TrackDisplayUpdateScope;
1168 
1169     RefPtr&lt;Blob&gt; m_blob;
1170     MediaProvider m_mediaProvider;
1171 
1172 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1173     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1174 #endif

1175 #if ENABLE(ENCRYPTED_MEDIA)
1176     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1177     bool m_attachingMediaKeys { false };
1178     bool m_playbackBlockedWaitingForKey { false };
1179     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1180 #endif
1181 




1182     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1183     size_t m_reportedExtraMemoryCost { 0 };
1184 
1185 #if !RELEASE_LOG_DISABLED
1186     RefPtr&lt;Logger&gt; m_logger;
1187     const void* m_logIdentifier;
1188 #endif
1189 
1190 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1191     friend class MediaControlsHost;
1192     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1193     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1194 #endif
1195 
1196 #if ENABLE(MEDIA_STREAM)
1197     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1198     bool m_settingMediaStreamSrcObject { false };
1199 #endif
1200 
1201 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1202     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1203     bool m_hasPlaybackTargetAvailabilityListeners { false };
1204     bool m_failedToPlayToWirelessTarget { false };
1205 #endif
1206 
1207     bool m_isPlayingToWirelessTarget { false };
1208     bool m_playingOnSecondScreen { false };
1209     bool m_removedBehaviorRestrictionsAfterFirstUserGesture { false };
1210 };
1211 
1212 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1213 
1214 } // namespace WebCore
1215 
1216 namespace WTF {
1217 
1218 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1219     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1220 };
1221 
<span class="line-removed">1222 #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)</span>
<span class="line-removed">1223 </span>
<span class="line-removed">1224 // Template specialization required by PodIntervalTree in debug mode.</span>
<span class="line-removed">1225 template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {</span>
<span class="line-removed">1226     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }</span>
<span class="line-removed">1227 };</span>
<span class="line-removed">1228 </span>
<span class="line-removed">1229 #endif</span>
<span class="line-removed">1230 </span>
<span class="line-removed">1231 #ifndef NDEBUG</span>
<span class="line-removed">1232 </span>
<span class="line-removed">1233 template&lt;&gt; struct ValueToString&lt;MediaTime&gt; {</span>
<span class="line-removed">1234     static String string(const MediaTime&amp; time) { return toString(time); }</span>
<span class="line-removed">1235 };</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237 #endif</span>
<span class="line-removed">1238 </span>
1239 } // namespace WTF
1240 
1241 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
1242     static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
1243     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
1244 SPECIALIZE_TYPE_TRAITS_END()
1245 
1246 #endif
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(VIDEO)
  29 
  30 #include &quot;ActiveDOMObject.h&quot;

  31 #include &quot;AutoplayEvent.h&quot;
  32 #include &quot;DeferrableTask.h&quot;
  33 #include &quot;GenericEventQueue.h&quot;
  34 #include &quot;HTMLElement.h&quot;
  35 #include &quot;HTMLMediaElementEnums.h&quot;
  36 #include &quot;MediaCanStartListener.h&quot;
  37 #include &quot;MediaControllerInterface.h&quot;
  38 #include &quot;MediaElementSession.h&quot;
  39 #include &quot;MediaPlayer.h&quot;
  40 #include &quot;MediaProducer.h&quot;
  41 #include &quot;VisibilityChangeClient.h&quot;
  42 #include &lt;wtf/Function.h&gt;
  43 #include &lt;wtf/LoggerHelper.h&gt;
  44 #include &lt;wtf/WeakPtr.h&gt;
  45 
  46 #if ENABLE(VIDEO_TRACK)
  47 #include &quot;AudioTrack.h&quot;
  48 #include &quot;CaptionUserPreferences.h&quot;

  49 #include &quot;TextTrack.h&quot;
  50 #include &quot;TextTrackCue.h&quot;
  51 #include &quot;VTTCue.h&quot;
  52 #include &quot;VideoTrack.h&quot;
  53 #endif
  54 
  55 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
  56 #include &quot;AudioSession.h&quot;
  57 #endif
  58 
  59 #if ENABLE(ENCRYPTED_MEDIA)
  60 #include &quot;CDMClient.h&quot;
  61 #endif
  62 
  63 #ifndef NDEBUG
  64 #include &lt;wtf/StringPrintStream.h&gt;
  65 #endif
  66 
  67 namespace PAL {
  68 class SleepDisabler;
</pre>
<hr />
<pre>
  87 class MediaControlsHost;
  88 class MediaElementAudioSourceNode;
  89 class MediaError;
  90 class MediaKeys;
  91 class MediaResourceLoader;
  92 class MediaSession;
  93 class MediaSource;
  94 class MediaStream;
  95 class RenderMedia;
  96 class ScriptController;
  97 class ScriptExecutionContext;
  98 class SourceBuffer;
  99 class TextTrackList;
 100 class TimeRanges;
 101 class VideoPlaybackQuality;
 102 class VideoTrackList;
 103 class VideoTrackPrivate;
 104 class WebKitMediaKeys;
 105 
 106 template&lt;typename&gt; class DOMPromiseDeferred;
<span class="line-added"> 107 template&lt;typename, typename&gt; class PODInterval;</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 110 class RemotePlayback;</span>
<span class="line-added"> 111 #endif</span>
 112 
 113 #if ENABLE(VIDEO_TRACK)
<span class="line-modified"> 114 using CueInterval = PODInterval&lt;MediaTime, TextTrackCue*&gt;;</span>

 115 using CueList = Vector&lt;CueInterval&gt;;
 116 #endif
 117 
 118 using MediaProvider = Optional&lt;Variant&lt;
 119 #if ENABLE(MEDIA_STREAM)
 120     RefPtr&lt;MediaStream&gt;,
 121 #endif
 122 #if ENABLE(MEDIA_SOURCE)
 123     RefPtr&lt;MediaSource&gt;,
 124 #endif
 125     RefPtr&lt;Blob&gt;&gt;&gt;;
 126 
 127 class HTMLMediaElement
 128     : public HTMLElement
 129     , public ActiveDOMObject
 130     , public MediaControllerInterface
 131     , public PlatformMediaSessionClient
 132     , private MediaCanStartListener
 133     , private MediaPlayerClient
 134     , private MediaProducer
 135     , private VisibilityChangeClient

 136 #if ENABLE(VIDEO_TRACK)
 137     , private AudioTrackClient
 138     , private TextTrackClient
 139     , private VideoTrackClient
 140 #endif
 141 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 142     , private AudioSession::MutedStateObserver
 143 #endif
 144 #if ENABLE(ENCRYPTED_MEDIA)
 145     , private CDMClient
 146 #endif
 147 #if !RELEASE_LOG_DISABLED
 148     , private LoggerHelper
 149 #endif
<span class="line-added"> 150     , public CanMakeWeakPtr&lt;HTMLMediaElement, WeakPtrFactoryInitialization::Eager&gt;</span>
 151 {
 152     WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
 153 public:
 154     using WeakValueType = HTMLElement::WeakValueType;
 155     using HTMLElement::weakPtrFactory;
 156 
 157     RefPtr&lt;MediaPlayer&gt; player() const { return m_player; }
 158 
 159     virtual bool isVideo() const { return false; }
 160     bool hasVideo() const override { return false; }
 161     bool hasAudio() const override;
 162 
 163     static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
 164 
 165     WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
 166 


 167     WEBCORE_EXPORT void rewind(double timeDelta);
 168     WEBCORE_EXPORT void returnToRealtime() override;
 169 
 170     // Eventually overloaded in HTMLVideoElement
 171     bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
 172 
 173     bool supportsScanning() const override;
 174 
 175     bool canSaveMediaData() const;
 176 
 177     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const override;
 178 
 179     PlatformLayer* platformLayer() const;
 180     bool isVideoLayerInline();
 181     void setPreparedToReturnVideoLayerToInline(bool);
 182     void waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 183 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 184     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
 185 #ifdef __OBJC__
 186     PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
 187 #endif
<span class="line-modified"> 188     virtual void setVideoFullscreenFrame(FloatRect);</span>
<span class="line-modified"> 189     void setVideoFullscreenGravity(MediaPlayer::VideoGravity);</span>
<span class="line-modified"> 190     MediaPlayer::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }</span>
 191 #endif
 192 
 193     void scheduleCheckPlaybackTargetCompatability();
 194     void checkPlaybackTargetCompatablity();
 195     void scheduleResolvePendingPlayPromises();
 196     void scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp;);
 197     using PlayPromiseVector = Vector&lt;DOMPromiseDeferred&lt;void&gt;&gt;;
 198     void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
 199     void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
 200     void scheduleNotifyAboutPlaying();
 201     void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
 202 
<span class="line-modified"> 203     MediaPlayer::MovieLoadType movieLoadType() const;</span>
 204 
 205     bool inActiveDocument() const { return m_inActiveDocument; }
 206 
 207     Document* hostingDocument() const final { return &amp;document(); }
 208 
 209 // DOM API
 210 // error state
 211     WEBCORE_EXPORT MediaError* error() const;
 212 
 213     const URL&amp; currentSrc() const { return m_currentSrc; }
 214 
 215     const MediaProvider&amp; srcObject() const { return m_mediaProvider; }
 216     void setSrcObject(MediaProvider&amp;&amp;);
 217 
 218     WEBCORE_EXPORT void setCrossOrigin(const AtomString&amp;);
 219     WEBCORE_EXPORT String crossOrigin() const;
 220 
 221 // network state
 222     using HTMLMediaElementEnums::NetworkState;
 223     WEBCORE_EXPORT NetworkState networkState() const;
</pre>
<hr />
<pre>
 328     void beginScanning(ScanDirection) override;
 329     void endScanning() override;
 330     double nextScanRate();
 331 
 332     WEBCORE_EXPORT bool canPlay() const override;
 333 
 334     double percentLoaded() const;
 335 
 336     bool shouldForceControlsDisplay() const;
 337 
 338 #if ENABLE(VIDEO_TRACK)
 339     ExceptionOr&lt;TextTrack&amp;&gt; addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language);
 340 
 341     AudioTrackList&amp; ensureAudioTracks();
 342     TextTrackList&amp; ensureTextTracks();
 343     VideoTrackList&amp; ensureVideoTracks();
 344     AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
 345     TextTrackList* textTracks() const { return m_textTracks.get(); }
 346     VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
 347 
<span class="line-modified"> 348     CueList currentlyActiveCues() const;</span>
 349 
 350     void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 351     void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
 352     void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 353     void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
 354     void removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;, bool scheduleEvent = true);
 355     void removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
 356     void forgetResourceSpecificTracks();
 357     void closeCaptionTracksChanged();
 358     void notifyMediaPlayerOfTextTrackChanges();
 359 
 360     virtual void didAddTextTrack(HTMLTrackElement&amp;);
 361     virtual void didRemoveTextTrack(HTMLTrackElement&amp;);
 362 
 363     void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) final;
 364     void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) final;
 365     void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) final;
 366     void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) final;
 367     void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) final;
 368     void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) final;
</pre>
<hr />
<pre>
 386 
 387     // AudioTrackClient
 388     void audioTrackEnabledChanged(AudioTrack&amp;) final;
 389 
 390     void textTrackReadyStateChanged(TextTrack*);
 391 
 392     // TextTrackClient
 393     void textTrackKindChanged(TextTrack&amp;) override;
 394     void textTrackModeChanged(TextTrack&amp;) override;
 395     void textTrackAddCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 396     void textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp;) override;
 397     void textTrackAddCue(TextTrack&amp;, TextTrackCue&amp;) override;
 398     void textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp;) override;
 399 
 400     // VideoTrackClient
 401     void videoTrackSelectedChanged(VideoTrack&amp;) final;
 402 
 403     bool requiresTextTrackRepresentation() const;
 404     void setTextTrackRepresentation(TextTrackRepresentation*);
 405     void syncTextTrackBounds();
<span class="line-added"> 406 </span>
<span class="line-added"> 407     void captionPreferencesChanged();</span>
 408 #endif
 409 
 410 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 411     void webkitShowPlaybackTargetPicker();
 412     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;
 413     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;
 414 
 415     void wirelessRoutesAvailableDidChange() override;
 416     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
 417     void setShouldPlayToPlaybackTarget(bool) override;
<span class="line-added"> 418     void playbackTargetPickerWasDismissed() override;</span>
 419 #endif
 420     bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
 421     void setIsPlayingToWirelessTarget(bool);
 422     bool webkitCurrentPlaybackTargetIsWireless() const;
 423 
 424     void setPlayingOnSecondScreen(bool value);
 425     bool isPlayingOnSecondScreen() const override { return m_playingOnSecondScreen; }
 426 
 427     bool isPlayingToExternalTarget() const { return isPlayingToWirelessPlaybackTarget() || isPlayingOnSecondScreen(); }
 428 
 429     // EventTarget function.
 430     // Both Node (via HTMLElement) and ActiveDOMObject define this method, which
 431     // causes an ambiguity error at compile time. This class&#39;s constructor
 432     // ensures that both implementations return document, so return the result
 433     // of one of them here.
 434     using HTMLElement::scriptExecutionContext;
 435 
 436     bool hasSingleSecurityOrigin() const { return !m_player || m_player-&gt;hasSingleSecurityOrigin(); }
 437     bool didPassCORSAccessCheck() const { return m_player &amp;&amp; m_player-&gt;didPassCORSAccessCheck(); }
 438     bool wouldTaintOrigin(const SecurityOrigin&amp; origin) const { return m_player &amp;&amp; m_player-&gt;wouldTaintOrigin(origin); }
</pre>
<hr />
<pre>
 442     void toggleStandardFullscreenState();
 443 
 444     using MediaPlayerEnums::VideoFullscreenMode;
 445     VideoFullscreenMode fullscreenMode() const { return m_videoFullscreenMode; }
 446     virtual void fullscreenModeChanged(VideoFullscreenMode);
 447 
 448     void enterFullscreen(VideoFullscreenMode);
 449     void enterFullscreen() override;
 450     WEBCORE_EXPORT void exitFullscreen();
 451     WEBCORE_EXPORT void setVideoFullscreenStandby(bool);
 452 
 453     bool hasClosedCaptions() const override;
 454     bool closedCaptionsVisible() const override;
 455     void setClosedCaptionsVisible(bool) override;
 456 
 457     MediaControls* mediaControls() const;
 458 
 459     void sourceWasRemoved(HTMLSourceElement&amp;);
 460     void sourceWasAdded(HTMLSourceElement&amp;);
 461 


 462     // Media cache management.
 463     WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
 464     WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
 465     WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
 466     WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
 467     WEBCORE_EXPORT static void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
 468     static void resetMediaEngines();
 469 
 470     bool isPlaying() const { return m_playing; }
 471 
 472     bool hasPendingActivity() const override;
 473 
 474 #if ENABLE(WEB_AUDIO)
 475     MediaElementAudioSourceNode* audioSourceNode() { return m_audioSourceNode; }
 476     void setAudioSourceNode(MediaElementAudioSourceNode*);
 477 
 478     AudioSourceProvider* audioSourceProvider();
 479 #endif
 480 
 481     using HTMLMediaElementEnums::InvalidURLAction;
 482     bool isSafeToLoadURL(const URL&amp;, InvalidURLAction);
 483 
 484     const String&amp; mediaGroup() const;
 485     void setMediaGroup(const String&amp;);
 486 
 487     MediaController* controller() const;
 488     void setController(RefPtr&lt;MediaController&gt;&amp;&amp;);
 489 
 490     MediaController* controllerForBindings() const { return controller(); }
 491     void setControllerForBindings(MediaController*);
 492 
 493     void enteredOrExitedFullscreen() { configureMediaControls(); }
 494 
 495     unsigned long long fileSize() const;
 496 
<span class="line-modified"> 497     void mediaLoadingFailed(MediaPlayer::NetworkState);</span>
<span class="line-modified"> 498     void mediaLoadingFailedFatally(MediaPlayer::NetworkState);</span>
 499 
 500 #if ENABLE(MEDIA_SESSION)
 501     WEBCORE_EXPORT double playerVolume() const;
 502 
 503     const String&amp; kind() const { return m_kind; }
 504     void setKind(const String&amp; kind) { m_kind = kind; }
 505 
 506     MediaSession* session() const;
 507     void setSession(MediaSession*);
 508 
 509     void setShouldDuck(bool);
 510 
 511     static HTMLMediaElement* elementWithID(uint64_t);
 512     uint64_t elementID() const { return m_elementID; }
 513 #endif
 514 
 515     RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
 516 
<span class="line-modified"> 517     MediaPlayer::Preload preloadValue() const { return m_preload; }</span>
 518     MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
 519 
 520 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 521     void pageScaleFactorChanged();
 522     void userInterfaceLayoutDirectionChanged();
 523     WEBCORE_EXPORT String getCurrentMediaControlsStatus();
 524 
 525     MediaControlsHost* mediaControlsHost() { return m_mediaControlsHost.get(); }
 526 #endif
 527 
 528     bool isDisablingSleep() const { return m_sleepDisabler.get(); }
 529 
 530     double maxBufferedTime() const;
 531 
 532     MediaProducer::MediaStateFlags mediaState() const override;
 533 
 534     void layoutSizeChanged();
 535     void visibilityDidChange();
 536 
 537     void allowsMediaDocumentInlinePlaybackChanged();
</pre>
<hr />
<pre>
 540     RenderMedia* renderer() const;
 541 
 542     void resetPlaybackSessionState();
 543     bool isVisibleInViewport() const;
 544     bool hasEverNotifiedAboutPlaying() const;
 545     void setShouldDelayLoadEvent(bool);
 546 
 547     bool hasEverHadAudio() const { return m_hasEverHadAudio; }
 548     bool hasEverHadVideo() const { return m_hasEverHadVideo; }
 549 
 550     double playbackStartedTime() const { return m_playbackStartedTime; }
 551 
 552     bool isTemporarilyAllowingInlinePlaybackAfterFullscreen() const {return m_temporarilyAllowingInlinePlaybackAfterFullscreen; }
 553 
 554     void isVisibleInViewportChanged();
 555     void updateRateChangeRestrictions();
 556 
 557     WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
 558 
 559 #if ENABLE(MEDIA_STREAM)
<span class="line-modified"> 560     void mediaStreamCaptureStarted();</span>
 561     bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
 562 #endif
 563 
 564     bool supportsSeeking() const override;
 565 
 566 #if !RELEASE_LOG_DISABLED
 567     const Logger&amp; logger() const final { return *m_logger.get(); }
 568     const void* logIdentifier() const final { return m_logIdentifier; }
 569     const char* logClassName() const final { return &quot;HTMLMediaElement&quot;; }
 570     WTFLogChannel&amp; logChannel() const final;
 571 #endif
 572 
 573     bool willLog(WTFLogLevel) const;
 574 
 575     bool isSuspended() const final;
 576 
 577     WEBCORE_EXPORT void didBecomeFullscreenElement() override;
 578     WEBCORE_EXPORT void willExitFullscreen();
 579 
<span class="line-added"> 580 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 581     void scheduleEvent(Ref&lt;Event&gt;&amp;&amp;);</span>
<span class="line-added"> 582 #endif</span>
<span class="line-added"> 583 </span>
 584     enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
 585 
<span class="line-added"> 586 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 587     RemotePlayback&amp; remote() { return m_remote; }</span>
<span class="line-added"> 588     void remoteHasAvailabilityCallbacksChanged();</span>
<span class="line-added"> 589 #endif</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591     void privateBrowsingStateDidChange(PAL::SessionID);</span>
<span class="line-added"> 592     void mediaVolumeDidChange();</span>
<span class="line-added"> 593     void applicationWillResignActive();</span>
<span class="line-added"> 594     void applicationDidBecomeActive();</span>
<span class="line-added"> 595 </span>
 596 protected:
 597     HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
 598     virtual void finishInitialization();
 599     virtual ~HTMLMediaElement();
 600 
 601     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
 602     void finishParsingChildren() override;
 603     bool isURLAttribute(const Attribute&amp;) const override;
 604     void willAttachRenderers() override;
 605     void didAttachRenderers() override;
 606     void willDetachRenderers() override;
 607     void didDetachRenderers() override;
 608 
 609     void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument) override;
 610 
 611     enum DisplayMode { Unknown, None, Poster, PosterWaitingForVideo, Video };
 612     DisplayMode displayMode() const { return m_displayMode; }
 613     virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
 614 
 615     bool isMediaElement() const final { return true; }
 616 






 617     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
 618 
 619 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 620     bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
 621     void setMediaControlsDependOnPageScaleFactor(bool);
 622     void updateMediaControlsAfterPresentationModeChange();
 623 #endif
 624 
<span class="line-modified"> 625     void scheduleEvent(const AtomString&amp;);</span>
 626 
 627 private:
 628     void createMediaPlayer();
 629 
 630     bool supportsFocus() const override;
 631     bool isMouseFocusable() const override;
 632     bool rendererIsNeeded(const RenderStyle&amp;) override;
 633     bool childShouldCreateRenderer(const Node&amp;) const override;
 634     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
 635     void didFinishInsertingNode() override;
 636     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
 637     void didRecalcStyle(Style::Change) override;
 638     bool isInteractiveContent() const override;
 639 
 640     void willBecomeFullscreenElement() override;
 641     void willStopBeingFullscreenElement() override;
 642 
 643     // ActiveDOMObject API.
 644     const char* activeDOMObjectName() const override;

 645     void suspend(ReasonForSuspension) override;
 646     void resume() override;
 647     void stop() override;
 648     void stopWithoutDestroyingMediaPlayer();
 649     void contextDestroyed() override;
 650 
<span class="line-modified"> 651     void visibilityStateChanged() final;</span>


 652 
 653     virtual void updateDisplayState() { }
 654 
<span class="line-modified"> 655     void setReadyState(MediaPlayer::ReadyState);</span>
<span class="line-modified"> 656     void setNetworkState(MediaPlayer::NetworkState);</span>
 657 
 658     double effectivePlaybackRate() const;
 659     double requestedPlaybackRate() const;
 660 
<span class="line-modified"> 661     void mediaPlayerNetworkStateChanged() final;</span>
<span class="line-modified"> 662     void mediaPlayerReadyStateChanged() final;</span>
<span class="line-modified"> 663     void mediaPlayerTimeChanged() final;</span>
<span class="line-modified"> 664     void mediaPlayerVolumeChanged() final;</span>
<span class="line-modified"> 665     void mediaPlayerMuteChanged() final;</span>
<span class="line-modified"> 666     void mediaPlayerDurationChanged() final;</span>
<span class="line-modified"> 667     void mediaPlayerRateChanged() final;</span>
<span class="line-modified"> 668     void mediaPlayerPlaybackStateChanged() final;</span>
<span class="line-modified"> 669     void mediaPlayerResourceNotSupported() final;</span>
<span class="line-modified"> 670     void mediaPlayerRepaint() final;</span>
<span class="line-modified"> 671     void mediaPlayerSizeChanged() final;</span>
<span class="line-modified"> 672     bool mediaPlayerRenderingCanBeAccelerated() final;</span>
<span class="line-modified"> 673     void mediaPlayerRenderingModeChanged() final;</span>
<span class="line-modified"> 674     bool mediaPlayerAcceleratedCompositingEnabled() final;</span>
<span class="line-modified"> 675     void mediaPlayerEngineUpdated() final;</span>

 676 
 677     void scheduleMediaEngineWasUpdated();
 678     void mediaEngineWasUpdated();
 679 
<span class="line-modified"> 680     void mediaPlayerFirstVideoFrameAvailable() final;</span>
<span class="line-modified"> 681     void mediaPlayerCharacteristicChanged() final;</span>
 682 
 683 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
<span class="line-modified"> 684     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const final;</span>
<span class="line-modified"> 685     bool mediaPlayerKeyNeeded(Uint8Array*) final;</span>
<span class="line-modified"> 686     String mediaPlayerMediaKeysStorageDirectory() const final;</span>
 687 #endif
 688 
 689 #if ENABLE(ENCRYPTED_MEDIA)
 690     void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
 691     void mediaPlayerWaitingForKeyChanged() final;
 692 
 693     void attemptToDecrypt();
 694     void attemptToResumePlaybackIfNecessary();
 695 
 696     // CDMClient
 697     void cdmClientAttemptToResumePlaybackIfNecessary() final;
 698 #endif
 699 
 700 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified"> 701     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) final;</span>
 702     void enqueuePlaybackTargetAvailabilityChangedEvent();
 703 
 704     using EventTarget::dispatchEvent;
 705     void dispatchEvent(Event&amp;) override;
 706 #endif
 707 
 708 #if ENABLE(MEDIA_SESSION)
 709     void setSessionInternal(MediaSession&amp;);
 710 #endif
 711 
 712     String mediaPlayerReferrer() const override;
 713     String mediaPlayerUserAgent() const override;
 714 
 715     void mediaPlayerEnterFullscreen() override;
 716     void mediaPlayerExitFullscreen() override;
 717     bool mediaPlayerIsFullscreen() const override;
 718     bool mediaPlayerIsFullscreenPermitted() const override;
 719     bool mediaPlayerIsVideo() const override;
 720     LayoutRect mediaPlayerContentBoxRect() const override;
 721     float mediaPlayerContentsScale() const override;

 722     void mediaPlayerPause() override;
 723     void mediaPlayerPlay() override;
 724     bool mediaPlayerPlatformVolumeConfigurationRequired() const override;

 725     bool mediaPlayerIsLooping() const override;
 726     CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
 727     RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
 728     bool mediaPlayerShouldUsePersistentCache() const override;
 729     const String&amp; mediaPlayerMediaCacheDirectory() const override;
 730 
 731 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified"> 732     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const override;</span>
 733 #endif
 734 
<span class="line-modified"> 735     void mediaPlayerActiveSourceBuffersChanged() override;</span>
 736 

 737     String sourceApplicationIdentifier() const override;
 738     String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
 739     Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
 740 
 741 #if PLATFORM(IOS_FAMILY)
 742     String mediaPlayerNetworkInterfaceName() const override;
 743     bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
 744 #endif
 745 

 746     void mediaPlayerEngineFailedToLoad() const final;
 747 
 748     double mediaPlayerRequestedPlaybackRate() const final;
 749     VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
 750     bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
 751     bool mediaPlayerShouldDisableSleep() const final { return shouldDisableSleep() == SleepType::Display; }
 752     bool mediaPlayerShouldCheckHardwareSupport() const final;
 753     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const final;
 754 
 755 #if USE(GSTREAMER)
 756     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp;) final;
 757 #endif
 758 
 759     void pendingActionTimerFired();
 760     void progressEventTimerFired();
 761     void playbackProgressTimerFired();
 762     void scanTimerFired();
 763     void seekTask();
 764     void startPlaybackProgressTimer();
 765     void startProgressEventTimer();
</pre>
<hr />
<pre>
 776 
 777     void scheduleTimeupdateEvent(bool periodicEvent);
 778     virtual void scheduleResizeEvent() { }
 779     virtual void scheduleResizeEventIfSizeChanged() { }
 780 
 781     void selectMediaResource();
 782     void loadResource(const URL&amp;, ContentType&amp;, const String&amp; keySystem);
 783     void scheduleNextSourceChild();
 784     void loadNextSourceChild();
 785     void userCancelledLoad();
 786     void clearMediaPlayer();
 787     bool havePotentialSourceChild();
 788     void noneSupported();
 789     void cancelPendingEventsAndCallbacks();
 790     void waitForSourceChange();
 791     void prepareToPlay();
 792 
 793     URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
 794 
 795 #if ENABLE(VIDEO_TRACK)
<span class="line-added"> 796     bool ignoreTrackDisplayUpdateRequests() const;</span>
<span class="line-added"> 797     void beginIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added"> 798     void endIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added"> 799 </span>
 800     void updateActiveTextTrackCues(const MediaTime&amp;);
 801     HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
 802 
<span class="line-modified"> 803     enum ReconfigureMode { Immediately, AfterDelay };</span>



 804     void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);

 805     CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
 806 #endif
 807 
 808     // These &quot;internal&quot; functions do not check user gesture restrictions.
 809     void playInternal();
 810     void pauseInternal();
 811 
 812     void prepareForLoad();
 813     void allowVideoRendering();
 814 
 815     bool processingMediaPlayerCallback() const { return m_processingMediaPlayerCallback &gt; 0; }
 816     void beginProcessingMediaPlayerCallback() { ++m_processingMediaPlayerCallback; }
 817     void endProcessingMediaPlayerCallback() { ASSERT(m_processingMediaPlayerCallback); --m_processingMediaPlayerCallback; }
 818 
 819     void scheduleUpdatePlayState();
 820     void updatePlayState();
 821 
 822     void updateVolume();
 823     void setPlaying(bool);
 824     bool potentiallyPlaying() const;
 825     bool endedPlayback() const;
 826     bool stoppedDueToErrors() const;
 827     bool pausedForUserInteraction() const;
 828     bool couldPlayIfEnoughData() const;
 829     void dispatchPlayPauseEventsIfNeedsQuirks();
 830     SuccessOr&lt;MediaPlaybackDenialReason&gt; canTransitionFromAutoplayToPlay() const;
 831 
 832     void setAutoplayEventPlaybackState(AutoplayEventPlaybackState);
 833     void userDidInterfereWithAutoplay();
 834     void handleAutoplayEvent(AutoplayEvent);
 835 
 836     MediaTime minTimeSeekable() const;
 837     MediaTime maxTimeSeekable() const;
 838 
 839     // Pauses playback without changing any states or generating events
 840     void setPausedInternal(bool);
<span class="line-added"> 841     void pauseAndUpdatePlayStateImmediately();</span>
 842 
 843     void setPlaybackRateInternal(double);
 844 
 845     void mediaCanStart(Document&amp;) final;
 846 
 847     void invalidateCachedTime() const;
 848     void refreshCachedTime() const;
 849 
 850     bool hasMediaControls() const;
 851     bool createMediaControls();
 852     void configureMediaControls();
 853 
 854     void prepareMediaFragmentURI();
 855     void applyMediaFragmentURI();
 856 
 857     void changeNetworkStateFromLoadingToIdle();
 858 
 859     void removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask = MediaElementSession::AllRestrictions);
 860 
 861     void updateMediaController();
 862     bool isBlocked() const;
 863     bool isBlockedOnMediaController() const;
 864     bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
<span class="line-modified"> 865     bool isLiveStream() const override { return movieLoadType() == MovieLoadType::LiveStream; }</span>
 866 
 867     void updateSleepDisabling();
<span class="line-modified"> 868     enum class SleepType { None, Display, System };</span>




 869     SleepType shouldDisableSleep() const;
 870 
 871 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 872     void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
 873     DOMWrapperWorld&amp; ensureIsolatedWorld();
 874     bool ensureMediaControlsInjectedScript();
 875 #endif
 876 
 877     PlatformMediaSession::MediaType mediaType() const override;
 878     PlatformMediaSession::MediaType presentationType() const override;
 879     PlatformMediaSession::DisplayType displayType() const override;
 880     PlatformMediaSession::CharacteristicsFlags characteristics() const final;
 881 
 882     void suspendPlayback() override;
 883     void resumeAutoplaying() override;
 884     void mayResumePlayback(bool shouldResume) override;
 885     uint64_t mediaSessionUniqueIdentifier() const final;
 886     String mediaSessionTitle() const override;
 887     double mediaSessionDuration() const override { return duration(); }
 888     double mediaSessionCurrentTime() const override { return currentTime(); }
</pre>
<hr />
<pre>
 893     bool canProduceAudio() const final;
 894     bool processingUserGestureForMedia() const final;
 895     bool hasMediaStreamSource() const final;
 896     void processIsSuspendedChanged() final;
 897 
 898     void pageMutedStateDidChange() override;
 899 
 900 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 901     void hardwareMutedStateDidChange(AudioSession*) final;
 902 #endif
 903 
 904     bool effectiveMuted() const;
 905     double effectiveVolume() const;
 906 
 907     void registerWithDocument(Document&amp;);
 908     void unregisterWithDocument(Document&amp;);
 909 
 910     void updateCaptionContainer();
 911     void ensureMediaControlsShadowRoot();
 912 
<span class="line-modified"> 913     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::JSGlobalObject&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;</span>
 914     bool setupAndCallJS(const JSSetupFunction&amp;);
 915 
 916 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 917     void prepareForDocumentSuspension() final;
 918     void resumeFromDocumentSuspension() final;
 919 
 920     void scheduleUpdateMediaState();
 921     void updateMediaState();
 922     bool hasPlaybackTargetAvailabilityListeners() const { return m_hasPlaybackTargetAvailabilityListeners; }
 923 #endif
 924 
 925     bool isVideoTooSmallForInlinePlayback();
 926     void updateShouldAutoplay();
 927 
 928     void pauseAfterDetachedTask();
 929     void updatePlaybackControlsManager();
 930     void schedulePlaybackControlsManagerUpdate();
 931     void playbackControlsManagerBehaviorRestrictionsTimerFired();
 932 
 933     void updateRenderer();
 934 
 935     void updatePageScaleFactorJSProperty();
 936     void updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
 937     void setControllerJSProperty(const char*, JSC::JSValue);
 938 
 939     void addBehaviorRestrictionsOnEndIfNecessary();
 940     void handleSeekToPlaybackPosition(double);
 941     void seekToPlaybackPositionEndedTimerFired();
 942 



 943     void setInActiveDocument(bool);
 944 
 945 #if !RELEASE_LOG_DISABLED
 946     const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
 947     const Logger&amp; mediaPlayerLogger() final { return logger(); }
 948 #endif
 949 
<span class="line-added"> 950     friend class TaskDispatcher&lt;HTMLMediaElement&gt;;</span>
<span class="line-added"> 951     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp;);</span>
<span class="line-added"> 952 </span>
 953     Timer m_progressEventTimer;
 954     Timer m_playbackProgressTimer;
 955     Timer m_scanTimer;
 956     Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
 957     Timer m_seekToPlaybackPositionEndedTimer;
 958     DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
 959     DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
 960     DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
 961     DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
<span class="line-modified"> 962     DeferrableTask&lt;HTMLMediaElement&gt; m_updatePlayStateTask;</span>
 963     DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
 964     DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
 965     DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
 966     GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
 967     GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
 968     GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
 969     GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
 970     GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
 971     GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
 972     RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
<span class="line-modified"> 973     UniqueRef&lt;MainThreadGenericEventQueue&gt; m_asyncEventQueue;</span>
 974 #if PLATFORM(IOS_FAMILY)
 975     DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;
 976 #endif
 977 
 978     PlayPromiseVector m_pendingPlayPromises;
 979 
 980     double m_requestedPlaybackRate { 1 };
 981     double m_reportedPlaybackRate { 1 };
 982     double m_defaultPlaybackRate { 1 };
 983     bool m_webkitPreservesPitch { true };
 984     NetworkState m_networkState { NETWORK_EMPTY };
 985     ReadyState m_readyState { HAVE_NOTHING };
 986     ReadyState m_readyStateMaximum { HAVE_NOTHING };
 987     URL m_currentSrc;
 988 
 989     RefPtr&lt;MediaError&gt; m_error;
 990 
 991     struct PendingSeek {
 992         WTF_MAKE_STRUCT_FAST_ALLOCATED;
 993         PendingSeek(const MediaTime&amp; now, const MediaTime&amp; targetTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance)
</pre>
<hr />
<pre>
1017 
1018     // The last time a timeupdate event was sent in movie time.
1019     MediaTime m_lastTimeUpdateEventMovieTime;
1020 
1021     // Loading state.
1022     enum LoadState { WaitingForSource, LoadingFromSrcAttr, LoadingFromSourceElement };
1023     LoadState m_loadState { WaitingForSource };
1024     RefPtr&lt;HTMLSourceElement&gt; m_currentSourceNode;
1025     RefPtr&lt;HTMLSourceElement&gt; m_nextChildNodeToConsider;
1026 
1027     VideoFullscreenMode m_videoFullscreenMode { VideoFullscreenModeNone };
1028     bool m_videoFullscreenStandby { false };
1029     bool m_preparedForInline;
1030     WTF::Function&lt;void()&gt; m_preparedForInlineCompletionHandler;
1031 
1032     bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
1033 
1034 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
1035     RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
1036     FloatRect m_videoFullscreenFrame;
<span class="line-modified">1037     MediaPlayer::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravity::ResizeAspect };</span>
1038 #endif
1039 
1040     RefPtr&lt;MediaPlayer&gt; m_player;
1041 
<span class="line-modified">1042     MediaPlayer::Preload m_preload { Preload::Auto };</span>
1043 
1044     DisplayMode m_displayMode { Unknown };
1045 
1046     // Counter incremented while processing a callback from the media player, so we can avoid
1047     // calling the media engine recursively.
1048     int m_processingMediaPlayerCallback { 0 };
1049 
1050 #if ENABLE(MEDIA_SESSION)
1051     String m_kind;
1052     RefPtr&lt;MediaSession&gt; m_session;
1053     bool m_shouldDuck { false };
1054     uint64_t m_elementID;
1055 #endif
1056 
1057 #if ENABLE(MEDIA_SOURCE)
1058     RefPtr&lt;MediaSource&gt; m_mediaSource;
1059     unsigned m_droppedVideoFrames { 0 };
1060 #endif
1061 
1062     mutable MediaTime m_cachedTime;
</pre>
<hr />
<pre>
1122     bool m_isScrubbingRemotely : 1;
1123     bool m_waitingToEnterFullscreen : 1;
1124 
1125 #if ENABLE(VIDEO_TRACK)
1126     bool m_tracksAreReady : 1;
1127     bool m_haveVisibleTextTrack : 1;
1128     bool m_processingPreferenceChange : 1;
1129 
1130     AutoplayEventPlaybackState m_autoplayEventPlaybackState { AutoplayEventPlaybackState::None };
1131 
1132     String m_subtitleTrackLanguage;
1133     MediaTime m_lastTextTrackUpdateTime { -1, 1 };
1134 
1135     Optional&lt;CaptionUserPreferences::CaptionDisplayMode&gt; m_captionDisplayMode;
1136 
1137     RefPtr&lt;AudioTrackList&gt; m_audioTracks;
1138     RefPtr&lt;TextTrackList&gt; m_textTracks;
1139     RefPtr&lt;VideoTrackList&gt; m_videoTracks;
1140     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
1141 
<span class="line-modified">1142     struct CueData;</span>
<span class="line-added">1143     std::unique_ptr&lt;CueData&gt; m_cueData;</span>
1144 

1145     int m_ignoreTrackDisplayUpdate { 0 };
1146 
1147     bool m_requireCaptionPreferencesChangedCallbacks { false };
1148 #endif
1149 
1150 #if ENABLE(WEB_AUDIO)
1151     // This is a weak reference, since m_audioSourceNode holds a reference to us.
1152     // The value is set just after the MediaElementAudioSourceNode is created.
1153     // The value is cleared in MediaElementAudioSourceNode::~MediaElementAudioSourceNode().
1154     MediaElementAudioSourceNode* m_audioSourceNode { nullptr };
1155 #endif
1156 
1157     String m_mediaGroup;
1158     friend class MediaController;
1159     RefPtr&lt;MediaController&gt; m_mediaController;
1160 
1161     std::unique_ptr&lt;PAL::SleepDisabler&gt; m_sleepDisabler;
1162 
1163     WeakPtr&lt;const MediaResourceLoader&gt; m_lastMediaResourceLoaderForTesting;
1164 
1165     friend class TrackDisplayUpdateScope;
1166 
1167     RefPtr&lt;Blob&gt; m_blob;
1168     MediaProvider m_mediaProvider;
1169 
1170 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
1171     RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
1172 #endif
<span class="line-added">1173 </span>
1174 #if ENABLE(ENCRYPTED_MEDIA)
1175     RefPtr&lt;MediaKeys&gt; m_mediaKeys;
1176     bool m_attachingMediaKeys { false };
1177     bool m_playbackBlockedWaitingForKey { false };
1178     GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
1179 #endif
1180 
<span class="line-added">1181 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">1182     Ref&lt;RemotePlayback&gt; m_remote;</span>
<span class="line-added">1183 #endif</span>
<span class="line-added">1184 </span>
1185     std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
1186     size_t m_reportedExtraMemoryCost { 0 };
1187 
1188 #if !RELEASE_LOG_DISABLED
1189     RefPtr&lt;Logger&gt; m_logger;
1190     const void* m_logIdentifier;
1191 #endif
1192 
1193 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1194     friend class MediaControlsHost;
1195     RefPtr&lt;MediaControlsHost&gt; m_mediaControlsHost;
1196     RefPtr&lt;DOMWrapperWorld&gt; m_isolatedWorld;
1197 #endif
1198 
1199 #if ENABLE(MEDIA_STREAM)
1200     RefPtr&lt;MediaStream&gt; m_mediaStreamSrcObject;
1201     bool m_settingMediaStreamSrcObject { false };
1202 #endif
1203 
1204 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1205     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1206     bool m_hasPlaybackTargetAvailabilityListeners { false };
1207     bool m_failedToPlayToWirelessTarget { false };
1208 #endif
1209 
1210     bool m_isPlayingToWirelessTarget { false };
1211     bool m_playingOnSecondScreen { false };
1212     bool m_removedBehaviorRestrictionsAfterFirstUserGesture { false };
1213 };
1214 
1215 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
1216 
1217 } // namespace WebCore
1218 
1219 namespace WTF {
1220 
1221 template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
1222     static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
1223 };
1224 

















1225 } // namespace WTF
1226 
1227 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
1228     static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
1229     static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
1230 SPECIALIZE_TYPE_TRAITS_END()
1231 
1232 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLMediaElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMeterElement.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
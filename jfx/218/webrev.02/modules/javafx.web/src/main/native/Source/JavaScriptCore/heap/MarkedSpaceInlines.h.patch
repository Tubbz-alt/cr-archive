diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpaceInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpaceInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpaceInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/MarkedSpaceInlines.h
@@ -28,10 +28,15 @@
 #include "MarkedBlockInlines.h"
 #include "MarkedSpace.h"
 
 namespace JSC {
 
+ALWAYS_INLINE Heap& MarkedSpace::heap() const
+{
+    return *bitwise_cast<Heap*>(bitwise_cast<uintptr_t>(this) - OBJECT_OFFSETOF(Heap, m_objectSpace));
+}
+
 template<typename Functor> inline void MarkedSpace::forEachLiveCell(HeapIterationScope&, const Functor& functor)
 {
     ASSERT(isIterating());
     forEachLiveCell(functor);
 }
@@ -45,11 +50,11 @@
                 return functor(cell, kind);
             });
         if (result == IterationStatus::Done)
             return;
     }
-    for (LargeAllocation* allocation : m_largeAllocations) {
+    for (PreciseAllocation* allocation : m_preciseAllocations) {
         if (allocation->isLive()) {
             if (functor(allocation->cell(), allocation->attributes().cellKind) == IterationStatus::Done)
                 return;
         }
     }
@@ -61,11 +66,11 @@
     BlockIterator end = m_blocks.set().end();
     for (BlockIterator it = m_blocks.set().begin(); it != end; ++it) {
         if ((*it)->handle().forEachDeadCell(functor) == IterationStatus::Done)
             return;
     }
-    for (LargeAllocation* allocation : m_largeAllocations) {
+    for (PreciseAllocation* allocation : m_preciseAllocations) {
         if (!allocation->isLive()) {
             if (functor(allocation->cell(), allocation->attributes().cellKind) == IterationStatus::Done)
                 return;
         }
     }

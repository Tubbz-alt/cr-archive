<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBackingStore.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Image.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBackingStore.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 58,18 ***</span>
      {
          if (size.isEmpty())
              return false;
  
          Vector&lt;char&gt; buffer;
<span class="line-modified">!         size_t bufferSize = size.area().unsafeGet() * sizeof(RGBA32);</span>
  
          if (!buffer.tryReserveCapacity(bufferSize))
              return false;
  
          buffer.grow(bufferSize);
          m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">!         m_pixelsPtr = reinterpret_cast&lt;RGBA32*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
          m_size = size;
          m_frameRect = IntRect(IntPoint(), m_size);
          clear();
          return true;
      }
<span class="line-new-header">--- 58,18 ---</span>
      {
          if (size.isEmpty())
              return false;
  
          Vector&lt;char&gt; buffer;
<span class="line-modified">!         size_t bufferSize = size.area().unsafeGet() * sizeof(uint32_t);</span>
  
          if (!buffer.tryReserveCapacity(bufferSize))
              return false;
  
          buffer.grow(bufferSize);
          m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">!         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
          m_size = size;
          m_frameRect = IntRect(IntPoint(), m_size);
          clear();
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,20 ***</span>
      const IntSize&amp; size() const { return m_size; }
      const IntRect&amp; frameRect() const { return m_frameRect; }
  
      void clear()
      {
<span class="line-modified">!         memset(m_pixelsPtr, 0, (m_size.area() * sizeof(RGBA32)).unsafeGet());</span>
      }
  
      void clearRect(const IntRect&amp; rect)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         size_t rowBytes = rect.width() * sizeof(RGBA32);</span>
<span class="line-modified">!         RGBA32* start = pixelAt(rect.x(), rect.y());</span>
          for (int i = 0; i &lt; rect.height(); ++i) {
              memset(start, 0, rowBytes);
              start += m_size.width();
          }
      }
<span class="line-new-header">--- 84,20 ---</span>
      const IntSize&amp; size() const { return m_size; }
      const IntRect&amp; frameRect() const { return m_frameRect; }
  
      void clear()
      {
<span class="line-modified">!         memset(m_pixelsPtr, 0, (m_size.area() * sizeof(uint32_t)).unsafeGet());</span>
      }
  
      void clearRect(const IntRect&amp; rect)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified">!         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
          for (int i = 0; i &lt; rect.height(); ++i) {
              memset(start, 0, rowBytes);
              start += m_size.width();
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,12 ***</span>
      void fillRect(const IntRect &amp;rect, unsigned r, unsigned g, unsigned b, unsigned a)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         RGBA32* start = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">!         RGBA32 pixelValue = this-&gt;pixelValue(r, g, b, a);</span>
          for (int i = 0; i &lt; rect.height(); ++i) {
              for (int j = 0; j &lt; rect.width(); ++j)
                  start[j] = pixelValue;
              start += m_size.width();
          }
<span class="line-new-header">--- 105,12 ---</span>
      void fillRect(const IntRect &amp;rect, unsigned r, unsigned g, unsigned b, unsigned a)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         uint32_t* start = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">!         uint32_t pixelValue = this-&gt;pixelValue(r, g, b, a);</span>
          for (int i = 0; i &lt; rect.height(); ++i) {
              for (int j = 0; j &lt; rect.width(); ++j)
                  start[j] = pixelValue;
              start += m_size.width();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,60 ***</span>
      void repeatFirstRow(const IntRect&amp; rect)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         size_t rowBytes = rect.width() * sizeof(RGBA32);</span>
<span class="line-modified">!         RGBA32* src = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">!         RGBA32* dest = src + m_size.width();</span>
          for (int i = 1; i &lt; rect.height(); ++i) {
              memcpy(dest, src, rowBytes);
              dest += m_size.width();
          }
      }
  
<span class="line-modified">!     RGBA32* pixelAt(int x, int y) const</span>
      {
          ASSERT(inBounds(IntPoint(x, y)));
          return m_pixelsPtr + y * m_size.width() + x;
      }
  
<span class="line-modified">!     void setPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
      {
          ASSERT(dest);
          *dest = pixelValue(r, g, b, a);
      }
  
      void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
      {
          setPixel(pixelAt(x, y), r, g, b, a);
      }
  
<span class="line-modified">!     void blendPixel(RGBA32* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
      {
          if (!a)
              return;
  
<span class="line-modified">!         if (a &gt;= 255 || !alphaChannel(*dest)) {</span>
              setPixel(dest, r, g, b, a);
              return;
          }
  
          if (!m_premultiplyAlpha)
<span class="line-modified">!             *dest = makePremultipliedRGBA(redChannel(*dest), greenChannel(*dest), blueChannel(*dest), alphaChannel(*dest), false);</span>
  
          unsigned d = 255 - a;
  
<span class="line-modified">!         r = fastDivideBy255(r * a + redChannel(*dest) * d);</span>
<span class="line-modified">!         g = fastDivideBy255(g * a + greenChannel(*dest) * d);</span>
<span class="line-modified">!         b = fastDivideBy255(b * a + blueChannel(*dest) * d);</span>
<span class="line-modified">!         a += fastDivideBy255(d * alphaChannel(*dest));</span>
  
          if (m_premultiplyAlpha)
<span class="line-modified">!             *dest = makeRGBA(r, g, b, a);</span>
          else
<span class="line-modified">!             *dest = makeUnPremultipliedRGBA(r, g, b, a);</span>
      }
  
      static bool isOverSize(const IntSize&amp; size)
      {
  #if USE(CAIRO)
<span class="line-new-header">--- 119,62 ---</span>
      void repeatFirstRow(const IntRect&amp; rect)
      {
          if (rect.isEmpty() || !inBounds(rect))
              return;
  
<span class="line-modified">!         size_t rowBytes = rect.width() * sizeof(uint32_t);</span>
<span class="line-modified">!         uint32_t* src = pixelAt(rect.x(), rect.y());</span>
<span class="line-modified">!         uint32_t* dest = src + m_size.width();</span>
          for (int i = 1; i &lt; rect.height(); ++i) {
              memcpy(dest, src, rowBytes);
              dest += m_size.width();
          }
      }
  
<span class="line-modified">!     uint32_t* pixelAt(int x, int y) const</span>
      {
          ASSERT(inBounds(IntPoint(x, y)));
          return m_pixelsPtr + y * m_size.width() + x;
      }
  
<span class="line-modified">!     void setPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
      {
          ASSERT(dest);
          *dest = pixelValue(r, g, b, a);
      }
  
      void setPixel(int x, int y, unsigned r, unsigned g, unsigned b, unsigned a)
      {
          setPixel(pixelAt(x, y), r, g, b, a);
      }
  
<span class="line-modified">!     void blendPixel(uint32_t* dest, unsigned r, unsigned g, unsigned b, unsigned a)</span>
      {
          if (!a)
              return;
  
<span class="line-modified">!         SimpleColor pixel { *dest };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (a &gt;= 255 || !pixel.isVisible()) {</span>
              setPixel(dest, r, g, b, a);
              return;
          }
  
          if (!m_premultiplyAlpha)
<span class="line-modified">!             pixel = makePremultipliedRGBA(pixel.redComponent(), pixel.greenComponent(), pixel.blueComponent(), pixel.alphaComponent(), false);</span>
  
          unsigned d = 255 - a;
  
<span class="line-modified">!         r = fastDivideBy255(r * a + pixel.redComponent() * d);</span>
<span class="line-modified">!         g = fastDivideBy255(g * a + pixel.greenComponent() * d);</span>
<span class="line-modified">!         b = fastDivideBy255(b * a + pixel.blueComponent() * d);</span>
<span class="line-modified">!         a += fastDivideBy255(d * pixel.alphaComponent());</span>
  
          if (m_premultiplyAlpha)
<span class="line-modified">!             *dest = makeRGBA(r, g, b, a).value();</span>
          else
<span class="line-modified">!             *dest = makeUnPremultipliedRGBA(r, g, b, a).value();</span>
      }
  
      static bool isOverSize(const IntSize&amp; size)
      {
  #if USE(CAIRO)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,11 ***</span>
      {
          ASSERT(!m_size.isEmpty() &amp;&amp; !isOverSize(m_size));
          Vector&lt;char&gt; buffer;
          buffer.append(other.m_pixels-&gt;data(), other.m_pixels-&gt;size());
          m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">!         m_pixelsPtr = reinterpret_cast&lt;RGBA32*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
      }
  
      bool inBounds(const IntPoint&amp; point) const
      {
          return IntRect(IntPoint(), m_size).contains(point);
<span class="line-new-header">--- 204,11 ---</span>
      {
          ASSERT(!m_size.isEmpty() &amp;&amp; !isOverSize(m_size));
          Vector&lt;char&gt; buffer;
          buffer.append(other.m_pixels-&gt;data(), other.m_pixels-&gt;size());
          m_pixels = SharedBuffer::DataSegment::create(WTFMove(buffer));
<span class="line-modified">!         m_pixelsPtr = reinterpret_cast&lt;uint32_t*&gt;(const_cast&lt;char*&gt;(m_pixels-&gt;data()));</span>
      }
  
      bool inBounds(const IntPoint&amp; point) const
      {
          return IntRect(IntPoint(), m_size).contains(point);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,23 ***</span>
      bool inBounds(const IntRect&amp; rect) const
      {
          return IntRect(IntPoint(), m_size).contains(rect);
      }
  
<span class="line-modified">!     RGBA32 pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const</span>
      {
          if (m_premultiplyAlpha &amp;&amp; !a)
              return 0;
  
          if (m_premultiplyAlpha &amp;&amp; a &lt; 255)
<span class="line-modified">!             return makePremultipliedRGBA(r, g, b, a, false);</span>
  
<span class="line-modified">!         return makeRGBA(r, g, b, a);</span>
      }
  
      RefPtr&lt;SharedBuffer::DataSegment&gt; m_pixels;
<span class="line-modified">!     RGBA32* m_pixelsPtr { nullptr };</span>
      IntSize m_size;
      IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
      bool m_premultiplyAlpha { true };
  };
  
<span class="line-new-header">--- 217,23 ---</span>
      bool inBounds(const IntRect&amp; rect) const
      {
          return IntRect(IntPoint(), m_size).contains(rect);
      }
  
<span class="line-modified">!     uint32_t pixelValue(unsigned r, unsigned g, unsigned b, unsigned a) const</span>
      {
          if (m_premultiplyAlpha &amp;&amp; !a)
              return 0;
  
          if (m_premultiplyAlpha &amp;&amp; a &lt; 255)
<span class="line-modified">!             return makePremultipliedRGBA(r, g, b, a, false).value();</span>
  
<span class="line-modified">!         return makeRGBA(r, g, b, a).value();</span>
      }
  
      RefPtr&lt;SharedBuffer::DataSegment&gt; m_pixels;
<span class="line-modified">!     uint32_t* m_pixelsPtr { nullptr };</span>
      IntSize m_size;
      IntRect m_frameRect; // This will always just be the entire buffer except for GIF and PNG frames
      bool m_premultiplyAlpha { true };
  };
  
</pre>
<center><a href="Image.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
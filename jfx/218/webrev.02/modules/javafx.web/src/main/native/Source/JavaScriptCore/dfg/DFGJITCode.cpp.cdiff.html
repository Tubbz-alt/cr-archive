<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGInvalidationPointInjectionPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCode.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGJITCode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 56,11 ***</span>
  JITCode* JITCode::dfg()
  {
      return this;
  }
  
<span class="line-modified">! void JITCode::shrinkToFit()</span>
  {
      common.shrinkToFit();
      osrEntry.shrinkToFit();
      osrExit.shrinkToFit();
      speculationRecovery.shrinkToFit();
<span class="line-new-header">--- 56,11 ---</span>
  JITCode* JITCode::dfg()
  {
      return this;
  }
  
<span class="line-modified">! void JITCode::shrinkToFit(const ConcurrentJSLocker&amp;)</span>
  {
      common.shrinkToFit();
      osrEntry.shrinkToFit();
      osrExit.shrinkToFit();
      speculationRecovery.shrinkToFit();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,20 ***</span>
  {
      variableEventStream.reconstruct(
          codeBlock, codeOrigin, minifiedDFG, streamIndex, result);
  }
  
<span class="line-modified">! void JITCode::reconstruct(</span>
<span class="line-removed">-     ExecState* exec, CodeBlock* codeBlock, CodeOrigin codeOrigin, unsigned streamIndex,</span>
<span class="line-removed">-     Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result)</span>
  {
      Operands&lt;ValueRecovery&gt; recoveries;
      reconstruct(codeBlock, codeOrigin, streamIndex, recoveries);
  
      result = Operands&lt;Optional&lt;JSValue&gt;&gt;(OperandsLike, recoveries);
      for (size_t i = result.size(); i--;)
<span class="line-modified">!         result[i] = recoveries[i].recover(exec);</span>
  }
  
  RegisterSet JITCode::liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock* codeBlock, CallSiteIndex callSiteIndex)
  {
      for (OSRExit&amp; exit : osrExit) {
<span class="line-new-header">--- 74,18 ---</span>
  {
      variableEventStream.reconstruct(
          codeBlock, codeOrigin, minifiedDFG, streamIndex, result);
  }
  
<span class="line-modified">! void JITCode::reconstruct(CallFrame* callFrame, CodeBlock* codeBlock, CodeOrigin codeOrigin, unsigned streamIndex, Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; result)</span>
  {
      Operands&lt;ValueRecovery&gt; recoveries;
      reconstruct(codeBlock, codeOrigin, streamIndex, recoveries);
  
      result = Operands&lt;Optional&lt;JSValue&gt;&gt;(OperandsLike, recoveries);
      for (size_t i = result.size(); i--;)
<span class="line-modified">!         result[i] = recoveries[i].recover(callFrame);</span>
  }
  
  RegisterSet JITCode::liveRegistersToPreserveAtExceptionHandlingCallSite(CodeBlock* codeBlock, CallSiteIndex callSiteIndex)
  {
      for (OSRExit&amp; exit : osrExit) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 128,50 ***</span>
  }
  
  void JITCode::optimizeNextInvocation(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: FTL-optimizing next invocation.\n&quot;);</span>
      tierUpCounter.setNewThreshold(0, codeBlock);
  }
  
  void JITCode::dontOptimizeAnytimeSoon(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: Not FTL-optimizing anytime soon.\n&quot;);</span>
      tierUpCounter.deferIndefinitely();
  }
  
  void JITCode::optimizeAfterWarmUp(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: FTL-optimizing after warm-up.\n&quot;);</span>
      CodeBlock* baseline = codeBlock-&gt;baselineVersion();
      tierUpCounter.setNewThreshold(
          baseline-&gt;adjustedCounterValue(Options::thresholdForFTLOptimizeAfterWarmUp()),
          baseline);
  }
  
  void JITCode::optimizeSoon(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: FTL-optimizing soon.\n&quot;);</span>
      CodeBlock* baseline = codeBlock-&gt;baselineVersion();
      tierUpCounter.setNewThreshold(
          baseline-&gt;adjustedCounterValue(Options::thresholdForFTLOptimizeSoon()),
          codeBlock);
  }
  
  void JITCode::forceOptimizationSlowPathConcurrently(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*codeBlock, &quot;: Forcing slow path concurrently for FTL entry.\n&quot;);</span>
      tierUpCounter.forceSlowPathConcurrently();
  }
  
  void JITCode::setOptimizationThresholdBasedOnCompilationResult(
      CodeBlock* codeBlock, CompilationResult result)
<span class="line-new-header">--- 126,45 ---</span>
  }
  
  void JITCode::optimizeNextInvocation(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: FTL-optimizing next invocation.&quot;);</span>
      tierUpCounter.setNewThreshold(0, codeBlock);
  }
  
  void JITCode::dontOptimizeAnytimeSoon(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Not FTL-optimizing anytime soon.&quot;);</span>
      tierUpCounter.deferIndefinitely();
  }
  
  void JITCode::optimizeAfterWarmUp(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: FTL-optimizing after warm-up.&quot;);</span>
      CodeBlock* baseline = codeBlock-&gt;baselineVersion();
      tierUpCounter.setNewThreshold(
          baseline-&gt;adjustedCounterValue(Options::thresholdForFTLOptimizeAfterWarmUp()),
          baseline);
  }
  
  void JITCode::optimizeSoon(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: FTL-optimizing soon.&quot;);</span>
      CodeBlock* baseline = codeBlock-&gt;baselineVersion();
      tierUpCounter.setNewThreshold(
          baseline-&gt;adjustedCounterValue(Options::thresholdForFTLOptimizeSoon()),
          codeBlock);
  }
  
  void JITCode::forceOptimizationSlowPathConcurrently(CodeBlock* codeBlock)
  {
      ASSERT(codeBlock-&gt;jitType() == JITType::DFGJIT);
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *codeBlock, &quot;: Forcing slow path concurrently for FTL entry.&quot;);</span>
      tierUpCounter.forceSlowPathConcurrently();
  }
  
  void JITCode::setOptimizationThresholdBasedOnCompilationResult(
      CodeBlock* codeBlock, CompilationResult result)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,21 ***</span>
  }
  
  void JITCode::setOSREntryBlock(VM&amp; vm, const JSCell* owner, CodeBlock* osrEntryBlock)
  {
      if (Options::verboseOSR()) {
<span class="line-modified">!         dataLog(RawPointer(this), &quot;: Setting OSR entry block to &quot;, RawPointer(osrEntryBlock), &quot;\n&quot;);</span>
<span class="line-modified">!         dataLog(&quot;OSR entries will go to &quot;, osrEntryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;addressForCall(ArityCheckNotRequired), &quot;\n&quot;);</span>
      }
      m_osrEntryBlock.set(vm, owner, osrEntryBlock);
  }
  
  void JITCode::clearOSREntryBlockAndResetThresholds(CodeBlock *dfgCodeBlock)
  {
      ASSERT(m_osrEntryBlock);
  
<span class="line-modified">!     unsigned osrEntryBytecode = m_osrEntryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;bytecodeIndex();</span>
      m_osrEntryBlock.clear();
      osrEntryRetry = 0;
      tierUpEntryTriggers.set(osrEntryBytecode, JITCode::TriggerReason::DontTrigger);
      setOptimizationThresholdBasedOnCompilationResult(dfgCodeBlock, CompilationDeferred);
  }
<span class="line-new-header">--- 197,21 ---</span>
  }
  
  void JITCode::setOSREntryBlock(VM&amp; vm, const JSCell* owner, CodeBlock* osrEntryBlock)
  {
      if (Options::verboseOSR()) {
<span class="line-modified">!         dataLogLn(RawPointer(this), &quot;: Setting OSR entry block to &quot;, RawPointer(osrEntryBlock));</span>
<span class="line-modified">!         dataLogLn(&quot;OSR entries will go to &quot;, osrEntryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;addressForCall(ArityCheckNotRequired));</span>
      }
      m_osrEntryBlock.set(vm, owner, osrEntryBlock);
  }
  
  void JITCode::clearOSREntryBlockAndResetThresholds(CodeBlock *dfgCodeBlock)
  {
      ASSERT(m_osrEntryBlock);
  
<span class="line-modified">!     BytecodeIndex osrEntryBytecode = m_osrEntryBlock-&gt;jitCode()-&gt;ftlForOSREntry()-&gt;bytecodeIndex();</span>
      m_osrEntryBlock.clear();
      osrEntryRetry = 0;
      tierUpEntryTriggers.set(osrEntryBytecode, JITCode::TriggerReason::DontTrigger);
      setOptimizationThresholdBasedOnCompilationResult(dfgCodeBlock, CompilationDeferred);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
      auto comparator = [] (const auto&amp; a, const auto&amp; b) {
          return a.m_bytecodeIndex &lt; b.m_bytecodeIndex;
      };
      std::sort(osrEntry.begin(), osrEntry.end(), comparator);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      auto verifyIsSorted = [&amp;] (auto&amp; osrVector) {
          for (unsigned i = 0; i + 1 &lt; osrVector.size(); ++i)
              ASSERT(osrVector[i].m_bytecodeIndex &lt;= osrVector[i + 1].m_bytecodeIndex);
      };
      verifyIsSorted(osrEntry);
<span class="line-new-header">--- 246,11 ---</span>
      auto comparator = [] (const auto&amp; a, const auto&amp; b) {
          return a.m_bytecodeIndex &lt; b.m_bytecodeIndex;
      };
      std::sort(osrEntry.begin(), osrEntry.end(), comparator);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      auto verifyIsSorted = [&amp;] (auto&amp; osrVector) {
          for (unsigned i = 0; i + 1 &lt; osrVector.size(); ++i)
              ASSERT(osrVector[i].m_bytecodeIndex &lt;= osrVector[i + 1].m_bytecodeIndex);
      };
      verifyIsSorted(osrEntry);
</pre>
<center><a href="DFGInvalidationPointInjectionPhase.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGJITCode.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MessageEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MessagePort.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/MessagePort.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &quot;MessageWithMessagePorts.h&quot;
  #include &quot;WorkerGlobalScope.h&quot;
  #include &quot;WorkerThread.h&quot;
  #include &lt;wtf/CompletionHandler.h&gt;
  #include &lt;wtf/IsoMallocInlines.h&gt;
<span class="line-added">+ #include &lt;wtf/Scope.h&gt;</span>
  
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(MessagePort);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,21 ***</span>
          m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
  }
  
  void MessagePort::entangle()
  {
<span class="line-modified">!     MessagePortChannelProvider::singleton().entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; MessagePort::postMessage(JSC::ExecState&amp; state, JSC::JSValue messageValue, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
  {
      LOG(MessagePorts, &quot;Attempting to post message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
  
      registerLocalActivity();
  
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports);</span>
      if (messageData.hasException())
          return messageData.releaseException();
  
      if (!isEntangled())
          return { };
<span class="line-new-header">--- 123,21 ---</span>
          m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
  }
  
  void MessagePort::entangle()
  {
<span class="line-modified">!     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).entangleLocalPortInThisProcessToRemote(m_identifier, m_remoteIdentifier);</span>
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; MessagePort::postMessage(JSC::JSGlobalObject&amp; state, JSC::JSValue messageValue, PostMessageOptions&amp;&amp; options)</span>
  {
      LOG(MessagePorts, &quot;Attempting to post message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
  
      registerLocalActivity();
  
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(options.transfer), ports);</span>
      if (messageData.hasException())
          return messageData.releaseException();
  
      if (!isEntangled())
          return { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 158,25 ***</span>
  
      MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
  
      LOG(MessagePorts, &quot;Actually posting message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
  
<span class="line-modified">!     MessagePortChannelProvider::singleton().postMessageToRemote(WTFMove(message), m_remoteIdentifier);</span>
      return { };
  }
  
  void MessagePort::disentangle()
  {
      ASSERT(m_entangled);
      m_entangled = false;
  
      registerLocalActivity();
  
<span class="line-modified">!     MessagePortChannelProvider::singleton().messagePortDisentangled(m_identifier);</span>
  
      // We can&#39;t receive any messages or generate any events after this, so remove ourselves from the list of active ports.
<span class="line-removed">-     ASSERT(m_scriptExecutionContext);</span>
      m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
      m_scriptExecutionContext-&gt;willDestroyActiveDOMObject(*this);
      m_scriptExecutionContext-&gt;willDestroyDestructionObserver(*this);
  
      m_scriptExecutionContext = nullptr;
<span class="line-new-header">--- 159,24 ---</span>
  
      MessageWithMessagePorts message { messageData.releaseReturnValue(), WTFMove(transferredPorts) };
  
      LOG(MessagePorts, &quot;Actually posting message to port %s (to be received by port %s)&quot;, m_identifier.logString().utf8().data(), m_remoteIdentifier.logString().utf8().data());
  
<span class="line-modified">!     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).postMessageToRemote(WTFMove(message), m_remoteIdentifier);</span>
      return { };
  }
  
  void MessagePort::disentangle()
  {
      ASSERT(m_entangled);
      m_entangled = false;
  
      registerLocalActivity();
  
<span class="line-modified">!     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).messagePortDisentangled(m_identifier);</span>
  
      // We can&#39;t receive any messages or generate any events after this, so remove ourselves from the list of active ports.
      m_scriptExecutionContext-&gt;destroyedMessagePort(*this);
      m_scriptExecutionContext-&gt;willDestroyActiveDOMObject(*this);
      m_scriptExecutionContext-&gt;willDestroyDestructionObserver(*this);
  
      m_scriptExecutionContext = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,11 ***</span>
  
      if (m_closed)
          return;
      m_closed = true;
  
<span class="line-modified">!     MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);</span>
      removeAllEventListeners();
  }
  
  void MessagePort::contextDestroyed()
  {
<span class="line-new-header">--- 223,18 ---</span>
  
      if (m_closed)
          return;
      m_closed = true;
  
<span class="line-modified">!     if (isMainThread())</span>
<span class="line-added">+         MessagePortChannelProvider::singleton().messagePortClosed(m_identifier);</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         callOnMainThread([identifier = m_identifier] {</span>
<span class="line-added">+             MessagePortChannelProvider::singleton().messagePortClosed(identifier);</span>
<span class="line-added">+         });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      removeAllEventListeners();
  }
  
  void MessagePort::contextDestroyed()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,54 ***</span>
      ASSERT(started());
  
      if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended() || !isEntangled())
          return;
  
<span class="line-modified">!     RefPtr&lt;WorkerThread&gt; workerThread;</span>
<span class="line-modified">!     if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))</span>
<span class="line-removed">-         workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();</span>
  
<span class="line-modified">!     auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this), workerThread = WTFMove(workerThread)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionCallback) mutable {</span>
<span class="line-modified">!         ASSERT(isMainThread());</span>
<span class="line-removed">-         auto innerHandler = [this, weakThis = WTFMove(weakThis)](auto&amp;&amp; messages) {</span>
<span class="line-removed">-             if (!weakThis)</span>
<span class="line-removed">-                 return;</span>
  
<span class="line-modified">!             LOG(MessagePorts, &quot;MessagePort %s (%p) dispatching %zu messages&quot;, m_identifier.logString().utf8().data(), this, messages.size());</span>
  
<span class="line-modified">!             if (!m_scriptExecutionContext)</span>
<span class="line-modified">!                 return;</span>
  
<span class="line-modified">!             if (!messages.isEmpty())</span>
<span class="line-modified">!                 registerLocalActivity();</span>
  
<span class="line-modified">!             ASSERT(m_scriptExecutionContext-&gt;isContextThread());</span>
  
<span class="line-modified">!             bool contextIsWorker = is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext);</span>
<span class="line-modified">!             for (auto&amp; message : messages) {</span>
<span class="line-modified">!                 // close() in Worker onmessage handler should prevent next message from dispatching.</span>
<span class="line-modified">!                 if (contextIsWorker &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">!                 auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));</span>
<span class="line-modified">!                 dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-         };</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (!workerThread) {</span>
<span class="line-removed">-             innerHandler(WTFMove(messages));</span>
<span class="line-removed">-             completionCallback();</span>
<span class="line-removed">-             return;</span>
          }
<span class="line-removed">-         workerThread-&gt;runLoop().postTaskForMode([innerHandler = WTFMove(innerHandler), messages = WTFMove(messages), completionCallback = WTFMove(completionCallback)](auto&amp;) mutable {</span>
<span class="line-removed">-             innerHandler(WTFMove(messages));</span>
<span class="line-removed">-             callOnMainThread([completionCallback = WTFMove(completionCallback)] {</span>
<span class="line-removed">-                 completionCallback();</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-         }, WorkerRunLoop::defaultMode());</span>
      };
  
<span class="line-modified">!     MessagePortChannelProvider::singleton().takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));</span>
  }
  
  void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
  {
      bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
<span class="line-new-header">--- 251,49 ---</span>
      ASSERT(started());
  
      if (!m_scriptExecutionContext || m_scriptExecutionContext-&gt;activeDOMObjectsAreSuspended() || !isEntangled())
          return;
  
<span class="line-modified">!     auto messagesTakenHandler = [this, weakThis = makeWeakPtr(this)](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionCallback) mutable {</span>
<span class="line-modified">!         auto scopeExit = makeScopeExit(WTFMove(completionCallback));</span>
  
<span class="line-modified">!         if (!weakThis)</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         LOG(MessagePorts, &quot;MessagePort %s (%p) dispatching %zu messages&quot;, m_identifier.logString().utf8().data(), this, messages.size());</span>
  
<span class="line-modified">!         if (!m_scriptExecutionContext)</span>
<span class="line-modified">!             return;</span>
  
<span class="line-modified">!         if (!messages.isEmpty())</span>
<span class="line-modified">!             registerLocalActivity();</span>
  
<span class="line-modified">!         ASSERT(m_scriptExecutionContext-&gt;isContextThread());</span>
  
<span class="line-modified">!         bool contextIsWorker = is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext);</span>
<span class="line-modified">!         for (auto&amp; message : messages) {</span>
<span class="line-modified">!             // close() in Worker onmessage handler should prevent next message from dispatching.</span>
<span class="line-modified">!             if (contextIsWorker &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             auto ports = MessagePort::entanglePorts(*m_scriptExecutionContext, WTFMove(message.transferredPorts));</span>
<span class="line-modified">!             // Per specification, each MessagePort object has a task source called the port message queue.</span>
<span class="line-modified">!             queueTaskToDispatchEvent(*this, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
          }
      };
  
<span class="line-modified">!     MessagePortChannelProvider::fromContext(*m_scriptExecutionContext).takeAllMessagesForPort(m_identifier, WTFMove(messagesTakenHandler));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void MessagePort::dispatchEvent(Event&amp; event)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_closed)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).isClosing())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     EventTarget::dispatchEvent(event);</span>
  }
  
  void MessagePort::updateActivity(MessagePortChannelProvider::HasActivity hasActivity)
  {
      bool hasHadLocalActivity = m_hasHadLocalActivitySinceLastCheck;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,23 ***</span>
      if (!m_isAskingRemoteAboutGC) {
          RefPtr&lt;WorkerThread&gt; workerThread;
          if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))
              workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();
  
<span class="line-modified">!         MessagePortChannelProvider::singleton().checkRemotePortForActivity(m_remoteIdentifier, [weakThis = makeWeakPtr(const_cast&lt;MessagePort*&gt;(this)), workerThread = WTFMove(workerThread)](MessagePortChannelProvider::HasActivity hasActivity) mutable {</span>
<span class="line-modified">! </span>
<span class="line-modified">!             ASSERT(isMainThread());</span>
<span class="line-modified">!             if (!workerThread) {</span>
<span class="line-modified">!                 if (weakThis)</span>
<span class="line-modified">!                     weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">!                 return;</span>
<span class="line-removed">-             }</span>
  
<span class="line-modified">!             workerThread-&gt;runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&amp;) mutable {</span>
<span class="line-modified">!                 if (weakThis)</span>
<span class="line-modified">!                     weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">!             }, WorkerRunLoop::defaultMode());</span>
          });
          m_isAskingRemoteAboutGC = true;
      }
  
      // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
<span class="line-new-header">--- 328,23 ---</span>
      if (!m_isAskingRemoteAboutGC) {
          RefPtr&lt;WorkerThread&gt; workerThread;
          if (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext))
              workerThread = &amp;downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread();
  
<span class="line-modified">!         callOnMainThread([remoteIdentifier = m_remoteIdentifier, weakThis = makeWeakPtr(const_cast&lt;MessagePort*&gt;(this)), workerThread = WTFMove(workerThread)]() mutable {</span>
<span class="line-modified">!             MessagePortChannelProvider::singleton().checkRemotePortForActivity(remoteIdentifier, [weakThis = WTFMove(weakThis), workerThread = WTFMove(workerThread)](auto hasActivity) mutable {</span>
<span class="line-modified">!                 if (!workerThread) {</span>
<span class="line-modified">!                     if (weakThis)</span>
<span class="line-modified">!                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">!                     return;</span>
<span class="line-modified">!                 }</span>
  
<span class="line-modified">!                 workerThread-&gt;runLoop().postTaskForMode([weakThis = WTFMove(weakThis), hasActivity](auto&amp;) mutable {</span>
<span class="line-modified">!                     if (weakThis)</span>
<span class="line-modified">!                         weakThis-&gt;updateActivity(hasActivity);</span>
<span class="line-modified">!                 }, WorkerRunLoop::defaultMode());</span>
<span class="line-added">+             });</span>
          });
          m_isAskingRemoteAboutGC = true;
      }
  
      // Since we need an answer from the remote object, we have to pretend we have pending activity for now.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,11 ***</span>
  const char* MessagePort::activeDOMObjectName() const
  {
      return &quot;MessagePort&quot;;
  }
  
<span class="line-removed">- bool MessagePort::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  } // namespace WebCore
<span class="line-new-header">--- 428,6 ---</span>
</pre>
<center><a href="MessageEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MessagePort.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSEntry.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSEntry.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSEntry.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSEntry.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -23,25 +23,51 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "BAssert.h"
 #include "BMalloced.h"
+#include "IsoTLSLayout.h"
+#include <climits>
 
 namespace bmalloc {
 
 class IsoTLS;
-class IsoTLSLayout;
+
+template<typename Entry>
+class IsoTLSEntryHolder {
+    MAKE_BMALLOCED;
+    IsoTLSEntryHolder(const IsoTLSEntryHolder&) = delete;
+    IsoTLSEntryHolder& operator=(const IsoTLSEntryHolder&) = delete;
+public:
+    template<typename... Args>
+    IsoTLSEntryHolder(Args&&... args)
+        : m_entry(std::forward<Args>(args)...)
+    {
+        IsoTLSLayout::get()->add(&m_entry);
+        RELEASE_BASSERT(m_entry.offset() != UINT_MAX);
+    }
+
+    inline const Entry& operator*() const { m_entry; }
+    inline Entry& operator*() { m_entry; }
+    inline const Entry* operator->() const { return &m_entry; }
+    inline Entry* operator->() { return &m_entry; }
+
+private:
+    Entry m_entry;
+};
 
 class BEXPORT IsoTLSEntry {
     MAKE_BMALLOCED;
+    IsoTLSEntry(const IsoTLSEntry&) = delete;
+    IsoTLSEntry& operator=(const IsoTLSEntry&) = delete;
 public:
-    IsoTLSEntry(size_t alignment, size_t size);
     virtual ~IsoTLSEntry();
 
     size_t offset() const { return m_offset; }
-    size_t alignment() const { return m_alignment; }
+    size_t alignment() const { return sizeof(void*); }
     size_t size() const { return m_size; }
     size_t extent() const { return m_offset + m_size; }
 
     virtual void construct(void* entry) = 0;
     virtual void move(void* src, void* dst) = 0;
@@ -49,36 +75,37 @@
     virtual void scavenge(void* entry) = 0;
 
     template<typename Func>
     void walkUpToInclusive(IsoTLSEntry*, const Func&);
 
+protected:
+    IsoTLSEntry(size_t size);
+
 private:
     friend class IsoTLS;
     friend class IsoTLSLayout;
 
     IsoTLSEntry* m_next { nullptr };
 
-    size_t m_offset; // Computed in constructor.
-    size_t m_alignment;
-    size_t m_size;
+    unsigned m_offset { UINT_MAX }; // Computed in constructor.
+    unsigned m_size;
 };
 
 template<typename EntryType>
 class DefaultIsoTLSEntry : public IsoTLSEntry {
 public:
-    DefaultIsoTLSEntry();
-    ~DefaultIsoTLSEntry();
+    ~DefaultIsoTLSEntry() = default;
 
 protected:
+    DefaultIsoTLSEntry();
+
     // This clones src onto dst and then destructs src. Therefore, entry destructors cannot do
     // scavenging.
     void move(void* src, void* dst) override;
 
     // Likewise, this is separate from scavenging. When the TLS is shutting down, we will be asked to
     // scavenge and then we will be asked to destruct.
     void destruct(void* entry) override;
-
-    void scavenge(void* entry) override;
 };
 
 } // namespace bmalloc
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLLinkElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLInputElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLLinkElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLLinkElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;ContentSecurityPolicy.h&quot;
 34 #include &quot;CrossOriginAccessControl.h&quot;
 35 #include &quot;DOMTokenList.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;EventSender.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;FrameLoaderClient.h&quot;
 43 #include &quot;FrameTree.h&quot;
 44 #include &quot;FrameView.h&quot;
 45 #include &quot;HTMLAnchorElement.h&quot;
 46 #include &quot;HTMLNames.h&quot;
 47 #include &quot;HTMLParserIdioms.h&quot;
 48 #include &quot;Logging.h&quot;
 49 #include &quot;MediaList.h&quot;
 50 #include &quot;MediaQueryEvaluator.h&quot;
 51 #include &quot;MediaQueryParser.h&quot;
 52 #include &quot;MouseEvent.h&quot;

 53 #include &quot;RenderStyle.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &quot;SecurityOrigin.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &quot;StyleInheritedData.h&quot;
 58 #include &quot;StyleResolveForDocument.h&quot;
 59 #include &quot;StyleScope.h&quot;
 60 #include &quot;StyleSheetContents.h&quot;
 61 #include &quot;SubresourceIntegrity.h&quot;
 62 #include &lt;wtf/IsoMallocInlines.h&gt;
 63 #include &lt;wtf/Ref.h&gt;
<span class="line-modified"> 64 #include &lt;wtf/SetForScope.h&gt;</span>
 65 #include &lt;wtf/StdLibExtras.h&gt;
 66 
 67 namespace WebCore {
 68 
 69 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLLinkElement);
 70 
 71 using namespace HTMLNames;
 72 
 73 static LinkEventSender&amp; linkLoadEventSender()
 74 {
 75     static NeverDestroyed&lt;LinkEventSender&gt; sharedLoadEventSender(eventNames().loadEvent);
 76     return sharedLoadEventSender;
 77 }
 78 
 79 static LinkEventSender&amp; linkErrorEventSender()
 80 {
 81     static NeverDestroyed&lt;LinkEventSender&gt; sharedErrorEventSender(eventNames().errorEvent);
 82     return sharedErrorEventSender;
 83 }
 84 
 85 inline HTMLLinkElement::HTMLLinkElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 86     : HTMLElement(tagName, document)
 87     , m_linkLoader(*this)
 88     , m_disabledState(Unset)
 89     , m_loading(false)
 90     , m_createdByParser(createdByParser)
 91     , m_firedLoad(false)
 92     , m_loadedResource(false)


 93     , m_pendingSheetType(Unknown)
 94 {
 95     ASSERT(hasTagName(linkTag));
 96 }
 97 
 98 Ref&lt;HTMLLinkElement&gt; HTMLLinkElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 99 {
100     return adoptRef(*new HTMLLinkElement(tagName, document, createdByParser));
101 }
102 
103 HTMLLinkElement::~HTMLLinkElement()
104 {
105     if (m_sheet)
106         m_sheet-&gt;clearOwnerNode();
107 
108     if (m_cachedSheet)
109         m_cachedSheet-&gt;removeClient(*this);
110 
111     if (m_styleScope)
112         m_styleScope-&gt;removeStyleSheetCandidateNode(*this);
</pre>
<hr />
<pre>
258 
259     // Prevent recursive loading of link.
260     if (m_isHandlingBeforeLoad)
261         return;
262 
263     URL url = getNonEmptyURLAttribute(hrefAttr);
264 
265     LinkLoadParameters params {
266         m_relAttribute,
267         url,
268         attributeWithoutSynchronization(asAttr),
269         attributeWithoutSynchronization(mediaAttr),
270         attributeWithoutSynchronization(typeAttr),
271         attributeWithoutSynchronization(crossoriginAttr),
272         attributeWithoutSynchronization(imagesrcsetAttr),
273         attributeWithoutSynchronization(imagesizesAttr)
274     };
275 
276     m_linkLoader.loadLink(params, document());
277 
<span class="line-modified">278     bool treatAsStyleSheet = m_relAttribute.isStyleSheet</span>
<span class="line-modified">279         || (document().settings().treatsAnyTextCSSLinkAsStylesheet() &amp;&amp; m_type.containsIgnoringASCIICase(&quot;text/css&quot;));</span>







280 
281     if (m_disabledState != Disabled &amp;&amp; treatAsStyleSheet &amp;&amp; document().frame() &amp;&amp; url.isValid()) {
282         String charset = attributeWithoutSynchronization(charsetAttr);
283         if (charset.isEmpty())
284             charset = document().charset();
285 
286         if (m_cachedSheet) {
287             removePendingSheet();
288             m_cachedSheet-&gt;removeClient(*this);
289             m_cachedSheet = nullptr;
290         }
291 
292         {
<span class="line-modified">293         SetForScope&lt;bool&gt; change(m_isHandlingBeforeLoad, true);</span>
<span class="line-modified">294         if (!shouldLoadLink())</span>
<span class="line-modified">295             return;</span>


296         }
297 
298         m_loading = true;
299 
300         bool mediaQueryMatches = true;
301         if (!m_media.isEmpty()) {
302             Optional&lt;RenderStyle&gt; documentStyle;
303             if (document().hasLivingRenderTree())
304                 documentStyle = Style::resolveForDocument(document());
305             auto media = MediaQuerySet::create(m_media, MediaQueryParserContext(document()));
306             LOG(MediaQueries, &quot;HTMLLinkElement::process evaluating queries&quot;);
307             mediaQueryMatches = MediaQueryEvaluator { document().frame()-&gt;view()-&gt;mediaType(), document(), documentStyle ? &amp;*documentStyle : nullptr }.evaluate(media.get());
308         }
309 
310         // Don&#39;t hold up render tree construction and script execution on stylesheets
311         // that are not needed for the rendering at the moment.
312         bool isActive = mediaQueryMatches &amp;&amp; !isAlternate();
313         addPendingSheet(isActive ? ActiveSheet : InactiveSheet);
314 
315         // Load stylesheets that are not needed for the rendering immediately with low priority.
316         Optional&lt;ResourceLoadPriority&gt; priority;
317         if (!isActive)
318             priority = ResourceLoadPriority::VeryLow;
319 
320         if (document().settings().subresourceIntegrityEnabled())
321             m_integrityMetadataForPendingSheetRequest = attributeWithoutSynchronization(HTMLNames::integrityAttr);
322 
323         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
324         options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
325         if (document().contentSecurityPolicy()-&gt;allowStyleWithNonce(attributeWithoutSynchronization(HTMLNames::nonceAttr)))
326             options.contentSecurityPolicyImposition = ContentSecurityPolicyImposition::SkipPolicyCheck;
327         options.integrity = m_integrityMetadataForPendingSheetRequest;
328 
<span class="line-modified">329         auto request = createPotentialAccessControlRequest(WTFMove(url), document(), crossOrigin(), WTFMove(options));</span>
330         request.setPriority(WTFMove(priority));
331         request.setCharset(WTFMove(charset));
332         request.setInitiator(*this);
333 
334         ASSERT_WITH_SECURITY_IMPLICATION(!m_cachedSheet);
335         m_cachedSheet = document().cachedResourceLoader().requestCSSStyleSheet(WTFMove(request)).value_or(nullptr);
336 
337         if (m_cachedSheet)
338             m_cachedSheet-&gt;addClient(*this);
339         else {
340             // The request may have been denied if (for example) the stylesheet is local and the document is remote.
341             m_loading = false;
342             sheetLoaded();
<span class="line-modified">343             notifyLoadedSheetAndAllCriticalSubresources(false);</span>
344         }
345     } else if (m_sheet) {
346         // we no longer contain a stylesheet, e.g. perhaps rel or type was changed
347         clearSheet();
348         m_styleScope-&gt;didChangeActiveStyleSheetCandidates();
349     }
350 }
351 
352 void HTMLLinkElement::clearSheet()
353 {
354     ASSERT(m_sheet);
355     ASSERT(m_sheet-&gt;ownerNode() == this);
356     m_sheet-&gt;clearOwnerNode();
357     m_sheet = nullptr;
358 }
359 
360 Node::InsertedIntoAncestorResult HTMLLinkElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
361 {
362     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
363     if (!insertionType.connectedToDocument)
</pre>
<hr />
<pre>
415         m_sheet-&gt;setTitle(title());
416 
417     if (!m_sheet-&gt;canAccessRules())
418         m_sheet-&gt;contents().setAsOpaque();
419 }
420 
421 void HTMLLinkElement::setCSSStyleSheet(const String&amp; href, const URL&amp; baseURL, const String&amp; charset, const CachedCSSStyleSheet* cachedStyleSheet)
422 {
423     if (!isConnected()) {
424         ASSERT(!m_sheet);
425         return;
426     }
427     auto frame = makeRefPtr(document().frame());
428     if (!frame)
429         return;
430 
431     // Completing the sheet load may cause scripts to execute.
432     Ref&lt;HTMLLinkElement&gt; protectedThis(*this);
433 
434     if (!cachedStyleSheet-&gt;errorOccurred() &amp;&amp; !matchIntegrityMetadata(*cachedStyleSheet, m_integrityMetadataForPendingSheetRequest)) {
<span class="line-modified">435         document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Cannot load stylesheet &quot;, cachedStyleSheet-&gt;url().stringCenterEllipsizedToLength(), &quot;. Failed integrity metadata check.&quot;));</span>
436 
437         m_loading = false;
438         sheetLoaded();
439         notifyLoadedSheetAndAllCriticalSubresources(true);
440         return;
441     }
442 
443     CSSParserContext parserContext(document(), baseURL, charset);
444     auto cachePolicy = frame-&gt;loader().subresourceCachePolicy(baseURL);
445 
446     if (auto restoredSheet = const_cast&lt;CachedCSSStyleSheet*&gt;(cachedStyleSheet)-&gt;restoreParsedStyleSheet(parserContext, cachePolicy, frame-&gt;loader())) {
447         ASSERT(restoredSheet-&gt;isCacheable());
448         ASSERT(!restoredSheet-&gt;isLoading());
449         initializeStyleSheet(restoredSheet.releaseNonNull(), *cachedStyleSheet, MediaQueryParserContext(document()));
450 
451         m_loading = false;
452         sheetLoaded();
453         notifyLoadedSheetAndAllCriticalSubresources(false);
454         return;
455     }
456 
457     auto styleSheet = StyleSheetContents::create(href, parserContext);
458     initializeStyleSheet(styleSheet.copyRef(), *cachedStyleSheet, MediaQueryParserContext(document()));
459 
460     // FIXME: Set the visibility option based on m_sheet being clean or not.
461     // Best approach might be to set it on the style sheet content itself or its context parser otherwise.
<span class="line-modified">462     styleSheet.get().parseAuthorStyleSheet(cachedStyleSheet, &amp;document().securityOrigin());</span>





463 
464     m_loading = false;
465     styleSheet.get().notifyLoadedSheet(cachedStyleSheet);
466     styleSheet.get().checkLoaded();
467 
468     if (styleSheet.get().isCacheable())
469         const_cast&lt;CachedCSSStyleSheet*&gt;(cachedStyleSheet)-&gt;saveParsedStyleSheet(WTFMove(styleSheet));
470 }
471 
472 bool HTMLLinkElement::styleSheetIsLoading() const
473 {
474     if (m_loading)
475         return true;
476     if (!m_sheet)
477         return false;
478     return m_sheet-&gt;contents().isLoading();
479 }
480 
481 DOMTokenList&amp; HTMLLinkElement::sizes()
482 {
483     if (!m_sizes)
484         m_sizes = makeUnique&lt;DOMTokenList&gt;(*this, sizesAttr);
485     return *m_sizes;
486 }
487 
488 void HTMLLinkElement::linkLoaded()
489 {
490     m_loadedResource = true;
<span class="line-modified">491     linkLoadEventSender().dispatchEventSoon(*this);</span>

492 }
493 
494 void HTMLLinkElement::linkLoadingErrored()
495 {
<span class="line-modified">496     linkErrorEventSender().dispatchEventSoon(*this);</span>

497 }
498 
499 bool HTMLLinkElement::sheetLoaded()
500 {
501     if (!styleSheetIsLoading()) {
502         removePendingSheet();
503         return true;
504     }
505     return false;
506 }
507 
508 void HTMLLinkElement::dispatchPendingLoadEvents()
509 {
510     linkLoadEventSender().dispatchPendingEvents();
511 }
512 
513 void HTMLLinkElement::dispatchPendingEvent(LinkEventSender* eventSender)
514 {
515     ASSERT_UNUSED(eventSender, eventSender == &amp;linkLoadEventSender() || eventSender == &amp;linkErrorEventSender());
516     if (m_loadedResource)
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;ContentSecurityPolicy.h&quot;
 34 #include &quot;CrossOriginAccessControl.h&quot;
 35 #include &quot;DOMTokenList.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;EventNames.h&quot;
 39 #include &quot;EventSender.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;FrameLoader.h&quot;
 42 #include &quot;FrameLoaderClient.h&quot;
 43 #include &quot;FrameTree.h&quot;
 44 #include &quot;FrameView.h&quot;
 45 #include &quot;HTMLAnchorElement.h&quot;
 46 #include &quot;HTMLNames.h&quot;
 47 #include &quot;HTMLParserIdioms.h&quot;
 48 #include &quot;Logging.h&quot;
 49 #include &quot;MediaList.h&quot;
 50 #include &quot;MediaQueryEvaluator.h&quot;
 51 #include &quot;MediaQueryParser.h&quot;
 52 #include &quot;MouseEvent.h&quot;
<span class="line-added"> 53 #include &quot;ParsedContentType.h&quot;</span>
 54 #include &quot;RenderStyle.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &quot;SecurityOrigin.h&quot;
 57 #include &quot;Settings.h&quot;
 58 #include &quot;StyleInheritedData.h&quot;
 59 #include &quot;StyleResolveForDocument.h&quot;
 60 #include &quot;StyleScope.h&quot;
 61 #include &quot;StyleSheetContents.h&quot;
 62 #include &quot;SubresourceIntegrity.h&quot;
 63 #include &lt;wtf/IsoMallocInlines.h&gt;
 64 #include &lt;wtf/Ref.h&gt;
<span class="line-modified"> 65 #include &lt;wtf/Scope.h&gt;</span>
 66 #include &lt;wtf/StdLibExtras.h&gt;
 67 
 68 namespace WebCore {
 69 
 70 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLLinkElement);
 71 
 72 using namespace HTMLNames;
 73 
 74 static LinkEventSender&amp; linkLoadEventSender()
 75 {
 76     static NeverDestroyed&lt;LinkEventSender&gt; sharedLoadEventSender(eventNames().loadEvent);
 77     return sharedLoadEventSender;
 78 }
 79 
 80 static LinkEventSender&amp; linkErrorEventSender()
 81 {
 82     static NeverDestroyed&lt;LinkEventSender&gt; sharedErrorEventSender(eventNames().errorEvent);
 83     return sharedErrorEventSender;
 84 }
 85 
 86 inline HTMLLinkElement::HTMLLinkElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 87     : HTMLElement(tagName, document)
 88     , m_linkLoader(*this)
 89     , m_disabledState(Unset)
 90     , m_loading(false)
 91     , m_createdByParser(createdByParser)
 92     , m_firedLoad(false)
 93     , m_loadedResource(false)
<span class="line-added"> 94     , m_isHandlingBeforeLoad(false)</span>
<span class="line-added"> 95     , m_allowPrefetchLoadAndErrorForTesting(false)</span>
 96     , m_pendingSheetType(Unknown)
 97 {
 98     ASSERT(hasTagName(linkTag));
 99 }
100 
101 Ref&lt;HTMLLinkElement&gt; HTMLLinkElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
102 {
103     return adoptRef(*new HTMLLinkElement(tagName, document, createdByParser));
104 }
105 
106 HTMLLinkElement::~HTMLLinkElement()
107 {
108     if (m_sheet)
109         m_sheet-&gt;clearOwnerNode();
110 
111     if (m_cachedSheet)
112         m_cachedSheet-&gt;removeClient(*this);
113 
114     if (m_styleScope)
115         m_styleScope-&gt;removeStyleSheetCandidateNode(*this);
</pre>
<hr />
<pre>
261 
262     // Prevent recursive loading of link.
263     if (m_isHandlingBeforeLoad)
264         return;
265 
266     URL url = getNonEmptyURLAttribute(hrefAttr);
267 
268     LinkLoadParameters params {
269         m_relAttribute,
270         url,
271         attributeWithoutSynchronization(asAttr),
272         attributeWithoutSynchronization(mediaAttr),
273         attributeWithoutSynchronization(typeAttr),
274         attributeWithoutSynchronization(crossoriginAttr),
275         attributeWithoutSynchronization(imagesrcsetAttr),
276         attributeWithoutSynchronization(imagesizesAttr)
277     };
278 
279     m_linkLoader.loadLink(params, document());
280 
<span class="line-modified">281     bool treatAsStyleSheet = false;</span>
<span class="line-modified">282     if (m_relAttribute.isStyleSheet) {</span>
<span class="line-added">283         if (m_type.isNull())</span>
<span class="line-added">284             treatAsStyleSheet = true;</span>
<span class="line-added">285         else if (auto parsedContentType = ParsedContentType::create(m_type))</span>
<span class="line-added">286             treatAsStyleSheet = equalLettersIgnoringASCIICase(parsedContentType-&gt;mimeType(), &quot;text/css&quot;);</span>
<span class="line-added">287     }</span>
<span class="line-added">288     if (!treatAsStyleSheet)</span>
<span class="line-added">289         treatAsStyleSheet = document().settings().treatsAnyTextCSSLinkAsStylesheet() &amp;&amp; m_type.containsIgnoringASCIICase(&quot;text/css&quot;);</span>
290 
291     if (m_disabledState != Disabled &amp;&amp; treatAsStyleSheet &amp;&amp; document().frame() &amp;&amp; url.isValid()) {
292         String charset = attributeWithoutSynchronization(charsetAttr);
293         if (charset.isEmpty())
294             charset = document().charset();
295 
296         if (m_cachedSheet) {
297             removePendingSheet();
298             m_cachedSheet-&gt;removeClient(*this);
299             m_cachedSheet = nullptr;
300         }
301 
302         {
<span class="line-modified">303             bool previous = m_isHandlingBeforeLoad;</span>
<span class="line-modified">304             m_isHandlingBeforeLoad = true;</span>
<span class="line-modified">305             makeScopeExit([&amp;] { m_isHandlingBeforeLoad = previous; });</span>
<span class="line-added">306             if (!shouldLoadLink())</span>
<span class="line-added">307                 return;</span>
308         }
309 
310         m_loading = true;
311 
312         bool mediaQueryMatches = true;
313         if (!m_media.isEmpty()) {
314             Optional&lt;RenderStyle&gt; documentStyle;
315             if (document().hasLivingRenderTree())
316                 documentStyle = Style::resolveForDocument(document());
317             auto media = MediaQuerySet::create(m_media, MediaQueryParserContext(document()));
318             LOG(MediaQueries, &quot;HTMLLinkElement::process evaluating queries&quot;);
319             mediaQueryMatches = MediaQueryEvaluator { document().frame()-&gt;view()-&gt;mediaType(), document(), documentStyle ? &amp;*documentStyle : nullptr }.evaluate(media.get());
320         }
321 
322         // Don&#39;t hold up render tree construction and script execution on stylesheets
323         // that are not needed for the rendering at the moment.
324         bool isActive = mediaQueryMatches &amp;&amp; !isAlternate();
325         addPendingSheet(isActive ? ActiveSheet : InactiveSheet);
326 
327         // Load stylesheets that are not needed for the rendering immediately with low priority.
328         Optional&lt;ResourceLoadPriority&gt; priority;
329         if (!isActive)
330             priority = ResourceLoadPriority::VeryLow;
331 
332         if (document().settings().subresourceIntegrityEnabled())
333             m_integrityMetadataForPendingSheetRequest = attributeWithoutSynchronization(HTMLNames::integrityAttr);
334 
335         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
336         options.sameOriginDataURLFlag = SameOriginDataURLFlag::Set;
337         if (document().contentSecurityPolicy()-&gt;allowStyleWithNonce(attributeWithoutSynchronization(HTMLNames::nonceAttr)))
338             options.contentSecurityPolicyImposition = ContentSecurityPolicyImposition::SkipPolicyCheck;
339         options.integrity = m_integrityMetadataForPendingSheetRequest;
340 
<span class="line-modified">341         auto request = createPotentialAccessControlRequest(WTFMove(url), WTFMove(options), document(), crossOrigin());</span>
342         request.setPriority(WTFMove(priority));
343         request.setCharset(WTFMove(charset));
344         request.setInitiator(*this);
345 
346         ASSERT_WITH_SECURITY_IMPLICATION(!m_cachedSheet);
347         m_cachedSheet = document().cachedResourceLoader().requestCSSStyleSheet(WTFMove(request)).value_or(nullptr);
348 
349         if (m_cachedSheet)
350             m_cachedSheet-&gt;addClient(*this);
351         else {
352             // The request may have been denied if (for example) the stylesheet is local and the document is remote.
353             m_loading = false;
354             sheetLoaded();
<span class="line-modified">355             notifyLoadedSheetAndAllCriticalSubresources(true);</span>
356         }
357     } else if (m_sheet) {
358         // we no longer contain a stylesheet, e.g. perhaps rel or type was changed
359         clearSheet();
360         m_styleScope-&gt;didChangeActiveStyleSheetCandidates();
361     }
362 }
363 
364 void HTMLLinkElement::clearSheet()
365 {
366     ASSERT(m_sheet);
367     ASSERT(m_sheet-&gt;ownerNode() == this);
368     m_sheet-&gt;clearOwnerNode();
369     m_sheet = nullptr;
370 }
371 
372 Node::InsertedIntoAncestorResult HTMLLinkElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
373 {
374     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
375     if (!insertionType.connectedToDocument)
</pre>
<hr />
<pre>
427         m_sheet-&gt;setTitle(title());
428 
429     if (!m_sheet-&gt;canAccessRules())
430         m_sheet-&gt;contents().setAsOpaque();
431 }
432 
433 void HTMLLinkElement::setCSSStyleSheet(const String&amp; href, const URL&amp; baseURL, const String&amp; charset, const CachedCSSStyleSheet* cachedStyleSheet)
434 {
435     if (!isConnected()) {
436         ASSERT(!m_sheet);
437         return;
438     }
439     auto frame = makeRefPtr(document().frame());
440     if (!frame)
441         return;
442 
443     // Completing the sheet load may cause scripts to execute.
444     Ref&lt;HTMLLinkElement&gt; protectedThis(*this);
445 
446     if (!cachedStyleSheet-&gt;errorOccurred() &amp;&amp; !matchIntegrityMetadata(*cachedStyleSheet, m_integrityMetadataForPendingSheetRequest)) {
<span class="line-modified">447         document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Cannot load stylesheet &quot;, integrityMismatchDescription(*cachedStyleSheet, m_integrityMetadataForPendingSheetRequest)));</span>
448 
449         m_loading = false;
450         sheetLoaded();
451         notifyLoadedSheetAndAllCriticalSubresources(true);
452         return;
453     }
454 
455     CSSParserContext parserContext(document(), baseURL, charset);
456     auto cachePolicy = frame-&gt;loader().subresourceCachePolicy(baseURL);
457 
458     if (auto restoredSheet = const_cast&lt;CachedCSSStyleSheet*&gt;(cachedStyleSheet)-&gt;restoreParsedStyleSheet(parserContext, cachePolicy, frame-&gt;loader())) {
459         ASSERT(restoredSheet-&gt;isCacheable());
460         ASSERT(!restoredSheet-&gt;isLoading());
461         initializeStyleSheet(restoredSheet.releaseNonNull(), *cachedStyleSheet, MediaQueryParserContext(document()));
462 
463         m_loading = false;
464         sheetLoaded();
465         notifyLoadedSheetAndAllCriticalSubresources(false);
466         return;
467     }
468 
469     auto styleSheet = StyleSheetContents::create(href, parserContext);
470     initializeStyleSheet(styleSheet.copyRef(), *cachedStyleSheet, MediaQueryParserContext(document()));
471 
472     // FIXME: Set the visibility option based on m_sheet being clean or not.
473     // Best approach might be to set it on the style sheet content itself or its context parser otherwise.
<span class="line-modified">474     if (!styleSheet.get().parseAuthorStyleSheet(cachedStyleSheet, &amp;document().securityOrigin())) {</span>
<span class="line-added">475         m_loading = false;</span>
<span class="line-added">476         sheetLoaded();</span>
<span class="line-added">477         notifyLoadedSheetAndAllCriticalSubresources(true);</span>
<span class="line-added">478         return;</span>
<span class="line-added">479     }</span>
480 
481     m_loading = false;
482     styleSheet.get().notifyLoadedSheet(cachedStyleSheet);
483     styleSheet.get().checkLoaded();
484 
485     if (styleSheet.get().isCacheable())
486         const_cast&lt;CachedCSSStyleSheet*&gt;(cachedStyleSheet)-&gt;saveParsedStyleSheet(WTFMove(styleSheet));
487 }
488 
489 bool HTMLLinkElement::styleSheetIsLoading() const
490 {
491     if (m_loading)
492         return true;
493     if (!m_sheet)
494         return false;
495     return m_sheet-&gt;contents().isLoading();
496 }
497 
498 DOMTokenList&amp; HTMLLinkElement::sizes()
499 {
500     if (!m_sizes)
501         m_sizes = makeUnique&lt;DOMTokenList&gt;(*this, sizesAttr);
502     return *m_sizes;
503 }
504 
505 void HTMLLinkElement::linkLoaded()
506 {
507     m_loadedResource = true;
<span class="line-modified">508     if (!m_relAttribute.isLinkPrefetch || m_allowPrefetchLoadAndErrorForTesting)</span>
<span class="line-added">509         linkLoadEventSender().dispatchEventSoon(*this);</span>
510 }
511 
512 void HTMLLinkElement::linkLoadingErrored()
513 {
<span class="line-modified">514     if (!m_relAttribute.isLinkPrefetch || m_allowPrefetchLoadAndErrorForTesting)</span>
<span class="line-added">515         linkErrorEventSender().dispatchEventSoon(*this);</span>
516 }
517 
518 bool HTMLLinkElement::sheetLoaded()
519 {
520     if (!styleSheetIsLoading()) {
521         removePendingSheet();
522         return true;
523     }
524     return false;
525 }
526 
527 void HTMLLinkElement::dispatchPendingLoadEvents()
528 {
529     linkLoadEventSender().dispatchPendingEvents();
530 }
531 
532 void HTMLLinkElement::dispatchPendingEvent(LinkEventSender* eventSender)
533 {
534     ASSERT_UNUSED(eventSender, eventSender == &amp;linkLoadEventSender() || eventSender == &amp;linkErrorEventSender());
535     if (m_loadedResource)
</pre>
</td>
</tr>
</table>
<center><a href="HTMLInputElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLLinkElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
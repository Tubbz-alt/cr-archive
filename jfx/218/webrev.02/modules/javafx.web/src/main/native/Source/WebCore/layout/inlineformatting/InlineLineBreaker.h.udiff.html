<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineLineBreaker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextItem.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,39 +25,107 @@</span>
  
  #pragma once
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="udiff-line-modified-removed">- #include &quot;LayoutUnit.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;LayoutUnits.h&quot;</span>
  
  namespace WebCore {
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ class RenderStyle;</span>
<span class="udiff-line-added">+ </span>
  namespace Layout {
  
  class InlineItem;
  class InlineTextItem;
<span class="udiff-line-added">+ struct ContinuousContent;</span>
<span class="udiff-line-added">+ struct WrappedTextContent;</span>
  
  class LineBreaker {
  public:
<span class="udiff-line-modified-removed">-     enum class BreakingBehavior { Keep, Split, Wrap };</span>
<span class="udiff-line-modified-removed">-     struct BreakingContext {</span>
<span class="udiff-line-modified-removed">-         BreakingBehavior breakingBehavior;</span>
<span class="udiff-line-modified-removed">-         bool isAtBreakingOpportunity { false };</span>
<span class="udiff-line-modified-added">+     struct PartialRun {</span>
<span class="udiff-line-modified-added">+         unsigned length { 0 };</span>
<span class="udiff-line-modified-added">+         InlineLayoutUnit logicalWidth { 0 };</span>
<span class="udiff-line-modified-added">+         bool needsHyphen { false };</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     enum class IsEndOfLine { No, Yes };</span>
<span class="udiff-line-added">+     struct Result {</span>
<span class="udiff-line-added">+         enum class Action {</span>
<span class="udiff-line-added">+             Keep, // Keep content on the current line.</span>
<span class="udiff-line-added">+             Split, // Partial content is on the current line.</span>
<span class="udiff-line-added">+             Push, // Content is pushed to the next line.</span>
<span class="udiff-line-added">+             Revert // The current content overflows and can&#39;t get wrapped. The line needs to be reverted back to the last line wrapping opportunity.</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+         struct PartialTrailingContent {</span>
<span class="udiff-line-added">+             size_t trailingRunIndex { 0 };</span>
<span class="udiff-line-added">+             Optional&lt;PartialRun&gt; partialRun; // nullopt partial run means the trailing run is a complete run.</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Action action { Action::Keep };</span>
<span class="udiff-line-added">+         IsEndOfLine isEndOfLine { IsEndOfLine::No };</span>
<span class="udiff-line-added">+         Optional&lt;PartialTrailingContent&gt; partialTrailingContent { };</span>
<span class="udiff-line-added">+         const InlineItem* revertTo { nullptr };</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     struct Run {</span>
<span class="udiff-line-added">+         Run(const InlineItem&amp;, InlineLayoutUnit);</span>
<span class="udiff-line-added">+         Run(const Run&amp;);</span>
<span class="udiff-line-added">+         Run&amp; operator=(const Run&amp;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         const InlineItem&amp; inlineItem;</span>
<span class="udiff-line-added">+         InlineLayoutUnit logicalWidth { 0 };</span>
      };
<span class="udiff-line-modified-removed">-     struct LineContext {</span>
<span class="udiff-line-modified-removed">-         LayoutUnit availableWidth;</span>
<span class="udiff-line-modified-removed">-         LayoutUnit logicalLeft;</span>
<span class="udiff-line-modified-removed">-         LayoutUnit trimmableWidth;</span>
<span class="udiff-line-modified-removed">-         bool isEmpty { false };</span>
<span class="udiff-line-modified-added">+     using RunList = Vector&lt;Run, 3&gt;;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     struct LineStatus {</span>
<span class="udiff-line-modified-added">+         InlineLayoutUnit availableWidth { 0 };</span>
<span class="udiff-line-modified-added">+         InlineLayoutUnit collapsibleWidth { 0 };</span>
<span class="udiff-line-added">+         bool lineHasFullyCollapsibleTrailingRun { false };</span>
<span class="udiff-line-added">+         bool lineIsEmpty { true };</span>
      };
<span class="udiff-line-modified-removed">-     BreakingContext breakingContext(const InlineItem&amp;, LayoutUnit logicalWidth, const LineContext&amp;);</span>
<span class="udiff-line-modified-added">+     Result shouldWrapInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp;);</span>
<span class="udiff-line-added">+     bool shouldWrapFloatBox(InlineLayoutUnit floatLogicalWidth, InlineLayoutUnit availableWidth, bool lineIsEmpty);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void setHyphenationDisabled() { n_hyphenationIsDisabled = true; }</span>
  
  private:
<span class="udiff-line-added">+     // This struct represents the amount of content committed to line breaking at a time e.g.</span>
<span class="udiff-line-added">+     // text content &lt;span&gt;span1&lt;/span&gt;between&lt;span&gt;span2&lt;/span&gt;</span>
<span class="udiff-line-added">+     // [text][ ][content][ ][container start][span1][container end][between][container start][span2][container end]</span>
<span class="udiff-line-added">+     // -&gt; content chunks -&gt;</span>
<span class="udiff-line-added">+     // [text]</span>
<span class="udiff-line-added">+     // [ ]</span>
<span class="udiff-line-added">+     // [content]</span>
<span class="udiff-line-added">+     // [container start][span1][container end][between][container start][span2][container end]</span>
<span class="udiff-line-added">+     // see https://drafts.csswg.org/css-text-3/#line-break-details</span>
<span class="udiff-line-added">+     Optional&lt;WrappedTextContent&gt; wrapTextContent(const RunList&amp;, const LineStatus&amp;) const;</span>
<span class="udiff-line-added">+     Result tryWrappingInlineContent(const RunList&amp;, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp;) const;</span>
<span class="udiff-line-added">+     Optional&lt;PartialRun&gt; tryBreakingTextRun(const Run&amp; overflowRun, InlineLayoutUnit availableWidth) const;</span>
  
<span class="udiff-line-modified-removed">-     BreakingBehavior wordBreakingBehavior(const InlineTextItem&amp;, bool lineIsEmpty) const;</span>
<span class="udiff-line-modified-removed">-     bool isAtBreakingOpportunity(const InlineItem&amp;);</span>
<span class="udiff-line-modified-added">+     enum class WordBreakRule {</span>
<span class="udiff-line-modified-added">+         NoBreak,</span>
<span class="udiff-line-added">+         AtArbitraryPosition,</span>
<span class="udiff-line-added">+         OnlyHyphenationAllowed</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+     WordBreakRule wordBreakBehavior(const RenderStyle&amp;) const;</span>
<span class="udiff-line-added">+     bool shouldKeepEndOfLineWhitespace(const ContinuousContent&amp;) const;</span>
<span class="udiff-line-added">+     bool isContentWrappingAllowed(const ContinuousContent&amp;) const;</span>
  
<span class="udiff-line-modified-removed">-     bool m_hyphenationIsDisabled { true };</span>
<span class="udiff-line-modified-added">+     bool n_hyphenationIsDisabled { false };</span>
<span class="udiff-line-added">+     const InlineItem* m_lastWrapOpportunity { nullptr };</span>
  };
  
<span class="udiff-line-added">+ inline LineBreaker::Run::Run(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)</span>
<span class="udiff-line-added">+     : inlineItem(inlineItem)</span>
<span class="udiff-line-added">+     , logicalWidth(logicalWidth)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline LineBreaker::Run::Run(const Run&amp; other)</span>
<span class="udiff-line-added">+     : inlineItem(other.inlineItem)</span>
<span class="udiff-line-added">+     , logicalWidth(other.logicalWidth)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  }
  }
  #endif
</pre>
<center><a href="InlineLineBreaker.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextItem.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
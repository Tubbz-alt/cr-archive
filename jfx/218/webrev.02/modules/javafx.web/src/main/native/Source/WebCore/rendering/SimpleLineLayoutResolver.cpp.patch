diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutResolver.cpp
@@ -65,18 +65,11 @@
     auto& run = m_iterator.simpleRun();
     auto& resolver = m_iterator.resolver();
     float baseline = computeBaselinePosition();
     FloatPoint position = linePosition(run.logicalLeft, baseline - resolver.m_ascent);
     FloatSize size = lineSize(run.logicalLeft, run.logicalRight, resolver.m_ascent + resolver.m_descent + resolver.m_visualOverflowOffset);
-    bool moveLineBreakToBaseline = false;
-    if (run.start == run.end && m_iterator != resolver.begin() && m_iterator.inQuirksMode()) {
-        auto previousRun = m_iterator;
-        --previousRun;
-        moveLineBreakToBaseline = !previousRun.simpleRun().isEndOfLine;
-    }
-    if (moveLineBreakToBaseline)
-        return FloatRect(FloatPoint(position.x(), baseline), FloatSize(size.width(), std::max<float>(0, resolver.m_ascent - resolver.m_baseline.toFloat())));
+
     return FloatRect(position, size);
 }
 
 StringView RunResolver::Run::text() const
 {
@@ -111,14 +104,16 @@
     ASSERT(run.start != run.end);
     return m_iterator.resolver().m_flowContents.segmentForRun(run.start, run.end).toSegmentPosition(run.end);
 }
 
 RunResolver::Iterator::Iterator(const RunResolver& resolver, unsigned runIndex, unsigned lineIndex)
-    : m_resolver(resolver)
+    : m_layout(&resolver.m_layout)
+    , m_resolver(&resolver)
     , m_runIndex(runIndex)
     , m_lineIndex(lineIndex)
 {
+    ASSERT(&resolver == &m_layout->runResolver());
 }
 
 RunResolver::Iterator& RunResolver::Iterator::advance()
 {
     if (simpleRun().isEndOfLine)
@@ -127,12 +122,12 @@
     return *this;
 }
 
 RunResolver::Iterator& RunResolver::Iterator::advanceLines(unsigned lineCount)
 {
-    unsigned runCount = m_resolver.m_layout.runCount();
-    if (runCount == m_resolver.m_layout.lineCount()) {
+    unsigned runCount = layout().runCount();
+    if (runCount == layout().lineCount()) {
         m_runIndex = std::min(runCount, m_runIndex + lineCount);
         m_lineIndex = m_runIndex;
         return *this;
     }
     unsigned target = m_lineIndex + lineCount;
@@ -150,11 +145,10 @@
     , m_baseline(baselineFromFlow(flow))
     , m_borderAndPaddingBefore(flow.borderAndPaddingBefore())
     , m_ascent(flow.style().fontCascade().fontMetrics().ascent())
     , m_descent(flow.style().fontCascade().fontMetrics().descent())
     , m_visualOverflowOffset(visualOverflowForDecorations(flow.style(), nullptr).bottom)
-    , m_inQuirksMode(flow.document().inQuirksMode())
 {
 }
 
 unsigned RunResolver::adjustLineIndexForStruts(LayoutUnit y, IndexType type, unsigned lineIndexCandidate) const
 {
@@ -301,12 +295,14 @@
     auto range = rangeForRenderer(renderer);
     if (range.begin() == range.end())
         return { end(), end() };
     auto it = range.begin();
     auto localEnd = (*it).start() + endOffset;
-    // Advance to the first run with the start offset inside. Only the first node in a range can have a startOffset.
-    while (it != range.end() && (*it).end() <= startOffset)
+    // Advance to the first run before the start offset. Only the first node in a range can have a startOffset.
+    // Note that the start offset may coincide with the end of a run. The run is still considered so that we
+    // can return an empty rect, which conforms to the behavior of Element.getClientRects().
+    while (it != range.end() && (*it).end() < startOffset)
         ++it;
     if (it == range.end())
         return { end(), end() };
     auto rangeBegin = it;
     // Special case empty ranges that start at the edge of the run. Apparently normal line layout include those.

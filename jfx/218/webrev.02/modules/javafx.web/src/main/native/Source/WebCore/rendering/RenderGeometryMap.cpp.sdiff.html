<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFullScreen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGeometryMap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderGeometryMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38     : m_insertionPosition(notFound)
 39     , m_nonUniformStepsCount(0)
 40     , m_transformedStepsCount(0)
 41     , m_fixedStepsCount(0)
 42     , m_mapCoordinatesFlags(flags)
 43 {
 44 }
 45 
 46 RenderGeometryMap::~RenderGeometryMap() = default;
 47 
 48 void RenderGeometryMap::mapToContainer(TransformState&amp; transformState, const RenderLayerModelObject* container) const
 49 {
 50     // If the mapping includes something like columns, we have to go via renderers.
 51     if (hasNonUniformStep()) {
 52         m_mapping.last().m_renderer-&gt;mapLocalToContainer(container, transformState, ApplyContainerFlip | m_mapCoordinatesFlags);
 53         transformState.flatten();
 54         return;
 55     }
 56 
 57     bool inFixed = false;
<span class="line-modified"> 58 #if !ASSERT_DISABLED</span>
 59     bool foundContainer = !container || (m_mapping.size() &amp;&amp; m_mapping[0].m_renderer == container);
 60 #endif
 61 
 62     for (int i = m_mapping.size() - 1; i &gt;= 0; --i) {
 63         const RenderGeometryMapStep&amp; currentStep = m_mapping[i];
 64 
 65         // If container is the RenderView (step 0) we want to apply its scroll offset.
 66         if (i &gt; 0 &amp;&amp; currentStep.m_renderer == container) {
<span class="line-modified"> 67 #if !ASSERT_DISABLED</span>
 68             foundContainer = true;
 69 #endif
 70             break;
 71         }
 72 
 73         // If this box has a transform, it acts as a fixed position container
 74         // for fixed descendants, which prevents the propagation of &#39;fixed&#39;
 75         // unless the layer itself is also fixed position.
 76         if (i &amp;&amp; currentStep.m_hasTransform &amp;&amp; !currentStep.m_isFixedPosition)
 77             inFixed = false;
 78         else if (currentStep.m_isFixedPosition)
 79             inFixed = true;
 80 
 81         if (!i) {
 82             // The root gets special treatment for fixed position
 83             if (inFixed)
 84                 transformState.move(currentStep.m_offset.width(), currentStep.m_offset.height());
 85 
 86             // A null container indicates mapping through the RenderView, so including its transform (the page scale).
 87             if (!container &amp;&amp; currentStep.m_transform)
 88                 transformState.applyTransform(*currentStep.m_transform.get());
 89         } else {
 90             TransformState::TransformAccumulation accumulate = currentStep.m_accumulatingTransform ? TransformState::AccumulateTransform : TransformState::FlattenTransform;
 91             if (currentStep.m_transform)
 92                 transformState.applyTransform(*currentStep.m_transform.get(), accumulate);
 93             else
 94                 transformState.move(currentStep.m_offset.width(), currentStep.m_offset.height(), accumulate);
 95         }
 96     }
 97 
 98     ASSERT(foundContainer);
 99     transformState.flatten();
100 }
101 
102 FloatPoint RenderGeometryMap::mapToContainer(const FloatPoint&amp; p, const RenderLayerModelObject* container) const
103 {
104     FloatPoint result;
<span class="line-modified">105 #if !ASSERT_DISABLED</span>
106     FloatPoint rendererMappedResult = m_mapping.last().m_renderer-&gt;localToAbsolute(p, m_mapCoordinatesFlags);
107 #endif
108 
109     if (!hasFixedPositionStep() &amp;&amp; !hasTransformStep() &amp;&amp; !hasNonUniformStep() &amp;&amp; (!container || (m_mapping.size() &amp;&amp; container == m_mapping[0].m_renderer))) {
110         result = p + roundedIntSize(m_accumulatedOffset);
111         // Should convert to a LayoutPoint because of the uniqueness of LayoutUnit::round
<span class="line-modified">112         ASSERT(roundedIntPoint(LayoutPoint(rendererMappedResult)) == result);</span>
113     } else {
114         TransformState transformState(TransformState::ApplyTransformDirection, p);
115         mapToContainer(transformState, container);
116         result = transformState.lastPlanarPoint();
117         ASSERT(areEssentiallyEqual(rendererMappedResult, result));
118     }
119 
120     return result;
121 }
122 
123 FloatQuad RenderGeometryMap::mapToContainer(const FloatRect&amp; rect, const RenderLayerModelObject* container) const
124 {
125     FloatQuad result;
126 
127     if (!hasFixedPositionStep() &amp;&amp; !hasTransformStep() &amp;&amp; !hasNonUniformStep() &amp;&amp; (!container || (m_mapping.size() &amp;&amp; container == m_mapping[0].m_renderer))) {
128         result = rect;
129         result.move(m_accumulatedOffset);
130     } else {
131         TransformState transformState(TransformState::ApplyTransformDirection, rect.center(), rect);
132         mapToContainer(transformState, container);
</pre>
<hr />
<pre>
248 
249 void RenderGeometryMap::popMappingsToAncestor(const RenderLayerModelObject* ancestorRenderer)
250 {
251     ASSERT(m_mapping.size());
252 
253     while (m_mapping.size() &amp;&amp; m_mapping.last().m_renderer != ancestorRenderer) {
254         stepRemoved(m_mapping.last());
255         m_mapping.removeLast();
256     }
257 }
258 
259 void RenderGeometryMap::popMappingsToAncestor(const RenderLayer* ancestorLayer)
260 {
261     const RenderLayerModelObject* ancestorRenderer = ancestorLayer ? &amp;ancestorLayer-&gt;renderer() : 0;
262     popMappingsToAncestor(ancestorRenderer);
263 }
264 
265 void RenderGeometryMap::stepInserted(const RenderGeometryMapStep&amp; step)
266 {
267     // RenderView&#39;s offset, is only applied when we have fixed-positions.
<span class="line-modified">268     if (!step.m_renderer-&gt;isRenderView())</span>
269         m_accumulatedOffset += step.m_offset;




270 
271     if (step.m_isNonUniform)
272         ++m_nonUniformStepsCount;
273 
274     if (step.m_transform)
275         ++m_transformedStepsCount;
276 
277     if (step.m_isFixedPosition)
278         ++m_fixedStepsCount;
279 }
280 
281 void RenderGeometryMap::stepRemoved(const RenderGeometryMapStep&amp; step)
282 {
283     // RenderView&#39;s offset, is only applied when we have fixed-positions.
<span class="line-modified">284     if (!step.m_renderer-&gt;isRenderView())</span>
285         m_accumulatedOffset -= step.m_offset;




286 
287     if (step.m_isNonUniform) {
288         ASSERT(m_nonUniformStepsCount);
289         --m_nonUniformStepsCount;
290     }
291 
292     if (step.m_transform) {
293         ASSERT(m_transformedStepsCount);
294         --m_transformedStepsCount;
295     }
296 
297     if (step.m_isFixedPosition) {
298         ASSERT(m_fixedStepsCount);
299         --m_fixedStepsCount;
300     }
301 }
302 
303 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 38     : m_insertionPosition(notFound)
 39     , m_nonUniformStepsCount(0)
 40     , m_transformedStepsCount(0)
 41     , m_fixedStepsCount(0)
 42     , m_mapCoordinatesFlags(flags)
 43 {
 44 }
 45 
 46 RenderGeometryMap::~RenderGeometryMap() = default;
 47 
 48 void RenderGeometryMap::mapToContainer(TransformState&amp; transformState, const RenderLayerModelObject* container) const
 49 {
 50     // If the mapping includes something like columns, we have to go via renderers.
 51     if (hasNonUniformStep()) {
 52         m_mapping.last().m_renderer-&gt;mapLocalToContainer(container, transformState, ApplyContainerFlip | m_mapCoordinatesFlags);
 53         transformState.flatten();
 54         return;
 55     }
 56 
 57     bool inFixed = false;
<span class="line-modified"> 58 #if ASSERT_ENABLED</span>
 59     bool foundContainer = !container || (m_mapping.size() &amp;&amp; m_mapping[0].m_renderer == container);
 60 #endif
 61 
 62     for (int i = m_mapping.size() - 1; i &gt;= 0; --i) {
 63         const RenderGeometryMapStep&amp; currentStep = m_mapping[i];
 64 
 65         // If container is the RenderView (step 0) we want to apply its scroll offset.
 66         if (i &gt; 0 &amp;&amp; currentStep.m_renderer == container) {
<span class="line-modified"> 67 #if ASSERT_ENABLED</span>
 68             foundContainer = true;
 69 #endif
 70             break;
 71         }
 72 
 73         // If this box has a transform, it acts as a fixed position container
 74         // for fixed descendants, which prevents the propagation of &#39;fixed&#39;
 75         // unless the layer itself is also fixed position.
 76         if (i &amp;&amp; currentStep.m_hasTransform &amp;&amp; !currentStep.m_isFixedPosition)
 77             inFixed = false;
 78         else if (currentStep.m_isFixedPosition)
 79             inFixed = true;
 80 
 81         if (!i) {
 82             // The root gets special treatment for fixed position
 83             if (inFixed)
 84                 transformState.move(currentStep.m_offset.width(), currentStep.m_offset.height());
 85 
 86             // A null container indicates mapping through the RenderView, so including its transform (the page scale).
 87             if (!container &amp;&amp; currentStep.m_transform)
 88                 transformState.applyTransform(*currentStep.m_transform.get());
 89         } else {
 90             TransformState::TransformAccumulation accumulate = currentStep.m_accumulatingTransform ? TransformState::AccumulateTransform : TransformState::FlattenTransform;
 91             if (currentStep.m_transform)
 92                 transformState.applyTransform(*currentStep.m_transform.get(), accumulate);
 93             else
 94                 transformState.move(currentStep.m_offset.width(), currentStep.m_offset.height(), accumulate);
 95         }
 96     }
 97 
 98     ASSERT(foundContainer);
 99     transformState.flatten();
100 }
101 
102 FloatPoint RenderGeometryMap::mapToContainer(const FloatPoint&amp; p, const RenderLayerModelObject* container) const
103 {
104     FloatPoint result;
<span class="line-modified">105 #if ASSERT_ENABLED</span>
106     FloatPoint rendererMappedResult = m_mapping.last().m_renderer-&gt;localToAbsolute(p, m_mapCoordinatesFlags);
107 #endif
108 
109     if (!hasFixedPositionStep() &amp;&amp; !hasTransformStep() &amp;&amp; !hasNonUniformStep() &amp;&amp; (!container || (m_mapping.size() &amp;&amp; container == m_mapping[0].m_renderer))) {
110         result = p + roundedIntSize(m_accumulatedOffset);
111         // Should convert to a LayoutPoint because of the uniqueness of LayoutUnit::round
<span class="line-modified">112         ASSERT(m_accumulatedOffsetMightBeSaturated || roundedIntPoint(LayoutPoint(rendererMappedResult)) == result);</span>
113     } else {
114         TransformState transformState(TransformState::ApplyTransformDirection, p);
115         mapToContainer(transformState, container);
116         result = transformState.lastPlanarPoint();
117         ASSERT(areEssentiallyEqual(rendererMappedResult, result));
118     }
119 
120     return result;
121 }
122 
123 FloatQuad RenderGeometryMap::mapToContainer(const FloatRect&amp; rect, const RenderLayerModelObject* container) const
124 {
125     FloatQuad result;
126 
127     if (!hasFixedPositionStep() &amp;&amp; !hasTransformStep() &amp;&amp; !hasNonUniformStep() &amp;&amp; (!container || (m_mapping.size() &amp;&amp; container == m_mapping[0].m_renderer))) {
128         result = rect;
129         result.move(m_accumulatedOffset);
130     } else {
131         TransformState transformState(TransformState::ApplyTransformDirection, rect.center(), rect);
132         mapToContainer(transformState, container);
</pre>
<hr />
<pre>
248 
249 void RenderGeometryMap::popMappingsToAncestor(const RenderLayerModelObject* ancestorRenderer)
250 {
251     ASSERT(m_mapping.size());
252 
253     while (m_mapping.size() &amp;&amp; m_mapping.last().m_renderer != ancestorRenderer) {
254         stepRemoved(m_mapping.last());
255         m_mapping.removeLast();
256     }
257 }
258 
259 void RenderGeometryMap::popMappingsToAncestor(const RenderLayer* ancestorLayer)
260 {
261     const RenderLayerModelObject* ancestorRenderer = ancestorLayer ? &amp;ancestorLayer-&gt;renderer() : 0;
262     popMappingsToAncestor(ancestorRenderer);
263 }
264 
265 void RenderGeometryMap::stepInserted(const RenderGeometryMapStep&amp; step)
266 {
267     // RenderView&#39;s offset, is only applied when we have fixed-positions.
<span class="line-modified">268     if (!step.m_renderer-&gt;isRenderView()) {</span>
269         m_accumulatedOffset += step.m_offset;
<span class="line-added">270 #if ASSERT_ENABLED</span>
<span class="line-added">271         m_accumulatedOffsetMightBeSaturated |= m_accumulatedOffset.mightBeSaturated();</span>
<span class="line-added">272 #endif</span>
<span class="line-added">273     }</span>
274 
275     if (step.m_isNonUniform)
276         ++m_nonUniformStepsCount;
277 
278     if (step.m_transform)
279         ++m_transformedStepsCount;
280 
281     if (step.m_isFixedPosition)
282         ++m_fixedStepsCount;
283 }
284 
285 void RenderGeometryMap::stepRemoved(const RenderGeometryMapStep&amp; step)
286 {
287     // RenderView&#39;s offset, is only applied when we have fixed-positions.
<span class="line-modified">288     if (!step.m_renderer-&gt;isRenderView()) {</span>
289         m_accumulatedOffset -= step.m_offset;
<span class="line-added">290 #if ASSERT_ENABLED</span>
<span class="line-added">291         m_accumulatedOffsetMightBeSaturated |= m_accumulatedOffset.mightBeSaturated();</span>
<span class="line-added">292 #endif</span>
<span class="line-added">293     }</span>
294 
295     if (step.m_isNonUniform) {
296         ASSERT(m_nonUniformStepsCount);
297         --m_nonUniformStepsCount;
298     }
299 
300     if (step.m_transform) {
301         ASSERT(m_transformedStepsCount);
302         --m_transformedStepsCount;
303     }
304 
305     if (step.m_isFixedPosition) {
306         ASSERT(m_fixedStepsCount);
307         --m_fixedStepsCount;
308     }
309 }
310 
311 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="RenderFullScreen.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderGeometryMap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SecurityPolicyViolationEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorQuery.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/SelectorQuery.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;SelectorQuery.h&quot;
 29 
 30 #include &quot;CSSParser.h&quot;
 31 #include &quot;ElementDescendantIterator.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;SelectorChecker.h&quot;
 34 #include &quot;StaticNodeList.h&quot;
 35 #include &quot;StyledElement.h&quot;
 36 
 37 namespace WebCore {
 38 
<span class="line-modified"> 39 #if !ASSERT_DISABLED</span>
 40 static bool isSingleTagNameSelector(const CSSSelector&amp; selector)
 41 {
 42     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Tag;
 43 }
 44 
 45 static bool isSingleClassNameSelector(const CSSSelector&amp; selector)
 46 {
 47     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Class;
 48 }
<span class="line-modified"> 49 #endif</span>
 50 
 51 enum class IdMatchingType : uint8_t {
 52     None,
 53     Rightmost,
 54     Filter
 55 };
 56 
 57 static bool canBeUsedForIdFastPath(const CSSSelector&amp; selector)
 58 {
 59     return selector.match() == CSSSelector::Id
 60         || (selector.match() == CSSSelector::Exact &amp;&amp; selector.attribute() == HTMLNames::idAttr &amp;&amp; !selector.attributeValueMatchingIsCaseInsensitive());
 61 }
 62 
 63 static IdMatchingType findIdMatchingType(const CSSSelector&amp; firstSelector)
 64 {
 65     bool inRightmost = true;
 66     for (const CSSSelector* selector = &amp;firstSelector; selector; selector = selector-&gt;tagHistory()) {
 67         if (canBeUsedForIdFastPath(*selector)) {
 68             if (inRightmost)
 69                 return IdMatchingType::Rightmost;
 70             return IdMatchingType::Filter;
 71         }
 72         if (selector-&gt;relation() != CSSSelector::Subselector)
 73             inRightmost = false;
 74     }
 75     return IdMatchingType::None;
 76 }
 77 
 78 SelectorDataList::SelectorDataList(const CSSSelectorList&amp; selectorList)
 79 {
 80     unsigned selectorCount = 0;
 81     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
 82         selectorCount++;
 83 
 84     m_selectors.reserveInitialCapacity(selectorCount);
 85     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
<span class="line-modified"> 86         m_selectors.uncheckedAppend(SelectorData(selector));</span>
 87 
 88     if (selectorCount == 1) {
 89         const CSSSelector&amp; selector = *m_selectors.first().selector;
 90         if (selector.isLastInTagHistory()) {
 91             switch (selector.match()) {
 92             case CSSSelector::Tag:
 93                 m_matchType = TagNameMatch;
 94                 break;
 95             case CSSSelector::Class:
 96                 m_matchType = ClassNameMatch;
 97                 break;
 98             default:
 99                 if (canBeUsedForIdFastPath(selector))
100                     m_matchType = RightMostWithIdMatch;
101                 else
102                     m_matchType = CompilableSingle;
103                 break;
104             }
105         } else {
106             switch (findIdMatchingType(selector)) {
</pre>
<hr />
<pre>
388 template &lt;typename SelectorQueryTrait&gt;
389 ALWAYS_INLINE void SelectorDataList::executeSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
390 {
391     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
392         for (auto&amp; selector : m_selectors) {
393             if (selectorMatches(selector, element, rootNode)) {
394                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
395                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
396                     return;
397                 break;
398             }
399         }
400     }
401 }
402 
403 #if ENABLE(CSS_SELECTOR_JIT)
404 template &lt;typename SelectorQueryTrait&gt;
405 ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
406 {
407     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">408 #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">409         selectorData.compiledSelectorUsed();</span>
<span class="line-removed">410 #else</span>
<span class="line-removed">411         UNUSED_PARAM(selectorData);</span>
<span class="line-removed">412 #endif</span>
413         if (selectorChecker(&amp;element)) {
414             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
415             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
416                 return;
417         }
418     }
419 }
420 
421 template &lt;typename SelectorQueryTrait&gt;
422 ALWAYS_INLINE void SelectorDataList::executeCompiledSelectorCheckerWithCheckingContext(const ContainerNode&amp; rootNode, const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
423 {
424     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
425     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
426 
427     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">428 #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">429         selectorData.compiledSelectorUsed();</span>
<span class="line-removed">430 #else</span>
<span class="line-removed">431         UNUSED_PARAM(selectorData);</span>
<span class="line-removed">432 #endif</span>
433         if (selectorChecker(&amp;element, &amp;checkingContext)) {
434             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
435             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
436                 return;
437         }
438     }
439 }
440 
441 template &lt;typename SelectorQueryTrait&gt;
442 ALWAYS_INLINE void SelectorDataList::executeCompiledSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
443 {
444     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
445     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
446     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
447         for (auto&amp; selector : m_selectors) {
<span class="line-modified">448 #if CSS_SELECTOR_JIT_PROFILING</span>
<span class="line-modified">449             selector.compiledSelectorUsed();</span>
<span class="line-removed">450 #endif</span>
451             bool matched = false;
<span class="line-modified">452             void* compiledSelectorChecker = selector.compiledSelectorCodeRef.code().executableAddress();</span>
<span class="line-modified">453             if (selector.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-removed">454                 auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selector.compilationStatus);</span>
455                 matched = selectorChecker(&amp;element);
456             } else {
<span class="line-modified">457                 ASSERT(selector.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">458                 auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selector.compilationStatus);</span>
459                 matched = selectorChecker(&amp;element, &amp;checkingContext);
460             }
461             if (matched) {
462                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
463                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
464                     return;
465                 break;
466             }
467         }
468     }
469 }
470 
<span class="line-removed">471 static bool isCompiledSelector(SelectorCompilationStatus compilationStatus)</span>
<span class="line-removed">472 {</span>
<span class="line-removed">473     return compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker || compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext;</span>
<span class="line-removed">474 }</span>
<span class="line-removed">475 </span>
476 bool SelectorDataList::compileSelector(const SelectorData&amp; selectorData)
477 {
<span class="line-modified">478     if (selectorData.compilationStatus != SelectorCompilationStatus::NotCompiled)</span>
<span class="line-removed">479         return isCompiledSelector(selectorData.compilationStatus);</span>
480 
<span class="line-modified">481     selectorData.compilationStatus = SelectorCompiler::compileSelector(selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector, selectorData.compiledSelectorCodeRef);</span>
<span class="line-modified">482     return isCompiledSelector(selectorData.compilationStatus);</span>
<span class="line-removed">483 }</span>
484 


485 
486 #endif // ENABLE(CSS_SELECTOR_JIT)
487 
488 template &lt;typename SelectorQueryTrait&gt;
489 ALWAYS_INLINE void SelectorDataList::execute(ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
490 {
491     ContainerNode* searchRootNode = &amp;rootNode;
492     switch (m_matchType) {
493     case RightMostWithIdMatch:
494         {
495         const SelectorData&amp; selectorData = m_selectors.first();
496         if (const CSSSelector* idSelector = selectorForIdLookup(*searchRootNode, *selectorData.selector)) {
497             executeFastPathForIdSelector&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), idSelector, output);
498             break;
499         }
500 #if ENABLE(CSS_SELECTOR_JIT)
501         if (compileSelector(selectorData))
502             goto CompiledSingleCase;
503 #endif // ENABLE(CSS_SELECTOR_JIT)
504         goto SingleSelectorCase;
505         ASSERT_NOT_REACHED();
506         }
507 
508     case CompilableSingleWithRootFilter:
509     case CompilableSingle:
510         {
511 #if ENABLE(CSS_SELECTOR_JIT)
512         const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">513         ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::NotCompiled);</span>
514         ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
515         if (compileSelector(selectorData)) {
516             if (m_matchType == CompilableSingle) {
517                 m_matchType = CompiledSingle;
518                 goto CompiledSingleCase;
519             }
520             ASSERT(m_matchType == CompilableSingleWithRootFilter);
521             m_matchType = CompiledSingleWithRootFilter;
522             goto CompiledSingleWithRootFilterCase;
523         }
524 #endif // ENABLE(CSS_SELECTOR_JIT)
525         if (m_matchType == CompilableSingle) {
526             m_matchType = SingleSelector;
527             goto SingleSelectorCase;
528         }
529         ASSERT(m_matchType == CompilableSingleWithRootFilter);
530         m_matchType = SingleSelectorWithRootFilter;
531         goto SingleSelectorWithRootFilterCase;
532         ASSERT_NOT_REACHED();
533         }
534 
535 #if ENABLE(CSS_SELECTOR_JIT)
536     case CompiledSingleWithRootFilter:
537         CompiledSingleWithRootFilterCase:
538         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
539         FALLTHROUGH;
540     case CompiledSingle:
541         {
542         CompiledSingleCase:
543         const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">544         void* compiledSelectorChecker = selectorData.compiledSelectorCodeRef.code().executableAddress();</span>
<span class="line-modified">545         if (selectorData.compilationStatus == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-removed">546             SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(compiledSelectorChecker, selectorData.compilationStatus);</span>
547             executeCompiledSimpleSelectorChecker&lt;SelectorQueryTrait&gt;(*searchRootNode, selectorChecker, output, selectorData);
548         } else {
<span class="line-modified">549             ASSERT(selectorData.compilationStatus == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">550             SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(compiledSelectorChecker, selectorData.compilationStatus);</span>
551             executeCompiledSelectorCheckerWithCheckingContext&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, selectorChecker, output, selectorData);
552         }
553         break;
554         }
555 #else
556     case CompiledSingleWithRootFilter:
557     case CompiledSingle:
558         ASSERT_NOT_REACHED();
<span class="line-modified">559 #if ASSERT_DISABLED</span>
560         FALLTHROUGH;
561 #endif
562 #endif // ENABLE(CSS_SELECTOR_JIT)
563 
564     case SingleSelectorWithRootFilter:
565         SingleSelectorWithRootFilterCase:
566         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
567         FALLTHROUGH;
568     case SingleSelector:
569         SingleSelectorCase:
570         executeSingleSelectorData&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, m_selectors.first(), output);
571         break;
572 
573     case TagNameMatch:
574         executeSingleTagNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
575         break;
576     case ClassNameMatch:
577         executeSingleClassNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
578         break;
579     case CompilableMultipleSelectorMatch:
</pre>
</td>
<td>
<hr />
<pre>
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;SelectorQuery.h&quot;
 29 
 30 #include &quot;CSSParser.h&quot;
 31 #include &quot;ElementDescendantIterator.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;SelectorChecker.h&quot;
 34 #include &quot;StaticNodeList.h&quot;
 35 #include &quot;StyledElement.h&quot;
 36 
 37 namespace WebCore {
 38 
<span class="line-modified"> 39 #if ASSERT_ENABLED</span>
 40 static bool isSingleTagNameSelector(const CSSSelector&amp; selector)
 41 {
 42     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Tag;
 43 }
 44 
 45 static bool isSingleClassNameSelector(const CSSSelector&amp; selector)
 46 {
 47     return selector.isLastInTagHistory() &amp;&amp; selector.match() == CSSSelector::Class;
 48 }
<span class="line-modified"> 49 #endif // ASSERT_ENABLED</span>
 50 
 51 enum class IdMatchingType : uint8_t {
 52     None,
 53     Rightmost,
 54     Filter
 55 };
 56 
 57 static bool canBeUsedForIdFastPath(const CSSSelector&amp; selector)
 58 {
 59     return selector.match() == CSSSelector::Id
 60         || (selector.match() == CSSSelector::Exact &amp;&amp; selector.attribute() == HTMLNames::idAttr &amp;&amp; !selector.attributeValueMatchingIsCaseInsensitive());
 61 }
 62 
 63 static IdMatchingType findIdMatchingType(const CSSSelector&amp; firstSelector)
 64 {
 65     bool inRightmost = true;
 66     for (const CSSSelector* selector = &amp;firstSelector; selector; selector = selector-&gt;tagHistory()) {
 67         if (canBeUsedForIdFastPath(*selector)) {
 68             if (inRightmost)
 69                 return IdMatchingType::Rightmost;
 70             return IdMatchingType::Filter;
 71         }
 72         if (selector-&gt;relation() != CSSSelector::Subselector)
 73             inRightmost = false;
 74     }
 75     return IdMatchingType::None;
 76 }
 77 
 78 SelectorDataList::SelectorDataList(const CSSSelectorList&amp; selectorList)
 79 {
 80     unsigned selectorCount = 0;
 81     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
 82         selectorCount++;
 83 
 84     m_selectors.reserveInitialCapacity(selectorCount);
 85     for (const CSSSelector* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector))
<span class="line-modified"> 86         m_selectors.uncheckedAppend({ selector });</span>
 87 
 88     if (selectorCount == 1) {
 89         const CSSSelector&amp; selector = *m_selectors.first().selector;
 90         if (selector.isLastInTagHistory()) {
 91             switch (selector.match()) {
 92             case CSSSelector::Tag:
 93                 m_matchType = TagNameMatch;
 94                 break;
 95             case CSSSelector::Class:
 96                 m_matchType = ClassNameMatch;
 97                 break;
 98             default:
 99                 if (canBeUsedForIdFastPath(selector))
100                     m_matchType = RightMostWithIdMatch;
101                 else
102                     m_matchType = CompilableSingle;
103                 break;
104             }
105         } else {
106             switch (findIdMatchingType(selector)) {
</pre>
<hr />
<pre>
388 template &lt;typename SelectorQueryTrait&gt;
389 ALWAYS_INLINE void SelectorDataList::executeSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
390 {
391     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
392         for (auto&amp; selector : m_selectors) {
393             if (selectorMatches(selector, element, rootNode)) {
394                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
395                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
396                     return;
397                 break;
398             }
399         }
400     }
401 }
402 
403 #if ENABLE(CSS_SELECTOR_JIT)
404 template &lt;typename SelectorQueryTrait&gt;
405 ALWAYS_INLINE void SelectorDataList::executeCompiledSimpleSelectorChecker(const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSimpleSelectorChecker selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
406 {
407     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">408         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">409 </span>



410         if (selectorChecker(&amp;element)) {
411             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
412             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
413                 return;
414         }
415     }
416 }
417 
418 template &lt;typename SelectorQueryTrait&gt;
419 ALWAYS_INLINE void SelectorDataList::executeCompiledSelectorCheckerWithCheckingContext(const ContainerNode&amp; rootNode, const ContainerNode&amp; searchRootNode, SelectorCompiler::QuerySelectorSelectorCheckerWithCheckingContext selectorChecker, typename SelectorQueryTrait::OutputType&amp; output, const SelectorData&amp; selectorData) const
420 {
421     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
422     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
423 
424     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(searchRootNode))) {
<span class="line-modified">425         selectorData.compiledSelector.wasUsed();</span>
<span class="line-modified">426 </span>



427         if (selectorChecker(&amp;element, &amp;checkingContext)) {
428             SelectorQueryTrait::appendOutputForElement(output, &amp;element);
429             if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
430                 return;
431         }
432     }
433 }
434 
435 template &lt;typename SelectorQueryTrait&gt;
436 ALWAYS_INLINE void SelectorDataList::executeCompiledSingleMultiSelectorData(const ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
437 {
438     SelectorChecker::CheckingContext checkingContext(SelectorChecker::Mode::QueryingRules);
439     checkingContext.scope = rootNode.isDocumentNode() ? nullptr : &amp;rootNode;
440     for (auto&amp; element : elementDescendants(const_cast&lt;ContainerNode&amp;&gt;(rootNode))) {
441         for (auto&amp; selector : m_selectors) {
<span class="line-modified">442             selector.compiledSelector.wasUsed();</span>
<span class="line-modified">443 </span>

444             bool matched = false;
<span class="line-modified">445             if (selector.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">446                 auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selector.compiledSelector);</span>

447                 matched = selectorChecker(&amp;element);
448             } else {
<span class="line-modified">449                 ASSERT(selector.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">450                 auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selector.compiledSelector);</span>
451                 matched = selectorChecker(&amp;element, &amp;checkingContext);
452             }
453             if (matched) {
454                 SelectorQueryTrait::appendOutputForElement(output, &amp;element);
455                 if (SelectorQueryTrait::shouldOnlyMatchFirstElement)
456                     return;
457                 break;
458             }
459         }
460     }
461 }
462 





463 bool SelectorDataList::compileSelector(const SelectorData&amp; selectorData)
464 {
<span class="line-modified">465     auto&amp; compiledSelector = selectorData.compiledSelector;</span>

466 
<span class="line-modified">467     if (compiledSelector.status == SelectorCompilationStatus::NotCompiled)</span>
<span class="line-modified">468         SelectorCompiler::compileSelector(compiledSelector, selectorData.selector, SelectorCompiler::SelectorContext::QuerySelector);</span>

469 
<span class="line-added">470     return compiledSelector.status != SelectorCompilationStatus::CannotCompile;</span>
<span class="line-added">471 }</span>
472 
473 #endif // ENABLE(CSS_SELECTOR_JIT)
474 
475 template &lt;typename SelectorQueryTrait&gt;
476 ALWAYS_INLINE void SelectorDataList::execute(ContainerNode&amp; rootNode, typename SelectorQueryTrait::OutputType&amp; output) const
477 {
478     ContainerNode* searchRootNode = &amp;rootNode;
479     switch (m_matchType) {
480     case RightMostWithIdMatch:
481         {
482         const SelectorData&amp; selectorData = m_selectors.first();
483         if (const CSSSelector* idSelector = selectorForIdLookup(*searchRootNode, *selectorData.selector)) {
484             executeFastPathForIdSelector&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), idSelector, output);
485             break;
486         }
487 #if ENABLE(CSS_SELECTOR_JIT)
488         if (compileSelector(selectorData))
489             goto CompiledSingleCase;
490 #endif // ENABLE(CSS_SELECTOR_JIT)
491         goto SingleSelectorCase;
492         ASSERT_NOT_REACHED();
493         }
494 
495     case CompilableSingleWithRootFilter:
496     case CompilableSingle:
497         {
498 #if ENABLE(CSS_SELECTOR_JIT)
499         const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">500         ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::NotCompiled);</span>
501         ASSERT(m_matchType == CompilableSingle || m_matchType == CompilableSingleWithRootFilter);
502         if (compileSelector(selectorData)) {
503             if (m_matchType == CompilableSingle) {
504                 m_matchType = CompiledSingle;
505                 goto CompiledSingleCase;
506             }
507             ASSERT(m_matchType == CompilableSingleWithRootFilter);
508             m_matchType = CompiledSingleWithRootFilter;
509             goto CompiledSingleWithRootFilterCase;
510         }
511 #endif // ENABLE(CSS_SELECTOR_JIT)
512         if (m_matchType == CompilableSingle) {
513             m_matchType = SingleSelector;
514             goto SingleSelectorCase;
515         }
516         ASSERT(m_matchType == CompilableSingleWithRootFilter);
517         m_matchType = SingleSelectorWithRootFilter;
518         goto SingleSelectorWithRootFilterCase;
519         ASSERT_NOT_REACHED();
520         }
521 
522 #if ENABLE(CSS_SELECTOR_JIT)
523     case CompiledSingleWithRootFilter:
524         CompiledSingleWithRootFilterCase:
525         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
526         FALLTHROUGH;
527     case CompiledSingle:
528         {
529         CompiledSingleCase:
530         const SelectorData&amp; selectorData = m_selectors.first();
<span class="line-modified">531         if (selectorData.compiledSelector.status == SelectorCompilationStatus::SimpleSelectorChecker) {</span>
<span class="line-modified">532             auto selectorChecker = SelectorCompiler::querySelectorSimpleSelectorCheckerFunction(selectorData.compiledSelector);</span>

533             executeCompiledSimpleSelectorChecker&lt;SelectorQueryTrait&gt;(*searchRootNode, selectorChecker, output, selectorData);
534         } else {
<span class="line-modified">535             ASSERT(selectorData.compiledSelector.status == SelectorCompilationStatus::SelectorCheckerWithCheckingContext);</span>
<span class="line-modified">536             auto selectorChecker = SelectorCompiler::querySelectorSelectorCheckerFunctionWithCheckingContext(selectorData.compiledSelector);</span>
537             executeCompiledSelectorCheckerWithCheckingContext&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, selectorChecker, output, selectorData);
538         }
539         break;
540         }
541 #else
542     case CompiledSingleWithRootFilter:
543     case CompiledSingle:
544         ASSERT_NOT_REACHED();
<span class="line-modified">545 #if !ASSERT_ENABLED</span>
546         FALLTHROUGH;
547 #endif
548 #endif // ENABLE(CSS_SELECTOR_JIT)
549 
550     case SingleSelectorWithRootFilter:
551         SingleSelectorWithRootFilterCase:
552         searchRootNode = &amp;filterRootById(*searchRootNode, *m_selectors.first().selector);
553         FALLTHROUGH;
554     case SingleSelector:
555         SingleSelectorCase:
556         executeSingleSelectorData&lt;SelectorQueryTrait&gt;(rootNode, *searchRootNode, m_selectors.first(), output);
557         break;
558 
559     case TagNameMatch:
560         executeSingleTagNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
561         break;
562     case ClassNameMatch:
563         executeSingleClassNameSelectorData&lt;SelectorQueryTrait&gt;(*searchRootNode, m_selectors.first(), output);
564         break;
565     case CompilableMultipleSelectorMatch:
</pre>
</td>
</tr>
</table>
<center><a href="SecurityPolicyViolationEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorQuery.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
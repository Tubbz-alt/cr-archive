<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyFunction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAssemblyCompileErrorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyFunction.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyFunction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyFunction.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;

 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSFunctionInlines.h&quot;
 34 #include &quot;JSObject.h&quot;

 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyMemory.h&quot;
 38 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 39 #include &quot;LLIntThunks.h&quot;
 40 #include &quot;LinkBuffer.h&quot;
<span class="line-modified"> 41 #include &quot;ProtoCallFrame.h&quot;</span>
 42 #include &quot;VM.h&quot;
 43 #include &quot;WasmCallee.h&quot;
 44 #include &quot;WasmCallingConvention.h&quot;
 45 #include &quot;WasmContextInlines.h&quot;
 46 #include &quot;WasmFormat.h&quot;
 47 #include &quot;WasmMemory.h&quot;
 48 #include &quot;WasmMemoryInformation.h&quot;
 49 #include &quot;WasmModuleInformation.h&quot;
 50 #include &quot;WasmSignatureInlines.h&quot;
 51 #include &lt;wtf/FastTLS.h&gt;
 52 #include &lt;wtf/StackPointer.h&gt;
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 
 55 namespace JSC {
 56 
 57 const ClassInfo WebAssemblyFunction::s_info = { &quot;WebAssemblyFunction&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyFunction) };
 58 
<span class="line-modified"> 59 static EncodedJSValue JSC_HOST_CALL callWebAssemblyFunction(ExecState* exec)</span>
 60 {
<span class="line-modified"> 61     VM&amp; vm = exec-&gt;vm();</span>
 62     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 63     WebAssemblyFunction* wasmFunction = jsCast&lt;WebAssemblyFunction*&gt;(exec-&gt;jsCallee());</span>
 64     Wasm::SignatureIndex signatureIndex = wasmFunction-&gt;signatureIndex();
 65     const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
 66 
 67     // Make sure that the memory we think we are going to run with matches the one we expect.
 68     ASSERT(wasmFunction-&gt;instance()-&gt;instance().codeBlock()-&gt;isSafeToRun(wasmFunction-&gt;instance()-&gt;memory()-&gt;memory().mode()));
 69 
 70     Optional&lt;TraceScope&gt; traceScope;
 71     if (Options::useTracePoints())
 72         traceScope.emplace(WebAssemblyExecuteStart, WebAssemblyExecuteEnd);
 73 
 74     Vector&lt;JSValue, MarkedArgumentBuffer::inlineCapacity&gt; boxedArgs;
 75     JSWebAssemblyInstance* instance = wasmFunction-&gt;instance();
 76     Wasm::Instance* wasmInstance = &amp;instance-&gt;instance();
<span class="line-removed"> 77     // When we don&#39;t use fast TLS to store the context, the JS</span>
<span class="line-removed"> 78     // entry wrapper expects a JSWebAssemblyInstance as the first argument.</span>
<span class="line-removed"> 79     if (!Wasm::Context::useFastTLS())</span>
<span class="line-removed"> 80         boxedArgs.append(instance);</span>
 81 
 82     for (unsigned argIndex = 0; argIndex &lt; signature.argumentCount(); ++argIndex) {
<span class="line-modified"> 83         JSValue arg = exec-&gt;argument(argIndex);</span>
 84         switch (signature.argument(argIndex)) {
 85         case Wasm::I32:
<span class="line-modified"> 86             arg = JSValue::decode(arg.toInt32(exec));</span>
 87             break;
 88         case Wasm::Funcref: {
 89             if (!isWebAssemblyHostFunction(vm, arg) &amp;&amp; !arg.isNull())
<span class="line-modified"> 90                 return JSValue::encode(throwException(exec, scope, createJSWebAssemblyRuntimeError(exec, vm, &quot;Funcref must be an exported wasm function&quot;)));</span>
 91             break;
 92         }
 93         case Wasm::Anyref:
 94             break;
 95         case Wasm::I64:
 96             arg = JSValue();
 97             break;
 98         case Wasm::F32:
<span class="line-modified"> 99             arg = JSValue::decode(bitwise_cast&lt;uint32_t&gt;(arg.toFloat(exec)));</span>
100             break;
101         case Wasm::F64:
<span class="line-modified">102             arg = JSValue::decode(bitwise_cast&lt;uint64_t&gt;(arg.toNumber(exec)));</span>
103             break;
104         case Wasm::Void:
105         case Wasm::Func:
106             RELEASE_ASSERT_NOT_REACHED();
107         }
108         RETURN_IF_EXCEPTION(scope, encodedJSValue());
109         boxedArgs.append(arg);
110     }
111 
<span class="line-modified">112     JSValue firstArgument = JSValue();</span>
<span class="line-modified">113     int argCount = 1;</span>
<span class="line-modified">114     JSValue* remainingArgs = nullptr;</span>
<span class="line-modified">115     if (boxedArgs.size()) {</span>
<span class="line-modified">116         remainingArgs = boxedArgs.data();</span>
<span class="line-removed">117         firstArgument = *remainingArgs;</span>
<span class="line-removed">118         remainingArgs++;</span>
<span class="line-removed">119         argCount = boxedArgs.size();</span>
<span class="line-removed">120     }</span>
121 
122     // Note: we specifically use the WebAssemblyFunction as the callee to begin with in the ProtoCallFrame.
123     // The reason for this is that calling into the llint may stack overflow, and the stack overflow
124     // handler might read the global object from the callee.
125     ProtoCallFrame protoCallFrame;
<span class="line-modified">126     protoCallFrame.init(nullptr, wasmFunction, firstArgument, argCount, remainingArgs);</span>
127 
128     // FIXME Do away with this entire function, and only use the entrypoint generated by B3. https://bugs.webkit.org/show_bug.cgi?id=166486
129     Wasm::Instance* prevWasmInstance = vm.wasmContext.load();
130     {
131         // We do the stack check here for the wrapper function because we don&#39;t
132         // want to emit a stack check inside every wrapper function.
133         const intptr_t sp = bitwise_cast&lt;intptr_t&gt;(currentStackPointer());
134         const intptr_t frameSize = (boxedArgs.size() + CallFrame::headerSizeInRegisters) * sizeof(Register);
135         const intptr_t stackSpaceUsed = 2 * frameSize; // We&#39;re making two calls. One to the wrapper, and one to the actual wasm code.
136         if (UNLIKELY((sp &lt; stackSpaceUsed) || ((sp - stackSpaceUsed) &lt; bitwise_cast&lt;intptr_t&gt;(vm.softStackLimit()))))
<span class="line-modified">137             return JSValue::encode(throwException(exec, scope, createStackOverflowError(exec)));</span>
138     }
139     vm.wasmContext.store(wasmInstance, vm.softStackLimit());
140     ASSERT(wasmFunction-&gt;instance());
141     ASSERT(&amp;wasmFunction-&gt;instance()-&gt;instance() == vm.wasmContext.load());
142     EncodedJSValue rawResult = vmEntryToWasm(wasmFunction-&gt;jsEntrypoint(MustCheckArity).executableAddress(), &amp;vm, &amp;protoCallFrame);
143     // We need to make sure this is in a register or on the stack since it&#39;s stored in Vector&lt;JSValue&gt;.
144     // This probably isn&#39;t strictly necessary, since the WebAssemblyFunction* should keep the instance
145     // alive. But it&#39;s good hygiene.
146     instance-&gt;use();
147     if (prevWasmInstance != wasmInstance) {
148         // This is just for some extra safety instead of leaving a cached
149         // value in there. If we ever forget to set the value to be a real
150         // bounds, this will force every stack overflow check to immediately
151         // fire. The stack limit never changes while executing except when
152         // WebAssembly is used through the JSC API: API users can ask the code
153         // to migrate threads.
154         wasmInstance-&gt;setCachedStackLimit(bitwise_cast&lt;void*&gt;(std::numeric_limits&lt;uintptr_t&gt;::max()));
155     }
156     vm.wasmContext.store(prevWasmInstance, vm.softStackLimit());
157     RETURN_IF_EXCEPTION(scope, { });
158 
159     return rawResult;
160 }
161 
162 bool WebAssemblyFunction::useTagRegisters() const
163 {
164     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());
<span class="line-modified">165     return signature.argumentCount() || signature.returnType() != Wasm::Void;</span>
166 }
167 
168 RegisterSet WebAssemblyFunction::calleeSaves() const
169 {
<span class="line-modified">170     RegisterSet toSave = Wasm::PinnedRegisterInfo::get().toSave(instance()-&gt;memoryMode());</span>
<span class="line-modified">171     if (useTagRegisters()) {</span>
<span class="line-removed">172         RegisterSet tagRegisters = RegisterSet::runtimeTagRegisters();</span>
<span class="line-removed">173         // We rely on these being disjoint sets.</span>
<span class="line-removed">174 #if !ASSERT_DISABLED</span>
<span class="line-removed">175         for (Reg reg : tagRegisters)</span>
<span class="line-removed">176             ASSERT(!toSave.contains(reg));</span>
<span class="line-removed">177 #endif</span>
<span class="line-removed">178         toSave.merge(tagRegisters);</span>
<span class="line-removed">179     }</span>
<span class="line-removed">180     return toSave;</span>
181 }
182 
183 RegisterAtOffsetList WebAssemblyFunction::usedCalleeSaveRegisters() const
184 {
185     return RegisterAtOffsetList { calleeSaves(), RegisterAtOffsetList::OffsetBaseType::FramePointerBased };
186 }
187 
188 ptrdiff_t WebAssemblyFunction::previousInstanceOffset() const
189 {
190     ptrdiff_t result = calleeSaves().numberOfSetRegisters() * sizeof(CPURegister);
191     result = -result - sizeof(CPURegister);
<span class="line-modified">192 #if !ASSERT_DISABLED</span>
193     ptrdiff_t minOffset = 1;
194     for (const RegisterAtOffset&amp; regAtOffset : usedCalleeSaveRegisters()) {
195         ptrdiff_t offset = regAtOffset.offset();
196         ASSERT(offset &lt; 0);
197         minOffset = std::min(offset, minOffset);
198     }
199     ASSERT(minOffset - static_cast&lt;ptrdiff_t&gt;(sizeof(CPURegister)) == result);
200 #endif
201     return result;
202 }
203 
204 Wasm::Instance* WebAssemblyFunction::previousInstance(CallFrame* callFrame)
205 {
206     ASSERT(callFrame-&gt;callee().rawPtr() == m_jsToWasmICCallee.get());
207     auto* result = *bitwise_cast&lt;Wasm::Instance**&gt;(bitwise_cast&lt;char*&gt;(callFrame) + previousInstanceOffset());
208     return result;
209 }
210 
211 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; WebAssemblyFunction::jsCallEntrypointSlow()
212 {
213     VM&amp; vm = this-&gt;vm();
214     CCallHelpers jit;
215 
216     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());
217     const auto&amp; pinnedRegs = Wasm::PinnedRegisterInfo::get();
218     RegisterAtOffsetList registersToSpill = usedCalleeSaveRegisters();
219 
220     auto&amp; moduleInformation = instance()-&gt;instance().module().moduleInformation();
221 





222     unsigned totalFrameSize = registersToSpill.size() * sizeof(CPURegister);
223     totalFrameSize += sizeof(CPURegister); // Slot for the VM&#39;s previous wasm instance.
<span class="line-modified">224     totalFrameSize += Wasm::WasmCallingConvention::headerSizeInBytes();</span>
<span class="line-modified">225     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="line-removed">226 </span>
<span class="line-removed">227     unsigned numGPRs = 0;</span>
<span class="line-removed">228     unsigned numFPRs = 0;</span>
<span class="line-removed">229     bool argumentsIncludeI64 = false;</span>
<span class="line-removed">230     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-removed">231         switch (signature.argument(i)) {</span>
<span class="line-removed">232         case Wasm::I64:</span>
<span class="line-removed">233             argumentsIncludeI64 = true;</span>
<span class="line-removed">234             break;</span>
<span class="line-removed">235         case Wasm::Anyref:</span>
<span class="line-removed">236         case Wasm::Funcref:</span>
<span class="line-removed">237         case Wasm::I32:</span>
<span class="line-removed">238             if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size())</span>
<span class="line-removed">239                 totalFrameSize += sizeof(CPURegister);</span>
<span class="line-removed">240             ++numGPRs;</span>
<span class="line-removed">241             break;</span>
<span class="line-removed">242         case Wasm::F32:</span>
<span class="line-removed">243         case Wasm::F64:</span>
<span class="line-removed">244             if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size())</span>
<span class="line-removed">245                 totalFrameSize += sizeof(CPURegister);</span>
<span class="line-removed">246             ++numFPRs;</span>
<span class="line-removed">247             break;</span>
<span class="line-removed">248         default:</span>
<span class="line-removed">249             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">250         }</span>
<span class="line-removed">251     }</span>
252 
<span class="line-modified">253     if (argumentsIncludeI64)</span>
254         return nullptr;
255 
256     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
257 
258     jit.emitFunctionPrologue();
259     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
260     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::addressFor(CallFrameSlot::codeBlock));
261 
262     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
263         GPRReg reg = regAtOffset.reg().gpr();
264         ptrdiff_t offset = regAtOffset.offset();
265         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
266     }
267 
<span class="line-modified">268     GPRReg scratchGPR = Wasm::wasmCallingConventionAir().prologueScratch(1);</span>
269     bool stackLimitGPRIsClobbered = false;
<span class="line-modified">270     GPRReg stackLimitGPR = Wasm::wasmCallingConventionAir().prologueScratch(0);</span>
271     jit.loadPtr(vm.addressOfSoftStackLimit(), stackLimitGPR);
272 
273     CCallHelpers::JumpList slowPath;
274     slowPath.append(jit.branchPtr(CCallHelpers::Above, MacroAssembler::stackPointerRegister, GPRInfo::callFrameRegister));
275     slowPath.append(jit.branchPtr(CCallHelpers::Below, MacroAssembler::stackPointerRegister, stackLimitGPR));
276 
277     // Ensure:
278     // argCountPlusThis - 1 &gt;= signature.argumentCount()
279     // argCountPlusThis &gt;= signature.argumentCount() + 1
280     // FIXME: We should handle mismatched arity
281     // https://bugs.webkit.org/show_bug.cgi?id=196564
282     slowPath.append(jit.branch32(CCallHelpers::Below,
<span class="line-modified">283         CCallHelpers::payloadFor(CallFrameSlot::argumentCount), CCallHelpers::TrustedImm32(signature.argumentCount() + 1)));</span>
284 
285     if (useTagRegisters())
286         jit.emitMaterializeTagCheckRegisters();
287 
<span class="line-modified">288     // First we do stack slots for FPRs so we can use FPR argument registers as scratch.</span>
<span class="line-modified">289     // After that, we handle FPR argument registers.</span>
<span class="line-modified">290     // We also handle all GPR types here as we have GPR scratch registers.</span>
<span class="line-modified">291     {</span>
<span class="line-modified">292         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="line-modified">293         numGPRs = 0;</span>
<span class="line-modified">294         numFPRs = 0;</span>
<span class="line-modified">295         FPRReg scratchFPR = Wasm::wasmCallingConvention().m_fprArgs[0].fpr();</span>
<span class="line-modified">296 </span>
<span class="line-modified">297         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="line-modified">298 </span>
<span class="line-modified">299         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(CPURegister);</span>
<span class="line-modified">300         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-modified">301             switch (signature.argument(i)) {</span>
<span class="line-modified">302             case Wasm::I32:</span>
<span class="line-modified">303                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-modified">304                 slowPath.append(jit.branchIfNotInt32(scratchGPR));</span>
<span class="line-removed">305                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-removed">306                     jit.store32(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">307                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-removed">308                 } else {</span>
<span class="line-removed">309                     jit.zeroExtend32ToPtr(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">310                     ++numGPRs;</span>
<span class="line-removed">311                 }</span>
<span class="line-removed">312                 break;</span>
<span class="line-removed">313             case Wasm::Funcref: {</span>
<span class="line-removed">314                 // Ensure we have a WASM exported function.</span>
<span class="line-removed">315                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-removed">316                 auto isNull = jit.branchIfNull(scratchGPR);</span>
<span class="line-removed">317                 slowPath.append(jit.branchIfNotCell(scratchGPR));</span>
<span class="line-removed">318 </span>
<span class="line-removed">319                 stackLimitGPRIsClobbered = true;</span>
<span class="line-removed">320                 jit.emitLoadStructure(vm, scratchGPR, scratchGPR, stackLimitGPR);</span>
<span class="line-removed">321                 jit.loadPtr(CCallHelpers::Address(scratchGPR, Structure::classInfoOffset()), scratchGPR);</span>
<span class="line-removed">322 </span>
<span class="line-removed">323                 static_assert(std::is_final&lt;WebAssemblyFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-removed">324                 static_assert(std::is_final&lt;WebAssemblyWrapperFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-removed">325 </span>
<span class="line-removed">326                 auto isWasmFunction = jit.branchPtr(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyFunction::info()));</span>
<span class="line-removed">327                 slowPath.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyWrapperFunction::info())));</span>
<span class="line-removed">328 </span>
<span class="line-removed">329                 isWasmFunction.link(&amp;jit);</span>
<span class="line-removed">330                 isNull.link(&amp;jit);</span>
<span class="line-removed">331                 FALLTHROUGH;</span>
<span class="line-removed">332             }</span>
<span class="line-removed">333             case Wasm::Anyref: {</span>
<span class="line-removed">334                 jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-removed">335 </span>
<span class="line-removed">336                 if (numGPRs &gt;= Wasm::wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-removed">337                     jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">338                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-removed">339                 } else {</span>
<span class="line-removed">340                     jit.move(scratchGPR, Wasm::wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">341                     ++numGPRs;</span>
<span class="line-removed">342                 }</span>
<span class="line-removed">343                 break;</span>
<span class="line-removed">344             }</span>
<span class="line-removed">345             case Wasm::F32:</span>
<span class="line-removed">346             case Wasm::F64:</span>
<span class="line-removed">347                 if (numFPRs &gt;= Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-removed">348                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-removed">349                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="line-removed">350                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="line-removed">351                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-removed">352                         jit.unboxDouble(scratchGPR, scratchGPR, scratchFPR);</span>
<span class="line-removed">353                         jit.convertDoubleToFloat(scratchFPR, scratchFPR);</span>
<span class="line-removed">354                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">355                     } else {</span>
<span class="line-removed">356                         jit.add64(GPRInfo::tagTypeNumberRegister, scratchGPR, scratchGPR);</span>
<span class="line-removed">357                         jit.store64(scratchGPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">358                     }</span>
<span class="line-removed">359                     auto done = jit.jump();</span>
<span class="line-removed">360 </span>
<span class="line-removed">361                     isInt32.link(&amp;jit);</span>
<span class="line-removed">362                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-removed">363                         jit.convertInt32ToFloat(scratchGPR, scratchFPR);</span>
<span class="line-removed">364                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">365                     } else {</span>
<span class="line-removed">366                         jit.convertInt32ToDouble(scratchGPR, scratchFPR);</span>
<span class="line-removed">367                         jit.storeDouble(scratchFPR, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">368                     }</span>
<span class="line-removed">369                     done.link(&amp;jit);</span>
<span class="line-removed">370 </span>
<span class="line-removed">371                     wasmOffset += sizeof(CPURegister);</span>
<span class="line-removed">372                 } else</span>
<span class="line-removed">373                     ++numFPRs;</span>
<span class="line-removed">374                 break;</span>
<span class="line-removed">375             default:</span>
<span class="line-removed">376                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">377             }</span>
<span class="line-removed">378 </span>
<span class="line-removed">379             jsOffset += sizeof(EncodedJSValue);</span>
380         }
<span class="line-modified">381     }</span>




382 
<span class="line-modified">383     // Now handle FPR arguments in registers.</span>
<span class="line-modified">384     {</span>
<span class="line-modified">385         numFPRs = 0;</span>
<span class="line-modified">386         ptrdiff_t jsOffset = CallFrameSlot::firstArgument * sizeof(EncodedJSValue);</span>
<span class="line-modified">387         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-modified">388             switch (signature.argument(i)) {</span>
<span class="line-modified">389             case Wasm::F32:</span>
<span class="line-modified">390             case Wasm::F64:</span>
<span class="line-modified">391                 if (numFPRs &lt; Wasm::wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-removed">392                     FPRReg argFPR = Wasm::wasmCallingConvention().m_fprArgs[numFPRs].fpr();</span>
<span class="line-removed">393                     jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchGPR);</span>
<span class="line-removed">394                     slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="line-removed">395                     auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="line-removed">396                     jit.unboxDouble(scratchGPR, scratchGPR, argFPR);</span>
<span class="line-removed">397                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-removed">398                         jit.convertDoubleToFloat(argFPR, argFPR);</span>
<span class="line-removed">399                     auto done = jit.jump();</span>
400 
<span class="line-modified">401                     isInt32.link(&amp;jit);</span>

















402                     if (signature.argument(i) == Wasm::F32)
<span class="line-modified">403                         jit.convertInt32ToFloat(scratchGPR, argFPR);</span>
404                     else
<span class="line-modified">405                         jit.convertInt32ToDouble(scratchGPR, argFPR);</span>
<span class="line-removed">406 </span>
<span class="line-removed">407                     done.link(&amp;jit);</span>
<span class="line-removed">408                     ++numFPRs;</span>
409                 }
<span class="line-modified">410                 break;</span>
<span class="line-modified">411             default:</span>
<span class="line-modified">412                 break;</span>
















413             }

414 
<span class="line-modified">415             jsOffset += sizeof(EncodedJSValue);</span>



416         }
417     }
418 
419     // At this point, we&#39;re committed to doing a fast call.
420 
421     if (Wasm::Context::useFastTLS())
422         jit.loadWasmContextInstance(scratchGPR);
423     else
424         jit.loadPtr(vm.wasmContext.pointerToInstance(), scratchGPR);
425     ptrdiff_t previousInstanceOffset = this-&gt;previousInstanceOffset();
426     jit.storePtr(scratchGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset));
427 
428     jit.move(CCallHelpers::TrustedImmPtr(&amp;instance()-&gt;instance()), scratchGPR);
429     if (Wasm::Context::useFastTLS())
430         jit.storeWasmContextInstance(scratchGPR);
431     else {
432         jit.move(scratchGPR, pinnedRegs.wasmContextInstancePointer);
433         jit.storePtr(scratchGPR, vm.wasmContext.pointerToInstance());
434     }
435     if (stackLimitGPRIsClobbered)
</pre>
<hr />
<pre>
452 
453         jit.loadPtr(CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
454         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
455     }
456 
457     // We use this callee to indicate how to unwind past these types of frames:
458     // 1. We need to know where to get callee saves.
459     // 2. We need to know to restore the previous wasm context.
460     if (!m_jsToWasmICCallee)
461         m_jsToWasmICCallee.set(vm, this, JSToWasmICCallee::create(vm, globalObject(), this));
462     jit.storePtr(CCallHelpers::TrustedImmPtr(m_jsToWasmICCallee.get()), CCallHelpers::addressFor(CallFrameSlot::callee));
463 
464     {
465         // FIXME: Currently we just do an indirect jump. But we should teach the Module
466         // how to repatch us:
467         // https://bugs.webkit.org/show_bug.cgi?id=196570
468         jit.loadPtr(entrypointLoadLocation(), scratchGPR);
469         jit.call(scratchGPR, WasmEntryPtrTag);
470     }
471 


472     ASSERT(!RegisterSet::runtimeTagRegisters().contains(GPRInfo::nonPreservedNonReturnGPR));
473     jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset), GPRInfo::nonPreservedNonReturnGPR);
474     if (Wasm::Context::useFastTLS())
475         jit.storeWasmContextInstance(GPRInfo::nonPreservedNonReturnGPR);
476     else
477         jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, vm.wasmContext.pointerToInstance());
478 
<span class="line-removed">479     switch (signature.returnType()) {</span>
<span class="line-removed">480     case Wasm::Void:</span>
<span class="line-removed">481         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">482         break;</span>
<span class="line-removed">483     case Wasm::I32:</span>
<span class="line-removed">484         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-removed">485         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">486         break;</span>
<span class="line-removed">487     case Wasm::F32:</span>
<span class="line-removed">488         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">489         FALLTHROUGH;</span>
<span class="line-removed">490     case Wasm::F64: {</span>
<span class="line-removed">491         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">492         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="line-removed">493         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">494         isNaN.link(&amp;jit);</span>
<span class="line-removed">495         break;</span>
<span class="line-removed">496     }</span>
<span class="line-removed">497     case Wasm::Funcref:</span>
<span class="line-removed">498     case Wasm::Anyref:</span>
<span class="line-removed">499         break;</span>
<span class="line-removed">500     case Wasm::I64:</span>
<span class="line-removed">501     case Wasm::Func:</span>
<span class="line-removed">502         return nullptr;</span>
<span class="line-removed">503     default:</span>
<span class="line-removed">504         break;</span>
<span class="line-removed">505     }</span>
<span class="line-removed">506 </span>
507     auto emitRestoreCalleeSaves = [&amp;] {
508         for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
509             GPRReg reg = regAtOffset.reg().gpr();
510             ASSERT(reg != GPRInfo::returnValueGPR);
511             ptrdiff_t offset = regAtOffset.offset();
512             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
513         }
514     };
515 
516     emitRestoreCalleeSaves();
517 
518     jit.emitFunctionEpilogue();
519     jit.ret();
520 
521     slowPath.link(&amp;jit);
522     emitRestoreCalleeSaves();
523     jit.move(CCallHelpers::TrustedImmPtr(this), GPRInfo::regT0);
524     jit.emitFunctionEpilogue();
525 #if CPU(ARM64E)
526     jit.untagReturnAddress();
527 #endif
528     auto jumpToHostCallThunk = jit.jump();
529 
530     LinkBuffer linkBuffer(jit, nullptr, JITCompilationCanFail);
531     if (UNLIKELY(linkBuffer.didFailToAllocate()))
532         return nullptr;
533 
534     linkBuffer.link(jumpToHostCallThunk, CodeLocationLabel&lt;JSEntryPtrTag&gt;(executable()-&gt;entrypointFor(CodeForCall, MustCheckArity).executableAddress()));
<span class="line-modified">535     m_jsCallEntrypoint = FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;JS-&gt;Wasm IC&quot;);</span>
536     return m_jsCallEntrypoint.code();
537 }
538 
539 WebAssemblyFunction* WebAssemblyFunction::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, unsigned length, const String&amp; name, JSWebAssemblyInstance* instance, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)
540 {
541     NativeExecutable* executable = vm.getHostFunction(callWebAssemblyFunction, NoIntrinsic, callHostFunctionAsConstructor, nullptr, name);
<span class="line-modified">542     WebAssemblyFunction* function = new (NotNull, allocateCell&lt;WebAssemblyFunction&gt;(vm.heap)) WebAssemblyFunction(vm, globalObject, structure, jsEntrypoint, wasmToWasmEntrypointLoadLocation, signatureIndex);</span>
543     function-&gt;finishCreation(vm, executable, length, name, instance);
<span class="line-removed">544     ASSERT_WITH_MESSAGE(!function-&gt;isLargeAllocation(), &quot;WebAssemblyFunction should be allocated not in large allocation since it is JSCallee.&quot;);</span>
545     return function;
546 }
547 
548 Structure* WebAssemblyFunction::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
549 {
550     ASSERT(globalObject);
551     return Structure::create(vm, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), info());
552 }
553 
<span class="line-modified">554 WebAssemblyFunction::WebAssemblyFunction(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)</span>
<span class="line-modified">555     : Base { vm, globalObject, structure }</span>
556     , m_jsEntrypoint { jsEntrypoint.entrypoint() }
557     , m_importableFunction { signatureIndex, wasmToWasmEntrypointLoadLocation }
558 { }
559 
560 void WebAssemblyFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
561 {
562     WebAssemblyFunction* thisObject = jsCast&lt;WebAssemblyFunction*&gt;(cell);
563     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
564 
565     Base::visitChildren(thisObject, visitor);
566     visitor.append(thisObject-&gt;m_jsToWasmICCallee);
567 }
568 
569 void WebAssemblyFunction::destroy(JSCell* cell)
570 {
571     static_cast&lt;WebAssemblyFunction*&gt;(cell)-&gt;WebAssemblyFunction::~WebAssemblyFunction();
572 }
573 
574 } // namespace JSC
575 
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebAssemblyFunction.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
<span class="line-added"> 32 #include &quot;FrameTracers.h&quot;</span>
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSFunctionInlines.h&quot;
 35 #include &quot;JSObject.h&quot;
<span class="line-added"> 36 #include &quot;JSToWasm.h&quot;</span>
 37 #include &quot;JSWebAssemblyHelpers.h&quot;
 38 #include &quot;JSWebAssemblyInstance.h&quot;
 39 #include &quot;JSWebAssemblyMemory.h&quot;
 40 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 41 #include &quot;LLIntThunks.h&quot;
 42 #include &quot;LinkBuffer.h&quot;
<span class="line-modified"> 43 #include &quot;ProtoCallFrameInlines.h&quot;</span>
 44 #include &quot;VM.h&quot;
 45 #include &quot;WasmCallee.h&quot;
 46 #include &quot;WasmCallingConvention.h&quot;
 47 #include &quot;WasmContextInlines.h&quot;
 48 #include &quot;WasmFormat.h&quot;
 49 #include &quot;WasmMemory.h&quot;
 50 #include &quot;WasmMemoryInformation.h&quot;
 51 #include &quot;WasmModuleInformation.h&quot;
 52 #include &quot;WasmSignatureInlines.h&quot;
 53 #include &lt;wtf/FastTLS.h&gt;
 54 #include &lt;wtf/StackPointer.h&gt;
 55 #include &lt;wtf/SystemTracing.h&gt;
 56 
 57 namespace JSC {
 58 
 59 const ClassInfo WebAssemblyFunction::s_info = { &quot;WebAssemblyFunction&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WebAssemblyFunction) };
 60 
<span class="line-modified"> 61 static EncodedJSValue JSC_HOST_CALL callWebAssemblyFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 62 {
<span class="line-modified"> 63     VM&amp; vm = globalObject-&gt;vm();</span>
 64     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 65     WebAssemblyFunction* wasmFunction = jsCast&lt;WebAssemblyFunction*&gt;(callFrame-&gt;jsCallee());</span>
 66     Wasm::SignatureIndex signatureIndex = wasmFunction-&gt;signatureIndex();
 67     const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
 68 
 69     // Make sure that the memory we think we are going to run with matches the one we expect.
 70     ASSERT(wasmFunction-&gt;instance()-&gt;instance().codeBlock()-&gt;isSafeToRun(wasmFunction-&gt;instance()-&gt;memory()-&gt;memory().mode()));
 71 
 72     Optional&lt;TraceScope&gt; traceScope;
 73     if (Options::useTracePoints())
 74         traceScope.emplace(WebAssemblyExecuteStart, WebAssemblyExecuteEnd);
 75 
 76     Vector&lt;JSValue, MarkedArgumentBuffer::inlineCapacity&gt; boxedArgs;
 77     JSWebAssemblyInstance* instance = wasmFunction-&gt;instance();
 78     Wasm::Instance* wasmInstance = &amp;instance-&gt;instance();




 79 
 80     for (unsigned argIndex = 0; argIndex &lt; signature.argumentCount(); ++argIndex) {
<span class="line-modified"> 81         JSValue arg = callFrame-&gt;argument(argIndex);</span>
 82         switch (signature.argument(argIndex)) {
 83         case Wasm::I32:
<span class="line-modified"> 84             arg = JSValue::decode(arg.toInt32(globalObject));</span>
 85             break;
 86         case Wasm::Funcref: {
 87             if (!isWebAssemblyHostFunction(vm, arg) &amp;&amp; !arg.isNull())
<span class="line-modified"> 88                 return JSValue::encode(throwException(globalObject, scope, createJSWebAssemblyRuntimeError(globalObject, vm, &quot;Funcref must be an exported wasm function&quot;)));</span>
 89             break;
 90         }
 91         case Wasm::Anyref:
 92             break;
 93         case Wasm::I64:
 94             arg = JSValue();
 95             break;
 96         case Wasm::F32:
<span class="line-modified"> 97             arg = JSValue::decode(bitwise_cast&lt;uint32_t&gt;(arg.toFloat(globalObject)));</span>
 98             break;
 99         case Wasm::F64:
<span class="line-modified">100             arg = JSValue::decode(bitwise_cast&lt;uint64_t&gt;(arg.toNumber(globalObject)));</span>
101             break;
102         case Wasm::Void:
103         case Wasm::Func:
104             RELEASE_ASSERT_NOT_REACHED();
105         }
106         RETURN_IF_EXCEPTION(scope, encodedJSValue());
107         boxedArgs.append(arg);
108     }
109 
<span class="line-modified">110     // When we don&#39;t use fast TLS to store the context, the JS</span>
<span class="line-modified">111     // entry wrapper expects a JSWebAssemblyInstance as the |this| value argument.</span>
<span class="line-modified">112     JSValue context = Wasm::Context::useFastTLS() ? JSValue() : instance;</span>
<span class="line-modified">113     JSValue* args = boxedArgs.data();</span>
<span class="line-modified">114     int argCount = boxedArgs.size() + 1;</span>




115 
116     // Note: we specifically use the WebAssemblyFunction as the callee to begin with in the ProtoCallFrame.
117     // The reason for this is that calling into the llint may stack overflow, and the stack overflow
118     // handler might read the global object from the callee.
119     ProtoCallFrame protoCallFrame;
<span class="line-modified">120     protoCallFrame.init(nullptr, globalObject, wasmFunction, context, argCount, args);</span>
121 
122     // FIXME Do away with this entire function, and only use the entrypoint generated by B3. https://bugs.webkit.org/show_bug.cgi?id=166486
123     Wasm::Instance* prevWasmInstance = vm.wasmContext.load();
124     {
125         // We do the stack check here for the wrapper function because we don&#39;t
126         // want to emit a stack check inside every wrapper function.
127         const intptr_t sp = bitwise_cast&lt;intptr_t&gt;(currentStackPointer());
128         const intptr_t frameSize = (boxedArgs.size() + CallFrame::headerSizeInRegisters) * sizeof(Register);
129         const intptr_t stackSpaceUsed = 2 * frameSize; // We&#39;re making two calls. One to the wrapper, and one to the actual wasm code.
130         if (UNLIKELY((sp &lt; stackSpaceUsed) || ((sp - stackSpaceUsed) &lt; bitwise_cast&lt;intptr_t&gt;(vm.softStackLimit()))))
<span class="line-modified">131             return JSValue::encode(throwException(globalObject, scope, createStackOverflowError(globalObject)));</span>
132     }
133     vm.wasmContext.store(wasmInstance, vm.softStackLimit());
134     ASSERT(wasmFunction-&gt;instance());
135     ASSERT(&amp;wasmFunction-&gt;instance()-&gt;instance() == vm.wasmContext.load());
136     EncodedJSValue rawResult = vmEntryToWasm(wasmFunction-&gt;jsEntrypoint(MustCheckArity).executableAddress(), &amp;vm, &amp;protoCallFrame);
137     // We need to make sure this is in a register or on the stack since it&#39;s stored in Vector&lt;JSValue&gt;.
138     // This probably isn&#39;t strictly necessary, since the WebAssemblyFunction* should keep the instance
139     // alive. But it&#39;s good hygiene.
140     instance-&gt;use();
141     if (prevWasmInstance != wasmInstance) {
142         // This is just for some extra safety instead of leaving a cached
143         // value in there. If we ever forget to set the value to be a real
144         // bounds, this will force every stack overflow check to immediately
145         // fire. The stack limit never changes while executing except when
146         // WebAssembly is used through the JSC API: API users can ask the code
147         // to migrate threads.
148         wasmInstance-&gt;setCachedStackLimit(bitwise_cast&lt;void*&gt;(std::numeric_limits&lt;uintptr_t&gt;::max()));
149     }
150     vm.wasmContext.store(prevWasmInstance, vm.softStackLimit());
151     RETURN_IF_EXCEPTION(scope, { });
152 
153     return rawResult;
154 }
155 
156 bool WebAssemblyFunction::useTagRegisters() const
157 {
158     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());
<span class="line-modified">159     return signature.argumentCount() || !signature.returnsVoid();</span>
160 }
161 
162 RegisterSet WebAssemblyFunction::calleeSaves() const
163 {
<span class="line-modified">164     // Pessimistically save callee saves in BoundsChecking mode since the LLInt always bounds checks</span>
<span class="line-modified">165     return Wasm::PinnedRegisterInfo::get().toSave(Wasm::MemoryMode::BoundsChecking);</span>









166 }
167 
168 RegisterAtOffsetList WebAssemblyFunction::usedCalleeSaveRegisters() const
169 {
170     return RegisterAtOffsetList { calleeSaves(), RegisterAtOffsetList::OffsetBaseType::FramePointerBased };
171 }
172 
173 ptrdiff_t WebAssemblyFunction::previousInstanceOffset() const
174 {
175     ptrdiff_t result = calleeSaves().numberOfSetRegisters() * sizeof(CPURegister);
176     result = -result - sizeof(CPURegister);
<span class="line-modified">177 #if ASSERT_ENABLED</span>
178     ptrdiff_t minOffset = 1;
179     for (const RegisterAtOffset&amp; regAtOffset : usedCalleeSaveRegisters()) {
180         ptrdiff_t offset = regAtOffset.offset();
181         ASSERT(offset &lt; 0);
182         minOffset = std::min(offset, minOffset);
183     }
184     ASSERT(minOffset - static_cast&lt;ptrdiff_t&gt;(sizeof(CPURegister)) == result);
185 #endif
186     return result;
187 }
188 
189 Wasm::Instance* WebAssemblyFunction::previousInstance(CallFrame* callFrame)
190 {
191     ASSERT(callFrame-&gt;callee().rawPtr() == m_jsToWasmICCallee.get());
192     auto* result = *bitwise_cast&lt;Wasm::Instance**&gt;(bitwise_cast&lt;char*&gt;(callFrame) + previousInstanceOffset());
193     return result;
194 }
195 
196 MacroAssemblerCodePtr&lt;JSEntryPtrTag&gt; WebAssemblyFunction::jsCallEntrypointSlow()
197 {
198     VM&amp; vm = this-&gt;vm();
199     CCallHelpers jit;
200 
201     const auto&amp; signature = Wasm::SignatureInformation::get(signatureIndex());
202     const auto&amp; pinnedRegs = Wasm::PinnedRegisterInfo::get();
203     RegisterAtOffsetList registersToSpill = usedCalleeSaveRegisters();
204 
205     auto&amp; moduleInformation = instance()-&gt;instance().module().moduleInformation();
206 
<span class="line-added">207     const Wasm::WasmCallingConvention&amp; wasmCC = Wasm::wasmCallingConvention();</span>
<span class="line-added">208     Wasm::CallInformation wasmCallInfo = wasmCC.callInformationFor(signature);</span>
<span class="line-added">209     Wasm::CallInformation jsCallInfo = Wasm::jsCallingConvention().callInformationFor(signature, Wasm::CallRole::Callee);</span>
<span class="line-added">210     RegisterAtOffsetList savedResultRegisters = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added">211 </span>
212     unsigned totalFrameSize = registersToSpill.size() * sizeof(CPURegister);
213     totalFrameSize += sizeof(CPURegister); // Slot for the VM&#39;s previous wasm instance.
<span class="line-modified">214     totalFrameSize += wasmCallInfo.headerAndArgumentStackSizeInBytes;</span>
<span class="line-modified">215     totalFrameSize += savedResultRegisters.size() * sizeof(CPURegister);</span>


























216 
<span class="line-modified">217     if (wasmCallInfo.argumentsIncludeI64 || wasmCallInfo.resultsIncludeI64)</span>
218         return nullptr;
219 
220     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
221 
222     jit.emitFunctionPrologue();
223     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
224     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::addressFor(CallFrameSlot::codeBlock));
225 
226     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
227         GPRReg reg = regAtOffset.reg().gpr();
228         ptrdiff_t offset = regAtOffset.offset();
229         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
230     }
231 
<span class="line-modified">232     GPRReg scratchGPR = Wasm::wasmCallingConvention().prologueScratchGPRs[1];</span>
233     bool stackLimitGPRIsClobbered = false;
<span class="line-modified">234     GPRReg stackLimitGPR = Wasm::wasmCallingConvention().prologueScratchGPRs[0];</span>
235     jit.loadPtr(vm.addressOfSoftStackLimit(), stackLimitGPR);
236 
237     CCallHelpers::JumpList slowPath;
238     slowPath.append(jit.branchPtr(CCallHelpers::Above, MacroAssembler::stackPointerRegister, GPRInfo::callFrameRegister));
239     slowPath.append(jit.branchPtr(CCallHelpers::Below, MacroAssembler::stackPointerRegister, stackLimitGPR));
240 
241     // Ensure:
242     // argCountPlusThis - 1 &gt;= signature.argumentCount()
243     // argCountPlusThis &gt;= signature.argumentCount() + 1
244     // FIXME: We should handle mismatched arity
245     // https://bugs.webkit.org/show_bug.cgi?id=196564
246     slowPath.append(jit.branch32(CCallHelpers::Below,
<span class="line-modified">247         CCallHelpers::payloadFor(CallFrameSlot::argumentCountIncludingThis), CCallHelpers::TrustedImm32(signature.argumentCount() + 1)));</span>
248 
249     if (useTagRegisters())
250         jit.emitMaterializeTagCheckRegisters();
251 
<span class="line-modified">252     // Loop backwards so we can use the first floating point argument as a scratch.</span>
<span class="line-modified">253     FPRReg scratchFPR = Wasm::wasmCallingConvention().fprArgs[0].fpr();</span>
<span class="line-modified">254     for (unsigned i = signature.argumentCount(); i--;) {</span>
<span class="line-modified">255         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, 0);</span>
<span class="line-modified">256         CCallHelpers::Address jsParam(GPRInfo::callFrameRegister, jsCallInfo.params[i].offsetFromFP());</span>
<span class="line-modified">257         bool isStack = wasmCallInfo.params[i].isStackArgument();</span>
<span class="line-modified">258 </span>
<span class="line-modified">259         auto type = signature.argument(i);</span>
<span class="line-modified">260         switch (type) {</span>
<span class="line-modified">261         case Wasm::I32: {</span>
<span class="line-modified">262             jit.load64(jsParam, scratchGPR);</span>
<span class="line-modified">263             slowPath.append(jit.branchIfNotInt32(scratchGPR));</span>
<span class="line-modified">264             if (isStack)</span>
<span class="line-modified">265                 jit.store32(scratchGPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
<span class="line-modified">266             else</span>
<span class="line-modified">267                 jit.zeroExtend32ToPtr(scratchGPR, wasmCallInfo.params[i].gpr());</span>
<span class="line-modified">268             break;</span>











































































269         }
<span class="line-modified">270         case Wasm::Funcref: {</span>
<span class="line-added">271             // Ensure we have a WASM exported function.</span>
<span class="line-added">272             jit.load64(jsParam, scratchGPR);</span>
<span class="line-added">273             auto isNull = jit.branchIfNull(scratchGPR);</span>
<span class="line-added">274             slowPath.append(jit.branchIfNotCell(scratchGPR));</span>
275 
<span class="line-modified">276             stackLimitGPRIsClobbered = true;</span>
<span class="line-modified">277             jit.emitLoadStructure(vm, scratchGPR, scratchGPR, stackLimitGPR);</span>
<span class="line-modified">278             jit.loadPtr(CCallHelpers::Address(scratchGPR, Structure::classInfoOffset()), scratchGPR);</span>
<span class="line-modified">279 </span>
<span class="line-modified">280             static_assert(std::is_final&lt;WebAssemblyFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-modified">281             static_assert(std::is_final&lt;WebAssemblyWrapperFunction&gt;::value, &quot;We do not check for subtypes below&quot;);</span>
<span class="line-modified">282 </span>
<span class="line-modified">283             auto isWasmFunction = jit.branchPtr(CCallHelpers::Equal, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyFunction::info()));</span>
<span class="line-modified">284             slowPath.append(jit.branchPtr(CCallHelpers::NotEqual, scratchGPR, CCallHelpers::TrustedImmPtr(WebAssemblyWrapperFunction::info())));</span>








285 
<span class="line-modified">286             isWasmFunction.link(&amp;jit);</span>
<span class="line-added">287             isNull.link(&amp;jit);</span>
<span class="line-added">288             FALLTHROUGH;</span>
<span class="line-added">289         }</span>
<span class="line-added">290         case Wasm::Anyref: {</span>
<span class="line-added">291             if (isStack) {</span>
<span class="line-added">292                 jit.load64(jsParam, scratchGPR);</span>
<span class="line-added">293                 jit.store64(scratchGPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
<span class="line-added">294             } else</span>
<span class="line-added">295                 jit.load64(jsParam, wasmCallInfo.params[i].gpr());</span>
<span class="line-added">296             break;</span>
<span class="line-added">297         }</span>
<span class="line-added">298         case Wasm::F32:</span>
<span class="line-added">299         case Wasm::F64: {</span>
<span class="line-added">300             if (!isStack)</span>
<span class="line-added">301                 scratchFPR = wasmCallInfo.params[i].fpr();</span>
<span class="line-added">302             auto moveToDestination = [&amp;] () {</span>
<span class="line-added">303                 if (isStack) {</span>
304                     if (signature.argument(i) == Wasm::F32)
<span class="line-modified">305                         jit.storeFloat(scratchFPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>
306                     else
<span class="line-modified">307                         jit.storeDouble(scratchFPR, calleeFrame.withOffset(wasmCallInfo.params[i].offsetFromSP()));</span>



308                 }
<span class="line-modified">309             };</span>
<span class="line-modified">310 </span>
<span class="line-modified">311             jit.load64(jsParam, scratchGPR);</span>
<span class="line-added">312             slowPath.append(jit.branchIfNotNumber(scratchGPR));</span>
<span class="line-added">313             auto isInt32 = jit.branchIfInt32(scratchGPR);</span>
<span class="line-added">314 </span>
<span class="line-added">315             jit.unboxDouble(scratchGPR, scratchGPR, scratchFPR);</span>
<span class="line-added">316             if (signature.argument(i) == Wasm::F32)</span>
<span class="line-added">317                 jit.convertDoubleToFloat(scratchFPR, scratchFPR);</span>
<span class="line-added">318             moveToDestination();</span>
<span class="line-added">319             auto done = jit.jump();</span>
<span class="line-added">320 </span>
<span class="line-added">321             isInt32.link(&amp;jit);</span>
<span class="line-added">322             if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-added">323                 jit.convertInt32ToFloat(scratchGPR, scratchFPR);</span>
<span class="line-added">324                 moveToDestination();</span>
<span class="line-added">325             } else {</span>
<span class="line-added">326                 jit.convertInt32ToDouble(scratchGPR, scratchFPR);</span>
<span class="line-added">327                 moveToDestination();</span>
328             }
<span class="line-added">329             done.link(&amp;jit);</span>
330 
<span class="line-modified">331             break;</span>
<span class="line-added">332         }</span>
<span class="line-added">333         default:</span>
<span class="line-added">334             RELEASE_ASSERT_NOT_REACHED();</span>
335         }
336     }
337 
338     // At this point, we&#39;re committed to doing a fast call.
339 
340     if (Wasm::Context::useFastTLS())
341         jit.loadWasmContextInstance(scratchGPR);
342     else
343         jit.loadPtr(vm.wasmContext.pointerToInstance(), scratchGPR);
344     ptrdiff_t previousInstanceOffset = this-&gt;previousInstanceOffset();
345     jit.storePtr(scratchGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset));
346 
347     jit.move(CCallHelpers::TrustedImmPtr(&amp;instance()-&gt;instance()), scratchGPR);
348     if (Wasm::Context::useFastTLS())
349         jit.storeWasmContextInstance(scratchGPR);
350     else {
351         jit.move(scratchGPR, pinnedRegs.wasmContextInstancePointer);
352         jit.storePtr(scratchGPR, vm.wasmContext.pointerToInstance());
353     }
354     if (stackLimitGPRIsClobbered)
</pre>
<hr />
<pre>
371 
372         jit.loadPtr(CCallHelpers::Address(scratchGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
373         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
374     }
375 
376     // We use this callee to indicate how to unwind past these types of frames:
377     // 1. We need to know where to get callee saves.
378     // 2. We need to know to restore the previous wasm context.
379     if (!m_jsToWasmICCallee)
380         m_jsToWasmICCallee.set(vm, this, JSToWasmICCallee::create(vm, globalObject(), this));
381     jit.storePtr(CCallHelpers::TrustedImmPtr(m_jsToWasmICCallee.get()), CCallHelpers::addressFor(CallFrameSlot::callee));
382 
383     {
384         // FIXME: Currently we just do an indirect jump. But we should teach the Module
385         // how to repatch us:
386         // https://bugs.webkit.org/show_bug.cgi?id=196570
387         jit.loadPtr(entrypointLoadLocation(), scratchGPR);
388         jit.call(scratchGPR, WasmEntryPtrTag);
389     }
390 
<span class="line-added">391     marshallJSResult(jit, signature, wasmCallInfo, savedResultRegisters);</span>
<span class="line-added">392 </span>
393     ASSERT(!RegisterSet::runtimeTagRegisters().contains(GPRInfo::nonPreservedNonReturnGPR));
394     jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, previousInstanceOffset), GPRInfo::nonPreservedNonReturnGPR);
395     if (Wasm::Context::useFastTLS())
396         jit.storeWasmContextInstance(GPRInfo::nonPreservedNonReturnGPR);
397     else
398         jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, vm.wasmContext.pointerToInstance());
399 




























400     auto emitRestoreCalleeSaves = [&amp;] {
401         for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
402             GPRReg reg = regAtOffset.reg().gpr();
403             ASSERT(reg != GPRInfo::returnValueGPR);
404             ptrdiff_t offset = regAtOffset.offset();
405             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
406         }
407     };
408 
409     emitRestoreCalleeSaves();
410 
411     jit.emitFunctionEpilogue();
412     jit.ret();
413 
414     slowPath.link(&amp;jit);
415     emitRestoreCalleeSaves();
416     jit.move(CCallHelpers::TrustedImmPtr(this), GPRInfo::regT0);
417     jit.emitFunctionEpilogue();
418 #if CPU(ARM64E)
419     jit.untagReturnAddress();
420 #endif
421     auto jumpToHostCallThunk = jit.jump();
422 
423     LinkBuffer linkBuffer(jit, nullptr, JITCompilationCanFail);
424     if (UNLIKELY(linkBuffer.didFailToAllocate()))
425         return nullptr;
426 
427     linkBuffer.link(jumpToHostCallThunk, CodeLocationLabel&lt;JSEntryPtrTag&gt;(executable()-&gt;entrypointFor(CodeForCall, MustCheckArity).executableAddress()));
<span class="line-modified">428     m_jsCallEntrypoint = FINALIZE_WASM_CODE(linkBuffer, WasmEntryPtrTag, &quot;JS-&gt;Wasm IC&quot;);</span>
429     return m_jsCallEntrypoint.code();
430 }
431 
432 WebAssemblyFunction* WebAssemblyFunction::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure, unsigned length, const String&amp; name, JSWebAssemblyInstance* instance, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)
433 {
434     NativeExecutable* executable = vm.getHostFunction(callWebAssemblyFunction, NoIntrinsic, callHostFunctionAsConstructor, nullptr, name);
<span class="line-modified">435     WebAssemblyFunction* function = new (NotNull, allocateCell&lt;WebAssemblyFunction&gt;(vm.heap)) WebAssemblyFunction(vm, executable, globalObject, structure, jsEntrypoint, wasmToWasmEntrypointLoadLocation, signatureIndex);</span>
436     function-&gt;finishCreation(vm, executable, length, name, instance);

437     return function;
438 }
439 
440 Structure* WebAssemblyFunction::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
441 {
442     ASSERT(globalObject);
443     return Structure::create(vm, globalObject, prototype, TypeInfo(JSFunctionType, StructureFlags), info());
444 }
445 
<span class="line-modified">446 WebAssemblyFunction::WebAssemblyFunction(VM&amp; vm, NativeExecutable* executable, JSGlobalObject* globalObject, Structure* structure, Wasm::Callee&amp; jsEntrypoint, Wasm::WasmToWasmImportableFunction::LoadLocation wasmToWasmEntrypointLoadLocation, Wasm::SignatureIndex signatureIndex)</span>
<span class="line-modified">447     : Base { vm, executable, globalObject, structure }</span>
448     , m_jsEntrypoint { jsEntrypoint.entrypoint() }
449     , m_importableFunction { signatureIndex, wasmToWasmEntrypointLoadLocation }
450 { }
451 
452 void WebAssemblyFunction::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
453 {
454     WebAssemblyFunction* thisObject = jsCast&lt;WebAssemblyFunction*&gt;(cell);
455     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
456 
457     Base::visitChildren(thisObject, visitor);
458     visitor.append(thisObject-&gt;m_jsToWasmICCallee);
459 }
460 
461 void WebAssemblyFunction::destroy(JSCell* cell)
462 {
463     static_cast&lt;WebAssemblyFunction*&gt;(cell)-&gt;WebAssemblyFunction::~WebAssemblyFunction();
464 }
465 
466 } // namespace JSC
467 
</pre>
</td>
</tr>
</table>
<center><a href="WebAssemblyCompileErrorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyFunction.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
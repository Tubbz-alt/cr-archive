diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSREntry.h
@@ -31,11 +31,11 @@
 #include "Operands.h"
 #include <wtf/BitVector.h>
 
 namespace JSC {
 
-class ExecState;
+class CallFrame;
 class CodeBlock;
 
 namespace DFG {
 
 #if ENABLE(DFG_JIT)
@@ -51,11 +51,11 @@
     int fromOffset;
     int toOffset;
 };
 
 struct OSREntryData {
-    unsigned m_bytecodeIndex;
+    BytecodeIndex m_bytecodeIndex;
     CodeLocationLabel<OSREntryPtrTag> m_machineCode;
     Operands<AbstractValue> m_expectedValues;
     // Use bitvectors here because they tend to only require one word.
     BitVector m_localsForcedDouble;
     BitVector m_localsForcedAnyInt;
@@ -64,29 +64,29 @@
 
     void dumpInContext(PrintStream&, DumpContext*) const;
     void dump(PrintStream&) const;
 };
 
-inline unsigned getOSREntryDataBytecodeIndex(OSREntryData* osrEntryData)
+inline BytecodeIndex getOSREntryDataBytecodeIndex(OSREntryData* osrEntryData)
 {
     return osrEntryData->m_bytecodeIndex;
 }
 
 struct CatchEntrypointData {
     // We use this when doing OSR entry at catch. We prove the arguments
     // are of the expected type before entering at a catch block.
     MacroAssemblerCodePtr<ExceptionHandlerPtrTag> machineCode;
     Vector<FlushFormat> argumentFormats;
-    unsigned bytecodeIndex;
+    BytecodeIndex bytecodeIndex;
 };
 
 // Returns a pointer to a data buffer that the OSR entry thunk will recognize and
 // parse. If this returns null, it means
-void* prepareOSREntry(ExecState*, CodeBlock*, unsigned bytecodeIndex);
+void* prepareOSREntry(VM&, CallFrame*, CodeBlock*, BytecodeIndex);
 
 // If null is returned, we can't OSR enter. If it's not null, it's the PC to jump to.
-MacroAssemblerCodePtr<ExceptionHandlerPtrTag> prepareCatchOSREntry(ExecState*, CodeBlock*, unsigned bytecodeIndex);
+MacroAssemblerCodePtr<ExceptionHandlerPtrTag> prepareCatchOSREntry(VM&, CallFrame*, CodeBlock* baselineCodeBlock, CodeBlock* optimizedCodeBlock, BytecodeIndex);
 #else
-inline MacroAssemblerCodePtr<ExceptionHandlerPtrTag> prepareOSREntry(ExecState*, CodeBlock*, unsigned) { return nullptr; }
+inline MacroAssemblerCodePtr<ExceptionHandlerPtrTag> prepareOSREntry(VM&, CallFrame*, CodeBlock*, BytecodeIndex) { return nullptr; }
 #endif
 
 } } // namespace JSC::DFG

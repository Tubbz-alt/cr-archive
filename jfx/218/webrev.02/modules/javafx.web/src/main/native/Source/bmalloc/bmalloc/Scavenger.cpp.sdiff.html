<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Scavenger.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Scavenger.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Scavenger.h&quot;
 27 
 28 #include &quot;AllIsoHeapsInlines.h&quot;
 29 #include &quot;AvailableMemory.h&quot;
 30 #include &quot;BulkDecommit.h&quot;
 31 #include &quot;Environment.h&quot;
 32 #include &quot;Heap.h&quot;

 33 #if BOS(DARWIN)
 34 #import &lt;dispatch/dispatch.h&gt;
 35 #import &lt;mach/host_info.h&gt;
 36 #import &lt;mach/mach.h&gt;
 37 #import &lt;mach/mach_error.h&gt;
 38 #endif
 39 #include &lt;stdio.h&gt;
 40 #include &lt;thread&gt;
 41 
 42 namespace bmalloc {
 43 
 44 static constexpr bool verbose = false;
 45 
 46 struct PrintTime {
 47     PrintTime(const char* str)
 48         : string(str)
 49     { }
 50 
 51     ~PrintTime()
 52     {
 53         if (!printed)
 54             print();
 55     }
 56     void print()
 57     {
 58         if (verbose) {
 59             fprintf(stderr, &quot;%s %lfms\n&quot;, string, static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::steady_clock::now() - start).count()) / 1000);
 60             printed = true;
 61         }
 62     }
 63     const char* string;
 64     std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
 65     bool printed { false };
 66 };
 67 
 68 DEFINE_STATIC_PER_PROCESS_STORAGE(Scavenger);
 69 
<span class="line-modified"> 70 Scavenger::Scavenger(std::lock_guard&lt;Mutex&gt;&amp;)</span>
 71 {
 72     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 73 
 74 #if BOS(DARWIN)
 75     auto queue = dispatch_queue_create(&quot;WebKit Malloc Memory Pressure Handler&quot;, DISPATCH_QUEUE_SERIAL);
 76     m_pressureHandlerDispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_MEMORYPRESSURE, 0, DISPATCH_MEMORYPRESSURE_CRITICAL, queue);
 77     dispatch_source_set_event_handler(m_pressureHandlerDispatchSource, ^{
 78         scavenge();
 79     });
 80     dispatch_resume(m_pressureHandlerDispatchSource);
 81     dispatch_release(queue);
 82 #endif



 83     m_waitTime = std::chrono::milliseconds(10);

 84 
 85     m_thread = std::thread(&amp;threadEntryPoint, this);
 86 }
 87 
 88 void Scavenger::run()
 89 {
<span class="line-modified"> 90     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified"> 91     runHoldingLock();</span>
 92 }
 93 
<span class="line-modified"> 94 void Scavenger::runHoldingLock()</span>
 95 {
 96     m_state = State::Run;
 97     m_condition.notify_all();
 98 }
 99 
100 void Scavenger::runSoon()
101 {
<span class="line-modified">102     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">103     runSoonHoldingLock();</span>
104 }
105 
<span class="line-modified">106 void Scavenger::runSoonHoldingLock()</span>
107 {
108     if (willRunSoon())
109         return;
110     m_state = State::RunSoon;
111     m_condition.notify_all();
112 }
113 
114 void Scavenger::didStartGrowing()
115 {
116     // We don&#39;t really need to lock here, since this is just a heuristic.
117     m_isProbablyGrowing = true;
118 }
119 
120 void Scavenger::scheduleIfUnderMemoryPressure(size_t bytes)
121 {
<span class="line-modified">122     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">123     scheduleIfUnderMemoryPressureHoldingLock(bytes);</span>
124 }
125 
<span class="line-modified">126 void Scavenger::scheduleIfUnderMemoryPressureHoldingLock(size_t bytes)</span>
127 {
128     m_scavengerBytes += bytes;
129     if (m_scavengerBytes &lt; scavengerBytesPerMemoryPressureCheck)
130         return;
131 
132     m_scavengerBytes = 0;
133 
134     if (willRun())
135         return;
136 
137     if (!isUnderMemoryPressure())
138         return;
139 
140     m_isProbablyGrowing = false;
<span class="line-modified">141     runHoldingLock();</span>
142 }
143 
144 void Scavenger::schedule(size_t bytes)
145 {
<span class="line-modified">146     std::lock_guard&lt;Mutex&gt; lock(mutex());</span>
<span class="line-modified">147     scheduleIfUnderMemoryPressureHoldingLock(bytes);</span>
148 
149     if (willRunSoon())
150         return;
151 
152     m_isProbablyGrowing = false;
<span class="line-modified">153     runSoonHoldingLock();</span>
154 }
155 
156 inline void dumpStats()
157 {
158     auto dump = [] (auto* string, auto size) {
159         fprintf(stderr, &quot;%s %zuMB\n&quot;, string, static_cast&lt;size_t&gt;(size) / 1024 / 1024);
160     };
161 
162 #if BOS(DARWIN)
163     task_vm_info_data_t vmInfo;
164     mach_msg_type_number_t vmSize = TASK_VM_INFO_COUNT;
165     if (KERN_SUCCESS == task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&amp;vmInfo), &amp;vmSize)) {
166         dump(&quot;phys_footprint&quot;, vmInfo.phys_footprint);
167         dump(&quot;internal+compressed&quot;, vmInfo.internal + vmInfo.compressed);
168     }
169 #endif
170 
171     dump(&quot;bmalloc-freeable&quot;, Scavenger::get()-&gt;freeableMemory());
172     dump(&quot;bmalloc-footprint&quot;, Scavenger::get()-&gt;footprint());
173 }
174 
175 std::chrono::milliseconds Scavenger::timeSinceLastFullScavenge()
176 {
<span class="line-modified">177     std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
178     return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastFullScavengeTime);
179 }
180 








181 void Scavenger::enableMiniMode()
182 {
183     m_isInMiniMode = true; // We just store to this racily. The scavenger thread will eventually pick up the right value.
184     if (m_state == State::RunSoon)
185         run();
186 }
187 
188 void Scavenger::scavenge()
189 {
<span class="line-modified">190     std::unique_lock&lt;Mutex&gt; lock(m_scavengingMutex);</span>
191 
192     if (verbose) {
193         fprintf(stderr, &quot;--------------------------------\n&quot;);
194         fprintf(stderr, &quot;--before scavenging--\n&quot;);
195         dumpStats();
196     }
197 
198     {
199         BulkDecommit decommitter;
200 
201         {
202             PrintTime printTime(&quot;\nfull scavenge under lock time&quot;);

203             size_t deferredDecommits = 0;
<span class="line-modified">204             std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>

205             for (unsigned i = numHeaps; i--;) {
206                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
207                     continue;



208                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter, deferredDecommits);

209             }
210             decommitter.processEager();
211 

212             if (deferredDecommits)
213                 m_state = State::RunSoon;

214         }
215 
216         {
217             PrintTime printTime(&quot;full scavenge lazy decommit time&quot;);
218             decommitter.processLazy();
219         }
220 
221         {
222             PrintTime printTime(&quot;full scavenge mark all as eligible time&quot;);
<span class="line-modified">223             std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>
224             for (unsigned i = numHeaps; i--;) {
225                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
226                     continue;
227                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).markAllLargeAsEligibile(lock);
228             }
229         }
230     }
231 
232     {
233         RELEASE_BASSERT(!m_deferredDecommits.size());
234         AllIsoHeaps::get()-&gt;forEach(
235             [&amp;] (IsoHeapImplBase&amp; heap) {
236                 heap.scavenge(m_deferredDecommits);
237             });
238         IsoHeapImplBase::finishScavenging(m_deferredDecommits);
239         m_deferredDecommits.shrink(0);
240     }
241 
242     if (verbose) {
243         fprintf(stderr, &quot;--after scavenging--\n&quot;);
244         dumpStats();
245         fprintf(stderr, &quot;--------------------------------\n&quot;);
246     }
247 
248     {
<span class="line-modified">249         std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
250         m_lastFullScavengeTime = std::chrono::steady_clock::now();
251     }
252 }
253 





































































254 size_t Scavenger::freeableMemory()
255 {
256     size_t result = 0;
257     {
<span class="line-modified">258         std::lock_guard&lt;Mutex&gt; lock(Heap::mutex());</span>
259         for (unsigned i = numHeaps; i--;) {
260             if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
261                 continue;
262             result += PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).freeableMemory(lock);
263         }
264     }
265 
266     AllIsoHeaps::get()-&gt;forEach(
267         [&amp;] (IsoHeapImplBase&amp; heap) {
268             result += heap.freeableMemory();
269         });
270 
271     return result;
272 }
273 
274 size_t Scavenger::footprint()
275 {
276     RELEASE_BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
277 
278     size_t result = 0;
</pre>
<hr />
<pre>
295     scavenger-&gt;threadRunLoop();
296 }
297 
298 void Scavenger::threadRunLoop()
299 {
300     setSelfQOSClass();
301 #if BOS(DARWIN)
302     setThreadName(&quot;JavaScriptCore bmalloc scavenger&quot;);
303 #else
304     setThreadName(&quot;BMScavenger&quot;);
305 #endif
306 
307     // This loop ratchets downward from most active to least active state. While
308     // we ratchet downward, any other thread may reset our state.
309 
310     // We require any state change while we are sleeping to signal to our
311     // condition variable and wake us up.
312 
313     while (true) {
314         if (m_state == State::Sleep) {
<span class="line-modified">315             std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
316             m_condition.wait(lock, [&amp;]() { return m_state != State::Sleep; });
317         }
318 
319         if (m_state == State::RunSoon) {
<span class="line-modified">320             std::unique_lock&lt;Mutex&gt; lock(mutex());</span>
321             m_condition.wait_for(lock, m_waitTime, [&amp;]() { return m_state != State::RunSoon; });
322         }
323 
324         m_state = State::Sleep;
325 
326         setSelfQOSClass();
327 
328         if (verbose) {
329             fprintf(stderr, &quot;--------------------------------\n&quot;);
330             fprintf(stderr, &quot;considering running scavenger\n&quot;);
331             dumpStats();
332             fprintf(stderr, &quot;--------------------------------\n&quot;);
333         }
334 































































335         std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
336 
337         scavenge();
338 
339         auto timeSpentScavenging = std::chrono::steady_clock::now() - start;
340 
341         if (verbose) {
342             fprintf(stderr, &quot;time spent scavenging %lfms\n&quot;,
343                 static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(timeSpentScavenging).count()) / 1000);
344         }
345 
<span class="line-modified">346         std::chrono::milliseconds newWaitTime;</span>
<span class="line-modified">347 </span>
<span class="line-modified">348         if (m_isInMiniMode) {</span>
<span class="line-removed">349             timeSpentScavenging *= 50;</span>
<span class="line-removed">350             newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
<span class="line-removed">351             newWaitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(25)), std::chrono::milliseconds(500));</span>
<span class="line-removed">352         } else {</span>
353             timeSpentScavenging *= 150;
<span class="line-modified">354             newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
355             m_waitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(100)), std::chrono::milliseconds(10000));
356         }
357 
358         if (verbose)
359             fprintf(stderr, &quot;new wait time %lldms\n&quot;, static_cast&lt;long long int&gt;(m_waitTime.count()));

360     }
361 }
362 
363 void Scavenger::setThreadName(const char* name)
364 {
365     BUNUSED(name);
366 #if BOS(DARWIN)
367     pthread_setname_np(name);
368 #elif BOS(LINUX)
369     // Truncate the given name since Linux limits the size of the thread name 16 including null terminator.
370     std::array&lt;char, 16&gt; buf;
371     strncpy(buf.data(), name, buf.size() - 1);
372     buf[buf.size() - 1] = &#39;\0&#39;;
373     pthread_setname_np(pthread_self(), buf.data());
374 #endif
375 }
376 
377 void Scavenger::setSelfQOSClass()
378 {
379 #if BOS(DARWIN)
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;Scavenger.h&quot;
 27 
 28 #include &quot;AllIsoHeapsInlines.h&quot;
 29 #include &quot;AvailableMemory.h&quot;
 30 #include &quot;BulkDecommit.h&quot;
 31 #include &quot;Environment.h&quot;
 32 #include &quot;Heap.h&quot;
<span class="line-added"> 33 #include &quot;IsoHeapImplInlines.h&quot;</span>
 34 #if BOS(DARWIN)
 35 #import &lt;dispatch/dispatch.h&gt;
 36 #import &lt;mach/host_info.h&gt;
 37 #import &lt;mach/mach.h&gt;
 38 #import &lt;mach/mach_error.h&gt;
 39 #endif
 40 #include &lt;stdio.h&gt;
 41 #include &lt;thread&gt;
 42 
 43 namespace bmalloc {
 44 
 45 static constexpr bool verbose = false;
 46 
 47 struct PrintTime {
 48     PrintTime(const char* str)
 49         : string(str)
 50     { }
 51 
 52     ~PrintTime()
 53     {
 54         if (!printed)
 55             print();
 56     }
 57     void print()
 58     {
 59         if (verbose) {
 60             fprintf(stderr, &quot;%s %lfms\n&quot;, string, static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(std::chrono::steady_clock::now() - start).count()) / 1000);
 61             printed = true;
 62         }
 63     }
 64     const char* string;
 65     std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
 66     bool printed { false };
 67 };
 68 
 69 DEFINE_STATIC_PER_PROCESS_STORAGE(Scavenger);
 70 
<span class="line-modified"> 71 Scavenger::Scavenger(const LockHolder&amp;)</span>
 72 {
 73     BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
 74 
 75 #if BOS(DARWIN)
 76     auto queue = dispatch_queue_create(&quot;WebKit Malloc Memory Pressure Handler&quot;, DISPATCH_QUEUE_SERIAL);
 77     m_pressureHandlerDispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_MEMORYPRESSURE, 0, DISPATCH_MEMORYPRESSURE_CRITICAL, queue);
 78     dispatch_source_set_event_handler(m_pressureHandlerDispatchSource, ^{
 79         scavenge();
 80     });
 81     dispatch_resume(m_pressureHandlerDispatchSource);
 82     dispatch_release(queue);
 83 #endif
<span class="line-added"> 84 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added"> 85     m_waitTime = std::chrono::milliseconds(m_isInMiniMode ? 200 : 2000);</span>
<span class="line-added"> 86 #else</span>
 87     m_waitTime = std::chrono::milliseconds(10);
<span class="line-added"> 88 #endif</span>
 89 
 90     m_thread = std::thread(&amp;threadEntryPoint, this);
 91 }
 92 
 93 void Scavenger::run()
 94 {
<span class="line-modified"> 95     LockHolder lock(mutex());</span>
<span class="line-modified"> 96     run(lock);</span>
 97 }
 98 
<span class="line-modified"> 99 void Scavenger::run(const LockHolder&amp;)</span>
100 {
101     m_state = State::Run;
102     m_condition.notify_all();
103 }
104 
105 void Scavenger::runSoon()
106 {
<span class="line-modified">107     LockHolder lock(mutex());</span>
<span class="line-modified">108     runSoon(lock);</span>
109 }
110 
<span class="line-modified">111 void Scavenger::runSoon(const LockHolder&amp;)</span>
112 {
113     if (willRunSoon())
114         return;
115     m_state = State::RunSoon;
116     m_condition.notify_all();
117 }
118 
119 void Scavenger::didStartGrowing()
120 {
121     // We don&#39;t really need to lock here, since this is just a heuristic.
122     m_isProbablyGrowing = true;
123 }
124 
125 void Scavenger::scheduleIfUnderMemoryPressure(size_t bytes)
126 {
<span class="line-modified">127     LockHolder lock(mutex());</span>
<span class="line-modified">128     scheduleIfUnderMemoryPressure(lock, bytes);</span>
129 }
130 
<span class="line-modified">131 void Scavenger::scheduleIfUnderMemoryPressure(const LockHolder&amp; lock, size_t bytes)</span>
132 {
133     m_scavengerBytes += bytes;
134     if (m_scavengerBytes &lt; scavengerBytesPerMemoryPressureCheck)
135         return;
136 
137     m_scavengerBytes = 0;
138 
139     if (willRun())
140         return;
141 
142     if (!isUnderMemoryPressure())
143         return;
144 
145     m_isProbablyGrowing = false;
<span class="line-modified">146     run(lock);</span>
147 }
148 
149 void Scavenger::schedule(size_t bytes)
150 {
<span class="line-modified">151     LockHolder lock(mutex());</span>
<span class="line-modified">152     scheduleIfUnderMemoryPressure(lock, bytes);</span>
153 
154     if (willRunSoon())
155         return;
156 
157     m_isProbablyGrowing = false;
<span class="line-modified">158     runSoon(lock);</span>
159 }
160 
161 inline void dumpStats()
162 {
163     auto dump = [] (auto* string, auto size) {
164         fprintf(stderr, &quot;%s %zuMB\n&quot;, string, static_cast&lt;size_t&gt;(size) / 1024 / 1024);
165     };
166 
167 #if BOS(DARWIN)
168     task_vm_info_data_t vmInfo;
169     mach_msg_type_number_t vmSize = TASK_VM_INFO_COUNT;
170     if (KERN_SUCCESS == task_info(mach_task_self(), TASK_VM_INFO, (task_info_t)(&amp;vmInfo), &amp;vmSize)) {
171         dump(&quot;phys_footprint&quot;, vmInfo.phys_footprint);
172         dump(&quot;internal+compressed&quot;, vmInfo.internal + vmInfo.compressed);
173     }
174 #endif
175 
176     dump(&quot;bmalloc-freeable&quot;, Scavenger::get()-&gt;freeableMemory());
177     dump(&quot;bmalloc-footprint&quot;, Scavenger::get()-&gt;footprint());
178 }
179 
180 std::chrono::milliseconds Scavenger::timeSinceLastFullScavenge()
181 {
<span class="line-modified">182     UniqueLockHolder lock(mutex());</span>
183     return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastFullScavengeTime);
184 }
185 
<span class="line-added">186 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">187 std::chrono::milliseconds Scavenger::timeSinceLastPartialScavenge()</span>
<span class="line-added">188 {</span>
<span class="line-added">189     UniqueLockHolder lock(mutex());</span>
<span class="line-added">190     return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::steady_clock::now() - m_lastPartialScavengeTime);</span>
<span class="line-added">191 }</span>
<span class="line-added">192 #endif</span>
<span class="line-added">193 </span>
194 void Scavenger::enableMiniMode()
195 {
196     m_isInMiniMode = true; // We just store to this racily. The scavenger thread will eventually pick up the right value.
197     if (m_state == State::RunSoon)
198         run();
199 }
200 
201 void Scavenger::scavenge()
202 {
<span class="line-modified">203     UniqueLockHolder lock(m_scavengingMutex);</span>
204 
205     if (verbose) {
206         fprintf(stderr, &quot;--------------------------------\n&quot;);
207         fprintf(stderr, &quot;--before scavenging--\n&quot;);
208         dumpStats();
209     }
210 
211     {
212         BulkDecommit decommitter;
213 
214         {
215             PrintTime printTime(&quot;\nfull scavenge under lock time&quot;);
<span class="line-added">216 #if !BUSE(PARTIAL_SCAVENGE)</span>
217             size_t deferredDecommits = 0;
<span class="line-modified">218 #endif</span>
<span class="line-added">219             LockHolder lock(Heap::mutex());</span>
220             for (unsigned i = numHeaps; i--;) {
221                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
222                     continue;
<span class="line-added">223 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">224                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter);</span>
<span class="line-added">225 #else</span>
226                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).scavenge(lock, decommitter, deferredDecommits);
<span class="line-added">227 #endif</span>
228             }
229             decommitter.processEager();
230 
<span class="line-added">231 #if !BUSE(PARTIAL_SCAVENGE)</span>
232             if (deferredDecommits)
233                 m_state = State::RunSoon;
<span class="line-added">234 #endif</span>
235         }
236 
237         {
238             PrintTime printTime(&quot;full scavenge lazy decommit time&quot;);
239             decommitter.processLazy();
240         }
241 
242         {
243             PrintTime printTime(&quot;full scavenge mark all as eligible time&quot;);
<span class="line-modified">244             LockHolder lock(Heap::mutex());</span>
245             for (unsigned i = numHeaps; i--;) {
246                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
247                     continue;
248                 PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).markAllLargeAsEligibile(lock);
249             }
250         }
251     }
252 
253     {
254         RELEASE_BASSERT(!m_deferredDecommits.size());
255         AllIsoHeaps::get()-&gt;forEach(
256             [&amp;] (IsoHeapImplBase&amp; heap) {
257                 heap.scavenge(m_deferredDecommits);
258             });
259         IsoHeapImplBase::finishScavenging(m_deferredDecommits);
260         m_deferredDecommits.shrink(0);
261     }
262 
263     if (verbose) {
264         fprintf(stderr, &quot;--after scavenging--\n&quot;);
265         dumpStats();
266         fprintf(stderr, &quot;--------------------------------\n&quot;);
267     }
268 
269     {
<span class="line-modified">270         UniqueLockHolder lock(mutex());</span>
271         m_lastFullScavengeTime = std::chrono::steady_clock::now();
272     }
273 }
274 
<span class="line-added">275 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">276 void Scavenger::partialScavenge()</span>
<span class="line-added">277 {</span>
<span class="line-added">278     UniqueLockHolder lock(m_scavengingMutex);</span>
<span class="line-added">279 </span>
<span class="line-added">280     if (verbose) {</span>
<span class="line-added">281         fprintf(stderr, &quot;--------------------------------\n&quot;);</span>
<span class="line-added">282         fprintf(stderr, &quot;--before partial scavenging--\n&quot;);</span>
<span class="line-added">283         dumpStats();</span>
<span class="line-added">284     }</span>
<span class="line-added">285 </span>
<span class="line-added">286     {</span>
<span class="line-added">287         BulkDecommit decommitter;</span>
<span class="line-added">288         {</span>
<span class="line-added">289             PrintTime printTime(&quot;\npartialScavenge under lock time&quot;);</span>
<span class="line-added">290             LockHolder lock(Heap::mutex());</span>
<span class="line-added">291             for (unsigned i = numHeaps; i--;) {</span>
<span class="line-added">292                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))</span>
<span class="line-added">293                     continue;</span>
<span class="line-added">294                 Heap&amp; heap = PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i);</span>
<span class="line-added">295                 size_t freeableMemory = heap.freeableMemory(lock);</span>
<span class="line-added">296                 if (freeableMemory &lt; 4 * MB)</span>
<span class="line-added">297                     continue;</span>
<span class="line-added">298                 heap.scavengeToHighWatermark(lock, decommitter);</span>
<span class="line-added">299             }</span>
<span class="line-added">300 </span>
<span class="line-added">301             decommitter.processEager();</span>
<span class="line-added">302         }</span>
<span class="line-added">303 </span>
<span class="line-added">304         {</span>
<span class="line-added">305             PrintTime printTime(&quot;partialScavenge lazy decommit time&quot;);</span>
<span class="line-added">306             decommitter.processLazy();</span>
<span class="line-added">307         }</span>
<span class="line-added">308 </span>
<span class="line-added">309         {</span>
<span class="line-added">310             PrintTime printTime(&quot;partialScavenge mark all as eligible time&quot;);</span>
<span class="line-added">311             LockHolder lock(Heap::mutex());</span>
<span class="line-added">312             for (unsigned i = numHeaps; i--;) {</span>
<span class="line-added">313                 if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))</span>
<span class="line-added">314                     continue;</span>
<span class="line-added">315                 Heap&amp; heap = PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i);</span>
<span class="line-added">316                 heap.markAllLargeAsEligibile(lock);</span>
<span class="line-added">317             }</span>
<span class="line-added">318         }</span>
<span class="line-added">319     }</span>
<span class="line-added">320 </span>
<span class="line-added">321     {</span>
<span class="line-added">322         RELEASE_BASSERT(!m_deferredDecommits.size());</span>
<span class="line-added">323         AllIsoHeaps::get()-&gt;forEach(</span>
<span class="line-added">324             [&amp;] (IsoHeapImplBase&amp; heap) {</span>
<span class="line-added">325                 heap.scavengeToHighWatermark(m_deferredDecommits);</span>
<span class="line-added">326             });</span>
<span class="line-added">327         IsoHeapImplBase::finishScavenging(m_deferredDecommits);</span>
<span class="line-added">328         m_deferredDecommits.shrink(0);</span>
<span class="line-added">329     }</span>
<span class="line-added">330 </span>
<span class="line-added">331     if (verbose) {</span>
<span class="line-added">332         fprintf(stderr, &quot;--after partial scavenging--\n&quot;);</span>
<span class="line-added">333         dumpStats();</span>
<span class="line-added">334         fprintf(stderr, &quot;--------------------------------\n&quot;);</span>
<span class="line-added">335     }</span>
<span class="line-added">336 </span>
<span class="line-added">337     {</span>
<span class="line-added">338         UniqueLockHolder lock(mutex());</span>
<span class="line-added">339         m_lastPartialScavengeTime = std::chrono::steady_clock::now();</span>
<span class="line-added">340     }</span>
<span class="line-added">341 }</span>
<span class="line-added">342 #endif</span>
<span class="line-added">343 </span>
344 size_t Scavenger::freeableMemory()
345 {
346     size_t result = 0;
347     {
<span class="line-modified">348         LockHolder lock(Heap::mutex());</span>
349         for (unsigned i = numHeaps; i--;) {
350             if (!isActiveHeapKind(static_cast&lt;HeapKind&gt;(i)))
351                 continue;
352             result += PerProcess&lt;PerHeapKind&lt;Heap&gt;&gt;::get()-&gt;at(i).freeableMemory(lock);
353         }
354     }
355 
356     AllIsoHeaps::get()-&gt;forEach(
357         [&amp;] (IsoHeapImplBase&amp; heap) {
358             result += heap.freeableMemory();
359         });
360 
361     return result;
362 }
363 
364 size_t Scavenger::footprint()
365 {
366     RELEASE_BASSERT(!Environment::get()-&gt;isDebugHeapEnabled());
367 
368     size_t result = 0;
</pre>
<hr />
<pre>
385     scavenger-&gt;threadRunLoop();
386 }
387 
388 void Scavenger::threadRunLoop()
389 {
390     setSelfQOSClass();
391 #if BOS(DARWIN)
392     setThreadName(&quot;JavaScriptCore bmalloc scavenger&quot;);
393 #else
394     setThreadName(&quot;BMScavenger&quot;);
395 #endif
396 
397     // This loop ratchets downward from most active to least active state. While
398     // we ratchet downward, any other thread may reset our state.
399 
400     // We require any state change while we are sleeping to signal to our
401     // condition variable and wake us up.
402 
403     while (true) {
404         if (m_state == State::Sleep) {
<span class="line-modified">405             UniqueLockHolder lock(mutex());</span>
406             m_condition.wait(lock, [&amp;]() { return m_state != State::Sleep; });
407         }
408 
409         if (m_state == State::RunSoon) {
<span class="line-modified">410             UniqueLockHolder lock(mutex());</span>
411             m_condition.wait_for(lock, m_waitTime, [&amp;]() { return m_state != State::RunSoon; });
412         }
413 
414         m_state = State::Sleep;
415 
416         setSelfQOSClass();
417 
418         if (verbose) {
419             fprintf(stderr, &quot;--------------------------------\n&quot;);
420             fprintf(stderr, &quot;considering running scavenger\n&quot;);
421             dumpStats();
422             fprintf(stderr, &quot;--------------------------------\n&quot;);
423         }
424 
<span class="line-added">425 #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="line-added">426         enum class ScavengeMode {</span>
<span class="line-added">427             None,</span>
<span class="line-added">428             Partial,</span>
<span class="line-added">429             Full</span>
<span class="line-added">430         };</span>
<span class="line-added">431 </span>
<span class="line-added">432         size_t freeableMemory = this-&gt;freeableMemory();</span>
<span class="line-added">433 </span>
<span class="line-added">434         ScavengeMode scavengeMode = [&amp;] {</span>
<span class="line-added">435             auto timeSinceLastFullScavenge = this-&gt;timeSinceLastFullScavenge();</span>
<span class="line-added">436             auto timeSinceLastPartialScavenge = this-&gt;timeSinceLastPartialScavenge();</span>
<span class="line-added">437             auto timeSinceLastScavenge = std::min(timeSinceLastPartialScavenge, timeSinceLastFullScavenge);</span>
<span class="line-added">438 </span>
<span class="line-added">439             if (isUnderMemoryPressure() &amp;&amp; freeableMemory &gt; 1 * MB &amp;&amp; timeSinceLastScavenge &gt; std::chrono::milliseconds(5))</span>
<span class="line-added">440                 return ScavengeMode::Full;</span>
<span class="line-added">441 </span>
<span class="line-added">442             if (!m_isProbablyGrowing) {</span>
<span class="line-added">443                 if (timeSinceLastFullScavenge &lt; std::chrono::milliseconds(1000) &amp;&amp; !m_isInMiniMode)</span>
<span class="line-added">444                     return ScavengeMode::Partial;</span>
<span class="line-added">445                 return ScavengeMode::Full;</span>
<span class="line-added">446             }</span>
<span class="line-added">447 </span>
<span class="line-added">448             if (m_isInMiniMode) {</span>
<span class="line-added">449                 if (timeSinceLastFullScavenge &lt; std::chrono::milliseconds(200))</span>
<span class="line-added">450                     return ScavengeMode::Partial;</span>
<span class="line-added">451                 return ScavengeMode::Full;</span>
<span class="line-added">452             }</span>
<span class="line-added">453 </span>
<span class="line-added">454 #if BCPU(X86_64)</span>
<span class="line-added">455             auto partialScavengeInterval = std::chrono::milliseconds(12000);</span>
<span class="line-added">456 #else</span>
<span class="line-added">457             auto partialScavengeInterval = std::chrono::milliseconds(8000);</span>
<span class="line-added">458 #endif</span>
<span class="line-added">459             if (timeSinceLastScavenge &lt; partialScavengeInterval) {</span>
<span class="line-added">460                 // Rate limit partial scavenges.</span>
<span class="line-added">461                 return ScavengeMode::None;</span>
<span class="line-added">462             }</span>
<span class="line-added">463             if (freeableMemory &lt; 25 * MB)</span>
<span class="line-added">464                 return ScavengeMode::None;</span>
<span class="line-added">465             if (5 * freeableMemory &lt; footprint())</span>
<span class="line-added">466                 return ScavengeMode::None;</span>
<span class="line-added">467             return ScavengeMode::Partial;</span>
<span class="line-added">468         }();</span>
<span class="line-added">469 </span>
<span class="line-added">470         m_isProbablyGrowing = false;</span>
<span class="line-added">471 </span>
<span class="line-added">472         switch (scavengeMode) {</span>
<span class="line-added">473         case ScavengeMode::None: {</span>
<span class="line-added">474             runSoon();</span>
<span class="line-added">475             break;</span>
<span class="line-added">476         }</span>
<span class="line-added">477         case ScavengeMode::Partial: {</span>
<span class="line-added">478             partialScavenge();</span>
<span class="line-added">479             runSoon();</span>
<span class="line-added">480             break;</span>
<span class="line-added">481         }</span>
<span class="line-added">482         case ScavengeMode::Full: {</span>
<span class="line-added">483             scavenge();</span>
<span class="line-added">484             break;</span>
<span class="line-added">485         }</span>
<span class="line-added">486         }</span>
<span class="line-added">487 #else</span>
488         std::chrono::steady_clock::time_point start { std::chrono::steady_clock::now() };
489 
490         scavenge();
491 
492         auto timeSpentScavenging = std::chrono::steady_clock::now() - start;
493 
494         if (verbose) {
495             fprintf(stderr, &quot;time spent scavenging %lfms\n&quot;,
496                 static_cast&lt;double&gt;(std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(timeSpentScavenging).count()) / 1000);
497         }
498 
<span class="line-modified">499         // FIXME: We need to investigate mini-mode&#39;s adjustment.</span>
<span class="line-modified">500         // https://bugs.webkit.org/show_bug.cgi?id=203987</span>
<span class="line-modified">501         if (!m_isInMiniMode) {</span>




502             timeSpentScavenging *= 150;
<span class="line-modified">503             std::chrono::milliseconds newWaitTime = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeSpentScavenging);</span>
504             m_waitTime = std::min(std::max(newWaitTime, std::chrono::milliseconds(100)), std::chrono::milliseconds(10000));
505         }
506 
507         if (verbose)
508             fprintf(stderr, &quot;new wait time %lldms\n&quot;, static_cast&lt;long long int&gt;(m_waitTime.count()));
<span class="line-added">509 #endif</span>
510     }
511 }
512 
513 void Scavenger::setThreadName(const char* name)
514 {
515     BUNUSED(name);
516 #if BOS(DARWIN)
517     pthread_setname_np(name);
518 #elif BOS(LINUX)
519     // Truncate the given name since Linux limits the size of the thread name 16 including null terminator.
520     std::array&lt;char, 16&gt; buf;
521     strncpy(buf.data(), name, buf.size() - 1);
522     buf[buf.size() - 1] = &#39;\0&#39;;
523     pthread_setname_np(pthread_self(), buf.data());
524 #endif
525 }
526 
527 void Scavenger::setSelfQOSClass()
528 {
529 #if BOS(DARWIN)
</pre>
</td>
</tr>
</table>
<center><a href="PerThread.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Scavenger.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
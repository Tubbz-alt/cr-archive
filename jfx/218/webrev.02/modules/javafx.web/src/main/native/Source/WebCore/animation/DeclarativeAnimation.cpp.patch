diff a/modules/javafx.web/src/main/native/Source/WebCore/animation/DeclarativeAnimation.cpp b/modules/javafx.web/src/main/native/Source/WebCore/animation/DeclarativeAnimation.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/animation/DeclarativeAnimation.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/animation/DeclarativeAnimation.cpp
@@ -33,29 +33,32 @@
 #include "DocumentTimeline.h"
 #include "Element.h"
 #include "EventNames.h"
 #include "KeyframeEffect.h"
 #include "PseudoElement.h"
-#include "TransitionEvent.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(DeclarativeAnimation);
 
 DeclarativeAnimation::DeclarativeAnimation(Element& owningElement, const Animation& backingAnimation)
     : WebAnimation(owningElement.document())
-    , m_eventQueue(owningElement)
-    , m_owningElement(&owningElement)
+    , m_owningElement(makeWeakPtr(owningElement))
     , m_backingAnimation(const_cast<Animation&>(backingAnimation))
 {
 }
 
 DeclarativeAnimation::~DeclarativeAnimation()
 {
 }
 
+Element* DeclarativeAnimation::owningElement() const
+{
+    return m_owningElement.get();
+}
+
 void DeclarativeAnimation::tick()
 {
     bool wasRelevant = isRelevant();
 
     WebAnimation::tick();
@@ -63,14 +66,23 @@
 
     // If a declarative animation transitions from a non-idle state to an idle state, it means it was
     // canceled using the Web Animations API and it should be disassociated from its owner element.
     // From this point on, this animation is like any other animation and should not appear in the
     // maps containing running CSS Transitions and CSS Animations for a given element.
-    if (wasRelevant && playState() == WebAnimation::PlayState::Idle) {
+    if (wasRelevant && playState() == WebAnimation::PlayState::Idle)
         disassociateFromOwningElement();
-        m_eventQueue.close();
-    }
+}
+
+bool DeclarativeAnimation::canHaveGlobalPosition()
+{
+    // https://drafts.csswg.org/css-animations-2/#animation-composite-order
+    // https://drafts.csswg.org/css-transitions-2/#animation-composite-order
+    // CSS Animations and CSS Transitions generated using the markup defined in this specification are not added
+    // to the global animation list when they are created. Instead, these animations are appended to the global
+    // animation list at the first moment when they transition out of the idle play state after being disassociated
+    // from their owning element.
+    return !m_owningElement && playState() != WebAnimation::PlayState::Idle;
 }
 
 void DeclarativeAnimation::disassociateFromOwningElement()
 {
     if (!m_owningElement)
@@ -79,21 +91,10 @@
     if (auto* animationTimeline = timeline())
         animationTimeline->removeDeclarativeAnimationFromListsForOwningElement(*this, *m_owningElement);
     m_owningElement = nullptr;
 }
 
-bool DeclarativeAnimation::needsTick() const
-{
-    return WebAnimation::needsTick() || m_eventQueue.hasPendingEvents();
-}
-
-void DeclarativeAnimation::remove()
-{
-    m_eventQueue.close();
-    WebAnimation::remove();
-}
-
 void DeclarativeAnimation::setBackingAnimation(const Animation& backingAnimation)
 {
     m_backingAnimation = const_cast<Animation&>(backingAnimation);
     syncPropertiesWithBackingAnimation();
 }
@@ -151,10 +152,16 @@
 {
     flushPendingStyleChanges();
     return WebAnimation::bindingsPlayState();
 }
 
+WebAnimation::ReplaceState DeclarativeAnimation::bindingsReplaceState() const
+{
+    flushPendingStyleChanges();
+    return WebAnimation::bindingsReplaceState();
+}
+
 bool DeclarativeAnimation::bindingsPending() const
 {
     flushPendingStyleChanges();
     return WebAnimation::bindingsPending();
 }
@@ -330,32 +337,17 @@
     m_previousIteration = iteration;
 }
 
 void DeclarativeAnimation::enqueueDOMEvent(const AtomString& eventType, Seconds elapsedTime)
 {
-    ASSERT(m_owningElement);
-    auto time = secondsToWebAnimationsAPITime(elapsedTime) / 1000;
-    if (is<CSSAnimation>(this))
-        m_eventQueue.enqueueEvent(AnimationEvent::create(eventType, downcast<CSSAnimation>(this)->animationName(), time));
-    else if (is<CSSTransition>(this))
-        m_eventQueue.enqueueEvent(TransitionEvent::create(eventType, downcast<CSSTransition>(this)->transitionProperty(), time, PseudoElement::pseudoElementNameForEvents(m_owningElement->pseudoId())));
-}
-
-void DeclarativeAnimation::stop()
-{
-    m_eventQueue.close();
-    WebAnimation::stop();
-}
-
-void DeclarativeAnimation::suspend(ReasonForSuspension reason)
-{
-    m_eventQueue.suspend();
-    WebAnimation::suspend(reason);
-}
+    if (!m_owningElement)
+        return;
 
-void DeclarativeAnimation::resume()
-{
-    m_eventQueue.resume();
-    WebAnimation::resume();
+    auto time = secondsToWebAnimationsAPITime(elapsedTime) / 1000;
+    const auto& pseudoId = PseudoElement::pseudoElementNameForEvents(m_owningElement->pseudoId());
+    auto timelineTime = timeline() ? timeline()->currentTime() : WTF::nullopt;
+    auto event = createEvent(eventType, time, pseudoId, timelineTime);
+    event->setTarget(m_owningElement.get());
+    enqueueAnimationEvent(WTFMove(event));
 }
 
 } // namespace WebCore

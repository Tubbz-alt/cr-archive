<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DragClient.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DragController.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DragController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 81,10 ***</span>
<span class="line-new-header">--- 81,11 ---</span>
  #include &quot;ShadowRoot.h&quot;
  #include &quot;StyleProperties.h&quot;
  #include &quot;Text.h&quot;
  #include &quot;TextEvent.h&quot;
  #include &quot;VisiblePosition.h&quot;
<span class="line-added">+ #include &quot;WebContentReader.h&quot;</span>
  #include &quot;markup.h&quot;
  
  #if ENABLE(DATA_INTERACTION)
  #include &quot;SelectionRect.h&quot;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,20 ***</span>
      return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
                                LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
                                metaKey, WallTime::now(), ForceAtClick, NoTap);
  }
  
<span class="line-modified">! DragController::DragController(Page&amp; page, DragClient&amp; client)</span>
      : m_page(page)
<span class="line-modified">!     , m_client(client)</span>
  {
  }
  
<span class="line-modified">! DragController::~DragController()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_client.dragControllerDestroyed();</span>
<span class="line-removed">- }</span>
  
  static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
  {
      chosePlainText = false;
  
<span class="line-new-header">--- 131,17 ---</span>
      return PlatformMouseEvent(dragData.clientPosition(), dragData.globalPosition(),
                                LeftButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey,
                                metaKey, WallTime::now(), ForceAtClick, NoTap);
  }
  
<span class="line-modified">! DragController::DragController(Page&amp; page, std::unique_ptr&lt;DragClient&gt;&amp;&amp; client)</span>
      : m_page(page)
<span class="line-modified">!     , m_client(WTFMove(client))</span>
  {
  }
  
<span class="line-modified">! DragController::~DragController() = default;</span>
  
  static RefPtr&lt;DocumentFragment&gt; documentFragmentFromDragData(const DragData&amp; dragData, Frame&amp; frame, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText)
  {
      chosePlainText = false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,12 ***</span>
  {
      m_dragInitiator = nullptr;
      m_didInitiateDrag = false;
      m_documentUnderMouse = nullptr;
      clearDragCaret();
  
<span class="line-modified">!     m_client.dragEnded();</span>
  }
  
  DragOperation DragController::dragEntered(const DragData&amp; dragData)
  {
      return dragEnteredOrUpdated(dragData);
<span class="line-new-header">--- 202,13 ---</span>
  {
      m_dragInitiator = nullptr;
      m_didInitiateDrag = false;
      m_documentUnderMouse = nullptr;
      clearDragCaret();
<span class="line-added">+     removeAllDroppedImagePlaceholders();</span>
  
<span class="line-modified">!     client().dragEnded();</span>
  }
  
  DragOperation DragController::dragEntered(const DragData&amp; dragData)
  {
      return dragEnteredOrUpdated(dragData);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,21 ***</span>
      return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
  }
  
  bool DragController::performDragOperation(const DragData&amp; dragData)
  {
      SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
      TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
  
      m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
  
      ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
      if (m_documentUnderMouse)
          shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
  
      if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
<span class="line-modified">!         m_client.willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);</span>
          Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
          bool preventedDefault = false;
          if (mainFrame-&gt;view())
              preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
          if (preventedDefault) {
<span class="line-new-header">--- 235,31 ---</span>
      return dragHandlingMethod != DragHandlingMethod::None &amp;&amp; dragHandlingMethod != DragHandlingMethod::PageLoad;
  }
  
  bool DragController::performDragOperation(const DragData&amp; dragData)
  {
<span class="line-added">+     if (!m_droppedImagePlaceholders.isEmpty() &amp;&amp; m_droppedImagePlaceholderRange &amp;&amp; tryToUpdateDroppedImagePlaceholders(dragData)) {</span>
<span class="line-added">+         m_droppedImagePlaceholders.clear();</span>
<span class="line-added">+         m_droppedImagePlaceholderRange = nullptr;</span>
<span class="line-added">+         m_documentUnderMouse = nullptr;</span>
<span class="line-added">+         clearDragCaret();</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     removeAllDroppedImagePlaceholders();</span>
<span class="line-added">+ </span>
      SetForScope&lt;bool&gt; isPerformingDrop(m_isPerformingDrop, true);
      TemporarySelectionChange ignoreSelectionChanges(m_page.focusController().focusedOrMainFrame(), WTF::nullopt, TemporarySelectionOption::IgnoreSelectionChanges);
  
      m_documentUnderMouse = m_page.mainFrame().documentAtPoint(dragData.clientPosition());
  
      ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicy = ShouldOpenExternalURLsPolicy::ShouldNotAllow;
      if (m_documentUnderMouse)
          shouldOpenExternalURLsPolicy = m_documentUnderMouse-&gt;shouldOpenExternalURLsPolicyToPropagate();
  
      if ((m_dragDestinationAction &amp; DragDestinationActionDHTML) &amp;&amp; dragIsHandledByDocument(m_dragHandlingMethod)) {
<span class="line-modified">!         client().willPerformDragDestinationAction(DragDestinationActionDHTML, dragData);</span>
          Ref&lt;Frame&gt; mainFrame(m_page.mainFrame());
          bool preventedDefault = false;
          if (mainFrame-&gt;view())
              preventedDefault = mainFrame-&gt;eventHandler().performDragAndDrop(createMouseEvent(dragData), Pasteboard::createForDragAndDrop(dragData), dragData.draggingSourceOperationMask(), dragData.containsFiles());
          if (preventedDefault) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
              return true;
          }
      }
  
      if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
<span class="line-modified">!         m_client.didConcludeEditDrag();</span>
          m_documentUnderMouse = nullptr;
          clearDragCaret();
          return true;
      }
  
<span class="line-new-header">--- 268,11 ---</span>
              return true;
          }
      }
  
      if ((m_dragDestinationAction &amp; DragDestinationActionEdit) &amp;&amp; concludeEditDrag(dragData)) {
<span class="line-modified">!         client().didConcludeEditDrag();</span>
          m_documentUnderMouse = nullptr;
          clearDragCaret();
          return true;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
  
      auto urlString = dragData.asURL();
      if (urlString.isEmpty())
          return false;
  
<span class="line-modified">!     m_client.willPerformDragDestinationAction(DragDestinationActionLoad, dragData);</span>
      FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };
      frameLoadRequest.setIsRequestFromClientOrUserInput();
      m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
      return true;
  }
<span class="line-new-header">--- 284,11 ---</span>
  
      auto urlString = dragData.asURL();
      if (urlString.isEmpty())
          return false;
  
<span class="line-modified">!     client().willPerformDragDestinationAction(DragDestinationActionLoad, dragData);</span>
      FrameLoadRequest frameLoadRequest { m_page.mainFrame(), ResourceRequest { urlString }, shouldOpenExternalURLsPolicy };
      frameLoadRequest.setIsRequestFromClientOrUserInput();
      m_page.mainFrame().loader().load(WTFMove(frameLoadRequest));
      return true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,11 ***</span>
      return DragHandlingMethod::None;
  }
  
  DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
  {
<span class="line-modified">!     m_dragSourceAction = m_client.dragSourceActionMaskForPoint(rootViewPoint);</span>
      return m_dragSourceAction;
  }
  
  DragOperation DragController::operationForLoad(const DragData&amp; dragData)
  {
<span class="line-new-header">--- 483,11 ---</span>
      return DragHandlingMethod::None;
  }
  
  DragSourceAction DragController::delegateDragSourceAction(const IntPoint&amp; rootViewPoint)
  {
<span class="line-modified">!     m_dragSourceAction = client().dragSourceActionMaskForPoint(rootViewPoint);</span>
      return m_dragSourceAction;
  }
  
  DragOperation DragController::operationForLoad(const DragData&amp; dragData)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,11 ***</span>
              return false;
          auto style = MutableStyleProperties::create();
          style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
          if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
              return false;
<span class="line-modified">!         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
          innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
          return true;
      }
  
      if (dragData.containsFiles() &amp;&amp; fileInput) {
<span class="line-new-header">--- 568,11 ---</span>
              return false;
          auto style = MutableStyleProperties::create();
          style-&gt;setProperty(CSSPropertyColor, color.serialized(), false);
          if (!innerFrame-&gt;editor().shouldApplyStyle(style.ptr(), innerRange.get()))
              return false;
<span class="line-modified">!         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
          innerFrame-&gt;editor().applyStyle(style.ptr(), EditAction::SetColor);
          return true;
      }
  
      if (dragData.containsFiles() &amp;&amp; fileInput) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 595,11 ***</span>
          bool chosePlainText = false;
          RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
          if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
              return false;
  
<span class="line-modified">!         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
  
          if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
              return true;
  
          if (isMove) {
<span class="line-new-header">--- 604,11 ---</span>
          bool chosePlainText = false;
          RefPtr&lt;DocumentFragment&gt; fragment = documentFragmentFromDragData(dragData, *innerFrame, *range, true, chosePlainText);
          if (!fragment || !editor.shouldInsertFragment(*fragment, range.get(), EditorInsertAction::Dropped))
              return false;
  
<span class="line-modified">!         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
  
          if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
              return true;
  
          if (isMove) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 621,11 ***</span>
      } else {
          String text = dragData.asPlainText();
          if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
              return false;
  
<span class="line-modified">!         m_client.willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
          RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
          if (!fragment)
              return false;
  
          if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
<span class="line-new-header">--- 630,11 ---</span>
      } else {
          String text = dragData.asPlainText();
          if (text.isEmpty() || !editor.shouldInsertText(text, range.get(), EditorInsertAction::Dropped))
              return false;
  
<span class="line-modified">!         client().willPerformDragDestinationAction(DragDestinationActionEdit, dragData);</span>
          RefPtr&lt;DocumentFragment&gt; fragment = createFragmentFromText(*range, text);
          if (!fragment)
              return false;
  
          if (editor.client() &amp;&amp; editor.client()-&gt;performTwoStepDrop(*fragment, *range, isMove))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 942,11 ***</span>
      }
  
      ASSERT(state.source);
      Element&amp; element = *state.source;
  
<span class="line-modified">!     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || m_client.useLegacyDragClient();</span>
  
      IntRect dragImageBounds;
      Image* image = getImage(element);
      if (state.type == DragSourceActionSelection) {
          PasteboardWriterData pasteboardWriterData;
<span class="line-new-header">--- 951,11 ---</span>
      }
  
      ASSERT(state.source);
      Element&amp; element = *state.source;
  
<span class="line-modified">!     bool mustUseLegacyDragClient = hasData == HasNonDefaultPasteboardData::Yes || client().useLegacyDragClient();</span>
  
      IntRect dragImageBounds;
      Image* image = getImage(element);
      if (state.type == DragSourceActionSelection) {
          PasteboardWriterData pasteboardWriterData;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 988,11 ***</span>
                  }
              }
  
              src.editor().didWriteSelectionToPasteboard();
          }
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);</span>
          if (!dragImage) {
              TextIndicatorData textIndicator;
              dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
              if (textIndicator.contentImage)
                  dragImage.setIndicatorData(textIndicator);
<span class="line-new-header">--- 997,11 ---</span>
                  }
              }
  
              src.editor().didWriteSelectionToPasteboard();
          }
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionSelection, dragOrigin, dataTransfer);</span>
          if (!dragImage) {
              TextIndicatorData textIndicator;
              dragImage = DragImage { dissolveDragImageToFraction(createDragImageForSelection(src, textIndicator), DragImageAlpha) };
              if (textIndicator.contentImage)
                  dragImage.setIndicatorData(textIndicator);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1040,11 ***</span>
                  selectElement(element);
              if (!attachmentInfo)
                  declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
          }
  
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);</span>
  
          if (!dragImage)
              doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
          else {
              // DHTML defined drag image
<span class="line-new-header">--- 1049,11 ---</span>
                  selectElement(element);
              if (!attachmentInfo)
                  declareAndWriteDragImage(dataTransfer, element, !linkURL.isEmpty() ? linkURL : imageURL, hitTestResult.altDisplayString());
          }
  
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionImage, dragOrigin, dataTransfer);</span>
  
          if (!dragImage)
              doImageDrag(element, dragOrigin, hitTestResult.imageRect(), src, m_dragOffset, state, WTFMove(attachmentInfo));
          else {
              // DHTML defined drag image
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1084,11 ***</span>
              Node* node = enclosingAnchorElement(pos);
              if (node)
                  src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
          }
  
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);</span>
          if (!dragImage) {
              TextIndicatorData textIndicator;
              dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
              if (dragImage) {
                  m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
<span class="line-new-header">--- 1093,11 ---</span>
              Node* node = enclosingAnchorElement(pos);
              if (node)
                  src.selection().setSelection(VisibleSelection::selectionFromContentsOfNode(node));
          }
  
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionLink, dragOrigin, dataTransfer);</span>
          if (!dragImage) {
              TextIndicatorData textIndicator;
              dragImage = DragImage { createDragImageForLink(element, linkURL, textContentWithSimplifiedWhiteSpace, textIndicator, src.settings().fontRenderingMode(), m_page.deviceScaleFactor()) };
              if (dragImage) {
                  m_dragOffset = dragOffsetForLinkDragImage(dragImage.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,11 ***</span>
                  editor.didWriteSelectionToPasteboard();
  #endif
              }
          }
  
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);</span>
  
          if (!dragImage) {
              TextIndicatorData textIndicator;
              if (attachmentRenderer)
                  attachmentRenderer-&gt;setShouldDrawBorder(false);
<span class="line-new-header">--- 1144,11 ---</span>
                  editor.didWriteSelectionToPasteboard();
  #endif
              }
          }
  
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionAttachment, dragOrigin, dataTransfer);</span>
  
          if (!dragImage) {
              TextIndicatorData textIndicator;
              if (attachmentRenderer)
                  attachmentRenderer-&gt;setShouldDrawBorder(false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,19 ***</span>
          dragImage.setVisiblePath(visiblePath);
          dataTransfer.pasteboard().write(color);
          dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
          dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
  
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);</span>
          doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
          return true;
      }
  #endif
  
      if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
          ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
<span class="line-modified">!         m_client.willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);</span>
          doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
          return true;
      }
  
      return false;
<span class="line-new-header">--- 1179,19 ---</span>
          dragImage.setVisiblePath(visiblePath);
          dataTransfer.pasteboard().write(color);
          dragImageOffset = IntPoint { dragImageSize(dragImage.get()) };
          dragLoc = dragLocForDHTMLDrag(mouseDraggedPoint, dragOrigin, dragImageOffset, false);
  
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionColor, dragOrigin, dataTransfer);</span>
          doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
          return true;
      }
  #endif
  
      if (state.type == DragSourceActionDHTML &amp;&amp; dragImage) {
          ASSERT(m_dragSourceAction &amp; DragSourceActionDHTML);
<span class="line-modified">!         client().willPerformDragSourceAction(DragSourceActionDHTML, dragOrigin, dataTransfer);</span>
          doSystemDrag(WTFMove(dragImage), dragLoc, dragOrigin, src, state, { });
          return true;
      }
  
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1234,11 ***</span>
      doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
  }
  
  void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
  {
<span class="line-modified">!     ASSERT(!m_client.useLegacyDragClient());</span>
  
      m_didInitiateDrag = true;
      m_dragInitiator = frame.document();
  
      // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
<span class="line-new-header">--- 1243,11 ---</span>
      doSystemDrag(WTFMove(dragImage), dragImageOffset, dragOrigin, frame, state, WTFMove(attachmentInfo));
  }
  
  void DragController::beginDrag(DragItem dragItem, Frame&amp; frame, const IntPoint&amp; mouseDownPoint, const IntPoint&amp; mouseDraggedPoint, DataTransfer&amp; dataTransfer, DragSourceAction dragSourceAction)
  {
<span class="line-modified">!     ASSERT(!client().useLegacyDragClient());</span>
  
      m_didInitiateDrag = true;
      m_dragInitiator = frame.document();
  
      // Protect this frame and view, as a load may occur mid drag and attempt to unload this frame
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1246,11 ***</span>
      RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
  
      auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
      auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
  
<span class="line-modified">!     m_client.beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);</span>
  }
  
  void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
  {
      m_didInitiateDrag = true;
<span class="line-new-header">--- 1255,11 ---</span>
      RefPtr&lt;FrameView&gt; viewProtector = mainFrameProtector-&gt;view();
  
      auto mouseDownPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDownPoint));
      auto mouseDraggedPointInRootViewCoordinates = viewProtector-&gt;rootViewToContents(frame.view()-&gt;contentsToRootView(mouseDraggedPoint));
  
<span class="line-modified">!     client().beginDrag(WTFMove(dragItem), frame, mouseDownPointInRootViewCoordinates, mouseDraggedPointInRootViewCoordinates, dataTransfer, dragSourceAction);</span>
  }
  
  void DragController::doSystemDrag(DragImage image, const IntPoint&amp; dragLoc, const IntPoint&amp; eventPos, Frame&amp; frame, const DragState&amp; state, PromisedAttachmentInfo&amp;&amp; promisedAttachmentInfo)
  {
      m_didInitiateDrag = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1302,18 ***</span>
              auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
              item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
              item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
          }
      }
<span class="line-modified">!     m_client.startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());</span>
      // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
      if (!frameProtector-&gt;page())
          return;
  
      cleanupAfterSystemDrag();
  }
  
  // Manual drag caret manipulation
  void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
  {
      mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
      if (!m_documentUnderMouse)
<span class="line-new-header">--- 1311,150 ---</span>
              auto titleAttribute = link-&gt;attributeWithoutSynchronization(HTMLNames::titleAttr);
              item.title = titleAttribute.isEmpty() ? link-&gt;innerText() : titleAttribute.string();
              item.url = frame.document()-&gt;completeURL(stripLeadingAndTrailingHTMLSpaces(link-&gt;getAttribute(HTMLNames::hrefAttr)));
          }
      }
<span class="line-modified">!     client().startDrag(WTFMove(item), *state.dataTransfer, frameProtector.get());</span>
      // DragClient::startDrag can cause our Page to dispear, deallocating |this|.
      if (!frameProtector-&gt;page())
          return;
  
      cleanupAfterSystemDrag();
  }
  
<span class="line-added">+ void DragController::removeAllDroppedImagePlaceholders()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_droppedImagePlaceholderRange = nullptr;</span>
<span class="line-added">+     for (auto&amp; placeholder : std::exchange(m_droppedImagePlaceholders, { })) {</span>
<span class="line-added">+         if (placeholder-&gt;isConnected())</span>
<span class="line-added">+             placeholder-&gt;remove();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool DragController::tryToUpdateDroppedImagePlaceholders(const DragData&amp; dragData)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_droppedImagePlaceholders.isEmpty());</span>
<span class="line-added">+     ASSERT(m_droppedImagePlaceholderRange);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto document = makeRef(m_droppedImagePlaceholders[0]-&gt;document());</span>
<span class="line-added">+     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">+     if (!frame)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     WebContentReader reader(*frame, *m_droppedImagePlaceholderRange, true);</span>
<span class="line-added">+     auto pasteboard = Pasteboard::createForDragAndDrop(dragData);</span>
<span class="line-added">+     pasteboard-&gt;read(reader);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!reader.fragment)</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; imageElements;</span>
<span class="line-added">+     for (auto&amp; imageElement : descendantsOfType&lt;HTMLImageElement&gt;(*reader.fragment))</span>
<span class="line-added">+         imageElements.append(imageElement);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (imageElements.size() != m_droppedImagePlaceholders.size()) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; imageElements.size(); ++i) {</span>
<span class="line-added">+         auto&amp; imageElement = imageElements[i];</span>
<span class="line-added">+         auto&amp; placeholder = m_droppedImagePlaceholders[i];</span>
<span class="line-added">+         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::srcAttr, imageElement-&gt;attributeWithoutSynchronization(HTMLNames::srcAttr));</span>
<span class="line-added">+ #if ENABLE(ATTACHMENT_ELEMENT)</span>
<span class="line-added">+         if (auto attachment = imageElement-&gt;attachmentElement())</span>
<span class="line-added">+             placeholder-&gt;setAttachmentElement(attachment.releaseNonNull());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DragController::insertDroppedImagePlaceholdersAtCaret(const Vector&lt;IntSize&gt;&amp; imageSizes)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; caretController = m_page.dragCaretController();</span>
<span class="line-added">+     if (!caretController.isContentRichlyEditable())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto dropCaret = caretController.caretPosition();</span>
<span class="line-added">+     if (dropCaret.isNull())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto document = makeRefPtr(dropCaret.deepEquivalent().document());</span>
<span class="line-added">+     if (!document)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto frame = makeRefPtr(document-&gt;frame());</span>
<span class="line-added">+     if (!frame)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     TemporarySelectionChange selectionChange(*frame, WTF::nullopt, { TemporarySelectionOption::IgnoreSelectionChanges });</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto fragment = DocumentFragment::create(*document);</span>
<span class="line-added">+     for (auto&amp; size : imageSizes) {</span>
<span class="line-added">+         ASSERT(!size.isEmpty());</span>
<span class="line-added">+         auto image = HTMLImageElement::create(*document);</span>
<span class="line-added">+         image-&gt;setAttributeWithoutSynchronization(HTMLNames::widthAttr, AtomString::number(size.width()));</span>
<span class="line-added">+         image-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(size.height()));</span>
<span class="line-added">+         image-&gt;setInlineStyleProperty(CSSPropertyMaxWidth, 100, CSSUnitType::CSS_PERCENTAGE);</span>
<span class="line-added">+         image-&gt;setInlineStyleProperty(CSSPropertyBackgroundColor, Color(Color::black).colorWithAlpha(0.05).cssText());</span>
<span class="line-added">+         image-&gt;setIsDroppedImagePlaceholder();</span>
<span class="line-added">+         fragment-&gt;appendChild(WTFMove(image));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     frame-&gt;selection().setSelection(dropCaret);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto command = ReplaceSelectionCommand::create(*document, WTFMove(fragment), { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SmartReplace }, EditAction::InsertFromDrop);</span>
<span class="line-added">+     command-&gt;apply();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto insertedContentRange = command-&gt;insertedContentRange();</span>
<span class="line-added">+     if (!insertedContentRange) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto container = makeRefPtr(insertedContentRange-&gt;commonAncestorContainer());</span>
<span class="line-added">+     if (!is&lt;ContainerNode&gt;(container)) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; placeholders;</span>
<span class="line-added">+     for (auto&amp; placeholder : descendantsOfType&lt;HTMLImageElement&gt;(downcast&lt;ContainerNode&gt;(*container))) {</span>
<span class="line-added">+         auto intersectsNode = insertedContentRange-&gt;intersectsNode(placeholder);</span>
<span class="line-added">+         if (!intersectsNode.hasException() &amp;&amp; intersectsNode.returnValue())</span>
<span class="line-added">+             placeholders.append(placeholder);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (placeholders.size() != imageSizes.size()) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; placeholders.size(); ++i) {</span>
<span class="line-added">+         auto&amp; placeholder = placeholders[i];</span>
<span class="line-added">+         auto imageSize = imageSizes[i];</span>
<span class="line-added">+         double clientWidth = placeholder-&gt;clientWidth();</span>
<span class="line-added">+         double heightRespectingAspectRatio = (imageSize.height() * clientWidth) / imageSize.width();</span>
<span class="line-added">+         placeholder-&gt;setAttributeWithoutSynchronization(HTMLNames::heightAttr, AtomString::number(heightRespectingAspectRatio));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     document-&gt;updateLayout();</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_droppedImagePlaceholders = WTFMove(placeholders);</span>
<span class="line-added">+     m_droppedImagePlaceholderRange = WTFMove(insertedContentRange);</span>
<span class="line-added">+ </span>
<span class="line-added">+     frame-&gt;selection().clear();</span>
<span class="line-added">+     caretController.setCaretPosition(m_droppedImagePlaceholderRange-&gt;startPosition());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DragController::finalizeDroppedImagePlaceholder(HTMLImageElement&amp; placeholder)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(placeholder.isDroppedImagePlaceholder());</span>
<span class="line-added">+     placeholder.removeAttribute(HTMLNames::heightAttr);</span>
<span class="line-added">+     placeholder.removeInlineStyleProperty(CSSPropertyBackgroundColor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Manual drag caret manipulation
  void DragController::placeDragCaret(const IntPoint&amp; windowPoint)
  {
      mouseMovedIntoDocument(m_page.mainFrame().documentAtPoint(windowPoint));
      if (!m_documentUnderMouse)
</pre>
<center><a href="DragClient.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DragController.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorDebuggerAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorHeapAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 #include &quot;ScriptBreakpoint.h&quot;
 37 #include &quot;ScriptDebugListener.h&quot;
 38 #include &lt;wtf/Forward.h&gt;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/Noncopyable.h&gt;
 42 #include &lt;wtf/Vector.h&gt;
 43 
 44 namespace Inspector {
 45 
 46 class AsyncStackTrace;
 47 class InjectedScript;
 48 class InjectedScriptManager;
 49 class ScriptDebugServer;
 50 typedef String ErrorString;
 51 
 52 class JS_EXPORT_PRIVATE InspectorDebuggerAgent : public InspectorAgentBase, public DebuggerBackendDispatcherHandler, public ScriptDebugListener {
 53     WTF_MAKE_NONCOPYABLE(InspectorDebuggerAgent);
 54     WTF_MAKE_FAST_ALLOCATED;
 55 public:
<span class="line-modified"> 56     virtual ~InspectorDebuggerAgent();</span>
 57 
 58     static const char* backtraceObjectGroup;
 59 
 60     // InspectorAgentBase
 61     void didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*) final;
 62     void willDestroyFrontendAndBackend(DisconnectReason) final;

 63 
 64     // DebuggerBackendDispatcherHandler
 65     void enable(ErrorString&amp;) final;
 66     void disable(ErrorString&amp;) final;
 67     void setAsyncStackTraceDepth(ErrorString&amp;, int depth) final;
 68     void setBreakpointsActive(ErrorString&amp;, bool active) final;
 69     void setBreakpointByUrl(ErrorString&amp;, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId*, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations) final;
 70     void setBreakpoint(ErrorString&amp;, const JSON::Object&amp; location, const JSON::Object* options, Protocol::Debugger::BreakpointId*, RefPtr&lt;Protocol::Debugger::Location&gt;&amp; actualLocation) final;
 71     void removeBreakpoint(ErrorString&amp;, const String&amp; breakpointIdentifier) final;
 72     void continueUntilNextRunLoop(ErrorString&amp;) final;
 73     void continueToLocation(ErrorString&amp;, const JSON::Object&amp; location) final;
 74     void stepOver(ErrorString&amp;) final;
 75     void stepInto(ErrorString&amp;) final;
 76     void stepOut(ErrorString&amp;) final;
 77     void pause(ErrorString&amp;) final;
 78     void resume(ErrorString&amp;) final;
 79     void searchInContent(ErrorString&amp;, const String&amp; scriptID, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp;) final;
 80     void getScriptSource(ErrorString&amp;, const String&amp; scriptID, String* scriptSource) final;
 81     void getFunctionDetails(ErrorString&amp;, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp;) final;

 82     void setPauseOnExceptions(ErrorString&amp;, const String&amp; pauseState) final;
 83     void setPauseOnAssertions(ErrorString&amp;, bool enabled) final;
 84     void setPauseOnMicrotasks(ErrorString&amp;, bool enabled) final;
 85     void setPauseForInternalScripts(ErrorString&amp;, bool shouldPause) final;
 86     void evaluateOnCallFrame(ErrorString&amp;, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* emulateUserGesture, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex) override;

 87 
 88     // ScriptDebugListener
 89     void didParseSource(JSC::SourceID, const Script&amp;) final;
 90     void failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage) final;
 91     void willRunMicrotask() final;
 92     void didRunMicrotask() final;
<span class="line-modified"> 93     void didPause(JSC::ExecState&amp;, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue) final;</span>
 94     void didContinue() final;
 95     void breakpointActionSound(int breakpointActionIdentifier) final;
<span class="line-modified"> 96     void breakpointActionProbe(JSC::ExecState&amp;, const ScriptBreakpointAction&amp;, unsigned batchId, unsigned sampleId, JSC::JSValue sample) final;</span>
 97 
 98     bool isPaused() const;
 99     bool breakpointsActive() const;
100 
101     void setSuppressAllPauses(bool);
102 
103     void handleConsoleAssert(const String&amp; message);
104 
105     enum class AsyncCallType {
106         DOMTimer,
107         EventListener,
108         PostMessage,
109         RequestAnimationFrame,
110     };
111 
<span class="line-modified">112     void didScheduleAsyncCall(JSC::ExecState*, AsyncCallType, int callbackId, bool singleShot);</span>
113     void didCancelAsyncCall(AsyncCallType, int callbackId);
114     void willDispatchAsyncCall(AsyncCallType, int callbackId);
115     void didDispatchAsyncCall();
116 
<span class="line-modified">117     void schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data);</span>
118     void cancelPauseOnNextStatement();
119     bool pauseOnNextStatementEnabled() const { return m_javaScriptPauseScheduled; }
120 
<span class="line-modified">121     void breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data);</span>
122     void scriptExecutionBlockedByCSP(const String&amp; directiveText);
123 
124     class Listener {
125     public:
126         virtual ~Listener() { }
127         virtual void debuggerWasEnabled() = 0;
128         virtual void debuggerWasDisabled() = 0;
129     };
130     void addListener(Listener&amp; listener) { m_listeners.add(&amp;listener); }
131     void removeListener(Listener&amp; listener) { m_listeners.remove(&amp;listener); }
132 
133 protected:
134     InspectorDebuggerAgent(AgentContext&amp;);


135 
136     InjectedScriptManager&amp; injectedScriptManager() const { return m_injectedScriptManager; }
137     virtual InjectedScript injectedScriptForEval(ErrorString&amp;, const int* executionContextId) = 0;
138 
139     ScriptDebugServer&amp; scriptDebugServer() { return m_scriptDebugServer; }
140 
141     virtual void muteConsole() = 0;
142     virtual void unmuteConsole() = 0;
143 
<span class="line-removed">144     virtual void enable();</span>
<span class="line-removed">145     virtual void disable(bool isBeingDestroyed);</span>
<span class="line-removed">146 </span>
147     virtual String sourceMapURLForScript(const Script&amp;);
148 
149     void didClearGlobalObject();
150     virtual void didClearAsyncStackTraceData() { }
151 
152 private:


153     Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; currentCallFrames(const InjectedScript&amp;);
154 
155     void resolveBreakpoint(const Script&amp;, JSC::Breakpoint&amp;);
156     void setBreakpoint(JSC::Breakpoint&amp;, bool&amp; existing);
157     void didSetBreakpoint(const JSC::Breakpoint&amp;, const String&amp;, const ScriptBreakpoint&amp;);
158 
159     bool assertPaused(ErrorString&amp;);
160     void clearDebuggerBreakpointState();
161     void clearInspectorBreakpointState();
<span class="line-modified">162     void clearBreakDetails();</span>
163     void clearExceptionValue();
164     void clearAsyncStackTraceData();
165 
166     enum class ShouldDispatchResumed { No, WhenIdle, WhenContinued };
167     void registerIdleHandler();
168     void willStepAndMayBecomeIdle();
169     void didBecomeIdle();
170 


171     RefPtr&lt;JSON::Object&gt; buildBreakpointPauseReason(JSC::BreakpointID);
172     RefPtr&lt;JSON::Object&gt; buildExceptionPauseReason(JSC::JSValue exception, const InjectedScript&amp;);
173 
174     bool breakpointActionsFromProtocol(ErrorString&amp;, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result);
175 
176     typedef std::pair&lt;unsigned, int&gt; AsyncCallIdentifier;
177     static AsyncCallIdentifier asyncCallIdentifier(AsyncCallType, int callbackId);
178 
179     std::unique_ptr&lt;DebuggerFrontendDispatcher&gt; m_frontendDispatcher;
180     RefPtr&lt;DebuggerBackendDispatcher&gt; m_backendDispatcher;
181 
182     ScriptDebugServer&amp; m_scriptDebugServer;
183     InjectedScriptManager&amp; m_injectedScriptManager;
184     HashMap&lt;JSC::SourceID, Script&gt; m_scripts;
185 














186     HashSet&lt;Listener*&gt; m_listeners;
187 
<span class="line-modified">188     JSC::ExecState* m_pausedScriptState { nullptr };</span>
189     JSC::Strong&lt;JSC::Unknown&gt; m_currentCallStack;
190 
191     HashMap&lt;String, Vector&lt;JSC::BreakpointID&gt;&gt; m_breakpointIdentifierToDebugServerBreakpointIDs;
192     HashMap&lt;String, RefPtr&lt;JSON::Object&gt;&gt; m_javaScriptBreakpoints;
193     HashMap&lt;JSC::BreakpointID, String&gt; m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier;
194     JSC::BreakpointID m_continueToLocationBreakpointID { JSC::noBreakpointID };
<span class="line-removed">195     DebuggerFrontendDispatcher::Reason m_breakReason;</span>
<span class="line-removed">196     RefPtr&lt;JSON::Object&gt; m_breakData;</span>
197     ShouldDispatchResumed m_conditionToDispatchResumed { ShouldDispatchResumed::No };
198 






199     HashMap&lt;AsyncCallIdentifier, RefPtr&lt;AsyncStackTrace&gt;&gt; m_pendingAsyncCalls;
200     Optional&lt;AsyncCallIdentifier&gt; m_currentAsyncCallIdentifier;
201     int m_asyncStackTraceDepth { 0 };
202 
203     bool m_enabled { false };
204     bool m_enablePauseWhenIdle { false };
205     bool m_pauseOnAssertionFailures { false };
206     bool m_pauseOnMicrotasks { false };
207     bool m_pauseForInternalScripts { false };
208     bool m_javaScriptPauseScheduled { false };
209     bool m_didPauseStopwatch { false };
210     bool m_hasExceptionValue { false };
211     bool m_registeredIdleCallback { false };
212 };
213 
214 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
 36 #include &quot;ScriptBreakpoint.h&quot;
 37 #include &quot;ScriptDebugListener.h&quot;
 38 #include &lt;wtf/Forward.h&gt;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/Noncopyable.h&gt;
 42 #include &lt;wtf/Vector.h&gt;
 43 
 44 namespace Inspector {
 45 
 46 class AsyncStackTrace;
 47 class InjectedScript;
 48 class InjectedScriptManager;
 49 class ScriptDebugServer;
 50 typedef String ErrorString;
 51 
 52 class JS_EXPORT_PRIVATE InspectorDebuggerAgent : public InspectorAgentBase, public DebuggerBackendDispatcherHandler, public ScriptDebugListener {
 53     WTF_MAKE_NONCOPYABLE(InspectorDebuggerAgent);
 54     WTF_MAKE_FAST_ALLOCATED;
 55 public:
<span class="line-modified"> 56     ~InspectorDebuggerAgent() override;</span>
 57 
 58     static const char* backtraceObjectGroup;
 59 
 60     // InspectorAgentBase
 61     void didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*) final;
 62     void willDestroyFrontendAndBackend(DisconnectReason) final;
<span class="line-added"> 63     virtual bool enabled() const { return m_enabled; }</span>
 64 
 65     // DebuggerBackendDispatcherHandler
 66     void enable(ErrorString&amp;) final;
 67     void disable(ErrorString&amp;) final;
 68     void setAsyncStackTraceDepth(ErrorString&amp;, int depth) final;
 69     void setBreakpointsActive(ErrorString&amp;, bool active) final;
 70     void setBreakpointByUrl(ErrorString&amp;, int lineNumber, const String* optionalURL, const String* optionalURLRegex, const int* optionalColumnNumber, const JSON::Object* options, Protocol::Debugger::BreakpointId*, RefPtr&lt;JSON::ArrayOf&lt;Protocol::Debugger::Location&gt;&gt;&amp; locations) final;
 71     void setBreakpoint(ErrorString&amp;, const JSON::Object&amp; location, const JSON::Object* options, Protocol::Debugger::BreakpointId*, RefPtr&lt;Protocol::Debugger::Location&gt;&amp; actualLocation) final;
 72     void removeBreakpoint(ErrorString&amp;, const String&amp; breakpointIdentifier) final;
 73     void continueUntilNextRunLoop(ErrorString&amp;) final;
 74     void continueToLocation(ErrorString&amp;, const JSON::Object&amp; location) final;
 75     void stepOver(ErrorString&amp;) final;
 76     void stepInto(ErrorString&amp;) final;
 77     void stepOut(ErrorString&amp;) final;
 78     void pause(ErrorString&amp;) final;
 79     void resume(ErrorString&amp;) final;
 80     void searchInContent(ErrorString&amp;, const String&amp; scriptID, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Protocol::GenericTypes::SearchMatch&gt;&gt;&amp;) final;
 81     void getScriptSource(ErrorString&amp;, const String&amp; scriptID, String* scriptSource) final;
 82     void getFunctionDetails(ErrorString&amp;, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp;) final;
<span class="line-added"> 83     void setPauseOnDebuggerStatements(ErrorString&amp;, bool enabled) final;</span>
 84     void setPauseOnExceptions(ErrorString&amp;, const String&amp; pauseState) final;
 85     void setPauseOnAssertions(ErrorString&amp;, bool enabled) final;
 86     void setPauseOnMicrotasks(ErrorString&amp;, bool enabled) final;
 87     void setPauseForInternalScripts(ErrorString&amp;, bool shouldPause) final;
 88     void evaluateOnCallFrame(ErrorString&amp;, const String&amp; callFrameId, const String&amp; expression, const String* objectGroup, const bool* includeCommandLineAPI, const bool* doNotPauseOnExceptionsAndMuteConsole, const bool* returnByValue, const bool* generatePreview, const bool* saveResult, const bool* emulateUserGesture, RefPtr&lt;Protocol::Runtime::RemoteObject&gt;&amp; result, Optional&lt;bool&gt;&amp; wasThrown, Optional&lt;int&gt;&amp; savedResultIndex) override;
<span class="line-added"> 89     void setShouldBlackboxURL(ErrorString&amp;, const String&amp; url, bool shouldBlackbox, const bool* caseSensitive, const bool* isRegex) final;</span>
 90 
 91     // ScriptDebugListener
 92     void didParseSource(JSC::SourceID, const Script&amp;) final;
 93     void failedToParseSource(const String&amp; url, const String&amp; data, int firstLine, int errorLine, const String&amp; errorMessage) final;
 94     void willRunMicrotask() final;
 95     void didRunMicrotask() final;
<span class="line-modified"> 96     void didPause(JSC::JSGlobalObject*, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue) final;</span>
 97     void didContinue() final;
 98     void breakpointActionSound(int breakpointActionIdentifier) final;
<span class="line-modified"> 99     void breakpointActionProbe(JSC::JSGlobalObject*, const ScriptBreakpointAction&amp;, unsigned batchId, unsigned sampleId, JSC::JSValue sample) final;</span>
100 
101     bool isPaused() const;
102     bool breakpointsActive() const;
103 
104     void setSuppressAllPauses(bool);
105 
106     void handleConsoleAssert(const String&amp; message);
107 
108     enum class AsyncCallType {
109         DOMTimer,
110         EventListener,
111         PostMessage,
112         RequestAnimationFrame,
113     };
114 
<span class="line-modified">115     void didScheduleAsyncCall(JSC::JSGlobalObject*, AsyncCallType, int callbackId, bool singleShot);</span>
116     void didCancelAsyncCall(AsyncCallType, int callbackId);
117     void willDispatchAsyncCall(AsyncCallType, int callbackId);
118     void didDispatchAsyncCall();
119 
<span class="line-modified">120     void schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data);</span>
121     void cancelPauseOnNextStatement();
122     bool pauseOnNextStatementEnabled() const { return m_javaScriptPauseScheduled; }
123 
<span class="line-modified">124     void breakProgram(DebuggerFrontendDispatcher::Reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data);</span>
125     void scriptExecutionBlockedByCSP(const String&amp; directiveText);
126 
127     class Listener {
128     public:
129         virtual ~Listener() { }
130         virtual void debuggerWasEnabled() = 0;
131         virtual void debuggerWasDisabled() = 0;
132     };
133     void addListener(Listener&amp; listener) { m_listeners.add(&amp;listener); }
134     void removeListener(Listener&amp; listener) { m_listeners.remove(&amp;listener); }
135 
136 protected:
137     InspectorDebuggerAgent(AgentContext&amp;);
<span class="line-added">138     virtual void enable();</span>
<span class="line-added">139     virtual void disable(bool isBeingDestroyed);</span>
140 
141     InjectedScriptManager&amp; injectedScriptManager() const { return m_injectedScriptManager; }
142     virtual InjectedScript injectedScriptForEval(ErrorString&amp;, const int* executionContextId) = 0;
143 
144     ScriptDebugServer&amp; scriptDebugServer() { return m_scriptDebugServer; }
145 
146     virtual void muteConsole() = 0;
147     virtual void unmuteConsole() = 0;
148 



149     virtual String sourceMapURLForScript(const Script&amp;);
150 
151     void didClearGlobalObject();
152     virtual void didClearAsyncStackTraceData() { }
153 
154 private:
<span class="line-added">155     bool shouldBlackboxURL(const String&amp;) const;</span>
<span class="line-added">156 </span>
157     Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; currentCallFrames(const InjectedScript&amp;);
158 
159     void resolveBreakpoint(const Script&amp;, JSC::Breakpoint&amp;);
160     void setBreakpoint(JSC::Breakpoint&amp;, bool&amp; existing);
161     void didSetBreakpoint(const JSC::Breakpoint&amp;, const String&amp;, const ScriptBreakpoint&amp;);
162 
163     bool assertPaused(ErrorString&amp;);
164     void clearDebuggerBreakpointState();
165     void clearInspectorBreakpointState();
<span class="line-modified">166     void clearPauseDetails();</span>
167     void clearExceptionValue();
168     void clearAsyncStackTraceData();
169 
170     enum class ShouldDispatchResumed { No, WhenIdle, WhenContinued };
171     void registerIdleHandler();
172     void willStepAndMayBecomeIdle();
173     void didBecomeIdle();
174 
<span class="line-added">175     void updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data);</span>
<span class="line-added">176 </span>
177     RefPtr&lt;JSON::Object&gt; buildBreakpointPauseReason(JSC::BreakpointID);
178     RefPtr&lt;JSON::Object&gt; buildExceptionPauseReason(JSC::JSValue exception, const InjectedScript&amp;);
179 
180     bool breakpointActionsFromProtocol(ErrorString&amp;, RefPtr&lt;JSON::Array&gt;&amp; actions, BreakpointActions* result);
181 
182     typedef std::pair&lt;unsigned, int&gt; AsyncCallIdentifier;
183     static AsyncCallIdentifier asyncCallIdentifier(AsyncCallType, int callbackId);
184 
185     std::unique_ptr&lt;DebuggerFrontendDispatcher&gt; m_frontendDispatcher;
186     RefPtr&lt;DebuggerBackendDispatcher&gt; m_backendDispatcher;
187 
188     ScriptDebugServer&amp; m_scriptDebugServer;
189     InjectedScriptManager&amp; m_injectedScriptManager;
190     HashMap&lt;JSC::SourceID, Script&gt; m_scripts;
191 
<span class="line-added">192     struct BlackboxConfig {</span>
<span class="line-added">193         String url;</span>
<span class="line-added">194         bool caseSensitive { false };</span>
<span class="line-added">195         bool isRegex { false };</span>
<span class="line-added">196 </span>
<span class="line-added">197         inline bool operator==(const BlackboxConfig&amp; other) const</span>
<span class="line-added">198         {</span>
<span class="line-added">199             return url == other.url</span>
<span class="line-added">200                 &amp;&amp; caseSensitive == other.caseSensitive</span>
<span class="line-added">201                 &amp;&amp; isRegex == other.isRegex;</span>
<span class="line-added">202         }</span>
<span class="line-added">203     };</span>
<span class="line-added">204     Vector&lt;BlackboxConfig&gt; m_blackboxedURLs;</span>
<span class="line-added">205 </span>
206     HashSet&lt;Listener*&gt; m_listeners;
207 
<span class="line-modified">208     JSC::JSGlobalObject* m_pausedGlobalObject { nullptr };</span>
209     JSC::Strong&lt;JSC::Unknown&gt; m_currentCallStack;
210 
211     HashMap&lt;String, Vector&lt;JSC::BreakpointID&gt;&gt; m_breakpointIdentifierToDebugServerBreakpointIDs;
212     HashMap&lt;String, RefPtr&lt;JSON::Object&gt;&gt; m_javaScriptBreakpoints;
213     HashMap&lt;JSC::BreakpointID, String&gt; m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier;
214     JSC::BreakpointID m_continueToLocationBreakpointID { JSC::noBreakpointID };


215     ShouldDispatchResumed m_conditionToDispatchResumed { ShouldDispatchResumed::No };
216 
<span class="line-added">217     DebuggerFrontendDispatcher::Reason m_pauseReason;</span>
<span class="line-added">218     RefPtr&lt;JSON::Object&gt; m_pauseData;</span>
<span class="line-added">219 </span>
<span class="line-added">220     DebuggerFrontendDispatcher::Reason m_preBlackboxPauseReason;</span>
<span class="line-added">221     RefPtr&lt;JSON::Object&gt; m_preBlackboxPauseData;</span>
<span class="line-added">222 </span>
223     HashMap&lt;AsyncCallIdentifier, RefPtr&lt;AsyncStackTrace&gt;&gt; m_pendingAsyncCalls;
224     Optional&lt;AsyncCallIdentifier&gt; m_currentAsyncCallIdentifier;
225     int m_asyncStackTraceDepth { 0 };
226 
227     bool m_enabled { false };
228     bool m_enablePauseWhenIdle { false };
229     bool m_pauseOnAssertionFailures { false };
230     bool m_pauseOnMicrotasks { false };
231     bool m_pauseForInternalScripts { false };
232     bool m_javaScriptPauseScheduled { false };
233     bool m_didPauseStopwatch { false };
234     bool m_hasExceptionValue { false };
235     bool m_registeredIdleCallback { false };
236 };
237 
238 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="InspectorDebuggerAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorHeapAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
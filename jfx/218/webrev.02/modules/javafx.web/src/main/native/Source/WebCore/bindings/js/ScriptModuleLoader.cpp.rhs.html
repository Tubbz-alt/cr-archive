<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ScriptModuleLoader.h&quot;
 28 
 29 #include &quot;CachedModuleScriptLoader.h&quot;
 30 #include &quot;CachedScript.h&quot;
 31 #include &quot;CachedScriptFetcher.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;JSDOMBinding.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 36 #include &quot;LoadableModuleScript.h&quot;
 37 #include &quot;MIMETypeRegistry.h&quot;
 38 #include &quot;ModuleFetchFailureKind.h&quot;
 39 #include &quot;ModuleFetchParameters.h&quot;
 40 #include &quot;ScriptController.h&quot;
 41 #include &quot;ScriptSourceCode.h&quot;
 42 #include &quot;SubresourceIntegrity.h&quot;
 43 #include &quot;WebCoreJSClientData.h&quot;
 44 #include &lt;JavaScriptCore/Completion.h&gt;
 45 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
<a name="2" id="anc2"></a>
 46 #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
 47 #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
 48 #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
 49 #include &lt;JavaScriptCore/JSSourceCode.h&gt;
 50 #include &lt;JavaScriptCore/JSString.h&gt;
 51 #include &lt;JavaScriptCore/Symbol.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 ScriptModuleLoader::ScriptModuleLoader(Document&amp; document)
 56     : m_document(document)
 57 {
 58 }
 59 
 60 ScriptModuleLoader::~ScriptModuleLoader()
 61 {
 62     for (auto&amp; loader : m_loaders)
 63         loader-&gt;clearClient();
 64 }
 65 
 66 static bool isRootModule(JSC::JSValue importerModuleKey)
 67 {
 68     return importerModuleKey.isSymbol() || importerModuleKey.isUndefined();
 69 }
 70 
 71 static Expected&lt;URL, ASCIILiteral&gt; resolveModuleSpecifier(Document&amp; document, const String&amp; specifier, const URL&amp; baseURL)
 72 {
 73     // https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier
 74 
 75     URL absoluteURL(URL(), specifier);
 76     if (absoluteURL.isValid())
 77         return absoluteURL;
 78 
 79     if (!specifier.startsWith(&#39;/&#39;) &amp;&amp; !specifier.startsWith(&quot;./&quot;) &amp;&amp; !specifier.startsWith(&quot;../&quot;))
 80         return makeUnexpected(&quot;Module specifier does not start with \&quot;/\&quot;, \&quot;./\&quot;, or \&quot;../\&quot;.&quot;_s);
 81 
 82     auto result = document.completeURL(specifier, baseURL);
 83     if (!result.isValid())
 84         return makeUnexpected(&quot;Module name does not resolve to a valid URL.&quot;_s);
 85     return result;
 86 }
 87 
<a name="3" id="anc3"></a><span class="line-modified"> 88 JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)</span>
 89 {
<a name="4" id="anc4"></a><span class="line-modified"> 90     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
 91     auto scope = DECLARE_THROW_SCOPE(vm);
 92 
 93     // We use a Symbol as a special purpose; It means this module is an inline module.
 94     // So there is no correct URL to retrieve the module source code. If the module name
 95     // value is a Symbol, it is used directly as a module key.
 96     if (moduleNameValue.isSymbol())
 97         return JSC::Identifier::fromUid(asSymbol(moduleNameValue)-&gt;privateName());
 98 
 99     if (!moduleNameValue.isString()) {
<a name="5" id="anc5"></a><span class="line-modified">100         JSC::throwTypeError(jsGlobalObject, scope, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
101         return { };
102     }
103 
<a name="6" id="anc6"></a><span class="line-modified">104     String specifier = asString(moduleNameValue)-&gt;value(jsGlobalObject);</span>
105     RETURN_IF_EXCEPTION(scope, { });
106 
107     URL baseURL;
108     if (isRootModule(importerModuleKey))
109         baseURL = m_document.baseURL();
110     else {
111         ASSERT(importerModuleKey.isString());
<a name="7" id="anc7"></a><span class="line-modified">112         URL importerModuleRequestURL(URL(), asString(importerModuleKey)-&gt;value(jsGlobalObject));</span>
113         ASSERT_WITH_MESSAGE(importerModuleRequestURL.isValid(), &quot;Invalid module referrer never starts importing dependent modules.&quot;);
114 
115         auto iterator = m_requestURLToResponseURLMap.find(importerModuleRequestURL);
116         ASSERT_WITH_MESSAGE(iterator != m_requestURLToResponseURLMap.end(), &quot;Module referrer must register itself to the map before starting importing dependent modules.&quot;);
117         baseURL = iterator-&gt;value;
118     }
119 
120     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
121     if (!result) {
<a name="8" id="anc8"></a><span class="line-modified">122         JSC::throwTypeError(jsGlobalObject, scope, result.error());</span>
123         return { };
124     }
125 
126     return JSC::Identifier::fromString(vm, result-&gt;string());
127 }
128 
129 static void rejectToPropagateNetworkError(DeferredPromise&amp; deferred, ModuleFetchFailureKind failureKind, ASCIILiteral message)
130 {
<a name="9" id="anc9"></a><span class="line-modified">131     deferred.rejectWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {</span>
132         // We annotate exception with special private symbol. It allows us to distinguish these errors from the user thrown ones.
<a name="10" id="anc10"></a><span class="line-modified">133         JSC::VM&amp; vm = jsGlobalObject.vm();</span>
134         // FIXME: Propagate more descriptive error.
135         // https://bugs.webkit.org/show_bug.cgi?id=167553
<a name="11" id="anc11"></a><span class="line-modified">136         auto* error = JSC::createTypeError(&amp;jsGlobalObject, message);</span>
137         ASSERT(error);
138         error-&gt;putDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName(), JSC::jsNumber(static_cast&lt;int32_t&gt;(failureKind)));
139         return error;
140     });
141 }
142 
<a name="12" id="anc12"></a><span class="line-modified">143 JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)</span>
144 {
<a name="13" id="anc13"></a><span class="line-modified">145     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
146     ASSERT(JSC::jsDynamicCast&lt;JSC::JSScriptFetcher*&gt;(vm, scriptFetcher));
147 
148     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
<a name="14" id="anc14"></a><span class="line-modified">149     auto* jsPromise = JSC::JSInternalPromise::create(vm, globalObject.internalPromiseStructure());</span>
150     RELEASE_ASSERT(jsPromise);
151     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
152     if (moduleKeyValue.isSymbol()) {
153         deferred-&gt;reject(TypeError, &quot;Symbol module key should be already fulfilled with the inlined resource.&quot;_s);
<a name="15" id="anc15"></a><span class="line-modified">154         return jsPromise;</span>
155     }
156 
157     if (!moduleKeyValue.isString()) {
158         deferred-&gt;reject(TypeError, &quot;Module key is not Symbol or String.&quot;_s);
<a name="16" id="anc16"></a><span class="line-modified">159         return jsPromise;</span>
160     }
161 
162     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
163 
<a name="17" id="anc17"></a><span class="line-modified">164     URL completedURL(URL(), asString(moduleKeyValue)-&gt;value(jsGlobalObject));</span>
165     if (!completedURL.isValid()) {
166         deferred-&gt;reject(TypeError, &quot;Module key is a valid URL.&quot;_s);
<a name="18" id="anc18"></a><span class="line-modified">167         return jsPromise;</span>
168     }
169 
170     RefPtr&lt;ModuleFetchParameters&gt; topLevelFetchParameters;
171     if (auto* scriptFetchParameters = JSC::jsDynamicCast&lt;JSC::JSScriptFetchParameters*&gt;(vm, parameters))
172         topLevelFetchParameters = static_cast&lt;ModuleFetchParameters*&gt;(&amp;scriptFetchParameters-&gt;parameters());
173 
174     auto loader = CachedModuleScriptLoader::create(*this, deferred.get(), *static_cast&lt;CachedScriptFetcher*&gt;(JSC::jsCast&lt;JSC::JSScriptFetcher*&gt;(scriptFetcher)-&gt;fetcher()), WTFMove(topLevelFetchParameters));
175     m_loaders.add(loader.copyRef());
176     if (!loader-&gt;load(m_document, completedURL)) {
177         loader-&gt;clearClient();
178         m_loaders.remove(WTFMove(loader));
179         rejectToPropagateNetworkError(deferred.get(), ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
<a name="19" id="anc19"></a><span class="line-modified">180         return jsPromise;</span>
181     }
182 
<a name="20" id="anc20"></a><span class="line-modified">183     return jsPromise;</span>
184 }
185 
<a name="21" id="anc21"></a><span class="line-modified">186 URL ScriptModuleLoader::moduleURL(JSC::JSGlobalObject&amp; jsGlobalObject, JSC::JSValue moduleKeyValue)</span>
187 {
188     if (moduleKeyValue.isSymbol())
189         return m_document.url();
190 
191     ASSERT(moduleKeyValue.isString());
<a name="22" id="anc22"></a><span class="line-modified">192     return URL(URL(), asString(moduleKeyValue)-&gt;value(&amp;jsGlobalObject));</span>
193 }
194 
<a name="23" id="anc23"></a><span class="line-modified">195 JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)</span>
196 {
<a name="24" id="anc24"></a><span class="line-modified">197     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>
198     auto scope = DECLARE_THROW_SCOPE(vm);
199 
200     // FIXME: Currently, we only support JSModuleRecord.
201     // Once the reflective part of the module loader is supported, we will handle arbitrary values.
202     // https://whatwg.github.io/loader/#registry-prototype-provide
203     auto* moduleRecord = JSC::jsDynamicCast&lt;JSC::JSModuleRecord*&gt;(vm, moduleRecordValue);
204     if (!moduleRecord)
205         return JSC::jsUndefined();
206 
<a name="25" id="anc25"></a><span class="line-modified">207     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);</span>
208     if (!sourceURL.isValid())
<a name="26" id="anc26"></a><span class="line-modified">209         return JSC::throwTypeError(jsGlobalObject, scope, &quot;Module key is an invalid URL.&quot;_s);</span>
210 
211     if (auto* frame = m_document.frame())
212         return frame-&gt;script().evaluateModule(sourceURL, *moduleRecord);
213     return JSC::jsUndefined();
214 }
215 
<a name="27" id="anc27"></a><span class="line-modified">216 static JSC::JSInternalPromise* rejectPromise(JSDOMGlobalObject&amp; globalObject, ExceptionCode ec, ASCIILiteral message)</span>
217 {
<a name="28" id="anc28"></a><span class="line-modified">218     auto* jsPromise = JSC::JSInternalPromise::create(globalObject.vm(), globalObject.internalPromiseStructure());</span>
219     RELEASE_ASSERT(jsPromise);
220     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
221     deferred-&gt;reject(ec, WTFMove(message));
<a name="29" id="anc29"></a><span class="line-modified">222     return jsPromise;</span>
223 }
224 
<a name="30" id="anc30"></a><span class="line-modified">225 JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)</span>
226 {
<a name="31" id="anc31"></a><span class="line-modified">227     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();</span>

228     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
229 
230     // If SourceOrigin and/or CachedScriptFetcher is null, we import the module with the default fetcher.
231     // SourceOrigin can be null if the source code is not coupled with the script file.
232     // The examples,
233     //     1. The code evaluated by the inspector.
234     //     2. The other unusual code execution like the evaluation through the NPAPI.
235     //     3. The code from injected bundle&#39;s script.
236     //     4. The code from extension script.
237     URL baseURL;
238     RefPtr&lt;JSC::ScriptFetcher&gt; scriptFetcher;
239     if (sourceOrigin.isNull()) {
240         baseURL = m_document.baseURL();
241         scriptFetcher = CachedScriptFetcher::create(m_document.charset());
242     } else {
243         baseURL = URL(URL(), sourceOrigin.string());
244         if (!baseURL.isValid())
<a name="32" id="anc32"></a><span class="line-modified">245             return rejectPromise(globalObject, TypeError, &quot;Importer module key is not a Symbol or a String.&quot;_s);</span>
246 
247         if (sourceOrigin.fetcher())
248             scriptFetcher = sourceOrigin.fetcher();
249         else
250             scriptFetcher = CachedScriptFetcher::create(m_document.charset());
251     }
252     ASSERT(baseURL.isValid());
253     ASSERT(scriptFetcher);
254 
<a name="33" id="anc33"></a><span class="line-modified">255     auto specifier = moduleName-&gt;value(jsGlobalObject);</span>
256     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
257     if (!result)
<a name="34" id="anc34"></a><span class="line-modified">258         return rejectPromise(globalObject, TypeError, result.error());</span>
259 
<a name="35" id="anc35"></a><span class="line-modified">260     return JSC::importModule(jsGlobalObject, JSC::Identifier::fromString(vm, result-&gt;string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));</span>
261 }
262 
<a name="36" id="anc36"></a><span class="line-modified">263 JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)</span>
264 {
<a name="37" id="anc37"></a><span class="line-modified">265     auto&amp; vm = jsGlobalObject-&gt;vm();</span>
266     auto scope = DECLARE_THROW_SCOPE(vm);
267 
<a name="38" id="anc38"></a><span class="line-modified">268     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);</span>
269     ASSERT(sourceURL.isValid());
270 
<a name="39" id="anc39"></a><span class="line-modified">271     auto* metaProperties = JSC::constructEmptyObject(vm, jsGlobalObject-&gt;nullPrototypeObjectStructure());</span>
272     RETURN_IF_EXCEPTION(scope, nullptr);
273 
274     metaProperties-&gt;putDirect(vm, JSC::Identifier::fromString(vm, &quot;url&quot;), JSC::jsString(vm, sourceURL.string()));
275     RETURN_IF_EXCEPTION(scope, nullptr);
276 
277     return metaProperties;
278 }
279 
280 void ScriptModuleLoader::notifyFinished(CachedModuleScriptLoader&amp; loader, RefPtr&lt;DeferredPromise&gt; promise)
281 {
282     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
283 
<a name="40" id="anc40"></a><span class="line-added">284     URL sourceURL = loader.sourceURL();</span>
285     if (!m_loaders.remove(&amp;loader))
286         return;
287     loader.clearClient();
288 
289     auto&amp; cachedScript = *loader.cachedScript();
290 
291     if (cachedScript.resourceError().isAccessControl()) {
292         promise-&gt;reject(TypeError, &quot;Cross-origin script load denied by Cross-Origin Resource Sharing policy.&quot;_s);
293         return;
294     }
295 
296     if (cachedScript.errorOccurred()) {
297         rejectToPropagateNetworkError(*promise, ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
298         return;
299     }
300 
301     if (cachedScript.wasCanceled()) {
302         rejectToPropagateNetworkError(*promise, ModuleFetchFailureKind::WasCanceled, &quot;Importing a module script is canceled.&quot;_s);
303         return;
304     }
305 
306     if (!MIMETypeRegistry::isSupportedJavaScriptMIMEType(cachedScript.response().mimeType())) {
307         // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
308         // The result of extracting a MIME type from response&#39;s header list (ignoring parameters) is not a JavaScript MIME type.
309         // For historical reasons, fetching a classic script does not include MIME type checking. In contrast, module scripts will fail to load if they are not of a correct MIME type.
310         promise-&gt;reject(TypeError, makeString(&quot;&#39;&quot;, cachedScript.response().mimeType(), &quot;&#39; is not a valid JavaScript MIME type.&quot;));
311         return;
312     }
313 
314     if (auto* parameters = loader.parameters()) {
315         if (!matchIntegrityMetadata(cachedScript, parameters-&gt;integrity())) {
<a name="41" id="anc41"></a><span class="line-modified">316             promise-&gt;reject(TypeError, makeString(&quot;Cannot load script &quot;, integrityMismatchDescription(cachedScript, parameters-&gt;integrity())));</span>
317             return;
318         }
319     }
320 
<a name="42" id="anc42"></a><span class="line-modified">321     m_requestURLToResponseURLMap.add(WTFMove(sourceURL), cachedScript.response().url());</span>
<span class="line-modified">322     promise-&gt;resolveWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {</span>
<span class="line-modified">323         return JSC::JSSourceCode::create(jsGlobalObject.vm(),</span>
324             JSC::SourceCode { ScriptSourceCode { &amp;cachedScript, JSC::SourceProviderSourceType::Module, loader.scriptFetcher() }.jsSourceCode() });
325     });
326 }
327 
328 }
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
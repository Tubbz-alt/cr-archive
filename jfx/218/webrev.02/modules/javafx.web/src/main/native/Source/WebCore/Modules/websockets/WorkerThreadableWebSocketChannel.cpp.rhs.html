<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/websockets/WorkerThreadableWebSocketChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011, 2012 Google Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;WorkerThreadableWebSocketChannel.h&quot;
 33 
 34 #include &quot;Blob.h&quot;
 35 #include &quot;Document.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 36 #include &quot;Frame.h&quot;</span>
<span class="line-added"> 37 #include &quot;FrameLoader.h&quot;</span>
 38 #include &quot;ScriptExecutionContext.h&quot;
 39 #include &quot;SocketProvider.h&quot;
 40 #include &quot;ThreadableWebSocketChannelClientWrapper.h&quot;
 41 #include &quot;WebSocketChannel.h&quot;
 42 #include &quot;WebSocketChannelClient.h&quot;
 43 #include &quot;WorkerGlobalScope.h&quot;
 44 #include &quot;WorkerLoaderProxy.h&quot;
 45 #include &quot;WorkerRunLoop.h&quot;
 46 #include &quot;WorkerThread.h&quot;
 47 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 48 #include &lt;wtf/MainThread.h&gt;
 49 #include &lt;wtf/text/WTFString.h&gt;
 50 
 51 namespace WebCore {
 52 
 53 WorkerThreadableWebSocketChannel::WorkerThreadableWebSocketChannel(WorkerGlobalScope&amp; context, WebSocketChannelClient&amp; client, const String&amp; taskMode, SocketProvider&amp; provider)
 54     : m_workerGlobalScope(context)
 55     , m_workerClientWrapper(ThreadableWebSocketChannelClientWrapper::create(context, client))
 56     , m_bridge(Bridge::create(m_workerClientWrapper.copyRef(), m_workerGlobalScope.copyRef(), taskMode, provider))
 57     , m_socketProvider(provider)
 58 {
 59     m_bridge-&gt;initialize();
 60 }
 61 
 62 WorkerThreadableWebSocketChannel::~WorkerThreadableWebSocketChannel()
 63 {
 64     if (m_bridge)
 65         m_bridge-&gt;disconnect();
 66 }
 67 
 68 WorkerThreadableWebSocketChannel::ConnectStatus WorkerThreadableWebSocketChannel::connect(const URL&amp; url, const String&amp; protocol)
 69 {
 70     if (m_bridge)
 71         m_bridge-&gt;connect(url, protocol);
 72     // connect is called asynchronously, so we do not have any possibility for synchronous errors.
 73     return ConnectStatus::OK;
 74 }
 75 
 76 String WorkerThreadableWebSocketChannel::subprotocol()
 77 {
 78     return m_workerClientWrapper-&gt;subprotocol();
 79 }
 80 
 81 String WorkerThreadableWebSocketChannel::extensions()
 82 {
 83     return m_workerClientWrapper-&gt;extensions();
 84 }
 85 
 86 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::send(const String&amp; message)
 87 {
 88     if (!m_bridge)
 89         return ThreadableWebSocketChannel::SendFail;
 90     return m_bridge-&gt;send(message);
 91 }
 92 
 93 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::send(const ArrayBuffer&amp; binaryData, unsigned byteOffset, unsigned byteLength)
 94 {
 95     if (!m_bridge)
 96         return ThreadableWebSocketChannel::SendFail;
 97     return m_bridge-&gt;send(binaryData, byteOffset, byteLength);
 98 }
 99 
100 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::send(Blob&amp; binaryData)
101 {
102     if (!m_bridge)
103         return ThreadableWebSocketChannel::SendFail;
104     return m_bridge-&gt;send(binaryData);
105 }
106 
107 unsigned WorkerThreadableWebSocketChannel::bufferedAmount() const
108 {
109     if (!m_bridge)
110         return 0;
111     return m_bridge-&gt;bufferedAmount();
112 }
113 
114 void WorkerThreadableWebSocketChannel::close(int code, const String&amp; reason)
115 {
116     if (m_bridge)
117         m_bridge-&gt;close(code, reason);
118 }
119 
120 void WorkerThreadableWebSocketChannel::fail(const String&amp; reason)
121 {
122     if (m_bridge)
123         m_bridge-&gt;fail(reason);
124 }
125 
126 void WorkerThreadableWebSocketChannel::disconnect()
127 {
128     m_bridge-&gt;disconnect();
129     m_bridge = nullptr;
130 }
131 
132 void WorkerThreadableWebSocketChannel::suspend()
133 {
134     m_workerClientWrapper-&gt;suspend();
135     if (m_bridge)
136         m_bridge-&gt;suspend();
137 }
138 
139 void WorkerThreadableWebSocketChannel::resume()
140 {
141     m_workerClientWrapper-&gt;resume();
142     if (m_bridge)
143         m_bridge-&gt;resume();
144 }
145 
146 WorkerThreadableWebSocketChannel::Peer::Peer(Ref&lt;ThreadableWebSocketChannelClientWrapper&gt;&amp;&amp; clientWrapper, WorkerLoaderProxy&amp; loaderProxy, ScriptExecutionContext&amp; context, const String&amp; taskMode, SocketProvider&amp; provider)
147     : m_workerClientWrapper(WTFMove(clientWrapper))
148     , m_loaderProxy(loaderProxy)
149     , m_mainWebSocketChannel(ThreadableWebSocketChannel::create(downcast&lt;Document&gt;(context), *this, provider))
150     , m_taskMode(taskMode)
151 {
152     ASSERT(isMainThread());
153 }
154 
155 WorkerThreadableWebSocketChannel::Peer::~Peer()
156 {
157     ASSERT(isMainThread());
158     if (m_mainWebSocketChannel)
159         m_mainWebSocketChannel-&gt;disconnect();
160 }
161 
162 WorkerThreadableWebSocketChannel::ConnectStatus WorkerThreadableWebSocketChannel::Peer::connect(const URL&amp; url, const String&amp; protocol)
163 {
164     ASSERT(isMainThread());
165     if (!m_mainWebSocketChannel)
166         return WorkerThreadableWebSocketChannel::ConnectStatus::KO;
167     return m_mainWebSocketChannel-&gt;connect(url, protocol);
168 }
169 
170 void WorkerThreadableWebSocketChannel::Peer::send(const String&amp; message)
171 {
172     ASSERT(isMainThread());
173     if (!m_mainWebSocketChannel)
174         return;
175 
176     ThreadableWebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel-&gt;send(message);
177     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), sendRequestResult](ScriptExecutionContext&amp;) mutable {
178         workerClientWrapper-&gt;setSendRequestResult(sendRequestResult);
179     }, m_taskMode);
180 }
181 
182 void WorkerThreadableWebSocketChannel::Peer::send(const ArrayBuffer&amp; binaryData)
183 {
184     ASSERT(isMainThread());
185     if (!m_mainWebSocketChannel)
186         return;
187 
188     ThreadableWebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel-&gt;send(binaryData, 0, binaryData.byteLength());
189     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), sendRequestResult](ScriptExecutionContext&amp;) mutable {
190         workerClientWrapper-&gt;setSendRequestResult(sendRequestResult);
191     }, m_taskMode);
192 }
193 
194 void WorkerThreadableWebSocketChannel::Peer::send(Blob&amp; binaryData)
195 {
196     ASSERT(isMainThread());
197     if (!m_mainWebSocketChannel)
198         return;
199 
200     ThreadableWebSocketChannel::SendResult sendRequestResult = m_mainWebSocketChannel-&gt;send(binaryData);
201     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), sendRequestResult](ScriptExecutionContext&amp;) mutable {
202         workerClientWrapper-&gt;setSendRequestResult(sendRequestResult);
203     }, m_taskMode);
204 }
205 
206 void WorkerThreadableWebSocketChannel::Peer::bufferedAmount()
207 {
208     ASSERT(isMainThread());
209     if (!m_mainWebSocketChannel)
210         return;
211 
212     unsigned bufferedAmount = m_mainWebSocketChannel-&gt;bufferedAmount();
213     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), bufferedAmount](ScriptExecutionContext&amp; context) mutable {
214         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
215         workerClientWrapper-&gt;setBufferedAmount(bufferedAmount);
216     }, m_taskMode);
217 }
218 
219 void WorkerThreadableWebSocketChannel::Peer::close(int code, const String&amp; reason)
220 {
221     ASSERT(isMainThread());
222     if (!m_mainWebSocketChannel)
223         return;
224     m_mainWebSocketChannel-&gt;close(code, reason);
225 }
226 
227 void WorkerThreadableWebSocketChannel::Peer::fail(const String&amp; reason)
228 {
229     ASSERT(isMainThread());
230     if (!m_mainWebSocketChannel)
231         return;
232     m_mainWebSocketChannel-&gt;fail(reason);
233 }
234 
235 void WorkerThreadableWebSocketChannel::Peer::disconnect()
236 {
237     ASSERT(isMainThread());
238     if (!m_mainWebSocketChannel)
239         return;
240     m_mainWebSocketChannel-&gt;disconnect();
241     m_mainWebSocketChannel = nullptr;
242 }
243 
244 void WorkerThreadableWebSocketChannel::Peer::suspend()
245 {
246     ASSERT(isMainThread());
247     if (!m_mainWebSocketChannel)
248         return;
249     m_mainWebSocketChannel-&gt;suspend();
250 }
251 
252 void WorkerThreadableWebSocketChannel::Peer::resume()
253 {
254     ASSERT(isMainThread());
255     if (!m_mainWebSocketChannel)
256         return;
257     m_mainWebSocketChannel-&gt;resume();
258 }
259 
260 void WorkerThreadableWebSocketChannel::Peer::didConnect()
261 {
262     ASSERT(isMainThread());
263 
264     String subprotocol = m_mainWebSocketChannel-&gt;subprotocol();
265     String extensions = m_mainWebSocketChannel-&gt;extensions();
266     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), subprotocol = subprotocol.isolatedCopy(), extensions = extensions.isolatedCopy()](ScriptExecutionContext&amp; context) mutable {
267         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
268         workerClientWrapper-&gt;setSubprotocol(subprotocol);
269         workerClientWrapper-&gt;setExtensions(extensions);
270         workerClientWrapper-&gt;didConnect();
271     }, m_taskMode);
272 }
273 
274 void WorkerThreadableWebSocketChannel::Peer::didReceiveMessage(const String&amp; message)
275 {
276     ASSERT(isMainThread());
277 
278     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), message = message.isolatedCopy()](ScriptExecutionContext&amp; context) mutable {
279         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
280         workerClientWrapper-&gt;didReceiveMessage(message);
281     }, m_taskMode);
282 }
283 
284 void WorkerThreadableWebSocketChannel::Peer::didReceiveBinaryData(Vector&lt;uint8_t&gt;&amp;&amp; binaryData)
285 {
286     ASSERT(isMainThread());
287 
288     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), binaryData = WTFMove(binaryData)](ScriptExecutionContext&amp; context) mutable {
289         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
290         workerClientWrapper-&gt;didReceiveBinaryData(WTFMove(binaryData));
291     }, m_taskMode);
292 }
293 
294 void WorkerThreadableWebSocketChannel::Peer::didUpdateBufferedAmount(unsigned bufferedAmount)
295 {
296     ASSERT(isMainThread());
297 
298     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), bufferedAmount](ScriptExecutionContext&amp; context) mutable {
299         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
300         workerClientWrapper-&gt;didUpdateBufferedAmount(bufferedAmount);
301     }, m_taskMode);
302 }
303 
304 void WorkerThreadableWebSocketChannel::Peer::didStartClosingHandshake()
305 {
306     ASSERT(isMainThread());
307 
308     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef()](ScriptExecutionContext&amp; context) mutable {
309         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
310         workerClientWrapper-&gt;didStartClosingHandshake();
311     }, m_taskMode);
312 }
313 
314 void WorkerThreadableWebSocketChannel::Peer::didClose(unsigned unhandledBufferedAmount, ClosingHandshakeCompletionStatus closingHandshakeCompletion, unsigned short code, const String&amp; reason)
315 {
316     ASSERT(isMainThread());
317     m_mainWebSocketChannel = nullptr;
318 
319     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef(), unhandledBufferedAmount, closingHandshakeCompletion, code, reason = reason.isolatedCopy()](ScriptExecutionContext&amp; context) mutable {
320             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
321             workerClientWrapper-&gt;didClose(unhandledBufferedAmount, closingHandshakeCompletion, code, reason);
322         }, m_taskMode);
323 }
324 
325 void WorkerThreadableWebSocketChannel::Peer::didReceiveMessageError()
326 {
327     ASSERT(isMainThread());
328 
329     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef()](ScriptExecutionContext&amp; context) mutable {
330         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
331         workerClientWrapper-&gt;didReceiveMessageError();
332     }, m_taskMode);
333 }
334 
335 void WorkerThreadableWebSocketChannel::Peer::didUpgradeURL()
336 {
337     ASSERT(isMainThread());
338 
339     m_loaderProxy.postTaskForModeToWorkerGlobalScope([workerClientWrapper = m_workerClientWrapper.copyRef()](ScriptExecutionContext&amp; context) mutable {
340         ASSERT_UNUSED(context, context.isWorkerGlobalScope());
341         workerClientWrapper-&gt;didUpgradeURL();
342     }, m_taskMode);
343 }
344 
345 WorkerThreadableWebSocketChannel::Bridge::Bridge(Ref&lt;ThreadableWebSocketChannelClientWrapper&gt;&amp;&amp; workerClientWrapper, Ref&lt;WorkerGlobalScope&gt;&amp;&amp; workerGlobalScope, const String&amp; taskMode, Ref&lt;SocketProvider&gt;&amp;&amp; socketProvider)
346     : m_workerClientWrapper(WTFMove(workerClientWrapper))
347     , m_workerGlobalScope(WTFMove(workerGlobalScope))
348     , m_loaderProxy(m_workerGlobalScope-&gt;thread().workerLoaderProxy())
349     , m_taskMode(taskMode)
350     , m_socketProvider(WTFMove(socketProvider))
351 {
352 }
353 
354 WorkerThreadableWebSocketChannel::Bridge::~Bridge()
355 {
356     disconnect();
357 }
358 
359 void WorkerThreadableWebSocketChannel::Bridge::mainThreadInitialize(ScriptExecutionContext&amp; context, WorkerLoaderProxy&amp; loaderProxy, Ref&lt;ThreadableWebSocketChannelClientWrapper&gt;&amp;&amp; clientWrapper, const String&amp; taskMode, Ref&lt;SocketProvider&gt;&amp;&amp; provider)
360 {
361     ASSERT(isMainThread());
362     ASSERT(context.isDocument());
363 
364     bool sent = loaderProxy.postTaskForModeToWorkerGlobalScope({
365         ScriptExecutionContext::Task::CleanupTask,
366         [clientWrapper = clientWrapper.copyRef(), &amp;loaderProxy, peer = makeUnique&lt;Peer&gt;(clientWrapper.copyRef(), loaderProxy, context, taskMode, WTFMove(provider))](ScriptExecutionContext&amp; context) mutable {
367             ASSERT_UNUSED(context, context.isWorkerGlobalScope());
368             if (clientWrapper-&gt;failedWebSocketChannelCreation()) {
369                 // If Bridge::initialize() quitted earlier, we need to kick mainThreadDestroy() to delete the peer.
370                 loaderProxy.postTaskToLoader([peer = WTFMove(peer)](ScriptExecutionContext&amp; context) {
371                     ASSERT(isMainThread());
372                     ASSERT_UNUSED(context, context.isDocument());
373                 });
374             } else
375                 clientWrapper-&gt;didCreateWebSocketChannel(peer.release());
376         }
377     }, taskMode);
378 
379     if (!sent)
380         clientWrapper-&gt;clearPeer();
381 }
382 
383 void WorkerThreadableWebSocketChannel::Bridge::initialize()
384 {
385     ASSERT(!m_peer);
386     setMethodNotCompleted();
387     Ref&lt;Bridge&gt; protectedThis(*this);
388 
389     m_loaderProxy.postTaskToLoader([&amp;loaderProxy = m_loaderProxy, workerClientWrapper = m_workerClientWrapper.copyRef(), taskMode = m_taskMode.isolatedCopy(), provider = m_socketProvider.copyRef()](ScriptExecutionContext&amp; context) mutable {
390         mainThreadInitialize(context, loaderProxy, WTFMove(workerClientWrapper), taskMode, WTFMove(provider));
391     });
392     waitForMethodCompletion();
393 
394     // m_peer may be null when the nested runloop exited before a peer has created.
395     m_peer = m_workerClientWrapper-&gt;peer();
396     if (!m_peer)
397         m_workerClientWrapper-&gt;setFailedWebSocketChannelCreation();
398 }
399 
400 void WorkerThreadableWebSocketChannel::Bridge::connect(const URL&amp; url, const String&amp; protocol)
401 {
402     if (!m_peer)
403         return;
404 
405     m_loaderProxy.postTaskToLoader([peer = m_peer, url = url.isolatedCopy(), protocol = protocol.isolatedCopy()](ScriptExecutionContext&amp; context) {
406         ASSERT(isMainThread());
<a name="2" id="anc2"></a><span class="line-modified">407         ASSERT(context.isDocument());</span>
408         ASSERT(peer);
409 
<a name="3" id="anc3"></a><span class="line-added">410         auto&amp; document = downcast&lt;Document&gt;(context);</span>
<span class="line-added">411 </span>
<span class="line-added">412         // FIXME: make this mixed content check equivalent to the document mixed content check currently in WebSocket::connect()</span>
<span class="line-added">413         if (document.frame()) {</span>
<span class="line-added">414             Optional&lt;String&gt; errorString = document.frame()-&gt;loader().mixedContentChecker().checkForMixedContentInFrameTree(url);</span>
<span class="line-added">415             if (errorString) {</span>
<span class="line-added">416                 peer-&gt;fail(errorString.value());</span>
<span class="line-added">417                 return;</span>
<span class="line-added">418             }</span>
<span class="line-added">419         }</span>
<span class="line-added">420 </span>
421         if (peer-&gt;connect(url, protocol) == ThreadableWebSocketChannel::ConnectStatus::KO)
422             peer-&gt;didReceiveMessageError();
423     });
424 }
425 
426 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(const String&amp; message)
427 {
428     if (!m_peer)
429         return ThreadableWebSocketChannel::SendFail;
430     setMethodNotCompleted();
431 
432     m_loaderProxy.postTaskToLoader([peer = m_peer, message = message.isolatedCopy()](ScriptExecutionContext&amp; context) {
433         ASSERT(isMainThread());
434         ASSERT_UNUSED(context, context.isDocument());
435         ASSERT(peer);
436 
437         peer-&gt;send(message);
438     });
439 
440     Ref&lt;Bridge&gt; protectedThis(*this);
441     waitForMethodCompletion();
442     return m_workerClientWrapper-&gt;sendRequestResult();
443 }
444 
445 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(const ArrayBuffer&amp; binaryData, unsigned byteOffset, unsigned byteLength)
446 {
447     if (!m_peer)
448         return ThreadableWebSocketChannel::SendFail;
449 
450     // ArrayBuffer isn&#39;t thread-safe, hence the content of ArrayBuffer is copied into Vector&lt;char&gt;.
451     Vector&lt;char&gt; data(byteLength);
452     if (binaryData.byteLength())
453         memcpy(data.data(), static_cast&lt;const char*&gt;(binaryData.data()) + byteOffset, byteLength);
454     setMethodNotCompleted();
455 
456     m_loaderProxy.postTaskToLoader([peer = m_peer, data = WTFMove(data)](ScriptExecutionContext&amp; context) {
457         ASSERT(isMainThread());
458         ASSERT_UNUSED(context, context.isDocument());
459         ASSERT(peer);
460 
461         auto arrayBuffer = ArrayBuffer::create(data.data(), data.size());
462         peer-&gt;send(arrayBuffer);
463     });
464 
465     Ref&lt;Bridge&gt; protectedThis(*this);
466     waitForMethodCompletion();
467     return m_workerClientWrapper-&gt;sendRequestResult();
468 }
469 
470 ThreadableWebSocketChannel::SendResult WorkerThreadableWebSocketChannel::Bridge::send(Blob&amp; binaryData)
471 {
472     if (!m_peer)
473         return ThreadableWebSocketChannel::SendFail;
474     setMethodNotCompleted();
475 
476     m_loaderProxy.postTaskToLoader([peer = m_peer, url = binaryData.url().isolatedCopy(), type = binaryData.type().isolatedCopy(), size = binaryData.size()](ScriptExecutionContext&amp; context) {
477         ASSERT(isMainThread());
478         ASSERT_UNUSED(context, context.isDocument());
479         ASSERT(peer);
480 
<a name="4" id="anc4"></a><span class="line-modified">481         peer-&gt;send(Blob::deserialize(url, type, size, { }));</span>
482     });
483 
484     Ref&lt;Bridge&gt; protectedThis(*this);
485     waitForMethodCompletion();
486     return m_workerClientWrapper-&gt;sendRequestResult();
487 }
488 
489 unsigned WorkerThreadableWebSocketChannel::Bridge::bufferedAmount()
490 {
491     if (!m_peer)
492         return 0;
493     setMethodNotCompleted();
494 
495     m_loaderProxy.postTaskToLoader([peer = m_peer](ScriptExecutionContext&amp; context) {
496         ASSERT(isMainThread());
497         ASSERT_UNUSED(context, context.isDocument());
498         ASSERT(peer);
499 
500         peer-&gt;bufferedAmount();
501     });
502 
503     Ref&lt;Bridge&gt; protectedThis(*this);
504     waitForMethodCompletion();
505     return m_workerClientWrapper-&gt;bufferedAmount();
506 }
507 
508 void WorkerThreadableWebSocketChannel::Bridge::close(int code, const String&amp; reason)
509 {
510     if (!m_peer)
511         return;
512 
513     m_loaderProxy.postTaskToLoader([peer = m_peer, code, reason = reason.isolatedCopy()](ScriptExecutionContext&amp; context) {
514         ASSERT(isMainThread());
515         ASSERT_UNUSED(context, context.isDocument());
516         ASSERT(peer);
517 
518         peer-&gt;close(code, reason);
519     });
520 }
521 
522 void WorkerThreadableWebSocketChannel::Bridge::fail(const String&amp; reason)
523 {
524     if (!m_peer)
525         return;
526 
527     m_loaderProxy.postTaskToLoader([peer = m_peer, reason = reason.isolatedCopy()](ScriptExecutionContext&amp; context) {
528         ASSERT(isMainThread());
529         ASSERT_UNUSED(context, context.isDocument());
530         ASSERT(peer);
531 
532         peer-&gt;fail(reason);
533     });
534 }
535 
536 void WorkerThreadableWebSocketChannel::Bridge::disconnect()
537 {
538     clearClientWrapper();
539     if (m_peer) {
540         m_loaderProxy.postTaskToLoader([peer = std::unique_ptr&lt;Peer&gt;(m_peer)](ScriptExecutionContext&amp; context) {
541             ASSERT(isMainThread());
542             ASSERT_UNUSED(context, context.isDocument());
543         });
544         m_peer = nullptr;
545     }
546     m_workerGlobalScope = nullptr;
547 }
548 
549 void WorkerThreadableWebSocketChannel::Bridge::suspend()
550 {
551     if (!m_peer)
552         return;
553 
554     m_loaderProxy.postTaskToLoader([peer = m_peer](ScriptExecutionContext&amp; context) {
555         ASSERT(isMainThread());
556         ASSERT_UNUSED(context, context.isDocument());
557         ASSERT(peer);
558 
559         peer-&gt;suspend();
560     });
561 }
562 
563 void WorkerThreadableWebSocketChannel::Bridge::resume()
564 {
565     if (!m_peer)
566         return;
567 
568     m_loaderProxy.postTaskToLoader([peer = m_peer](ScriptExecutionContext&amp; context) {
569         ASSERT(isMainThread());
570         ASSERT_UNUSED(context, context.isDocument());
571         ASSERT(peer);
572 
573         peer-&gt;resume();
574     });
575 }
576 
577 void WorkerThreadableWebSocketChannel::Bridge::clearClientWrapper()
578 {
579     m_workerClientWrapper-&gt;clearClient();
580 }
581 
582 void WorkerThreadableWebSocketChannel::Bridge::setMethodNotCompleted()
583 {
584     m_workerClientWrapper-&gt;clearSyncMethodDone();
585 }
586 
587 // Caller of this function should hold a reference to the bridge, because this function may call WebSocket::didClose() in the end,
588 // which causes the bridge to get disconnected from the WebSocket and deleted if there is no other reference.
589 void WorkerThreadableWebSocketChannel::Bridge::waitForMethodCompletion()
590 {
591     if (!m_workerGlobalScope)
592         return;
593     WorkerRunLoop&amp; runLoop = m_workerGlobalScope-&gt;thread().runLoop();
594     MessageQueueWaitResult result = MessageQueueMessageReceived;
595     ThreadableWebSocketChannelClientWrapper* clientWrapper = m_workerClientWrapper.ptr();
596     while (m_workerGlobalScope &amp;&amp; clientWrapper &amp;&amp; !clientWrapper-&gt;syncMethodDone() &amp;&amp; result != MessageQueueTerminated) {
597         result = runLoop.runInMode(m_workerGlobalScope.get(), m_taskMode); // May cause this bridge to get disconnected, which makes m_workerGlobalScope become null.
598         clientWrapper = m_workerClientWrapper.ptr();
599     }
600 }
601 
602 } // namespace WebCore
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
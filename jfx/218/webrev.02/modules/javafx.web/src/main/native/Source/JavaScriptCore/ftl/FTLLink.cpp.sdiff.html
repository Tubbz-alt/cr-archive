<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLink.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLJITFinalizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLLocation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLink.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
116 
117         dumpContext.dump(out, prefix);
118         compilation-&gt;addDescription(Profiler::OriginStack(), out.toCString());
119         out.reset();
120 
121         out.print(&quot;    Disassembly:\n&quot;);
122         out.print(&quot;        &lt;not implemented yet&gt;\n&quot;);
123         compilation-&gt;addDescription(Profiler::OriginStack(), out.toCString());
124         out.reset();
125 
126         state.jitCode-&gt;common.compilation = compilation;
127     }
128 
129     switch (graph.m_plan.mode()) {
130     case FTLMode: {
131         bool requiresArityFixup = codeBlock-&gt;numParameters() != 1;
132         if (codeBlock-&gt;codeType() == FunctionCode &amp;&amp; requiresArityFixup) {
133             CCallHelpers::JumpList mainPathJumps;
134 
135             jit.load32(
<span class="line-modified">136                 frame.withOffset(sizeof(Register) * CallFrameSlot::argumentCount),</span>
137                 GPRInfo::regT1);
138             mainPathJumps.append(jit.branch32(
139                                      CCallHelpers::AboveOrEqual, GPRInfo::regT1,
140                                      CCallHelpers::TrustedImm32(codeBlock-&gt;numParameters())));
141             jit.emitFunctionPrologue();
<span class="line-modified">142             jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
143             jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
144             CCallHelpers::Call callArityCheck = jit.call(OperationPtrTag);
145 
146             auto noException = jit.branch32(CCallHelpers::GreaterThanOrEqual, GPRInfo::returnValueGPR, CCallHelpers::TrustedImm32(0));
147             jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
148             jit.move(CCallHelpers::TrustedImmPtr(&amp;vm), GPRInfo::argumentGPR0);
<span class="line-modified">149             jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);</span>
150             CCallHelpers::Call callLookupExceptionHandlerFromCallerFrame = jit.call(OperationPtrTag);
151             jit.jumpToExceptionHandler(vm);
152             noException.link(&amp;jit);
153 
<span class="line-modified">154             if (!ASSERT_DISABLED) {</span>
155                 jit.load64(vm.addressOfException(), GPRInfo::regT1);
156                 jit.jitAssertIsNull(GPRInfo::regT1);
157             }
158 
159             jit.move(GPRInfo::returnValueGPR, GPRInfo::argumentGPR0);
160             jit.emitFunctionEpilogue();
161             jit.untagReturnAddress();
162             mainPathJumps.append(jit.branchTest32(CCallHelpers::Zero, GPRInfo::argumentGPR0));
163             jit.emitFunctionPrologue();
164             CCallHelpers::Call callArityFixup = jit.nearCall();
165             jit.emitFunctionEpilogue();
166             jit.untagReturnAddress();
167             mainPathJumps.append(jit.jump());
168 
169             linkBuffer = makeUnique&lt;LinkBuffer&gt;(jit, codeBlock, JITCompilationCanFail);
170             if (linkBuffer-&gt;didFailToAllocate()) {
171                 state.allocationFailed = true;
172                 return;
173             }
174             linkBuffer-&gt;link(callArityCheck, FunctionPtr&lt;OperationPtrTag&gt;(codeBlock-&gt;isConstructor() ? operationConstructArityCheck : operationCallArityCheck));
<span class="line-modified">175             linkBuffer-&gt;link(callLookupExceptionHandlerFromCallerFrame, FunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandlerFromCallerFrame));</span>
176             linkBuffer-&gt;link(callArityFixup, FunctionPtr&lt;JITThunkPtrTag&gt;(vm.getCTIStub(arityFixupGenerator).code()));
177             linkBuffer-&gt;link(mainPathJumps, state.generatedFunction);
178         }
179 
180         state.jitCode-&gt;initializeAddressForCall(state.generatedFunction);
181         break;
182     }
183 
184     case FTLForOSREntryMode: {
185         // We jump to here straight from DFG code, after having boxed up all of the
186         // values into the scratch buffer. Everything should be good to go - at this
187         // point we&#39;ve even done the stack check. Basically we just have to make the
188         // call to the B3-generated code.
189         CCallHelpers::Label start = jit.label();
190         jit.emitFunctionEpilogue();
191         jit.untagReturnAddress();
192         CCallHelpers::Jump mainPathJump = jit.jump();
193 
194         linkBuffer = makeUnique&lt;LinkBuffer&gt;(jit, codeBlock, JITCompilationCanFail);
195         if (linkBuffer-&gt;didFailToAllocate()) {
</pre>
</td>
<td>
<hr />
<pre>
116 
117         dumpContext.dump(out, prefix);
118         compilation-&gt;addDescription(Profiler::OriginStack(), out.toCString());
119         out.reset();
120 
121         out.print(&quot;    Disassembly:\n&quot;);
122         out.print(&quot;        &lt;not implemented yet&gt;\n&quot;);
123         compilation-&gt;addDescription(Profiler::OriginStack(), out.toCString());
124         out.reset();
125 
126         state.jitCode-&gt;common.compilation = compilation;
127     }
128 
129     switch (graph.m_plan.mode()) {
130     case FTLMode: {
131         bool requiresArityFixup = codeBlock-&gt;numParameters() != 1;
132         if (codeBlock-&gt;codeType() == FunctionCode &amp;&amp; requiresArityFixup) {
133             CCallHelpers::JumpList mainPathJumps;
134 
135             jit.load32(
<span class="line-modified">136                 frame.withOffset(sizeof(Register) * CallFrameSlot::argumentCountIncludingThis),</span>
137                 GPRInfo::regT1);
138             mainPathJumps.append(jit.branch32(
139                                      CCallHelpers::AboveOrEqual, GPRInfo::regT1,
140                                      CCallHelpers::TrustedImm32(codeBlock-&gt;numParameters())));
141             jit.emitFunctionPrologue();
<span class="line-modified">142             jit.move(CCallHelpers::TrustedImmPtr(codeBlock-&gt;globalObject()), GPRInfo::argumentGPR0);</span>
143             jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
144             CCallHelpers::Call callArityCheck = jit.call(OperationPtrTag);
145 
146             auto noException = jit.branch32(CCallHelpers::GreaterThanOrEqual, GPRInfo::returnValueGPR, CCallHelpers::TrustedImm32(0));
147             jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
148             jit.move(CCallHelpers::TrustedImmPtr(&amp;vm), GPRInfo::argumentGPR0);
<span class="line-modified">149             jit.prepareCallOperation(vm);</span>
150             CCallHelpers::Call callLookupExceptionHandlerFromCallerFrame = jit.call(OperationPtrTag);
151             jit.jumpToExceptionHandler(vm);
152             noException.link(&amp;jit);
153 
<span class="line-modified">154             if (ASSERT_ENABLED) {</span>
155                 jit.load64(vm.addressOfException(), GPRInfo::regT1);
156                 jit.jitAssertIsNull(GPRInfo::regT1);
157             }
158 
159             jit.move(GPRInfo::returnValueGPR, GPRInfo::argumentGPR0);
160             jit.emitFunctionEpilogue();
161             jit.untagReturnAddress();
162             mainPathJumps.append(jit.branchTest32(CCallHelpers::Zero, GPRInfo::argumentGPR0));
163             jit.emitFunctionPrologue();
164             CCallHelpers::Call callArityFixup = jit.nearCall();
165             jit.emitFunctionEpilogue();
166             jit.untagReturnAddress();
167             mainPathJumps.append(jit.jump());
168 
169             linkBuffer = makeUnique&lt;LinkBuffer&gt;(jit, codeBlock, JITCompilationCanFail);
170             if (linkBuffer-&gt;didFailToAllocate()) {
171                 state.allocationFailed = true;
172                 return;
173             }
174             linkBuffer-&gt;link(callArityCheck, FunctionPtr&lt;OperationPtrTag&gt;(codeBlock-&gt;isConstructor() ? operationConstructArityCheck : operationCallArityCheck));
<span class="line-modified">175             linkBuffer-&gt;link(callLookupExceptionHandlerFromCallerFrame, FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandlerFromCallerFrame));</span>
176             linkBuffer-&gt;link(callArityFixup, FunctionPtr&lt;JITThunkPtrTag&gt;(vm.getCTIStub(arityFixupGenerator).code()));
177             linkBuffer-&gt;link(mainPathJumps, state.generatedFunction);
178         }
179 
180         state.jitCode-&gt;initializeAddressForCall(state.generatedFunction);
181         break;
182     }
183 
184     case FTLForOSREntryMode: {
185         // We jump to here straight from DFG code, after having boxed up all of the
186         // values into the scratch buffer. Everything should be good to go - at this
187         // point we&#39;ve even done the stack check. Basically we just have to make the
188         // call to the B3-generated code.
189         CCallHelpers::Label start = jit.label();
190         jit.emitFunctionEpilogue();
191         jit.untagReturnAddress();
192         CCallHelpers::Jump mainPathJump = jit.jump();
193 
194         linkBuffer = makeUnique&lt;LinkBuffer&gt;(jit, codeBlock, JITCompilationCanFail);
195         if (linkBuffer-&gt;didFailToAllocate()) {
</pre>
</td>
</tr>
</table>
<center><a href="FTLJITFinalizer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLLocation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
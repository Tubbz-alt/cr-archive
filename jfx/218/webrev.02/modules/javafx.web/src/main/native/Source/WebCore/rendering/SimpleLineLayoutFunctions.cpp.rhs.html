<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SimpleLineLayoutFunctions.h&quot;
 28 
 29 #include &quot;BidiRun.h&quot;
 30 #include &quot;BidiRunList.h&quot;
 31 #include &quot;EventRegion.h&quot;
 32 #include &quot;FontCache.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;GraphicsContext.h&quot;
 35 #include &quot;HitTestLocation.h&quot;
 36 #include &quot;HitTestRequest.h&quot;
 37 #include &quot;HitTestResult.h&quot;
 38 #include &quot;InlineTextBox.h&quot;
 39 #include &quot;LineInfo.h&quot;
 40 #include &quot;PaintInfo.h&quot;
 41 #include &quot;RenderBlockFlow.h&quot;
 42 #include &quot;RenderChildIterator.h&quot;
 43 #include &quot;RenderIterator.h&quot;
 44 #include &quot;RenderStyle.h&quot;
 45 #include &quot;RenderText.h&quot;
 46 #include &quot;RenderView.h&quot;
 47 #include &quot;Settings.h&quot;
 48 #include &quot;SimpleLineLayoutFlowContents.h&quot;
 49 #include &quot;SimpleLineLayoutResolver.h&quot;
 50 #include &quot;Text.h&quot;
 51 #include &quot;TextDecorationPainter.h&quot;
 52 #include &quot;TextPaintStyle.h&quot;
 53 #include &quot;TextPainter.h&quot;
 54 #include &lt;wtf/text/TextStream.h&gt;
 55 
 56 #if ENABLE(TREE_DEBUGGING)
 57 #include &lt;stdio.h&gt;
 58 #endif
 59 
 60 namespace WebCore {
 61 namespace SimpleLineLayout {
 62 
 63 FloatRect computeOverflow(const RenderBlockFlow&amp; flow, const FloatRect&amp; layoutRect)
 64 {
 65     auto overflowRect = layoutRect;
 66     auto viewportSize = flow.frame().view() ? flow.frame().view()-&gt;size() : IntSize();
 67     auto strokeOverflow = std::ceil(flow.style().computedStrokeWidth(viewportSize));
 68     overflowRect.inflate(strokeOverflow);
 69 
 70     auto letterSpacing = flow.style().fontCascade().letterSpacing();
 71     if (letterSpacing &gt;= 0)
 72         return overflowRect;
 73     // Last letter&#39;s negative spacing shrinks layout rect. Push it to visual overflow.
 74     overflowRect.expand(-letterSpacing, 0);
 75     return overflowRect;
 76 }
 77 
 78 void paintFlow(const RenderBlockFlow&amp; flow, const Layout&amp; layout, PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
 79 {
 80     if (paintInfo.phase == PaintPhase::EventRegion) {
 81         if (!flow.visibleToHitTesting())
 82             return;
 83         auto paintRect = paintInfo.rect;
 84         paintRect.moveBy(-paintOffset);
 85         for (auto run : layout.runResolver().rangeForRect(paintRect)) {
 86             FloatRect visualOverflowRect = computeOverflow(flow, run.rect());
 87             paintInfo.eventRegionContext-&gt;unite(enclosingIntRect(visualOverflowRect), flow.style());
 88         }
 89         return;
 90     }
 91 
 92     if (paintInfo.phase != PaintPhase::Foreground)
 93         return;
 94 
 95     auto&amp; style = flow.style();
 96     if (style.visibility() != Visibility::Visible)
 97         return;
 98 
 99     TextPainter textPainter(paintInfo.context());
100     textPainter.setFont(style.fontCascade());
101     textPainter.setStyle(computeTextPaintStyle(flow.frame(), style, paintInfo));
102 
103     std::unique_ptr&lt;ShadowData&gt; debugShadow = nullptr;
104     if (flow.settings().simpleLineLayoutDebugBordersEnabled()) {
105         debugShadow = makeUnique&lt;ShadowData&gt;(IntPoint(0, 0), 10, 20, ShadowStyle::Normal, true, Color(0, 255, 0, 200));
106         textPainter.setShadow(debugShadow.get());
107     }
108 
109     Optional&lt;TextDecorationPainter&gt; textDecorationPainter;
110     if (!style.textDecorationsInEffect().isEmpty()) {
111         const RenderText* textRenderer = childrenOfType&lt;RenderText&gt;(flow).first();
112         if (textRenderer) {
113             textDecorationPainter.emplace(paintInfo.context(), style.textDecorationsInEffect(), *textRenderer, false, style.fontCascade());
114         }
115     }
116 
117     LayoutRect paintRect = paintInfo.rect;
118     paintRect.moveBy(-paintOffset);
119 
120     auto&amp; resolver = layout.runResolver();
121     float deviceScaleFactor = flow.document().deviceScaleFactor();
122     for (auto run : resolver.rangeForRect(paintRect)) {
123         if (run.start() == run.end())
124             continue;
125 
126         FloatRect rect = run.rect();
127         FloatRect visualOverflowRect = computeOverflow(flow, rect);
128         if (paintRect.y() &gt; visualOverflowRect.maxY() || paintRect.maxY() &lt; visualOverflowRect.y())
129             continue;
130 
131         String textWithHyphen;
132         if (run.hasHyphen())
133             textWithHyphen = run.textWithHyphen();
<a name="1" id="anc1"></a><span class="line-modified">134         // xPos is relative to the line box&#39;s logical left.</span>
<span class="line-modified">135         // We don&#39;t have any line geometry here in SLL, so let&#39;s get the first run&#39;s logical left in the current line and use it as the line&#39;s logical left.</span>
<span class="line-added">136         auto lineLogicalLeft = (*resolver.rangeForLine(run.lineIndex()).begin()).logicalLeft();</span>
<span class="line-added">137         TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), run.logicalLeft() - lineLogicalLeft, run.expansion(), run.expansionBehavior() };</span>
138         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
139         FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
140 
141         textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
142         textPainter.paint(textRun, rect, textOrigin);
143         if (textDecorationPainter) {
144             textDecorationPainter-&gt;setWidth(rect.width());
145             textDecorationPainter-&gt;paintTextDecoration(textRun, textOrigin, rect.location() + paintOffset);
146         }
147     }
148 }
149 
150 bool hitTestFlow(const RenderBlockFlow&amp; flow, const Layout&amp; layout, const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
151 {
152     if (hitTestAction != HitTestForeground)
153         return false;
154 
155     if (!layout.runCount())
156         return false;
157 
158     auto&amp; style = flow.style();
159     if (style.visibility() != Visibility::Visible || style.pointerEvents() == PointerEvents::None)
160         return false;
161 
162     LayoutRect rangeRect = locationInContainer.boundingBox();
163     rangeRect.moveBy(-accumulatedOffset);
164     auto resolver = lineResolver(layout.runResolver());
165     auto range = resolver.rangeForRect(rangeRect);
166     for (auto it = range.begin(), end = range.end(); it != end; ++it) {
167         auto lineRect = *it;
168         lineRect.moveBy(accumulatedOffset);
169         auto&amp; renderer = const_cast&lt;RenderObject&amp;&gt;(it.renderer());
170         if (!locationInContainer.intersects(lineRect))
171             continue;
172         renderer.updateHitTestResult(result, locationInContainer.point() - toLayoutSize(accumulatedOffset));
173         if (result.addNodeToListBasedTestResult(renderer.node(), request, locationInContainer, lineRect) == HitTestProgress::Stop)
174             return true;
175     }
176     return false;
177 }
178 
179 void collectFlowOverflow(RenderBlockFlow&amp; flow, const Layout&amp; layout)
180 {
181     for (auto lineRect : lineResolver(layout.runResolver())) {
182         LayoutRect visualOverflowRect = LayoutRect(computeOverflow(flow, lineRect));
183         flow.addLayoutOverflow(LayoutRect(lineRect));
184         flow.addVisualOverflow(visualOverflowRect);
185     }
186 }
187 
<a name="2" id="anc2"></a>











































188 unsigned textOffsetForPoint(const LayoutPoint&amp; point, const RenderText&amp; renderer, const Layout&amp; layout)
189 {
190     auto&amp; flow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
191     ASSERT(flow.firstChild() == flow.lastChild());
192     auto&amp; resolver = layout.runResolver();
193     auto it = resolver.runForPoint(point);
194     if (it == resolver.end())
195         return renderer.text().length();
196     auto run = *it;
197     auto&amp; style = flow.style();
198     TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
199     textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
200     return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
201 }
202 
<a name="3" id="anc3"></a><span class="line-modified">203 Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForRange(const RenderObject&amp; renderer, unsigned start, unsigned end, const Layout&amp; layout, bool ignoreEmptyTextSelections, bool* wasFixed)</span>
204 {
205     auto&amp; style = downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).style();
206     Vector&lt;FloatQuad&gt; quads;
207     auto&amp; resolver = layout.runResolver();
208     for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {
<a name="4" id="anc4"></a><span class="line-added">209         if (ignoreEmptyTextSelections &amp;&amp; run.start() == run.end())</span>
<span class="line-added">210             continue;</span>
211         // This run is fully contained.
212         if (start &lt;= run.start() &amp;&amp; end &gt;= run.end()) {
213             quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
214             continue;
215         }
216         // Partially contained run.
217         TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
218         textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
219         LayoutRect runRect(run.rect());
220         // Special case empty ranges.
221         if (start == end) {
222             runRect.setWidth(0);
223             quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
224             continue;
225         }
226         auto localStart = std::max(run.start(), start) - run.start();
227         auto localEnd = std::min(run.end(), end) - run.start();
228         ASSERT(localStart &lt;= localEnd);
229         style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);
<a name="5" id="anc5"></a><span class="line-added">230         runRect = snappedSelectionRect(runRect, run.logicalRight(), runRect.y(), runRect.height(), true /* isHorizontal */);</span>
231         quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
232     }
233     return quads;
234 }
235 
<a name="6" id="anc6"></a>




236 void simpleLineLayoutWillBeDeleted(const Layout&amp; layout)
237 {
238     for (unsigned i = 0; i &lt; layout.runCount(); ++i)
239         TextPainter::removeGlyphDisplayList(layout.runAt(i));
240 }
241 
242 bool canUseForLineBoxTree(RenderBlockFlow&amp; flow, const Layout&amp; layout)
243 {
244     // Line breaking requires some context that SLL can&#39;t provide at the moment (see RootInlineBox::setLineBreakInfo).
245     if (layout.lineCount() &gt; 1)
246         return false;
247 
248     if (layout.isPaginated())
249         return false;
250 
251     if (flow.style().preserveNewline())
252         return false;
253 
254     if (!flow.firstChild())
255         return false;
256 
257     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(flow)) {
258         if (!is&lt;RenderText&gt;(child))
259             return false;
260         // Simple line layout iterator can&#39;t handle renderers with zero length properly.
261         if (!downcast&lt;RenderText&gt;(child).length())
262             return false;
263     }
264     return true;
265 }
266 
267 static void initializeInlineTextBox(RenderBlockFlow&amp; flow, InlineTextBox&amp; inlineTextBox, const RunResolver::Run&amp; run)
268 {
269     inlineTextBox.setLogicalLeft(run.logicalLeft());
270     inlineTextBox.setLogicalTop(run.rect().y());
271     inlineTextBox.setLogicalWidth(run.logicalRight() - run.logicalLeft());
272     auto overflowRect = computeOverflow(const_cast&lt;RenderBlockFlow&amp;&gt;(flow), run.rect());
273     if (overflowRect != run.rect())
274         inlineTextBox.setLogicalOverflowRect(LayoutRect(overflowRect));
275 
276     inlineTextBox.setHasHyphen(run.hasHyphen());
277     inlineTextBox.setExpansionWithoutGrowing(run.expansion());
278 
279     auto expansionBehavior = run.expansionBehavior();
280     inlineTextBox.setCanHaveLeadingExpansion(expansionBehavior &amp; AllowLeadingExpansion);
281     inlineTextBox.setCanHaveTrailingExpansion(expansionBehavior &amp; AllowTrailingExpansion);
282     if (expansionBehavior &amp; ForceTrailingExpansion)
283         inlineTextBox.setForceTrailingExpansion();
284     if (expansionBehavior &amp; ForceLeadingExpansion)
285         inlineTextBox.setForceLeadingExpansion();
286 }
287 
288 void generateLineBoxTree(RenderBlockFlow&amp; flow, const Layout&amp; layout)
289 {
290     ASSERT(!flow.complexLineLayout()-&gt;lineBoxes().firstLineBox());
291     if (!layout.runCount())
292         return;
293 
294     Ref&lt;BidiContext&gt; bidiContext = BidiContext::create(0, U_LEFT_TO_RIGHT);
295     auto&amp; resolver = layout.runResolver();
296     unsigned lineIndex = 0;
297     while (true) {
298         auto range = resolver.rangeForLine(lineIndex++);
299         if (range.begin() == range.end())
300             break;
301 
302         // Generate bidi runs out of simple line layout runs.
303         BidiRunList&lt;BidiRun&gt; bidiRuns;
304         for (auto it = range.begin(); it != range.end(); ++it) {
305             auto run = *it;
306             bidiRuns.appendRun(makeUnique&lt;BidiRun&gt;(run.localStart(), run.localEnd(), const_cast&lt;RenderObject&amp;&gt;(run.renderer()), bidiContext.ptr(), U_LEFT_TO_RIGHT));
307         }
308 
309         LineInfo lineInfo;
310         lineInfo.setFirstLine(!flow.complexLineLayout()-&gt;lineBoxes().firstLineBox());
311         // FIXME: This is needed for flow boxes -but we don&#39;t have them yet.
312         // lineInfo.setLastLine(lastLine);
313         lineInfo.setEmpty(!bidiRuns.runCount());
314         bidiRuns.setLogicallyLastRun(bidiRuns.lastRun());
315         auto* root = flow.complexLineLayout()-&gt;constructLine(bidiRuns, lineInfo);
316         bidiRuns.clear();
317         if (!root)
318             continue;
319 
320         auto&amp; rootLineBox = *root;
321         auto it = range.begin();
322         float lineWidth = 0;
323         // Set the geometry for the inlineboxes.
324         for (auto* inlineBox = rootLineBox.firstChild(); inlineBox &amp;&amp; it != range.end(); inlineBox = inlineBox-&gt;nextOnLine(), ++it) {
325             auto run = *it;
326             initializeInlineTextBox(flow, downcast&lt;InlineTextBox&gt;(*inlineBox), run);
327             lineWidth += inlineBox-&gt;logicalWidth();
328         }
329 
330         // Finish setting up the rootline.
331         auto iter = range.begin();
332         auto firstRun = *iter;
333         rootLineBox.setLogicalLeft(firstRun.logicalLeft());
334         rootLineBox.setLogicalWidth(lineWidth);
335         auto lineTop = firstRun.rect().y();
336         auto lineHeight = firstRun.rect().height();
337         rootLineBox.setLogicalTop(lineTop);
338         rootLineBox.setLineTopBottomPositions(LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight), LayoutUnit(lineTop), LayoutUnit(lineTop + lineHeight));
339     }
340 }
341 
342 #if ENABLE(TREE_DEBUGGING)
343 static void printPrefix(TextStream&amp; stream, int&amp; printedCharacters, int depth)
344 {
345     stream &lt;&lt; &quot;-------- --&quot;;
346     printedCharacters = 0;
347     while (++printedCharacters &lt;= depth * 2)
348         stream &lt;&lt; &quot; &quot;;
349 }
350 
<a name="7" id="anc7"></a><span class="line-modified">351 void outputLineLayoutForFlow(TextStream&amp; stream, const RenderBlockFlow&amp;, const Layout&amp; layout, int depth)</span>
352 {
353     int printedCharacters = 0;
354     printPrefix(stream, printedCharacters, depth);
355 
356     stream &lt;&lt; &quot;SimpleLineLayout (&quot; &lt;&lt; layout.lineCount() &lt;&lt; &quot; lines, &quot; &lt;&lt; layout.runCount() &lt;&lt; &quot; runs) (&quot; &lt;&lt; &amp;layout &lt;&lt; &quot;)&quot;;
357     stream.nextLine();
358     ++depth;
359 
<a name="8" id="anc8"></a><span class="line-modified">360     for (auto run : layout.runResolver()) {</span>
361         FloatRect rect = run.rect();
362         printPrefix(stream, printedCharacters, depth);
363         if (run.start() &lt; run.end()) {
364             stream &lt;&lt; &quot;line &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect &lt;&lt; &quot; \&quot;&quot; &lt;&lt; run.text().toStringWithoutCopying().utf8().data() &lt;&lt; &quot;\&quot;&quot;;
365         } else {
366             ASSERT(run.start() == run.end());
367             stream &lt;&lt; &quot;line break &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect;
368         }
369     }
370     stream.nextLine();
371 }
372 #endif
373 
374 }
375 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
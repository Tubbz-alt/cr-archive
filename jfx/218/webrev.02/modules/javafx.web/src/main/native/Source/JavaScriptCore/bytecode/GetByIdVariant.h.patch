diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/GetByIdVariant.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2014-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2014-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -23,34 +23,37 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "CacheableIdentifier.h"
 #include "CallLinkStatus.h"
 #include "ObjectPropertyConditionSet.h"
 #include "PropertyOffset.h"
 #include "StructureSet.h"
+#include <wtf/Box.h>
 
 namespace JSC {
 namespace DOMJIT {
 class GetterSetter;
 }
 
 class CallLinkStatus;
-class GetByIdStatus;
+class GetByStatus;
 struct DumpContext;
 
 class GetByIdVariant {
     WTF_MAKE_FAST_ALLOCATED;
 public:
     GetByIdVariant(
+        CacheableIdentifier,
         const StructureSet& structureSet = StructureSet(), PropertyOffset offset = invalidOffset,
         const ObjectPropertyConditionSet& = ObjectPropertyConditionSet(),
         std::unique_ptr<CallLinkStatus> = nullptr,
         JSFunction* = nullptr,
         FunctionPtr<OperationPtrTag> customAccessorGetter = nullptr,
-        Optional<DOMAttributeAnnotation> = WTF::nullopt);
+        std::unique_ptr<DOMAttributeAnnotation> = nullptr);
 
     ~GetByIdVariant();
 
     GetByIdVariant(const GetByIdVariant&);
     GetByIdVariant& operator=(const GetByIdVariant&);
@@ -66,32 +69,47 @@
     PropertyOffset offset() const { return m_offset; }
     CallLinkStatus* callLinkStatus() const { return m_callLinkStatus.get(); }
     JSFunction* intrinsicFunction() const { return m_intrinsicFunction; }
     Intrinsic intrinsic() const { return m_intrinsicFunction ? m_intrinsicFunction->intrinsic() : NoIntrinsic; }
     FunctionPtr<OperationPtrTag> customAccessorGetter() const { return m_customAccessorGetter; }
-    Optional<DOMAttributeAnnotation> domAttribute() const { return m_domAttribute; }
+    DOMAttributeAnnotation* domAttribute() const { return m_domAttribute.get(); }
 
     bool isPropertyUnset() const { return offset() == invalidOffset; }
 
     bool attemptToMerge(const GetByIdVariant& other);
 
+    void visitAggregate(SlotVisitor&);
     void markIfCheap(SlotVisitor&);
     bool finalize(VM&);
 
     void dump(PrintStream&) const;
     void dumpInContext(PrintStream&, DumpContext*) const;
 
+    CacheableIdentifier identifier() const { return m_identifier; }
+
+    bool overlaps(const GetByIdVariant& other)
+    {
+        if (!!m_identifier != !!other.m_identifier)
+            return true;
+        if (m_identifier) {
+            if (m_identifier != other.m_identifier)
+                return false;
+        }
+        return structureSet().overlaps(other.structureSet());
+    }
+
 private:
-    friend class GetByIdStatus;
+    friend class GetByStatus;
 
     bool canMergeIntrinsicStructures(const GetByIdVariant&) const;
 
     StructureSet m_structureSet;
     ObjectPropertyConditionSet m_conditionSet;
     PropertyOffset m_offset;
     std::unique_ptr<CallLinkStatus> m_callLinkStatus;
     JSFunction* m_intrinsicFunction;
     FunctionPtr<OperationPtrTag> m_customAccessorGetter;
-    Optional<DOMAttributeAnnotation> m_domAttribute;
+    std::unique_ptr<DOMAttributeAnnotation> m_domAttribute;
+    CacheableIdentifier m_identifier;
 };
 
 } // namespace JSC

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ExecutableAllocator.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -24,24 +24,23 @@
  */
 
 #pragma once
 
 #include "JITCompilationEffort.h"
+#include "JSCConfig.h"
 #include "JSCPtrTag.h"
 #include "Options.h"
 #include <stddef.h> // for ptrdiff_t
 #include <limits>
 #include <wtf/Assertions.h>
+#include <wtf/Gigacage.h>
 #include <wtf/Lock.h>
 #include <wtf/MetaAllocatorHandle.h>
 #include <wtf/MetaAllocator.h>
 
-#if OS(IOS_FAMILY)
+#if OS(DARWIN)
 #include <libkern/OSCacheControl.h>
-#endif
-
-#if OS(IOS_FAMILY)
 #include <sys/mman.h>
 #endif
 
 #if CPU(MIPS) && OS(LINUX)
 #include <sys/cachectl.h>
@@ -54,11 +53,11 @@
 
 #define EXECUTABLE_POOL_WRITABLE true
 
 namespace JSC {
 
-static const unsigned jitAllocationGranule = 32;
+static constexpr unsigned jitAllocationGranule = 32;
 
 typedef WTF::MetaAllocatorHandle ExecutableMemoryHandle;
 
 class ExecutableAllocatorBase {
     WTF_MAKE_FAST_ALLOCATED;
@@ -112,19 +111,11 @@
 
 JS_EXPORT_PRIVATE bool isJITPC(void* pc);
 
 JS_EXPORT_PRIVATE void dumpJITMemory(const void*, const void*, size_t);
 
-#if ENABLE(SEPARATED_WX_HEAP)
-
-typedef void (*JITWriteSeparateHeapsFunction)(off_t, const void*, size_t);
-extern JS_EXPORT_PRIVATE JITWriteSeparateHeapsFunction jitWriteSeparateHeapsFunction;
-extern JS_EXPORT_PRIVATE bool useFastPermisionsJITCopy;
-
-#endif // ENABLE(SEPARATED_WX_HEAP)
-
-static inline void* performJITMemcpy(void *dst, const void *src, size_t n)
+static ALWAYS_INLINE void* performJITMemcpy(void *dst, const void *src, size_t n)
 {
 #if CPU(ARM64)
     static constexpr size_t instructionSize = sizeof(unsigned);
     RELEASE_ASSERT(roundUpToMultipleOf<instructionSize>(dst) == dst);
     RELEASE_ASSERT(roundUpToMultipleOf<instructionSize>(src) == src);
@@ -134,26 +125,28 @@
 
         if (UNLIKELY(Options::dumpJITMemoryPath()))
             dumpJITMemory(dst, src, n);
 #if ENABLE(FAST_JIT_PERMISSIONS)
 #if ENABLE(SEPARATED_WX_HEAP)
-        if (useFastPermisionsJITCopy)
+        if (g_jscConfig.useFastPermisionsJITCopy)
 #endif
         {
             os_thread_self_restrict_rwx_to_rw();
             memcpy(dst, src, n);
+            RELEASE_ASSERT(!Gigacage::contains(src));
             os_thread_self_restrict_rwx_to_rx();
             return dst;
         }
 #endif // ENABLE(FAST_JIT_PERMISSIONS)
 
 #if ENABLE(SEPARATED_WX_HEAP)
-        if (jitWriteSeparateHeapsFunction) {
+        if (g_jscConfig.jitWriteSeparateHeaps) {
             // Use execute-only write thunk for writes inside the JIT region. This is a variant of
             // memcpy that takes an offset into the JIT region as its destination (first) parameter.
             off_t offset = (off_t)((uintptr_t)dst - startOfFixedExecutableMemoryPool<uintptr_t>());
-            retagCodePtr<JITThunkPtrTag, CFunctionPtrTag>(jitWriteSeparateHeapsFunction)(offset, src, n);
+            retagCodePtr<JITThunkPtrTag, CFunctionPtrTag>(g_jscConfig.jitWriteSeparateHeaps)(offset, src, n);
+            RELEASE_ASSERT(!Gigacage::contains(src));
             return dst;
         }
 #endif
     }
 

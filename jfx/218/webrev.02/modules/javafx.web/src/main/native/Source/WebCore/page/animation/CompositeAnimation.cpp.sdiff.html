<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImplicitAnimation.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CompositeAnimation.h&quot;
 31 
 32 #include &quot;CSSAnimationControllerPrivate.h&quot;
 33 #include &quot;CSSPropertyAnimation.h&quot;
 34 #include &quot;CSSPropertyNames.h&quot;
 35 #include &quot;ImplicitAnimation.h&quot;
 36 #include &quot;KeyframeAnimation.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RenderStyle.h&quot;

 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 #include &lt;wtf/text/CString.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 CompositeAnimation::CompositeAnimation(CSSAnimationControllerPrivate&amp; animationController)
 46     : m_animationController(animationController)
 47 {
 48     m_suspended = m_animationController.isSuspended() &amp;&amp; !m_animationController.allowsNewAnimationsWhileSuspended();
 49 }
 50 
 51 CompositeAnimation::~CompositeAnimation()
 52 {
 53     // Toss the refs to all animations, but make sure we remove them from
 54     // any waiting lists first.
 55 
 56     clearElement();
 57     m_transitions.clear();
 58     m_keyframeAnimations.clear();
 59 }
</pre>
<hr />
<pre>
269 
270     // Make a list of animations to be removed.
271     for (auto&amp; animation : m_keyframeAnimations.values()) {
272         if (!newAnimations.contains(animation-&gt;name().impl())) {
273             animationController().animationWillBeRemoved(*animation);
274             animation-&gt;clear();
275             LOG(Animations, &quot;Removing KeyframeAnimation %p from element %p&quot;, animation.get(), &amp;element);
276         }
277     }
278 
279     std::swap(newAnimations, m_keyframeAnimations);
280 }
281 
282 AnimationUpdate CompositeAnimation::animate(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; targetStyle)
283 {
284     // We don&#39;t do any transitions if we don&#39;t have a currentStyle (on startup).
285     updateTransitions(element, currentStyle, targetStyle);
286     updateKeyframeAnimations(element, currentStyle, targetStyle);
287     m_keyframeAnimations.checkConsistency();
288 
<span class="line-modified">289     bool animationChangeRequiresRecomposite = false;</span>
<span class="line-removed">290     bool forceStackingContext = false;</span>
291 
292     std::unique_ptr&lt;RenderStyle&gt; animatedStyle;
293 
294     if (currentStyle) {
295         // Now that we have transition objects ready, let them know about the new goal state.  We want them
296         // to fill in a RenderStyle*&amp; only if needed.
297         bool checkForStackingContext = false;
298         for (auto&amp; transition : m_transitions.values()) {
299             auto changes = transition-&gt;animate(*this, targetStyle, animatedStyle);
300             if (changes.contains(AnimateChange::StyleBlended))
301                 checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition-&gt;animatingProperty());
302 
<span class="line-modified">303             animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) &amp;&amp; transition-&gt;affectsAcceleratedProperty();</span>

304         }
305 
306         if (animatedStyle &amp;&amp; checkForStackingContext) {
<span class="line-modified">307             // Note that this is similar to code in StyleResolver::adjustRenderStyle() but only needs to consult</span>
308             // animatable properties that can trigger stacking context.
309             if (animatedStyle-&gt;opacity() &lt; 1.0f
310                 || animatedStyle-&gt;hasTransformRelatedProperty()
311                 || animatedStyle-&gt;hasMask()
312                 || animatedStyle-&gt;clipPath()
313                 || animatedStyle-&gt;boxReflect()
314                 || animatedStyle-&gt;hasFilter()
315 #if ENABLE(FILTERS_LEVEL_2)
316                 || animatedStyle-&gt;hasBackdropFilter()
317 #endif
318                 )
<span class="line-modified">319             forceStackingContext = true;</span>
320         }
321     }
322 
323     // Now that we have animation objects ready, let them know about the new goal state.  We want them
324     // to fill in a RenderStyle*&amp; only if needed.
325     for (auto&amp; name : m_keyframeAnimationOrderMap) {
326         RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name);
327         if (keyframeAnim) {
328             auto changes = keyframeAnim-&gt;animate(*this, targetStyle, animatedStyle);
<span class="line-modified">329             animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) &amp;&amp; keyframeAnim-&gt;affectsAcceleratedProperty();</span>
<span class="line-modified">330             forceStackingContext |= changes.contains(AnimateChange::StyleBlended) &amp;&amp; keyframeAnim-&gt;triggersStackingContext();</span>




331             m_hasAnimationThatDependsOnLayout |= keyframeAnim-&gt;dependsOnLayout();
332         }
333     }
334 
<span class="line-modified">335     // https://drafts.csswg.org/css-animations-1/</span>
<span class="line-removed">336     // While an animation is applied but has not finished, or has finished but has an animation-fill-mode of forwards or both,</span>
<span class="line-removed">337     // the user agent must act as if the will-change property ([css-will-change-1]) on the element additionally</span>
<span class="line-removed">338     // includes all the properties animated by the animation.</span>
<span class="line-removed">339     if (forceStackingContext &amp;&amp; animatedStyle) {</span>
<span class="line-removed">340         if (animatedStyle-&gt;hasAutoZIndex())</span>
<span class="line-removed">341             animatedStyle-&gt;setZIndex(0);</span>
<span class="line-removed">342     }</span>
<span class="line-removed">343 </span>
<span class="line-removed">344     return { WTFMove(animatedStyle), animationChangeRequiresRecomposite };</span>
345 }
346 
347 std::unique_ptr&lt;RenderStyle&gt; CompositeAnimation::getAnimatedStyle() const
348 {
349     std::unique_ptr&lt;RenderStyle&gt; resultStyle;
350     for (auto&amp; transition : m_transitions.values())
351         transition-&gt;getAnimatedStyle(resultStyle);
352 
353     m_keyframeAnimations.checkConsistency();
354 
355     for (auto&amp; name : m_keyframeAnimationOrderMap) {
356         RefPtr&lt;KeyframeAnimation&gt; keyframeAnimation = m_keyframeAnimations.get(name);
357         if (keyframeAnimation)
358             keyframeAnimation-&gt;getAnimatedStyle(resultStyle);
359     }
360 
361     return resultStyle;
362 }
363 
364 Optional&lt;Seconds&gt; CompositeAnimation::timeToNextService() const
</pre>
</td>
<td>
<hr />
<pre>
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;CompositeAnimation.h&quot;
 31 
 32 #include &quot;CSSAnimationControllerPrivate.h&quot;
 33 #include &quot;CSSPropertyAnimation.h&quot;
 34 #include &quot;CSSPropertyNames.h&quot;
 35 #include &quot;ImplicitAnimation.h&quot;
 36 #include &quot;KeyframeAnimation.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;RenderElement.h&quot;
 39 #include &quot;RenderStyle.h&quot;
<span class="line-added"> 40 #include &quot;StyleAdjuster.h&quot;</span>
 41 #include &lt;wtf/NeverDestroyed.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 CompositeAnimation::CompositeAnimation(CSSAnimationControllerPrivate&amp; animationController)
 47     : m_animationController(animationController)
 48 {
 49     m_suspended = m_animationController.isSuspended() &amp;&amp; !m_animationController.allowsNewAnimationsWhileSuspended();
 50 }
 51 
 52 CompositeAnimation::~CompositeAnimation()
 53 {
 54     // Toss the refs to all animations, but make sure we remove them from
 55     // any waiting lists first.
 56 
 57     clearElement();
 58     m_transitions.clear();
 59     m_keyframeAnimations.clear();
 60 }
</pre>
<hr />
<pre>
270 
271     // Make a list of animations to be removed.
272     for (auto&amp; animation : m_keyframeAnimations.values()) {
273         if (!newAnimations.contains(animation-&gt;name().impl())) {
274             animationController().animationWillBeRemoved(*animation);
275             animation-&gt;clear();
276             LOG(Animations, &quot;Removing KeyframeAnimation %p from element %p&quot;, animation.get(), &amp;element);
277         }
278     }
279 
280     std::swap(newAnimations, m_keyframeAnimations);
281 }
282 
283 AnimationUpdate CompositeAnimation::animate(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; targetStyle)
284 {
285     // We don&#39;t do any transitions if we don&#39;t have a currentStyle (on startup).
286     updateTransitions(element, currentStyle, targetStyle);
287     updateKeyframeAnimations(element, currentStyle, targetStyle);
288     m_keyframeAnimations.checkConsistency();
289 
<span class="line-modified">290     OptionSet&lt;AnimationImpact&gt; imapct;</span>

291 
292     std::unique_ptr&lt;RenderStyle&gt; animatedStyle;
293 
294     if (currentStyle) {
295         // Now that we have transition objects ready, let them know about the new goal state.  We want them
296         // to fill in a RenderStyle*&amp; only if needed.
297         bool checkForStackingContext = false;
298         for (auto&amp; transition : m_transitions.values()) {
299             auto changes = transition-&gt;animate(*this, targetStyle, animatedStyle);
300             if (changes.contains(AnimateChange::StyleBlended))
301                 checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition-&gt;animatingProperty());
302 
<span class="line-modified">303             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; transition-&gt;affectsAcceleratedProperty())</span>
<span class="line-added">304                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
305         }
306 
307         if (animatedStyle &amp;&amp; checkForStackingContext) {
<span class="line-modified">308             // Note that this is similar to code in Style::Adjuster::adjust() but only needs to consult</span>
309             // animatable properties that can trigger stacking context.
310             if (animatedStyle-&gt;opacity() &lt; 1.0f
311                 || animatedStyle-&gt;hasTransformRelatedProperty()
312                 || animatedStyle-&gt;hasMask()
313                 || animatedStyle-&gt;clipPath()
314                 || animatedStyle-&gt;boxReflect()
315                 || animatedStyle-&gt;hasFilter()
316 #if ENABLE(FILTERS_LEVEL_2)
317                 || animatedStyle-&gt;hasBackdropFilter()
318 #endif
319                 )
<span class="line-modified">320             imapct.add(AnimationImpact::ForcesStackingContext);</span>
321         }
322     }
323 
324     // Now that we have animation objects ready, let them know about the new goal state.  We want them
325     // to fill in a RenderStyle*&amp; only if needed.
326     for (auto&amp; name : m_keyframeAnimationOrderMap) {
327         RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name);
328         if (keyframeAnim) {
329             auto changes = keyframeAnim-&gt;animate(*this, targetStyle, animatedStyle);
<span class="line-modified">330             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; keyframeAnim-&gt;affectsAcceleratedProperty())</span>
<span class="line-modified">331                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
<span class="line-added">332 </span>
<span class="line-added">333             if (changes.contains(AnimateChange::StyleBlended) &amp;&amp; keyframeAnim-&gt;triggersStackingContext())</span>
<span class="line-added">334                 imapct.add(AnimationImpact::ForcesStackingContext);</span>
<span class="line-added">335 </span>
336             m_hasAnimationThatDependsOnLayout |= keyframeAnim-&gt;dependsOnLayout();
337         }
338     }
339 
<span class="line-modified">340     return { WTFMove(animatedStyle), imapct };</span>









341 }
342 
343 std::unique_ptr&lt;RenderStyle&gt; CompositeAnimation::getAnimatedStyle() const
344 {
345     std::unique_ptr&lt;RenderStyle&gt; resultStyle;
346     for (auto&amp; transition : m_transitions.values())
347         transition-&gt;getAnimatedStyle(resultStyle);
348 
349     m_keyframeAnimations.checkConsistency();
350 
351     for (auto&amp; name : m_keyframeAnimationOrderMap) {
352         RefPtr&lt;KeyframeAnimation&gt; keyframeAnimation = m_keyframeAnimations.get(name);
353         if (keyframeAnimation)
354             keyframeAnimation-&gt;getAnimatedStyle(resultStyle);
355     }
356 
357     return resultStyle;
358 }
359 
360 Optional&lt;Seconds&gt; CompositeAnimation::timeToNextService() const
</pre>
</td>
</tr>
</table>
<center><a href="CSSPropertyAnimation.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImplicitAnimation.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
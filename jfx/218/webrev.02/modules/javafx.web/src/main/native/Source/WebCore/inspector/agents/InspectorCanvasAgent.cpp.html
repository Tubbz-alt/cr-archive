<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvasAgent.h&quot;
 28 
 29 #include &quot;CanvasRenderingContext.h&quot;
 30 #include &quot;CanvasRenderingContext2D.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Element.h&quot;
 33 #include &quot;EventLoop.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;HTMLCanvasElement.h&quot;
 36 #include &quot;ImageBitmap.h&quot;
 37 #include &quot;ImageBitmapRenderingContext.h&quot;
 38 #include &quot;InspectorDOMAgent.h&quot;
 39 #include &quot;InspectorShaderProgram.h&quot;
 40 #include &quot;InstrumentingAgents.h&quot;
 41 #include &quot;JSExecState.h&quot;
 42 #include &quot;ScriptState.h&quot;
 43 #include &quot;StringAdaptors.h&quot;
 44 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 45 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 46 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 47 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
 48 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 49 #include &lt;wtf/HashMap.h&gt;
 50 #include &lt;wtf/HashSet.h&gt;
 51 #include &lt;wtf/Lock.h&gt;
 52 #include &lt;wtf/Optional.h&gt;
 53 #include &lt;wtf/RefPtr.h&gt;
 54 #include &lt;wtf/Vector.h&gt;
 55 #include &lt;wtf/text/WTFString.h&gt;
 56 
 57 #if ENABLE(OFFSCREEN_CANVAS)
 58 #include &quot;OffscreenCanvas.h&quot;
 59 #endif
 60 
 61 #if ENABLE(WEBGL)
 62 #include &quot;WebGLProgram.h&quot;
 63 #include &quot;WebGLRenderingContext.h&quot;
 64 #include &quot;WebGLRenderingContextBase.h&quot;
 65 #endif
 66 
 67 #if ENABLE(WEBGL2)
 68 #include &quot;WebGL2RenderingContext.h&quot;
 69 #endif
 70 
 71 #if ENABLE(WEBGPU)
 72 #include &quot;GPUCanvasContext.h&quot;
 73 #include &quot;WebGPUComputePipeline.h&quot;
 74 #include &quot;WebGPUDevice.h&quot;
 75 #include &quot;WebGPUPipeline.h&quot;
 76 #include &quot;WebGPURenderPipeline.h&quot;
 77 #include &quot;WebGPUSwapChain.h&quot;
 78 #endif
 79 
 80 namespace WebCore {
 81 
 82 using namespace Inspector;
 83 
 84 InspectorCanvasAgent::InspectorCanvasAgent(PageAgentContext&amp; context)
 85     : InspectorAgentBase(&quot;Canvas&quot;_s, context)
 86     , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))
 87     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
 88     , m_injectedScriptManager(context.injectedScriptManager)
 89     , m_inspectedPage(context.inspectedPage)
 90     , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
 91     , m_programDestroyedTimer(*this, &amp;InspectorCanvasAgent::programDestroyedTimerFired)
 92 {
 93 }
 94 
 95 InspectorCanvasAgent::~InspectorCanvasAgent() = default;
 96 
 97 void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 98 {
 99 }
100 
101 void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
102 {
103     ErrorString ignored;
104     disable(ignored);
105 }
106 
107 void InspectorCanvasAgent::discardAgent()
108 {
109     reset();
110 }
111 
112 void InspectorCanvasAgent::enable(ErrorString&amp;)
113 {
114     if (m_instrumentingAgents.inspectorCanvasAgent() == this)
115         return;
116 
117     m_instrumentingAgents.setInspectorCanvasAgent(this);
118 
119     const auto existsInCurrentPage = [&amp;] (ScriptExecutionContext* scriptExecutionContext) {
120         if (!is&lt;Document&gt;(scriptExecutionContext))
121             return false;
122 
123         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
124         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
125         return document-&gt;page() == &amp;m_inspectedPage;
126     };
127 
128     {
129         LockHolder lock(CanvasRenderingContext::instancesMutex());
130         for (auto* context : CanvasRenderingContext::instances(lock)) {
131 #if ENABLE(WEBGPU)
132             // The actual &quot;context&quot; for WebGPU is the `WebGPUDevice`, not the &lt;canvas&gt;.
133             if (is&lt;GPUCanvasContext&gt;(context))
134                 continue;
135 #endif
136 
137             if (existsInCurrentPage(context-&gt;canvasBase().scriptExecutionContext()))
138                 bindCanvas(*context, false);
139         }
140     }
141 
142 #if ENABLE(WEBGPU)
143     {
144         LockHolder lock(WebGPUDevice::instancesMutex());
145         for (auto* device : WebGPUDevice::instances(lock)) {
146             if (existsInCurrentPage(device-&gt;scriptExecutionContext()))
147                 bindCanvas(*device, false);
148         }
149     }
150 #endif
151 
152 #if ENABLE(WEBGL)
153     {
154         LockHolder lock(WebGLProgram::instancesMutex());
155         for (auto&amp; [program, contextWebGLBase] : WebGLProgram::instances(lock)) {
156             if (contextWebGLBase &amp;&amp; existsInCurrentPage(contextWebGLBase-&gt;canvasBase().scriptExecutionContext()))
157                 didCreateWebGLProgram(*contextWebGLBase, *program);
158         }
159     }
160 #endif
161 
162 #if ENABLE(WEBGPU)
163     {
164         LockHolder lock(WebGPUPipeline::instancesMutex());
165         for (auto&amp; [pipeline, device] : WebGPUPipeline::instances(lock)) {
166             if (device &amp;&amp; existsInCurrentPage(device-&gt;scriptExecutionContext()) &amp;&amp; pipeline-&gt;isValid())
167                 didCreateWebGPUPipeline(*device, *pipeline);
168         }
169     }
170 #endif
171 }
172 
173 void InspectorCanvasAgent::disable(ErrorString&amp;)
174 {
175     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
176 
177     reset();
178 
179     m_recordingAutoCaptureFrameCount = WTF::nullopt;
180 }
181 
182 void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
183 {
184     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
185     if (!inspectorCanvas)
186         return;
187 
188     auto* node = inspectorCanvas-&gt;canvasElement();
189     if (!node) {
190         errorString = &quot;Missing element of canvas for given canvasId&quot;_s;
191         return;
192     }
193 
194     int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
195     if (!documentNodeId) {
196         errorString = &quot;Document must have been requested&quot;_s;
197         return;
198     }
199 
200     *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
201 }
202 
203 void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
204 {
205     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
206     if (!inspectorCanvas)
207         return;
208 
209     *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);
210 }
211 
212 void InspectorCanvasAgent::requestClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; clientNodeIds)
213 {
214     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
215     if (!domAgent) {
216         errorString = &quot;DOM domain must be enabled&quot;_s;
217         return;
218     }
219 
220     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
221     if (!inspectorCanvas)
222         return;
223 
224     clientNodeIds = JSON::ArrayOf&lt;int&gt;::create();
225     for (auto&amp; clientNode : inspectorCanvas-&gt;clientNodes()) {
226         if (auto documentNodeId = domAgent-&gt;boundNodeId(&amp;clientNode-&gt;document()))
227             clientNodeIds-&gt;addItem(domAgent-&gt;pushNodeToFrontend(errorString, documentNodeId, clientNode));
228     }
229 }
230 
231 void InspectorCanvasAgent::resolveContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
232 {
233     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
234     if (!inspectorCanvas)
235         return;
236 
237     auto* state = inspectorCanvas-&gt;scriptExecutionContext()-&gt;execState();
238     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);
239     ASSERT(!injectedScript.hasNoValue());
240 
241     JSC::JSValue value = inspectorCanvas-&gt;resolveContext(state);
242 
243     if (!value) {
244         ASSERT_NOT_REACHED();
245         errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;
246         return;
247     }
248 
249     String objectGroupName = objectGroup ? *objectGroup : String();
250     result = injectedScript.wrapObject(value, objectGroupName);
251 }
252 
253 void InspectorCanvasAgent::setRecordingAutoCaptureFrameCount(ErrorString&amp;, int count)
254 {
255     if (count &gt; 0)
256         m_recordingAutoCaptureFrameCount = count;
257     else
258         m_recordingAutoCaptureFrameCount = WTF::nullopt;
259 }
260 
261 void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
262 {
263     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
264     if (!inspectorCanvas)
265         return;
266 
267     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
268 
269     auto* context = inspectorCanvas-&gt;canvasContext();
270     if (!context)
271         return;
272 
273     if (context-&gt;callTracingActive()) {
274         errorString = &quot;Already recording canvas&quot;_s;
275         return;
276     }
277 
278     RecordingOptions recordingOptions;
279     if (frameCount)
280         recordingOptions.frameCount = *frameCount;
281     if (memoryLimit)
282         recordingOptions.memoryLimit = *memoryLimit;
283     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
284 }
285 
286 void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
287 {
288     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
289     if (!inspectorCanvas)
290         return;
291 
292     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
293 
294     auto* context = inspectorCanvas-&gt;canvasContext();
295     if (!context)
296         return;
297 
298     if (!context-&gt;callTracingActive()) {
299         errorString = &quot;Not recording canvas&quot;_s;
300         return;
301     }
302 
303     didFinishRecordingCanvasFrame(*context, true);
304 }
305 
306 void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, String* outSource)
307 {
308     auto inspectorProgram = assertInspectorProgram(errorString, programId);
309     if (!inspectorProgram)
310         return;
311 
312     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);
313     if (!shaderType) {
314         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);
315         return;
316     }
317 
318     auto source = inspectorProgram-&gt;requestShaderSource(shaderType.value());
319     if (!source) {
320         errorString = &quot;Missing shader of given shaderType for given programId&quot;_s;
321         return;
322     }
323 
324     *outSource = source;
325 }
326 
327 void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, const String&amp; source)
328 {
329     auto inspectorProgram = assertInspectorProgram(errorString, programId);
330     if (!inspectorProgram)
331         return;
332 
333     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);
334     if (!shaderType) {
335         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);
336         return;
337     }
338 
339     if (!inspectorProgram-&gt;updateShader(shaderType.value(), source))
340         errorString = &quot;Failed to update shader of given shaderType for given programId&quot;_s;
341 }
342 
343 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
344 {
345     auto inspectorProgram = assertInspectorProgram(errorString, programId);
346     if (!inspectorProgram)
347         return;
348 
349     inspectorProgram-&gt;setDisabled(disabled);
350 }
351 
352 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
353 {
354     auto inspectorProgram = assertInspectorProgram(errorString, programId);
355     if (!inspectorProgram)
356         return;
357 
358     inspectorProgram-&gt;setHighlighted(highlighted);
359 }
360 
361 void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
362 {
363     if (frame.isMainFrame()) {
364         reset();
365         return;
366     }
367 
368     Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
369     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
370         if (auto* canvasElement = inspectorCanvas-&gt;canvasElement()) {
371             if (canvasElement-&gt;document().frame() == &amp;frame)
372                 inspectorCanvases.append(inspectorCanvas.get());
373         }
374     }
375 
376     for (auto* inspectorCanvas : inspectorCanvases)
377         unbindCanvas(*inspectorCanvas);
378 }
379 
380 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
381 {
382     auto* context = canvasBase.renderingContext();
383     if (!context) {
384         ASSERT_NOT_REACHED();
385         return;
386     }
387 
388     auto inspectorCanvas = findInspectorCanvas(*context);
389     ASSERT(inspectorCanvas);
390     if (!inspectorCanvas)
391         return;
392 
393     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());
394 }
395 
396 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
397 {
398     if (findInspectorCanvas(context)) {
399         ASSERT_NOT_REACHED();
400         return;
401     }
402 
403     auto&amp; inspectorCanvas = bindCanvas(context, true);
404 
405     if (m_recordingAutoCaptureFrameCount) {
406         RecordingOptions recordingOptions;
407         recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
408         startRecording(inspectorCanvas, Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));
409     }
410 }
411 
412 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
413 {
414     RefPtr&lt;InspectorCanvas&gt; inspectorCanvas;
415 
416 #if ENABLE(WEBGPU)
417     if (is&lt;GPUCanvasContext&gt;(context)) {
418         for (auto&amp; item : m_identifierToInspectorCanvas.values()) {
419             if (item-&gt;isDeviceForCanvasContext(context)) {
420                 inspectorCanvas = item;
421                 break;
422             }
423         }
424     }
425 #endif
426 
427     if (!inspectorCanvas)
428         inspectorCanvas = findInspectorCanvas(context);
429 
430     ASSERT(inspectorCanvas);
431     if (!inspectorCanvas)
432         return;
433 
434     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
435 
436     if (auto* node = inspectorCanvas-&gt;canvasElement())
437         m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
438 }
439 
440 void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
441 {
442     auto inspectorCanvas = findInspectorCanvas(canvasRenderingContext);
443     ASSERT(inspectorCanvas);
444     if (!inspectorCanvas)
445         return;
446 
447     ASSERT(canvasRenderingContext.callTracingActive());
448     if (!canvasRenderingContext.callTracingActive())
449         return;
450 
451     // Only enqueue one microtask for all actively recording canvases.
452     if (m_recordingCanvasIdentifiers.isEmpty()) {
453         if (auto* scriptExecutionContext = inspectorCanvas-&gt;scriptExecutionContext()) {
454             scriptExecutionContext-&gt;eventLoop().queueMicrotask([weakThis = makeWeakPtr(*this)] {
455                 if (!weakThis)
456                     return;
457 
458                 auto&amp; canvasAgent = *weakThis;
459 
460                 auto identifiers = copyToVector(canvasAgent.m_recordingCanvasIdentifiers);
461                 for (auto&amp; identifier : identifiers) {
462                     auto inspectorCanvas = canvasAgent.m_identifierToInspectorCanvas.get(identifier);
463                     if (!inspectorCanvas)
464                         continue;
465 
466                     auto* canvasRenderingContext = inspectorCanvas-&gt;canvasContext();
467                     ASSERT(canvasRenderingContext);
468                     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
469 
470                     if (canvasRenderingContext-&gt;callTracingActive())
471                         canvasAgent.didFinishRecordingCanvasFrame(*canvasRenderingContext);
472                 }
473 
474                 canvasAgent.m_recordingCanvasIdentifiers.clear();
475             });
476         }
477     }
478 
479     m_recordingCanvasIdentifiers.add(inspectorCanvas-&gt;identifier());
480 
481     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));
482 
483     if (!inspectorCanvas-&gt;hasBufferSpace())
484         didFinishRecordingCanvasFrame(canvasRenderingContext, true);
485 }
486 
487 void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)
488 {
489     auto* context = canvasBase.renderingContext();
490     if (!context)
491         return;
492 
493     auto inspectorCanvas = findInspectorCanvas(*context);
494     ASSERT(inspectorCanvas);
495     if (!inspectorCanvas)
496         return;
497 
498     inspectorCanvas-&gt;canvasChanged();
499 }
500 
501 void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
502 {
503     auto* context = canvasBase.renderingContext();
504     if (!context)
505         return;
506 
507     auto inspectorCanvas = findInspectorCanvas(*context);
508     ASSERT(inspectorCanvas);
509     if (!inspectorCanvas)
510         return;
511 
512     unbindCanvas(*inspectorCanvas);
513 }
514 
515 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
516 {
517     if (!context.callTracingActive())
518         return;
519 
520     auto inspectorCanvas = findInspectorCanvas(context);
521     ASSERT(inspectorCanvas);
522     if (!inspectorCanvas)
523         return;
524 
525     if (!inspectorCanvas-&gt;hasRecordingData()) {
526         if (forceDispatch) {
527             m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
528             inspectorCanvas-&gt;resetRecordingData();
529             ASSERT(!m_recordingCanvasIdentifiers.contains(inspectorCanvas-&gt;identifier()));
530         }
531         return;
532     }
533 
534     if (forceDispatch)
535         inspectorCanvas-&gt;markCurrentFrameIncomplete();
536 
537     inspectorCanvas-&gt;finalizeFrame();
538     if (inspectorCanvas-&gt;currentFrameHasData())
539         m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
540 
541     if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
542         return;
543 
544     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());
545 
546     m_recordingCanvasIdentifiers.remove(inspectorCanvas-&gt;identifier());
547 }
548 
549 void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::JSGlobalObject&amp; exec, JSC::JSObject* options)
550 {
551     auto inspectorCanvas = findInspectorCanvas(context);
552     ASSERT(inspectorCanvas);
553     if (!inspectorCanvas)
554         return;
555 
556     RecordingOptions recordingOptions;
557     if (options) {
558         JSC::VM&amp; vm = exec.vm();
559         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;singleFrame&quot;)))
560             recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
561         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;frameCount&quot;)))
562             recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
563         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;memoryLimit&quot;)))
564             recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
565         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;name&quot;)))
566             recordingOptions.name = optionName.toWTFString(&amp;exec);
567     }
568     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
569 }
570 
571 void InspectorCanvasAgent::consoleStopRecordingCanvas(CanvasRenderingContext&amp; context)
572 {
573     didFinishRecordingCanvasFrame(context, true);
574 }
575 
576 #if ENABLE(WEBGL)
577 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
578 {
579     auto inspectorCanvas = findInspectorCanvas(context);
580     ASSERT(inspectorCanvas);
581     if (!inspectorCanvas)
582         return;
583 
584     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
585 }
586 
587 void InspectorCanvasAgent::didCreateWebGLProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)
588 {
589     auto inspectorCanvas = findInspectorCanvas(context);
590     ASSERT(inspectorCanvas);
591     if (!inspectorCanvas)
592         return;
593 
594     auto inspectorProgramRef = InspectorShaderProgram::create(program, *inspectorCanvas);
595     auto&amp; inspectorProgram = inspectorProgramRef.get();
596     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));
597     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());
598 }
599 
600 void InspectorCanvasAgent::willDestroyWebGLProgram(WebGLProgram&amp; program)
601 {
602     auto inspectorProgram = findInspectorProgram(program);
603     if (!inspectorProgram)
604         return;
605 
606     unbindProgram(*inspectorProgram);
607 }
608 
609 bool InspectorCanvasAgent::isWebGLProgramDisabled(WebGLProgram&amp; program)
610 {
611     auto inspectorProgram = findInspectorProgram(program);
612     ASSERT(inspectorProgram);
613     if (!inspectorProgram)
614         return false;
615 
616     return inspectorProgram-&gt;disabled();
617 }
618 
619 bool InspectorCanvasAgent::isWebGLProgramHighlighted(WebGLProgram&amp; program)
620 {
621     auto inspectorProgram = findInspectorProgram(program);
622     ASSERT(inspectorProgram);
623     if (!inspectorProgram)
624         return false;
625 
626     return inspectorProgram-&gt;highlighted();
627 }
628 #endif
629 
630 #if ENABLE(WEBGPU)
631 void InspectorCanvasAgent::didCreateWebGPUDevice(WebGPUDevice&amp; device)
632 {
633     if (findInspectorCanvas(device)) {
634         ASSERT_NOT_REACHED();
635         return;
636     }
637 
638     bindCanvas(device, true);
639 }
640 
641 void InspectorCanvasAgent::willDestroyWebGPUDevice(WebGPUDevice&amp; device)
642 {
643     auto inspectorCanvas = findInspectorCanvas(device);
644     ASSERT(inspectorCanvas);
645     if (!inspectorCanvas)
646         return;
647 
648     unbindCanvas(*inspectorCanvas);
649 }
650 
651 void InspectorCanvasAgent::willConfigureSwapChain(GPUCanvasContext&amp; contextGPU, WebGPUSwapChain&amp; newSwapChain)
652 {
653     auto notifyDeviceForSwapChain = [&amp;] (WebGPUSwapChain&amp; webGPUSwapChain) {
654         for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
655             if (auto* device = inspectorCanvas-&gt;deviceContext()) {
656                 if (device-&gt;device().swapChain() == webGPUSwapChain.swapChain())
657                     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());
658             }
659         }
660     };
661 
662     if (auto* existingSwapChain = contextGPU.swapChain())
663         notifyDeviceForSwapChain(*existingSwapChain);
664 
665     notifyDeviceForSwapChain(newSwapChain);
666 }
667 
668 void InspectorCanvasAgent::didCreateWebGPUPipeline(WebGPUDevice&amp; device, WebGPUPipeline&amp; pipeline)
669 {
670     auto inspectorCanvas = findInspectorCanvas(device);
671     ASSERT(inspectorCanvas);
672     if (!inspectorCanvas)
673         return;
674 
675     ASSERT(pipeline.isValid());
676 
677     auto inspectorProgramRef = InspectorShaderProgram::create(pipeline, *inspectorCanvas);
678     auto&amp; inspectorProgram = inspectorProgramRef.get();
679     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));
680     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());
681 }
682 
683 void InspectorCanvasAgent::willDestroyWebGPUPipeline(WebGPUPipeline&amp; pipeline)
684 {
685     auto inspectorProgram = findInspectorProgram(pipeline);
686     if (!inspectorProgram)
687         return;
688 
689     unbindProgram(*inspectorProgram);
690 }
691 #endif
692 
693 void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
694 {
695     auto* context = inspectorCanvas.canvasContext();
696     ASSERT(context);
697     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice
698 
699     if (!is&lt;CanvasRenderingContext2D&gt;(context)
700         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(context)
701 #if ENABLE(WEBGL)
702         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(context)
703 #endif
704 #if ENABLE(WEBGL2)
705         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(context)
706 #endif
707     )
708         return;
709 
710     if (context-&gt;callTracingActive())
711         return;
712 
713     inspectorCanvas.resetRecordingData();
714     if (recordingOptions.frameCount)
715         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
716     if (recordingOptions.memoryLimit)
717         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
718     if (recordingOptions.name)
719         inspectorCanvas.setRecordingName(recordingOptions.name.value());
720     context-&gt;setCallTracingActive(true);
721 
722     m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
723 }
724 
725 void InspectorCanvasAgent::canvasDestroyedTimerFired()
726 {
727     if (!m_removedCanvasIdentifiers.size())
728         return;
729 
730     for (auto&amp; identifier : m_removedCanvasIdentifiers)
731         m_frontendDispatcher-&gt;canvasRemoved(identifier);
732 
733     m_removedCanvasIdentifiers.clear();
734 }
735 
736 void InspectorCanvasAgent::programDestroyedTimerFired()
737 {
738     if (!m_removedProgramIdentifiers.size())
739         return;
740 
741     for (auto&amp; identifier : m_removedProgramIdentifiers)
742         m_frontendDispatcher-&gt;programDeleted(identifier);
743 
744     m_removedProgramIdentifiers.clear();
745 }
746 
747 void InspectorCanvasAgent::reset()
748 {
749     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
750         if (auto* context = inspectorCanvas-&gt;canvasContext())
751             context-&gt;canvasBase().removeObserver(*this);
752     }
753 
754     m_identifierToInspectorCanvas.clear();
755     m_removedCanvasIdentifiers.clear();
756     if (m_canvasDestroyedTimer.isActive())
757         m_canvasDestroyedTimer.stop();
758 
759     m_identifierToInspectorProgram.clear();
760     m_removedProgramIdentifiers.clear();
761     if (m_programDestroyedTimer.isActive())
762         m_programDestroyedTimer.stop();
763 
764     m_recordingCanvasIdentifiers.clear();
765 }
766 
767 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)
768 {
769     auto inspectorCanvas = InspectorCanvas::create(context);
770     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
771 
772     context.canvasBase().addObserver(*this);
773 
774     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
775 
776 #if ENABLE(WEBGL)
777     if (is&lt;WebGLRenderingContextBase&gt;(context)) {
778         auto&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(context);
779         if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {
780             for (const String&amp; extension : *extensions) {
781                 if (contextWebGL.extensionIsEnabled(extension))
782                     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
783             }
784         }
785     }
786 #endif
787 
788     return inspectorCanvas;
789 }
790 
791 #if ENABLE(WEBGPU)
792 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(WebGPUDevice&amp; device, bool captureBacktrace)
793 {
794     auto inspectorCanvas = InspectorCanvas::create(device);
795     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
796 
797     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
798 
799     return inspectorCanvas;
800 }
801 #endif
802 
803 void InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)
804 {
805 #if ENABLE(WEBGL)
806     Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
807     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
808         if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
809             programsToRemove.append(inspectorProgram.get());
810     }
811 
812     for (auto* inspectorProgram : programsToRemove)
813         unbindProgram(*inspectorProgram);
814 #endif
815 
816     if (auto* context = inspectorCanvas.canvasContext())
817         context-&gt;canvasBase().removeObserver(*this);
818 
819     String identifier = inspectorCanvas.identifier();
820     m_identifierToInspectorCanvas.remove(identifier);
821 
822     // This can be called in response to GC. Due to the single-process model used in WebKit1, the
823     // event must be dispatched from a timer to prevent the frontend from making JS allocations
824     // while the GC is still active.
825     m_removedCanvasIdentifiers.append(identifier);
826 
827     if (!m_canvasDestroyedTimer.isActive())
828         m_canvasDestroyedTimer.startOneShot(0_s);
829 }
830 
831 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)
832 {
833     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
834     if (!inspectorCanvas) {
835         errorString = &quot;Missing canvas for given canvasId&quot;_s;
836         return nullptr;
837     }
838     return inspectorCanvas;
839 }
840 
841 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)
842 {
843     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
844         if (inspectorCanvas-&gt;canvasContext() == &amp;context)
845             return inspectorCanvas;
846     }
847     return nullptr;
848 }
849 
850 #if ENABLE(WEBGPU)
851 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(WebGPUDevice&amp; device)
852 {
853     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
854         if (inspectorCanvas-&gt;deviceContext() == &amp;device)
855             return inspectorCanvas;
856     }
857     return nullptr;
858 }
859 #endif
860 
861 void InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)
862 {
863     String identifier = inspectorProgram.identifier();
864     m_identifierToInspectorProgram.remove(identifier);
865 
866     // This can be called in response to GC. Due to the single-process model used in WebKit1, the
867     // event must be dispatched from a timer to prevent the frontend from making JS allocations
868     // while the GC is still active.
869     m_removedProgramIdentifiers.append(identifier);
870 
871     if (!m_programDestroyedTimer.isActive())
872         m_programDestroyedTimer.startOneShot(0_s);
873 }
874 
875 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)
876 {
877     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
878     if (!inspectorProgram) {
879         errorString = &quot;Missing program for given programId&quot;_s;
880         return nullptr;
881     }
882     return inspectorProgram;
883 }
884 
885 #if ENABLE(WEBGL)
886 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)
887 {
888     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
889         if (inspectorProgram-&gt;program() == &amp;program)
890             return inspectorProgram;
891     }
892     return nullptr;
893 }
894 #endif
895 
896 #if ENABLE(WEBGPU)
897 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGPUPipeline&amp; pipeline)
898 {
899     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
900         if (inspectorProgram-&gt;pipeline() == &amp;pipeline)
901             return inspectorProgram;
902     }
903     return nullptr;
904 }
905 #endif
906 
907 } // namespace WebCore
    </pre>
  </body>
</html>
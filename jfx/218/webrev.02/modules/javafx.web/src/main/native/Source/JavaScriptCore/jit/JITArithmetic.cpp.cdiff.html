<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITAddGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITArithmetic32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  
  #if ENABLE(JIT)
  #include &quot;JIT.h&quot;
  
  #include &quot;ArithProfile.h&quot;
<span class="line-added">+ #include &quot;BytecodeGenerator.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;JITAddGenerator.h&quot;
  #include &quot;JITBitAndGenerator.h&quot;
  #include &quot;JITBitOrGenerator.h&quot;
  #include &quot;JITBitXorGenerator.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,32 ***</span>
  #if USE(JSVALUE64)
  
  void JIT::emit_op_unsigned(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_operand.offset();</span>
  
      emitGetVirtualRegister(op1, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
      boxInt32(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(result, regT0);
  }
  
  template&lt;typename Op&gt;
  void JIT::emit_compareAndJump(const Instruction* instruction, RelationalCondition condition)
  {
      // We generate inline code for the following cases in the fast path:
      // - int immediate to constant int immediate
      // - constant int immediate to int immediate
      // - int immediate to int immediate
  
<span class="line-removed">-     auto bytecode = instruction-&gt;as&lt;Op&gt;();</span>
<span class="line-removed">-     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">-     int op2 = bytecode.m_rhs.offset();</span>
<span class="line-removed">-     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);</span>
      bool disallowAllocation = false;
      if (isOperandConstantChar(op1)) {
          emitGetVirtualRegister(op2, regT0);
          addSlowCase(branchIfNotCell(regT0));
          JumpList failures;
<span class="line-new-header">--- 156,37 ---</span>
  #if USE(JSVALUE64)
  
  void JIT::emit_op_unsigned(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_operand;</span>
  
      emitGetVirtualRegister(op1, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
      boxInt32(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(result, regT0);
  }
  
  template&lt;typename Op&gt;
  void JIT::emit_compareAndJump(const Instruction* instruction, RelationalCondition condition)
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = instruction-&gt;as&lt;Op&gt;();</span>
<span class="line-added">+     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-added">+     VirtualRegister op2 = bytecode.m_rhs;</span>
<span class="line-added">+     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);</span>
<span class="line-added">+     emit_compareAndJumpImpl(op1, op2, target, condition);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_compareAndJumpImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, RelationalCondition condition)</span>
  {
      // We generate inline code for the following cases in the fast path:
      // - int immediate to constant int immediate
      // - constant int immediate to int immediate
      // - int immediate to int immediate
  
      bool disallowAllocation = false;
      if (isOperandConstantChar(op1)) {
          emitGetVirtualRegister(op2, regT0);
          addSlowCase(branchIfNotCell(regT0));
          JumpList failures;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 222,13 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
      if (isOperandConstantInt(op2)) {
          emitGetVirtualRegister(op1, regT0);
          int32_t op2imm = getOperandConstantInt(op2);
          addJump(branch32(condition, regT0, Imm32(op2imm)), target);
      } else if (isOperandConstantInt(op1)) {
<span class="line-new-header">--- 228,18 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-added">+     emit_compareUnsignedAndJumpImpl(op1, op2, target, condition);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_compareUnsignedAndJumpImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, RelationalCondition condition)</span>
<span class="line-added">+ {</span>
      if (isOperandConstantInt(op2)) {
          emitGetVirtualRegister(op1, regT0);
          int32_t op2imm = getOperandConstantInt(op2);
          addJump(branch32(condition, regT0, Imm32(op2imm)), target);
      } else if (isOperandConstantInt(op1)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,13 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      if (isOperandConstantInt(op2)) {
          emitGetVirtualRegister(op1, regT0);
          int32_t op2imm = getOperandConstantInt(op2);
          compare32(condition, regT0, Imm32(op2imm), regT0);
      } else if (isOperandConstantInt(op1)) {
<span class="line-new-header">--- 254,18 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
<span class="line-added">+     emit_compareUnsignedImpl(dst, op1, op2, condition);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_compareUnsignedImpl(VirtualRegister dst, VirtualRegister op1, VirtualRegister op2, RelationalCondition condition)</span>
<span class="line-added">+ {</span>
      if (isOperandConstantInt(op2)) {
          emitGetVirtualRegister(op1, regT0);
          int32_t op2imm = getOperandConstantInt(op2);
          compare32(condition, regT0, Imm32(op2imm), regT0);
      } else if (isOperandConstantInt(op1)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,112 ***</span>
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  template&lt;typename Op&gt;
<span class="line-modified">! void JIT::emit_compareAndJumpSlow(const Instruction* instruction, DoubleCondition condition, size_t (JIT_OPERATION *operation)(ExecState*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
  
      // We generate inline code for the following cases in the slow path:
      // - floating-point number to constant int immediate
      // - constant int immediate to floating-point number
      // - floating-point number to floating-point number.
      if (isOperandConstantChar(op1) || isOperandConstantChar(op2)) {
          linkAllSlowCases(iter);
  
          emitGetVirtualRegister(op1, argumentGPR0);
          emitGetVirtualRegister(op2, argumentGPR1);
<span class="line-modified">!         callOperation(operation, argumentGPR0, argumentGPR1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      if (isOperandConstantInt(op2)) {
          linkAllSlowCases(iter);
  
          if (supportsFloatingPoint()) {
              Jump fail1 = branchIfNotNumber(regT0);
<span class="line-modified">!             add64(tagTypeNumberRegister, regT0);</span>
              move64ToDouble(regT0, fpRegT0);
  
              int32_t op2imm = getConstantOperand(op2).asInt32();
  
              move(Imm32(op2imm), regT1);
              convertInt32ToDouble(regT1, fpRegT1);
  
              emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!             emitJumpSlowToHot(jump(), instruction-&gt;size());</span>
  
              fail1.link(this);
          }
  
          emitGetVirtualRegister(op2, regT1);
<span class="line-modified">!         callOperation(operation, regT0, regT1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      if (isOperandConstantInt(op1)) {
          linkAllSlowCases(iter);
  
          if (supportsFloatingPoint()) {
              Jump fail1 = branchIfNotNumber(regT1);
<span class="line-modified">!             add64(tagTypeNumberRegister, regT1);</span>
              move64ToDouble(regT1, fpRegT1);
  
              int32_t op1imm = getConstantOperand(op1).asInt32();
  
              move(Imm32(op1imm), regT0);
              convertInt32ToDouble(regT0, fpRegT0);
  
              emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!             emitJumpSlowToHot(jump(), instruction-&gt;size());</span>
  
              fail1.link(this);
          }
  
          emitGetVirtualRegister(op1, regT2);
<span class="line-modified">!         callOperation(operation, regT2, regT1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      linkSlowCase(iter); // LHS is not Int.
  
      if (supportsFloatingPoint()) {
          Jump fail1 = branchIfNotNumber(regT0);
          Jump fail2 = branchIfNotNumber(regT1);
          Jump fail3 = branchIfInt32(regT1);
<span class="line-modified">!         add64(tagTypeNumberRegister, regT0);</span>
<span class="line-modified">!         add64(tagTypeNumberRegister, regT1);</span>
          move64ToDouble(regT0, fpRegT0);
          move64ToDouble(regT1, fpRegT1);
  
          emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!         emitJumpSlowToHot(jump(), instruction-&gt;size());</span>
  
          fail1.link(this);
          fail2.link(this);
          fail3.link(this);
      }
  
      linkSlowCase(iter); // RHS is not Int.
<span class="line-modified">!     callOperation(operation, regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
  }
  
  void JIT::emit_op_inc(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     int srcDst = bytecode.m_srcDst.offset();</span>
  
      emitGetVirtualRegister(srcDst, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
      boxInt32(regT0, JSValueRegs { regT0 });
<span class="line-new-header">--- 279,117 ---</span>
      boxBoolean(regT0, JSValueRegs { regT0 });
      emitPutVirtualRegister(dst);
  }
  
  template&lt;typename Op&gt;
<span class="line-modified">! void JIT::emit_compareAndJumpSlow(const Instruction* instruction, DoubleCondition condition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
  {
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
      unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-added">+     emit_compareAndJumpSlowImpl(op1, op2, target, instruction-&gt;size(), condition, operation, invert, iter);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_compareAndJumpSlowImpl(VirtualRegister op1, VirtualRegister op2, unsigned target, size_t instructionSize, DoubleCondition condition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
<span class="line-added">+ {</span>
  
      // We generate inline code for the following cases in the slow path:
      // - floating-point number to constant int immediate
      // - constant int immediate to floating-point number
      // - floating-point number to floating-point number.
      if (isOperandConstantChar(op1) || isOperandConstantChar(op2)) {
          linkAllSlowCases(iter);
  
          emitGetVirtualRegister(op1, argumentGPR0);
          emitGetVirtualRegister(op2, argumentGPR1);
<span class="line-modified">!         callOperation(operation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), argumentGPR0, argumentGPR1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      if (isOperandConstantInt(op2)) {
          linkAllSlowCases(iter);
  
          if (supportsFloatingPoint()) {
              Jump fail1 = branchIfNotNumber(regT0);
<span class="line-modified">!             add64(numberTagRegister, regT0);</span>
              move64ToDouble(regT0, fpRegT0);
  
              int32_t op2imm = getConstantOperand(op2).asInt32();
  
              move(Imm32(op2imm), regT1);
              convertInt32ToDouble(regT1, fpRegT1);
  
              emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!             emitJumpSlowToHot(jump(), instructionSize);</span>
  
              fail1.link(this);
          }
  
          emitGetVirtualRegister(op2, regT1);
<span class="line-modified">!         callOperation(operation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      if (isOperandConstantInt(op1)) {
          linkAllSlowCases(iter);
  
          if (supportsFloatingPoint()) {
              Jump fail1 = branchIfNotNumber(regT1);
<span class="line-modified">!             add64(numberTagRegister, regT1);</span>
              move64ToDouble(regT1, fpRegT1);
  
              int32_t op1imm = getConstantOperand(op1).asInt32();
  
              move(Imm32(op1imm), regT0);
              convertInt32ToDouble(regT0, fpRegT0);
  
              emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!             emitJumpSlowToHot(jump(), instructionSize);</span>
  
              fail1.link(this);
          }
  
          emitGetVirtualRegister(op1, regT2);
<span class="line-modified">!         callOperation(operation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT2, regT1);</span>
          emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
          return;
      }
  
      linkSlowCase(iter); // LHS is not Int.
  
      if (supportsFloatingPoint()) {
          Jump fail1 = branchIfNotNumber(regT0);
          Jump fail2 = branchIfNotNumber(regT1);
          Jump fail3 = branchIfInt32(regT1);
<span class="line-modified">!         add64(numberTagRegister, regT0);</span>
<span class="line-modified">!         add64(numberTagRegister, regT1);</span>
          move64ToDouble(regT0, fpRegT0);
          move64ToDouble(regT1, fpRegT1);
  
          emitJumpSlowToHot(branchDouble(condition, fpRegT0, fpRegT1), target);
  
<span class="line-modified">!         emitJumpSlowToHot(jump(), instructionSize);</span>
  
          fail1.link(this);
          fail2.link(this);
          fail3.link(this);
      }
  
      linkSlowCase(iter); // RHS is not Int.
<span class="line-modified">!     callOperation(operation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
      emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
  }
  
  void JIT::emit_op_inc(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">!     VirtualRegister srcDst = bytecode.m_srcDst;</span>
  
      emitGetVirtualRegister(srcDst, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
      boxInt32(regT0, JSValueRegs { regT0 });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,11 ***</span>
  }
  
  void JIT::emit_op_dec(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     int srcDst = bytecode.m_srcDst.offset();</span>
  
      emitGetVirtualRegister(srcDst, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
      boxInt32(regT0, JSValueRegs { regT0 });
<span class="line-new-header">--- 397,11 ---</span>
  }
  
  void JIT::emit_op_dec(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">!     VirtualRegister srcDst = bytecode.m_srcDst;</span>
  
      emitGetVirtualRegister(srcDst, regT0);
      emitJumpSlowCaseIfNotInt(regT0);
      addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
      boxInt32(regT0, JSValueRegs { regT0 });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,13 ***</span>
  #if CPU(X86_64)
  
  void JIT::emit_op_mod(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMod&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
  
      // Make sure registers are correct for x86 IDIV instructions.
      ASSERT(regT0 == X86Registers::eax);
      auto edx = X86Registers::edx;
      auto ecx = X86Registers::ecx;
<span class="line-new-header">--- 413,13 ---</span>
  #if CPU(X86_64)
  
  void JIT::emit_op_mod(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpMod&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
      // Make sure registers are correct for x86 IDIV instructions.
      ASSERT(regT0 == X86Registers::eax);
      auto edx = X86Registers::edx;
      auto ecx = X86Registers::ecx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_negate(const Instruction* currentInstruction)
  {
<span class="line-modified">!     ArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpNegate&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITNegIC* negateIC = m_codeBlock-&gt;addJITNegIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, negateIC);
      emitMathICFast&lt;OpNegate&gt;(negateIC, currentInstruction, operationArithNegateProfiled, operationArithNegate);
  }
  
<span class="line-new-header">--- 471,11 ---</span>
  
  #endif // USE(JSVALUE64)
  
  void JIT::emit_op_negate(const Instruction* currentInstruction)
  {
<span class="line-modified">!     UnaryArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpNegate&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITNegIC* negateIC = m_codeBlock-&gt;addJITNegIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, negateIC);
      emitMathICFast&lt;OpNegate&gt;(negateIC, currentInstruction, operationArithNegateProfiled, operationArithNegate);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 468,13 ***</span>
  
  template&lt;typename Op, typename SnippetGenerator&gt;
  void JIT::emitBitBinaryOpFastPath(const Instruction* currentInstruction, ProfilingPolicy profilingPolicy)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
<span class="line-new-header">--- 489,13 ---</span>
  
  template&lt;typename Op, typename SnippetGenerator&gt;
  void JIT::emitBitBinaryOpFastPath(const Instruction* currentInstruction, ProfilingPolicy profilingPolicy)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,12 ***</span>
  }
  
  void JIT::emit_op_bitnot(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_operand.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
  #else
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
<span class="line-new-header">--- 536,12 ---</span>
  }
  
  void JIT::emit_op_bitnot(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_operand;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
  #else
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 576,13 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emitRightShiftFastPath(const Instruction* currentInstruction, JITRightShiftGenerator::ShiftType snippetShiftType)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">!     int op2 = bytecode.m_rhs.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
<span class="line-new-header">--- 597,13 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emitRightShiftFastPath(const Instruction* currentInstruction, JITRightShiftGenerator::ShiftType snippetShiftType)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,18 ***</span>
  void JIT::emit_op_urshift(const Instruction* currentInstruction)
  {
      emitRightShiftFastPath(currentInstruction, op_urshift);
  }
  
<span class="line-removed">- ALWAYS_INLINE static OperandTypes getOperandTypes(const ArithProfile&amp; arithProfile)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return OperandTypes(arithProfile.lhsResultType(), arithProfile.rhsResultType());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void JIT::emit_op_add(const Instruction* currentInstruction)
  {
<span class="line-modified">!     ArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpAdd&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITAddIC* addIC = m_codeBlock-&gt;addJITAddIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, addIC);
      emitMathICFast&lt;OpAdd&gt;(addIC, currentInstruction, operationValueAddProfiled, operationValueAdd);
  }
  
<span class="line-new-header">--- 652,13 ---</span>
  void JIT::emit_op_urshift(const Instruction* currentInstruction)
  {
      emitRightShiftFastPath(currentInstruction, op_urshift);
  }
  
  void JIT::emit_op_add(const Instruction* currentInstruction)
  {
<span class="line-modified">!     BinaryArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpAdd&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITAddIC* addIC = m_codeBlock-&gt;addJITAddIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, addIC);
      emitMathICFast&lt;OpAdd&gt;(addIC, currentInstruction, operationValueAddProfiled, operationValueAdd);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 656,12 ***</span>
  
  template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
  void JIT::emitMathICFast(JITUnaryMathIC&lt;Generator&gt;* mathIC, const Instruction* currentInstruction, ProfiledFunction profiledFunction, NonProfiledFunction nonProfiledFunction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int operand = bytecode.m_operand.offset();</span>
  
  #if USE(JSVALUE64)
      // ArithNegate benefits from using the same register as src and dst.
      // Since regT1==argumentGPR1, using regT1 avoid shuffling register to call the slow path.
      JSValueRegs srcRegs = JSValueRegs(regT1);
<span class="line-new-header">--- 672,12 ---</span>
  
  template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
  void JIT::emitMathICFast(JITUnaryMathIC&lt;Generator&gt;* mathIC, const Instruction* currentInstruction, ProfiledFunction profiledFunction, NonProfiledFunction nonProfiledFunction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister operand = bytecode.m_operand;</span>
  
  #if USE(JSVALUE64)
      // ArithNegate benefits from using the same register as src and dst.
      // Since regT1==argumentGPR1, using regT1 avoid shuffling register to call the slow path.
      JSValueRegs srcRegs = JSValueRegs(regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 683,15 ***</span>
  
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.add(currentInstruction, MathICGenerationState()).iterator-&gt;value;
  
      bool generatedInlineCode = mathIC-&gt;generateInline(*this, mathICGenerationState);
      if (!generatedInlineCode) {
<span class="line-modified">!         ArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
          if (arithProfile &amp;&amp; shouldEmitProfiling())
<span class="line-modified">!             callOperationWithResult(profiledFunction, resultRegs, srcRegs, arithProfile);</span>
          else
<span class="line-modified">!             callOperationWithResult(nonProfiledFunction, resultRegs, srcRegs);</span>
      } else
          addSlowCase(mathICGenerationState.slowPathJumps);
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = label();
<span class="line-new-header">--- 699,15 ---</span>
  
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.add(currentInstruction, MathICGenerationState()).iterator-&gt;value;
  
      bool generatedInlineCode = mathIC-&gt;generateInline(*this, mathICGenerationState);
      if (!generatedInlineCode) {
<span class="line-modified">!         UnaryArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
          if (arithProfile &amp;&amp; shouldEmitProfiling())
<span class="line-modified">!             callOperationWithResult(profiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), srcRegs, arithProfile);</span>
          else
<span class="line-modified">!             callOperationWithResult(nonProfiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), srcRegs);</span>
      } else
          addSlowCase(mathICGenerationState.slowPathJumps);
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = label();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,14 ***</span>
  
  template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
  void JIT::emitMathICFast(JITBinaryMathIC&lt;Generator&gt;* mathIC, const Instruction* currentInstruction, ProfiledFunction profiledFunction, NonProfiledFunction nonProfiledFunction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     OperandTypes types = getOperandTypes(copiedArithProfile(bytecode));</span>
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">-     int op2 = bytecode.m_rhs.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT1);
      JSValueRegs rightRegs = JSValueRegs(regT2);
      JSValueRegs resultRegs = JSValueRegs(regT0);
<span class="line-new-header">--- 722,13 ---</span>
  
  template &lt;typename Op, typename Generator, typename ProfiledFunction, typename NonProfiledFunction&gt;
  void JIT::emitMathICFast(JITBinaryMathIC&lt;Generator&gt;* mathIC, const Instruction* currentInstruction, ProfiledFunction profiledFunction, NonProfiledFunction nonProfiledFunction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT1);
      JSValueRegs rightRegs = JSValueRegs(regT2);
      JSValueRegs resultRegs = JSValueRegs(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,12 ***</span>
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT4;
      FPRReg scratchFPR = fpRegT2;
  #endif
  
<span class="line-modified">!     SnippetOperand leftOperand(types.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(types.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
      else if (isOperandConstantInt(op2))
          rightOperand.setConstInt32(getOperandConstantInt(op2));
<span class="line-new-header">--- 740,12 ---</span>
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT4;
      FPRReg scratchFPR = fpRegT2;
  #endif
  
<span class="line-modified">!     SnippetOperand leftOperand(bytecode.m_operandTypes.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(bytecode.m_operandTypes.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
      else if (isOperandConstantInt(op2))
          rightOperand.setConstInt32(getOperandConstantInt(op2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 756,15 ***</span>
      if (!generatedInlineCode) {
          if (leftOperand.isConst())
              emitGetVirtualRegister(op1, leftRegs);
          else if (rightOperand.isConst())
              emitGetVirtualRegister(op2, rightRegs);
<span class="line-modified">!         ArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
          if (arithProfile &amp;&amp; shouldEmitProfiling())
<span class="line-modified">!             callOperationWithResult(profiledFunction, resultRegs, leftRegs, rightRegs, arithProfile);</span>
          else
<span class="line-modified">!             callOperationWithResult(nonProfiledFunction, resultRegs, leftRegs, rightRegs);</span>
      } else
          addSlowCase(mathICGenerationState.slowPathJumps);
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = label();
<span class="line-new-header">--- 771,15 ---</span>
      if (!generatedInlineCode) {
          if (leftOperand.isConst())
              emitGetVirtualRegister(op1, leftRegs);
          else if (rightOperand.isConst())
              emitGetVirtualRegister(op2, rightRegs);
<span class="line-modified">!         BinaryArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
          if (arithProfile &amp;&amp; shouldEmitProfiling())
<span class="line-modified">!             callOperationWithResult(profiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), leftRegs, rightRegs, arithProfile);</span>
          else
<span class="line-modified">!             callOperationWithResult(nonProfiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), leftRegs, rightRegs);</span>
      } else
          addSlowCase(mathICGenerationState.slowPathJumps);
  
  #if ENABLE(MATH_IC_STATS)
      auto inlineEnd = label();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 782,11 ***</span>
  {
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.find(currentInstruction)-&gt;value;
      mathICGenerationState.slowPathStart = label();
  
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs srcRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = JSValueRegs(regT0);
  #else
<span class="line-new-header">--- 797,11 ---</span>
  {
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.find(currentInstruction)-&gt;value;
      mathICGenerationState.slowPathStart = label();
  
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs srcRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = JSValueRegs(regT0);
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 796,18 ***</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathStart = label();
  #endif
  
<span class="line-modified">!     ArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
      if (arithProfile &amp;&amp; shouldEmitProfiling()) {
          if (mathICGenerationState.shouldSlowPathRepatch)
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(reinterpret_cast&lt;J_JITOperation_EJMic&gt;(profiledRepatchFunction), resultRegs, srcRegs, TrustedImmPtr(mathIC));</span>
          else
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(profiledFunction, resultRegs, srcRegs, arithProfile);</span>
      } else
<span class="line-modified">!         mathICGenerationState.slowPathCall = callOperationWithResult(reinterpret_cast&lt;J_JITOperation_EJMic&gt;(repatchFunction), resultRegs, srcRegs, TrustedImmPtr(mathIC));</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathEnd = label();
      addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
          size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
<span class="line-new-header">--- 811,18 ---</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathStart = label();
  #endif
  
<span class="line-modified">!     UnaryArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
      if (arithProfile &amp;&amp; shouldEmitProfiling()) {
          if (mathICGenerationState.shouldSlowPathRepatch)
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(reinterpret_cast&lt;J_JITOperation_GJMic&gt;(profiledRepatchFunction), resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), srcRegs, TrustedImmPtr(mathIC));</span>
          else
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(profiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), srcRegs, arithProfile);</span>
      } else
<span class="line-modified">!         mathICGenerationState.slowPathCall = callOperationWithResult(reinterpret_cast&lt;J_JITOperation_GJMic&gt;(repatchFunction), resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), srcRegs, TrustedImmPtr(mathIC));</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathEnd = label();
      addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
          size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,14 ***</span>
  {
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.find(currentInstruction)-&gt;value;
      mathICGenerationState.slowPathStart = label();
  
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     OperandTypes types = getOperandTypes(copiedArithProfile(bytecode));</span>
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">-     int op2 = bytecode.m_rhs.offset();</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT1);
      JSValueRegs rightRegs = JSValueRegs(regT2);
      JSValueRegs resultRegs = JSValueRegs(regT0);
<span class="line-new-header">--- 843,13 ---</span>
  {
      MathICGenerationState&amp; mathICGenerationState = m_instructionToMathICGenerationState.find(currentInstruction)-&gt;value;
      mathICGenerationState.slowPathStart = label();
  
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT1);
      JSValueRegs rightRegs = JSValueRegs(regT2);
      JSValueRegs resultRegs = JSValueRegs(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 843,12 ***</span>
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
      JSValueRegs rightRegs = JSValueRegs(regT3, regT2);
      JSValueRegs resultRegs = leftRegs;
  #endif
  
<span class="line-modified">!     SnippetOperand leftOperand(types.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(types.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
      else if (isOperandConstantInt(op2))
          rightOperand.setConstInt32(getOperandConstantInt(op2));
<span class="line-new-header">--- 857,12 ---</span>
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
      JSValueRegs rightRegs = JSValueRegs(regT3, regT2);
      JSValueRegs resultRegs = leftRegs;
  #endif
  
<span class="line-modified">!     SnippetOperand leftOperand(bytecode.m_operandTypes.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(bytecode.m_operandTypes.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
      else if (isOperandConstantInt(op2))
          rightOperand.setConstInt32(getOperandConstantInt(op2));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 862,18 ***</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathStart = label();
  #endif
  
<span class="line-modified">!     ArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
      if (arithProfile &amp;&amp; shouldEmitProfiling()) {
          if (mathICGenerationState.shouldSlowPathRepatch)
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(profiledRepatchFunction), resultRegs, leftRegs, rightRegs, TrustedImmPtr(mathIC));</span>
          else
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(profiledFunction, resultRegs, leftRegs, rightRegs, arithProfile);</span>
      } else
<span class="line-modified">!         mathICGenerationState.slowPathCall = callOperationWithResult(bitwise_cast&lt;J_JITOperation_EJJMic&gt;(repatchFunction), resultRegs, leftRegs, rightRegs, TrustedImmPtr(mathIC));</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathEnd = label();
      addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
          size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
<span class="line-new-header">--- 876,18 ---</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathStart = label();
  #endif
  
<span class="line-modified">!     BinaryArithProfile* arithProfile = mathIC-&gt;arithProfile();</span>
      if (arithProfile &amp;&amp; shouldEmitProfiling()) {
          if (mathICGenerationState.shouldSlowPathRepatch)
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(bitwise_cast&lt;J_JITOperation_GJJMic&gt;(profiledRepatchFunction), resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), leftRegs, rightRegs, TrustedImmPtr(mathIC));</span>
          else
<span class="line-modified">!             mathICGenerationState.slowPathCall = callOperationWithResult(profiledFunction, resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), leftRegs, rightRegs, arithProfile);</span>
      } else
<span class="line-modified">!         mathICGenerationState.slowPathCall = callOperationWithResult(bitwise_cast&lt;J_JITOperation_GJJMic&gt;(repatchFunction), resultRegs, TrustedImmPtr(m_codeBlock-&gt;globalObject()), leftRegs, rightRegs, TrustedImmPtr(mathIC));</span>
  
  #if ENABLE(MATH_IC_STATS)
      auto slowPathEnd = label();
      addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
          size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,36 ***</span>
  }
  
  void JIT::emit_op_div(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDiv&gt;();
<span class="line-modified">!     auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-modified">!     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">-     int op2 = bytecode.m_rhs.offset();</span>
  
  #if USE(JSVALUE64)
<span class="line-removed">-     OperandTypes types = getOperandTypes(metadata.m_arithProfile);</span>
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT2;
  #else
<span class="line-removed">-     OperandTypes types = getOperandTypes(metadata.m_arithProfile);</span>
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
      JSValueRegs rightRegs = JSValueRegs(regT3, regT2);
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT4;
  #endif
      FPRReg scratchFPR = fpRegT2;
  
<span class="line-modified">!     ArithProfile* arithProfile = nullptr;</span>
      if (shouldEmitProfiling())
          arithProfile = &amp;currentInstruction-&gt;as&lt;OpDiv&gt;().metadata(m_codeBlock).m_arithProfile;
  
<span class="line-modified">!     SnippetOperand leftOperand(types.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(types.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
  #if USE(JSVALUE64)
      else if (isOperandConstantDouble(op1))
<span class="line-new-header">--- 904,33 ---</span>
  }
  
  void JIT::emit_op_div(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDiv&gt;();
<span class="line-modified">!     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">!     VirtualRegister op2 = bytecode.m_rhs;</span>
  
  #if USE(JSVALUE64)
      JSValueRegs leftRegs = JSValueRegs(regT0);
      JSValueRegs rightRegs = JSValueRegs(regT1);
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT2;
  #else
      JSValueRegs leftRegs = JSValueRegs(regT1, regT0);
      JSValueRegs rightRegs = JSValueRegs(regT3, regT2);
      JSValueRegs resultRegs = leftRegs;
      GPRReg scratchGPR = regT4;
  #endif
      FPRReg scratchFPR = fpRegT2;
  
<span class="line-modified">!     BinaryArithProfile* arithProfile = nullptr;</span>
      if (shouldEmitProfiling())
          arithProfile = &amp;currentInstruction-&gt;as&lt;OpDiv&gt;().metadata(m_codeBlock).m_arithProfile;
  
<span class="line-modified">!     SnippetOperand leftOperand(bytecode.m_operandTypes.first());</span>
<span class="line-modified">!     SnippetOperand rightOperand(bytecode.m_operandTypes.second());</span>
  
      if (isOperandConstantInt(op1))
          leftOperand.setConstInt32(getOperandConstantInt(op1));
  #if USE(JSVALUE64)
      else if (isOperandConstantDouble(op1))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 957,11 ***</span>
      }
  }
  
  void JIT::emit_op_mul(const Instruction* currentInstruction)
  {
<span class="line-modified">!     ArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpMul&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITMulIC* mulIC = m_codeBlock-&gt;addJITMulIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, mulIC);
      emitMathICFast&lt;OpMul&gt;(mulIC, currentInstruction, operationValueMulProfiled, operationValueMul);
  }
  
<span class="line-new-header">--- 968,11 ---</span>
      }
  }
  
  void JIT::emit_op_mul(const Instruction* currentInstruction)
  {
<span class="line-modified">!     BinaryArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpMul&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITMulIC* mulIC = m_codeBlock-&gt;addJITMulIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, mulIC);
      emitMathICFast&lt;OpMul&gt;(mulIC, currentInstruction, operationValueMulProfiled, operationValueMul);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 973,11 ***</span>
      emitMathICSlow&lt;OpMul&gt;(mulIC, currentInstruction, operationValueMulProfiledOptimize, operationValueMulProfiled, operationValueMulOptimize);
  }
  
  void JIT::emit_op_sub(const Instruction* currentInstruction)
  {
<span class="line-modified">!     ArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpSub&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITSubIC* subIC = m_codeBlock-&gt;addJITSubIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, subIC);
      emitMathICFast&lt;OpSub&gt;(subIC, currentInstruction, operationValueSubProfiled, operationValueSub);
  }
  
<span class="line-new-header">--- 984,11 ---</span>
      emitMathICSlow&lt;OpMul&gt;(mulIC, currentInstruction, operationValueMulProfiledOptimize, operationValueMulProfiled, operationValueMulOptimize);
  }
  
  void JIT::emit_op_sub(const Instruction* currentInstruction)
  {
<span class="line-modified">!     BinaryArithProfile* arithProfile = &amp;currentInstruction-&gt;as&lt;OpSub&gt;().metadata(m_codeBlock).m_arithProfile;</span>
      JITSubIC* subIC = m_codeBlock-&gt;addJITSubIC(arithProfile);
      m_instructionToMathIC.add(currentInstruction, subIC);
      emitMathICFast&lt;OpSub&gt;(subIC, currentInstruction, operationValueSubProfiled, operationValueSub);
  }
  
</pre>
<center><a href="JITAddGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITArithmetic32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
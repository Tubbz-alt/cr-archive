<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebAssemblyModulePrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyModuleRecord.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WebAssemblyModuleRecord.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,10 ***</span>
<span class="line-new-header">--- 30,11 ---</span>
  
  #include &quot;Error.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSModuleEnvironment.h&quot;
<span class="line-added">+ #include &quot;JSWebAssemblyGlobal.h&quot;</span>
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyLinkError.h&quot;
  #include &quot;JSWebAssemblyModule.h&quot;
  #include &quot;ProtoCallFrame.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,14 ***</span>
  Structure* WebAssemblyModuleRecord::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
<span class="line-modified">! WebAssemblyModuleRecord* WebAssemblyModuleRecord::create(ExecState* exec, VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey, const Wasm::ModuleInformation&amp; moduleInformation)</span>
  {
      WebAssemblyModuleRecord* instance = new (NotNull, allocateCell&lt;WebAssemblyModuleRecord&gt;(vm.heap)) WebAssemblyModuleRecord(vm, structure, moduleKey);
<span class="line-modified">!     instance-&gt;finishCreation(exec, vm, moduleInformation);</span>
      return instance;
  }
  
  WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
      : Base(vm, structure, moduleKey)
<span class="line-new-header">--- 49,14 ---</span>
  Structure* WebAssemblyModuleRecord::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
<span class="line-modified">! WebAssemblyModuleRecord* WebAssemblyModuleRecord::create(JSGlobalObject* globalObject, VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey, const Wasm::ModuleInformation&amp; moduleInformation)</span>
  {
      WebAssemblyModuleRecord* instance = new (NotNull, allocateCell&lt;WebAssemblyModuleRecord&gt;(vm.heap)) WebAssemblyModuleRecord(vm, structure, moduleKey);
<span class="line-modified">!     instance-&gt;finishCreation(globalObject, vm, moduleInformation);</span>
      return instance;
  }
  
  WebAssemblyModuleRecord::WebAssemblyModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
      : Base(vm, structure, moduleKey)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,13 ***</span>
  {
      WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
      thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
  }
  
<span class="line-modified">! void WebAssemblyModuleRecord::finishCreation(ExecState* exec, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)</span>
  {
<span class="line-modified">!     Base::finishCreation(exec, vm);</span>
      ASSERT(inherits(vm, info()));
      for (const auto&amp; exp : moduleInformation.exports) {
          Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));
          addExportEntry(ExportEntry::createLocal(field, field));
      }
<span class="line-new-header">--- 67,13 ---</span>
  {
      WebAssemblyModuleRecord* thisObject = static_cast&lt;WebAssemblyModuleRecord*&gt;(cell);
      thisObject-&gt;WebAssemblyModuleRecord::~WebAssemblyModuleRecord();
  }
  
<span class="line-modified">! void WebAssemblyModuleRecord::finishCreation(JSGlobalObject* globalObject, VM&amp; vm, const Wasm::ModuleInformation&amp; moduleInformation)</span>
  {
<span class="line-modified">!     Base::finishCreation(globalObject, vm);</span>
      ASSERT(inherits(vm, info()));
      for (const auto&amp; exp : moduleInformation.exports) {
          Identifier field = Identifier::fromString(vm, String::fromUTF8(exp.field));
          addExportEntry(ExportEntry::createLocal(field, field));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,25 ***</span>
  {
      RELEASE_ASSERT(!m_instance);
      m_instance.set(vm, this, instance);
  }
  
<span class="line-modified">! void WebAssemblyModuleRecord::link(ExecState* exec, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      UNUSED_PARAM(scope);
<span class="line-removed">-     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
  
      RELEASE_ASSERT(m_instance);
  
      Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
      JSWebAssemblyModule* module = m_instance-&gt;module();
      const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
  
      auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">!         throwException(exec, scope, error);</span>
      };
  
      auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
          return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
      };
<span class="line-new-header">--- 92,24 ---</span>
  {
      RELEASE_ASSERT(!m_instance);
      m_instance.set(vm, this, instance);
  }
  
<span class="line-modified">! void WebAssemblyModuleRecord::link(JSGlobalObject* globalObject, JSValue, JSObject* importObject, Wasm::CreationMode creationMode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      UNUSED_PARAM(scope);
  
      RELEASE_ASSERT(m_instance);
  
      Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
      JSWebAssemblyModule* module = m_instance-&gt;module();
      const Wasm::ModuleInformation&amp; moduleInformation = module-&gt;moduleInformation();
  
      auto exception = [&amp;] (JSObject* error) {
<span class="line-modified">!         throwException(globalObject, scope, error);</span>
      };
  
      auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
          return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,36 ***</span>
          Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
          Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
          JSValue value;
          if (creationMode == Wasm::CreationMode::FromJS) {
              // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">!             JSValue importModuleValue = importObject-&gt;get(exec, moduleName);</span>
              RETURN_IF_EXCEPTION(scope, void());
              // 2. If Type(o) is not Object, throw a TypeError.
              if (!importModuleValue.isObject())
<span class="line-modified">!                 return exception(createTypeError(exec, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
  
              // 3. Let v be the value of performing Get(o, i.item_name)
              JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">!             value = object-&gt;get(exec, fieldName);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             AbstractModuleRecord* importedModule = hostResolveImportedModule(exec, moduleName);</span>
              RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!             Resolution resolution = importedModule-&gt;resolveExport(exec, fieldName);</span>
              RETURN_IF_EXCEPTION(scope, void());
              switch (resolution.type) {
              case Resolution::Type::NotFound:
<span class="line-modified">!                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; is not found.&quot;));</span>
                  return;
  
              case Resolution::Type::Ambiguous:
<span class="line-modified">!                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; cannot be resolved due to ambiguous multiple bindings.&quot;));</span>
                  return;
  
              case Resolution::Type::Error:
<span class="line-modified">!                 throwSyntaxError(exec, scope, makeString(&quot;Importing binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
                  return;
  
              case Resolution::Type::Resolved:
                  break;
              }
<span class="line-new-header">--- 129,36 ---</span>
          Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
          Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
          JSValue value;
          if (creationMode == Wasm::CreationMode::FromJS) {
              // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<span class="line-modified">!             JSValue importModuleValue = importObject-&gt;get(globalObject, moduleName);</span>
              RETURN_IF_EXCEPTION(scope, void());
              // 2. If Type(o) is not Object, throw a TypeError.
              if (!importModuleValue.isObject())
<span class="line-modified">!                 return exception(createTypeError(globalObject, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
  
              // 3. Let v be the value of performing Get(o, i.item_name)
              JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<span class="line-modified">!             value = object-&gt;get(globalObject, fieldName);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, moduleName);</span>
              RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!             Resolution resolution = importedModule-&gt;resolveExport(globalObject, fieldName);</span>
              RETURN_IF_EXCEPTION(scope, void());
              switch (resolution.type) {
              case Resolution::Type::NotFound:
<span class="line-modified">!                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; is not found.&quot;));</span>
                  return;
  
              case Resolution::Type::Ambiguous:
<span class="line-modified">!                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;&quot;, String(fieldName.impl()), &quot;&#39; cannot be resolved due to ambiguous multiple bindings.&quot;));</span>
                  return;
  
              case Resolution::Type::Error:
<span class="line-modified">!                 throwSyntaxError(globalObject, scope, makeString(&quot;Importing binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));</span>
                  return;
  
              case Resolution::Type::Resolved:
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,11 ***</span>
          switch (import.kind) {
          case Wasm::ExternalKind::Function: {
              // 4. If i is a function import:
              // i. If IsCallable(v) is false, throw a WebAssembly.LinkError.
              if (!value.isFunction(vm))
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;import function&quot;, &quot;must be callable&quot;)));</span>
  
              Wasm::Instance* calleeInstance = nullptr;
              WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = nullptr;
              JSObject* function = jsCast&lt;JSObject*&gt;(value);
  
<span class="line-new-header">--- 187,11 ---</span>
          switch (import.kind) {
          case Wasm::ExternalKind::Function: {
              // 4. If i is a function import:
              // i. If IsCallable(v) is false, throw a WebAssembly.LinkError.
              if (!value.isFunction(vm))
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;import function&quot;, &quot;must be callable&quot;)));</span>
  
              Wasm::Instance* calleeInstance = nullptr;
              WasmToWasmImportableFunction::LoadLocation entrypointLoadLocation = nullptr;
              JSObject* function = jsCast&lt;JSObject*&gt;(value);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,11 ***</span>
                      // b. Let closure be v.[[Closure]].
                      function = wasmWrapperFunction-&gt;function();
                  }
                  Wasm::SignatureIndex expectedSignatureIndex = moduleInformation.importFunctionSignatureIndices[import.kindIndex];
                  if (importedSignatureIndex != expectedSignatureIndex)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported function&quot;, &quot;signature doesn&#39;t match the provided WebAssembly function&#39;s signature&quot;)));</span>
              }
              // iii. Otherwise:
              // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
              // Note: done as part of Plan compilation.
              // iv. Append v to funcs.
<span class="line-new-header">--- 210,11 ---</span>
                      // b. Let closure be v.[[Closure]].
                      function = wasmWrapperFunction-&gt;function();
                  }
                  Wasm::SignatureIndex expectedSignatureIndex = moduleInformation.importFunctionSignatureIndices[import.kindIndex];
                  if (importedSignatureIndex != expectedSignatureIndex)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported function&quot;, &quot;signature doesn&#39;t match the provided WebAssembly function&#39;s signature&quot;)));</span>
              }
              // iii. Otherwise:
              // a. Let closure be a new host function of the given signature which calls v by coercing WebAssembly arguments to JavaScript arguments via ToJSValue and returns the result, if any, by coercing via ToWebAssemblyValue.
              // Note: done as part of Plan compilation.
              // iv. Append v to funcs.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 227,67 ***</span>
              break;
          }
  
          case Wasm::ExternalKind::Global: {
              // 5. If i is a global import:
<span class="line-modified">!             // i. If i is not an immutable global, throw a TypeError.</span>
<span class="line-modified">!             ASSERT(moduleInformation.globals[import.kindIndex].mutability == Wasm::Global::Immutable);</span>
<span class="line-modified">!             // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.</span>
<span class="line-modified">!             if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)</span>
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));</span>
<span class="line-modified">!             if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));</span>
<span class="line-modified">!             // iii. Append ToWebAssemblyValue(v) to imports.</span>
<span class="line-modified">!             switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-modified">!             case Wasm::Funcref:</span>
<span class="line-modified">!                 if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case Wasm::Anyref:</span>
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case Wasm::I32:</span>
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(exec));</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case Wasm::F32:</span>
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(exec)));</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             case Wasm::F64:</span>
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 RELEASE_ASSERT_NOT_REACHED();</span>
              }
              scope.assertNoException();
              break;
          }
  
          case Wasm::ExternalKind::Table: {
              // 7. Otherwise (i is a table import):
              JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
              // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
              if (!table)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));</span>
  
              uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();
              uint32_t actualInitial = table-&gt;length();
              if (actualInitial &lt; expectedInitial)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));</span>
  
              if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {
                  Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
                  if (!actualMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
                  if (*actualMaximum &gt; *expectedMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));</span>
              }
  
              auto expectedType = moduleInformation.tables[import.kindIndex].type();
              auto actualType = table-&gt;table()-&gt;type();
              if (expectedType != actualType)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
  
              // ii. Append v to tables.
              // iii. Append v.[[Table]] to imports.
              m_instance-&gt;setTable(vm, import.kindIndex, table);
              RETURN_IF_EXCEPTION(scope, void());
<span class="line-new-header">--- 227,106 ---</span>
              break;
          }
  
          case Wasm::ExternalKind::Global: {
              // 5. If i is a global import:
<span class="line-modified">!             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[import.kindIndex];</span>
<span class="line-modified">!             if (global.mutability == Wasm::GlobalInformation::Immutable) {</span>
<span class="line-modified">!                 if (value.inherits&lt;JSWebAssemblyGlobal&gt;(vm)) {</span>
<span class="line-modified">!                     JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-modified">!                     if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-modified">!                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-modified">!                     if (globalValue-&gt;global()-&gt;mutability() != Wasm::GlobalInformation::Immutable)</span>
<span class="line-modified">!                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-modified">!                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-modified">!                     case Wasm::Funcref:</span>
<span class="line-modified">!                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">!                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-modified">!                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-modified">!                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     case Wasm::Anyref:</span>
<span class="line-modified">!                         value = globalValue-&gt;global()-&gt;get();</span>
<span class="line-modified">!                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     case Wasm::I32:</span>
<span class="line-modified">!                     case Wasm::I64:</span>
<span class="line-modified">!                     case Wasm::F32:</span>
<span class="line-modified">!                     case Wasm::F64:</span>
<span class="line-modified">!                         m_instance-&gt;instance().setGlobal(import.kindIndex, globalValue-&gt;global()-&gt;getPrimitive());</span>
<span class="line-modified">!                         break;</span>
<span class="line-modified">!                     default:</span>
<span class="line-modified">!                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-modified">!                     }</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     // ii. If the global_type of i is i64 or Type(v) is not Number, throw a WebAssembly.LinkError.</span>
<span class="line-added">+                     if (moduleInformation.globals[import.kindIndex].type == Wasm::I64)</span>
<span class="line-added">+                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;cannot be an i64&quot;)));</span>
<span class="line-added">+                     if (!isSubtype(moduleInformation.globals[import.kindIndex].type, Wasm::Anyref) &amp;&amp; !value.isNumber())</span>
<span class="line-added">+                         return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a number&quot;)));</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // iii. Append ToWebAssemblyValue(v) to imports.</span>
<span class="line-added">+                     switch (moduleInformation.globals[import.kindIndex].type) {</span>
<span class="line-added">+                     case Wasm::Funcref:</span>
<span class="line-added">+                         if (!isWebAssemblyHostFunction(vm, value) &amp;&amp; !value.isNull())</span>
<span class="line-added">+                             return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a wasm exported function or null&quot;)));</span>
<span class="line-added">+                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case Wasm::Anyref:</span>
<span class="line-added">+                         m_instance-&gt;instance().setGlobal(import.kindIndex, value);</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case Wasm::I32:</span>
<span class="line-added">+                         m_instance-&gt;instance().setGlobal(import.kindIndex, value.toInt32(globalObject));</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case Wasm::F32:</span>
<span class="line-added">+                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject)));</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     case Wasm::F64:</span>
<span class="line-added">+                         m_instance-&gt;instance().setGlobal(import.kindIndex, bitwise_cast&lt;uint64_t&gt;(value.asNumber()));</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+                     default:</span>
<span class="line-added">+                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 if (!value.inherits&lt;JSWebAssemblyGlobal&gt;(vm))</span>
<span class="line-added">+                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a WebAssembly.Global object since it is mutable&quot;)));</span>
<span class="line-added">+                 JSWebAssemblyGlobal* globalValue = jsCast&lt;JSWebAssemblyGlobal*&gt;(value);</span>
<span class="line-added">+                 if (globalValue-&gt;global()-&gt;type() != global.type)</span>
<span class="line-added">+                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same type&quot;)));</span>
<span class="line-added">+                 if (globalValue-&gt;global()-&gt;mutability() != global.mutability)</span>
<span class="line-added">+                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;imported global&quot;, &quot;must be a same mutability&quot;)));</span>
<span class="line-added">+                 m_instance-&gt;linkGlobal(vm, import.kindIndex, globalValue);</span>
              }
              scope.assertNoException();
              break;
          }
  
          case Wasm::ExternalKind::Table: {
              // 7. Otherwise (i is a table import):
              JSWebAssemblyTable* table = jsDynamicCast&lt;JSWebAssemblyTable*&gt;(vm, value);
              // i. If v is not a WebAssembly.Table object, throw a WebAssembly.LinkError.
              if (!table)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;is not an instance of WebAssembly.Table&quot;)));</span>
  
              uint32_t expectedInitial = moduleInformation.tables[import.kindIndex].initial();
              uint32_t actualInitial = table-&gt;length();
              if (actualInitial &lt; expectedInitial)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided an &#39;initial&#39; that is too small&quot;)));</span>
  
              if (Optional&lt;uint32_t&gt; expectedMaximum = moduleInformation.tables[import.kindIndex].maximum()) {
                  Optional&lt;uint32_t&gt; actualMaximum = table-&gt;maximum();
                  if (!actualMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;does not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
                  if (*actualMaximum &gt; *expectedMaximum)
<span class="line-modified">!                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Imported Table&quot;, &quot;&#39;maximum&#39; is larger than the module&#39;s expected &#39;maximum&#39;&quot;)));</span>
              }
  
              auto expectedType = moduleInformation.tables[import.kindIndex].type();
              auto actualType = table-&gt;table()-&gt;type();
              if (expectedType != actualType)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Table import&quot;, &quot;provided a &#39;type&#39; that is wrong&quot;)));</span>
  
              // ii. Append v to tables.
              // iii. Append v.[[Table]] to imports.
              m_instance-&gt;setTable(vm, import.kindIndex, table);
              RETURN_IF_EXCEPTION(scope, void());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,12 ***</span>
          if (!m_instance-&gt;table(i)) {
              RELEASE_ASSERT(!moduleInformation.tables[i].isImport());
              // We create a Table when it&#39;s a Table definition.
              RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());
              if (!wasmTable)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(exec, vm, &quot;couldn&#39;t create Table&quot;));</span>
<span class="line-modified">!             JSWebAssemblyTable* table = JSWebAssemblyTable::create(exec, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
              // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
              // If it&#39;s defined to be too large, we should have thrown a validation error.
              scope.assertNoException();
              ASSERT(table);
              m_instance-&gt;setTable(vm, i, table);
<span class="line-new-header">--- 347,12 ---</span>
          if (!m_instance-&gt;table(i)) {
              RELEASE_ASSERT(!moduleInformation.tables[i].isImport());
              // We create a Table when it&#39;s a Table definition.
              RefPtr&lt;Wasm::Table&gt; wasmTable = Wasm::Table::tryCreate(moduleInformation.tables[i].initial(), moduleInformation.tables[i].maximum(), moduleInformation.tables[i].type());
              if (!wasmTable)
<span class="line-modified">!                 return exception(createJSWebAssemblyLinkError(globalObject, vm, &quot;couldn&#39;t create Table&quot;));</span>
<span class="line-modified">!             JSWebAssemblyTable* table = JSWebAssemblyTable::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyTableStructure(), wasmTable.releaseNonNull());</span>
              // We should always be able to allocate a JSWebAssemblyTable we&#39;ve defined.
              // If it&#39;s defined to be too large, we should have thrown a validation error.
              scope.assertNoException();
              ASSERT(table);
              m_instance-&gt;setTable(vm, i, table);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,20 ***</span>
  
      // Globals
      {
          for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
              const auto&amp; global = moduleInformation.globals[globalIndex];
<span class="line-modified">!             ASSERT(global.initializationType != Wasm::Global::IsImport);</span>
<span class="line-modified">!             if (global.initializationType == Wasm::Global::FromGlobalImport) {</span>
                  ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(globalIndex, m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber));</span>
<span class="line-modified">!             } else if (global.initializationType == Wasm::Global::FromRefFunc) {</span>
                  ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());
                  ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(globalIndex, JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber)));</span>
              } else
<span class="line-modified">!                 m_instance-&gt;instance().setGlobal(globalIndex, global.initialBitsOrImportNumber);</span>
          }
      }
  
      SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
  
<span class="line-new-header">--- 403,37 ---</span>
  
      // Globals
      {
          for (size_t globalIndex = moduleInformation.firstInternalGlobal; globalIndex &lt; moduleInformation.globals.size(); ++globalIndex) {
              const auto&amp; global = moduleInformation.globals[globalIndex];
<span class="line-modified">!             ASSERT(global.initializationType != Wasm::GlobalInformation::IsImport);</span>
<span class="line-modified">!             uint64_t initialBits = 0;</span>
<span class="line-added">+             if (global.initializationType == Wasm::GlobalInformation::FromGlobalImport) {</span>
                  ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.firstInternalGlobal);
<span class="line-modified">!                 initialBits = m_instance-&gt;instance().loadI64Global(global.initialBitsOrImportNumber);</span>
<span class="line-modified">!             } else if (global.initializationType == Wasm::GlobalInformation::FromRefFunc) {</span>
                  ASSERT(global.initialBitsOrImportNumber &lt; moduleInformation.functionIndexSpaceSize());
                  ASSERT(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber).isFunction(vm));
<span class="line-modified">!                 initialBits = JSValue::encode(makeFunctionWrapper(&quot;Global init expr&quot;, global.initialBitsOrImportNumber));</span>
              } else
<span class="line-modified">!                 initialBits = global.initialBitsOrImportNumber;</span>
<span class="line-added">+ </span>
<span class="line-added">+             switch (global.bindingMode) {</span>
<span class="line-added">+             case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance: {</span>
<span class="line-added">+                 m_instance-&gt;instance().setGlobal(globalIndex, initialBits);</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             case Wasm::GlobalInformation::BindingMode::Portable: {</span>
<span class="line-added">+                 ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+                 Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, Wasm::GlobalInformation::Mutability::Mutable, initialBits);</span>
<span class="line-added">+                 JSWebAssemblyGlobal* globalValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">+                 scope.assertNoException();</span>
<span class="line-added">+                 m_instance-&gt;linkGlobal(vm, globalIndex, globalValue);</span>
<span class="line-added">+                 keepAlive(bitwise_cast&lt;void*&gt;(initialBits)); // Ensure this is kept alive while creating JSWebAssemblyGlobal.</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             }</span>
          }
      }
  
      SymbolTable* exportSymbolTable = module-&gt;exportSymbolTable();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,47 ***</span>
  
              exportedValue = m_instance-&gt;memory();
              break;
          }
          case Wasm::ExternalKind::Global: {
<span class="line-modified">!             // Assert: the global is immutable by MVP validation constraint.</span>
<span class="line-removed">-             const Wasm::Global&amp; global = moduleInformation.globals[exp.kindIndex];</span>
<span class="line-removed">-             ASSERT(global.mutability == Wasm::Global::Immutable);</span>
<span class="line-removed">-             // Return ToJSValue(v).</span>
              switch (global.type) {
              case Wasm::Anyref:
              case Wasm::Funcref:
<span class="line-removed">-                 exportedValue = JSValue::decode(m_instance-&gt;instance().loadI64Global(exp.kindIndex));</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">- </span>
              case Wasm::I32:
<span class="line-removed">-                 exportedValue = JSValue(m_instance-&gt;instance().loadI32Global(exp.kindIndex));</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">- </span>
              case Wasm::I64:
<span class="line-removed">-                 throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;exported global cannot be an i64&quot;_s));</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">- </span>
              case Wasm::F32:
<span class="line-modified">!                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF32Global(exp.kindIndex)));</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!             case Wasm::F64:</span>
<span class="line-modified">!                 exportedValue = jsNumber(purifyNaN(m_instance-&gt;instance().loadF64Global(exp.kindIndex)));</span>
                  break;
<span class="line-modified">! </span>
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              break;
          }
          }
  
          bool shouldThrowReadOnlyError = false;
          bool ignoreReadOnlyErrors = true;
          bool putResult = false;
<span class="line-modified">!         symbolTablePutTouchWatchpointSet(moduleEnvironment, exec, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
          scope.assertNoException();
          RELEASE_ASSERT(putResult);
      }
  
      bool hasStart = !!moduleInformation.startFunctionIndexSpace;
<span class="line-new-header">--- 459,48 ---</span>
  
              exportedValue = m_instance-&gt;memory();
              break;
          }
          case Wasm::ExternalKind::Global: {
<span class="line-modified">!             const Wasm::GlobalInformation&amp; global = moduleInformation.globals[exp.kindIndex];</span>
              switch (global.type) {
              case Wasm::Anyref:
              case Wasm::Funcref:
              case Wasm::I32:
              case Wasm::I64:
              case Wasm::F32:
<span class="line-modified">!             case Wasm::F64: {</span>
<span class="line-modified">!                 // If global is immutable, we are not creating a binding internally.</span>
<span class="line-modified">!                 // But we need to create a binding just to export it. This binding is not actually connected. But this is OK since it is immutable.</span>
<span class="line-modified">!                 if (global.bindingMode == Wasm::GlobalInformation::BindingMode::EmbeddedInInstance) {</span>
<span class="line-modified">!                     uint64_t initialValue = m_instance-&gt;instance().loadI64Global(exp.kindIndex);</span>
<span class="line-added">+                     Ref&lt;Wasm::Global&gt; globalRef = Wasm::Global::create(global.type, global.mutability, initialValue);</span>
<span class="line-added">+                     exportedValue = JSWebAssemblyGlobal::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyGlobalStructure(), WTFMove(globalRef));</span>
<span class="line-added">+                     scope.assertNoException();</span>
<span class="line-added">+                 } else {</span>
<span class="line-added">+                     ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+                     RefPtr&lt;Wasm::Global&gt; globalRef = m_instance-&gt;instance().getGlobalBinding(exp.kindIndex);</span>
<span class="line-added">+                     ASSERT(globalRef);</span>
<span class="line-added">+                     ASSERT(globalRef-&gt;type() == global.type);</span>
<span class="line-added">+                     ASSERT(globalRef-&gt;mutability() == global.mutability);</span>
<span class="line-added">+                     ASSERT(globalRef-&gt;mutability() == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+                     ASSERT(globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;());</span>
<span class="line-added">+                     exportedValue = globalRef-&gt;owner&lt;JSWebAssemblyGlobal&gt;();</span>
<span class="line-added">+                 }</span>
                  break;
<span class="line-modified">!             }</span>
              default:
                  RELEASE_ASSERT_NOT_REACHED();
              }
              break;
          }
          }
  
          bool shouldThrowReadOnlyError = false;
          bool ignoreReadOnlyErrors = true;
          bool putResult = false;
<span class="line-modified">!         symbolTablePutTouchWatchpointSet(moduleEnvironment, globalObject, Identifier::fromString(vm, String::fromUTF8(exp.field)), exportedValue, shouldThrowReadOnlyError, ignoreReadOnlyErrors, putResult);</span>
          scope.assertNoException();
          RELEASE_ASSERT(putResult);
      }
  
      bool hasStart = !!moduleInformation.startFunctionIndexSpace;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,11 ***</span>
          auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
          Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
          const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
          // The start function must not take any arguments or return anything. This is enforced by the parser.
          ASSERT(!signature.argumentCount());
<span class="line-modified">!         ASSERT(signature.returnType() == Wasm::Void);</span>
          if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
              JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
              m_startFunction.set(vm, this, startFunction);
          } else {
              Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
<span class="line-new-header">--- 508,11 ---</span>
          auto startFunctionIndexSpace = moduleInformation.startFunctionIndexSpace.valueOr(0);
          Wasm::SignatureIndex signatureIndex = module-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndexSpace);
          const Wasm::Signature&amp; signature = Wasm::SignatureInformation::get(signatureIndex);
          // The start function must not take any arguments or return anything. This is enforced by the parser.
          ASSERT(!signature.argumentCount());
<span class="line-modified">!         ASSERT(signature.returnsVoid());</span>
          if (startFunctionIndexSpace &lt; codeBlock-&gt;functionImportCount()) {
              JSObject* startFunction = m_instance-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(startFunctionIndexSpace)-&gt;get();
              m_startFunction.set(vm, this, startFunction);
          } else {
              Wasm::Callee&amp; embedderEntrypointCallee = codeBlock-&gt;embedderEntrypointCalleeFromFunctionIndexSpace(startFunctionIndexSpace);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 466,18 ***</span>
      }
      m_moduleEnvironment.set(vm, this, moduleEnvironment);
  }
  
  template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
<span class="line-modified">! NEVER_INLINE static JSValue dataSegmentFail(ExecState* exec, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)</span>
  {
<span class="line-modified">!     return throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));</span>
  }
  
<span class="line-modified">! JSValue WebAssemblyModuleRecord::evaluate(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Wasm::Module&amp; module = m_instance-&gt;instance().module();
      Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
      const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
<span class="line-new-header">--- 523,18 ---</span>
      }
      m_moduleEnvironment.set(vm, this, moduleEnvironment);
  }
  
  template &lt;typename Scope, typename M, typename N, typename ...Args&gt;
<span class="line-modified">! NEVER_INLINE static JSValue dataSegmentFail(JSGlobalObject* globalObject, VM&amp; vm, Scope&amp; scope, M memorySize, N segmentSize, N offset, Args... args)</span>
  {
<span class="line-modified">!     return throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, makeString(&quot;Invalid data segment initialization: segment of &quot;_s, String::number(segmentSize), &quot; bytes memory of &quot;_s, String::number(memorySize), &quot; bytes, at offset &quot;_s, String::number(offset), args...)));</span>
  }
  
<span class="line-modified">! JSValue WebAssemblyModuleRecord::evaluate(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Wasm::Module&amp; module = m_instance-&gt;instance().module();
      Wasm::CodeBlock* codeBlock = m_instance-&gt;instance().codeBlock();
      const Wasm::ModuleInformation&amp; moduleInformation = module.moduleInformation();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 526,28 ***</span>
  
      // Validation of all element ranges comes before all Table and Memory initialization.
      forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
          uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;
          if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))
<span class="line-modified">!             exception = JSValue(throwException(exec, scope, createJSWebAssemblyLinkError(exec, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));</span>
      });
  
      if (UNLIKELY(exception))
          return exception.value();
  
      // Validation of all segment ranges comes before all Table and Memory initialization.
      forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
          if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
<span class="line-modified">!             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);</span>
          else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
<span class="line-modified">!             exception = dataSegmentFail(exec, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);</span>
      });
  
      if (UNLIKELY(exception))
          return exception.value();
  
<span class="line-removed">-     JSGlobalObject* globalObject = m_instance-&gt;globalObject(vm);</span>
      forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
          for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
              // FIXME: This essentially means we&#39;re exporting an import.
              // We need a story here. We need to create a WebAssemblyFunction
              // for the import.
<span class="line-new-header">--- 583,27 ---</span>
  
      // Validation of all element ranges comes before all Table and Memory initialization.
      forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
          uint64_t lastWrittenIndex = static_cast&lt;uint64_t&gt;(elementIndex) + static_cast&lt;uint64_t&gt;(element.functionIndices.size()) - 1;
          if (UNLIKELY(lastWrittenIndex &gt;= m_instance-&gt;table(tableIndex)-&gt;length()))
<span class="line-modified">!             exception = JSValue(throwException(globalObject, scope, createJSWebAssemblyLinkError(globalObject, vm, &quot;Element is trying to set an out of bounds table index&quot;_s)));</span>
      });
  
      if (UNLIKELY(exception))
          return exception.value();
  
      // Validation of all segment ranges comes before all Table and Memory initialization.
      forEachSegment([&amp;] (uint8_t*, uint64_t sizeInBytes, const Wasm::Segment::Ptr&amp; segment, uint32_t offset) {
          if (UNLIKELY(sizeInBytes &lt; segment-&gt;sizeInBytes))
<span class="line-modified">!             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment is too big&quot;_s);</span>
          else if (UNLIKELY(offset &gt; sizeInBytes - segment-&gt;sizeInBytes))
<span class="line-modified">!             exception = dataSegmentFail(globalObject, vm, scope, sizeInBytes, segment-&gt;sizeInBytes, offset, &quot;, segment writes outside of memory&quot;_s);</span>
      });
  
      if (UNLIKELY(exception))
          return exception.value();
  
      forEachElement([&amp;] (const Wasm::Element&amp; element, uint32_t tableIndex, uint32_t elementIndex) {
          for (uint32_t i = 0; i &lt; element.functionIndices.size(); ++i) {
              // FIXME: This essentially means we&#39;re exporting an import.
              // We need a story here. We need to create a WebAssemblyFunction
              // for the import.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 601,11 ***</span>
      ASSERT(!exception);
  
      if (JSObject* startFunction = m_startFunction.get()) {
          CallData callData;
          CallType callType = JSC::getCallData(vm, startFunction, callData);
<span class="line-modified">!         call(exec, startFunction, callType, callData, jsUndefined(), *vm.emptyList);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      return jsUndefined();
  }
<span class="line-new-header">--- 657,11 ---</span>
      ASSERT(!exception);
  
      if (JSObject* startFunction = m_startFunction.get()) {
          CallData callData;
          CallType callType = JSC::getCallData(vm, startFunction, callData);
<span class="line-modified">!         call(globalObject, startFunction, callType, callData, jsUndefined(), *vm.emptyList);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      return jsUndefined();
  }
</pre>
<center><a href="WebAssemblyModulePrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebAssemblyModuleRecord.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  #include &quot;Error.h&quot;
  #include &quot;GetterSetter.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JSArrayInlines.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSCBuiltins.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSStringJoiner.h&quot;
  #include &quot;Lookup.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,21 ***</span>
  #include &lt;algorithm&gt;
  #include &lt;wtf/Assertions.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState*);</span>
  
  // ------------------------------ ArrayPrototype ----------------------------
  
  const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  
<span class="line-new-header">--- 47,23 ---</span>
  #include &lt;algorithm&gt;
  #include &lt;wtf/Assertions.h&gt;
  
  namespace JSC {
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncKeys(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncEntries(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);</span>
  
  // ------------------------------ ArrayPrototype ----------------------------
  
  const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,23 ***</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified">!     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  
<span class="line-modified">!     JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());</span>
      unscopables-&gt;convertToDictionary(vm);
      const Identifier* const unscopableNames[] = {
          &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),
          &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),
          &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),
<span class="line-new-header">--- 112,23 ---</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified">!     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayProtoFuncKeys, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayKeysIntrinsic);</span>
<span class="line-modified">!     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayProtoFuncEntries, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayEntriesIntrinsic);</span>
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
  
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  
<span class="line-modified">!     JSObject* unscopables = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
      unscopables-&gt;convertToDictionary(vm);
      const Identifier* const unscopableNames[] = {
          &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),
          &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),
          &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,65 ***</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
  }
  
  // ------------------------------ Array Functions ----------------------------
  
<span class="line-modified">! static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (JSValue result = object-&gt;tryGetIndexQuickly(index))
          return result;
      // We want to perform get and has in the same operation.
      // We can only do so when this behavior is not observable. The
      // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
      // somewhere in the prototype chain.
      PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified">!     bool hasProperty = object-&gt;getPropertySlot(exec, index, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (!hasProperty)
          return { };
      if (UNLIKELY(slot.isTaintedByOpaqueObject()))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, object-&gt;get(exec, index));</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, slot.getValue(exec, index));</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool putLength(ExecState* exec, VM&amp; vm, JSObject* obj, JSValue value)</span>
  {
      PutPropertySlot slot(obj);
<span class="line-modified">!     return obj-&gt;methodTable(vm)-&gt;put(obj, exec, vm.propertyNames-&gt;length, value, slot);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE void setLength(ExecState* exec, VM&amp; vm, JSObject* obj, unsigned value)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     static const bool throwException = true;</span>
      if (isJSArray(obj)) {
<span class="line-modified">!         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(exec, value, throwException);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
<span class="line-modified">!     bool success = putLength(exec, vm, obj, jsNumber(value));</span>
<span class="line-modified">!     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-removed">-     if (UNLIKELY(!success))</span>
<span class="line-removed">-         throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
  }
  
  namespace ArrayPrototypeInternal {
  static bool verbose = false;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
      ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
  
      if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {
          dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));
<span class="line-modified">!         globalObject-&gt;tryInstallArraySpeciesWatchpoint(exec);</span>
          ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);
      }
  
      return !thisObject-&gt;hasCustomProperties(vm)
          &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
<span class="line-new-header">--- 145,66 ---</span>
      putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
  }
  
  // ------------------------------ Array Functions ----------------------------
  
<span class="line-modified">! static ALWAYS_INLINE JSValue getProperty(JSGlobalObject* globalObject, JSObject* object, unsigned index)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (JSValue result = object-&gt;tryGetIndexQuickly(index))
          return result;
      // We want to perform get and has in the same operation.
      // We can only do so when this behavior is not observable. The
      // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
      // somewhere in the prototype chain.
      PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified">!     bool hasProperty = object-&gt;getPropertySlot(globalObject, index, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (!hasProperty)
          return { };
      if (UNLIKELY(slot.isTaintedByOpaqueObject()))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, object-&gt;get(globalObject, index));</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, index));</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE void putLength(JSGlobalObject* globalObject, VM&amp; vm, JSObject* obj, JSValue value)</span>
  {
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
      PutPropertySlot slot(obj);
<span class="line-modified">!     bool success = obj-&gt;methodTable(vm)-&gt;put(obj, globalObject, vm.propertyNames-&gt;length, value, slot);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+     if (UNLIKELY(!success))</span>
<span class="line-added">+         throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE void setLength(JSGlobalObject* globalObject, VM&amp; vm, JSObject* obj, unsigned value)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     static constexpr bool throwException = true;</span>
      if (isJSArray(obj)) {
<span class="line-modified">!         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(globalObject, value, throwException);</span>
          RETURN_IF_EXCEPTION(scope, void());
      }
<span class="line-modified">!     scope.release();</span>
<span class="line-modified">!     putLength(globalObject, vm, obj, jsNumber(value));</span>
  }
  
  namespace ArrayPrototypeInternal {
  static bool verbose = false;
  }
  
<span class="line-modified">! ALWAYS_INLINE bool speciesWatchpointIsValid(VM&amp; vm, JSObject* thisObject)</span>
  {
      JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
      ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
  
      if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {
          dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));
<span class="line-modified">!         globalObject-&gt;tryInstallArraySpeciesWatchpoint();</span>
          ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);
      }
  
      return !thisObject-&gt;hasCustomProperties(vm)
          &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,42 ***</span>
      FastPath,
      Exception,
      CreatedObject
  };
  
<span class="line-modified">! static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, uint64_t length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto exceptionResult = [] () {
          return std::make_pair(SpeciesConstructResult::Exception, nullptr);
      };
  
      // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
      JSValue constructor = jsUndefined();
<span class="line-modified">!     bool thisIsArray = isArray(exec, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, exceptionResult());
      if (LIKELY(thisIsArray)) {
          // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
          // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
<span class="line-modified">!         bool isValid = speciesWatchpointIsValid(exec, thisObject);</span>
          scope.assertNoException();
          if (LIKELY(isValid))
              return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
  
<span class="line-modified">!         constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);</span>
          RETURN_IF_EXCEPTION(scope, exceptionResult());
          if (constructor.isConstructor(vm)) {
              JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified">!             bool isArrayConstructorFromAnotherRealm = exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm)</span>
                  &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);
              if (isArrayConstructorFromAnotherRealm)
                  return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
          }
          if (constructor.isObject()) {
<span class="line-modified">!             constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);</span>
              RETURN_IF_EXCEPTION(scope, exceptionResult());
              if (constructor.isNull())
                  return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
          }
      } else {
<span class="line-new-header">--- 215,42 ---</span>
      FastPath,
      Exception,
      CreatedObject
  };
  
<span class="line-modified">! static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(JSGlobalObject* globalObject, JSObject* thisObject, uint64_t length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto exceptionResult = [] () {
          return std::make_pair(SpeciesConstructResult::Exception, nullptr);
      };
  
      // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
      JSValue constructor = jsUndefined();
<span class="line-modified">!     bool thisIsArray = isArray(globalObject, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, exceptionResult());
      if (LIKELY(thisIsArray)) {
          // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
          // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
<span class="line-modified">!         bool isValid = speciesWatchpointIsValid(vm, thisObject);</span>
          scope.assertNoException();
          if (LIKELY(isValid))
              return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
  
<span class="line-modified">!         constructor = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;constructor);</span>
          RETURN_IF_EXCEPTION(scope, exceptionResult());
          if (constructor.isConstructor(vm)) {
              JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified">!             bool isArrayConstructorFromAnotherRealm = globalObject != constructorObject-&gt;globalObject(vm)</span>
                  &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);
              if (isArrayConstructorFromAnotherRealm)
                  return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
          }
          if (constructor.isObject()) {
<span class="line-modified">!             constructor = constructor.get(globalObject, vm.propertyNames-&gt;speciesSymbol);</span>
              RETURN_IF_EXCEPTION(scope, exceptionResult());
              if (constructor.isNull())
                  return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
          }
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,44 ***</span>
          return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
  
      MarkedArgumentBuffer args;
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, exceptionResult());
      return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     uint64_t length = static_cast&lt;uint64_t&gt;(exec-&gt;uncheckedArgument(1).asNumber());</span>
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, object, length);</span>
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
          return { };
      if (speciesResult.first == SpeciesConstructResult::CreatedObject)
          return JSValue::encode(speciesResult.second);
  
      if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified">!         throwRangeError(exec, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
  }
  
<span class="line-modified">! static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)</span>
  {
<span class="line-removed">-     JSValue value = exec-&gt;argument(argument);</span>
      if (value.isUndefined())
          return undefinedValue;
  
<span class="line-modified">!     double indexDouble = value.toInteger(exec);</span>
      if (indexDouble &lt; 0) {
          indexDouble += length;
          return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
      }
      return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
<span class="line-new-header">--- 262,43 ---</span>
          return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
  
      MarkedArgumentBuffer args;
      args.append(jsNumber(length));
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     JSObject* newObject = construct(globalObject, constructor, args, &quot;Species construction did not get a valid constructor&quot;);</span>
      RETURN_IF_EXCEPTION(scope, exceptionResult());
      return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* object = asObject(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     uint64_t length = static_cast&lt;uint64_t&gt;(callFrame-&gt;uncheckedArgument(1).asNumber());</span>
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, object, length);</span>
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
          return { };
      if (speciesResult.first == SpeciesConstructResult::CreatedObject)
          return JSValue::encode(speciesResult.second);
  
      if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified">!         throwRangeError(globalObject, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
          return { };
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(globalObject, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
  }
  
<span class="line-modified">! static inline unsigned argumentClampedIndexFromStartOrEnd(JSGlobalObject* globalObject, JSValue value, unsigned length, unsigned undefinedValue = 0)</span>
  {
      if (value.isUndefined())
          return undefinedValue;
  
<span class="line-modified">!     double indexDouble = value.toInteger(globalObject);</span>
      if (indexDouble &lt; 0) {
          indexDouble += length;
          return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
      }
      return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,95 ***</span>
  // currentCount) will be shifted to the left or right as appropriate; in the
  // case of shift this must be removing values, in the case of unshift this
  // must be introducing new values.
  
  template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified">! void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT(currentCount &gt; resultCount);
      unsigned count = currentCount - resultCount;
  
      RELEASE_ASSERT(header &lt;= length);
      RELEASE_ASSERT(currentCount &lt;= (length - header));
  
      if (isJSArray(thisObj)) {
          JSArray* array = asArray(thisObj);
<span class="line-modified">!         if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(exec, header, count))</span>
              return;
      }
  
      for (unsigned k = header; k &lt; length - currentCount; ++k) {
          unsigned from = k + currentCount;
          unsigned to = k + resultCount;
<span class="line-modified">!         JSValue value = getProperty(exec, thisObj, from);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (value) {
<span class="line-modified">!             thisObj-&gt;putByIndexInline(exec, to, value, true);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (!success) {
<span class="line-modified">!                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
                  return;
              }
          }
      }
      for (unsigned k = length; k &gt; length - count; --k) {
<span class="line-modified">!         bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, k - 1);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (!success) {
<span class="line-modified">!             throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
              return;
          }
      }
  }
  
  template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified">! void unshift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT(resultCount &gt; currentCount);
      unsigned count = resultCount - currentCount;
  
      RELEASE_ASSERT(header &lt;= length);
      RELEASE_ASSERT(currentCount &lt;= (length - header));
  
      // Guard against overflow.
      if (count &gt; UINT_MAX - length) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return;
      }
  
      if (isJSArray(thisObj)) {
          JSArray* array = asArray(thisObj);
          if (array-&gt;length() == length) {
<span class="line-modified">!             bool handled = array-&gt;unshiftCount&lt;shiftCountMode&gt;(exec, header, count);</span>
              EXCEPTION_ASSERT(!scope.exception() || handled);
              if (handled)
                  return;
          }
      }
  
      for (unsigned k = length - currentCount; k &gt; header; --k) {
          unsigned from = k + currentCount - 1;
          unsigned to = k + resultCount - 1;
<span class="line-modified">!         JSValue value = getProperty(exec, thisObj, from);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (value) {
<span class="line-modified">!             thisObj-&gt;putByIndexInline(exec, to, value, true);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
                  return;
              }
          }
      }
  }
<span class="line-new-header">--- 318,95 ---</span>
  // currentCount) will be shifted to the left or right as appropriate; in the
  // case of shift this must be removing values, in the case of unshift this
  // must be introducing new values.
  
  template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified">! void shift(JSGlobalObject* globalObject, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT(currentCount &gt; resultCount);
      unsigned count = currentCount - resultCount;
  
      RELEASE_ASSERT(header &lt;= length);
      RELEASE_ASSERT(currentCount &lt;= (length - header));
  
      if (isJSArray(thisObj)) {
          JSArray* array = asArray(thisObj);
<span class="line-modified">!         if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(globalObject, header, count))</span>
              return;
      }
  
      for (unsigned k = header; k &lt; length - currentCount; ++k) {
          unsigned from = k + currentCount;
          unsigned to = k + resultCount;
<span class="line-modified">!         JSValue value = getProperty(globalObject, thisObj, from);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (value) {
<span class="line-modified">!             thisObj-&gt;putByIndexInline(globalObject, to, value, true);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, to);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (!success) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
                  return;
              }
          }
      }
      for (unsigned k = length; k &gt; length - count; --k) {
<span class="line-modified">!         bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, k - 1);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (!success) {
<span class="line-modified">!             throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
              return;
          }
      }
  }
  
  template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified">! void unshift(JSGlobalObject* globalObject, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      RELEASE_ASSERT(resultCount &gt; currentCount);
      unsigned count = resultCount - currentCount;
  
      RELEASE_ASSERT(header &lt;= length);
      RELEASE_ASSERT(currentCount &lt;= (length - header));
  
      // Guard against overflow.
      if (count &gt; UINT_MAX - length) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return;
      }
  
      if (isJSArray(thisObj)) {
          JSArray* array = asArray(thisObj);
          if (array-&gt;length() == length) {
<span class="line-modified">!             bool handled = array-&gt;unshiftCount&lt;shiftCountMode&gt;(globalObject, header, count);</span>
              EXCEPTION_ASSERT(!scope.exception() || handled);
              if (handled)
                  return;
          }
      }
  
      for (unsigned k = length - currentCount; k &gt; header; --k) {
          unsigned from = k + currentCount - 1;
          unsigned to = k + resultCount - 1;
<span class="line-modified">!         JSValue value = getProperty(globalObject, thisObj, from);</span>
          RETURN_IF_EXCEPTION(scope, void());
          if (value) {
<span class="line-modified">!             thisObj-&gt;putByIndexInline(globalObject, to, value, true);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
<span class="line-modified">!             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, to);</span>
              RETURN_IF_EXCEPTION(scope, void());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
                  return;
              }
          }
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,21 ***</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! inline JSValue fastJoin(ExecState&amp; state, JSObject* thisObject, StringView separator, unsigned length, bool* sawHoles = nullptr)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (thisObject-&gt;indexingType()) {
      case ALL_INT32_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(state, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguous().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              JSValue value = data[i].get();
<span class="line-new-header">--- 448,21 ---</span>
              return true;
      }
      return false;
  }
  
<span class="line-modified">! inline JSValue fastJoin(JSGlobalObject* globalObject, JSObject* thisObject, StringView separator, unsigned length, bool* sawHoles = nullptr)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      switch (thisObject-&gt;indexingType()) {
      case ALL_INT32_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(globalObject, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguous().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              JSValue value = data[i].get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,24 ***</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
      }
      case ALL_CONTIGUOUS_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(state, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguous().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              if (JSValue value = data[i].get()) {
<span class="line-modified">!                 if (!joiner.appendWithoutSideEffects(state, value))</span>
                      goto generalCase;
              } else {
                  if (sawHoles)
                      *sawHoles = true;
                  if (!holesKnownToBeOK) {
                      if (holesMustForwardToPrototype(vm, thisObject))
<span class="line-new-header">--- 477,25 ---</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
      }
      case ALL_CONTIGUOUS_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(globalObject, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguous().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              if (JSValue value = data[i].get()) {
<span class="line-modified">!                 if (!joiner.appendWithoutSideEffects(globalObject, value))</span>
                      goto generalCase;
<span class="line-added">+                 RETURN_IF_EXCEPTION(scope, { });</span>
              } else {
                  if (sawHoles)
                      *sawHoles = true;
                  if (!holesKnownToBeOK) {
                      if (holesMustForwardToPrototype(vm, thisObject))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,17 ***</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
      }
      case ALL_DOUBLE_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(state, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguousDouble().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              double value = data[i];
<span class="line-new-header">--- 503,17 ---</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
      }
      case ALL_DOUBLE_INDEXING_TYPES: {
          auto&amp; butterfly = *thisObject-&gt;butterfly();
          if (UNLIKELY(length &gt; butterfly.publicLength()))
              break;
<span class="line-modified">!         JSStringJoiner joiner(globalObject, separator, length);</span>
          RETURN_IF_EXCEPTION(scope, { });
          auto data = butterfly.contiguousDouble().data();
          bool holesKnownToBeOK = false;
          for (unsigned i = 0; i &lt; length; ++i) {
              double value = data[i];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 524,11 ***</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
      }
      case ALL_UNDECIDED_INDEXING_TYPES: {
          if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
              goto generalCase;
          switch (separator.length()) {
<span class="line-new-header">--- 528,11 ---</span>
                      holesKnownToBeOK = true;
                  }
                  joiner.appendEmptyString();
              }
          }
<span class="line-modified">!         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
      }
      case ALL_UNDECIDED_INDEXING_TYPES: {
          if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
              goto generalCase;
          switch (separator.length()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,46 ***</span>
              RELEASE_AND_RETURN(scope, jsEmptyString(vm));
          case 1: {
              if (length &lt;= 1)
                  RELEASE_AND_RETURN(scope, jsEmptyString(vm));
              if (separator.is8Bit())
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));</span>
<span class="line-modified">!             RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));</span>
          default:
              JSString* result = jsEmptyString(vm);
              if (length &lt;= 1)
                  return result;
  
              JSString* operand = jsString(vm, separator.toString());
              RETURN_IF_EXCEPTION(scope, { });
              unsigned count = length - 1;
              for (;;) {
                  if (count &amp; 1) {
<span class="line-modified">!                     result = jsString(&amp;state, result, operand);</span>
                      RETURN_IF_EXCEPTION(scope, { });
                  }
                  count &gt;&gt;= 1;
                  if (!count)
                      return result;
<span class="line-modified">!                 operand = jsString(&amp;state, operand, operand);</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
          }
          }
      }
      }
  
  generalCase:
<span class="line-modified">!     JSStringJoiner joiner(state, separator, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         JSValue element = thisObject-&gt;getIndex(&amp;state, i);</span>
          RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!         joiner.append(state, element);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, joiner.join(state));</span>
  }
  
  inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)
  {
      JSGlobalObject* globalObject = thisObject-&gt;globalObject();
<span class="line-new-header">--- 540,46 ---</span>
              RELEASE_AND_RETURN(scope, jsEmptyString(vm));
          case 1: {
              if (length &lt;= 1)
                  RELEASE_AND_RETURN(scope, jsEmptyString(vm));
              if (separator.is8Bit())
<span class="line-modified">!                 RELEASE_AND_RETURN(scope, repeatCharacter(globalObject, separator.characters8()[0], length - 1));</span>
<span class="line-modified">!             RELEASE_AND_RETURN(scope, repeatCharacter(globalObject, separator.characters16()[0], length - 1));</span>
          default:
              JSString* result = jsEmptyString(vm);
              if (length &lt;= 1)
                  return result;
  
              JSString* operand = jsString(vm, separator.toString());
              RETURN_IF_EXCEPTION(scope, { });
              unsigned count = length - 1;
              for (;;) {
                  if (count &amp; 1) {
<span class="line-modified">!                     result = jsString(globalObject, result, operand);</span>
                      RETURN_IF_EXCEPTION(scope, { });
                  }
                  count &gt;&gt;= 1;
                  if (!count)
                      return result;
<span class="line-modified">!                 operand = jsString(globalObject, operand, operand);</span>
                  RETURN_IF_EXCEPTION(scope, { });
              }
          }
          }
      }
      }
  
  generalCase:
<span class="line-modified">!     JSStringJoiner joiner(globalObject, separator, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         JSValue element = thisObject-&gt;getIndex(globalObject, i);</span>
          RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!         joiner.append(globalObject, element);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
<span class="line-modified">!     RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
  }
  
  inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)
  {
      JSGlobalObject* globalObject = thisObject-&gt;globalObject();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,23 ***</span>
      // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,
      // it would be possible that just looking into &quot;join&quot; function will show the same performance.
      return globalObject-&gt;isOriginalArrayStructure(structure);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
  
      // 1. Let array be the result of calling ToObject on the this value.
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {
          // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.
<span class="line-modified">!         JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).
          bool customJoinCase = false;
          if (!function.isCell())
<span class="line-new-header">--- 593,23 ---</span>
      // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,
      // it would be possible that just looking into &quot;join&quot; function will show the same performance.
      return globalObject-&gt;isOriginalArrayStructure(structure);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
  
      // 1. Let array be the result of calling ToObject on the this value.
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {
          // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.
<span class="line-modified">!         JSValue function = JSValue(thisObject).get(globalObject, vm.propertyNames-&gt;join);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
          // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).
          bool customJoinCase = false;
          if (!function.isCell())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 614,23 ***</span>
          CallType callType = getCallData(vm, function, callData);
          if (callType == CallType::None)
              customJoinCase = true;
  
          if (UNLIKELY(customJoinCase))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
  
          // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
          if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>
      }
  
      ASSERT(isJSArray(thisValue));
      JSArray* thisArray = asArray(thisValue);
  
      unsigned length = thisArray-&gt;length();
  
<span class="line-modified">!     StringRecursionChecker checker(exec, thisArray);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
      if (LIKELY(canUseFastJoin(thisArray))) {
<span class="line-new-header">--- 618,23 ---</span>
          CallType callType = getCallData(vm, function, callData);
          if (callType == CallType::None)
              customJoinCase = true;
  
          if (UNLIKELY(customJoinCase))
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(globalObject, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
  
          // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
          if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, function, callType, callData, thisObject, *vm.emptyList)));</span>
      }
  
      ASSERT(isJSArray(thisValue));
      JSArray* thisArray = asArray(thisValue);
  
      unsigned length = thisArray-&gt;length();
  
<span class="line-modified">!     StringRecursionChecker checker(globalObject, thisArray);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
      if (LIKELY(canUseFastJoin(thisArray))) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 645,274 ***</span>
              if (iter != vm.heap.immutableButterflyToStringCache.end())
                  return JSValue::encode(iter-&gt;value);
          }
  
          bool sawHoles = false;
<span class="line-modified">!         JSValue result = fastJoin(*exec, thisArray, { &amp;comma, 1 }, length, &amp;sawHoles);</span>
  
          if (!sawHoles &amp;&amp; result &amp;&amp; isJSString(result) &amp;&amp; isCoW) {
              ASSERT(JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly()) == immutableButterfly);
              vm.heap.immutableButterflyToStringCache.add(immutableButterfly, jsCast&lt;JSString*&gt;(result));
          }
  
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     JSStringJoiner joiner(*exec, &#39;,&#39;, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      for (unsigned i = 0; i &lt; length; ++i) {
          JSValue element = thisArray-&gt;tryGetIndexQuickly(i);
          if (!element) {
<span class="line-modified">!             element = thisArray-&gt;get(exec, i);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
<span class="line-modified">!         joiner.append(*exec, element);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(*exec)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
  
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     unsigned length = toLength(exec, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     StringRecursionChecker checker(exec, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
<span class="line-modified">!     JSStringJoiner stringJoiner(*exec, &#39;,&#39;, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
  #if ENABLE(INTL)
<span class="line-modified">!     ArgList arguments(exec);</span>
  #endif
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         JSValue element = thisObject-&gt;getIndex(exec, i);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (element.isUndefinedOrNull())
              element = jsEmptyString(vm);
          else {
<span class="line-modified">!             JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              CallData callData;
              CallType callType = getCallData(vm, conversionFunction, callData);
              if (callType != CallType::None) {
  #if ENABLE(INTL)
<span class="line-modified">!                 element = call(exec, conversionFunction, callType, callData, element, arguments);</span>
  #else
<span class="line-modified">!                 element = call(exec, conversionFunction, callType, callData, element, *vm.emptyList);</span>
  #endif
                  RETURN_IF_EXCEPTION(scope, encodedJSValue());
              }
          }
<span class="line-modified">!         stringJoiner.append(*exec, element);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(*exec)));</span>
  }
  
<span class="line-modified">! static JSValue slowJoin(ExecState&amp; exec, JSObject* thisObject, JSString* separator, uint64_t length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 5. If len is zero, return the empty String.
      if (!length)
          return jsEmptyString(vm);
  
      // 6. Let element0 be Get(O, &quot;0&quot;).
<span class="line-modified">!     JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
      JSString* r = nullptr;
      if (element0.isUndefinedOrNull())
          r = jsEmptyString(vm);
      else
<span class="line-modified">!         r = element0.toString(&amp;exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 8. Let k be 1.
      // 9. Repeat, while k &lt; len
      // 9.e Increase k by 1..
      for (uint64_t k = 1; k &lt; length; ++k) {
          // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified">!         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(vm, AtomString::number(k)));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
          JSString* next = nullptr;
          if (element.isUndefinedOrNull()) {
              if (!separator-&gt;length())
                  continue;
              next = jsEmptyString(vm);
          } else
<span class="line-modified">!             next = element.toString(&amp;exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // a. Let S be the String value produced by concatenating R and sep.
          // d. Let R be a String value produced by concatenating S and next.
<span class="line-modified">!         r = jsString(&amp;exec, r, separator, next);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      // 10. Return R.
      return r;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let O be ? ToObject(this value).
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
<span class="line-modified">!     StringRecursionChecker checker(exec, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
      // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
<span class="line-modified">!     double length = toLength(exec, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
<span class="line-modified">!     JSValue separatorValue = exec-&gt;argument(0);</span>
      if (separatorValue.isUndefined()) {
          const LChar comma = &#39;,&#39;;
  
          if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
              uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
              ASSERT(static_cast&lt;double&gt;(length64) == length);
              JSString* jsSeparator = jsSingleCharacterString(vm, comma);
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));</span>
          }
  
          unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
          ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, { &amp;comma, 1 }, unsignedLength)));</span>
      }
  
      // 4. Let sep be ? ToString(separator).
<span class="line-modified">!     JSString* jsSeparator = separatorValue.toString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
          uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
          ASSERT(static_cast&lt;double&gt;(length64) == length);
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));</span>
      }
  
<span class="line-modified">!     auto viewWithString = jsSeparator-&gt;viewWithUnderlyingString(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, viewWithString.view, length)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
  
      if (isJSArray(thisValue))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(asArray(thisValue)-&gt;pop(exec)));</span>
  
<span class="line-modified">!     JSObject* thisObj = thisValue.toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (length == 0) {
          scope.release();
<span class="line-modified">!         putLength(exec, vm, thisObj, jsNumber(length));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue result = thisObj-&gt;get(exec, length - 1);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, length - 1);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
          return encodedJSValue();
      }
      scope.release();
<span class="line-modified">!     putLength(exec, vm, thisObj, jsNumber(length - 1));</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
  
<span class="line-modified">!     if (LIKELY(isJSArray(thisValue) &amp;&amp; exec-&gt;argumentCount() == 1)) {</span>
          JSArray* array = asArray(thisValue);
          scope.release();
<span class="line-modified">!         array-&gt;pushInline(exec, exec-&gt;uncheckedArgument(0));</span>
          return JSValue::encode(jsNumber(array-&gt;length()));
      }
  
<span class="line-modified">!     JSObject* thisObj = thisValue.toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     for (unsigned n = 0; n &lt; exec-&gt;argumentCount(); n++) {</span>
          // Check for integer overflow; where safe we can do a fast put by index.
          if (length + n &gt;= length)
<span class="line-modified">!             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);</span>
          else {
              PutPropertySlot slot(thisObj);
<span class="line-modified">!             Identifier propertyName = Identifier::fromString(vm, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
<span class="line-modified">!             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);</span>
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(exec-&gt;argumentCount()));</span>
      scope.release();
<span class="line-modified">!     putLength(exec, vm, thisObj, newLength);</span>
      return JSValue::encode(newLength);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
<span class="line-modified">!     unsigned length = toLength(exec, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      thisObject-&gt;ensureWritable(vm);
  
      switch (thisObject-&gt;indexingType()) {
<span class="line-new-header">--- 649,305 ---</span>
              if (iter != vm.heap.immutableButterflyToStringCache.end())
                  return JSValue::encode(iter-&gt;value);
          }
  
          bool sawHoles = false;
<span class="line-modified">!         JSValue result = fastJoin(globalObject, thisArray, { &amp;comma, 1 }, length, &amp;sawHoles);</span>
  
          if (!sawHoles &amp;&amp; result &amp;&amp; isJSString(result) &amp;&amp; isCoW) {
              ASSERT(JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly()) == immutableButterfly);
              vm.heap.immutableButterflyToStringCache.add(immutableButterfly, jsCast&lt;JSString*&gt;(result));
          }
  
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     JSStringJoiner joiner(globalObject, &#39;,&#39;, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      for (unsigned i = 0; i &lt; length; ++i) {
          JSValue element = thisArray-&gt;tryGetIndexQuickly(i);
          if (!element) {
<span class="line-modified">!             element = thisArray-&gt;get(globalObject, i);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
<span class="line-modified">!         joiner.append(globalObject, element);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(globalObject)));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
  
<span class="line-modified">!     JSObject* thisObject = thisValue.toObject(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     StringRecursionChecker checker(globalObject, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
<span class="line-modified">!     JSStringJoiner stringJoiner(globalObject, &#39;,&#39;, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
  #if ENABLE(INTL)
<span class="line-modified">!     ArgList arguments(callFrame);</span>
  #endif
      for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!         JSValue element = thisObject-&gt;getIndex(globalObject, i);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (element.isUndefinedOrNull())
              element = jsEmptyString(vm);
          else {
<span class="line-modified">!             JSValue conversionFunction = element.get(globalObject, vm.propertyNames-&gt;toLocaleString);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              CallData callData;
              CallType callType = getCallData(vm, conversionFunction, callData);
              if (callType != CallType::None) {
  #if ENABLE(INTL)
<span class="line-modified">!                 element = call(globalObject, conversionFunction, callType, callData, element, arguments);</span>
  #else
<span class="line-modified">!                 element = call(globalObject, conversionFunction, callType, callData, element, *vm.emptyList);</span>
  #endif
                  RETURN_IF_EXCEPTION(scope, encodedJSValue());
              }
          }
<span class="line-modified">!         stringJoiner.append(globalObject, element);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(globalObject)));</span>
  }
  
<span class="line-modified">! static JSValue slowJoin(JSGlobalObject* globalObject, JSObject* thisObject, JSString* separator, uint64_t length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 5. If len is zero, return the empty String.
      if (!length)
          return jsEmptyString(vm);
  
      // 6. Let element0 be Get(O, &quot;0&quot;).
<span class="line-modified">!     JSValue element0 = thisObject-&gt;getIndex(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
      JSString* r = nullptr;
      if (element0.isUndefinedOrNull())
          r = jsEmptyString(vm);
      else
<span class="line-modified">!         r = element0.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      // 8. Let k be 1.
      // 9. Repeat, while k &lt; len
      // 9.e Increase k by 1..
      for (uint64_t k = 1; k &lt; length; ++k) {
          // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified">!         JSValue element = thisObject-&gt;get(globalObject, Identifier::fromString(vm, AtomString::number(k)));</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
          JSString* next = nullptr;
          if (element.isUndefinedOrNull()) {
              if (!separator-&gt;length())
                  continue;
              next = jsEmptyString(vm);
          } else
<span class="line-modified">!             next = element.toString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
  
          // a. Let S be the String value produced by concatenating R and sep.
          // d. Let R be a String value produced by concatenating S and next.
<span class="line-modified">!         r = jsString(globalObject, r, separator, next);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
      // 10. Return R.
      return r;
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. Let O be ? ToObject(this value).
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
<span class="line-modified">!     StringRecursionChecker checker(globalObject, thisObject);</span>
      EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
      if (JSValue earlyReturnValue = checker.earlyReturnValue())
          return JSValue::encode(earlyReturnValue);
  
      // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
<span class="line-modified">!     double length = toLength(globalObject, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
<span class="line-modified">!     JSValue separatorValue = callFrame-&gt;argument(0);</span>
      if (separatorValue.isUndefined()) {
          const LChar comma = &#39;,&#39;;
  
          if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
              uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
              ASSERT(static_cast&lt;double&gt;(length64) == length);
              JSString* jsSeparator = jsSingleCharacterString(vm, comma);
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(globalObject, thisObject, jsSeparator, length64)));</span>
          }
  
          unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
          ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(globalObject, thisObject, { &amp;comma, 1 }, unsignedLength)));</span>
      }
  
      // 4. Let sep be ? ToString(separator).
<span class="line-modified">!     JSString* jsSeparator = separatorValue.toString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
          uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
          ASSERT(static_cast&lt;double&gt;(length64) == length);
  
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(globalObject, thisObject, jsSeparator, length64)));</span>
      }
  
<span class="line-modified">!     auto viewWithString = jsSeparator-&gt;viewWithUnderlyingString(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(globalObject, thisObject, viewWithString.view, length)));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline EncodedJSValue createArrayIteratorObject(JSGlobalObject* globalObject, CallFrame* callFrame, IterationKind kind)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* thisObject  = callFrame-&gt;thisValue().toObject(globalObject);</span>
<span class="line-added">+     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);</span>
<span class="line-added">+     UNUSED_PARAM(scope);</span>
<span class="line-added">+     if (UNLIKELY(!thisObject))</span>
<span class="line-added">+         return encodedJSValue();</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(JSArrayIterator::create(vm, globalObject-&gt;arrayIteratorStructure(), thisObject, jsNumber(static_cast&lt;unsigned&gt;(kind))));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncValues(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Values);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncEntries(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Entries);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Keys);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
  
      if (isJSArray(thisValue))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, JSValue::encode(asArray(thisValue)-&gt;pop(globalObject)));</span>
  
<span class="line-modified">!     JSObject* thisObj = thisValue.toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (length == 0) {
          scope.release();
<span class="line-modified">!         putLength(globalObject, vm, thisObj, jsNumber(length));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue result = thisObj-&gt;get(globalObject, length - 1);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, length - 1);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (UNLIKELY(!success)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
          return encodedJSValue();
      }
      scope.release();
<span class="line-modified">!     putLength(globalObject, vm, thisObj, jsNumber(length - 1));</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
  
<span class="line-modified">!     if (LIKELY(isJSArray(thisValue) &amp;&amp; callFrame-&gt;argumentCount() == 1)) {</span>
          JSArray* array = asArray(thisValue);
          scope.release();
<span class="line-modified">!         array-&gt;pushInline(globalObject, callFrame-&gt;uncheckedArgument(0));</span>
          return JSValue::encode(jsNumber(array-&gt;length()));
      }
  
<span class="line-modified">!     JSObject* thisObj = thisValue.toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     for (unsigned n = 0; n &lt; callFrame-&gt;argumentCount(); n++) {</span>
          // Check for integer overflow; where safe we can do a fast put by index.
          if (length + n &gt;= length)
<span class="line-modified">!             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, globalObject, length + n, callFrame-&gt;uncheckedArgument(n), true);</span>
          else {
              PutPropertySlot slot(thisObj);
<span class="line-modified">!             auto string = JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(globalObject);</span>
<span class="line-modified">!             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added">+             Identifier propertyName = Identifier::fromString(vm, string);</span>
<span class="line-added">+             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, globalObject, propertyName, callFrame-&gt;uncheckedArgument(n), slot);</span>
          }
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
<span class="line-modified">!     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(callFrame-&gt;argumentCount()));</span>
      scope.release();
<span class="line-modified">!     putLength(globalObject, vm, thisObj, newLength);</span>
      return JSValue::encode(newLength);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return encodedJSValue();
  
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      thisObject-&gt;ensureWritable(vm);
  
      switch (thisObject-&gt;indexingType()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 953,270 ***</span>
      }
  
      unsigned middle = length / 2;
      for (unsigned lower = 0; lower &lt; middle; lower++) {
          unsigned upper = length - lower - 1;
<span class="line-modified">!         bool lowerExists = thisObject-&gt;hasProperty(exec, lower);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          JSValue lowerValue;
          if (lowerExists) {
<span class="line-modified">!             lowerValue = thisObject-&gt;get(exec, lower);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
<span class="line-modified">!         bool upperExists = thisObject-&gt;hasProperty(exec, upper);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          JSValue upperValue;
          if (upperExists) {
<span class="line-modified">!             upperValue = thisObject-&gt;get(exec, upper);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
          if (upperExists) {
<span class="line-modified">!             thisObject-&gt;putByIndexInline(exec, lower, upperValue, true);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } else {
<span class="line-modified">!             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, lower);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
                  return encodedJSValue();
              }
          }
  
          if (lowerExists) {
<span class="line-modified">!             thisObject-&gt;putByIndexInline(exec, upper, lowerValue, true);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } else {
<span class="line-modified">!             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, upper);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
                  return encodedJSValue();
              }
          }
      }
      return JSValue::encode(thisObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (length == 0) {
          scope.release();
<span class="line-modified">!         putLength(exec, vm, thisObj, jsNumber(length));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue result = thisObj-&gt;getIndex(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     shift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 1, 0, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     putLength(exec, vm, thisObj, jsNumber(length - 1));</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)</span>
  {
      // https://tc39.github.io/ecma262/#sec-array.prototype.slice
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return { };
<span class="line-modified">!     unsigned length = toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (end &lt; begin)
          end = begin;
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin);</span>
      // We can only get an exception if we call some user function.
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
          return { };
  
<span class="line-modified">!     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (LIKELY(okToDoFastPath)) {
<span class="line-modified">!         if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))</span>
              return JSValue::encode(result);
      }
  
      JSObject* result;
      if (speciesResult.first == SpeciesConstructResult::CreatedObject)
          result = speciesResult.second;
      else {
<span class="line-modified">!         result = constructEmptyArray(exec, nullptr, end - begin);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      // Document that we need to keep the source array alive until after anything
      // that can GC (e.g. allocating the result array).
      thisObj-&gt;use();
  
      unsigned n = 0;
      for (unsigned k = begin; k &lt; end; k++, n++) {
<span class="line-modified">!         JSValue v = getProperty(exec, thisObj, k);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (v) {
<span class="line-modified">!             result-&gt;putDirectIndex(exec, n, v, 0, PutDirectIndexShouldThrow);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
      }
      scope.release();
<span class="line-modified">!     setLength(exec, vm, result, n);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)</span>
  {
      // 15.4.4.12
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     if (!exec-&gt;argumentCount()) {</span>
<span class="line-modified">!         std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, 0);</span>
          EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
          if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
              return encodedJSValue();
  
          JSObject* result;
          if (speciesResult.first == SpeciesConstructResult::CreatedObject)
              result = speciesResult.second;
          else {
<span class="line-modified">!             result = constructEmptyArray(exec, nullptr);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
<span class="line-modified">!         setLength(exec, vm, result, 0);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          scope.release();
<span class="line-modified">!         setLength(exec, vm, thisObj, length);</span>
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned actualDeleteCount = length - actualStart;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">!         double deleteCount = exec-&gt;uncheckedArgument(1).toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (deleteCount &lt; 0)
              actualDeleteCount = 0;
          else if (deleteCount &gt; length - actualStart)
              actualDeleteCount = length - actualStart;
          else
              actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
      }
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, actualDeleteCount);</span>
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (speciesResult.first == SpeciesConstructResult::Exception)
          return JSValue::encode(jsUndefined());
  
      JSObject* result = nullptr;
<span class="line-modified">!     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (LIKELY(okToDoFastPath))
<span class="line-modified">!         result = asArray(thisObj)-&gt;fastSlice(*exec, actualStart, actualDeleteCount);</span>
  
      if (!result) {
          if (speciesResult.first == SpeciesConstructResult::CreatedObject)
              result = speciesResult.second;
          else {
<span class="line-modified">!             result = JSArray::tryCreate(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), actualDeleteCount);</span>
              if (UNLIKELY(!result)) {
<span class="line-modified">!                 throwOutOfMemoryError(exec, scope);</span>
                  return encodedJSValue();
              }
          }
          for (unsigned k = 0; k &lt; actualDeleteCount; ++k) {
<span class="line-modified">!             JSValue v = getProperty(exec, thisObj, k + actualStart);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!v))
                  continue;
<span class="line-modified">!             result-&gt;putDirectIndex(exec, k, v, 0, PutDirectIndexShouldThrow);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
      }
  
<span class="line-modified">!     unsigned itemCount = std::max&lt;int&gt;(exec-&gt;argumentCount() - 2, 0);</span>
      if (itemCount &lt; actualDeleteCount) {
<span class="line-modified">!         shift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      } else if (itemCount &gt; actualDeleteCount) {
<span class="line-modified">!         unshift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      for (unsigned k = 0; k &lt; itemCount; ++k) {
<span class="line-modified">!         thisObj-&gt;putByIndexInline(exec, k + actualStart, exec-&gt;uncheckedArgument(k + 2), true);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      scope.release();
<span class="line-modified">!     setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      // 15.4.4.13
  
<span class="line-modified">!     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     double doubleLength = toLength(exec, thisObj);</span>
      unsigned length = doubleLength;
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     unsigned nrArgs = exec-&gt;argumentCount();</span>
      if (nrArgs) {
          if (UNLIKELY(doubleLength + static_cast&lt;double&gt;(nrArgs) &gt; maxSafeInteger()))
<span class="line-modified">!             return throwVMTypeError(exec, scope, &quot;Cannot shift to offset greater than (2 ** 53) - 1&quot;_s);</span>
<span class="line-modified">!         unshift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 0, nrArgs, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      for (unsigned k = 0; k &lt; nrArgs; ++k) {
<span class="line-modified">!         thisObj-&gt;putByIndexInline(exec, k, exec-&gt;uncheckedArgument(k), true);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      JSValue result = jsNumber(length + nrArgs);
      scope.release();
<span class="line-modified">!     putLength(exec, vm, thisObj, result);</span>
      return JSValue::encode(result);
  }
  
  enum class IndexOfDirection { Forward, Backward };
  template&lt;IndexOfDirection direction&gt;
<span class="line-modified">! ALWAYS_INLINE JSValue fastIndexOf(ExecState* exec, VM&amp; vm, JSArray* array, unsigned length, JSValue searchElement, unsigned index)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      bool canDoFastPath = array-&gt;canDoFastIndexedAccess(vm)
          &amp;&amp; array-&gt;getArrayLength() == length; // The effects in getting `index` could have changed the length of this array.
<span class="line-new-header">--- 988,270 ---</span>
      }
  
      unsigned middle = length / 2;
      for (unsigned lower = 0; lower &lt; middle; lower++) {
          unsigned upper = length - lower - 1;
<span class="line-modified">!         bool lowerExists = thisObject-&gt;hasProperty(globalObject, lower);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          JSValue lowerValue;
          if (lowerExists) {
<span class="line-modified">!             lowerValue = thisObject-&gt;get(globalObject, lower);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
<span class="line-modified">!         bool upperExists = thisObject-&gt;hasProperty(globalObject, upper);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          JSValue upperValue;
          if (upperExists) {
<span class="line-modified">!             upperValue = thisObject-&gt;get(globalObject, upper);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
          if (upperExists) {
<span class="line-modified">!             thisObject-&gt;putByIndexInline(globalObject, lower, upperValue, true);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } else {
<span class="line-modified">!             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, lower);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
                  return encodedJSValue();
              }
          }
  
          if (lowerExists) {
<span class="line-modified">!             thisObject-&gt;putByIndexInline(globalObject, upper, lowerValue, true);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          } else {
<span class="line-modified">!             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, upper);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!success)) {
<span class="line-modified">!                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
                  return encodedJSValue();
              }
          }
      }
      return JSValue::encode(thisObject);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      if (length == 0) {
          scope.release();
<span class="line-modified">!         putLength(globalObject, vm, thisObj, jsNumber(length));</span>
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     JSValue result = thisObj-&gt;getIndex(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">!     shift&lt;JSArray::ShiftCountForShift&gt;(globalObject, thisObj, 0, 1, 0, length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     putLength(globalObject, vm, thisObj, jsNumber(length - 1));</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // https://tc39.github.io/ecma262/#sec-array.prototype.slice
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return { };
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (end &lt; begin)
          end = begin;
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, end - begin);</span>
      // We can only get an exception if we call some user function.
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
          return { };
  
<span class="line-modified">!     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, { });
      if (LIKELY(okToDoFastPath)) {
<span class="line-modified">!         if (JSArray* result = asArray(thisObj)-&gt;fastSlice(globalObject, begin, end - begin))</span>
              return JSValue::encode(result);
      }
  
      JSObject* result;
      if (speciesResult.first == SpeciesConstructResult::CreatedObject)
          result = speciesResult.second;
      else {
<span class="line-modified">!         result = constructEmptyArray(globalObject, nullptr, end - begin);</span>
          RETURN_IF_EXCEPTION(scope, { });
      }
  
      // Document that we need to keep the source array alive until after anything
      // that can GC (e.g. allocating the result array).
      thisObj-&gt;use();
  
      unsigned n = 0;
      for (unsigned k = begin; k &lt; end; k++, n++) {
<span class="line-modified">!         JSValue v = getProperty(globalObject, thisObj, k);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (v) {
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, n, v, 0, PutDirectIndexShouldThrow);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
      }
      scope.release();
<span class="line-modified">!     setLength(globalObject, vm, result, n);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
      // 15.4.4.12
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     if (!callFrame-&gt;argumentCount()) {</span>
<span class="line-modified">!         std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, 0);</span>
          EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
          if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
              return encodedJSValue();
  
          JSObject* result;
          if (speciesResult.first == SpeciesConstructResult::CreatedObject)
              result = speciesResult.second;
          else {
<span class="line-modified">!             result = constructEmptyArray(globalObject, nullptr);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
  
<span class="line-modified">!         setLength(globalObject, vm, result, 0);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          scope.release();
<span class="line-modified">!         setLength(globalObject, vm, thisObj, length);</span>
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     unsigned actualStart = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      unsigned actualDeleteCount = length - actualStart;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">!         double deleteCount = callFrame-&gt;uncheckedArgument(1).toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (deleteCount &lt; 0)
              actualDeleteCount = 0;
          else if (deleteCount &gt; length - actualStart)
              actualDeleteCount = length - actualStart;
          else
              actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
      }
  
<span class="line-modified">!     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, actualDeleteCount);</span>
      EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
      if (speciesResult.first == SpeciesConstructResult::Exception)
          return JSValue::encode(jsUndefined());
  
      JSObject* result = nullptr;
<span class="line-modified">!     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(globalObject, thisObj);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      if (LIKELY(okToDoFastPath))
<span class="line-modified">!         result = asArray(thisObj)-&gt;fastSlice(globalObject, actualStart, actualDeleteCount);</span>
  
      if (!result) {
          if (speciesResult.first == SpeciesConstructResult::CreatedObject)
              result = speciesResult.second;
          else {
<span class="line-modified">!             result = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), actualDeleteCount);</span>
              if (UNLIKELY(!result)) {
<span class="line-modified">!                 throwOutOfMemoryError(globalObject, scope);</span>
                  return encodedJSValue();
              }
          }
          for (unsigned k = 0; k &lt; actualDeleteCount; ++k) {
<span class="line-modified">!             JSValue v = getProperty(globalObject, thisObj, k + actualStart);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
              if (UNLIKELY(!v))
                  continue;
<span class="line-modified">!             result-&gt;putDirectIndex(globalObject, k, v, 0, PutDirectIndexShouldThrow);</span>
              RETURN_IF_EXCEPTION(scope, encodedJSValue());
          }
      }
  
<span class="line-modified">!     unsigned itemCount = std::max&lt;int&gt;(callFrame-&gt;argumentCount() - 2, 0);</span>
      if (itemCount &lt; actualDeleteCount) {
<span class="line-modified">!         shift&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      } else if (itemCount &gt; actualDeleteCount) {
<span class="line-modified">!         unshift&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      for (unsigned k = 0; k &lt; itemCount; ++k) {
<span class="line-modified">!         thisObj-&gt;putByIndexInline(globalObject, k + actualStart, callFrame-&gt;uncheckedArgument(k + 2), true);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
  
      scope.release();
<span class="line-modified">!     setLength(globalObject, vm, thisObj, length - actualDeleteCount + itemCount);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      // 15.4.4.13
  
<span class="line-modified">!     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
      if (UNLIKELY(!thisObj))
          return encodedJSValue();
<span class="line-modified">!     double doubleLength = toLength(globalObject, thisObj);</span>
      unsigned length = doubleLength;
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     unsigned nrArgs = callFrame-&gt;argumentCount();</span>
      if (nrArgs) {
          if (UNLIKELY(doubleLength + static_cast&lt;double&gt;(nrArgs) &gt; maxSafeInteger()))
<span class="line-modified">!             return throwVMTypeError(globalObject, scope, &quot;Cannot shift to offset greater than (2 ** 53) - 1&quot;_s);</span>
<span class="line-modified">!         unshift&lt;JSArray::ShiftCountForShift&gt;(globalObject, thisObj, 0, 0, nrArgs, length);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      for (unsigned k = 0; k &lt; nrArgs; ++k) {
<span class="line-modified">!         thisObj-&gt;putByIndexInline(globalObject, k, callFrame-&gt;uncheckedArgument(k), true);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
      }
      JSValue result = jsNumber(length + nrArgs);
      scope.release();
<span class="line-modified">!     putLength(globalObject, vm, thisObj, result);</span>
      return JSValue::encode(result);
  }
  
  enum class IndexOfDirection { Forward, Backward };
  template&lt;IndexOfDirection direction&gt;
<span class="line-modified">! ALWAYS_INLINE JSValue fastIndexOf(JSGlobalObject* globalObject, VM&amp; vm, JSArray* array, unsigned length, JSValue searchElement, unsigned index)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      bool canDoFastPath = array-&gt;canDoFastIndexedAccess(vm)
          &amp;&amp; array-&gt;getArrayLength() == length; // The effects in getting `index` could have changed the length of this array.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1263,22 ***</span>
          if (direction == IndexOfDirection::Forward) {
              for (; index &lt; length; ++index) {
                  JSValue value = data[index].get();
                  if (!value)
                      continue;
<span class="line-modified">!                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  if (isEqual)
                      return jsNumber(index);
              }
          } else {
              do {
                  ASSERT(index &lt; length);
                  JSValue value = data[index].get();
                  if (!value)
                      continue;
<span class="line-modified">!                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  if (isEqual)
                      return jsNumber(index);
              } while (index--);
          }
<span class="line-new-header">--- 1298,22 ---</span>
          if (direction == IndexOfDirection::Forward) {
              for (; index &lt; length; ++index) {
                  JSValue value = data[index].get();
                  if (!value)
                      continue;
<span class="line-modified">!                 bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  if (isEqual)
                      return jsNumber(index);
              }
          } else {
              do {
                  ASSERT(index &lt; length);
                  JSValue value = data[index].get();
                  if (!value)
                      continue;
<span class="line-modified">!                 bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
                  RETURN_IF_EXCEPTION(scope, { });
                  if (isEqual)
                      return jsNumber(index);
              } while (index--);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1311,126 ***</span>
      default:
          return JSValue();
      }
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 15.4.4.14
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return { };
<span class="line-modified">!     unsigned length = toLength(exec, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     JSValue searchElement = exec-&gt;argument(0);</span>
  
      if (isJSArray(thisObject)) {
<span class="line-modified">!         JSValue result = fastIndexOf&lt;IndexOfDirection::Forward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (result)
              return JSValue::encode(result);
      }
  
      for (; index &lt; length; ++index) {
<span class="line-modified">!         JSValue e = getProperty(exec, thisObject, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!e)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(exec, searchElement, e);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return JSValue::encode(jsNumber(index));
      }
  
      return JSValue::encode(jsNumber(-1));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 15.4.4.15
<span class="line-modified">!     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return { };
<span class="line-modified">!     unsigned length = toLength(exec, thisObject);</span>
      if (UNLIKELY(scope.exception()) || !length)
          return JSValue::encode(jsNumber(-1));
  
      unsigned index = length - 1;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         JSValue fromValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!         double fromDouble = fromValue.toInteger(exec);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (fromDouble &lt; 0) {
              fromDouble += length;
              if (fromDouble &lt; 0)
                  return JSValue::encode(jsNumber(-1));
          }
          if (fromDouble &lt; length)
              index = static_cast&lt;unsigned&gt;(fromDouble);
      }
  
<span class="line-modified">!     JSValue searchElement = exec-&gt;argument(0);</span>
  
      if (isJSArray(thisObject)) {
<span class="line-modified">!         JSValue result = fastIndexOf&lt;IndexOfDirection::Backward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (result)
              return JSValue::encode(result);
      }
  
      do {
          ASSERT(index &lt; length);
<span class="line-modified">!         JSValue e = getProperty(exec, thisObject, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!e)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(exec, searchElement, e);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return JSValue::encode(jsNumber(index));
      } while (index--);
  
      return JSValue::encode(jsNumber(-1));
  }
  
<span class="line-modified">! static bool moveElements(ExecState* exec, VM&amp; vm, JSArray* target, unsigned targetOffset, JSArray* source, unsigned sourceLength)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (LIKELY(!hasAnyArrayStorage(source-&gt;indexingType()) &amp;&amp; !holesMustForwardToPrototype(vm, source))) {
          for (unsigned i = 0; i &lt; sourceLength; ++i) {
              JSValue value = source-&gt;tryGetIndexQuickly(i);
              if (value) {
<span class="line-modified">!                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
                  RETURN_IF_EXCEPTION(scope, false);
              }
          }
      } else {
          for (unsigned i = 0; i &lt; sourceLength; ++i) {
<span class="line-modified">!             JSValue value = getProperty(exec, source, i);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (value) {
<span class="line-modified">!                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
                  RETURN_IF_EXCEPTION(scope, false);
              }
          }
      }
      return true;
  }
  
<span class="line-modified">! static EncodedJSValue concatAppendOne(ExecState* exec, VM&amp; vm, JSArray* first, JSValue second)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!isJSArray(second));
      ASSERT(!shouldUseSlowPut(first-&gt;indexingType()));
<span class="line-new-header">--- 1346,126 ---</span>
      default:
          return JSValue();
      }
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 15.4.4.14
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return { };
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
<span class="line-modified">!     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     JSValue searchElement = callFrame-&gt;argument(0);</span>
  
      if (isJSArray(thisObject)) {
<span class="line-modified">!         JSValue result = fastIndexOf&lt;IndexOfDirection::Forward&gt;(globalObject, vm, asArray(thisObject), length, searchElement, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (result)
              return JSValue::encode(result);
      }
  
      for (; index &lt; length; ++index) {
<span class="line-modified">!         JSValue e = getProperty(globalObject, thisObject, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!e)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(globalObject, searchElement, e);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return JSValue::encode(jsNumber(index));
      }
  
      return JSValue::encode(jsNumber(-1));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 15.4.4.15
<span class="line-modified">!     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
      if (UNLIKELY(!thisObject))
          return { };
<span class="line-modified">!     unsigned length = toLength(globalObject, thisObject);</span>
      if (UNLIKELY(scope.exception()) || !length)
          return JSValue::encode(jsNumber(-1));
  
      unsigned index = length - 1;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">!         JSValue fromValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">!         double fromDouble = fromValue.toInteger(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (fromDouble &lt; 0) {
              fromDouble += length;
              if (fromDouble &lt; 0)
                  return JSValue::encode(jsNumber(-1));
          }
          if (fromDouble &lt; length)
              index = static_cast&lt;unsigned&gt;(fromDouble);
      }
  
<span class="line-modified">!     JSValue searchElement = callFrame-&gt;argument(0);</span>
  
      if (isJSArray(thisObject)) {
<span class="line-modified">!         JSValue result = fastIndexOf&lt;IndexOfDirection::Backward&gt;(globalObject, vm, asArray(thisObject), length, searchElement, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (result)
              return JSValue::encode(result);
      }
  
      do {
          ASSERT(index &lt; length);
<span class="line-modified">!         JSValue e = getProperty(globalObject, thisObject, index);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (!e)
              continue;
<span class="line-modified">!         bool isEqual = JSValue::strictEqual(globalObject, searchElement, e);</span>
          RETURN_IF_EXCEPTION(scope, { });
          if (isEqual)
              return JSValue::encode(jsNumber(index));
      } while (index--);
  
      return JSValue::encode(jsNumber(-1));
  }
  
<span class="line-modified">! static bool moveElements(JSGlobalObject* globalObject, VM&amp; vm, JSArray* target, unsigned targetOffset, JSArray* source, unsigned sourceLength)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (LIKELY(!hasAnyArrayStorage(source-&gt;indexingType()) &amp;&amp; !holesMustForwardToPrototype(vm, source))) {
          for (unsigned i = 0; i &lt; sourceLength; ++i) {
              JSValue value = source-&gt;tryGetIndexQuickly(i);
              if (value) {
<span class="line-modified">!                 target-&gt;putDirectIndex(globalObject, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
                  RETURN_IF_EXCEPTION(scope, false);
              }
          }
      } else {
          for (unsigned i = 0; i &lt; sourceLength; ++i) {
<span class="line-modified">!             JSValue value = getProperty(globalObject, source, i);</span>
              RETURN_IF_EXCEPTION(scope, false);
              if (value) {
<span class="line-modified">!                 target-&gt;putDirectIndex(globalObject, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
                  RETURN_IF_EXCEPTION(scope, false);
              }
          }
      }
      return true;
  }
  
<span class="line-modified">! static EncodedJSValue concatAppendOne(JSGlobalObject* globalObject, VM&amp; vm, JSArray* first, JSValue second)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      ASSERT(!isJSArray(second));
      ASSERT(!shouldUseSlowPut(first-&gt;indexingType()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1438,40 ***</span>
      unsigned firstArraySize = firstButterfly-&gt;publicLength();
  
      Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
      checkedResultSize += 1;
      if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      unsigned resultSize = checkedResultSize.unsafeGet();
      IndexingType type = first-&gt;mergeIndexingTypeForCopying(indexingTypeForValue(second) | IsArray);
  
      if (type == NonArray)
          type = first-&gt;indexingType();
  
<span class="line-modified">!     Structure* resultStructure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
      JSArray* result = JSArray::tryCreate(vm, resultStructure, resultSize);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
<span class="line-modified">!     bool success = result-&gt;appendMemcpy(exec, vm, 0, first);</span>
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (!success) {
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         bool success = moveElements(exec, vm, result, 0, first, firstArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
      }
  
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(exec, firstArraySize, second);</span>
      return JSValue::encode(result);
  
  }
  
  template&lt;typename T&gt;
<span class="line-new-header">--- 1473,40 ---</span>
      unsigned firstArraySize = firstButterfly-&gt;publicLength();
  
      Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
      checkedResultSize += 1;
      if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      unsigned resultSize = checkedResultSize.unsafeGet();
      IndexingType type = first-&gt;mergeIndexingTypeForCopying(indexingTypeForValue(second) | IsArray);
  
      if (type == NonArray)
          type = first-&gt;indexingType();
  
<span class="line-modified">!     Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
      JSArray* result = JSArray::tryCreate(vm, resultStructure, resultSize);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
<span class="line-modified">!     bool success = result-&gt;appendMemcpy(globalObject, vm, 0, first);</span>
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (!success) {
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         bool success = moveElements(globalObject, vm, result, 0, first, firstArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
      }
  
      scope.release();
<span class="line-modified">!     result-&gt;putDirectIndex(globalObject, firstArraySize, second);</span>
      return JSValue::encode(result);
  
  }
  
  template&lt;typename T&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1485,44 ***</span>
  {
      element = PNaN;
  }
  
  template&lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE void copyElements(T* buffer, unsigned offset, void* source, unsigned sourceSize, IndexingType sourceType)</span>
  {
      if (sourceType != ArrayWithUndecided) {
<span class="line-modified">!         memcpy(buffer + offset, source, sizeof(JSValue) * sourceSize);</span>
          return;
      }
  
      for (unsigned i = sourceSize; i--;)
          clearElement&lt;T&gt;(buffer[i + offset]);
  };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncConcatMemcpy(ExecState* exec)</span>
  {
<span class="line-modified">!     ASSERT(exec-&gt;argumentCount() == 2);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSArray* firstArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));</span>
  
      // This code assumes that neither array has set Symbol.isConcatSpreadable. If the first array
      // has indexed accessors then one of those accessors might change the value of Symbol.isConcatSpreadable
      // on the second argument.
      if (UNLIKELY(shouldUseSlowPut(firstArray-&gt;indexingType())))
          return JSValue::encode(jsNull());
  
      // We need to check the species constructor here since checking it in the JS wrapper is too expensive for the non-optimizing tiers.
<span class="line-modified">!     bool isValid = speciesWatchpointIsValid(exec, firstArray);</span>
      scope.assertNoException();
      if (UNLIKELY(!isValid))
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     JSValue second = exec-&gt;uncheckedArgument(1);</span>
      if (!isJSArray(second))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, concatAppendOne(exec, vm, firstArray, second));</span>
  
      JSArray* secondArray = jsCast&lt;JSArray*&gt;(second);
  
      Butterfly* firstButterfly = firstArray-&gt;butterfly();
      Butterfly* secondButterfly = secondArray-&gt;butterfly();
<span class="line-new-header">--- 1520,44 ---</span>
  {
      element = PNaN;
  }
  
  template&lt;typename T&gt;
<span class="line-modified">! ALWAYS_INLINE void copyElements(T* buffer, unsigned offset, T* source, unsigned sourceSize, IndexingType sourceType)</span>
  {
      if (sourceType != ArrayWithUndecided) {
<span class="line-modified">!         gcSafeMemcpy(buffer + offset, source, sizeof(JSValue) * sourceSize);</span>
          return;
      }
  
      for (unsigned i = sourceSize; i--;)
          clearElement&lt;T&gt;(buffer[i + offset]);
  };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncConcatMemcpy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     ASSERT(callFrame-&gt;argumentCount() == 2);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSArray* firstArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
  
      // This code assumes that neither array has set Symbol.isConcatSpreadable. If the first array
      // has indexed accessors then one of those accessors might change the value of Symbol.isConcatSpreadable
      // on the second argument.
      if (UNLIKELY(shouldUseSlowPut(firstArray-&gt;indexingType())))
          return JSValue::encode(jsNull());
  
      // We need to check the species constructor here since checking it in the JS wrapper is too expensive for the non-optimizing tiers.
<span class="line-modified">!     bool isValid = speciesWatchpointIsValid(vm, firstArray);</span>
      scope.assertNoException();
      if (UNLIKELY(!isValid))
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     JSValue second = callFrame-&gt;uncheckedArgument(1);</span>
      if (!isJSArray(second))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, concatAppendOne(globalObject, vm, firstArray, second));</span>
  
      JSArray* secondArray = jsCast&lt;JSArray*&gt;(second);
  
      Butterfly* firstButterfly = firstArray-&gt;butterfly();
      Butterfly* secondButterfly = secondArray-&gt;butterfly();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1532,44 ***</span>
  
      Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
      checkedResultSize += secondArraySize;
  
      if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      unsigned resultSize = checkedResultSize.unsafeGet();
      IndexingType firstType = firstArray-&gt;indexingType();
      IndexingType secondType = secondArray-&gt;indexingType();
      IndexingType type = firstArray-&gt;mergeIndexingTypeForCopying(secondType);
      if (type == NonArray || !firstArray-&gt;canFastCopy(vm, secondArray) || resultSize &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">!         JSArray* result = constructEmptyArray(exec, nullptr, resultSize);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         bool success = moveElements(exec, vm, result, 0, firstArray, firstArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
<span class="line-modified">!         success = moveElements(exec, vm, result, firstArraySize, secondArray, secondArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
  
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">-     Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
      if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());</span>
      ObjectInitializationScope initializationScope(vm);
      JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, resultStructure, resultSize);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
      if (type == ArrayWithDouble) {
          double* buffer = result-&gt;butterfly()-&gt;contiguousDouble().data();
<span class="line-new-header">--- 1567,43 ---</span>
  
      Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
      checkedResultSize += secondArraySize;
  
      if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      unsigned resultSize = checkedResultSize.unsafeGet();
      IndexingType firstType = firstArray-&gt;indexingType();
      IndexingType secondType = secondArray-&gt;indexingType();
      IndexingType type = firstArray-&gt;mergeIndexingTypeForCopying(secondType);
      if (type == NonArray || !firstArray-&gt;canFastCopy(vm, secondArray) || resultSize &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">!         JSArray* result = constructEmptyArray(globalObject, nullptr, resultSize);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!         bool success = moveElements(globalObject, vm, result, 0, firstArray, firstArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
<span class="line-modified">!         success = moveElements(globalObject, vm, result, firstArraySize, secondArray, secondArraySize);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (UNLIKELY(!success))
              return encodedJSValue();
  
          return JSValue::encode(result);
      }
  
<span class="line-modified">!     Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
      if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
          return JSValue::encode(jsNull());
  
<span class="line-modified">!     ASSERT(!globalObject-&gt;isHavingABadTime());</span>
      ObjectInitializationScope initializationScope(vm);
      JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, resultStructure, resultSize);
      if (UNLIKELY(!result)) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
      if (type == ArrayWithDouble) {
          double* buffer = result-&gt;butterfly()-&gt;contiguousDouble().data();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1580,31 ***</span>
          WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
          copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
          copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
      }
  
<span class="line-modified">!     result-&gt;butterfly()-&gt;setPublicLength(resultSize);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)</span>
  {
<span class="line-modified">!     ASSERT(exec-&gt;argumentCount() == 3);</span>
  
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));</span>
<span class="line-modified">!     JSValue startValue = exec-&gt;uncheckedArgument(2);</span>
      ASSERT(startValue.isUInt32AsAnyInt());
      unsigned startIndex = startValue.asUInt32AsAnyInt();
<span class="line-modified">!     bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);</span>
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (success)
          return JSValue::encode(jsUndefined());
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());</span>
      return JSValue::encode(jsUndefined());
  }
  
  } // namespace JSC
<span class="line-new-header">--- 1614,31 ---</span>
          WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
          copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
          copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
      }
  
<span class="line-modified">!     ASSERT(result-&gt;butterfly()-&gt;publicLength() == resultSize);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     ASSERT(callFrame-&gt;argumentCount() == 3);</span>
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!     JSArray* resultArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">!     JSArray* otherArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(1));</span>
<span class="line-modified">!     JSValue startValue = callFrame-&gt;uncheckedArgument(2);</span>
      ASSERT(startValue.isUInt32AsAnyInt());
      unsigned startIndex = startValue.asUInt32AsAnyInt();
<span class="line-modified">!     bool success = resultArray-&gt;appendMemcpy(globalObject, vm, startIndex, otherArray);</span>
      EXCEPTION_ASSERT(!scope.exception() || !success);
      if (success)
          return JSValue::encode(jsUndefined());
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      scope.release();
<span class="line-modified">!     moveElements(globalObject, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());</span>
      return JSValue::encode(jsUndefined());
  }
  
  } // namespace JSC
</pre>
<center><a href="ArrayIteratorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PopStateEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Position.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Position.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;Editing.h&quot;
  31 #include &quot;HTMLBRElement.h&quot;
  32 #include &quot;HTMLBodyElement.h&quot;
  33 #include &quot;HTMLHtmlElement.h&quot;
  34 #include &quot;HTMLNames.h&quot;
  35 #include &quot;HTMLParserIdioms.h&quot;
  36 #include &quot;HTMLTableElement.h&quot;
  37 #include &quot;InlineElementBox.h&quot;
  38 #include &quot;InlineIterator.h&quot;
  39 #include &quot;InlineTextBox.h&quot;

  40 #include &quot;Logging.h&quot;
  41 #include &quot;NodeTraversal.h&quot;
  42 #include &quot;PositionIterator.h&quot;
  43 #include &quot;RenderBlock.h&quot;
  44 #include &quot;RenderFlexibleBox.h&quot;
  45 #include &quot;RenderGrid.h&quot;
  46 #include &quot;RenderInline.h&quot;
  47 #include &quot;RenderIterator.h&quot;
  48 #include &quot;RenderLineBreak.h&quot;
  49 #include &quot;RenderText.h&quot;
<span class="line-removed">  50 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  51 #include &quot;Text.h&quot;
  52 #include &quot;TextIterator.h&quot;
  53 #include &quot;VisiblePosition.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;stdio.h&gt;
  56 #include &lt;wtf/text/CString.h&gt;
  57 #include &lt;wtf/text/TextStream.h&gt;
  58 #include &lt;wtf/unicode/CharacterNames.h&gt;
  59 
  60 #if ENABLE(TREE_DEBUGGING)
  61 #include &lt;wtf/text/StringBuilder.h&gt;
  62 #endif
  63 
  64 namespace WebCore {
  65 
  66 using namespace HTMLNames;
  67 
  68 static bool hasInlineBoxWrapper(RenderObject&amp; renderer)
  69 {
  70     if (is&lt;RenderBox&gt;(renderer) &amp;&amp; downcast&lt;RenderBox&gt;(renderer).inlineBoxWrapper())
</pre>
<hr />
<pre>
 639 {
 640     while (node &amp;&amp; !endsOfNodeAreVisuallyDistinctPositions(node))
 641         node = node-&gt;parentNode();
 642 
 643     return node;
 644 }
 645 
 646 // upstream() and downstream() want to return positions that are either in a
 647 // text node or at just before a non-text node.  This method checks for that.
 648 static bool isStreamer(const PositionIterator&amp; pos)
 649 {
 650     if (!pos.node())
 651         return true;
 652 
 653     if (isAtomicNode(pos.node()))
 654         return true;
 655 
 656     return pos.atStartOfNode();
 657 }
 658 
<span class="line-removed"> 659 static void ensureLineBoxesIfNeeded(RenderObject&amp; renderer)</span>
<span class="line-removed"> 660 {</span>
<span class="line-removed"> 661     if (!is&lt;RenderText&gt;(renderer) &amp;&amp; !is&lt;RenderLineBreak&gt;(renderer))</span>
<span class="line-removed"> 662         return;</span>
<span class="line-removed"> 663     is&lt;RenderText&gt;(renderer) ? downcast&lt;RenderText&gt;(renderer).ensureLineBoxes() : downcast&lt;RenderLineBreak&gt;(renderer).ensureLineBoxes();</span>
<span class="line-removed"> 664 }</span>
<span class="line-removed"> 665 </span>
 666 // This function and downstream() are used for moving back and forth between visually equivalent candidates.
 667 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 668 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the left candidate
 669 // and downstream() will return the right one.
 670 // Also, upstream() will return [boundary, 0] for any of the positions from [boundary, 0] to the first candidate
 671 // in boundary, where endsOfNodeAreVisuallyDistinctPositions(boundary) is true.
 672 Position Position::upstream(EditingBoundaryCrossingRule rule) const
 673 {
 674     Node* startNode = deprecatedNode();
 675     if (!startNode)
 676         return { };
 677 
 678     // iterate backward from there, looking for a qualified position
 679     Node* boundary = enclosingVisualBoundary(startNode);
 680     // FIXME: PositionIterator should respect Before and After positions.
 681     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 682     PositionIterator currentPosition = lastVisible;
 683     bool startEditable = startNode-&gt;hasEditableStyle();
 684     Node* lastNode = startNode;
 685     bool boundaryCrossed = false;
</pre>
<hr />
<pre>
 691         if (&amp;currentNode != lastNode) {
 692             // Don&#39;t change editability.
 693             bool currentEditable = currentNode.hasEditableStyle();
 694             if (startEditable != currentEditable) {
 695                 if (rule == CannotCrossEditingBoundary)
 696                     break;
 697                 boundaryCrossed = true;
 698             }
 699             lastNode = &amp;currentNode;
 700         }
 701 
 702         // If we&#39;ve moved to a position that is visually distinct, return the last saved position. There
 703         // is code below that terminates early if we&#39;re *about* to move to a visually distinct position.
 704         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 705             return lastVisible;
 706 
 707         // skip position in unrendered or invisible node
 708         RenderObject* renderer = currentNode.renderer();
 709         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 710             continue;
<span class="line-modified"> 711         ensureLineBoxesIfNeeded(*renderer);</span>
 712         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 713             lastVisible = currentPosition;
 714             break;
 715         }
 716 
 717         // track last visible streamer position
 718         if (isStreamer(currentPosition))
 719             lastVisible = currentPosition;
 720 
 721         // Don&#39;t move past a position that is visually distinct.  We could rely on code above to terminate and
 722         // return lastVisible on the next iteration, but we terminate early to avoid doing a computeNodeIndex() call.
 723         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; currentPosition.atStartOfNode())
 724             return lastVisible;
 725 
 726         // Return position after tables and nodes which have content that can be ignored.
 727         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 728             if (currentPosition.atEndOfNode())
 729                 return positionAfterNode(&amp;currentNode);
 730             continue;
 731         }
 732 
 733         // return current position if it is in rendered text
 734         if (is&lt;RenderText&gt;(*renderer)) {
 735             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<span class="line-modified"> 736             if (!textRenderer.firstTextBox())</span>


 737                 continue;

 738             if (&amp;currentNode != startNode) {
 739                 // This assertion fires in layout tests in the case-transform.html test because
 740                 // of a mix-up between offsets in the text in the DOM tree with text in the
 741                 // render tree which can have a different length due to case transformation.
 742                 // Until we resolve that, disable this so we can run the layout tests!
 743                 //ASSERT(currentOffset &gt;= renderer-&gt;caretMaxOffset());
 744                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMaxOffset());
 745             }
 746 
 747             unsigned textOffset = currentPosition.offsetInLeafNode();
<span class="line-modified"> 748             auto lastTextBox = textRenderer.lastTextBox();</span>
<span class="line-modified"> 749             for (auto* box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {</span>
<span class="line-modified"> 750                 if (textOffset &lt;= box-&gt;start() + box-&gt;len()) {</span>
<span class="line-removed"> 751                     if (textOffset &gt; box-&gt;start())</span>
 752                         return currentPosition;
 753                     continue;
 754                 }
 755 
<span class="line-modified"> 756                 if (box == lastTextBox || textOffset != box-&gt;start() + box-&gt;len() + 1)</span>
<span class="line-removed"> 757                     continue;</span>
<span class="line-removed"> 758 </span>
<span class="line-removed"> 759                 // The text continues on the next line only if the last text box is not on this line and</span>
<span class="line-removed"> 760                 // none of the boxes on this line have a larger start offset.</span>
<span class="line-removed"> 761 </span>
<span class="line-removed"> 762                 bool continuesOnNextLine = true;</span>
<span class="line-removed"> 763                 InlineBox* otherBox = box;</span>
<span class="line-removed"> 764                 while (continuesOnNextLine) {</span>
<span class="line-removed"> 765                     otherBox = otherBox-&gt;nextLeafChild();</span>
<span class="line-removed"> 766                     if (!otherBox)</span>
<span class="line-removed"> 767                         break;</span>
<span class="line-removed"> 768                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt; textOffset))</span>
<span class="line-removed"> 769                         continuesOnNextLine = false;</span>
<span class="line-removed"> 770                 }</span>
<span class="line-removed"> 771 </span>
<span class="line-removed"> 772                 otherBox = box;</span>
<span class="line-removed"> 773                 while (continuesOnNextLine) {</span>
<span class="line-removed"> 774                     otherBox = otherBox-&gt;prevLeafChild();</span>
<span class="line-removed"> 775                     if (!otherBox)</span>
<span class="line-removed"> 776                         break;</span>
<span class="line-removed"> 777                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt; textOffset))</span>
<span class="line-removed"> 778                         continuesOnNextLine = false;</span>
<span class="line-removed"> 779                 }</span>
<span class="line-removed"> 780 </span>
<span class="line-removed"> 781                 if (continuesOnNextLine)</span>
 782                     return currentPosition;
 783             }
 784         }
 785     }
 786 
 787     return lastVisible;
 788 }
 789 
 790 // This function and upstream() are used for moving back and forth between visually equivalent candidates.
 791 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 792 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the right candidate
 793 // and upstream() will return the left one.
 794 // Also, downstream() will return the last position in the last atomic node in boundary for all of the positions
 795 // in boundary after the last candidate, where endsOfNodeAreVisuallyDistinctPositions(boundary).
 796 // FIXME: This function should never be called when the line box tree is dirty. See https://bugs.webkit.org/show_bug.cgi?id=97264
 797 Position Position::downstream(EditingBoundaryCrossingRule rule) const
 798 {
 799     Node* startNode = deprecatedNode();
 800     if (!startNode)
 801         return { };
</pre>
<hr />
<pre>
 826         }
 827 
 828         // stop before going above the body, up into the head
 829         // return the last visible streamer position
 830         if (is&lt;HTMLBodyElement&gt;(currentNode) &amp;&amp; currentPosition.atEndOfNode())
 831             break;
 832 
 833         // Do not move to a visually distinct position.
 834         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 835             return lastVisible;
 836         // Do not move past a visually disinct position.
 837         // Note: The first position after the last in a node whose ends are visually distinct
 838         // positions will be [boundary-&gt;parentNode(), originalBlock-&gt;computeNodeIndex() + 1].
 839         if (boundary &amp;&amp; boundary-&gt;parentNode() == &amp;currentNode)
 840             return lastVisible;
 841 
 842         // skip position in unrendered or invisible node
 843         auto* renderer = currentNode.renderer();
 844         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 845             continue;
<span class="line-modified"> 846         ensureLineBoxesIfNeeded(*renderer);</span>
 847         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 848             lastVisible = currentPosition;
 849             break;
 850         }
 851 
 852         // track last visible streamer position
 853         if (isStreamer(currentPosition))
 854             lastVisible = currentPosition;
 855 
 856         // Return position before tables and nodes which have content that can be ignored.
 857         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 858             if (currentPosition.atStartOfNode())
 859                 return positionBeforeNode(&amp;currentNode);
 860             continue;
 861         }
 862 
 863         // return current position if it is in rendered text
 864         if (is&lt;RenderText&gt;(*renderer)) {
 865             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<span class="line-modified"> 866             if (!textRenderer.firstTextBox())</span>


 867                 continue;

 868             if (&amp;currentNode != startNode) {
 869                 ASSERT(currentPosition.atStartOfNode());
<span class="line-modified"> 870                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMinOffset());</span>
 871             }
 872 
 873             unsigned textOffset = currentPosition.offsetInLeafNode();
<span class="line-modified"> 874             auto lastTextBox = textRenderer.lastTextBox();</span>
<span class="line-modified"> 875             for (auto* box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {</span>
<span class="line-modified"> 876                 if (textOffset &lt;= box-&gt;end()) {</span>
<span class="line-removed"> 877                     if (textOffset &gt;= box-&gt;start())</span>
<span class="line-removed"> 878                         return currentPosition;</span>
<span class="line-removed"> 879                     continue;</span>
<span class="line-removed"> 880                 }</span>
 881 
<span class="line-modified"> 882                 if (box == lastTextBox || textOffset != box-&gt;start() + box-&gt;len())</span>


 883                     continue;
<span class="line-removed"> 884 </span>
<span class="line-removed"> 885                 // The text continues on the next line only if the last text box is not on this line and</span>
<span class="line-removed"> 886                 // none of the boxes on this line have a larger start offset.</span>
<span class="line-removed"> 887 </span>
<span class="line-removed"> 888                 bool continuesOnNextLine = true;</span>
<span class="line-removed"> 889                 InlineBox* otherBox = box;</span>
<span class="line-removed"> 890                 while (continuesOnNextLine) {</span>
<span class="line-removed"> 891                     otherBox = otherBox-&gt;nextLeafChild();</span>
<span class="line-removed"> 892                     if (!otherBox)</span>
<span class="line-removed"> 893                         break;</span>
<span class="line-removed"> 894                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt;= textOffset))</span>
<span class="line-removed"> 895                         continuesOnNextLine = false;</span>
<span class="line-removed"> 896                 }</span>
<span class="line-removed"> 897 </span>
<span class="line-removed"> 898                 otherBox = box;</span>
<span class="line-removed"> 899                 while (continuesOnNextLine) {</span>
<span class="line-removed"> 900                     otherBox = otherBox-&gt;prevLeafChild();</span>
<span class="line-removed"> 901                     if (!otherBox)</span>
<span class="line-removed"> 902                         break;</span>
<span class="line-removed"> 903                     if (otherBox == lastTextBox || (&amp;otherBox-&gt;renderer() == &amp;textRenderer &amp;&amp; downcast&lt;InlineTextBox&gt;(*otherBox).start() &gt;= textOffset))</span>
<span class="line-removed"> 904                         continuesOnNextLine = false;</span>
 905                 }
 906 
<span class="line-modified"> 907                 if (continuesOnNextLine)</span>
 908                     return currentPosition;
 909             }
 910         }
 911     }
 912 
 913     return lastVisible;
 914 }
 915 
 916 unsigned Position::positionCountBetweenPositions(const Position&amp; a, const Position&amp; b)
 917 {
 918     if (a.isNull() || b.isNull())
 919         return UINT_MAX;
 920 
 921     Position endPos;
 922     Position pos;
 923     if (a &gt; b) {
 924         endPos = a;
 925         pos = b;
 926     } else if (a &lt; b) {
 927         endPos = b;
</pre>
<hr />
<pre>
1263         auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1264         textRenderer.ensureLineBoxes();
1265 
1266         InlineTextBox* box;
1267         InlineTextBox* candidate = nullptr;
1268 
1269         for (box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
1270             int caretMinOffset = box-&gt;caretMinOffset();
1271             int caretMaxOffset = box-&gt;caretMaxOffset();
1272 
1273             if (caretOffset &lt; caretMinOffset || caretOffset &gt; caretMaxOffset || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;isLineBreak()))
1274                 continue;
1275 
1276             if (caretOffset &gt; caretMinOffset &amp;&amp; caretOffset &lt; caretMaxOffset) {
1277                 inlineBox = box;
1278                 return;
1279             }
1280 
1281             if (((caretOffset == caretMaxOffset) ^ (affinity == DOWNSTREAM))
1282                 || ((caretOffset == caretMinOffset) ^ (affinity == UPSTREAM))
<span class="line-modified">1283                 || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;nextLeafChild() &amp;&amp; box-&gt;nextLeafChild()-&gt;isLineBreak()))</span>
1284                 break;
1285 
1286             candidate = box;
1287         }
1288         if (candidate &amp;&amp; candidate == textRenderer.lastTextBox() &amp;&amp; affinity == DOWNSTREAM) {
1289             box = searchAheadForBetterMatch(&amp;textRenderer);
1290             if (box)
1291                 caretOffset = box-&gt;caretMinOffset();
1292         }
1293         inlineBox = box ? box : candidate;
1294     } else {
1295         inlineBox = nullptr;
1296         if (canHaveChildrenForEditing(*deprecatedNode()) &amp;&amp; is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderBlockFlow&gt;(*renderer))) {
1297             // Try a visually equivalent position with possibly opposite editability. This helps in case |this| is in
1298             // an editable block but surrounded by non-editable positions. It acts to negate the logic at the beginning
1299             // of RenderObject::createVisiblePosition().
1300             Position equivalent = downstreamIgnoringEditingBoundaries(*this);
1301             if (equivalent == *this) {
1302                 equivalent = upstreamIgnoringEditingBoundaries(*this);
1303                 if (equivalent == *this || downstreamIgnoringEditingBoundaries(equivalent) == *this)
1304                     return;
1305             }
1306 
1307             equivalent.getInlineBoxAndOffset(UPSTREAM, primaryDirection, inlineBox, caretOffset);
1308             return;
1309         }
1310         if (is&lt;RenderBox&gt;(*renderer)) {
1311             inlineBox = downcast&lt;RenderBox&gt;(*renderer).inlineBoxWrapper();
1312             if (!inlineBox || (caretOffset &gt; inlineBox-&gt;caretMinOffset() &amp;&amp; caretOffset &lt; inlineBox-&gt;caretMaxOffset()))
1313                 return;
1314         }
1315     }
1316 
1317     if (!inlineBox)
1318         return;
1319 
1320     unsigned char level = inlineBox-&gt;bidiLevel();
1321 
1322     if (inlineBox-&gt;direction() == primaryDirection) {
1323         if (caretOffset == inlineBox-&gt;caretRightmostOffset()) {
<span class="line-modified">1324             InlineBox* nextBox = inlineBox-&gt;nextLeafChild();</span>
1325             if (!nextBox || nextBox-&gt;bidiLevel() &gt;= level)
1326                 return;
1327 
1328             level = nextBox-&gt;bidiLevel();
1329             InlineBox* prevBox = inlineBox;
1330             do {
<span class="line-modified">1331                 prevBox = prevBox-&gt;prevLeafChild();</span>
1332             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
1333 
1334             if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
1335                 return;
1336 
1337             // For example, abc 123 ^ CBA
<span class="line-modified">1338             while (InlineBox* nextBox = inlineBox-&gt;nextLeafChild()) {</span>
1339                 if (nextBox-&gt;bidiLevel() &lt; level)
1340                     break;
1341                 inlineBox = nextBox;
1342             }
1343             caretOffset = inlineBox-&gt;caretRightmostOffset();
1344         } else {
<span class="line-modified">1345             InlineBox* prevBox = inlineBox-&gt;prevLeafChild();</span>
1346             if (!prevBox || prevBox-&gt;bidiLevel() &gt;= level)
1347                 return;
1348 
1349             level = prevBox-&gt;bidiLevel();
1350             InlineBox* nextBox = inlineBox;
1351             do {
<span class="line-modified">1352                 nextBox = nextBox-&gt;nextLeafChild();</span>
1353             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
1354 
1355             if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
1356                 return;
1357 
<span class="line-modified">1358             while (InlineBox* prevBox = inlineBox-&gt;prevLeafChild()) {</span>
1359                 if (prevBox-&gt;bidiLevel() &lt; level)
1360                     break;
1361                 inlineBox = prevBox;
1362             }
1363             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1364         }
1365         return;
1366     }
1367 
1368     if (caretOffset == inlineBox-&gt;caretLeftmostOffset()) {
<span class="line-modified">1369         InlineBox* prevBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak();</span>
1370         if (!prevBox || prevBox-&gt;bidiLevel() &lt; level) {
1371             // Left edge of a secondary run. Set to the right edge of the entire run.
<span class="line-modified">1372             while (InlineBox* nextBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak()) {</span>
1373                 if (nextBox-&gt;bidiLevel() &lt; level)
1374                     break;
1375                 inlineBox = nextBox;
1376             }
1377             caretOffset = inlineBox-&gt;caretRightmostOffset();
1378         } else if (prevBox-&gt;bidiLevel() &gt; level) {
1379             // Right edge of a &quot;tertiary&quot; run. Set to the left edge of that run.
<span class="line-modified">1380             while (InlineBox* tertiaryBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak()) {</span>
1381                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1382                     break;
1383                 inlineBox = tertiaryBox;
1384             }
1385             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1386         }
1387     } else {
<span class="line-modified">1388         InlineBox* nextBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak();</span>
1389         if (!nextBox || nextBox-&gt;bidiLevel() &lt; level) {
1390             // Right edge of a secondary run. Set to the left edge of the entire run.
<span class="line-modified">1391             while (InlineBox* prevBox = inlineBox-&gt;prevLeafChildIgnoringLineBreak()) {</span>
1392                 if (prevBox-&gt;bidiLevel() &lt; level)
1393                     break;
1394                 inlineBox = prevBox;
1395             }
1396             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1397         } else if (nextBox-&gt;bidiLevel() &gt; level) {
1398             // Left edge of a &quot;tertiary&quot; run. Set to the right edge of that run.
<span class="line-modified">1399             while (InlineBox* tertiaryBox = inlineBox-&gt;nextLeafChildIgnoringLineBreak()) {</span>
1400                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1401                     break;
1402                 inlineBox = tertiaryBox;
1403             }
1404             caretOffset = inlineBox-&gt;caretRightmostOffset();
1405         }
1406     }
1407 }
1408 
1409 TextDirection Position::primaryDirection() const
1410 {
1411     if (!m_anchorNode-&gt;renderer())
1412         return TextDirection::LTR;
1413     if (auto* blockFlow = lineageOfType&lt;RenderBlockFlow&gt;(*m_anchorNode-&gt;renderer()).first())
1414         return blockFlow-&gt;style().direction();
1415     return TextDirection::LTR;
1416 }
1417 
1418 #if ENABLE(TREE_DEBUGGING)
1419 
</pre>
<hr />
<pre>
1602 
1603     stream.dumpProperty(&quot;anchor node&quot;, position.anchorNode());
1604     stream.dumpProperty(&quot;offset&quot;, position.offsetInContainerNode());
1605     stream.dumpProperty(&quot;anchor type&quot;, position.anchorType());
1606 
1607     return stream;
1608 }
1609 
1610 RefPtr&lt;Node&gt; commonShadowIncludingAncestor(const Position&amp; a, const Position&amp; b)
1611 {
1612     auto* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
1613     if (!commonScope)
1614         return nullptr;
1615     auto* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
1616     ASSERT(nodeA);
1617     auto* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
1618     ASSERT(nodeB);
1619     return Range::commonAncestorContainer(nodeA, nodeB);
1620 }
1621 






















1622 } // namespace WebCore
1623 
1624 #if ENABLE(TREE_DEBUGGING)
1625 
1626 void showTree(const WebCore::Position&amp; pos)
1627 {
1628     pos.showTreeForThis();
1629 }
1630 
1631 void showTree(const WebCore::Position* pos)
1632 {
1633     if (pos)
1634         pos-&gt;showTreeForThis();
1635 }
1636 
1637 #endif
</pre>
</td>
<td>
<hr />
<pre>
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Position.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;Editing.h&quot;
  31 #include &quot;HTMLBRElement.h&quot;
  32 #include &quot;HTMLBodyElement.h&quot;
  33 #include &quot;HTMLHtmlElement.h&quot;
  34 #include &quot;HTMLNames.h&quot;
  35 #include &quot;HTMLParserIdioms.h&quot;
  36 #include &quot;HTMLTableElement.h&quot;
  37 #include &quot;InlineElementBox.h&quot;
  38 #include &quot;InlineIterator.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
<span class="line-added">  40 #include &quot;LineLayoutTraversal.h&quot;</span>
  41 #include &quot;Logging.h&quot;
  42 #include &quot;NodeTraversal.h&quot;
  43 #include &quot;PositionIterator.h&quot;
  44 #include &quot;RenderBlock.h&quot;
  45 #include &quot;RenderFlexibleBox.h&quot;
  46 #include &quot;RenderGrid.h&quot;
  47 #include &quot;RenderInline.h&quot;
  48 #include &quot;RenderIterator.h&quot;
  49 #include &quot;RenderLineBreak.h&quot;
  50 #include &quot;RenderText.h&quot;

  51 #include &quot;Text.h&quot;
  52 #include &quot;TextIterator.h&quot;
  53 #include &quot;VisiblePosition.h&quot;
  54 #include &quot;VisibleUnits.h&quot;
  55 #include &lt;stdio.h&gt;
  56 #include &lt;wtf/text/CString.h&gt;
  57 #include &lt;wtf/text/TextStream.h&gt;
  58 #include &lt;wtf/unicode/CharacterNames.h&gt;
  59 
  60 #if ENABLE(TREE_DEBUGGING)
  61 #include &lt;wtf/text/StringBuilder.h&gt;
  62 #endif
  63 
  64 namespace WebCore {
  65 
  66 using namespace HTMLNames;
  67 
  68 static bool hasInlineBoxWrapper(RenderObject&amp; renderer)
  69 {
  70     if (is&lt;RenderBox&gt;(renderer) &amp;&amp; downcast&lt;RenderBox&gt;(renderer).inlineBoxWrapper())
</pre>
<hr />
<pre>
 639 {
 640     while (node &amp;&amp; !endsOfNodeAreVisuallyDistinctPositions(node))
 641         node = node-&gt;parentNode();
 642 
 643     return node;
 644 }
 645 
 646 // upstream() and downstream() want to return positions that are either in a
 647 // text node or at just before a non-text node.  This method checks for that.
 648 static bool isStreamer(const PositionIterator&amp; pos)
 649 {
 650     if (!pos.node())
 651         return true;
 652 
 653     if (isAtomicNode(pos.node()))
 654         return true;
 655 
 656     return pos.atStartOfNode();
 657 }
 658 







 659 // This function and downstream() are used for moving back and forth between visually equivalent candidates.
 660 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 661 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the left candidate
 662 // and downstream() will return the right one.
 663 // Also, upstream() will return [boundary, 0] for any of the positions from [boundary, 0] to the first candidate
 664 // in boundary, where endsOfNodeAreVisuallyDistinctPositions(boundary) is true.
 665 Position Position::upstream(EditingBoundaryCrossingRule rule) const
 666 {
 667     Node* startNode = deprecatedNode();
 668     if (!startNode)
 669         return { };
 670 
 671     // iterate backward from there, looking for a qualified position
 672     Node* boundary = enclosingVisualBoundary(startNode);
 673     // FIXME: PositionIterator should respect Before and After positions.
 674     PositionIterator lastVisible = m_anchorType == PositionIsAfterAnchor ? createLegacyEditingPosition(m_anchorNode.get(), caretMaxOffset(*m_anchorNode)) : *this;
 675     PositionIterator currentPosition = lastVisible;
 676     bool startEditable = startNode-&gt;hasEditableStyle();
 677     Node* lastNode = startNode;
 678     bool boundaryCrossed = false;
</pre>
<hr />
<pre>
 684         if (&amp;currentNode != lastNode) {
 685             // Don&#39;t change editability.
 686             bool currentEditable = currentNode.hasEditableStyle();
 687             if (startEditable != currentEditable) {
 688                 if (rule == CannotCrossEditingBoundary)
 689                     break;
 690                 boundaryCrossed = true;
 691             }
 692             lastNode = &amp;currentNode;
 693         }
 694 
 695         // If we&#39;ve moved to a position that is visually distinct, return the last saved position. There
 696         // is code below that terminates early if we&#39;re *about* to move to a visually distinct position.
 697         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 698             return lastVisible;
 699 
 700         // skip position in unrendered or invisible node
 701         RenderObject* renderer = currentNode.renderer();
 702         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 703             continue;
<span class="line-modified"> 704 </span>
 705         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 706             lastVisible = currentPosition;
 707             break;
 708         }
 709 
 710         // track last visible streamer position
 711         if (isStreamer(currentPosition))
 712             lastVisible = currentPosition;
 713 
 714         // Don&#39;t move past a position that is visually distinct.  We could rely on code above to terminate and
 715         // return lastVisible on the next iteration, but we terminate early to avoid doing a computeNodeIndex() call.
 716         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; currentPosition.atStartOfNode())
 717             return lastVisible;
 718 
 719         // Return position after tables and nodes which have content that can be ignored.
 720         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 721             if (currentPosition.atEndOfNode())
 722                 return positionAfterNode(&amp;currentNode);
 723             continue;
 724         }
 725 
 726         // return current position if it is in rendered text
 727         if (is&lt;RenderText&gt;(*renderer)) {
 728             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<span class="line-modified"> 729 </span>
<span class="line-added"> 730             auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);</span>
<span class="line-added"> 731             if (!firstTextBox)</span>
 732                 continue;
<span class="line-added"> 733 </span>
 734             if (&amp;currentNode != startNode) {
 735                 // This assertion fires in layout tests in the case-transform.html test because
 736                 // of a mix-up between offsets in the text in the DOM tree with text in the
 737                 // render tree which can have a different length due to case transformation.
 738                 // Until we resolve that, disable this so we can run the layout tests!
 739                 //ASSERT(currentOffset &gt;= renderer-&gt;caretMaxOffset());
 740                 return createLegacyEditingPosition(&amp;currentNode, renderer-&gt;caretMaxOffset());
 741             }
 742 
 743             unsigned textOffset = currentPosition.offsetInLeafNode();
<span class="line-modified"> 744             for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {</span>
<span class="line-modified"> 745                 if (textOffset &lt;= box-&gt;localEndOffset()) {</span>
<span class="line-modified"> 746                     if (textOffset &gt; box-&gt;localStartOffset())</span>

 747                         return currentPosition;
 748                     continue;
 749                 }
 750 
<span class="line-modified"> 751                 if (textOffset == box-&gt;localEndOffset() + 1 &amp;&amp; box-&gt;isLastOnLine() &amp;&amp; !box-&gt;isLast())</span>

























 752                     return currentPosition;
 753             }
 754         }
 755     }
 756 
 757     return lastVisible;
 758 }
 759 
 760 // This function and upstream() are used for moving back and forth between visually equivalent candidates.
 761 // For example, for the text node &quot;foo     bar&quot; where whitespace is collapsible, there are two candidates
 762 // that map to the VisiblePosition between &#39;b&#39; and the space.  This function will return the right candidate
 763 // and upstream() will return the left one.
 764 // Also, downstream() will return the last position in the last atomic node in boundary for all of the positions
 765 // in boundary after the last candidate, where endsOfNodeAreVisuallyDistinctPositions(boundary).
 766 // FIXME: This function should never be called when the line box tree is dirty. See https://bugs.webkit.org/show_bug.cgi?id=97264
 767 Position Position::downstream(EditingBoundaryCrossingRule rule) const
 768 {
 769     Node* startNode = deprecatedNode();
 770     if (!startNode)
 771         return { };
</pre>
<hr />
<pre>
 796         }
 797 
 798         // stop before going above the body, up into the head
 799         // return the last visible streamer position
 800         if (is&lt;HTMLBodyElement&gt;(currentNode) &amp;&amp; currentPosition.atEndOfNode())
 801             break;
 802 
 803         // Do not move to a visually distinct position.
 804         if (endsOfNodeAreVisuallyDistinctPositions(&amp;currentNode) &amp;&amp; &amp;currentNode != boundary)
 805             return lastVisible;
 806         // Do not move past a visually disinct position.
 807         // Note: The first position after the last in a node whose ends are visually distinct
 808         // positions will be [boundary-&gt;parentNode(), originalBlock-&gt;computeNodeIndex() + 1].
 809         if (boundary &amp;&amp; boundary-&gt;parentNode() == &amp;currentNode)
 810             return lastVisible;
 811 
 812         // skip position in unrendered or invisible node
 813         auto* renderer = currentNode.renderer();
 814         if (!renderer || renderer-&gt;style().visibility() != Visibility::Visible)
 815             continue;
<span class="line-modified"> 816 </span>
 817         if (rule == CanCrossEditingBoundary &amp;&amp; boundaryCrossed) {
 818             lastVisible = currentPosition;
 819             break;
 820         }
 821 
 822         // track last visible streamer position
 823         if (isStreamer(currentPosition))
 824             lastVisible = currentPosition;
 825 
 826         // Return position before tables and nodes which have content that can be ignored.
 827         if (editingIgnoresContent(currentNode) || isRenderedTable(&amp;currentNode)) {
 828             if (currentPosition.atStartOfNode())
 829                 return positionBeforeNode(&amp;currentNode);
 830             continue;
 831         }
 832 
 833         // return current position if it is in rendered text
 834         if (is&lt;RenderText&gt;(*renderer)) {
 835             auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
<span class="line-modified"> 836 </span>
<span class="line-added"> 837             auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);</span>
<span class="line-added"> 838             if (!firstTextBox)</span>
 839                 continue;
<span class="line-added"> 840 </span>
 841             if (&amp;currentNode != startNode) {
 842                 ASSERT(currentPosition.atStartOfNode());
<span class="line-modified"> 843                 return createLegacyEditingPosition(&amp;currentNode, textRenderer.caretMinOffset());</span>
 844             }
 845 
 846             unsigned textOffset = currentPosition.offsetInLeafNode();
<span class="line-modified"> 847             for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {</span>
<span class="line-modified"> 848                 if (!box-&gt;length() &amp;&amp; textOffset == box-&gt;localStartOffset())</span>
<span class="line-modified"> 849                     return currentPosition;</span>




 850 
<span class="line-modified"> 851                 if (textOffset &lt; box-&gt;localEndOffset()) {</span>
<span class="line-added"> 852                     if (textOffset &gt;= box-&gt;localStartOffset())</span>
<span class="line-added"> 853                         return currentPosition;</span>
 854                     continue;





















 855                 }
 856 
<span class="line-modified"> 857                 if (textOffset == box-&gt;localEndOffset() &amp;&amp; box-&gt;isLastOnLine() &amp;&amp; !box-&gt;isLast())</span>
 858                     return currentPosition;
 859             }
 860         }
 861     }
 862 
 863     return lastVisible;
 864 }
 865 
 866 unsigned Position::positionCountBetweenPositions(const Position&amp; a, const Position&amp; b)
 867 {
 868     if (a.isNull() || b.isNull())
 869         return UINT_MAX;
 870 
 871     Position endPos;
 872     Position pos;
 873     if (a &gt; b) {
 874         endPos = a;
 875         pos = b;
 876     } else if (a &lt; b) {
 877         endPos = b;
</pre>
<hr />
<pre>
1213         auto&amp; textRenderer = downcast&lt;RenderText&gt;(*renderer);
1214         textRenderer.ensureLineBoxes();
1215 
1216         InlineTextBox* box;
1217         InlineTextBox* candidate = nullptr;
1218 
1219         for (box = textRenderer.firstTextBox(); box; box = box-&gt;nextTextBox()) {
1220             int caretMinOffset = box-&gt;caretMinOffset();
1221             int caretMaxOffset = box-&gt;caretMaxOffset();
1222 
1223             if (caretOffset &lt; caretMinOffset || caretOffset &gt; caretMaxOffset || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;isLineBreak()))
1224                 continue;
1225 
1226             if (caretOffset &gt; caretMinOffset &amp;&amp; caretOffset &lt; caretMaxOffset) {
1227                 inlineBox = box;
1228                 return;
1229             }
1230 
1231             if (((caretOffset == caretMaxOffset) ^ (affinity == DOWNSTREAM))
1232                 || ((caretOffset == caretMinOffset) ^ (affinity == UPSTREAM))
<span class="line-modified">1233                 || (caretOffset == caretMaxOffset &amp;&amp; box-&gt;nextLeafOnLine() &amp;&amp; box-&gt;nextLeafOnLine()-&gt;isLineBreak()))</span>
1234                 break;
1235 
1236             candidate = box;
1237         }
1238         if (candidate &amp;&amp; candidate == textRenderer.lastTextBox() &amp;&amp; affinity == DOWNSTREAM) {
1239             box = searchAheadForBetterMatch(&amp;textRenderer);
1240             if (box)
1241                 caretOffset = box-&gt;caretMinOffset();
1242         }
1243         inlineBox = box ? box : candidate;
1244     } else {
1245         inlineBox = nullptr;
1246         if (canHaveChildrenForEditing(*deprecatedNode()) &amp;&amp; is&lt;RenderBlockFlow&gt;(*renderer) &amp;&amp; hasRenderedNonAnonymousDescendantsWithHeight(downcast&lt;RenderBlockFlow&gt;(*renderer))) {
1247             // Try a visually equivalent position with possibly opposite editability. This helps in case |this| is in
1248             // an editable block but surrounded by non-editable positions. It acts to negate the logic at the beginning
1249             // of RenderObject::createVisiblePosition().
1250             Position equivalent = downstreamIgnoringEditingBoundaries(*this);
1251             if (equivalent == *this) {
1252                 equivalent = upstreamIgnoringEditingBoundaries(*this);
1253                 if (equivalent == *this || downstreamIgnoringEditingBoundaries(equivalent) == *this)
1254                     return;
1255             }
1256 
1257             equivalent.getInlineBoxAndOffset(UPSTREAM, primaryDirection, inlineBox, caretOffset);
1258             return;
1259         }
1260         if (is&lt;RenderBox&gt;(*renderer)) {
1261             inlineBox = downcast&lt;RenderBox&gt;(*renderer).inlineBoxWrapper();
1262             if (!inlineBox || (caretOffset &gt; inlineBox-&gt;caretMinOffset() &amp;&amp; caretOffset &lt; inlineBox-&gt;caretMaxOffset()))
1263                 return;
1264         }
1265     }
1266 
1267     if (!inlineBox)
1268         return;
1269 
1270     unsigned char level = inlineBox-&gt;bidiLevel();
1271 
1272     if (inlineBox-&gt;direction() == primaryDirection) {
1273         if (caretOffset == inlineBox-&gt;caretRightmostOffset()) {
<span class="line-modified">1274             InlineBox* nextBox = inlineBox-&gt;nextLeafOnLine();</span>
1275             if (!nextBox || nextBox-&gt;bidiLevel() &gt;= level)
1276                 return;
1277 
1278             level = nextBox-&gt;bidiLevel();
1279             InlineBox* prevBox = inlineBox;
1280             do {
<span class="line-modified">1281                 prevBox = prevBox-&gt;previousLeafOnLine();</span>
1282             } while (prevBox &amp;&amp; prevBox-&gt;bidiLevel() &gt; level);
1283 
1284             if (prevBox &amp;&amp; prevBox-&gt;bidiLevel() == level)   // For example, abc FED 123 ^ CBA
1285                 return;
1286 
1287             // For example, abc 123 ^ CBA
<span class="line-modified">1288             while (InlineBox* nextBox = inlineBox-&gt;nextLeafOnLine()) {</span>
1289                 if (nextBox-&gt;bidiLevel() &lt; level)
1290                     break;
1291                 inlineBox = nextBox;
1292             }
1293             caretOffset = inlineBox-&gt;caretRightmostOffset();
1294         } else {
<span class="line-modified">1295             InlineBox* prevBox = inlineBox-&gt;previousLeafOnLine();</span>
1296             if (!prevBox || prevBox-&gt;bidiLevel() &gt;= level)
1297                 return;
1298 
1299             level = prevBox-&gt;bidiLevel();
1300             InlineBox* nextBox = inlineBox;
1301             do {
<span class="line-modified">1302                 nextBox = nextBox-&gt;nextLeafOnLine();</span>
1303             } while (nextBox &amp;&amp; nextBox-&gt;bidiLevel() &gt; level);
1304 
1305             if (nextBox &amp;&amp; nextBox-&gt;bidiLevel() == level)
1306                 return;
1307 
<span class="line-modified">1308             while (InlineBox* prevBox = inlineBox-&gt;previousLeafOnLine()) {</span>
1309                 if (prevBox-&gt;bidiLevel() &lt; level)
1310                     break;
1311                 inlineBox = prevBox;
1312             }
1313             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1314         }
1315         return;
1316     }
1317 
1318     if (caretOffset == inlineBox-&gt;caretLeftmostOffset()) {
<span class="line-modified">1319         InlineBox* prevBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak();</span>
1320         if (!prevBox || prevBox-&gt;bidiLevel() &lt; level) {
1321             // Left edge of a secondary run. Set to the right edge of the entire run.
<span class="line-modified">1322             while (InlineBox* nextBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
1323                 if (nextBox-&gt;bidiLevel() &lt; level)
1324                     break;
1325                 inlineBox = nextBox;
1326             }
1327             caretOffset = inlineBox-&gt;caretRightmostOffset();
1328         } else if (prevBox-&gt;bidiLevel() &gt; level) {
1329             // Right edge of a &quot;tertiary&quot; run. Set to the left edge of that run.
<span class="line-modified">1330             while (InlineBox* tertiaryBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak()) {</span>
1331                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1332                     break;
1333                 inlineBox = tertiaryBox;
1334             }
1335             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1336         }
1337     } else {
<span class="line-modified">1338         InlineBox* nextBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak();</span>
1339         if (!nextBox || nextBox-&gt;bidiLevel() &lt; level) {
1340             // Right edge of a secondary run. Set to the left edge of the entire run.
<span class="line-modified">1341             while (InlineBox* prevBox = inlineBox-&gt;previousLeafOnLineIgnoringLineBreak()) {</span>
1342                 if (prevBox-&gt;bidiLevel() &lt; level)
1343                     break;
1344                 inlineBox = prevBox;
1345             }
1346             caretOffset = inlineBox-&gt;caretLeftmostOffset();
1347         } else if (nextBox-&gt;bidiLevel() &gt; level) {
1348             // Left edge of a &quot;tertiary&quot; run. Set to the right edge of that run.
<span class="line-modified">1349             while (InlineBox* tertiaryBox = inlineBox-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
1350                 if (tertiaryBox-&gt;bidiLevel() &lt;= level)
1351                     break;
1352                 inlineBox = tertiaryBox;
1353             }
1354             caretOffset = inlineBox-&gt;caretRightmostOffset();
1355         }
1356     }
1357 }
1358 
1359 TextDirection Position::primaryDirection() const
1360 {
1361     if (!m_anchorNode-&gt;renderer())
1362         return TextDirection::LTR;
1363     if (auto* blockFlow = lineageOfType&lt;RenderBlockFlow&gt;(*m_anchorNode-&gt;renderer()).first())
1364         return blockFlow-&gt;style().direction();
1365     return TextDirection::LTR;
1366 }
1367 
1368 #if ENABLE(TREE_DEBUGGING)
1369 
</pre>
<hr />
<pre>
1552 
1553     stream.dumpProperty(&quot;anchor node&quot;, position.anchorNode());
1554     stream.dumpProperty(&quot;offset&quot;, position.offsetInContainerNode());
1555     stream.dumpProperty(&quot;anchor type&quot;, position.anchorType());
1556 
1557     return stream;
1558 }
1559 
1560 RefPtr&lt;Node&gt; commonShadowIncludingAncestor(const Position&amp; a, const Position&amp; b)
1561 {
1562     auto* commonScope = commonTreeScope(a.containerNode(), b.containerNode());
1563     if (!commonScope)
1564         return nullptr;
1565     auto* nodeA = commonScope-&gt;ancestorNodeInThisScope(a.containerNode());
1566     ASSERT(nodeA);
1567     auto* nodeB = commonScope-&gt;ancestorNodeInThisScope(b.containerNode());
1568     ASSERT(nodeB);
1569     return Range::commonAncestorContainer(nodeA, nodeB);
1570 }
1571 
<span class="line-added">1572 Position positionInParentBeforeNode(Node* node)</span>
<span class="line-added">1573 {</span>
<span class="line-added">1574     auto* ancestor = node-&gt;parentNode();</span>
<span class="line-added">1575     while (ancestor &amp;&amp; editingIgnoresContent(*ancestor)) {</span>
<span class="line-added">1576         node = ancestor;</span>
<span class="line-added">1577         ancestor = ancestor-&gt;parentNode();</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579     ASSERT(ancestor);</span>
<span class="line-added">1580     return Position(ancestor, node-&gt;computeNodeIndex(), Position::PositionIsOffsetInAnchor);</span>
<span class="line-added">1581 }</span>
<span class="line-added">1582 </span>
<span class="line-added">1583 Position positionInParentAfterNode(Node* node)</span>
<span class="line-added">1584 {</span>
<span class="line-added">1585     auto* ancestor = node-&gt;parentNode();</span>
<span class="line-added">1586     while (ancestor &amp;&amp; editingIgnoresContent(*ancestor)) {</span>
<span class="line-added">1587         node = ancestor;</span>
<span class="line-added">1588         ancestor = ancestor-&gt;parentNode();</span>
<span class="line-added">1589     }</span>
<span class="line-added">1590     ASSERT(ancestor);</span>
<span class="line-added">1591     return Position(ancestor, node-&gt;computeNodeIndex() + 1, Position::PositionIsOffsetInAnchor);</span>
<span class="line-added">1592 }</span>
<span class="line-added">1593 </span>
1594 } // namespace WebCore
1595 
1596 #if ENABLE(TREE_DEBUGGING)
1597 
1598 void showTree(const WebCore::Position&amp; pos)
1599 {
1600     pos.showTreeForThis();
1601 }
1602 
1603 void showTree(const WebCore::Position* pos)
1604 {
1605     if (pos)
1606         pos-&gt;showTreeForThis();
1607 }
1608 
1609 #endif
</pre>
</td>
</tr>
</table>
<center><a href="PopStateEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Position.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
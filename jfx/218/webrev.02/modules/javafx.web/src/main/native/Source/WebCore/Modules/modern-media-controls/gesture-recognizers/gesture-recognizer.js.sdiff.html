<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/gesture-recognizers/gesture-recognizer.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../controls/slider.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../media/pip-support.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/gesture-recognizers/gesture-recognizer.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-removed">  1 </span>
  2 class GestureRecognizer
  3 {
  4 
  5     constructor(target = null, delegate = null)
  6     {
<span class="line-modified">  7         this._targetTouches = [];</span>
  8 
  9         this.modifierKeys = {
 10             alt : false,
 11             ctrl : false,
 12             meta : false,
 13             shift : false
 14         };
 15 
 16         this._state = GestureRecognizer.States.Possible;
 17         this._enabled = true;
 18 
 19         this.target = target;
 20         this.delegate = delegate;
 21     }
 22 
 23     // Public
 24 
 25     get state()
 26     {
 27         return this._state;
</pre>
<hr />
<pre>
 36         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerStateDidChange === &quot;function&quot;)
 37             this.delegate.gestureRecognizerStateDidChange(this);
 38     }
 39 
 40     get target()
 41     {
 42         return this._target;
 43     }
 44 
 45     set target(target)
 46     {
 47         if (!target || this._target === target)
 48             return;
 49 
 50         this._target = target;
 51         this._initRecognizer();
 52     }
 53 
 54     get numberOfTouches()
 55     {
<span class="line-modified"> 56         return this._targetTouches.length;</span>
 57     }
 58 
 59     get enabled()
 60     {
 61         return this._enabled;
 62     }
 63 
 64     set enabled(enabled)
 65     {
 66         if (this._enabled === enabled)
 67             return;
 68 
 69         this._enabled = enabled;
 70 
 71         if (!enabled) {
 72             if (this.numberOfTouches === 0) {
 73                 this._removeTrackingListeners();
 74                 this.reset();
 75             } else
 76                 this.enterCancelledState();
 77         }
 78 
 79         this._updateBaseListeners();
 80     }
 81 
 82     reset()
 83     {
 84         // Implemented by subclasses.
 85     }
 86 
 87     locationInElement(element)
 88     {
 89         const p = new DOMPoint;
<span class="line-modified"> 90         const touches = this._targetTouches;</span>
<span class="line-modified"> 91         const count = touches.length;</span>
<span class="line-modified"> 92         for (let i = 0; i &lt; count; ++i) {</span>
<span class="line-modified"> 93             const touch = touches[i];</span>
<span class="line-modified"> 94             p.x += touch.pageX;</span>
<span class="line-modified"> 95             p.y += touch.pageY;</span>
<span class="line-modified"> 96         }</span>
 97         p.x /= count;
 98         p.y /= count;
 99 
100         if (!element)
101             return p;
102 
103         // FIXME: are WebKitPoint and DOMPoint interchangeable?
104         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(p.x, p.y));
105         return new DOMPoint(wkPoint.x, wkPoint.y);
106     }
107 
108     locationInClient()
109     {
110         const p = new DOMPoint;
<span class="line-modified">111         const touches = this._targetTouches;</span>
<span class="line-modified">112         const count = touches.length;</span>
<span class="line-modified">113         for (let i = 0; i &lt; count; ++i) {</span>
<span class="line-modified">114             const touch = touches[i];</span>
<span class="line-modified">115             p.x += touch.clientX;</span>
<span class="line-modified">116             p.y += touch.clientY;</span>
<span class="line-modified">117         }</span>
118         p.x /= count;
119         p.y /= count;
120 
121         return p;
122     }
123 
<span class="line-removed">124     locationOfTouchInElement(touchIndex, element)</span>
<span class="line-removed">125     {</span>
<span class="line-removed">126         const touch = this._targetTouches[touchIndex];</span>
<span class="line-removed">127         if (!touch)</span>
<span class="line-removed">128             return new DOMPoint;</span>
<span class="line-removed">129 </span>
<span class="line-removed">130         const touchLocation = new DOMPoint(touch.pageX, touch.pageY);</span>
<span class="line-removed">131         if (!element)</span>
<span class="line-removed">132             return touchLocation;</span>
<span class="line-removed">133 </span>
<span class="line-removed">134         // FIXME: are WebKitPoint and DOMPoint interchangeable?</span>
<span class="line-removed">135         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(touchLocation.x, touchLocation.y));</span>
<span class="line-removed">136         return new DOMPoint(wkPoint.x, wkPoint.y);</span>
<span class="line-removed">137     }</span>
<span class="line-removed">138 </span>
139     touchesBegan(event)
140     {
141         if (event.currentTarget !== this._target)
142             return;
143 
<span class="line-modified">144         window.addEventListener(GestureRecognizer.Events.TouchMove, this, true);</span>
<span class="line-modified">145         window.addEventListener(GestureRecognizer.Events.TouchEnd, this, true);</span>
<span class="line-modified">146         window.addEventListener(GestureRecognizer.Events.TouchCancel, this, true);</span>
147         this.enterPossibleState();
148     }
149 
150     touchesMoved(event)
151     {
152         // Implemented by subclasses.
153     }
154 
155     touchesEnded(event)
156     {
157         // Implemented by subclasses.
158     }
159 
160     touchesCancelled(event)
161     {
162         // Implemented by subclasses.
163     }
164 
165     gestureBegan(event)
166     {
</pre>
<hr />
<pre>
218     }
219 
220     enterChangedState()
221     {
222         this.state = GestureRecognizer.States.Changed;
223     }
224 
225     enterRecognizedState()
226     {
227         this.state = GestureRecognizer.States.Recognized;
228     }
229 
230     // Protected
231 
232     handleEvent(event)
233     {
234         this._updateTargetTouches(event);
235         this._updateKeyboardModifiers(event);
236 
237         switch (event.type) {
<span class="line-modified">238         case GestureRecognizer.Events.TouchStart:</span>
239             this.touchesBegan(event);
240             break;
<span class="line-modified">241         case GestureRecognizer.Events.TouchMove:</span>
242             this.touchesMoved(event);
243             break;
<span class="line-modified">244         case GestureRecognizer.Events.TouchEnd:</span>
245             this.touchesEnded(event);
246             break;
<span class="line-modified">247         case GestureRecognizer.Events.TouchCancel:</span>
248             this.touchesCancelled(event);
249             break;
250         case GestureRecognizer.Events.GestureStart:
251             this.gestureBegan(event);
252             break;
253         case GestureRecognizer.Events.GestureChange:
254             this.gestureChanged(event);
255             break;
256         case GestureRecognizer.Events.GestureEnd:
257             this.gestureEnded(event);
258             break;
259         }
260     }
261 
262     // Private
263 
264     _initRecognizer()
265     {
266         this.reset();
267         this.state = GestureRecognizer.States.Possible;
268 
269         this._updateBaseListeners();
270     }
271 
272     _updateBaseListeners()
273     {
274         if (!this._target)
275             return;
276 
277         if (this._enabled) {
<span class="line-modified">278             this._target.addEventListener(GestureRecognizer.Events.TouchStart, this);</span>
279             if (GestureRecognizer.SupportsGestures)
280                 this._target.addEventListener(GestureRecognizer.Events.GestureStart, this);
281         } else {
<span class="line-modified">282             this._target.removeEventListener(GestureRecognizer.Events.TouchStart, this);</span>
283             if (GestureRecognizer.SupportsGestures)
284                 this._target.removeEventListener(GestureRecognizer.Events.GestureStart, this);
285         }
286     }
287 
288     _removeTrackingListeners()
289     {
<span class="line-modified">290         window.removeEventListener(GestureRecognizer.Events.TouchMove, this, true);</span>
<span class="line-modified">291         window.removeEventListener(GestureRecognizer.Events.TouchEnd, this, true);</span>

292         this._target.removeEventListener(GestureRecognizer.Events.GestureChange, this, true);
293         this._target.removeEventListener(GestureRecognizer.Events.GestureEnd, this, true);


294     }
295 
296     _updateTargetTouches(event)
297     {
<span class="line-modified">298         if (!GestureRecognizer.SupportsTouches) {</span>
<span class="line-removed">299             if (event.type === GestureRecognizer.Events.TouchEnd)</span>
<span class="line-removed">300                 this._targetTouches = [];</span>
<span class="line-removed">301             else</span>
<span class="line-removed">302                 this._targetTouches = [event];</span>
<span class="line-removed">303             return;</span>
<span class="line-removed">304         }</span>
<span class="line-removed">305 </span>
<span class="line-removed">306         if (!(event instanceof TouchEvent))</span>
307             return;
308 
<span class="line-modified">309         // With a touchstart event, event.targetTouches is accurate so</span>
<span class="line-modified">310         // we simply add all of those.</span>
<span class="line-removed">311         if (event.type === GestureRecognizer.Events.TouchStart) {</span>
<span class="line-removed">312             this._targetTouches = [];</span>
<span class="line-removed">313             let touches = event.targetTouches;</span>
<span class="line-removed">314             for (let i = 0, count = touches.length; i &lt; count; ++i)</span>
<span class="line-removed">315                 this._targetTouches.push(touches[i]);</span>
316             return;
317         }
318 
<span class="line-modified">319         // With a touchmove event, the target is window so event.targetTouches is</span>
<span class="line-modified">320         // inaccurate so we add all touches that we knew about previously.</span>
<span class="line-removed">321         if (event.type === GestureRecognizer.Events.TouchMove) {</span>
<span class="line-removed">322             let targetIdentifiers = this._targetTouches.map(function(touch) {</span>
<span class="line-removed">323                 return touch.identifier;</span>
<span class="line-removed">324             });</span>
<span class="line-removed">325 </span>
<span class="line-removed">326             this._targetTouches = [];</span>
<span class="line-removed">327             let touches = event.touches;</span>
<span class="line-removed">328             for (let i = 0, count = touches.length; i &lt; count; ++i) {</span>
<span class="line-removed">329                 let touch = touches[i];</span>
<span class="line-removed">330                 if (targetIdentifiers.indexOf(touch.identifier) !== -1)</span>
<span class="line-removed">331                     this._targetTouches.push(touch);</span>
<span class="line-removed">332             }</span>
333             return;
334         }
335 
<span class="line-modified">336         // With a touchend or touchcancel event, we only keep the existing touches</span>
<span class="line-removed">337         // that are also found in event.touches.</span>
<span class="line-removed">338         let allTouches = event.touches;</span>
<span class="line-removed">339         let existingIdentifiers = [];</span>
<span class="line-removed">340         for (let i = 0, count = allTouches.length; i &lt; count; ++i)</span>
<span class="line-removed">341             existingIdentifiers.push(allTouches[i].identifier);</span>
<span class="line-removed">342 </span>
<span class="line-removed">343         this._targetTouches = this._targetTouches.filter(function(touch) {</span>
<span class="line-removed">344             return existingIdentifiers.indexOf(touch.identifier) !== -1;</span>
<span class="line-removed">345         });</span>
346     }
347 
348     _updateKeyboardModifiers(event)
349     {
350         this.modifierKeys.alt = event.altKey;
351         this.modifierKeys.ctrl = event.ctrlKey;
352         this.modifierKeys.meta = event.metaKey;
353         this.modifierKeys.shift = event.shiftKey;
354     }
355 
356 }
357 
358 GestureRecognizer.SupportsTouches = &quot;createTouch&quot; in document;
359 GestureRecognizer.SupportsGestures = !!window.GestureEvent;
360 
361 GestureRecognizer.States = {
362     Possible   : &quot;possible&quot;,
363     Began      : &quot;began&quot;,
364     Changed    : &quot;changed&quot;,
365     Ended      : &quot;ended&quot;,
366     Cancelled  : &quot;cancelled&quot;,
367     Failed     : &quot;failed&quot;,
368     Recognized : &quot;ended&quot;
369 };
370 
371 GestureRecognizer.Events = {
<span class="line-modified">372     TouchStart     : GestureRecognizer.SupportsTouches ? &quot;touchstart&quot; : &quot;mousedown&quot;,</span>
<span class="line-modified">373     TouchMove      : GestureRecognizer.SupportsTouches ? &quot;touchmove&quot; : &quot;mousemove&quot;,</span>
<span class="line-modified">374     TouchEnd       : GestureRecognizer.SupportsTouches ? &quot;touchend&quot; : &quot;mouseup&quot;,</span>
<span class="line-modified">375     TouchCancel    : &quot;touchcancel&quot;,</span>
376     GestureStart   : &quot;gesturestart&quot;,
377     GestureChange  : &quot;gesturechange&quot;,
378     GestureEnd     : &quot;gestureend&quot;
379 };
</pre>
</td>
<td>
<hr />
<pre>

  1 class GestureRecognizer
  2 {
  3 
  4     constructor(target = null, delegate = null)
  5     {
<span class="line-modified">  6         this._targetPointers = new Map;</span>
  7 
  8         this.modifierKeys = {
  9             alt : false,
 10             ctrl : false,
 11             meta : false,
 12             shift : false
 13         };
 14 
 15         this._state = GestureRecognizer.States.Possible;
 16         this._enabled = true;
 17 
 18         this.target = target;
 19         this.delegate = delegate;
 20     }
 21 
 22     // Public
 23 
 24     get state()
 25     {
 26         return this._state;
</pre>
<hr />
<pre>
 35         if (this.delegate &amp;&amp; typeof this.delegate.gestureRecognizerStateDidChange === &quot;function&quot;)
 36             this.delegate.gestureRecognizerStateDidChange(this);
 37     }
 38 
 39     get target()
 40     {
 41         return this._target;
 42     }
 43 
 44     set target(target)
 45     {
 46         if (!target || this._target === target)
 47             return;
 48 
 49         this._target = target;
 50         this._initRecognizer();
 51     }
 52 
 53     get numberOfTouches()
 54     {
<span class="line-modified"> 55         return this._targetPointers.size;</span>
 56     }
 57 
 58     get enabled()
 59     {
 60         return this._enabled;
 61     }
 62 
 63     set enabled(enabled)
 64     {
 65         if (this._enabled === enabled)
 66             return;
 67 
 68         this._enabled = enabled;
 69 
 70         if (!enabled) {
 71             if (this.numberOfTouches === 0) {
 72                 this._removeTrackingListeners();
 73                 this.reset();
 74             } else
 75                 this.enterCancelledState();
 76         }
 77 
 78         this._updateBaseListeners();
 79     }
 80 
 81     reset()
 82     {
 83         // Implemented by subclasses.
 84     }
 85 
 86     locationInElement(element)
 87     {
 88         const p = new DOMPoint;
<span class="line-modified"> 89         const count = this._targetPointers.size;</span>
<span class="line-modified"> 90         if (!count)</span>
<span class="line-modified"> 91             return p;</span>
<span class="line-modified"> 92         this._targetPointers.forEach(function (pointer) {</span>
<span class="line-modified"> 93             p.x += pointer.pageX;</span>
<span class="line-modified"> 94             p.y += pointer.pageY;</span>
<span class="line-modified"> 95         });</span>
 96         p.x /= count;
 97         p.y /= count;
 98 
 99         if (!element)
100             return p;
101 
102         // FIXME: are WebKitPoint and DOMPoint interchangeable?
103         const wkPoint = window.webkitConvertPointFromPageToNode(element, new WebKitPoint(p.x, p.y));
104         return new DOMPoint(wkPoint.x, wkPoint.y);
105     }
106 
107     locationInClient()
108     {
109         const p = new DOMPoint;
<span class="line-modified">110         const count = this._targetPointers.size;</span>
<span class="line-modified">111         if (!count)</span>
<span class="line-modified">112             return p;</span>
<span class="line-modified">113         this._targetPointers.forEach(function (pointer) {</span>
<span class="line-modified">114             p.x += pointer.clientX;</span>
<span class="line-modified">115             p.y += pointer.clientY;</span>
<span class="line-modified">116         });</span>
117         p.x /= count;
118         p.y /= count;
119 
120         return p;
121     }
122 















123     touchesBegan(event)
124     {
125         if (event.currentTarget !== this._target)
126             return;
127 
<span class="line-modified">128         window.addEventListener(GestureRecognizer.Events.PointerMove, this, true);</span>
<span class="line-modified">129         window.addEventListener(GestureRecognizer.Events.PointerUp, this, true);</span>
<span class="line-modified">130         window.addEventListener(GestureRecognizer.Events.PointerCancel, this, true);</span>
131         this.enterPossibleState();
132     }
133 
134     touchesMoved(event)
135     {
136         // Implemented by subclasses.
137     }
138 
139     touchesEnded(event)
140     {
141         // Implemented by subclasses.
142     }
143 
144     touchesCancelled(event)
145     {
146         // Implemented by subclasses.
147     }
148 
149     gestureBegan(event)
150     {
</pre>
<hr />
<pre>
202     }
203 
204     enterChangedState()
205     {
206         this.state = GestureRecognizer.States.Changed;
207     }
208 
209     enterRecognizedState()
210     {
211         this.state = GestureRecognizer.States.Recognized;
212     }
213 
214     // Protected
215 
216     handleEvent(event)
217     {
218         this._updateTargetTouches(event);
219         this._updateKeyboardModifiers(event);
220 
221         switch (event.type) {
<span class="line-modified">222         case GestureRecognizer.Events.PointerDown:</span>
223             this.touchesBegan(event);
224             break;
<span class="line-modified">225         case GestureRecognizer.Events.PointerMove:</span>
226             this.touchesMoved(event);
227             break;
<span class="line-modified">228         case GestureRecognizer.Events.PointerUp:</span>
229             this.touchesEnded(event);
230             break;
<span class="line-modified">231         case GestureRecognizer.Events.PointerCancel:</span>
232             this.touchesCancelled(event);
233             break;
234         case GestureRecognizer.Events.GestureStart:
235             this.gestureBegan(event);
236             break;
237         case GestureRecognizer.Events.GestureChange:
238             this.gestureChanged(event);
239             break;
240         case GestureRecognizer.Events.GestureEnd:
241             this.gestureEnded(event);
242             break;
243         }
244     }
245 
246     // Private
247 
248     _initRecognizer()
249     {
250         this.reset();
251         this.state = GestureRecognizer.States.Possible;
252 
253         this._updateBaseListeners();
254     }
255 
256     _updateBaseListeners()
257     {
258         if (!this._target)
259             return;
260 
261         if (this._enabled) {
<span class="line-modified">262             this._target.addEventListener(GestureRecognizer.Events.PointerDown, this);</span>
263             if (GestureRecognizer.SupportsGestures)
264                 this._target.addEventListener(GestureRecognizer.Events.GestureStart, this);
265         } else {
<span class="line-modified">266             this._target.removeEventListener(GestureRecognizer.Events.PointerDown, this);</span>
267             if (GestureRecognizer.SupportsGestures)
268                 this._target.removeEventListener(GestureRecognizer.Events.GestureStart, this);
269         }
270     }
271 
272     _removeTrackingListeners()
273     {
<span class="line-modified">274         window.removeEventListener(GestureRecognizer.Events.PointerMove, this, true);</span>
<span class="line-modified">275         window.removeEventListener(GestureRecognizer.Events.PointerUp, this, true);</span>
<span class="line-added">276         window.removeEventListener(GestureRecognizer.Events.PointerCancel, this, true);</span>
277         this._target.removeEventListener(GestureRecognizer.Events.GestureChange, this, true);
278         this._target.removeEventListener(GestureRecognizer.Events.GestureEnd, this, true);
<span class="line-added">279 </span>
<span class="line-added">280         this._targetPointers = new Map;</span>
281     }
282 
283     _updateTargetTouches(event)
284     {
<span class="line-modified">285         if (!(event instanceof PointerEvent))</span>








286             return;
287 
<span class="line-modified">288         if (event.type === GestureRecognizer.Events.PointerDown) {</span>
<span class="line-modified">289             this._targetPointers.set(event.pointerId, event);</span>





290             return;
291         }
292 
<span class="line-modified">293         if (event.type === GestureRecognizer.Events.PointerMove) {</span>
<span class="line-modified">294             this._targetPointers.set(event.pointerId, event);</span>












295             return;
296         }
297 
<span class="line-modified">298         this._targetPointers.delete(event.pointerId);</span>









299     }
300 
301     _updateKeyboardModifiers(event)
302     {
303         this.modifierKeys.alt = event.altKey;
304         this.modifierKeys.ctrl = event.ctrlKey;
305         this.modifierKeys.meta = event.metaKey;
306         this.modifierKeys.shift = event.shiftKey;
307     }
308 
309 }
310 
311 GestureRecognizer.SupportsTouches = &quot;createTouch&quot; in document;
312 GestureRecognizer.SupportsGestures = !!window.GestureEvent;
313 
314 GestureRecognizer.States = {
315     Possible   : &quot;possible&quot;,
316     Began      : &quot;began&quot;,
317     Changed    : &quot;changed&quot;,
318     Ended      : &quot;ended&quot;,
319     Cancelled  : &quot;cancelled&quot;,
320     Failed     : &quot;failed&quot;,
321     Recognized : &quot;ended&quot;
322 };
323 
324 GestureRecognizer.Events = {
<span class="line-modified">325     PointerDown    : &quot;pointerdown&quot;,</span>
<span class="line-modified">326     PointerMove    : &quot;pointermove&quot;,</span>
<span class="line-modified">327     PointerUp      : &quot;pointerup&quot;,</span>
<span class="line-modified">328     PointerCancel  : &quot;pointercancel&quot;,</span>
329     GestureStart   : &quot;gesturestart&quot;,
330     GestureChange  : &quot;gesturechange&quot;,
331     GestureEnd     : &quot;gestureend&quot;
332 };
</pre>
</td>
</tr>
</table>
<center><a href="../controls/slider.js.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../media/pip-support.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
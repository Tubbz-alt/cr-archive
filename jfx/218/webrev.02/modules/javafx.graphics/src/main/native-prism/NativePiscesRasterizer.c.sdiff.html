<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Dasher.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PathConsumer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 28 #include &lt;stddef.h&gt;
 29 #endif
 30 #include &quot;com_sun_prism_impl_shape_NativePiscesRasterizer.h&quot;
 31 
 32 #include &quot;Renderer.h&quot;
 33 #include &quot;Stroker.h&quot;
 34 #include &quot;Dasher.h&quot;
 35 #include &quot;Transformer.h&quot;
 36 #include &quot;AlphaConsumer.h&quot;
 37 
 38 #define SEG(T) com_sun_prism_impl_shape_NativePiscesRasterizer_SEG_ ## T
 39 
 40 #define SEG_MOVETO   SEG(MOVETO)
 41 #define SEG_LINETO   SEG(LINETO)
 42 #define SEG_QUADTO   SEG(QUADTO)
 43 #define SEG_CUBICTO  SEG(CUBICTO)
 44 #define SEG_CLOSE    SEG(CLOSE)
 45 
 46 #define NPException    &quot;java/lang/NullPointerException&quot;
 47 #define AIOOBException &quot;java/lang/ArrayIndexOutOfBoundsException&quot;

 48 #define IError         &quot;java/lang/InternalError&quot;
 49 
 50 #define CheckNPE(env, a)                                \
 51     do {                                                \
 52         if (a == NULL) {                                \
 53             Throw(env, NPException, #a);                \
 54             return;                                     \
 55         }                                               \
 56     } while (0)
 57 
 58 #define CheckLen(env, a, len)                           \
 59     do {                                                \
 60         if ((*env)-&gt;GetArrayLength(env, a) &lt; len) {     \
 61             Throw(env, AIOOBException, #a);             \
 62             return;                                     \
 63         }                                               \
 64     } while (0)
 65 
 66 
 67 static void Throw(JNIEnv *env, char *throw_class_name, char *detail) {
 68     jclass throw_class = (*env)-&gt;FindClass(env, throw_class_name);
 69     if (throw_class != NULL) {
 70         (*env)-&gt;ThrowNew(env, throw_class, detail);
 71     }
 72 }
 73 













 74 static char * feedConsumer
 75     (JNIEnv *env, PathConsumer *consumer,
 76      jfloatArray coordsArray, jint coordSize,
 77      jbyteArray commandsArray, jint numCommands)
 78 {

 79     char *failure = NULL;
 80     jfloat *coords;
 81 
 82     coords = (*env)-&gt;GetPrimitiveArrayCritical(env, coordsArray, 0);
 83     if (coords == NULL) {
 84         failure = &quot;&quot;;
 85     } else {
 86         jbyte *commands = (*env)-&gt;GetPrimitiveArrayCritical(env, commandsArray, 0);
 87         if (commands == NULL) {
 88             failure = &quot;&quot;;
 89         } else {
 90             jint cmdoff, coordoff = 0;
 91             for (cmdoff = 0; cmdoff &lt; numCommands &amp;&amp; failure == NULL; cmdoff++) {
 92                 switch (commands[cmdoff]) {
 93                     case SEG_MOVETO:
 94                         if (coordoff + 2 &gt; coordSize) {
 95                             failure = &quot;[not enough coordinates for moveTo&quot;;
 96                         } else {
<span class="line-modified"> 97                             consumer-&gt;moveTo(consumer,</span>
 98                                              coords[coordoff+0], coords[coordoff+1]);



 99                             coordoff += 2;
100                         }
101                         break;
102                     case SEG_LINETO:
103                         if (coordoff + 2 &gt; coordSize) {
104                             failure = &quot;[not enough coordinates for lineTo&quot;;
105                         } else {
<span class="line-modified">106                             consumer-&gt;lineTo(consumer,</span>
107                                              coords[coordoff+0], coords[coordoff+1]);



108                             coordoff += 2;
109                         }
110                         break;
111                     case SEG_QUADTO:
112                         if (coordoff + 4 &gt; coordSize) {
113                             failure = &quot;[not enough coordinates for quadTo&quot;;
114                         } else {
<span class="line-modified">115                             consumer-&gt;quadTo(consumer,</span>
116                                              coords[coordoff+0], coords[coordoff+1],
117                                              coords[coordoff+2], coords[coordoff+3]);



118                             coordoff += 4;
119                         }
120                         break;
121                     case SEG_CUBICTO:
122                         if (coordoff + 6 &gt; coordSize) {
123                             failure = &quot;[not enough coordinates for curveTo&quot;;
124                         } else {
<span class="line-modified">125                             consumer-&gt;curveTo(consumer,</span>
126                                               coords[coordoff+0], coords[coordoff+1],
127                                               coords[coordoff+2], coords[coordoff+3],
128                                               coords[coordoff+4], coords[coordoff+5]);



129                             coordoff += 6;
130                         }
131                         break;
132                     case SEG_CLOSE:
<span class="line-modified">133                         consumer-&gt;closePath(consumer);</span>



134                         break;
135                     default:
136                         failure = &quot;unrecognized Path segment&quot;;
137                         break;
138                 }
139             }
140             (*env)-&gt;ReleasePrimitiveArrayCritical(env, commandsArray, commands, JNI_ABORT);
141         }
142         (*env)-&gt;ReleasePrimitiveArrayCritical(env, coordsArray, coords, JNI_ABORT);
143         if (failure == NULL) {
<span class="line-modified">144             consumer-&gt;pathDone(consumer);</span>



145         }
146     }
147     return failure;
148 }
149 
150 /*
151  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
152  * Method:    init
153  * Signature: (II)V
154  */
155 JNIEXPORT void JNICALL
156 Java_com_sun_prism_impl_shape_NativePiscesRasterizer_init
157     (JNIEnv *env, jclass klass,
158      jint subpixelLgPositionsX, jint subpixelLgPositionsY)
159 {
160     Renderer_setup(subpixelLgPositionsX, subpixelLgPositionsY);
161 }
162 
163 /*
164  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
</pre>
<hr />
<pre>
194                    nonzero ? WIND_NON_ZERO : WIND_EVEN_ODD);
195     consumer = Transformer_init(&amp;transformer, &amp;renderer.consumer,
196                                 mxx, mxy, mxt, myx, myy, myt);
197     failure = feedConsumer(env, consumer,
198                            coordsArray, coordSize, commandsArray, numCommands);
199     if (failure == NULL) {
200         Renderer_getOutputBounds(&amp;renderer, bounds);
201         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
202         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
203             AlphaConsumer ac = {
204                 bounds[0],
205                 bounds[1],
206                 bounds[2] - bounds[0],
207                 bounds[3] - bounds[1],
208             };
209             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
210                 Throw(env, AIOOBException, &quot;maskArray&quot;);
211             } else {
212                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
213                 if (ac.alphas != NULL) {
<span class="line-modified">214                     Renderer_produceAlphas(&amp;renderer, &amp;ac);</span>







215                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
216                 }
217             }
218         }
219     } else if (*failure != 0) {
220         if (*failure == &#39;[&#39;) {
221             Throw(env, AIOOBException, failure + 1);
222         } else {
223             Throw(env, IError, failure);
224         }
225     }
226     Renderer_destroy(&amp;renderer);
227 }
228 
229 /*
230  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
231  * Method:    produceStrokeAlphas
232  * Signature: ([F[BIFIIF[FFDDDDDD[I[B)V
233  */
234 JNIEXPORT void JNICALL
</pre>
<hr />
<pre>
283     if (dashArray != NULL) {
284         (*env)-&gt;ReleasePrimitiveArrayCritical(env, dashArray, dashes, JNI_ABORT);
285         Dasher_destroy(&amp;dasher);
286     }
287     Stroker_destroy(&amp;stroker);
288     if (failure == NULL) {
289         Renderer_getOutputBounds(&amp;renderer, bounds);
290         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
291         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
292             AlphaConsumer ac = {
293                 bounds[0],
294                 bounds[1],
295                 bounds[2] - bounds[0],
296                 bounds[3] - bounds[1],
297             };
298             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
299                 Throw(env, AIOOBException, &quot;Mask&quot;);
300             } else {
301                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
302                 if (ac.alphas != NULL) {
<span class="line-modified">303                     Renderer_produceAlphas(&amp;renderer, &amp;ac);</span>







304                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
305                 }
306             }
307         }
308     } else if (*failure != 0) {
309         if (*failure == &#39;[&#39;) {
310             Throw(env, AIOOBException, failure + 1);
311         } else {
312             Throw(env, IError, failure);
313         }
314     }
315     Renderer_destroy(&amp;renderer);
316 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 28 #include &lt;stddef.h&gt;
 29 #endif
 30 #include &quot;com_sun_prism_impl_shape_NativePiscesRasterizer.h&quot;
 31 
 32 #include &quot;Renderer.h&quot;
 33 #include &quot;Stroker.h&quot;
 34 #include &quot;Dasher.h&quot;
 35 #include &quot;Transformer.h&quot;
 36 #include &quot;AlphaConsumer.h&quot;
 37 
 38 #define SEG(T) com_sun_prism_impl_shape_NativePiscesRasterizer_SEG_ ## T
 39 
 40 #define SEG_MOVETO   SEG(MOVETO)
 41 #define SEG_LINETO   SEG(LINETO)
 42 #define SEG_QUADTO   SEG(QUADTO)
 43 #define SEG_CUBICTO  SEG(CUBICTO)
 44 #define SEG_CLOSE    SEG(CLOSE)
 45 
 46 #define NPException    &quot;java/lang/NullPointerException&quot;
 47 #define AIOOBException &quot;java/lang/ArrayIndexOutOfBoundsException&quot;
<span class="line-added"> 48 #define OOMError       &quot;java/lang/OutOfMemoryError&quot;</span>
 49 #define IError         &quot;java/lang/InternalError&quot;
 50 
 51 #define CheckNPE(env, a)                                \
 52     do {                                                \
 53         if (a == NULL) {                                \
 54             Throw(env, NPException, #a);                \
 55             return;                                     \
 56         }                                               \
 57     } while (0)
 58 
 59 #define CheckLen(env, a, len)                           \
 60     do {                                                \
 61         if ((*env)-&gt;GetArrayLength(env, a) &lt; len) {     \
 62             Throw(env, AIOOBException, #a);             \
 63             return;                                     \
 64         }                                               \
 65     } while (0)
 66 
 67 
 68 static void Throw(JNIEnv *env, char *throw_class_name, char *detail) {
 69     jclass throw_class = (*env)-&gt;FindClass(env, throw_class_name);
 70     if (throw_class != NULL) {
 71         (*env)-&gt;ThrowNew(env, throw_class, detail);
 72     }
 73 }
 74 
<span class="line-added"> 75 static char * errorToString(jint errorCode) {</span>
<span class="line-added"> 76     switch (errorCode) {</span>
<span class="line-added"> 77         case ERROR_NONE:</span>
<span class="line-added"> 78             return NULL;</span>
<span class="line-added"> 79         case ERROR_OOM:</span>
<span class="line-added"> 80             return &quot;Out of Memory&quot;;</span>
<span class="line-added"> 81         case ERROR_AIOOBE:</span>
<span class="line-added"> 82             return &quot;[PathConsumer&quot;;</span>
<span class="line-added"> 83         default:</span>
<span class="line-added"> 84             return &quot;Unknown error&quot;;</span>
<span class="line-added"> 85     }</span>
<span class="line-added"> 86 }</span>
<span class="line-added"> 87 </span>
 88 static char * feedConsumer
 89     (JNIEnv *env, PathConsumer *consumer,
 90      jfloatArray coordsArray, jint coordSize,
 91      jbyteArray commandsArray, jint numCommands)
 92 {
<span class="line-added"> 93     jint status = ERROR_NONE;</span>
 94     char *failure = NULL;
 95     jfloat *coords;
 96 
 97     coords = (*env)-&gt;GetPrimitiveArrayCritical(env, coordsArray, 0);
 98     if (coords == NULL) {
 99         failure = &quot;&quot;;
100     } else {
101         jbyte *commands = (*env)-&gt;GetPrimitiveArrayCritical(env, commandsArray, 0);
102         if (commands == NULL) {
103             failure = &quot;&quot;;
104         } else {
105             jint cmdoff, coordoff = 0;
106             for (cmdoff = 0; cmdoff &lt; numCommands &amp;&amp; failure == NULL; cmdoff++) {
107                 switch (commands[cmdoff]) {
108                     case SEG_MOVETO:
109                         if (coordoff + 2 &gt; coordSize) {
110                             failure = &quot;[not enough coordinates for moveTo&quot;;
111                         } else {
<span class="line-modified">112                             status = consumer-&gt;moveTo(consumer,</span>
113                                              coords[coordoff+0], coords[coordoff+1]);
<span class="line-added">114                             if (status != ERROR_NONE) {</span>
<span class="line-added">115                                 failure = errorToString(status);</span>
<span class="line-added">116                             }</span>
117                             coordoff += 2;
118                         }
119                         break;
120                     case SEG_LINETO:
121                         if (coordoff + 2 &gt; coordSize) {
122                             failure = &quot;[not enough coordinates for lineTo&quot;;
123                         } else {
<span class="line-modified">124                             status = consumer-&gt;lineTo(consumer,</span>
125                                              coords[coordoff+0], coords[coordoff+1]);
<span class="line-added">126                             if (status != ERROR_NONE) {</span>
<span class="line-added">127                                 failure = errorToString(status);</span>
<span class="line-added">128                             }</span>
129                             coordoff += 2;
130                         }
131                         break;
132                     case SEG_QUADTO:
133                         if (coordoff + 4 &gt; coordSize) {
134                             failure = &quot;[not enough coordinates for quadTo&quot;;
135                         } else {
<span class="line-modified">136                             status = consumer-&gt;quadTo(consumer,</span>
137                                              coords[coordoff+0], coords[coordoff+1],
138                                              coords[coordoff+2], coords[coordoff+3]);
<span class="line-added">139                             if (status != ERROR_NONE) {</span>
<span class="line-added">140                                 failure = errorToString(status);</span>
<span class="line-added">141                             }</span>
142                             coordoff += 4;
143                         }
144                         break;
145                     case SEG_CUBICTO:
146                         if (coordoff + 6 &gt; coordSize) {
147                             failure = &quot;[not enough coordinates for curveTo&quot;;
148                         } else {
<span class="line-modified">149                             status = consumer-&gt;curveTo(consumer,</span>
150                                               coords[coordoff+0], coords[coordoff+1],
151                                               coords[coordoff+2], coords[coordoff+3],
152                                               coords[coordoff+4], coords[coordoff+5]);
<span class="line-added">153                             if (status != ERROR_NONE) {</span>
<span class="line-added">154                                 failure = errorToString(status);</span>
<span class="line-added">155                             }</span>
156                             coordoff += 6;
157                         }
158                         break;
159                     case SEG_CLOSE:
<span class="line-modified">160                         status = consumer-&gt;closePath(consumer);</span>
<span class="line-added">161                         if (status != ERROR_NONE) {</span>
<span class="line-added">162                             failure = errorToString(status);</span>
<span class="line-added">163                         }</span>
164                         break;
165                     default:
166                         failure = &quot;unrecognized Path segment&quot;;
167                         break;
168                 }
169             }
170             (*env)-&gt;ReleasePrimitiveArrayCritical(env, commandsArray, commands, JNI_ABORT);
171         }
172         (*env)-&gt;ReleasePrimitiveArrayCritical(env, coordsArray, coords, JNI_ABORT);
173         if (failure == NULL) {
<span class="line-modified">174             status = consumer-&gt;pathDone(consumer);</span>
<span class="line-added">175             if (status != ERROR_NONE) {</span>
<span class="line-added">176                 failure = errorToString(status);</span>
<span class="line-added">177             }</span>
178         }
179     }
180     return failure;
181 }
182 
183 /*
184  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
185  * Method:    init
186  * Signature: (II)V
187  */
188 JNIEXPORT void JNICALL
189 Java_com_sun_prism_impl_shape_NativePiscesRasterizer_init
190     (JNIEnv *env, jclass klass,
191      jint subpixelLgPositionsX, jint subpixelLgPositionsY)
192 {
193     Renderer_setup(subpixelLgPositionsX, subpixelLgPositionsY);
194 }
195 
196 /*
197  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
</pre>
<hr />
<pre>
227                    nonzero ? WIND_NON_ZERO : WIND_EVEN_ODD);
228     consumer = Transformer_init(&amp;transformer, &amp;renderer.consumer,
229                                 mxx, mxy, mxt, myx, myy, myt);
230     failure = feedConsumer(env, consumer,
231                            coordsArray, coordSize, commandsArray, numCommands);
232     if (failure == NULL) {
233         Renderer_getOutputBounds(&amp;renderer, bounds);
234         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
235         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
236             AlphaConsumer ac = {
237                 bounds[0],
238                 bounds[1],
239                 bounds[2] - bounds[0],
240                 bounds[3] - bounds[1],
241             };
242             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
243                 Throw(env, AIOOBException, &quot;maskArray&quot;);
244             } else {
245                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
246                 if (ac.alphas != NULL) {
<span class="line-modified">247                     jint status;</span>
<span class="line-added">248                     if ((status = Renderer_produceAlphas(&amp;renderer, &amp;ac)) != ERROR_NONE) {</span>
<span class="line-added">249                         if (status == ERROR_OOM) {</span>
<span class="line-added">250                             Throw(env, OOMError, &quot;produceAlphas&quot;);</span>
<span class="line-added">251                         } else {</span>
<span class="line-added">252                             Throw(env, AIOOBException, &quot;produceAlphas&quot;);</span>
<span class="line-added">253                         }</span>
<span class="line-added">254                     }</span>
255                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
256                 }
257             }
258         }
259     } else if (*failure != 0) {
260         if (*failure == &#39;[&#39;) {
261             Throw(env, AIOOBException, failure + 1);
262         } else {
263             Throw(env, IError, failure);
264         }
265     }
266     Renderer_destroy(&amp;renderer);
267 }
268 
269 /*
270  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
271  * Method:    produceStrokeAlphas
272  * Signature: ([F[BIFIIF[FFDDDDDD[I[B)V
273  */
274 JNIEXPORT void JNICALL
</pre>
<hr />
<pre>
323     if (dashArray != NULL) {
324         (*env)-&gt;ReleasePrimitiveArrayCritical(env, dashArray, dashes, JNI_ABORT);
325         Dasher_destroy(&amp;dasher);
326     }
327     Stroker_destroy(&amp;stroker);
328     if (failure == NULL) {
329         Renderer_getOutputBounds(&amp;renderer, bounds);
330         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
331         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
332             AlphaConsumer ac = {
333                 bounds[0],
334                 bounds[1],
335                 bounds[2] - bounds[0],
336                 bounds[3] - bounds[1],
337             };
338             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
339                 Throw(env, AIOOBException, &quot;Mask&quot;);
340             } else {
341                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
342                 if (ac.alphas != NULL) {
<span class="line-modified">343                     jint status;</span>
<span class="line-added">344                     if ((status = Renderer_produceAlphas(&amp;renderer, &amp;ac)) != ERROR_NONE) {</span>
<span class="line-added">345                         if (status == ERROR_OOM) {</span>
<span class="line-added">346                             Throw(env, OOMError, &quot;produceAlphas&quot;);</span>
<span class="line-added">347                         } else {</span>
<span class="line-added">348                             Throw(env, AIOOBException, &quot;produceAlphas&quot;);</span>
<span class="line-added">349                         }</span>
<span class="line-added">350                     }</span>
351                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
352                 }
353             }
354         }
355     } else if (*failure != 0) {
356         if (*failure == &#39;[&#39;) {
357             Throw(env, AIOOBException, failure + 1);
358         } else {
359             Throw(env, IError, failure);
360         }
361     }
362     Renderer_destroy(&amp;renderer);
363 }
</pre>
</td>
</tr>
</table>
<center><a href="Dasher.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="PathConsumer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
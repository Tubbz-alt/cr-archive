<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/native-prism/Renderer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;math.h&gt;
 27 #include &lt;stdlib.h&gt;
 28 #include &lt;jni.h&gt;
 29 #include &lt;string.h&gt;
 30 
 31 #include &quot;Helpers.h&quot;
 32 #include &quot;Renderer.h&quot;
 33 #include &quot;AlphaConsumer.h&quot;
 34 
 35 //public final class Renderer implements PathConsumer2D {
 36 
 37 //    private final class ScanlineIterator {
 38 
 39 #define this (*((ScanlineIterator *) pIterator))
 40 
 41 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 42                                    Renderer *pRenderer);
 43 
 44 static void ScanlineIterator_init(ScanlineIterator *pIterator,
 45                                   Renderer *pRenderer)
 46 {
 47     this.crossings = new_int(INIT_CROSSINGS_SIZE);
 48     this.crossingsSIZE = INIT_CROSSINGS_SIZE;
 49     this.edgePtrs = new_int(INIT_CROSSINGS_SIZE);
 50     this.edgePtrsSIZE = INIT_CROSSINGS_SIZE;
 51     ScanlineIterator_reset(pIterator, pRenderer);
 52 }
 53 
 54 static void ScanlineIterator_destroy(ScanlineIterator *pIterator) {
 55     free(this.crossings);
 56     this.crossings = NULL;
 57     this.crossingsSIZE = 0;
 58     free(this.edgePtrs);
 59     this.edgePtrs = NULL;
 60     this.edgePtrsSIZE = 0;
 61 }
 62 
 63 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 64                                    Renderer *pRenderer)
 65 {
 66     // We don&#39;t care if we clip some of the line off with ceil, since
 67     // no scan line crossings will be eliminated (in fact, the ceil is
 68     // the y of the first scan line crossing).
 69     this.nextY = pRenderer-&gt;sampleRowMin;
 70     this.edgeCount = 0;
 71 }
 72 
 73 static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
 74     jint i, ecur;
 75     jint *xings;
 76     // NOTE: make function that convert from y value to bucket idx?
 77     jint cury = this.nextY++;
 78     jint bucket = cury - pRenderer-&gt;boundsMinY;
 79     jint count = this.edgeCount;
 80     jint *ptrs = this.edgePtrs;
 81     jfloat *edges = pRenderer-&gt;edges;
 82     jint bucketcount = pRenderer-&gt;edgeBuckets[bucket*2 + 1];
 83 
 84     if ((bucketcount &amp; 0x1) != 0) {
 85         jint newCount = 0;
 86         jint i;
 87         for (i = 0; i &lt; count; i++) {
 88             jint ecur = ptrs[i];
 89             if (edges[ecur+YMAX] &gt; cury) {
 90                 ptrs[newCount++] = ecur;
 91             }
 92         }
 93         count = newCount;
 94     }
 95     if (this.edgePtrsSIZE &lt; count + (bucketcount &gt;&gt; 1)) {
 96         jint newSize = (count + (bucketcount &gt;&gt; 1)) * 2;
 97         jint *newPtrs = new_int(newSize);
 98         System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
 99         free(this.edgePtrs);
100         this.edgePtrs = newPtrs;
101         this.edgePtrsSIZE = newSize;
102     }
103     ptrs = this.edgePtrs;
104     for (ecur = pRenderer-&gt;edgeBuckets[bucket*2];
105          ecur != 0;
106          ecur = (jint) edges[ecur+NEXT])
107     {
108         ptrs[count++] = --ecur;
109         // REMIND: Adjust start Y if necessary
110     }
111     this.edgePtrs = ptrs;
112     this.edgeCount = count;
113 //    if ((count &amp; 0x1) != 0) {
114 //        System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
115 //    }
116     xings = this.crossings;
117     if (this.crossingsSIZE &lt; count) {
118         free(this.crossings);
119         this.crossings = xings = new_int(this.edgePtrsSIZE);
120         this.crossingsSIZE = this.edgePtrsSIZE;
121     }
122     for (i = 0; i &lt; count; i++) {
123         jint ecur = ptrs[i];
124         jfloat curx = edges[ecur+CURX];
125         jint cross = ((jint) ceil(curx - 0.5f)) &lt;&lt; 1;
126         jint j;
127         edges[ecur+CURX] = curx + edges[ecur+SLOPE];
128         if (edges[ecur+OR] &gt; 0) {
129             cross |= 1;
130         }
131         j = i;
132         while (--j &gt;= 0) {
133             jint jcross = xings[j];
134             if (jcross &lt;= cross) {
135                 break;
136             }
137             xings[j+1] = jcross;
138             ptrs[j+1] = ptrs[j];
139         }
140         xings[j+1] = cross;
141         ptrs[j+1] = ecur;
142     }
143     return count;
144 }
145 
146 static jboolean ScanlineIterator_hasNext(ScanlineIterator *pIterator, Renderer *pRenderer) {
147     return this.nextY &lt; pRenderer-&gt;sampleRowMax;
148 }
149 
150 static jint ScanlineIterator_curY(ScanlineIterator *pIterator) {
151     return this.nextY - 1;
152 }
153 
154 #undef this
155 #define this (*((Renderer *) pRenderer))
156 
157 //////////////////////////////////////////////////////////////////////////////
158 //  EDGE LIST
159 //////////////////////////////////////////////////////////////////////////////
160 // NOTE(maybe): very tempting to use fixed point here. A lot of opportunities
161 // for shifts and just removing certain operations altogether.
162 
163 
164 // each bucket is a linked list. this method adds eptr to the
165 // start &quot;bucket&quot;th linked list.
166 static void addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {
167     // we could implement this in terms of insertEdge, but this is a special
168     // case, so we optimize a bit.
169     this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
170     this.edgeBuckets[bucket*2] = eptr + 1;
171     this.edgeBuckets[bucket*2 + 1] += 2;
172 }
173 
174 static void addLine(PathConsumer *pRenderer,
175                     jfloat x1, jfloat y1,
176                     jfloat x2, jfloat y2);
177 
178 // Flattens using adaptive forward differencing. This only carries out
179 // one iteration of the AFD loop. All it does is update AFD variables (i.e.
180 // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
181 static void quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,
182                                      jfloat x0, jfloat y0,
183                                      const Curve c,
184                                      const jfloat x2, const jfloat y2)
185 {
186     jfloat ddx, ddy, dx, dy;
187     const jfloat QUAD_DEC_BND = 32;
188     const jint countlg = 4;
189     jint count = 1 &lt;&lt; countlg;
190     jint countsq = count * count;
191     jfloat maxDD = Math_max(c.dbx / countsq, c.dby / countsq);
192     while (maxDD &gt; QUAD_DEC_BND) {
193         maxDD /= 4;
194         count &lt;&lt;= 1;
195     }
196 
197     countsq = count * count;
198     ddx = c.dbx / countsq;
199     ddy = c.dby / countsq;
200     dx = c.bx / countsq + c.cx / count;
201     dy = c.by / countsq + c.cy / count;
202 
203     while (count-- &gt; 1) {
204         jfloat x1 = x0 + dx;
205         jfloat y1 = y0 + dy;
206         dx += ddx;
207         dy += ddy;
208         addLine(pRenderer, x0, y0, x1, y1);
209         x0 = x1;
210         y0 = y1;
211     }
212     addLine(pRenderer, x0, y0, x2, y2);
213 }
214 
215 // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
216 // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
217 // numerical errors, and our callers already have the exact values.
218 // Another alternative would be to pass all the control points, and call c.set
219 // here, but then too many numbers are passed around.
220 static void curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,
221                                       jfloat x0, jfloat y0,
222                                       const Curve c,
223                                       const jfloat x3, const jfloat y3)
224 {
225     const jint countlg = 3;
226     jint count = 1 &lt;&lt; countlg;
227     jfloat x1, y1;
228 
229     // the dx and dy refer to forward differencing variables, not the last
230     // coefficients of the &quot;points&quot; polynomial
231     jfloat dddx, dddy, ddx, ddy, dx, dy;
232     dddx = 2.0f * c.dax / (1 &lt;&lt; (3 * countlg));
233     dddy = 2.0f * c.day / (1 &lt;&lt; (3 * countlg));
234 
235     ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));
236     ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));
237     dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);
238     dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);
239 
240     // we use x0, y0 to walk the line
241     x1 = x0;
242     y1 = y0;
243     while (count &gt; 0) {
244         while (fabs(ddx) &gt; DEC_BND || fabs(ddy) &gt; DEC_BND) {
245             dddx /= 8;
246             dddy /= 8;
247             ddx = ddx/4 - dddx;
248             ddy = ddy/4 - dddy;
249             dx = (dx - ddx) / 2;
250             dy = (dy - ddy) / 2;
251             count &lt;&lt;= 1;
252         }
253         // can only do this on even &quot;count&quot; values, because we must divide count by 2
254         while (count % 2 == 0 &amp;&amp; fabs(dx) &lt;= INC_BND &amp;&amp; fabs(dy) &lt;= INC_BND) {
255             dx = 2 * dx + ddx;
256             dy = 2 * dy + ddy;
257             ddx = 4 * (ddx + dddx);
258             ddy = 4 * (ddy + dddy);
259             dddx = 8 * dddx;
260             dddy = 8 * dddy;
261             count &gt;&gt;= 1;
262         }
263         count--;
264         if (count &gt; 0) {
265             x1 += dx;
266             dx += ddx;
267             ddx += dddx;
268             y1 += dy;
269             dy += ddy;
270             ddy += dddy;
271         } else {
272             x1 = x3;
273             y1 = y3;
274         }
275         addLine(pRenderer, x0, y0, x1, y1);
276         x0 = x1;
277         y0 = y1;
278     }
279 }
280 
281 static void addLine(PathConsumer *pRenderer,
282                     jfloat x1, jfloat y1,
283                     jfloat x2, jfloat y2)
284 {
285     jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
286     jint firstCrossing, lastCrossing;
287     jfloat slope;
288     jint ptr, bucketIdx;
289 
290     if (y2 &lt; y1) {
291         or = y2; // no need to declare a temp variable. We have or.
292         y2 = y1;
293         y1 = or;
294         or = x2;
295         x2 = x1;
296         x1 = or;
297         or = 0;
298     }
299     firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
300     lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
301     if (firstCrossing &gt;= lastCrossing) {
302         return;
303     }
304     if (firstCrossing &lt; this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
305     if (lastCrossing &gt; this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
306 
307     slope = (x2 - x1) / (y2 - y1);
308 
309     if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
310         if (x1 &lt; this.edgeMinX) { this.edgeMinX = x1; }
311         if (x2 &gt; this.edgeMaxX) { this.edgeMaxX = x2; }
312     } else {
313         if (x2 &lt; this.edgeMinX) { this.edgeMinX = x2; }
314         if (x1 &gt; this.edgeMaxX) { this.edgeMaxX = x1; }
315     }
316 
317     ptr = this.numEdges * SIZEOF_EDGE;
318     if (this.edgesSIZE &lt; ptr + SIZEOF_EDGE) {
319         jint newSize = (ptr + SIZEOF_EDGE) * 2;
320         jfloat *newEdges = new_float(newSize);
321         System_arraycopy(this.edges, 0, newEdges, 0, ptr);
322         free(this.edges);
323         this.edges = newEdges;
324         this.edgesSIZE = newSize;
325     }
326     this.numEdges++;
327     this.edges[ptr+OR] = or;
328     this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
329     this.edges[ptr+SLOPE] = slope;
330     this.edges[ptr+YMAX] = (jfloat) lastCrossing;
331     bucketIdx = firstCrossing - this.boundsMinY;
332     addEdgeToBucket(pRenderer, ptr, bucketIdx);
333     this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
334 }
335 
336 // END EDGE LIST
337 //////////////////////////////////////////////////////////////////////////////
338 static MoveToFunc       Renderer_moveTo;
339 static LineToFunc       Renderer_lineTo;
340 static QuadToFunc       Renderer_quadTo;
341 static CurveToFunc      Renderer_curveTo;
342 static ClosePathFunc    Renderer_closePath;
343 static PathDoneFunc     Renderer_pathDone;
344 
345 // Antialiasing
346 static jint SUBPIXEL_LG_POSITIONS_X;
347 static jint SUBPIXEL_LG_POSITIONS_Y;
348 static jint SUBPIXEL_POSITIONS_X;
349 static jint SUBPIXEL_POSITIONS_Y;
350 static jint SUBPIXEL_MASK_X;
351 static jint SUBPIXEL_MASK_Y;
352 //static jint MAX_AA_ALPHA;
353 
354 // We keep 2 alpha maps around which map from the number of sub-pixel
355 // samples to a byte-based alpha value from 0 to 255.  We only ever
356 // use 2 different sub-pixel sample counts in practice (depending on
357 // AA vs. non-AA rendering), so these 2 should satisfy all of our needs.
358 static jbyte *alphaMap = NULL;
359 static jint alphaMax;
360 static jbyte *altAlphaMap = NULL;
361 static jint altAlphaMax;
362 
363 static void setMaxAlpha(jint maxalpha);
364 
365 void Renderer_setup(jint subpixelLgPositionsX, jint subpixelLgPositionsY) {
366     SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;
367     SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;
368     SUBPIXEL_POSITIONS_X = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X);
369     SUBPIXEL_POSITIONS_Y = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y);
370     SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
371     SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
372 //    MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);
373     setMaxAlpha((SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y));
374 }
375 
376 void Renderer_init(Renderer *pRenderer) {
377     memset(pRenderer, 0, sizeof(Renderer));
378     PathConsumer_init(&amp;pRenderer-&gt;consumer,
379                       Renderer_moveTo,
380                       Renderer_lineTo,
381                       Renderer_quadTo,
382                       Renderer_curveTo,
383                       Renderer_closePath,
384                       Renderer_pathDone);
385 }
386 
387 void Renderer_reset(Renderer *pRenderer,
388                     jint pix_boundsX, jint pix_boundsY,
389                     jint pix_boundsWidth, jint pix_boundsHeight,
390                     jint windingRule)
391 {
392     jint numBuckets;
393 
394     this.windingRule = windingRule;
395 
396     this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;
397     this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;
398     this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;
399     this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;
400 
401     this.edgeMinX = BIGGEST_FLOAT;
402     this.edgeMaxX = -BIGGEST_FLOAT;
403     this.sampleRowMax = this.boundsMinY;
404     this.sampleRowMin = this.boundsMaxY;
405 
406     numBuckets = this.boundsMaxY - this.boundsMinY;
407     if (this.edgeBuckets == NULL || this.edgeBucketsSIZE &lt; numBuckets*2+2) {
408         // The last 2 entries are ignored and only used to store unused
409         // values for segments ending on the last line of the bounds
410         // so we can avoid having to check the bounds on this array.
411         this.edgeBuckets = new_int(numBuckets*2 + 2);
412         this.edgeBucketsSIZE = numBuckets*2 + 2;
413     } else {
414         // Only need to fill the first numBuckets*2 entries since the
415         // last 2 entries are write-only for overflow avoidance only.
416         Arrays_fill(this.edgeBuckets, 0, numBuckets*2, 0);
417     }
418     if (this.edges == NULL) {
419         this.edges = new_float(SIZEOF_EDGE * 32);
420         this.edgesSIZE = SIZEOF_EDGE * 32;
421     }
422     this.numEdges = 0;
423     this.pix_sx0 = this.pix_sy0 = this.x0 = this.y0 = 0.0f;
424 }
425 
426 void Renderer_destroy(Renderer *pRenderer) {
427     free(pRenderer-&gt;edgeBuckets);
428     pRenderer-&gt;edgeBuckets = NULL;
429     pRenderer-&gt;edgeBucketsSIZE = 0;
430     free(pRenderer-&gt;edges);
431     pRenderer-&gt;edges = NULL;
432     pRenderer-&gt;edgesSIZE = 0;
433 }
434 
435 static jfloat tosubpixx(jfloat pix_x) {
436     return pix_x * SUBPIXEL_POSITIONS_X;
437 }
438 static jfloat tosubpixy(jfloat pix_y) {
439     return pix_y * SUBPIXEL_POSITIONS_Y;
440 }
441 
442 static void Renderer_moveTo(PathConsumer *pRenderer,
443                             jfloat pix_x0, jfloat pix_y0)
444 {
445     Renderer_closePath(pRenderer);
446     this.pix_sx0 = pix_x0;
447     this.pix_sy0 = pix_y0;
448     this.y0 = tosubpixy(pix_y0);
449     this.x0 = tosubpixx(pix_x0);
450 }
451 
452 static void Renderer_lineTo(PathConsumer *pRenderer,
453                             jfloat pix_x1, jfloat pix_y1)
454 {
455     jfloat x1 = tosubpixx(pix_x1);
456     jfloat y1 = tosubpixy(pix_y1);
457     addLine(pRenderer, this.x0, this.y0, x1, y1);
458     this.x0 = x1;
459     this.y0 = y1;
460 }
461 
462 static void Renderer_curveTo(PathConsumer *pRenderer,
463                              jfloat x1, jfloat y1,
464                              jfloat x2, jfloat y2,
465                              jfloat x3, jfloat y3)
466 {
467     const jfloat xe = tosubpixx(x3);
468     const jfloat ye = tosubpixy(y3);
469     Curve_setcubic(&amp;this.c,
470                    this.x0, this.y0,
471                    tosubpixx(x1), tosubpixy(y1),
472                    tosubpixx(x2), tosubpixy(y2),
473                    xe, ye);
474     curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
475     this.x0 = xe;
476     this.y0 = ye;
477 }
478 
479 void Renderer_quadTo(PathConsumer *pRenderer,
480                      jfloat x1, jfloat y1,
481                      jfloat x2, jfloat y2)
482 {
483     const jfloat xe = tosubpixx(x2);
484     const jfloat ye = tosubpixy(y2);
485     Curve_setquad(&amp;this.c,
486                   this.x0, this.y0,
487                   tosubpixx(x1), tosubpixy(y1),
488                   xe, ye);
489     quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
490     this.x0 = xe;
491     this.y0 = ye;
492 }
493 
494 static void Renderer_closePath(PathConsumer *pRenderer) {
495     // lineTo expects its input in pixel coordinates.
496     Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);
497 }
498 
499 static void Renderer_pathDone(PathConsumer *pRenderer) {
500     Renderer_closePath(pRenderer);
501 }
502 
503 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
504                                       jint alphaRow[], jint pix_y,
505                                       jint pix_from, jint pix_to);
506 
507 void Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {
508 //    ac.setMaxAlpha(MAX_AA_ALPHA);
509 
510     // Mask to determine the relevant bit of the crossing sum
511     // 0x1 if EVEN_ODD, all bits if NON_ZERO
512     jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
513     jint bboxx0, bboxx1;
514     jint pix_minX, pix_maxX;
515     jint y;
516     ScanlineIterator it;
517 
518     // add 2 to better deal with the last pixel in a pixel row.
519     jint width = pAC-&gt;width;
520     jint savedAlpha[1024];
521     jint *alpha;
522     if (1024 &lt; width+2) {
523         alpha = new_int(width+2);
524     } else {
525         alpha = savedAlpha;
526     }
527     Arrays_fill(alpha, 0, width+2, 0);
528 
529     bboxx0 = pAC-&gt;originX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
530     bboxx1 = bboxx0 + (width &lt;&lt; SUBPIXEL_LG_POSITIONS_X);
531 
532     // Now we iterate through the scanlines. We must tell emitRow the coord
533     // of the first non-transparent pixel, so we must keep accumulators for
534     // the first and last pixels of the section of the current pixel row
535     // that we will emit.
536     // We also need to accumulate pix_bbox*, but the iterator does it
537     // for us. We will just get the values from it once this loop is done
538     pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
539     pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
540 
541     y = this.boundsMinY; // needs to be declared here so we emit the last row properly.
542     ScanlineIterator_init(&amp;it, pRenderer);
543     for ( ; ScanlineIterator_hasNext(&amp;it, pRenderer); ) {
544         jint numCrossings = ScanlineIterator_next(&amp;it, pRenderer);
545         jint *crossings = it.crossings;
546         jint sum, prev;
547         jint i;
548 
549         y = ScanlineIterator_curY(&amp;it);
550 
551         if (numCrossings &gt; 0) {
552             jint lowx = crossings[0] &gt;&gt; 1;
553             jint highx = crossings[numCrossings - 1] &gt;&gt; 1;
554             jint x0 = Math_max(lowx, bboxx0);
555             jint x1 = Math_min(highx, bboxx1);
556 
557             pix_minX = Math_min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
558             pix_maxX = Math_max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
559         }
560 
561         sum = 0;
562         prev = bboxx0;
563         for (i = 0; i &lt; numCrossings; i++) {
564             jint curxo = crossings[i];
565             jint curx = curxo &gt;&gt; 1;
566             jint crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
567             if ((sum &amp; mask) != 0) {
568                 jint x0 = Math_max(prev, bboxx0);
569                 jint x1 = Math_min(curx, bboxx1);
570                 if (x0 &lt; x1) {
571                     jint pix_x, pix_xmaxm1;
572 
573                     x0 -= bboxx0; // turn x0, x1 from coords to indices
574                     x1 -= bboxx0; // in the alpha array.
575 
576                     pix_x = x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
577                     pix_xmaxm1 = (x1 - 1) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
578 
579                     if (pix_x == pix_xmaxm1) {
580                         // Start and end in same pixel
581                         alpha[pix_x] += (x1 - x0);
582                         alpha[pix_x+1] -= (x1 - x0);
583                     } else {
584                         jint pix_xmax = x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
585                         alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 &amp; SUBPIXEL_MASK_X);
586                         alpha[pix_x+1] += (x0 &amp; SUBPIXEL_MASK_X);
587                         alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 &amp; SUBPIXEL_MASK_X);
588                         alpha[pix_xmax+1] -= (x1 &amp; SUBPIXEL_MASK_X);
589                     }
590                 }
591             }
592             sum += crorientation;
593             prev = curx;
594         }
595 
596         // even if this last row had no crossings, alpha will be zeroed
597         // from the last emitRow call. But this doesn&#39;t matter because
598         // maxX &lt; minX, so no row will be emitted to the cache.
599         if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
600             setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
601                                       pix_minX, pix_maxX);
602             pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
603             pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
604         }
605     }
606 
607     // Emit final row.
608     // Note, if y is on a MASK row then it was already sent above...
609     if ((y &amp; SUBPIXEL_MASK_Y) &lt; SUBPIXEL_MASK_Y) {
610         setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
611                                   pix_minX, pix_maxX);
612     }
613     ScanlineIterator_destroy(&amp;it);
614     if (alpha != savedAlpha) free (alpha);
615 }
616 
617 //@Override
618 static void setMaxAlpha(jint maxalpha) {
619     jint i, altMax;
620     jbyte *altMap;
621 
622     // Attempt to reuse either alphaMap or altAlphaMap.
623     // In practice, we should not get here if alphaMap is the right size
624     // due to checks above in our calling chain, but we check for that
625     // condition for completeness.
626     // Also in practice, we only ever have 2 values for maxalpha, but we
627     // protect against running into a 3rd value for maxalpha just in case.
628     if (alphaMap != NULL) {
629         if (maxalpha == alphaMax) {
630             return;
631         }
632         // We will either free the alt values and calculate a new map,
633         // or we will swap them to the main alpha* variables.  In either
634         // case, the main alpha* variables will become the new alt values.
635         altMap = altAlphaMap;
636         altMax = altAlphaMax;
637         altAlphaMap = alphaMap;
638         altAlphaMax = alphaMax;
639         if (altMap != NULL) {
640             if (maxalpha == altMax) {
641                 alphaMap = altMap;
642                 alphaMax = altMax;
643                 return;
644             }
645             free(altMap);
646         }
647         alphaMap = NULL;
648     }
649     // assert alphaMap == NULL
650     alphaMap = malloc(maxalpha+1);
651     alphaMax = maxalpha;
652     for (i = 0; i &lt;= maxalpha; i++) {
653         alphaMap[i] = (jbyte) ((i*255 + maxalpha/2)/maxalpha);
654     }
655 }
656 
657 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
658                                       jint alphaRow[], jint pix_y,
659                                       jint pix_from, jint pix_to)
660 {
661 //    System.out.println(&quot;setting row &quot;+(pix_y - y)+
662 //                       &quot; out of &quot;+width+&quot; x &quot;+height);
663     jint w = pAC-&gt;width;
664     jint off = (pix_y - pAC-&gt;originY) * w;
665     jbyte *out = pAC-&gt;alphas;
666     jint a = 0;
667     jint i;
668     for (i = 0; i &lt; w; i++) {
669         a += alphaRow[i];
670         alphaRow[i] = 0;
671         out[off+i] = alphaMap[a];
672     }
673 }
674 
675 static jint getSubpixMinX(Renderer *pRenderer) {
676     jint sampleColMin = (jint) ceil(this.edgeMinX - 0.5f);
677     if (sampleColMin &lt; this.boundsMinX) sampleColMin = this.boundsMinX;
678     return sampleColMin;
679 }
680 
681 static jint getSubpixMaxX(Renderer *pRenderer) {
682     jint sampleColMax = (jint) ceil(this.edgeMaxX - 0.5f);
683     if (sampleColMax &gt; this.boundsMaxX) sampleColMax = this.boundsMaxX;
684     return sampleColMax;
685 }
686 
687 static jint getSubpixMinY(Renderer *pRenderer) {
688     return this.sampleRowMin;
689 }
690 
691 static jint getSubpixMaxY(Renderer *pRenderer) {
692     return this.sampleRowMax;
693 }
694 
695 static jint getOutpixMinX(Renderer *pRenderer) {
696     return (getSubpixMinX(pRenderer) &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
697 }
698 
699 static jint getOutpixMaxX(Renderer *pRenderer) {
700     return (getSubpixMaxX(pRenderer) + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
701 }
702 
703 static jint getOutpixMinY(Renderer *pRenderer) {
704     return (this.sampleRowMin &gt;&gt; SUBPIXEL_LG_POSITIONS_Y);
705 }
706 
707 static jint getOutpixMaxY(Renderer *pRenderer) {
708     return (this.sampleRowMax + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
709 }
710 
711 void Renderer_getOutputBounds(Renderer *pRenderer, jint bounds[]) {
712     bounds[0] = getOutpixMinX(pRenderer);
713     bounds[1] = getOutpixMinY(pRenderer);
714     bounds[2] = getOutpixMaxX(pRenderer);
715     bounds[3] = getOutpixMaxY(pRenderer);
716 }
    </pre>
  </body>
</html>
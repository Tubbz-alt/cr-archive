<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;jni.h&gt;
 27 #ifdef ANDROID_NDK
 28 #include &lt;stddef.h&gt;
 29 #endif
 30 #include &quot;com_sun_prism_impl_shape_NativePiscesRasterizer.h&quot;
 31 
 32 #include &quot;Renderer.h&quot;
 33 #include &quot;Stroker.h&quot;
 34 #include &quot;Dasher.h&quot;
 35 #include &quot;Transformer.h&quot;
 36 #include &quot;AlphaConsumer.h&quot;
 37 
 38 #define SEG(T) com_sun_prism_impl_shape_NativePiscesRasterizer_SEG_ ## T
 39 
 40 #define SEG_MOVETO   SEG(MOVETO)
 41 #define SEG_LINETO   SEG(LINETO)
 42 #define SEG_QUADTO   SEG(QUADTO)
 43 #define SEG_CUBICTO  SEG(CUBICTO)
 44 #define SEG_CLOSE    SEG(CLOSE)
 45 
 46 #define NPException    &quot;java/lang/NullPointerException&quot;
 47 #define AIOOBException &quot;java/lang/ArrayIndexOutOfBoundsException&quot;
<a name="2" id="anc2"></a>
 48 #define IError         &quot;java/lang/InternalError&quot;
 49 
 50 #define CheckNPE(env, a)                                \
 51     do {                                                \
 52         if (a == NULL) {                                \
 53             Throw(env, NPException, #a);                \
 54             return;                                     \
 55         }                                               \
 56     } while (0)
 57 
 58 #define CheckLen(env, a, len)                           \
 59     do {                                                \
 60         if ((*env)-&gt;GetArrayLength(env, a) &lt; len) {     \
 61             Throw(env, AIOOBException, #a);             \
 62             return;                                     \
 63         }                                               \
 64     } while (0)
 65 
 66 
 67 static void Throw(JNIEnv *env, char *throw_class_name, char *detail) {
 68     jclass throw_class = (*env)-&gt;FindClass(env, throw_class_name);
 69     if (throw_class != NULL) {
 70         (*env)-&gt;ThrowNew(env, throw_class, detail);
 71     }
 72 }
 73 
<a name="3" id="anc3"></a>












 74 static char * feedConsumer
 75     (JNIEnv *env, PathConsumer *consumer,
 76      jfloatArray coordsArray, jint coordSize,
 77      jbyteArray commandsArray, jint numCommands)
 78 {
<a name="4" id="anc4"></a>
 79     char *failure = NULL;
 80     jfloat *coords;
 81 
 82     coords = (*env)-&gt;GetPrimitiveArrayCritical(env, coordsArray, 0);
 83     if (coords == NULL) {
 84         failure = &quot;&quot;;
 85     } else {
 86         jbyte *commands = (*env)-&gt;GetPrimitiveArrayCritical(env, commandsArray, 0);
 87         if (commands == NULL) {
 88             failure = &quot;&quot;;
 89         } else {
 90             jint cmdoff, coordoff = 0;
 91             for (cmdoff = 0; cmdoff &lt; numCommands &amp;&amp; failure == NULL; cmdoff++) {
 92                 switch (commands[cmdoff]) {
 93                     case SEG_MOVETO:
 94                         if (coordoff + 2 &gt; coordSize) {
 95                             failure = &quot;[not enough coordinates for moveTo&quot;;
 96                         } else {
<a name="5" id="anc5"></a><span class="line-modified"> 97                             consumer-&gt;moveTo(consumer,</span>
 98                                              coords[coordoff+0], coords[coordoff+1]);
<a name="6" id="anc6"></a>


 99                             coordoff += 2;
100                         }
101                         break;
102                     case SEG_LINETO:
103                         if (coordoff + 2 &gt; coordSize) {
104                             failure = &quot;[not enough coordinates for lineTo&quot;;
105                         } else {
<a name="7" id="anc7"></a><span class="line-modified">106                             consumer-&gt;lineTo(consumer,</span>
107                                              coords[coordoff+0], coords[coordoff+1]);
<a name="8" id="anc8"></a>


108                             coordoff += 2;
109                         }
110                         break;
111                     case SEG_QUADTO:
112                         if (coordoff + 4 &gt; coordSize) {
113                             failure = &quot;[not enough coordinates for quadTo&quot;;
114                         } else {
<a name="9" id="anc9"></a><span class="line-modified">115                             consumer-&gt;quadTo(consumer,</span>
116                                              coords[coordoff+0], coords[coordoff+1],
117                                              coords[coordoff+2], coords[coordoff+3]);
<a name="10" id="anc10"></a>


118                             coordoff += 4;
119                         }
120                         break;
121                     case SEG_CUBICTO:
122                         if (coordoff + 6 &gt; coordSize) {
123                             failure = &quot;[not enough coordinates for curveTo&quot;;
124                         } else {
<a name="11" id="anc11"></a><span class="line-modified">125                             consumer-&gt;curveTo(consumer,</span>
126                                               coords[coordoff+0], coords[coordoff+1],
127                                               coords[coordoff+2], coords[coordoff+3],
128                                               coords[coordoff+4], coords[coordoff+5]);
<a name="12" id="anc12"></a>


129                             coordoff += 6;
130                         }
131                         break;
132                     case SEG_CLOSE:
<a name="13" id="anc13"></a><span class="line-modified">133                         consumer-&gt;closePath(consumer);</span>



134                         break;
135                     default:
136                         failure = &quot;unrecognized Path segment&quot;;
137                         break;
138                 }
139             }
140             (*env)-&gt;ReleasePrimitiveArrayCritical(env, commandsArray, commands, JNI_ABORT);
141         }
142         (*env)-&gt;ReleasePrimitiveArrayCritical(env, coordsArray, coords, JNI_ABORT);
143         if (failure == NULL) {
<a name="14" id="anc14"></a><span class="line-modified">144             consumer-&gt;pathDone(consumer);</span>



145         }
146     }
147     return failure;
148 }
149 
150 /*
151  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
152  * Method:    init
153  * Signature: (II)V
154  */
155 JNIEXPORT void JNICALL
156 Java_com_sun_prism_impl_shape_NativePiscesRasterizer_init
157     (JNIEnv *env, jclass klass,
158      jint subpixelLgPositionsX, jint subpixelLgPositionsY)
159 {
160     Renderer_setup(subpixelLgPositionsX, subpixelLgPositionsY);
161 }
162 
163 /*
164  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
165  * Method:    produceFillAlphas
166  * Signature: ([F[BIZDDDDDD[I[B)V
167  */
168 JNIEXPORT void JNICALL
169 Java_com_sun_prism_impl_shape_NativePiscesRasterizer_produceFillAlphas
170     (JNIEnv *env, jclass klass,
171      jfloatArray coordsArray, jbyteArray commandsArray, jint numCommands, jboolean nonzero,
172      jdouble mxx, jdouble mxy, jdouble mxt, jdouble myx, jdouble myy, jdouble myt,
173      jintArray boundsArray, jbyteArray maskArray)
174 {
175     jint bounds[4];
176     Transformer transformer;
177     Renderer renderer;
178     PathConsumer *consumer;
179     char *failure;
180     jint coordSize;
181 
182     CheckNPE(env, coordsArray);
183     CheckNPE(env, commandsArray);
184     CheckNPE(env, boundsArray);
185     CheckNPE(env, maskArray);
186     CheckLen(env, boundsArray, 4);
187     CheckLen(env, commandsArray, numCommands);
188 
189     (*env)-&gt;GetIntArrayRegion(env, boundsArray, 0, 4, bounds);
190     coordSize = (*env)-&gt;GetArrayLength(env, coordsArray);
191     Renderer_init(&amp;renderer);
192     Renderer_reset(&amp;renderer,
193                    bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1],
194                    nonzero ? WIND_NON_ZERO : WIND_EVEN_ODD);
195     consumer = Transformer_init(&amp;transformer, &amp;renderer.consumer,
196                                 mxx, mxy, mxt, myx, myy, myt);
197     failure = feedConsumer(env, consumer,
198                            coordsArray, coordSize, commandsArray, numCommands);
199     if (failure == NULL) {
200         Renderer_getOutputBounds(&amp;renderer, bounds);
201         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
202         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
203             AlphaConsumer ac = {
204                 bounds[0],
205                 bounds[1],
206                 bounds[2] - bounds[0],
207                 bounds[3] - bounds[1],
208             };
209             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
210                 Throw(env, AIOOBException, &quot;maskArray&quot;);
211             } else {
212                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
213                 if (ac.alphas != NULL) {
<a name="15" id="anc15"></a><span class="line-modified">214                     Renderer_produceAlphas(&amp;renderer, &amp;ac);</span>







215                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
216                 }
217             }
218         }
219     } else if (*failure != 0) {
220         if (*failure == &#39;[&#39;) {
221             Throw(env, AIOOBException, failure + 1);
222         } else {
223             Throw(env, IError, failure);
224         }
225     }
226     Renderer_destroy(&amp;renderer);
227 }
228 
229 /*
230  * Class:     com_sun_prism_impl_shape_NativePiscesRasterizer
231  * Method:    produceStrokeAlphas
232  * Signature: ([F[BIFIIF[FFDDDDDD[I[B)V
233  */
234 JNIEXPORT void JNICALL
235 Java_com_sun_prism_impl_shape_NativePiscesRasterizer_produceStrokeAlphas
236     (JNIEnv *env, jclass klass,
237      jfloatArray coordsArray, jbyteArray commandsArray, jint numCommands,
238      jfloat linewidth, jint linecap, jint linejoin, jfloat miterlimit,
239      jfloatArray dashArray, jfloat dashphase,
240      jdouble mxx, jdouble mxy, jdouble mxt, jdouble myx, jdouble myy, jdouble myt,
241      jintArray boundsArray, jbyteArray maskArray)
242 {
243     jint bounds[4];
244     Stroker stroker;
245     Dasher dasher;
246     Renderer renderer;
247     Transformer transformer;
248     PathConsumer *consumer;
249     jint coordSize;
250     jfloat *dashes;
251     char *failure;
252 
253     CheckNPE(env, coordsArray);
254     CheckNPE(env, commandsArray);
255     CheckNPE(env, boundsArray);
256     CheckNPE(env, maskArray);
257     CheckLen(env, boundsArray, 4);
258     CheckLen(env, commandsArray, numCommands);
259 
260     (*env)-&gt;GetIntArrayRegion(env, boundsArray, 0, 4, bounds);
261     coordSize = (*env)-&gt;GetArrayLength(env, coordsArray);
262     Renderer_init(&amp;renderer);
263     Renderer_reset(&amp;renderer,
264                    bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1],
265                    WIND_NON_ZERO);
266     consumer = Transformer_init(&amp;transformer, &amp;renderer.consumer,
267                                 mxx, mxy, mxt, myx, myy, myt);
268     Stroker_init(&amp;stroker, consumer, linewidth, linecap, linejoin, miterlimit);
269     if (dashArray == NULL) {
270         dashes = NULL;
271         consumer = &amp;stroker.consumer;
272     } else {
273         jint numdashes = (*env)-&gt;GetArrayLength(env, dashArray);
274         dashes = (*env)-&gt;GetPrimitiveArrayCritical(env, dashArray, 0);
275         if (dashes == NULL) {
276             return;
277         }
278         Dasher_init(&amp;dasher, &amp;stroker.consumer, dashes, numdashes, dashphase);
279         consumer = &amp;dasher.consumer;
280     }
281     failure = feedConsumer(env, consumer,
282                            coordsArray, coordSize, commandsArray, numCommands);
283     if (dashArray != NULL) {
284         (*env)-&gt;ReleasePrimitiveArrayCritical(env, dashArray, dashes, JNI_ABORT);
285         Dasher_destroy(&amp;dasher);
286     }
287     Stroker_destroy(&amp;stroker);
288     if (failure == NULL) {
289         Renderer_getOutputBounds(&amp;renderer, bounds);
290         (*env)-&gt;SetIntArrayRegion(env, boundsArray, 0, 4, bounds);
291         if (bounds[0] &lt; bounds[2] &amp;&amp; bounds[1] &lt; bounds[3]) {
292             AlphaConsumer ac = {
293                 bounds[0],
294                 bounds[1],
295                 bounds[2] - bounds[0],
296                 bounds[3] - bounds[1],
297             };
298             if ((*env)-&gt;GetArrayLength(env, maskArray) / ac.width &lt; ac.height) {
299                 Throw(env, AIOOBException, &quot;Mask&quot;);
300             } else {
301                 ac.alphas = (*env)-&gt;GetPrimitiveArrayCritical(env, maskArray, 0);
302                 if (ac.alphas != NULL) {
<a name="16" id="anc16"></a><span class="line-modified">303                     Renderer_produceAlphas(&amp;renderer, &amp;ac);</span>







304                     (*env)-&gt;ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
305                 }
306             }
307         }
308     } else if (*failure != 0) {
309         if (*failure == &#39;[&#39;) {
310             Throw(env, AIOOBException, failure + 1);
311         } else {
312             Throw(env, IError, failure);
313         }
314     }
315     Renderer_destroy(&amp;renderer);
316 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
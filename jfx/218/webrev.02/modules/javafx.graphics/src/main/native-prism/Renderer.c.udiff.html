<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.graphics/src/main/native-prism/Renderer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="PathConsumer.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Renderer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/Renderer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -68,10 +68,12 @@</span>
      // the y of the first scan line crossing).
      this.nextY = pRenderer-&gt;sampleRowMin;
      this.edgeCount = 0;
  }
  
<span class="udiff-line-added">+ // Iterate to the next scanline and return the number of crossings.</span>
<span class="udiff-line-added">+ // A count of -1 is returned to indicate OOM.</span>
  static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
      jint i, ecur;
      jint *xings;
      // NOTE: make function that convert from y value to bucket idx?
      jint cury = this.nextY++;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -93,10 +95,13 @@</span>
          count = newCount;
      }
      if (this.edgePtrsSIZE &lt; count + (bucketcount &gt;&gt; 1)) {
          jint newSize = (count + (bucketcount &gt;&gt; 1)) * 2;
          jint *newPtrs = new_int(newSize);
<span class="udiff-line-added">+         if (!newPtrs) {</span>
<span class="udiff-line-added">+             return -1;</span>
<span class="udiff-line-added">+         }</span>
          System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
          free(this.edgePtrs);
          this.edgePtrs = newPtrs;
          this.edgePtrsSIZE = newSize;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -115,10 +120,13 @@</span>
  //    }
      xings = this.crossings;
      if (this.crossingsSIZE &lt; count) {
          free(this.crossings);
          this.crossings = xings = new_int(this.edgePtrsSIZE);
<span class="udiff-line-added">+         if (!xings) {</span>
<span class="udiff-line-added">+             return -1;</span>
<span class="udiff-line-added">+         }</span>
          this.crossingsSIZE = this.edgePtrsSIZE;
      }
      for (i = 0; i &lt; count; i++) {
          jint ecur = ptrs[i];
          jfloat curx = edges[ecur+CURX];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -161,30 +169,35 @@</span>
  // for shifts and just removing certain operations altogether.
  
  
  // each bucket is a linked list. this method adds eptr to the
  // start &quot;bucket&quot;th linked list.
<span class="udiff-line-modified-removed">- static void addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {</span>
<span class="udiff-line-modified-added">+ static jint addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {</span>
      // we could implement this in terms of insertEdge, but this is a special
      // case, so we optimize a bit.
<span class="udiff-line-added">+     if (this.edgeBuckets[bucket*2] &gt;= MAX_EDGE_IDX) {</span>
<span class="udiff-line-added">+         return ERROR_AIOOBE;</span>
<span class="udiff-line-added">+     }</span>
      this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
      this.edgeBuckets[bucket*2] = eptr + 1;
      this.edgeBuckets[bucket*2 + 1] += 2;
<span class="udiff-line-added">+     return ERROR_NONE;</span>
  }
  
<span class="udiff-line-modified-removed">- static void addLine(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint addLine(PathConsumer *pRenderer,</span>
                      jfloat x1, jfloat y1,
                      jfloat x2, jfloat y2);
  
  // Flattens using adaptive forward differencing. This only carries out
  // one iteration of the AFD loop. All it does is update AFD variables (i.e.
  // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
<span class="udiff-line-modified-removed">- static void quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
                                       jfloat x0, jfloat y0,
                                       const Curve c,
                                       const jfloat x2, const jfloat y2)
  {
<span class="udiff-line-added">+     jint status = ERROR_NONE;</span>
      jfloat ddx, ddy, dx, dy;
      const jfloat QUAD_DEC_BND = 32;
      const jint countlg = 4;
      jint count = 1 &lt;&lt; countlg;
      jint countsq = count * count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -203,27 +216,31 @@</span>
      while (count-- &gt; 1) {
          jfloat x1 = x0 + dx;
          jfloat y1 = y0 + dy;
          dx += ddx;
          dy += ddy;
<span class="udiff-line-modified-removed">-         addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="udiff-line-modified-added">+         status = addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="udiff-line-added">+         if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+             return status;</span>
<span class="udiff-line-added">+         }</span>
          x0 = x1;
          y0 = y1;
      }
<span class="udiff-line-modified-removed">-     addLine(pRenderer, x0, y0, x2, y2);</span>
<span class="udiff-line-modified-added">+     return addLine(pRenderer, x0, y0, x2, y2);</span>
  }
  
  // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
  // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
  // numerical errors, and our callers already have the exact values.
  // Another alternative would be to pass all the control points, and call c.set
  // here, but then too many numbers are passed around.
<span class="udiff-line-modified-removed">- static void curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
                                        jfloat x0, jfloat y0,
                                        const Curve c,
                                        const jfloat x3, const jfloat y3)
  {
<span class="udiff-line-added">+     jint status = ERROR_NONE;</span>
      const jint countlg = 3;
      jint count = 1 &lt;&lt; countlg;
      jfloat x1, y1;
  
      // the dx and dy refer to forward differencing variables, not the last
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -270,20 +287,25 @@</span>
              ddy += dddy;
          } else {
              x1 = x3;
              y1 = y3;
          }
<span class="udiff-line-modified-removed">-         addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="udiff-line-modified-added">+         status = addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="udiff-line-added">+         if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+             return status;</span>
<span class="udiff-line-added">+         }</span>
          x0 = x1;
          y0 = y1;
      }
<span class="udiff-line-added">+     return status;</span>
  }
  
<span class="udiff-line-modified-removed">- static void addLine(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint addLine(PathConsumer *pRenderer,</span>
                      jfloat x1, jfloat y1,
                      jfloat x2, jfloat y2)
  {
<span class="udiff-line-added">+     jint status = ERROR_NONE;</span>
      jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
      jint firstCrossing, lastCrossing;
      jfloat slope;
      jint ptr, bucketIdx;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -297,11 +319,11 @@</span>
          or = 0;
      }
      firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
      lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
      if (firstCrossing &gt;= lastCrossing) {
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+         return status;</span>
      }
      if (firstCrossing &lt; this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
      if (lastCrossing &gt; this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
  
      slope = (x2 - x1) / (y2 - y1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -312,27 +334,38 @@</span>
      } else {
          if (x2 &lt; this.edgeMinX) { this.edgeMinX = x2; }
          if (x1 &gt; this.edgeMaxX) { this.edgeMaxX = x1; }
      }
  
<span class="udiff-line-added">+     bucketIdx = firstCrossing - this.boundsMinY;</span>
<span class="udiff-line-added">+     if (this.edgeBuckets[bucketIdx*2] &gt;= MAX_EDGE_IDX) {</span>
<span class="udiff-line-added">+         return ERROR_AIOOBE;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ptr = this.numEdges * SIZEOF_EDGE;
      if (this.edgesSIZE &lt; ptr + SIZEOF_EDGE) {
          jint newSize = (ptr + SIZEOF_EDGE) * 2;
          jfloat *newEdges = new_float(newSize);
<span class="udiff-line-added">+         if (!newEdges) {</span>
<span class="udiff-line-added">+             return ERROR_OOM;</span>
<span class="udiff-line-added">+         }</span>
          System_arraycopy(this.edges, 0, newEdges, 0, ptr);
          free(this.edges);
          this.edges = newEdges;
          this.edgesSIZE = newSize;
      }
      this.numEdges++;
      this.edges[ptr+OR] = or;
      this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
      this.edges[ptr+SLOPE] = slope;
      this.edges[ptr+YMAX] = (jfloat) lastCrossing;
<span class="udiff-line-modified-removed">-     bucketIdx = firstCrossing - this.boundsMinY;</span>
<span class="udiff-line-modified-removed">-     addEdgeToBucket(pRenderer, ptr, bucketIdx);</span>
<span class="udiff-line-modified-added">+     status = addEdgeToBucket(pRenderer, ptr, bucketIdx);</span>
<span class="udiff-line-modified-added">+     if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+         return status;</span>
<span class="udiff-line-added">+     }</span>
      this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
<span class="udiff-line-added">+     return status;</span>
  }
  
  // END EDGE LIST
  //////////////////////////////////////////////////////////////////////////////
  static MoveToFunc       Renderer_moveTo;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -437,76 +470,94 @@</span>
  }
  static jfloat tosubpixy(jfloat pix_y) {
      return pix_y * SUBPIXEL_POSITIONS_Y;
  }
  
<span class="udiff-line-modified-removed">- static void Renderer_moveTo(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint Renderer_moveTo(PathConsumer *pRenderer,</span>
                              jfloat pix_x0, jfloat pix_y0)
  {
<span class="udiff-line-modified-removed">-     Renderer_closePath(pRenderer);</span>
<span class="udiff-line-modified-added">+     jint status = Renderer_closePath(pRenderer);</span>
<span class="udiff-line-added">+     if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+         return status;</span>
<span class="udiff-line-added">+     }</span>
      this.pix_sx0 = pix_x0;
      this.pix_sy0 = pix_y0;
      this.y0 = tosubpixy(pix_y0);
      this.x0 = tosubpixx(pix_x0);
<span class="udiff-line-added">+     return status;</span>
  }
  
<span class="udiff-line-modified-removed">- static void Renderer_lineTo(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint Renderer_lineTo(PathConsumer *pRenderer,</span>
                              jfloat pix_x1, jfloat pix_y1)
  {
      jfloat x1 = tosubpixx(pix_x1);
      jfloat y1 = tosubpixy(pix_y1);
<span class="udiff-line-modified-removed">-     addLine(pRenderer, this.x0, this.y0, x1, y1);</span>
<span class="udiff-line-modified-added">+     jint status = addLine(pRenderer, this.x0, this.y0, x1, y1);</span>
<span class="udiff-line-added">+     if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+         return status;</span>
<span class="udiff-line-added">+     }</span>
      this.x0 = x1;
      this.y0 = y1;
<span class="udiff-line-added">+     return status;</span>
  }
  
<span class="udiff-line-modified-removed">- static void Renderer_curveTo(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ static jint Renderer_curveTo(PathConsumer *pRenderer,</span>
                               jfloat x1, jfloat y1,
                               jfloat x2, jfloat y2,
                               jfloat x3, jfloat y3)
  {
<span class="udiff-line-added">+     jint status = ERROR_NONE;</span>
      const jfloat xe = tosubpixx(x3);
      const jfloat ye = tosubpixy(y3);
      Curve_setcubic(&amp;this.c,
                     this.x0, this.y0,
                     tosubpixx(x1), tosubpixy(y1),
                     tosubpixx(x2), tosubpixy(y2),
                     xe, ye);
<span class="udiff-line-modified-removed">-     curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="udiff-line-modified-added">+     status = curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="udiff-line-added">+     if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+         return status;</span>
<span class="udiff-line-added">+     }</span>
      this.x0 = xe;
      this.y0 = ye;
<span class="udiff-line-added">+     return status;</span>
  }
  
<span class="udiff-line-modified-removed">- void Renderer_quadTo(PathConsumer *pRenderer,</span>
<span class="udiff-line-modified-added">+ jint Renderer_quadTo(PathConsumer *pRenderer,</span>
                       jfloat x1, jfloat y1,
                       jfloat x2, jfloat y2)
  {
<span class="udiff-line-added">+     jint status = ERROR_NONE;</span>
      const jfloat xe = tosubpixx(x2);
      const jfloat ye = tosubpixy(y2);
      Curve_setquad(&amp;this.c,
                    this.x0, this.y0,
                    tosubpixx(x1), tosubpixy(y1),
                    xe, ye);
<span class="udiff-line-modified-removed">-     quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="udiff-line-modified-added">+     status = quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="udiff-line-added">+     if (status != ERROR_NONE) {</span>
<span class="udiff-line-added">+         return status;</span>
<span class="udiff-line-added">+     }</span>
      this.x0 = xe;
      this.y0 = ye;
<span class="udiff-line-added">+     return status;</span>
  }
  
<span class="udiff-line-modified-removed">- static void Renderer_closePath(PathConsumer *pRenderer) {</span>
<span class="udiff-line-modified-added">+ static jint Renderer_closePath(PathConsumer *pRenderer) {</span>
      // lineTo expects its input in pixel coordinates.
<span class="udiff-line-modified-removed">-     Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);</span>
<span class="udiff-line-modified-added">+     return Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);</span>
  }
  
<span class="udiff-line-modified-removed">- static void Renderer_pathDone(PathConsumer *pRenderer) {</span>
<span class="udiff-line-modified-removed">-     Renderer_closePath(pRenderer);</span>
<span class="udiff-line-modified-added">+ static jint Renderer_pathDone(PathConsumer *pRenderer) {</span>
<span class="udiff-line-modified-added">+     return Renderer_closePath(pRenderer);</span>
  }
  
  static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
                                        jint alphaRow[], jint pix_y,
                                        jint pix_from, jint pix_to);
  
<span class="udiff-line-modified-removed">- void Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {</span>
<span class="udiff-line-modified-added">+ jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {</span>
  //    ac.setMaxAlpha(MAX_AA_ALPHA);
  
      // Mask to determine the relevant bit of the crossing sum
      // 0x1 if EVEN_ODD, all bits if NON_ZERO
      jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -519,10 +570,13 @@</span>
      jint width = pAC-&gt;width;
      jint savedAlpha[1024];
      jint *alpha;
      if (1024 &lt; width+2) {
          alpha = new_int(width+2);
<span class="udiff-line-added">+         if (!alpha) {</span>
<span class="udiff-line-added">+             return ERROR_OOM;</span>
<span class="udiff-line-added">+         }</span>
      } else {
          alpha = savedAlpha;
      }
      Arrays_fill(alpha, 0, width+2, 0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -544,10 +598,16 @@</span>
          jint numCrossings = ScanlineIterator_next(&amp;it, pRenderer);
          jint *crossings = it.crossings;
          jint sum, prev;
          jint i;
  
<span class="udiff-line-added">+         if (numCrossings &lt; 0) {</span>
<span class="udiff-line-added">+             ScanlineIterator_destroy(&amp;it);</span>
<span class="udiff-line-added">+             if (alpha != savedAlpha) free (alpha);</span>
<span class="udiff-line-added">+             return ERROR_OOM;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          y = ScanlineIterator_curY(&amp;it);
  
          if (numCrossings &gt; 0) {
              jint lowx = crossings[0] &gt;&gt; 1;
              jint highx = crossings[numCrossings - 1] &gt;&gt; 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -610,10 +670,12 @@</span>
          setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
                                    pix_minX, pix_maxX);
      }
      ScanlineIterator_destroy(&amp;it);
      if (alpha != savedAlpha) free (alpha);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return ERROR_NONE;</span>
  }
  
  //@Override
  static void setMaxAlpha(jint maxalpha) {
      jint i, altMax;
</pre>
<center><a href="PathConsumer.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Renderer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
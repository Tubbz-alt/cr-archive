<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.sw;
 27 
 28 import com.sun.javafx.geom.Path2D;
 29 import com.sun.javafx.geom.Rectangle;
 30 import com.sun.javafx.geom.Shape;
 31 import com.sun.javafx.geom.transform.BaseTransform;
 32 import com.sun.marlin.DMarlinRenderer;
 33 import com.sun.marlin.DMarlinRenderingEngine;
 34 import com.sun.marlin.DRendererContext;
 35 import com.sun.marlin.IntArrayCache;
 36 import com.sun.marlin.MarlinAlphaConsumer;
 37 import com.sun.marlin.MarlinConst;
 38 import com.sun.marlin.MarlinRenderer;
 39 import com.sun.marlin.MarlinRenderingEngine;
 40 import com.sun.marlin.RendererContext;
 41 import com.sun.openpisces.Renderer;
 42 import com.sun.pisces.PiscesRenderer;
 43 import com.sun.prism.BasicStroke;
 44 import com.sun.prism.PixelFormat;
 45 import com.sun.prism.ResourceFactory;
 46 import com.sun.prism.Texture;
 47 import com.sun.prism.impl.PrismSettings;
 48 import com.sun.prism.impl.shape.DMarlinPrismUtils;
 49 import com.sun.prism.impl.shape.MarlinPrismUtils;
 50 import com.sun.prism.impl.shape.MaskData;
 51 import com.sun.prism.impl.shape.OpenPiscesPrismUtils;
 52 import com.sun.prism.impl.shape.ShapeUtil;
 53 
 54 import java.lang.ref.SoftReference;
 55 
 56 final class SWContext {
 57 
 58     private final ResourceFactory factory;
 59     private final ShapeRenderer shapeRenderer;
 60     private SoftReference&lt;SWRTTexture&gt; readBackBufferRef;
 61     private SoftReference&lt;SWArgbPreTexture&gt; imagePaintTextureRef;
 62 
 63     interface ShapeRenderer {
 64         void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape);
 65         void dispose();
 66     }
 67 
 68     class NativeShapeRenderer implements ShapeRenderer {
 69         private SoftReference&lt;SWMaskTexture&gt; maskTextureRef;
 70 
 71         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
 72             final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);
 73             final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());
 74             mask.uploadToTexture(tex, 0, 0, false);
 75             pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),
 76                              mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());
 77         }
 78 
 79         private SWMaskTexture initMaskTexture(int width, int height) {
 80             final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
 81             maskTextureRef = new SoftReference&lt;SWMaskTexture&gt;(tex);
 82             return tex;
 83         }
 84 
 85         private void disposeMaskTexture() {
 86             if (maskTextureRef != null){
 87                 maskTextureRef.clear();
 88                 maskTextureRef = null;
 89             }
 90         }
 91 
 92         private SWMaskTexture validateMaskTexture(int width, int height) {
 93             SWMaskTexture tex;
 94             if (maskTextureRef == null) {
 95                 tex = this.initMaskTexture(width, height);
 96             } else {
 97                 tex = maskTextureRef.get();
 98                 if (tex == null ||
 99                     tex.getPhysicalWidth() &lt; width ||
100                     tex.getPhysicalHeight() &lt; height)
101                 {
102                     this.disposeMaskTexture();
103                     tex = this.initMaskTexture(width, height);
104                 }
105             }
106             return tex;
107         }
108 
109         public void dispose() {
110             this.disposeMaskTexture();
111         }
112     }
113 
114     static final class JavaShapeRenderer implements ShapeRenderer {
115         private final DirectRTPiscesAlphaConsumer alphaConsumer = new DirectRTPiscesAlphaConsumer();
116 
117         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
118             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
119                 // RT-27427
120                 // TODO: Optimize the combinatorial strokes for simple
121                 // shapes and/or teach the rasterizer to be able to
122                 // do a &quot;differential fill&quot; between two shapes.
123                 // Note that most simple shapes will use a more optimized path
124                 // than this method for the INNER/OUTER strokes anyway.
125                 shape = stroke.createStrokedShape(shape);
126                 stroke = null;
127             }
128             final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);
129             alphaConsumer.initConsumer(r, pr);
130             r.produceAlphas(alphaConsumer);
131         }
132 
133         public void dispose() { }
134     }
135 
136     static final class MarlinShapeRenderer implements ShapeRenderer {
137         private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();
138 
139         @Override
140         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
141             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
142                 // RT-27427
143                 // TODO: Optimize the combinatorial strokes for simple
144                 // shapes and/or teach the rasterizer to be able to
145                 // do a &quot;differential fill&quot; between two shapes.
146                 // Note that most simple shapes will use a more optimized path
147                 // than this method for the INNER/OUTER strokes anyway.
148                 shape = stroke.createStrokedShape(shape);
149                 stroke = null;
150             }
151             final RendererContext rdrCtx = MarlinRenderingEngine.getRendererContext();
152             MarlinRenderer renderer = null;
153             try {
154                 if (shape instanceof Path2D) {
155                     renderer = MarlinPrismUtils.setupRenderer(rdrCtx, (Path2D) shape, stroke, tr, clip,
156                             antialiasedShape);
157                 }
158                 if (renderer == null) {
159                     renderer = MarlinPrismUtils.setupRenderer(rdrCtx, shape, stroke, tr, clip,
160                             antialiasedShape);
161                 }
162                 final int outpix_xmin = renderer.getOutpixMinX();
163                 final int outpix_xmax = renderer.getOutpixMaxX();
164                 final int outpix_ymin = renderer.getOutpixMinY();
165                 final int outpix_ymax = renderer.getOutpixMaxY();
166                 final int w = outpix_xmax - outpix_xmin;
167                 final int h = outpix_ymax - outpix_ymin;
168                 if ((w &lt;= 0) || (h &lt;= 0)) {
169                     return;
170                 }
171                 alphaConsumer.initConsumer(outpix_xmin, outpix_ymin, w, h, pr);
172                 renderer.produceAlphas(alphaConsumer);
173             } finally {
174                 if (renderer != null) {
175                     renderer.dispose();
176                 }
177                 // recycle the RendererContext instance
178                 MarlinRenderingEngine.returnRendererContext(rdrCtx);
179             }
180         }
181 
182         @Override
183         public void dispose() { }
184     }
185 
186     static final class DirectRTMarlinAlphaConsumer implements MarlinAlphaConsumer {
187         private byte alpha_map[];
188         private int x;
189         private int y;
190         private int w;
191         private int h;
192         private int rowNum;
193 
194         private PiscesRenderer pr;
195 
196         public void initConsumer(int x, int y, int w, int h, PiscesRenderer pr) {
197             this.x = x;
198             this.y = y;
199             this.w = w;
200             this.h = h;
201             rowNum = 0;
202             this.pr = pr;
203         }
204 
205         @Override
206         public int getOriginX() {
207             return x;
208         }
209 
210         @Override
211         public int getOriginY() {
212             return y;
213         }
214 
215         @Override
216         public int getWidth() {
217             return w;
218         }
219 
220         @Override
221         public int getHeight() {
222             return h;
223         }
224 
225         @Override
226         public void setMaxAlpha(int maxalpha) {
227             if ((alpha_map == null) || (alpha_map.length != maxalpha+1)) {
228                 alpha_map = new byte[maxalpha+1];
229                 for (int i = 0; i &lt;= maxalpha; i++) {
230                     alpha_map[i] = (byte) ((i*255 + maxalpha/2)/maxalpha);
231                 }
232             }
233         }
234 
235         @Override
236         public boolean supportBlockFlags() {
237             return false;
238         }
239 
240         @Override
241         public void clearAlphas(final int pix_y) {
242             // noop
243         }
244 
245         @Override
246         public void setAndClearRelativeAlphas(final int[] alphaDeltas, final int pix_y,
247                                               final int pix_from, final int pix_to)
248         {
249             // pix_from indicates the first alpha coverage != 0 within [x; pix_to[
250             pr.emitAndClearAlphaRow(alpha_map, alphaDeltas, pix_y, pix_from, pix_to, (pix_from - x), rowNum);
251             rowNum++;
252 
253             // clear properly the end of the alphaDeltas:
254             final int to = pix_to - x;
255             if (to &lt;= w) {
256                 alphaDeltas[to] = 0;
257             } else {
258                 alphaDeltas[w]  = 0;
259             }
260 
261             if (MarlinConst.DO_CHECKS) {
262                 IntArrayCache.check(alphaDeltas, pix_from - x, to + 1, 0);
263             }
264         }
265 
266         @Override
267         public void setAndClearRelativeAlphas(final int[] blkFlags, final int[] alphaDeltas, final int pix_y,
268                                               final int pix_from, final int pix_to)
269         {
270             throw new UnsupportedOperationException();
271         }
272     }
273 
274     static final class DMarlinShapeRenderer implements ShapeRenderer {
275         private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();
276 
277         @Override
278         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
279             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
280                 // RT-27427
281                 // TODO: Optimize the combinatorial strokes for simple
282                 // shapes and/or teach the rasterizer to be able to
283                 // do a &quot;differential fill&quot; between two shapes.
284                 // Note that most simple shapes will use a more optimized path
285                 // than this method for the INNER/OUTER strokes anyway.
286                 shape = stroke.createStrokedShape(shape);
287                 stroke = null;
288             }
289             final DRendererContext rdrCtx = DMarlinRenderingEngine.getRendererContext();
290             DMarlinRenderer renderer = null;
291             try {
292                 if (shape instanceof Path2D) {
293                     renderer = DMarlinPrismUtils.setupRenderer(rdrCtx, (Path2D) shape, stroke, tr, clip,
294                             antialiasedShape);
295                 }
296                 if (renderer == null) {
297                     renderer = DMarlinPrismUtils.setupRenderer(rdrCtx, shape, stroke, tr, clip,
298                             antialiasedShape);
299                 }
300                 final int outpix_xmin = renderer.getOutpixMinX();
301                 final int outpix_xmax = renderer.getOutpixMaxX();
302                 final int outpix_ymin = renderer.getOutpixMinY();
303                 final int outpix_ymax = renderer.getOutpixMaxY();
304                 final int w = outpix_xmax - outpix_xmin;
305                 final int h = outpix_ymax - outpix_ymin;
306                 if ((w &lt;= 0) || (h &lt;= 0)) {
307                     return;
308                 }
309                 alphaConsumer.initConsumer(outpix_xmin, outpix_ymin, w, h, pr);
310                 renderer.produceAlphas(alphaConsumer);
311             } finally {
312                 if (renderer != null) {
313                     renderer.dispose();
314                 }
315                 // recycle the RendererContext instance
316                 DMarlinRenderingEngine.returnRendererContext(rdrCtx);
317             }
318         }
319 
320         @Override
321         public void dispose() { }
322     }
323 
324     SWContext(ResourceFactory factory) {
325         this.factory = factory;
326         switch (PrismSettings.rasterizerSpec) {
327             case JavaPisces:
328                 this.shapeRenderer = new JavaShapeRenderer();
329                 break;
330             case NativePisces:
331                 this.shapeRenderer = new NativeShapeRenderer();
332                 break;
333             case FloatMarlin:
334                 this.shapeRenderer = new MarlinShapeRenderer();
335                 break;
336             default:
337             case DoubleMarlin:
338                 this.shapeRenderer = new DMarlinShapeRenderer();
339                 break;
340         }
341     }
342 
343     void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
344         this.shapeRenderer.renderShape(pr, shape, stroke, tr, clip, antialiasedShape);
345     }
346 
347     private SWRTTexture initRBBuffer(int width, int height) {
348         final SWRTTexture tex = (SWRTTexture)factory.createRTTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
349         readBackBufferRef = new SoftReference&lt;SWRTTexture&gt;(tex);
350         return tex;
351     }
352 
353     private void disposeRBBuffer() {
354         if (readBackBufferRef != null) {
355             readBackBufferRef.clear();
356             readBackBufferRef = null;
357         }
358     }
359 
360     SWRTTexture validateRBBuffer(int width, int height) {
361         SWRTTexture tex;
362         if (readBackBufferRef == null) {
363             tex = this.initRBBuffer(width, height);
364         } else {
365             tex = readBackBufferRef.get();
366             if (tex == null ||
367                 tex.getPhysicalWidth() &lt; width ||
368                 tex.getPhysicalHeight() &lt; height)
369             {
370                 this.disposeRBBuffer();
371                 tex = this.initRBBuffer(width, height);
372             }
373             tex.setContentWidth(width);
374             tex.setContentHeight(height);
375         }
376         return tex;
377     }
378 
379     private SWArgbPreTexture initImagePaintTexture(int width, int height) {
380         final SWArgbPreTexture tex = (SWArgbPreTexture)factory.createTexture(PixelFormat.INT_ARGB_PRE,
381                 Texture.Usage.DEFAULT, Texture.WrapMode.REPEAT, width, height);
382         imagePaintTextureRef = new SoftReference&lt;SWArgbPreTexture&gt;(tex);
383         return tex;
384     }
385 
386     private void disposeImagePaintTexture() {
387         if (imagePaintTextureRef != null) {
388             imagePaintTextureRef.clear();
389             imagePaintTextureRef = null;
390         }
391     }
392 
393     SWArgbPreTexture validateImagePaintTexture(int width, int height) {
394         SWArgbPreTexture tex;
395         if (imagePaintTextureRef == null) {
396             tex = this.initImagePaintTexture(width, height);
397         } else {
398             tex = imagePaintTextureRef.get();
399             if (tex == null ||
400                 tex.getPhysicalWidth() &lt; width ||
401                 tex.getPhysicalHeight() &lt; height)
402             {
403                 this.disposeImagePaintTexture();
404                 tex = this.initImagePaintTexture(width, height);
405             }
406             tex.setContentWidth(width);
407             tex.setContentHeight(height);
408         }
409         return tex;
410     }
411 
412 
413     void dispose() {
414         this.disposeRBBuffer();
415         this.disposeImagePaintTexture();
416         this.shapeRenderer.dispose();
417     }
418 }
    </pre>
  </body>
</html>
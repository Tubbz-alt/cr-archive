<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../javafx/util/Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../prism/es2/X11GLFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
122             return nextY &lt; sampleRowMax;
123         }
124 
125         private int curY() {
126             return nextY - 1;
127         }
128     }
129 
130 
131 //////////////////////////////////////////////////////////////////////////////
132 //  EDGE LIST
133 //////////////////////////////////////////////////////////////////////////////
134 // TODO(maybe): very tempting to use fixed point here. A lot of opportunities
135 // for shifts and just removing certain operations altogether. (RT-26922)
136 
137     // common to all types of input path segments.
138     private static final int YMAX = 0;
139     private static final int CURX = 1;
140     // NEXT and OR are meant to be indeces into &quot;int&quot; fields, but arrays must
141     // be homogenous, so every field is a float. However floats can represent
<span class="line-modified">142     // exactly up to 26 bit ints, so we&#39;re ok.</span>
143     private static final int OR   = 2;
144     private static final int SLOPE = 3;
145     private static final int NEXT = 4;
146     private static final int SIZEOF_EDGE = 5;
147 


148     private int sampleRowMin;
149     private int sampleRowMax;
150     private float edgeMinX;
151     private float edgeMaxX;
152 
153     private float[] edges;
154     private int[] edgeBuckets;
155     private int numEdges;
156 
157     private static final float DEC_BND = 1.0f;
158     private static final float INC_BND = 0.4f;
159 
160     // each bucket is a linked list. this method adds eptr to the
161     // start &quot;bucket&quot;th linked list.
162     private void addEdgeToBucket(final int eptr, final int bucket) {
163         // we could implement this in terms of insertEdge, but this is a special
164         // case, so we optimize a bit.



165         edges[eptr+NEXT] = edgeBuckets[bucket*2];
166         edgeBuckets[bucket*2] = eptr + 1;
167         edgeBuckets[bucket*2 + 1] += 2;
168     }
169 
170     // Flattens using adaptive forward differencing. This only carries out
171     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
172     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
173     private void quadBreakIntoLinesAndAdd(float x0, float y0,
174                                           final Curve c,
175                                           final float x2, final float y2)
176     {
177         final float QUAD_DEC_BND = 32;
178         final int countlg = 4;
179         int count = 1 &lt;&lt; countlg;
180         int countsq = count * count;
181         float maxDD = Math.max(c.dbx / countsq, c.dby / countsq);
182         while (maxDD &gt; QUAD_DEC_BND) {
183             maxDD /= 4;
184             count &lt;&lt;= 1;
</pre>
<hr />
<pre>
277             or = 0;
278         }
279         final int firstCrossing = Math.max((int) Math.ceil(y1 - 0.5f), boundsMinY);
280         final int lastCrossing = Math.min((int) Math.ceil(y2 - 0.5f), boundsMaxY);
281         if (firstCrossing &gt;= lastCrossing) {
282             return;
283         }
284         if (firstCrossing &lt; sampleRowMin) { sampleRowMin = firstCrossing; }
285         if (lastCrossing &gt; sampleRowMax) { sampleRowMax = lastCrossing; }
286 
287         final float slope = (x2 - x1) / (y2 - y1);
288 
289         if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
290             if (x1 &lt; edgeMinX) { edgeMinX = x1; }
291             if (x2 &gt; edgeMaxX) { edgeMaxX = x2; }
292         } else {
293             if (x2 &lt; edgeMinX) { edgeMinX = x2; }
294             if (x1 &gt; edgeMaxX) { edgeMaxX = x1; }
295         }
296 






297         final int ptr = numEdges * SIZEOF_EDGE;
298         edges = Helpers.widenArray(edges, ptr, SIZEOF_EDGE);
299         numEdges++;
300         edges[ptr+OR] = or;
301         edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
302         edges[ptr+SLOPE] = slope;
303         edges[ptr+YMAX] = lastCrossing;
<span class="line-removed">304         final int bucketIdx = firstCrossing - boundsMinY;</span>
305         addEdgeToBucket(ptr, bucketIdx);
306         edgeBuckets[(lastCrossing - boundsMinY)*2 + 1] |= 1;
307     }
308 
309 // END EDGE LIST
310 //////////////////////////////////////////////////////////////////////////////
311 
312 
313     public static final int WIND_EVEN_ODD = 0;
314     public static final int WIND_NON_ZERO = 1;
315 
316     // Antialiasing
317     final private int SUBPIXEL_LG_POSITIONS_X;
318     final private int SUBPIXEL_LG_POSITIONS_Y;
319     final private int SUBPIXEL_POSITIONS_X;
320     final private int SUBPIXEL_POSITIONS_Y;
321     final private int SUBPIXEL_MASK_X;
322     final private int SUBPIXEL_MASK_Y;
323     final int MAX_AA_ALPHA;
324 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
122             return nextY &lt; sampleRowMax;
123         }
124 
125         private int curY() {
126             return nextY - 1;
127         }
128     }
129 
130 
131 //////////////////////////////////////////////////////////////////////////////
132 //  EDGE LIST
133 //////////////////////////////////////////////////////////////////////////////
134 // TODO(maybe): very tempting to use fixed point here. A lot of opportunities
135 // for shifts and just removing certain operations altogether. (RT-26922)
136 
137     // common to all types of input path segments.
138     private static final int YMAX = 0;
139     private static final int CURX = 1;
140     // NEXT and OR are meant to be indeces into &quot;int&quot; fields, but arrays must
141     // be homogenous, so every field is a float. However floats can represent
<span class="line-modified">142     // exactly up to 24 bit ints, so we&#39;re ok as long as we check for overflow.</span>
143     private static final int OR   = 2;
144     private static final int SLOPE = 3;
145     private static final int NEXT = 4;
146     private static final int SIZEOF_EDGE = 5;
147 
<span class="line-added">148     private static final int MAX_EDGE_IDX = 1 &lt;&lt; 24;</span>
<span class="line-added">149 </span>
150     private int sampleRowMin;
151     private int sampleRowMax;
152     private float edgeMinX;
153     private float edgeMaxX;
154 
155     private float[] edges;
156     private int[] edgeBuckets;
157     private int numEdges;
158 
159     private static final float DEC_BND = 1.0f;
160     private static final float INC_BND = 0.4f;
161 
162     // each bucket is a linked list. this method adds eptr to the
163     // start &quot;bucket&quot;th linked list.
164     private void addEdgeToBucket(final int eptr, final int bucket) {
165         // we could implement this in terms of insertEdge, but this is a special
166         // case, so we optimize a bit.
<span class="line-added">167         if (edgeBuckets[bucket*2] &gt;= MAX_EDGE_IDX) {</span>
<span class="line-added">168             throw new ArrayIndexOutOfBoundsException(edgeBuckets[bucket*2]);</span>
<span class="line-added">169         }</span>
170         edges[eptr+NEXT] = edgeBuckets[bucket*2];
171         edgeBuckets[bucket*2] = eptr + 1;
172         edgeBuckets[bucket*2 + 1] += 2;
173     }
174 
175     // Flattens using adaptive forward differencing. This only carries out
176     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
177     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
178     private void quadBreakIntoLinesAndAdd(float x0, float y0,
179                                           final Curve c,
180                                           final float x2, final float y2)
181     {
182         final float QUAD_DEC_BND = 32;
183         final int countlg = 4;
184         int count = 1 &lt;&lt; countlg;
185         int countsq = count * count;
186         float maxDD = Math.max(c.dbx / countsq, c.dby / countsq);
187         while (maxDD &gt; QUAD_DEC_BND) {
188             maxDD /= 4;
189             count &lt;&lt;= 1;
</pre>
<hr />
<pre>
282             or = 0;
283         }
284         final int firstCrossing = Math.max((int) Math.ceil(y1 - 0.5f), boundsMinY);
285         final int lastCrossing = Math.min((int) Math.ceil(y2 - 0.5f), boundsMaxY);
286         if (firstCrossing &gt;= lastCrossing) {
287             return;
288         }
289         if (firstCrossing &lt; sampleRowMin) { sampleRowMin = firstCrossing; }
290         if (lastCrossing &gt; sampleRowMax) { sampleRowMax = lastCrossing; }
291 
292         final float slope = (x2 - x1) / (y2 - y1);
293 
294         if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
295             if (x1 &lt; edgeMinX) { edgeMinX = x1; }
296             if (x2 &gt; edgeMaxX) { edgeMaxX = x2; }
297         } else {
298             if (x2 &lt; edgeMinX) { edgeMinX = x2; }
299             if (x1 &gt; edgeMaxX) { edgeMaxX = x1; }
300         }
301 
<span class="line-added">302         final int bucketIdx = firstCrossing - boundsMinY;</span>
<span class="line-added">303         final int nextCurrEdge = edgeBuckets[bucketIdx*2];</span>
<span class="line-added">304         if (nextCurrEdge &gt;= MAX_EDGE_IDX) {</span>
<span class="line-added">305             throw new ArrayIndexOutOfBoundsException(nextCurrEdge);</span>
<span class="line-added">306         }</span>
<span class="line-added">307 </span>
308         final int ptr = numEdges * SIZEOF_EDGE;
309         edges = Helpers.widenArray(edges, ptr, SIZEOF_EDGE);
310         numEdges++;
311         edges[ptr+OR] = or;
312         edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
313         edges[ptr+SLOPE] = slope;
314         edges[ptr+YMAX] = lastCrossing;

315         addEdgeToBucket(ptr, bucketIdx);
316         edgeBuckets[(lastCrossing - boundsMinY)*2 + 1] |= 1;
317     }
318 
319 // END EDGE LIST
320 //////////////////////////////////////////////////////////////////////////////
321 
322 
323     public static final int WIND_EVEN_ODD = 0;
324     public static final int WIND_NON_ZERO = 1;
325 
326     // Antialiasing
327     final private int SUBPIXEL_LG_POSITIONS_X;
328     final private int SUBPIXEL_LG_POSITIONS_Y;
329     final private int SUBPIXEL_POSITIONS_X;
330     final private int SUBPIXEL_POSITIONS_Y;
331     final private int SUBPIXEL_MASK_X;
332     final private int SUBPIXEL_MASK_Y;
333     final int MAX_AA_ALPHA;
334 
</pre>
</td>
</tr>
</table>
<center><a href="../javafx/util/Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../prism/es2/X11GLFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java b/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
--- a/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
+++ b/modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,10 +27,11 @@
 
 import com.sun.javafx.geom.Path2D;
 import com.sun.javafx.geom.Rectangle;
 import com.sun.javafx.geom.Shape;
 import com.sun.javafx.geom.transform.BaseTransform;
+import com.sun.javafx.util.Logging;
 import com.sun.marlin.DMarlinRenderer;
 import com.sun.marlin.DMarlinRenderingEngine;
 import com.sun.marlin.DRendererContext;
 import com.sun.marlin.IntArrayCache;
 import com.sun.marlin.MarlinAlphaConsumer;
@@ -67,15 +68,23 @@
 
     class NativeShapeRenderer implements ShapeRenderer {
         private SoftReference<SWMaskTexture> maskTextureRef;
 
         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
-            final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);
-            final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());
-            mask.uploadToTexture(tex, 0, 0, false);
-            pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),
-                             mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());
+            try {
+                final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);
+                final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());
+                mask.uploadToTexture(tex, 0, 0, false);
+                pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),
+                                 mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());
+            } catch (Throwable ex) {
+                if (PrismSettings.verbose) {
+                    ex.printStackTrace();
+                }
+                Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
+                        + ex.toString());
+            }
         }
 
         private SWMaskTexture initMaskTexture(int width, int height) {
             final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
             maskTextureRef = new SoftReference<SWMaskTexture>(tex);
@@ -123,13 +132,21 @@
                 // Note that most simple shapes will use a more optimized path
                 // than this method for the INNER/OUTER strokes anyway.
                 shape = stroke.createStrokedShape(shape);
                 stroke = null;
             }
-            final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);
-            alphaConsumer.initConsumer(r, pr);
-            r.produceAlphas(alphaConsumer);
+            try {
+                final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);
+                alphaConsumer.initConsumer(r, pr);
+                r.produceAlphas(alphaConsumer);
+            } catch (Throwable ex) {
+                if (PrismSettings.verbose) {
+                    ex.printStackTrace();
+                }
+                Logging.getJavaFXLogger().warning("Cannot rasterize Shape: "
+                        + ex.toString());
+            }
         }
 
         public void dispose() { }
     }
 

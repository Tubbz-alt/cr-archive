<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../types.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ffi64.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /* -----------------------------------------------------------------------
<span class="line-modified">  2    ffi.c - Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>

  3            Copyright (c) 2002  Ranjit Mathew
  4            Copyright (c) 2002  Bo Thorsen
  5            Copyright (c) 2002  Roger Sayle
  6            Copyright (C) 2008, 2010  Free Software Foundation, Inc.
  7 
  8    x86 Foreign Function Interface
  9 
 10    Permission is hereby granted, free of charge, to any person obtaining
 11    a copy of this software and associated documentation files (the
 12    ``Software&#39;&#39;), to deal in the Software without restriction, including
 13    without limitation the rights to use, copy, modify, merge, publish,
 14    distribute, sublicense, and/or sell copies of the Software, and to
 15    permit persons to whom the Software is furnished to do so, subject to
 16    the following conditions:
 17 
 18    The above copyright notice and this permission notice shall be included
 19    in all copies or substantial portions of the Software.
 20 
 21    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 22    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 23    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 24    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 25    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 26    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 27    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 28    DEALINGS IN THE SOFTWARE.
 29    ----------------------------------------------------------------------- */
 30 
<span class="line-modified"> 31 #if !defined(__x86_64__) || defined(_WIN64) || defined(__CYGWIN__)</span>
<span class="line-removed"> 32 </span>
<span class="line-removed"> 33 #ifdef _WIN64</span>
<span class="line-removed"> 34 #include &lt;windows.h&gt;</span>
<span class="line-removed"> 35 #endif</span>
<span class="line-removed"> 36 </span>
 37 #include &lt;ffi.h&gt;
 38 #include &lt;ffi_common.h&gt;
<span class="line-modified"> 39 </span>
 40 #include &lt;stdlib.h&gt;
<span class="line-modified"> 41 </span>
<span class="line-modified"> 42 </span>
<span class="line-modified"> 43 /* ffi_prep_args is called by the assembly routine once stack space</span>
<span class="line-modified"> 44    has been allocated for the function&#39;s arguments */</span>
<span class="line-modified"> 45 </span>
<span class="line-modified"> 46 unsigned int ffi_prep_args(char *stack, extended_cif *ecif);</span>
<span class="line-modified"> 47 unsigned int ffi_prep_args(char *stack, extended_cif *ecif)</span>
<span class="line-modified"> 48 {</span>
<span class="line-removed"> 49   register unsigned int i;</span>
<span class="line-removed"> 50   register void **p_argv;</span>
<span class="line-removed"> 51   register char *argp;</span>
<span class="line-removed"> 52   register ffi_type **p_arg;</span>
<span class="line-removed"> 53 #ifndef X86_WIN64</span>
<span class="line-removed"> 54   const int cabi = ecif-&gt;cif-&gt;abi;</span>
<span class="line-removed"> 55   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="line-removed"> 56   unsigned int stack_args_count = 0;</span>
<span class="line-removed"> 57   void *p_stack_data[3];</span>
<span class="line-removed"> 58   char *argp2 = stack;</span>
 59 #else
<span class="line-modified"> 60   #define dir 1</span>

 61 #endif
 62 
<span class="line-modified"> 63   argp = stack;</span>
<span class="line-modified"> 64 </span>
<span class="line-removed"> 65   if ((ecif-&gt;cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed"> 66        || ecif-&gt;cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="line-removed"> 67 #ifdef X86_WIN64</span>
<span class="line-removed"> 68       &amp;&amp; ((ecif-&gt;cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
 69 #endif
<span class="line-modified"> 70       )</span>
<span class="line-modified"> 71     {</span>
<span class="line-modified"> 72 #ifndef X86_WIN64</span>
<span class="line-modified"> 73       /* For fastcall/thiscall/register this is first register-passed</span>
<span class="line-modified"> 74          argument.  */</span>
<span class="line-modified"> 75       if (cabi == FFI_THISCALL || cabi == FFI_FASTCALL || cabi == FFI_REGISTER)</span>
<span class="line-removed"> 76         {</span>
<span class="line-removed"> 77           p_stack_data[stack_args_count] = argp;</span>
<span class="line-removed"> 78           ++stack_args_count;</span>
<span class="line-removed"> 79         }</span>
 80 #endif
 81 
<span class="line-modified"> 82       *(void **) argp = ecif-&gt;rvalue;</span>
<span class="line-modified"> 83       argp += sizeof(void*);</span>
<span class="line-modified"> 84     }</span>



 85 
<span class="line-modified"> 86   p_arg  = ecif-&gt;cif-&gt;arg_types;</span>
<span class="line-removed"> 87   p_argv = ecif-&gt;avalue;</span>
<span class="line-removed"> 88   if (dir &lt; 0)</span>
 89     {
<span class="line-modified"> 90       const int nargs = ecif-&gt;cif-&gt;nargs - 1;</span>
<span class="line-modified"> 91       if (nargs &gt; 0)</span>
<span class="line-modified"> 92       {</span>
<span class="line-modified"> 93         p_arg  += nargs;</span>
<span class="line-modified"> 94         p_argv += nargs;</span>





 95       }
<span class="line-removed"> 96     }</span>
 97 
<span class="line-modified"> 98   for (i = ecif-&gt;cif-&gt;nargs;</span>
<span class="line-removed"> 99        i != 0;</span>
<span class="line-removed">100        i--, p_arg += dir, p_argv += dir)</span>
101     {
<span class="line-modified">102 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">103       size_t z = 0;</span>
<span class="line-removed">104 #endif // GSTREAMER_LITE</span>
<span class="line-removed">105 </span>
<span class="line-removed">106       /* Align if necessary */</span>
<span class="line-removed">107       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="line-removed">108         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">111       z = (*p_arg)-&gt;size;</span>
<span class="line-removed">112 #else // GSTREAMER_LITE</span>
<span class="line-removed">113       size_t z = (*p_arg)-&gt;size;</span>
<span class="line-removed">114 #endif // GSTREAMER_LITE</span>
<span class="line-removed">115 </span>
<span class="line-removed">116 #ifdef X86_WIN64</span>
<span class="line-removed">117       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="line-removed">118           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="line-removed">119               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-removed">120 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-removed">121           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="line-removed">122 #endif</span>
<span class="line-removed">123           )</span>
<span class="line-removed">124         {</span>
<span class="line-removed">125           z = FFI_SIZEOF_ARG;</span>
<span class="line-removed">126           *(void **)argp = *p_argv;</span>
<span class="line-removed">127         }</span>
<span class="line-removed">128       else if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT)</span>
<span class="line-removed">129         {</span>
<span class="line-removed">130           memcpy(argp, *p_argv, z);</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132       else</span>
<span class="line-removed">133 #endif</span>
<span class="line-removed">134       if (z &lt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">135         {</span>
<span class="line-removed">136           z = FFI_SIZEOF_ARG;</span>
<span class="line-removed">137           switch ((*p_arg)-&gt;type)</span>
<span class="line-removed">138             {</span>
<span class="line-removed">139             case FFI_TYPE_SINT8:</span>
<span class="line-removed">140               *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);</span>
141               break;
<span class="line-modified">142 </span>








143             case FFI_TYPE_UINT8:
<span class="line-modified">144               *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);</span>
145               break;
<span class="line-modified">146 </span>





147             case FFI_TYPE_SINT16:
<span class="line-modified">148               *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);</span>
149               break;
<span class="line-modified">150 </span>
<span class="line-removed">151             case FFI_TYPE_UINT16:</span>
<span class="line-removed">152               *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);</span>
<span class="line-removed">153               break;</span>
<span class="line-removed">154 </span>
155             case FFI_TYPE_SINT32:
<span class="line-removed">156               *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);</span>
<span class="line-removed">157               break;</span>
<span class="line-removed">158 </span>
159             case FFI_TYPE_UINT32:
<span class="line-modified">160               *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);</span>

161               break;
<span class="line-modified">162 </span>



163             case FFI_TYPE_STRUCT:
<span class="line-modified">164               *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);</span>




















165               break;
<span class="line-removed">166 </span>
167             default:
<span class="line-modified">168               FFI_ASSERT(0);</span>

169             }


170         }
<span class="line-modified">171       else</span>


172         {
<span class="line-modified">173           memcpy(argp, *p_argv, z);</span>




















174         }





175 
<span class="line-modified">176 #ifndef X86_WIN64</span>
<span class="line-removed">177     /* For thiscall/fastcall/register convention register-passed arguments</span>
<span class="line-removed">178        are the first two none-floating-point arguments with a size</span>
<span class="line-removed">179        smaller or equal to sizeof (void*).  */</span>
<span class="line-removed">180     if ((z == FFI_SIZEOF_ARG)</span>
<span class="line-removed">181         &amp;&amp; ((cabi == FFI_REGISTER)</span>
<span class="line-removed">182           || (cabi == FFI_THISCALL &amp;&amp; stack_args_count &lt; 1)</span>
<span class="line-removed">183           || (cabi == FFI_FASTCALL &amp;&amp; stack_args_count &lt; 2))</span>
<span class="line-removed">184         &amp;&amp; ((*p_arg)-&gt;type != FFI_TYPE_FLOAT &amp;&amp; (*p_arg)-&gt;type != FFI_TYPE_STRUCT)</span>
<span class="line-removed">185        )</span>
186       {
<span class="line-modified">187         if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 2)</span>
<span class="line-modified">188           {</span>
<span class="line-modified">189             /* Iterating arguments backwards, so first register-passed argument</span>
<span class="line-modified">190                will be passed last. Shift temporary values to make place. */</span>
<span class="line-removed">191             p_stack_data[0] = p_stack_data[1];</span>
<span class="line-removed">192             p_stack_data[1] = p_stack_data[2];</span>
<span class="line-removed">193             stack_args_count = 2;</span>
<span class="line-removed">194           }</span>
<span class="line-removed">195 </span>
<span class="line-removed">196         p_stack_data[stack_args_count] = argp;</span>
<span class="line-removed">197         ++stack_args_count;</span>
198       }
<span class="line-modified">199 #endif</span>
200 
<span class="line-modified">201 #ifdef X86_WIN64</span>
<span class="line-removed">202       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="line-removed">203 #else</span>
<span class="line-removed">204       argp += z;</span>
<span class="line-removed">205 #endif</span>
206     }
207 
<span class="line-modified">208 #ifndef X86_WIN64</span>
<span class="line-modified">209   /* We need to move the register-passed arguments for thiscall/fastcall/register</span>
<span class="line-removed">210      on top of stack, so that those can be moved to registers by call-handler.  */</span>
<span class="line-removed">211   if (stack_args_count &gt; 0)</span>
212     {
<span class="line-modified">213 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">214       int i;</span>
<span class="line-removed">215 #endif // GSTREAMER_LITE</span>
<span class="line-removed">216       if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 1)</span>
217         {
<span class="line-modified">218           /* Reverse order if iterating arguments backwards */</span>
<span class="line-modified">219           ffi_arg tmp = *(ffi_arg*) p_stack_data[0];</span>
<span class="line-modified">220           *(ffi_arg*) p_stack_data[0] = *(ffi_arg*) p_stack_data[stack_args_count - 1];</span>
<span class="line-modified">221           *(ffi_arg*) p_stack_data[stack_args_count - 1] = tmp;</span>
<span class="line-modified">222         }</span>



223 
<span class="line-modified">224 #ifndef GSTREAMER_LITE</span>
<span class="line-modified">225       int i;</span>
<span class="line-modified">226 #endif // GSTREAMER_LITE</span>
<span class="line-modified">227       for (i = 0; i &lt; stack_args_count; i++)</span>
<span class="line-modified">228         {</span>
<span class="line-removed">229           if (p_stack_data[i] != argp2)</span>
<span class="line-removed">230             {</span>
<span class="line-removed">231               ffi_arg tmp = *(ffi_arg*) p_stack_data[i];</span>
<span class="line-removed">232               memmove (argp2 + FFI_SIZEOF_ARG, argp2, (size_t) ((char*) p_stack_data[i] - (char*)argp2));</span>
<span class="line-removed">233               *(ffi_arg *) argp2 = tmp;</span>
<span class="line-removed">234             }</span>
235 
<span class="line-modified">236           argp2 += FFI_SIZEOF_ARG;</span>

237         }
238     }
239 
<span class="line-modified">240     return stack_args_count;</span>
<span class="line-removed">241 #endif</span>
<span class="line-removed">242     return 0;</span>
<span class="line-removed">243 }</span>
<span class="line-removed">244 </span>
<span class="line-removed">245 /* Perform machine dependent cif processing */</span>
<span class="line-removed">246 ffi_status ffi_prep_cif_machdep(ffi_cif *cif)</span>
247 {
<span class="line-modified">248   unsigned int i;</span>
<span class="line-modified">249   ffi_type **ptr;</span>
<span class="line-modified">250 </span>
<span class="line-modified">251   /* Set the return type flag */</span>
<span class="line-modified">252   switch (cif-&gt;rtype-&gt;type)</span>
<span class="line-modified">253     {</span>
<span class="line-modified">254     case FFI_TYPE_VOID:</span>
<span class="line-modified">255     case FFI_TYPE_UINT8:</span>
<span class="line-modified">256     case FFI_TYPE_UINT16:</span>
<span class="line-modified">257     case FFI_TYPE_SINT8:</span>
<span class="line-modified">258     case FFI_TYPE_SINT16:</span>
<span class="line-modified">259 #ifdef X86_WIN64</span>
<span class="line-modified">260     case FFI_TYPE_UINT32:</span>
<span class="line-modified">261     case FFI_TYPE_SINT32:</span>
<span class="line-modified">262 #endif</span>
<span class="line-modified">263     case FFI_TYPE_SINT64:</span>
<span class="line-modified">264     case FFI_TYPE_FLOAT:</span>
<span class="line-modified">265     case FFI_TYPE_DOUBLE:</span>
<span class="line-modified">266 #ifndef X86_WIN64</span>
<span class="line-modified">267 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-modified">268     case FFI_TYPE_LONGDOUBLE:</span>











269 #endif


270 #endif
<span class="line-removed">271       cif-&gt;flags = (unsigned) cif-&gt;rtype-&gt;type;</span>
<span class="line-removed">272       break;</span>
273 
<span class="line-modified">274     case FFI_TYPE_UINT64:</span>
<span class="line-removed">275 #ifdef X86_WIN64</span>
<span class="line-removed">276     case FFI_TYPE_POINTER:</span>
<span class="line-removed">277 #endif</span>
<span class="line-removed">278       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="line-removed">279       break;</span>
280 
<span class="line-modified">281     case FFI_TYPE_STRUCT:</span>
<span class="line-modified">282 #ifndef X86</span>
<span class="line-modified">283       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="line-removed">284         {</span>
<span class="line-removed">285           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */</span>
<span class="line-removed">286         }</span>
<span class="line-removed">287       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="line-removed">288         {</span>
<span class="line-removed">289           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */</span>
<span class="line-removed">290         }</span>
<span class="line-removed">291       else if (cif-&gt;rtype-&gt;size == 4)</span>
292         {
<span class="line-modified">293 #ifdef X86_WIN64</span>
<span class="line-modified">294           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_4B;</span>
<span class="line-modified">295 #else</span>
<span class="line-modified">296           cif-&gt;flags = FFI_TYPE_INT; /* same as int type */</span>
<span class="line-modified">297 #endif</span>
<span class="line-modified">298         }</span>
<span class="line-modified">299       else if (cif-&gt;rtype-&gt;size == 8)</span>







300         {
<span class="line-modified">301           cif-&gt;flags = FFI_TYPE_SINT64; /* same as int64 type */</span>
<span class="line-removed">302         }</span>
<span class="line-removed">303       else</span>
<span class="line-removed">304 #endif</span>
305         {
<span class="line-modified">306 #ifdef X86_WIN32</span>
<span class="line-modified">307           if (cif-&gt;abi == FFI_MS_CDECL)</span>
<span class="line-modified">308             cif-&gt;flags = FFI_TYPE_MS_STRUCT;</span>
<span class="line-modified">309           else</span>
<span class="line-modified">310 #endif</span>
<span class="line-modified">311             cif-&gt;flags = FFI_TYPE_STRUCT;</span>
<span class="line-modified">312           /* allocate space for return value pointer */</span>
<span class="line-modified">313           cif-&gt;bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);</span>
<span class="line-removed">314         }</span>
315       break;
<span class="line-removed">316 </span>
317     default:
<span class="line-modified">318 #ifdef X86_WIN64</span>
<span class="line-modified">319       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="line-removed">320       break;</span>
<span class="line-removed">321     case FFI_TYPE_INT:</span>
<span class="line-removed">322       cif-&gt;flags = FFI_TYPE_SINT32;</span>
<span class="line-removed">323 #else</span>
<span class="line-removed">324       cif-&gt;flags = FFI_TYPE_INT;</span>
<span class="line-removed">325 #endif</span>
326       break;
327     }
<span class="line-removed">328 </span>
<span class="line-removed">329   for (ptr = cif-&gt;arg_types, i = cif-&gt;nargs; i &gt; 0; i--, ptr++)</span>
<span class="line-removed">330     {</span>
<span class="line-removed">331       if (((*ptr)-&gt;alignment - 1) &amp; cif-&gt;bytes)</span>
<span class="line-removed">332         cif-&gt;bytes = ALIGN(cif-&gt;bytes, (*ptr)-&gt;alignment);</span>
<span class="line-removed">333       cif-&gt;bytes += (unsigned)ALIGN((*ptr)-&gt;size, FFI_SIZEOF_ARG);</span>
334     }
335 
<span class="line-modified">336 #ifdef X86_WIN64</span>
<span class="line-modified">337   /* ensure space for storing four registers */</span>
<span class="line-modified">338   cif-&gt;bytes += 4 * FFI_SIZEOF_ARG;</span>
<span class="line-modified">339 #endif</span>


340 
<span class="line-modified">341 #ifndef X86_WIN32</span>
<span class="line-modified">342 #ifndef X86_WIN64</span>
<span class="line-modified">343   if (cif-&gt;abi == FFI_SYSV || cif-&gt;abi == FFI_UNIX64)</span>
<span class="line-modified">344 #endif</span>
<span class="line-removed">345     cif-&gt;bytes = (cif-&gt;bytes + 15) &amp; ~0xF;</span>
<span class="line-removed">346 #endif</span>
347 
<span class="line-modified">348   return FFI_OK;</span>









349 }






350 
<span class="line-modified">351 #ifdef X86_WIN64</span>
<span class="line-modified">352 extern int</span>
<span class="line-modified">353 ffi_call_win64(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-modified">354                unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-modified">355 #else</span>
<span class="line-modified">356 extern void</span>
<span class="line-modified">357 ffi_call_win32(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-removed">358                unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-removed">359 extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-removed">360                           unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-removed">361 #endif</span>
362 
<span class="line-modified">363 void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
364 {
<span class="line-modified">365   extended_cif ecif;</span>
366 
<span class="line-modified">367   ecif.cif = cif;</span>
<span class="line-modified">368   ecif.avalue = avalue;</span>
<span class="line-modified">369 </span>
<span class="line-removed">370   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="line-removed">371   /* value address then we need to make one                     */</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 #ifdef X86_WIN64</span>
<span class="line-removed">374   if (rvalue == NULL</span>
<span class="line-removed">375       &amp;&amp; cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">376       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0))</span>
377     {
<span class="line-modified">378       ecif.rvalue = alloca((cif-&gt;rtype-&gt;size + 0xF) &amp; ~0xF);</span>

379     }
<span class="line-modified">380 #else</span>
<span class="line-removed">381   if (rvalue == NULL</span>
<span class="line-removed">382       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">383           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
384     {
<span class="line-modified">385       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>


386     }
<span class="line-removed">387 #endif</span>
388   else
<span class="line-removed">389     ecif.rvalue = rvalue;</span>
<span class="line-removed">390 </span>
<span class="line-removed">391 </span>
<span class="line-removed">392   switch (cif-&gt;abi)</span>
393     {
<span class="line-modified">394 #ifdef X86_WIN64</span>
<span class="line-modified">395     case FFI_WIN64:</span>
<span class="line-modified">396       ffi_call_win64(ffi_prep_args, &amp;ecif, cif-&gt;bytes,</span>
<span class="line-modified">397                      cif-&gt;flags, ecif.rvalue, fn);</span>
<span class="line-modified">398       break;</span>
<span class="line-modified">399 #else</span>
<span class="line-modified">400 #ifndef X86_WIN32</span>
<span class="line-modified">401     case FFI_SYSV:</span>
<span class="line-modified">402       ffi_call_SYSV(ffi_prep_args, &amp;ecif, cif-&gt;bytes, cif-&gt;flags, ecif.rvalue,</span>
<span class="line-modified">403                     fn);</span>
<span class="line-modified">404       break;</span>
<span class="line-modified">405 #else</span>
<span class="line-modified">406     case FFI_SYSV:</span>
<span class="line-modified">407     case FFI_MS_CDECL:</span>
<span class="line-modified">408 #endif</span>
<span class="line-modified">409     case FFI_STDCALL:</span>
<span class="line-modified">410     case FFI_THISCALL:</span>
<span class="line-modified">411     case FFI_FASTCALL:</span>
<span class="line-modified">412     case FFI_PASCAL:</span>
<span class="line-modified">413     case FFI_REGISTER:</span>
<span class="line-modified">414       ffi_call_win32(ffi_prep_args, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-modified">415                      ecif.rvalue, fn);</span>
<span class="line-modified">416       break;</span>
<span class="line-modified">417 #endif</span>
<span class="line-modified">418     default:</span>
<span class="line-modified">419       FFI_ASSERT(0);</span>
<span class="line-modified">420       break;</span>

421     }





422 }



423 
<span class="line-modified">424 </span>
<span class="line-removed">425 /** private members **/</span>
<span class="line-removed">426 </span>
<span class="line-removed">427 /* The following __attribute__((regparm(1))) decorations will have no effect</span>
<span class="line-removed">428    on MSVC or SUNPRO_C -- standard conventions apply. */</span>
<span class="line-removed">429 static unsigned int ffi_prep_incoming_args (char *stack, void **ret,</span>
<span class="line-removed">430                                             void** args, ffi_cif* cif);</span>
<span class="line-removed">431 void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)</span>
<span class="line-removed">432      __attribute__ ((regparm(1)));</span>
<span class="line-removed">433 unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)</span>
<span class="line-removed">434      __attribute__ ((regparm(1)));</span>
<span class="line-removed">435 unsigned int FFI_HIDDEN ffi_closure_WIN32_inner (ffi_closure *, void **, void *)</span>
<span class="line-removed">436      __attribute__ ((regparm(1)));</span>
<span class="line-removed">437 void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)</span>
<span class="line-removed">438      __attribute__ ((regparm(1)));</span>
<span class="line-removed">439 #ifdef X86_WIN32</span>
<span class="line-removed">440 void FFI_HIDDEN ffi_closure_raw_THISCALL (ffi_raw_closure *)</span>
<span class="line-removed">441      __attribute__ ((regparm(1)));</span>
<span class="line-removed">442 #endif</span>
<span class="line-removed">443 #ifndef X86_WIN64</span>
<span class="line-removed">444 void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *);</span>
<span class="line-removed">445 void FFI_HIDDEN ffi_closure_THISCALL (ffi_closure *);</span>
<span class="line-removed">446 void FFI_HIDDEN ffi_closure_FASTCALL (ffi_closure *);</span>
<span class="line-removed">447 void FFI_HIDDEN ffi_closure_REGISTER (ffi_closure *);</span>
<span class="line-removed">448 #else</span>
<span class="line-removed">449 void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);</span>
<span class="line-removed">450 #endif</span>
<span class="line-removed">451 </span>
<span class="line-removed">452 /* This function is jumped to by the trampoline */</span>
<span class="line-removed">453 </span>
<span class="line-removed">454 #ifdef X86_WIN64</span>
<span class="line-removed">455 void * FFI_HIDDEN</span>
<span class="line-removed">456 ffi_closure_win64_inner (ffi_closure *closure, void *args) {</span>
<span class="line-removed">457   ffi_cif       *cif;</span>
<span class="line-removed">458   void         **arg_area;</span>
<span class="line-removed">459   void          *result;</span>
<span class="line-removed">460   void          *resp = &amp;result;</span>
<span class="line-removed">461 </span>
<span class="line-removed">462   cif         = closure-&gt;cif;</span>
<span class="line-removed">463   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">464 </span>
<span class="line-removed">465   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">466    * element in that array points to the corresponding</span>
<span class="line-removed">467    * value on the stack; and if the function returns</span>
<span class="line-removed">468    * a structure, it will change RESP to point to the</span>
<span class="line-removed">469    * structure return address.  */</span>
<span class="line-removed">470 </span>
<span class="line-removed">471   ffi_prep_incoming_args(args, &amp;resp, arg_area, cif);</span>
<span class="line-removed">472 </span>
<span class="line-removed">473   (closure-&gt;fun) (cif, resp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">474 </span>
<span class="line-removed">475   /* The result is returned in rax.  This does the right thing for</span>
<span class="line-removed">476      result types except for floats; we have to &#39;mov xmm0, rax&#39; in the</span>
<span class="line-removed">477      caller to correct this.</span>
<span class="line-removed">478      TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!</span>
<span class="line-removed">479   */</span>
<span class="line-removed">480   return cif-&gt;rtype-&gt;size &gt; sizeof(void *) ? resp : *(void **)resp;</span>
481 }
482 
<span class="line-modified">483 #else</span>
<span class="line-modified">484 unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="line-removed">485 ffi_closure_SYSV_inner (ffi_closure *closure, void **respp, void *args)</span>
486 {
<span class="line-modified">487   /* our various things...  */</span>
<span class="line-removed">488   ffi_cif       *cif;</span>
<span class="line-removed">489   void         **arg_area;</span>
<span class="line-removed">490 </span>
<span class="line-removed">491   cif         = closure-&gt;cif;</span>
<span class="line-removed">492   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">493 </span>
<span class="line-removed">494   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">495    * element in that array points to the corresponding</span>
<span class="line-removed">496    * value on the stack; and if the function returns</span>
<span class="line-removed">497    * a structure, it will change RESP to point to the</span>
<span class="line-removed">498    * structure return address.  */</span>
<span class="line-removed">499 </span>
<span class="line-removed">500   ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="line-removed">501 </span>
<span class="line-removed">502   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">503 </span>
<span class="line-removed">504   return cif-&gt;flags;</span>
505 }
506 
<span class="line-modified">507 unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="line-modified">508 ffi_closure_WIN32_inner (ffi_closure *closure, void **respp, void *args)</span>

509 {
<span class="line-modified">510   /* our various things...  */</span>
<span class="line-removed">511   ffi_cif       *cif;</span>
<span class="line-removed">512   void         **arg_area;</span>
<span class="line-removed">513   unsigned int   ret;</span>
<span class="line-removed">514 </span>
<span class="line-removed">515   cif         = closure-&gt;cif;</span>
<span class="line-removed">516   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">517 </span>
<span class="line-removed">518   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">519    * element in that array points to the corresponding</span>
<span class="line-removed">520    * value on the stack; and if the function returns</span>
<span class="line-removed">521    * a structure, it will change RESP to point to the</span>
<span class="line-removed">522    * structure return address.  */</span>
<span class="line-removed">523 </span>
<span class="line-removed">524   ret = ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="line-removed">525 </span>
<span class="line-removed">526   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">527 </span>
<span class="line-removed">528   return ret;</span>
529 }
<span class="line-removed">530 #endif /* !X86_WIN64 */</span>
531 
<span class="line-modified">532 static unsigned int</span>
<span class="line-removed">533 ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,</span>
<span class="line-removed">534                        ffi_cif *cif)</span>
<span class="line-removed">535 {</span>
<span class="line-removed">536   register unsigned int i;</span>
<span class="line-removed">537   register void **p_argv;</span>
<span class="line-removed">538   register char *argp;</span>
<span class="line-removed">539   register ffi_type **p_arg;</span>
<span class="line-removed">540 #ifndef X86_WIN64</span>
<span class="line-removed">541   const int cabi = cif-&gt;abi;</span>
<span class="line-removed">542   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="line-removed">543   const unsigned int max_stack_count = (cabi == FFI_THISCALL) ? 1</span>
<span class="line-removed">544                                      : (cabi == FFI_FASTCALL) ? 2</span>
<span class="line-removed">545                                      : (cabi == FFI_REGISTER) ? 3</span>
<span class="line-removed">546                                      : 0;</span>
<span class="line-removed">547   unsigned int passed_regs = 0;</span>
<span class="line-removed">548   void *p_stack_data[3] = { stack - 1 };</span>
<span class="line-removed">549 #else</span>
<span class="line-removed">550   #define dir 1</span>
<span class="line-removed">551 #endif</span>
552 
<span class="line-modified">553   argp = stack;</span>
<span class="line-modified">554 #ifndef X86_WIN64</span>
<span class="line-modified">555   argp += max_stack_count * FFI_SIZEOF_ARG;</span>
<span class="line-removed">556 #endif</span>
557 
<span class="line-modified">558   if ((cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-modified">559        || cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="line-modified">560 #ifdef X86_WIN64</span>
<span class="line-modified">561       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-modified">562 #endif</span>
<span class="line-modified">563       )</span>























564     {
<span class="line-modified">565 #ifndef X86_WIN64</span>
<span class="line-modified">566       if (passed_regs &lt; max_stack_count)</span>
567         {
<span class="line-modified">568           *rvalue = *(void**) (stack + (passed_regs*FFI_SIZEOF_ARG));</span>
<span class="line-modified">569           ++passed_regs;</span>


570         }
<span class="line-modified">571       else</span>
<span class="line-modified">572 #endif</span>
<span class="line-modified">573         {</span>
<span class="line-removed">574           *rvalue = *(void **) argp;</span>
575           argp += sizeof(void *);


576         }
<span class="line-removed">577     }</span>
578 
<span class="line-modified">579 #ifndef X86_WIN64</span>
<span class="line-modified">580   /* Do register arguments first  */</span>
<span class="line-modified">581   for (i = 0, p_arg = cif-&gt;arg_types;</span>
<span class="line-modified">582        i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt; max_stack_count;</span>
<span class="line-modified">583        i++, p_arg++)</span>
584   {
<span class="line-modified">585 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">586       size_t sz = 0;</span>
<span class="line-modified">587 #endif // GSTREAMER_LITE</span>
<span class="line-modified">588       if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT</span>
<span class="line-removed">589          || (*p_arg)-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="line-removed">590         continue;</span>
<span class="line-removed">591 </span>
<span class="line-removed">592 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">593       sz = (*p_arg)-&gt;size;</span>
<span class="line-removed">594 #else // GSTREAMER_LITE</span>
<span class="line-removed">595       size_t sz = (*p_arg)-&gt;size;</span>
<span class="line-removed">596 #endif // GSTREAMER_LITE</span>
<span class="line-removed">597       if(sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">598         continue;</span>
<span class="line-removed">599 </span>
<span class="line-removed">600       p_stack_data[passed_regs] = avalue + i;</span>
<span class="line-removed">601       avalue[i] = stack + (passed_regs*FFI_SIZEOF_ARG);</span>
<span class="line-removed">602       ++passed_regs;</span>
<span class="line-removed">603     }</span>
<span class="line-removed">604 #endif</span>
605 
<span class="line-modified">606   p_arg = cif-&gt;arg_types;</span>
<span class="line-removed">607   p_argv = avalue;</span>
<span class="line-removed">608   if (dir &lt; 0)</span>
609     {
<span class="line-modified">610       const int nargs = cif-&gt;nargs - 1;</span>
<span class="line-modified">611       if (nargs &gt; 0)</span>

612       {
<span class="line-modified">613         p_arg  += nargs;</span>
<span class="line-modified">614         p_argv += nargs;</span>
615       }




616     }
<span class="line-modified">617 </span>
<span class="line-modified">618   for (i = cif-&gt;nargs;</span>
<span class="line-removed">619        i != 0;</span>
<span class="line-removed">620        i--, p_arg += dir, p_argv += dir)</span>
621     {
<span class="line-modified">622 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">623       size_t z = 0;</span>
<span class="line-modified">624 #endif // GSTREAMER_LITE</span>
<span class="line-modified">625       /* Align if necessary */</span>
<span class="line-modified">626       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="line-modified">627         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="line-modified">628 </span>
<span class="line-modified">629 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">630       z = (*p_arg)-&gt;size;</span>
<span class="line-modified">631 #else // GSTREAMER_LITE</span>
<span class="line-modified">632       size_t z = (*p_arg)-&gt;size;</span>
<span class="line-modified">633 #endif // GSTREAMER_LITE</span>
<span class="line-modified">634 </span>
<span class="line-modified">635 #ifdef X86_WIN64</span>
<span class="line-modified">636       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="line-modified">637           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="line-modified">638               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-removed">639 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-removed">640           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="line-removed">641 #endif</span>
<span class="line-removed">642           )</span>
643         {
<span class="line-modified">644           z = FFI_SIZEOF_ARG;</span>
<span class="line-modified">645           *p_argv = *(void **)argp;</span>


646         }
647       else
<span class="line-removed">648 #else</span>
<span class="line-removed">649       if (passed_regs &gt; 0</span>
<span class="line-removed">650           &amp;&amp; z &lt;= FFI_SIZEOF_ARG</span>
<span class="line-removed">651           &amp;&amp; (p_argv == p_stack_data[0]</span>
<span class="line-removed">652             || p_argv == p_stack_data[1]</span>
<span class="line-removed">653             || p_argv == p_stack_data[2]))</span>
654         {
<span class="line-modified">655           /* Already assigned a register value */</span>
<span class="line-modified">656           continue;</span>

657         }
<span class="line-removed">658       else</span>
<span class="line-removed">659 #endif</span>
<span class="line-removed">660         {</span>
<span class="line-removed">661           /* because we&#39;re little endian, this is what it turns into.   */</span>
<span class="line-removed">662           *p_argv = (void*) argp;</span>
663         }
664 
<span class="line-modified">665 #ifdef X86_WIN64</span>
<span class="line-removed">666       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="line-removed">667 #else</span>
<span class="line-removed">668       argp += z;</span>
<span class="line-removed">669 #endif</span>
670     }
671 
<span class="line-modified">672   return (size_t)argp - (size_t)stack;</span>
<span class="line-removed">673 }</span>
674 
<span class="line-modified">675 #define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \</span>
<span class="line-modified">676 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-modified">677    void*  __fun = (void*)(FUN); \</span>
<span class="line-modified">678    void*  __ctx = (void*)(CTX); \</span>
<span class="line-removed">679    *(unsigned char*) &amp;__tramp[0] = 0x41; \</span>
<span class="line-removed">680    *(unsigned char*) &amp;__tramp[1] = 0xbb; \</span>
<span class="line-removed">681    *(unsigned int*) &amp;__tramp[2] = MASK; /* mov $mask, %r11 */ \</span>
<span class="line-removed">682    *(unsigned char*) &amp;__tramp[6] = 0x48; \</span>
<span class="line-removed">683    *(unsigned char*) &amp;__tramp[7] = 0xb8; \</span>
<span class="line-removed">684    *(void**) &amp;__tramp[8] = __ctx; /* mov __ctx, %rax */ \</span>
<span class="line-removed">685    *(unsigned char *)  &amp;__tramp[16] = 0x49; \</span>
<span class="line-removed">686    *(unsigned char *)  &amp;__tramp[17] = 0xba; \</span>
<span class="line-removed">687    *(void**) &amp;__tramp[18] = __fun; /* mov __fun, %r10 */ \</span>
<span class="line-removed">688    *(unsigned char *)  &amp;__tramp[26] = 0x41; \</span>
<span class="line-removed">689    *(unsigned char *)  &amp;__tramp[27] = 0xff; \</span>
<span class="line-removed">690    *(unsigned char *)  &amp;__tramp[28] = 0xe2; /* jmp %r10 */ \</span>
<span class="line-removed">691  }</span>
<span class="line-removed">692 </span>
<span class="line-removed">693 /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */</span>
<span class="line-removed">694 </span>
<span class="line-removed">695 #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \</span>
<span class="line-removed">696 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">697    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">698    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">699    unsigned int  __dis = __fun - (__ctx + 10);  \</span>
<span class="line-removed">700    *(unsigned char*) &amp;__tramp[0] = 0xb8; \</span>
<span class="line-removed">701    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* movl __ctx, %eax */ \</span>
<span class="line-removed">702    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="line-removed">703    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
<span class="line-removed">704  }</span>
<span class="line-removed">705 </span>
<span class="line-removed">706 #define FFI_INIT_TRAMPOLINE_RAW_THISCALL(TRAMP,FUN,CTX,SIZE) \</span>
<span class="line-removed">707 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">708    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">709    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">710    unsigned int  __dis = __fun - (__ctx + 49);  \</span>
<span class="line-removed">711    unsigned short __size = (unsigned short)(SIZE); \</span>
<span class="line-removed">712    *(unsigned int *) &amp;__tramp[0] = 0x8324048b;      /* mov (%esp), %eax */ \</span>
<span class="line-removed">713    *(unsigned int *) &amp;__tramp[4] = 0x4c890cec;      /* sub $12, %esp */ \</span>
<span class="line-removed">714    *(unsigned int *) &amp;__tramp[8] = 0x04890424;      /* mov %ecx, 4(%esp) */ \</span>
<span class="line-removed">715    *(unsigned char*) &amp;__tramp[12] = 0x24;           /* mov %eax, (%esp) */ \</span>
<span class="line-removed">716    *(unsigned char*) &amp;__tramp[13] = 0xb8; \</span>
<span class="line-removed">717    *(unsigned int *) &amp;__tramp[14] = __size;         /* mov __size, %eax */ \</span>
<span class="line-removed">718    *(unsigned int *) &amp;__tramp[18] = 0x08244c8d;     /* lea 8(%esp), %ecx */ \</span>
<span class="line-removed">719    *(unsigned int *) &amp;__tramp[22] = 0x4802e8c1;     /* shr $2, %eax ; dec %eax */ \</span>
<span class="line-removed">720    *(unsigned short*) &amp;__tramp[26] = 0x0b74;        /* jz 1f */ \</span>
<span class="line-removed">721    *(unsigned int *) &amp;__tramp[28] = 0x8908518b;     /* 2b: mov 8(%ecx), %edx */ \</span>
<span class="line-removed">722    *(unsigned int *) &amp;__tramp[32] = 0x04c18311;     /* mov %edx, (%ecx) ; add $4, %ecx */ \</span>
<span class="line-removed">723    *(unsigned char*) &amp;__tramp[36] = 0x48;           /* dec %eax */ \</span>
<span class="line-removed">724    *(unsigned short*) &amp;__tramp[37] = 0xf575;        /* jnz 2b ; 1f: */ \</span>
<span class="line-removed">725    *(unsigned char*) &amp;__tramp[39] = 0xb8; \</span>
<span class="line-removed">726    *(unsigned int*)  &amp;__tramp[40] = __ctx;          /* movl __ctx, %eax */ \</span>
<span class="line-removed">727    *(unsigned char *)  &amp;__tramp[44] = 0xe8; \</span>
<span class="line-removed">728    *(unsigned int*)  &amp;__tramp[45] = __dis;          /* call __fun  */ \</span>
<span class="line-removed">729    *(unsigned char*)  &amp;__tramp[49] = 0xc2;          /* ret  */ \</span>
<span class="line-removed">730    *(unsigned short*)  &amp;__tramp[50] = (__size + 8); /* ret (__size + 8)  */ \</span>
<span class="line-removed">731  }</span>
<span class="line-removed">732 </span>
<span class="line-removed">733 #define FFI_INIT_TRAMPOLINE_WIN32(TRAMP,FUN,CTX)  \</span>
<span class="line-removed">734 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">735    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">736    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">737    unsigned int  __dis = __fun - (__ctx + 10); \</span>
<span class="line-removed">738    *(unsigned char*) &amp;__tramp[0] = 0x68; \</span>
<span class="line-removed">739    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* push __ctx */ \</span>
<span class="line-removed">740    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="line-removed">741    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
742  }
743 
<span class="line-removed">744 /* the cif must already be prep&#39;ed */</span>
<span class="line-removed">745 </span>
746 ffi_status
747 ffi_prep_closure_loc (ffi_closure* closure,
748                       ffi_cif* cif,
749                       void (*fun)(ffi_cif*,void*,void**,void*),
750                       void *user_data,
751                       void *codeloc)
752 {
<span class="line-modified">753 #ifdef X86_WIN64</span>
<span class="line-modified">754 #define ISFLOAT(IDX) (cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_FLOAT || cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_DOUBLE)</span>
<span class="line-modified">755 #define FLAG(IDX) (cif-&gt;nargs&gt;(IDX)&amp;&amp;ISFLOAT(IDX)?(1&lt;&lt;(IDX)):0)</span>
<span class="line-modified">756   if (cif-&gt;abi == FFI_WIN64)</span>
<span class="line-modified">757     {</span>
<span class="line-removed">758       int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);</span>
<span class="line-removed">759       FFI_INIT_TRAMPOLINE_WIN64 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">760                                  &amp;ffi_closure_win64,</span>
<span class="line-removed">761                                  codeloc, mask);</span>
<span class="line-removed">762       /* make sure we can execute here */</span>
<span class="line-removed">763     }</span>
<span class="line-removed">764 #else</span>
<span class="line-removed">765   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="line-removed">766     {</span>
<span class="line-removed">767       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">768                            &amp;ffi_closure_SYSV,</span>
<span class="line-removed">769                            (void*)codeloc);</span>
<span class="line-removed">770     }</span>
<span class="line-removed">771   else if (cif-&gt;abi == FFI_REGISTER)</span>
<span class="line-removed">772     {</span>
<span class="line-removed">773       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">774                                    &amp;ffi_closure_REGISTER,</span>
<span class="line-removed">775                                    (void*)codeloc);</span>
<span class="line-removed">776     }</span>
<span class="line-removed">777   else if (cif-&gt;abi == FFI_FASTCALL)</span>
<span class="line-removed">778     {</span>
<span class="line-removed">779       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">780                                    &amp;ffi_closure_FASTCALL,</span>
<span class="line-removed">781                                    (void*)codeloc);</span>
<span class="line-removed">782     }</span>
<span class="line-removed">783   else if (cif-&gt;abi == FFI_THISCALL)</span>
784     {
<span class="line-modified">785       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">786                                    &amp;ffi_closure_THISCALL,</span>
<span class="line-modified">787                                    (void*)codeloc);</span>













788     }
<span class="line-modified">789   else if (cif-&gt;abi == FFI_STDCALL || cif-&gt;abi == FFI_PASCAL)</span>
<span class="line-modified">790     {</span>
<span class="line-modified">791       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">792                                    &amp;ffi_closure_STDCALL,</span>
<span class="line-modified">793                                    (void*)codeloc);</span>









794     }
<span class="line-modified">795 #ifdef X86_WIN32</span>
<span class="line-modified">796   else if (cif-&gt;abi == FFI_MS_CDECL)</span>






797     {
<span class="line-modified">798       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">799                            &amp;ffi_closure_SYSV,</span>
<span class="line-modified">800                            (void*)codeloc);</span>
<span class="line-removed">801     }</span>
<span class="line-removed">802 #endif /* X86_WIN32 */</span>
<span class="line-removed">803 #endif /* !X86_WIN64 */</span>
<span class="line-removed">804   else</span>
805     {














806       return FFI_BAD_ABI;
807     }
808 
<span class="line-modified">809   closure-&gt;cif  = cif;</span>
<span class="line-modified">810   closure-&gt;user_data = user_data;</span>
<span class="line-modified">811   closure-&gt;fun  = fun;</span>
812 
813   return FFI_OK;
814 }
815 
816 /* ------- Native raw API support -------------------------------- */
817 
818 #if !FFI_NO_RAW_API
819 



820 ffi_status
<span class="line-modified">821 ffi_prep_raw_closure_loc (ffi_raw_closure* closure,</span>
<span class="line-modified">822                           ffi_cif* cif,</span>
823                           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
824                           void *user_data,
825                           void *codeloc)
826 {


827   int i;
828 
<span class="line-modified">829   if (cif-&gt;abi != FFI_SYSV</span>
<span class="line-removed">830 #ifdef X86_WIN32</span>
<span class="line-removed">831       &amp;&amp; cif-&gt;abi != FFI_THISCALL</span>
<span class="line-removed">832 #endif</span>
<span class="line-removed">833      )</span>
<span class="line-removed">834     return FFI_BAD_ABI;</span>
<span class="line-removed">835 </span>
<span class="line-removed">836   /* we currently don&#39;t support certain kinds of arguments for raw</span>
837      closures.  This should be implemented by a separate assembly
838      language routine, since it would require argument processing,
839      something we don&#39;t do now for performance.  */
<span class="line-removed">840 </span>
841   for (i = cif-&gt;nargs-1; i &gt;= 0; i--)

842     {
<span class="line-modified">843       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_STRUCT);</span>
<span class="line-modified">844       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_LONGDOUBLE);</span>

845     }
846 
<span class="line-modified">847 #ifdef X86_WIN32</span>
<span class="line-removed">848   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="line-removed">849     {</span>
<span class="line-removed">850 #endif</span>
<span class="line-removed">851   FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_SYSV,</span>
<span class="line-removed">852                        codeloc);</span>
<span class="line-removed">853 #ifdef X86_WIN32</span>
<span class="line-removed">854     }</span>
<span class="line-removed">855   else if (cif-&gt;abi == FFI_THISCALL)</span>
856     {
<span class="line-modified">857       FFI_INIT_TRAMPOLINE_RAW_THISCALL (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_THISCALL, codeloc, cif-&gt;bytes);</span>







858     }
<span class="line-modified">859 #endif</span>
<span class="line-modified">860   closure-&gt;cif  = cif;</span>









861   closure-&gt;user_data = user_data;
<span class="line-removed">862   closure-&gt;fun  = fun;</span>
863 
864   return FFI_OK;
865 }
866 
<span class="line-modified">867 static unsigned int</span>
<span class="line-modified">868 ffi_prep_args_raw(char *stack, extended_cif *ecif)</span>
869 {
<span class="line-modified">870   const ffi_cif *cif = ecif-&gt;cif;</span>
<span class="line-modified">871   unsigned int i, passed_regs = 0;</span>





























872 
<span class="line-modified">873 #ifndef X86_WIN64</span>
<span class="line-modified">874   const unsigned int abi = cif-&gt;abi;</span>
<span class="line-modified">875   const unsigned int max_regs = (abi == FFI_THISCALL) ? 1</span>
<span class="line-modified">876                               : (abi == FFI_FASTCALL) ? 2</span>
<span class="line-modified">877                               : (abi == FFI_REGISTER) ? 3</span>
<span class="line-modified">878                               : 0;</span>
879 
<span class="line-modified">880   if (cif-&gt;flags == FFI_TYPE_STRUCT)</span>
<span class="line-modified">881     ++passed_regs;</span>

882 
<span class="line-modified">883   for (i = 0; i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt;= max_regs; i++)</span>

884     {
<span class="line-modified">885 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">886       size_t sz = 0;</span>
<span class="line-modified">887 #endif // GSTREAMER_LITE</span>
<span class="line-modified">888       if (cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_FLOAT</span>
<span class="line-modified">889          || cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="line-modified">890         continue;</span>
<span class="line-modified">891 </span>
<span class="line-removed">892 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">893       sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="line-removed">894 #else // GSTREAMER_LITE</span>
<span class="line-removed">895       size_t sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="line-removed">896 #endif // GSTREAMER_LITE</span>
<span class="line-removed">897       if (sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">898         continue;</span>
<span class="line-removed">899 </span>
<span class="line-removed">900       ++passed_regs;</span>
<span class="line-removed">901     }</span>
<span class="line-removed">902 #endif</span>
<span class="line-removed">903 </span>
<span class="line-removed">904   memcpy (stack, ecif-&gt;avalue, cif-&gt;bytes);</span>
<span class="line-removed">905   return passed_regs;</span>
906 }







907 
<span class="line-modified">908 /* we borrow this routine from libffi (it must be changed, though, to</span>
<span class="line-modified">909  * actually call the function passed in the first argument.  as of</span>
<span class="line-removed">910  * libffi-1.20, this is not the case.)</span>
<span class="line-removed">911  */</span>
<span class="line-removed">912 </span>
<span class="line-removed">913 void</span>
<span class="line-removed">914 ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)</span>
915 {
<span class="line-modified">916   extended_cif ecif;</span>
<span class="line-modified">917   void **avalue = (void **)fake_avalue;</span>
<span class="line-modified">918 </span>
<span class="line-removed">919   ecif.cif = cif;</span>
<span class="line-removed">920   ecif.avalue = avalue;</span>
<span class="line-removed">921 </span>
<span class="line-removed">922   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="line-removed">923   /* value address then we need to make one                     */</span>
924 
<span class="line-modified">925   if (rvalue == NULL</span>
<span class="line-removed">926       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">927           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
928     {
<span class="line-modified">929       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>


930     }
931   else
<span class="line-removed">932     ecif.rvalue = rvalue;</span>
<span class="line-removed">933 </span>
<span class="line-removed">934 </span>
<span class="line-removed">935   switch (cif-&gt;abi)</span>
936     {
<span class="line-modified">937 #ifndef X86_WIN32</span>
<span class="line-modified">938     case FFI_SYSV:</span>
<span class="line-modified">939       ffi_call_SYSV(ffi_prep_args_raw, &amp;ecif, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-removed">940                     ecif.rvalue, fn);</span>
<span class="line-removed">941       break;</span>
<span class="line-removed">942 #else</span>
<span class="line-removed">943     case FFI_SYSV:</span>
<span class="line-removed">944     case FFI_MS_CDECL:</span>
<span class="line-removed">945 #endif</span>
<span class="line-removed">946 #ifndef X86_WIN64</span>
<span class="line-removed">947     case FFI_STDCALL:</span>
<span class="line-removed">948     case FFI_THISCALL:</span>
<span class="line-removed">949     case FFI_FASTCALL:</span>
<span class="line-removed">950     case FFI_PASCAL:</span>
<span class="line-removed">951     case FFI_REGISTER:</span>
<span class="line-removed">952       ffi_call_win32(ffi_prep_args_raw, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-removed">953                      ecif.rvalue, fn);</span>
<span class="line-removed">954       break;</span>
<span class="line-removed">955 #endif</span>
<span class="line-removed">956     default:</span>
<span class="line-removed">957       FFI_ASSERT(0);</span>
<span class="line-removed">958       break;</span>
959     }


960 }


961 
<span class="line-modified">962 #endif</span>
<span class="line-modified">963 </span>
<span class="line-modified">964 #endif /* !__x86_64__  || X86_WIN64 */</span>
<span class="line-modified">965 </span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /* -----------------------------------------------------------------------
<span class="line-modified">  2    ffi.c - Copyright (c) 2017  Anthony Green</span>
<span class="line-added">  3            Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>
  4            Copyright (c) 2002  Ranjit Mathew
  5            Copyright (c) 2002  Bo Thorsen
  6            Copyright (c) 2002  Roger Sayle
  7            Copyright (C) 2008, 2010  Free Software Foundation, Inc.
  8 
  9    x86 Foreign Function Interface
 10 
 11    Permission is hereby granted, free of charge, to any person obtaining
 12    a copy of this software and associated documentation files (the
 13    ``Software&#39;&#39;), to deal in the Software without restriction, including
 14    without limitation the rights to use, copy, modify, merge, publish,
 15    distribute, sublicense, and/or sell copies of the Software, and to
 16    permit persons to whom the Software is furnished to do so, subject to
 17    the following conditions:
 18 
 19    The above copyright notice and this permission notice shall be included
 20    in all copies or substantial portions of the Software.
 21 
 22    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 23    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 24    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 25    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 26    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 27    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 28    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 29    DEALINGS IN THE SOFTWARE.
 30    ----------------------------------------------------------------------- */
 31 
<span class="line-modified"> 32 #if defined(__i386__) || defined(_M_IX86)</span>





 33 #include &lt;ffi.h&gt;
 34 #include &lt;ffi_common.h&gt;
<span class="line-modified"> 35 #include &lt;stdint.h&gt;</span>
 36 #include &lt;stdlib.h&gt;
<span class="line-modified"> 37 #include &quot;internal.h&quot;</span>
<span class="line-modified"> 38 </span>
<span class="line-modified"> 39 /* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;</span>
<span class="line-modified"> 40    all further uses in this file will refer to the 80-bit type.  */</span>
<span class="line-modified"> 41 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-modified"> 42 # if FFI_TYPE_LONGDOUBLE != 4</span>
<span class="line-modified"> 43 #  error FFI_TYPE_LONGDOUBLE out of date</span>
<span class="line-modified"> 44 # endif</span>










 45 #else
<span class="line-modified"> 46 # undef FFI_TYPE_LONGDOUBLE</span>
<span class="line-added"> 47 # define FFI_TYPE_LONGDOUBLE 4</span>
 48 #endif
 49 
<span class="line-modified"> 50 #if defined(__GNUC__) &amp;&amp; !defined(__declspec)</span>
<span class="line-modified"> 51 # define __declspec(x)  __attribute__((x))</span>




 52 #endif
<span class="line-modified"> 53 </span>
<span class="line-modified"> 54 #if defined(_MSC_VER) &amp;&amp; defined(_M_IX86)</span>
<span class="line-modified"> 55 /* Stack is not 16-byte aligned on Windows.  */</span>
<span class="line-modified"> 56 #define STACK_ALIGN(bytes) (bytes)</span>
<span class="line-modified"> 57 #else</span>
<span class="line-modified"> 58 #define STACK_ALIGN(bytes) FFI_ALIGN (bytes, 16)</span>




 59 #endif
 60 
<span class="line-modified"> 61 /* Perform machine dependent cif processing.  */</span>
<span class="line-modified"> 62 ffi_status FFI_HIDDEN</span>
<span class="line-modified"> 63 ffi_prep_cif_machdep(ffi_cif *cif)</span>
<span class="line-added"> 64     {</span>
<span class="line-added"> 65   size_t bytes = 0;</span>
<span class="line-added"> 66   int i, n, flags, cabi = cif-&gt;abi;</span>
 67 
<span class="line-modified"> 68   switch (cabi)</span>


 69     {
<span class="line-modified"> 70     case FFI_SYSV:</span>
<span class="line-modified"> 71     case FFI_STDCALL:</span>
<span class="line-modified"> 72     case FFI_THISCALL:</span>
<span class="line-modified"> 73     case FFI_FASTCALL:</span>
<span class="line-modified"> 74     case FFI_MS_CDECL:</span>
<span class="line-added"> 75     case FFI_PASCAL:</span>
<span class="line-added"> 76     case FFI_REGISTER:</span>
<span class="line-added"> 77       break;</span>
<span class="line-added"> 78     default:</span>
<span class="line-added"> 79       return FFI_BAD_ABI;</span>
 80       }

 81 
<span class="line-modified"> 82   switch (cif-&gt;rtype-&gt;type)</span>


 83     {
<span class="line-modified"> 84     case FFI_TYPE_VOID:</span>
<span class="line-modified"> 85       flags = X86_RET_VOID;</span>





































 86               break;
<span class="line-modified"> 87     case FFI_TYPE_FLOAT:</span>
<span class="line-added"> 88       flags = X86_RET_FLOAT;</span>
<span class="line-added"> 89       break;</span>
<span class="line-added"> 90     case FFI_TYPE_DOUBLE:</span>
<span class="line-added"> 91       flags = X86_RET_DOUBLE;</span>
<span class="line-added"> 92       break;</span>
<span class="line-added"> 93     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added"> 94       flags = X86_RET_LDOUBLE;</span>
<span class="line-added"> 95       break;</span>
 96             case FFI_TYPE_UINT8:
<span class="line-modified"> 97       flags = X86_RET_UINT8;</span>
 98               break;
<span class="line-modified"> 99     case FFI_TYPE_UINT16:</span>
<span class="line-added">100       flags = X86_RET_UINT16;</span>
<span class="line-added">101       break;</span>
<span class="line-added">102     case FFI_TYPE_SINT8:</span>
<span class="line-added">103       flags = X86_RET_SINT8;</span>
<span class="line-added">104       break;</span>
105             case FFI_TYPE_SINT16:
<span class="line-modified">106       flags = X86_RET_SINT16;</span>
107               break;
<span class="line-modified">108     case FFI_TYPE_INT:</span>




109             case FFI_TYPE_SINT32:



110             case FFI_TYPE_UINT32:
<span class="line-modified">111     case FFI_TYPE_POINTER:</span>
<span class="line-added">112       flags = X86_RET_INT32;</span>
113               break;
<span class="line-modified">114     case FFI_TYPE_SINT64:</span>
<span class="line-added">115     case FFI_TYPE_UINT64:</span>
<span class="line-added">116       flags = X86_RET_INT64;</span>
<span class="line-added">117       break;</span>
118             case FFI_TYPE_STRUCT:
<span class="line-modified">119 #ifndef X86</span>
<span class="line-added">120       /* ??? This should be a different ABI rather than an ifdef.  */</span>
<span class="line-added">121       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="line-added">122     flags = X86_RET_STRUCT_1B;</span>
<span class="line-added">123       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="line-added">124     flags = X86_RET_STRUCT_2B;</span>
<span class="line-added">125       else if (cif-&gt;rtype-&gt;size == 4)</span>
<span class="line-added">126     flags = X86_RET_INT32;</span>
<span class="line-added">127       else if (cif-&gt;rtype-&gt;size == 8)</span>
<span class="line-added">128     flags = X86_RET_INT64;</span>
<span class="line-added">129       else</span>
<span class="line-added">130 #endif</span>
<span class="line-added">131     {</span>
<span class="line-added">132     do_struct:</span>
<span class="line-added">133       switch (cabi)</span>
<span class="line-added">134         {</span>
<span class="line-added">135         case FFI_THISCALL:</span>
<span class="line-added">136         case FFI_FASTCALL:</span>
<span class="line-added">137         case FFI_STDCALL:</span>
<span class="line-added">138         case FFI_MS_CDECL:</span>
<span class="line-added">139           flags = X86_RET_STRUCTARG;</span>
140               break;

141             default:
<span class="line-modified">142           flags = X86_RET_STRUCTPOP;</span>
<span class="line-added">143           break;</span>
144             }
<span class="line-added">145       /* Allocate space for return value pointer.  */</span>
<span class="line-added">146       bytes += FFI_ALIGN (sizeof(void*), FFI_SIZEOF_ARG);</span>
147         }
<span class="line-modified">148       break;</span>
<span class="line-added">149     case FFI_TYPE_COMPLEX:</span>
<span class="line-added">150       switch (cif-&gt;rtype-&gt;elements[0]-&gt;type)</span>
151         {
<span class="line-modified">152     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">153     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">154     case FFI_TYPE_SINT64:</span>
<span class="line-added">155     case FFI_TYPE_UINT64:</span>
<span class="line-added">156       goto do_struct;</span>
<span class="line-added">157     case FFI_TYPE_FLOAT:</span>
<span class="line-added">158     case FFI_TYPE_INT:</span>
<span class="line-added">159     case FFI_TYPE_SINT32:</span>
<span class="line-added">160     case FFI_TYPE_UINT32:</span>
<span class="line-added">161       flags = X86_RET_INT64;</span>
<span class="line-added">162       break;</span>
<span class="line-added">163     case FFI_TYPE_SINT16:</span>
<span class="line-added">164     case FFI_TYPE_UINT16:</span>
<span class="line-added">165       flags = X86_RET_INT32;</span>
<span class="line-added">166       break;</span>
<span class="line-added">167     case FFI_TYPE_SINT8:</span>
<span class="line-added">168     case FFI_TYPE_UINT8:</span>
<span class="line-added">169       flags = X86_RET_STRUCT_2B;</span>
<span class="line-added">170       break;</span>
<span class="line-added">171     default:</span>
<span class="line-added">172       return FFI_BAD_TYPEDEF;</span>
173         }
<span class="line-added">174       break;</span>
<span class="line-added">175     default:</span>
<span class="line-added">176       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">177     }</span>
<span class="line-added">178   cif-&gt;flags = flags;</span>
179 
<span class="line-modified">180   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>









181       {
<span class="line-modified">182       ffi_type *t = cif-&gt;arg_types[i];</span>
<span class="line-modified">183 </span>
<span class="line-modified">184       bytes = FFI_ALIGN (bytes, t-&gt;alignment);</span>
<span class="line-modified">185       bytes += FFI_ALIGN (t-&gt;size, FFI_SIZEOF_ARG);</span>







186       }
<span class="line-modified">187   cif-&gt;bytes = bytes;</span>
188 
<span class="line-modified">189   return FFI_OK;</span>




190     }
191 
<span class="line-modified">192 static ffi_arg</span>
<span class="line-modified">193 extend_basic_type(void *arg, int type)</span>


194     {
<span class="line-modified">195   switch (type)</span>



196         {
<span class="line-modified">197     case FFI_TYPE_SINT8:</span>
<span class="line-modified">198       return *(SINT8 *)arg;</span>
<span class="line-modified">199     case FFI_TYPE_UINT8:</span>
<span class="line-modified">200       return *(UINT8 *)arg;</span>
<span class="line-modified">201     case FFI_TYPE_SINT16:</span>
<span class="line-added">202       return *(SINT16 *)arg;</span>
<span class="line-added">203     case FFI_TYPE_UINT16:</span>
<span class="line-added">204       return *(UINT16 *)arg;</span>
205 
<span class="line-modified">206     case FFI_TYPE_SINT32:</span>
<span class="line-modified">207     case FFI_TYPE_UINT32:</span>
<span class="line-modified">208     case FFI_TYPE_POINTER:</span>
<span class="line-modified">209     case FFI_TYPE_FLOAT:</span>
<span class="line-modified">210       return *(UINT32 *)arg;</span>






211 
<span class="line-modified">212     default:</span>
<span class="line-added">213       abort();</span>
214         }
215     }
216 
<span class="line-modified">217 struct call_frame</span>






218 {
<span class="line-modified">219   void *ebp;        /* 0 */</span>
<span class="line-modified">220   void *retaddr;    /* 4 */</span>
<span class="line-modified">221   void (*fn)(void); /* 8 */</span>
<span class="line-modified">222   int flags;        /* 12 */</span>
<span class="line-modified">223   void *rvalue;     /* 16 */</span>
<span class="line-modified">224   unsigned regs[3]; /* 20-28 */</span>
<span class="line-modified">225 };</span>
<span class="line-modified">226 </span>
<span class="line-modified">227 struct abi_params</span>
<span class="line-modified">228 {</span>
<span class="line-modified">229   int dir;      /* parameter growth direction */</span>
<span class="line-modified">230   int static_chain; /* the static chain register used by gcc */</span>
<span class="line-modified">231   int nregs;        /* number of register parameters */</span>
<span class="line-modified">232   int regs[3];</span>
<span class="line-modified">233 };</span>
<span class="line-modified">234 </span>
<span class="line-modified">235 static const struct abi_params abi_params[FFI_LAST_ABI] = {</span>
<span class="line-modified">236   [FFI_SYSV] = { 1, R_ECX, 0 },</span>
<span class="line-modified">237   [FFI_THISCALL] = { 1, R_EAX, 1, { R_ECX } },</span>
<span class="line-modified">238   [FFI_FASTCALL] = { 1, R_EAX, 2, { R_ECX, R_EDX } },</span>
<span class="line-modified">239   [FFI_STDCALL] = { 1, R_ECX, 0 },</span>
<span class="line-added">240   [FFI_PASCAL] = { -1, R_ECX, 0 },</span>
<span class="line-added">241   /* ??? No defined static chain; gcc does not support REGISTER.  */</span>
<span class="line-added">242   [FFI_REGISTER] = { -1, R_ECX, 3, { R_EAX, R_EDX, R_ECX } },</span>
<span class="line-added">243   [FFI_MS_CDECL] = { 1, R_ECX, 0 }</span>
<span class="line-added">244 };</span>
<span class="line-added">245 </span>
<span class="line-added">246 #ifdef HAVE_FASTCALL</span>
<span class="line-added">247   #ifdef _MSC_VER</span>
<span class="line-added">248     #define FFI_DECLARE_FASTCALL __fastcall</span>
<span class="line-added">249   #else</span>
<span class="line-added">250     #define FFI_DECLARE_FASTCALL __declspec(fastcall)</span>
251 #endif
<span class="line-added">252 #else</span>
<span class="line-added">253   #define FFI_DECLARE_FASTCALL</span>
254 #endif


255 
<span class="line-modified">256 extern void FFI_DECLARE_FASTCALL ffi_call_i386(struct call_frame *, char *) FFI_HIDDEN;</span>





257 
<span class="line-modified">258 static void</span>
<span class="line-modified">259 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-modified">260           void **avalue, void *closure)</span>








261         {
<span class="line-modified">262   size_t rsize, bytes;</span>
<span class="line-modified">263   struct call_frame *frame;</span>
<span class="line-modified">264   char *stack, *argp;</span>
<span class="line-modified">265   ffi_type **arg_types;</span>
<span class="line-modified">266   int flags, cabi, i, n, dir, narg_reg;</span>
<span class="line-modified">267   const struct abi_params *pabi;</span>
<span class="line-modified">268 </span>
<span class="line-added">269   flags = cif-&gt;flags;</span>
<span class="line-added">270   cabi = cif-&gt;abi;</span>
<span class="line-added">271   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">272   dir = pabi-&gt;dir;</span>
<span class="line-added">273 </span>
<span class="line-added">274   rsize = 0;</span>
<span class="line-added">275   if (rvalue == NULL)</span>
276         {
<span class="line-modified">277       switch (flags)</span>



278         {
<span class="line-modified">279     case X86_RET_FLOAT:</span>
<span class="line-modified">280     case X86_RET_DOUBLE:</span>
<span class="line-modified">281     case X86_RET_LDOUBLE:</span>
<span class="line-modified">282     case X86_RET_STRUCTPOP:</span>
<span class="line-modified">283     case X86_RET_STRUCTARG:</span>
<span class="line-modified">284       /* The float cases need to pop the 387 stack.</span>
<span class="line-modified">285          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="line-modified">286       rsize = cif-&gt;rtype-&gt;size;</span>

287       break;

288     default:
<span class="line-modified">289       /* We can pretend that the callee returns nothing.  */</span>
<span class="line-modified">290       flags = X86_RET_VOID;</span>






291       break;
292     }






293     }
294 
<span class="line-modified">295   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="line-modified">296   stack = alloca(bytes + sizeof(*frame) + rsize);</span>
<span class="line-modified">297   argp = (dir &lt; 0 ? stack + bytes : stack);</span>
<span class="line-modified">298   frame = (struct call_frame *)(stack + bytes);</span>
<span class="line-added">299   if (rsize)</span>
<span class="line-added">300     rvalue = frame + 1;</span>
301 
<span class="line-modified">302   frame-&gt;fn = fn;</span>
<span class="line-modified">303   frame-&gt;flags = flags;</span>
<span class="line-modified">304   frame-&gt;rvalue = rvalue;</span>
<span class="line-modified">305   frame-&gt;regs[pabi-&gt;static_chain] = (unsigned)closure;</span>


306 
<span class="line-modified">307   narg_reg = 0;</span>
<span class="line-added">308   switch (flags)</span>
<span class="line-added">309     {</span>
<span class="line-added">310     case X86_RET_STRUCTARG:</span>
<span class="line-added">311       /* The pointer is passed as the first argument.  */</span>
<span class="line-added">312       if (pabi-&gt;nregs &gt; 0)</span>
<span class="line-added">313     {</span>
<span class="line-added">314       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="line-added">315       narg_reg = 1;</span>
<span class="line-added">316       break;</span>
317 }
<span class="line-added">318       /* fallthru */</span>
<span class="line-added">319     case X86_RET_STRUCTPOP:</span>
<span class="line-added">320       *(void **)argp = rvalue;</span>
<span class="line-added">321       argp += sizeof(void *);</span>
<span class="line-added">322       break;</span>
<span class="line-added">323     }</span>
324 
<span class="line-modified">325   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">326   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>
<span class="line-modified">327     {</span>
<span class="line-modified">328       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">329       void *valp = avalue[i];</span>
<span class="line-modified">330       size_t z = ty-&gt;size;</span>
<span class="line-modified">331       int t = ty-&gt;type;</span>




332 
<span class="line-modified">333       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>
334 {
<span class="line-modified">335       ffi_arg val = extend_basic_type (valp, t);</span>
336 
<span class="line-modified">337       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="line-modified">338         frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="line-modified">339       else if (dir &lt; 0)</span>







340     {
<span class="line-modified">341           argp -= 4;</span>
<span class="line-added">342           *(ffi_arg *)argp = val;</span>
343     }
<span class="line-modified">344       else</span>



345     {
<span class="line-modified">346           *(ffi_arg *)argp = val;</span>
<span class="line-added">347           argp += 4;</span>
<span class="line-added">348     }</span>
349     }

350   else




351     {
<span class="line-modified">352       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">353       size_t align = FFI_SIZEOF_ARG;</span>
<span class="line-modified">354 </span>
<span class="line-modified">355       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="line-modified">356          as 64-bit integer or struct, all following integer paramters</span>
<span class="line-modified">357          will be passed on stack.  */</span>
<span class="line-modified">358       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="line-modified">359           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="line-modified">360           || t == FFI_TYPE_UINT64</span>
<span class="line-modified">361           || t == FFI_TYPE_STRUCT))</span>
<span class="line-modified">362         narg_reg = 2;</span>
<span class="line-modified">363 </span>
<span class="line-modified">364       /* Alignment rules for arguments are quite complex.  Vectors and</span>
<span class="line-modified">365          structures with 16 byte alignment get it.  Note that long double</span>
<span class="line-modified">366          on Darwin does have 16 byte alignment, and does not get this</span>
<span class="line-modified">367          alignment if passed directly; a structure with a long double</span>
<span class="line-modified">368          inside, however, would get 16 byte alignment.  Since libffi does</span>
<span class="line-modified">369          not support vectors, we need non concern ourselves with other</span>
<span class="line-modified">370          cases.  */</span>
<span class="line-modified">371       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="line-modified">372         align = 16;</span>
<span class="line-modified">373 </span>
<span class="line-modified">374       if (dir &lt; 0)</span>
<span class="line-modified">375     {</span>
<span class="line-modified">376           /* ??? These reverse argument ABIs are probably too old</span>
<span class="line-modified">377          to have cared about alignment.  Someone should check.  */</span>
<span class="line-modified">378           argp -= za;</span>
<span class="line-added">379           memcpy (argp, valp, z);</span>
380     }
<span class="line-added">381       else</span>
<span class="line-added">382         {</span>
<span class="line-added">383           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="line-added">384           memcpy (argp, valp, z);</span>
<span class="line-added">385           argp += za;</span>
386 }
<span class="line-added">387     }</span>
<span class="line-added">388     }</span>
<span class="line-added">389   FFI_ASSERT (dir &gt; 0 || argp == stack);</span>
390 
<span class="line-modified">391   ffi_call_i386 (frame, stack);</span>
























































392 }
393 
<span class="line-modified">394 void</span>
<span class="line-modified">395 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>

396 {
<span class="line-modified">397   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>

















398 }
399 
<span class="line-modified">400 void</span>
<span class="line-modified">401 ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">402          void **avalue, void *closure)</span>
403 {
<span class="line-modified">404   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>


















405 }

406 
<span class="line-modified">407 /** private members **/</span>



















408 
<span class="line-modified">409 void FFI_HIDDEN ffi_closure_i386(void);</span>
<span class="line-modified">410 void FFI_HIDDEN ffi_closure_STDCALL(void);</span>
<span class="line-modified">411 void FFI_HIDDEN ffi_closure_REGISTER(void);</span>

412 
<span class="line-modified">413 struct closure_frame</span>
<span class="line-modified">414 {</span>
<span class="line-modified">415   unsigned rettemp[4];              /* 0 */</span>
<span class="line-modified">416   unsigned regs[3];             /* 16-24 */</span>
<span class="line-modified">417   ffi_cif *cif;                 /* 28 */</span>
<span class="line-modified">418   void (*fun)(ffi_cif*,void*,void**,void*); /* 32 */</span>
<span class="line-added">419   void *user_data;              /* 36 */</span>
<span class="line-added">420 };</span>
<span class="line-added">421 </span>
<span class="line-added">422 int FFI_HIDDEN FFI_DECLARE_FASTCALL</span>
<span class="line-added">423 ffi_closure_inner (struct closure_frame *frame, char *stack)</span>
<span class="line-added">424 {</span>
<span class="line-added">425   ffi_cif *cif = frame-&gt;cif;</span>
<span class="line-added">426   int cabi, i, n, flags, dir, narg_reg;</span>
<span class="line-added">427   const struct abi_params *pabi;</span>
<span class="line-added">428   ffi_type **arg_types;</span>
<span class="line-added">429   char *argp;</span>
<span class="line-added">430   void *rvalue;</span>
<span class="line-added">431   void **avalue;</span>
<span class="line-added">432 </span>
<span class="line-added">433   cabi = cif-&gt;abi;</span>
<span class="line-added">434   flags = cif-&gt;flags;</span>
<span class="line-added">435   narg_reg = 0;</span>
<span class="line-added">436   rvalue = frame-&gt;rettemp;</span>
<span class="line-added">437   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">438   dir = pabi-&gt;dir;</span>
<span class="line-added">439   argp = (dir &lt; 0 ? stack + STACK_ALIGN (cif-&gt;bytes) : stack);</span>
<span class="line-added">440 </span>
<span class="line-added">441   switch (flags)</span>
442     {
<span class="line-modified">443     case X86_RET_STRUCTARG:</span>
<span class="line-modified">444       if (pabi-&gt;nregs &gt; 0)</span>
445         {
<span class="line-modified">446       rvalue = (void *)frame-&gt;regs[pabi-&gt;regs[0]];</span>
<span class="line-modified">447       narg_reg = 1;</span>
<span class="line-added">448       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="line-added">449       break;</span>
450         }
<span class="line-modified">451       /* fallthru */</span>
<span class="line-modified">452     case X86_RET_STRUCTPOP:</span>
<span class="line-modified">453       rvalue = *(void **)argp;</span>

454           argp += sizeof(void *);
<span class="line-added">455       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="line-added">456       break;</span>
457         }

458 
<span class="line-modified">459   n = cif-&gt;nargs;</span>
<span class="line-modified">460   avalue = alloca(sizeof(void *) * n);</span>
<span class="line-modified">461 </span>
<span class="line-modified">462   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">463   for (i = 0; i &lt; n; ++i)</span>
464   {
<span class="line-modified">465       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">466       size_t z = ty-&gt;size;</span>
<span class="line-modified">467       int t = ty-&gt;type;</span>
<span class="line-modified">468       void *valp;</span>
















469 
<span class="line-modified">470       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>


471     {
<span class="line-modified">472       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="line-modified">473         valp = &amp;frame-&gt;regs[pabi-&gt;regs[narg_reg++]];</span>
<span class="line-added">474       else if (dir &lt; 0)</span>
475       {
<span class="line-modified">476           argp -= 4;</span>
<span class="line-modified">477           valp = argp;</span>
478       }
<span class="line-added">479       else</span>
<span class="line-added">480         {</span>
<span class="line-added">481           valp = argp;</span>
<span class="line-added">482           argp += 4;</span>
483     }
<span class="line-modified">484     }</span>
<span class="line-modified">485       else</span>


486     {
<span class="line-modified">487       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">488       size_t align = FFI_SIZEOF_ARG;</span>
<span class="line-modified">489 </span>
<span class="line-modified">490       /* See the comment in ffi_call_int.  */</span>
<span class="line-modified">491       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="line-modified">492         align = 16;</span>
<span class="line-modified">493 </span>
<span class="line-modified">494       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="line-modified">495          as 64-bit integer or struct, all following integer paramters</span>
<span class="line-modified">496          will be passed on stack.  */</span>
<span class="line-modified">497       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="line-modified">498           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="line-modified">499           || t == FFI_TYPE_UINT64</span>
<span class="line-modified">500           || t == FFI_TYPE_STRUCT))</span>
<span class="line-modified">501         narg_reg = 2;</span>
<span class="line-modified">502 </span>
<span class="line-modified">503       if (dir &lt; 0)</span>




504         {
<span class="line-modified">505           /* ??? These reverse argument ABIs are probably too old</span>
<span class="line-modified">506          to have cared about alignment.  Someone should check.  */</span>
<span class="line-added">507           argp -= za;</span>
<span class="line-added">508           valp = argp;</span>
509         }
510       else






511         {
<span class="line-modified">512           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="line-modified">513           valp = argp;</span>
<span class="line-added">514           argp += za;</span>
515         }





516         }
517 
<span class="line-modified">518       avalue[i] = valp;</span>




519     }
520 
<span class="line-modified">521   frame-&gt;fun (cif, rvalue, avalue, frame-&gt;user_data);</span>

522 
<span class="line-modified">523   if (cabi == FFI_STDCALL)</span>
<span class="line-modified">524     return flags + (cif-&gt;bytes &lt;&lt; X86_RET_POP_SHIFT);</span>
<span class="line-modified">525   else</span>
<span class="line-modified">526     return flags;</span>































































527  }
528 


529 ffi_status
530 ffi_prep_closure_loc (ffi_closure* closure,
531                       ffi_cif* cif,
532                       void (*fun)(ffi_cif*,void*,void**,void*),
533                       void *user_data,
534                       void *codeloc)
535 {
<span class="line-modified">536   char *tramp = closure-&gt;tramp;</span>
<span class="line-modified">537   void (*dest)(void);</span>
<span class="line-modified">538   int op = 0xb8;  /* movl imm, %eax */</span>
<span class="line-modified">539 </span>
<span class="line-modified">540   switch (cif-&gt;abi)</span>


























541     {
<span class="line-modified">542     case FFI_SYSV:</span>
<span class="line-modified">543     case FFI_THISCALL:</span>
<span class="line-modified">544     case FFI_FASTCALL:</span>
<span class="line-added">545     case FFI_MS_CDECL:</span>
<span class="line-added">546       dest = ffi_closure_i386;</span>
<span class="line-added">547       break;</span>
<span class="line-added">548     case FFI_STDCALL:</span>
<span class="line-added">549     case FFI_PASCAL:</span>
<span class="line-added">550       dest = ffi_closure_STDCALL;</span>
<span class="line-added">551       break;</span>
<span class="line-added">552     case FFI_REGISTER:</span>
<span class="line-added">553       dest = ffi_closure_REGISTER;</span>
<span class="line-added">554       op = 0x68;  /* pushl imm */</span>
<span class="line-added">555       break;</span>
<span class="line-added">556     default:</span>
<span class="line-added">557       return FFI_BAD_ABI;</span>
558     }
<span class="line-modified">559 </span>
<span class="line-modified">560   /* movl or pushl immediate.  */</span>
<span class="line-modified">561   tramp[0] = op;</span>
<span class="line-modified">562   *(void **)(tramp + 1) = codeloc;</span>
<span class="line-modified">563 </span>
<span class="line-added">564   /* jmp dest */</span>
<span class="line-added">565   tramp[5] = 0xe9;</span>
<span class="line-added">566   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="line-added">567 </span>
<span class="line-added">568   closure-&gt;cif = cif;</span>
<span class="line-added">569   closure-&gt;fun = fun;</span>
<span class="line-added">570   closure-&gt;user_data = user_data;</span>
<span class="line-added">571 </span>
<span class="line-added">572   return FFI_OK;</span>
573     }
<span class="line-modified">574 </span>
<span class="line-modified">575 void FFI_HIDDEN ffi_go_closure_EAX(void);</span>
<span class="line-added">576 void FFI_HIDDEN ffi_go_closure_ECX(void);</span>
<span class="line-added">577 void FFI_HIDDEN ffi_go_closure_STDCALL(void);</span>
<span class="line-added">578 </span>
<span class="line-added">579 ffi_status</span>
<span class="line-added">580 ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">581              void (*fun)(ffi_cif*,void*,void**,void*))</span>
582     {
<span class="line-modified">583   void (*dest)(void);</span>
<span class="line-modified">584 </span>
<span class="line-modified">585   switch (cif-&gt;abi)</span>




586     {
<span class="line-added">587     case FFI_SYSV:</span>
<span class="line-added">588     case FFI_MS_CDECL:</span>
<span class="line-added">589       dest = ffi_go_closure_ECX;</span>
<span class="line-added">590       break;</span>
<span class="line-added">591     case FFI_THISCALL:</span>
<span class="line-added">592     case FFI_FASTCALL:</span>
<span class="line-added">593       dest = ffi_go_closure_EAX;</span>
<span class="line-added">594       break;</span>
<span class="line-added">595     case FFI_STDCALL:</span>
<span class="line-added">596     case FFI_PASCAL:</span>
<span class="line-added">597       dest = ffi_go_closure_STDCALL;</span>
<span class="line-added">598       break;</span>
<span class="line-added">599     case FFI_REGISTER:</span>
<span class="line-added">600     default:</span>
601       return FFI_BAD_ABI;
602     }
603 
<span class="line-modified">604   closure-&gt;tramp = dest;</span>
<span class="line-modified">605   closure-&gt;cif = cif;</span>
<span class="line-modified">606   closure-&gt;fun = fun;</span>
607 
608   return FFI_OK;
609 }
610 
611 /* ------- Native raw API support -------------------------------- */
612 
613 #if !FFI_NO_RAW_API
614 
<span class="line-added">615 void FFI_HIDDEN ffi_closure_raw_SYSV(void);</span>
<span class="line-added">616 void FFI_HIDDEN ffi_closure_raw_THISCALL(void);</span>
<span class="line-added">617 </span>
618 ffi_status
<span class="line-modified">619 ffi_prep_raw_closure_loc (ffi_raw_closure *closure,</span>
<span class="line-modified">620                           ffi_cif *cif,</span>
621                           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
622                           void *user_data,
623                           void *codeloc)
624 {
<span class="line-added">625   char *tramp = closure-&gt;tramp;</span>
<span class="line-added">626   void (*dest)(void);</span>
627   int i;
628 
<span class="line-modified">629   /* We currently don&#39;t support certain kinds of arguments for raw</span>







630      closures.  This should be implemented by a separate assembly
631      language routine, since it would require argument processing,
632      something we don&#39;t do now for performance.  */

633   for (i = cif-&gt;nargs-1; i &gt;= 0; i--)
<span class="line-added">634     switch (cif-&gt;arg_types[i]-&gt;type)</span>
635     {
<span class="line-modified">636       case FFI_TYPE_STRUCT:</span>
<span class="line-modified">637       case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">638     return FFI_BAD_TYPEDEF;</span>
639     }
640 
<span class="line-modified">641   switch (cif-&gt;abi)</span>








642     {
<span class="line-modified">643     case FFI_THISCALL:</span>
<span class="line-added">644       dest = ffi_closure_raw_THISCALL;</span>
<span class="line-added">645       break;</span>
<span class="line-added">646     case FFI_SYSV:</span>
<span class="line-added">647       dest = ffi_closure_raw_SYSV;</span>
<span class="line-added">648       break;</span>
<span class="line-added">649     default:</span>
<span class="line-added">650       return FFI_BAD_ABI;</span>
651     }
<span class="line-modified">652 </span>
<span class="line-modified">653   /* movl imm, %eax.  */</span>
<span class="line-added">654   tramp[0] = 0xb8;</span>
<span class="line-added">655   *(void **)(tramp + 1) = codeloc;</span>
<span class="line-added">656 </span>
<span class="line-added">657   /* jmp dest */</span>
<span class="line-added">658   tramp[5] = 0xe9;</span>
<span class="line-added">659   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="line-added">660 </span>
<span class="line-added">661   closure-&gt;cif = cif;</span>
<span class="line-added">662   closure-&gt;fun = fun;</span>
663   closure-&gt;user_data = user_data;

664 
665   return FFI_OK;
666 }
667 
<span class="line-modified">668 void</span>
<span class="line-modified">669 ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *avalue)</span>
670 {
<span class="line-modified">671   size_t rsize, bytes;</span>
<span class="line-modified">672   struct call_frame *frame;</span>
<span class="line-added">673   char *stack, *argp;</span>
<span class="line-added">674   ffi_type **arg_types;</span>
<span class="line-added">675   int flags, cabi, i, n, narg_reg;</span>
<span class="line-added">676   const struct abi_params *pabi;</span>
<span class="line-added">677 </span>
<span class="line-added">678   flags = cif-&gt;flags;</span>
<span class="line-added">679   cabi = cif-&gt;abi;</span>
<span class="line-added">680   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">681 </span>
<span class="line-added">682   rsize = 0;</span>
<span class="line-added">683   if (rvalue == NULL)</span>
<span class="line-added">684     {</span>
<span class="line-added">685       switch (flags)</span>
<span class="line-added">686     {</span>
<span class="line-added">687     case X86_RET_FLOAT:</span>
<span class="line-added">688     case X86_RET_DOUBLE:</span>
<span class="line-added">689     case X86_RET_LDOUBLE:</span>
<span class="line-added">690     case X86_RET_STRUCTPOP:</span>
<span class="line-added">691     case X86_RET_STRUCTARG:</span>
<span class="line-added">692       /* The float cases need to pop the 387 stack.</span>
<span class="line-added">693          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="line-added">694       rsize = cif-&gt;rtype-&gt;size;</span>
<span class="line-added">695       break;</span>
<span class="line-added">696     default:</span>
<span class="line-added">697       /* We can pretend that the callee returns nothing.  */</span>
<span class="line-added">698       flags = X86_RET_VOID;</span>
<span class="line-added">699       break;</span>
<span class="line-added">700     }</span>
<span class="line-added">701     }</span>
702 
<span class="line-modified">703   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="line-modified">704   argp = stack =</span>
<span class="line-modified">705       (void *)((uintptr_t)alloca(bytes + sizeof(*frame) + rsize + 15) &amp; ~16);</span>
<span class="line-modified">706   frame = (struct call_frame *)(stack + bytes);</span>
<span class="line-modified">707   if (rsize)</span>
<span class="line-modified">708     rvalue = frame + 1;</span>
709 
<span class="line-modified">710   frame-&gt;fn = fn;</span>
<span class="line-modified">711   frame-&gt;flags = flags;</span>
<span class="line-added">712   frame-&gt;rvalue = rvalue;</span>
713 
<span class="line-modified">714   narg_reg = 0;</span>
<span class="line-added">715   switch (flags)</span>
716     {
<span class="line-modified">717     case X86_RET_STRUCTARG:</span>
<span class="line-modified">718       /* The pointer is passed as the first argument.  */</span>
<span class="line-modified">719       if (pabi-&gt;nregs &gt; 0)</span>
<span class="line-modified">720     {</span>
<span class="line-modified">721       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="line-modified">722       narg_reg = 1;</span>
<span class="line-modified">723       break;</span>














724 }
<span class="line-added">725       /* fallthru */</span>
<span class="line-added">726     case X86_RET_STRUCTPOP:</span>
<span class="line-added">727       *(void **)argp = rvalue;</span>
<span class="line-added">728       argp += sizeof(void *);</span>
<span class="line-added">729       bytes -= sizeof(void *);</span>
<span class="line-added">730       break;</span>
<span class="line-added">731     }</span>
732 
<span class="line-modified">733   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">734   for (i = 0, n = cif-&gt;nargs; narg_reg &lt; pabi-&gt;nregs &amp;&amp; i &lt; n; i++)</span>





735 {
<span class="line-modified">736       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">737       size_t z = ty-&gt;size;</span>
<span class="line-modified">738       int t = ty-&gt;type;</span>





739 
<span class="line-modified">740       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT &amp;&amp; t != FFI_TYPE_FLOAT)</span>


741     {
<span class="line-modified">742       ffi_arg val = extend_basic_type (avalue, t);</span>
<span class="line-added">743       frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="line-added">744       z = FFI_SIZEOF_ARG;</span>
745     }
746   else




747     {
<span class="line-modified">748       memcpy (argp, avalue, z);</span>
<span class="line-modified">749       z = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">750       argp += z;</span>



















751     }
<span class="line-added">752       avalue += z;</span>
<span class="line-added">753       bytes -= z;</span>
754 }
<span class="line-added">755   if (i &lt; n)</span>
<span class="line-added">756     memcpy (argp, avalue, bytes);</span>
757 
<span class="line-modified">758   ffi_call_i386 (frame, stack);</span>
<span class="line-modified">759 }</span>
<span class="line-modified">760 #endif /* !FFI_NO_RAW_API */</span>
<span class="line-modified">761 #endif /* __i386__ */</span>
</pre>
</td>
</tr>
</table>
<center><a href="../types.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ffi64.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
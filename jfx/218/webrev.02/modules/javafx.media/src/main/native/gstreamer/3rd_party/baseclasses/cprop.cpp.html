<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/cprop.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: CProp.cpp
  3 //
  4 // Desc: DirectShow base classes - implements CBasePropertyPage class.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #include &lt;streams.h&gt;
 11 
 12 // Constructor for the base property page class. As described in the header
 13 // file we must be initialised with dialog and title resource identifiers.
 14 // The class supports IPropertyPage and overrides AddRef and Release calls
 15 // to keep track of the reference counts. When the last count is released
 16 // we call SetPageSite(NULL) and SetObjects(0,NULL) to release interfaces
 17 // previously obtained by the property page when it had SetObjects called
 18 
 19 CBasePropertyPage::CBasePropertyPage(__in_opt LPCTSTR pName,   // Debug only name
 20                                      __inout_opt LPUNKNOWN pUnk, // COM Delegator
 21                                      int DialogId,      // Resource ID
 22                                      int TitleId) :     // To get tital
 23     CUnknown(pName,pUnk),
 24     m_DialogId(DialogId),
 25     m_TitleId(TitleId),
 26     m_hwnd(NULL),
 27     m_Dlg(NULL),
 28     m_pPageSite(NULL),
 29     m_bObjectSet(FALSE),
 30     m_bDirty(FALSE)
 31 {
 32 }
 33 
 34 #ifdef UNICODE
 35 CBasePropertyPage::CBasePropertyPage(__in_opt LPCSTR pName,     // Debug only name
 36                                      __inout_opt LPUNKNOWN pUnk,  // COM Delegator
 37                                      int DialogId,      // Resource ID
 38                                      int TitleId) :     // To get tital
 39     CUnknown(pName,pUnk),
 40     m_DialogId(DialogId),
 41     m_TitleId(TitleId),
 42     m_hwnd(NULL),
 43     m_Dlg(NULL),
 44     m_pPageSite(NULL),
 45     m_bObjectSet(FALSE),
 46     m_bDirty(FALSE)
 47 {
 48 }
 49 #endif
 50 
 51 // Increment our reference count
 52 
 53 STDMETHODIMP_(ULONG) CBasePropertyPage::NonDelegatingAddRef()
 54 {
 55     LONG lRef = InterlockedIncrement(&amp;m_cRef);
 56     ASSERT(lRef &gt; 0);
 57     return max(ULONG(m_cRef),1ul);
 58 }
 59 
 60 
 61 // Release a reference count and protect against reentrancy
 62 
 63 STDMETHODIMP_(ULONG) CBasePropertyPage::NonDelegatingRelease()
 64 {
 65     // If the reference count drops to zero delete ourselves
 66 
 67     LONG lRef = InterlockedDecrement(&amp;m_cRef);
 68     if (lRef == 0) {
 69         m_cRef++;
 70         SetPageSite(NULL);
 71         SetObjects(0,NULL);
 72         delete this;
 73         return ULONG(0);
 74     } else {
 75         //  Don&#39;t touch m_cRef again here!
 76         return max(ULONG(lRef),1ul);
 77     }
 78 }
 79 
 80 
 81 // Expose our IPropertyPage interface
 82 
 83 STDMETHODIMP
 84 CBasePropertyPage::NonDelegatingQueryInterface(REFIID riid,__deref_out void **ppv)
 85 {
 86     if (riid == IID_IPropertyPage) {
 87         return GetInterface((IPropertyPage *)this,ppv);
 88     } else {
 89         return CUnknown::NonDelegatingQueryInterface(riid,ppv);
 90     }
 91 }
 92 
 93 
 94 // Get the page info so that the page site can size itself
 95 
 96 STDMETHODIMP CBasePropertyPage::GetPageInfo(__out LPPROPPAGEINFO pPageInfo)
 97 {
 98     CheckPointer(pPageInfo,E_POINTER);
 99     WCHAR wszTitle[STR_MAX_LENGTH];
100     WideStringFromResource(wszTitle,m_TitleId);
101 
102     // Allocate dynamic memory for the property page title
103 
104     LPOLESTR pszTitle;
105     HRESULT hr = AMGetWideString(wszTitle, &amp;pszTitle);
106     if (FAILED(hr)) {
107         NOTE(&quot;No caption memory&quot;);
108         return hr;
109     }
110 
111     pPageInfo-&gt;cb               = sizeof(PROPPAGEINFO);
112     pPageInfo-&gt;pszTitle         = pszTitle;
113     pPageInfo-&gt;pszDocString     = NULL;
114     pPageInfo-&gt;pszHelpFile      = NULL;
115     pPageInfo-&gt;dwHelpContext    = 0;
116 
117     // Set defaults in case GetDialogSize fails
118     pPageInfo-&gt;size.cx          = 340;
119     pPageInfo-&gt;size.cy          = 150;
120 
121     GetDialogSize(m_DialogId, DialogProc,0L,&amp;pPageInfo-&gt;size);
122     return NOERROR;
123 }
124 
125 
126 // Handles the messages for our property window
127 
128 INT_PTR CALLBACK CBasePropertyPage::DialogProc(HWND hwnd,
129                                             UINT uMsg,
130                                             WPARAM wParam,
131                                             LPARAM lParam)
132 {
133     CBasePropertyPage *pPropertyPage;
134 
135     switch (uMsg) {
136 
137         case WM_INITDIALOG:
138 
139             _SetWindowLongPtr(hwnd, DWLP_USER, lParam);
140 
141             // This pointer may be NULL when calculating size
142 
143             pPropertyPage = (CBasePropertyPage *) lParam;
144             if (pPropertyPage == NULL) {
145                 return (LRESULT) 1;
146             }
147             pPropertyPage-&gt;m_Dlg = hwnd;
148     }
149 
150     // This pointer may be NULL when calculating size
151 
152     pPropertyPage = _GetWindowLongPtr&lt;CBasePropertyPage*&gt;(hwnd, DWLP_USER);
153     if (pPropertyPage == NULL) {
154         return (LRESULT) 1;
155     }
156     return pPropertyPage-&gt;OnReceiveMessage(hwnd,uMsg,wParam,lParam);
157 }
158 
159 
160 // Tells us the object that should be informed of the property changes
161 
162 STDMETHODIMP CBasePropertyPage::SetObjects(ULONG cObjects,__in_ecount_opt(cObjects) LPUNKNOWN *ppUnk)
163 {
164     if (cObjects == 1) {
165 
166         if ((ppUnk == NULL) || (*ppUnk == NULL)) {
167             return E_POINTER;
168         }
169 
170         // Set a flag to say that we have set the Object
171         m_bObjectSet = TRUE ;
172         return OnConnect(*ppUnk);
173 
174     } else if (cObjects == 0) {
175 
176         // Set a flag to say that we have not set the Object for the page
177         m_bObjectSet = FALSE ;
178         return OnDisconnect();
179     }
180 
181     DbgBreak(&quot;No support for more than one object&quot;);
182     return E_UNEXPECTED;
183 }
184 
185 
186 // Create the window we will use to edit properties
187 
188 STDMETHODIMP CBasePropertyPage::Activate(HWND hwndParent,
189                                          LPCRECT pRect,
190                                          BOOL fModal)
191 {
192     CheckPointer(pRect,E_POINTER);
193 
194     // Return failure if SetObject has not been called.
195     if (m_bObjectSet == FALSE) {
196         return E_UNEXPECTED;
197     }
198 
199     if (m_hwnd) {
200         return E_UNEXPECTED;
201     }
202 
203     m_hwnd = CreateDialogParam(g_hInst,
204                                MAKEINTRESOURCE(m_DialogId),
205                                hwndParent,
206                                DialogProc,
207                                (LPARAM) this);
208     if (m_hwnd == NULL) {
209         return E_OUTOFMEMORY;
210     }
211 
212     OnActivate();
213     Move(pRect);
214     return Show(SW_SHOWNORMAL);
215 }
216 
217 
218 // Set the position of the property page
219 
220 STDMETHODIMP CBasePropertyPage::Move(LPCRECT pRect)
221 {
222     CheckPointer(pRect,E_POINTER);
223 
224     if (m_hwnd == NULL) {
225         return E_UNEXPECTED;
226     }
227 
228     MoveWindow(m_hwnd,              // Property page handle
229                pRect-&gt;left,         // x coordinate
230                pRect-&gt;top,          // y coordinate
231                WIDTH(pRect),        // Overall window width
232                HEIGHT(pRect),       // And likewise height
233                TRUE);               // Should we repaint it
234 
235     return NOERROR;
236 }
237 
238 
239 // Display the property dialog
240 
241 STDMETHODIMP CBasePropertyPage::Show(UINT nCmdShow)
242 {
243    // Have we been activated yet
244 
245     if (m_hwnd == NULL) {
246         return E_UNEXPECTED;
247     }
248 
249     // Ignore wrong show flags
250 
251     if ((nCmdShow != SW_SHOW) &amp;&amp; (nCmdShow != SW_SHOWNORMAL) &amp;&amp; (nCmdShow != SW_HIDE)) {
252         return E_INVALIDARG;
253     }
254 
255     ShowWindow(m_hwnd,nCmdShow);
256     InvalidateRect(m_hwnd,NULL,TRUE);
257     return NOERROR;
258 }
259 
260 
261 // Destroy the property page dialog
262 
263 STDMETHODIMP CBasePropertyPage::Deactivate(void)
264 {
265     if (m_hwnd == NULL) {
266         return E_UNEXPECTED;
267     }
268 
269     // Remove WS_EX_CONTROLPARENT before DestroyWindow call
270 
271     DWORD dwStyle = GetWindowLong(m_hwnd, GWL_EXSTYLE);
272     dwStyle = dwStyle &amp; (~WS_EX_CONTROLPARENT);
273 
274     //  Set m_hwnd to be NULL temporarily so the message handler
275     //  for WM_STYLECHANGING doesn&#39;t add the WS_EX_CONTROLPARENT
276     //  style back in
277     HWND hwnd = m_hwnd;
278     m_hwnd = NULL;
279     SetWindowLong(hwnd, GWL_EXSTYLE, dwStyle);
280     m_hwnd = hwnd;
281 
282     OnDeactivate();
283 
284     // Destroy the dialog window
285 
286     DestroyWindow(m_hwnd);
287     m_hwnd = NULL;
288     return NOERROR;
289 }
290 
291 
292 // Tells the application property page site
293 
294 STDMETHODIMP CBasePropertyPage::SetPageSite(__in_opt LPPROPERTYPAGESITE pPageSite)
295 {
296     if (pPageSite) {
297 
298         if (m_pPageSite) {
299             return E_UNEXPECTED;
300         }
301 
302         m_pPageSite = pPageSite;
303         m_pPageSite-&gt;AddRef();
304 
305     } else {
306 
307         if (m_pPageSite == NULL) {
308             return E_UNEXPECTED;
309         }
310 
311         m_pPageSite-&gt;Release();
312         m_pPageSite = NULL;
313     }
314     return NOERROR;
315 }
316 
317 
318 // Apply any changes so far made
319 
320 STDMETHODIMP CBasePropertyPage::Apply()
321 {
322     // In ActiveMovie 1.0 we used to check whether we had been activated or
323     // not. This is too constrictive. Apply should be allowed as long as
324     // SetObject was called to set an object. So we will no longer check to
325     // see if we have been activated (ie., m_hWnd != NULL), but instead
326     // make sure that m_bObjectSet is TRUE (ie., SetObject has been called).
327 
328     if (m_bObjectSet == FALSE) {
329         return E_UNEXPECTED;
330     }
331 
332     // Must have had a site set
333 
334     if (m_pPageSite == NULL) {
335         return E_UNEXPECTED;
336     }
337 
338     // Has anything changed
339 
340     if (m_bDirty == FALSE) {
341         return NOERROR;
342     }
343 
344     // Commit derived class changes
345 
346     HRESULT hr = OnApplyChanges();
347     if (SUCCEEDED(hr)) {
348         m_bDirty = FALSE;
349     }
350     return hr;
351 }
352 
353 
354 // Base class definition for message handling
355 
356 INT_PTR CBasePropertyPage::OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam)
357 {
358     // we would like the TAB key to move around the tab stops in our property
359     // page, but for some reason OleCreatePropertyFrame clears the CONTROLPARENT
360     // style behind our back, so we need to switch it back on now behind its
361     // back.  Otherwise the tab key will be useless in every page.
362     //
363 
364     CBasePropertyPage *pPropertyPage;
365     {
366         pPropertyPage = _GetWindowLongPtr&lt;CBasePropertyPage*&gt;(hwnd, DWLP_USER);
367 
368         if (pPropertyPage-&gt;m_hwnd == NULL) {
369             return 0;
370         }
371         switch (uMsg) {
372           case WM_STYLECHANGING:
373               if (wParam == GWL_EXSTYLE) {
374                   LPSTYLESTRUCT lpss = (LPSTYLESTRUCT)lParam;
375                   lpss-&gt;styleNew |= WS_EX_CONTROLPARENT;
376                   return 0;
377               }
378         }
379     }
380 
381     return DefWindowProc(hwnd,uMsg,wParam,lParam);
382 }
383 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/pstream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: PStream.cpp
  3 //
  4 // Desc: DirectShow base classes.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #include &lt;streams.h&gt;
 11 #include &lt;strsafe.h&gt;
 12 
 13 #ifdef PERF
 14 #include &lt;measure.h&gt;
 15 #endif
 16 // #include &quot;pstream.h&quot;  in streams.h
 17 
 18 //
 19 // Constructor
 20 //
 21 CPersistStream::CPersistStream(IUnknown *punk, __inout HRESULT *phr)
 22     : mPS_fDirty(FALSE)
 23 {
 24     mPS_dwFileVersion = GetSoftwareVersion();
 25 }
 26 
 27 
 28 //
 29 // Destructor
 30 //
 31 CPersistStream::~CPersistStream() {
 32     // Nothing to do
 33 }
 34 
 35 #if 0
 36 SAMPLE CODE TO COPY - not active at the moment
 37 
 38 //
 39 // NonDelegatingQueryInterface
 40 //
 41 // This object supports IPersist &amp; IPersistStream
 42 STDMETHODIMP CPersistStream::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
 43 {
 44     if (riid == IID_IPersist) {
 45         return GetInterface((IPersist *) this, ppv);      // ???
 46     }
 47     else if (riid == IID_IPersistStream) {
 48         return GetInterface((IPersistStream *) this, ppv);
 49     }
 50     else {
 51         return CUnknown::NonDelegatingQueryInterface(riid, ppv);
 52     }
 53 }
 54 #endif
 55 
 56 
 57 //
 58 // WriteToStream
 59 //
 60 // Writes to the stream (default action is to write nothing)
 61 HRESULT CPersistStream::WriteToStream(IStream *pStream)
 62 {
 63     // You can override this to do things like
 64     // hr = pStream-&gt;Write(MyStructure, sizeof(MyStructure), NULL);
 65 
 66     return NOERROR;
 67 }
 68 
 69 
 70 
 71 HRESULT CPersistStream::ReadFromStream(IStream * pStream)
 72 {
 73     // You can override this to do things like
 74     // hr = pStream-&gt;Read(MyStructure, sizeof(MyStructure), NULL);
 75 
 76     return NOERROR;
 77 }
 78 
 79 
 80 //
 81 // Load
 82 //
 83 // Load all the data from the given stream
 84 STDMETHODIMP CPersistStream::Load(LPSTREAM pStm)
 85 {
 86     HRESULT hr;
 87     // Load the version number then the data
 88     mPS_dwFileVersion = ReadInt(pStm, hr);
 89     if (FAILED(hr)) {
 90         return hr;
 91     }
 92 
 93     return ReadFromStream(pStm);
 94 }  // Load
 95 
 96 
 97 
 98 //
 99 // Save
100 //
101 // Save the contents of this Stream.
102 STDMETHODIMP CPersistStream::Save(LPSTREAM pStm, BOOL fClearDirty)
103 {
104 
105     HRESULT hr = WriteInt(pStm, GetSoftwareVersion());
106     if (FAILED(hr)) {
107         return hr;
108     }
109 
110     hr = WriteToStream(pStm);
111     if (FAILED(hr)) {
112         return hr;
113     }
114 
115     mPS_fDirty = !fClearDirty;
116 
117     return hr;
118 } // Save
119 
120 
121 // WriteInt
122 //
123 // Writes an integer to an IStream as 11 UNICODE characters followed by one space.
124 // You could use this for shorts or unsigneds or anything (up to 32 bits)
125 // where the value isn&#39;t actually truncated by squeezing it into 32 bits.
126 // Values such as (unsigned) 0x80000000 would come out as -2147483648
127 // but would then load as 0x80000000 through ReadInt.  Cast as you please.
128 
129 STDAPI WriteInt(IStream *pIStream, int n)
130 {
131     WCHAR Buff[13];  // Allows for trailing null that we don&#39;t write
132     (void)StringCchPrintfW(Buff, NUMELMS(Buff),L&quot;%011d &quot;,n);
133     return pIStream-&gt;Write(&amp;(Buff[0]), 12*sizeof(WCHAR), NULL);
134 } // WriteInt
135 
136 
137 // ReadInt
138 //
139 // Reads an integer from an IStream.
140 // Read as 4 bytes.  You could use this for shorts or unsigneds or anything
141 // where the value isn&#39;t actually truncated by squeezing it into 32 bits
142 // Striped down subset of what sscanf can do (without dragging in the C runtime)
143 
144 STDAPI_(int) ReadInt(IStream *pIStream, __out HRESULT &amp;hr)
145 {
146 
147     int Sign = 1;
148     unsigned int n = 0;    // result wil be n*Sign
149     WCHAR wch;
150 
151     hr = pIStream-&gt;Read( &amp;wch, sizeof(wch), NULL);
152     if (FAILED(hr)) {
153         return 0;
154     }
155 
156     if (wch==L&#39;-&#39;){
157         Sign = -1;
158         hr = pIStream-&gt;Read( &amp;wch, sizeof(wch), NULL);
159         if (FAILED(hr)) {
160             return 0;
161         }
162     }
163 
164     for( ; ; ) {
165         if (wch&gt;=L&#39;0&#39; &amp;&amp; wch&lt;=L&#39;9&#39;) {
166             n = 10*n+(int)(wch-L&#39;0&#39;);
167         } else if (  wch == L&#39; &#39;
168                   || wch == L&#39;\t&#39;
169                   || wch == L&#39;\r&#39;
170                   || wch == L&#39;\n&#39;
171                   || wch == L&#39;\0&#39;
172                   ) {
173             break;
174         } else {
175             hr = VFW_E_INVALID_FILE_FORMAT;
176             return 0;
177         }
178 
179         hr = pIStream-&gt;Read( &amp;wch, sizeof(wch), NULL);
180         if (FAILED(hr)) {
181             return 0;
182         }
183     }
184 
185     if (n==0x80000000 &amp;&amp; Sign==-1) {
186         // This is the negative number that has no positive version!
187         return (int)n;
188     }
189     else return (int)n * Sign;
190 } // ReadInt
191 
192 
193 // The microsoft C/C++ compile generates level 4 warnings to the effect that
194 // a particular inline function (from some base class) was not needed.
195 // This line gets rid of hundreds of such unwanted messages and makes
196 // -W4 compilation feasible:
197 #pragma warning(disable: 4514)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/amvideo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: AMVideo.cpp
  3 //
  4 // Desc: DirectShow base classes - implements helper functions for
  5 //       bitmap formats.
  6 //
  7 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  8 //------------------------------------------------------------------------------
  9 
 10 
 11 #include &lt;streams.h&gt;
 12 #include &lt;limits.h&gt;
 13 
 14 // These are bit field masks for true colour devices
 15 
 16 const DWORD bits555[] = {0x007C00,0x0003E0,0x00001F};
 17 const DWORD bits565[] = {0x00F800,0x0007E0,0x00001F};
 18 const DWORD bits888[] = {0xFF0000,0x00FF00,0x0000FF};
 19 
 20 // This maps bitmap subtypes into a bits per pixel value and also a
 21 // name. unicode and ansi versions are stored because we have to
 22 // return a pointer to a static string.
 23 const struct {
 24     const GUID *pSubtype;
 25     WORD BitCount;
 26     CHAR *pName;
 27     WCHAR *wszName;
 28 } BitCountMap[] =  { &amp;MEDIASUBTYPE_RGB1,        1,   &quot;RGB Monochrome&quot;,     L&quot;RGB Monochrome&quot;,
 29                      &amp;MEDIASUBTYPE_RGB4,        4,   &quot;RGB VGA&quot;,            L&quot;RGB VGA&quot;,
 30                      &amp;MEDIASUBTYPE_RGB8,        8,   &quot;RGB 8&quot;,              L&quot;RGB 8&quot;,
 31                      &amp;MEDIASUBTYPE_RGB565,      16,  &quot;RGB 565 (16 bit)&quot;,   L&quot;RGB 565 (16 bit)&quot;,
 32                      &amp;MEDIASUBTYPE_RGB555,      16,  &quot;RGB 555 (16 bit)&quot;,   L&quot;RGB 555 (16 bit)&quot;,
 33                      &amp;MEDIASUBTYPE_RGB24,       24,  &quot;RGB 24&quot;,             L&quot;RGB 24&quot;,
 34                      &amp;MEDIASUBTYPE_RGB32,       32,  &quot;RGB 32&quot;,             L&quot;RGB 32&quot;,
 35                      &amp;MEDIASUBTYPE_ARGB32,    32,  &quot;ARGB 32&quot;,             L&quot;ARGB 32&quot;,
 36                      &amp;MEDIASUBTYPE_Overlay,     0,   &quot;Overlay&quot;,            L&quot;Overlay&quot;,
 37                      &amp;GUID_NULL,                0,   &quot;UNKNOWN&quot;,            L&quot;UNKNOWN&quot;
 38 };
 39 
 40 // Return the size of the bitmap as defined by this header
 41 
 42 STDAPI_(DWORD) GetBitmapSize(const BITMAPINFOHEADER *pHeader)
 43 {
 44     return DIBSIZE(*pHeader);
 45 }
 46 
 47 
 48 // This is called if the header has a 16 bit colour depth and needs to work
 49 // out the detailed type from the bit fields (either RGB 565 or RGB 555)
 50 
 51 STDAPI_(const GUID) GetTrueColorType(const BITMAPINFOHEADER *pbmiHeader)
 52 {
 53     BITMAPINFO *pbmInfo = (BITMAPINFO *) pbmiHeader;
 54     ASSERT(pbmiHeader-&gt;biBitCount == 16);
 55 
 56     // If its BI_RGB then it&#39;s RGB 555 by default
 57 
 58     if (pbmiHeader-&gt;biCompression == BI_RGB) {
 59         return MEDIASUBTYPE_RGB555;
 60     }
 61 
 62     // Compare the bit fields with RGB 555
 63 
 64     DWORD *pMask = (DWORD *) pbmInfo-&gt;bmiColors;
 65     if (pMask[0] == bits555[0]) {
 66         if (pMask[1] == bits555[1]) {
 67             if (pMask[2] == bits555[2]) {
 68                 return MEDIASUBTYPE_RGB555;
 69             }
 70         }
 71     }
 72 
 73     // Compare the bit fields with RGB 565
 74 
 75     pMask = (DWORD *) pbmInfo-&gt;bmiColors;
 76     if (pMask[0] == bits565[0]) {
 77         if (pMask[1] == bits565[1]) {
 78             if (pMask[2] == bits565[2]) {
 79                 return MEDIASUBTYPE_RGB565;
 80             }
 81         }
 82     }
 83     return GUID_NULL;
 84 }
 85 
 86 
 87 // Given a BITMAPINFOHEADER structure this returns the GUID sub type that is
 88 // used to describe it in format negotiations. For example a video codec fills
 89 // in the format block with a VIDEOINFO structure, it also fills in the major
 90 // type with MEDIATYPE_VIDEO and the subtype with a GUID that matches the bit
 91 // count, for example if it is an eight bit image then MEDIASUBTYPE_RGB8
 92 
 93 STDAPI_(const GUID) GetBitmapSubtype(const BITMAPINFOHEADER *pbmiHeader)
 94 {
 95     ASSERT(pbmiHeader);
 96 
 97     // If it&#39;s not RGB then create a GUID from the compression type
 98 
 99     if (pbmiHeader-&gt;biCompression != BI_RGB) {
100         if (pbmiHeader-&gt;biCompression != BI_BITFIELDS) {
101             FOURCCMap FourCCMap(pbmiHeader-&gt;biCompression);
102             return (const GUID) FourCCMap;
103         }
104     }
105 
106     // Map the RGB DIB bit depth to a image GUID
107 
108     switch(pbmiHeader-&gt;biBitCount) {
109         case 1    :   return MEDIASUBTYPE_RGB1;
110         case 4    :   return MEDIASUBTYPE_RGB4;
111         case 8    :   return MEDIASUBTYPE_RGB8;
112         case 16   :   return GetTrueColorType(pbmiHeader);
113         case 24   :   return MEDIASUBTYPE_RGB24;
114         case 32   :   return MEDIASUBTYPE_RGB32;
115     }
116     return GUID_NULL;
117 }
118 
119 
120 // Given a video bitmap subtype we return the number of bits per pixel it uses
121 // We return a WORD bit count as thats what the BITMAPINFOHEADER uses. If the
122 // GUID subtype is not found in the table we return an invalid USHRT_MAX
123 
124 STDAPI_(WORD) GetBitCount(const GUID *pSubtype)
125 {
126     ASSERT(pSubtype);
127     const GUID *pMediaSubtype;
128     INT iPosition = 0;
129 
130     // Scan the mapping list seeing if the source GUID matches any known
131     // bitmap subtypes, the list is terminated by a GUID_NULL entry
132 
133     while (TRUE) {
134         pMediaSubtype = BitCountMap[iPosition].pSubtype;
135         if (IsEqualGUID(*pMediaSubtype,GUID_NULL)) {
136             return USHRT_MAX;
137         }
138         if (IsEqualGUID(*pMediaSubtype,*pSubtype)) {
139             return BitCountMap[iPosition].BitCount;
140         }
141         iPosition++;
142     }
143 }
144 
145 
146 // Given a bitmap subtype we return a description name that can be used for
147 // debug purposes. In a retail build this function still returns the names
148 // If the subtype isn&#39;t found in the lookup table we return string UNKNOWN
149 
150 int LocateSubtype(const GUID *pSubtype)
151 {
152     ASSERT(pSubtype);
153     const GUID *pMediaSubtype;
154     INT iPosition = 0;
155 
156     // Scan the mapping list seeing if the source GUID matches any known
157     // bitmap subtypes, the list is terminated by a GUID_NULL entry
158 
159     while (TRUE) {
160         pMediaSubtype = BitCountMap[iPosition].pSubtype;
161         if (IsEqualGUID(*pMediaSubtype,*pSubtype) ||
162             IsEqualGUID(*pMediaSubtype,GUID_NULL)
163             )
164         {
165             break;
166         }
167 
168         iPosition++;
169     }
170 
171     return iPosition;
172 }
173 
174 
175 
176 STDAPI_(WCHAR *) GetSubtypeNameW(const GUID *pSubtype)
177 {
178     return BitCountMap[LocateSubtype(pSubtype)].wszName;
179 }
180 
181 STDAPI_(CHAR *) GetSubtypeNameA(const GUID *pSubtype)
182 {
183     return BitCountMap[LocateSubtype(pSubtype)].pName;
184 }
185 
186 #ifndef GetSubtypeName
187 #error wxutil.h should have defined GetSubtypeName
188 #endif
189 #undef GetSubtypeName
190 
191 // this is here for people that linked to it directly; most people
192 // would use the header file that picks the A or W version.
193 STDAPI_(CHAR *) GetSubtypeName(const GUID *pSubtype)
194 {
195     return GetSubtypeNameA(pSubtype);
196 }
197 
198 
199 // The mechanism for describing a bitmap format is with the BITMAPINFOHEADER
200 // This is really messy to deal with because it invariably has fields that
201 // follow it holding bit fields, palettes and the rest. This function gives
202 // the number of bytes required to hold a VIDEOINFO that represents it. This
203 // count includes the prefix information (like the rcSource rectangle) the
204 // BITMAPINFOHEADER field, and any other colour information on the end.
205 //
206 // WARNING If you want to copy a BITMAPINFOHEADER into a VIDEOINFO always make
207 // sure that you use the HEADER macro because the BITMAPINFOHEADER field isn&#39;t
208 // right at the start of the VIDEOINFO (there are a number of other fields),
209 //
210 //     CopyMemory(HEADER(pVideoInfo),pbmi,sizeof(BITMAPINFOHEADER));
211 //
212 
213 STDAPI_(LONG) GetBitmapFormatSize(const BITMAPINFOHEADER *pHeader)
214 {
215     // Everyone has this to start with this
216     LONG Size = SIZE_PREHEADER + pHeader-&gt;biSize;
217 
218     ASSERT(pHeader-&gt;biSize &gt;= sizeof(BITMAPINFOHEADER));
219 
220     // Does this format use a palette, if the number of colours actually used
221     // is zero then it is set to the maximum that are allowed for that colour
222     // depth (an example is 256 for eight bits). Truecolour formats may also
223     // pass a palette with them in which case the used count is non zero
224 
225     // This would scare me.
226     ASSERT(pHeader-&gt;biBitCount &lt;= iPALETTE || pHeader-&gt;biClrUsed == 0);
227 
228     if (pHeader-&gt;biBitCount &lt;= iPALETTE || pHeader-&gt;biClrUsed) {
229         LONG Entries = (DWORD) 1 &lt;&lt; pHeader-&gt;biBitCount;
230         if (pHeader-&gt;biClrUsed) {
231             Entries = pHeader-&gt;biClrUsed;
232         }
233         Size += Entries * sizeof(RGBQUAD);
234     }
235 
236     // Truecolour formats may have a BI_BITFIELDS specifier for compression
237     // type which means that room for three DWORDs should be allocated that
238     // specify where in each pixel the RGB colour components may be found
239 
240     if (pHeader-&gt;biCompression == BI_BITFIELDS) {
241         Size += SIZE_MASKS;
242     }
243 
244     // A BITMAPINFO for a palettised image may also contain a palette map that
245     // provides the information to map from a source palette to a destination
246     // palette during a BitBlt for example, because this information is only
247     // ever processed during drawing you don&#39;t normally store the palette map
248     // nor have any way of knowing if it is present in the data structure
249 
250     return Size;
251 }
252 
253 
254 // Returns TRUE if the VIDEOINFO contains a palette
255 
256 STDAPI_(BOOL) ContainsPalette(const VIDEOINFOHEADER *pVideoInfo)
257 {
258     if (PALETTISED(pVideoInfo) == FALSE) {
259         if (pVideoInfo-&gt;bmiHeader.biClrUsed == 0) {
260             return FALSE;
261         }
262     }
263     return TRUE;
264 }
265 
266 
267 // Return a pointer to the first entry in a palette
268 
269 STDAPI_(const RGBQUAD *) GetBitmapPalette(const VIDEOINFOHEADER *pVideoInfo)
270 {
271     if (pVideoInfo-&gt;bmiHeader.biCompression == BI_BITFIELDS) {
272         return TRUECOLOR(pVideoInfo)-&gt;bmiColors;
273     }
274     return COLORS(pVideoInfo);
275 }
    </pre>
  </body>
</html>
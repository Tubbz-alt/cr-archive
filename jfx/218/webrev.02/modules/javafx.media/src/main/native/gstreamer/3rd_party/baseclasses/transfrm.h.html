<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/transfrm.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: Transfrm.h
  3 //
  4 // Desc: DirectShow base classes - defines classes from which simple
  5 //       transform codecs may be derived.
  6 //
  7 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  8 //------------------------------------------------------------------------------
  9 
 10 
 11 // It assumes the codec has one input and one output stream, and has no
 12 // interest in memory management, interface negotiation or anything else.
 13 //
 14 // derive your class from this, and supply Transform and the media type/format
 15 // negotiation functions. Implement that class, compile and link and
 16 // you&#39;re done.
 17 
 18 
 19 #ifndef __TRANSFRM__
 20 #define __TRANSFRM__
 21 
 22 // ======================================================================
 23 // This is the com object that represents a simple transform filter. It
 24 // supports IBaseFilter, IMediaFilter and two pins through nested interfaces
 25 // ======================================================================
 26 
 27 class CTransformFilter;
 28 
 29 // ==================================================
 30 // Implements the input pin
 31 // ==================================================
 32 
 33 class CTransformInputPin : public CBaseInputPin
 34 {
 35     friend class CTransformFilter;
 36 
 37 protected:
 38     CTransformFilter *m_pTransformFilter;
 39 
 40 
 41 public:
 42 
 43     CTransformInputPin(
 44         __in_opt LPCTSTR pObjectName,
 45         __inout CTransformFilter *pTransformFilter,
 46         __inout HRESULT * phr,
 47         __in_opt LPCWSTR pName);
 48 #ifdef UNICODE
 49     CTransformInputPin(
 50         __in_opt LPCSTR pObjectName,
 51         __inout CTransformFilter *pTransformFilter,
 52         __inout HRESULT * phr,
 53         __in_opt LPCWSTR pName);
 54 #endif
 55 
 56     STDMETHODIMP QueryId(__deref_out LPWSTR * Id)
 57     {
 58         return AMGetWideString(L&quot;In&quot;, Id);
 59     }
 60 
 61     // Grab and release extra interfaces if required
 62 
 63     HRESULT CheckConnect(IPin *pPin);
 64     HRESULT BreakConnect();
 65     HRESULT CompleteConnect(IPin *pReceivePin);
 66 
 67     // check that we can support this output type
 68     HRESULT CheckMediaType(const CMediaType* mtIn);
 69 
 70     // set the connection media type
 71     HRESULT SetMediaType(const CMediaType* mt);
 72 
 73     // --- IMemInputPin -----
 74 
 75     // here&#39;s the next block of data from the stream.
 76     // AddRef it yourself if you need to hold it beyond the end
 77     // of this call.
 78     STDMETHODIMP Receive(IMediaSample * pSample);
 79 
 80     // provide EndOfStream that passes straight downstream
 81     // (there is no queued data)
 82     STDMETHODIMP EndOfStream(void);
 83 
 84     // passes it to CTransformFilter::BeginFlush
 85     STDMETHODIMP BeginFlush(void);
 86 
 87     // passes it to CTransformFilter::EndFlush
 88     STDMETHODIMP EndFlush(void);
 89 
 90     STDMETHODIMP NewSegment(
 91                         REFERENCE_TIME tStart,
 92                         REFERENCE_TIME tStop,
 93                         double dRate);
 94 
 95     // Check if it&#39;s OK to process samples
 96     virtual HRESULT CheckStreaming();
 97 
 98     // Media type
 99 public:
100     CMediaType&amp; CurrentMediaType() { return m_mt; };
101 
102 };
103 
104 // ==================================================
105 // Implements the output pin
106 // ==================================================
107 
108 class CTransformOutputPin : public CBaseOutputPin
109 {
110     friend class CTransformFilter;
111 
112 protected:
113     CTransformFilter *m_pTransformFilter;
114 
115 public:
116 
117     // implement IMediaPosition by passing upstream
118     IUnknown * m_pPosition;
119 
120     CTransformOutputPin(
121         __in_opt LPCTSTR pObjectName,
122         __inout CTransformFilter *pTransformFilter,
123         __inout HRESULT * phr,
124         __in_opt LPCWSTR pName);
125 #ifdef UNICODE
126     CTransformOutputPin(
127         __in_opt LPCSTR pObjectName,
128         __inout CTransformFilter *pTransformFilter,
129         __inout HRESULT * phr,
130         __in_opt LPCWSTR pName);
131 #endif
132     ~CTransformOutputPin();
133 
134     // override to expose IMediaPosition
135     STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv);
136 
137     // --- CBaseOutputPin ------------
138 
139     STDMETHODIMP QueryId(__deref_out LPWSTR * Id)
140     {
141         return AMGetWideString(L&quot;Out&quot;, Id);
142     }
143 
144     // Grab and release extra interfaces if required
145 
146     HRESULT CheckConnect(IPin *pPin);
147     HRESULT BreakConnect();
148     HRESULT CompleteConnect(IPin *pReceivePin);
149 
150     // check that we can support this output type
151     HRESULT CheckMediaType(const CMediaType* mtOut);
152 
153     // set the connection media type
154     HRESULT SetMediaType(const CMediaType *pmt);
155 
156     // called from CBaseOutputPin during connection to ask for
157     // the count and size of buffers we need.
158     HRESULT DecideBufferSize(
159                 IMemAllocator * pAlloc,
160                 __inout ALLOCATOR_PROPERTIES *pProp);
161 
162     // returns the preferred formats for a pin
163     HRESULT GetMediaType(int iPosition, __inout CMediaType *pMediaType);
164 
165     // inherited from IQualityControl via CBasePin
166     STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
167 
168     // Media type
169 public:
170     CMediaType&amp; CurrentMediaType() { return m_mt; };
171 };
172 
173 
174 class AM_NOVTABLE CTransformFilter : public CBaseFilter
175 {
176 
177 public:
178 
179     // map getpin/getpincount for base enum of pins to owner
180     // override this to return more specialised pin objects
181 
182     virtual int GetPinCount();
183     virtual CBasePin * GetPin(int n);
184     STDMETHODIMP FindPin(LPCWSTR Id, __deref_out IPin **ppPin);
185 
186     // override state changes to allow derived transform filter
187     // to control streaming start/stop
188     STDMETHODIMP Stop();
189     STDMETHODIMP Pause();
190 
191 public:
192 
193     CTransformFilter(__in_opt LPCTSTR , __inout_opt LPUNKNOWN, REFCLSID clsid);
194 #ifdef UNICODE
195     CTransformFilter(__in_opt LPCSTR , __inout_opt LPUNKNOWN, REFCLSID clsid);
196 #endif
197     ~CTransformFilter();
198 
199     // =================================================================
200     // ----- override these bits ---------------------------------------
201     // =================================================================
202 
203     // These must be supplied in a derived class
204 
205     virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);
206 
207     // check if you can support mtIn
208     virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE;
209 
210     // check if you can support the transform from this input to this output
211     virtual HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut) PURE;
212 
213     // this goes in the factory template table to create new instances
214     // static CCOMObject * CreateInstance(__inout_opt LPUNKNOWN, HRESULT *);
215 
216     // call the SetProperties function with appropriate arguments
217     virtual HRESULT DecideBufferSize(
218                         IMemAllocator * pAllocator,
219                         __inout ALLOCATOR_PROPERTIES *pprop) PURE;
220 
221     // override to suggest OUTPUT pin media types
222     virtual HRESULT GetMediaType(int iPosition, __inout CMediaType *pMediaType) PURE;
223 
224 
225 
226     // =================================================================
227     // ----- Optional Override Methods           -----------------------
228     // =================================================================
229 
230     // you can also override these if you want to know about streaming
231     virtual HRESULT StartStreaming();
232     virtual HRESULT StopStreaming();
233 
234     // override if you can do anything constructive with quality notifications
235     virtual HRESULT AlterQuality(Quality q);
236 
237     // override this to know when the media type is actually set
238     virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
239 
240     // chance to grab extra interfaces on connection
241     virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
242     virtual HRESULT BreakConnect(PIN_DIRECTION dir);
243     virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin);
244 
245     // chance to customize the transform process
246     virtual HRESULT Receive(IMediaSample *pSample);
247 
248     // Standard setup for output sample
249     HRESULT InitializeOutputSample(IMediaSample *pSample, __deref_out IMediaSample **ppOutSample);
250 
251     // if you override Receive, you may need to override these three too
252     virtual HRESULT EndOfStream(void);
253     virtual HRESULT BeginFlush(void);
254     virtual HRESULT EndFlush(void);
255     virtual HRESULT NewSegment(
256                         REFERENCE_TIME tStart,
257                         REFERENCE_TIME tStop,
258                         double dRate);
259 
260 #ifdef PERF
261     // Override to register performance measurement with a less generic string
262     // You should do this to avoid confusion with other filters
263     virtual void RegisterPerfId()
264          {m_idTransform = MSR_REGISTER(TEXT(&quot;Transform&quot;));}
265 #endif // PERF
266 
267 
268 // implementation details
269 
270 protected:
271 
272 #ifdef PERF
273     int m_idTransform;                 // performance measuring id
274 #endif
275     BOOL m_bEOSDelivered;              // have we sent EndOfStream
276     BOOL m_bSampleSkipped;             // Did we just skip a frame
277     BOOL m_bQualityChanged;            // Have we degraded?
278 
279     // critical section protecting filter state.
280 
281     CCritSec m_csFilter;
282 
283     // critical section stopping state changes (ie Stop) while we&#39;re
284     // processing a sample.
285     //
286     // This critical section is held when processing
287     // events that occur on the receive thread - Receive() and EndOfStream().
288     //
289     // If you want to hold both m_csReceive and m_csFilter then grab
290     // m_csFilter FIRST - like CTransformFilter::Stop() does.
291 
292     CCritSec m_csReceive;
293 
294     // these hold our input and output pins
295 
296     friend class CTransformInputPin;
297     friend class CTransformOutputPin;
298     CTransformInputPin *m_pInput;
299     CTransformOutputPin *m_pOutput;
300 };
301 
302 #endif /* __TRANSFRM__ */
303 
304 
    </pre>
  </body>
</html>
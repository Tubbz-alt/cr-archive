<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* -----------------------------------------------------------------------
<a name="1" id="anc1"></a><span class="line-modified">  2    ffi.c - Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>

  3            Copyright (c) 2002  Ranjit Mathew
  4            Copyright (c) 2002  Bo Thorsen
  5            Copyright (c) 2002  Roger Sayle
  6            Copyright (C) 2008, 2010  Free Software Foundation, Inc.
  7 
  8    x86 Foreign Function Interface
  9 
 10    Permission is hereby granted, free of charge, to any person obtaining
 11    a copy of this software and associated documentation files (the
 12    ``Software&#39;&#39;), to deal in the Software without restriction, including
 13    without limitation the rights to use, copy, modify, merge, publish,
 14    distribute, sublicense, and/or sell copies of the Software, and to
 15    permit persons to whom the Software is furnished to do so, subject to
 16    the following conditions:
 17 
 18    The above copyright notice and this permission notice shall be included
 19    in all copies or substantial portions of the Software.
 20 
 21    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 22    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 23    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 24    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 25    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 26    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 27    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 28    DEALINGS IN THE SOFTWARE.
 29    ----------------------------------------------------------------------- */
 30 
<a name="2" id="anc2"></a><span class="line-modified"> 31 #if !defined(__x86_64__) || defined(_WIN64) || defined(__CYGWIN__)</span>
<span class="line-removed"> 32 </span>
<span class="line-removed"> 33 #ifdef _WIN64</span>
<span class="line-removed"> 34 #include &lt;windows.h&gt;</span>
<span class="line-removed"> 35 #endif</span>
<span class="line-removed"> 36 </span>
 37 #include &lt;ffi.h&gt;
 38 #include &lt;ffi_common.h&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 39 </span>
 40 #include &lt;stdlib.h&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 41 </span>
<span class="line-modified"> 42 </span>
<span class="line-modified"> 43 /* ffi_prep_args is called by the assembly routine once stack space</span>
<span class="line-modified"> 44    has been allocated for the function&#39;s arguments */</span>
<span class="line-modified"> 45 </span>
<span class="line-modified"> 46 unsigned int ffi_prep_args(char *stack, extended_cif *ecif);</span>
<span class="line-modified"> 47 unsigned int ffi_prep_args(char *stack, extended_cif *ecif)</span>
<span class="line-modified"> 48 {</span>
<span class="line-removed"> 49   register unsigned int i;</span>
<span class="line-removed"> 50   register void **p_argv;</span>
<span class="line-removed"> 51   register char *argp;</span>
<span class="line-removed"> 52   register ffi_type **p_arg;</span>
<span class="line-removed"> 53 #ifndef X86_WIN64</span>
<span class="line-removed"> 54   const int cabi = ecif-&gt;cif-&gt;abi;</span>
<span class="line-removed"> 55   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="line-removed"> 56   unsigned int stack_args_count = 0;</span>
<span class="line-removed"> 57   void *p_stack_data[3];</span>
<span class="line-removed"> 58   char *argp2 = stack;</span>
 59 #else
<a name="5" id="anc5"></a><span class="line-modified"> 60   #define dir 1</span>

 61 #endif
 62 
<a name="6" id="anc6"></a><span class="line-modified"> 63   argp = stack;</span>
<span class="line-modified"> 64 </span>
<span class="line-removed"> 65   if ((ecif-&gt;cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed"> 66        || ecif-&gt;cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="line-removed"> 67 #ifdef X86_WIN64</span>
<span class="line-removed"> 68       &amp;&amp; ((ecif-&gt;cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
 69 #endif
<a name="7" id="anc7"></a><span class="line-modified"> 70       )</span>
<span class="line-modified"> 71     {</span>
<span class="line-modified"> 72 #ifndef X86_WIN64</span>
<span class="line-modified"> 73       /* For fastcall/thiscall/register this is first register-passed</span>
<span class="line-modified"> 74          argument.  */</span>
<span class="line-modified"> 75       if (cabi == FFI_THISCALL || cabi == FFI_FASTCALL || cabi == FFI_REGISTER)</span>
<span class="line-removed"> 76         {</span>
<span class="line-removed"> 77           p_stack_data[stack_args_count] = argp;</span>
<span class="line-removed"> 78           ++stack_args_count;</span>
<span class="line-removed"> 79         }</span>
 80 #endif
 81 
<a name="8" id="anc8"></a><span class="line-modified"> 82       *(void **) argp = ecif-&gt;rvalue;</span>
<span class="line-modified"> 83       argp += sizeof(void*);</span>
<span class="line-modified"> 84     }</span>



 85 
<a name="9" id="anc9"></a><span class="line-modified"> 86   p_arg  = ecif-&gt;cif-&gt;arg_types;</span>
<span class="line-removed"> 87   p_argv = ecif-&gt;avalue;</span>
<span class="line-removed"> 88   if (dir &lt; 0)</span>
 89     {
<a name="10" id="anc10"></a><span class="line-modified"> 90       const int nargs = ecif-&gt;cif-&gt;nargs - 1;</span>
<span class="line-modified"> 91       if (nargs &gt; 0)</span>
<span class="line-modified"> 92       {</span>
<span class="line-modified"> 93         p_arg  += nargs;</span>
<span class="line-modified"> 94         p_argv += nargs;</span>





 95       }
<a name="11" id="anc11"></a><span class="line-removed"> 96     }</span>
 97 
<a name="12" id="anc12"></a><span class="line-modified"> 98   for (i = ecif-&gt;cif-&gt;nargs;</span>
<span class="line-removed"> 99        i != 0;</span>
<span class="line-removed">100        i--, p_arg += dir, p_argv += dir)</span>
101     {
<a name="13" id="anc13"></a><span class="line-modified">102 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">103       size_t z = 0;</span>
<span class="line-removed">104 #endif // GSTREAMER_LITE</span>
<span class="line-removed">105 </span>
<span class="line-removed">106       /* Align if necessary */</span>
<span class="line-removed">107       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="line-removed">108         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="line-removed">109 </span>
<span class="line-removed">110 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">111       z = (*p_arg)-&gt;size;</span>
<span class="line-removed">112 #else // GSTREAMER_LITE</span>
<span class="line-removed">113       size_t z = (*p_arg)-&gt;size;</span>
<span class="line-removed">114 #endif // GSTREAMER_LITE</span>
<span class="line-removed">115 </span>
<span class="line-removed">116 #ifdef X86_WIN64</span>
<span class="line-removed">117       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="line-removed">118           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="line-removed">119               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-removed">120 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-removed">121           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="line-removed">122 #endif</span>
<span class="line-removed">123           )</span>
<span class="line-removed">124         {</span>
<span class="line-removed">125           z = FFI_SIZEOF_ARG;</span>
<span class="line-removed">126           *(void **)argp = *p_argv;</span>
<span class="line-removed">127         }</span>
<span class="line-removed">128       else if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT)</span>
<span class="line-removed">129         {</span>
<span class="line-removed">130           memcpy(argp, *p_argv, z);</span>
<span class="line-removed">131         }</span>
<span class="line-removed">132       else</span>
<span class="line-removed">133 #endif</span>
<span class="line-removed">134       if (z &lt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">135         {</span>
<span class="line-removed">136           z = FFI_SIZEOF_ARG;</span>
<span class="line-removed">137           switch ((*p_arg)-&gt;type)</span>
<span class="line-removed">138             {</span>
<span class="line-removed">139             case FFI_TYPE_SINT8:</span>
<span class="line-removed">140               *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);</span>
141               break;
<a name="14" id="anc14"></a><span class="line-modified">142 </span>








143             case FFI_TYPE_UINT8:
<a name="15" id="anc15"></a><span class="line-modified">144               *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);</span>
145               break;
<a name="16" id="anc16"></a><span class="line-modified">146 </span>





147             case FFI_TYPE_SINT16:
<a name="17" id="anc17"></a><span class="line-modified">148               *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);</span>
149               break;
<a name="18" id="anc18"></a><span class="line-modified">150 </span>
<span class="line-removed">151             case FFI_TYPE_UINT16:</span>
<span class="line-removed">152               *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);</span>
<span class="line-removed">153               break;</span>
<span class="line-removed">154 </span>
155             case FFI_TYPE_SINT32:
<a name="19" id="anc19"></a><span class="line-removed">156               *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);</span>
<span class="line-removed">157               break;</span>
<span class="line-removed">158 </span>
159             case FFI_TYPE_UINT32:
<a name="20" id="anc20"></a><span class="line-modified">160               *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);</span>

161               break;
<a name="21" id="anc21"></a><span class="line-modified">162 </span>



163             case FFI_TYPE_STRUCT:
<a name="22" id="anc22"></a><span class="line-modified">164               *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);</span>




















165               break;
<a name="23" id="anc23"></a><span class="line-removed">166 </span>
167             default:
<a name="24" id="anc24"></a><span class="line-modified">168               FFI_ASSERT(0);</span>

169             }
<a name="25" id="anc25"></a>

170         }
<a name="26" id="anc26"></a><span class="line-modified">171       else</span>


172         {
<a name="27" id="anc27"></a><span class="line-modified">173           memcpy(argp, *p_argv, z);</span>




















174         }
<a name="28" id="anc28"></a>




175 
<a name="29" id="anc29"></a><span class="line-modified">176 #ifndef X86_WIN64</span>
<span class="line-removed">177     /* For thiscall/fastcall/register convention register-passed arguments</span>
<span class="line-removed">178        are the first two none-floating-point arguments with a size</span>
<span class="line-removed">179        smaller or equal to sizeof (void*).  */</span>
<span class="line-removed">180     if ((z == FFI_SIZEOF_ARG)</span>
<span class="line-removed">181         &amp;&amp; ((cabi == FFI_REGISTER)</span>
<span class="line-removed">182           || (cabi == FFI_THISCALL &amp;&amp; stack_args_count &lt; 1)</span>
<span class="line-removed">183           || (cabi == FFI_FASTCALL &amp;&amp; stack_args_count &lt; 2))</span>
<span class="line-removed">184         &amp;&amp; ((*p_arg)-&gt;type != FFI_TYPE_FLOAT &amp;&amp; (*p_arg)-&gt;type != FFI_TYPE_STRUCT)</span>
<span class="line-removed">185        )</span>
186       {
<a name="30" id="anc30"></a><span class="line-modified">187         if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 2)</span>
<span class="line-modified">188           {</span>
<span class="line-modified">189             /* Iterating arguments backwards, so first register-passed argument</span>
<span class="line-modified">190                will be passed last. Shift temporary values to make place. */</span>
<span class="line-removed">191             p_stack_data[0] = p_stack_data[1];</span>
<span class="line-removed">192             p_stack_data[1] = p_stack_data[2];</span>
<span class="line-removed">193             stack_args_count = 2;</span>
<span class="line-removed">194           }</span>
<span class="line-removed">195 </span>
<span class="line-removed">196         p_stack_data[stack_args_count] = argp;</span>
<span class="line-removed">197         ++stack_args_count;</span>
198       }
<a name="31" id="anc31"></a><span class="line-modified">199 #endif</span>
200 
<a name="32" id="anc32"></a><span class="line-modified">201 #ifdef X86_WIN64</span>
<span class="line-removed">202       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="line-removed">203 #else</span>
<span class="line-removed">204       argp += z;</span>
<span class="line-removed">205 #endif</span>
206     }
207 
<a name="33" id="anc33"></a><span class="line-modified">208 #ifndef X86_WIN64</span>
<span class="line-modified">209   /* We need to move the register-passed arguments for thiscall/fastcall/register</span>
<span class="line-removed">210      on top of stack, so that those can be moved to registers by call-handler.  */</span>
<span class="line-removed">211   if (stack_args_count &gt; 0)</span>
212     {
<a name="34" id="anc34"></a><span class="line-modified">213 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">214       int i;</span>
<span class="line-removed">215 #endif // GSTREAMER_LITE</span>
<span class="line-removed">216       if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 1)</span>
217         {
<a name="35" id="anc35"></a><span class="line-modified">218           /* Reverse order if iterating arguments backwards */</span>
<span class="line-modified">219           ffi_arg tmp = *(ffi_arg*) p_stack_data[0];</span>
<span class="line-modified">220           *(ffi_arg*) p_stack_data[0] = *(ffi_arg*) p_stack_data[stack_args_count - 1];</span>
<span class="line-modified">221           *(ffi_arg*) p_stack_data[stack_args_count - 1] = tmp;</span>
<span class="line-modified">222         }</span>



223 
<a name="36" id="anc36"></a><span class="line-modified">224 #ifndef GSTREAMER_LITE</span>
<span class="line-modified">225       int i;</span>
<span class="line-modified">226 #endif // GSTREAMER_LITE</span>
<span class="line-modified">227       for (i = 0; i &lt; stack_args_count; i++)</span>
<span class="line-modified">228         {</span>
<span class="line-removed">229           if (p_stack_data[i] != argp2)</span>
<span class="line-removed">230             {</span>
<span class="line-removed">231               ffi_arg tmp = *(ffi_arg*) p_stack_data[i];</span>
<span class="line-removed">232               memmove (argp2 + FFI_SIZEOF_ARG, argp2, (size_t) ((char*) p_stack_data[i] - (char*)argp2));</span>
<span class="line-removed">233               *(ffi_arg *) argp2 = tmp;</span>
<span class="line-removed">234             }</span>
235 
<a name="37" id="anc37"></a><span class="line-modified">236           argp2 += FFI_SIZEOF_ARG;</span>

237         }
238     }
239 
<a name="38" id="anc38"></a><span class="line-modified">240     return stack_args_count;</span>
<span class="line-removed">241 #endif</span>
<span class="line-removed">242     return 0;</span>
<span class="line-removed">243 }</span>
<span class="line-removed">244 </span>
<span class="line-removed">245 /* Perform machine dependent cif processing */</span>
<span class="line-removed">246 ffi_status ffi_prep_cif_machdep(ffi_cif *cif)</span>
247 {
<a name="39" id="anc39"></a><span class="line-modified">248   unsigned int i;</span>
<span class="line-modified">249   ffi_type **ptr;</span>
<span class="line-modified">250 </span>
<span class="line-modified">251   /* Set the return type flag */</span>
<span class="line-modified">252   switch (cif-&gt;rtype-&gt;type)</span>
<span class="line-modified">253     {</span>
<span class="line-modified">254     case FFI_TYPE_VOID:</span>
<span class="line-modified">255     case FFI_TYPE_UINT8:</span>
<span class="line-modified">256     case FFI_TYPE_UINT16:</span>
<span class="line-modified">257     case FFI_TYPE_SINT8:</span>
<span class="line-modified">258     case FFI_TYPE_SINT16:</span>
<span class="line-modified">259 #ifdef X86_WIN64</span>
<span class="line-modified">260     case FFI_TYPE_UINT32:</span>
<span class="line-modified">261     case FFI_TYPE_SINT32:</span>
<span class="line-modified">262 #endif</span>
<span class="line-modified">263     case FFI_TYPE_SINT64:</span>
<span class="line-modified">264     case FFI_TYPE_FLOAT:</span>
<span class="line-modified">265     case FFI_TYPE_DOUBLE:</span>
<span class="line-modified">266 #ifndef X86_WIN64</span>
<span class="line-modified">267 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-modified">268     case FFI_TYPE_LONGDOUBLE:</span>











269 #endif
<a name="40" id="anc40"></a>

270 #endif
<a name="41" id="anc41"></a><span class="line-removed">271       cif-&gt;flags = (unsigned) cif-&gt;rtype-&gt;type;</span>
<span class="line-removed">272       break;</span>
273 
<a name="42" id="anc42"></a><span class="line-modified">274     case FFI_TYPE_UINT64:</span>
<span class="line-removed">275 #ifdef X86_WIN64</span>
<span class="line-removed">276     case FFI_TYPE_POINTER:</span>
<span class="line-removed">277 #endif</span>
<span class="line-removed">278       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="line-removed">279       break;</span>
280 
<a name="43" id="anc43"></a><span class="line-modified">281     case FFI_TYPE_STRUCT:</span>
<span class="line-modified">282 #ifndef X86</span>
<span class="line-modified">283       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="line-removed">284         {</span>
<span class="line-removed">285           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */</span>
<span class="line-removed">286         }</span>
<span class="line-removed">287       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="line-removed">288         {</span>
<span class="line-removed">289           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */</span>
<span class="line-removed">290         }</span>
<span class="line-removed">291       else if (cif-&gt;rtype-&gt;size == 4)</span>
292         {
<a name="44" id="anc44"></a><span class="line-modified">293 #ifdef X86_WIN64</span>
<span class="line-modified">294           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_4B;</span>
<span class="line-modified">295 #else</span>
<span class="line-modified">296           cif-&gt;flags = FFI_TYPE_INT; /* same as int type */</span>
<span class="line-modified">297 #endif</span>
<span class="line-modified">298         }</span>
<span class="line-modified">299       else if (cif-&gt;rtype-&gt;size == 8)</span>







300         {
<a name="45" id="anc45"></a><span class="line-modified">301           cif-&gt;flags = FFI_TYPE_SINT64; /* same as int64 type */</span>
<span class="line-removed">302         }</span>
<span class="line-removed">303       else</span>
<span class="line-removed">304 #endif</span>
305         {
<a name="46" id="anc46"></a><span class="line-modified">306 #ifdef X86_WIN32</span>
<span class="line-modified">307           if (cif-&gt;abi == FFI_MS_CDECL)</span>
<span class="line-modified">308             cif-&gt;flags = FFI_TYPE_MS_STRUCT;</span>
<span class="line-modified">309           else</span>
<span class="line-modified">310 #endif</span>
<span class="line-modified">311             cif-&gt;flags = FFI_TYPE_STRUCT;</span>
<span class="line-modified">312           /* allocate space for return value pointer */</span>
<span class="line-modified">313           cif-&gt;bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);</span>
<span class="line-removed">314         }</span>
315       break;
<a name="47" id="anc47"></a><span class="line-removed">316 </span>
317     default:
<a name="48" id="anc48"></a><span class="line-modified">318 #ifdef X86_WIN64</span>
<span class="line-modified">319       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="line-removed">320       break;</span>
<span class="line-removed">321     case FFI_TYPE_INT:</span>
<span class="line-removed">322       cif-&gt;flags = FFI_TYPE_SINT32;</span>
<span class="line-removed">323 #else</span>
<span class="line-removed">324       cif-&gt;flags = FFI_TYPE_INT;</span>
<span class="line-removed">325 #endif</span>
326       break;
327     }
<a name="49" id="anc49"></a><span class="line-removed">328 </span>
<span class="line-removed">329   for (ptr = cif-&gt;arg_types, i = cif-&gt;nargs; i &gt; 0; i--, ptr++)</span>
<span class="line-removed">330     {</span>
<span class="line-removed">331       if (((*ptr)-&gt;alignment - 1) &amp; cif-&gt;bytes)</span>
<span class="line-removed">332         cif-&gt;bytes = ALIGN(cif-&gt;bytes, (*ptr)-&gt;alignment);</span>
<span class="line-removed">333       cif-&gt;bytes += (unsigned)ALIGN((*ptr)-&gt;size, FFI_SIZEOF_ARG);</span>
334     }
335 
<a name="50" id="anc50"></a><span class="line-modified">336 #ifdef X86_WIN64</span>
<span class="line-modified">337   /* ensure space for storing four registers */</span>
<span class="line-modified">338   cif-&gt;bytes += 4 * FFI_SIZEOF_ARG;</span>
<span class="line-modified">339 #endif</span>


340 
<a name="51" id="anc51"></a><span class="line-modified">341 #ifndef X86_WIN32</span>
<span class="line-modified">342 #ifndef X86_WIN64</span>
<span class="line-modified">343   if (cif-&gt;abi == FFI_SYSV || cif-&gt;abi == FFI_UNIX64)</span>
<span class="line-modified">344 #endif</span>
<span class="line-removed">345     cif-&gt;bytes = (cif-&gt;bytes + 15) &amp; ~0xF;</span>
<span class="line-removed">346 #endif</span>
347 
<a name="52" id="anc52"></a><span class="line-modified">348   return FFI_OK;</span>









349 }
<a name="53" id="anc53"></a>





350 
<a name="54" id="anc54"></a><span class="line-modified">351 #ifdef X86_WIN64</span>
<span class="line-modified">352 extern int</span>
<span class="line-modified">353 ffi_call_win64(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-modified">354                unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-modified">355 #else</span>
<span class="line-modified">356 extern void</span>
<span class="line-modified">357 ffi_call_win32(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-removed">358                unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-removed">359 extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,</span>
<span class="line-removed">360                           unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="line-removed">361 #endif</span>
362 
<a name="55" id="anc55"></a><span class="line-modified">363 void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
364 {
<a name="56" id="anc56"></a><span class="line-modified">365   extended_cif ecif;</span>
366 
<a name="57" id="anc57"></a><span class="line-modified">367   ecif.cif = cif;</span>
<span class="line-modified">368   ecif.avalue = avalue;</span>
<span class="line-modified">369 </span>
<span class="line-removed">370   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="line-removed">371   /* value address then we need to make one                     */</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 #ifdef X86_WIN64</span>
<span class="line-removed">374   if (rvalue == NULL</span>
<span class="line-removed">375       &amp;&amp; cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">376       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0))</span>
377     {
<a name="58" id="anc58"></a><span class="line-modified">378       ecif.rvalue = alloca((cif-&gt;rtype-&gt;size + 0xF) &amp; ~0xF);</span>

379     }
<a name="59" id="anc59"></a><span class="line-modified">380 #else</span>
<span class="line-removed">381   if (rvalue == NULL</span>
<span class="line-removed">382       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">383           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
384     {
<a name="60" id="anc60"></a><span class="line-modified">385       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>


386     }
<a name="61" id="anc61"></a><span class="line-removed">387 #endif</span>
388   else
<a name="62" id="anc62"></a><span class="line-removed">389     ecif.rvalue = rvalue;</span>
<span class="line-removed">390 </span>
<span class="line-removed">391 </span>
<span class="line-removed">392   switch (cif-&gt;abi)</span>
393     {
<a name="63" id="anc63"></a><span class="line-modified">394 #ifdef X86_WIN64</span>
<span class="line-modified">395     case FFI_WIN64:</span>
<span class="line-modified">396       ffi_call_win64(ffi_prep_args, &amp;ecif, cif-&gt;bytes,</span>
<span class="line-modified">397                      cif-&gt;flags, ecif.rvalue, fn);</span>
<span class="line-modified">398       break;</span>
<span class="line-modified">399 #else</span>
<span class="line-modified">400 #ifndef X86_WIN32</span>
<span class="line-modified">401     case FFI_SYSV:</span>
<span class="line-modified">402       ffi_call_SYSV(ffi_prep_args, &amp;ecif, cif-&gt;bytes, cif-&gt;flags, ecif.rvalue,</span>
<span class="line-modified">403                     fn);</span>
<span class="line-modified">404       break;</span>
<span class="line-modified">405 #else</span>
<span class="line-modified">406     case FFI_SYSV:</span>
<span class="line-modified">407     case FFI_MS_CDECL:</span>
<span class="line-modified">408 #endif</span>
<span class="line-modified">409     case FFI_STDCALL:</span>
<span class="line-modified">410     case FFI_THISCALL:</span>
<span class="line-modified">411     case FFI_FASTCALL:</span>
<span class="line-modified">412     case FFI_PASCAL:</span>
<span class="line-modified">413     case FFI_REGISTER:</span>
<span class="line-modified">414       ffi_call_win32(ffi_prep_args, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-modified">415                      ecif.rvalue, fn);</span>
<span class="line-modified">416       break;</span>
<span class="line-modified">417 #endif</span>
<span class="line-modified">418     default:</span>
<span class="line-modified">419       FFI_ASSERT(0);</span>
<span class="line-modified">420       break;</span>

421     }
<a name="64" id="anc64"></a>




422 }
<a name="65" id="anc65"></a>


423 
<a name="66" id="anc66"></a><span class="line-modified">424 </span>
<span class="line-removed">425 /** private members **/</span>
<span class="line-removed">426 </span>
<span class="line-removed">427 /* The following __attribute__((regparm(1))) decorations will have no effect</span>
<span class="line-removed">428    on MSVC or SUNPRO_C -- standard conventions apply. */</span>
<span class="line-removed">429 static unsigned int ffi_prep_incoming_args (char *stack, void **ret,</span>
<span class="line-removed">430                                             void** args, ffi_cif* cif);</span>
<span class="line-removed">431 void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)</span>
<span class="line-removed">432      __attribute__ ((regparm(1)));</span>
<span class="line-removed">433 unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)</span>
<span class="line-removed">434      __attribute__ ((regparm(1)));</span>
<span class="line-removed">435 unsigned int FFI_HIDDEN ffi_closure_WIN32_inner (ffi_closure *, void **, void *)</span>
<span class="line-removed">436      __attribute__ ((regparm(1)));</span>
<span class="line-removed">437 void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)</span>
<span class="line-removed">438      __attribute__ ((regparm(1)));</span>
<span class="line-removed">439 #ifdef X86_WIN32</span>
<span class="line-removed">440 void FFI_HIDDEN ffi_closure_raw_THISCALL (ffi_raw_closure *)</span>
<span class="line-removed">441      __attribute__ ((regparm(1)));</span>
<span class="line-removed">442 #endif</span>
<span class="line-removed">443 #ifndef X86_WIN64</span>
<span class="line-removed">444 void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *);</span>
<span class="line-removed">445 void FFI_HIDDEN ffi_closure_THISCALL (ffi_closure *);</span>
<span class="line-removed">446 void FFI_HIDDEN ffi_closure_FASTCALL (ffi_closure *);</span>
<span class="line-removed">447 void FFI_HIDDEN ffi_closure_REGISTER (ffi_closure *);</span>
<span class="line-removed">448 #else</span>
<span class="line-removed">449 void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);</span>
<span class="line-removed">450 #endif</span>
<span class="line-removed">451 </span>
<span class="line-removed">452 /* This function is jumped to by the trampoline */</span>
<span class="line-removed">453 </span>
<span class="line-removed">454 #ifdef X86_WIN64</span>
<span class="line-removed">455 void * FFI_HIDDEN</span>
<span class="line-removed">456 ffi_closure_win64_inner (ffi_closure *closure, void *args) {</span>
<span class="line-removed">457   ffi_cif       *cif;</span>
<span class="line-removed">458   void         **arg_area;</span>
<span class="line-removed">459   void          *result;</span>
<span class="line-removed">460   void          *resp = &amp;result;</span>
<span class="line-removed">461 </span>
<span class="line-removed">462   cif         = closure-&gt;cif;</span>
<span class="line-removed">463   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">464 </span>
<span class="line-removed">465   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">466    * element in that array points to the corresponding</span>
<span class="line-removed">467    * value on the stack; and if the function returns</span>
<span class="line-removed">468    * a structure, it will change RESP to point to the</span>
<span class="line-removed">469    * structure return address.  */</span>
<span class="line-removed">470 </span>
<span class="line-removed">471   ffi_prep_incoming_args(args, &amp;resp, arg_area, cif);</span>
<span class="line-removed">472 </span>
<span class="line-removed">473   (closure-&gt;fun) (cif, resp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">474 </span>
<span class="line-removed">475   /* The result is returned in rax.  This does the right thing for</span>
<span class="line-removed">476      result types except for floats; we have to &#39;mov xmm0, rax&#39; in the</span>
<span class="line-removed">477      caller to correct this.</span>
<span class="line-removed">478      TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!</span>
<span class="line-removed">479   */</span>
<span class="line-removed">480   return cif-&gt;rtype-&gt;size &gt; sizeof(void *) ? resp : *(void **)resp;</span>
481 }
482 
<a name="67" id="anc67"></a><span class="line-modified">483 #else</span>
<span class="line-modified">484 unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="line-removed">485 ffi_closure_SYSV_inner (ffi_closure *closure, void **respp, void *args)</span>
486 {
<a name="68" id="anc68"></a><span class="line-modified">487   /* our various things...  */</span>
<span class="line-removed">488   ffi_cif       *cif;</span>
<span class="line-removed">489   void         **arg_area;</span>
<span class="line-removed">490 </span>
<span class="line-removed">491   cif         = closure-&gt;cif;</span>
<span class="line-removed">492   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">493 </span>
<span class="line-removed">494   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">495    * element in that array points to the corresponding</span>
<span class="line-removed">496    * value on the stack; and if the function returns</span>
<span class="line-removed">497    * a structure, it will change RESP to point to the</span>
<span class="line-removed">498    * structure return address.  */</span>
<span class="line-removed">499 </span>
<span class="line-removed">500   ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="line-removed">501 </span>
<span class="line-removed">502   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">503 </span>
<span class="line-removed">504   return cif-&gt;flags;</span>
505 }
506 
<a name="69" id="anc69"></a><span class="line-modified">507 unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="line-modified">508 ffi_closure_WIN32_inner (ffi_closure *closure, void **respp, void *args)</span>

509 {
<a name="70" id="anc70"></a><span class="line-modified">510   /* our various things...  */</span>
<span class="line-removed">511   ffi_cif       *cif;</span>
<span class="line-removed">512   void         **arg_area;</span>
<span class="line-removed">513   unsigned int   ret;</span>
<span class="line-removed">514 </span>
<span class="line-removed">515   cif         = closure-&gt;cif;</span>
<span class="line-removed">516   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="line-removed">517 </span>
<span class="line-removed">518   /* this call will initialize ARG_AREA, such that each</span>
<span class="line-removed">519    * element in that array points to the corresponding</span>
<span class="line-removed">520    * value on the stack; and if the function returns</span>
<span class="line-removed">521    * a structure, it will change RESP to point to the</span>
<span class="line-removed">522    * structure return address.  */</span>
<span class="line-removed">523 </span>
<span class="line-removed">524   ret = ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="line-removed">525 </span>
<span class="line-removed">526   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="line-removed">527 </span>
<span class="line-removed">528   return ret;</span>
529 }
<a name="71" id="anc71"></a><span class="line-removed">530 #endif /* !X86_WIN64 */</span>
531 
<a name="72" id="anc72"></a><span class="line-modified">532 static unsigned int</span>
<span class="line-removed">533 ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,</span>
<span class="line-removed">534                        ffi_cif *cif)</span>
<span class="line-removed">535 {</span>
<span class="line-removed">536   register unsigned int i;</span>
<span class="line-removed">537   register void **p_argv;</span>
<span class="line-removed">538   register char *argp;</span>
<span class="line-removed">539   register ffi_type **p_arg;</span>
<span class="line-removed">540 #ifndef X86_WIN64</span>
<span class="line-removed">541   const int cabi = cif-&gt;abi;</span>
<span class="line-removed">542   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="line-removed">543   const unsigned int max_stack_count = (cabi == FFI_THISCALL) ? 1</span>
<span class="line-removed">544                                      : (cabi == FFI_FASTCALL) ? 2</span>
<span class="line-removed">545                                      : (cabi == FFI_REGISTER) ? 3</span>
<span class="line-removed">546                                      : 0;</span>
<span class="line-removed">547   unsigned int passed_regs = 0;</span>
<span class="line-removed">548   void *p_stack_data[3] = { stack - 1 };</span>
<span class="line-removed">549 #else</span>
<span class="line-removed">550   #define dir 1</span>
<span class="line-removed">551 #endif</span>
552 
<a name="73" id="anc73"></a><span class="line-modified">553   argp = stack;</span>
<span class="line-modified">554 #ifndef X86_WIN64</span>
<span class="line-modified">555   argp += max_stack_count * FFI_SIZEOF_ARG;</span>
<span class="line-removed">556 #endif</span>
557 
<a name="74" id="anc74"></a><span class="line-modified">558   if ((cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-modified">559        || cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="line-modified">560 #ifdef X86_WIN64</span>
<span class="line-modified">561       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-modified">562 #endif</span>
<span class="line-modified">563       )</span>























564     {
<a name="75" id="anc75"></a><span class="line-modified">565 #ifndef X86_WIN64</span>
<span class="line-modified">566       if (passed_regs &lt; max_stack_count)</span>
567         {
<a name="76" id="anc76"></a><span class="line-modified">568           *rvalue = *(void**) (stack + (passed_regs*FFI_SIZEOF_ARG));</span>
<span class="line-modified">569           ++passed_regs;</span>


570         }
<a name="77" id="anc77"></a><span class="line-modified">571       else</span>
<span class="line-modified">572 #endif</span>
<span class="line-modified">573         {</span>
<span class="line-removed">574           *rvalue = *(void **) argp;</span>
575           argp += sizeof(void *);
<a name="78" id="anc78"></a>

576         }
<a name="79" id="anc79"></a><span class="line-removed">577     }</span>
578 
<a name="80" id="anc80"></a><span class="line-modified">579 #ifndef X86_WIN64</span>
<span class="line-modified">580   /* Do register arguments first  */</span>
<span class="line-modified">581   for (i = 0, p_arg = cif-&gt;arg_types;</span>
<span class="line-modified">582        i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt; max_stack_count;</span>
<span class="line-modified">583        i++, p_arg++)</span>
584   {
<a name="81" id="anc81"></a><span class="line-modified">585 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">586       size_t sz = 0;</span>
<span class="line-modified">587 #endif // GSTREAMER_LITE</span>
<span class="line-modified">588       if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT</span>
<span class="line-removed">589          || (*p_arg)-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="line-removed">590         continue;</span>
<span class="line-removed">591 </span>
<span class="line-removed">592 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">593       sz = (*p_arg)-&gt;size;</span>
<span class="line-removed">594 #else // GSTREAMER_LITE</span>
<span class="line-removed">595       size_t sz = (*p_arg)-&gt;size;</span>
<span class="line-removed">596 #endif // GSTREAMER_LITE</span>
<span class="line-removed">597       if(sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">598         continue;</span>
<span class="line-removed">599 </span>
<span class="line-removed">600       p_stack_data[passed_regs] = avalue + i;</span>
<span class="line-removed">601       avalue[i] = stack + (passed_regs*FFI_SIZEOF_ARG);</span>
<span class="line-removed">602       ++passed_regs;</span>
<span class="line-removed">603     }</span>
<span class="line-removed">604 #endif</span>
605 
<a name="82" id="anc82"></a><span class="line-modified">606   p_arg = cif-&gt;arg_types;</span>
<span class="line-removed">607   p_argv = avalue;</span>
<span class="line-removed">608   if (dir &lt; 0)</span>
609     {
<a name="83" id="anc83"></a><span class="line-modified">610       const int nargs = cif-&gt;nargs - 1;</span>
<span class="line-modified">611       if (nargs &gt; 0)</span>

612       {
<a name="84" id="anc84"></a><span class="line-modified">613         p_arg  += nargs;</span>
<span class="line-modified">614         p_argv += nargs;</span>
615       }
<a name="85" id="anc85"></a>



616     }
<a name="86" id="anc86"></a><span class="line-modified">617 </span>
<span class="line-modified">618   for (i = cif-&gt;nargs;</span>
<span class="line-removed">619        i != 0;</span>
<span class="line-removed">620        i--, p_arg += dir, p_argv += dir)</span>
621     {
<a name="87" id="anc87"></a><span class="line-modified">622 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">623       size_t z = 0;</span>
<span class="line-modified">624 #endif // GSTREAMER_LITE</span>
<span class="line-modified">625       /* Align if necessary */</span>
<span class="line-modified">626       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="line-modified">627         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="line-modified">628 </span>
<span class="line-modified">629 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">630       z = (*p_arg)-&gt;size;</span>
<span class="line-modified">631 #else // GSTREAMER_LITE</span>
<span class="line-modified">632       size_t z = (*p_arg)-&gt;size;</span>
<span class="line-modified">633 #endif // GSTREAMER_LITE</span>
<span class="line-modified">634 </span>
<span class="line-modified">635 #ifdef X86_WIN64</span>
<span class="line-modified">636       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="line-modified">637           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="line-modified">638               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="line-removed">639 #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="line-removed">640           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="line-removed">641 #endif</span>
<span class="line-removed">642           )</span>
643         {
<a name="88" id="anc88"></a><span class="line-modified">644           z = FFI_SIZEOF_ARG;</span>
<span class="line-modified">645           *p_argv = *(void **)argp;</span>


646         }
647       else
<a name="89" id="anc89"></a><span class="line-removed">648 #else</span>
<span class="line-removed">649       if (passed_regs &gt; 0</span>
<span class="line-removed">650           &amp;&amp; z &lt;= FFI_SIZEOF_ARG</span>
<span class="line-removed">651           &amp;&amp; (p_argv == p_stack_data[0]</span>
<span class="line-removed">652             || p_argv == p_stack_data[1]</span>
<span class="line-removed">653             || p_argv == p_stack_data[2]))</span>
654         {
<a name="90" id="anc90"></a><span class="line-modified">655           /* Already assigned a register value */</span>
<span class="line-modified">656           continue;</span>

657         }
<a name="91" id="anc91"></a><span class="line-removed">658       else</span>
<span class="line-removed">659 #endif</span>
<span class="line-removed">660         {</span>
<span class="line-removed">661           /* because we&#39;re little endian, this is what it turns into.   */</span>
<span class="line-removed">662           *p_argv = (void*) argp;</span>
663         }
664 
<a name="92" id="anc92"></a><span class="line-modified">665 #ifdef X86_WIN64</span>
<span class="line-removed">666       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="line-removed">667 #else</span>
<span class="line-removed">668       argp += z;</span>
<span class="line-removed">669 #endif</span>
670     }
671 
<a name="93" id="anc93"></a><span class="line-modified">672   return (size_t)argp - (size_t)stack;</span>
<span class="line-removed">673 }</span>
674 
<a name="94" id="anc94"></a><span class="line-modified">675 #define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \</span>
<span class="line-modified">676 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-modified">677    void*  __fun = (void*)(FUN); \</span>
<span class="line-modified">678    void*  __ctx = (void*)(CTX); \</span>
<span class="line-removed">679    *(unsigned char*) &amp;__tramp[0] = 0x41; \</span>
<span class="line-removed">680    *(unsigned char*) &amp;__tramp[1] = 0xbb; \</span>
<span class="line-removed">681    *(unsigned int*) &amp;__tramp[2] = MASK; /* mov $mask, %r11 */ \</span>
<span class="line-removed">682    *(unsigned char*) &amp;__tramp[6] = 0x48; \</span>
<span class="line-removed">683    *(unsigned char*) &amp;__tramp[7] = 0xb8; \</span>
<span class="line-removed">684    *(void**) &amp;__tramp[8] = __ctx; /* mov __ctx, %rax */ \</span>
<span class="line-removed">685    *(unsigned char *)  &amp;__tramp[16] = 0x49; \</span>
<span class="line-removed">686    *(unsigned char *)  &amp;__tramp[17] = 0xba; \</span>
<span class="line-removed">687    *(void**) &amp;__tramp[18] = __fun; /* mov __fun, %r10 */ \</span>
<span class="line-removed">688    *(unsigned char *)  &amp;__tramp[26] = 0x41; \</span>
<span class="line-removed">689    *(unsigned char *)  &amp;__tramp[27] = 0xff; \</span>
<span class="line-removed">690    *(unsigned char *)  &amp;__tramp[28] = 0xe2; /* jmp %r10 */ \</span>
<span class="line-removed">691  }</span>
<span class="line-removed">692 </span>
<span class="line-removed">693 /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */</span>
<span class="line-removed">694 </span>
<span class="line-removed">695 #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \</span>
<span class="line-removed">696 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">697    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">698    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">699    unsigned int  __dis = __fun - (__ctx + 10);  \</span>
<span class="line-removed">700    *(unsigned char*) &amp;__tramp[0] = 0xb8; \</span>
<span class="line-removed">701    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* movl __ctx, %eax */ \</span>
<span class="line-removed">702    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="line-removed">703    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
<span class="line-removed">704  }</span>
<span class="line-removed">705 </span>
<span class="line-removed">706 #define FFI_INIT_TRAMPOLINE_RAW_THISCALL(TRAMP,FUN,CTX,SIZE) \</span>
<span class="line-removed">707 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">708    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">709    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">710    unsigned int  __dis = __fun - (__ctx + 49);  \</span>
<span class="line-removed">711    unsigned short __size = (unsigned short)(SIZE); \</span>
<span class="line-removed">712    *(unsigned int *) &amp;__tramp[0] = 0x8324048b;      /* mov (%esp), %eax */ \</span>
<span class="line-removed">713    *(unsigned int *) &amp;__tramp[4] = 0x4c890cec;      /* sub $12, %esp */ \</span>
<span class="line-removed">714    *(unsigned int *) &amp;__tramp[8] = 0x04890424;      /* mov %ecx, 4(%esp) */ \</span>
<span class="line-removed">715    *(unsigned char*) &amp;__tramp[12] = 0x24;           /* mov %eax, (%esp) */ \</span>
<span class="line-removed">716    *(unsigned char*) &amp;__tramp[13] = 0xb8; \</span>
<span class="line-removed">717    *(unsigned int *) &amp;__tramp[14] = __size;         /* mov __size, %eax */ \</span>
<span class="line-removed">718    *(unsigned int *) &amp;__tramp[18] = 0x08244c8d;     /* lea 8(%esp), %ecx */ \</span>
<span class="line-removed">719    *(unsigned int *) &amp;__tramp[22] = 0x4802e8c1;     /* shr $2, %eax ; dec %eax */ \</span>
<span class="line-removed">720    *(unsigned short*) &amp;__tramp[26] = 0x0b74;        /* jz 1f */ \</span>
<span class="line-removed">721    *(unsigned int *) &amp;__tramp[28] = 0x8908518b;     /* 2b: mov 8(%ecx), %edx */ \</span>
<span class="line-removed">722    *(unsigned int *) &amp;__tramp[32] = 0x04c18311;     /* mov %edx, (%ecx) ; add $4, %ecx */ \</span>
<span class="line-removed">723    *(unsigned char*) &amp;__tramp[36] = 0x48;           /* dec %eax */ \</span>
<span class="line-removed">724    *(unsigned short*) &amp;__tramp[37] = 0xf575;        /* jnz 2b ; 1f: */ \</span>
<span class="line-removed">725    *(unsigned char*) &amp;__tramp[39] = 0xb8; \</span>
<span class="line-removed">726    *(unsigned int*)  &amp;__tramp[40] = __ctx;          /* movl __ctx, %eax */ \</span>
<span class="line-removed">727    *(unsigned char *)  &amp;__tramp[44] = 0xe8; \</span>
<span class="line-removed">728    *(unsigned int*)  &amp;__tramp[45] = __dis;          /* call __fun  */ \</span>
<span class="line-removed">729    *(unsigned char*)  &amp;__tramp[49] = 0xc2;          /* ret  */ \</span>
<span class="line-removed">730    *(unsigned short*)  &amp;__tramp[50] = (__size + 8); /* ret (__size + 8)  */ \</span>
<span class="line-removed">731  }</span>
<span class="line-removed">732 </span>
<span class="line-removed">733 #define FFI_INIT_TRAMPOLINE_WIN32(TRAMP,FUN,CTX)  \</span>
<span class="line-removed">734 { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="line-removed">735    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="line-removed">736    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="line-removed">737    unsigned int  __dis = __fun - (__ctx + 10); \</span>
<span class="line-removed">738    *(unsigned char*) &amp;__tramp[0] = 0x68; \</span>
<span class="line-removed">739    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* push __ctx */ \</span>
<span class="line-removed">740    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="line-removed">741    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
742  }
743 
<a name="95" id="anc95"></a><span class="line-removed">744 /* the cif must already be prep&#39;ed */</span>
<span class="line-removed">745 </span>
746 ffi_status
747 ffi_prep_closure_loc (ffi_closure* closure,
748                       ffi_cif* cif,
749                       void (*fun)(ffi_cif*,void*,void**,void*),
750                       void *user_data,
751                       void *codeloc)
752 {
<a name="96" id="anc96"></a><span class="line-modified">753 #ifdef X86_WIN64</span>
<span class="line-modified">754 #define ISFLOAT(IDX) (cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_FLOAT || cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_DOUBLE)</span>
<span class="line-modified">755 #define FLAG(IDX) (cif-&gt;nargs&gt;(IDX)&amp;&amp;ISFLOAT(IDX)?(1&lt;&lt;(IDX)):0)</span>
<span class="line-modified">756   if (cif-&gt;abi == FFI_WIN64)</span>
<span class="line-modified">757     {</span>
<span class="line-removed">758       int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);</span>
<span class="line-removed">759       FFI_INIT_TRAMPOLINE_WIN64 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">760                                  &amp;ffi_closure_win64,</span>
<span class="line-removed">761                                  codeloc, mask);</span>
<span class="line-removed">762       /* make sure we can execute here */</span>
<span class="line-removed">763     }</span>
<span class="line-removed">764 #else</span>
<span class="line-removed">765   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="line-removed">766     {</span>
<span class="line-removed">767       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">768                            &amp;ffi_closure_SYSV,</span>
<span class="line-removed">769                            (void*)codeloc);</span>
<span class="line-removed">770     }</span>
<span class="line-removed">771   else if (cif-&gt;abi == FFI_REGISTER)</span>
<span class="line-removed">772     {</span>
<span class="line-removed">773       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">774                                    &amp;ffi_closure_REGISTER,</span>
<span class="line-removed">775                                    (void*)codeloc);</span>
<span class="line-removed">776     }</span>
<span class="line-removed">777   else if (cif-&gt;abi == FFI_FASTCALL)</span>
<span class="line-removed">778     {</span>
<span class="line-removed">779       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-removed">780                                    &amp;ffi_closure_FASTCALL,</span>
<span class="line-removed">781                                    (void*)codeloc);</span>
<span class="line-removed">782     }</span>
<span class="line-removed">783   else if (cif-&gt;abi == FFI_THISCALL)</span>
784     {
<a name="97" id="anc97"></a><span class="line-modified">785       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">786                                    &amp;ffi_closure_THISCALL,</span>
<span class="line-modified">787                                    (void*)codeloc);</span>













788     }
<a name="98" id="anc98"></a><span class="line-modified">789   else if (cif-&gt;abi == FFI_STDCALL || cif-&gt;abi == FFI_PASCAL)</span>
<span class="line-modified">790     {</span>
<span class="line-modified">791       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">792                                    &amp;ffi_closure_STDCALL,</span>
<span class="line-modified">793                                    (void*)codeloc);</span>









794     }
<a name="99" id="anc99"></a><span class="line-modified">795 #ifdef X86_WIN32</span>
<span class="line-modified">796   else if (cif-&gt;abi == FFI_MS_CDECL)</span>






797     {
<a name="100" id="anc100"></a><span class="line-modified">798       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="line-modified">799                            &amp;ffi_closure_SYSV,</span>
<span class="line-modified">800                            (void*)codeloc);</span>
<span class="line-removed">801     }</span>
<span class="line-removed">802 #endif /* X86_WIN32 */</span>
<span class="line-removed">803 #endif /* !X86_WIN64 */</span>
<span class="line-removed">804   else</span>
805     {
<a name="101" id="anc101"></a>













806       return FFI_BAD_ABI;
807     }
808 
<a name="102" id="anc102"></a><span class="line-modified">809   closure-&gt;cif  = cif;</span>
<span class="line-modified">810   closure-&gt;user_data = user_data;</span>
<span class="line-modified">811   closure-&gt;fun  = fun;</span>
812 
813   return FFI_OK;
814 }
815 
816 /* ------- Native raw API support -------------------------------- */
817 
818 #if !FFI_NO_RAW_API
819 
<a name="103" id="anc103"></a>


820 ffi_status
<a name="104" id="anc104"></a><span class="line-modified">821 ffi_prep_raw_closure_loc (ffi_raw_closure* closure,</span>
<span class="line-modified">822                           ffi_cif* cif,</span>
823                           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
824                           void *user_data,
825                           void *codeloc)
826 {
<a name="105" id="anc105"></a>

827   int i;
828 
<a name="106" id="anc106"></a><span class="line-modified">829   if (cif-&gt;abi != FFI_SYSV</span>
<span class="line-removed">830 #ifdef X86_WIN32</span>
<span class="line-removed">831       &amp;&amp; cif-&gt;abi != FFI_THISCALL</span>
<span class="line-removed">832 #endif</span>
<span class="line-removed">833      )</span>
<span class="line-removed">834     return FFI_BAD_ABI;</span>
<span class="line-removed">835 </span>
<span class="line-removed">836   /* we currently don&#39;t support certain kinds of arguments for raw</span>
837      closures.  This should be implemented by a separate assembly
838      language routine, since it would require argument processing,
839      something we don&#39;t do now for performance.  */
<a name="107" id="anc107"></a><span class="line-removed">840 </span>
841   for (i = cif-&gt;nargs-1; i &gt;= 0; i--)
<a name="108" id="anc108"></a>
842     {
<a name="109" id="anc109"></a><span class="line-modified">843       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_STRUCT);</span>
<span class="line-modified">844       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_LONGDOUBLE);</span>

845     }
846 
<a name="110" id="anc110"></a><span class="line-modified">847 #ifdef X86_WIN32</span>
<span class="line-removed">848   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="line-removed">849     {</span>
<span class="line-removed">850 #endif</span>
<span class="line-removed">851   FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_SYSV,</span>
<span class="line-removed">852                        codeloc);</span>
<span class="line-removed">853 #ifdef X86_WIN32</span>
<span class="line-removed">854     }</span>
<span class="line-removed">855   else if (cif-&gt;abi == FFI_THISCALL)</span>
856     {
<a name="111" id="anc111"></a><span class="line-modified">857       FFI_INIT_TRAMPOLINE_RAW_THISCALL (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_THISCALL, codeloc, cif-&gt;bytes);</span>







858     }
<a name="112" id="anc112"></a><span class="line-modified">859 #endif</span>
<span class="line-modified">860   closure-&gt;cif  = cif;</span>









861   closure-&gt;user_data = user_data;
<a name="113" id="anc113"></a><span class="line-removed">862   closure-&gt;fun  = fun;</span>
863 
864   return FFI_OK;
865 }
866 
<a name="114" id="anc114"></a><span class="line-modified">867 static unsigned int</span>
<span class="line-modified">868 ffi_prep_args_raw(char *stack, extended_cif *ecif)</span>
869 {
<a name="115" id="anc115"></a><span class="line-modified">870   const ffi_cif *cif = ecif-&gt;cif;</span>
<span class="line-modified">871   unsigned int i, passed_regs = 0;</span>





























872 
<a name="116" id="anc116"></a><span class="line-modified">873 #ifndef X86_WIN64</span>
<span class="line-modified">874   const unsigned int abi = cif-&gt;abi;</span>
<span class="line-modified">875   const unsigned int max_regs = (abi == FFI_THISCALL) ? 1</span>
<span class="line-modified">876                               : (abi == FFI_FASTCALL) ? 2</span>
<span class="line-modified">877                               : (abi == FFI_REGISTER) ? 3</span>
<span class="line-modified">878                               : 0;</span>
879 
<a name="117" id="anc117"></a><span class="line-modified">880   if (cif-&gt;flags == FFI_TYPE_STRUCT)</span>
<span class="line-modified">881     ++passed_regs;</span>

882 
<a name="118" id="anc118"></a><span class="line-modified">883   for (i = 0; i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt;= max_regs; i++)</span>

884     {
<a name="119" id="anc119"></a><span class="line-modified">885 #ifdef GSTREAMER_LITE</span>
<span class="line-modified">886       size_t sz = 0;</span>
<span class="line-modified">887 #endif // GSTREAMER_LITE</span>
<span class="line-modified">888       if (cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_FLOAT</span>
<span class="line-modified">889          || cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="line-modified">890         continue;</span>
<span class="line-modified">891 </span>
<span class="line-removed">892 #ifdef GSTREAMER_LITE</span>
<span class="line-removed">893       sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="line-removed">894 #else // GSTREAMER_LITE</span>
<span class="line-removed">895       size_t sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="line-removed">896 #endif // GSTREAMER_LITE</span>
<span class="line-removed">897       if (sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="line-removed">898         continue;</span>
<span class="line-removed">899 </span>
<span class="line-removed">900       ++passed_regs;</span>
<span class="line-removed">901     }</span>
<span class="line-removed">902 #endif</span>
<span class="line-removed">903 </span>
<span class="line-removed">904   memcpy (stack, ecif-&gt;avalue, cif-&gt;bytes);</span>
<span class="line-removed">905   return passed_regs;</span>
906 }
<a name="120" id="anc120"></a>






907 
<a name="121" id="anc121"></a><span class="line-modified">908 /* we borrow this routine from libffi (it must be changed, though, to</span>
<span class="line-modified">909  * actually call the function passed in the first argument.  as of</span>
<span class="line-removed">910  * libffi-1.20, this is not the case.)</span>
<span class="line-removed">911  */</span>
<span class="line-removed">912 </span>
<span class="line-removed">913 void</span>
<span class="line-removed">914 ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)</span>
915 {
<a name="122" id="anc122"></a><span class="line-modified">916   extended_cif ecif;</span>
<span class="line-modified">917   void **avalue = (void **)fake_avalue;</span>
<span class="line-modified">918 </span>
<span class="line-removed">919   ecif.cif = cif;</span>
<span class="line-removed">920   ecif.avalue = avalue;</span>
<span class="line-removed">921 </span>
<span class="line-removed">922   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="line-removed">923   /* value address then we need to make one                     */</span>
924 
<a name="123" id="anc123"></a><span class="line-modified">925   if (rvalue == NULL</span>
<span class="line-removed">926       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="line-removed">927           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
928     {
<a name="124" id="anc124"></a><span class="line-modified">929       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>


930     }
931   else
<a name="125" id="anc125"></a><span class="line-removed">932     ecif.rvalue = rvalue;</span>
<span class="line-removed">933 </span>
<span class="line-removed">934 </span>
<span class="line-removed">935   switch (cif-&gt;abi)</span>
936     {
<a name="126" id="anc126"></a><span class="line-modified">937 #ifndef X86_WIN32</span>
<span class="line-modified">938     case FFI_SYSV:</span>
<span class="line-modified">939       ffi_call_SYSV(ffi_prep_args_raw, &amp;ecif, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-removed">940                     ecif.rvalue, fn);</span>
<span class="line-removed">941       break;</span>
<span class="line-removed">942 #else</span>
<span class="line-removed">943     case FFI_SYSV:</span>
<span class="line-removed">944     case FFI_MS_CDECL:</span>
<span class="line-removed">945 #endif</span>
<span class="line-removed">946 #ifndef X86_WIN64</span>
<span class="line-removed">947     case FFI_STDCALL:</span>
<span class="line-removed">948     case FFI_THISCALL:</span>
<span class="line-removed">949     case FFI_FASTCALL:</span>
<span class="line-removed">950     case FFI_PASCAL:</span>
<span class="line-removed">951     case FFI_REGISTER:</span>
<span class="line-removed">952       ffi_call_win32(ffi_prep_args_raw, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="line-removed">953                      ecif.rvalue, fn);</span>
<span class="line-removed">954       break;</span>
<span class="line-removed">955 #endif</span>
<span class="line-removed">956     default:</span>
<span class="line-removed">957       FFI_ASSERT(0);</span>
<span class="line-removed">958       break;</span>
959     }
<a name="127" id="anc127"></a>

960 }
<a name="128" id="anc128"></a>

961 
<a name="129" id="anc129"></a><span class="line-modified">962 #endif</span>
<span class="line-modified">963 </span>
<span class="line-modified">964 #endif /* !__x86_64__  || X86_WIN64 */</span>
<span class="line-modified">965 </span>
<a name="130" id="anc130"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="130" type="hidden" />
</body>
</html>
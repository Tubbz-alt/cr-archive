<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/vtrans.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: VTrans.h
  3 //
  4 // Desc: DirectShow base classes - defines a video transform class.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 // This class is derived from CTransformFilter, but is specialised to handle
 11 // the requirements of video quality control by frame dropping.
 12 // This is a non-in-place transform, (i.e. it copies the data) such as a decoder.
 13 
 14 class CVideoTransformFilter : public CTransformFilter
 15 {
 16   public:
 17 
 18     CVideoTransformFilter(__in_opt LPCTSTR, __inout_opt LPUNKNOWN, REFCLSID clsid);
 19     ~CVideoTransformFilter();
 20     HRESULT EndFlush();
 21 
 22     // =================================================================
 23     // ----- override these bits ---------------------------------------
 24     // =================================================================
 25     // The following methods are in CTransformFilter which is inherited.
 26     // They are mentioned here for completeness
 27     //
 28     // These MUST be supplied in a derived class
 29     //
 30     // NOTE:
 31     // virtual HRESULT Transform(IMediaSample * pIn, IMediaSample *pOut);
 32     // virtual HRESULT CheckInputType(const CMediaType* mtIn) PURE;
 33     // virtual HRESULT CheckTransform
 34     //     (const CMediaType* mtIn, const CMediaType* mtOut) PURE;
 35     // static CCOMObject * CreateInstance(LPUNKNOWN, HRESULT *);
 36     // virtual HRESULT DecideBufferSize
 37     //     (IMemAllocator * pAllocator, ALLOCATOR_PROPERTIES *pprop) PURE;
 38     // virtual HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) PURE;
 39     //
 40     // These MAY also be overridden
 41     //
 42     // virtual HRESULT StopStreaming();
 43     // virtual HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt);
 44     // virtual HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
 45     // virtual HRESULT BreakConnect(PIN_DIRECTION dir);
 46     // virtual HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin);
 47     // virtual HRESULT EndOfStream(void);
 48     // virtual HRESULT BeginFlush(void);
 49     // virtual HRESULT EndFlush(void);
 50     // virtual HRESULT NewSegment
 51     //     (REFERENCE_TIME tStart,REFERENCE_TIME tStop,double dRate);
 52 #ifdef PERF
 53 
 54     // If you override this - ensure that you register all these ids
 55     // as well as any of your own,
 56     virtual void RegisterPerfId() {
 57         m_idSkip        = MSR_REGISTER(TEXT(&quot;Video Transform Skip frame&quot;));
 58         m_idFrameType   = MSR_REGISTER(TEXT(&quot;Video transform frame type&quot;));
 59         m_idLate        = MSR_REGISTER(TEXT(&quot;Video Transform Lateness&quot;));
 60         m_idTimeTillKey = MSR_REGISTER(TEXT(&quot;Video Transform Estd. time to next key&quot;));
 61         CTransformFilter::RegisterPerfId();
 62     }
 63 #endif
 64 
 65   protected:
 66 
 67     // =========== QUALITY MANAGEMENT IMPLEMENTATION ========================
 68     // Frames are assumed to come in three types:
 69     // Type 1: an AVI key frame or an MPEG I frame.
 70     //        This frame can be decoded with no history.
 71     //        Dropping this frame means that no further frame can be decoded
 72     //        until the next type 1 frame.
 73     //        Type 1 frames are sync points.
 74     // Type 2: an AVI non-key frame or an MPEG P frame.
 75     //        This frame cannot be decoded unless the previous type 1 frame was
 76     //        decoded and all type 2 frames since have been decoded.
 77     //        Dropping this frame means that no further frame can be decoded
 78     //        until the next type 1 frame.
 79     // Type 3: An MPEG B frame.
 80     //        This frame cannot be decoded unless the previous type 1 or 2 frame
 81     //        has been decoded AND the subsequent type 1 or 2 frame has also
 82     //        been decoded.  (This requires decoding the frames out of sequence).
 83     //        Dropping this frame affects no other frames.  This implementation
 84     //        does not allow for these.  All non-sync-point frames are treated
 85     //        as being type 2.
 86     //
 87     // The spacing of frames of type 1 in a file is not guaranteed.  There MUST
 88     // be a type 1 frame at (well, near) the start of the file in order to start
 89     // decoding at all.  After that there could be one every half second or so,
 90     // there could be one at the start of each scene (aka &quot;cut&quot;, &quot;shot&quot;) or
 91     // there could be no more at all.
 92     // If there is only a single type 1 frame then NO FRAMES CAN BE DROPPED
 93     // without losing all the rest of the movie.  There is no way to tell whether
 94     // this is the case, so we find that we are in the gambling business.
 95     // To try to improve the odds, we record the greatest interval between type 1s
 96     // that we have seen and we bet on things being no worse than this in the
 97     // future.
 98 
 99     // You can tell if it&#39;s a type 1 frame by calling IsSyncPoint().
100     // there is no architected way to test for a type 3, so you should override
101     // the quality management here if you have B-frames.
102 
103     int m_nKeyFramePeriod; // the largest observed interval between type 1 frames
104                            // 1 means every frame is type 1, 2 means every other.
105 
106     int m_nFramesSinceKeyFrame; // Used to count frames since the last type 1.
107                                 // becomes the new m_nKeyFramePeriod if greater.
108 
109     BOOL m_bSkipping;           // we are skipping to the next type 1 frame
110 
111 #ifdef PERF
112     int m_idFrameType;          // MSR id Frame type.  1=Key, 2=&quot;non-key&quot;
113     int m_idSkip;               // MSR id skipping
114     int m_idLate;               // MSR id lateness
115     int m_idTimeTillKey;        // MSR id for guessed time till next key frame.
116 #endif
117 
118     virtual HRESULT StartStreaming();
119 
120     HRESULT AbortPlayback(HRESULT hr);  // if something bad happens
121 
122     HRESULT Receive(IMediaSample *pSample);
123 
124     HRESULT AlterQuality(Quality q);
125 
126     BOOL ShouldSkipFrame(IMediaSample * pIn);
127 
128     int m_itrLate;              // lateness from last Quality message
129                                 // (this overflows at 214 secs late).
130     int m_tDecodeStart;         // timeGetTime when decode started.
131     int m_itrAvgDecode;         // Average decode time in reference units.
132 
133     BOOL m_bNoSkip;             // debug - no skipping.
134 
135     // We send an EC_QUALITY_CHANGE notification to the app if we have to degrade.
136     // We send one when we start degrading, not one for every frame, this means
137     // we track whether we&#39;ve sent one yet.
138     BOOL m_bQualityChanged;
139 
140     // When non-zero, don&#39;t pass anything to renderer until next keyframe
141     // If there are few keys, give up and eventually draw something
142     int m_nWaitForKey;
143 };
    </pre>
  </body>
</html>
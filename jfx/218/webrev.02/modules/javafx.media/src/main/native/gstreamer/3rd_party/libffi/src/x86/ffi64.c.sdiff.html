<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi64.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ffi.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="win64.S.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi64.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /* -----------------------------------------------------------------------
<span class="line-modified">  2    ffi64.c - Copyright (c) 2013  The Written Word, Inc.</span>
<span class="line-modified">  3              Copyright (c) 2011  Anthony Green</span>
  4              Copyright (c) 2008, 2010  Red Hat, Inc.
  5              Copyright (c) 2002, 2007  Bo Thorsen &lt;bo@suse.de&gt;
  6 
  7    x86-64 Foreign Function Interface
  8 
  9    Permission is hereby granted, free of charge, to any person obtaining
 10    a copy of this software and associated documentation files (the
 11    ``Software&#39;&#39;), to deal in the Software without restriction, including
 12    without limitation the rights to use, copy, modify, merge, publish,
 13    distribute, sublicense, and/or sell copies of the Software, and to
 14    permit persons to whom the Software is furnished to do so, subject to
 15    the following conditions:
 16 
 17    The above copyright notice and this permission notice shall be included
 18    in all copies or substantial portions of the Software.
 19 
 20    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 21    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 22    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 23    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 24    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 25    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 26    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 27    DEALINGS IN THE SOFTWARE.
 28    ----------------------------------------------------------------------- */
 29 
 30 #include &lt;ffi.h&gt;
 31 #include &lt;ffi_common.h&gt;
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;stdarg.h&gt;


 35 
 36 #ifdef __x86_64__
 37 
 38 #define MAX_GPR_REGS 6
 39 #define MAX_SSE_REGS 8
 40 
 41 #if defined(__INTEL_COMPILER)
 42 #include &quot;xmmintrin.h&quot;
 43 #define UINT128 __m128
 44 #else
 45 #if defined(__SUNPRO_C)
 46 #include &lt;sunmedia_types.h&gt;
 47 #define UINT128 __m128i
 48 #else
 49 #define UINT128 __int128_t
 50 #endif
 51 #endif
 52 
 53 union big_int_union
 54 {
 55   UINT32 i32;
 56   UINT64 i64;
 57   UINT128 i128;
 58 };
 59 
 60 struct register_args
 61 {
 62   /* Registers for argument passing.  */
 63   UINT64 gpr[MAX_GPR_REGS];
 64   union big_int_union sse[MAX_SSE_REGS];


 65 };
 66 
 67 extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
<span class="line-modified"> 68                  void *raddr, void (*fnaddr)(void), unsigned ssecount);</span>
 69 
 70 /* All reference to register classes here is identical to the code in
 71    gcc/config/i386/i386.c. Do *not* change one without the other.  */
 72 
 73 /* Register class used for passing given 64bit part of the argument.
 74    These represent classes as documented by the PS ABI, with the
 75    exception of SSESF, SSEDF classes, that are basically SSE class,
 76    just gcc will use SF or DFmode move instead of DImode to avoid
 77    reformatting penalties.
 78 
 79    Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
 80    whenever possible (upper half does contain padding).  */
 81 enum x86_64_reg_class
 82   {
 83     X86_64_NO_CLASS,
 84     X86_64_INTEGER_CLASS,
 85     X86_64_INTEGERSI_CLASS,
 86     X86_64_SSE_CLASS,
 87     X86_64_SSESF_CLASS,
 88     X86_64_SSEDF_CLASS,
</pre>
<hr />
<pre>
150    should be passed in memory, 0 is returned. As a special case for zero
151    sized containers, classes[0] will be NO_CLASS and 1 is returned.
152 
153    See the x86-64 PS ABI for details.
154 */
155 static size_t
156 classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
157            size_t byte_offset)
158 {
159   switch (type-&gt;type)
160     {
161     case FFI_TYPE_UINT8:
162     case FFI_TYPE_SINT8:
163     case FFI_TYPE_UINT16:
164     case FFI_TYPE_SINT16:
165     case FFI_TYPE_UINT32:
166     case FFI_TYPE_SINT32:
167     case FFI_TYPE_UINT64:
168     case FFI_TYPE_SINT64:
169     case FFI_TYPE_POINTER:

170       {
171     size_t size = byte_offset + type-&gt;size;
172 
173     if (size &lt;= 4)
174       {
175         classes[0] = X86_64_INTEGERSI_CLASS;
176         return 1;
177       }
178     else if (size &lt;= 8)
179       {
180         classes[0] = X86_64_INTEGER_CLASS;
181         return 1;
182       }
183     else if (size &lt;= 12)
184       {
185         classes[0] = X86_64_INTEGER_CLASS;
186         classes[1] = X86_64_INTEGERSI_CLASS;
187         return 2;
188       }
189     else if (size &lt;= 16)
190       {
<span class="line-modified">191         classes[0] = classes[1] = X86_64_INTEGERSI_CLASS;</span>
192         return 2;
193       }
194     else
195       FFI_ASSERT (0);
196       }
197     case FFI_TYPE_FLOAT:
198       if (!(byte_offset % 8))
199     classes[0] = X86_64_SSESF_CLASS;
200       else
201     classes[0] = X86_64_SSE_CLASS;
202       return 1;
203     case FFI_TYPE_DOUBLE:
204       classes[0] = X86_64_SSEDF_CLASS;
205       return 1;
206 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
207     case FFI_TYPE_LONGDOUBLE:
208       classes[0] = X86_64_X87_CLASS;
209       classes[1] = X86_64_X87UP_CLASS;
210       return 2;
211 #endif
212     case FFI_TYPE_STRUCT:
213       {
214     const size_t UNITS_PER_WORD = 8;
215     size_t words = (type-&gt;size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
216     ffi_type **ptr;
<span class="line-modified">217     int i;</span>
218     enum x86_64_reg_class subclasses[MAX_CLASSES];
219 
220     /* If the struct is larger than 32 bytes, pass it on the stack.  */
221     if (type-&gt;size &gt; 32)
222       return 0;
223 
224     for (i = 0; i &lt; words; i++)
225       classes[i] = X86_64_NO_CLASS;
226 
227     /* Zero sized arrays or structures are NO_CLASS.  We return 0 to
228        signalize memory class, so handle it as special case.  */
229     if (!words)
230       {

231         classes[0] = X86_64_NO_CLASS;
232         return 1;
233       }
234 
235     /* Merge the fields of structure.  */
236     for (ptr = type-&gt;elements; *ptr != NULL; ptr++)
237       {
238         size_t num;
239 
<span class="line-modified">240         byte_offset = ALIGN (byte_offset, (*ptr)-&gt;alignment);</span>
241 
242         num = classify_argument (*ptr, subclasses, byte_offset % 8);
243         if (num == 0)
244           return 0;
245         for (i = 0; i &lt; num; i++)
246           {
247         size_t pos = byte_offset / 8;
248         classes[i + pos] =
249           merge_classes (subclasses[i], classes[i + pos]);
250           }
251 
252         byte_offset += (*ptr)-&gt;size;
253       }
254 
255     if (words &gt; 2)
256       {
257         /* When size &gt; 16 bytes, if the first one isn&#39;t
258            X86_64_SSE_CLASS or any other ones aren&#39;t
259            X86_64_SSEUP_CLASS, everything should be passed in
260            memory.  */
261         if (classes[0] != X86_64_SSE_CLASS)
262           return 0;
263 
264         for (i = 1; i &lt; words; i++)
265           if (classes[i] != X86_64_SSEUP_CLASS)
266         return 0;
267       }
268 
269     /* Final merger cleanup.  */
270     for (i = 0; i &lt; words; i++)
271       {
272         /* If one class is MEMORY, everything should be passed in
273            memory.  */
274         if (classes[i] == X86_64_MEMORY_CLASS)
275           return 0;
276 
277         /* The X86_64_SSEUP_CLASS should be always preceded by
278            X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */
<span class="line-modified">279         if (classes[i] == X86_64_SSEUP_CLASS</span>
280         &amp;&amp; classes[i - 1] != X86_64_SSE_CLASS
281         &amp;&amp; classes[i - 1] != X86_64_SSEUP_CLASS)
282           {
283         /* The first one should never be X86_64_SSEUP_CLASS.  */
284         FFI_ASSERT (i != 0);
285         classes[i] = X86_64_SSE_CLASS;
286           }
287 
288         /*  If X86_64_X87UP_CLASS isn&#39;t preceded by X86_64_X87_CLASS,
289         everything should be passed in memory.  */
<span class="line-modified">290         if (classes[i] == X86_64_X87UP_CLASS</span>
291         &amp;&amp; (classes[i - 1] != X86_64_X87_CLASS))
292           {
293         /* The first one should never be X86_64_X87UP_CLASS.  */
294         FFI_ASSERT (i != 0);
295         return 0;
296           }
297       }
298     return words;
299       }
<span class="line-modified">300 </span>
<span class="line-modified">301     default:</span>
<span class="line-modified">302       FFI_ASSERT(0);</span>



















303     }
<span class="line-modified">304   return 0; /* Never reached.  */</span>












305 }
306 
307 /* Examine the argument and return set number of register required in each
308    class.  Return zero iff parameter should be passed in memory, otherwise
309    the number of registers.  */
310 
311 static size_t
312 examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
313           _Bool in_return, int *pngpr, int *pnsse)
314 {
315   size_t n;
<span class="line-modified">316   int i, ngpr, nsse;</span>

317 
318   n = classify_argument (type, classes, 0);
319   if (n == 0)
320     return 0;
321 
322   ngpr = nsse = 0;
323   for (i = 0; i &lt; n; ++i)
324     switch (classes[i])
325       {
326       case X86_64_INTEGER_CLASS:
327       case X86_64_INTEGERSI_CLASS:
328     ngpr++;
329     break;
330       case X86_64_SSE_CLASS:
331       case X86_64_SSESF_CLASS:
332       case X86_64_SSEDF_CLASS:
333     nsse++;
334     break;
335       case X86_64_NO_CLASS:
336       case X86_64_SSEUP_CLASS:
337     break;
338       case X86_64_X87_CLASS:
339       case X86_64_X87UP_CLASS:
340       case X86_64_COMPLEX_X87_CLASS:
341     return in_return != 0;
342       default:
343     abort ();
344       }
345 
346   *pngpr = ngpr;
347   *pnsse = nsse;
348 
349   return n;
350 }
351 
352 /* Perform machine dependent cif processing.  */
353 
<span class="line-modified">354 ffi_status</span>





355 ffi_prep_cif_machdep (ffi_cif *cif)
356 {
<span class="line-modified">357   int gprcount, ssecount, i, avn, ngpr, nsse, flags;</span>

358   enum x86_64_reg_class classes[MAX_CLASSES];
<span class="line-modified">359   size_t bytes, n;</span>








360 
361   gprcount = ssecount = 0;
362 
<span class="line-modified">363   flags = cif-&gt;rtype-&gt;type;</span>
<span class="line-modified">364   if (flags != FFI_TYPE_VOID)</span>

365     {









































366       n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);
367       if (n == 0)
368     {
369       /* The return value is passed in memory.  A pointer to that
370          memory is the first argument.  Allocate a register for it.  */
371       gprcount++;
372       /* We don&#39;t have to do anything in asm for the return.  */
<span class="line-modified">373       flags = FFI_TYPE_VOID;</span>
374     }
<span class="line-modified">375       else if (flags == FFI_TYPE_STRUCT)</span>
376     {
<span class="line-removed">377       /* Mark which registers the result appears in.  */</span>
378       _Bool sse0 = SSE_CLASS_P (classes[0]);







379       _Bool sse1 = n == 2 &amp;&amp; SSE_CLASS_P (classes[1]);
<span class="line-modified">380       if (sse0 &amp;&amp; !sse1)</span>
<span class="line-modified">381         flags |= 1 &lt;&lt; 8;</span>
<span class="line-modified">382       else if (!sse0 &amp;&amp; sse1)</span>
<span class="line-modified">383         flags |= 1 &lt;&lt; 9;</span>
<span class="line-modified">384       else if (sse0 &amp;&amp; sse1)</span>
<span class="line-modified">385         flags |= 1 &lt;&lt; 10;</span>
<span class="line-modified">386       /* Mark the true size of the structure.  */</span>
<span class="line-modified">387       flags |= cif-&gt;rtype-&gt;size &lt;&lt; 12;</span>

388     }
389     }

































390 
391   /* Go over all arguments and determine the way they should be passed.
392      If it&#39;s in a register and there is space for it, let that be so. If
393      not, add it&#39;s size to the stack byte count.  */
394   for (bytes = 0, i = 0, avn = cif-&gt;nargs; i &lt; avn; i++)
395     {
396       if (examine_argument (cif-&gt;arg_types[i], classes, 0, &amp;ngpr, &amp;nsse) == 0
397       || gprcount + ngpr &gt; MAX_GPR_REGS
398       || ssecount + nsse &gt; MAX_SSE_REGS)
399     {
400       long align = cif-&gt;arg_types[i]-&gt;alignment;
401 
402       if (align &lt; 8)
403         align = 8;
404 
<span class="line-modified">405       bytes = ALIGN (bytes, align);</span>
406       bytes += cif-&gt;arg_types[i]-&gt;size;
407     }
408       else
409     {
410       gprcount += ngpr;
411       ssecount += nsse;
412     }
413     }
414   if (ssecount)
<span class="line-modified">415     flags |= 1 &lt;&lt; 11;</span>

416   cif-&gt;flags = flags;
<span class="line-modified">417   cif-&gt;bytes = (unsigned)ALIGN (bytes, 8);</span>
418 
419   return FFI_OK;
420 }
421 
<span class="line-modified">422 void</span>
<span class="line-modified">423 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>

424 {
425   enum x86_64_reg_class classes[MAX_CLASSES];
426   char *stack, *argp;
427   ffi_type **arg_types;
<span class="line-modified">428   int gprcount, ssecount, ngpr, nsse, i, avn;</span>
<span class="line-removed">429   _Bool ret_in_memory;</span>
430   struct register_args *reg_args;
431 
432   /* Can&#39;t call 32-bit mode from 64-bit mode.  */
433   FFI_ASSERT (cif-&gt;abi == FFI_UNIX64);
434 
435   /* If the return value is a struct and we don&#39;t have a return value
<span class="line-modified">436      address then we need to make one.  Note the setting of flags to</span>
<span class="line-modified">437      VOID above in ffi_prep_cif_machdep.  */</span>
<span class="line-modified">438   ret_in_memory = (cif-&gt;rtype-&gt;type == FFI_TYPE_STRUCT</span>
<span class="line-modified">439            &amp;&amp; (cif-&gt;flags &amp; 0xff) == FFI_TYPE_VOID);</span>
<span class="line-modified">440   if (rvalue == NULL &amp;&amp; ret_in_memory)</span>
441     rvalue = alloca (cif-&gt;rtype-&gt;size);



442 
443   /* Allocate the space for the arguments, plus 4 words of temp space.  */
444   stack = alloca (sizeof (struct register_args) + cif-&gt;bytes + 4*8);
445   reg_args = (struct register_args *) stack;
446   argp = stack + sizeof (struct register_args);
447 


448   gprcount = ssecount = 0;
449 
450   /* If the return value is passed in memory, add the pointer as the
451      first integer argument.  */
<span class="line-modified">452   if (ret_in_memory)</span>
453     reg_args-&gt;gpr[gprcount++] = (unsigned long) rvalue;
454 
455   avn = cif-&gt;nargs;
456   arg_types = cif-&gt;arg_types;
457 
458   for (i = 0; i &lt; avn; ++i)
459     {
460       size_t n, size = arg_types[i]-&gt;size;
461 
462       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
463       if (n == 0
464       || gprcount + ngpr &gt; MAX_GPR_REGS
465       || ssecount + nsse &gt; MAX_SSE_REGS)
466     {
467       long align = arg_types[i]-&gt;alignment;
468 
469       /* Stack arguments are *always* at least 8 byte aligned.  */
470       if (align &lt; 8)
471         align = 8;
472 
473       /* Pass this argument in memory.  */
<span class="line-modified">474       argp = (void *) ALIGN (argp, align);</span>
475       memcpy (argp, avalue[i], size);
476       argp += size;
477     }
478       else
479     {
480       /* The argument is passed entirely in registers.  */
481       char *a = (char *) avalue[i];
<span class="line-modified">482       int j;</span>
483 
484       for (j = 0; j &lt; n; j++, a += 8, size -= 8)
485         {
486           switch (classes[j])
487         {



488         case X86_64_INTEGER_CLASS:
489         case X86_64_INTEGERSI_CLASS:
490           /* Sign-extend integer arguments passed in general
491              purpose registers, to cope with the fact that
492              LLVM incorrectly assumes that this will be done
493              (the x86-64 PS ABI does not specify this). */
494           switch (arg_types[i]-&gt;type)
495             {
496             case FFI_TYPE_SINT8:
<span class="line-modified">497               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT8 *) a);</span>
498               break;
499             case FFI_TYPE_SINT16:
<span class="line-modified">500               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT16 *) a);</span>
501               break;
502             case FFI_TYPE_SINT32:
<span class="line-modified">503               *(SINT64 *)&amp;reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT32 *) a);</span>
504               break;
505             default:
506               reg_args-&gt;gpr[gprcount] = 0;
<span class="line-modified">507               memcpy (&amp;reg_args-&gt;gpr[gprcount], a, size &lt; 8 ? size : 8);</span>
508             }
509           gprcount++;
510           break;
511         case X86_64_SSE_CLASS:
512         case X86_64_SSEDF_CLASS:
<span class="line-modified">513           reg_args-&gt;sse[ssecount++].i64 = *(UINT64 *) a;</span>
514           break;
515         case X86_64_SSESF_CLASS:
<span class="line-modified">516           reg_args-&gt;sse[ssecount++].i32 = *(UINT32 *) a;</span>
517           break;
518         default:
519           abort();
520         }
521         }
522     }
523     }

524 
525   ffi_call_unix64 (stack, cif-&gt;bytes + sizeof (struct register_args),
<span class="line-modified">526            cif-&gt;flags, rvalue, fn, ssecount);</span>
527 }
528 




529 
<span class="line-modified">530 extern void ffi_closure_unix64(void);</span>












































531 
532 ffi_status
533 ffi_prep_closure_loc (ffi_closure* closure,
534               ffi_cif* cif,
535               void (*fun)(ffi_cif*, void*, void**, void*),
536               void *user_data,
537               void *codeloc)
538 {
<span class="line-modified">539   volatile unsigned short *tramp;</span>









540 
<span class="line-modified">541   /* Sanity check on the cif ABI.  */</span>
<span class="line-modified">542   {</span>
<span class="line-modified">543     int abi = cif-&gt;abi;</span>
<span class="line-modified">544     if (UNLIKELY (! (abi &gt; FFI_FIRST_ABI &amp;&amp; abi &lt; FFI_LAST_ABI)))</span>

545       return FFI_BAD_ABI;
<span class="line-removed">546   }</span>
<span class="line-removed">547 </span>
<span class="line-removed">548   tramp = (volatile unsigned short *) &amp;closure-&gt;tramp[0];</span>
<span class="line-removed">549 </span>
<span class="line-removed">550   tramp[0] = 0xbb49;        /* mov &lt;code&gt;, %r11 */</span>
<span class="line-removed">551   *((unsigned long long * volatile) &amp;tramp[1])</span>
<span class="line-removed">552     = (unsigned long) ffi_closure_unix64;</span>
<span class="line-removed">553   tramp[5] = 0xba49;        /* mov &lt;data&gt;, %r10 */</span>
<span class="line-removed">554   *((unsigned long long * volatile) &amp;tramp[6])</span>
<span class="line-removed">555     = (unsigned long) codeloc;</span>
556 
<span class="line-modified">557   /* Set the carry bit iff the function uses any sse registers.</span>
<span class="line-modified">558      This is clc or stc, together with the first byte of the jmp.  */</span>
<span class="line-modified">559   tramp[10] = cif-&gt;flags &amp; (1 &lt;&lt; 11) ? 0x49f9 : 0x49f8;</span>

560 
<span class="line-modified">561   tramp[11] = 0xe3ff;           /* jmp *%r11    */</span>

562 
563   closure-&gt;cif = cif;
564   closure-&gt;fun = fun;
565   closure-&gt;user_data = user_data;
566 
567   return FFI_OK;
568 }
569 
<span class="line-modified">570 int</span>
<span class="line-modified">571 ffi_closure_unix64_inner(ffi_closure *closure, void *rvalue,</span>
<span class="line-modified">572              struct register_args *reg_args, char *argp)</span>




573 {
<span class="line-removed">574   ffi_cif *cif;</span>
575   void **avalue;
576   ffi_type **arg_types;
577   long i, avn;
578   int gprcount, ssecount, ngpr, nsse;
<span class="line-modified">579   int ret;</span>
580 
<span class="line-modified">581   cif = closure-&gt;cif;</span>
<span class="line-modified">582   avalue = alloca(cif-&gt;nargs * sizeof(void *));</span>

583   gprcount = ssecount = 0;
584 
<span class="line-modified">585   ret = cif-&gt;rtype-&gt;type;</span>
<span class="line-removed">586   if (ret != FFI_TYPE_VOID)</span>
<span class="line-removed">587     {</span>
<span class="line-removed">588       enum x86_64_reg_class classes[MAX_CLASSES];</span>
<span class="line-removed">589       size_t n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);</span>
<span class="line-removed">590       if (n == 0)</span>
591     {
<span class="line-modified">592       /* The return value goes in memory.  Arrange for the closure</span>
<span class="line-modified">593          return value to go directly back to the original caller.  */</span>
<span class="line-modified">594       rvalue = (void *) (unsigned long) reg_args-&gt;gpr[gprcount++];</span>
<span class="line-modified">595       /* We don&#39;t have to do anything in asm for the return.  */</span>
<span class="line-modified">596       ret = FFI_TYPE_VOID;</span>
<span class="line-modified">597     }</span>
<span class="line-removed">598       else if (ret == FFI_TYPE_STRUCT &amp;&amp; n == 2)</span>
<span class="line-removed">599     {</span>
<span class="line-removed">600       /* Mark which register the second word of the structure goes in.  */</span>
<span class="line-removed">601       _Bool sse0 = SSE_CLASS_P (classes[0]);</span>
<span class="line-removed">602       _Bool sse1 = SSE_CLASS_P (classes[1]);</span>
<span class="line-removed">603       if (!sse0 &amp;&amp; sse1)</span>
<span class="line-removed">604         ret |= 1 &lt;&lt; 8;</span>
<span class="line-removed">605       else if (sse0 &amp;&amp; !sse1)</span>
<span class="line-removed">606         ret |= 1 &lt;&lt; 9;</span>
<span class="line-removed">607     }</span>
608     }
609 
<span class="line-removed">610   avn = cif-&gt;nargs;</span>
611   arg_types = cif-&gt;arg_types;
<span class="line-removed">612 </span>
613   for (i = 0; i &lt; avn; ++i)
614     {
615       enum x86_64_reg_class classes[MAX_CLASSES];
616       size_t n;
617 
618       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
619       if (n == 0
620       || gprcount + ngpr &gt; MAX_GPR_REGS
621       || ssecount + nsse &gt; MAX_SSE_REGS)
622     {
623       long align = arg_types[i]-&gt;alignment;
624 
625       /* Stack arguments are *always* at least 8 byte aligned.  */
626       if (align &lt; 8)
627         align = 8;
628 
629       /* Pass this argument in memory.  */
<span class="line-modified">630       argp = (void *) ALIGN (argp, align);</span>
631       avalue[i] = argp;
632       argp += arg_types[i]-&gt;size;
633     }
634       /* If the argument is in a single register, or two consecutive
635      integer registers, then we can use that address directly.  */
636       else if (n == 1
637            || (n == 2 &amp;&amp; !(SSE_CLASS_P (classes[0])
638                    || SSE_CLASS_P (classes[1]))))
639     {
640       /* The argument is in a single register.  */
641       if (SSE_CLASS_P (classes[0]))
642         {
643           avalue[i] = &amp;reg_args-&gt;sse[ssecount];
644           ssecount += n;
645         }
646       else
647         {
648           avalue[i] = &amp;reg_args-&gt;gpr[gprcount];
649           gprcount += n;
650         }
651     }
652       /* Otherwise, allocate space to make them consecutive.  */
653       else
654     {
655       char *a = alloca (16);
<span class="line-modified">656       int j;</span>
657 
658       avalue[i] = a;
659       for (j = 0; j &lt; n; j++, a += 8)
660         {
661           if (SSE_CLASS_P (classes[j]))
662         memcpy (a, &amp;reg_args-&gt;sse[ssecount++], 8);
663           else
664         memcpy (a, &amp;reg_args-&gt;gpr[gprcount++], 8);
665         }
666     }
667     }
668 
669   /* Invoke the closure.  */
<span class="line-modified">670   closure-&gt;fun (cif, rvalue, avalue, closure-&gt;user_data);</span>
671 
672   /* Tell assembly how to perform return type promotions.  */
<span class="line-modified">673   return ret;</span>





























674 }
675 
676 #endif /* __x86_64__ */
</pre>
</td>
<td>
<hr />
<pre>
  1 /* -----------------------------------------------------------------------
<span class="line-modified">  2    ffi64.c - Copyright (c) 2011, 2018  Anthony Green</span>
<span class="line-modified">  3              Copyright (c) 2013  The Written Word, Inc.</span>
  4              Copyright (c) 2008, 2010  Red Hat, Inc.
  5              Copyright (c) 2002, 2007  Bo Thorsen &lt;bo@suse.de&gt;
  6 
  7    x86-64 Foreign Function Interface
  8 
  9    Permission is hereby granted, free of charge, to any person obtaining
 10    a copy of this software and associated documentation files (the
 11    ``Software&#39;&#39;), to deal in the Software without restriction, including
 12    without limitation the rights to use, copy, modify, merge, publish,
 13    distribute, sublicense, and/or sell copies of the Software, and to
 14    permit persons to whom the Software is furnished to do so, subject to
 15    the following conditions:
 16 
 17    The above copyright notice and this permission notice shall be included
 18    in all copies or substantial portions of the Software.
 19 
 20    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 21    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 22    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 23    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 24    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 25    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 26    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 27    DEALINGS IN THE SOFTWARE.
 28    ----------------------------------------------------------------------- */
 29 
 30 #include &lt;ffi.h&gt;
 31 #include &lt;ffi_common.h&gt;
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;stdarg.h&gt;
<span class="line-added"> 35 #include &lt;stdint.h&gt;</span>
<span class="line-added"> 36 #include &quot;internal64.h&quot;</span>
 37 
 38 #ifdef __x86_64__
 39 
 40 #define MAX_GPR_REGS 6
 41 #define MAX_SSE_REGS 8
 42 
 43 #if defined(__INTEL_COMPILER)
 44 #include &quot;xmmintrin.h&quot;
 45 #define UINT128 __m128
 46 #else
 47 #if defined(__SUNPRO_C)
 48 #include &lt;sunmedia_types.h&gt;
 49 #define UINT128 __m128i
 50 #else
 51 #define UINT128 __int128_t
 52 #endif
 53 #endif
 54 
 55 union big_int_union
 56 {
 57   UINT32 i32;
 58   UINT64 i64;
 59   UINT128 i128;
 60 };
 61 
 62 struct register_args
 63 {
 64   /* Registers for argument passing.  */
 65   UINT64 gpr[MAX_GPR_REGS];
 66   union big_int_union sse[MAX_SSE_REGS];
<span class="line-added"> 67   UINT64 rax;   /* ssecount */</span>
<span class="line-added"> 68   UINT64 r10;   /* static chain */</span>
 69 };
 70 
 71 extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,
<span class="line-modified"> 72                  void *raddr, void (*fnaddr)(void)) FFI_HIDDEN;</span>
 73 
 74 /* All reference to register classes here is identical to the code in
 75    gcc/config/i386/i386.c. Do *not* change one without the other.  */
 76 
 77 /* Register class used for passing given 64bit part of the argument.
 78    These represent classes as documented by the PS ABI, with the
 79    exception of SSESF, SSEDF classes, that are basically SSE class,
 80    just gcc will use SF or DFmode move instead of DImode to avoid
 81    reformatting penalties.
 82 
 83    Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves
 84    whenever possible (upper half does contain padding).  */
 85 enum x86_64_reg_class
 86   {
 87     X86_64_NO_CLASS,
 88     X86_64_INTEGER_CLASS,
 89     X86_64_INTEGERSI_CLASS,
 90     X86_64_SSE_CLASS,
 91     X86_64_SSESF_CLASS,
 92     X86_64_SSEDF_CLASS,
</pre>
<hr />
<pre>
154    should be passed in memory, 0 is returned. As a special case for zero
155    sized containers, classes[0] will be NO_CLASS and 1 is returned.
156 
157    See the x86-64 PS ABI for details.
158 */
159 static size_t
160 classify_argument (ffi_type *type, enum x86_64_reg_class classes[],
161            size_t byte_offset)
162 {
163   switch (type-&gt;type)
164     {
165     case FFI_TYPE_UINT8:
166     case FFI_TYPE_SINT8:
167     case FFI_TYPE_UINT16:
168     case FFI_TYPE_SINT16:
169     case FFI_TYPE_UINT32:
170     case FFI_TYPE_SINT32:
171     case FFI_TYPE_UINT64:
172     case FFI_TYPE_SINT64:
173     case FFI_TYPE_POINTER:
<span class="line-added">174     do_integer:</span>
175       {
176     size_t size = byte_offset + type-&gt;size;
177 
178     if (size &lt;= 4)
179       {
180         classes[0] = X86_64_INTEGERSI_CLASS;
181         return 1;
182       }
183     else if (size &lt;= 8)
184       {
185         classes[0] = X86_64_INTEGER_CLASS;
186         return 1;
187       }
188     else if (size &lt;= 12)
189       {
190         classes[0] = X86_64_INTEGER_CLASS;
191         classes[1] = X86_64_INTEGERSI_CLASS;
192         return 2;
193       }
194     else if (size &lt;= 16)
195       {
<span class="line-modified">196         classes[0] = classes[1] = X86_64_INTEGER_CLASS;</span>
197         return 2;
198       }
199     else
200       FFI_ASSERT (0);
201       }
202     case FFI_TYPE_FLOAT:
203       if (!(byte_offset % 8))
204     classes[0] = X86_64_SSESF_CLASS;
205       else
206     classes[0] = X86_64_SSE_CLASS;
207       return 1;
208     case FFI_TYPE_DOUBLE:
209       classes[0] = X86_64_SSEDF_CLASS;
210       return 1;
211 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
212     case FFI_TYPE_LONGDOUBLE:
213       classes[0] = X86_64_X87_CLASS;
214       classes[1] = X86_64_X87UP_CLASS;
215       return 2;
216 #endif
217     case FFI_TYPE_STRUCT:
218       {
219     const size_t UNITS_PER_WORD = 8;
220     size_t words = (type-&gt;size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;
221     ffi_type **ptr;
<span class="line-modified">222     unsigned int i;</span>
223     enum x86_64_reg_class subclasses[MAX_CLASSES];
224 
225     /* If the struct is larger than 32 bytes, pass it on the stack.  */
226     if (type-&gt;size &gt; 32)
227       return 0;
228 
229     for (i = 0; i &lt; words; i++)
230       classes[i] = X86_64_NO_CLASS;
231 
232     /* Zero sized arrays or structures are NO_CLASS.  We return 0 to
233        signalize memory class, so handle it as special case.  */
234     if (!words)
235       {
<span class="line-added">236     case FFI_TYPE_VOID:</span>
237         classes[0] = X86_64_NO_CLASS;
238         return 1;
239       }
240 
241     /* Merge the fields of structure.  */
242     for (ptr = type-&gt;elements; *ptr != NULL; ptr++)
243       {
244         size_t num;
245 
<span class="line-modified">246         byte_offset = FFI_ALIGN (byte_offset, (*ptr)-&gt;alignment);</span>
247 
248         num = classify_argument (*ptr, subclasses, byte_offset % 8);
249         if (num == 0)
250           return 0;
251         for (i = 0; i &lt; num; i++)
252           {
253         size_t pos = byte_offset / 8;
254         classes[i + pos] =
255           merge_classes (subclasses[i], classes[i + pos]);
256           }
257 
258         byte_offset += (*ptr)-&gt;size;
259       }
260 
261     if (words &gt; 2)
262       {
263         /* When size &gt; 16 bytes, if the first one isn&#39;t
264            X86_64_SSE_CLASS or any other ones aren&#39;t
265            X86_64_SSEUP_CLASS, everything should be passed in
266            memory.  */
267         if (classes[0] != X86_64_SSE_CLASS)
268           return 0;
269 
270         for (i = 1; i &lt; words; i++)
271           if (classes[i] != X86_64_SSEUP_CLASS)
272         return 0;
273       }
274 
275     /* Final merger cleanup.  */
276     for (i = 0; i &lt; words; i++)
277       {
278         /* If one class is MEMORY, everything should be passed in
279            memory.  */
280         if (classes[i] == X86_64_MEMORY_CLASS)
281           return 0;
282 
283         /* The X86_64_SSEUP_CLASS should be always preceded by
284            X86_64_SSE_CLASS or X86_64_SSEUP_CLASS.  */
<span class="line-modified">285         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_SSEUP_CLASS</span>
286         &amp;&amp; classes[i - 1] != X86_64_SSE_CLASS
287         &amp;&amp; classes[i - 1] != X86_64_SSEUP_CLASS)
288           {
289         /* The first one should never be X86_64_SSEUP_CLASS.  */
290         FFI_ASSERT (i != 0);
291         classes[i] = X86_64_SSE_CLASS;
292           }
293 
294         /*  If X86_64_X87UP_CLASS isn&#39;t preceded by X86_64_X87_CLASS,
295         everything should be passed in memory.  */
<span class="line-modified">296         if (i &gt; 1 &amp;&amp; classes[i] == X86_64_X87UP_CLASS</span>
297         &amp;&amp; (classes[i - 1] != X86_64_X87_CLASS))
298           {
299         /* The first one should never be X86_64_X87UP_CLASS.  */
300         FFI_ASSERT (i != 0);
301         return 0;
302           }
303       }
304     return words;
305       }
<span class="line-modified">306     case FFI_TYPE_COMPLEX:</span>
<span class="line-modified">307       {</span>
<span class="line-modified">308     ffi_type *inner = type-&gt;elements[0];</span>
<span class="line-added">309     switch (inner-&gt;type)</span>
<span class="line-added">310       {</span>
<span class="line-added">311       case FFI_TYPE_INT:</span>
<span class="line-added">312       case FFI_TYPE_UINT8:</span>
<span class="line-added">313       case FFI_TYPE_SINT8:</span>
<span class="line-added">314       case FFI_TYPE_UINT16:</span>
<span class="line-added">315       case FFI_TYPE_SINT16:</span>
<span class="line-added">316       case FFI_TYPE_UINT32:</span>
<span class="line-added">317       case FFI_TYPE_SINT32:</span>
<span class="line-added">318       case FFI_TYPE_UINT64:</span>
<span class="line-added">319       case FFI_TYPE_SINT64:</span>
<span class="line-added">320         goto do_integer;</span>
<span class="line-added">321 </span>
<span class="line-added">322       case FFI_TYPE_FLOAT:</span>
<span class="line-added">323         classes[0] = X86_64_SSE_CLASS;</span>
<span class="line-added">324         if (byte_offset % 8)</span>
<span class="line-added">325           {</span>
<span class="line-added">326         classes[1] = X86_64_SSESF_CLASS;</span>
<span class="line-added">327         return 2;</span>
328     }
<span class="line-modified">329         return 1;</span>
<span class="line-added">330       case FFI_TYPE_DOUBLE:</span>
<span class="line-added">331         classes[0] = classes[1] = X86_64_SSEDF_CLASS;</span>
<span class="line-added">332         return 2;</span>
<span class="line-added">333 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">334       case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">335         classes[0] = X86_64_COMPLEX_X87_CLASS;</span>
<span class="line-added">336         return 1;</span>
<span class="line-added">337 #endif</span>
<span class="line-added">338 }</span>
<span class="line-added">339       }</span>
<span class="line-added">340     }</span>
<span class="line-added">341   abort();</span>
342 }
343 
344 /* Examine the argument and return set number of register required in each
345    class.  Return zero iff parameter should be passed in memory, otherwise
346    the number of registers.  */
347 
348 static size_t
349 examine_argument (ffi_type *type, enum x86_64_reg_class classes[MAX_CLASSES],
350           _Bool in_return, int *pngpr, int *pnsse)
351 {
352   size_t n;
<span class="line-modified">353   unsigned int i;</span>
<span class="line-added">354   int ngpr, nsse;</span>
355 
356   n = classify_argument (type, classes, 0);
357   if (n == 0)
358     return 0;
359 
360   ngpr = nsse = 0;
361   for (i = 0; i &lt; n; ++i)
362     switch (classes[i])
363       {
364       case X86_64_INTEGER_CLASS:
365       case X86_64_INTEGERSI_CLASS:
366     ngpr++;
367     break;
368       case X86_64_SSE_CLASS:
369       case X86_64_SSESF_CLASS:
370       case X86_64_SSEDF_CLASS:
371     nsse++;
372     break;
373       case X86_64_NO_CLASS:
374       case X86_64_SSEUP_CLASS:
375     break;
376       case X86_64_X87_CLASS:
377       case X86_64_X87UP_CLASS:
378       case X86_64_COMPLEX_X87_CLASS:
379     return in_return != 0;
380       default:
381     abort ();
382       }
383 
384   *pngpr = ngpr;
385   *pnsse = nsse;
386 
387   return n;
388 }
389 
390 /* Perform machine dependent cif processing.  */
391 
<span class="line-modified">392 #ifndef __ILP32__</span>
<span class="line-added">393 extern ffi_status</span>
<span class="line-added">394 ffi_prep_cif_machdep_efi64(ffi_cif *cif);</span>
<span class="line-added">395 #endif</span>
<span class="line-added">396 </span>
<span class="line-added">397 ffi_status FFI_HIDDEN</span>
398 ffi_prep_cif_machdep (ffi_cif *cif)
399 {
<span class="line-modified">400   int gprcount, ssecount, i, avn, ngpr, nsse;</span>
<span class="line-added">401   unsigned flags;</span>
402   enum x86_64_reg_class classes[MAX_CLASSES];
<span class="line-modified">403   size_t bytes, n, rtype_size;</span>
<span class="line-added">404   ffi_type *rtype;</span>
<span class="line-added">405 </span>
<span class="line-added">406 #ifndef __ILP32__</span>
<span class="line-added">407   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">408     return ffi_prep_cif_machdep_efi64(cif);</span>
<span class="line-added">409 #endif</span>
<span class="line-added">410   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="line-added">411     return FFI_BAD_ABI;</span>
412 
413   gprcount = ssecount = 0;
414 
<span class="line-modified">415   rtype = cif-&gt;rtype;</span>
<span class="line-modified">416   rtype_size = rtype-&gt;size;</span>
<span class="line-added">417   switch (rtype-&gt;type)</span>
418     {
<span class="line-added">419     case FFI_TYPE_VOID:</span>
<span class="line-added">420       flags = UNIX64_RET_VOID;</span>
<span class="line-added">421       break;</span>
<span class="line-added">422     case FFI_TYPE_UINT8:</span>
<span class="line-added">423       flags = UNIX64_RET_UINT8;</span>
<span class="line-added">424       break;</span>
<span class="line-added">425     case FFI_TYPE_SINT8:</span>
<span class="line-added">426       flags = UNIX64_RET_SINT8;</span>
<span class="line-added">427       break;</span>
<span class="line-added">428     case FFI_TYPE_UINT16:</span>
<span class="line-added">429       flags = UNIX64_RET_UINT16;</span>
<span class="line-added">430       break;</span>
<span class="line-added">431     case FFI_TYPE_SINT16:</span>
<span class="line-added">432       flags = UNIX64_RET_SINT16;</span>
<span class="line-added">433       break;</span>
<span class="line-added">434     case FFI_TYPE_UINT32:</span>
<span class="line-added">435       flags = UNIX64_RET_UINT32;</span>
<span class="line-added">436       break;</span>
<span class="line-added">437     case FFI_TYPE_INT:</span>
<span class="line-added">438     case FFI_TYPE_SINT32:</span>
<span class="line-added">439       flags = UNIX64_RET_SINT32;</span>
<span class="line-added">440       break;</span>
<span class="line-added">441     case FFI_TYPE_UINT64:</span>
<span class="line-added">442     case FFI_TYPE_SINT64:</span>
<span class="line-added">443       flags = UNIX64_RET_INT64;</span>
<span class="line-added">444       break;</span>
<span class="line-added">445     case FFI_TYPE_POINTER:</span>
<span class="line-added">446       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>
<span class="line-added">447       break;</span>
<span class="line-added">448     case FFI_TYPE_FLOAT:</span>
<span class="line-added">449       flags = UNIX64_RET_XMM32;</span>
<span class="line-added">450       break;</span>
<span class="line-added">451     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">452       flags = UNIX64_RET_XMM64;</span>
<span class="line-added">453       break;</span>
<span class="line-added">454 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">455     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">456       flags = UNIX64_RET_X87;</span>
<span class="line-added">457       break;</span>
<span class="line-added">458 #endif</span>
<span class="line-added">459     case FFI_TYPE_STRUCT:</span>
460       n = examine_argument (cif-&gt;rtype, classes, 1, &amp;ngpr, &amp;nsse);
461       if (n == 0)
462     {
463       /* The return value is passed in memory.  A pointer to that
464          memory is the first argument.  Allocate a register for it.  */
465       gprcount++;
466       /* We don&#39;t have to do anything in asm for the return.  */
<span class="line-modified">467       flags = UNIX64_RET_VOID | UNIX64_FLAG_RET_IN_MEM;</span>
468     }
<span class="line-modified">469       else</span>
470     {

471       _Bool sse0 = SSE_CLASS_P (classes[0]);
<span class="line-added">472 </span>
<span class="line-added">473       if (rtype_size == 4 &amp;&amp; sse0)</span>
<span class="line-added">474         flags = UNIX64_RET_XMM32;</span>
<span class="line-added">475       else if (rtype_size == 8)</span>
<span class="line-added">476         flags = sse0 ? UNIX64_RET_XMM64 : UNIX64_RET_INT64;</span>
<span class="line-added">477       else</span>
<span class="line-added">478         {</span>
479       _Bool sse1 = n == 2 &amp;&amp; SSE_CLASS_P (classes[1]);
<span class="line-modified">480           if (sse0 &amp;&amp; sse1)</span>
<span class="line-modified">481         flags = UNIX64_RET_ST_XMM0_XMM1;</span>
<span class="line-modified">482           else if (sse0)</span>
<span class="line-modified">483         flags = UNIX64_RET_ST_XMM0_RAX;</span>
<span class="line-modified">484           else if (sse1)</span>
<span class="line-modified">485         flags = UNIX64_RET_ST_RAX_XMM0;</span>
<span class="line-modified">486           else</span>
<span class="line-modified">487         flags = UNIX64_RET_ST_RAX_RDX;</span>
<span class="line-added">488           flags |= rtype_size &lt;&lt; UNIX64_SIZE_SHIFT;</span>
489     }
490     }
<span class="line-added">491       break;</span>
<span class="line-added">492     case FFI_TYPE_COMPLEX:</span>
<span class="line-added">493       switch (rtype-&gt;elements[0]-&gt;type)</span>
<span class="line-added">494     {</span>
<span class="line-added">495     case FFI_TYPE_UINT8:</span>
<span class="line-added">496     case FFI_TYPE_SINT8:</span>
<span class="line-added">497     case FFI_TYPE_UINT16:</span>
<span class="line-added">498     case FFI_TYPE_SINT16:</span>
<span class="line-added">499     case FFI_TYPE_INT:</span>
<span class="line-added">500     case FFI_TYPE_UINT32:</span>
<span class="line-added">501     case FFI_TYPE_SINT32:</span>
<span class="line-added">502     case FFI_TYPE_UINT64:</span>
<span class="line-added">503     case FFI_TYPE_SINT64:</span>
<span class="line-added">504       flags = UNIX64_RET_ST_RAX_RDX | ((unsigned) rtype_size &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="line-added">505       break;</span>
<span class="line-added">506     case FFI_TYPE_FLOAT:</span>
<span class="line-added">507       flags = UNIX64_RET_XMM64;</span>
<span class="line-added">508       break;</span>
<span class="line-added">509     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">510       flags = UNIX64_RET_ST_XMM0_XMM1 | (16 &lt;&lt; UNIX64_SIZE_SHIFT);</span>
<span class="line-added">511       break;</span>
<span class="line-added">512 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-added">513     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">514       flags = UNIX64_RET_X87_2;</span>
<span class="line-added">515       break;</span>
<span class="line-added">516 #endif</span>
<span class="line-added">517     default:</span>
<span class="line-added">518       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">519     }</span>
<span class="line-added">520       break;</span>
<span class="line-added">521     default:</span>
<span class="line-added">522       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">523     }</span>
524 
525   /* Go over all arguments and determine the way they should be passed.
526      If it&#39;s in a register and there is space for it, let that be so. If
527      not, add it&#39;s size to the stack byte count.  */
528   for (bytes = 0, i = 0, avn = cif-&gt;nargs; i &lt; avn; i++)
529     {
530       if (examine_argument (cif-&gt;arg_types[i], classes, 0, &amp;ngpr, &amp;nsse) == 0
531       || gprcount + ngpr &gt; MAX_GPR_REGS
532       || ssecount + nsse &gt; MAX_SSE_REGS)
533     {
534       long align = cif-&gt;arg_types[i]-&gt;alignment;
535 
536       if (align &lt; 8)
537         align = 8;
538 
<span class="line-modified">539       bytes = FFI_ALIGN (bytes, align);</span>
540       bytes += cif-&gt;arg_types[i]-&gt;size;
541     }
542       else
543     {
544       gprcount += ngpr;
545       ssecount += nsse;
546     }
547     }
548   if (ssecount)
<span class="line-modified">549     flags |= UNIX64_FLAG_XMM_ARGS;</span>
<span class="line-added">550 </span>
551   cif-&gt;flags = flags;
<span class="line-modified">552   cif-&gt;bytes = (unsigned) FFI_ALIGN (bytes, 8);</span>
553 
554   return FFI_OK;
555 }
556 
<span class="line-modified">557 static void</span>
<span class="line-modified">558 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">559           void **avalue, void *closure)</span>
560 {
561   enum x86_64_reg_class classes[MAX_CLASSES];
562   char *stack, *argp;
563   ffi_type **arg_types;
<span class="line-modified">564   int gprcount, ssecount, ngpr, nsse, i, avn, flags;</span>

565   struct register_args *reg_args;
566 
567   /* Can&#39;t call 32-bit mode from 64-bit mode.  */
568   FFI_ASSERT (cif-&gt;abi == FFI_UNIX64);
569 
570   /* If the return value is a struct and we don&#39;t have a return value
<span class="line-modified">571      address then we need to make one.  Otherwise we can ignore it.  */</span>
<span class="line-modified">572   flags = cif-&gt;flags;</span>
<span class="line-modified">573   if (rvalue == NULL)</span>
<span class="line-modified">574     {</span>
<span class="line-modified">575       if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
576     rvalue = alloca (cif-&gt;rtype-&gt;size);
<span class="line-added">577       else</span>
<span class="line-added">578     flags = UNIX64_RET_VOID;</span>
<span class="line-added">579     }</span>
580 
581   /* Allocate the space for the arguments, plus 4 words of temp space.  */
582   stack = alloca (sizeof (struct register_args) + cif-&gt;bytes + 4*8);
583   reg_args = (struct register_args *) stack;
584   argp = stack + sizeof (struct register_args);
585 
<span class="line-added">586   reg_args-&gt;r10 = (uintptr_t) closure;</span>
<span class="line-added">587 </span>
588   gprcount = ssecount = 0;
589 
590   /* If the return value is passed in memory, add the pointer as the
591      first integer argument.  */
<span class="line-modified">592   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>
593     reg_args-&gt;gpr[gprcount++] = (unsigned long) rvalue;
594 
595   avn = cif-&gt;nargs;
596   arg_types = cif-&gt;arg_types;
597 
598   for (i = 0; i &lt; avn; ++i)
599     {
600       size_t n, size = arg_types[i]-&gt;size;
601 
602       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
603       if (n == 0
604       || gprcount + ngpr &gt; MAX_GPR_REGS
605       || ssecount + nsse &gt; MAX_SSE_REGS)
606     {
607       long align = arg_types[i]-&gt;alignment;
608 
609       /* Stack arguments are *always* at least 8 byte aligned.  */
610       if (align &lt; 8)
611         align = 8;
612 
613       /* Pass this argument in memory.  */
<span class="line-modified">614       argp = (void *) FFI_ALIGN (argp, align);</span>
615       memcpy (argp, avalue[i], size);
616       argp += size;
617     }
618       else
619     {
620       /* The argument is passed entirely in registers.  */
621       char *a = (char *) avalue[i];
<span class="line-modified">622       unsigned int j;</span>
623 
624       for (j = 0; j &lt; n; j++, a += 8, size -= 8)
625         {
626           switch (classes[j])
627         {
<span class="line-added">628         case X86_64_NO_CLASS:</span>
<span class="line-added">629         case X86_64_SSEUP_CLASS:</span>
<span class="line-added">630           break;</span>
631         case X86_64_INTEGER_CLASS:
632         case X86_64_INTEGERSI_CLASS:
633           /* Sign-extend integer arguments passed in general
634              purpose registers, to cope with the fact that
635              LLVM incorrectly assumes that this will be done
636              (the x86-64 PS ABI does not specify this). */
637           switch (arg_types[i]-&gt;type)
638             {
639             case FFI_TYPE_SINT8:
<span class="line-modified">640               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT8 *) a);</span>
641               break;
642             case FFI_TYPE_SINT16:
<span class="line-modified">643               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT16 *) a);</span>
644               break;
645             case FFI_TYPE_SINT32:
<span class="line-modified">646               reg_args-&gt;gpr[gprcount] = (SINT64) *((SINT32 *) a);</span>
647               break;
648             default:
649               reg_args-&gt;gpr[gprcount] = 0;
<span class="line-modified">650               memcpy (&amp;reg_args-&gt;gpr[gprcount], a, size);</span>
651             }
652           gprcount++;
653           break;
654         case X86_64_SSE_CLASS:
655         case X86_64_SSEDF_CLASS:
<span class="line-modified">656           memcpy (&amp;reg_args-&gt;sse[ssecount++].i64, a, sizeof(UINT64));</span>
657           break;
658         case X86_64_SSESF_CLASS:
<span class="line-modified">659           memcpy (&amp;reg_args-&gt;sse[ssecount++].i32, a, sizeof(UINT32));</span>
660           break;
661         default:
662           abort();
663         }
664         }
665     }
666     }
<span class="line-added">667   reg_args-&gt;rax = ssecount;</span>
668 
669   ffi_call_unix64 (stack, cif-&gt;bytes + sizeof (struct register_args),
<span class="line-modified">670            flags, rvalue, fn);</span>
671 }
672 
<span class="line-added">673 #ifndef __ILP32__</span>
<span class="line-added">674 extern void</span>
<span class="line-added">675 ffi_call_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue);</span>
<span class="line-added">676 #endif</span>
677 
<span class="line-modified">678 void</span>
<span class="line-added">679 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
<span class="line-added">680 {</span>
<span class="line-added">681 #ifndef __ILP32__</span>
<span class="line-added">682   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">683     {</span>
<span class="line-added">684       ffi_call_efi64(cif, fn, rvalue, avalue);</span>
<span class="line-added">685       return;</span>
<span class="line-added">686     }</span>
<span class="line-added">687 #endif</span>
<span class="line-added">688   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>
<span class="line-added">689 }</span>
<span class="line-added">690 </span>
<span class="line-added">691 #ifndef __ILP32__</span>
<span class="line-added">692 extern void</span>
<span class="line-added">693 ffi_call_go_efi64(ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">694           void **avalue, void *closure);</span>
<span class="line-added">695 #endif</span>
<span class="line-added">696 </span>
<span class="line-added">697 void</span>
<span class="line-added">698 ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">699          void **avalue, void *closure)</span>
<span class="line-added">700 {</span>
<span class="line-added">701 #ifndef __ILP32__</span>
<span class="line-added">702   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">703     {</span>
<span class="line-added">704       ffi_call_go_efi64(cif, fn, rvalue, avalue, closure);</span>
<span class="line-added">705       return;</span>
<span class="line-added">706     }</span>
<span class="line-added">707 #endif</span>
<span class="line-added">708   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>
<span class="line-added">709 }</span>
<span class="line-added">710 </span>
<span class="line-added">711 </span>
<span class="line-added">712 extern void ffi_closure_unix64(void) FFI_HIDDEN;</span>
<span class="line-added">713 extern void ffi_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="line-added">714 </span>
<span class="line-added">715 #ifndef __ILP32__</span>
<span class="line-added">716 extern ffi_status</span>
<span class="line-added">717 ffi_prep_closure_loc_efi64(ffi_closure* closure,</span>
<span class="line-added">718                ffi_cif* cif,</span>
<span class="line-added">719                void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="line-added">720                void *user_data,</span>
<span class="line-added">721                void *codeloc);</span>
<span class="line-added">722 #endif</span>
723 
724 ffi_status
725 ffi_prep_closure_loc (ffi_closure* closure,
726               ffi_cif* cif,
727               void (*fun)(ffi_cif*, void*, void**, void*),
728               void *user_data,
729               void *codeloc)
730 {
<span class="line-modified">731   static const unsigned char trampoline[16] = {</span>
<span class="line-added">732     /* leaq  -0x7(%rip),%r10   # 0x0  */</span>
<span class="line-added">733     0x4c, 0x8d, 0x15, 0xf9, 0xff, 0xff, 0xff,</span>
<span class="line-added">734     /* jmpq  *0x3(%rip)        # 0x10 */</span>
<span class="line-added">735     0xff, 0x25, 0x03, 0x00, 0x00, 0x00,</span>
<span class="line-added">736     /* nopl  (%rax) */</span>
<span class="line-added">737     0x0f, 0x1f, 0x00</span>
<span class="line-added">738   };</span>
<span class="line-added">739   void (*dest)(void);</span>
<span class="line-added">740   char *tramp = closure-&gt;tramp;</span>
741 
<span class="line-modified">742 #ifndef __ILP32__</span>
<span class="line-modified">743   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-modified">744     return ffi_prep_closure_loc_efi64(closure, cif, fun, user_data, codeloc);</span>
<span class="line-modified">745 #endif</span>
<span class="line-added">746   if (cif-&gt;abi != FFI_UNIX64)</span>
747       return FFI_BAD_ABI;










748 
<span class="line-modified">749   if (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS)</span>
<span class="line-modified">750     dest = ffi_closure_unix64_sse;</span>
<span class="line-modified">751   else</span>
<span class="line-added">752     dest = ffi_closure_unix64;</span>
753 
<span class="line-modified">754   memcpy (tramp, trampoline, sizeof(trampoline));</span>
<span class="line-added">755   *(UINT64 *)(tramp + 16) = (uintptr_t)dest;</span>
756 
757   closure-&gt;cif = cif;
758   closure-&gt;fun = fun;
759   closure-&gt;user_data = user_data;
760 
761   return FFI_OK;
762 }
763 
<span class="line-modified">764 int FFI_HIDDEN</span>
<span class="line-modified">765 ffi_closure_unix64_inner(ffi_cif *cif,</span>
<span class="line-modified">766              void (*fun)(ffi_cif*, void*, void**, void*),</span>
<span class="line-added">767              void *user_data,</span>
<span class="line-added">768              void *rvalue,</span>
<span class="line-added">769              struct register_args *reg_args,</span>
<span class="line-added">770              char *argp)</span>
771 {

772   void **avalue;
773   ffi_type **arg_types;
774   long i, avn;
775   int gprcount, ssecount, ngpr, nsse;
<span class="line-modified">776   int flags;</span>
777 
<span class="line-modified">778   avn = cif-&gt;nargs;</span>
<span class="line-modified">779   flags = cif-&gt;flags;</span>
<span class="line-added">780   avalue = alloca(avn * sizeof(void *));</span>
781   gprcount = ssecount = 0;
782 
<span class="line-modified">783   if (flags &amp; UNIX64_FLAG_RET_IN_MEM)</span>





784     {
<span class="line-modified">785       /* On return, %rax will contain the address that was passed</span>
<span class="line-modified">786      by the caller in %rdi.  */</span>
<span class="line-modified">787       void *r = (void *)(uintptr_t)reg_args-&gt;gpr[gprcount++];</span>
<span class="line-modified">788       *(void **)rvalue = r;</span>
<span class="line-modified">789       rvalue = r;</span>
<span class="line-modified">790       flags = (sizeof(void *) == 4 ? UNIX64_RET_UINT32 : UNIX64_RET_INT64);</span>










791     }
792 

793   arg_types = cif-&gt;arg_types;

794   for (i = 0; i &lt; avn; ++i)
795     {
796       enum x86_64_reg_class classes[MAX_CLASSES];
797       size_t n;
798 
799       n = examine_argument (arg_types[i], classes, 0, &amp;ngpr, &amp;nsse);
800       if (n == 0
801       || gprcount + ngpr &gt; MAX_GPR_REGS
802       || ssecount + nsse &gt; MAX_SSE_REGS)
803     {
804       long align = arg_types[i]-&gt;alignment;
805 
806       /* Stack arguments are *always* at least 8 byte aligned.  */
807       if (align &lt; 8)
808         align = 8;
809 
810       /* Pass this argument in memory.  */
<span class="line-modified">811       argp = (void *) FFI_ALIGN (argp, align);</span>
812       avalue[i] = argp;
813       argp += arg_types[i]-&gt;size;
814     }
815       /* If the argument is in a single register, or two consecutive
816      integer registers, then we can use that address directly.  */
817       else if (n == 1
818            || (n == 2 &amp;&amp; !(SSE_CLASS_P (classes[0])
819                    || SSE_CLASS_P (classes[1]))))
820     {
821       /* The argument is in a single register.  */
822       if (SSE_CLASS_P (classes[0]))
823         {
824           avalue[i] = &amp;reg_args-&gt;sse[ssecount];
825           ssecount += n;
826         }
827       else
828         {
829           avalue[i] = &amp;reg_args-&gt;gpr[gprcount];
830           gprcount += n;
831         }
832     }
833       /* Otherwise, allocate space to make them consecutive.  */
834       else
835     {
836       char *a = alloca (16);
<span class="line-modified">837       unsigned int j;</span>
838 
839       avalue[i] = a;
840       for (j = 0; j &lt; n; j++, a += 8)
841         {
842           if (SSE_CLASS_P (classes[j]))
843         memcpy (a, &amp;reg_args-&gt;sse[ssecount++], 8);
844           else
845         memcpy (a, &amp;reg_args-&gt;gpr[gprcount++], 8);
846         }
847     }
848     }
849 
850   /* Invoke the closure.  */
<span class="line-modified">851   fun (cif, rvalue, avalue, user_data);</span>
852 
853   /* Tell assembly how to perform return type promotions.  */
<span class="line-modified">854   return flags;</span>
<span class="line-added">855 }</span>
<span class="line-added">856 </span>
<span class="line-added">857 extern void ffi_go_closure_unix64(void) FFI_HIDDEN;</span>
<span class="line-added">858 extern void ffi_go_closure_unix64_sse(void) FFI_HIDDEN;</span>
<span class="line-added">859 </span>
<span class="line-added">860 #ifndef __ILP32__</span>
<span class="line-added">861 extern ffi_status</span>
<span class="line-added">862 ffi_prep_go_closure_efi64(ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">863               void (*fun)(ffi_cif*, void*, void**, void*));</span>
<span class="line-added">864 #endif</span>
<span class="line-added">865 </span>
<span class="line-added">866 ffi_status</span>
<span class="line-added">867 ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">868              void (*fun)(ffi_cif*, void*, void**, void*))</span>
<span class="line-added">869 {</span>
<span class="line-added">870 #ifndef __ILP32__</span>
<span class="line-added">871   if (cif-&gt;abi == FFI_EFI64 || cif-&gt;abi == FFI_GNUW64)</span>
<span class="line-added">872     return ffi_prep_go_closure_efi64(closure, cif, fun);</span>
<span class="line-added">873 #endif</span>
<span class="line-added">874   if (cif-&gt;abi != FFI_UNIX64)</span>
<span class="line-added">875     return FFI_BAD_ABI;</span>
<span class="line-added">876 </span>
<span class="line-added">877   closure-&gt;tramp = (cif-&gt;flags &amp; UNIX64_FLAG_XMM_ARGS</span>
<span class="line-added">878             ? ffi_go_closure_unix64_sse</span>
<span class="line-added">879             : ffi_go_closure_unix64);</span>
<span class="line-added">880   closure-&gt;cif = cif;</span>
<span class="line-added">881   closure-&gt;fun = fun;</span>
<span class="line-added">882 </span>
<span class="line-added">883   return FFI_OK;</span>
884 }
885 
886 #endif /* __x86_64__ */
</pre>
</td>
</tr>
</table>
<center><a href="ffi.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="win64.S.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
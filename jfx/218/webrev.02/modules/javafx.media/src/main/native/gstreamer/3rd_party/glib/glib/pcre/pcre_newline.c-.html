<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/pcre/pcre_newline.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*************************************************
  2 *      Perl-Compatible Regular Expressions       *
  3 *************************************************/
  4 
  5 /* PCRE is a library of functions to support regular expressions whose syntax
  6 and semantics are as close as possible to those of the Perl 5 language.
  7 
  8                        Written by Philip Hazel
  9            Copyright (c) 1997-2012 University of Cambridge
 10 
 11 -----------------------------------------------------------------------------
 12 Redistribution and use in source and binary forms, with or without
 13 modification, are permitted provided that the following conditions are met:
 14 
 15     * Redistributions of source code must retain the above copyright notice,
 16       this list of conditions and the following disclaimer.
 17 
 18     * Redistributions in binary form must reproduce the above copyright
 19       notice, this list of conditions and the following disclaimer in the
 20       documentation and/or other materials provided with the distribution.
 21 
 22     * Neither the name of the University of Cambridge nor the names of its
 23       contributors may be used to endorse or promote products derived from
 24       this software without specific prior written permission.
 25 
 26 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 27 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 28 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 29 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 30 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 31 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 32 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 33 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 34 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 35 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 36 POSSIBILITY OF SUCH DAMAGE.
 37 -----------------------------------------------------------------------------
 38 */
 39 
 40 
 41 /* This module contains internal functions for testing newlines when more than
 42 one kind of newline is to be recognized. When a newline is found, its length is
 43 returned. In principle, we could implement several newline &quot;types&quot;, each
 44 referring to a different set of newline characters. At present, PCRE supports
 45 only NLTYPE_FIXED, which gets handled without these functions, NLTYPE_ANYCRLF,
 46 and NLTYPE_ANY. The full list of Unicode newline characters is taken from
 47 http://unicode.org/unicode/reports/tr18/. */
 48 
 49 
 50 #include &quot;config.h&quot;
 51 
 52 #include &quot;pcre_internal.h&quot;
 53 
 54 
 55 
 56 /*************************************************
 57 *      Check for newline at given position       *
 58 *************************************************/
 59 
 60 /* It is guaranteed that the initial value of ptr is less than the end of the
 61 string that is being processed.
 62 
 63 Arguments:
 64   ptr          pointer to possible newline
 65   type         the newline type
 66   endptr       pointer to the end of the string
 67   lenptr       where to return the length
 68   utf          TRUE if in utf mode
 69 
 70 Returns:       TRUE or FALSE
 71 */
 72 
 73 BOOL
 74 PRIV(is_newline)(PCRE_PUCHAR ptr, int type, PCRE_PUCHAR endptr, int *lenptr,
 75   BOOL utf)
 76 {
 77 int c;
 78 (void)utf;
 79 #ifdef SUPPORT_UTF
 80 if (utf)
 81   {
 82   GETCHAR(c, ptr);
 83   }
 84 else
 85 #endif  /* SUPPORT_UTF */
 86   c = *ptr;
 87 
 88 if (type == NLTYPE_ANYCRLF) switch(c)
 89   {
 90   case 0x000a: *lenptr = 1; return TRUE;             /* LF */
 91   case 0x000d: *lenptr = (ptr &lt; endptr - 1 &amp;&amp; ptr[1] == 0x0a)? 2 : 1;
 92                return TRUE;                          /* CR */
 93   default: return FALSE;
 94   }
 95 
 96 /* NLTYPE_ANY */
 97 
 98 else switch(c)
 99   {
100   case 0x000a:                                       /* LF */
101   case 0x000b:                                       /* VT */
102   case 0x000c: *lenptr = 1; return TRUE;             /* FF */
103   case 0x000d: *lenptr = (ptr &lt; endptr - 1 &amp;&amp; ptr[1] == 0x0a)? 2 : 1;
104                return TRUE;                          /* CR */
105 #ifdef COMPILE_PCRE8
106   case 0x0085: *lenptr = utf? 2 : 1; return TRUE;    /* NEL */
107   case 0x2028:                                       /* LS */
108   case 0x2029: *lenptr = 3; return TRUE;             /* PS */
109 #else
110   case 0x0085:                                       /* NEL */
111   case 0x2028:                                       /* LS */
112   case 0x2029: *lenptr = 1; return TRUE;             /* PS */
113 #endif /* COMPILE_PCRE8 */
114   default: return FALSE;
115   }
116 }
117 
118 
119 
120 /*************************************************
121 *     Check for newline at previous position     *
122 *************************************************/
123 
124 /* It is guaranteed that the initial value of ptr is greater than the start of
125 the string that is being processed.
126 
127 Arguments:
128   ptr          pointer to possible newline
129   type         the newline type
130   startptr     pointer to the start of the string
131   lenptr       where to return the length
132   utf          TRUE if in utf mode
133 
134 Returns:       TRUE or FALSE
135 */
136 
137 BOOL
138 PRIV(was_newline)(PCRE_PUCHAR ptr, int type, PCRE_PUCHAR startptr, int *lenptr,
139   BOOL utf)
140 {
141 int c;
142 (void)utf;
143 ptr--;
144 #ifdef SUPPORT_UTF
145 if (utf)
146   {
147   BACKCHAR(ptr);
148   GETCHAR(c, ptr);
149   }
150 else
151 #endif  /* SUPPORT_UTF */
152   c = *ptr;
153 
154 if (type == NLTYPE_ANYCRLF) switch(c)
155   {
156   case 0x000a: *lenptr = (ptr &gt; startptr &amp;&amp; ptr[-1] == 0x0d)? 2 : 1;
157                return TRUE;                         /* LF */
158   case 0x000d: *lenptr = 1; return TRUE;            /* CR */
159   default: return FALSE;
160   }
161 
162 else switch(c)
163   {
164   case 0x000a: *lenptr = (ptr &gt; startptr &amp;&amp; ptr[-1] == 0x0d)? 2 : 1;
165                return TRUE;                         /* LF */
166   case 0x000b:                                      /* VT */
167   case 0x000c:                                      /* FF */
168   case 0x000d: *lenptr = 1; return TRUE;            /* CR */
169 #ifdef COMPILE_PCRE8
170   case 0x0085: *lenptr = utf? 2 : 1; return TRUE;   /* NEL */
171   case 0x2028:                                      /* LS */
172   case 0x2029: *lenptr = 3; return TRUE;            /* PS */
173 #else
174   case 0x0085:                                       /* NEL */
175   case 0x2028:                                       /* LS */
176   case 0x2029: *lenptr = 1; return TRUE;             /* PS */
177 #endif /* COMPILE_PCRE8 */
178   default: return FALSE;
179   }
180 }
181 
182 /* End of pcre_newline.c */
    </pre>
  </body>
</html>
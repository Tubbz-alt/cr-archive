<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/schedule.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: Schedule.h
  3 //
  4 // Desc: DirectShow base classes.
  5 //
  6 // Copyright (c) 1996-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #ifndef __CAMSchedule__
 11 #define __CAMSchedule__
 12 
 13 class CAMSchedule : private CBaseObject
 14 {
 15 public:
 16     virtual ~CAMSchedule();
 17     // ev is the event we should fire if the advise time needs re-evaluating
 18     CAMSchedule( HANDLE ev );
 19 
 20     DWORD GetAdviseCount();
 21     REFERENCE_TIME GetNextAdviseTime();
 22 
 23     // We need a method for derived classes to add advise packets, we return the cookie
 24     DWORD_PTR AddAdvisePacket( const REFERENCE_TIME &amp; time1, const REFERENCE_TIME &amp; time2, HANDLE h, BOOL periodic );
 25     // And a way to cancel
 26     HRESULT Unadvise(DWORD_PTR dwAdviseCookie);
 27 
 28     // Tell us the time please, and we&#39;ll dispatch the expired events.  We return the time of the next event.
 29     // NB: The time returned will be &quot;useless&quot; if you start adding extra Advises.  But that&#39;s the problem of
 30     // whoever is using this helper class (typically a clock).
 31     REFERENCE_TIME Advise( const REFERENCE_TIME &amp; rtTime );
 32 
 33     // Get the event handle which will be set if advise time requires re-evaluation.
 34     HANDLE GetEvent() const { return m_ev; }
 35 
 36 private:
 37     // We define the nodes that will be used in our singly linked list
 38     // of advise packets.  The list is ordered by time, with the
 39     // elements that will expire first at the front.
 40     class CAdvisePacket
 41     {
 42     public:
 43         CAdvisePacket()
 44         {}
 45 
 46         CAdvisePacket * m_next;
 47         DWORD_PTR       m_dwAdviseCookie;
 48         REFERENCE_TIME  m_rtEventTime;      // Time at which event should be set
 49         REFERENCE_TIME  m_rtPeriod;         // Periodic time
 50         HANDLE          m_hNotify;          // Handle to event or semephore
 51         BOOL            m_bPeriodic;        // TRUE =&gt; Periodic event
 52 
 53         CAdvisePacket( __inout_opt CAdvisePacket * next, LONGLONG time ) : m_next(next), m_rtEventTime(time)
 54         {}
 55 
 56         void InsertAfter( __inout CAdvisePacket * p )
 57         {
 58             p-&gt;m_next = m_next;
 59             m_next    = p;
 60         }
 61 
 62         int IsZ() const // That is, is it the node that represents the end of the list
 63         { return m_next == 0; }
 64 
 65         CAdvisePacket * RemoveNext()
 66         {
 67             CAdvisePacket *const next = m_next;
 68             CAdvisePacket *const new_next = next-&gt;m_next;
 69             m_next = new_next;
 70             return next;
 71         }
 72 
 73         void DeleteNext()
 74         {
 75             delete RemoveNext();
 76         }
 77 
 78         CAdvisePacket * Next() const
 79         {
 80             CAdvisePacket * result = m_next;
 81             if (result-&gt;IsZ()) result = 0;
 82             return result;
 83         }
 84 
 85         DWORD_PTR Cookie() const
 86         { return m_dwAdviseCookie; }
 87     };
 88 
 89     // Structure is:
 90     // head -&gt; elmt1 -&gt; elmt2 -&gt; z -&gt; null
 91     // So an empty list is:       head -&gt; z -&gt; null
 92     // Having head &amp; z as links makes insertaion,
 93     // deletion and shunting much easier.
 94     CAdvisePacket   head, z;            // z is both a tail and a sentry
 95 
 96     volatile DWORD_PTR  m_dwNextCookie;     // Strictly increasing
 97     volatile DWORD  m_dwAdviseCount;    // Number of elements on list
 98 
 99     CCritSec        m_Serialize;
100 
101     // AddAdvisePacket: adds the packet, returns the cookie (0 if failed)
102     DWORD_PTR AddAdvisePacket( __inout CAdvisePacket * pPacket );
103     // Event that we should set if the packed added above will be the next to fire.
104     const HANDLE m_ev;
105 
106     // A Shunt is where we have changed the first element in the
107     // list and want it re-evaluating (i.e. repositioned) in
108     // the list.
109     void ShuntHead();
110 
111     // Rather than delete advise packets, we cache them for future use
112     CAdvisePacket * m_pAdviseCache;
113     DWORD           m_dwCacheCount;
114     enum { dwCacheMax = 5 };             // Don&#39;t bother caching more than five
115 
116     void Delete( __inout CAdvisePacket * pLink );// This &quot;Delete&quot; will cache the Link
117 
118 // Attributes and methods for debugging
119 public:
120 #ifdef DEBUG
121     void DumpLinkedList();
122 #else
123     void DumpLinkedList() {}
124 #endif
125 
126 };
127 
128 #endif // __CAMSchedule__
    </pre>
  </body>
</html>
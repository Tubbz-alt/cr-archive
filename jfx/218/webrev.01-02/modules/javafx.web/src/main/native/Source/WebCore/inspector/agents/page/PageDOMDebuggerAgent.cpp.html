<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/page/PageDOMDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PageDOMDebuggerAgent.h&quot;
 28 
 29 #include &quot;Element.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;InspectorDOMAgent.h&quot;
 32 #include &quot;InstrumentingAgents.h&quot;
 33 #include &quot;Node.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 using namespace Inspector;
 38 
 39 enum DOMBreakpointType {
 40     SubtreeModified,
 41     AttributeModified,
 42     NodeRemoved,
 43 };
 44 
 45 const uint32_t inheritableDOMBreakpointTypesMask = (1 &lt;&lt; SubtreeModified);
 46 const int domBreakpointDerivedTypeShift = 16;
 47 
 48 static int domTypeForName(ErrorString&amp; errorString, const String&amp; typeString)
 49 {
 50     if (typeString == &quot;subtree-modified&quot;)
 51         return SubtreeModified;
 52     if (typeString == &quot;attribute-modified&quot;)
 53         return AttributeModified;
 54     if (typeString == &quot;node-removed&quot;)
 55         return NodeRemoved;
 56     errorString = makeString(&quot;Unknown DOM breakpoint type: &quot;, typeString);
 57     return -1;
 58 }
 59 
 60 static String domTypeName(int type)
 61 {
 62     switch (type) {
 63     case SubtreeModified:
 64         return &quot;subtree-modified&quot;_s;
 65     case AttributeModified:
 66         return &quot;attribute-modified&quot;_s;
 67     case NodeRemoved:
 68         return &quot;node-removed&quot;_s;
 69     }
 70     return emptyString();
 71 }
 72 
 73 PageDOMDebuggerAgent::PageDOMDebuggerAgent(PageAgentContext&amp; context, InspectorDebuggerAgent* debuggerAgent)
 74     : InspectorDOMDebuggerAgent(context, debuggerAgent)
 75 {
 76 }
 77 
 78 PageDOMDebuggerAgent::~PageDOMDebuggerAgent() = default;
 79 
 80 bool PageDOMDebuggerAgent::enabled() const
 81 {
 82     return m_instrumentingAgents.pageDOMDebuggerAgent() == this &amp;&amp; InspectorDOMDebuggerAgent::enabled();
 83 }
 84 
 85 void PageDOMDebuggerAgent::enable()
 86 {
 87     m_instrumentingAgents.setPageDOMDebuggerAgent(this);
 88 
 89     InspectorDOMDebuggerAgent::enable();
 90 }
 91 
 92 void PageDOMDebuggerAgent::disable()
 93 {
 94     m_instrumentingAgents.setPageDOMDebuggerAgent(nullptr);
 95 
 96     m_domBreakpoints.clear();
 97     m_pauseOnAllAnimationFramesEnabled = false;
 98 
 99     InspectorDOMDebuggerAgent::disable();
100 }
101 
102 void PageDOMDebuggerAgent::setDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
103 {
104     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
105     if (!domAgent) {
106         errorString = &quot;DOM domain must be enabled&quot;_s;
107         return;
108     }
109 
110     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
111     if (!node)
112         return;
113 
114     int type = domTypeForName(errorString, typeString);
115     if (type == -1)
116         return;
117 
118     uint32_t rootBit = 1 &lt;&lt; type;
119     m_domBreakpoints.set(node, m_domBreakpoints.get(node) | rootBit);
120     if (rootBit &amp; inheritableDOMBreakpointTypesMask) {
121         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
122             updateSubtreeBreakpoints(child, rootBit, true);
123     }
124 }
125 
126 void PageDOMDebuggerAgent::removeDOMBreakpoint(ErrorString&amp; errorString, int nodeId, const String&amp; typeString)
127 {
128     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
129     if (!domAgent) {
130         errorString = &quot;DOM domain must be enabled&quot;_s;
131         return;
132     }
133 
134     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
135     if (!node)
136         return;
137 
138     int type = domTypeForName(errorString, typeString);
139     if (type == -1)
140         return;
141 
142     uint32_t rootBit = 1 &lt;&lt; type;
143     uint32_t mask = m_domBreakpoints.get(node) &amp; ~rootBit;
144     if (mask)
145         m_domBreakpoints.set(node, mask);
146     else
147         m_domBreakpoints.remove(node);
148 
149     if ((rootBit &amp; inheritableDOMBreakpointTypesMask) &amp;&amp; !(mask &amp; (rootBit &lt;&lt; domBreakpointDerivedTypeShift))) {
150         for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
151             updateSubtreeBreakpoints(child, rootBit, false);
152     }
153 }
154 
155 void PageDOMDebuggerAgent::frameDocumentUpdated(Frame&amp; frame)
156 {
157     if (!frame.isMainFrame())
158         return;
159 
160     m_domBreakpoints.clear();
161 }
162 
163 void PageDOMDebuggerAgent::willInsertDOMNode(Node&amp; parent)
164 {
165     if (!m_debuggerAgent-&gt;breakpointsActive())
166         return;
167 
168     if (hasBreakpoint(&amp;parent, SubtreeModified)) {
169         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
170         descriptionForDOMEvent(parent, SubtreeModified, true, eventData.get());
171         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
172     }
173 }
174 
175 void PageDOMDebuggerAgent::didInsertDOMNode(Node&amp; node)
176 {
177     if (m_domBreakpoints.size()) {
178         uint32_t mask = m_domBreakpoints.get(InspectorDOMAgent::innerParentNode(&amp;node));
179         uint32_t inheritableTypesMask = (mask | (mask &gt;&gt; domBreakpointDerivedTypeShift)) &amp; inheritableDOMBreakpointTypesMask;
180         if (inheritableTypesMask)
181             updateSubtreeBreakpoints(&amp;node, inheritableTypesMask, true);
182     }
183 }
184 
185 void PageDOMDebuggerAgent::willRemoveDOMNode(Node&amp; node)
186 {
187     if (!m_debuggerAgent-&gt;breakpointsActive())
188         return;
189 
190     if (hasBreakpoint(&amp;node, NodeRemoved)) {
191         auto eventData = JSON::Object::create();
192         descriptionForDOMEvent(node, NodeRemoved, false, eventData.get());
193         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
194         return;
195     }
196 
197     uint32_t rootBit = 1 &lt;&lt; NodeRemoved;
198     uint32_t derivedBit = rootBit &lt;&lt; domBreakpointDerivedTypeShift;
199     uint32_t matchBit = rootBit | derivedBit;
200     for (auto&amp; [nodeWithBreakpoint, breakpointTypes] : m_domBreakpoints) {
201         if (node.contains(nodeWithBreakpoint) &amp;&amp; (breakpointTypes &amp; matchBit)) {
202             auto eventData = JSON::Object::create();
203             descriptionForDOMEvent(*nodeWithBreakpoint, NodeRemoved, false, eventData.get());
204             if (auto* domAgent = m_instrumentingAgents.inspectorDOMAgent())
205                 eventData-&gt;setInteger(&quot;targetNodeId&quot;_s, domAgent-&gt;pushNodeToFrontend(&amp;node));
206             m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
207             return;
208         }
209     }
210 
211     auto* parentNode = InspectorDOMAgent::innerParentNode(&amp;node);
212     if (parentNode &amp;&amp; hasBreakpoint(parentNode, SubtreeModified)) {
213         auto eventData = JSON::Object::create();
214         descriptionForDOMEvent(node, SubtreeModified, false, eventData.get());
215         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
216         return;
217     }
218 }
219 
220 void PageDOMDebuggerAgent::didRemoveDOMNode(Node&amp; node)
221 {
222     if (m_domBreakpoints.size()) {
223         // Remove subtree breakpoints.
224         m_domBreakpoints.remove(&amp;node);
225         Vector&lt;Node*&gt; stack(1, InspectorDOMAgent::innerFirstChild(&amp;node));
226         do {
227             Node* node = stack.last();
228             stack.removeLast();
229             if (!node)
230                 continue;
231             m_domBreakpoints.remove(node);
232             stack.append(InspectorDOMAgent::innerFirstChild(node));
233             stack.append(InspectorDOMAgent::innerNextSibling(node));
234         } while (!stack.isEmpty());
235     }
236 }
237 
238 void PageDOMDebuggerAgent::willModifyDOMAttr(Element&amp; element)
239 {
240     if (!m_debuggerAgent-&gt;breakpointsActive())
241         return;
242 
243     if (hasBreakpoint(&amp;element, AttributeModified)) {
244         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
245         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());
246         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
247     }
248 }
249 
250 void PageDOMDebuggerAgent::willFireAnimationFrame()
251 {
252     if (!m_debuggerAgent-&gt;breakpointsActive())
253         return;
254 
255     bool shouldPause = m_debuggerAgent-&gt;pauseOnNextStatementEnabled() || m_pauseOnAllAnimationFramesEnabled;
256     if (!shouldPause)
257         return;
258 
259     m_debuggerAgent-&gt;schedulePauseOnNextStatement(Inspector::DebuggerFrontendDispatcher::Reason::AnimationFrame, nullptr);
260 }
261 
262 void PageDOMDebuggerAgent::willInvalidateStyleAttr(Element&amp; element)
263 {
264     if (!m_debuggerAgent-&gt;breakpointsActive())
265         return;
266 
267     if (hasBreakpoint(&amp;element, AttributeModified)) {
268         Ref&lt;JSON::Object&gt; eventData = JSON::Object::create();
269         descriptionForDOMEvent(element, AttributeModified, false, eventData.get());
270         m_debuggerAgent-&gt;breakProgram(Inspector::DebuggerFrontendDispatcher::Reason::DOM, WTFMove(eventData));
271     }
272 }
273 
274 void PageDOMDebuggerAgent::setAnimationFrameBreakpoint(ErrorString&amp; errorString, bool enabled)
275 {
276     if (m_pauseOnAllAnimationFramesEnabled == enabled)
277         errorString = m_pauseOnAllAnimationFramesEnabled ? &quot;Breakpoint for AnimationFrame already exists&quot;_s : &quot;Breakpoint for AnimationFrame missing&quot;_s;
278 
279     m_pauseOnAllAnimationFramesEnabled = enabled;
280 }
281 
282 void PageDOMDebuggerAgent::descriptionForDOMEvent(Node&amp; target, int breakpointType, bool insertion, JSON::Object&amp; description)
283 {
284     ASSERT(m_debuggerAgent-&gt;breakpointsActive());
285     ASSERT(hasBreakpoint(&amp;target, breakpointType));
286 
287     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
288 
289     Node* breakpointOwner = &amp;target;
290     if ((1 &lt;&lt; breakpointType) &amp; inheritableDOMBreakpointTypesMask) {
291         if (domAgent) {
292             // For inheritable breakpoint types, target node isn&#39;t always the same as the node that owns a breakpoint.
293             // Target node may be unknown to frontend, so we need to push it first.
294             description.setInteger(&quot;targetNodeId&quot;_s, domAgent-&gt;pushNodeToFrontend(&amp;target));
295         }
296 
297         // Find breakpoint owner node.
298         if (!insertion)
299             breakpointOwner = InspectorDOMAgent::innerParentNode(&amp;target);
300         ASSERT(breakpointOwner);
301         while (!(m_domBreakpoints.get(breakpointOwner) &amp; (1 &lt;&lt; breakpointType))) {
302             Node* parentNode = InspectorDOMAgent::innerParentNode(breakpointOwner);
303             if (!parentNode)
304                 break;
305             breakpointOwner = parentNode;
306         }
307 
308         if (breakpointType == SubtreeModified)
309             description.setBoolean(&quot;insertion&quot;, insertion);
310     }
311 
312     if (domAgent) {
313         int breakpointOwnerNodeId = domAgent-&gt;boundNodeId(breakpointOwner);
314         ASSERT(breakpointOwnerNodeId);
315         description.setInteger(&quot;nodeId&quot;, breakpointOwnerNodeId);
316     }
317 
318     description.setString(&quot;type&quot;, domTypeName(breakpointType));
319 }
320 
321 void PageDOMDebuggerAgent::updateSubtreeBreakpoints(Node* node, uint32_t rootMask, bool set)
322 {
323     uint32_t oldMask = m_domBreakpoints.get(node);
324     uint32_t derivedMask = rootMask &lt;&lt; domBreakpointDerivedTypeShift;
325     uint32_t newMask = set ? oldMask | derivedMask : oldMask &amp; ~derivedMask;
326     if (newMask)
327         m_domBreakpoints.set(node, newMask);
328     else
329         m_domBreakpoints.remove(node);
330 
331     uint32_t newRootMask = rootMask &amp; ~newMask;
332     if (!newRootMask)
333         return;
334 
335     for (Node* child = InspectorDOMAgent::innerFirstChild(node); child; child = InspectorDOMAgent::innerNextSibling(child))
336         updateSubtreeBreakpoints(child, newRootMask, set);
337 }
338 
339 bool PageDOMDebuggerAgent::hasBreakpoint(Node* node, int type)
340 {
341     uint32_t rootBit = 1 &lt;&lt; type;
342     uint32_t derivedBit = rootBit &lt;&lt; domBreakpointDerivedTypeShift;
343     return m_domBreakpoints.get(node) &amp; (rootBit | derivedBit);
344 }
345 
346 } // namespace WebCore
    </pre>
  </body>
</html>
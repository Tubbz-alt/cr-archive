<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/BitmapTextureGL.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapTextureGL.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapTextureJava.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/BitmapTextureGL.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9 
 10  This library is distributed in the hope that it will be useful,
 11  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  Library General Public License for more details.
 14 
 15  You should have received a copy of the GNU Library General Public License
 16  along with this library; see the file COPYING.LIB.  If not, write to
 17  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #ifndef BitmapTextureGL_h
 22 #define BitmapTextureGL_h
 23 
 24 #if USE(TEXTURE_MAPPER_GL)
 25 
 26 #include &quot;BitmapTexture.h&quot;
 27 #include &quot;ClipStack.h&quot;
 28 #include &quot;FilterOperation.h&quot;

 29 #include &quot;IntSize.h&quot;
 30 #include &quot;TextureMapperContextAttributes.h&quot;
 31 #include &quot;TextureMapperGL.h&quot;
 32 #include &quot;TextureMapperGLHeaders.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 class TextureMapper;
 37 class TextureMapperGL;
 38 class FilterOperation;
 39 
 40 class BitmapTextureGL : public BitmapTexture {
 41 public:
 42     static Ref&lt;BitmapTexture&gt; create(const TextureMapperContextAttributes&amp; contextAttributes, const Flags flags = NoFlag, GLint internalFormat = GL_DONT_CARE)
 43     {
 44         return adoptRef(*new BitmapTextureGL(contextAttributes, flags, internalFormat));
 45     }
 46 
 47     virtual ~BitmapTextureGL();
 48 
</pre>
<hr />
<pre>
 60     bool isBackedByOpenGL() const override { return true; }
 61 
 62     RefPtr&lt;BitmapTexture&gt; applyFilters(TextureMapper&amp;, const FilterOperations&amp;) override;
 63     struct FilterInfo {
 64         RefPtr&lt;FilterOperation&gt; filter;
 65         unsigned pass;
 66         RefPtr&lt;BitmapTexture&gt; contentTexture;
 67 
 68         FilterInfo(RefPtr&lt;FilterOperation&gt;&amp;&amp; f = nullptr, unsigned p = 0, RefPtr&lt;BitmapTexture&gt;&amp;&amp; t = nullptr)
 69             : filter(WTFMove(f))
 70             , pass(p)
 71             , contentTexture(WTFMove(t))
 72             { }
 73     };
 74     const FilterInfo* filterInfo() const { return &amp;m_filterInfo; }
 75     ClipStack&amp; clipStack() { return m_clipStack; }
 76 
 77     GLint internalFormat() const { return m_internalFormat; }
 78 
 79     void copyFromExternalTexture(GLuint textureID);




 80 
 81     TextureMapperGL::Flags colorConvertFlags() const { return m_colorConvertFlags; }
 82 
 83 private:
 84     BitmapTextureGL(const TextureMapperContextAttributes&amp;, const Flags, GLint internalFormat);
 85 
 86     GLuint m_id { 0 };
 87     IntSize m_textureSize;
 88     IntRect m_dirtyRect;
 89     GLuint m_fbo { 0 };
 90     GLuint m_rbo { 0 };
 91     GLuint m_depthBufferObject { 0 };
 92     bool m_shouldClear { true };
 93     ClipStack m_clipStack;
 94     TextureMapperContextAttributes m_contextAttributes;
 95     TextureMapperGL::Flags m_colorConvertFlags { TextureMapperGL::NoFlag };
 96 




 97     void clearIfNeeded();
 98     void createFboIfNeeded();
 99 
100     FilterInfo m_filterInfo;
101 
102     GLint m_internalFormat;
103     GLenum m_format;
104     GLenum m_type {
105 #if OS(DARWIN)
106         GL_UNSIGNED_INT_8_8_8_8_REV
107 #else
108         GL_UNSIGNED_BYTE
109 #endif
110     };
111 };
112 
113 BitmapTextureGL* toBitmapTextureGL(BitmapTexture*);
114 
115 }
116 
</pre>
</td>
<td>
<hr />
<pre>
  9 
 10  This library is distributed in the hope that it will be useful,
 11  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  Library General Public License for more details.
 14 
 15  You should have received a copy of the GNU Library General Public License
 16  along with this library; see the file COPYING.LIB.  If not, write to
 17  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  Boston, MA 02110-1301, USA.
 19  */
 20 
 21 #ifndef BitmapTextureGL_h
 22 #define BitmapTextureGL_h
 23 
 24 #if USE(TEXTURE_MAPPER_GL)
 25 
 26 #include &quot;BitmapTexture.h&quot;
 27 #include &quot;ClipStack.h&quot;
 28 #include &quot;FilterOperation.h&quot;
<span class="line-added"> 29 #include &quot;Image.h&quot;</span>
 30 #include &quot;IntSize.h&quot;
 31 #include &quot;TextureMapperContextAttributes.h&quot;
 32 #include &quot;TextureMapperGL.h&quot;
 33 #include &quot;TextureMapperGLHeaders.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 class TextureMapper;
 38 class TextureMapperGL;
 39 class FilterOperation;
 40 
 41 class BitmapTextureGL : public BitmapTexture {
 42 public:
 43     static Ref&lt;BitmapTexture&gt; create(const TextureMapperContextAttributes&amp; contextAttributes, const Flags flags = NoFlag, GLint internalFormat = GL_DONT_CARE)
 44     {
 45         return adoptRef(*new BitmapTextureGL(contextAttributes, flags, internalFormat));
 46     }
 47 
 48     virtual ~BitmapTextureGL();
 49 
</pre>
<hr />
<pre>
 61     bool isBackedByOpenGL() const override { return true; }
 62 
 63     RefPtr&lt;BitmapTexture&gt; applyFilters(TextureMapper&amp;, const FilterOperations&amp;) override;
 64     struct FilterInfo {
 65         RefPtr&lt;FilterOperation&gt; filter;
 66         unsigned pass;
 67         RefPtr&lt;BitmapTexture&gt; contentTexture;
 68 
 69         FilterInfo(RefPtr&lt;FilterOperation&gt;&amp;&amp; f = nullptr, unsigned p = 0, RefPtr&lt;BitmapTexture&gt;&amp;&amp; t = nullptr)
 70             : filter(WTFMove(f))
 71             , pass(p)
 72             , contentTexture(WTFMove(t))
 73             { }
 74     };
 75     const FilterInfo* filterInfo() const { return &amp;m_filterInfo; }
 76     ClipStack&amp; clipStack() { return m_clipStack; }
 77 
 78     GLint internalFormat() const { return m_internalFormat; }
 79 
 80     void copyFromExternalTexture(GLuint textureID);
<span class="line-added"> 81 #if USE(ANGLE)</span>
<span class="line-added"> 82     void setPendingContents(RefPtr&lt;Image&gt;&amp;&amp;);</span>
<span class="line-added"> 83     void updatePendingContents(const IntRect&amp; targetRect, const IntPoint&amp; offset);</span>
<span class="line-added"> 84 #endif</span>
 85 
 86     TextureMapperGL::Flags colorConvertFlags() const { return m_colorConvertFlags; }
 87 
 88 private:
 89     BitmapTextureGL(const TextureMapperContextAttributes&amp;, const Flags, GLint internalFormat);
 90 
 91     GLuint m_id { 0 };
 92     IntSize m_textureSize;
 93     IntRect m_dirtyRect;
 94     GLuint m_fbo { 0 };
 95     GLuint m_rbo { 0 };
 96     GLuint m_depthBufferObject { 0 };
 97     bool m_shouldClear { true };
 98     ClipStack m_clipStack;
 99     TextureMapperContextAttributes m_contextAttributes;
100     TextureMapperGL::Flags m_colorConvertFlags { TextureMapperGL::NoFlag };
101 
<span class="line-added">102 #if USE(ANGLE)</span>
<span class="line-added">103     RefPtr&lt;Image&gt; m_pendingContents { nullptr };</span>
<span class="line-added">104 #endif</span>
<span class="line-added">105 </span>
106     void clearIfNeeded();
107     void createFboIfNeeded();
108 
109     FilterInfo m_filterInfo;
110 
111     GLint m_internalFormat;
112     GLenum m_format;
113     GLenum m_type {
114 #if OS(DARWIN)
115         GL_UNSIGNED_INT_8_8_8_8_REV
116 #else
117         GL_UNSIGNED_BYTE
118 #endif
119     };
120 };
121 
122 BitmapTextureGL* toBitmapTextureGL(BitmapTexture*);
123 
124 }
125 
</pre>
</td>
</tr>
</table>
<center><a href="BitmapTextureGL.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="BitmapTextureJava.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SimpleLineLayoutCoverage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutFunctions.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayoutFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 129,12 ***</span>
              continue;
  
          String textWithHyphen;
          if (run.hasHyphen())
              textWithHyphen = run.textWithHyphen();
<span class="line-modified">!         // x position indicates the line offset from the rootbox. It&#39;s always 0 in case of simple line layout.</span>
<span class="line-modified">!         TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), 0, run.expansion(), run.expansionBehavior() };</span>
          textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
          FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
  
          textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
          textPainter.paint(textRun, rect, textOrigin);
<span class="line-new-header">--- 129,14 ---</span>
              continue;
  
          String textWithHyphen;
          if (run.hasHyphen())
              textWithHyphen = run.textWithHyphen();
<span class="line-modified">!         // xPos is relative to the line box&#39;s logical left.</span>
<span class="line-modified">!         // We don&#39;t have any line geometry here in SLL, so let&#39;s get the first run&#39;s logical left in the current line and use it as the line&#39;s logical left.</span>
<span class="line-added">+         auto lineLogicalLeft = (*resolver.rangeForLine(run.lineIndex()).begin()).logicalLeft();</span>
<span class="line-added">+         TextRun textRun { run.hasHyphen() ? textWithHyphen : run.text(), run.logicalLeft() - lineLogicalLeft, run.expansion(), run.expansionBehavior() };</span>
          textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
          FloatPoint textOrigin { rect.x() + paintOffset.x(), roundToDevicePixel(run.baselinePosition() + paintOffset.y(), deviceScaleFactor) };
  
          textPainter.setGlyphDisplayListIfNeeded(run.simpleRun(), paintInfo, style.fontCascade(), paintInfo.context(), textRun);
          textPainter.paint(textRun, rect, textOrigin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 181,54 ***</span>
          flow.addLayoutOverflow(LayoutRect(lineRect));
          flow.addVisualOverflow(visualOverflowRect);
      }
  }
  
<span class="line-removed">- IntRect computeBoundingBox(const RenderObject&amp; renderer, const Layout&amp; layout)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">-     FloatRect boundingBoxRect;</span>
<span class="line-removed">-     for (auto run : resolver.rangeForRenderer(renderer)) {</span>
<span class="line-removed">-         FloatRect rect = run.rect();</span>
<span class="line-removed">-         if (boundingBoxRect == FloatRect())</span>
<span class="line-removed">-             boundingBoxRect = rect;</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             boundingBoxRect.uniteEvenIfEmpty(rect);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return enclosingIntRect(boundingBoxRect);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IntPoint computeFirstRunLocation(const RenderObject&amp; renderer, const Layout&amp; layout)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">-     auto range = resolver.rangeForRenderer(renderer);</span>
<span class="line-removed">-     auto begin = range.begin();</span>
<span class="line-removed">-     if (begin == range.end())</span>
<span class="line-removed">-         return IntPoint(0, 0);</span>
<span class="line-removed">-     return flooredIntPoint((*begin).rect().location());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Vector&lt;IntRect&gt; collectAbsoluteRects(const RenderObject&amp; renderer, const Layout&amp; layout, const LayoutPoint&amp; accumulatedOffset)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Vector&lt;IntRect&gt; rects;</span>
<span class="line-removed">-     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">-     for (auto run : resolver.rangeForRenderer(renderer)) {</span>
<span class="line-removed">-         FloatRect rect = run.rect();</span>
<span class="line-removed">-         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return rects;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Vector&lt;FloatQuad&gt; collectAbsoluteQuads(const RenderObject&amp; renderer, const Layout&amp; layout, bool* wasFixed)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-removed">-     auto&amp; resolver = layout.runResolver();</span>
<span class="line-removed">-     for (auto run : resolver.rangeForRenderer(renderer))</span>
<span class="line-removed">-         quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));</span>
<span class="line-removed">-     return quads;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  unsigned textOffsetForPoint(const LayoutPoint&amp; point, const RenderText&amp; renderer, const Layout&amp; layout)
  {
      auto&amp; flow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());
      ASSERT(flow.firstChild() == flow.lastChild());
      auto&amp; resolver = layout.runResolver();
<span class="line-new-header">--- 183,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,16 ***</span>
      TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
      textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
      return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
  }
  
<span class="line-modified">! Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForRange(const RenderObject&amp; renderer, unsigned start, unsigned end, const Layout&amp; layout, bool* wasFixed)</span>
  {
      auto&amp; style = downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).style();
      Vector&lt;FloatQuad&gt; quads;
      auto&amp; resolver = layout.runResolver();
      for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {
          // This run is fully contained.
          if (start &lt;= run.start() &amp;&amp; end &gt;= run.end()) {
              quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
              continue;
          }
<span class="line-new-header">--- 198,18 ---</span>
      TextRun textRun(run.text(), run.logicalLeft(), run.expansion(), run.expansionBehavior());
      textRun.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
      return run.start() + style.fontCascade().offsetForPosition(textRun, point.x() - run.logicalLeft(), true);
  }
  
<span class="line-modified">! Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForRange(const RenderObject&amp; renderer, unsigned start, unsigned end, const Layout&amp; layout, bool ignoreEmptyTextSelections, bool* wasFixed)</span>
  {
      auto&amp; style = downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).style();
      Vector&lt;FloatQuad&gt; quads;
      auto&amp; resolver = layout.runResolver();
      for (auto run : resolver.rangeForRendererWithOffsets(renderer, start, end)) {
<span class="line-added">+         if (ignoreEmptyTextSelections &amp;&amp; run.start() == run.end())</span>
<span class="line-added">+             continue;</span>
          // This run is fully contained.
          if (start &lt;= run.start() &amp;&amp; end &gt;= run.end()) {
              quads.append(renderer.localToAbsoluteQuad(FloatQuad(run.rect()), UseTransforms, wasFixed));
              continue;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 265,20 ***</span>
          }
          auto localStart = std::max(run.start(), start) - run.start();
          auto localEnd = std::min(run.end(), end) - run.start();
          ASSERT(localStart &lt;= localEnd);
          style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);
          quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
      }
      return quads;
  }
  
<span class="line-removed">- const RenderObject&amp; rendererForPosition(const FlowContents&amp; flowContents, unsigned position)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return flowContents.segmentForPosition(position).renderer;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void simpleLineLayoutWillBeDeleted(const Layout&amp; layout)
  {
      for (unsigned i = 0; i &lt; layout.runCount(); ++i)
          TextPainter::removeGlyphDisplayList(layout.runAt(i));
  }
<span class="line-new-header">--- 225,16 ---</span>
          }
          auto localStart = std::max(run.start(), start) - run.start();
          auto localEnd = std::min(run.end(), end) - run.start();
          ASSERT(localStart &lt;= localEnd);
          style.fontCascade().adjustSelectionRectForText(textRun, runRect, localStart, localEnd);
<span class="line-added">+         runRect = snappedSelectionRect(runRect, run.logicalRight(), runRect.y(), runRect.height(), true /* isHorizontal */);</span>
          quads.append(renderer.localToAbsoluteQuad(FloatQuad(runRect), UseTransforms, wasFixed));
      }
      return quads;
  }
  
  void simpleLineLayoutWillBeDeleted(const Layout&amp; layout)
  {
      for (unsigned i = 0; i &lt; layout.runCount(); ++i)
          TextPainter::removeGlyphDisplayList(layout.runAt(i));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,20 ***</span>
      printedCharacters = 0;
      while (++printedCharacters &lt;= depth * 2)
          stream &lt;&lt; &quot; &quot;;
  }
  
<span class="line-modified">! void outputLineLayoutForFlow(TextStream&amp; stream, const RenderBlockFlow&amp; flow, const Layout&amp; layout, int depth)</span>
  {
      int printedCharacters = 0;
      printPrefix(stream, printedCharacters, depth);
  
      stream &lt;&lt; &quot;SimpleLineLayout (&quot; &lt;&lt; layout.lineCount() &lt;&lt; &quot; lines, &quot; &lt;&lt; layout.runCount() &lt;&lt; &quot; runs) (&quot; &lt;&lt; &amp;layout &lt;&lt; &quot;)&quot;;
      stream.nextLine();
      ++depth;
  
<span class="line-modified">!     for (auto run : runResolver(flow, layout)) {</span>
          FloatRect rect = run.rect();
          printPrefix(stream, printedCharacters, depth);
          if (run.start() &lt; run.end()) {
              stream &lt;&lt; &quot;line &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect &lt;&lt; &quot; \&quot;&quot; &lt;&lt; run.text().toStringWithoutCopying().utf8().data() &lt;&lt; &quot;\&quot;&quot;;
          } else {
<span class="line-new-header">--- 346,20 ---</span>
      printedCharacters = 0;
      while (++printedCharacters &lt;= depth * 2)
          stream &lt;&lt; &quot; &quot;;
  }
  
<span class="line-modified">! void outputLineLayoutForFlow(TextStream&amp; stream, const RenderBlockFlow&amp;, const Layout&amp; layout, int depth)</span>
  {
      int printedCharacters = 0;
      printPrefix(stream, printedCharacters, depth);
  
      stream &lt;&lt; &quot;SimpleLineLayout (&quot; &lt;&lt; layout.lineCount() &lt;&lt; &quot; lines, &quot; &lt;&lt; layout.runCount() &lt;&lt; &quot; runs) (&quot; &lt;&lt; &amp;layout &lt;&lt; &quot;)&quot;;
      stream.nextLine();
      ++depth;
  
<span class="line-modified">!     for (auto run : layout.runResolver()) {</span>
          FloatRect rect = run.rect();
          printPrefix(stream, printedCharacters, depth);
          if (run.start() &lt; run.end()) {
              stream &lt;&lt; &quot;line &quot; &lt;&lt; run.lineIndex() &lt;&lt; &quot; run(&quot; &lt;&lt; run.start() &lt;&lt; &quot;, &quot; &lt;&lt; run.end() &lt;&lt; &quot;) &quot; &lt;&lt; rect &lt;&lt; &quot; \&quot;&quot; &lt;&lt; run.text().toStringWithoutCopying().utf8().data() &lt;&lt; &quot;\&quot;&quot;;
          } else {
</pre>
<center><a href="SimpleLineLayoutCoverage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SimpleLineLayoutFunctions.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
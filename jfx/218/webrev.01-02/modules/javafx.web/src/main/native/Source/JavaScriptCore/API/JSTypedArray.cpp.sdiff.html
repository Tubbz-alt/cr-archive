<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSTypedArray.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSScriptRef.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSValueRef.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSTypedArray.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 82     case kJSTypedArrayTypeUint8Array:
 83         return TypeUint8;
 84     case kJSTypedArrayTypeUint8ClampedArray:
 85         return TypeUint8Clamped;
 86     case kJSTypedArrayTypeInt16Array:
 87         return TypeInt16;
 88     case kJSTypedArrayTypeUint16Array:
 89         return TypeUint16;
 90     case kJSTypedArrayTypeInt32Array:
 91         return TypeInt32;
 92     case kJSTypedArrayTypeUint32Array:
 93         return TypeUint32;
 94     case kJSTypedArrayTypeFloat32Array:
 95         return TypeFloat32;
 96     case kJSTypedArrayTypeFloat64Array:
 97         return TypeFloat64;
 98     }
 99     RELEASE_ASSERT_NOT_REACHED();
100 }
101 
<span class="line-modified">102 static JSObject* createTypedArray(ExecState* exec, JSTypedArrayType type, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer, size_t offset, size_t length)</span>
103 {
<span class="line-modified">104     VM&amp; vm = exec-&gt;vm();</span>
105     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-removed">106     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
107     if (!buffer) {
<span class="line-modified">108         throwOutOfMemoryError(exec, scope);</span>
109         return nullptr;
110     }
111     switch (type) {
112     case kJSTypedArrayTypeInt8Array:
<span class="line-modified">113         return JSInt8Array::create(exec, globalObject-&gt;typedArrayStructure(TypeInt8), WTFMove(buffer), offset, length);</span>
114     case kJSTypedArrayTypeInt16Array:
<span class="line-modified">115         return JSInt16Array::create(exec, globalObject-&gt;typedArrayStructure(TypeInt16), WTFMove(buffer), offset, length);</span>
116     case kJSTypedArrayTypeInt32Array:
<span class="line-modified">117         return JSInt32Array::create(exec, globalObject-&gt;typedArrayStructure(TypeInt32), WTFMove(buffer), offset, length);</span>
118     case kJSTypedArrayTypeUint8Array:
<span class="line-modified">119         return JSUint8Array::create(exec, globalObject-&gt;typedArrayStructure(TypeUint8), WTFMove(buffer), offset, length);</span>
120     case kJSTypedArrayTypeUint8ClampedArray:
<span class="line-modified">121         return JSUint8ClampedArray::create(exec, globalObject-&gt;typedArrayStructure(TypeUint8Clamped), WTFMove(buffer), offset, length);</span>
122     case kJSTypedArrayTypeUint16Array:
<span class="line-modified">123         return JSUint16Array::create(exec, globalObject-&gt;typedArrayStructure(TypeUint16), WTFMove(buffer), offset, length);</span>
124     case kJSTypedArrayTypeUint32Array:
<span class="line-modified">125         return JSUint32Array::create(exec, globalObject-&gt;typedArrayStructure(TypeUint32), WTFMove(buffer), offset, length);</span>
126     case kJSTypedArrayTypeFloat32Array:
<span class="line-modified">127         return JSFloat32Array::create(exec, globalObject-&gt;typedArrayStructure(TypeFloat32), WTFMove(buffer), offset, length);</span>
128     case kJSTypedArrayTypeFloat64Array:
<span class="line-modified">129         return JSFloat64Array::create(exec, globalObject-&gt;typedArrayStructure(TypeFloat64), WTFMove(buffer), offset, length);</span>
130     case kJSTypedArrayTypeArrayBuffer:
131     case kJSTypedArrayTypeNone:
132         RELEASE_ASSERT_NOT_REACHED();
133     }
134     return nullptr;
135 }
136 
137 // Implementations of the API functions.
138 
139 JSTypedArrayType JSValueGetTypedArrayType(JSContextRef ctx, JSValueRef valueRef, JSValueRef*)
140 {
141 
<span class="line-modified">142     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">143     VM&amp; vm = exec-&gt;vm();</span>
144     JSLockHolder locker(vm);
145 
<span class="line-modified">146     JSValue value = toJS(exec, valueRef);</span>
147     if (!value.isObject())
148         return kJSTypedArrayTypeNone;
149     JSObject* object = value.getObject();
150 
151     if (jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
152         return kJSTypedArrayTypeArrayBuffer;
153 
154     return toJSTypedArrayType(object-&gt;classInfo(vm)-&gt;typedArrayStorageType);
155 }
156 
157 JSObjectRef JSObjectMakeTypedArray(JSContextRef ctx, JSTypedArrayType arrayType, size_t length, JSValueRef* exception)
158 {
<span class="line-modified">159     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">160     VM&amp; vm = exec-&gt;vm();</span>
161     JSLockHolder locker(vm);
162     auto scope = DECLARE_CATCH_SCOPE(vm);
163 
164     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
165         return nullptr;
166 
167     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
168 
169     auto buffer = ArrayBuffer::tryCreate(length, elementByteSize);
<span class="line-modified">170     JSObject* result = createTypedArray(exec, arrayType, WTFMove(buffer), 0, length);</span>
<span class="line-modified">171     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
172         return nullptr;
173     return toRef(result);
174 }
175 
176 JSObjectRef JSObjectMakeTypedArrayWithBytesNoCopy(JSContextRef ctx, JSTypedArrayType arrayType, void* bytes, size_t length, JSTypedArrayBytesDeallocator destructor, void* destructorContext, JSValueRef* exception)
177 {
<span class="line-modified">178     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">179     VM&amp; vm = exec-&gt;vm();</span>
180     JSLockHolder locker(vm);
181     auto scope = DECLARE_CATCH_SCOPE(vm);
182 
183     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
184         return nullptr;
185 
186     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
187 
<span class="line-modified">188     auto buffer = ArrayBuffer::createFromBytes(bytes, length, [=](void* p) {</span>
189         if (destructor)
190             destructor(p, destructorContext);
<span class="line-modified">191     });</span>
<span class="line-modified">192     JSObject* result = createTypedArray(exec, arrayType, WTFMove(buffer), 0, length / elementByteSize);</span>
<span class="line-modified">193     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
194         return nullptr;
195     return toRef(result);
196 }
197 
198 JSObjectRef JSObjectMakeTypedArrayWithArrayBuffer(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, JSValueRef* exception)
199 {
<span class="line-modified">200     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">201     VM&amp; vm = exec-&gt;vm();</span>
202     JSLockHolder locker(vm);
203     auto scope = DECLARE_CATCH_SCOPE(vm);
204 
205     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
206         return nullptr;
207 
208     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
209     if (!jsBuffer) {
<span class="line-modified">210         setException(exec, exception, createTypeError(exec, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));</span>
211         return nullptr;
212     }
213 
214     RefPtr&lt;ArrayBuffer&gt; buffer = jsBuffer-&gt;impl();
215     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
216 
<span class="line-modified">217     JSObject* result = createTypedArray(exec, arrayType, WTFMove(buffer), 0, buffer-&gt;byteLength() / elementByteSize);</span>
<span class="line-modified">218     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
219         return nullptr;
220     return toRef(result);
221 }
222 
223 JSObjectRef JSObjectMakeTypedArrayWithArrayBufferAndOffset(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, size_t offset, size_t length, JSValueRef* exception)
224 {
<span class="line-modified">225     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">226     VM&amp; vm = exec-&gt;vm();</span>
227     JSLockHolder locker(vm);
228     auto scope = DECLARE_CATCH_SCOPE(vm);
229 
230     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
231         return nullptr;
232 
233     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
234     if (!jsBuffer) {
<span class="line-modified">235         setException(exec, exception, createTypeError(exec, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));</span>
236         return nullptr;
237     }
238 
<span class="line-modified">239     JSObject* result = createTypedArray(exec, arrayType, jsBuffer-&gt;impl(), offset, length);</span>
<span class="line-modified">240     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
241         return nullptr;
242     return toRef(result);
243 }
244 
245 void* JSObjectGetTypedArrayBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
246 {
<span class="line-modified">247     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">248     VM&amp; vm = exec-&gt;vm();</span>
249     JSLockHolder locker(vm);
250     JSObject* object = toJS(objectRef);
251 
252     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object)) {
253         ArrayBuffer* buffer = typedArray-&gt;possiblySharedBuffer();
254         buffer-&gt;pinAndLock();
255         return buffer-&gt;data();
256     }
257     return nullptr;
258 }
259 
260 size_t JSObjectGetTypedArrayLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
261 {
<span class="line-modified">262     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">263     VM&amp; vm = exec-&gt;vm();</span>
264     JSObject* object = toJS(objectRef);
265 
266     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
267         return typedArray-&gt;length();
268 
269     return 0;
270 }
271 
272 size_t JSObjectGetTypedArrayByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
273 {
<span class="line-modified">274     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">275     VM&amp; vm = exec-&gt;vm();</span>
276     JSObject* object = toJS(objectRef);
277 
278     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
279         return typedArray-&gt;length() * elementSize(typedArray-&gt;classInfo(vm)-&gt;typedArrayStorageType);
280 
281     return 0;
282 }
283 
284 size_t JSObjectGetTypedArrayByteOffset(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
285 {
<span class="line-modified">286     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">287     VM&amp; vm = exec-&gt;vm();</span>
288     JSObject* object = toJS(objectRef);
289 
290     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
291         return typedArray-&gt;byteOffset();
292 
293     return 0;
294 }
295 
296 JSObjectRef JSObjectGetTypedArrayBuffer(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
297 {
<span class="line-modified">298     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">299     VM&amp; vm = exec-&gt;vm();</span>
300     JSLockHolder locker(vm);
301     JSObject* object = toJS(objectRef);
302 
303     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
<span class="line-modified">304         return toRef(vm.m_typedArrayController-&gt;toJS(exec, typedArray-&gt;globalObject(vm), typedArray-&gt;possiblySharedBuffer()));</span>
305 
306     return nullptr;
307 }
308 
309 JSObjectRef JSObjectMakeArrayBufferWithBytesNoCopy(JSContextRef ctx, void* bytes, size_t byteLength, JSTypedArrayBytesDeallocator bytesDeallocator, void* deallocatorContext, JSValueRef* exception)
310 {
<span class="line-modified">311     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">312     VM&amp; vm = exec-&gt;vm();</span>
313     JSLockHolder locker(vm);
314     auto scope = DECLARE_CATCH_SCOPE(vm);
315 
<span class="line-modified">316     auto buffer = ArrayBuffer::createFromBytes(bytes, byteLength, [=](void* p) {</span>
317         if (bytesDeallocator)
318             bytesDeallocator(p, deallocatorContext);
<span class="line-modified">319     });</span>
320 
<span class="line-modified">321     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(ArrayBufferSharingMode::Default), WTFMove(buffer));</span>
<span class="line-modified">322     if (handleExceptionIfNeeded(scope, exec, exception) == ExceptionStatus::DidThrow)</span>
323         return nullptr;
324 
325     return toRef(jsBuffer);
326 }
327 
328 void* JSObjectGetArrayBufferBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef* exception)
329 {
<span class="line-modified">330     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">331     VM&amp; vm = exec-&gt;vm();</span>
332     JSLockHolder locker(vm);
333     JSObject* object = toJS(objectRef);
334 
335     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object)) {
336         ArrayBuffer* buffer = jsBuffer-&gt;impl();
337         if (buffer-&gt;isWasmMemory()) {
<span class="line-modified">338             setException(exec, exception, createTypeError(exec, &quot;Cannot get the backing buffer for a WebAssembly.Memory&quot;_s));</span>
339             return nullptr;
340         }
341 
342         buffer-&gt;pinAndLock();
343         return buffer-&gt;data();
344     }
345     return nullptr;
346 }
347 
348 size_t JSObjectGetArrayBufferByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
349 {
<span class="line-modified">350     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">351     VM&amp; vm = exec-&gt;vm();</span>
352     JSObject* object = toJS(objectRef);
353 
354     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
355         return jsBuffer-&gt;impl()-&gt;byteLength();
356 
357     return 0;
358 }
</pre>
</td>
<td>
<hr />
<pre>
 82     case kJSTypedArrayTypeUint8Array:
 83         return TypeUint8;
 84     case kJSTypedArrayTypeUint8ClampedArray:
 85         return TypeUint8Clamped;
 86     case kJSTypedArrayTypeInt16Array:
 87         return TypeInt16;
 88     case kJSTypedArrayTypeUint16Array:
 89         return TypeUint16;
 90     case kJSTypedArrayTypeInt32Array:
 91         return TypeInt32;
 92     case kJSTypedArrayTypeUint32Array:
 93         return TypeUint32;
 94     case kJSTypedArrayTypeFloat32Array:
 95         return TypeFloat32;
 96     case kJSTypedArrayTypeFloat64Array:
 97         return TypeFloat64;
 98     }
 99     RELEASE_ASSERT_NOT_REACHED();
100 }
101 
<span class="line-modified">102 static JSObject* createTypedArray(JSGlobalObject* globalObject, JSTypedArrayType type, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer, size_t offset, size_t length)</span>
103 {
<span class="line-modified">104     VM&amp; vm = globalObject-&gt;vm();</span>
105     auto scope = DECLARE_THROW_SCOPE(vm);

106     if (!buffer) {
<span class="line-modified">107         throwOutOfMemoryError(globalObject, scope);</span>
108         return nullptr;
109     }
110     switch (type) {
111     case kJSTypedArrayTypeInt8Array:
<span class="line-modified">112         return JSInt8Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt8), WTFMove(buffer), offset, length);</span>
113     case kJSTypedArrayTypeInt16Array:
<span class="line-modified">114         return JSInt16Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt16), WTFMove(buffer), offset, length);</span>
115     case kJSTypedArrayTypeInt32Array:
<span class="line-modified">116         return JSInt32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeInt32), WTFMove(buffer), offset, length);</span>
117     case kJSTypedArrayTypeUint8Array:
<span class="line-modified">118         return JSUint8Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint8), WTFMove(buffer), offset, length);</span>
119     case kJSTypedArrayTypeUint8ClampedArray:
<span class="line-modified">120         return JSUint8ClampedArray::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint8Clamped), WTFMove(buffer), offset, length);</span>
121     case kJSTypedArrayTypeUint16Array:
<span class="line-modified">122         return JSUint16Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint16), WTFMove(buffer), offset, length);</span>
123     case kJSTypedArrayTypeUint32Array:
<span class="line-modified">124         return JSUint32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeUint32), WTFMove(buffer), offset, length);</span>
125     case kJSTypedArrayTypeFloat32Array:
<span class="line-modified">126         return JSFloat32Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeFloat32), WTFMove(buffer), offset, length);</span>
127     case kJSTypedArrayTypeFloat64Array:
<span class="line-modified">128         return JSFloat64Array::create(globalObject, globalObject-&gt;typedArrayStructure(TypeFloat64), WTFMove(buffer), offset, length);</span>
129     case kJSTypedArrayTypeArrayBuffer:
130     case kJSTypedArrayTypeNone:
131         RELEASE_ASSERT_NOT_REACHED();
132     }
133     return nullptr;
134 }
135 
136 // Implementations of the API functions.
137 
138 JSTypedArrayType JSValueGetTypedArrayType(JSContextRef ctx, JSValueRef valueRef, JSValueRef*)
139 {
140 
<span class="line-modified">141     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">142     VM&amp; vm = globalObject-&gt;vm();</span>
143     JSLockHolder locker(vm);
144 
<span class="line-modified">145     JSValue value = toJS(globalObject, valueRef);</span>
146     if (!value.isObject())
147         return kJSTypedArrayTypeNone;
148     JSObject* object = value.getObject();
149 
150     if (jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
151         return kJSTypedArrayTypeArrayBuffer;
152 
153     return toJSTypedArrayType(object-&gt;classInfo(vm)-&gt;typedArrayStorageType);
154 }
155 
156 JSObjectRef JSObjectMakeTypedArray(JSContextRef ctx, JSTypedArrayType arrayType, size_t length, JSValueRef* exception)
157 {
<span class="line-modified">158     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">159     VM&amp; vm = globalObject-&gt;vm();</span>
160     JSLockHolder locker(vm);
161     auto scope = DECLARE_CATCH_SCOPE(vm);
162 
163     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
164         return nullptr;
165 
166     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
167 
168     auto buffer = ArrayBuffer::tryCreate(length, elementByteSize);
<span class="line-modified">169     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, length);</span>
<span class="line-modified">170     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
171         return nullptr;
172     return toRef(result);
173 }
174 
175 JSObjectRef JSObjectMakeTypedArrayWithBytesNoCopy(JSContextRef ctx, JSTypedArrayType arrayType, void* bytes, size_t length, JSTypedArrayBytesDeallocator destructor, void* destructorContext, JSValueRef* exception)
176 {
<span class="line-modified">177     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">178     VM&amp; vm = globalObject-&gt;vm();</span>
179     JSLockHolder locker(vm);
180     auto scope = DECLARE_CATCH_SCOPE(vm);
181 
182     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
183         return nullptr;
184 
185     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
186 
<span class="line-modified">187     auto buffer = ArrayBuffer::createFromBytes(bytes, length, createSharedTask&lt;void(void*)&gt;([=](void* p) {</span>
188         if (destructor)
189             destructor(p, destructorContext);
<span class="line-modified">190     }));</span>
<span class="line-modified">191     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, length / elementByteSize);</span>
<span class="line-modified">192     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
193         return nullptr;
194     return toRef(result);
195 }
196 
197 JSObjectRef JSObjectMakeTypedArrayWithArrayBuffer(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, JSValueRef* exception)
198 {
<span class="line-modified">199     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">200     VM&amp; vm = globalObject-&gt;vm();</span>
201     JSLockHolder locker(vm);
202     auto scope = DECLARE_CATCH_SCOPE(vm);
203 
204     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
205         return nullptr;
206 
207     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
208     if (!jsBuffer) {
<span class="line-modified">209         setException(ctx, exception, createTypeError(globalObject, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));</span>
210         return nullptr;
211     }
212 
213     RefPtr&lt;ArrayBuffer&gt; buffer = jsBuffer-&gt;impl();
214     unsigned elementByteSize = elementSize(toTypedArrayType(arrayType));
215 
<span class="line-modified">216     JSObject* result = createTypedArray(globalObject, arrayType, WTFMove(buffer), 0, buffer-&gt;byteLength() / elementByteSize);</span>
<span class="line-modified">217     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
218         return nullptr;
219     return toRef(result);
220 }
221 
222 JSObjectRef JSObjectMakeTypedArrayWithArrayBufferAndOffset(JSContextRef ctx, JSTypedArrayType arrayType, JSObjectRef jsBufferRef, size_t offset, size_t length, JSValueRef* exception)
223 {
<span class="line-modified">224     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">225     VM&amp; vm = globalObject-&gt;vm();</span>
226     JSLockHolder locker(vm);
227     auto scope = DECLARE_CATCH_SCOPE(vm);
228 
229     if (arrayType == kJSTypedArrayTypeNone || arrayType == kJSTypedArrayTypeArrayBuffer)
230         return nullptr;
231 
232     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, toJS(jsBufferRef));
233     if (!jsBuffer) {
<span class="line-modified">234         setException(ctx, exception, createTypeError(globalObject, &quot;JSObjectMakeTypedArrayWithArrayBuffer expects buffer to be an Array Buffer object&quot;));</span>
235         return nullptr;
236     }
237 
<span class="line-modified">238     JSObject* result = createTypedArray(globalObject, arrayType, jsBuffer-&gt;impl(), offset, length);</span>
<span class="line-modified">239     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
240         return nullptr;
241     return toRef(result);
242 }
243 
244 void* JSObjectGetTypedArrayBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
245 {
<span class="line-modified">246     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">247     VM&amp; vm = globalObject-&gt;vm();</span>
248     JSLockHolder locker(vm);
249     JSObject* object = toJS(objectRef);
250 
251     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object)) {
252         ArrayBuffer* buffer = typedArray-&gt;possiblySharedBuffer();
253         buffer-&gt;pinAndLock();
254         return buffer-&gt;data();
255     }
256     return nullptr;
257 }
258 
259 size_t JSObjectGetTypedArrayLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
260 {
<span class="line-modified">261     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">262     VM&amp; vm = globalObject-&gt;vm();</span>
263     JSObject* object = toJS(objectRef);
264 
265     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
266         return typedArray-&gt;length();
267 
268     return 0;
269 }
270 
271 size_t JSObjectGetTypedArrayByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
272 {
<span class="line-modified">273     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">274     VM&amp; vm = globalObject-&gt;vm();</span>
275     JSObject* object = toJS(objectRef);
276 
277     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
278         return typedArray-&gt;length() * elementSize(typedArray-&gt;classInfo(vm)-&gt;typedArrayStorageType);
279 
280     return 0;
281 }
282 
283 size_t JSObjectGetTypedArrayByteOffset(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
284 {
<span class="line-modified">285     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">286     VM&amp; vm = globalObject-&gt;vm();</span>
287     JSObject* object = toJS(objectRef);
288 
289     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
290         return typedArray-&gt;byteOffset();
291 
292     return 0;
293 }
294 
295 JSObjectRef JSObjectGetTypedArrayBuffer(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
296 {
<span class="line-modified">297     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">298     VM&amp; vm = globalObject-&gt;vm();</span>
299     JSLockHolder locker(vm);
300     JSObject* object = toJS(objectRef);
301 
302     if (JSArrayBufferView* typedArray = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, object))
<span class="line-modified">303         return toRef(vm.m_typedArrayController-&gt;toJS(globalObject, typedArray-&gt;globalObject(vm), typedArray-&gt;possiblySharedBuffer()));</span>
304 
305     return nullptr;
306 }
307 
308 JSObjectRef JSObjectMakeArrayBufferWithBytesNoCopy(JSContextRef ctx, void* bytes, size_t byteLength, JSTypedArrayBytesDeallocator bytesDeallocator, void* deallocatorContext, JSValueRef* exception)
309 {
<span class="line-modified">310     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">311     VM&amp; vm = globalObject-&gt;vm();</span>
312     JSLockHolder locker(vm);
313     auto scope = DECLARE_CATCH_SCOPE(vm);
314 
<span class="line-modified">315     auto buffer = ArrayBuffer::createFromBytes(bytes, byteLength, createSharedTask&lt;void(void*)&gt;([=](void* p) {</span>
316         if (bytesDeallocator)
317             bytesDeallocator(p, deallocatorContext);
<span class="line-modified">318     }));</span>
319 
<span class="line-modified">320     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(ArrayBufferSharingMode::Default), WTFMove(buffer));</span>
<span class="line-modified">321     if (handleExceptionIfNeeded(scope, ctx, exception) == ExceptionStatus::DidThrow)</span>
322         return nullptr;
323 
324     return toRef(jsBuffer);
325 }
326 
327 void* JSObjectGetArrayBufferBytesPtr(JSContextRef ctx, JSObjectRef objectRef, JSValueRef* exception)
328 {
<span class="line-modified">329     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">330     VM&amp; vm = globalObject-&gt;vm();</span>
331     JSLockHolder locker(vm);
332     JSObject* object = toJS(objectRef);
333 
334     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object)) {
335         ArrayBuffer* buffer = jsBuffer-&gt;impl();
336         if (buffer-&gt;isWasmMemory()) {
<span class="line-modified">337             setException(ctx, exception, createTypeError(globalObject, &quot;Cannot get the backing buffer for a WebAssembly.Memory&quot;_s));</span>
338             return nullptr;
339         }
340 
341         buffer-&gt;pinAndLock();
342         return buffer-&gt;data();
343     }
344     return nullptr;
345 }
346 
347 size_t JSObjectGetArrayBufferByteLength(JSContextRef ctx, JSObjectRef objectRef, JSValueRef*)
348 {
<span class="line-modified">349     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">350     VM&amp; vm = globalObject-&gt;vm();</span>
351     JSObject* object = toJS(objectRef);
352 
353     if (JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, object))
354         return jsBuffer-&gt;impl()-&gt;byteLength();
355 
356     return 0;
357 }
</pre>
</td>
</tr>
</table>
<center><a href="JSScriptRef.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSValueRef.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
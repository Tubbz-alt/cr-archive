diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringConstructor.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringConstructor.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringConstructor.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/StringConstructor.cpp
@@ -29,12 +29,12 @@
 #include "StringPrototype.h"
 #include <wtf/text/StringBuilder.h>
 
 namespace JSC {
 
-static EncodedJSValue JSC_HOST_CALL stringFromCharCode(ExecState*);
-static EncodedJSValue JSC_HOST_CALL stringFromCodePoint(ExecState*);
+static EncodedJSValue JSC_HOST_CALL stringFromCharCode(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL stringFromCodePoint(JSGlobalObject*, CallFrame*);
 
 }
 
 #include "StringConstructor.lut.h"
 
@@ -51,84 +51,84 @@
 */
 
 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(StringConstructor);
 
 
-static EncodedJSValue JSC_HOST_CALL callStringConstructor(ExecState*);
-static EncodedJSValue JSC_HOST_CALL constructWithStringConstructor(ExecState*);
+static EncodedJSValue JSC_HOST_CALL callStringConstructor(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL constructWithStringConstructor(JSGlobalObject*, CallFrame*);
 
 StringConstructor::StringConstructor(VM& vm, Structure* structure)
     : InternalFunction(vm, structure, callStringConstructor, constructWithStringConstructor)
 {
 }
 
 void StringConstructor::finishCreation(VM& vm, StringPrototype* stringPrototype)
 {
-    Base::finishCreation(vm, vm.propertyNames->String.string(), NameVisibility::Visible, NameAdditionMode::WithoutStructureTransition);
+    Base::finishCreation(vm, vm.propertyNames->String.string(), NameAdditionMode::WithoutStructureTransition);
     putDirectWithoutTransition(vm, vm.propertyNames->prototype, stringPrototype, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::DontDelete);
     putDirectWithoutTransition(vm, vm.propertyNames->length, jsNumber(1), PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum);
 }
 
 // ------------------------------ Functions --------------------------------
 
-static EncodedJSValue JSC_HOST_CALL stringFromCharCode(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL stringFromCharCode(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    unsigned length = exec->argumentCount();
+    unsigned length = callFrame->argumentCount();
     if (LIKELY(length == 1)) {
         scope.release();
-        unsigned code = exec->uncheckedArgument(0).toUInt32(exec);
+        unsigned code = callFrame->uncheckedArgument(0).toUInt32(globalObject);
         // Not checking for an exception here is ok because jsSingleCharacterString will just fetch an unused string if there's an exception.
         return JSValue::encode(jsSingleCharacterString(vm, code));
     }
 
     LChar* buf8Bit;
     auto impl8Bit = StringImpl::createUninitialized(length, buf8Bit);
     for (unsigned i = 0; i < length; ++i) {
-        UChar character = static_cast<UChar>(exec->uncheckedArgument(i).toUInt32(exec));
+        UChar character = static_cast<UChar>(callFrame->uncheckedArgument(i).toUInt32(globalObject));
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         if (UNLIKELY(!isLatin1(character))) {
             UChar* buf16Bit;
             auto impl16Bit = StringImpl::createUninitialized(length, buf16Bit);
             StringImpl::copyCharacters(buf16Bit, buf8Bit, i);
             buf16Bit[i] = character;
             ++i;
             for (; i < length; ++i) {
-                buf16Bit[i] = static_cast<UChar>(exec->uncheckedArgument(i).toUInt32(exec));
+                buf16Bit[i] = static_cast<UChar>(callFrame->uncheckedArgument(i).toUInt32(globalObject));
                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
             }
             RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, WTFMove(impl16Bit))));
         }
         buf8Bit[i] = static_cast<LChar>(character);
     }
     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, WTFMove(impl8Bit))));
 }
 
-JSString* JSC_HOST_CALL stringFromCharCode(ExecState* exec, int32_t arg)
+JSString* JSC_HOST_CALL stringFromCharCode(JSGlobalObject* globalObject, int32_t arg)
 {
-    return jsSingleCharacterString(exec->vm(), arg);
+    return jsSingleCharacterString(globalObject->vm(), arg);
 }
 
-static EncodedJSValue JSC_HOST_CALL stringFromCodePoint(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL stringFromCodePoint(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    unsigned length = exec->argumentCount();
+    unsigned length = callFrame->argumentCount();
     StringBuilder builder;
     builder.reserveCapacity(length);
 
     for (unsigned i = 0; i < length; ++i) {
-        double codePointAsDouble = exec->uncheckedArgument(i).toNumber(exec);
+        double codePointAsDouble = callFrame->uncheckedArgument(i).toNumber(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
         uint32_t codePoint = static_cast<uint32_t>(codePointAsDouble);
 
         if (codePoint != codePointAsDouble || codePoint > UCHAR_MAX_VALUE)
-            return throwVMError(exec, scope, createRangeError(exec, "Arguments contain a value that is out of range of code points"_s));
+            return throwVMError(globalObject, scope, createRangeError(globalObject, "Arguments contain a value that is out of range of code points"_s));
 
         if (U_IS_BMP(codePoint))
             builder.append(static_cast<UChar>(codePoint));
         else {
             builder.append(U16_LEAD(codePoint));
@@ -137,38 +137,37 @@
     }
 
     RELEASE_AND_RETURN(scope, JSValue::encode(jsString(vm, builder.toString())));
 }
 
-static EncodedJSValue JSC_HOST_CALL constructWithStringConstructor(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL constructWithStringConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    JSGlobalObject* globalObject = jsCast<InternalFunction*>(exec->jsCallee())->globalObject(vm);
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    Structure* structure = InternalFunction::createSubclassStructure(exec, exec->newTarget(), globalObject->stringObjectStructure());
+    Structure* structure = InternalFunction::createSubclassStructure(globalObject, callFrame->jsCallee(), callFrame->newTarget(), globalObject->stringObjectStructure());
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    if (!exec->argumentCount())
+    if (!callFrame->argumentCount())
         return JSValue::encode(StringObject::create(vm, structure));
-    JSString* str = exec->uncheckedArgument(0).toString(exec);
+    JSString* str = callFrame->uncheckedArgument(0).toString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     return JSValue::encode(StringObject::create(vm, structure, str));
 }
 
-JSString* stringConstructor(ExecState* exec, JSValue argument)
+JSString* stringConstructor(JSGlobalObject* globalObject, JSValue argument)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     if (argument.isSymbol())
         return jsNontrivialString(vm, asSymbol(argument)->descriptiveString());
-    return argument.toString(exec);
+    return argument.toString(globalObject);
 }
 
-static EncodedJSValue JSC_HOST_CALL callStringConstructor(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL callStringConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    if (!exec->argumentCount())
+    VM& vm = globalObject->vm();
+    if (!callFrame->argumentCount())
         return JSValue::encode(jsEmptyString(vm));
-    return JSValue::encode(stringConstructor(exec, exec->uncheckedArgument(0)));
+    return JSValue::encode(stringConstructor(globalObject, callFrame->uncheckedArgument(0)));
 }
 
 } // namespace JSC

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPredictionInjectionPhase.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPromotedHeapLocation.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -177,10 +177,11 @@</span>
              else
                  changed |= mergePrediction(SpecBytecodeNumber);
              break;
          }
  
<span class="udiff-line-added">+         case ValueBitRShift:</span>
          case ValueBitLShift: {
              SpeculatedType left = node-&gt;child1()-&gt;prediction();
              SpeculatedType right = node-&gt;child2()-&gt;prediction();
  
              if (left &amp;&amp; right) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,10 +292,35 @@</span>
              }
  
              break;
          }
  
<span class="udiff-line-added">+         case Inc:</span>
<span class="udiff-line-added">+         case Dec: {</span>
<span class="udiff-line-added">+             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             if (prediction) {</span>
<span class="udiff-line-added">+                 if (isFullNumberOrBooleanSpeculationExpectingDefined(prediction)) {</span>
<span class="udiff-line-added">+                     if (m_graph.unaryArithShouldSpeculateInt32(node, m_pass))</span>
<span class="udiff-line-added">+                         changed |= mergePrediction(SpecInt32Only);</span>
<span class="udiff-line-added">+                     else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))</span>
<span class="udiff-line-added">+                         changed |= mergePrediction(SpecInt52Any);</span>
<span class="udiff-line-added">+                     else</span>
<span class="udiff-line-added">+                         changed |= mergePrediction(speculatedDoubleTypeForPrediction(prediction));</span>
<span class="udiff-line-added">+                 } else if (isBigIntSpeculation(prediction))</span>
<span class="udiff-line-added">+                     changed |= mergePrediction(SpecBigInt);</span>
<span class="udiff-line-added">+                 else {</span>
<span class="udiff-line-added">+                     changed |= mergePrediction(SpecInt32Only);</span>
<span class="udiff-line-added">+                     if (node-&gt;mayHaveDoubleResult())</span>
<span class="udiff-line-added">+                         changed |= mergePrediction(SpecBytecodeDouble);</span>
<span class="udiff-line-added">+                     if (node-&gt;mayHaveBigIntResult())</span>
<span class="udiff-line-added">+                         changed |= mergePrediction(SpecBigInt);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case ValuePow: {
              SpeculatedType left = node-&gt;child1()-&gt;prediction();
              SpeculatedType right = node-&gt;child2()-&gt;prediction();
  
              if (left &amp;&amp; right) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -547,10 +573,17 @@</span>
              if (child)
                  changed |= mergePrediction(resultOfToPrimitive(child));
              break;
          }
  
<span class="udiff-line-added">+         case ToPropertyKey: {</span>
<span class="udiff-line-added">+             SpeculatedType child = node-&gt;child1()-&gt;prediction();</span>
<span class="udiff-line-added">+             if (child)</span>
<span class="udiff-line-added">+                 changed |= mergePrediction(resultOfToPropertyKey(child));</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case NormalizeMapKey: {
              SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
              if (prediction)
                  changed |= mergePrediction(prediction);
              break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -781,11 +814,11 @@</span>
  
          case ArithBitNot:
          case ArithBitAnd:
          case ArithBitOr:
          case ArithBitXor:
<span class="udiff-line-modified-removed">-         case BitRShift:</span>
<span class="udiff-line-modified-added">+         case ArithBitRShift:</span>
          case ArithBitLShift:
          case BitURShift:
          case ArithIMul:
          case ArithClz32: {
              setPrediction(SpecInt32Only);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -825,14 +858,16 @@</span>
          case ConstructForwardVarargs:
          case TailCallForwardVarargsInlinedCaller:
          case GetGlobalVar:
          case GetGlobalLexicalVariable:
          case GetClosureVar:
<span class="udiff-line-added">+         case GetInternalField:</span>
          case GetFromArguments:
          case LoadKeyFromMapBucket:
          case LoadValueFromMapBucket:
          case ToNumber:
<span class="udiff-line-added">+         case ToNumeric:</span>
          case ToObject:
          case ValueBitAnd:
          case ValueBitXor:
          case ValueBitOr:
          case ValueBitNot:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -841,15 +876,21 @@</span>
          case CallDOMGetter:
          case GetDynamicVar:
          case GetPrototypeOf:
          case ExtractValueFromWeakMapGet:
          case DataViewGetInt:
<span class="udiff-line-modified-removed">-         case DataViewGetFloat: {</span>
<span class="udiff-line-modified-added">+         case DataViewGetFloat:</span>
<span class="udiff-line-added">+         case DateGetInt32OrNaN: {</span>
              setPrediction(m_currentNode-&gt;getHeapPrediction());
              break;
          }
  
<span class="udiff-line-added">+         case DateGetTime: {</span>
<span class="udiff-line-added">+             setPrediction(SpecFullNumber);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case WeakMapGet:
          case ResolveScopeForHoistingFuncDeclInEval: {
              setPrediction(SpecBytecodeTop);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -903,11 +944,12 @@</span>
          case GetVectorLength: {
              setPrediction(SpecInt32Only);
              break;
          }
  
<span class="udiff-line-modified-removed">-         case StringCharCodeAt: {</span>
<span class="udiff-line-modified-added">+         case StringCharCodeAt:</span>
<span class="udiff-line-added">+         case StringCodePointAt: {</span>
              setPrediction(SpecInt32Only);
              break;
          }
  
          case StringValueOf:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1007,10 +1049,23 @@</span>
          case NewObject: {
              setPrediction(SpecFinalObject);
              break;
          }
  
<span class="udiff-line-added">+         case CreatePromise:</span>
<span class="udiff-line-added">+         case NewPromise:</span>
<span class="udiff-line-added">+             setPrediction(SpecPromiseObject);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         case CreateGenerator:</span>
<span class="udiff-line-added">+         case NewGenerator:</span>
<span class="udiff-line-added">+         case CreateAsyncGenerator:</span>
<span class="udiff-line-added">+         case NewAsyncGenerator:</span>
<span class="udiff-line-added">+         case NewArrayIterator:</span>
<span class="udiff-line-added">+             setPrediction(SpecObjectOther);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+ </span>
          case ArraySlice:
          case NewArrayWithSpread:
          case NewArray:
          case NewArrayWithSize:
          case CreateRest:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1077,10 +1132,15 @@</span>
          case CreateClonedArguments: {
              setPrediction(SpecObjectOther);
              break;
          }
  
<span class="udiff-line-added">+         case CreateArgumentsButterfly: {</span>
<span class="udiff-line-added">+             setPrediction(SpecCellOther);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          case FiatInt52: {
              RELEASE_ASSERT(enableInt52());
              setPrediction(SpecInt52Any);
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1152,10 +1212,13 @@</span>
          case ValueMul:
          case ValueDiv:
          case ValueMod:
          case ValuePow:
          case ValueBitLShift:
<span class="udiff-line-added">+         case ValueBitRShift:</span>
<span class="udiff-line-added">+         case Inc:</span>
<span class="udiff-line-added">+         case Dec:</span>
          case ArithAdd:
          case ArithSub:
          case ArithNegate:
          case ArithMin:
          case ArithMax:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1164,10 +1227,11 @@</span>
          case ArithMod:
          case ArithAbs:
          case GetByVal:
          case ToThis:
          case ToPrimitive:
<span class="udiff-line-added">+         case ToPropertyKey:</span>
          case NormalizeMapKey:
          case AtomicsAdd:
          case AtomicsAnd:
          case AtomicsCompareExchange:
          case AtomicsExchange:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,11 +1257,10 @@</span>
              break;
          }
  
          case PutByValAlias:
          case DoubleAsInt32:
<span class="udiff-line-removed">-         case CheckArray:</span>
          case CheckTypeInfoFlags:
          case Arrayify:
          case ArrayifyToStructure:
          case CheckTierUpInLoop:
          case CheckTierUpAtReturn:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1219,19 +1282,22 @@</span>
          case PhantomDirectArguments:
          case PhantomCreateRest:
          case PhantomSpread:
          case PhantomNewArrayWithSpread:
          case PhantomNewArrayBuffer:
<span class="udiff-line-added">+         case PhantomNewArrayIterator:</span>
          case PhantomClonedArguments:
          case PhantomNewRegexp:
          case GetMyArgumentByVal:
          case GetMyArgumentByValOutOfBounds:
          case PutHint:
          case CheckStructureImmediate:
          case CheckStructureOrEmpty:
<span class="udiff-line-added">+         case CheckArrayOrEmpty:</span>
          case MaterializeNewObject:
          case MaterializeCreateActivation:
<span class="udiff-line-added">+         case MaterializeNewInternalFieldObject:</span>
          case PutStack:
          case KillStack:
          case StoreBarrier:
          case FencedStoreBarrier:
          case GetStack:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1262,10 +1328,11 @@</span>
          case PutByValDirect:
          case PutByValWithThis:
          case PutByIdWithThis:
          case PutByVal:
          case PutClosureVar:
<span class="udiff-line-added">+         case PutInternalField:</span>
          case PutToArguments:
          case Return:
          case Throw:
          case ThrowStaticError:
          case TailCall:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1295,15 +1362,17 @@</span>
          case SetFunctionName:
          case CheckStructure:
          case CheckCell:
          case CheckNotEmpty:
          case AssertNotEmpty:
<span class="udiff-line-modified-removed">-         case CheckStringIdent:</span>
<span class="udiff-line-modified-added">+         case CheckIdent:</span>
          case CheckBadCell:
          case PutStructure:
          case Phantom:
          case Check:
<span class="udiff-line-added">+         case CheckArray:</span>
<span class="udiff-line-added">+         case CheckNeutered:</span>
          case CheckVarargs:
          case PutGlobalVariable:
          case CheckTraps:
          case LogShadowChickenPrologue:
          case LogShadowChickenTail:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1312,19 +1381,20 @@</span>
          case NotifyWrite:
          case ConstantStoragePointer:
          case MovHint:
          case ZombieHint:
          case ExitOK:
<span class="udiff-line-added">+         case VarargsLength:</span>
          case LoadVarargs:
          case ForwardVarargs:
          case PutDynamicVar:
          case NukeStructureAndSetButterfly:
          case InitializeEntrypointArguments:
          case WeakSetAdd:
          case WeakMapSet:
          case FilterCallLinkStatus:
<span class="udiff-line-modified-removed">-         case FilterGetByIdStatus:</span>
<span class="udiff-line-modified-added">+         case FilterGetByStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
          case ClearCatchLocals:
          case DataViewSet:
          case InvalidationPoint:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1368,10 +1438,22 @@</span>
          }
  
          return type;
      }
  
<span class="udiff-line-added">+     SpeculatedType resultOfToPropertyKey(SpeculatedType type)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         // Propagate the prediction of the source directly if already proven to be a property key.</span>
<span class="udiff-line-added">+         if (type &amp;&amp; !(type &amp; ~(SpecString | SpecSymbol)))</span>
<span class="udiff-line-added">+             return type;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))</span>
<span class="udiff-line-added">+             return mergeSpeculations(type &amp; SpecSymbol, SpecString);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return SpecString | SpecSymbol;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      Vector&lt;Node*&gt; m_dependentNodes;
      Node* m_currentNode;
      bool m_changed { false };
      PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
  };
</pre>
<center><a href="DFGPredictionInjectionPhase.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPromotedHeapLocation.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
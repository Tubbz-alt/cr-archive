<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/GlyphBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2009, 2011, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007-2008 Torch Mobile Inc.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #pragma once
 31 
 32 #include &quot;FloatSize.h&quot;
 33 #include &quot;Glyph.h&quot;
 34 #include &lt;climits&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 #if USE(CG)
 38 #include &lt;CoreGraphics/CGGeometry.h&gt;
 39 #endif
 40 
 41 namespace WebCore {
 42 
 43 class Font;
 44 
 45 #if USE(WINGDI)
 46 typedef wchar_t GlyphBufferGlyph;
 47 #elif PLATFORM(JAVA)
 48 typedef jint GlyphBufferGlyph;
 49 #else
 50 typedef Glyph GlyphBufferGlyph;
 51 #endif
 52 
 53 // CG uses CGSize instead of FloatSize so that the result of advances()
 54 // can be passed directly to CGContextShowGlyphsWithAdvances in FontMac.mm
 55 #if USE(CG)
 56 struct GlyphBufferAdvance : CGSize {
 57 public:
 58     GlyphBufferAdvance() : CGSize(CGSizeZero) { }
 59     GlyphBufferAdvance(CGSize size)
 60         : CGSize(size)
 61     {
 62     }
 63     GlyphBufferAdvance(float width, float height)
 64         : CGSize(CGSizeMake(width, height))
 65     {
 66     }
 67 
 68     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
 69     template&lt;class Decoder&gt; static Optional&lt;GlyphBufferAdvance&gt; decode(Decoder&amp;);
 70 
 71     void setWidth(CGFloat width) { this-&gt;CGSize::width = width; }
 72     void setHeight(CGFloat height) { this-&gt;CGSize::height = height; }
 73     CGFloat width() const { return this-&gt;CGSize::width; }
 74     CGFloat height() const { return this-&gt;CGSize::height; }
 75 };
 76 
 77 template&lt;class Encoder&gt;
 78 void GlyphBufferAdvance::encode(Encoder&amp; encoder) const
 79 {
 80     encoder &lt;&lt; width();
 81     encoder &lt;&lt; height();
 82 }
 83 
 84 template&lt;class Decoder&gt;
 85 Optional&lt;GlyphBufferAdvance&gt; GlyphBufferAdvance::decode(Decoder&amp; decoder)
 86 {
 87     Optional&lt;CGFloat&gt; width;
 88     decoder &gt;&gt; width;
 89     if (!width)
 90         return WTF::nullopt;
 91 
 92     Optional&lt;CGFloat&gt; height;
 93     decoder &gt;&gt; height;
 94     if (!height)
 95         return WTF::nullopt;
 96 
 97     return GlyphBufferAdvance(CGSizeMake(*width, *height));
 98 }
 99 #else
100 typedef FloatSize GlyphBufferAdvance;
101 #endif
102 
103 inline FloatSize toFloatSize(const GlyphBufferAdvance&amp; a)
104 {
105     return FloatSize(a.width(), a.height());
106 }
107 
108 class GlyphBuffer {
109 public:
110     bool isEmpty() const { return m_fonts.isEmpty(); }
111     unsigned size() const { return m_fonts.size(); }
112 
113     void clear()
114     {
115         m_fonts.clear();
116         m_glyphs.clear();
117         m_advances.clear();
118         if (m_offsetsInString)
119             m_offsetsInString-&gt;clear();
120     }
121 
122     GlyphBufferGlyph* glyphs(unsigned from) { return m_glyphs.data() + from; }
123     GlyphBufferAdvance* advances(unsigned from) { return m_advances.data() + from; }
124     const GlyphBufferGlyph* glyphs(unsigned from) const { return m_glyphs.data() + from; }
125     const GlyphBufferAdvance* advances(unsigned from) const { return m_advances.data() + from; }
126 
127     const Font* fontAt(unsigned index) const { return m_fonts[index]; }
128 
129     void setInitialAdvance(GlyphBufferAdvance initialAdvance) { m_initialAdvance = initialAdvance; }
130     const GlyphBufferAdvance&amp; initialAdvance() const { return m_initialAdvance; }
131 
132     Glyph glyphAt(unsigned index) const
133     {
134         return m_glyphs[index];
135     }
136 
137     GlyphBufferAdvance advanceAt(unsigned index) const
138     {
139         return m_advances[index];
140     }
141 
142     static const unsigned noOffset = UINT_MAX;
143     void add(Glyph glyph, const Font* font, float width, unsigned offsetInString = noOffset)
144     {
145         GlyphBufferAdvance advance;
146         advance.setWidth(width);
147         advance.setHeight(0);
148 
149         add(glyph, font, advance, offsetInString);
150     }
151 
152     void add(Glyph glyph, const Font* font, GlyphBufferAdvance advance, unsigned offsetInString)
153     {
154         m_fonts.append(font);
155         m_glyphs.append(glyph);
156 
157         m_advances.append(advance);
158 
159         if (offsetInString != noOffset &amp;&amp; m_offsetsInString)
160             m_offsetsInString-&gt;append(offsetInString);
161     }
162 
163     void remove(unsigned location, unsigned length)
164     {
165         m_fonts.remove(location, length);
166         m_glyphs.remove(location, length);
167         m_advances.remove(location, length);
168         if (m_offsetsInString)
169             m_offsetsInString-&gt;remove(location, length);
170     }
171 
172     void makeHole(unsigned location, unsigned length, const Font* font)
173     {
174         ASSERT(location &lt;= size());
175 
176         m_fonts.insertVector(location, Vector&lt;const Font*&gt;(length, font));
177         m_glyphs.insertVector(location, Vector&lt;GlyphBufferGlyph&gt;(length, 0xFFFF));
178         m_advances.insertVector(location, Vector&lt;GlyphBufferAdvance&gt;(length, GlyphBufferAdvance(0, 0)));
179         if (m_offsetsInString)
180             m_offsetsInString-&gt;insertVector(location, Vector&lt;unsigned&gt;(length, 0));
181     }
182 
183     void reverse(unsigned from, unsigned length)
184     {
185         for (unsigned i = from, end = from + length - 1; i &lt; end; ++i, --end)
186             swap(i, end);
187     }
188 
189     void expandLastAdvance(float width)
190     {
191         ASSERT(!isEmpty());
192         GlyphBufferAdvance&amp; lastAdvance = m_advances.last();
193         lastAdvance.setWidth(lastAdvance.width() + width);
194     }
195 
196     void expandLastAdvance(GlyphBufferAdvance expansion)
197     {
198         ASSERT(!isEmpty());
199         GlyphBufferAdvance&amp; lastAdvance = m_advances.last();
200         lastAdvance.setWidth(lastAdvance.width() + expansion.width());
201         lastAdvance.setHeight(lastAdvance.height() + expansion.height());
202     }
203 
204     void saveOffsetsInString()
205     {
206         m_offsetsInString.reset(new Vector&lt;unsigned, 2048&gt;());
207     }
208 
209     int offsetInString(unsigned index) const
210     {
211         ASSERT(m_offsetsInString);
212         return (*m_offsetsInString)[index];
213     }
214 
215     void shrink(unsigned truncationPoint)
216     {
217         m_fonts.shrink(truncationPoint);
218         m_glyphs.shrink(truncationPoint);
219         m_advances.shrink(truncationPoint);
220         if (m_offsetsInString)
221             m_offsetsInString-&gt;shrink(truncationPoint);
222     }
223 
224 private:
225     void swap(unsigned index1, unsigned index2)
226     {
227         const Font* f = m_fonts[index1];
228         m_fonts[index1] = m_fonts[index2];
229         m_fonts[index2] = f;
230 
231         GlyphBufferGlyph g = m_glyphs[index1];
232         m_glyphs[index1] = m_glyphs[index2];
233         m_glyphs[index2] = g;
234 
235         GlyphBufferAdvance s = m_advances[index1];
236         m_advances[index1] = m_advances[index2];
237         m_advances[index2] = s;
238     }
239 
240     Vector&lt;const Font*, 2048&gt; m_fonts;
241     Vector&lt;GlyphBufferGlyph, 2048&gt; m_glyphs;
242     Vector&lt;GlyphBufferAdvance, 2048&gt; m_advances;
243     GlyphBufferAdvance m_initialAdvance;
244     std::unique_ptr&lt;Vector&lt;unsigned, 2048&gt;&gt; m_offsetsInString;
245 };
246 
247 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerMessagingProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerLoaderProxy.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerMessagingProxy.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerMessagingProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,11 ***</span>
      ASSERT(!m_workerObject);
      ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
          || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
  }
  
<span class="line-modified">! void WorkerMessagingProxy::startWorkerGlobalScope(const URL&amp; scriptURL, const String&amp; name, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, MonotonicTime timeOrigin, JSC::RuntimeFlags runtimeFlags, PAL::SessionID sessionID)</span>
  {
      // FIXME: This need to be revisited when we support nested worker one day
      ASSERT(m_scriptExecutionContext);
      Document&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
      WorkerThreadStartMode startMode = m_inspectorProxy-&gt;workerStartMode(*m_scriptExecutionContext.get());
<span class="line-new-header">--- 70,11 ---</span>
      ASSERT(!m_workerObject);
      ASSERT((is&lt;Document&gt;(*m_scriptExecutionContext) &amp;&amp; isMainThread())
          || (is&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*m_scriptExecutionContext).thread().thread() == &amp;Thread::current()));
  }
  
<span class="line-modified">! void WorkerMessagingProxy::startWorkerGlobalScope(const URL&amp; scriptURL, const String&amp; name, const String&amp; userAgent, bool isOnline, const String&amp; sourceCode, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicyResponseHeaders, bool shouldBypassMainWorldContentSecurityPolicy, MonotonicTime timeOrigin, ReferrerPolicy referrerPolicy, JSC::RuntimeFlags runtimeFlags)</span>
  {
      // FIXME: This need to be revisited when we support nested worker one day
      ASSERT(m_scriptExecutionContext);
      Document&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
      WorkerThreadStartMode startMode = m_inspectorProxy-&gt;workerStartMode(*m_scriptExecutionContext.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,14 ***</span>
      IDBClient::IDBConnectionProxy* proxy = nullptr;
  #endif
  
      SocketProvider* socketProvider = document.socketProvider();
  
<span class="line-modified">!     auto thread = DedicatedWorkerThread::create(scriptURL, name, identifier, userAgent, isOnline, sourceCode, *this, *this, *this, startMode, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, document.topOrigin(), timeOrigin, proxy, socketProvider, runtimeFlags, sessionID);</span>
  
      workerThreadCreated(thread.get());
<span class="line-modified">!     thread-&gt;start(nullptr);</span>
  
      m_inspectorProxy-&gt;workerStarted(m_scriptExecutionContext.get(), thread.ptr(), scriptURL);
  }
  
  void WorkerMessagingProxy::postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp; message)
<span class="line-new-header">--- 86,15 ---</span>
      IDBClient::IDBConnectionProxy* proxy = nullptr;
  #endif
  
      SocketProvider* socketProvider = document.socketProvider();
  
<span class="line-modified">!     WorkerParameters params = { scriptURL, name, identifier, userAgent, isOnline, contentSecurityPolicyResponseHeaders, shouldBypassMainWorldContentSecurityPolicy, timeOrigin, referrerPolicy };</span>
<span class="line-added">+     auto thread = DedicatedWorkerThread::create(params, sourceCode, *this, *this, *this, startMode, document.topOrigin(), proxy, socketProvider, runtimeFlags);</span>
  
      workerThreadCreated(thread.get());
<span class="line-modified">!     thread-&gt;start();</span>
  
      m_inspectorProxy-&gt;workerStarted(m_scriptExecutionContext.get(), thread.ptr(), scriptURL);
  }
  
  void WorkerMessagingProxy::postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp; message)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,11 ***</span>
          Worker* workerObject = this-&gt;workerObject();
          if (!workerObject || askedToTerminate())
              return;
  
          auto ports = MessagePort::entanglePorts(context, WTFMove(message.transferredPorts));
<span class="line-modified">!         workerObject-&gt;dispatchEvent(MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
      });
  }
  
  void WorkerMessagingProxy::postMessageToWorkerGlobalScope(MessageWithMessagePorts&amp;&amp; message)
  {
<span class="line-new-header">--- 103,11 ---</span>
          Worker* workerObject = this-&gt;workerObject();
          if (!workerObject || askedToTerminate())
              return;
  
          auto ports = MessagePort::entanglePorts(context, WTFMove(message.transferredPorts));
<span class="line-modified">!         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::PostedMessageQueue, MessageEvent::create(WTFMove(ports), message.message.releaseNonNull()));</span>
      });
  }
  
  void WorkerMessagingProxy::postMessageToWorkerGlobalScope(MessageWithMessagePorts&amp;&amp; message)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,10 ***</span>
<span class="line-new-header">--- 127,26 ---</span>
          m_workerThread-&gt;runLoop().postTask(WTFMove(task));
      } else
          m_queuedEarlyTasks.append(makeUnique&lt;ScriptExecutionContext::Task&gt;(WTFMove(task)));
  }
  
<span class="line-added">+ void WorkerMessagingProxy::suspendForBackForwardCache()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_workerThread)</span>
<span class="line-added">+         m_workerThread-&gt;suspend();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_askedToSuspend = true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void WorkerMessagingProxy::resumeForBackForwardCache()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_workerThread)</span>
<span class="line-added">+         m_workerThread-&gt;resume();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_askedToSuspend = false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void WorkerMessagingProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
  {
      // FIXME: In case of nested workers, this should go directly to the root Document context.
      ASSERT(m_scriptExecutionContext-&gt;isDocument());
      m_scriptExecutionContext-&gt;postTask(WTFMove(task));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,11 ***</span>
  
  Ref&lt;CacheStorageConnection&gt; WorkerMessagingProxy::createCacheStorageConnection()
  {
      ASSERT(isMainThread());
      auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
<span class="line-modified">!     return document.page()-&gt;cacheStorageProvider().createCacheStorageConnection(document.page()-&gt;sessionID());</span>
  }
  
  bool WorkerMessagingProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
  {
      if (m_askedToTerminate)
<span class="line-new-header">--- 154,11 ---</span>
  
  Ref&lt;CacheStorageConnection&gt; WorkerMessagingProxy::createCacheStorageConnection()
  {
      ASSERT(isMainThread());
      auto&amp; document = downcast&lt;Document&gt;(*m_scriptExecutionContext);
<span class="line-modified">!     return document.page()-&gt;cacheStorageProvider().createCacheStorageConnection();</span>
  }
  
  bool WorkerMessagingProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
  {
      if (m_askedToTerminate)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,22 ***</span>
      return true;
  }
  
  void WorkerMessagingProxy::postExceptionToWorkerObject(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL)
  {
<span class="line-modified">!     m_scriptExecutionContext-&gt;postTask([this, errorMessage = errorMessage.isolatedCopy(), sourceURL = sourceURL.isolatedCopy(), lineNumber, columnNumber] (ScriptExecutionContext&amp; context) {</span>
          Worker* workerObject = this-&gt;workerObject();
          if (!workerObject)
              return;
  
          // We don&#39;t bother checking the askedToTerminate() flag here, because exceptions should *always* be reported even if the thread is terminated.
          // This is intentionally different than the behavior in MessageWorkerTask, because terminated workers no longer deliver messages (section 4.6 of the WebWorker spec), but they do report exceptions.
<span class="line-modified">! </span>
<span class="line-removed">-         auto event = ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { });</span>
<span class="line-removed">-         workerObject-&gt;dispatchEvent(event);</span>
<span class="line-removed">-         if (!event-&gt;defaultPrevented())</span>
<span class="line-removed">-             context.reportException(errorMessage, lineNumber, columnNumber, sourceURL, nullptr, nullptr);</span>
      });
  }
  
  void WorkerMessagingProxy::postMessageToDebugger(const String&amp; message)
  {
<span class="line-new-header">--- 169,18 ---</span>
      return true;
  }
  
  void WorkerMessagingProxy::postExceptionToWorkerObject(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL)
  {
<span class="line-modified">!     m_scriptExecutionContext-&gt;postTask([this, errorMessage = errorMessage.isolatedCopy(), sourceURL = sourceURL.isolatedCopy(), lineNumber, columnNumber] (ScriptExecutionContext&amp;) {</span>
          Worker* workerObject = this-&gt;workerObject();
          if (!workerObject)
              return;
  
          // We don&#39;t bother checking the askedToTerminate() flag here, because exceptions should *always* be reported even if the thread is terminated.
          // This is intentionally different than the behavior in MessageWorkerTask, because terminated workers no longer deliver messages (section 4.6 of the WebWorker spec), but they do report exceptions.
<span class="line-modified">!         ActiveDOMObject::queueTaskToDispatchEvent(*workerObject, TaskSource::DOMManipulation, ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { }));</span>
      });
  }
  
  void WorkerMessagingProxy::postMessageToDebugger(const String&amp; message)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,16 ***</span>
          if (!m_mayBeDestroyed)
              m_inspectorProxy-&gt;sendMessageFromWorkerToFrontend(message);
      });
  }
  
<span class="line-modified">! void WorkerMessagingProxy::setResourceCachingDisabled(bool disabled)</span>
  {
      postTaskToLoader([disabled] (ScriptExecutionContext&amp; context) {
          ASSERT(isMainThread());
          if (auto* page = downcast&lt;Document&gt;(context).page())
<span class="line-modified">!             page-&gt;setResourceCachingDisabled(disabled);</span>
      });
  }
  
  void WorkerMessagingProxy::workerThreadCreated(DedicatedWorkerThread&amp; workerThread)
  {
<span class="line-new-header">--- 188,16 ---</span>
          if (!m_mayBeDestroyed)
              m_inspectorProxy-&gt;sendMessageFromWorkerToFrontend(message);
      });
  }
  
<span class="line-modified">! void WorkerMessagingProxy::setResourceCachingDisabledByWebInspector(bool disabled)</span>
  {
      postTaskToLoader([disabled] (ScriptExecutionContext&amp; context) {
          ASSERT(isMainThread());
          if (auto* page = downcast&lt;Document&gt;(context).page())
<span class="line-modified">!             page-&gt;setResourceCachingDisabledByWebInspector(disabled);</span>
      });
  }
  
  void WorkerMessagingProxy::workerThreadCreated(DedicatedWorkerThread&amp; workerThread)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,10 ***</span>
<span class="line-new-header">--- 205,15 ---</span>
  
      if (m_askedToTerminate) {
          // Worker.terminate() could be called from JS before the thread was created.
          m_workerThread-&gt;stop(nullptr);
      } else {
<span class="line-added">+         if (m_askedToSuspend) {</span>
<span class="line-added">+             m_askedToSuspend = false;</span>
<span class="line-added">+             m_workerThread-&gt;suspend();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          ASSERT(!m_unconfirmedMessageCount);
          m_unconfirmedMessageCount = m_queuedEarlyTasks.size();
          m_workerThreadHadPendingActivity = true; // Worker initialization means a pending activity.
  
          auto queuedEarlyTasks = WTFMove(m_queuedEarlyTasks);
</pre>
<center><a href="WorkerLoaderProxy.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerMessagingProxy.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
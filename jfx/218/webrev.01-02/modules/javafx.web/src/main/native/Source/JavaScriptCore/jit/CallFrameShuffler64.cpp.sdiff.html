<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrameShuffler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExecutableAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 71     default:
 72         RELEASE_ASSERT_NOT_REACHED();
 73     }
 74 }
 75 
 76 void CallFrameShuffler::emitBox(CachedRecovery&amp; cachedRecovery)
 77 {
 78     ASSERT(canBox(cachedRecovery));
 79     if (cachedRecovery.recovery().isConstant())
 80         return;
 81 
 82     if (cachedRecovery.recovery().isInGPR()) {
 83         switch (cachedRecovery.recovery().dataFormat()) {
 84         case DataFormatInt32:
 85             if (verbose)
 86                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
 87             m_jit.zeroExtend32ToPtr(
 88                 cachedRecovery.recovery().gpr(),
 89                 cachedRecovery.recovery().gpr());
 90             m_lockedRegisters.set(cachedRecovery.recovery().gpr());
<span class="line-modified"> 91             if (tryAcquireTagTypeNumber())</span>
<span class="line-modified"> 92                 m_jit.or64(m_tagTypeNumber, cachedRecovery.recovery().gpr());</span>
 93             else {
 94                 // We have to do this the hard way
<span class="line-modified"> 95                 m_jit.or64(MacroAssembler::TrustedImm64(TagTypeNumber),</span>
 96                     cachedRecovery.recovery().gpr());
 97             }
 98             m_lockedRegisters.clear(cachedRecovery.recovery().gpr());
 99             cachedRecovery.setRecovery(
100                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatJS));
101             if (verbose)
102                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
103             return;
104         case DataFormatInt52:
105             if (verbose)
106                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
107             m_jit.rshift64(MacroAssembler::TrustedImm32(JSValue::int52ShiftAmount),
108                 cachedRecovery.recovery().gpr());
109             cachedRecovery.setRecovery(
110                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatStrictInt52));
111             if (verbose)
112                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
113             FALLTHROUGH;
114         case DataFormatStrictInt52: {
115             if (verbose)
116                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
117             FPRReg resultFPR = getFreeFPR();
118             ASSERT(resultFPR != InvalidFPRReg);
119             m_jit.convertInt64ToDouble(cachedRecovery.recovery().gpr(), resultFPR);
120             updateRecovery(cachedRecovery, ValueRecovery::inFPR(resultFPR, DataFormatDouble));
121             if (verbose)
122                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
123             break;
124         }
125         case DataFormatBoolean:
126             if (verbose)
127                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
<span class="line-modified">128             m_jit.add32(MacroAssembler::TrustedImm32(ValueFalse),</span>
129                 cachedRecovery.recovery().gpr());
130             cachedRecovery.setRecovery(
131                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatJS));
132             if (verbose)
133                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
134             return;
135         default:
136             return;
137         }
138     }
139 
140     if (cachedRecovery.recovery().isInFPR()) {
141         if (cachedRecovery.recovery().dataFormat() == DataFormatDouble) {
142             if (verbose)
143                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
144             GPRReg resultGPR = cachedRecovery.wantedJSValueRegs().gpr();
145             if (resultGPR == InvalidGPRReg || m_registers[resultGPR])
146                 resultGPR = getFreeGPR();
147             ASSERT(resultGPR != InvalidGPRReg);
148             m_jit.purifyNaN(cachedRecovery.recovery().fpr());
149             m_jit.moveDoubleTo64(cachedRecovery.recovery().fpr(), resultGPR);
150             m_lockedRegisters.set(resultGPR);
<span class="line-modified">151             if (tryAcquireTagTypeNumber())</span>
<span class="line-modified">152                 m_jit.sub64(m_tagTypeNumber, resultGPR);</span>
153             else
<span class="line-modified">154                 m_jit.sub64(MacroAssembler::TrustedImm64(TagTypeNumber), resultGPR);</span>
155             m_lockedRegisters.clear(resultGPR);
156             updateRecovery(cachedRecovery, ValueRecovery::inGPR(resultGPR, DataFormatJS));
157             if (verbose)
158                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
159             return;
160         }
161         ASSERT(cachedRecovery.recovery().dataFormat() == DataFormatJS);
162         return;
163     }
164 
165     RELEASE_ASSERT_NOT_REACHED();
166 }
167 
168 void CallFrameShuffler::emitLoad(CachedRecovery&amp; cachedRecovery)
169 {
170     if (!cachedRecovery.recovery().isInJSStack())
171         return;
172 
173     if (verbose)
174         dataLog(&quot;   * Loading &quot;, cachedRecovery.recovery(), &quot; into &quot;);
</pre>
<hr />
<pre>
332             // We only care about callee saves for wanted FPRs, and those are always DataFormatJS
333             ASSERT(wantedReg.isGPR());
334             // This will automatically pick the wanted GPR
335             emitBox(cachedRecovery);
336         } else {
337             if (verbose)
338                 dataLog(&quot;   * Moving &quot;, cachedRecovery.recovery().fpr(), &quot; into &quot;, wantedReg, &quot;\n&quot;);
339             if (wantedReg.isGPR())
340                 m_jit.moveDoubleTo64(cachedRecovery.recovery().fpr(), wantedReg.gpr());
341             else
342                 m_jit.moveDouble(cachedRecovery.recovery().fpr(), wantedReg.fpr());
343             RELEASE_ASSERT(cachedRecovery.recovery().dataFormat() == DataFormatJS);
344             updateRecovery(cachedRecovery,
345                 ValueRecovery::inRegister(wantedReg, DataFormatJS));
346         }
347     }
348 
349     ASSERT(m_registers[wantedReg] == &amp;cachedRecovery);
350 }
351 
<span class="line-modified">352 bool CallFrameShuffler::tryAcquireTagTypeNumber()</span>
353 {
<span class="line-modified">354     if (m_tagTypeNumber != InvalidGPRReg)</span>
355         return true;
356 
<span class="line-modified">357     m_tagTypeNumber = getFreeGPR();</span>
358 
<span class="line-modified">359     if (m_tagTypeNumber == InvalidGPRReg)</span>
360         return false;
361 
<span class="line-modified">362     m_lockedRegisters.set(m_tagTypeNumber);</span>
<span class="line-modified">363     m_jit.move(MacroAssembler::TrustedImm64(TagTypeNumber), m_tagTypeNumber);</span>
364     return true;
365 }
366 
367 } // namespace JSC
368 
369 #endif // ENABLE(JIT) &amp;&amp; USE(JSVALUE64)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 71     default:
 72         RELEASE_ASSERT_NOT_REACHED();
 73     }
 74 }
 75 
 76 void CallFrameShuffler::emitBox(CachedRecovery&amp; cachedRecovery)
 77 {
 78     ASSERT(canBox(cachedRecovery));
 79     if (cachedRecovery.recovery().isConstant())
 80         return;
 81 
 82     if (cachedRecovery.recovery().isInGPR()) {
 83         switch (cachedRecovery.recovery().dataFormat()) {
 84         case DataFormatInt32:
 85             if (verbose)
 86                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
 87             m_jit.zeroExtend32ToPtr(
 88                 cachedRecovery.recovery().gpr(),
 89                 cachedRecovery.recovery().gpr());
 90             m_lockedRegisters.set(cachedRecovery.recovery().gpr());
<span class="line-modified"> 91             if (tryAcquireNumberTagRegister())</span>
<span class="line-modified"> 92                 m_jit.or64(m_numberTagRegister, cachedRecovery.recovery().gpr());</span>
 93             else {
 94                 // We have to do this the hard way
<span class="line-modified"> 95                 m_jit.or64(MacroAssembler::TrustedImm64(JSValue::NumberTag),</span>
 96                     cachedRecovery.recovery().gpr());
 97             }
 98             m_lockedRegisters.clear(cachedRecovery.recovery().gpr());
 99             cachedRecovery.setRecovery(
100                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatJS));
101             if (verbose)
102                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
103             return;
104         case DataFormatInt52:
105             if (verbose)
106                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
107             m_jit.rshift64(MacroAssembler::TrustedImm32(JSValue::int52ShiftAmount),
108                 cachedRecovery.recovery().gpr());
109             cachedRecovery.setRecovery(
110                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatStrictInt52));
111             if (verbose)
112                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
113             FALLTHROUGH;
114         case DataFormatStrictInt52: {
115             if (verbose)
116                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
117             FPRReg resultFPR = getFreeFPR();
118             ASSERT(resultFPR != InvalidFPRReg);
119             m_jit.convertInt64ToDouble(cachedRecovery.recovery().gpr(), resultFPR);
120             updateRecovery(cachedRecovery, ValueRecovery::inFPR(resultFPR, DataFormatDouble));
121             if (verbose)
122                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
123             break;
124         }
125         case DataFormatBoolean:
126             if (verbose)
127                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
<span class="line-modified">128             m_jit.add32(MacroAssembler::TrustedImm32(JSValue::ValueFalse),</span>
129                 cachedRecovery.recovery().gpr());
130             cachedRecovery.setRecovery(
131                 ValueRecovery::inGPR(cachedRecovery.recovery().gpr(), DataFormatJS));
132             if (verbose)
133                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
134             return;
135         default:
136             return;
137         }
138     }
139 
140     if (cachedRecovery.recovery().isInFPR()) {
141         if (cachedRecovery.recovery().dataFormat() == DataFormatDouble) {
142             if (verbose)
143                 dataLog(&quot;   * Boxing &quot;, cachedRecovery.recovery());
144             GPRReg resultGPR = cachedRecovery.wantedJSValueRegs().gpr();
145             if (resultGPR == InvalidGPRReg || m_registers[resultGPR])
146                 resultGPR = getFreeGPR();
147             ASSERT(resultGPR != InvalidGPRReg);
148             m_jit.purifyNaN(cachedRecovery.recovery().fpr());
149             m_jit.moveDoubleTo64(cachedRecovery.recovery().fpr(), resultGPR);
150             m_lockedRegisters.set(resultGPR);
<span class="line-modified">151             if (tryAcquireNumberTagRegister())</span>
<span class="line-modified">152                 m_jit.sub64(m_numberTagRegister, resultGPR);</span>
153             else
<span class="line-modified">154                 m_jit.sub64(MacroAssembler::TrustedImm64(JSValue::NumberTag), resultGPR);</span>
155             m_lockedRegisters.clear(resultGPR);
156             updateRecovery(cachedRecovery, ValueRecovery::inGPR(resultGPR, DataFormatJS));
157             if (verbose)
158                 dataLog(&quot; into &quot;, cachedRecovery.recovery(), &quot;\n&quot;);
159             return;
160         }
161         ASSERT(cachedRecovery.recovery().dataFormat() == DataFormatJS);
162         return;
163     }
164 
165     RELEASE_ASSERT_NOT_REACHED();
166 }
167 
168 void CallFrameShuffler::emitLoad(CachedRecovery&amp; cachedRecovery)
169 {
170     if (!cachedRecovery.recovery().isInJSStack())
171         return;
172 
173     if (verbose)
174         dataLog(&quot;   * Loading &quot;, cachedRecovery.recovery(), &quot; into &quot;);
</pre>
<hr />
<pre>
332             // We only care about callee saves for wanted FPRs, and those are always DataFormatJS
333             ASSERT(wantedReg.isGPR());
334             // This will automatically pick the wanted GPR
335             emitBox(cachedRecovery);
336         } else {
337             if (verbose)
338                 dataLog(&quot;   * Moving &quot;, cachedRecovery.recovery().fpr(), &quot; into &quot;, wantedReg, &quot;\n&quot;);
339             if (wantedReg.isGPR())
340                 m_jit.moveDoubleTo64(cachedRecovery.recovery().fpr(), wantedReg.gpr());
341             else
342                 m_jit.moveDouble(cachedRecovery.recovery().fpr(), wantedReg.fpr());
343             RELEASE_ASSERT(cachedRecovery.recovery().dataFormat() == DataFormatJS);
344             updateRecovery(cachedRecovery,
345                 ValueRecovery::inRegister(wantedReg, DataFormatJS));
346         }
347     }
348 
349     ASSERT(m_registers[wantedReg] == &amp;cachedRecovery);
350 }
351 
<span class="line-modified">352 bool CallFrameShuffler::tryAcquireNumberTagRegister()</span>
353 {
<span class="line-modified">354     if (m_numberTagRegister != InvalidGPRReg)</span>
355         return true;
356 
<span class="line-modified">357     m_numberTagRegister = getFreeGPR();</span>
358 
<span class="line-modified">359     if (m_numberTagRegister == InvalidGPRReg)</span>
360         return false;
361 
<span class="line-modified">362     m_lockedRegisters.set(m_numberTagRegister);</span>
<span class="line-modified">363     m_jit.move(MacroAssembler::TrustedImm64(JSValue::NumberTag), m_numberTagRegister);</span>
364     return true;
365 }
366 
367 } // namespace JSC
368 
369 #endif // ENABLE(JIT) &amp;&amp; USE(JSVALUE64)
</pre>
</td>
</tr>
</table>
<center><a href="CallFrameShuffler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ExecutableAllocator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
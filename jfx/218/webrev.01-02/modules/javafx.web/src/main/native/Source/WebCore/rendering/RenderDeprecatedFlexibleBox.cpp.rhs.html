<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderDeprecatedFlexibleBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * This file is part of the render object implementation for KHTML.
   3  *
   4  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   5  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   6  * Copyright (C) 2003 Apple Inc.
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  27 
  28 #include &quot;FontCascade.h&quot;
  29 #include &quot;LayoutRepainter.h&quot;
  30 #include &quot;RenderLayer.h&quot;
  31 #include &quot;RenderLayoutState.h&quot;
  32 #include &quot;RenderView.h&quot;
  33 #include &lt;wtf/IsoMallocInlines.h&gt;
  34 #include &lt;wtf/StdLibExtras.h&gt;
  35 #include &lt;wtf/unicode/CharacterNames.h&gt;
  36 
  37 namespace WebCore {
  38 
  39 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderDeprecatedFlexibleBox);
  40 
  41 class FlexBoxIterator {
  42 public:
  43     FlexBoxIterator(RenderDeprecatedFlexibleBox* parent)
  44         : m_box(parent)
  45         , m_largestOrdinal(1)
  46     {
  47         if (m_box-&gt;style().boxOrient() == BoxOrient::Horizontal &amp;&amp; !m_box-&gt;style().isLeftToRightDirection())
  48             m_forward = m_box-&gt;style().boxDirection() != BoxDirection::Normal;
  49         else
  50             m_forward = m_box-&gt;style().boxDirection() == BoxDirection::Normal;
  51         if (!m_forward) {
  52             // No choice, since we&#39;re going backwards, we have to find out the highest ordinal up front.
  53             RenderBox* child = m_box-&gt;firstChildBox();
  54             while (child) {
  55                 if (child-&gt;style().boxOrdinalGroup() &gt; m_largestOrdinal)
  56                     m_largestOrdinal = child-&gt;style().boxOrdinalGroup();
  57                 child = child-&gt;nextSiblingBox();
  58             }
  59         }
  60 
  61         reset();
  62     }
  63 
  64     void reset()
  65     {
  66         m_currentChild = nullptr;
  67         m_ordinalIteration = std::numeric_limits&lt;unsigned&gt;::max();
  68     }
  69 
  70     RenderBox* first()
  71     {
  72         reset();
  73         return next();
  74     }
  75 
  76     RenderBox* next()
  77     {
  78         do {
  79             if (!m_currentChild) {
  80                 ++m_ordinalIteration;
  81 
  82                 if (!m_ordinalIteration)
  83                     m_currentOrdinal = m_forward ? 1 : m_largestOrdinal;
  84                 else {
  85                     if (m_ordinalIteration &gt; m_ordinalValues.size())
  86                         return nullptr;
  87 
  88                     // Only copy+sort the values once per layout even if the iterator is reset.
  89                     if (static_cast&lt;size_t&gt;(m_ordinalValues.size()) != m_sortedOrdinalValues.size()) {
  90                         m_sortedOrdinalValues = copyToVector(m_ordinalValues);
  91                         std::sort(m_sortedOrdinalValues.begin(), m_sortedOrdinalValues.end());
  92                     }
  93                     m_currentOrdinal = m_forward ? m_sortedOrdinalValues[m_ordinalIteration - 1] : m_sortedOrdinalValues[m_sortedOrdinalValues.size() - m_ordinalIteration];
  94                 }
  95 
  96                 m_currentChild = m_forward ? m_box-&gt;firstChildBox() : m_box-&gt;lastChildBox();
  97             } else
  98                 m_currentChild = m_forward ? m_currentChild-&gt;nextSiblingBox() : m_currentChild-&gt;previousSiblingBox();
  99 
 100             if (m_currentChild &amp;&amp; notFirstOrdinalValue())
 101                 m_ordinalValues.add(m_currentChild-&gt;style().boxOrdinalGroup());
 102         } while (!m_currentChild || m_currentChild-&gt;isExcludedFromNormalLayout() || (!m_currentChild-&gt;isAnonymous()
 103                  &amp;&amp; m_currentChild-&gt;style().boxOrdinalGroup() != m_currentOrdinal));
 104         return m_currentChild;
 105     }
 106 
 107 private:
 108     bool notFirstOrdinalValue()
 109     {
 110         unsigned int firstOrdinalValue = m_forward ? 1 : m_largestOrdinal;
 111         return m_currentOrdinal == firstOrdinalValue &amp;&amp; m_currentChild-&gt;style().boxOrdinalGroup() != firstOrdinalValue;
 112     }
 113 
 114     RenderDeprecatedFlexibleBox* m_box;
 115     RenderBox* m_currentChild;
 116     bool m_forward;
 117     unsigned m_currentOrdinal;
 118     unsigned m_largestOrdinal;
 119     HashSet&lt;unsigned&gt; m_ordinalValues;
 120     Vector&lt;unsigned&gt; m_sortedOrdinalValues;
 121     unsigned m_ordinalIteration;
 122 };
 123 
 124 RenderDeprecatedFlexibleBox::RenderDeprecatedFlexibleBox(Element&amp; element, RenderStyle&amp;&amp; style)
 125     : RenderBlock(element, WTFMove(style), 0)
 126 {
 127     setChildrenInline(false); // All of our children must be block-level
 128     m_stretchingChildren = false;
 129 }
 130 
 131 RenderDeprecatedFlexibleBox::~RenderDeprecatedFlexibleBox() = default;
 132 
 133 static LayoutUnit marginWidthForChild(RenderBox* child)
 134 {
 135     // A margin basically has three types: fixed, percentage, and auto (variable).
 136     // Auto and percentage margins simply become 0 when computing min/max width.
 137     // Fixed margins can be added in as is.
 138     Length marginLeft = child-&gt;style().marginLeft();
 139     Length marginRight = child-&gt;style().marginRight();
 140     LayoutUnit margin;
 141     if (marginLeft.isFixed())
 142         margin += marginLeft.value();
 143     if (marginRight.isFixed())
 144         margin += marginRight.value();
 145     return margin;
 146 }
 147 
 148 static bool childDoesNotAffectWidthOrFlexing(RenderObject* child)
 149 {
 150     // Positioned children and collapsed children don&#39;t affect the min/max width.
 151     return child-&gt;isOutOfFlowPositioned() || child-&gt;style().visibility() == Visibility::Collapse;
 152 }
 153 
 154 static LayoutUnit contentWidthForChild(RenderBox* child)
 155 {
 156     if (child-&gt;hasOverrideContentLogicalWidth())
 157         return child-&gt;overrideContentLogicalWidth();
 158     return child-&gt;logicalWidth() - child-&gt;borderAndPaddingLogicalWidth();
 159 }
 160 
 161 static LayoutUnit contentHeightForChild(RenderBox* child)
 162 {
 163     if (child-&gt;hasOverrideContentLogicalHeight())
 164         return child-&gt;overrideContentLogicalHeight();
 165     return child-&gt;logicalHeight() - child-&gt;borderAndPaddingLogicalHeight();
 166 }
 167 
 168 void RenderDeprecatedFlexibleBox::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 169 {
 170     auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 171     if (oldStyle &amp;&amp; !oldStyle-&gt;lineClamp().isNone() &amp;&amp; newStyle.lineClamp().isNone())
 172         clearLineClamp();
 173 
 174     RenderBlock::styleWillChange(diff, newStyle);
 175 }
 176 
 177 void RenderDeprecatedFlexibleBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
 178 {
 179     if (hasMultipleLines() || isVertical()) {
 180         for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 181             if (childDoesNotAffectWidthOrFlexing(child))
 182                 continue;
 183 
 184             LayoutUnit margin = marginWidthForChild(child);
 185             LayoutUnit width = child-&gt;minPreferredLogicalWidth() + margin;
 186             minLogicalWidth = std::max(width, minLogicalWidth);
 187 
 188             width = child-&gt;maxPreferredLogicalWidth() + margin;
 189             maxLogicalWidth = std::max(width, maxLogicalWidth);
 190         }
 191     } else {
 192         for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 193             if (childDoesNotAffectWidthOrFlexing(child))
 194                 continue;
 195 
 196             LayoutUnit margin = marginWidthForChild(child);
 197             minLogicalWidth += child-&gt;minPreferredLogicalWidth() + margin;
 198             maxLogicalWidth += child-&gt;maxPreferredLogicalWidth() + margin;
 199         }
 200     }
 201 
 202     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
 203 
 204     LayoutUnit scrollbarWidth = intrinsicScrollbarLogicalWidth();
 205     maxLogicalWidth += scrollbarWidth;
 206     minLogicalWidth += scrollbarWidth;
 207 }
 208 
 209 void RenderDeprecatedFlexibleBox::computePreferredLogicalWidths()
 210 {
 211     ASSERT(preferredLogicalWidthsDirty());
 212 
 213     m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = 0;
 214     if (style().width().isFixed() &amp;&amp; style().width().value() &gt; 0)
 215         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(style().width().value());
 216     else
 217         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
 218 
 219     if (style().minWidth().isFixed() &amp;&amp; style().minWidth().value() &gt; 0) {
 220         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
 221         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().minWidth().value()));
 222     }
 223 
 224     if (style().maxWidth().isFixed()) {
 225         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
 226         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(style().maxWidth().value()));
 227     }
 228 
 229     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
 230     m_minPreferredLogicalWidth += borderAndPadding;
 231     m_maxPreferredLogicalWidth += borderAndPadding;
 232 
 233     setPreferredLogicalWidthsDirty(false);
 234 }
 235 
 236 // Use an inline capacity of 8, since flexbox containers usually have less than 8 children.
 237 typedef Vector&lt;LayoutRect, 8&gt; ChildFrameRects;
 238 typedef Vector&lt;LayoutSize, 8&gt; ChildLayoutDeltas;
 239 
 240 static void appendChildFrameRects(RenderDeprecatedFlexibleBox* box, ChildFrameRects&amp; childFrameRects)
 241 {
 242     FlexBoxIterator iterator(box);
 243     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 244         if (!child-&gt;isOutOfFlowPositioned())
 245             childFrameRects.append(child-&gt;frameRect());
 246     }
 247 }
 248 
 249 static void appendChildLayoutDeltas(RenderDeprecatedFlexibleBox* box, ChildLayoutDeltas&amp; childLayoutDeltas)
 250 {
 251     FlexBoxIterator iterator(box);
 252     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 253         if (!child-&gt;isOutOfFlowPositioned())
 254             childLayoutDeltas.append(LayoutSize());
 255     }
 256 }
 257 
 258 static void repaintChildrenDuringLayoutIfMoved(RenderDeprecatedFlexibleBox* box, const ChildFrameRects&amp; oldChildRects)
 259 {
 260     size_t childIndex = 0;
 261     FlexBoxIterator iterator(box);
 262     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 263         if (child-&gt;isOutOfFlowPositioned())
 264             continue;
 265 
 266         // If the child moved, we have to repaint it as well as any floating/positioned
 267         // descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
 268         // repaint ourselves (and the child) anyway.
 269         if (!box-&gt;selfNeedsLayout() &amp;&amp; child-&gt;checkForRepaintDuringLayout())
 270             child-&gt;repaintDuringLayoutIfMoved(oldChildRects[childIndex]);
 271 
 272         ++childIndex;
 273     }
 274     ASSERT(childIndex == oldChildRects.size());
 275 }
 276 
 277 void RenderDeprecatedFlexibleBox::layoutBlock(bool relayoutChildren, LayoutUnit)
 278 {
 279     ASSERT(needsLayout());
 280 
 281     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 282         return;
 283 
 284     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 285     {
 286         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 287 
<a name="1" id="anc1"></a><span class="line-added"> 288         resetLogicalHeightBeforeLayoutIfNeeded();</span>
 289         preparePaginationBeforeBlockLayout(relayoutChildren);
 290 
 291         LayoutSize previousSize = size();
 292 
 293         updateLogicalWidth();
 294         updateLogicalHeight();
 295 
 296         if (previousSize != size()
 297             || (parent()-&gt;isDeprecatedFlexibleBox() &amp;&amp; parent()-&gt;style().boxOrient() == BoxOrient::Horizontal
 298                 &amp;&amp; parent()-&gt;style().boxAlign() == BoxAlignment::Stretch))
 299             relayoutChildren = true;
 300 
 301         setHeight(0);
 302 
 303         m_stretchingChildren = false;
 304 
<a name="2" id="anc2"></a><span class="line-modified"> 305 #if ASSERT_ENABLED</span>
 306         LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
 307 #endif
 308 
 309         // Fieldsets need to find their legend and position it inside the border of the object.
 310         // The legend then gets skipped during normal layout. The same is true for ruby text.
 311         // It doesn&#39;t get included in the normal layout process but is instead skipped.
 312         layoutExcludedChildren(relayoutChildren);
 313 
 314         ChildFrameRects oldChildRects;
 315         appendChildFrameRects(this, oldChildRects);
 316 
 317         if (isHorizontal())
 318             layoutHorizontalBox(relayoutChildren);
 319         else
 320             layoutVerticalBox(relayoutChildren);
 321 
 322         repaintChildrenDuringLayoutIfMoved(this, oldChildRects);
 323         ASSERT(view().frameView().layoutContext().layoutDeltaMatches(oldLayoutDelta));
 324 
 325         LayoutUnit oldClientAfterEdge = clientLogicalBottom();
 326         updateLogicalHeight();
 327 
 328         if (previousSize.height() != height())
 329             relayoutChildren = true;
 330 
 331         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 332 
 333         computeOverflow(oldClientAfterEdge);
 334     }
 335 
 336     updateLayerTransform();
 337 
 338     auto* layoutState = view().frameView().layoutContext().layoutState();
 339     if (layoutState &amp;&amp; layoutState-&gt;pageLogicalHeight())
 340         setPageLogicalOffset(layoutState-&gt;pageLogicalOffset(this, logicalTop()));
 341 
 342     // Update our scrollbars if we&#39;re overflow:auto/scroll/hidden now that we know if
 343     // we overflow or not.
 344     updateScrollInfoAfterLayout();
 345 
 346     // Repaint with our new bounds if they are different from our old bounds.
 347     repainter.repaintAfterLayout();
 348 
 349     clearNeedsLayout();
 350 }
 351 
 352 // The first walk over our kids is to find out if we have any flexible children.
 353 static void gatherFlexChildrenInfo(FlexBoxIterator&amp; iterator, bool relayoutChildren, unsigned int&amp; highestFlexGroup, unsigned int&amp; lowestFlexGroup, bool&amp; haveFlex)
 354 {
 355     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 356         // Check to see if this child flexes.
 357         if (!childDoesNotAffectWidthOrFlexing(child) &amp;&amp; child-&gt;style().boxFlex() &gt; 0.0f) {
 358             // We always have to lay out flexible objects again, since the flex distribution
 359             // may have changed, and we need to reallocate space.
 360             child-&gt;clearOverrideContentSize();
 361             if (!relayoutChildren)
 362                 child-&gt;setChildNeedsLayout(MarkOnlyThis);
 363             haveFlex = true;
 364             unsigned flexGroup = child-&gt;style().boxFlexGroup();
 365             if (lowestFlexGroup == 0)
 366                 lowestFlexGroup = flexGroup;
 367             if (flexGroup &lt; lowestFlexGroup)
 368                 lowestFlexGroup = flexGroup;
 369             if (flexGroup &gt; highestFlexGroup)
 370                 highestFlexGroup = flexGroup;
 371         }
 372     }
 373 }
 374 
 375 static void layoutChildIfNeededApplyingDelta(RenderBox* child, const LayoutSize&amp; layoutDelta)
 376 {
 377     if (!child-&gt;needsLayout())
 378         return;
 379 
 380     child-&gt;view().frameView().layoutContext().addLayoutDelta(layoutDelta);
 381     child-&gt;layoutIfNeeded();
 382     child-&gt;view().frameView().layoutContext().addLayoutDelta(-layoutDelta);
 383 }
 384 
 385 void RenderDeprecatedFlexibleBox::layoutHorizontalBox(bool relayoutChildren)
 386 {
 387     LayoutUnit toAdd = borderBottom() + paddingBottom() + horizontalScrollbarHeight();
 388     LayoutUnit yPos = borderTop() + paddingTop();
 389     LayoutUnit xPos = borderLeft() + paddingLeft();
 390     bool heightSpecified = false;
 391     LayoutUnit oldHeight;
 392 
 393     LayoutUnit remainingSpace;
 394 
 395     FlexBoxIterator iterator(this);
 396     unsigned int highestFlexGroup = 0;
 397     unsigned int lowestFlexGroup = 0;
 398     bool haveFlex = false, flexingChildren = false;
 399     gatherFlexChildrenInfo(iterator, relayoutChildren, highestFlexGroup, lowestFlexGroup, haveFlex);
 400 
 401     beginUpdateScrollInfoAfterLayoutTransaction();
 402 
 403     ChildLayoutDeltas childLayoutDeltas;
 404     appendChildLayoutDeltas(this, childLayoutDeltas);
 405 
 406     // We do 2 passes.  The first pass is simply to lay everyone out at
 407     // their preferred widths. The subsequent passes handle flexing the children.
 408     // The first pass skips flexible objects completely.
 409     do {
 410         // Reset our height.
 411         setHeight(yPos);
 412 
 413         xPos = borderLeft() + paddingLeft();
 414 
 415         size_t childIndex = 0;
 416 
 417         // Our first pass is done without flexing.  We simply lay the children
 418         // out within the box.  We have to do a layout first in order to determine
 419         // our box&#39;s intrinsic height.
 420         LayoutUnit maxAscent, maxDescent;
 421         for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 422             if (relayoutChildren)
 423                 child-&gt;setChildNeedsLayout(MarkOnlyThis);
 424 
 425             if (child-&gt;isOutOfFlowPositioned())
 426                 continue;
 427 
 428             LayoutSize&amp; childLayoutDelta = childLayoutDeltas[childIndex++];
 429 
 430             // Compute the child&#39;s vertical margins.
 431             child-&gt;computeAndSetBlockDirectionMargins(*this);
 432 
 433             child-&gt;markForPaginationRelayoutIfNeeded();
 434 
 435             // Apply the child&#39;s current layout delta.
 436             layoutChildIfNeededApplyingDelta(child, childLayoutDelta);
 437 
 438             // Update our height and overflow height.
 439             if (style().boxAlign() == BoxAlignment::Baseline) {
 440                 LayoutUnit ascent = child-&gt;firstLineBaseline().valueOr(child-&gt;height() + child-&gt;marginBottom());
 441                 ascent += child-&gt;marginTop();
 442                 LayoutUnit descent = (child-&gt;height() + child-&gt;verticalMarginExtent()) - ascent;
 443 
 444                 // Update our maximum ascent.
 445                 maxAscent = std::max(maxAscent, ascent);
 446 
 447                 // Update our maximum descent.
 448                 maxDescent = std::max(maxDescent, descent);
 449 
 450                 // Now update our height.
 451                 setHeight(std::max(yPos + maxAscent + maxDescent, height()));
 452             }
 453             else
 454                 setHeight(std::max(height(), yPos + child-&gt;height() + child-&gt;verticalMarginExtent()));
 455         }
 456         ASSERT(childIndex == childLayoutDeltas.size());
 457 
 458         if (!iterator.first() &amp;&amp; hasLineIfEmpty())
 459             setHeight(height() + lineHeight(true, style().isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
 460 
 461         setHeight(height() + toAdd);
 462 
 463         oldHeight = height();
 464         updateLogicalHeight();
 465 
 466         relayoutChildren = false;
 467         if (oldHeight != height())
 468             heightSpecified = true;
 469 
 470         // Now that our height is actually known, we can place our boxes.
 471         childIndex = 0;
 472         m_stretchingChildren = (style().boxAlign() == BoxAlignment::Stretch);
 473         for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 474             if (child-&gt;isOutOfFlowPositioned()) {
 475                 child-&gt;containingBlock()-&gt;insertPositionedObject(*child);
 476                 RenderLayer* childLayer = child-&gt;layer();
 477                 childLayer-&gt;setStaticInlinePosition(xPos); // FIXME: Not right for regions.
 478                 if (childLayer-&gt;staticBlockPosition() != yPos) {
 479                     childLayer-&gt;setStaticBlockPosition(yPos);
 480                     if (child-&gt;style().hasStaticBlockPosition(style().isHorizontalWritingMode()))
 481                         child-&gt;setChildNeedsLayout(MarkOnlyThis);
 482                 }
 483                 continue;
 484             }
 485 
 486             LayoutSize&amp; childLayoutDelta = childLayoutDeltas[childIndex++];
 487 
 488             if (child-&gt;style().visibility() == Visibility::Collapse) {
 489                 // visibility: collapsed children do not participate in our positioning.
 490                 // But we need to lay them out.
 491                 layoutChildIfNeededApplyingDelta(child, childLayoutDelta);
 492                 continue;
 493             }
 494 
 495             // We need to see if this child&#39;s height has changed, since we make block elements
 496             // fill the height of a containing box by default.
 497             // Now do a layout.
 498             LayoutUnit oldChildHeight = child-&gt;height();
 499             child-&gt;updateLogicalHeight();
 500             if (oldChildHeight != child-&gt;height())
 501                 child-&gt;setChildNeedsLayout(MarkOnlyThis);
 502 
 503             child-&gt;markForPaginationRelayoutIfNeeded();
 504 
 505             layoutChildIfNeededApplyingDelta(child, childLayoutDelta);
 506 
 507             // We can place the child now, using our value of box-align.
 508             xPos += child-&gt;marginLeft();
 509             LayoutUnit childY = yPos;
 510             switch (style().boxAlign()) {
 511             case BoxAlignment::Center:
 512                 childY += child-&gt;marginTop() + std::max&lt;LayoutUnit&gt;(0, (contentHeight() - (child-&gt;height() + child-&gt;verticalMarginExtent())) / 2);
 513                 break;
 514             case BoxAlignment::Baseline: {
 515                 LayoutUnit ascent = child-&gt;firstLineBaseline().valueOr(child-&gt;height() + child-&gt;marginBottom());
 516                 ascent += child-&gt;marginTop();
 517                 childY += child-&gt;marginTop() + (maxAscent - ascent);
 518                 break;
 519             }
 520             case BoxAlignment::End:
 521                 childY += contentHeight() - child-&gt;marginBottom() - child-&gt;height();
 522                 break;
 523             default: // BoxAlignment::Start
 524                 childY += child-&gt;marginTop();
 525                 break;
 526             }
 527 
 528             placeChild(child, LayoutPoint(xPos, childY), &amp;childLayoutDelta);
 529 
 530             xPos += child-&gt;width() + child-&gt;marginRight();
 531         }
 532         ASSERT(childIndex == childLayoutDeltas.size());
 533 
 534         remainingSpace = borderLeft() + paddingLeft() + contentWidth() - xPos;
 535 
 536         m_stretchingChildren = false;
 537         if (flexingChildren)
 538             haveFlex = false; // We&#39;re done.
 539         else if (haveFlex) {
 540             // We have some flexible objects.  See if we need to grow/shrink them at all.
 541             if (!remainingSpace)
 542                 break;
 543 
 544             // Allocate the remaining space among the flexible objects.  If we are trying to
 545             // grow, then we go from the lowest flex group to the highest flex group.  For shrinking,
 546             // we go from the highest flex group to the lowest group.
 547             bool expanding = remainingSpace &gt; 0;
 548             unsigned int start = expanding ? lowestFlexGroup : highestFlexGroup;
 549             unsigned int end = expanding? highestFlexGroup : lowestFlexGroup;
 550             for (unsigned int i = start; i &lt;= end &amp;&amp; remainingSpace; i++) {
 551                 // Always start off by assuming the group can get all the remaining space.
 552                 LayoutUnit groupRemainingSpace = remainingSpace;
 553                 do {
 554                     // Flexing consists of multiple passes, since we have to change ratios every time an object hits its max/min-width
 555                     // For a given pass, we always start off by computing the totalFlex of all objects that can grow/shrink at all, and
 556                     // computing the allowed growth before an object hits its min/max width (and thus
 557                     // forces a totalFlex recomputation).
 558                     LayoutUnit groupRemainingSpaceAtBeginning = groupRemainingSpace;
 559                     float totalFlex = 0.0f;
 560                     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 561                         if (allowedChildFlex(child, expanding, i))
 562                             totalFlex += child-&gt;style().boxFlex();
 563                     }
 564                     LayoutUnit spaceAvailableThisPass = groupRemainingSpace;
 565                     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 566                         LayoutUnit allowedFlex = allowedChildFlex(child, expanding, i);
 567                         if (allowedFlex) {
 568                             LayoutUnit projectedFlex = (allowedFlex == LayoutUnit::max()) ? allowedFlex : LayoutUnit(allowedFlex * (totalFlex / child-&gt;style().boxFlex()));
 569                             spaceAvailableThisPass = expanding ? std::min(spaceAvailableThisPass, projectedFlex) : std::max(spaceAvailableThisPass, projectedFlex);
 570                         }
 571                     }
 572 
 573                     // The flex groups may not have any flexible objects this time around.
 574                     if (!spaceAvailableThisPass || totalFlex == 0.0f) {
 575                         // If we just couldn&#39;t grow/shrink any more, then it&#39;s time to transition to the next flex group.
 576                         groupRemainingSpace = 0;
 577                         continue;
 578                     }
 579 
 580                     // Now distribute the space to objects.
 581                     for (RenderBox* child = iterator.first(); child &amp;&amp; spaceAvailableThisPass &amp;&amp; totalFlex; child = iterator.next()) {
 582                         if (child-&gt;style().visibility() == Visibility::Collapse)
 583                             continue;
 584 
 585                         if (allowedChildFlex(child, expanding, i)) {
 586                             LayoutUnit spaceAdd = LayoutUnit(spaceAvailableThisPass * (child-&gt;style().boxFlex() / totalFlex));
 587                             if (spaceAdd) {
 588                                 child-&gt;setOverrideContentLogicalWidth(contentWidthForChild(child) + spaceAdd);
 589                                 flexingChildren = true;
 590                                 relayoutChildren = true;
 591                             }
 592 
 593                             spaceAvailableThisPass -= spaceAdd;
 594                             remainingSpace -= spaceAdd;
 595                             groupRemainingSpace -= spaceAdd;
 596 
 597                             totalFlex -= child-&gt;style().boxFlex();
 598                         }
 599                     }
 600                     if (groupRemainingSpace == groupRemainingSpaceAtBeginning) {
 601                         // This is not advancing, avoid getting stuck by distributing the remaining pixels.
 602                         LayoutUnit spaceAdd = groupRemainingSpace &gt; 0 ? 1 : -1;
 603                         for (RenderBox* child = iterator.first(); child &amp;&amp; groupRemainingSpace; child = iterator.next()) {
 604                             if (allowedChildFlex(child, expanding, i)) {
 605                                 child-&gt;setOverrideContentLogicalWidth(contentWidthForChild(child) + spaceAdd);
 606                                 flexingChildren = true;
 607                                 relayoutChildren = true;
 608                                 remainingSpace -= spaceAdd;
 609                                 groupRemainingSpace -= spaceAdd;
 610                             }
 611                         }
 612                     }
 613                 } while (absoluteValue(groupRemainingSpace) &gt;= 1);
 614             }
 615 
 616             // We didn&#39;t find any children that could grow.
 617             if (haveFlex &amp;&amp; !flexingChildren)
 618                 haveFlex = false;
 619         }
 620     } while (haveFlex);
 621 
 622     endAndCommitUpdateScrollInfoAfterLayoutTransaction();
 623 
 624     if (remainingSpace &gt; 0 &amp;&amp; ((style().isLeftToRightDirection() &amp;&amp; style().boxPack() != BoxPack::Start)
 625         || (!style().isLeftToRightDirection() &amp;&amp; style().boxPack() != BoxPack::End))) {
 626         // Children must be repositioned.
 627         LayoutUnit offset;
 628         if (style().boxPack() == BoxPack::Justify) {
 629             // Determine the total number of children.
 630             int totalChildren = 0;
 631             for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 632                 if (childDoesNotAffectWidthOrFlexing(child))
 633                     continue;
 634                 ++totalChildren;
 635             }
 636 
 637             // Iterate over the children and space them out according to the
 638             // justification level.
 639             if (totalChildren &gt; 1) {
 640                 --totalChildren;
 641                 bool firstChild = true;
 642                 for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 643                     if (childDoesNotAffectWidthOrFlexing(child))
 644                         continue;
 645 
 646                     if (firstChild) {
 647                         firstChild = false;
 648                         continue;
 649                     }
 650 
 651                     offset += remainingSpace/totalChildren;
 652                     remainingSpace -= (remainingSpace/totalChildren);
 653                     --totalChildren;
 654 
 655                     placeChild(child, child-&gt;location() + LayoutSize(offset, 0_lu));
 656                 }
 657             }
 658         } else {
 659             if (style().boxPack() == BoxPack::Center)
 660                 offset += remainingSpace / 2;
 661             else // BoxPack::End for LTR, BoxPack::Start for RTL
 662                 offset += remainingSpace;
 663             for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 664                 if (childDoesNotAffectWidthOrFlexing(child))
 665                     continue;
 666 
 667                 placeChild(child, child-&gt;location() + LayoutSize(offset, 0_lu));
 668             }
 669         }
 670     }
 671 
 672     // So that the computeLogicalHeight in layoutBlock() knows to relayout positioned objects because of
 673     // a height change, we revert our height back to the intrinsic height before returning.
 674     if (heightSpecified)
 675         setHeight(oldHeight);
 676 }
 677 
 678 void RenderDeprecatedFlexibleBox::layoutVerticalBox(bool relayoutChildren)
 679 {
 680     LayoutUnit yPos = borderTop() + paddingTop();
 681     LayoutUnit toAdd = borderBottom() + paddingBottom() + horizontalScrollbarHeight();
 682     bool heightSpecified = false;
 683     LayoutUnit oldHeight;
 684 
 685     LayoutUnit remainingSpace;
 686 
 687     FlexBoxIterator iterator(this);
 688     unsigned int highestFlexGroup = 0;
 689     unsigned int lowestFlexGroup = 0;
 690     bool haveFlex = false, flexingChildren = false;
 691     gatherFlexChildrenInfo(iterator, relayoutChildren, highestFlexGroup, lowestFlexGroup, haveFlex);
 692 
 693     // We confine the line clamp ugliness to vertical flexible boxes (thus keeping it out of
 694     // mainstream block layout); this is not really part of the XUL box model.
 695     bool haveLineClamp = !style().lineClamp().isNone();
 696     if (haveLineClamp)
 697         applyLineClamp(iterator, relayoutChildren);
 698 
 699     beginUpdateScrollInfoAfterLayoutTransaction();
 700 
 701     ChildLayoutDeltas childLayoutDeltas;
 702     appendChildLayoutDeltas(this, childLayoutDeltas);
 703 
 704     // We do 2 passes.  The first pass is simply to lay everyone out at
 705     // their preferred widths.  The second pass handles flexing the children.
 706     // Our first pass is done without flexing.  We simply lay the children
 707     // out within the box.
 708     do {
 709         setHeight(borderTop() + paddingTop());
 710         LayoutUnit minHeight = height() + toAdd;
 711 
 712         size_t childIndex = 0;
 713         for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 714             // Make sure we relayout children if we need it.
 715             if (!haveLineClamp &amp;&amp; relayoutChildren)
 716                 child-&gt;setChildNeedsLayout(MarkOnlyThis);
 717 
 718             if (child-&gt;isOutOfFlowPositioned()) {
 719                 child-&gt;containingBlock()-&gt;insertPositionedObject(*child);
 720                 RenderLayer* childLayer = child-&gt;layer();
 721                 childLayer-&gt;setStaticInlinePosition(borderStart() + paddingStart()); // FIXME: Not right for regions.
 722                 if (childLayer-&gt;staticBlockPosition() != height()) {
 723                     childLayer-&gt;setStaticBlockPosition(height());
 724                     if (child-&gt;style().hasStaticBlockPosition(style().isHorizontalWritingMode()))
 725                         child-&gt;setChildNeedsLayout(MarkOnlyThis);
 726                 }
 727                 continue;
 728             }
 729 
 730             LayoutSize&amp; childLayoutDelta = childLayoutDeltas[childIndex++];
 731 
 732             if (child-&gt;style().visibility() == Visibility::Collapse) {
 733                 // visibility: collapsed children do not participate in our positioning.
 734                 // But we need to lay them down.
 735                 layoutChildIfNeededApplyingDelta(child, childLayoutDelta);
 736                 continue;
 737             }
 738 
 739             // Compute the child&#39;s vertical margins.
 740             child-&gt;computeAndSetBlockDirectionMargins(*this);
 741 
 742             // Add in the child&#39;s marginTop to our height.
 743             setHeight(height() + child-&gt;marginTop());
 744 
 745             child-&gt;markForPaginationRelayoutIfNeeded();
 746 
 747             // Now do a layout.
 748             layoutChildIfNeededApplyingDelta(child, childLayoutDelta);
 749 
 750             // We can place the child now, using our value of box-align.
 751             LayoutUnit childX = borderLeft() + paddingLeft();
 752             switch (style().boxAlign()) {
 753             case BoxAlignment::Center:
 754             case BoxAlignment::Baseline: // Baseline just maps to center for vertical boxes
 755                 childX += child-&gt;marginLeft() + std::max&lt;LayoutUnit&gt;(0, (contentWidth() - (child-&gt;width() + child-&gt;horizontalMarginExtent())) / 2);
 756                 break;
 757             case BoxAlignment::End:
 758                 if (!style().isLeftToRightDirection())
 759                     childX += child-&gt;marginLeft();
 760                 else
 761                     childX += contentWidth() - child-&gt;marginRight() - child-&gt;width();
 762                 break;
 763             default: // BoxAlignment::Start/BoxAlignment::Stretch
 764                 if (style().isLeftToRightDirection())
 765                     childX += child-&gt;marginLeft();
 766                 else
 767                     childX += contentWidth() - child-&gt;marginRight() - child-&gt;width();
 768                 break;
 769             }
 770 
 771             // Place the child.
 772             placeChild(child, LayoutPoint(childX, height()), &amp;childLayoutDelta);
 773             setHeight(height() + child-&gt;height() + child-&gt;marginBottom());
 774         }
 775         ASSERT(childIndex == childLayoutDeltas.size());
 776 
 777         yPos = height();
 778 
 779         if (!iterator.first() &amp;&amp; hasLineIfEmpty())
 780             setHeight(height() + lineHeight(true, style().isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes));
 781 
 782         setHeight(height() + toAdd);
 783 
 784         // Negative margins can cause our height to shrink below our minimal height (border/padding).
 785         // If this happens, ensure that the computed height is increased to the minimal height.
 786         if (height() &lt; minHeight)
 787             setHeight(minHeight);
 788 
 789         // Now we have to calc our height, so we know how much space we have remaining.
 790         oldHeight = height();
 791         updateLogicalHeight();
 792         if (oldHeight != height())
 793             heightSpecified = true;
 794 
 795         remainingSpace = borderTop() + paddingTop() + contentHeight() - yPos;
 796 
 797         if (flexingChildren)
 798             haveFlex = false; // We&#39;re done.
 799         else if (haveFlex) {
 800             // We have some flexible objects.  See if we need to grow/shrink them at all.
 801             if (!remainingSpace)
 802                 break;
 803 
 804             // Allocate the remaining space among the flexible objects.  If we are trying to
 805             // grow, then we go from the lowest flex group to the highest flex group.  For shrinking,
 806             // we go from the highest flex group to the lowest group.
 807             bool expanding = remainingSpace &gt; 0;
 808             unsigned int start = expanding ? lowestFlexGroup : highestFlexGroup;
 809             unsigned int end = expanding? highestFlexGroup : lowestFlexGroup;
 810             for (unsigned int i = start; i &lt;= end &amp;&amp; remainingSpace; i++) {
 811                 // Always start off by assuming the group can get all the remaining space.
 812                 LayoutUnit groupRemainingSpace = remainingSpace;
 813                 do {
 814                     // Flexing consists of multiple passes, since we have to change ratios every time an object hits its max/min-width
 815                     // For a given pass, we always start off by computing the totalFlex of all objects that can grow/shrink at all, and
 816                     // computing the allowed growth before an object hits its min/max width (and thus
 817                     // forces a totalFlex recomputation).
 818                     LayoutUnit groupRemainingSpaceAtBeginning = groupRemainingSpace;
 819                     float totalFlex = 0.0f;
 820                     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 821                         if (allowedChildFlex(child, expanding, i))
 822                             totalFlex += child-&gt;style().boxFlex();
 823                     }
 824                     LayoutUnit spaceAvailableThisPass = groupRemainingSpace;
 825                     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 826                         LayoutUnit allowedFlex = allowedChildFlex(child, expanding, i);
 827                         if (allowedFlex) {
 828                             LayoutUnit projectedFlex = (allowedFlex == LayoutUnit::max()) ? allowedFlex : LayoutUnit(allowedFlex * (totalFlex / child-&gt;style().boxFlex()));
 829                             spaceAvailableThisPass = expanding ? std::min(spaceAvailableThisPass, projectedFlex) : std::max(spaceAvailableThisPass, projectedFlex);
 830                         }
 831                     }
 832 
 833                     // The flex groups may not have any flexible objects this time around.
 834                     if (!spaceAvailableThisPass || totalFlex == 0.0f) {
 835                         // If we just couldn&#39;t grow/shrink any more, then it&#39;s time to transition to the next flex group.
 836                         groupRemainingSpace = 0;
 837                         continue;
 838                     }
 839 
 840                     // Now distribute the space to objects.
 841                     for (RenderBox* child = iterator.first(); child &amp;&amp; spaceAvailableThisPass &amp;&amp; totalFlex; child = iterator.next()) {
 842                         if (allowedChildFlex(child, expanding, i)) {
 843                             LayoutUnit spaceAdd { spaceAvailableThisPass * (child-&gt;style().boxFlex() / totalFlex) };
 844                             if (spaceAdd) {
 845                                 child-&gt;setOverrideContentLogicalHeight(contentHeightForChild(child) + spaceAdd);
 846                                 flexingChildren = true;
 847                                 relayoutChildren = true;
 848                             }
 849 
 850                             spaceAvailableThisPass -= spaceAdd;
 851                             remainingSpace -= spaceAdd;
 852                             groupRemainingSpace -= spaceAdd;
 853 
 854                             totalFlex -= child-&gt;style().boxFlex();
 855                         }
 856                     }
 857                     if (groupRemainingSpace == groupRemainingSpaceAtBeginning) {
 858                         // This is not advancing, avoid getting stuck by distributing the remaining pixels.
 859                         LayoutUnit spaceAdd = groupRemainingSpace &gt; 0 ? 1 : -1;
 860                         for (RenderBox* child = iterator.first(); child &amp;&amp; groupRemainingSpace; child = iterator.next()) {
 861                             if (allowedChildFlex(child, expanding, i)) {
 862                                 child-&gt;setOverrideContentLogicalHeight(contentHeightForChild(child) + spaceAdd);
 863                                 flexingChildren = true;
 864                                 relayoutChildren = true;
 865                                 remainingSpace -= spaceAdd;
 866                                 groupRemainingSpace -= spaceAdd;
 867                             }
 868                         }
 869                     }
 870                 } while (absoluteValue(groupRemainingSpace) &gt;= 1);
 871             }
 872 
 873             // We didn&#39;t find any children that could grow.
 874             if (haveFlex &amp;&amp; !flexingChildren)
 875                 haveFlex = false;
 876         }
 877     } while (haveFlex);
 878 
 879     endAndCommitUpdateScrollInfoAfterLayoutTransaction();
 880 
 881     if (style().boxPack() != BoxPack::Start &amp;&amp; remainingSpace &gt; 0) {
 882         // Children must be repositioned.
 883         LayoutUnit offset;
 884         if (style().boxPack() == BoxPack::Justify) {
 885             // Determine the total number of children.
 886             int totalChildren = 0;
 887             for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 888                 if (childDoesNotAffectWidthOrFlexing(child))
 889                     continue;
 890 
 891                 ++totalChildren;
 892             }
 893 
 894             // Iterate over the children and space them out according to the
 895             // justification level.
 896             if (totalChildren &gt; 1) {
 897                 --totalChildren;
 898                 bool firstChild = true;
 899                 for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 900                     if (childDoesNotAffectWidthOrFlexing(child))
 901                         continue;
 902 
 903                     if (firstChild) {
 904                         firstChild = false;
 905                         continue;
 906                     }
 907 
 908                     offset += remainingSpace/totalChildren;
 909                     remainingSpace -= (remainingSpace/totalChildren);
 910                     --totalChildren;
 911                     placeChild(child, child-&gt;location() + LayoutSize(0_lu, offset));
 912                 }
 913             }
 914         } else {
 915             if (style().boxPack() == BoxPack::Center)
 916                 offset += remainingSpace / 2;
 917             else // BoxPack::End
 918                 offset += remainingSpace;
 919             for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 920                 if (childDoesNotAffectWidthOrFlexing(child))
 921                     continue;
 922                 placeChild(child, child-&gt;location() + LayoutSize(0_lu, offset));
 923             }
 924         }
 925     }
 926 
 927     // So that the computeLogicalHeight in layoutBlock() knows to relayout positioned objects because of
 928     // a height change, we revert our height back to the intrinsic height before returning.
 929     if (heightSpecified)
 930         setHeight(oldHeight);
 931 }
 932 
 933 void RenderDeprecatedFlexibleBox::applyLineClamp(FlexBoxIterator&amp; iterator, bool relayoutChildren)
 934 {
 935     int maxLineCount = 0;
 936     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 937         if (childDoesNotAffectWidthOrFlexing(child))
 938             continue;
 939 
 940         child-&gt;clearOverrideContentSize();
 941         if (relayoutChildren || (child-&gt;isReplaced() &amp;&amp; (child-&gt;style().width().isPercentOrCalculated() || child-&gt;style().height().isPercentOrCalculated()))
 942             || (child-&gt;style().height().isAuto() &amp;&amp; is&lt;RenderBlockFlow&gt;(*child))) {
 943             child-&gt;setChildNeedsLayout(MarkOnlyThis);
 944 
 945             // Dirty all the positioned objects.
 946             if (is&lt;RenderBlockFlow&gt;(*child)) {
 947                 downcast&lt;RenderBlockFlow&gt;(*child).markPositionedObjectsForLayout();
 948                 downcast&lt;RenderBlockFlow&gt;(*child).clearTruncation();
 949             }
 950         }
 951         child-&gt;layoutIfNeeded();
 952         if (child-&gt;style().height().isAuto() &amp;&amp; is&lt;RenderBlockFlow&gt;(*child))
 953             maxLineCount = std::max(maxLineCount, downcast&lt;RenderBlockFlow&gt;(*child).lineCount());
 954     }
 955 
 956     // Get the number of lines and then alter all block flow children with auto height to use the
 957     // specified height. We always try to leave room for at least one line.
 958     LineClampValue lineClamp = style().lineClamp();
 959     int numVisibleLines = lineClamp.isPercentage() ? std::max(1, (maxLineCount + 1) * lineClamp.value() / 100) : lineClamp.value();
 960     if (numVisibleLines &gt;= maxLineCount)
 961         return;
 962 
 963     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
 964         if (childDoesNotAffectWidthOrFlexing(child) || !child-&gt;style().height().isAuto() || !is&lt;RenderBlockFlow&gt;(*child))
 965             continue;
 966 
 967         RenderBlockFlow&amp; blockChild = downcast&lt;RenderBlockFlow&gt;(*child);
 968         int lineCount = blockChild.lineCount();
 969         if (lineCount &lt;= numVisibleLines)
 970             continue;
 971 
 972         LayoutUnit newHeight = blockChild.heightForLineCount(numVisibleLines);
 973         if (newHeight == child-&gt;height())
 974             continue;
 975 
 976         child-&gt;setChildNeedsLayout(MarkOnlyThis);
 977         child-&gt;setOverrideContentLogicalHeight(newHeight - child-&gt;verticalBorderAndPaddingExtent());
 978         child-&gt;layoutIfNeeded();
 979 
 980         // FIXME: For now don&#39;t support RTL.
 981         if (style().direction() != TextDirection::LTR)
 982             continue;
 983 
 984         // Get the last line
 985         RootInlineBox* lastLine = blockChild.lineAtIndex(lineCount - 1);
 986         if (!lastLine)
 987             continue;
 988 
 989         RootInlineBox* lastVisibleLine = blockChild.lineAtIndex(numVisibleLines - 1);
 990         if (!lastVisibleLine)
 991             continue;
 992 
 993         const UChar ellipsisAndSpace[2] = { horizontalEllipsis, &#39; &#39; };
 994         static NeverDestroyed&lt;AtomString&gt; ellipsisAndSpaceStr(ellipsisAndSpace, 2);
 995         static NeverDestroyed&lt;AtomString&gt; ellipsisStr(&amp;horizontalEllipsis, 1);
 996         const RenderStyle&amp; lineStyle = numVisibleLines == 1 ? firstLineStyle() : style();
 997         const FontCascade&amp; font = lineStyle.fontCascade();
 998 
 999         // Get ellipsis width, and if the last child is an anchor, it will go after the ellipsis, so add in a space and the anchor width too
1000         LayoutUnit totalWidth;
1001         InlineBox* anchorBox = lastLine-&gt;lastChild();
1002         if (anchorBox &amp;&amp; anchorBox-&gt;renderer().style().isLink())
1003             totalWidth = anchorBox-&gt;logicalWidth() + font.width(constructTextRun(ellipsisAndSpace, 2, style()));
1004         else {
1005             anchorBox = nullptr;
1006             totalWidth = font.width(constructTextRun(&amp;horizontalEllipsis, 1, style()));
1007         }
1008 
1009         // See if this width can be accommodated on the last visible line
1010         RenderBlockFlow&amp; destBlock = lastVisibleLine-&gt;blockFlow();
1011         RenderBlockFlow&amp; srcBlock = lastLine-&gt;blockFlow();
1012 
1013         // FIXME: Directions of src/destBlock could be different from our direction and from one another.
1014         if (!srcBlock.style().isLeftToRightDirection())
1015             continue;
1016 
1017         bool leftToRight = destBlock.style().isLeftToRightDirection();
1018         if (!leftToRight)
1019             continue;
1020 
1021         LayoutUnit blockRightEdge = destBlock.logicalRightOffsetForLine(LayoutUnit(lastVisibleLine-&gt;y()), DoNotIndentText);
1022         if (!lastVisibleLine-&gt;lineCanAccommodateEllipsis(leftToRight, blockRightEdge, lastVisibleLine-&gt;x() + lastVisibleLine-&gt;logicalWidth(), totalWidth))
1023             continue;
1024 
1025         // Let the truncation code kick in.
1026         // FIXME: the text alignment should be recomputed after the width changes due to truncation.
1027         LayoutUnit blockLeftEdge = destBlock.logicalLeftOffsetForLine(LayoutUnit(lastVisibleLine-&gt;y()), DoNotIndentText);
1028         lastVisibleLine-&gt;placeEllipsis(anchorBox ? ellipsisAndSpaceStr : ellipsisStr, leftToRight, blockLeftEdge, blockRightEdge, totalWidth, anchorBox);
1029         destBlock.setHasMarkupTruncation(true);
1030     }
1031 }
1032 
1033 void RenderDeprecatedFlexibleBox::clearLineClamp()
1034 {
1035     FlexBoxIterator iterator(this);
1036     for (RenderBox* child = iterator.first(); child; child = iterator.next()) {
1037         if (childDoesNotAffectWidthOrFlexing(child))
1038             continue;
1039 
1040         child-&gt;clearOverrideContentSize();
1041         if ((child-&gt;isReplaced() &amp;&amp; (child-&gt;style().width().isPercentOrCalculated() || child-&gt;style().height().isPercentOrCalculated()))
1042             || (child-&gt;style().height().isAuto() &amp;&amp; is&lt;RenderBlockFlow&gt;(*child))) {
1043             child-&gt;setChildNeedsLayout();
1044 
1045             if (is&lt;RenderBlockFlow&gt;(*child)) {
1046                 downcast&lt;RenderBlockFlow&gt;(*child).markPositionedObjectsForLayout();
1047                 downcast&lt;RenderBlockFlow&gt;(*child).clearTruncation();
1048             }
1049         }
1050     }
1051 }
1052 
1053 void RenderDeprecatedFlexibleBox::placeChild(RenderBox* child, const LayoutPoint&amp; location, LayoutSize* childLayoutDelta)
1054 {
1055     // Place the child and track the layout delta so we can apply it if we do another layout.
1056     if (childLayoutDelta)
1057         *childLayoutDelta += LayoutSize(child-&gt;x() - location.x(), child-&gt;y() - location.y());
1058     child-&gt;setLocation(location);
1059 }
1060 
1061 LayoutUnit RenderDeprecatedFlexibleBox::allowedChildFlex(RenderBox* child, bool expanding, unsigned int group)
1062 {
1063     if (childDoesNotAffectWidthOrFlexing(child) || child-&gt;style().boxFlex() == 0.0f || child-&gt;style().boxFlexGroup() != group)
1064         return 0;
1065 
1066     if (expanding) {
1067         if (isHorizontal()) {
1068             // FIXME: For now just handle fixed values.
1069             LayoutUnit maxWidth = LayoutUnit::max();
1070             LayoutUnit width = contentWidthForChild(child);
1071             if (!child-&gt;style().maxWidth().isUndefined() &amp;&amp; child-&gt;style().maxWidth().isFixed())
1072                 maxWidth = child-&gt;style().maxWidth().value();
1073             else if (child-&gt;style().maxWidth().type() == Intrinsic)
1074                 maxWidth = child-&gt;maxPreferredLogicalWidth();
1075             else if (child-&gt;style().maxWidth().type() == MinIntrinsic)
1076                 maxWidth = child-&gt;minPreferredLogicalWidth();
1077             if (maxWidth == LayoutUnit::max())
1078                 return maxWidth;
1079             return std::max&lt;LayoutUnit&gt;(0, maxWidth - width);
1080         } else {
1081             // FIXME: For now just handle fixed values.
1082             LayoutUnit maxHeight = LayoutUnit::max();
1083             LayoutUnit height = contentHeightForChild(child);
1084             if (!child-&gt;style().maxHeight().isUndefined() &amp;&amp; child-&gt;style().maxHeight().isFixed())
1085                 maxHeight = child-&gt;style().maxHeight().value();
1086             if (maxHeight == LayoutUnit::max())
1087                 return maxHeight;
1088             return std::max&lt;LayoutUnit&gt;(0, maxHeight - height);
1089         }
1090     }
1091 
1092     // FIXME: For now just handle fixed values.
1093     if (isHorizontal()) {
1094         LayoutUnit minWidth = child-&gt;minPreferredLogicalWidth();
1095         LayoutUnit width = contentWidthForChild(child);
1096         if (child-&gt;style().minWidth().isFixed())
1097             minWidth = child-&gt;style().minWidth().value();
1098         else if (child-&gt;style().minWidth().type() == Intrinsic)
1099             minWidth = child-&gt;maxPreferredLogicalWidth();
1100         else if (child-&gt;style().minWidth().type() == MinIntrinsic)
1101             minWidth = child-&gt;minPreferredLogicalWidth();
1102         else if (child-&gt;style().minWidth().type() == Auto)
1103             minWidth = 0;
1104 
1105         LayoutUnit allowedShrinkage = std::min&lt;LayoutUnit&gt;(0, minWidth - width);
1106         return allowedShrinkage;
1107     } else {
1108         Length minHeight = child-&gt;style().minHeight();
1109         if (minHeight.isFixed() || minHeight.isAuto()) {
1110             LayoutUnit minHeight { child-&gt;style().minHeight().value() };
1111             LayoutUnit height = contentHeightForChild(child);
1112             LayoutUnit allowedShrinkage = std::min&lt;LayoutUnit&gt;(0, minHeight - height);
1113             return allowedShrinkage;
1114         }
1115     }
1116 
1117     return 0;
1118 }
1119 
1120 const char* RenderDeprecatedFlexibleBox::renderName() const
1121 {
1122     if (isFloating())
1123         return &quot;RenderDeprecatedFlexibleBox (floating)&quot;;
1124     if (isOutOfFlowPositioned())
1125         return &quot;RenderDeprecatedFlexibleBox (positioned)&quot;;
1126     // FIXME: Temporary hack while the new generated content system is being implemented.
1127     if (isPseudoElement())
1128         return &quot;RenderDeprecatedFlexibleBox (generated)&quot;;
1129     if (isAnonymous())
1130         return &quot;RenderDeprecatedFlexibleBox (generated)&quot;;
1131     if (isRelativelyPositioned())
1132         return &quot;RenderDeprecatedFlexibleBox (relative positioned)&quot;;
1133     return &quot;RenderDeprecatedFlexibleBox&quot;;
1134 }
1135 
1136 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
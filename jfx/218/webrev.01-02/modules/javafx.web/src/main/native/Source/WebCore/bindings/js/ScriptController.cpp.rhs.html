<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;ScriptController.h&quot;
 23 
 24 #include &quot;BridgeJSC.h&quot;
 25 #include &quot;CachedScriptFetcher.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;CustomHeaderFields.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 29 #include &quot;DOMWrapperWorld.h&quot;</span>
 30 #include &quot;DocumentLoader.h&quot;
 31 #include &quot;Event.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;FrameLoaderClient.h&quot;
 35 #include &quot;HTMLPlugInElement.h&quot;
 36 #include &quot;InspectorInstrumentation.h&quot;
 37 #include &quot;JSDOMBindingSecurity.h&quot;
 38 #include &quot;JSDOMExceptionHandling.h&quot;
 39 #include &quot;JSDOMWindow.h&quot;
 40 #include &quot;JSDocument.h&quot;
 41 #include &quot;JSExecState.h&quot;
 42 #include &quot;LoadableModuleScript.h&quot;
 43 #include &quot;ModuleFetchFailureKind.h&quot;
 44 #include &quot;ModuleFetchParameters.h&quot;
 45 #include &quot;NP_jsobject.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;PageConsoleClient.h&quot;
 48 #include &quot;PageGroup.h&quot;
 49 #include &quot;PaymentCoordinator.h&quot;
 50 #include &quot;PluginViewBase.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 51 #include &quot;RunJavaScriptParameters.h&quot;</span>
 52 #include &quot;RuntimeApplicationChecks.h&quot;
 53 #include &quot;ScriptDisallowedScope.h&quot;
 54 #include &quot;ScriptSourceCode.h&quot;
 55 #include &quot;ScriptableDocumentParser.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &quot;UserGestureIndicator.h&quot;
 58 #include &quot;WebCoreJSClientData.h&quot;
 59 #include &quot;npruntime_impl.h&quot;
 60 #include &quot;runtime_root.h&quot;
 61 #include &lt;JavaScriptCore/Debugger.h&gt;
<a name="3" id="anc3"></a><span class="line-added"> 62 #include &lt;JavaScriptCore/Heap.h&gt;</span>
 63 #include &lt;JavaScriptCore/InitializeThreading.h&gt;
 64 #include &lt;JavaScriptCore/JSFunction.h&gt;
 65 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
 66 #include &lt;JavaScriptCore/JSLock.h&gt;
 67 #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
 68 #include &lt;JavaScriptCore/JSNativeStdFunction.h&gt;
 69 #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
 70 #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
 71 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 72 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<a name="4" id="anc4"></a><span class="line-added"> 73 #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;</span>
 74 #include &lt;wtf/SetForScope.h&gt;
<a name="5" id="anc5"></a><span class="line-added"> 75 #include &lt;wtf/SharedTask.h&gt;</span>
 76 #include &lt;wtf/Threading.h&gt;
 77 #include &lt;wtf/text/TextPosition.h&gt;
 78 
 79 namespace WebCore {
 80 using namespace JSC;
 81 
 82 void ScriptController::initializeThreading()
 83 {
 84 #if !PLATFORM(IOS_FAMILY)
 85     JSC::initializeThreading();
 86     WTF::initializeMainThread();
 87 #endif
 88 }
 89 
 90 ScriptController::ScriptController(Frame&amp; frame)
 91     : m_frame(frame)
 92     , m_sourceURL(0)
 93     , m_paused(false)
 94 #if ENABLE(NETSCAPE_PLUGIN_API)
 95     , m_windowScriptNPObject(0)
 96 #endif
 97 #if PLATFORM(COCOA)
 98     , m_windowScriptObject(0)
 99 #endif
100 {
101 }
102 
103 ScriptController::~ScriptController()
104 {
105     disconnectPlatformScriptObjects();
106 
107     if (m_cacheableBindingRootObject) {
108         JSLockHolder lock(commonVM());
109         m_cacheableBindingRootObject-&gt;invalidate();
110         m_cacheableBindingRootObject = nullptr;
111     }
112 }
113 
<a name="6" id="anc6"></a><span class="line-modified">114 JSC::JSValue ScriptController::evaluateInWorldIgnoringException(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
<span class="line-added">115 {</span>
<span class="line-added">116     auto result = evaluateInWorld(sourceCode, world);</span>
<span class="line-added">117     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 ValueOrException ScriptController::evaluateInWorld(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
121 {
122     JSLockHolder lock(world.vm());
123 
124     const SourceCode&amp; jsSourceCode = sourceCode.jsSourceCode();
125     String sourceURL = jsSourceCode.provider()-&gt;url();
126 
127     // evaluate code. Returns the JS return value or 0
128     // if there was none, an error occurred or the type couldn&#39;t be converted.
129 
130     // inlineCode is true for &lt;a href=&quot;javascript:doSomething()&quot;&gt;
131     // and false for &lt;script&gt;doSomething()&lt;/script&gt;. Check if it has the
132     // expected value in all cases.
133     // See smart window.open policy for where this is used.
134     auto&amp; proxy = jsWindowProxy(world);
<a name="7" id="anc7"></a><span class="line-modified">135     auto&amp; globalObject = *proxy.window();</span>
136     const String* savedSourceURL = m_sourceURL;
137     m_sourceURL = &amp;sourceURL;
138 
139     Ref&lt;Frame&gt; protector(m_frame);
140 
<a name="8" id="anc8"></a><span class="line-modified">141     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
142 
143     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<a name="9" id="anc9"></a><span class="line-modified">144     JSValue returnValue = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
145 
<a name="10" id="anc10"></a><span class="line-modified">146     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
147 
<a name="11" id="anc11"></a><span class="line-added">148     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
149     if (evaluationException) {
<a name="12" id="anc12"></a><span class="line-modified">150         ExceptionDetails details;</span>
<span class="line-modified">151         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-modified">152         optionalDetails = WTFMove(details);</span>
153     }
154 
155     m_sourceURL = savedSourceURL;
<a name="13" id="anc13"></a><span class="line-added">156     if (optionalDetails)</span>
<span class="line-added">157         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">158 </span>
159     return returnValue;
160 }
161 
<a name="14" id="anc14"></a><span class="line-modified">162 JSC::JSValue ScriptController::evaluateIgnoringException(const ScriptSourceCode&amp; sourceCode)</span>
163 {
<a name="15" id="anc15"></a><span class="line-modified">164     return evaluateInWorldIgnoringException(sourceCode, mainThreadNormalWorld());</span>
165 }
166 
167 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters, DOMWrapperWorld&amp; world)
168 {
169     JSLockHolder lock(world.vm());
170 
171     auto&amp; proxy = jsWindowProxy(world);
<a name="16" id="anc16"></a><span class="line-modified">172     auto&amp; lexicalGlobalObject = *proxy.window();</span>
173 
<a name="17" id="anc17"></a><span class="line-modified">174     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, moduleName, JSC::JSScriptFetchParameters::create(lexicalGlobalObject.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
175     setupModuleScriptHandlers(moduleScript, promise, world);
176 }
177 
178 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters)
179 {
180     loadModuleScriptInWorld(moduleScript, moduleName, WTFMove(topLevelFetchParameters), mainThreadNormalWorld());
181 }
182 
183 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)
184 {
185     JSLockHolder lock(world.vm());
186 
187     auto&amp; proxy = jsWindowProxy(world);
<a name="18" id="anc18"></a><span class="line-modified">188     auto&amp; lexicalGlobalObject = *proxy.window();</span>
189 
<a name="19" id="anc19"></a><span class="line-modified">190     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
191     setupModuleScriptHandlers(moduleScript, promise, world);
192 }
193 
194 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode)
195 {
196     loadModuleScriptInWorld(moduleScript, sourceCode, mainThreadNormalWorld());
197 }
198 
199 JSC::JSValue ScriptController::linkAndEvaluateModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, DOMWrapperWorld&amp; world)
200 {
201     JSC::VM&amp; vm = world.vm();
202     JSLockHolder lock(vm);
203 
204     auto&amp; proxy = jsWindowProxy(world);
<a name="20" id="anc20"></a><span class="line-modified">205     auto&amp; lexicalGlobalObject = *proxy.window();</span>
206 
207     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
208     // https://bugs.webkit.org/show_bug.cgi?id=164763
209     Ref&lt;Frame&gt; protector(m_frame);
210 
211     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<a name="21" id="anc21"></a><span class="line-modified">212     auto returnValue = JSExecState::linkAndEvaluateModule(lexicalGlobalObject, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);</span>
213     if (evaluationException) {
214         // FIXME: Give a chance to dump the stack trace if the &quot;crossorigin&quot; attribute allows.
215         // https://bugs.webkit.org/show_bug.cgi?id=164539
<a name="22" id="anc22"></a><span class="line-modified">216         reportException(&amp;lexicalGlobalObject, evaluationException, nullptr);</span>
217         return jsUndefined();
218     }
219     return returnValue;
220 }
221 
222 JSC::JSValue ScriptController::linkAndEvaluateModuleScript(LoadableModuleScript&amp; moduleScript)
223 {
224     return linkAndEvaluateModuleScriptInWorld(moduleScript, mainThreadNormalWorld());
225 }
226 
227 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord, DOMWrapperWorld&amp; world)
228 {
229     JSLockHolder lock(world.vm());
230 
231     const auto&amp; jsSourceCode = moduleRecord.sourceCode();
232 
233     auto&amp; proxy = jsWindowProxy(world);
<a name="23" id="anc23"></a><span class="line-modified">234     auto&amp; lexicalGlobalObject = *proxy.window();</span>
235     SetForScope&lt;const String*&gt; sourceURLScope(m_sourceURL, &amp;sourceURL.string());
236 
237     Ref&lt;Frame&gt; protector(m_frame);
238 
<a name="24" id="anc24"></a><span class="line-modified">239     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());</span>
<span class="line-modified">240     auto returnValue = moduleRecord.evaluate(&amp;lexicalGlobalObject);</span>
<span class="line-modified">241     InspectorInstrumentation::didEvaluateScript(m_frame);</span>

242 
243     return returnValue;
244 }
245 
246 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord)
247 {
248     return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
249 }
250 
<a name="25" id="anc25"></a><span class="line-modified">251 Ref&lt;DOMWrapperWorld&gt; ScriptController::createWorld(const String&amp; name, WorldType type)</span>
252 {
<a name="26" id="anc26"></a><span class="line-modified">253     return DOMWrapperWorld::create(commonVM(), type == WorldType::User ? DOMWrapperWorld::Type::User : DOMWrapperWorld::Type::Internal, name);</span>
254 }
255 
256 void ScriptController::getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp; worlds)
257 {
258     static_cast&lt;JSVMClientData*&gt;(commonVM().clientData)-&gt;getAllWorlds(worlds);
259 }
260 
261 void ScriptController::initScriptForWindowProxy(JSWindowProxy&amp; windowProxy)
262 {
263     auto&amp; world = windowProxy.world();
264 
265     jsCast&lt;JSDOMWindow*&gt;(windowProxy.window())-&gt;updateDocument();
266 
267     if (Document* document = m_frame.document())
268         document-&gt;contentSecurityPolicy()-&gt;didCreateWindowProxy(windowProxy);
269 
270     if (Page* page = m_frame.page()) {
271         windowProxy.attachDebugger(page-&gt;debugger());
272         windowProxy.window()-&gt;setProfileGroup(page-&gt;group().identifier());
273         windowProxy.window()-&gt;setConsoleClient(&amp;page-&gt;console());
274     }
275 
276     m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
277 }
278 
<a name="27" id="anc27"></a><span class="line-modified">279 static Identifier jsValueToModuleKey(JSGlobalObject* lexicalGlobalObject, JSValue value)</span>
280 {
281     if (value.isSymbol())
282         return Identifier::fromUid(jsCast&lt;Symbol*&gt;(value)-&gt;privateName());
283     ASSERT(value.isString());
<a name="28" id="anc28"></a><span class="line-modified">284     return asString(value)-&gt;toIdentifier(lexicalGlobalObject);</span>
285 }
286 
287 void ScriptController::setupModuleScriptHandlers(LoadableModuleScript&amp; moduleScriptRef, JSInternalPromise&amp; promise, DOMWrapperWorld&amp; world)
288 {
289     auto&amp; proxy = jsWindowProxy(world);
<a name="29" id="anc29"></a><span class="line-modified">290     auto&amp; lexicalGlobalObject = *proxy.window();</span>
291 
292     // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
293     // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
294     // Thus the promise returned from this function could remain unresolved.
295 
296     RefPtr&lt;LoadableModuleScript&gt; moduleScript(&amp;moduleScriptRef);
297 
<a name="30" id="anc30"></a><span class="line-modified">298     auto&amp; fulfillHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) -&gt; JSC::EncodedJSValue {</span>
<span class="line-modified">299         VM&amp; vm = globalObject-&gt;vm();</span>
300         auto scope = DECLARE_THROW_SCOPE(vm);
<a name="31" id="anc31"></a><span class="line-modified">301         Identifier moduleKey = jsValueToModuleKey(globalObject, callFrame-&gt;argument(0));</span>
302         RETURN_IF_EXCEPTION(scope, { });
303         moduleScript-&gt;notifyLoadCompleted(*moduleKey.impl());
304         return JSValue::encode(jsUndefined());
305     });
306 
<a name="32" id="anc32"></a><span class="line-modified">307     auto&amp; rejectHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">308         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">309         JSValue errorValue = callFrame-&gt;argument(0);</span>
310         if (errorValue.isObject()) {
311             auto* object = JSC::asObject(errorValue);
312             if (JSValue failureKindValue = object-&gt;getDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName())) {
313                 // This is host propagated error in the module loader pipeline.
314                 switch (static_cast&lt;ModuleFetchFailureKind&gt;(failureKindValue.asInt32())) {
315                 case ModuleFetchFailureKind::WasErrored:
316                     moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
317                         LoadableScript::ErrorType::CachedScript,
318                         WTF::nullopt
319                     });
320                     break;
321                 case ModuleFetchFailureKind::WasCanceled:
322                     moduleScript-&gt;notifyLoadWasCanceled();
323                     break;
324                 }
325                 return JSValue::encode(jsUndefined());
326             }
327         }
328 
329         auto scope = DECLARE_CATCH_SCOPE(vm);
330         moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
331             LoadableScript::ErrorType::CachedScript,
332             LoadableScript::ConsoleMessage {
333                 MessageSource::JS,
334                 MessageLevel::Error,
<a name="33" id="anc33"></a><span class="line-modified">335                 retrieveErrorMessage(*globalObject, vm, errorValue, scope),</span>
336             }
337         });
338         return JSValue::encode(jsUndefined());
339     });
340 
<a name="34" id="anc34"></a><span class="line-modified">341     promise.then(&amp;lexicalGlobalObject, &amp;fulfillHandler, &amp;rejectHandler);</span>
342 }
343 
344 WindowProxy&amp; ScriptController::windowProxy()
345 {
346     return m_frame.windowProxy();
347 }
348 
349 JSWindowProxy&amp; ScriptController::jsWindowProxy(DOMWrapperWorld&amp; world)
350 {
351     auto* jsWindowProxy = m_frame.windowProxy().jsWindowProxy(world);
352     ASSERT_WITH_MESSAGE(jsWindowProxy, &quot;The JSWindowProxy can only be null if the frame has been destroyed&quot;);
353     return *jsWindowProxy;
354 }
355 
356 TextPosition ScriptController::eventHandlerPosition() const
357 {
358     // FIXME: If we are not currently parsing, we should use our current location
359     // in JavaScript, to cover cases like &quot;element.setAttribute(&#39;click&#39;, ...)&quot;.
360 
361     // FIXME: This location maps to the end of the HTML tag, and not to the
362     // exact column number belonging to the event handler attribute.
363     auto* parser = m_frame.document()-&gt;scriptableDocumentParser();
364     if (parser)
365         return parser-&gt;textPosition();
366     return TextPosition();
367 }
368 
369 void ScriptController::enableEval()
370 {
371     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
372     if (!jsWindowProxy)
373         return;
374     jsWindowProxy-&gt;window()-&gt;setEvalEnabled(true);
375 }
376 
377 void ScriptController::enableWebAssembly()
378 {
379     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
380     if (!jsWindowProxy)
381         return;
382     jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(true);
383 }
384 
385 void ScriptController::disableEval(const String&amp; errorMessage)
386 {
387     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
388     if (!jsWindowProxy)
389         return;
390     jsWindowProxy-&gt;window()-&gt;setEvalEnabled(false, errorMessage);
391 }
392 
393 void ScriptController::disableWebAssembly(const String&amp; errorMessage)
394 {
395     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
396     if (!jsWindowProxy)
397         return;
398     jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(false, errorMessage);
399 }
400 
401 bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document&amp; accessingDocument)
402 {
<a name="35" id="anc35"></a><span class="line-modified">403     auto* lexicalGlobalObject = JSExecState::currentState();</span>
404 
<a name="36" id="anc36"></a><span class="line-modified">405     // If the current lexicalGlobalObject is null we should use the accessing document for the security check.</span>
<span class="line-modified">406     if (!lexicalGlobalObject) {</span>
407         auto* targetDocument = frame ? frame-&gt;document() : nullptr;
408         return targetDocument &amp;&amp; accessingDocument.securityOrigin().canAccess(targetDocument-&gt;securityOrigin());
409     }
410 
<a name="37" id="anc37"></a><span class="line-modified">411     return BindingSecurity::shouldAllowAccessToFrame(lexicalGlobalObject, frame);</span>
412 }
413 
414 void ScriptController::updateDocument()
415 {
416     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
417         JSLockHolder lock(jsWindowProxy-&gt;world().vm());
418         jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy-&gt;window())-&gt;updateDocument();
419     }
420 }
421 
422 Bindings::RootObject* ScriptController::cacheableBindingRootObject()
423 {
424     if (!canExecuteScripts(NotAboutToExecuteScript))
425         return nullptr;
426 
427     if (!m_cacheableBindingRootObject) {
428         JSLockHolder lock(commonVM());
429         m_cacheableBindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
430     }
431     return m_cacheableBindingRootObject.get();
432 }
433 
434 Bindings::RootObject* ScriptController::bindingRootObject()
435 {
436     if (!canExecuteScripts(NotAboutToExecuteScript))
437         return nullptr;
438 
439     if (!m_bindingRootObject) {
440         JSLockHolder lock(commonVM());
441         m_bindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
442     }
443     return m_bindingRootObject.get();
444 }
445 
446 Ref&lt;Bindings::RootObject&gt; ScriptController::createRootObject(void* nativeHandle)
447 {
448     auto it = m_rootObjects.find(nativeHandle);
449     if (it != m_rootObjects.end())
450         return it-&gt;value.copyRef();
451 
452     auto rootObject = Bindings::RootObject::create(nativeHandle, globalObject(pluginWorld()));
453 
454     m_rootObjects.set(nativeHandle, rootObject.copyRef());
455     return rootObject;
456 }
457 
<a name="38" id="anc38"></a><span class="line-modified">458 void ScriptController::collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::JSGlobalObject*, SecurityOrigin*&gt;&gt;&amp; result)</span>
459 {
460     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<a name="39" id="anc39"></a><span class="line-modified">461         auto* lexicalGlobalObject = jsWindowProxy-&gt;window();</span>
462         auto* origin = &amp;downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();
<a name="40" id="anc40"></a><span class="line-modified">463         result.append(std::make_pair(lexicalGlobalObject, origin));</span>
464     }
465 }
466 
467 #if ENABLE(NETSCAPE_PLUGIN_API)
468 NPObject* ScriptController::windowScriptNPObject()
469 {
470     if (!m_windowScriptNPObject) {
471         JSLockHolder lock(commonVM());
472         if (canExecuteScripts(NotAboutToExecuteScript)) {
473             // JavaScript is enabled, so there is a JavaScript window object.
474             // Return an NPObject bound to the window object.
475             auto* window = jsWindowProxy(pluginWorld()).window();
476             ASSERT(window);
477             Bindings::RootObject* root = bindingRootObject();
478             m_windowScriptNPObject = _NPN_CreateScriptObject(0, window, root);
479         } else {
480             // JavaScript is not enabled, so we cannot bind the NPObject to the JavaScript window object.
481             // Instead, we create an NPObject of a different class, one which is not bound to a JavaScript object.
482             m_windowScriptNPObject = _NPN_CreateNoScriptObject();
483         }
484     }
485 
486     return m_windowScriptNPObject;
487 }
488 #endif
489 
490 #if !PLATFORM(COCOA)
491 RefPtr&lt;JSC::Bindings::Instance&gt; ScriptController::createScriptInstanceForWidget(Widget* widget)
492 {
493     if (!is&lt;PluginViewBase&gt;(*widget))
494         return nullptr;
495 
496     return downcast&lt;PluginViewBase&gt;(*widget).bindingInstance();
497 }
498 #endif
499 
500 JSObject* ScriptController::jsObjectForPluginElement(HTMLPlugInElement* plugin)
501 {
502     // Can&#39;t create JSObjects when JavaScript is disabled
503     if (!canExecuteScripts(NotAboutToExecuteScript))
504         return nullptr;
505 
506     JSLockHolder lock(commonVM());
507 
508     // Create a JSObject bound to this element
509     auto* globalObj = globalObject(pluginWorld());
510     // FIXME: is normal okay? - used for NP plugins?
<a name="41" id="anc41"></a><span class="line-modified">511     JSValue jsElementValue = toJS(globalObj, globalObj, plugin);</span>
512     if (!jsElementValue || !jsElementValue.isObject())
513         return nullptr;
514 
515     return jsElementValue.getObject();
516 }
517 
518 #if !PLATFORM(COCOA)
519 
520 void ScriptController::updatePlatformScriptObjects()
521 {
522 }
523 
524 void ScriptController::disconnectPlatformScriptObjects()
525 {
526 }
527 
528 #endif
529 
530 void ScriptController::cleanupScriptObjectsForPlugin(void* nativeHandle)
531 {
532     auto it = m_rootObjects.find(nativeHandle);
533     if (it == m_rootObjects.end())
534         return;
535 
536     it-&gt;value-&gt;invalidate();
537     m_rootObjects.remove(it);
538 }
539 
540 void ScriptController::clearScriptObjects()
541 {
542     JSLockHolder lock(commonVM());
543 
544     for (auto&amp; rootObject : m_rootObjects.values())
545         rootObject-&gt;invalidate();
546 
547     m_rootObjects.clear();
548 
549     if (m_bindingRootObject) {
550         m_bindingRootObject-&gt;invalidate();
551         m_bindingRootObject = nullptr;
552     }
553 
554 #if ENABLE(NETSCAPE_PLUGIN_API)
555     if (m_windowScriptNPObject) {
556         // Call _NPN_DeallocateObject() instead of _NPN_ReleaseObject() so that we don&#39;t leak if a plugin fails to release the window
557         // script object properly.
558         // This shouldn&#39;t cause any problems for plugins since they should have already been stopped and destroyed at this point.
559         _NPN_DeallocateObject(m_windowScriptNPObject);
560         m_windowScriptNPObject = nullptr;
561     }
562 #endif
563 }
564 
<a name="42" id="anc42"></a><span class="line-modified">565 JSC::JSValue ScriptController::executeScriptIgnoringException(const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">566 {</span>
<span class="line-added">567     return executeScriptInWorldIgnoringException(mainThreadNormalWorld(), script, forceUserGesture);</span>
<span class="line-added">568 }</span>
<span class="line-added">569 </span>
<span class="line-added">570 JSC::JSValue ScriptController::executeScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">571 {</span>
<span class="line-added">572     auto result = executeScriptInWorld(world, RunJavaScriptParameters { script, false, WTF::nullopt, forceUserGesture });</span>
<span class="line-added">573     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">574 }</span>
<span class="line-added">575 </span>
<span class="line-added">576 ValueOrException ScriptController::executeScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
577 {
<a name="43" id="anc43"></a><span class="line-modified">578     UserGestureIndicator gestureIndicator(parameters.forceUserGesture == ForceUserGesture::Yes ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>

579 
580     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
<a name="44" id="anc44"></a><span class="line-modified">581         return makeUnexpected(ExceptionDetails { &quot;Cannot execute JavaScript in this document&quot;_s });</span>
<span class="line-added">582 </span>
<span class="line-added">583     switch (parameters.runAsAsyncFunction) {</span>
<span class="line-added">584     case RunAsAsyncFunction::No: {</span>
<span class="line-added">585         ScriptSourceCode sourceCode(parameters.source, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()));</span>
<span class="line-added">586         return evaluateInWorld(sourceCode, world);</span>
<span class="line-added">587     }</span>
<span class="line-added">588     case RunAsAsyncFunction::Yes:</span>
<span class="line-added">589         return callInWorld(WTFMove(parameters), world);</span>
<span class="line-added">590     default:</span>
<span class="line-added">591         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">592     }</span>
<span class="line-added">593 }</span>
<span class="line-added">594 </span>
<span class="line-added">595 ValueOrException ScriptController::callInWorld(RunJavaScriptParameters&amp;&amp; parameters, DOMWrapperWorld&amp; world)</span>
<span class="line-added">596 {</span>
<span class="line-added">597     ASSERT(parameters.runAsAsyncFunction == RunAsAsyncFunction::Yes);</span>
<span class="line-added">598     ASSERT(parameters.arguments);</span>
<span class="line-added">599 </span>
<span class="line-added">600     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">601     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">602     MarkedArgumentBuffer markedArguments;</span>
<span class="line-added">603     StringBuilder functionStringBuilder;</span>
<span class="line-added">604     String errorMessage;</span>
<span class="line-added">605 </span>
<span class="line-added">606     // Build up a new script string that is an async function with arguments, and deserialize those arguments.</span>
<span class="line-added">607     functionStringBuilder.append(&quot;(async function(&quot;);</span>
<span class="line-added">608     for (auto argument = parameters.arguments-&gt;begin(); argument != parameters.arguments-&gt;end();) {</span>
<span class="line-added">609         functionStringBuilder.append(argument-&gt;key);</span>
<span class="line-added">610         auto serializedArgument = SerializedScriptValue::createFromWireBytes(WTFMove(argument-&gt;value));</span>
<span class="line-added">611 </span>
<span class="line-added">612         auto scope = DECLARE_CATCH_SCOPE(globalObject.vm());</span>
<span class="line-added">613         auto jsArgument = serializedArgument-&gt;deserialize(globalObject, &amp;globalObject);</span>
<span class="line-added">614         if (UNLIKELY(scope.exception())) {</span>
<span class="line-added">615             errorMessage = &quot;Unable to deserialize argument to execute asynchronous JavaScript function&quot;;</span>
<span class="line-added">616             break;</span>
<span class="line-added">617         }</span>
<span class="line-added">618 </span>
<span class="line-added">619         markedArguments.append(jsArgument);</span>
<span class="line-added">620 </span>
<span class="line-added">621         ++argument;</span>
<span class="line-added">622         if (argument != parameters.arguments-&gt;end())</span>
<span class="line-added">623             functionStringBuilder.append(&#39;,&#39;);</span>
<span class="line-added">624     }</span>
<span class="line-added">625 </span>
<span class="line-added">626     if (!errorMessage.isEmpty())</span>
<span class="line-added">627         return makeUnexpected(ExceptionDetails { errorMessage });</span>
<span class="line-added">628 </span>
<span class="line-added">629     functionStringBuilder.append(&quot;){&quot;, parameters.source, &quot;})&quot;);</span>
<span class="line-added">630 </span>
<span class="line-added">631     auto sourceCode = ScriptSourceCode { functionStringBuilder.toString(), URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()) };</span>
<span class="line-added">632     const auto&amp; jsSourceCode = sourceCode.jsSourceCode();</span>
<span class="line-added">633 </span>
<span class="line-added">634     String sourceURL = jsSourceCode.provider()-&gt;url();</span>
<span class="line-added">635     const String* savedSourceURL = m_sourceURL;</span>
<span class="line-added">636     m_sourceURL = &amp;sourceURL;</span>
<span class="line-added">637 </span>
<span class="line-added">638     Ref&lt;Frame&gt; protector(m_frame);</span>
<span class="line-added">639 </span>
<span class="line-added">640     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
<span class="line-added">641 </span>
<span class="line-added">642     NakedPtr&lt;JSC::Exception&gt; evaluationException;</span>
<span class="line-added">643     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
<span class="line-added">644     JSValue returnValue;</span>
<span class="line-added">645     do {</span>
<span class="line-added">646         JSValue functionObject = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
<span class="line-added">647 </span>
<span class="line-added">648         if (evaluationException)</span>
<span class="line-added">649             break;</span>
<span class="line-added">650 </span>
<span class="line-added">651         if (!functionObject || !functionObject.isFunction(world.vm())) {</span>
<span class="line-added">652             optionalDetails = { { &quot;Unable to create JavaScript async function to call&quot;_s } };</span>
<span class="line-added">653             break;</span>
<span class="line-added">654         }</span>
<span class="line-added">655 </span>
<span class="line-added">656         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=205562</span>
<span class="line-added">657         // Getting CallData/CallType shouldn&#39;t be required to call into JS.</span>
<span class="line-added">658         CallData callData;</span>
<span class="line-added">659         CallType callType = getCallData(world.vm(), functionObject, callData);</span>
<span class="line-added">660         if (callType == CallType::None) {</span>
<span class="line-added">661             optionalDetails = { { &quot;Unable to prepare JavaScript async function to be called&quot;_s } };</span>
<span class="line-added">662             break;</span>
<span class="line-added">663         }</span>
<span class="line-added">664 </span>
<span class="line-added">665         returnValue = JSExecState::profiledCall(&amp;globalObject, JSC::ProfilingReason::Other, functionObject, callType, callData, &amp;proxy, markedArguments, evaluationException);</span>
<span class="line-added">666     } while (false);</span>
<span class="line-added">667 </span>
<span class="line-added">668     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
<span class="line-added">669 </span>
<span class="line-added">670     if (evaluationException &amp;&amp; !optionalDetails) {</span>
<span class="line-added">671         ExceptionDetails details;</span>
<span class="line-added">672         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-added">673         optionalDetails = WTFMove(details);</span>
<span class="line-added">674     }</span>
<span class="line-added">675 </span>
<span class="line-added">676     m_sourceURL = savedSourceURL;</span>
<span class="line-added">677 </span>
<span class="line-added">678     if (optionalDetails)</span>
<span class="line-added">679         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">680     return returnValue;</span>
<span class="line-added">681 }</span>
682 
<a name="45" id="anc45"></a><span class="line-modified">683 JSC::JSValue ScriptController::executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">684 {</span>
<span class="line-added">685     auto result = executeUserAgentScriptInWorld(world, script, forceUserGesture);</span>
<span class="line-added">686     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">687 }</span>
<span class="line-added">688 ValueOrException ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">689 {</span>
<span class="line-added">690     return executeUserAgentScriptInWorldInternal(world, { script, false, WTF::nullopt, forceUserGesture });</span>
691 }
692 
<a name="46" id="anc46"></a><span class="line-modified">693 ValueOrException ScriptController::executeUserAgentScriptInWorldInternal(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
694 {
695     auto&amp; document = *m_frame.document();
<a name="47" id="anc47"></a><span class="line-modified">696     auto allowed = shouldAllowUserAgentScripts(document);</span>
<span class="line-modified">697     if (!allowed)</span>
<span class="line-added">698         return makeUnexpected(allowed.error());</span>
699 
700     document.setHasEvaluatedUserAgentScripts();
<a name="48" id="anc48"></a><span class="line-modified">701     return executeScriptInWorld(world, WTFMove(parameters));</span>
702 }
703 
<a name="49" id="anc49"></a><span class="line-modified">704 void ScriptController::executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters, ResolveFunction&amp;&amp; resolveCompletionHandler)</span>
<span class="line-added">705 {</span>
<span class="line-added">706     auto result = executeUserAgentScriptInWorldInternal(world, WTFMove(parameters));</span>
<span class="line-added">707 </span>
<span class="line-added">708     if (parameters.runAsAsyncFunction == RunAsAsyncFunction::No || !result || !result.value().isObject()) {</span>
<span class="line-added">709         resolveCompletionHandler(result);</span>
<span class="line-added">710         return;</span>
<span class="line-added">711     }</span>
<span class="line-added">712 </span>
<span class="line-added">713     // When running JavaScript as an async function, any &quot;thenable&quot; object gets promise-like behavior of deferred completion.</span>
<span class="line-added">714     auto thenIdentifier = world.vm().propertyNames-&gt;then;</span>
<span class="line-added">715     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">716     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">717 </span>
<span class="line-added">718     auto thenFunction = result.value().get(&amp;globalObject, thenIdentifier);</span>
<span class="line-added">719     if (!thenFunction.isObject()) {</span>
<span class="line-added">720         resolveCompletionHandler(result);</span>
<span class="line-added">721         return;</span>
<span class="line-added">722     }</span>
<span class="line-added">723 </span>
<span class="line-added">724     CallData callData;</span>
<span class="line-added">725     CallType callType = asObject(thenFunction)-&gt;methodTable(world.vm())-&gt;getCallData(asObject(thenFunction), callData);</span>
<span class="line-added">726     if (callType == CallType::None) {</span>
<span class="line-added">727         resolveCompletionHandler(result);</span>
<span class="line-added">728         return;</span>
<span class="line-added">729     }</span>
<span class="line-added">730 </span>
<span class="line-added">731     auto sharedResolveFunction = createSharedTask&lt;void(ValueOrException)&gt;([resolveCompletionHandler = WTFMove(resolveCompletionHandler)](ValueOrException result) mutable {</span>
<span class="line-added">732         if (resolveCompletionHandler)</span>
<span class="line-added">733             resolveCompletionHandler(result);</span>
<span class="line-added">734         resolveCompletionHandler = nullptr;</span>
<span class="line-added">735     });</span>
<span class="line-added">736 </span>
<span class="line-added">737     auto* fulfillHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject*, CallFrame* callFrame) mutable {</span>
<span class="line-added">738         sharedResolveFunction-&gt;run(callFrame-&gt;argument(0));</span>
<span class="line-added">739         return JSValue::encode(jsUndefined());</span>
<span class="line-added">740     });</span>
<span class="line-added">741 </span>
<span class="line-added">742     auto* rejectHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject* globalObject, CallFrame* callFrame) mutable {</span>
<span class="line-added">743         sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { callFrame-&gt;argument(0).toWTFString(globalObject) }));</span>
<span class="line-added">744         return JSValue::encode(jsUndefined());</span>
<span class="line-added">745     });</span>
<span class="line-added">746 </span>
<span class="line-added">747     auto finalizeCount = makeUniqueWithoutFastMallocCheck&lt;unsigned&gt;(0);</span>
<span class="line-added">748     auto finalizeGuard = createSharedTask&lt;void()&gt;([sharedResolveFunction = WTFMove(sharedResolveFunction), finalizeCount = WTFMove(finalizeCount)]() {</span>
<span class="line-added">749         if (++(*finalizeCount) == 2)</span>
<span class="line-added">750             sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { &quot;Completion handler for function call is no longer reachable&quot;_s }));</span>
<span class="line-added">751     });</span>
<span class="line-added">752 </span>
<span class="line-added">753     world.vm().heap.addFinalizer(fulfillHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">754         finalizeGuard-&gt;run();</span>
<span class="line-added">755     });</span>
<span class="line-added">756     world.vm().heap.addFinalizer(rejectHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">757         finalizeGuard-&gt;run();</span>
<span class="line-added">758     });</span>
<span class="line-added">759 </span>
<span class="line-added">760     JSC::MarkedArgumentBuffer arguments;</span>
<span class="line-added">761     arguments.append(fulfillHandler);</span>
<span class="line-added">762     arguments.append(rejectHandler);</span>
<span class="line-added">763 </span>
<span class="line-added">764     call(&amp;globalObject, thenFunction, callType, callData, result.value(), arguments);</span>
<span class="line-added">765 }</span>
<span class="line-added">766 </span>
<span class="line-added">767 Expected&lt;void, ExceptionDetails&gt; ScriptController::shouldAllowUserAgentScripts(Document&amp; document) const</span>
768 {
769 #if ENABLE(APPLE_PAY)
770     if (auto page = m_frame.page())
771         return page-&gt;paymentCoordinator().shouldAllowUserAgentScripts(document);
772 #else
773     UNUSED_PARAM(document);
774 #endif
<a name="50" id="anc50"></a><span class="line-modified">775     return { };</span>
776 }
777 
778 bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
779 {
780     if (reason == AboutToExecuteScript)
781         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed() || !isInWebProcess());
782 
783     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxScripts)) {
784         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
785         if (reason == AboutToExecuteScript || reason == AboutToCreateEventListener)
786             m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked script execution in &#39;&quot; + m_frame.document()-&gt;url().stringCenterEllipsizedToLength() + &quot;&#39; because the document&#39;s frame is sandboxed and the &#39;allow-scripts&#39; permission is not set.&quot;);
787         return false;
788     }
789 
790     if (!m_frame.page())
791         return false;
792 
793     return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
794 }
795 
<a name="51" id="anc51"></a><span class="line-modified">796 bool ScriptController::executeIfJavaScriptURL(const URL&amp; url, RefPtr&lt;SecurityOrigin&gt; requesterSecurityOrigin, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)</span>


















797 {
798     if (!WTF::protocolIsJavaScript(url))
799         return false;
800 
<a name="52" id="anc52"></a><span class="line-added">801     if (requesterSecurityOrigin &amp;&amp; !requesterSecurityOrigin-&gt;canAccess(m_frame.document()-&gt;securityOrigin()))</span>
<span class="line-added">802         return true;</span>
<span class="line-added">803 </span>
804     if (!m_frame.page() || !m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(m_frame.document()-&gt;url(), eventHandlerPosition().m_line))
805         return true;
806 
807     // We need to hold onto the Frame here because executing script can
808     // destroy the frame.
809     Ref&lt;Frame&gt; protector(m_frame);
810     RefPtr&lt;Document&gt; ownerDocument(m_frame.document());
811 
812     const int javascriptSchemeLength = sizeof(&quot;javascript:&quot;) - 1;
813 
814     String decodedURL = decodeURLEscapeSequences(url.string());
<a name="53" id="anc53"></a><span class="line-modified">815     auto result = executeScriptIgnoringException(decodedURL.substring(javascriptSchemeLength));</span>
816 
817     // If executing script caused this frame to be removed from the page, we
818     // don&#39;t want to try to replace its document!
819     if (!m_frame.page())
820         return true;
821 
822     String scriptResult;
<a name="54" id="anc54"></a><span class="line-modified">823     if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window(), scriptResult))</span>
824         return true;
825 
826     // FIXME: We should always replace the document, but doing so
827     //        synchronously can cause crashes:
828     //        http://bugs.webkit.org/show_bug.cgi?id=16782
829     if (shouldReplaceDocumentIfJavaScriptURL == ReplaceDocumentIfJavaScriptURL) {
830         // We&#39;re still in a frame, so there should be a DocumentLoader.
831         ASSERT(m_frame.document()-&gt;loader());
832 
833         // Signal to FrameLoader to disable navigations within this frame while replacing it with the result of executing javascript
834         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200523
835         // The only reason we do a nestable save/restore of this flag here is because we sometimes nest javascript: url loads as
836         // some will load synchronously. We&#39;d like to remove those synchronous loads and then change this.
837         SetForScope&lt;bool&gt; willBeReplaced(m_willReplaceWithResultOfExecutingJavascriptURL, true);
838 
839         // DocumentWriter::replaceDocumentWithResultOfExecutingJavascriptURL can cause the DocumentLoader to get deref&#39;ed and possible destroyed,
840         // so protect it with a RefPtr.
841         if (RefPtr&lt;DocumentLoader&gt; loader = m_frame.document()-&gt;loader())
842             loader-&gt;writer().replaceDocumentWithResultOfExecutingJavascriptURL(scriptResult, ownerDocument.get());
843     }
844     return true;
845 }
846 
847 } // namespace WebCore
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>
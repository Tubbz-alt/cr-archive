<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITRightShiftGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITRightShiftGenerator.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 namespace JSC {
 32 
 33 void JITRightShiftGenerator::generateFastPath(CCallHelpers&amp; jit)
 34 {
 35     ASSERT(m_scratchGPR != InvalidGPRReg);
 36     ASSERT(m_scratchGPR != m_left.payloadGPR());
 37     ASSERT(m_scratchGPR != m_right.payloadGPR());
 38 #if USE(JSVALUE32_64)
 39     ASSERT(m_scratchGPR != m_left.tagGPR());
 40     ASSERT(m_scratchGPR != m_right.tagGPR());
 41     ASSERT(m_scratchFPR != InvalidFPRReg);
 42 #endif
 43 
 44     ASSERT(!m_leftOperand.isConstInt32() || !m_rightOperand.isConstInt32());
 45 
 46     m_didEmitFastPath = true;
 47 
 48     if (m_rightOperand.isConstInt32()) {
 49         // Try to do (intVar &gt;&gt; intConstant).
 50         CCallHelpers::Jump notInt = jit.branchIfNotInt32(m_left);
 51 
 52         jit.moveValueRegs(m_left, m_result);
 53         int32_t shiftAmount = m_rightOperand.asConstInt32() &amp; 0x1f;
 54         if (shiftAmount) {
 55             if (m_shiftType == SignedShift)
 56                 jit.rshift32(CCallHelpers::Imm32(shiftAmount), m_result.payloadGPR());
 57             else
 58                 jit.urshift32(CCallHelpers::Imm32(shiftAmount), m_result.payloadGPR());
 59 #if USE(JSVALUE64)
 60             jit.or64(GPRInfo::numberTagRegister, m_result.payloadGPR());
 61 #endif
 62         }
 63 
 64         if (jit.supportsFloatingPointTruncate()) {
 65             m_endJumpList.append(jit.jump()); // Terminate the above case before emitting more code.
 66 
 67             // Try to do (doubleVar &gt;&gt; intConstant).
 68             notInt.link(&amp;jit);
 69 
 70             m_slowPathJumpList.append(jit.branchIfNotNumber(m_left, m_scratchGPR));
 71 
 72             jit.unboxDoubleNonDestructive(m_left, m_leftFPR, m_scratchGPR, m_scratchFPR);
 73 #if CPU(ARM64)
 74             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 75                 jit.convertDoubleToInt32UsingJavaScriptSemantics(m_leftFPR, m_scratchGPR);
 76             else
 77 #endif
 78             {
 79                 m_slowPathJumpList.append(jit.branchTruncateDoubleToInt32(m_leftFPR, m_scratchGPR));
 80             }
 81 
 82             if (shiftAmount) {
 83                 if (m_shiftType == SignedShift)
 84                     jit.rshift32(CCallHelpers::Imm32(shiftAmount), m_scratchGPR);
 85                 else
 86                     jit.urshift32(CCallHelpers::Imm32(shiftAmount), m_scratchGPR);
 87             }
 88             jit.boxInt32(m_scratchGPR, m_result);
 89 
 90         } else
 91             m_slowPathJumpList.append(notInt);
 92 
 93     } else {
 94         // Try to do (intConstant &gt;&gt; intVar) or (intVar &gt;&gt; intVar).
 95         m_slowPathJumpList.append(jit.branchIfNotInt32(m_right));
 96 
 97         GPRReg rightOperandGPR = m_right.payloadGPR();
 98         if (rightOperandGPR == m_result.payloadGPR())
 99             rightOperandGPR = m_scratchGPR;
100 
101         CCallHelpers::Jump leftNotInt;
102         if (m_leftOperand.isConstInt32()) {
103             jit.move(m_right.payloadGPR(), rightOperandGPR);
104 #if USE(JSVALUE32_64)
105             jit.move(m_right.tagGPR(), m_result.tagGPR());
106 #endif
107             jit.move(CCallHelpers::Imm32(m_leftOperand.asConstInt32()), m_result.payloadGPR());
108         } else {
109             leftNotInt = jit.branchIfNotInt32(m_left);
110             jit.move(m_right.payloadGPR(), rightOperandGPR);
111             jit.moveValueRegs(m_left, m_result);
112         }
113 
114         if (m_shiftType == SignedShift)
115             jit.rshift32(rightOperandGPR, m_result.payloadGPR());
116         else
117             jit.urshift32(rightOperandGPR, m_result.payloadGPR());
118 #if USE(JSVALUE64)
119         jit.or64(GPRInfo::numberTagRegister, m_result.payloadGPR());
120 #endif
121         if (m_leftOperand.isConstInt32())
122             return;
123 
124         if (jit.supportsFloatingPointTruncate()) {
125             m_endJumpList.append(jit.jump()); // Terminate the above case before emitting more code.
126 
127             // Try to do (doubleVar &gt;&gt; intVar).
128             leftNotInt.link(&amp;jit);
129 
130             m_slowPathJumpList.append(jit.branchIfNotNumber(m_left, m_scratchGPR));
131             jit.unboxDoubleNonDestructive(m_left, m_leftFPR, m_scratchGPR, m_scratchFPR);
132 #if CPU(ARM64)
133             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
134                 jit.convertDoubleToInt32UsingJavaScriptSemantics(m_leftFPR, m_scratchGPR);
135             else
136 #endif
137             {
138                 m_slowPathJumpList.append(jit.branchTruncateDoubleToInt32(m_leftFPR, m_scratchGPR));
139             }
140 
141             if (m_shiftType == SignedShift)
142                 jit.rshift32(m_right.payloadGPR(), m_scratchGPR);
143             else
144                 jit.urshift32(m_right.payloadGPR(), m_scratchGPR);
145             jit.boxInt32(m_scratchGPR, m_result);
146 
147         } else
148             m_slowPathJumpList.append(leftNotInt);
149     }
150 }
151 
152 } // namespace JSC
153 
154 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;HTMLInputElement.h&quot;
  #include &quot;HTMLParserIdioms.h&quot;
  #include &quot;HTMLTextAreaElement.h&quot;
  #include &quot;HitTestLocation.h&quot;
  #include &quot;InlineTextBox.h&quot;
<span class="line-added">+ #include &quot;LayoutIntegrationLineLayout.h&quot;</span>
  #include &quot;LayoutRepainter.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;RenderCombineText.h&quot;
  #include &quot;RenderFlexibleBox.h&quot;
  #include &quot;RenderInline.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,12 ***</span>
              }
          } else if (parent())
              parent()-&gt;dirtyLinesFromChangedChild(*this);
      }
  
<span class="line-modified">!     if (m_complexLineLayout)</span>
<span class="line-modified">!         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
  
      blockWillBeDestroyed();
  
      // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
      RenderBox::willBeDestroyed();
<span class="line-new-header">--- 151,12 ---</span>
              }
          } else if (parent())
              parent()-&gt;dirtyLinesFromChangedChild(*this);
      }
  
<span class="line-modified">!     if (complexLineLayout())</span>
<span class="line-modified">!         complexLineLayout()-&gt;lineBoxes().deleteLineBoxes();</span>
  
      blockWillBeDestroyed();
  
      // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
      RenderBox::willBeDestroyed();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,11 ***</span>
      rebuildFloatingObjectSetFromIntrudingFloats();
  
      LayoutUnit previousHeight = logicalHeight();
      // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
      // for consistency with other render classes?
<span class="line-modified">!     setLogicalHeight(0);</span>
  
      bool pageLogicalHeightChanged = false;
      checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
  
      LayoutUnit repaintLogicalTop;
<span class="line-new-header">--- 471,11 ---</span>
      rebuildFloatingObjectSetFromIntrudingFloats();
  
      LayoutUnit previousHeight = logicalHeight();
      // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
      // for consistency with other render classes?
<span class="line-modified">!     resetLogicalHeightBeforeLayoutIfNeeded();</span>
  
      bool pageLogicalHeightChanged = false;
      checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
  
      LayoutUnit repaintLogicalTop;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 665,24 ***</span>
      handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
  }
  
  void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
  {
      if (lineLayoutPath() == UndeterminedPath)
<span class="line-modified">!         setLineLayoutPath(SimpleLineLayout::canUseFor(*this) ? SimpleLinesPath : LineBoxesPath);</span>
  
      if (lineLayoutPath() == SimpleLinesPath) {
          layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
          return;
      }
  
<span class="line-modified">!     m_simpleLineLayout = nullptr;</span>
  
<span class="line-modified">!     if (!m_complexLineLayout)</span>
<span class="line-modified">!         m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
  
<span class="line-modified">!     m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
  }
  
  void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
  {
      LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
<span class="line-new-header">--- 666,41 ---</span>
      handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
  }
  
  void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
  {
<span class="line-added">+     auto computeLineLayoutPath = [&amp;] {</span>
<span class="line-added">+         bool canUseSimpleLines = SimpleLineLayout::canUseFor(*this);</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+         if (LayoutIntegration::LineLayout::canUseFor(*this, canUseSimpleLines))</span>
<span class="line-added">+             return LayoutFormattingContextPath;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         if (canUseSimpleLines)</span>
<span class="line-added">+             return SimpleLinesPath;</span>
<span class="line-added">+ </span>
<span class="line-added">+         return LineBoxesPath;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      if (lineLayoutPath() == UndeterminedPath)
<span class="line-modified">!         setLineLayoutPath(computeLineLayoutPath());</span>
  
      if (lineLayoutPath() == SimpleLinesPath) {
          layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
          return;
      }
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (lineLayoutPath() == LayoutFormattingContextPath) {</span>
<span class="line-added">+         layoutLFCLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
  
<span class="line-modified">!     if (!complexLineLayout())</span>
<span class="line-modified">!         m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
  
<span class="line-modified">!     complexLineLayout()-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
  }
  
  void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
  {
      LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,11 ***</span>
  
      // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
      LayoutRect oldRect = child.frameRect();
      LayoutUnit oldLogicalTop = logicalTopForChild(child);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
  #endif
      // Position the child as though it didn&#39;t collapse with the top.
      setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
      estimateFragmentRangeForBoxChild(child);
<span class="line-new-header">--- 717,11 ---</span>
  
      // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
      LayoutRect oldRect = child.frameRect();
      LayoutUnit oldLogicalTop = logicalTopForChild(child);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
  #endif
      // Position the child as though it didn&#39;t collapse with the top.
      setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
      estimateFragmentRangeForBoxChild(child);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,11 ***</span>
      }
  
      LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
      overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
  
<span class="line-modified">!     int lineIndex = lineCount(lineBox);</span>
      if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
          if (lineBreakToAvoidWidow() == lineIndex)
              clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
          // If we have a non-uniform page height, then we have to shift further possibly.
          if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
<span class="line-new-header">--- 1790,11 ---</span>
      }
  
      LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
      overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
  
<span class="line-modified">!     int lineIndex = complexLineLayout()-&gt;lineCountUntil(lineBox);</span>
      if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
          if (lineBreakToAvoidWidow() == lineIndex)
              clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
          // If we have a non-uniform page height, then we have to shift further possibly.
          if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1791,10 ***</span>
<span class="line-new-header">--- 1809,14 ---</span>
          LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
          setPageBreak(logicalOffset, lineHeight - remainingLogicalHeight);
          if (((lineBox == firstRootBox() &amp;&amp; totalLogicalHeight &lt; pageLogicalHeightAtNewOffset) || (!style().hasAutoOrphans() &amp;&amp; style().orphans() &gt;= lineIndex))
              &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
              auto firstRootBox = this-&gt;firstRootBox();
<span class="line-added">+             if (!firstRootBox) {</span>
<span class="line-added">+                 setPaginationStrut(remainingLogicalHeight + logicalOffset);</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
              auto firstRootBoxOverflowRect = firstRootBox-&gt;logicalVisualOverflowRect(firstRootBox-&gt;lineTop(), firstRootBox-&gt;lineBottom());
              auto firstLineUpperOverhang = std::max(-firstRootBoxOverflowRect.y(), 0_lu);
              if (needsAppleMailPaginationQuirk(*lineBox))
                  return;
              setPaginationStrut(remainingLogicalHeight + logicalOffset + firstLineUpperOverhang);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2068,17 ***</span>
          parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
          parentBlock-&gt;markSiblingsWithFloatsForLayout();
      }
  
      if (diff &gt;= StyleDifference::Repaint) {
<span class="line-modified">!         // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.</span>
<span class="line-modified">!         if (selfNeedsLayout() || !m_simpleLineLayout || !SimpleLineLayout::canUseFor(*this))</span>
              invalidateLineLayoutPath();
      }
  
      if (multiColumnFlow())
          updateStylesForColumnChildren();
  }
  
  void RenderBlockFlow::updateStylesForColumnChildren()
  {
      for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
<span class="line-new-header">--- 2090,33 ---</span>
          parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
          parentBlock-&gt;markSiblingsWithFloatsForLayout();
      }
  
      if (diff &gt;= StyleDifference::Repaint) {
<span class="line-modified">!         auto shouldInvalidateLineLayoutPath = [&amp;] {</span>
<span class="line-modified">!             if (selfNeedsLayout() || complexLineLayout())</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+             // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.</span>
<span class="line-added">+             if (simpleLineLayout() &amp;&amp; !SimpleLineLayout::canUseFor(*this))</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+             if (layoutFormattingContextLineLayout() &amp;&amp; !LayoutIntegration::LineLayout::canUseFor(*this))</span>
<span class="line-added">+                 return true;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         };</span>
<span class="line-added">+         if (shouldInvalidateLineLayoutPath())</span>
              invalidateLineLayoutPath();
      }
  
      if (multiColumnFlow())
          updateStylesForColumnChildren();
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+         layoutFormattingContextLineLayout()-&gt;updateStyle();</span>
<span class="line-added">+ #endif</span>
  }
  
  void RenderBlockFlow::updateStylesForColumnChildren()
  {
      for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2103,18 ***</span>
      RenderBlock::styleWillChange(diff, newStyle);
  }
  
  void RenderBlockFlow::deleteLines()
  {
<span class="line-modified">!     if (containsFloats())</span>
<span class="line-removed">-         m_floatingObjects-&gt;clearLineBoxTreePointers();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_simpleLineLayout) {</span>
<span class="line-removed">-         ASSERT(!m_complexLineLayout);</span>
<span class="line-removed">-         m_simpleLineLayout = nullptr;</span>
<span class="line-removed">-     } else if (m_complexLineLayout)</span>
<span class="line-removed">-         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxTree();</span>
  
      RenderBlock::deleteLines();
  }
  
  void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
<span class="line-new-header">--- 2141,11 ---</span>
      RenderBlock::styleWillChange(diff, newStyle);
  }
  
  void RenderBlockFlow::deleteLines()
  {
<span class="line-modified">!     m_lineLayout = WTF::Monostate();</span>
  
      RenderBlock::deleteLines();
  }
  
  void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2337,11 ***</span>
                      floatingObject.originatingLine()-&gt;removeFloat(floatBox);
                      if (!selfNeedsLayout()) {
                          ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
                          floatingObject.originatingLine()-&gt;markDirty();
                      }
<span class="line-modified">! #if !ASSERT_DISABLED</span>
                      floatingObject.clearOriginatingLine();
  #endif
                  }
                  markLinesDirtyInBlockRange(0, logicalBottom);
              }
<span class="line-new-header">--- 2368,11 ---</span>
                      floatingObject.originatingLine()-&gt;removeFloat(floatBox);
                      if (!selfNeedsLayout()) {
                          ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
                          floatingObject.originatingLine()-&gt;markDirty();
                      }
<span class="line-modified">! #if ASSERT_ENABLED</span>
                      floatingObject.clearOriginatingLine();
  #endif
                  }
                  markLinesDirtyInBlockRange(0, logicalBottom);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2944,25 ***</span>
  
  bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
  {
      ASSERT(childrenInline());
  
<span class="line-modified">!     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
  
<span class="line-modified">!     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
  }
  
  void RenderBlockFlow::addOverflowFromInlineChildren()
  {
      if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
          ASSERT(!hasOverflowClip());
          SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);
          return;
      }
  
<span class="line-modified">!     m_complexLineLayout-&gt;addOverflowFromInlineChildren();</span>
  }
  
  void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
  {
      if (style().visibility() != Visibility::Visible)
<span class="line-new-header">--- 2975,38 ---</span>
  
  bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
  {
      ASSERT(childrenInline());
  
<span class="line-modified">!     if (simpleLineLayout())</span>
<span class="line-modified">!         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout(), request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+         return layoutFormattingContextLineLayout()-&gt;hitTest(request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
  }
  
  void RenderBlockFlow::addOverflowFromInlineChildren()
  {
      if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
          ASSERT(!hasOverflowClip());
          SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);
          return;
      }
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout()) {</span>
<span class="line-added">+         layoutFormattingContextLineLayout()-&gt;collectOverflow(*this);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (complexLineLayout())</span>
<span class="line-added">+         complexLineLayout()-&gt;addOverflowFromInlineChildren();</span>
  }
  
  void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
  {
      if (style().visibility() != Visibility::Visible)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3038,15 ***</span>
  void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
  {
      if (logicalTop &gt;= logicalBottom)
          return;
  
<span class="line-modified">!     // Floats currently affect the choice whether to use simple line layout path.</span>
<span class="line-modified">!     if (m_simpleLineLayout) {</span>
          invalidateLineLayoutPath();
          return;
      }
  
      RootInlineBox* lowestDirtyLine = lastRootBox();
      RootInlineBox* afterLowest = lowestDirtyLine;
      while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
          afterLowest = lowestDirtyLine;
<span class="line-new-header">--- 3082,22 ---</span>
  void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
  {
      if (logicalTop &gt;= logicalBottom)
          return;
  
<span class="line-modified">!     // Floats currently affect the choice of layout path.</span>
<span class="line-modified">!     if (simpleLineLayout()) {</span>
<span class="line-added">+         invalidateLineLayoutPath();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout()) {</span>
          invalidateLineLayoutPath();
          return;
      }
<span class="line-added">+ #endif</span>
  
      RootInlineBox* lowestDirtyLine = lastRootBox();
      RootInlineBox* afterLowest = lowestDirtyLine;
      while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
          afterLowest = lowestDirtyLine;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3068,12 ***</span>
          return RenderBlock::firstLineBaseline();
  
      if (!hasLines())
          return WTF::nullopt;
  
<span class="line-modified">!     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">!         return Optional&lt;int&gt;(SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout));</span>
  
      ASSERT(firstRootBox());
      if (style().isFlippedLinesWritingMode())
          return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
      return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
<span class="line-new-header">--- 3119,17 ---</span>
          return RenderBlock::firstLineBaseline();
  
      if (!hasLines())
          return WTF::nullopt;
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">!     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+         return floorToInt(layoutFormattingContextLineLayout()-&gt;firstLineBaseline());</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (simpleLineLayout())</span>
<span class="line-added">+         return { SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout()) };</span>
  
      ASSERT(firstRootBox());
      if (style().isFlippedLinesWritingMode())
          return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
      return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3100,12 ***</span>
              return Optional&lt;int&gt;(fontMetrics.ascent()
                  + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
                  + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
          }
  
<span class="line-modified">!         if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">!             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout);</span>
          else {
              bool isFirstLine = lastRootBox() == firstRootBox();
              const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
              // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
              lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
<span class="line-new-header">--- 3156,16 ---</span>
              return Optional&lt;int&gt;(fontMetrics.ascent()
                  + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
                  + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
          }
  
<span class="line-modified">!         if (simpleLineLayout())</span>
<span class="line-modified">!             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout());</span>
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+         else if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+             lastBaseline = floorToInt(layoutFormattingContextLineLayout()-&gt;lastLineBaseline());</span>
<span class="line-added">+ #endif</span>
          else {
              bool isFirstLine = lastRootBox() == firstRootBox();
              const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
              // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
              lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3126,11 ***</span>
  }
  
  GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
      LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
  {
<span class="line-modified">!     ASSERT(!m_simpleLineLayout);</span>
  
      GapRects result;
  
      bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
  
<span class="line-new-header">--- 3186,11 ---</span>
  }
  
  GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
      LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
  {
<span class="line-modified">!     ASSERT(!simpleLineLayout());</span>
  
      GapRects result;
  
      bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3232,43 ***</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! int RenderBlockFlow::lineCount(const RootInlineBox* stopRootInlineBox, bool* found) const</span>
  {
      if (style().visibility() != Visibility::Visible)
          return 0;
  
<span class="line-removed">-     int count = 0;</span>
<span class="line-removed">- </span>
      if (childrenInline()) {
<span class="line-modified">!         if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {</span>
<span class="line-modified">!             ASSERT(!stopRootInlineBox);</span>
<span class="line-modified">!             return simpleLineLayout-&gt;lineCount();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {</span>
<span class="line-modified">!             ++count;</span>
<span class="line-modified">!             if (box == stopRootInlineBox) {</span>
<span class="line-modified">!                 if (found)</span>
<span class="line-modified">!                     *found = true;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return count;</span>
      }
  
      for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
          if (!shouldCheckLines(blockFlow))
              continue;
<span class="line-modified">!         bool recursiveFound = false;</span>
<span class="line-removed">-         count += blockFlow.lineCount(stopRootInlineBox, &amp;recursiveFound);</span>
<span class="line-removed">-         if (recursiveFound) {</span>
<span class="line-removed">-             if (found)</span>
<span class="line-removed">-                 *found = true;</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         }</span>
      }
  
      return count;
  }
  
<span class="line-new-header">--- 3292,35 ---</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! int RenderBlockFlow::lineCount() const</span>
  {
<span class="line-added">+     // FIXME: This should be tested by clients.</span>
      if (style().visibility() != Visibility::Visible)
          return 0;
  
      if (childrenInline()) {
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">!         if (layoutFormattingContextLineLayout())</span>
<span class="line-modified">!             return layoutFormattingContextLineLayout()-&gt;lineCount();</span>
<span class="line-modified">! #endif</span>
<span class="line-modified">!         if (simpleLineLayout())</span>
<span class="line-modified">!             return simpleLineLayout()-&gt;lineCount();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (complexLineLayout())</span>
<span class="line-modified">!             return complexLineLayout()-&gt;lineCount();</span>
<span class="line-modified">! </span>
<span class="line-modified">!         return 0;</span>
      }
  
<span class="line-added">+     int count = 0;</span>
      for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
          if (!shouldCheckLines(blockFlow))
              continue;
<span class="line-modified">!         count += blockFlow.lineCount();</span>
      }
  
      return count;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3326,11 ***</span>
  }
  
  bool RenderBlockFlow::containsNonZeroBidiLevel() const
  {
      for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
<span class="line-modified">!         for (auto* box = root-&gt;firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
              if (box-&gt;bidiLevel())
                  return true;
          }
      }
      return false;
<span class="line-new-header">--- 3378,11 ---</span>
  }
  
  bool RenderBlockFlow::containsNonZeroBidiLevel() const
  {
      for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
<span class="line-modified">!         for (auto* box = root-&gt;firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
              if (box-&gt;bidiLevel())
                  return true;
          }
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3434,11 ***</span>
      RootInlineBox* lastRootBoxWithChildren = 0;
      for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
          if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
              continue;
  
<span class="line-modified">!         if (!root-&gt;firstLeafChild())</span>
              continue;
          if (!firstRootBoxWithChildren)
              firstRootBoxWithChildren = root;
  
          if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
<span class="line-new-header">--- 3486,11 ---</span>
      RootInlineBox* lastRootBoxWithChildren = 0;
      for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
          if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
              continue;
  
<span class="line-modified">!         if (!root-&gt;firstLeafDescendant())</span>
              continue;
          if (!firstRootBoxWithChildren)
              firstRootBoxWithChildren = root;
  
          if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3449,11 ***</span>
  
          // check if this root line box is located at this y coordinate
          if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
              if (linesAreFlipped) {
                  RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
<span class="line-modified">!                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafChild())</span>
                      nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
  
                  if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
                      || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
                      continue;
<span class="line-new-header">--- 3501,11 ---</span>
  
          // check if this root line box is located at this y coordinate
          if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
              if (linesAreFlipped) {
                  RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
<span class="line-modified">!                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafDescendant())</span>
                      nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
  
                  if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
                      || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
                      continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3474,13 ***</span>
      if (closestBox) {
          if (moveCaretToBoundary) {
              LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));
              if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
                  || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
<span class="line-modified">!                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafChild();</span>
                  if (box-&gt;isLineBreak()) {
<span class="line-modified">!                     if (InlineBox* newBox = box-&gt;nextLeafChildIgnoringLineBreak())</span>
                          box = newBox;
                  }
                  // y coordinate is above first root line box, so return the start of the first
                  return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
              }
<span class="line-new-header">--- 3526,13 ---</span>
      if (closestBox) {
          if (moveCaretToBoundary) {
              LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));
              if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
                  || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
<span class="line-modified">!                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafDescendant();</span>
                  if (box-&gt;isLineBreak()) {
<span class="line-modified">!                     if (InlineBox* newBox = box-&gt;nextLeafOnLineIgnoringLineBreak())</span>
                          box = newBox;
                  }
                  // y coordinate is above first root line box, so return the start of the first
                  return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3536,17 ***</span>
  
  void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
  {
      ASSERT(childrenInline());
  
      if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
          SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
          return;
      }
  
<span class="line-modified">!     if (m_complexLineLayout)</span>
<span class="line-modified">!         m_complexLineLayout-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
  }
  
  bool RenderBlockFlow::relayoutForPagination()
  {
      if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
<span class="line-new-header">--- 3588,24 ---</span>
  
  void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
  {
      ASSERT(childrenInline());
  
<span class="line-added">+ #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+     if (layoutFormattingContextLineLayout()) {</span>
<span class="line-added">+         layoutFormattingContextLineLayout()-&gt;paint(paintInfo, paintOffset);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
          SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
          return;
      }
  
<span class="line-modified">!     if (complexLineLayout())</span>
<span class="line-modified">!         complexLineLayout()-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
  }
  
  bool RenderBlockFlow::relayoutForPagination()
  {
      if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3594,30 ***</span>
  bool RenderBlockFlow::hasLines() const
  {
      if (!childrenInline())
          return false;
  
<span class="line-modified">!     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">!         return simpleLineLayout-&gt;lineCount();</span>
  
<span class="line-modified">!     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().firstLineBox();</span>
  }
  
  void RenderBlockFlow::invalidateLineLayoutPath()
  {
      switch (lineLayoutPath()) {
      case UndeterminedPath:
      case ForceLineBoxesPath:
<span class="line-modified">!         ASSERT(!m_simpleLineLayout);</span>
          return;
      case LineBoxesPath:
<span class="line-modified">!         ASSERT(!m_simpleLineLayout);</span>
          setLineLayoutPath(UndeterminedPath);
          return;
      case SimpleLinesPath:
          // The simple line layout may have become invalid.
<span class="line-modified">!         m_simpleLineLayout = nullptr;</span>
          setLineLayoutPath(UndeterminedPath);
          if (needsLayout())
              return;
          // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
          setNeedsLayout();
<span class="line-new-header">--- 3653,35 ---</span>
  bool RenderBlockFlow::hasLines() const
  {
      if (!childrenInline())
          return false;
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">!     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">+         return layoutFormattingContextLineLayout()-&gt;lineCount();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     if (simpleLineLayout())</span>
<span class="line-added">+         return simpleLineLayout()-&gt;lineCount();</span>
  
<span class="line-modified">!     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().firstLineBox();</span>
  }
  
  void RenderBlockFlow::invalidateLineLayoutPath()
  {
      switch (lineLayoutPath()) {
      case UndeterminedPath:
      case ForceLineBoxesPath:
<span class="line-modified">!         ASSERT(!simpleLineLayout());</span>
          return;
      case LineBoxesPath:
<span class="line-modified">!         ASSERT(!simpleLineLayout());</span>
          setLineLayoutPath(UndeterminedPath);
          return;
<span class="line-added">+     case LayoutFormattingContextPath: // FIXME: Not all clients of invalidateLineLayoutPath() actually need to wipe the layout.</span>
      case SimpleLinesPath:
          // The simple line layout may have become invalid.
<span class="line-modified">!         m_lineLayout = WTF::Monostate();</span>
          setLineLayoutPath(UndeterminedPath);
          if (needsLayout())
              return;
          // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
          setNeedsLayout();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3626,87 ***</span>
      ASSERT_NOT_REACHED();
  }
  
  void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
  {
<span class="line-modified">!     bool needsLayout = selfNeedsLayout() || relayoutChildren || !m_simpleLineLayout;</span>
<span class="line-modified">!     if (needsLayout) {</span>
<span class="line-modified">!         deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-modified">!         m_simpleLineLayout = SimpleLineLayout::create(*this);</span>
<span class="line-modified">!     }</span>
      if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
<span class="line-modified">!         m_simpleLineLayout-&gt;setIsPaginated();</span>
<span class="line-modified">!         SimpleLineLayout::adjustLinePositionsForPagination(*m_simpleLineLayout, *this);</span>
      }
      for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
          renderer.clearNeedsLayout();
<span class="line-modified">!     ASSERT(!m_complexLineLayout);</span>
<span class="line-modified">!     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, *m_simpleLineLayout);</span>
      LayoutUnit lineLayoutTop = borderAndPaddingBefore();
      repaintLogicalTop = lineLayoutTop;
      repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
      setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
  }
  
<span class="line-modified">! void RenderBlockFlow::deleteLineBoxesBeforeSimpleLineLayout()</span>
  {
<span class="line-modified">!     ASSERT(lineLayoutPath() == SimpleLinesPath);</span>
  
<span class="line-modified">!     if (m_complexLineLayout)</span>
<span class="line-removed">-         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
  
<span class="line-modified">!     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this)) {</span>
<span class="line-modified">!         if (is&lt;RenderText&gt;(renderer))</span>
<span class="line-removed">-             downcast&lt;RenderText&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-removed">-         else if (is&lt;RenderLineBreak&gt;(renderer))</span>
<span class="line-removed">-             downcast&lt;RenderLineBreak&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             ASSERT_NOT_REACHED();</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     m_complexLineLayout = nullptr;</span>
  }
  
  void RenderBlockFlow::ensureLineBoxes()
  {
      if (!childrenInline())
          return;
  
      setLineLayoutPath(ForceLineBoxesPath);
  
<span class="line-modified">!     if (!m_simpleLineLayout)</span>
          return;
  
<span class="line-modified">!     ASSERT(!m_complexLineLayout);</span>
<span class="line-removed">-     m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
  
<span class="line-modified">!     if (SimpleLineLayout::canUseForLineBoxTree(*this, *m_simpleLineLayout)) {</span>
<span class="line-modified">!         SimpleLineLayout::generateLineBoxTree(*this, *m_simpleLineLayout);</span>
<span class="line-modified">!         m_simpleLineLayout = nullptr;</span>
<span class="line-modified">!         return;</span>
      }
<span class="line-removed">-     bool isPaginated = m_simpleLineLayout-&gt;isPaginated();</span>
<span class="line-removed">-     m_simpleLineLayout = nullptr;</span>
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      LayoutUnit oldHeight = logicalHeight();
  #endif
      bool didNeedLayout = needsLayout();
  
      bool relayoutChildren = false;
      LayoutUnit repaintLogicalTop;
      LayoutUnit repaintLogicalBottom;
<span class="line-modified">!     if (isPaginated) {</span>
          PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">!         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
          // This matches relayoutToAvoidWidows.
          if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">!             m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
          // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
          repaint();
      } else
<span class="line-modified">!         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
  
      updateLogicalHeight();
      ASSERT(didNeedLayout || logicalHeight() == oldHeight);
  
      if (!didNeedLayout)
<span class="line-new-header">--- 3690,96 ---</span>
      ASSERT_NOT_REACHED();
  }
  
  void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
  {
<span class="line-modified">!     bool needsLayout = selfNeedsLayout() || relayoutChildren || !simpleLineLayout();</span>
<span class="line-modified">!     if (needsLayout)</span>
<span class="line-modified">!         m_lineLayout = SimpleLineLayout::create(*this);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto&amp; simpleLineLayout = *this-&gt;simpleLineLayout();</span>
<span class="line-added">+ </span>
      if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
<span class="line-modified">!         simpleLineLayout.setIsPaginated();</span>
<span class="line-modified">!         SimpleLineLayout::adjustLinePositionsForPagination(simpleLineLayout, *this);</span>
      }
<span class="line-added">+ </span>
      for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
          renderer.clearNeedsLayout();
<span class="line-modified">! </span>
<span class="line-modified">!     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, simpleLineLayout);</span>
      LayoutUnit lineLayoutTop = borderAndPaddingBefore();
      repaintLogicalTop = lineLayoutTop;
      repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
      setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
  }
  
<span class="line-modified">! #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">+ void RenderBlockFlow::layoutLFCLines(bool, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)</span>
  {
<span class="line-modified">!     if (!layoutFormattingContextLineLayout())</span>
<span class="line-added">+         m_lineLayout = makeUnique&lt;LayoutIntegration::LineLayout&gt;(*this);</span>
  
<span class="line-modified">!     auto&amp; layoutFormattingContextLineLayout = *this-&gt;layoutFormattingContextLineLayout();</span>
  
<span class="line-modified">!     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))</span>
<span class="line-modified">!         renderer.clearNeedsLayout();</span>
  
<span class="line-modified">!     layoutFormattingContextLineLayout.layout();</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto contentHeight = layoutFormattingContextLineLayout.contentLogicalHeight();</span>
<span class="line-added">+     auto contentBoxTop = borderAndPaddingBefore();</span>
<span class="line-added">+     auto contentBoxBottom = contentBoxTop + contentHeight;</span>
<span class="line-added">+     auto borderBoxBottom = contentBoxBottom + borderAndPaddingAfter();</span>
<span class="line-added">+ </span>
<span class="line-added">+     repaintLogicalTop = contentBoxTop;</span>
<span class="line-added">+     repaintLogicalBottom = borderBoxBottom;</span>
<span class="line-added">+     setLogicalHeight(borderBoxBottom);</span>
  }
<span class="line-added">+ #endif</span>
  
  void RenderBlockFlow::ensureLineBoxes()
  {
      if (!childrenInline())
          return;
  
      setLineLayoutPath(ForceLineBoxesPath);
  
<span class="line-modified">!     if (complexLineLayout() || !hasLineLayout())</span>
          return;
  
<span class="line-modified">!     auto simpleLineLayout = makeRefPtr(this-&gt;simpleLineLayout());</span>
  
<span class="line-modified">!     m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (simpleLineLayout) {</span>
<span class="line-modified">!         if (SimpleLineLayout::canUseForLineBoxTree(*this, *simpleLineLayout)) {</span>
<span class="line-added">+             SimpleLineLayout::generateLineBoxTree(*this, *simpleLineLayout);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
      }
  
<span class="line-modified">!     auto&amp; complexLineLayout = *this-&gt;complexLineLayout();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
      LayoutUnit oldHeight = logicalHeight();
  #endif
      bool didNeedLayout = needsLayout();
  
      bool relayoutChildren = false;
      LayoutUnit repaintLogicalTop;
      LayoutUnit repaintLogicalBottom;
<span class="line-modified">!     if (simpleLineLayout &amp;&amp; simpleLineLayout-&gt;isPaginated()) {</span>
          PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">!         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
          // This matches relayoutToAvoidWidows.
          if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">!             complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
          // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
          repaint();
      } else
<span class="line-modified">!         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
  
      updateLogicalHeight();
      ASSERT(didNeedLayout || logicalHeight() == oldHeight);
  
      if (!didNeedLayout)
</pre>
<center><a href="RenderBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
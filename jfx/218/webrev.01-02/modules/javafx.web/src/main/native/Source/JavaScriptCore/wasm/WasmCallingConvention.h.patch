diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCallingConvention.h
@@ -37,308 +37,208 @@
 #include "B3PatchpointValue.h"
 #include "B3Procedure.h"
 #include "B3StackmapGenerationParams.h"
 #include "CallFrame.h"
 #include "LinkBuffer.h"
+#include "RegisterAtOffsetList.h"
 #include "RegisterSet.h"
 #include "WasmFormat.h"
 #include "WasmSignature.h"
 
 namespace JSC { namespace Wasm {
 
-typedef unsigned (*NextOffset)(unsigned currentOffset);
+constexpr unsigned numberOfLLIntCalleeSaveRegisters = 2;
 
-template<unsigned headerSize, NextOffset updateOffset>
-class CallingConvention {
-public:
-    CallingConvention(Vector<Reg>&& gprArgs, Vector<Reg>&& fprArgs, RegisterSet&& calleeSaveRegisters)
-        : m_gprArgs(WTFMove(gprArgs))
-        , m_fprArgs(WTFMove(fprArgs))
-        , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))
+using ArgumentLocation = B3::ValueRep;
+enum class CallRole : uint8_t {
+    Caller,
+    Callee,
+};
+
+struct CallInformation {
+    CallInformation(Vector<ArgumentLocation>&& parameters, Vector<ArgumentLocation, 1>&& returnValues, size_t stackOffset)
+        : params(WTFMove(parameters))
+        , results(WTFMove(returnValues))
+        , headerAndArgumentStackSizeInBytes(stackOffset)
+    { }
+
+    RegisterAtOffsetList computeResultsOffsetList()
     {
+        RegisterSet usedResultRegisters;
+        for (B3::ValueRep rep : results) {
+            if (rep.isReg())
+                usedResultRegisters.set(rep.reg());
+        }
+
+        RegisterAtOffsetList savedRegs(usedResultRegisters, RegisterAtOffsetList::ZeroBased);
+        return savedRegs;
     }
 
+    bool argumentsIncludeI64 { false };
+    bool resultsIncludeI64 { false };
+    Vector<ArgumentLocation> params;
+    Vector<ArgumentLocation, 1> results;
+    // As a callee this includes CallerFrameAndPC as a caller it does not.
+    size_t headerAndArgumentStackSizeInBytes;
+};
+
+class WasmCallingConvention {
+public:
+    static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);
+
+    WasmCallingConvention(Vector<Reg>&& gprs, Vector<Reg>&& fprs, Vector<GPRReg>&& scratches, RegisterSet&& calleeSaves, RegisterSet&& callerSaves)
+        : gprArgs(WTFMove(gprs))
+        , fprArgs(WTFMove(fprs))
+        , prologueScratchGPRs(WTFMove(scratches))
+        , calleeSaveRegisters(WTFMove(calleeSaves))
+        , callerSaveRegisters(WTFMove(callerSaves))
+    { }
+
+    WTF_MAKE_NONCOPYABLE(WasmCallingConvention);
+
 private:
-    B3::ValueRep marshallArgumentImpl(const Vector<Reg>& regArgs, size_t& count, size_t& stackOffset) const
+    ArgumentLocation marshallLocationImpl(CallRole role, const Vector<Reg>& regArgs, size_t& count, size_t& stackOffset) const
     {
         if (count < regArgs.size())
-            return B3::ValueRep::reg(regArgs[count++]);
+            return ArgumentLocation::reg(regArgs[count++]);
 
         count++;
-        B3::ValueRep result = B3::ValueRep::stackArgument(stackOffset);
-        stackOffset = updateOffset(stackOffset);
+        ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);
+        stackOffset += sizeof(Register);
         return result;
     }
 
-    B3::ValueRep marshallArgument(B3::Type type, size_t& gpArgumentCount, size_t& fpArgumentCount, size_t& stackOffset) const
+    ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t& gpArgumentCount, size_t& fpArgumentCount, size_t& stackOffset) const
     {
-        switch (type.kind()) {
-        case B3::Int32:
-        case B3::Int64:
-            return marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset);
-        case B3::Float:
-        case B3::Double:
-            return marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset);
-        case B3::Void:
-        case B3::Tuple:
+        ASSERT(isValueType(valueType));
+        switch (valueType) {
+        case I32:
+        case I64:
+        case Funcref:
+        case Anyref:
+            return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);
+        case F32:
+        case F64:
+            return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);
+        default:
             break;
-
         }
         RELEASE_ASSERT_NOT_REACHED();
     }
 
 public:
-    static unsigned headerSizeInBytes() { return headerSize; }
-    void setupFrameInPrologue(CodeLocationDataLabelPtr<WasmEntryPtrTag>* calleeMoveLocation, B3::Procedure& proc, B3::Origin origin, B3::BasicBlock* block) const
-    {
-        static_assert(CallFrameSlot::callee * sizeof(Register) < headerSize, "We rely on this here for now.");
-        static_assert(CallFrameSlot::codeBlock * sizeof(Register) < headerSize, "We rely on this here for now.");
-
-        B3::PatchpointValue* getCalleePatchpoint = block->appendNew<B3::PatchpointValue>(proc, B3::Int64, origin);
-        getCalleePatchpoint->resultConstraints = { B3::ValueRep::SomeRegister };
-        getCalleePatchpoint->effects = B3::Effects::none();
-        getCalleePatchpoint->setGenerator(
-            [=] (CCallHelpers& jit, const B3::StackmapGenerationParams& params) {
-                GPRReg result = params[0].gpr();
-                MacroAssembler::DataLabelPtr moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), result);
-                jit.addLinkTask([calleeMoveLocation, moveLocation] (LinkBuffer& linkBuffer) {
-                    *calleeMoveLocation = linkBuffer.locationOf<WasmEntryPtrTag>(moveLocation);
-                });
-            });
-
-        B3::Value* framePointer = block->appendNew<B3::Value>(proc, B3::FramePointer, origin);
-        B3::Value* offsetOfCallee = block->appendNew<B3::Const64Value>(proc, origin, CallFrameSlot::callee * sizeof(Register));
-        block->appendNew<B3::MemoryValue>(proc, B3::Store, origin,
-            getCalleePatchpoint,
-            block->appendNew<B3::Value>(proc, B3::Add, origin, framePointer, offsetOfCallee));
-
-        // FIXME: We shouldn't have to store zero into the CodeBlock* spot in the call frame,
-        // but there are places that interpret non-null CodeBlock slot to mean a valid CodeBlock.
-        // When doing unwinding, we'll need to verify that the entire runtime is OK with a non-null
-        // CodeBlock not implying that the CodeBlock is valid.
-        // https://bugs.webkit.org/show_bug.cgi?id=165321
-        B3::Value* offsetOfCodeBlock = block->appendNew<B3::Const64Value>(proc, origin, CallFrameSlot::codeBlock * sizeof(Register));
-        block->appendNew<B3::MemoryValue>(proc, B3::Store, origin,
-            block->appendNew<B3::Const64Value>(proc, origin, 0),
-            block->appendNew<B3::Value>(proc, B3::Add, origin, framePointer, offsetOfCodeBlock));
-    }
-
-    template<typename Functor>
-    void loadArguments(const Signature& signature, B3::Procedure& proc, B3::BasicBlock* block, B3::Origin origin, const Functor& functor) const
+    CallInformation callInformationFor(const Signature& signature, CallRole role = CallRole::Caller) const
     {
-        B3::Value* framePointer = block->appendNew<B3::Value>(proc, B3::FramePointer, origin);
-
+        bool argumentsIncludeI64 = false;
+        bool resultsIncludeI64 = false;
         size_t gpArgumentCount = 0;
         size_t fpArgumentCount = 0;
-        size_t stackOffset = headerSize;
+        size_t argStackOffset = headerSizeInBytes;
+        if (role == CallRole::Caller)
+            argStackOffset -= sizeof(CallerFrameAndPC);
 
+        Vector<ArgumentLocation> params(signature.argumentCount());
         for (size_t i = 0; i < signature.argumentCount(); ++i) {
-            B3::Type type = toB3Type(signature.argument(i));
-            B3::Value* argument;
-            B3::ValueRep rep = marshallArgument(type, gpArgumentCount, fpArgumentCount, stackOffset);
-            if (rep.isReg()) {
-                argument = block->appendNew<B3::ArgumentRegValue>(proc, origin, rep.reg());
-                if (type == B3::Int32 || type == B3::Float)
-                    argument = block->appendNew<B3::Value>(proc, B3::Trunc, origin, argument);
-            } else {
-                ASSERT(rep.isStackArgument());
-                B3::Value* address = block->appendNew<B3::Value>(proc, B3::Add, origin, framePointer,
-                    block->appendNew<B3::Const64Value>(proc, origin, rep.offsetFromSP()));
-                argument = block->appendNew<B3::MemoryValue>(proc, B3::Load, type, origin, address);
-            }
-            functor(argument, i);
+            argumentsIncludeI64 |= signature.argument(i) == I64;
+            params[i] = marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, argStackOffset);
         }
-    }
-
-    // It's expected that the pachpointFunctor sets the generator for the call operation.
-    template<typename Functor>
-    B3::Value* setupCall(B3::Procedure& proc, B3::BasicBlock* block, B3::Origin origin, const Vector<B3::Value*>& arguments, B3::Type returnType, const Functor& patchpointFunctor) const
-    {
-        size_t gpArgumentCount = 0;
-        size_t fpArgumentCount = 0;
-        size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);
-
-        Vector<B3::ConstrainedValue> constrainedArguments;
-        for (B3::Value* argument : arguments) {
-            B3::ValueRep rep = marshallArgument(argument->type(), gpArgumentCount, fpArgumentCount, stackOffset);
-            constrainedArguments.append(B3::ConstrainedValue(argument, rep));
+        gpArgumentCount = 0;
+        fpArgumentCount = 0;
+        size_t resultStackOffset = headerSizeInBytes;
+        if (role == CallRole::Caller)
+            resultStackOffset -= sizeof(CallerFrameAndPC);
+
+        Vector<ArgumentLocation, 1> results(signature.returnCount());
+        for (size_t i = 0; i < signature.returnCount(); ++i) {
+            resultsIncludeI64 |= signature.returnType(i) == I64;
+            results[i] = marshallLocation(role, signature.returnType(i), gpArgumentCount, fpArgumentCount, resultStackOffset);
         }
 
-        proc.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));
-
-        B3::PatchpointValue* patchpoint = block->appendNew<B3::PatchpointValue>(proc, returnType, origin);
-        patchpoint->clobberEarly(RegisterSet::macroScratchRegisters());
-        patchpoint->clobberLate(RegisterSet::volatileRegistersForJSCall());
-        patchpointFunctor(patchpoint);
-        patchpoint->appendVector(constrainedArguments);
-
-        switch (returnType.kind()) {
-        case B3::Void:
-            return nullptr;
-        case B3::Float:
-        case B3::Double:
-            patchpoint->resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };
-            break;
-        case B3::Int32:
-        case B3::Int64:
-            patchpoint->resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };
-            break;
-        case B3::Tuple:
-            RELEASE_ASSERT_NOT_REACHED();
-            break;
-        }
-        return patchpoint;
+        CallInformation result(WTFMove(params), WTFMove(results), std::max(argStackOffset, resultStackOffset));
+        result.argumentsIncludeI64 = argumentsIncludeI64;
+        result.resultsIncludeI64 = resultsIncludeI64;
+        return result;
     }
 
-    const Vector<Reg> m_gprArgs;
-    const Vector<Reg> m_fprArgs;
-    const RegisterSet m_calleeSaveRegisters;
-    const RegisterSet m_callerSaveRegisters;
+    const Vector<Reg> gprArgs;
+    const Vector<Reg> fprArgs;
+    const Vector<GPRReg> prologueScratchGPRs;
+    const RegisterSet calleeSaveRegisters;
+    const RegisterSet callerSaveRegisters;
 };
 
-// FIXME: Share more code with CallingConvention above:
-// https://bugs.webkit.org/show_bug.cgi?id=194065
-template<unsigned headerSize, NextOffset updateOffset>
-class CallingConventionAir {
+class JSCallingConvention {
 public:
-    CallingConventionAir(Vector<Reg>&& gprArgs, Vector<Reg>&& fprArgs, RegisterSet&& calleeSaveRegisters)
-        : m_gprArgs(WTFMove(gprArgs))
-        , m_fprArgs(WTFMove(fprArgs))
-        , m_calleeSaveRegisters(WTFMove(calleeSaveRegisters))
-    {
-        RegisterSet scratch = RegisterSet::allGPRs();
-        scratch.exclude(RegisterSet::macroScratchRegisters());
-        scratch.exclude(RegisterSet::reservedHardwareRegisters());
-        scratch.exclude(RegisterSet::stackRegisters());
-        for (Reg reg : m_gprArgs)
-            scratch.clear(reg);
-        for (Reg reg : m_calleeSaveRegisters)
-            scratch.clear(reg);
-        for (Reg reg : scratch)
-            m_scratchGPRs.append(reg);
-        RELEASE_ASSERT(m_scratchGPRs.size() >= 2);
-    }
+    static constexpr unsigned headerSizeInBytes = CallFrame::headerSizeInRegisters * sizeof(Register);
+
+    // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*'s
+    // instance as the first JS argument when we're not using fast TLS to hold the
+    // Wasm::Context*'s instance.
+    static constexpr ptrdiff_t instanceStackOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);
 
-    GPRReg prologueScratch(size_t i) const { return m_scratchGPRs[i].gpr(); }
+    JSCallingConvention(Vector<Reg>&& gprs, Vector<Reg>&& fprs, RegisterSet&& calleeSaves, RegisterSet&& callerSaves)
+        : gprArgs(WTFMove(gprs))
+        , fprArgs(WTFMove(fprs))
+        , calleeSaveRegisters(WTFMove(calleeSaves))
+        , callerSaveRegisters(WTFMove(callerSaves))
+    { }
 
+    WTF_MAKE_NONCOPYABLE(JSCallingConvention);
 private:
-    template <typename RegFunc, typename StackFunc>
-    void marshallArgumentImpl(const Vector<Reg>& regArgs, size_t& count, size_t& stackOffset, const RegFunc& regFunc, const StackFunc& stackFunc) const
+    ArgumentLocation marshallLocationImpl(CallRole role, const Vector<Reg>& regArgs, size_t& count, size_t& stackOffset) const
     {
-        if (count < regArgs.size()) {
-            regFunc(regArgs[count++]);
-            return;
-        }
+        if (count < regArgs.size())
+            return ArgumentLocation::reg(regArgs[count++]);
 
         count++;
-        stackFunc(stackOffset);
-        stackOffset = updateOffset(stackOffset);
+        ArgumentLocation result = role == CallRole::Caller ? ArgumentLocation::stackArgument(stackOffset) : ArgumentLocation::stack(stackOffset);
+        stackOffset += sizeof(Register);
+        return result;
     }
 
-    template <typename RegFunc, typename StackFunc>
-    void marshallArgument(Type type, size_t& gpArgumentCount, size_t& fpArgumentCount, size_t& stackOffset, const RegFunc& regFunc, const StackFunc& stackFunc) const
+    ArgumentLocation marshallLocation(CallRole role, Type valueType, size_t& gpArgumentCount, size_t& fpArgumentCount, size_t& stackOffset) const
     {
-        switch (type) {
-        case Type::I32:
-        case Type::I64:
-        case Type::Anyref:
-        case Wasm::Funcref:
-            marshallArgumentImpl(m_gprArgs, gpArgumentCount, stackOffset, regFunc, stackFunc);
-            break;
-        case Type::F32:
-        case Type::F64:
-            marshallArgumentImpl(m_fprArgs, fpArgumentCount, stackOffset, regFunc, stackFunc);
-            break;
+        ASSERT(isValueType(valueType));
+        switch (valueType) {
+        case I32:
+        case I64:
+        case Funcref:
+        case Anyref:
+            return marshallLocationImpl(role, gprArgs, gpArgumentCount, stackOffset);
+        case F32:
+        case F64:
+            return marshallLocationImpl(role, fprArgs, fpArgumentCount, stackOffset);
         default:
-            RELEASE_ASSERT_NOT_REACHED();
+            break;
         }
+        RELEASE_ASSERT_NOT_REACHED();
     }
 
 public:
-    static unsigned headerSizeInBytes() { return headerSize; }
-
-    template<typename Functor>
-    void loadArguments(const Signature& signature, const Functor& functor) const
-    {
-        size_t gpArgumentCount = 0;
-        size_t fpArgumentCount = 0;
-        size_t stackOffset = headerSize;
-
-        for (size_t i = 0; i < signature.argumentCount(); ++i) {
-            marshallArgument(signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset,
-                [&] (Reg reg) {
-                    functor(B3::Air::Tmp(reg), i);
-                },
-                [&] (size_t stackOffset) {
-                    functor(B3::Air::Arg::addr(B3::Air::Tmp(GPRInfo::callFrameRegister), stackOffset), i);
-                });
-        }
-    }
-
-    // It's expected that the pachpointFunctor sets the generator for the call operation.
-    template<typename Functor>
-    void setupCall(B3::Air::Code& code, Type returnType, B3::PatchpointValue* patchpoint, const Vector<B3::Air::Tmp>& args, const Functor& functor) const
+    CallInformation callInformationFor(const Signature& signature, CallRole role = CallRole::Callee) const
     {
         size_t gpArgumentCount = 0;
         size_t fpArgumentCount = 0;
-        size_t stackOffset = headerSize - sizeof(CallerFrameAndPC);
-
-        for (auto tmp : args) {
-            marshallArgument(tmp.isGP() ? Type::I64 : Type::F64, gpArgumentCount, fpArgumentCount, stackOffset,
-                [&] (Reg reg) {
-                    functor(tmp, B3::ValueRep::reg(reg));
-                },
-                [&] (size_t stackOffset) {
-                    functor(tmp, B3::ValueRep::stackArgument(stackOffset));
-                });
-        }
+        size_t stackOffset = headerSizeInBytes + sizeof(Register); // Skip the this value since wasm doesn't use it and we sometimes put the context there.
+        if (role == CallRole::Caller)
+            stackOffset -= sizeof(CallerFrameAndPC);
 
-        code.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), stackOffset));
+        Vector<ArgumentLocation> params;
+        for (size_t i = 0; i < signature.argumentCount(); ++i)
+            params.append(marshallLocation(role, signature.argument(i), gpArgumentCount, fpArgumentCount, stackOffset));
 
-        patchpoint->clobberEarly(RegisterSet::macroScratchRegisters());
-        patchpoint->clobberLate(RegisterSet::volatileRegistersForJSCall());
-
-        switch (returnType) {
-        case Type::Void:
-            break;
-        case Type::F32:
-        case Type::F64:
-            patchpoint->resultConstraints = { B3::ValueRep::reg(FPRInfo::returnValueFPR) };
-            break;
-        case Type::I32:
-        case Type::I64:
-        case Type::Anyref:
-        case Wasm::Funcref:
-            patchpoint->resultConstraints = { B3::ValueRep::reg(GPRInfo::returnValueGPR) };
-            break;
-        default:
-            RELEASE_ASSERT_NOT_REACHED();
-        }
+        Vector<ArgumentLocation, 1> results { ArgumentLocation::reg(GPRInfo::returnValueGPR) };
+        return CallInformation(WTFMove(params), WTFMove(results), stackOffset);
     }
 
-    const Vector<Reg> m_gprArgs;
-    const Vector<Reg> m_fprArgs;
-    Vector<Reg> m_scratchGPRs;
-    const RegisterSet m_calleeSaveRegisters;
-    const RegisterSet m_callerSaveRegisters;
+    const Vector<Reg> gprArgs;
+    const Vector<Reg> fprArgs;
+    const RegisterSet calleeSaveRegisters;
+    const RegisterSet callerSaveRegisters;
 };
 
-inline unsigned nextJSCOffset(unsigned currentOffset)
-{
-    return currentOffset + sizeof(Register);
-}
-
-constexpr unsigned jscHeaderSize = ExecState::headerSizeInRegisters * sizeof(Register);
-
-using JSCCallingConvention = CallingConvention<jscHeaderSize, nextJSCOffset>;
-using WasmCallingConvention = JSCCallingConvention;
-const JSCCallingConvention& jscCallingConvention();
+const JSCallingConvention& jsCallingConvention();
 const WasmCallingConvention& wasmCallingConvention();
 
-using JSCCallingConventionAir = CallingConventionAir<jscHeaderSize, nextJSCOffset>;
-using WasmCallingConventionAir = JSCCallingConventionAir;
-const JSCCallingConventionAir& jscCallingConventionAir();
-const WasmCallingConventionAir& wasmCallingConventionAir();
-
 } } // namespace JSC::Wasm
 
 #endif // ENABLE(WEBASSEMBLY)

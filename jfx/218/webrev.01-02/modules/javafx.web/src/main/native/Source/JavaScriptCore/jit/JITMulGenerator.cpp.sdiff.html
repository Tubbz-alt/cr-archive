<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITMulGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITMathIC.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITMulGenerator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITMulGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITMulGenerator.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;ArithProfile.h&quot;
 32 #include &quot;JITMathIC.h&quot;
 33 
 34 namespace JSC {
 35 
<span class="line-modified"> 36 JITMathICInlineResult JITMulGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const ArithProfile* arithProfile)</span>
 37 {
 38     // We default to speculating int32.
 39     ObservedType lhs = ObservedType().withInt32();
 40     ObservedType rhs = ObservedType().withInt32();
 41     if (arithProfile) {
 42         lhs = arithProfile-&gt;lhsObservedType();
 43         rhs = arithProfile-&gt;rhsObservedType();
 44     }
 45 
 46     if (lhs.isOnlyNonNumber() &amp;&amp; rhs.isOnlyNonNumber())
 47         return JITMathICInlineResult::DontGenerate;
 48 
 49     if (lhs.isOnlyNumber() &amp;&amp; rhs.isOnlyNumber() &amp;&amp; !m_leftOperand.isConst() &amp;&amp; !m_rightOperand.isConst()) {
 50         if (!jit.supportsFloatingPoint())
 51             return JITMathICInlineResult::DontGenerate;
 52 
 53         ASSERT(m_left);
 54         ASSERT(m_right);
 55         if (!m_leftOperand.definitelyIsNumber())
 56             state.slowPathJumps.append(jit.branchIfNotNumber(m_left, m_scratchGPR));
</pre>
<hr />
<pre>
 72             state.slowPathJumps.append(jit.branchIfNotInt32(m_left));
 73         if (!m_rightOperand.isPositiveConstInt32())
 74             state.slowPathJumps.append(jit.branchIfNotInt32(m_right));
 75 
 76         if (m_leftOperand.isPositiveConstInt32() || m_rightOperand.isPositiveConstInt32()) {
 77             JSValueRegs var = m_leftOperand.isPositiveConstInt32() ? m_right : m_left;
 78             int32_t constValue = m_leftOperand.isPositiveConstInt32() ? m_leftOperand.asConstInt32() : m_rightOperand.asConstInt32();
 79             state.slowPathJumps.append(jit.branchMul32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constValue), m_scratchGPR));
 80         } else {
 81             state.slowPathJumps.append(jit.branchMul32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), m_scratchGPR));
 82             state.slowPathJumps.append(jit.branchTest32(CCallHelpers::Zero, m_scratchGPR)); // Go slow if potential negative zero.
 83         }
 84         jit.boxInt32(m_scratchGPR, m_result);
 85 
 86         return JITMathICInlineResult::GeneratedFastPath;
 87     }
 88 
 89     return JITMathICInlineResult::GenerateFullSnippet;
 90 }
 91 
<span class="line-modified"> 92 bool JITMulGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const ArithProfile* arithProfile, bool shouldEmitProfiling)</span>
 93 {
 94     ASSERT(m_scratchGPR != InvalidGPRReg);
 95     ASSERT(m_scratchGPR != m_left.payloadGPR());
 96     ASSERT(m_scratchGPR != m_right.payloadGPR());
 97 #if USE(JSVALUE64)
 98     ASSERT(m_scratchGPR != m_result.payloadGPR());
 99 #else
100     ASSERT(m_scratchGPR != m_left.tagGPR());
101     ASSERT(m_scratchGPR != m_right.tagGPR());
102     ASSERT(m_scratchFPR != InvalidFPRReg);
103 #endif
104 
105     ASSERT(!m_leftOperand.isPositiveConstInt32() || !m_rightOperand.isPositiveConstInt32());
106 
107     if (!m_leftOperand.mightBeNumber() || !m_rightOperand.mightBeNumber())
108         return false;
109 
110     if (m_leftOperand.isPositiveConstInt32() || m_rightOperand.isPositiveConstInt32()) {
111         JSValueRegs var = m_leftOperand.isPositiveConstInt32() ? m_right : m_left;
112         SnippetOperand&amp; varOpr = m_leftOperand.isPositiveConstInt32() ? m_rightOperand : m_leftOperand;
</pre>
<hr />
<pre>
188 
189         // Fall thru to doubleVar * doubleVar.
190     }
191 
192     // Do doubleVar * doubleVar.
193     jit.mulDouble(m_rightFPR, m_leftFPR);
194 
195     if (!arithProfile || !shouldEmitProfiling)
196         jit.boxDouble(m_leftFPR, m_result);
197     else {
198         // The Int52 overflow check below intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
199         // Therefore, we will get a false positive if the result is that value. This is intentionally
200         // done to simplify the checking algorithm.
201 
202         const int64_t negativeZeroBits = 1ll &lt;&lt; 63;
203 #if USE(JSVALUE64)
204         jit.moveDoubleTo64(m_leftFPR, m_result.payloadGPR());
205 
206         CCallHelpers::Jump notNegativeZero = jit.branch64(CCallHelpers::NotEqual, m_result.payloadGPR(), CCallHelpers::TrustedImm64(negativeZeroBits));
207 
<span class="line-modified">208         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::NegZeroDouble), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
209         CCallHelpers::Jump done = jit.jump();
210 
211         notNegativeZero.link(&amp;jit);
<span class="line-modified">212         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::NonNegZeroDouble), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
213 
214         jit.move(m_result.payloadGPR(), m_scratchGPR);
215         jit.urshiftPtr(CCallHelpers::Imm32(52), m_scratchGPR);
216         jit.and32(CCallHelpers::Imm32(0x7ff), m_scratchGPR);
217         CCallHelpers::Jump noInt52Overflow = jit.branch32(CCallHelpers::LessThanOrEqual, m_scratchGPR, CCallHelpers::TrustedImm32(0x431));
218 
<span class="line-modified">219         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::Int52Overflow), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
220         noInt52Overflow.link(&amp;jit);
221 
222         done.link(&amp;jit);
<span class="line-modified">223         jit.sub64(GPRInfo::tagTypeNumberRegister, m_result.payloadGPR()); // Box the double.</span>
224 #else
225         jit.boxDouble(m_leftFPR, m_result);
226         CCallHelpers::JumpList notNegativeZero;
227         notNegativeZero.append(jit.branch32(CCallHelpers::NotEqual, m_result.payloadGPR(), CCallHelpers::TrustedImm32(0)));
228         notNegativeZero.append(jit.branch32(CCallHelpers::NotEqual, m_result.tagGPR(), CCallHelpers::TrustedImm32(negativeZeroBits &gt;&gt; 32)));
229 
<span class="line-modified">230         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::NegZeroDouble), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
231         CCallHelpers::Jump done = jit.jump();
232 
233         notNegativeZero.link(&amp;jit);
<span class="line-modified">234         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::NonNegZeroDouble), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
235 
236         jit.move(m_result.tagGPR(), m_scratchGPR);
237         jit.urshiftPtr(CCallHelpers::Imm32(52 - 32), m_scratchGPR);
238         jit.and32(CCallHelpers::Imm32(0x7ff), m_scratchGPR);
239         CCallHelpers::Jump noInt52Overflow = jit.branch32(CCallHelpers::LessThanOrEqual, m_scratchGPR, CCallHelpers::TrustedImm32(0x431));
240 
<span class="line-modified">241         jit.or32(CCallHelpers::TrustedImm32(ArithProfile::Int52Overflow), CCallHelpers::AbsoluteAddress(arithProfile-&gt;addressOfBits()));</span>
242 
243         endJumpList.append(noInt52Overflow);
244         if (m_scratchGPR == m_result.tagGPR() || m_scratchGPR == m_result.payloadGPR())
245             jit.boxDouble(m_leftFPR, m_result);
246 
247         endJumpList.append(done);
248 #endif
249     }
250 
251     return true;
252 }
253 
254 } // namespace JSC
255 
256 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITMulGenerator.h&quot;
 28 
 29 #if ENABLE(JIT)
 30 
 31 #include &quot;ArithProfile.h&quot;
 32 #include &quot;JITMathIC.h&quot;
 33 
 34 namespace JSC {
 35 
<span class="line-modified"> 36 JITMathICInlineResult JITMulGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const BinaryArithProfile* arithProfile)</span>
 37 {
 38     // We default to speculating int32.
 39     ObservedType lhs = ObservedType().withInt32();
 40     ObservedType rhs = ObservedType().withInt32();
 41     if (arithProfile) {
 42         lhs = arithProfile-&gt;lhsObservedType();
 43         rhs = arithProfile-&gt;rhsObservedType();
 44     }
 45 
 46     if (lhs.isOnlyNonNumber() &amp;&amp; rhs.isOnlyNonNumber())
 47         return JITMathICInlineResult::DontGenerate;
 48 
 49     if (lhs.isOnlyNumber() &amp;&amp; rhs.isOnlyNumber() &amp;&amp; !m_leftOperand.isConst() &amp;&amp; !m_rightOperand.isConst()) {
 50         if (!jit.supportsFloatingPoint())
 51             return JITMathICInlineResult::DontGenerate;
 52 
 53         ASSERT(m_left);
 54         ASSERT(m_right);
 55         if (!m_leftOperand.definitelyIsNumber())
 56             state.slowPathJumps.append(jit.branchIfNotNumber(m_left, m_scratchGPR));
</pre>
<hr />
<pre>
 72             state.slowPathJumps.append(jit.branchIfNotInt32(m_left));
 73         if (!m_rightOperand.isPositiveConstInt32())
 74             state.slowPathJumps.append(jit.branchIfNotInt32(m_right));
 75 
 76         if (m_leftOperand.isPositiveConstInt32() || m_rightOperand.isPositiveConstInt32()) {
 77             JSValueRegs var = m_leftOperand.isPositiveConstInt32() ? m_right : m_left;
 78             int32_t constValue = m_leftOperand.isPositiveConstInt32() ? m_leftOperand.asConstInt32() : m_rightOperand.asConstInt32();
 79             state.slowPathJumps.append(jit.branchMul32(CCallHelpers::Overflow, var.payloadGPR(), CCallHelpers::Imm32(constValue), m_scratchGPR));
 80         } else {
 81             state.slowPathJumps.append(jit.branchMul32(CCallHelpers::Overflow, m_right.payloadGPR(), m_left.payloadGPR(), m_scratchGPR));
 82             state.slowPathJumps.append(jit.branchTest32(CCallHelpers::Zero, m_scratchGPR)); // Go slow if potential negative zero.
 83         }
 84         jit.boxInt32(m_scratchGPR, m_result);
 85 
 86         return JITMathICInlineResult::GeneratedFastPath;
 87     }
 88 
 89     return JITMathICInlineResult::GenerateFullSnippet;
 90 }
 91 
<span class="line-modified"> 92 bool JITMulGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const BinaryArithProfile* arithProfile, bool shouldEmitProfiling)</span>
 93 {
 94     ASSERT(m_scratchGPR != InvalidGPRReg);
 95     ASSERT(m_scratchGPR != m_left.payloadGPR());
 96     ASSERT(m_scratchGPR != m_right.payloadGPR());
 97 #if USE(JSVALUE64)
 98     ASSERT(m_scratchGPR != m_result.payloadGPR());
 99 #else
100     ASSERT(m_scratchGPR != m_left.tagGPR());
101     ASSERT(m_scratchGPR != m_right.tagGPR());
102     ASSERT(m_scratchFPR != InvalidFPRReg);
103 #endif
104 
105     ASSERT(!m_leftOperand.isPositiveConstInt32() || !m_rightOperand.isPositiveConstInt32());
106 
107     if (!m_leftOperand.mightBeNumber() || !m_rightOperand.mightBeNumber())
108         return false;
109 
110     if (m_leftOperand.isPositiveConstInt32() || m_rightOperand.isPositiveConstInt32()) {
111         JSValueRegs var = m_leftOperand.isPositiveConstInt32() ? m_right : m_left;
112         SnippetOperand&amp; varOpr = m_leftOperand.isPositiveConstInt32() ? m_rightOperand : m_leftOperand;
</pre>
<hr />
<pre>
188 
189         // Fall thru to doubleVar * doubleVar.
190     }
191 
192     // Do doubleVar * doubleVar.
193     jit.mulDouble(m_rightFPR, m_leftFPR);
194 
195     if (!arithProfile || !shouldEmitProfiling)
196         jit.boxDouble(m_leftFPR, m_result);
197     else {
198         // The Int52 overflow check below intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
199         // Therefore, we will get a false positive if the result is that value. This is intentionally
200         // done to simplify the checking algorithm.
201 
202         const int64_t negativeZeroBits = 1ll &lt;&lt; 63;
203 #if USE(JSVALUE64)
204         jit.moveDoubleTo64(m_leftFPR, m_result.payloadGPR());
205 
206         CCallHelpers::Jump notNegativeZero = jit.branch64(CCallHelpers::NotEqual, m_result.payloadGPR(), CCallHelpers::TrustedImm64(negativeZeroBits));
207 
<span class="line-modified">208         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::NegZeroDouble);</span>
209         CCallHelpers::Jump done = jit.jump();
210 
211         notNegativeZero.link(&amp;jit);
<span class="line-modified">212         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::NonNegZeroDouble);</span>
213 
214         jit.move(m_result.payloadGPR(), m_scratchGPR);
215         jit.urshiftPtr(CCallHelpers::Imm32(52), m_scratchGPR);
216         jit.and32(CCallHelpers::Imm32(0x7ff), m_scratchGPR);
217         CCallHelpers::Jump noInt52Overflow = jit.branch32(CCallHelpers::LessThanOrEqual, m_scratchGPR, CCallHelpers::TrustedImm32(0x431));
218 
<span class="line-modified">219         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::Int52Overflow);</span>
220         noInt52Overflow.link(&amp;jit);
221 
222         done.link(&amp;jit);
<span class="line-modified">223         jit.sub64(GPRInfo::numberTagRegister, m_result.payloadGPR()); // Box the double.</span>
224 #else
225         jit.boxDouble(m_leftFPR, m_result);
226         CCallHelpers::JumpList notNegativeZero;
227         notNegativeZero.append(jit.branch32(CCallHelpers::NotEqual, m_result.payloadGPR(), CCallHelpers::TrustedImm32(0)));
228         notNegativeZero.append(jit.branch32(CCallHelpers::NotEqual, m_result.tagGPR(), CCallHelpers::TrustedImm32(negativeZeroBits &gt;&gt; 32)));
229 
<span class="line-modified">230         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::NegZeroDouble);</span>
231         CCallHelpers::Jump done = jit.jump();
232 
233         notNegativeZero.link(&amp;jit);
<span class="line-modified">234         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::NonNegZeroDouble);</span>
235 
236         jit.move(m_result.tagGPR(), m_scratchGPR);
237         jit.urshiftPtr(CCallHelpers::Imm32(52 - 32), m_scratchGPR);
238         jit.and32(CCallHelpers::Imm32(0x7ff), m_scratchGPR);
239         CCallHelpers::Jump noInt52Overflow = jit.branch32(CCallHelpers::LessThanOrEqual, m_scratchGPR, CCallHelpers::TrustedImm32(0x431));
240 
<span class="line-modified">241         arithProfile-&gt;emitUnconditionalSet(jit, ObservedResults::Int52Overflow);</span>
242 
243         endJumpList.append(noInt52Overflow);
244         if (m_scratchGPR == m_result.tagGPR() || m_scratchGPR == m_result.payloadGPR())
245             jit.boxDouble(m_leftFPR, m_result);
246 
247         endJumpList.append(done);
248 #endif
249     }
250 
251     return true;
252 }
253 
254 } // namespace JSC
255 
256 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITMathIC.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITMulGenerator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
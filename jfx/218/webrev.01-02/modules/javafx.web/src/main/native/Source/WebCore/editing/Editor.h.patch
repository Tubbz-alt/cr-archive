diff a/modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.h b/modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.h
@@ -70,20 +70,22 @@
 class HitTestResult;
 class KeyboardEvent;
 class KillRing;
 class Pasteboard;
 class PasteboardWriterData;
+class RenderLayer;
 class SharedBuffer;
 class Font;
 class SpellCheckRequest;
 class SpellChecker;
 class StaticRange;
 class StyleProperties;
 class Text;
 class TextCheckerClient;
 class TextEvent;
 
+struct CompositionHighlight;
 struct FontAttributes;
 struct PasteboardPlainText;
 struct PasteboardURL;
 struct TextCheckingResult;
 
@@ -148,10 +150,11 @@
 
     CompositeEditCommand* lastEditCommand() { return m_lastEditCommand.get(); }
 
     void handleKeyboardEvent(KeyboardEvent&);
     void handleInputMethodKeydown(KeyboardEvent&);
+    void didDispatchInputMethodKeydown(KeyboardEvent&);
     bool handleTextEvent(TextEvent&);
 
     WEBCORE_EXPORT bool canEdit() const;
     WEBCORE_EXPORT bool canEditRichly() const;
 
@@ -181,10 +184,13 @@
     PasteboardWriterData::URLData pasteboardWriterURL(const URL&, const String& title);
 #if !PLATFORM(IOS_FAMILY)
     WEBCORE_EXPORT void copyImage(const HitTestResult&);
 #endif
 
+    void renderLayerDidScroll(const RenderLayer&);
+    void revealSelectionIfNeededAfterLoadingImageForElement(HTMLImageElement&);
+
     String readPlainTextFromPasteboard(Pasteboard&);
 
     WEBCORE_EXPORT void indent();
     WEBCORE_EXPORT void outdent();
     void transpose();
@@ -348,11 +354,11 @@
 
     WEBCORE_EXPORT bool hasBidiSelection() const;
 
     // international text input composition
     bool hasComposition() const { return m_compositionNode; }
-    WEBCORE_EXPORT void setComposition(const String&, const Vector<CompositionUnderline>&, unsigned selectionStart, unsigned selectionEnd);
+    WEBCORE_EXPORT void setComposition(const String&, const Vector<CompositionUnderline>&, const Vector<CompositionHighlight>&, unsigned selectionStart, unsigned selectionEnd);
     WEBCORE_EXPORT void confirmComposition();
     WEBCORE_EXPORT void confirmComposition(const String&); // if no existing composition, replaces selection
     WEBCORE_EXPORT void cancelComposition();
     bool cancelCompositionIfSelectionIsInvalid();
     WEBCORE_EXPORT RefPtr<Range> compositionRange() const;
@@ -362,10 +368,12 @@
     Text* compositionNode() const { return m_compositionNode.get(); }
     unsigned compositionStart() const { return m_compositionStart; }
     unsigned compositionEnd() const { return m_compositionEnd; }
     bool compositionUsesCustomUnderlines() const { return !m_customCompositionUnderlines.isEmpty(); }
     const Vector<CompositionUnderline>& customCompositionUnderlines() const { return m_customCompositionUnderlines; }
+    bool compositionUsesCustomHighlights() const { return !m_customCompositionHighlights.isEmpty(); }
+    const Vector<CompositionHighlight>& customCompositionHighlights() const { return m_customCompositionHighlights; }
 
     enum class RevealSelection { No, Yes };
     WEBCORE_EXPORT void setIgnoreSelectionChanges(bool, RevealSelection shouldRevealExistingSelection = RevealSelection::Yes);
     bool ignoreSelectionChanges() const { return m_ignoreSelectionChanges; }
 
@@ -594,10 +602,11 @@
     RefPtr<CompositeEditCommand> m_lastEditCommand;
     RefPtr<Text> m_compositionNode;
     unsigned m_compositionStart;
     unsigned m_compositionEnd;
     Vector<CompositionUnderline> m_customCompositionUnderlines;
+    Vector<CompositionHighlight> m_customCompositionHighlights;
     bool m_ignoreSelectionChanges { false };
     bool m_shouldStartNewKillRingSequence { false };
     bool m_shouldStyleWithCSS { false };
     const std::unique_ptr<PAL::KillRing> m_killRing;
     const std::unique_ptr<SpellChecker> m_spellChecker;
@@ -626,10 +635,11 @@
     Timer m_telephoneNumberDetectionUpdateTimer;
     Vector<RefPtr<Range>> m_detectedTelephoneNumberRanges;
 #endif
 
     bool m_isGettingDictionaryPopupInfo { false };
+    HashSet<RefPtr<HTMLImageElement>> m_imageElementsToLoadBeforeRevealingSelection;
 };
 
 inline void Editor::setStartNewKillRingSequence(bool flag)
 {
     m_shouldStartNewKillRingSequence = flag;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerJobQueue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWServer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerJobQueue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerJobQueue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,11 ***</span>
  
  #include &quot;ExceptionData.h&quot;
  #include &quot;SWServer.h&quot;
  #include &quot;SWServerRegistration.h&quot;
  #include &quot;SWServerWorker.h&quot;
<span class="line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;ServiceWorkerFetchResult.h&quot;
  #include &quot;ServiceWorkerRegistrationData.h&quot;
  #include &quot;ServiceWorkerUpdateViaCache.h&quot;
  #include &quot;WorkerType.h&quot;
<span class="line-new-header">--- 30,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,11 ***</span>
  bool SWServerJobQueue::isCurrentlyProcessingJob(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier) const
  {
      return !m_jobQueue.isEmpty() &amp;&amp; firstJob().identifier() == jobDataIdentifier;
  }
  
<span class="line-modified">! void SWServerJobQueue::scriptFetchFinished(SWServer::Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)</span>
  {
      if (!isCurrentlyProcessingJob(result.jobDataIdentifier))
          return;
  
      auto&amp; job = firstJob();
<span class="line-new-header">--- 54,11 ---</span>
  bool SWServerJobQueue::isCurrentlyProcessingJob(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier) const
  {
      return !m_jobQueue.isEmpty() &amp;&amp; firstJob().identifier() == jobDataIdentifier;
  }
  
<span class="line-modified">! void SWServerJobQueue::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)</span>
  {
      if (!isCurrentlyProcessingJob(result.jobDataIdentifier))
          return;
  
      auto&amp; job = firstJob();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,11 ***</span>
      }
  
      // FIXME: Update all the imported scripts as per spec. For now, we just do as if there is none.
  
      // FIXME: Support the proper worker type (classic vs module)
<span class="line-modified">!     m_server.updateWorker(connection, job.identifier(), *registration, job.scriptURL, result.script, result.contentSecurityPolicy, result.referrerPolicy, WorkerType::Classic, { });</span>
  }
  
  // https://w3c.github.io/ServiceWorker/#update-algorithm
  void SWServerJobQueue::scriptContextFailedToStart(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier, const String&amp; message)
  {
<span class="line-new-header">--- 99,11 ---</span>
      }
  
      // FIXME: Update all the imported scripts as per spec. For now, we just do as if there is none.
  
      // FIXME: Support the proper worker type (classic vs module)
<span class="line-modified">!     m_server.updateWorker(job.identifier(), *registration, job.scriptURL, result.script, result.contentSecurityPolicy, result.referrerPolicy, WorkerType::Classic, { });</span>
  }
  
  // https://w3c.github.io/ServiceWorker/#update-algorithm
  void SWServerJobQueue::scriptContextFailedToStart(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier, const String&amp; message)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,29 ***</span>
      ASSERT(registration-&gt;installingWorker());
      m_server.fireInstallEvent(*registration-&gt;installingWorker());
  }
  
  // https://w3c.github.io/ServiceWorker/#install
<span class="line-modified">! void SWServerJobQueue::didFinishInstall(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, ServiceWorkerIdentifier identifier, bool wasSuccessful)</span>
  {
      if (!isCurrentlyProcessingJob(jobDataIdentifier))
          return;
  
<span class="line-modified">!     auto* registration = m_server.getRegistration(m_registrationKey);</span>
      ASSERT(registration);
<span class="line-modified">!     ASSERT(registration-&gt;installingWorker());</span>
<span class="line-removed">-     ASSERT(registration-&gt;installingWorker()-&gt;identifier() == identifier);</span>
  
      if (!wasSuccessful) {
<span class="line-modified">!         RefPtr&lt;SWServerWorker&gt; worker = m_server.workerByID(identifier);</span>
<span class="line-removed">-         RELEASE_ASSERT(worker);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         worker-&gt;terminate();</span>
          // Run the Update Registration State algorithm passing registration, &quot;installing&quot; and null as the arguments.
          registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
          // Run the Update Worker State algorithm passing registration&#39;s installing worker and redundant as the arguments.
<span class="line-modified">!         registration-&gt;updateWorkerState(*worker, ServiceWorkerState::Redundant);</span>
  
          // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
          if (!registration-&gt;getNewestWorker())
              registration-&gt;clear();
  
<span class="line-new-header">--- 175,25 ---</span>
      ASSERT(registration-&gt;installingWorker());
      m_server.fireInstallEvent(*registration-&gt;installingWorker());
  }
  
  // https://w3c.github.io/ServiceWorker/#install
<span class="line-modified">! void SWServerJobQueue::didFinishInstall(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)</span>
  {
      if (!isCurrentlyProcessingJob(jobDataIdentifier))
          return;
  
<span class="line-modified">!     auto* registration = worker.registration();</span>
      ASSERT(registration);
<span class="line-modified">!     ASSERT(registration-&gt;installingWorker() == &amp;worker);</span>
  
      if (!wasSuccessful) {
<span class="line-modified">!         worker.terminate();</span>
          // Run the Update Registration State algorithm passing registration, &quot;installing&quot; and null as the arguments.
          registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
          // Run the Update Worker State algorithm passing registration&#39;s installing worker and redundant as the arguments.
<span class="line-modified">!         registration-&gt;updateWorkerState(worker, ServiceWorkerState::Redundant);</span>
  
          // If newestWorker is null, invoke Clear Registration algorithm passing registration as its argument.
          if (!registration-&gt;getNewestWorker())
              registration-&gt;clear();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,16 ***</span>
      if (auto* waitingWorker = registration-&gt;waitingWorker()) {
          waitingWorker-&gt;terminate();
          registration-&gt;updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
      }
  
<span class="line-modified">!     auto* installing = registration-&gt;installingWorker();</span>
<span class="line-removed">-     ASSERT(installing);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Waiting, installing);</span>
      registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
<span class="line-modified">!     registration-&gt;updateWorkerState(*installing, ServiceWorkerState::Installed);</span>
  
      finishCurrentJob();
  
      // FIXME: Wait for all the tasks queued by Update Worker State invoked in this algorithm have executed.
      registration-&gt;tryActivate();
<span class="line-new-header">--- 205,13 ---</span>
      if (auto* waitingWorker = registration-&gt;waitingWorker()) {
          waitingWorker-&gt;terminate();
          registration-&gt;updateWorkerState(*waitingWorker, ServiceWorkerState::Redundant);
      }
  
<span class="line-modified">!     registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Waiting, &amp;worker);</span>
      registration-&gt;updateRegistrationState(ServiceWorkerRegistrationState::Installing, nullptr);
<span class="line-modified">!     registration-&gt;updateWorkerState(worker, ServiceWorkerState::Installed);</span>
  
      finishCurrentJob();
  
      // FIXME: Wait for all the tasks queued by Update Worker State invoked in this algorithm have executed.
      registration-&gt;tryActivate();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,11 ***</span>
  // https://w3c.github.io/ServiceWorker/#register-algorithm
  void SWServerJobQueue::runRegisterJob(const ServiceWorkerJobData&amp; job)
  {
      ASSERT(job.type == ServiceWorkerJobType::Register);
  
<span class="line-modified">!     if (!shouldTreatAsPotentiallyTrustworthy(job.scriptURL) &amp;&amp; !SchemeRegistry::isServiceWorkerContainerCustomScheme(job.scriptURL.protocol().toStringWithoutCopying()))</span>
          return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script URL is not potentially trustworthy&quot;_s });
  
      // If the origin of job&#39;s script url is not job&#39;s referrer&#39;s origin, then:
      if (!protocolHostAndPortAreEqual(job.scriptURL, job.clientCreationURL))
          return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script origin does not match the registering client&#39;s origin&quot;_s });
<span class="line-new-header">--- 250,11 ---</span>
  // https://w3c.github.io/ServiceWorker/#register-algorithm
  void SWServerJobQueue::runRegisterJob(const ServiceWorkerJobData&amp; job)
  {
      ASSERT(job.type == ServiceWorkerJobType::Register);
  
<span class="line-modified">!     if (!shouldTreatAsPotentiallyTrustworthy(job.scriptURL) &amp;&amp; !m_server.canHandleScheme(job.scriptURL.protocol()))</span>
          return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script URL is not potentially trustworthy&quot;_s });
  
      // If the origin of job&#39;s script url is not job&#39;s referrer&#39;s origin, then:
      if (!protocolHostAndPortAreEqual(job.scriptURL, job.clientCreationURL))
          return rejectCurrentJob(ExceptionData { SecurityError, &quot;Script origin does not match the registering client&#39;s origin&quot;_s });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,11 ***</span>
      if (!protocolHostAndPortAreEqual(job.scopeURL, job.clientCreationURL))
          return rejectCurrentJob(ExceptionData { SecurityError, &quot;Scope origin does not match the registering client&#39;s origin&quot;_s });
  
      // If registration is not null (in our parlance &quot;empty&quot;), then:
      if (auto* registration = m_server.getRegistration(m_registrationKey)) {
<span class="line-removed">-         registration-&gt;setIsUninstalling(false);</span>
          auto* newestWorker = registration-&gt;getNewestWorker();
          if (newestWorker &amp;&amp; equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()) &amp;&amp; job.registrationOptions.updateViaCache == registration-&gt;updateViaCache()) {
              RELEASE_LOG(ServiceWorker, &quot;%p - SWServerJobQueue::runRegisterJob: Found directly reusable registration %llu for job %s (DONE)&quot;, this, registration-&gt;identifier().toUInt64(), job.identifier().loggingString().utf8().data());
              m_server.resolveRegistrationJob(job, registration-&gt;data(), ShouldNotifyWhenResolved::No);
              finishCurrentJob();
<span class="line-new-header">--- 263,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,19 ***</span>
  
      // Let registration be the result of running &quot;Get Registration&quot; algorithm passing job&#39;s scope url as the argument.
      auto* registration = m_server.getRegistration(m_registrationKey);
  
      // If registration is null, then:
<span class="line-modified">!     if (!registration || registration-&gt;isUninstalling()) {</span>
          // Invoke Resolve Job Promise with job and false.
          m_server.resolveUnregistrationJob(job, m_registrationKey, false);
          finishCurrentJob();
          return;
      }
  
<span class="line-modified">!     // Set registration&#39;s uninstalling flag.</span>
<span class="line-modified">!     registration-&gt;setIsUninstalling(true);</span>
  
      // Invoke Resolve Job Promise with job and true.
      m_server.resolveUnregistrationJob(job, m_registrationKey, true);
  
      // Invoke Try Clear Registration with registration.
<span class="line-new-header">--- 295,19 ---</span>
  
      // Let registration be the result of running &quot;Get Registration&quot; algorithm passing job&#39;s scope url as the argument.
      auto* registration = m_server.getRegistration(m_registrationKey);
  
      // If registration is null, then:
<span class="line-modified">!     if (!registration) {</span>
          // Invoke Resolve Job Promise with job and false.
          m_server.resolveUnregistrationJob(job, m_registrationKey, false);
          finishCurrentJob();
          return;
      }
  
<span class="line-modified">!     // Remove scope to registration map[job’s scope url].</span>
<span class="line-modified">!     m_server.removeFromScopeToRegistrationMap(m_registrationKey);</span>
  
      // Invoke Resolve Job Promise with job and true.
      m_server.resolveUnregistrationJob(job, m_registrationKey, true);
  
      // Invoke Try Clear Registration with registration.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 331,31 ***</span>
      auto* registration = m_server.getRegistration(m_registrationKey);
  
      // If registration is null (in our parlance &quot;empty&quot;) or registration&#39;s uninstalling flag is set, then:
      if (!registration)
          return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a null/nonexistent service worker registration&quot;_s });
<span class="line-removed">-     if (registration-&gt;isUninstalling())</span>
<span class="line-removed">-         return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker registration that is uninstalling&quot;_s });</span>
  
      // Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
      auto* newestWorker = registration-&gt;getNewestWorker();
  
      // If job&#39;s type is update, and newestWorker&#39;s script url does not equal job&#39;s script url with the exclude fragments flag set, then:
      if (job.type == ServiceWorkerJobType::Update &amp;&amp; newestWorker &amp;&amp; !equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()))
          return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker with a requested script URL whose newest worker has a different script URL&quot;_s });
  
<span class="line-removed">-     FetchOptions::Cache cachePolicy = FetchOptions::Cache::Default;</span>
      // Set request&#39;s cache mode to &quot;no-cache&quot; if any of the following are true:
      // - registration&#39;s update via cache mode is not &quot;all&quot;.
      // - job&#39;s force bypass cache flag is set.
      // - newestWorker is not null, and registration&#39;s last update check time is not null and the time difference in seconds calculated by the
      //   current time minus registration&#39;s last update check time is greater than 86400.
<span class="line-modified">!     if (registration-&gt;updateViaCache() != ServiceWorkerUpdateViaCache::All</span>
<span class="line-modified">!         || (newestWorker &amp;&amp; registration-&gt;lastUpdateTime() &amp;&amp; (WallTime::now() - registration-&gt;lastUpdateTime()) &gt; 86400_s)) {</span>
<span class="line-removed">-         cachePolicy = FetchOptions::Cache::NoCache;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     m_server.startScriptFetch(job, cachePolicy);</span>
  }
  
  void SWServerJobQueue::rejectCurrentJob(const ExceptionData&amp; exceptionData)
  {
      m_server.rejectJob(firstJob(), exceptionData);
<span class="line-new-header">--- 322,25 ---</span>
      auto* registration = m_server.getRegistration(m_registrationKey);
  
      // If registration is null (in our parlance &quot;empty&quot;) or registration&#39;s uninstalling flag is set, then:
      if (!registration)
          return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a null/nonexistent service worker registration&quot;_s });
  
      // Let newestWorker be the result of running Get Newest Worker algorithm passing registration as the argument.
      auto* newestWorker = registration-&gt;getNewestWorker();
  
      // If job&#39;s type is update, and newestWorker&#39;s script url does not equal job&#39;s script url with the exclude fragments flag set, then:
      if (job.type == ServiceWorkerJobType::Update &amp;&amp; newestWorker &amp;&amp; !equalIgnoringFragmentIdentifier(job.scriptURL, newestWorker-&gt;scriptURL()))
          return rejectCurrentJob(ExceptionData { TypeError, &quot;Cannot update a service worker with a requested script URL whose newest worker has a different script URL&quot;_s });
  
      // Set request&#39;s cache mode to &quot;no-cache&quot; if any of the following are true:
      // - registration&#39;s update via cache mode is not &quot;all&quot;.
      // - job&#39;s force bypass cache flag is set.
      // - newestWorker is not null, and registration&#39;s last update check time is not null and the time difference in seconds calculated by the
      //   current time minus registration&#39;s last update check time is greater than 86400.
<span class="line-modified">!     bool shouldRefreshCache = registration-&gt;updateViaCache() != ServiceWorkerUpdateViaCache::All || (newestWorker &amp;&amp; registration-&gt;isStale());</span>
<span class="line-modified">!     m_server.startScriptFetch(job, shouldRefreshCache);</span>
  }
  
  void SWServerJobQueue::rejectCurrentJob(const ExceptionData&amp; exceptionData)
  {
      m_server.rejectJob(firstJob(), exceptionData);
</pre>
<center><a href="SWServer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerJobQueue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp b/modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp
@@ -29,10 +29,11 @@
  */
 
 #include "config.h"
 #include "FileReader.h"
 
+#include "EventLoop.h"
 #include "EventNames.h"
 #include "File.h"
 #include "Logging.h"
 #include "ProgressEvent.h"
 #include "ScriptExecutionContext.h"
@@ -63,28 +64,28 @@
 {
     if (m_loader)
         m_loader->cancel();
 }
 
-bool FileReader::canSuspendForDocumentSuspension() const
-{
-    return !hasPendingActivity();
-}
-
 const char* FileReader::activeDOMObjectName() const
 {
     return "FileReader";
 }
 
 void FileReader::stop()
 {
+    m_pendingTasks.clear();
     if (m_loader) {
         m_loader->cancel();
         m_loader = nullptr;
     }
     m_state = DONE;
-    m_loadingActivity = nullptr;
+}
+
+bool FileReader::hasPendingActivity() const
+{
+    return m_state == LOADING || ActiveDOMObject::hasPendingActivity();
 }
 
 ExceptionOr<void> FileReader::readAsArrayBuffer(Blob* blob)
 {
     if (!blob)
@@ -130,12 +131,10 @@
 {
     // If multiple concurrent read methods are called on the same FileReader, InvalidStateError should be thrown when the state is LOADING.
     if (m_state == LOADING)
         return Exception { InvalidStateError };
 
-    m_loadingActivity = makePendingActivity(*this);
-
     m_blob = &blob;
     m_readType = type;
     m_state = LOADING;
     m_error = nullptr;
 
@@ -154,14 +153,12 @@
     if (m_aborting || m_state != LOADING)
         return;
     m_aborting = true;
 
     // Schedule to have the abort done later since abort() might be called from the event handler and we do not want the resource loading code to be in the stack.
-    scriptExecutionContext()->postTask([this, protectedThis = makeRef(*this)] (ScriptExecutionContext&) {
-        if (isContextStopped())
-            return;
-
+    m_pendingTasks.clear();
+    enqueueTask([this] {
         ASSERT(m_state != DONE);
 
         stop();
         m_aborting = false;
 
@@ -173,59 +170,64 @@
     });
 }
 
 void FileReader::didStartLoading()
 {
-    fireEvent(eventNames().loadstartEvent);
+    enqueueTask([this] {
+        fireEvent(eventNames().loadstartEvent);
+    });
 }
 
 void FileReader::didReceiveData()
 {
-    auto now = MonotonicTime::now();
-    if (std::isnan(m_lastProgressNotificationTime)) {
-        m_lastProgressNotificationTime = now;
-        return;
-    }
-    if (now - m_lastProgressNotificationTime > progressNotificationInterval) {
-        fireEvent(eventNames().progressEvent);
-        m_lastProgressNotificationTime = now;
-    }
+    enqueueTask([this] {
+        auto now = MonotonicTime::now();
+        if (std::isnan(m_lastProgressNotificationTime)) {
+            m_lastProgressNotificationTime = now;
+            return;
+        }
+        if (now - m_lastProgressNotificationTime > progressNotificationInterval) {
+            fireEvent(eventNames().progressEvent);
+            m_lastProgressNotificationTime = now;
+        }
+    });
 }
 
 void FileReader::didFinishLoading()
 {
     if (m_aborting)
         return;
 
-    ASSERT(m_state != DONE);
-    m_state = DONE;
-
-    fireEvent(eventNames().progressEvent);
-    fireEvent(eventNames().loadEvent);
-    fireEvent(eventNames().loadendEvent);
+    enqueueTask([this] {
+        ASSERT(m_state != DONE);
+        m_state = DONE;
 
-    m_loadingActivity = nullptr;
+        fireEvent(eventNames().progressEvent);
+        fireEvent(eventNames().loadEvent);
+        fireEvent(eventNames().loadendEvent);
+    });
 }
 
 void FileReader::didFail(int errorCode)
 {
     // If we're aborting, do not proceed with normal error handling since it is covered in aborting code.
     if (m_aborting)
         return;
 
-    ASSERT(m_state != DONE);
-    m_state = DONE;
-
-    m_error = FileError::create(static_cast<FileError::ErrorCode>(errorCode));
-    fireEvent(eventNames().errorEvent);
-    fireEvent(eventNames().loadendEvent);
+    enqueueTask([this, errorCode] {
+        ASSERT(m_state != DONE);
+        m_state = DONE;
 
-    m_loadingActivity = nullptr;
+        m_error = FileError::create(static_cast<FileError::ErrorCode>(errorCode));
+        fireEvent(eventNames().errorEvent);
+        fireEvent(eventNames().loadendEvent);
+    });
 }
 
 void FileReader::fireEvent(const AtomString& type)
 {
+    RELEASE_ASSERT(isAllowedToRunScript());
     dispatchEvent(ProgressEvent::create(type, true, m_loader ? m_loader->bytesLoaded() : 0, m_loader ? m_loader->totalBytes() : 0));
 }
 
 Optional<Variant<String, RefPtr<JSC::ArrayBuffer>>> FileReader::result() const
 {
@@ -241,6 +243,22 @@
     if (result.isNull())
         return WTF::nullopt;
     return { WTFMove(result) };
 }
 
+void FileReader::enqueueTask(Function<void()>&& task)
+{
+    auto* context = scriptExecutionContext();
+    if (!context)
+        return;
+
+    static uint64_t taskIdentifierSeed = 0;
+    uint64_t taskIdentifier = ++taskIdentifierSeed;
+    m_pendingTasks.add(taskIdentifier, WTFMove(task));
+    context->eventLoop().queueTask(TaskSource::FileReading, [this, protectedThis = makeRef(*this), pendingActivity = makePendingActivity(*this), taskIdentifier] {
+        auto task = m_pendingTasks.take(taskIdentifier);
+        if (task)
+            task();
+    });
+}
+
 } // namespace WebCore

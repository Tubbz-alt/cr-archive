<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003-2013,  Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;ComplexLineLayout.h&quot;
 26 #include &quot;FloatingObjects.h&quot;
 27 #include &quot;LineWidth.h&quot;
 28 #include &quot;RenderBlock.h&quot;
 29 #include &quot;RenderLineBoxList.h&quot;
 30 #include &quot;SimpleLineLayout.h&quot;
 31 #include &quot;TrailingObjects.h&quot;
 32 #include &lt;memory&gt;
 33 
 34 namespace WebCore {
 35 
 36 class LineBreaker;
 37 class RenderMultiColumnFlow;
 38 class RenderRubyRun;
 39 
<a name="1" id="anc1"></a><span class="line-added"> 40 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 41 namespace LayoutIntegration {</span>
<span class="line-added"> 42 class LineLayout;</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 #endif</span>
<span class="line-added"> 45 </span>
 46 #if ENABLE(TEXT_AUTOSIZING)
 47 enum LineCount {
 48     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 49 };
 50 #endif
 51 
 52 class RenderBlockFlow : public RenderBlock {
 53     WTF_MAKE_ISO_ALLOCATED(RenderBlockFlow);
 54 public:
 55     RenderBlockFlow(Element&amp;, RenderStyle&amp;&amp;);
 56     RenderBlockFlow(Document&amp;, RenderStyle&amp;&amp;);
 57     virtual ~RenderBlockFlow();
 58 
 59     void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu) override;
 60 
 61 protected:
 62     void willBeDestroyed() override;
 63 
 64     // This method is called at the start of layout to wipe away all of the floats in our floating objects list. It also
 65     // repopulates the list with any floats that intrude from previous siblings or parents. Floats that were added by
 66     // descendants are gone when this call completes and will get added back later on after the children have gotten
 67     // a relayout.
 68     void rebuildFloatingObjectSetFromIntrudingFloats();
 69 
 70     // RenderBlockFlow always contains either lines or paragraphs. When the children are all blocks (e.g. paragraphs), we call layoutBlockChildren.
 71     // When the children are all inline (e.g., lines), we call layoutInlineChildren.
 72     void layoutBlockChildren(bool relayoutChildren, LayoutUnit&amp; maxFloatLogicalBottom);
 73     void layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
 74 
 75     // RenderBlockFlows override these methods, since they are the only class that supports margin collapsing.
 76     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
 77     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 78 
 79     void dirtyLinesFromChangedChild(RenderObject&amp; child) final
 80     {
<a name="2" id="anc2"></a><span class="line-modified"> 81         if (complexLineLayout())</span>
<span class="line-modified"> 82             complexLineLayout()-&gt;lineBoxes().dirtyLinesFromChangedChild(*this, child);</span>
 83     }
 84 
 85     void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) override;
 86 
 87 public:
 88     class MarginValues {
 89     public:
 90         MarginValues(LayoutUnit beforePos, LayoutUnit beforeNeg, LayoutUnit afterPos, LayoutUnit afterNeg)
 91             : m_positiveMarginBefore(beforePos)
 92             , m_negativeMarginBefore(beforeNeg)
 93             , m_positiveMarginAfter(afterPos)
 94             , m_negativeMarginAfter(afterNeg)
 95         {
 96         }
 97 
 98         LayoutUnit positiveMarginBefore() const { return m_positiveMarginBefore; }
 99         LayoutUnit negativeMarginBefore() const { return m_negativeMarginBefore; }
100         LayoutUnit positiveMarginAfter() const { return m_positiveMarginAfter; }
101         LayoutUnit negativeMarginAfter() const { return m_negativeMarginAfter; }
102 
103         void setPositiveMarginBefore(LayoutUnit pos) { m_positiveMarginBefore = pos; }
104         void setNegativeMarginBefore(LayoutUnit neg) { m_negativeMarginBefore = neg; }
105         void setPositiveMarginAfter(LayoutUnit pos) { m_positiveMarginAfter = pos; }
106         void setNegativeMarginAfter(LayoutUnit neg) { m_negativeMarginAfter = neg; }
107 
108     private:
109         LayoutUnit m_positiveMarginBefore;
110         LayoutUnit m_negativeMarginBefore;
111         LayoutUnit m_positiveMarginAfter;
112         LayoutUnit m_negativeMarginAfter;
113     };
114     MarginValues marginValuesForChild(RenderBox&amp; child) const;
115 
116     // Allocated only when some of these fields have non-default values
117     struct RenderBlockFlowRareData {
118         WTF_MAKE_NONCOPYABLE(RenderBlockFlowRareData); WTF_MAKE_FAST_ALLOCATED;
119     public:
120         RenderBlockFlowRareData(const RenderBlockFlow&amp; block)
121             : m_margins(positiveMarginBeforeDefault(block), negativeMarginBeforeDefault(block), positiveMarginAfterDefault(block), negativeMarginAfterDefault(block))
122             , m_lineBreakToAvoidWidow(-1)
123             , m_discardMarginBefore(false)
124             , m_discardMarginAfter(false)
125             , m_didBreakAtLineToAvoidWidow(false)
126         {
127         }
128 
129         static LayoutUnit positiveMarginBeforeDefault(const RenderBlock&amp; block)
130         {
131             return std::max&lt;LayoutUnit&gt;(block.marginBefore(), 0);
132         }
133         static LayoutUnit negativeMarginBeforeDefault(const RenderBlock&amp; block)
134         {
135             return std::max&lt;LayoutUnit&gt;(-block.marginBefore(), 0);
136         }
137         static LayoutUnit positiveMarginAfterDefault(const RenderBlock&amp; block)
138         {
139             return std::max&lt;LayoutUnit&gt;(block.marginAfter(), 0);
140         }
141         static LayoutUnit negativeMarginAfterDefault(const RenderBlock&amp; block)
142         {
143             return std::max&lt;LayoutUnit&gt;(-block.marginAfter(), 0);
144         }
145 
146         MarginValues m_margins;
147         int m_lineBreakToAvoidWidow;
148         std::unique_ptr&lt;RootInlineBox&gt; m_lineGridBox;
149 
150         WeakPtr&lt;RenderMultiColumnFlow&gt; m_multiColumnFlow;
151 
152         bool m_discardMarginBefore : 1;
153         bool m_discardMarginAfter : 1;
154         bool m_didBreakAtLineToAvoidWidow : 1;
155     };
156 
157     class MarginInfo {
158         // Collapsing flags for whether we can collapse our margins with our children&#39;s margins.
159         bool m_canCollapseWithChildren : 1;
160         bool m_canCollapseMarginBeforeWithChildren : 1;
161         bool m_canCollapseMarginAfterWithChildren : 1;
162 
163         // Whether or not we are a quirky container, i.e., do we collapse away top and bottom
164         // margins in our container. Table cells and the body are the common examples. We
165         // also have a custom style property for Safari RSS to deal with TypePad blog articles.
166         bool m_quirkContainer : 1;
167 
168         // This flag tracks whether we are still looking at child margins that can all collapse together at the beginning of a block.
169         // They may or may not collapse with the top margin of the block (|m_canCollapseTopWithChildren| tells us that), but they will
170         // always be collapsing with one another. This variable can remain set to true through multiple iterations
171         // as long as we keep encountering self-collapsing blocks.
172         bool m_atBeforeSideOfBlock : 1;
173 
174         // This flag is set when we know we&#39;re examining bottom margins and we know we&#39;re at the bottom of the block.
175         bool m_atAfterSideOfBlock : 1;
176 
177         // These variables are used to detect quirky margins that we need to collapse away (in table cells
178         // and in the body element).
179         bool m_hasMarginBeforeQuirk : 1;
180         bool m_hasMarginAfterQuirk : 1;
181         bool m_determinedMarginBeforeQuirk : 1;
182 
183         bool m_discardMargin : 1;
184 
185         // These flags track the previous maximal positive and negative margins.
186         LayoutUnit m_positiveMargin;
187         LayoutUnit m_negativeMargin;
188 
189     public:
190         MarginInfo(const RenderBlockFlow&amp;, LayoutUnit beforeBorderPadding, LayoutUnit afterBorderPadding);
191 
192         void setAtBeforeSideOfBlock(bool b) { m_atBeforeSideOfBlock = b; }
193         void setAtAfterSideOfBlock(bool b) { m_atAfterSideOfBlock = b; }
194         void clearMargin()
195         {
196             m_positiveMargin = 0;
197             m_negativeMargin = 0;
198         }
199         void setHasMarginBeforeQuirk(bool b) { m_hasMarginBeforeQuirk = b; }
200         void setHasMarginAfterQuirk(bool b) { m_hasMarginAfterQuirk = b; }
201         void setDeterminedMarginBeforeQuirk(bool b) { m_determinedMarginBeforeQuirk = b; }
202         void setPositiveMargin(LayoutUnit p) { ASSERT(!m_discardMargin); m_positiveMargin = p; }
203         void setNegativeMargin(LayoutUnit n) { ASSERT(!m_discardMargin); m_negativeMargin = n; }
204         void setPositiveMarginIfLarger(LayoutUnit p)
205         {
206             ASSERT(!m_discardMargin);
207             if (p &gt; m_positiveMargin)
208                 m_positiveMargin = p;
209         }
210         void setNegativeMarginIfLarger(LayoutUnit n)
211         {
212             ASSERT(!m_discardMargin);
213             if (n &gt; m_negativeMargin)
214                 m_negativeMargin = n;
215         }
216 
217         void setMargin(LayoutUnit p, LayoutUnit n) { ASSERT(!m_discardMargin); m_positiveMargin = p; m_negativeMargin = n; }
218         void setCanCollapseMarginAfterWithChildren(bool collapse) { m_canCollapseMarginAfterWithChildren = collapse; }
219         void setDiscardMargin(bool value) { m_discardMargin = value; }
220 
221         bool atBeforeSideOfBlock() const { return m_atBeforeSideOfBlock; }
222         bool canCollapseWithMarginBefore() const { return m_atBeforeSideOfBlock &amp;&amp; m_canCollapseMarginBeforeWithChildren; }
223         bool canCollapseWithMarginAfter() const { return m_atAfterSideOfBlock &amp;&amp; m_canCollapseMarginAfterWithChildren; }
224         bool canCollapseMarginBeforeWithChildren() const { return m_canCollapseMarginBeforeWithChildren; }
225         bool canCollapseMarginAfterWithChildren() const { return m_canCollapseMarginAfterWithChildren; }
226         bool quirkContainer() const { return m_quirkContainer; }
227         bool determinedMarginBeforeQuirk() const { return m_determinedMarginBeforeQuirk; }
228         bool hasMarginBeforeQuirk() const { return m_hasMarginBeforeQuirk; }
229         bool hasMarginAfterQuirk() const { return m_hasMarginAfterQuirk; }
230         LayoutUnit positiveMargin() const { return m_positiveMargin; }
231         LayoutUnit negativeMargin() const { return m_negativeMargin; }
232         bool discardMargin() const { return m_discardMargin; }
233         LayoutUnit margin() const { return m_positiveMargin - m_negativeMargin; }
234     };
235     LayoutUnit marginOffsetForSelfCollapsingBlock();
236 
237     void layoutBlockChild(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom);
238     void adjustPositionedBlock(RenderBox&amp; child, const MarginInfo&amp;);
239     void adjustFloatingBlock(const MarginInfo&amp;);
240 
241     void setStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit blockOffset, LayoutUnit inlinePosition);
242     void updateStaticInlinePositionForChild(RenderBox&amp; child, LayoutUnit logicalTop, IndentTextOrNot shouldIndentText);
243 
244     LayoutUnit startAlignedOffsetForLine(LayoutUnit position, IndentTextOrNot);
245 
246     LayoutUnit collapseMargins(RenderBox&amp; child, MarginInfo&amp;);
247     LayoutUnit collapseMarginsWithChildInfo(RenderBox* child, RenderObject* prevSibling, MarginInfo&amp;);
248 
249     LayoutUnit clearFloatsIfNeeded(RenderBox&amp; child, MarginInfo&amp;, LayoutUnit oldTopPosMargin, LayoutUnit oldTopNegMargin, LayoutUnit yPos);
250     LayoutUnit estimateLogicalTopPosition(RenderBox&amp; child, const MarginInfo&amp;, LayoutUnit&amp; estimateWithoutPagination);
251     void marginBeforeEstimateForChild(RenderBox&amp;, LayoutUnit&amp;, LayoutUnit&amp;, bool&amp;) const;
252     void handleAfterSideOfBlock(LayoutUnit top, LayoutUnit bottom, MarginInfo&amp;);
253     void setCollapsedBottomMargin(const MarginInfo&amp;);
254 
255     bool childrenPreventSelfCollapsing() const final;
256 
257     bool shouldBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow &gt;= 0; }
258     void clearShouldBreakAtLineToAvoidWidow() const;
259     int lineBreakToAvoidWidow() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineBreakToAvoidWidow : -1; }
260     void setBreakAtLineToAvoidWidow(int);
261     void clearDidBreakAtLineToAvoidWidow();
262     void setDidBreakAtLineToAvoidWidow();
263     bool didBreakAtLineToAvoidWidow() const { return hasRareBlockFlowData() &amp;&amp; rareBlockFlowData()-&gt;m_didBreakAtLineToAvoidWidow; }
264     bool relayoutToAvoidWidows();
265 
266     RootInlineBox* lineGridBox() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_lineGridBox.get() : nullptr; }
267     void setLineGridBox(std::unique_ptr&lt;RootInlineBox&gt; box)
268     {
269         ensureRareBlockFlowData().m_lineGridBox = WTFMove(box);
270     }
271     void layoutLineGridBox();
272 
273     RenderMultiColumnFlow* multiColumnFlow() const { return hasRareBlockFlowData() ? multiColumnFlowSlowCase() : nullptr; }
274     RenderMultiColumnFlow* multiColumnFlowSlowCase() const;
275     void setMultiColumnFlow(RenderMultiColumnFlow&amp;);
276     void clearMultiColumnFlow();
277     bool willCreateColumns(Optional&lt;unsigned&gt; desiredColumnCount = WTF::nullopt) const;
278     virtual bool requiresColumns(int) const;
279 
280     bool containsFloats() const override { return m_floatingObjects &amp;&amp; !m_floatingObjects-&gt;set().isEmpty(); }
281     bool containsFloat(RenderBox&amp;) const;
282 
283     void deleteLines() override;
284     void computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats = false) override;
285     Position positionForPoint(const LayoutPoint&amp;) override;
286     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
287 
288     LayoutUnit lowestFloatLogicalBottom(FloatingObject::Type = FloatingObject::FloatLeftRight) const;
289 
290     void removeFloatingObjects();
291     void markAllDescendantsWithFloatsForLayout(RenderBox* floatToRemove = nullptr, bool inLayout = true);
292     void markSiblingsWithFloatsForLayout(RenderBox* floatToRemove = nullptr);
293 
294     const FloatingObjectSet* floatingObjectSet() const { return m_floatingObjects ? &amp;m_floatingObjects-&gt;set() : nullptr; }
295 
296     LayoutUnit logicalTopForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.y() : floatingObject.x(); }
297     LayoutUnit logicalBottomForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.maxY() : floatingObject.maxX(); }
298     LayoutUnit logicalLeftForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.x() : floatingObject.y(); }
299     LayoutUnit logicalRightForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.maxX() : floatingObject.maxY(); }
300     LayoutUnit logicalWidthForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.width() : floatingObject.height(); }
301     LayoutUnit logicalHeightForFloat(const FloatingObject&amp; floatingObject) const { return isHorizontalWritingMode() ? floatingObject.height() : floatingObject.width(); }
302 
303     void setLogicalTopForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalTop)
304     {
305         if (isHorizontalWritingMode())
306             floatingObject.setY(logicalTop);
307         else
308             floatingObject.setX(logicalTop);
309     }
310     void setLogicalLeftForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeft)
311     {
312         if (isHorizontalWritingMode())
313             floatingObject.setX(logicalLeft);
314         else
315             floatingObject.setY(logicalLeft);
316     }
317     void setLogicalHeightForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalHeight)
318     {
319         if (isHorizontalWritingMode())
320             floatingObject.setHeight(logicalHeight);
321         else
322             floatingObject.setWidth(logicalHeight);
323     }
324     void setLogicalWidthForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalWidth)
325     {
326         if (isHorizontalWritingMode())
327             floatingObject.setWidth(logicalWidth);
328         else
329             floatingObject.setHeight(logicalWidth);
330     }
331     void setLogicalMarginsForFloat(FloatingObject&amp; floatingObject, LayoutUnit logicalLeftMargin, LayoutUnit logicalBeforeMargin)
332     {
333         if (isHorizontalWritingMode())
334             floatingObject.setMarginOffset(LayoutSize(logicalLeftMargin, logicalBeforeMargin));
335         else
336             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
337     }
338 
339     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&amp;, const LayoutPoint&amp;) const;
340 
<a name="3" id="anc3"></a><span class="line-modified">341     RootInlineBox* firstRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;firstRootBox() : nullptr; }</span>
<span class="line-modified">342     RootInlineBox* lastRootBox() const { return complexLineLayout() ? complexLineLayout()-&gt;lastRootBox() : nullptr; }</span>
343 
344     bool hasLines() const;
345     void invalidateLineLayoutPath() final;
346 
<a name="4" id="anc4"></a><span class="line-modified">347     enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, LayoutFormattingContextPath, ForceLineBoxesPath };</span>
348     LineLayoutPath lineLayoutPath() const { return static_cast&lt;LineLayoutPath&gt;(renderBlockFlowLineLayoutPath()); }
349     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
350 
351     // Helper methods for computing line counts and heights for line counts.
352     RootInlineBox* lineAtIndex(int) const;
<a name="5" id="anc5"></a><span class="line-modified">353     int lineCount() const;</span>
354     int heightForLineCount(int);
355     void clearTruncation();
356 
357     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
358     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
359 
360     bool containsNonZeroBidiLevel() const;
361 
362     const SimpleLineLayout::Layout* simpleLineLayout() const;
<a name="6" id="anc6"></a><span class="line-modified">363     SimpleLineLayout::Layout* simpleLineLayout();</span>
<span class="line-added">364     const ComplexLineLayout* complexLineLayout() const;</span>
<span class="line-added">365     ComplexLineLayout* complexLineLayout();</span>
<span class="line-added">366 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">367     const LayoutIntegration::LineLayout* layoutFormattingContextLineLayout() const;</span>
<span class="line-added">368     LayoutIntegration::LineLayout* layoutFormattingContextLineLayout();</span>
<span class="line-added">369 #endif</span>
<span class="line-added">370 </span>
371     void ensureLineBoxes();
372     void generateLineBoxTree();
373 
374 #if ENABLE(TREE_DEBUGGING)
375     void outputLineTreeAndMark(WTF::TextStream&amp;, const InlineBox* markedBox, int depth) const;
376 #endif
377 
378     // Returns the logicalOffset at the top of the next page. If the offset passed in is already at the top of the current page,
379     // then nextPageLogicalTop with ExcludePageBoundary will still move to the top of the next page. nextPageLogicalTop with
380     // IncludePageBoundary set will not.
381     //
382     // For a page height of 800px, the first rule will return 800 if the value passed in is 0. The second rule will simply return 0.
383     enum PageBoundaryRule { ExcludePageBoundary, IncludePageBoundary };
384     LayoutUnit nextPageLogicalTop(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
385     LayoutUnit pageLogicalTopForOffset(LayoutUnit offset) const;
386     LayoutUnit pageLogicalHeightForOffset(LayoutUnit offset) const;
387     LayoutUnit pageRemainingLogicalHeightForOffset(LayoutUnit offset, PageBoundaryRule = IncludePageBoundary) const;
388     LayoutUnit logicalHeightForChildForFragmentation(const RenderBox&amp; child) const;
389     bool hasNextPage(LayoutUnit logicalOffset, PageBoundaryRule = ExcludePageBoundary) const;
390 
391     void updateColumnProgressionFromStyle(RenderStyle&amp;);
392     void updateStylesForColumnChildren();
393 
394     bool needsLayoutAfterFragmentRangeChange() const override;
395     WEBCORE_EXPORT RenderText* findClosestTextAtAbsolutePoint(const FloatPoint&amp;);
396 
397     // A page break is required at some offset due to space shortage in the current fragmentainer.
398     void setPageBreak(LayoutUnit offset, LayoutUnit spaceShortage);
399     // Update minimum page height required to avoid fragmentation where it shouldn&#39;t occur (inside
400     // unbreakable content, between orphans and widows, etc.). This will be used as a hint to the
401     // column balancer to help set a good minimum column height.
402     void updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight);
403 
404     void addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const;
405 
406 protected:
<a name="7" id="anc7"></a><span class="line-added">407     bool shouldResetLogicalHeightBeforeLayout() const override { return true; }</span>
<span class="line-added">408 </span>
409     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
410 
411     bool pushToNextPageWithMinimumLogicalHeight(LayoutUnit&amp; adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const;
412 
413     // If the child is unsplittable and can&#39;t fit on the current page, return the top of the next page/column.
414     LayoutUnit adjustForUnsplittableChild(RenderBox&amp; child, LayoutUnit logicalOffset, LayoutUnit beforeMargin = 0_lu, LayoutUnit afterMargin = 0_lu);
415     LayoutUnit adjustBlockChildForPagination(LayoutUnit logicalTopAfterClear, LayoutUnit estimateWithoutPagination, RenderBox&amp; child, bool atBeforeSideOfBlock);
416     LayoutUnit applyBeforeBreak(RenderBox&amp; child, LayoutUnit logicalOffset); // If the child has a before break, then return a new yPos that shifts to the top of the next page/column.
417     LayoutUnit applyAfterBreak(RenderBox&amp; child, LayoutUnit logicalOffset, MarginInfo&amp;); // If the child has an after break, then return a new offset that shifts to the top of the next page/column.
418 
419     LayoutUnit maxPositiveMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginBefore() : RenderBlockFlowRareData::positiveMarginBeforeDefault(*this); }
420     LayoutUnit maxNegativeMarginBefore() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginBefore() : RenderBlockFlowRareData::negativeMarginBeforeDefault(*this); }
421     LayoutUnit maxPositiveMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.positiveMarginAfter() : RenderBlockFlowRareData::positiveMarginAfterDefault(*this); }
422     LayoutUnit maxNegativeMarginAfter() const { return hasRareBlockFlowData() ? rareBlockFlowData()-&gt;m_margins.negativeMarginAfter() : RenderBlockFlowRareData::negativeMarginAfterDefault(*this); }
423 
424     void initMaxMarginValues()
425     {
426         if (!hasRareBlockFlowData())
427             return;
428 
429         rareBlockFlowData()-&gt;m_margins = MarginValues(RenderBlockFlowRareData::positiveMarginBeforeDefault(*this) , RenderBlockFlowRareData::negativeMarginBeforeDefault(*this),
430             RenderBlockFlowRareData::positiveMarginAfterDefault(*this), RenderBlockFlowRareData::negativeMarginAfterDefault(*this));
431         rareBlockFlowData()-&gt;m_discardMarginBefore = false;
432         rareBlockFlowData()-&gt;m_discardMarginAfter = false;
433     }
434 
435     void setMaxMarginBeforeValues(LayoutUnit pos, LayoutUnit neg);
436     void setMaxMarginAfterValues(LayoutUnit pos, LayoutUnit neg);
437 
438     void setMustDiscardMarginBefore(bool = true);
439     void setMustDiscardMarginAfter(bool = true);
440 
441     bool mustDiscardMarginBefore() const;
442     bool mustDiscardMarginAfter() const;
443 
444     bool mustDiscardMarginBeforeForChild(const RenderBox&amp;) const;
445     bool mustDiscardMarginAfterForChild(const RenderBox&amp;) const;
446     bool mustSeparateMarginBeforeForChild(const RenderBox&amp;) const;
447     bool mustSeparateMarginAfterForChild(const RenderBox&amp;) const;
448 
449     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
450     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
451 
452     void createFloatingObjects();
453 
454     Optional&lt;int&gt; firstLineBaseline() const override;
455     Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const override;
456 
457     bool isMultiColumnBlockFlow() const override { return multiColumnFlow(); }
458 
459     void setComputedColumnCountAndWidth(int, LayoutUnit);
460 
461     LayoutUnit computedColumnWidth() const;
462     unsigned computedColumnCount() const;
463 
464     bool isTopLayoutOverflowAllowed() const override;
465     bool isLeftLayoutOverflowAllowed() const override;
466 
467     virtual void computeColumnCountAndWidth();
468 
469     virtual void cachePriorCharactersIfNeeded(const LazyLineBreakIterator&amp;) {};
470 
471 protected:
472     // Called to lay out the legend for a fieldset or the ruby text of a ruby run. Also used by multi-column layout to handle
473     // the flow thread child.
474     void layoutExcludedChildren(bool relayoutChildren) override;
475     void addOverflowFromFloats();
476 
477 private:
478     bool recomputeLogicalWidthAndColumnWidth();
479     LayoutUnit columnGap() const;
480 
481     RenderBlockFlow* previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const;
482 
483     void checkForPaginationLogicalHeightChange(bool&amp; relayoutChildren, LayoutUnit&amp; pageLogicalHeight, bool&amp; pageLogicalHeightChanged);
484 
485     void paintInlineChildren(PaintInfo&amp;, const LayoutPoint&amp;) override;
486     void paintFloats(PaintInfo&amp;, const LayoutPoint&amp;, bool preservePhase = false) override;
487 
488     void repaintOverhangingFloats(bool paintAllDescendants) final;
489     void clipOutFloatingObjects(RenderBlock&amp;, const PaintInfo*, const LayoutPoint&amp;, const LayoutSize&amp;) override;
490 
491     FloatingObject* insertFloatingObject(RenderBox&amp;);
492     void removeFloatingObject(RenderBox&amp;);
493     void removeFloatingObjectsBelow(FloatingObject*, int logicalOffset);
494     void computeLogicalLocationForFloat(FloatingObject&amp;, LayoutUnit&amp; logicalTopOffset);
495 
496     // Called from lineWidth, to position the floats added in the last line.
497     // Returns true if and only if it has positioned any floats.
498     bool positionNewFloats();
499     void clearFloats(Clear);
500     FloatingObjects* floatingObjects() { return m_floatingObjects.get(); }
501 
502     LayoutUnit logicalRightFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
503     LayoutUnit logicalLeftFloatOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, LayoutUnit logicalHeight) const override;
504 
505     LayoutUnit logicalRightOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
506     LayoutUnit logicalLeftOffsetForPositioningFloat(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit* heightRemaining) const;
507 
508     LayoutUnit lowestInitialLetterLogicalBottom() const;
509 
510     LayoutUnit nextFloatLogicalBottomBelow(LayoutUnit) const;
511     LayoutUnit nextFloatLogicalBottomBelowForBlock(LayoutUnit) const;
512 
513     LayoutUnit addOverhangingFloats(RenderBlockFlow&amp; child, bool makeChildPaintOtherFloats);
514     bool hasOverhangingFloat(RenderBox&amp;);
515     void addIntrudingFloats(RenderBlockFlow* prev, RenderBlockFlow* container, LayoutUnit xoffset, LayoutUnit yoffset);
516     bool hasOverhangingFloats() { return parent() &amp;&amp; containsFloats() &amp;&amp; lowestFloatLogicalBottom() &gt; logicalHeight(); }
517     LayoutUnit getClearDelta(RenderBox&amp; child, LayoutUnit yPos);
518 
519     void determineLogicalLeftPositionForChild(RenderBox&amp; child, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
520 
521     bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset) override;
522     bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
523 
524     void addOverflowFromInlineChildren() override;
525 
526     void fitBorderToLinesIfNeeded(); // Shrink the box in which the border paints if border-fit is set.
527     void adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const;
528 
529     void markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest = 0);
530 
531     GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
532         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*) override;
533 
534     Position positionForBox(InlineBox*, bool start = true) const;
535     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer*) override;
536     void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*) override;
537 
538 public:
<a name="8" id="anc8"></a>

539     virtual Optional&lt;TextAlignMode&gt; overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
540     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float&amp; /* logicalLeft */, float&amp; /* logicalWidth */) const { }
541 
542 private:
<a name="9" id="anc9"></a><span class="line-added">543     bool hasLineLayout() const;</span>
<span class="line-added">544     bool hasSimpleLineLayout() const;</span>
<span class="line-added">545     bool hasComplexLineLayout() const;</span>
<span class="line-added">546 </span>
547     void layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);
548 
<a name="10" id="anc10"></a><span class="line-added">549 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">550     bool hasLayoutFormattingContextLineLayout() const;</span>
<span class="line-added">551     void layoutLFCLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom);</span>
<span class="line-added">552 #endif</span>
<span class="line-added">553 </span>
554     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
555     void computeInlinePreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
556     void adjustInitialLetterPosition(RenderBox&amp; childBox, LayoutUnit&amp; logicalTopOffset, LayoutUnit&amp; marginBeforeOffset);
557 
558 #if ENABLE(TEXT_AUTOSIZING)
559     int m_widthForTextAutosizing;
560     unsigned m_lineCountForTextAutosizing : 2;
561 #endif
562     void setSelectionState(SelectionState) final;
563 
564 public:
565     // FIXME-BLOCKFLOW: These can be made protected again once all callers have been moved here.
566     void adjustLinePositionForPagination(RootInlineBox*, LayoutUnit&amp; deltaOffset, bool&amp; overflowsFragment, RenderFragmentedFlow*); // Computes a deltaOffset value that put a line at the top of the next page if it doesn&#39;t fit on the current page.
567 
568     // Pagination routines.
569     bool relayoutForPagination();
570 
571     bool hasRareBlockFlowData() const { return m_rareBlockFlowData.get(); }
572     RenderBlockFlowRareData* rareBlockFlowData() const { ASSERT_WITH_SECURITY_IMPLICATION(hasRareBlockFlowData()); return m_rareBlockFlowData.get(); }
573     RenderBlockFlowRareData&amp; ensureRareBlockFlowData();
574     void materializeRareBlockFlowData();
575 
576 #if ENABLE(TEXT_AUTOSIZING)
577     int lineCountForTextAutosizing();
578     void adjustComputedFontSizes(float size, float visibleWidth);
579     void resetComputedFontSize()
580     {
581         m_widthForTextAutosizing = -1;
582         m_lineCountForTextAutosizing = NOT_SET;
583     }
584 #endif
585 
586 protected:
587     std::unique_ptr&lt;FloatingObjects&gt; m_floatingObjects;
588     std::unique_ptr&lt;RenderBlockFlowRareData&gt; m_rareBlockFlowData;
589 
<a name="11" id="anc11"></a><span class="line-modified">590 private:</span>
<span class="line-modified">591     Variant&lt;</span>
<span class="line-modified">592         WTF::Monostate,</span>
<span class="line-added">593         Ref&lt;SimpleLineLayout::Layout&gt;,</span>
<span class="line-added">594 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">595         std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;,</span>
<span class="line-added">596 #endif</span>
<span class="line-added">597         std::unique_ptr&lt;ComplexLineLayout&gt;</span>
<span class="line-added">598     &gt; m_lineLayout;</span>
599 
600     friend class LineBreaker;
601     friend class LineWidth; // Needs to know FloatingObject
602     friend class ComplexLineLayout;
603 };
604 
<a name="12" id="anc12"></a><span class="line-added">605 inline bool RenderBlockFlow::hasLineLayout() const</span>
<span class="line-added">606 {</span>
<span class="line-added">607     return !WTF::holds_alternative&lt;WTF::Monostate&gt;(m_lineLayout);</span>
<span class="line-added">608 }</span>
<span class="line-added">609 </span>
<span class="line-added">610 inline bool RenderBlockFlow::hasComplexLineLayout() const</span>
<span class="line-added">611 {</span>
<span class="line-added">612     return WTF::holds_alternative&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">613 }</span>
<span class="line-added">614 </span>
<span class="line-added">615 inline const ComplexLineLayout* RenderBlockFlow::complexLineLayout() const</span>
<span class="line-added">616 {</span>
<span class="line-added">617     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">618 }</span>
<span class="line-added">619 </span>
<span class="line-added">620 inline ComplexLineLayout* RenderBlockFlow::complexLineLayout()</span>
<span class="line-added">621 {</span>
<span class="line-added">622     return hasComplexLineLayout() ? WTF::get&lt;std::unique_ptr&lt;ComplexLineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">623 }</span>
<span class="line-added">624 </span>
<span class="line-added">625 inline bool RenderBlockFlow::hasSimpleLineLayout() const</span>
<span class="line-added">626 {</span>
<span class="line-added">627     return WTF::holds_alternative&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">628 }</span>
<span class="line-added">629 </span>
630 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
631 {
<a name="13" id="anc13"></a><span class="line-modified">632     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
<span class="line-modified">633 }</span>
<span class="line-added">634 </span>
<span class="line-added">635 inline SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout()</span>
<span class="line-added">636 {</span>
<span class="line-added">637     return hasSimpleLineLayout() ? WTF::get&lt;Ref&lt;SimpleLineLayout::Layout&gt;&gt;(m_lineLayout).ptr() : nullptr;</span>
638 }
639 
<a name="14" id="anc14"></a><span class="line-added">640 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">641 inline bool RenderBlockFlow::hasLayoutFormattingContextLineLayout() const</span>
<span class="line-added">642 {</span>
<span class="line-added">643     return WTF::holds_alternative&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout);</span>
<span class="line-added">644 }</span>
<span class="line-added">645 </span>
<span class="line-added">646 inline const LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout() const</span>
<span class="line-added">647 {</span>
<span class="line-added">648     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">649 }</span>
<span class="line-added">650 </span>
<span class="line-added">651 inline LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout()</span>
<span class="line-added">652 {</span>
<span class="line-added">653     return hasLayoutFormattingContextLineLayout() ? WTF::get&lt;std::unique_ptr&lt;LayoutIntegration::LineLayout&gt;&gt;(m_lineLayout).get() : nullptr;</span>
<span class="line-added">654 }</span>
<span class="line-added">655 #endif</span>
<span class="line-added">656 </span>
657 } // namespace WebCore
658 
659 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
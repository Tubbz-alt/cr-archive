<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/generate_js_backend_commands.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014, 2016 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 
 28 import json
 29 import logging
 30 import string
 31 from string import Template
 32 
 33 try:
 34     from .generator import Generator, ucfirst
 35     from .generator_templates import GeneratorTemplates as Templates
 36     from .models import EnumType
 37 except ValueError:
 38     from generator import Generator, ucfirst
 39     from generator_templates import GeneratorTemplates as Templates
 40     from models import EnumType
 41 
 42 log = logging.getLogger(&#39;global&#39;)
 43 
 44 
 45 class JSBackendCommandsGenerator(Generator):
 46     def __init__(self, *args, **kwargs):
 47         Generator.__init__(self, *args, **kwargs)
 48 
 49     def output_filename(self):
 50         return &quot;InspectorBackendCommands.js&quot;
 51 
 52     def should_generate_domain(self, domain):
 53         type_declarations = self.type_declarations_for_domain(domain)
 54         domain_enum_types = [declaration for declaration in type_declarations if isinstance(declaration.type, EnumType)]
 55         return self.version_for_domain(domain) is not None or len(self.commands_for_domain(domain)) &gt; 0 or len(self.events_for_domain(domain)) &gt; 0 or len(domain_enum_types) &gt; 0
 56 
 57     def domains_to_generate(self):
 58         return list(filter(self.should_generate_domain, Generator.domains_to_generate(self)))
 59 
 60     def generate_output(self):
 61         sections = []
 62         sections.append(self.generate_license())
 63         sections.extend(list(map(self.generate_domain, self.domains_to_generate())))
 64         return &quot;\n\n&quot;.join(sections)
 65 
 66     def generate_domain(self, domain):
 67         lines = []
 68 
 69         comment_args = {
 70             &#39;domainName&#39;: domain.domain_name,
 71         }
 72         lines.append(&#39;// %(domainName)s&#39; % comment_args)
 73 
 74         version = self.version_for_domain(domain)
 75         type_declarations = self.type_declarations_for_domain(domain)
 76         commands = self.commands_for_domain(domain)
 77         events = self.events_for_domain(domain)
 78 
 79         domain_args = {
 80             &#39;domainName&#39;: domain.domain_name,
 81             &#39;targetTypes&#39;: json.dumps(domain.target_types),
 82         }
 83         lines.append(&#39;InspectorBackend.registerDomain(&quot;%(domainName)s&quot;, %(targetTypes)s);&#39; % domain_args)
 84 
 85         if isinstance(version, int):
 86             version_args = {
 87                 &#39;domainName&#39;: domain.domain_name,
 88                 &#39;version&#39;: version
 89             }
 90             lines.append(&#39;InspectorBackend.registerVersion(&quot;%(domainName)s&quot;, %(version)s);&#39; % version_args)
 91 
 92         for declaration in type_declarations:
 93             if declaration.type.is_enum():
 94                 enum_args = {
 95                     &#39;domainName&#39;: domain.domain_name,
 96                     &#39;enumName&#39;: declaration.type_name,
 97                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in declaration.type.enum_values()])
 98                 }
 99                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
100 
101             def is_anonymous_enum_member(type_member):
102                 return isinstance(type_member.type, EnumType) and type_member.type.is_anonymous
103 
104             for _member in filter(is_anonymous_enum_member, declaration.type_members):
105                 enum_args = {
106                     &#39;domainName&#39;: domain.domain_name,
107                     &#39;enumName&#39;: &#39;%s%s&#39; % (declaration.type_name, ucfirst(_member.member_name)),
108                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in _member.type.enum_values()])
109                 }
110                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
111 
112         def is_anonymous_enum_param(param):
113             return isinstance(param.type, EnumType) and param.type.is_anonymous
114 
115         for command in commands:
116             def generate_parameter_object(parameter):
117                 pairs = []
118                 pairs.append(&#39;&quot;name&quot;: &quot;%s&quot;&#39; % parameter.parameter_name)
119                 pairs.append(&#39;&quot;type&quot;: &quot;%s&quot;&#39; % Generator.js_name_for_parameter_type(parameter.type))
120                 if parameter.is_optional:
121                     pairs.append(&#39;&quot;optional&quot;: true&#39;)
122                 return &quot;{%s}&quot; % &quot;, &quot;.join(pairs)
123 
124             command_args = {
125                 &#39;domainName&#39;: domain.domain_name,
126                 &#39;commandName&#39;: command.command_name,
127                 &#39;targetTypes&#39;: json.dumps(command.target_types),
128                 &#39;callParams&#39;: &quot;, &quot;.join([generate_parameter_object(parameter) for parameter in command.call_parameters]),
129                 &#39;returnParams&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in command.return_parameters]),
130             }
131             lines.append(&#39;InspectorBackend.registerCommand(&quot;%(domainName)s.%(commandName)s&quot;, %(targetTypes)s, [%(callParams)s], [%(returnParams)s]);&#39; % command_args)
132 
133         for event in events:
134             for param in filter(is_anonymous_enum_param, event.event_parameters):
135                 enum_args = {
136                     &#39;domainName&#39;: domain.domain_name,
137                     &#39;enumName&#39;: &#39;%s%s&#39; % (ucfirst(event.event_name), ucfirst(param.parameter_name)),
138                     &#39;enumMap&#39;: &quot;, &quot;.join([&#39;%s: &quot;%s&quot;&#39; % (Generator.stylized_name_for_enum_value(enum_value), enum_value) for enum_value in param.type.enum_values()]),
139                 }
140                 lines.append(&#39;InspectorBackend.registerEnum(&quot;%(domainName)s.%(enumName)s&quot;, {%(enumMap)s});&#39; % enum_args)
141 
142             event_args = {
143                 &#39;domainName&#39;: domain.domain_name,
144                 &#39;eventName&#39;: event.event_name,
145                 &#39;targetTypes&#39;: json.dumps(event.target_types),
146                 &#39;params&#39;: &quot;, &quot;.join([&#39;&quot;%s&quot;&#39; % parameter.parameter_name for parameter in event.event_parameters]),
147             }
148             lines.append(&#39;InspectorBackend.registerEvent(&quot;%(domainName)s.%(eventName)s&quot;, %(targetTypes)s, [%(params)s]);&#39; % event_args)
149 
150         has_async_commands = any([command.is_async for command in commands])
151         if len(events) &gt; 0 or has_async_commands:
152             dispatcher_args = {
153                 &#39;domainName&#39;: domain.domain_name,
154             }
155             lines.append(&#39;InspectorBackend.register%(domainName)sDispatcher = InspectorBackend.registerDispatcher.bind(InspectorBackend, &quot;%(domainName)s&quot;);&#39; % dispatcher_args)
156 
157         activate_args = {
158             &#39;domainName&#39;: domain.domain_name,
159             &#39;debuggableTypes&#39;: json.dumps(domain.debuggable_types),
160         }
161         lines.append(&#39;InspectorBackend.activateDomain(&quot;%(domainName)s&quot;, %(debuggableTypes)s);&#39; % activate_args)
162 
163         return &quot;\n&quot;.join(lines)
    </pre>
  </body>
</html>
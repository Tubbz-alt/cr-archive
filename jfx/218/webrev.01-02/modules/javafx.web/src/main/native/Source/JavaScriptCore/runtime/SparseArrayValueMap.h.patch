diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2011-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -27,10 +27,11 @@
 
 #include "JSCast.h"
 #include "JSTypeInfo.h"
 #include "PropertyDescriptor.h"
 #include "PutDirectIndexMode.h"
+#include "VM.h"
 #include "WriteBarrier.h"
 #include <wtf/HashMap.h>
 
 namespace JSC {
 
@@ -46,11 +47,11 @@
         Base::setWithoutWriteBarrier(jsUndefined());
     }
 
     void get(JSObject*, PropertySlot&) const;
     void get(PropertyDescriptor&) const;
-    bool put(ExecState*, JSValue thisValue, SparseArrayValueMap*, JSValue, bool shouldThrow);
+    bool put(JSGlobalObject*, JSValue thisValue, SparseArrayValueMap*, JSValue, bool shouldThrow);
     JSValue getNonSparseMode() const;
     JSValue getConcurrently() const;
 
     unsigned attributes() const { return m_attributes; }
 
@@ -77,11 +78,11 @@
 };
 
 class SparseArrayValueMap final : public JSCell {
 public:
     typedef JSCell Base;
-    static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 
 private:
     typedef HashMap<uint64_t, SparseArrayEntry, WTF::IntHash<uint64_t>, WTF::UnsignedWithZeroKeyHashTraits<uint64_t>> Map;
 
     enum Flags {
@@ -101,13 +102,19 @@
     typedef Map::const_iterator const_iterator;
     typedef Map::AddResult AddResult;
 
     static SparseArrayValueMap* create(VM&);
 
-    static const bool needsDestruction = true;
+    static constexpr bool needsDestruction = true;
     static void destroy(JSCell*);
 
+    template<typename CellType, SubspaceAccess>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        return &vm.sparseArrayValueMapSpace;
+    }
+
     static Structure* createStructure(VM&, JSGlobalObject*, JSValue prototype);
 
     static void visitChildren(JSCell*, SlotVisitor&);
 
     bool sparseMode()
@@ -129,12 +136,12 @@
     {
         m_flags = static_cast<Flags>(m_flags | LengthIsReadOnly);
     }
 
     // These methods may mutate the contents of the map
-    bool putEntry(ExecState*, JSObject*, unsigned, JSValue, bool shouldThrow);
-    bool putDirect(ExecState*, JSObject*, unsigned, JSValue, unsigned attributes, PutDirectIndexMode);
+    bool putEntry(JSGlobalObject*, JSObject*, unsigned, JSValue, bool shouldThrow);
+    bool putDirect(JSGlobalObject*, JSObject*, unsigned, JSValue, unsigned attributes, PutDirectIndexMode);
     AddResult add(JSObject*, unsigned);
     iterator find(unsigned i) { return m_map.find(i); }
     // This should ASSERT the remove is valid (check the result of the find).
     void remove(iterator it);
     void remove(unsigned i);

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMWindowBase.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowCustom.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWindowCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,11 ---</span>
  #include &quot;HTMLCollection.h&quot;
  #include &quot;HTMLDocument.h&quot;
  #include &quot;HTMLFrameOwnerElement.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;JSDOMBindingSecurity.h&quot;
<span class="line-added">+ #include &quot;JSDOMConvertCallbacks.h&quot;</span>
  #include &quot;JSDOMConvertNullable.h&quot;
  #include &quot;JSDOMConvertNumbers.h&quot;
  #include &quot;JSDOMConvertStrings.h&quot;
  #include &quot;JSDatabase.h&quot;
  #include &quot;JSDatabaseCallback.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,12 ***</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(ExecState*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(ExecState*);</span>
  
  void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
  {
      if (Frame* frame = wrapped().frame())
          visitor.addOpaqueRoot(frame);
<span class="line-new-header">--- 63,12 ---</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionShowModalDialog(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject*, CallFrame*);</span>
  
  void JSDOMWindow::visitAdditionalChildren(SlotVisitor&amp; visitor)
  {
      if (Frame* frame = wrapped().frame())
          visitor.addOpaqueRoot(frame);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,24 ***</span>
      // to do this here.
      wrapped().visitJSEventListeners(visitor);
  }
  
  #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">! static EncodedJSValue jsDOMWindowWebKit(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, castedThis-&gt;wrapped()))</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(toJS(exec, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));</span>
  }
  #endif
  
  template &lt;DOMWindowType windowType&gt;
<span class="line-modified">! bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, ExecState&amp; state, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
  
      // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
<span class="line-new-header">--- 80,24 ---</span>
      // to do this here.
      wrapped().visitJSEventListeners(visitor);
  }
  
  #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">! static EncodedJSValue jsDOMWindowWebKit(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      JSDOMWindow* castedThis = toJSDOMWindow(vm, JSValue::decode(thisValue));
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped()))</span>
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     return JSValue::encode(toJS(lexicalGlobalObject, castedThis-&gt;globalObject(), castedThis-&gt;wrapped().webkitNamespace()));</span>
  }
  #endif
  
  template &lt;DOMWindowType windowType&gt;
<span class="line-modified">! bool jsDOMWindowGetOwnPropertySlotRestrictedAccess(JSDOMGlobalObject* thisObject, AbstractDOMWindow&amp; window, JSGlobalObject&amp; lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot, const String&amp; errorMessage)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto&amp; builtinNames = static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames();
  
      // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,41 ***</span>
              bool shouldExposeSetter = propertyName == builtinNames.locationPublicName();
              CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
              slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
              return true;
          }
<span class="line-removed">- </span>
<span class="line-removed">-         // For any other entries in the static property table, deny access. (Early return also prevents</span>
<span class="line-removed">-         // named getter from returning frames with matching names - this seems a little questionable, see</span>
<span class="line-removed">-         // FIXME comment on prototype search below.)</span>
<span class="line-removed">-         throwSecurityError(state, scope, errorMessage);</span>
<span class="line-removed">-         slot.setUndefined();</span>
<span class="line-removed">-         return false;</span>
      }
  
      // Check for child frames by name before built-in properties to match Mozilla. This does
      // not match IE, but some sites end up naming frames things that conflict with window
      // properties that are in Moz but not IE. Since we have some of these, we have to do it
      // the Moz way.
      // FIXME: Add support to named attributes on RemoteFrames.
      auto* frame = window.frame();
      if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
          if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomString(propertyName))) {
<span class="line-modified">!             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;state, scopedChild-&gt;document()-&gt;domWindow()));</span>
              return true;
          }
      }
  
      if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
          return true;
  
<span class="line-modified">!     throwSecurityError(state, scope, errorMessage);</span>
      slot.setUndefined();
      return false;
  }
<span class="line-modified">! template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
<span class="line-modified">! template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, ExecState&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
  
  // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
  bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
  {
      auto&amp; propertyNames =  vm.propertyNames;
<span class="line-new-header">--- 139,34 ---</span>
              bool shouldExposeSetter = propertyName == builtinNames.locationPublicName();
              CustomGetterSetter* customGetterSetter = CustomGetterSetter::create(vm, entry-&gt;propertyGetter(), shouldExposeSetter ? entry-&gt;propertyPutter() : nullptr);
              slot.setCustomGetterSetter(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::CustomAccessor | JSC::PropertyAttribute::DontEnum), customGetterSetter);
              return true;
          }
      }
  
      // Check for child frames by name before built-in properties to match Mozilla. This does
      // not match IE, but some sites end up naming frames things that conflict with window
      // properties that are in Moz but not IE. Since we have some of these, we have to do it
      // the Moz way.
      // FIXME: Add support to named attributes on RemoteFrames.
      auto* frame = window.frame();
      if (frame &amp;&amp; is&lt;Frame&gt;(*frame)) {
          if (auto* scopedChild = downcast&lt;Frame&gt;(*frame).tree().scopedChild(propertyNameToAtomString(propertyName))) {
<span class="line-modified">!             slot.setValue(thisObject, JSC::PropertyAttribute::ReadOnly | JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, toJS(&amp;lexicalGlobalObject, scopedChild-&gt;document()-&gt;domWindow()));</span>
              return true;
          }
      }
  
      if (handleCommonCrossOriginProperties(thisObject, vm, propertyName, slot))
          return true;
  
<span class="line-modified">!     throwSecurityError(lexicalGlobalObject, scope, errorMessage);</span>
      slot.setUndefined();
      return false;
  }
<span class="line-modified">! template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, JSGlobalObject&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
<span class="line-modified">! template bool jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Remote&gt;(JSDOMGlobalObject*, AbstractDOMWindow&amp;, JSGlobalObject&amp;, PropertyName, PropertySlot&amp;, const String&amp;);</span>
  
  // https://html.spec.whatwg.org/#crossorigingetownpropertyhelper-(-o,-p-)
  bool handleCommonCrossOriginProperties(JSObject* thisObject, VM&amp; vm, PropertyName propertyName, PropertySlot&amp; slot)
  {
      auto&amp; propertyNames =  vm.propertyNames;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,45 ***</span>
  
  // Property access sequence is:
  // (1) indexed properties,
  // (2) regular own properties,
  // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">! bool JSDOMWindow::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      // (1) First, indexed properties.
      // Hand off all indexed access to getOwnPropertySlotByIndex, which supports the indexed getter.
      if (Optional&lt;unsigned&gt; index = parseIndex(propertyName))
<span class="line-modified">!         return getOwnPropertySlotByIndex(object, state, index.value(), slot);</span>
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
  
      // Hand off all cross-domain access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage))</span>
<span class="line-modified">!         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, thisObject-&gt;wrapped(), *state, propertyName, slot, errorMessage);</span>
  
      // FIXME: this needs more explanation.
      // (Particularly, is it correct that this exists here but not in getOwnPropertySlotByIndex?)
      slot.setWatchpointSet(thisObject-&gt;m_windowCloseWatchpoints);
  
      // (2) Regular own properties.
      PropertySlot slotCopy = slot;
<span class="line-modified">!     if (Base::getOwnPropertySlot(thisObject, state, propertyName, slot)) {</span>
          auto* frame = thisObject-&gt;wrapped().frame();
  
          // Detect when we&#39;re getting the property &#39;showModalDialog&#39;, this is disabled, and has its original value.
<span class="line-modified">!         bool isShowModalDialogAndShouldHide = propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().showModalDialogPublicName()</span>
              &amp;&amp; (!frame || !DOMWindow::canShowModalDialog(*frame))
<span class="line-modified">!             &amp;&amp; slot.isValue() &amp;&amp; isHostFunction(slot.getValue(state, propertyName), jsDOMWindowInstanceFunctionShowModalDialog);</span>
          // Unless we&#39;re in the showModalDialog special case, we&#39;re done.
          if (!isShowModalDialogAndShouldHide)
              return true;
          slot = slotCopy;
      }
  
  #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">!     if (propertyName == static_cast&lt;JSVMClientData*&gt;(state-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {</span>
          slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
          return true;
      }
  #endif
  
<span class="line-new-header">--- 179,45 ---</span>
  
  // Property access sequence is:
  // (1) indexed properties,
  // (2) regular own properties,
  // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">! bool JSDOMWindow::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      // (1) First, indexed properties.
      // Hand off all indexed access to getOwnPropertySlotByIndex, which supports the indexed getter.
      if (Optional&lt;unsigned&gt; index = parseIndex(propertyName))
<span class="line-modified">!         return getOwnPropertySlotByIndex(object, lexicalGlobalObject, index.value(), slot);</span>
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
  
      // Hand off all cross-domain access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage))</span>
<span class="line-modified">!         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, thisObject-&gt;wrapped(), *lexicalGlobalObject, propertyName, slot, errorMessage);</span>
  
      // FIXME: this needs more explanation.
      // (Particularly, is it correct that this exists here but not in getOwnPropertySlotByIndex?)
      slot.setWatchpointSet(thisObject-&gt;m_windowCloseWatchpoints);
  
      // (2) Regular own properties.
      PropertySlot slotCopy = slot;
<span class="line-modified">!     if (Base::getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot)) {</span>
          auto* frame = thisObject-&gt;wrapped().frame();
  
          // Detect when we&#39;re getting the property &#39;showModalDialog&#39;, this is disabled, and has its original value.
<span class="line-modified">!         bool isShowModalDialogAndShouldHide = propertyName == static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().showModalDialogPublicName()</span>
              &amp;&amp; (!frame || !DOMWindow::canShowModalDialog(*frame))
<span class="line-modified">!             &amp;&amp; slot.isValue() &amp;&amp; isHostFunction(slot.getValue(lexicalGlobalObject, propertyName), jsDOMWindowInstanceFunctionShowModalDialog);</span>
          // Unless we&#39;re in the showModalDialog special case, we&#39;re done.
          if (!isShowModalDialogAndShouldHide)
              return true;
          slot = slotCopy;
      }
  
  #if ENABLE(USER_MESSAGE_HANDLERS)
<span class="line-modified">!     if (propertyName == static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject-&gt;vm().clientData)-&gt;builtinNames().webkitPublicName() &amp;&amp; thisObject-&gt;wrapped().shouldHaveWebKitNamespaceForWorld(thisObject-&gt;world())) {</span>
          slot.setCacheableCustom(thisObject, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::ReadOnly, jsDOMWindowWebKit);
          return true;
      }
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,13 ***</span>
  
  // Property access sequence is:
  // (1) indexed properties,
  // (2) regular own properties,
  // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">! bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
      auto&amp; window = thisObject-&gt;wrapped();
      auto* frame = window.frame();
  
      // Indexed getters take precendence over regular properties, so caching would be invalid.
<span class="line-new-header">--- 226,13 ---</span>
  
  // Property access sequence is:
  // (1) indexed properties,
  // (2) regular own properties,
  // (3) named properties (in fact, these shouldn&#39;t be on the window, should be on the NPO).
<span class="line-modified">! bool JSDOMWindow::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* lexicalGlobalObject, unsigned index, PropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
      auto&amp; window = thisObject-&gt;wrapped();
      auto* frame = window.frame();
  
      // Indexed getters take precendence over regular properties, so caching would be invalid.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,98 ***</span>
  
      String errorMessage;
      Optional&lt;bool&gt; cachedIsCrossOriginAccess;
      auto isCrossOriginAccess = [&amp;] {
          if (!cachedIsCrossOriginAccess)
<span class="line-modified">!             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*state, window, errorMessage);</span>
          return *cachedIsCrossOriginAccess;
      };
  
      // (1) First, indexed properties.
      // These are also allowed cross-origin, so come before the access check.
      if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
<span class="line-modified">!         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(state, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));</span>
          return true;
      }
  
      // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
      if (isCrossOriginAccess())
<span class="line-modified">!         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *state, Identifier::from(vm, index), slot, errorMessage);</span>
  
      // (2) Regular own properties.
<span class="line-modified">!     return Base::getOwnPropertySlotByIndex(thisObject, state, index, slot);</span>
  }
  
<span class="line-modified">! void JSDOMWindow::doPutPropertySecurityCheck(JSObject* cell, ExecState* state, PropertyName propertyName, PutPropertySlot&amp;)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      if (!thisObject-&gt;wrapped().frame())
          return;
  
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {</span>
          // We only allow setting &quot;location&quot; attribute cross-origin.
          if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName())
              return;
<span class="line-modified">!         throwSecurityError(*state, scope, errorMessage);</span>
          return;
      }
  }
  
<span class="line-modified">! bool JSDOMWindow::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = state-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      if (!thisObject-&gt;wrapped().frame())
          return false;
  
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*state, thisObject-&gt;wrapped(), errorMessage)) {</span>
          // We only allow setting &quot;location&quot; attribute cross-origin.
          if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
              bool putResult = false;
<span class="line-modified">!             if (lookupPut(state, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))</span>
                  return putResult;
              return false;
          }
<span class="line-modified">!         throwSecurityError(*state, scope, errorMessage);</span>
          return false;
      }
  
<span class="line-modified">!     return Base::put(thisObject, state, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::putByIndex(JSCell* cell, ExecState* exec, unsigned index, JSValue value, bool shouldThrow)</span>
  {
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
<span class="line-modified">!     if (!thisObject-&gt;wrapped().frame() || !BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped()))</span>
          return false;
  
<span class="line-modified">!     return Base::putByIndex(thisObject, exec, index, value, shouldThrow);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      // Only allow deleting properties by frames in the same origin.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
<span class="line-modified">!     return Base::deleteProperty(thisObject, exec, propertyName);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      // Only allow deleting properties by frames in the same origin.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
<span class="line-modified">!     return Base::deletePropertyByIndex(thisObject, exec, propertyName);</span>
  }
  
  void JSDOMWindow::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
<span class="line-new-header">--- 240,98 ---</span>
  
      String errorMessage;
      Optional&lt;bool&gt; cachedIsCrossOriginAccess;
      auto isCrossOriginAccess = [&amp;] {
          if (!cachedIsCrossOriginAccess)
<span class="line-modified">!             cachedIsCrossOriginAccess = !BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, window, errorMessage);</span>
          return *cachedIsCrossOriginAccess;
      };
  
      // (1) First, indexed properties.
      // These are also allowed cross-origin, so come before the access check.
      if (frame &amp;&amp; index &lt; frame-&gt;tree().scopedChildCount()) {
<span class="line-modified">!         slot.setValue(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::ReadOnly), toJS(lexicalGlobalObject, frame-&gt;tree().scopedChild(index)-&gt;document()-&gt;domWindow()));</span>
          return true;
      }
  
      // Hand off all cross-domain/frameless access to jsDOMWindowGetOwnPropertySlotRestrictedAccess.
      if (isCrossOriginAccess())
<span class="line-modified">!         return jsDOMWindowGetOwnPropertySlotRestrictedAccess&lt;DOMWindowType::Local&gt;(thisObject, window, *lexicalGlobalObject, Identifier::from(vm, index), slot, errorMessage);</span>
  
      // (2) Regular own properties.
<span class="line-modified">!     return Base::getOwnPropertySlotByIndex(thisObject, lexicalGlobalObject, index, slot);</span>
  }
  
<span class="line-modified">! void JSDOMWindow::doPutPropertySecurityCheck(JSObject* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PutPropertySlot&amp;)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      if (!thisObject-&gt;wrapped().frame())
          return;
  
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage)) {</span>
          // We only allow setting &quot;location&quot; attribute cross-origin.
          if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName())
              return;
<span class="line-modified">!         throwSecurityError(*lexicalGlobalObject, scope, errorMessage);</span>
          return;
      }
  }
  
<span class="line-modified">! bool JSDOMWindow::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      if (!thisObject-&gt;wrapped().frame())
          return false;
  
      String errorMessage;
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(*lexicalGlobalObject, thisObject-&gt;wrapped(), errorMessage)) {</span>
          // We only allow setting &quot;location&quot; attribute cross-origin.
          if (propertyName == static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().locationPublicName()) {
              bool putResult = false;
<span class="line-modified">!             if (lookupPut(lexicalGlobalObject, propertyName, thisObject, value, *s_info.staticPropHashTable, slot, putResult))</span>
                  return putResult;
              return false;
          }
<span class="line-modified">!         throwSecurityError(*lexicalGlobalObject, scope, errorMessage);</span>
          return false;
      }
  
<span class="line-modified">!     return Base::put(thisObject, lexicalGlobalObject, propertyName, value, slot);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::putByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned index, JSValue value, bool shouldThrow)</span>
  {
      auto* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
<span class="line-modified">!     if (!thisObject-&gt;wrapped().frame() || !BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped()))</span>
          return false;
  
<span class="line-modified">!     return Base::putByIndex(thisObject, lexicalGlobalObject, index, value, shouldThrow);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::deleteProperty(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      // Only allow deleting properties by frames in the same origin.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
<span class="line-modified">!     return Base::deleteProperty(thisObject, lexicalGlobalObject, propertyName);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::deletePropertyByIndex(JSCell* cell, JSGlobalObject* lexicalGlobalObject, unsigned propertyName)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
      // Only allow deleting properties by frames in the same origin.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
<span class="line-modified">!     return Base::deletePropertyByIndex(thisObject, lexicalGlobalObject, propertyName);</span>
  }
  
  void JSDOMWindow::analyzeHeap(JSCell* cell, HeapAnalyzer&amp; analyzer)
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(cell);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,182 ***</span>
      }
  }
  
  // https://html.spec.whatwg.org/#crossoriginownpropertykeys-(-o-)
  template &lt;CrossOriginObject objectType&gt;
<span class="line-modified">! void addCrossOriginOwnPropertyNames(JSC::ExecState&amp; state, JSC::PropertyNameArray&amp; propertyNames)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
      addCrossOriginPropertyNames&lt;objectType&gt;(vm, propertyNames);
  
      static const Identifier* const properties[] = {
          &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
      };
  
      for (auto* property : properties)
          propertyNames.add(*property);
  
  }
<span class="line-modified">! template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);</span>
<span class="line-modified">! template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::ExecState&amp;, JSC::PropertyNameArray&amp;);</span>
  
<span class="line-modified">! static void addScopedChildrenIndexes(ExecState&amp; state, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)</span>
  {
      auto* document = window.document();
      if (!document)
          return;
  
      auto* frame = document-&gt;frame();
      if (!frame)
          return;
  
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
      for (unsigned i = 0; i &lt; scopedChildCount; ++i)
          propertyNames.add(Identifier::from(vm, i));
  }
  
  // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
<span class="line-modified">! void JSDOMWindow::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
  
<span class="line-modified">!     addScopedChildrenIndexes(*exec, thisObject-&gt;wrapped(), propertyNames);</span>
  
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {</span>
          if (mode.includeDontEnumProperties())
<span class="line-modified">!             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*exec, propertyNames);</span>
          return;
      }
<span class="line-modified">!     Base::getOwnPropertyNames(thisObject, exec, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::ExecState* exec, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = exec-&gt;vm();</span>
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
      // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
  
      // Don&#39;t allow shadowing location using accessor properties.
      if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(vm, &quot;location&quot;))
          return false;
  
<span class="line-modified">!     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
  }
  
<span class="line-modified">! JSValue JSDOMWindow::getPrototype(JSObject* object, ExecState* exec)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
          return jsNull();
  
<span class="line-modified">!     return Base::getPrototype(object, exec);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::preventExtensions(JSObject*, ExecState* exec)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
  
<span class="line-modified">!     throwTypeError(exec, scope, &quot;Cannot prevent extensions on this object&quot;_s);</span>
      return false;
  }
  
<span class="line-modified">! String JSDOMWindow::toStringName(const JSObject* object, ExecState* exec)</span>
  {
      auto* thisObject = jsCast&lt;const JSDOMWindow*&gt;(object);
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(exec, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
          return &quot;Object&quot;_s;
      return &quot;Window&quot;_s;
  }
  
  // Custom Attributes
  
<span class="line-modified">! JSValue JSDOMWindow::event(ExecState&amp; state) const</span>
  {
      Event* event = currentEvent();
      if (!event)
          return jsUndefined();
<span class="line-modified">!     return toJS(&amp;state, const_cast&lt;JSDOMWindow*&gt;(this), event);</span>
  }
  
  // Custom functions
  
  class DialogHandler {
  public:
<span class="line-modified">!     explicit DialogHandler(ExecState&amp; exec)</span>
<span class="line-modified">!         : m_exec(exec)</span>
      {
      }
  
      void dialogCreated(DOMWindow&amp;);
      JSValue returnValue() const;
  
  private:
<span class="line-modified">!     ExecState&amp; m_exec;</span>
      RefPtr&lt;Frame&gt; m_frame;
  };
  
  inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
  {
<span class="line-modified">!     VM&amp; vm = m_exec.vm();</span>
      m_frame = dialog.frame();
  
      // FIXME: This looks like a leak between the normal world and an isolated
      //        world if dialogArguments comes from an isolated world.
      JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
<span class="line-modified">!     if (JSValue dialogArguments = m_exec.argument(1))</span>
          globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;dialogArguments&quot;), dialogArguments);
  }
  
  inline JSValue DialogHandler::returnValue() const
  {
<span class="line-modified">!     VM&amp; vm = m_exec.vm();</span>
      JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
      if (!globalObject)
          return jsUndefined();
      Identifier identifier = Identifier::fromString(vm, &quot;returnValue&quot;);
      PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_exec, identifier, slot))</span>
          return jsUndefined();
<span class="line-modified">!     return slot.getValue(&amp;m_exec, identifier);</span>
  }
  
<span class="line-modified">! JSValue JSDOMWindow::showModalDialog(ExecState&amp; state)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(state.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
  
<span class="line-modified">!     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(0));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(state, state.argument(2));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     DialogHandler handler(state);</span>
  
<span class="line-modified">!     wrapped().showModalDialog(urlString, dialogFeaturesString, activeDOMWindow(state), firstDOMWindow(state), [&amp;handler](DOMWindow&amp; dialog) {</span>
          handler.dialogCreated(dialog);
      });
  
      return handler.returnValue();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::queueMicrotask(ExecState&amp; state)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(state.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;state, scope, createNotEnoughArgumentsError(&amp;state));</span>
  
<span class="line-modified">!     JSValue functionValue = state.uncheckedArgument(0);</span>
      if (UNLIKELY(!functionValue.isFunction(vm)))
<span class="line-modified">!         return JSValue::decode(throwArgumentMustBeFunctionError(state, scope, 0, &quot;callback&quot;, &quot;Window&quot;, &quot;queueMicrotask&quot;));</span>
  
      scope.release();
      Base::queueMicrotask(JSC::createJSMicrotask(vm, functionValue));
      return jsUndefined();
  }
<span class="line-new-header">--- 369,184 ---</span>
      }
  }
  
  // https://html.spec.whatwg.org/#crossoriginownpropertykeys-(-o-)
  template &lt;CrossOriginObject objectType&gt;
<span class="line-modified">! void addCrossOriginOwnPropertyNames(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::PropertyNameArray&amp; propertyNames)</span>
  {
<span class="line-modified">!     auto&amp; vm = lexicalGlobalObject.vm();</span>
      addCrossOriginPropertyNames&lt;objectType&gt;(vm, propertyNames);
  
      static const Identifier* const properties[] = {
          &amp;vm.propertyNames-&gt;builtinNames().thenPublicName(), &amp;vm.propertyNames-&gt;toStringTagSymbol, &amp;vm.propertyNames-&gt;hasInstanceSymbol, &amp;vm.propertyNames-&gt;isConcatSpreadableSymbol
      };
  
      for (auto* property : properties)
          propertyNames.add(*property);
  
  }
<span class="line-modified">! template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(JSC::JSGlobalObject&amp;, JSC::PropertyNameArray&amp;);</span>
<span class="line-modified">! template void addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Location&gt;(JSC::JSGlobalObject&amp;, JSC::PropertyNameArray&amp;);</span>
  
<span class="line-modified">! static void addScopedChildrenIndexes(JSGlobalObject&amp; lexicalGlobalObject, DOMWindow&amp; window, PropertyNameArray&amp; propertyNames)</span>
  {
      auto* document = window.document();
      if (!document)
          return;
  
      auto* frame = document-&gt;frame();
      if (!frame)
          return;
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      unsigned scopedChildCount = frame-&gt;tree().scopedChildCount();
      for (unsigned i = 0; i &lt; scopedChildCount; ++i)
          propertyNames.add(Identifier::from(vm, i));
  }
  
  // https://html.spec.whatwg.org/#windowproxy-ownpropertykeys
<span class="line-modified">! void JSDOMWindow::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
  
<span class="line-modified">!     addScopedChildrenIndexes(*lexicalGlobalObject, thisObject-&gt;wrapped(), propertyNames);</span>
  
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError)) {</span>
          if (mode.includeDontEnumProperties())
<span class="line-modified">!             addCrossOriginOwnPropertyNames&lt;CrossOriginObject::Window&gt;(*lexicalGlobalObject, propertyNames);</span>
          return;
      }
<span class="line-modified">!     Base::getOwnPropertyNames(thisObject, lexicalGlobalObject, propertyNames, mode);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::defineOwnProperty(JSC::JSObject* object, JSC::JSGlobalObject* lexicalGlobalObject, JSC::PropertyName propertyName, const JSC::PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
<span class="line-modified">!     JSC::VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
      // Only allow defining properties in this way by frames in the same origin, as it allows setters to be introduced.
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), ThrowSecurityError))</span>
          return false;
  
      // Don&#39;t allow shadowing location using accessor properties.
      if (descriptor.isAccessorDescriptor() &amp;&amp; propertyName == Identifier::fromString(vm, &quot;location&quot;))
          return false;
  
<span class="line-modified">!     return Base::defineOwnProperty(thisObject, lexicalGlobalObject, propertyName, descriptor, shouldThrow);</span>
  }
  
<span class="line-modified">! JSValue JSDOMWindow::getPrototype(JSObject* object, JSGlobalObject* lexicalGlobalObject)</span>
  {
      JSDOMWindow* thisObject = jsCast&lt;JSDOMWindow*&gt;(object);
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
          return jsNull();
  
<span class="line-modified">!     return Base::getPrototype(object, lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! bool JSDOMWindow::preventExtensions(JSObject*, JSGlobalObject* lexicalGlobalObject)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(lexicalGlobalObject-&gt;vm());</span>
  
<span class="line-modified">!     throwTypeError(lexicalGlobalObject, scope, &quot;Cannot prevent extensions on this object&quot;_s);</span>
      return false;
  }
  
<span class="line-modified">! String JSDOMWindow::toStringName(const JSObject* object, JSGlobalObject* lexicalGlobalObject)</span>
  {
      auto* thisObject = jsCast&lt;const JSDOMWindow*&gt;(object);
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, thisObject-&gt;wrapped(), DoNotReportSecurityError))</span>
          return &quot;Object&quot;_s;
      return &quot;Window&quot;_s;
  }
  
  // Custom Attributes
  
<span class="line-modified">! JSValue JSDOMWindow::event(JSGlobalObject&amp; lexicalGlobalObject) const</span>
  {
      Event* event = currentEvent();
      if (!event)
          return jsUndefined();
<span class="line-modified">!     return toJS(&amp;lexicalGlobalObject, const_cast&lt;JSDOMWindow*&gt;(this), event);</span>
  }
  
  // Custom functions
  
  class DialogHandler {
  public:
<span class="line-modified">!     explicit DialogHandler(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
<span class="line-modified">!         : m_globalObject(lexicalGlobalObject)</span>
<span class="line-added">+         , m_callFrame(callFrame)</span>
      {
      }
  
      void dialogCreated(DOMWindow&amp;);
      JSValue returnValue() const;
  
  private:
<span class="line-modified">!     JSGlobalObject&amp; m_globalObject;</span>
<span class="line-added">+     CallFrame&amp; m_callFrame;</span>
      RefPtr&lt;Frame&gt; m_frame;
  };
  
  inline void DialogHandler::dialogCreated(DOMWindow&amp; dialog)
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject.vm();</span>
      m_frame = dialog.frame();
  
      // FIXME: This looks like a leak between the normal world and an isolated
      //        world if dialogArguments comes from an isolated world.
      JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
<span class="line-modified">!     if (JSValue dialogArguments = m_callFrame.argument(1))</span>
          globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;dialogArguments&quot;), dialogArguments);
  }
  
  inline JSValue DialogHandler::returnValue() const
  {
<span class="line-modified">!     VM&amp; vm = m_globalObject.vm();</span>
      JSDOMWindow* globalObject = toJSDOMWindow(m_frame.get(), normalWorld(vm));
      if (!globalObject)
          return jsUndefined();
      Identifier identifier = Identifier::fromString(vm, &quot;returnValue&quot;);
      PropertySlot slot(globalObject, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     if (!JSGlobalObject::getOwnPropertySlot(globalObject, &amp;m_globalObject, identifier, slot))</span>
          return jsUndefined();
<span class="line-modified">!     return slot.getValue(&amp;m_globalObject, identifier);</span>
  }
  
<span class="line-modified">! JSValue JSDOMWindow::showModalDialog(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(callFrame.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
  
<span class="line-modified">!     String urlString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, callFrame.argument(0));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
<span class="line-modified">!     String dialogFeaturesString = convert&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(lexicalGlobalObject, callFrame.argument(2));</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
<span class="line-modified">!     DialogHandler handler(lexicalGlobalObject, callFrame);</span>
  
<span class="line-modified">!     wrapped().showModalDialog(urlString, dialogFeaturesString, activeDOMWindow(lexicalGlobalObject), firstDOMWindow(lexicalGlobalObject), [&amp;handler](DOMWindow&amp; dialog) {</span>
          handler.dialogCreated(dialog);
      });
  
      return handler.returnValue();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::queueMicrotask(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (UNLIKELY(callFrame.argumentCount() &lt; 1))</span>
<span class="line-modified">!         return throwException(&amp;lexicalGlobalObject, scope, createNotEnoughArgumentsError(&amp;lexicalGlobalObject));</span>
  
<span class="line-modified">!     JSValue functionValue = callFrame.uncheckedArgument(0);</span>
      if (UNLIKELY(!functionValue.isFunction(vm)))
<span class="line-modified">!         return JSValue::decode(throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 0, &quot;callback&quot;, &quot;Window&quot;, &quot;queueMicrotask&quot;));</span>
  
      scope.release();
      Base::queueMicrotask(JSC::createJSMicrotask(vm, functionValue));
      return jsUndefined();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 567,95 ***</span>
              return &amp;jsDOMWindow-&gt;wrapped();
      }
      return nullptr;
  }
  
<span class="line-modified">! void JSDOMWindow::setOpener(JSC::ExecState&amp; state, JSC::JSValue value)</span>
  {
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))</span>
          return;
  
      if (value.isNull()) {
          wrapped().disownOpener();
          return;
      }
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;opener&quot;), value);
  }
  
<span class="line-modified">! JSValue JSDOMWindow::self(JSC::ExecState&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::window(JSC::ExecState&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::frames(JSC::ExecState&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! static inline JSC::EncodedJSValue jsDOMWindowInstanceFunctionOpenDatabaseBody(JSC::ExecState* state, typename IDLOperation&lt;JSDOMWindow&gt;::ClassParameter castedThis, JSC::ThrowScope&amp; throwScope)</span>
  {
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(state, castedThis-&gt;wrapped(), ThrowSecurityError))</span>
          return JSValue::encode(jsUndefined());
      auto&amp; impl = castedThis-&gt;wrapped();
<span class="line-modified">!     if (UNLIKELY(state-&gt;argumentCount() &lt; 4))</span>
<span class="line-modified">!         return throwVMError(state, throwScope, createNotEnoughArgumentsError(state));</span>
<span class="line-modified">!     auto name = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(0));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto version = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(1));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto displayName = convert&lt;IDLDOMString&gt;(*state, state-&gt;uncheckedArgument(2));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto estimatedSize = convert&lt;IDLUnsignedLong&gt;(*state, state-&gt;uncheckedArgument(3));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
  
      if (!RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled()) {
          if (name != &quot;null&quot; || version != &quot;null&quot; || displayName != &quot;null&quot; || estimatedSize)
<span class="line-modified">!             propagateException(*state, throwScope, Exception(UnknownError, &quot;Web SQL is deprecated&quot;_s));</span>
<span class="line-modified">!         return JSValue::encode(constructEmptyObject(state, castedThis-&gt;globalObject()-&gt;objectPrototype()));</span>
      }
  
<span class="line-modified">!     auto creationCallback = convert&lt;IDLNullable&lt;IDLCallbackFunction&lt;JSDatabaseCallback&gt;&gt;&gt;(*state, state-&gt;argument(4), *castedThis-&gt;globalObject(), [](JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope) {</span>
<span class="line-modified">!         throwArgumentMustBeFunctionError(state, scope, 4, &quot;creationCallback&quot;, &quot;Window&quot;, &quot;openDatabase&quot;);</span>
      });
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     return JSValue::encode(toJS&lt;IDLNullable&lt;IDLInterface&lt;Database&gt;&gt;&gt;(*state, *castedThis-&gt;globalObject(), throwScope, WebCore::DOMWindowWebDatabase::openDatabase(impl, WTFMove(name), WTFMove(version), WTFMove(displayName), WTFMove(estimatedSize), WTFMove(creationCallback))));</span>
  }
  
<span class="line-modified">! template&lt;&gt; inline JSDOMWindow* IDLOperation&lt;JSDOMWindow&gt;::cast(ExecState&amp; state)</span>
  {
<span class="line-modified">!     return toJSDOMWindow(state.vm(), state.thisValue().toThis(&amp;state, NotStrictMode));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return IDLOperation&lt;JSDOMWindow&gt;::call&lt;jsDOMWindowInstanceFunctionOpenDatabaseBody&gt;(*callFrame, &quot;openDatabase&quot;);</span>
  }
  
<span class="line-modified">! // // FIXME-java: Currently WebSQL feature is not implemented completely in JavaFX port.</span>
<span class="line-modified">! // #if !PLATFORM(JAVA)</span>
<span class="line-modified">! // JSValue JSDOMWindow::openDatabase(JSC::ExecState&amp; state) const</span>
<span class="line-modified">! // {</span>
<span class="line-modified">! //     VM&amp; vm = state.vm();</span>
<span class="line-modified">! //     StringImpl* name = PropertyName(static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().openDatabasePublicName()).publicName();</span>
<span class="line-modified">! //     if (RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled())</span>
<span class="line-modified">! //         return JSFunction::create(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
  
<span class="line-modified">! //     return JSFunction::createFunctionThatMasqueradesAsUndefined(vm, state.lexicalGlobalObject(), 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-modified">! // }</span>
  
<span class="line-modified">! // void JSDOMWindow::setOpenDatabase(JSC::ExecState&amp; state, JSC::JSValue value)</span>
<span class="line-modified">! // {</span>
<span class="line-modified">! //     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;state, wrapped(), ThrowSecurityError))</span>
<span class="line-modified">! //         return;</span>
  
<span class="line-modified">! //     VM&amp; vm = state.vm();</span>
<span class="line-modified">! //     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;openDatabase&quot;), value);</span>
<span class="line-modified">! // }</span>
<span class="line-modified">! // #endif</span>
  
  } // namespace WebCore
<span class="line-new-header">--- 563,95 ---</span>
              return &amp;jsDOMWindow-&gt;wrapped();
      }
      return nullptr;
  }
  
<span class="line-modified">! void JSDOMWindow::setOpener(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
  {
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, wrapped(), ThrowSecurityError))</span>
          return;
  
      if (value.isNull()) {
          wrapped().disownOpener();
          return;
      }
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;opener&quot;), value);
  }
  
<span class="line-modified">! JSValue JSDOMWindow::self(JSC::JSGlobalObject&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::window(JSC::JSGlobalObject&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! JSValue JSDOMWindow::frames(JSC::JSGlobalObject&amp;) const</span>
  {
      return globalThis();
  }
  
<span class="line-modified">! static inline JSC::EncodedJSValue jsDOMWindowInstanceFunctionOpenDatabaseBody(JSC::JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame, typename IDLOperation&lt;JSDOMWindow&gt;::ClassParameter castedThis, JSC::ThrowScope&amp; throwScope)</span>
  {
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, castedThis-&gt;wrapped(), ThrowSecurityError))</span>
          return JSValue::encode(jsUndefined());
      auto&amp; impl = castedThis-&gt;wrapped();
<span class="line-modified">!     if (UNLIKELY(callFrame-&gt;argumentCount() &lt; 4))</span>
<span class="line-modified">!         return throwVMError(lexicalGlobalObject, throwScope, createNotEnoughArgumentsError(lexicalGlobalObject));</span>
<span class="line-modified">!     auto name = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(0));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto version = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(1));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto displayName = convert&lt;IDLDOMString&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(2));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     auto estimatedSize = convert&lt;IDLUnsignedLong&gt;(*lexicalGlobalObject, callFrame-&gt;uncheckedArgument(3));</span>
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
  
      if (!RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled()) {
          if (name != &quot;null&quot; || version != &quot;null&quot; || displayName != &quot;null&quot; || estimatedSize)
<span class="line-modified">!             propagateException(*lexicalGlobalObject, throwScope, Exception(UnknownError, &quot;Web SQL is deprecated&quot;_s));</span>
<span class="line-modified">!         return JSValue::encode(constructEmptyObject(lexicalGlobalObject, castedThis-&gt;globalObject()-&gt;objectPrototype()));</span>
      }
  
<span class="line-modified">!     auto creationCallback = convert&lt;IDLNullable&lt;IDLCallbackFunction&lt;JSDatabaseCallback&gt;&gt;&gt;(*lexicalGlobalObject, callFrame-&gt;argument(4), *castedThis-&gt;globalObject(), [](JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::ThrowScope&amp; scope) {</span>
<span class="line-modified">!         throwArgumentMustBeFunctionError(lexicalGlobalObject, scope, 4, &quot;creationCallback&quot;, &quot;Window&quot;, &quot;openDatabase&quot;);</span>
      });
      RETURN_IF_EXCEPTION(throwScope, encodedJSValue());
<span class="line-modified">!     return JSValue::encode(toJS&lt;IDLNullable&lt;IDLInterface&lt;Database&gt;&gt;&gt;(*lexicalGlobalObject, *castedThis-&gt;globalObject(), throwScope, WebCore::DOMWindowWebDatabase::openDatabase(impl, WTFMove(name), WTFMove(version), WTFMove(displayName), WTFMove(estimatedSize), WTFMove(creationCallback))));</span>
  }
  
<span class="line-modified">! template&lt;&gt; inline JSDOMWindow* IDLOperation&lt;JSDOMWindow&gt;::cast(JSGlobalObject&amp; lexicalGlobalObject, CallFrame&amp; callFrame)</span>
  {
<span class="line-modified">!     return toJSDOMWindow(lexicalGlobalObject.vm(), callFrame.thisValue().toThis(&amp;lexicalGlobalObject, NotStrictMode));</span>
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL jsDOMWindowInstanceFunctionOpenDatabase(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     return IDLOperation&lt;JSDOMWindow&gt;::call&lt;jsDOMWindowInstanceFunctionOpenDatabaseBody&gt;(*globalObject, *callFrame, &quot;openDatabase&quot;);</span>
  }
  
<span class="line-modified">! // FIXME-java: Currently WebSQL feature is not implemented completely in JavaFX port.</span>
<span class="line-modified">! #if !PLATFORM(JAVA)</span>
<span class="line-modified">! JSValue JSDOMWindow::openDatabase(JSC::JSGlobalObject&amp; lexicalGlobalObject) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     StringImpl* name = PropertyName(static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;builtinNames().openDatabasePublicName()).publicName();</span>
<span class="line-modified">!     if (RuntimeEnabledFeatures::sharedFeatures().webSQLEnabled())</span>
<span class="line-modified">!         return JSFunction::create(vm, &amp;lexicalGlobalObject, 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
  
<span class="line-modified">!     return JSFunction::createFunctionThatMasqueradesAsUndefined(vm, &amp;lexicalGlobalObject, 4, name, jsDOMWindowInstanceFunctionOpenDatabase, NoIntrinsic);</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void JSDOMWindow::setOpenDatabase(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     if (!BindingSecurity::shouldAllowAccessToDOMWindow(&amp;lexicalGlobalObject, wrapped(), ThrowSecurityError))</span>
<span class="line-modified">!         return;</span>
  
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     replaceStaticPropertySlot(vm, this, Identifier::fromString(vm, &quot;openDatabase&quot;), value);</span>
<span class="line-modified">! }</span>
<span class="line-modified">! #endif</span>
  
  } // namespace WebCore
</pre>
<center><a href="JSDOMWindowBase.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMWindowCustom.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp
@@ -26,22 +26,23 @@
 
 #include "config.h"
 #include "BytecodeGeneratorification.h"
 
 #include "BytecodeDumper.h"
+#include "BytecodeGeneratorBaseInlines.h"
 #include "BytecodeLivenessAnalysisInlines.h"
 #include "BytecodeRewriter.h"
 #include "BytecodeStructs.h"
 #include "BytecodeUseDef.h"
 #include "IdentifierInlines.h"
 #include "InterpreterInlines.h"
 #include "JSCInlines.h"
 #include "JSCJSValueInlines.h"
-#include "JSGeneratorFunction.h"
+#include "JSGenerator.h"
 #include "Label.h"
 #include "StrongInlines.h"
-#include "UnlinkedCodeBlock.h"
+#include "UnlinkedCodeBlockGenerator.h"
 #include "UnlinkedMetadataTableInlines.h"
 #include <wtf/Optional.h>
 
 namespace JSC {
 
@@ -61,53 +62,50 @@
         VirtualRegister m_scope;
         VirtualRegister m_symbolTable;
         VirtualRegister m_initialValue;
     };
 
-    BytecodeGeneratorification(BytecodeGenerator& bytecodeGenerator, UnlinkedCodeBlock* codeBlock, InstructionStreamWriter& instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)
+    BytecodeGeneratorification(BytecodeGenerator& bytecodeGenerator, UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter& instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)
         : m_bytecodeGenerator(bytecodeGenerator)
         , m_codeBlock(codeBlock)
         , m_instructions(instructions)
         , m_graph(m_codeBlock, m_instructions)
         , m_generatorFrameSymbolTable(codeBlock->vm(), generatorFrameSymbolTable)
         , m_generatorFrameSymbolTableIndex(generatorFrameSymbolTableIndex)
     {
-        for (BytecodeBasicBlock* block : m_graph) {
-            for (const auto offset : block->offsets()) {
-                const auto instruction = m_instructions.at(offset);
-                switch (instruction->opcodeID()) {
-                case op_enter: {
-                    m_enterPoint = instruction.offset();
-                    break;
-                }
-
-                case op_yield: {
-                    auto bytecode = instruction->as<OpYield>();
-                    unsigned liveCalleeLocalsIndex = bytecode.m_yieldPoint;
-                    if (liveCalleeLocalsIndex >= m_yields.size())
-                        m_yields.resize(liveCalleeLocalsIndex + 1);
-                    YieldData& data = m_yields[liveCalleeLocalsIndex];
-                    data.point = instruction.offset();
-                    data.argument = bytecode.m_argument;
-                    break;
-                }
-
-                case op_create_generator_frame_environment: {
-                    auto bytecode = instruction->as<OpCreateGeneratorFrameEnvironment>();
-                    GeneratorFrameData data;
-                    data.m_point = instruction.offset();
-                    data.m_dst = bytecode.m_dst;
-                    data.m_scope = bytecode.m_scope;
-                    data.m_symbolTable = bytecode.m_symbolTable;
-                    data.m_initialValue = bytecode.m_initialValue;
-                    m_generatorFrameData = WTFMove(data);
-                    break;
-                }
-
-                default:
-                    break;
-                }
+        for (const auto& instruction : m_instructions) {
+            switch (instruction->opcodeID()) {
+            case op_enter: {
+                m_enterPoint = instruction.offset();
+                break;
+            }
+
+            case op_yield: {
+                auto bytecode = instruction->as<OpYield>();
+                unsigned liveCalleeLocalsIndex = bytecode.m_yieldPoint;
+                if (liveCalleeLocalsIndex >= m_yields.size())
+                    m_yields.resize(liveCalleeLocalsIndex + 1);
+                YieldData& data = m_yields[liveCalleeLocalsIndex];
+                data.point = instruction.offset();
+                data.argument = bytecode.m_argument;
+                break;
+            }
+
+            case op_create_generator_frame_environment: {
+                auto bytecode = instruction->as<OpCreateGeneratorFrameEnvironment>();
+                GeneratorFrameData data;
+                data.m_point = instruction.offset();
+                data.m_dst = bytecode.m_dst;
+                data.m_scope = bytecode.m_scope;
+                data.m_symbolTable = bytecode.m_symbolTable;
+                data.m_initialValue = bytecode.m_initialValue;
+                m_generatorFrameData = WTFMove(data);
+                break;
+            }
+
+            default:
+                break;
             }
         }
     }
 
     struct Storage {
@@ -174,11 +172,11 @@
     }
 
     BytecodeGenerator& m_bytecodeGenerator;
     InstructionStream::Offset m_enterPoint;
     Optional<GeneratorFrameData> m_generatorFrameData;
-    UnlinkedCodeBlock* m_codeBlock;
+    UnlinkedCodeBlockGenerator* m_codeBlock;
     InstructionStreamWriter& m_instructions;
     BytecodeGraph m_graph;
     Vector<Optional<Storage>> m_storages;
     Yields m_yields;
     Strong<SymbolTable> m_generatorFrameSymbolTable;
@@ -190,19 +188,19 @@
     GeneratorLivenessAnalysis(BytecodeGeneratorification& generatorification)
         : m_generatorification(generatorification)
     {
     }
 
-    void run(UnlinkedCodeBlock* codeBlock, InstructionStreamWriter& instructions)
+    void run(UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter& instructions)
     {
         // Perform modified liveness analysis to determine which locals are live at the merge points.
         // This produces the conservative results for the question, "which variables should be saved and resumed?".
 
         runLivenessFixpoint(codeBlock, instructions, m_generatorification.graph());
 
         for (YieldData& data : m_generatorification.yields())
-            data.liveness = getLivenessInfoAtBytecodeOffset(codeBlock, instructions, m_generatorification.graph(), m_generatorification.instructions().at(data.point).next().offset());
+            data.liveness = getLivenessInfoAtBytecodeIndex(codeBlock, instructions, m_generatorification.graph(), BytecodeIndex(m_generatorification.instructions().at(data.point).next().offset()));
     }
 
 private:
     BytecodeGeneratorification& m_generatorification;
 };
@@ -221,26 +219,26 @@
 
     // Setup the global switch for the generator.
     {
         auto nextToEnterPoint = enterPoint().next();
         unsigned switchTableIndex = m_codeBlock->numberOfSwitchJumpTables();
-        VirtualRegister state = virtualRegisterForArgument(static_cast<int32_t>(JSGeneratorFunction::GeneratorArgument::State));
+        VirtualRegister state = virtualRegisterForArgumentIncludingThis(static_cast<int32_t>(JSGenerator::GeneratorArgument::State));
         auto& jumpTable = m_codeBlock->addSwitchJumpTable();
         jumpTable.min = 0;
-        jumpTable.branchOffsets.resize(m_yields.size() + 1);
-        jumpTable.branchOffsets.fill(0);
+        jumpTable.branchOffsets = RefCountedArray<int32_t>(m_yields.size() + 1);
+        std::fill(jumpTable.branchOffsets.begin(), jumpTable.branchOffsets.end(), 0);
         jumpTable.add(0, nextToEnterPoint.offset());
         for (unsigned i = 0; i < m_yields.size(); ++i)
             jumpTable.add(i + 1, m_yields[i].point);
 
         rewriter.insertFragmentBefore(nextToEnterPoint, [&] (BytecodeRewriter::Fragment& fragment) {
             fragment.appendInstruction<OpSwitchImm>(switchTableIndex, BoundLabel(nextToEnterPoint.offset()), state);
         });
     }
 
     for (const YieldData& data : m_yields) {
-        VirtualRegister scope = virtualRegisterForArgument(static_cast<int32_t>(JSGeneratorFunction::GeneratorArgument::Frame));
+        VirtualRegister scope = virtualRegisterForArgumentIncludingThis(static_cast<int32_t>(JSGenerator::GeneratorArgument::Frame));
 
         auto instruction = m_instructions.at(data.point);
         // Emit save sequence.
         rewriter.insertFragmentBefore(instruction, [&] (BytecodeRewriter::Fragment& fragment) {
             data.liveness.forEachSetBit([&](size_t index) {
@@ -295,14 +293,14 @@
     }
 
     rewriter.execute();
 }
 
-void performGeneratorification(BytecodeGenerator& bytecodeGenerator, UnlinkedCodeBlock* codeBlock, InstructionStreamWriter& instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)
+void performGeneratorification(BytecodeGenerator& bytecodeGenerator, UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter& instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)
 {
-    if (Options::dumpBytecodesBeforeGeneratorification())
-        BytecodeDumper<UnlinkedCodeBlock>::dumpBlock(codeBlock, instructions, WTF::dataFile());
+    if (UNLIKELY(Options::dumpBytecodesBeforeGeneratorification()))
+        CodeBlockBytecodeDumper<UnlinkedCodeBlockGenerator>::dumpBlock(codeBlock, instructions, WTF::dataFile());
 
     BytecodeGeneratorification pass(bytecodeGenerator, codeBlock, instructions, generatorFrameSymbolTable, generatorFrameSymbolTableIndex);
     pass.run();
 }
 

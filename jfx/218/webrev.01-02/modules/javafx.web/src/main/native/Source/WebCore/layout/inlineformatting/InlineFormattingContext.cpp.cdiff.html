<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../floats/FloatingState.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,294 ***</span>
  #include &quot;config.h&quot;
  #include &quot;InlineFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;InlineFormattingState.h&quot;
<span class="line-removed">- #include &quot;InlineLineBreaker.h&quot;</span>
  #include &quot;InlineTextItem.h&quot;
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutState.h&quot;
  #include &quot;Logging.h&quot;
<span class="line-modified">! #include &quot;Textutil.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
  
<span class="line-modified">! InlineFormattingContext::InlineFormattingContext(const Box&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! static inline const Box* nextInPreOrder(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
  {
<span class="line-modified">!     const Box* nextInPreOrder = nullptr;</span>
<span class="line-modified">!     if (!layoutBox.establishesFormattingContext() &amp;&amp; is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-modified">!         return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();</span>
  
<span class="line-modified">!     for (nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
          if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
              return nextSibling;
      }
      return nullptr;
  }
  
<span class="line-modified">! void InlineFormattingContext::layout() const</span>
  {
<span class="line-modified">!     if (!is&lt;Container&gt;(root()))</span>
<span class="line-modified">!         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
<span class="line-removed">-     if (!root.hasInFlowOrFloatingChild())</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     auto availableWidth = layoutState().displayBoxForLayoutBox(root).contentBoxWidth();</span>
<span class="line-modified">!     auto usedValues = UsedHorizontalValues { availableWidth };</span>
<span class="line-modified">!     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>
<span class="line-removed">-     // Compute width/height for non-text content and margin/border/padding for inline containers.</span>
      while (layoutBox) {
<span class="line-modified">!         if (layoutBox-&gt;establishesFormattingContext())</span>
<span class="line-modified">!             layoutFormattingContextRoot(*layoutBox, usedValues);</span>
<span class="line-modified">!         else if (is&lt;Container&gt;(*layoutBox))</span>
<span class="line-modified">!             computeMarginBorderAndPaddingForInlineContainer(downcast&lt;Container&gt;(*layoutBox), usedValues);</span>
<span class="line-modified">!         else if (layoutBox-&gt;isReplaced())</span>
<span class="line-modified">!             computeWidthAndHeightForReplacedInlineBox(*layoutBox, usedValues);</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-modified">!             initializeMarginBorderAndPaddingForGenericInlineBox(*layoutBox);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         layoutBox = nextInPreOrder(*layoutBox, root);</span>
      }
  
<span class="line-modified">!     // FIXME: This is such a waste when intrinsic width computation already collected the inline items.</span>
<span class="line-removed">-     formattingState().inlineItems().clear();</span>
<span class="line-removed">-     formattingState().inlineRuns().clear();</span>
  
<span class="line-modified">!     collectInlineContent();</span>
<span class="line-modified">!     InlineLayout(*this).layout(formattingState().inlineItems(), availableWidth);</span>
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root &lt;&lt; &quot;)&quot;);</span>
  }
  
<span class="line-modified">! FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints() const</span>
  {
      auto&amp; layoutState = this-&gt;layoutState();
      ASSERT(!formattingState().intrinsicWidthConstraints());
  
<span class="line-modified">!     if (!is&lt;Container&gt;(root()) || !downcast&lt;Container&gt;(root()).hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">!         auto constraints = Geometry::constrainByMinMaxWidth(root(), { });</span>
          formattingState().setIntrinsicWidthConstraints(constraints);
          return constraints;
      }
  
<span class="line-removed">-     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
      Vector&lt;const Box*&gt; formattingContextRootList;
<span class="line-modified">!     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-modified">!     auto* layoutBox = root.firstInFlowOrFloatingChild();</span>
      while (layoutBox) {
<span class="line-modified">!         if (layoutBox-&gt;establishesFormattingContext()) {</span>
              formattingContextRootList.append(layoutBox);
              computeIntrinsicWidthForFormattingRoot(*layoutBox);
<span class="line-modified">!         } else if (layoutBox-&gt;isReplaced() || is&lt;Container&gt;(*layoutBox)) {</span>
<span class="line-modified">!             computeBorderAndPadding(*layoutBox, usedValues);</span>
<span class="line-modified">!             // inline-block and replaced.</span>
<span class="line-modified">!             auto needsWidthComputation = layoutBox-&gt;isReplaced();</span>
<span class="line-modified">!             if (needsWidthComputation)</span>
<span class="line-modified">!                 computeWidthAndMargin(*layoutBox, usedValues);</span>
<span class="line-removed">-             else {</span>
<span class="line-removed">-                 // Simple inline container with no intrinsic width &lt;span&gt;.</span>
<span class="line-removed">-                 computeHorizontalMargin(*layoutBox, usedValues);</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         layoutBox = nextInPreOrder(*layoutBox, root);</span>
      }
  
<span class="line-modified">!     collectInlineContent();</span>
  
      auto maximumLineWidth = [&amp;](auto availableWidth) {
          // Switch to the min/max formatting root width values before formatting the lines.
          for (auto* formattingRoot : formattingContextRootList) {
              auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
<span class="line-modified">!             auto&amp; displayBox = layoutState.displayBoxForLayoutBox(*formattingRoot);</span>
              auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
              displayBox.setContentBoxWidth(contentWidth);
          }
<span class="line-modified">!         return InlineLayout(*this).computedIntrinsicWidth(formattingState().inlineItems(), availableWidth);</span>
      };
  
<span class="line-modified">!     auto constraints = Geometry::constrainByMinMaxWidth(root, { maximumLineWidth(0), maximumLineWidth(LayoutUnit::max()) });</span>
      formattingState().setIntrinsicWidthConstraints(constraints);
      return constraints;
  }
  
<span class="line-modified">! void InlineFormattingContext::initializeMarginBorderAndPaddingForGenericInlineBox(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     ASSERT(layoutBox.isAnonymous() || layoutBox.isLineBreakBox());</span>
<span class="line-modified">!     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-modified">!     displayBox.setHorizontalMargin({ });</span>
<span class="line-modified">!     displayBox.setBorder({ { }, { } });</span>
<span class="line-modified">!     displayBox.setPadding({ });</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! void InlineFormattingContext::computeMarginBorderAndPaddingForInlineContainer(const Container&amp; container, UsedHorizontalValues usedValues) const</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     computeHorizontalMargin(container, usedValues);</span>
<span class="line-modified">!     computeBorderAndPadding(container, usedValues);</span>
<span class="line-modified">!     // Inline containers (&lt;span&gt;) have 0 vertical margins.</span>
<span class="line-modified">!     layoutState().displayBoxForLayoutBox(container).setVerticalMargin({ { }, { } });</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot) const</span>
  {
      ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">! </span>
<span class="line-removed">-     auto usedValues = UsedHorizontalValues { };</span>
<span class="line-removed">-     computeBorderAndPadding(formattingRoot, usedValues);</span>
<span class="line-removed">-     computeHorizontalMargin(formattingRoot, usedValues);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     IntrinsicWidthConstraints constraints;</span>
<span class="line-removed">-     if (auto fixedWidth = Geometry::fixedValue(formattingRoot.style().logicalWidth()))</span>
          constraints = { *fixedWidth, *fixedWidth };
<span class="line-modified">!     else</span>
<span class="line-modified">!         constraints = layoutState.createFormattingContext(formattingRoot)-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">!     constraints = Geometry::constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-modified">!     constraints.expand(layoutState.displayBoxForLayoutBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
      formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
  }
  
<span class="line-modified">! void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
  {
<span class="line-modified">!     auto computedHorizontalMargin = Geometry::computedHorizontalMargin(layoutBox, usedValues);</span>
<span class="line-modified">!     auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
      displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
      displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
  }
  
<span class="line-modified">! void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">!     WidthAndMargin widthAndMargin;</span>
      if (layoutBox.isFloatingPositioned())
<span class="line-modified">!         widthAndMargin = Geometry::floatingWidthAndMargin(layoutState, layoutBox, usedValues);</span>
      else if (layoutBox.isInlineBlockBox())
<span class="line-modified">!         widthAndMargin = Geometry::inlineBlockWidthAndMargin(layoutState, layoutBox, usedValues);</span>
      else if (layoutBox.replaced())
<span class="line-modified">!         widthAndMargin = Geometry::inlineReplacedWidthAndMargin(layoutState, layoutBox, usedValues);</span>
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxWidth(widthAndMargin.width);</span>
<span class="line-modified">!     displayBox.setHorizontalMargin(widthAndMargin.usedMargin);</span>
<span class="line-modified">!     displayBox.setHorizontalComputedMargin(widthAndMargin.computedMargin);</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     HeightAndMargin heightAndMargin;</span>
      if (layoutBox.isFloatingPositioned())
<span class="line-modified">!         heightAndMargin = Geometry::floatingHeightAndMargin(layoutState, layoutBox, { }, UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() });</span>
      else if (layoutBox.isInlineBlockBox())
<span class="line-modified">!         heightAndMargin = Geometry::inlineBlockHeightAndMargin(layoutState, layoutBox);</span>
      else if (layoutBox.replaced())
<span class="line-modified">!         heightAndMargin = Geometry::inlineReplacedHeightAndMargin(layoutState, layoutBox, { });</span>
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto&amp; displayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxHeight(heightAndMargin.height);</span>
<span class="line-modified">!     displayBox.setVerticalMargin({ heightAndMargin.nonCollapsedMargin, { } });</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InlineFormattingContext::layoutFormattingContextRoot(const Box&amp; root, UsedHorizontalValues usedValues) const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(root.isFloatingPositioned() || root.isInlineBlockBox());</span>
<span class="line-removed">-     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     computeBorderAndPadding(root, usedValues);</span>
<span class="line-removed">-     computeWidthAndMargin(root, usedValues);</span>
<span class="line-removed">-     // This is similar to static positioning in block formatting context. We just need to initialize the top left position.</span>
<span class="line-removed">-     layoutState().displayBoxForLayoutBox(root).setTopLeft({ 0, 0 });</span>
<span class="line-removed">-     // Swich over to the new formatting context (the one that the root creates).</span>
<span class="line-removed">-     auto formattingContext = layoutState().createFormattingContext(root);</span>
<span class="line-removed">-     formattingContext-&gt;layout();</span>
<span class="line-removed">-     // Come back and finalize the root&#39;s height and margin.</span>
<span class="line-removed">-     computeHeightAndMargin(root);</span>
<span class="line-removed">-     // Now that we computed the root&#39;s height, we can go back and layout the out-of-flow content.</span>
<span class="line-removed">-     formattingContext-&gt;layoutOutOfFlowContent();</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::computeWidthAndHeightForReplacedInlineBox(const Box&amp; layoutBox, UsedHorizontalValues usedValues) const</span>
  {
<span class="line-modified">!     ASSERT(!layoutBox.isContainer());</span>
<span class="line-modified">!     ASSERT(!layoutBox.establishesFormattingContext());</span>
<span class="line-modified">!     ASSERT(layoutBox.replaced());</span>
<span class="line-removed">-     ASSERT(usedValues.containingBlockWidth);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     computeBorderAndPadding(layoutBox, usedValues);</span>
<span class="line-removed">-     computeWidthAndMargin(layoutBox, usedValues);</span>
<span class="line-removed">-     computeHeightAndMargin(layoutBox);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InlineFormattingContext::collectInlineContent() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto&amp; root = downcast&lt;Container&gt;(this-&gt;root());</span>
      // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
      // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
<span class="line-modified">!     auto&amp; formattingState = this-&gt;formattingState();</span>
      LayoutQueue layoutQueue;
<span class="line-modified">!     layoutQueue.append(root.firstInFlowOrFloatingChild());</span>
      while (!layoutQueue.isEmpty()) {
<span class="line-removed">-         auto treatAsInlineContainer = [](auto&amp; layoutBox) {</span>
<span class="line-removed">-             return is&lt;Container&gt;(layoutBox) &amp;&amp; !layoutBox.establishesFormattingContext();</span>
<span class="line-removed">-         };</span>
          while (true) {
              auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">!             if (!treatAsInlineContainer(layoutBox))</span>
                  break;
<span class="line-modified">!             // This is the start of an inline container (e.g. &lt;span&gt;).</span>
<span class="line-modified">!             formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerStart));</span>
<span class="line-modified">!             auto&amp; container = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">!             if (!container.hasInFlowOrFloatingChild())</span>
                  break;
<span class="line-modified">!             layoutQueue.append(container.firstInFlowOrFloatingChild());</span>
          }
  
          while (!layoutQueue.isEmpty()) {
              auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">!             // This is the end of an inline container (e.g. &lt;/span&gt;).</span>
<span class="line-modified">!             if (treatAsInlineContainer(layoutBox))</span>
<span class="line-removed">-                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::ContainerEnd));</span>
<span class="line-removed">-             else if (layoutBox.isLineBreakBox())</span>
<span class="line-removed">-                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::HardLineBreak));</span>
              else if (layoutBox.isFloatingPositioned())
<span class="line-modified">!                 formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Float));</span>
<span class="line-modified">!             else {</span>
<span class="line-modified">!                 ASSERT(layoutBox.isInlineLevelBox());</span>
<span class="line-modified">!                 if (layoutBox.hasTextContent())</span>
<span class="line-modified">!                     InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">!                 else</span>
<span class="line-modified">!                     formattingState.addInlineItem(makeUnique&lt;InlineItem&gt;(layoutBox, InlineItem::Type::Box));</span>
<span class="line-modified">!             }</span>
  
              if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
                  layoutQueue.append(nextSibling);
                  break;
              }
          }
      }
  }
  
  }
  }
  
  #endif
<span class="line-new-header">--- 26,535 ---</span>
  #include &quot;config.h&quot;
  #include &quot;InlineFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-added">+ #include &quot;FloatingContext.h&quot;</span>
<span class="line-added">+ #include &quot;FontCascade.h&quot;</span>
  #include &quot;InlineFormattingState.h&quot;
  #include &quot;InlineTextItem.h&quot;
<span class="line-added">+ #include &quot;InvalidationState.h&quot;</span>
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
<span class="line-added">+ #include &quot;LayoutContext.h&quot;</span>
  #include &quot;LayoutState.h&quot;
  #include &quot;Logging.h&quot;
<span class="line-modified">! #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added">+ #include &quot;TextUtil.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
  
<span class="line-modified">! InlineFormattingContext::InlineFormattingContext(const Container&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)</span>
      : FormattingContext(formattingContextRoot, formattingState)
  {
  }
  
<span class="line-modified">! static inline const Box* nextInlineLevelBoxToLayout(const Box&amp; layoutBox, const Container&amp; stayWithin)</span>
  {
<span class="line-modified">!     // Atomic inline-level boxes and floats are opaque boxes meaning that they are</span>
<span class="line-modified">!     // responsible for their own content (do not need to descend into their subtrees).</span>
<span class="line-modified">!     // Only inline boxes may have relevant descendant content.</span>
<span class="line-added">+     if (layoutBox.isInlineBox()) {</span>
<span class="line-added">+         if (is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild()) {</span>
<span class="line-added">+             // Anonymous inline boxes/line breaks can&#39;t have descendant content by definition.</span>
<span class="line-added">+             ASSERT(!layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox());</span>
<span class="line-added">+             return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     for (auto* nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {</span>
          if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
              return nextSibling;
      }
      return nullptr;
  }
  
<span class="line-modified">! void InlineFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)</span>
  {
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);</span>
<span class="line-modified">!     ASSERT(root().hasInFlowOrFloatingChild());</span>
  
<span class="line-modified">!     invalidateFormattingState(invalidationState);</span>
<span class="line-modified">!     auto* layoutBox = root().firstInFlowOrFloatingChild();</span>
<span class="line-modified">!     // 1. Visit each inline box and partially compute their geometry (margins, paddings and borders).</span>
<span class="line-modified">!     // 2. Collect the inline items (flatten the the layout tree) and place them on lines in bidirectional order.</span>
      while (layoutBox) {
<span class="line-modified">!         ASSERT(layoutBox-&gt;isInlineLevelBox());</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (layoutBox-&gt;isAtomicInlineLevelBox()) {</span>
<span class="line-modified">!             // Inline-blocks, inline-tables and replaced elements (img, video) can be sized but not yet positioned.</span>
<span class="line-modified">!             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">!             computeWidthAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">!             auto createsFormattingContext = layoutBox-&gt;isInlineBlockBox() || layoutBox-&gt;isInlineTableBox();</span>
<span class="line-modified">!             auto hasInFlowOrFloatingChild = is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasInFlowOrFloatingChild();</span>
<span class="line-modified">!             if (createsFormattingContext &amp;&amp; hasInFlowOrFloatingChild) {</span>
<span class="line-modified">!                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());</span>
<span class="line-modified">!                 formattingContext-&gt;layoutInFlowContent(invalidationState, horizontalConstraints, verticalConstraints);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             computeHeightAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+             if (createsFormattingContext &amp;&amp; is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasChild()) {</span>
<span class="line-added">+                 auto&amp; displayBox = geometryForBox(*layoutBox);</span>
<span class="line-added">+                 auto horizontalConstraintsForOutOfFlow = Geometry::horizontalConstraintsForOutOfFlow(displayBox);</span>
<span class="line-added">+                 auto verticalConstraintsForOutOfFlow = Geometry::verticalConstraintsForOutOfFlow(displayBox);</span>
<span class="line-added">+                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());</span>
<span class="line-added">+                 formattingContext-&gt;layoutOutOfFlowContent(invalidationState, horizontalConstraintsForOutOfFlow, verticalConstraintsForOutOfFlow);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else if (layoutBox-&gt;isInlineBox()) {</span>
<span class="line-added">+             if (layoutBox-&gt;isAnonymous() || layoutBox-&gt;isLineBreakBox()) {</span>
<span class="line-added">+                 // Text wrapper boxes are anonymous inline level boxes. Their computed border/padding/margins are 0.</span>
<span class="line-added">+                 auto&amp; displayBox = formattingState().displayBox(*layoutBox);</span>
<span class="line-added">+                 displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">+                 displayBox.setHorizontalMargin({ });</span>
<span class="line-added">+                 displayBox.setBorder({ { }, { } });</span>
<span class="line-added">+                 displayBox.setPadding({ });</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // Inline boxes (&lt;span&gt;) can&#39;t get sized/positioned yet. At this point we can only compute their margins, borders and paddings.</span>
<span class="line-added">+                 computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+                 computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+                 formattingState().displayBox(*layoutBox).setVerticalMargin({ { }, { } });</span>
<span class="line-added">+             }</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             ASSERT_NOT_REACHED();</span>
<span class="line-added">+ </span>
<span class="line-added">+         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>
      }
  
<span class="line-modified">!     collectInlineContentIfNeeded();</span>
  
<span class="line-modified">!     auto&amp; inlineItems = formattingState().inlineItems();</span>
<span class="line-modified">!     lineLayout(inlineItems, { 0, inlineItems.size() }, horizontalConstraints, verticalConstraints);</span>
<span class="line-modified">!     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::lineLayout(InlineItems&amp; inlineItems, LineLayoutContext::InlineItemRange layoutRange, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto lineLogicalTop = verticalConstraints.logicalTop;</span>
<span class="line-added">+     Optional&lt;unsigned&gt; partialLeadingContentLength;</span>
<span class="line-added">+     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::No };</span>
<span class="line-added">+     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };</span>
<span class="line-added">+ </span>
<span class="line-added">+     while (!layoutRange.isEmpty()) {</span>
<span class="line-added">+         lineBuilder.initialize(constraintsForLine(horizontalConstraints, lineLogicalTop));</span>
<span class="line-added">+         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange, partialLeadingContentLength);</span>
<span class="line-added">+         setDisplayBoxesForLine(lineContent, horizontalConstraints);</span>
<span class="line-added">+ </span>
<span class="line-added">+         partialLeadingContentLength = { };</span>
<span class="line-added">+         if (lineContent.trailingInlineItemIndex) {</span>
<span class="line-added">+             lineLogicalTop = lineContent.lineBox.logicalBottom();</span>
<span class="line-added">+             // When the trailing content is partial, we need to reuse the last InlinItem.</span>
<span class="line-added">+             if (lineContent.partialContent) {</span>
<span class="line-added">+                 layoutRange.start = *lineContent.trailingInlineItemIndex;</span>
<span class="line-added">+                 // Turn previous line&#39;s overflow content length into the next line&#39;s leading content partial length.</span>
<span class="line-added">+                 // &quot;sp&lt;-&gt;litcontent&quot; -&gt; overflow length: 10 -&gt; leading partial content length: 10.</span>
<span class="line-added">+                 partialLeadingContentLength = lineContent.partialContent-&gt;overflowContentLength;</span>
<span class="line-added">+             } else</span>
<span class="line-added">+                 layoutRange.start = *lineContent.trailingInlineItemIndex + 1;</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Floats prevented us placing any content on the line.</span>
<span class="line-added">+         ASSERT(lineBuilder.hasIntrusiveFloat());</span>
<span class="line-added">+         // Move the next line below the intrusive float.</span>
<span class="line-added">+         auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };</span>
<span class="line-added">+         auto floatConstraints = floatingContext.constraints(lineLogicalTop, toLayoutUnit(lineContent.lineBox.logicalBottom()) );</span>
<span class="line-added">+         ASSERT(floatConstraints.left || floatConstraints.right);</span>
<span class="line-added">+         static auto inifitePoint = PointInContextRoot::max();</span>
<span class="line-added">+         // In case of left and right constraints, we need to pick the one that&#39;s closer to the current line.</span>
<span class="line-added">+         lineLogicalTop = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);</span>
<span class="line-added">+         ASSERT(lineLogicalTop &lt; inifitePoint.y);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints()</span>
  {
      auto&amp; layoutState = this-&gt;layoutState();
      ASSERT(!formattingState().intrinsicWidthConstraints());
  
<span class="line-modified">!     if (!root().hasInFlowOrFloatingChild()) {</span>
<span class="line-modified">!         auto constraints = geometry().constrainByMinMaxWidth(root(), { });</span>
          formattingState().setIntrinsicWidthConstraints(constraints);
          return constraints;
      }
  
      Vector&lt;const Box*&gt; formattingContextRootList;
<span class="line-modified">!     auto horizontalConstraints = HorizontalConstraints { 0_lu, 0_lu };</span>
<span class="line-modified">!     auto* layoutBox = root().firstInFlowOrFloatingChild();</span>
<span class="line-added">+     // In order to compute the max/min widths, we need to compute margins, borders and paddings for certain inline boxes first.</span>
      while (layoutBox) {
<span class="line-modified">!         if (layoutBox-&gt;isAnonymous()) {</span>
<span class="line-added">+             layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (layoutBox-&gt;isReplaced()) {</span>
<span class="line-added">+             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+             computeWidthAndMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+         } else if (layoutBox-&gt;isFloatingPositioned() || layoutBox-&gt;isAtomicInlineLevelBox()) {</span>
<span class="line-added">+             ASSERT(layoutBox-&gt;establishesFormattingContext());</span>
              formattingContextRootList.append(layoutBox);
<span class="line-added">+ </span>
<span class="line-added">+             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-added">+             computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
              computeIntrinsicWidthForFormattingRoot(*layoutBox);
<span class="line-modified">!         } else if (layoutBox-&gt;isInlineBox()) {</span>
<span class="line-modified">!             computeBorderAndPadding(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">!             computeHorizontalMargin(*layoutBox, horizontalConstraints);</span>
<span class="line-modified">!         } else</span>
<span class="line-modified">!             ASSERT_NOT_REACHED();</span>
<span class="line-modified">!         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());</span>
      }
  
<span class="line-modified">!     collectInlineContentIfNeeded();</span>
  
      auto maximumLineWidth = [&amp;](auto availableWidth) {
          // Switch to the min/max formatting root width values before formatting the lines.
          for (auto* formattingRoot : formattingContextRootList) {
              auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
<span class="line-modified">!             auto&amp; displayBox = formattingState().displayBox(*formattingRoot);</span>
              auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
              displayBox.setContentBoxWidth(contentWidth);
          }
<span class="line-modified">!         return computedIntrinsicWidthForConstraint({ 0_lu, toLayoutUnit(availableWidth) });</span>
      };
  
<span class="line-modified">!     auto constraints = geometry().constrainByMinMaxWidth(root(), { toLayoutUnit(maximumLineWidth(0)), toLayoutUnit(maximumLineWidth(maxInlineLayoutUnit())) });</span>
      formattingState().setIntrinsicWidthConstraints(constraints);
      return constraints;
  }
  
<span class="line-modified">! InlineLayoutUnit InlineFormattingContext::computedIntrinsicWidthForConstraint(const HorizontalConstraints&amp; horizontalConstraints) const</span>
  {
<span class="line-modified">!     auto&amp; inlineItems = formattingState().inlineItems();</span>
<span class="line-modified">!     auto maximumLineWidth = InlineLayoutUnit { };</span>
<span class="line-modified">!     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::Yes };</span>
<span class="line-modified">!     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };</span>
<span class="line-modified">!     auto layoutRange = LineLayoutContext::InlineItemRange { 0 , inlineItems.size() };</span>
<span class="line-modified">!     while (!layoutRange.isEmpty()) {</span>
<span class="line-modified">!         // Only the horiztonal available width is constrained when computing intrinsic width.</span>
<span class="line-modified">!         lineBuilder.initialize(LineBuilder::Constraints { { }, horizontalConstraints.logicalWidth, false, { } });</span>
<span class="line-modified">!         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange , { });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         layoutRange.start = *lineContent.trailingInlineItemIndex + 1;</span>
<span class="line-modified">!         InlineLayoutUnit floatsWidth = 0;</span>
<span class="line-modified">!         for (auto&amp; floatItem : lineContent.floats)</span>
<span class="line-modified">!             floatsWidth += geometryForBox(floatItem-&gt;layoutBox()).marginBoxWidth();</span>
<span class="line-modified">!         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.lineBox.logicalWidth());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return maximumLineWidth;</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot)</span>
  {
      ASSERT(formattingRoot.establishesFormattingContext());
<span class="line-modified">!     auto constraints = IntrinsicWidthConstraints { };</span>
<span class="line-modified">!     if (auto fixedWidth = geometry().fixedValue(formattingRoot.style().logicalWidth()))</span>
          constraints = { *fixedWidth, *fixedWidth };
<span class="line-modified">!     else if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild())</span>
<span class="line-modified">!         constraints = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(formattingRoot), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-modified">!     constraints = geometry().constrainByMinMaxWidth(formattingRoot, constraints);</span>
<span class="line-modified">!     constraints.expand(geometryForBox(formattingRoot).horizontalMarginBorderAndPadding());</span>
      formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
  }
  
<span class="line-modified">! void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
  {
<span class="line-modified">!     auto computedHorizontalMargin = geometry().computedHorizontalMargin(layoutBox, horizontalConstraints);</span>
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
      displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
      displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
  }
  
<span class="line-modified">! void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
  {
<span class="line-modified">!     ContentWidthAndMargin contentWidthAndMargin;</span>
<span class="line-modified">!     // FIXME: Add support for min/max-width.</span>
<span class="line-added">+     auto usedWidth = OverrideHorizontalValues { };</span>
      if (layoutBox.isFloatingPositioned())
<span class="line-modified">!         contentWidthAndMargin = geometry().floatingWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
      else if (layoutBox.isInlineBlockBox())
<span class="line-modified">!         contentWidthAndMargin = geometry().inlineBlockWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
      else if (layoutBox.replaced())
<span class="line-modified">!         contentWidthAndMargin = geometry().inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);</span>
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxWidth(contentWidthAndMargin.contentWidth);</span>
<span class="line-modified">!     displayBox.setHorizontalMargin(contentWidthAndMargin.usedMargin);</span>
<span class="line-modified">!     displayBox.setHorizontalComputedMargin(contentWidthAndMargin.computedMargin);</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)</span>
  {
<span class="line-modified">!     ContentHeightAndMargin contentHeightAndMargin;</span>
<span class="line-modified">!     // FIXME: Add min/max-height support.</span>
<span class="line-modified">!     auto usedHeight = OverrideVerticalValues { };</span>
      if (layoutBox.isFloatingPositioned())
<span class="line-modified">!         contentHeightAndMargin = geometry().floatingHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);</span>
      else if (layoutBox.isInlineBlockBox())
<span class="line-modified">!         contentHeightAndMargin = geometry().inlineBlockHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);</span>
      else if (layoutBox.replaced())
<span class="line-modified">!         contentHeightAndMargin = geometry().inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, usedHeight);</span>
      else
          ASSERT_NOT_REACHED();
  
<span class="line-modified">!     auto&amp; displayBox = formattingState().displayBox(layoutBox);</span>
<span class="line-modified">!     displayBox.setContentBoxHeight(contentHeightAndMargin.contentHeight);</span>
<span class="line-modified">!     displayBox.setVerticalMargin({ contentHeightAndMargin.nonCollapsedMargin, { } });</span>
  }
  
<span class="line-modified">! void InlineFormattingContext::collectInlineContentIfNeeded()</span>
  {
<span class="line-modified">!     auto&amp; formattingState = this-&gt;formattingState();</span>
<span class="line-modified">!     if (!formattingState.inlineItems().isEmpty())</span>
<span class="line-modified">!         return;</span>
      // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
      // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
<span class="line-modified">!     ASSERT(root().hasInFlowOrFloatingChild());</span>
      LayoutQueue layoutQueue;
<span class="line-modified">!     layoutQueue.append(root().firstInFlowOrFloatingChild());</span>
      while (!layoutQueue.isEmpty()) {
          while (true) {
              auto&amp; layoutBox = *layoutQueue.last();
<span class="line-modified">!             auto isBoxWithInlineContent = layoutBox.isInlineBox() &amp;&amp; !layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox();</span>
<span class="line-added">+             if (!isBoxWithInlineContent)</span>
                  break;
<span class="line-modified">!             // This is the start of an inline box (e.g. &lt;span&gt;).</span>
<span class="line-modified">!             formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerStart });</span>
<span class="line-modified">!             auto&amp; inlineBoxWithInlineContent = downcast&lt;Container&gt;(layoutBox);</span>
<span class="line-modified">!             if (!inlineBoxWithInlineContent.hasInFlowOrFloatingChild())</span>
                  break;
<span class="line-modified">!             layoutQueue.append(inlineBoxWithInlineContent.firstInFlowOrFloatingChild());</span>
          }
  
          while (!layoutQueue.isEmpty()) {
              auto&amp; layoutBox = *layoutQueue.takeLast();
<span class="line-modified">!             if (layoutBox.isLineBreakBox())</span>
<span class="line-modified">!                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::HardLineBreak });</span>
              else if (layoutBox.isFloatingPositioned())
<span class="line-modified">!                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Float });</span>
<span class="line-modified">!             else if (layoutBox.isAtomicInlineLevelBox())</span>
<span class="line-modified">!                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Box });</span>
<span class="line-modified">!             else if (layoutBox.isAnonymous()) {</span>
<span class="line-modified">!                 ASSERT(layoutBox.hasTextContent());</span>
<span class="line-modified">!                 InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);</span>
<span class="line-modified">!             } else if (layoutBox.isInlineBox())</span>
<span class="line-modified">!                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerEnd });</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 ASSERT_NOT_REACHED();</span>
  
              if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
                  layoutQueue.append(nextSibling);
                  break;
              }
          }
      }
  }
  
<span class="line-added">+ LineBuilder::Constraints InlineFormattingContext::constraintsForLine(const HorizontalConstraints&amp; horizontalConstraints, InlineLayoutUnit lineLogicalTop)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto lineLogicalLeft = horizontalConstraints.logicalLeft;</span>
<span class="line-added">+     auto lineLogicalRight = lineLogicalLeft + horizontalConstraints.logicalWidth;</span>
<span class="line-added">+     auto lineHeightAndBaseline = quirks().lineHeightConstraints(root());</span>
<span class="line-added">+     auto lineIsConstrainedByFloat = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };</span>
<span class="line-added">+     // Check for intruding floats and adjust logical left/available width for this line accordingly.</span>
<span class="line-added">+     if (!floatingContext.isEmpty()) {</span>
<span class="line-added">+         // FIXME: Add support for variable line height, where the intrusive floats should be probed as the line height grows.</span>
<span class="line-added">+         auto floatConstraints = floatingContext.constraints(toLayoutUnit(lineLogicalTop), toLayoutUnit(lineLogicalTop + lineHeightAndBaseline.height));</span>
<span class="line-added">+         // Check if these constraints actually put limitation on the line.</span>
<span class="line-added">+         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= lineLogicalLeft)</span>
<span class="line-added">+             floatConstraints.left = { };</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= lineLogicalRight)</span>
<span class="line-added">+             floatConstraints.right = { };</span>
<span class="line-added">+ </span>
<span class="line-added">+         lineIsConstrainedByFloat = floatConstraints.left || floatConstraints.right;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (floatConstraints.left &amp;&amp; floatConstraints.right) {</span>
<span class="line-added">+             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);</span>
<span class="line-added">+             lineLogicalRight = floatConstraints.right-&gt;x;</span>
<span class="line-added">+             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
<span class="line-added">+         } else if (floatConstraints.left) {</span>
<span class="line-added">+             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-added">+             lineLogicalLeft = floatConstraints.left-&gt;x;</span>
<span class="line-added">+         } else if (floatConstraints.right) {</span>
<span class="line-added">+             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);</span>
<span class="line-added">+             lineLogicalRight = floatConstraints.right-&gt;x;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto computedTextIndent = [&amp;] {</span>
<span class="line-added">+         // text-indent property specifies the indentation applied to lines of inline content in a block.</span>
<span class="line-added">+         // The indent is treated as a margin applied to the start edge of the line box.</span>
<span class="line-added">+         // Unless otherwise specified, only lines that are the first formatted line of an element are affected.</span>
<span class="line-added">+         // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.</span>
<span class="line-added">+         // FIXME: Add support for each-line.</span>
<span class="line-added">+         // [Integration] root()-&gt;parent() would normally produce a valid layout box.</span>
<span class="line-added">+         auto&amp; root = this-&gt;root();</span>
<span class="line-added">+         auto isFormattingContextRootCandidateToTextIndent = !root.isAnonymous();</span>
<span class="line-added">+         if (root.isAnonymous()) {</span>
<span class="line-added">+             // Unless otherwise specified by the each-line and/or hanging keywords, only lines that are the first formatted line</span>
<span class="line-added">+             // of an element are affected.</span>
<span class="line-added">+             // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.</span>
<span class="line-added">+             isFormattingContextRootCandidateToTextIndent = RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()</span>
<span class="line-added">+                 ? layoutState().isIntegratedRootBoxFirstChild()</span>
<span class="line-added">+                 : root.parent()-&gt;firstInFlowChild() == &amp;root;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!isFormattingContextRootCandidateToTextIndent)</span>
<span class="line-added">+             return InlineLayoutUnit { };</span>
<span class="line-added">+         auto invertLineRange = false;</span>
<span class="line-added">+ #if ENABLE(CSS3_TEXT)</span>
<span class="line-added">+         invertLineRange = root.style().textIndentType() == TextIndentType::Hanging;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         auto isFirstLine = formattingState().ensureDisplayInlineContent().lineBoxes.isEmpty();</span>
<span class="line-added">+         // text-indent: hanging inverts which lines are affected.</span>
<span class="line-added">+         // inverted line range -&gt; all the lines except the first one.</span>
<span class="line-added">+         // !inverted line range -&gt; first line gets the indent.</span>
<span class="line-added">+         auto shouldIndent = invertLineRange != isFirstLine;</span>
<span class="line-added">+         if (!shouldIndent)</span>
<span class="line-added">+             return InlineLayoutUnit { };</span>
<span class="line-added">+         return geometry().computedTextIndent(root, horizontalConstraints).valueOr(InlineLayoutUnit { });</span>
<span class="line-added">+     };</span>
<span class="line-added">+     lineLogicalLeft += computedTextIndent();</span>
<span class="line-added">+     return LineBuilder::Constraints { { lineLogicalLeft, lineLogicalTop }, lineLogicalRight - lineLogicalLeft, lineIsConstrainedByFloat, lineHeightAndBaseline };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InlineFormattingContext::setDisplayBoxesForLine(const LineLayoutContext::LineContent&amp; lineContent, const HorizontalConstraints&amp; horizontalConstraints)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto&amp; formattingState = this-&gt;formattingState();</span>
<span class="line-added">+     auto&amp; lineBox = lineContent.lineBox;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!lineContent.floats.isEmpty()) {</span>
<span class="line-added">+         auto floatingContext = FloatingContext { root(), *this, formattingState.floatingState() };</span>
<span class="line-added">+         // Move floats to their final position.</span>
<span class="line-added">+         for (const auto&amp; floatItem : lineContent.floats) {</span>
<span class="line-added">+             auto&amp; floatBox = floatItem-&gt;layoutBox();</span>
<span class="line-added">+             auto&amp; displayBox = formattingState.displayBox(floatBox);</span>
<span class="line-added">+             // Set static position first.</span>
<span class="line-added">+             displayBox.setTopLeft({ lineBox.logicalLeft(), lineBox.logicalTop() });</span>
<span class="line-added">+             // Float it.</span>
<span class="line-added">+             displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));</span>
<span class="line-added">+             floatingContext.append(floatBox);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto initialContaingBlockSize = LayoutSize { };</span>
<span class="line-added">+     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {</span>
<span class="line-added">+         // ICB is not the real ICB when lyoutFormattingContextIntegrationEnabled is on.</span>
<span class="line-added">+         initialContaingBlockSize = layoutState().viewportSize();</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         initialContaingBlockSize = geometryForBox(root().initialContainingBlock(), EscapeReason::StrokeOverflowNeedsViewportGeometry).contentBox().size();</span>
<span class="line-added">+     auto&amp; inlineContent = formattingState.ensureDisplayInlineContent();</span>
<span class="line-added">+     auto lineIndex = inlineContent.lineBoxes.size();</span>
<span class="line-added">+     auto lineInkOverflow = lineBox.scrollableOverflow();</span>
<span class="line-added">+     Optional&lt;unsigned&gt; lastTextItemIndex;</span>
<span class="line-added">+     // Compute box final geometry.</span>
<span class="line-added">+     auto&amp; lineRuns = lineContent.runList;</span>
<span class="line-added">+     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {</span>
<span class="line-added">+         auto&amp; lineRun = lineRuns.at(index);</span>
<span class="line-added">+         auto&amp; logicalRect = lineRun.logicalRect();</span>
<span class="line-added">+         auto&amp; layoutBox = lineRun.layoutBox();</span>
<span class="line-added">+         auto&amp; displayBox = formattingState.displayBox(layoutBox);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Add final display runs to state first.</span>
<span class="line-added">+         // Inline level containers (&lt;span&gt;) don&#39;t generate display runs and neither do completely collapsed runs.</span>
<span class="line-added">+         auto initiatesInlineRun = !lineRun.isContainerStart() &amp;&amp; !lineRun.isContainerEnd();</span>
<span class="line-added">+         if (initiatesInlineRun) {</span>
<span class="line-added">+             auto computedInkOverflow = [&amp;] {</span>
<span class="line-added">+                 // FIXME: Add support for non-text ink overflow.</span>
<span class="line-added">+                 if (!lineRun.isText())</span>
<span class="line-added">+                     return logicalRect;</span>
<span class="line-added">+                 auto&amp; style = lineRun.style();</span>
<span class="line-added">+                 auto inkOverflow = logicalRect;</span>
<span class="line-added">+                 auto strokeOverflow = std::ceil(style.computedStrokeWidth(ceiledIntSize(initialContaingBlockSize)));</span>
<span class="line-added">+                 inkOverflow.inflate(strokeOverflow);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto letterSpacing = style.fontCascade().letterSpacing();</span>
<span class="line-added">+                 if (letterSpacing &lt; 0) {</span>
<span class="line-added">+                     // Last letter&#39;s negative spacing shrinks logical rect. Push it to ink overflow.</span>
<span class="line-added">+                     inkOverflow.expandHorizontally(-letterSpacing);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 return inkOverflow;</span>
<span class="line-added">+             };</span>
<span class="line-added">+             auto inkOverflow = computedInkOverflow();</span>
<span class="line-added">+             lineInkOverflow.expandToContain(inkOverflow);</span>
<span class="line-added">+             inlineContent.runs.append({ lineIndex, lineRun.layoutBox(), logicalRect, inkOverflow, lineRun.textContext() });</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (lineRun.isLineBreak()) {</span>
<span class="line-added">+             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">+             displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));</span>
<span class="line-added">+             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Inline level box (replaced or inline-block)</span>
<span class="line-added">+         if (lineRun.isBox()) {</span>
<span class="line-added">+             auto topLeft = logicalRect.topLeft();</span>
<span class="line-added">+             if (layoutBox.isInFlowPositioned())</span>
<span class="line-added">+                 topLeft += geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);</span>
<span class="line-added">+             displayBox.setTopLeft(toLayoutPoint(topLeft));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Inline level container start (&lt;span&gt;)</span>
<span class="line-added">+         if (lineRun.isContainerStart()) {</span>
<span class="line-added">+             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Inline level container end (&lt;/span&gt;)</span>
<span class="line-added">+         if (lineRun.isContainerEnd()) {</span>
<span class="line-added">+             if (layoutBox.isInFlowPositioned()) {</span>
<span class="line-added">+                 auto inflowOffset = geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);</span>
<span class="line-added">+                 displayBox.moveHorizontally(inflowOffset.width());</span>
<span class="line-added">+                 displayBox.moveVertically(inflowOffset.height());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             auto marginBoxWidth = logicalRect.left() - displayBox.left();</span>
<span class="line-added">+             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));</span>
<span class="line-added">+             // FIXME fix it for multiline.</span>
<span class="line-added">+             displayBox.setContentBoxWidth(toLayoutUnit(contentBoxWidth));</span>
<span class="line-added">+             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (lineRun.isText()) {</span>
<span class="line-added">+             lastTextItemIndex = inlineContent.runs.size() - 1;</span>
<span class="line-added">+             auto firstRunForLayoutBox = !index || &amp;lineRuns[index - 1].layoutBox() != &amp;layoutBox;</span>
<span class="line-added">+             if (firstRunForLayoutBox) {</span>
<span class="line-added">+                 // Setup display box for the associated layout box.</span>
<span class="line-added">+                 displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));</span>
<span class="line-added">+                 displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));</span>
<span class="line-added">+                 displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 // FIXME fix it for multirun/multiline.</span>
<span class="line-added">+                 displayBox.setContentBoxWidth(toLayoutUnit(displayBox.contentBoxWidth() + logicalRect.width()));</span>
<span class="line-added">+             }</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Make sure the trailing text run gets a hyphen when it needs one.</span>
<span class="line-added">+     if (lineContent.partialContent &amp;&amp; lineContent.partialContent-&gt;trailingContentNeedsHyphen)</span>
<span class="line-added">+         inlineContent.runs[*lastTextItemIndex].textContext()-&gt;setNeedsHyphen();</span>
<span class="line-added">+     // FIXME: This is where the logical to physical translate should happen.</span>
<span class="line-added">+     auto&amp; baseline = lineBox.baseline();</span>
<span class="line-added">+     inlineContent.lineBoxes.append({ lineBox.logicalRect(), lineBox.scrollableOverflow(), lineInkOverflow, { baseline.ascent(), baseline.descent() }, lineBox.baselineOffset(), lineBox.isConsideredEmpty() });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void InlineFormattingContext::invalidateFormattingState(const InvalidationState&amp;)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Find out what we need to invalidate. This is where we add some smarts to do partial line layout.</span>
<span class="line-added">+     // For now let&#39;s just clear the runs.</span>
<span class="line-added">+     formattingState().clearDisplayInlineContent();</span>
<span class="line-added">+     // FIXME: This is also where we would delete inline items if their content changed.</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  }
  }
  
  #endif
</pre>
<center><a href="../floats/FloatingState.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InlineFormattingContext.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
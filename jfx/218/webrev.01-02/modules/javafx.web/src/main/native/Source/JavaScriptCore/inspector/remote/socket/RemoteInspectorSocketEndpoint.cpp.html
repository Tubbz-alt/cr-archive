<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/remote/socket/RemoteInspectorSocketEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Sony Interactive Entertainment Inc.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RemoteInspectorSocketEndpoint.h&quot;
 28 
 29 #if ENABLE(REMOTE_INSPECTOR)
 30 
 31 #include &lt;wtf/CryptographicallyRandomNumber.h&gt;
 32 #include &lt;wtf/MainThread.h&gt;
 33 #include &lt;wtf/RunLoop.h&gt;
 34 #include &lt;wtf/text/WTFString.h&gt;
 35 
 36 namespace Inspector {
 37 
 38 RemoteInspectorSocketEndpoint&amp; RemoteInspectorSocketEndpoint::singleton()
 39 {
 40     static NeverDestroyed&lt;RemoteInspectorSocketEndpoint&gt; shared;
 41     return shared;
 42 }
 43 
 44 RemoteInspectorSocketEndpoint::RemoteInspectorSocketEndpoint()
 45 {
 46     if (auto sockets = Socket::createPair()) {
 47         m_wakeupSendSocket = sockets-&gt;at(0);
 48         m_wakeupReceiveSocket = sockets-&gt;at(1);
 49     }
 50 
 51     m_workerThread = Thread::create(&quot;SocketEndpoint&quot;, [this] {
 52         workerThread();
 53     });
 54 }
 55 
 56 RemoteInspectorSocketEndpoint::~RemoteInspectorSocketEndpoint()
 57 {
 58     ASSERT(m_workerThread.get() != &amp;Thread::current());
 59 
 60     m_shouldAbortWorkerThread = true;
 61     wakeupWorkerThread();
 62     m_workerThread-&gt;waitForCompletion();
 63 
 64     Socket::close(m_wakeupSendSocket);
 65     Socket::close(m_wakeupReceiveSocket);
 66     for (const auto&amp; connection : m_connections.values())
 67         Socket::close(connection-&gt;socket);
 68     for (const auto&amp; connection : m_listeners.values())
 69         Socket::close(connection-&gt;socket);
 70 }
 71 
 72 void RemoteInspectorSocketEndpoint::wakeupWorkerThread()
 73 {
 74     if (Socket::isValid(m_wakeupSendSocket))
 75         Socket::write(m_wakeupSendSocket, &quot;1&quot;, 1);
 76 }
 77 
 78 Optional&lt;ConnectionID&gt; RemoteInspectorSocketEndpoint::connectInet(const char* serverAddress, uint16_t serverPort, Client&amp; client)
 79 {
 80     if (auto socket = Socket::connect(serverAddress, serverPort))
 81         return createClient(*socket, client);
 82     return WTF::nullopt;
 83 }
 84 
 85 Optional&lt;ConnectionID&gt; RemoteInspectorSocketEndpoint::listenInet(const char* address, uint16_t port, Listener&amp; listener, Client&amp; client)
 86 {
 87     if (auto socket = Socket::listen(address, port))
 88         return createListener(*socket, listener, client);
 89 
 90     return WTF::nullopt;
 91 }
 92 
 93 bool RemoteInspectorSocketEndpoint::isListening(ConnectionID id)
 94 {
 95     LockHolder lock(m_connectionsLock);
 96     if (m_listeners.contains(id))
 97         return true;
 98     return false;
 99 }
100 
101 void RemoteInspectorSocketEndpoint::workerThread()
102 {
103     PollingDescriptor wakeup = Socket::preparePolling(m_wakeupReceiveSocket);
104 
105     while (!m_shouldAbortWorkerThread) {
106 #if USE(GENERIC_EVENT_LOOP) || USE(WINDOWS_EVENT_LOOP)
107         RunLoop::iterate();
108 #endif
109 
110         Vector&lt;PollingDescriptor&gt; pollfds;
111         Vector&lt;ConnectionID&gt; ids;
112         {
113             LockHolder lock(m_connectionsLock);
114             for (const auto&amp; connection : m_connections) {
115                 pollfds.append(connection.value-&gt;poll);
116                 ids.append(connection.key);
117             }
118             for (const auto&amp; connection : m_listeners) {
119                 pollfds.append(connection.value-&gt;poll);
120                 ids.append(connection.key);
121             }
122         }
123         pollfds.append(wakeup);
124 
125         if (!Socket::poll(pollfds, -1))
126             continue;
127 
128         if (Socket::isReadable(pollfds.last())) {
129             char wakeMessage;
130             Socket::read(m_wakeupReceiveSocket, &amp;wakeMessage, sizeof(wakeMessage));
131             continue;
132         }
133 
134         for (size_t i = 0; i &lt; ids.size(); i++) {
135             auto id = ids[i];
136 
137             if (Socket::isReadable(pollfds[i])) {
138                 if (isListening(id))
139                     acceptInetSocketIfEnabled(id);
140                 else
141                     recvIfEnabled(id);
142             } else if (Socket::isWritable(pollfds[i]))
143                 sendIfEnabled(id);
144         }
145     }
146 }
147 
148 ConnectionID RemoteInspectorSocketEndpoint::generateConnectionID()
149 {
150     ASSERT(m_connectionsLock.isLocked());
151 
152     ConnectionID id;
153     do {
154         id = cryptographicallyRandomNumber();
155     } while (!id || m_connections.contains(id) || m_listeners.contains(id));
156 
157     return id;
158 }
159 
160 std::unique_ptr&lt;RemoteInspectorSocketEndpoint::Connection&gt; RemoteInspectorSocketEndpoint::makeConnection(PlatformSocketType socket, Client&amp; client)
161 {
162     ASSERT(m_connectionsLock.isLocked());
163 
164     Socket::setup(socket);
165 
166     auto connection = makeUnique&lt;Connection&gt;(client);
167 
168     connection-&gt;id = generateConnectionID();
169     connection-&gt;poll = Socket::preparePolling(socket);
170     connection-&gt;socket = socket;
171 
172     return connection;
173 }
174 
175 Optional&lt;ConnectionID&gt; RemoteInspectorSocketEndpoint::createClient(PlatformSocketType socket, Client&amp; client)
176 {
177     if (!Socket::isValid(socket))
178         return WTF::nullopt;
179 
180     LockHolder lock(m_connectionsLock);
181     auto connection = makeConnection(socket, client);
182     auto id = connection-&gt;id;
183     m_connections.add(id, WTFMove(connection));
184     wakeupWorkerThread();
185 
186     return id;
187 }
188 
189 Optional&lt;ConnectionID&gt; RemoteInspectorSocketEndpoint::createListener(PlatformSocketType socket, Listener&amp; listener, Client&amp; client)
190 {
191     if (!Socket::isValid(socket))
192         return WTF::nullopt;
193 
194     LockHolder lock(m_connectionsLock);
195 
196     if (!Socket::setup(socket))
197         return WTF::nullopt;
198 
199     auto connection = makeConnection(socket, client);
200     auto id = connection-&gt;id;
201     connection-&gt;listener = &amp;listener;
202     m_listeners.add(id, WTFMove(connection));
203     wakeupWorkerThread();
204 
205     return id;
206 }
207 
208 void RemoteInspectorSocketEndpoint::invalidateClient(Client&amp; client)
209 {
210     LockHolder lock(m_connectionsLock);
211     m_connections.removeIf([&amp;client](auto&amp; keyValue) {
212         const auto&amp; connection = keyValue.value;
213 
214         if (&amp;connection-&gt;client != &amp;client)
215             return false;
216 
217         Socket::close(connection-&gt;socket);
218         // do not call client.didClose because client is already invalidating phase.
219         return true;
220     });
221 }
222 
223 void RemoteInspectorSocketEndpoint::invalidateListener(Listener&amp; listener)
224 {
225     LockHolder lock(m_connectionsLock);
226     m_listeners.removeIf([&amp;listener](auto&amp; keyValue) {
227         const auto&amp; connection = keyValue.value;
228 
229         if (connection-&gt;listener == &amp;listener) {
230             Socket::close(connection-&gt;socket);
231             return true;
232         }
233 
234         return false;
235     });
236 }
237 
238 Optional&lt;uint16_t&gt; RemoteInspectorSocketEndpoint::getPort(ConnectionID id) const
239 {
240     LockHolder lock(m_connectionsLock);
241     if (const auto&amp; connection = m_listeners.get(id))
242         return Socket::getPort(connection-&gt;socket);
243     if (const auto&amp; connection = m_connections.get(id))
244         return Socket::getPort(connection-&gt;socket);
245 
246     return WTF::nullopt;
247 }
248 
249 void RemoteInspectorSocketEndpoint::recvIfEnabled(ConnectionID id)
250 {
251     LockHolder lock(m_connectionsLock);
252     if (const auto&amp; connection = m_connections.get(id)) {
253         Vector&lt;uint8_t&gt; recvBuffer(Socket::BufferSize);
254         if (auto readSize = Socket::read(connection-&gt;socket, recvBuffer.data(), recvBuffer.size())) {
255             if (*readSize &gt; 0) {
256                 recvBuffer.shrink(*readSize);
257                 connection-&gt;client.didReceive(id, WTFMove(recvBuffer));
258                 return;
259             }
260         }
261 
262         Socket::close(connection-&gt;socket);
263         m_connections.remove(id);
264 
265         lock.unlockEarly();
266         connection-&gt;client.didClose(id);
267     }
268 }
269 
270 void RemoteInspectorSocketEndpoint::sendIfEnabled(ConnectionID id)
271 {
272     LockHolder lock(m_connectionsLock);
273     if (const auto&amp; connection = m_connections.get(id)) {
274         Socket::clearWaitingWritable(connection-&gt;poll);
275 
276         auto&amp; buffer = connection-&gt;sendBuffer;
277         if (buffer.isEmpty())
278             return;
279 
280         if (auto writeSize = Socket::write(connection-&gt;socket, buffer.data(), std::min(buffer.size(), Socket::BufferSize))) {
281             auto size = *writeSize;
282             if (size == buffer.size()) {
283                 buffer.clear();
284                 return;
285             }
286 
287             if (size &gt; 0)
288                 buffer.remove(0, size);
289         }
290 
291         Socket::markWaitingWritable(connection-&gt;poll);
292     }
293 }
294 
295 void RemoteInspectorSocketEndpoint::send(ConnectionID id, const uint8_t* data, size_t size)
296 {
297     LockHolder lock(m_connectionsLock);
298     if (const auto&amp; connection = m_connections.get(id)) {
299         size_t offset = 0;
300         if (connection-&gt;sendBuffer.isEmpty()) {
301             // Try to call send() directly if buffer is empty.
302             if (auto writeSize = Socket::write(connection-&gt;socket, data, std::min(size, Socket::BufferSize)))
303                 offset = *writeSize;
304             // @TODO need to handle closed socket case?
305         }
306 
307         // Check all data is sent.
308         if (offset == size)
309             return;
310 
311         // Copy remaining data to send later.
312         connection-&gt;sendBuffer.appendRange(data + offset, data + size);
313         Socket::markWaitingWritable(connection-&gt;poll);
314 
315         wakeupWorkerThread();
316     }
317 }
318 
319 void RemoteInspectorSocketEndpoint::acceptInetSocketIfEnabled(ConnectionID id)
320 {
321     ASSERT(isListening(id));
322 
323     LockHolder lock(m_connectionsLock);
324     if (const auto&amp; connection = m_listeners.get(id)) {
325         if (auto socket = Socket::accept(connection-&gt;socket)) {
326             // Need to unlock before calling createClient as it also attempts to lock.
327             lock.unlockEarly();
328             if (auto newID = createClient(*socket, connection-&gt;client)) {
329                 if (connection-&gt;listener-&gt;didAccept(newID.value(), connection-&gt;id, Socket::Domain::Network))
330                     return;
331 
332                 m_connections.remove(id);
333             }
334 
335             Socket::close(*socket);
336         }
337     }
338 }
339 
340 } // namespace Inspector
341 
342 #endif // ENABLE(REMOTE_INSPECTOR)
    </pre>
  </body>
</html>
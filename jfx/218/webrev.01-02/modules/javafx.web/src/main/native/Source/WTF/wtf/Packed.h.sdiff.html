<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OptionSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;array&gt;



 29 #include &lt;wtf/MathExtras.h&gt;
 30 #include &lt;wtf/StdLibExtras.h&gt;
 31 #include &lt;wtf/UnalignedAccess.h&gt;
 32 
 33 namespace WTF {
 34 
 35 template&lt;typename T&gt;
 36 class Packed {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     static constexpr bool isPackedType = true;
 40 
 41     Packed()
 42         : Packed(T { })
 43     {
 44     }
 45 
 46     Packed(const T&amp; value)
 47     {
 48         unalignedStore&lt;T&gt;(m_storage.data(), value);
</pre>
<hr />
<pre>
 83         T t1 = get();
 84         T t2 = other.get();
 85         set(t2);
 86         other.set(t1);
 87     }
 88 
 89     void swap(T&amp; t2)
 90     {
 91         T t1 = get();
 92         std::swap(t1, t2);
 93         set(t1);
 94     }
 95 
 96 private:
 97     std::array&lt;uint8_t, sizeof(T)&gt; m_storage;
 98 };
 99 
100 // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
101 // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
102 // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
<span class="line-modified">103 template&lt;typename T, size_t alignment = alignof(T)&gt;</span>
104 class PackedAlignedPtr {
105     WTF_MAKE_FAST_ALLOCATED;
106 public:
<span class="line-modified">107     static_assert(hasOneBitSet(alignment), &quot;Alignment needs to be power-of-two&quot;);</span>

108     static constexpr bool isPackedType = true;
109     static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
<span class="line-modified">110     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8&gt;(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) / 8;</span>
<span class="line-modified">111     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8&gt;(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH - alignmentShiftSizeIfProfitable) / 8;</span>
112     static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
113     static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
114     static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
115 
116     constexpr PackedAlignedPtr()
117         : m_storage()
118     {
119     }
120 
121     constexpr PackedAlignedPtr(std::nullptr_t)
122         : m_storage()
123     {
124     }
125 
126     PackedAlignedPtr(T* value)
127     {
128         set(value);
129     }
130 
131     T* get() const
</pre>
<hr />
<pre>
146     void set(T* passedValue)
147     {
148         uintptr_t value = bitwise_cast&lt;uintptr_t&gt;(passedValue);
149         if (isAlignmentShiftProfitable)
150             value &gt;&gt;= alignmentShiftSize;
151 #if CPU(LITTLE_ENDIAN)
152         memcpy(m_storage.data(), &amp;value, storageSize);
153 #else
154         memcpy(m_storage.data(), bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), storageSize);
155 #endif
156     }
157 
158     void clear()
159     {
160         set(nullptr);
161     }
162 
163     T* operator-&gt;() const { return get(); }
164     T&amp; operator*() const { return *get(); }
165     bool operator!() const { return !get(); }




166     explicit operator bool() const { return get(); }
167 
168     PackedAlignedPtr&amp; operator=(T* value)
169     {
170         set(value);
171         return *this;
172     }
173 
174     template&lt;class U&gt;
<span class="line-modified">175     T exchange(U&amp;&amp; newValue)</span>
176     {
<span class="line-modified">177         T oldValue = get();</span>
178         set(std::forward&lt;U&gt;(newValue));
179         return oldValue;
180     }
181 
182     void swap(std::nullptr_t) { clear(); }
183 
184     void swap(PackedAlignedPtr&amp; other)
185     {
186         m_storage.swap(other.m_storage);
187     }
188 
189     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
190     void swap(Other&amp; other)
191     {
<span class="line-modified">192         T t1 = get();</span>
<span class="line-modified">193         T t2 = other.get();</span>
194         set(t2);
195         other.set(t1);
196     }
197 
<span class="line-modified">198     void swap(T&amp; t2)</span>
199     {
<span class="line-modified">200         T t1 = get();</span>
201         std::swap(t1, t2);
202         set(t1);
203     }
204 
205 private:
206     std::array&lt;uint8_t, storageSize&gt; m_storage;
207 };
208 
209 template&lt;typename T&gt;
210 class Packed&lt;T*&gt; : public PackedAlignedPtr&lt;T, 1&gt; {
211 public:
212     using Base = PackedAlignedPtr&lt;T, 1&gt;;
213     using Base::Base;




214 };
215 
216 template&lt;typename T&gt;
217 using PackedPtr = Packed&lt;T*&gt;;
218 











219 template&lt;typename T&gt;
220 struct PackedPtrTraits {
221     template&lt;typename U&gt; using RebindTraits = PackedPtrTraits&lt;U&gt;;
222 
223     using StorageType = PackedPtr&lt;T&gt;;
224 
225     template&lt;class U&gt; static ALWAYS_INLINE T* exchange(StorageType&amp; ptr, U&amp;&amp; newValue) { return ptr.exchange(newValue); }
226 
227     template&lt;typename Other&gt; static ALWAYS_INLINE void swap(PackedPtr&lt;T&gt;&amp; a, Other&amp; b) { a.swap(b); }
228 
229     static ALWAYS_INLINE T* unwrap(const StorageType&amp; ptr) { return ptr.get(); }






230 };
231 


232 } // namespace WTF
233 
234 using WTF::Packed;
235 using WTF::PackedAlignedPtr;
236 using WTF::PackedPtr;
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;array&gt;
<span class="line-added"> 29 #include &lt;wtf/Forward.h&gt;</span>
<span class="line-added"> 30 #include &lt;wtf/GetPtr.h&gt;</span>
<span class="line-added"> 31 #include &lt;wtf/HashFunctions.h&gt;</span>
 32 #include &lt;wtf/MathExtras.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/UnalignedAccess.h&gt;
 35 
 36 namespace WTF {
 37 
 38 template&lt;typename T&gt;
 39 class Packed {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     static constexpr bool isPackedType = true;
 43 
 44     Packed()
 45         : Packed(T { })
 46     {
 47     }
 48 
 49     Packed(const T&amp; value)
 50     {
 51         unalignedStore&lt;T&gt;(m_storage.data(), value);
</pre>
<hr />
<pre>
 86         T t1 = get();
 87         T t2 = other.get();
 88         set(t2);
 89         other.set(t1);
 90     }
 91 
 92     void swap(T&amp; t2)
 93     {
 94         T t1 = get();
 95         std::swap(t1, t2);
 96         set(t1);
 97     }
 98 
 99 private:
100     std::array&lt;uint8_t, sizeof(T)&gt; m_storage;
101 };
102 
103 // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
104 // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
105 // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
<span class="line-modified">106 template&lt;typename T, size_t passedAlignment&gt;</span>
107 class PackedAlignedPtr {
108     WTF_MAKE_FAST_ALLOCATED;
109 public:
<span class="line-modified">110     static_assert(hasOneBitSet(passedAlignment), &quot;Alignment needs to be power-of-two&quot;);</span>
<span class="line-added">111     static constexpr size_t alignment = passedAlignment;</span>
112     static constexpr bool isPackedType = true;
113     static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
<span class="line-modified">114     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) / 8;</span>
<span class="line-modified">115     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH) - alignmentShiftSizeIfProfitable) / 8;</span>
116     static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
117     static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
118     static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
119 
120     constexpr PackedAlignedPtr()
121         : m_storage()
122     {
123     }
124 
125     constexpr PackedAlignedPtr(std::nullptr_t)
126         : m_storage()
127     {
128     }
129 
130     PackedAlignedPtr(T* value)
131     {
132         set(value);
133     }
134 
135     T* get() const
</pre>
<hr />
<pre>
150     void set(T* passedValue)
151     {
152         uintptr_t value = bitwise_cast&lt;uintptr_t&gt;(passedValue);
153         if (isAlignmentShiftProfitable)
154             value &gt;&gt;= alignmentShiftSize;
155 #if CPU(LITTLE_ENDIAN)
156         memcpy(m_storage.data(), &amp;value, storageSize);
157 #else
158         memcpy(m_storage.data(), bitwise_cast&lt;uint8_t*&gt;(&amp;value) + (sizeof(void*) - storageSize), storageSize);
159 #endif
160     }
161 
162     void clear()
163     {
164         set(nullptr);
165     }
166 
167     T* operator-&gt;() const { return get(); }
168     T&amp; operator*() const { return *get(); }
169     bool operator!() const { return !get(); }
<span class="line-added">170 </span>
<span class="line-added">171     // This conversion operator allows implicit conversion to bool but not to other integer types.</span>
<span class="line-added">172     typedef T* (PackedAlignedPtr::*UnspecifiedBoolType);</span>
<span class="line-added">173     operator UnspecifiedBoolType() const { return get() ? &amp;PackedAlignedPtr::m_storage : nullptr; }</span>
174     explicit operator bool() const { return get(); }
175 
176     PackedAlignedPtr&amp; operator=(T* value)
177     {
178         set(value);
179         return *this;
180     }
181 
182     template&lt;class U&gt;
<span class="line-modified">183     T* exchange(U&amp;&amp; newValue)</span>
184     {
<span class="line-modified">185         T* oldValue = get();</span>
186         set(std::forward&lt;U&gt;(newValue));
187         return oldValue;
188     }
189 
190     void swap(std::nullptr_t) { clear(); }
191 
192     void swap(PackedAlignedPtr&amp; other)
193     {
194         m_storage.swap(other.m_storage);
195     }
196 
197     template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
198     void swap(Other&amp; other)
199     {
<span class="line-modified">200         T* t1 = get();</span>
<span class="line-modified">201         T* t2 = other.get();</span>
202         set(t2);
203         other.set(t1);
204     }
205 
<span class="line-modified">206     void swap(T* t2)</span>
207     {
<span class="line-modified">208         T* t1 = get();</span>
209         std::swap(t1, t2);
210         set(t1);
211     }
212 
213 private:
214     std::array&lt;uint8_t, storageSize&gt; m_storage;
215 };
216 
217 template&lt;typename T&gt;
218 class Packed&lt;T*&gt; : public PackedAlignedPtr&lt;T, 1&gt; {
219 public:
220     using Base = PackedAlignedPtr&lt;T, 1&gt;;
221     using Base::Base;
<span class="line-added">222 </span>
<span class="line-added">223     // Hash table deleted values, which are only constructed and never copied or destroyed.</span>
<span class="line-added">224     Packed(HashTableDeletedValueType) : Base(bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment))) { }</span>
<span class="line-added">225     bool isHashTableDeletedValue() const { return Base::get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment)); }</span>
226 };
227 
228 template&lt;typename T&gt;
229 using PackedPtr = Packed&lt;T*&gt;;
230 
<span class="line-added">231 template &lt;typename T&gt;</span>
<span class="line-added">232 struct GetPtrHelper&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">233     using PtrType = T*;</span>
<span class="line-added">234     static T* getPtr(const PackedPtr&lt;T&gt;&amp; p) { return const_cast&lt;T*&gt;(p.get()); }</span>
<span class="line-added">235 };</span>
<span class="line-added">236 </span>
<span class="line-added">237 template &lt;typename T&gt;</span>
<span class="line-added">238 struct IsSmartPtr&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">239     static constexpr bool value = true;</span>
<span class="line-added">240 };</span>
<span class="line-added">241 </span>
242 template&lt;typename T&gt;
243 struct PackedPtrTraits {
244     template&lt;typename U&gt; using RebindTraits = PackedPtrTraits&lt;U&gt;;
245 
246     using StorageType = PackedPtr&lt;T&gt;;
247 
248     template&lt;class U&gt; static ALWAYS_INLINE T* exchange(StorageType&amp; ptr, U&amp;&amp; newValue) { return ptr.exchange(newValue); }
249 
250     template&lt;typename Other&gt; static ALWAYS_INLINE void swap(PackedPtr&lt;T&gt;&amp; a, Other&amp; b) { a.swap(b); }
251 
252     static ALWAYS_INLINE T* unwrap(const StorageType&amp; ptr) { return ptr.get(); }
<span class="line-added">253 </span>
<span class="line-added">254     // We assume that,</span>
<span class="line-added">255     // 1. The alignment is &lt; 4KB. (It is tested by HashTraits).</span>
<span class="line-added">256     // 2. The first page (including nullptr) is never mapped.</span>
<span class="line-added">257     static StorageType hashTableDeletedValue() { return StorageType { bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)) }; }</span>
<span class="line-added">258     static ALWAYS_INLINE bool isHashTableDeletedValue(const StorageType&amp; ptr) { return ptr.get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)); }</span>
259 };
260 
<span class="line-added">261 template&lt;typename P&gt; struct DefaultHash&lt;PackedPtr&lt;P&gt;&gt; { using Hash = PtrHash&lt;PackedPtr&lt;P&gt;&gt;; };</span>
<span class="line-added">262 </span>
263 } // namespace WTF
264 
265 using WTF::Packed;
266 using WTF::PackedAlignedPtr;
267 using WTF::PackedPtr;
</pre>
</td>
</tr>
</table>
<center><a href="OptionSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
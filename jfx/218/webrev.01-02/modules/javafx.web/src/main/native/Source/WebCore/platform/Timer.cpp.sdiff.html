<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadTimers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserAgentQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;Timer.h&quot;
 29 
 30 #include &quot;RuntimeApplicationChecks.h&quot;
 31 #include &quot;SharedTimer.h&quot;
 32 #include &quot;ThreadGlobalData.h&quot;
 33 #include &quot;ThreadTimers.h&quot;
<span class="line-removed"> 34 #include &lt;limits.h&gt;</span>
 35 #include &lt;limits&gt;
 36 #include &lt;math.h&gt;
 37 #include &lt;wtf/MainThread.h&gt;
 38 #include &lt;wtf/Vector.h&gt;
 39 
<span class="line-modified"> 40 #if PLATFORM(IOS_FAMILY) || PLATFORM(MAC)</span>
 41 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 class TimerHeapReference;
 47 
 48 // Timers are stored in a heap data structure, used to implement a priority queue.
 49 // This allows us to efficiently determine which timer needs to fire the soonest.
 50 // Then we set a single shared system timer to fire at that time.
 51 //
 52 // When a timer&#39;s &quot;next fire time&quot; changes, we need to move it around in the priority queue.
<span class="line-modified"> 53 #if !ASSERT_DISABLED</span>
 54 static ThreadTimerHeap&amp; threadGlobalTimerHeap()
 55 {
 56     return threadGlobalData().threadTimers().timerHeap();
 57 }
 58 #endif
 59 
 60 inline ThreadTimerHeapItem::ThreadTimerHeapItem(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 61     : time(time)
 62     , insertionOrder(insertionOrder)
 63     , m_threadTimers(threadGlobalData().threadTimers())
 64     , m_timer(&amp;timer)
 65 {
 66     ASSERT(m_timer);
 67 }
 68 
 69 inline RefPtr&lt;ThreadTimerHeapItem&gt; ThreadTimerHeapItem::create(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 70 {
 71     return adoptRef(*new ThreadTimerHeapItem { timer, time, insertionOrder });
 72 }
 73 
</pre>
<hr />
<pre>
242 
243 // ----------------
244 
245 static bool shouldSuppressThreadSafetyCheck()
246 {
247 #if PLATFORM(IOS_FAMILY)
248     return WebThreadIsEnabled() || applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0;
249 #elif PLATFORM(MAC)
250     return !isInWebProcess() &amp;&amp; applicationSDKVersion() &lt; DYLD_MACOSX_VERSION_10_14;
251 #else
252     return false;
253 #endif
254 }
255 
256 TimerBase::TimerBase()
257 {
258 }
259 
260 TimerBase::~TimerBase()
261 {
<span class="line-modified">262     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
<span class="line-modified">263     RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());</span>
264     stop();
265     ASSERT(!inHeap());
266     if (m_heapItem)
267         m_heapItem-&gt;clearTimer();
268     m_unalignedNextFireTime = MonotonicTime::nan();
269 }
270 
271 void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
272 {
<span class="line-modified">273     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
274 
275     m_repeatInterval = repeatInterval;
276     setNextFireTime(MonotonicTime::now() + nextFireInterval);
277 }
278 
279 void TimerBase::stop()
280 {
<span class="line-modified">281     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
282 
283     m_repeatInterval = 0_s;
284     setNextFireTime(MonotonicTime { });
285 
286     ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
287     ASSERT(m_repeatInterval == 0_s);
288     ASSERT(!inHeap());
289 }
290 
291 Seconds TimerBase::nextFireInterval() const
292 {
293     ASSERT(isActive());
294     ASSERT(m_heapItem);
295     MonotonicTime current = MonotonicTime::now();
296     auto fireTime = nextFireTime();
297     if (fireTime &lt; current)
298         return 0_s;
299     return fireTime - current;
300 }
301 
302 inline void TimerBase::checkHeapIndex() const
303 {
<span class="line-modified">304 #if !ASSERT_DISABLED</span>
305     ASSERT(m_heapItem);
306     auto&amp; heap = m_heapItem-&gt;timerHeap();
307     ASSERT(&amp;heap == &amp;threadGlobalTimerHeap());
308     ASSERT(!heap.isEmpty());
309     ASSERT(m_heapItem-&gt;isInHeap());
310     ASSERT(m_heapItem-&gt;heapIndex() &lt; m_heapItem-&gt;timerHeap().size());
311     ASSERT(heap[m_heapItem-&gt;heapIndex()] == m_heapItem);
312     for (unsigned i = 0, size = heap.size(); i &lt; size; i++)
313         ASSERT(heap[i]-&gt;heapIndex() == i);
314 #endif
315 }
316 
317 inline void TimerBase::checkConsistency() const
318 {
319     // Timers should be in the heap if and only if they have a non-zero next fire time.
320     ASSERT(inHeap() == static_cast&lt;bool&gt;(nextFireTime()));
321     if (inHeap())
322         checkHeapIndex();
323 }
324 
</pre>
<hr />
<pre>
418     if (!inHeap())
419         return false;
420     // Check if the heap property still holds with the new fire time. If it does we don&#39;t need to do anything.
421     // This assumes that the STL heap is a standard binary heap. In an unlikely event it is not, the assertions
422     // in updateHeapIfNeeded() will get hit.
423     const auto&amp; heap = m_heapItem-&gt;timerHeap();
424     unsigned heapIndex = m_heapItem-&gt;heapIndex();
425     if (!parentHeapPropertyHolds(this, heap, heapIndex))
426         return false;
427     unsigned childIndex1 = 2 * heapIndex + 1;
428     unsigned childIndex2 = childIndex1 + 1;
429     return childHeapPropertyHolds(this, heap, childIndex1) &amp;&amp; childHeapPropertyHolds(this, heap, childIndex2);
430 }
431 
432 void TimerBase::updateHeapIfNeeded(MonotonicTime oldTime)
433 {
434     auto fireTime = nextFireTime();
435     if (fireTime &amp;&amp; hasValidHeapPosition())
436         return;
437 
<span class="line-modified">438 #if !ASSERT_DISABLED</span>
439     Optional&lt;unsigned&gt; oldHeapIndex;
440     if (m_heapItem-&gt;isInHeap())
441         oldHeapIndex = m_heapItem-&gt;heapIndex();
442 #endif
443 
444     if (!oldTime)
445         heapInsert();
446     else if (!fireTime)
447         heapDelete();
448     else if (fireTime &lt; oldTime)
449         heapDecreaseKey();
450     else
451         heapIncreaseKey();
452 
<span class="line-modified">453 #if !ASSERT_DISABLED</span>
454     Optional&lt;unsigned&gt; newHeapIndex;
455     if (m_heapItem-&gt;isInHeap())
456         newHeapIndex = m_heapItem-&gt;heapIndex();
457     ASSERT(newHeapIndex != oldHeapIndex);
458 #endif
459 
460     ASSERT(!inHeap() || hasValidHeapPosition());
461 }
462 
463 void TimerBase::setNextFireTime(MonotonicTime newTime)
464 {
<span class="line-modified">465     ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
<span class="line-modified">466     RELEASE_ASSERT(canAccessThreadLocalDataForThread(m_thread.get()) || shouldSuppressThreadSafetyCheck());</span>
467     bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
468     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
469 
470     if (m_unalignedNextFireTime != newTime) {
471         RELEASE_ASSERT(!std::isnan(newTime));
472         m_unalignedNextFireTime = newTime;
473     }
474 
475     // Keep heap valid while changing the next-fire time.
476     MonotonicTime oldTime = nextFireTime();
477     // Don&#39;t realign zero-delay timers.
478     if (newTime) {
479         if (auto newAlignedTime = alignedFireTime(newTime))
480             newTime = newAlignedTime.value();
481     }
482 
483     if (oldTime != newTime) {
<span class="line-modified">484         // FIXME: This should be part of ThreadTimers, or another per-thread structure.</span>
<span class="line-removed">485         static std::atomic&lt;unsigned&gt; currentHeapInsertionOrder;</span>
<span class="line-removed">486         auto newOrder = currentHeapInsertionOrder++;</span>
487 
488         if (!m_heapItem)
489             m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
490         m_heapItem-&gt;time = newTime;
491         m_heapItem-&gt;insertionOrder = newOrder;
492 
493         bool wasFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
494 
495         updateHeapIfNeeded(oldTime);
496 
497         bool isFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
498 
499         if (wasFirstTimerInHeap || isFirstTimerInHeap)
500             threadGlobalData().threadTimers().updateSharedTimer();
501     }
502 
503     checkConsistency();
504 }
505 
506 void TimerBase::fireTimersInNestedEventLoop()
</pre>
</td>
<td>
<hr />
<pre>
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;Timer.h&quot;
 29 
 30 #include &quot;RuntimeApplicationChecks.h&quot;
 31 #include &quot;SharedTimer.h&quot;
 32 #include &quot;ThreadGlobalData.h&quot;
 33 #include &quot;ThreadTimers.h&quot;

 34 #include &lt;limits&gt;
 35 #include &lt;math.h&gt;
 36 #include &lt;wtf/MainThread.h&gt;
 37 #include &lt;wtf/Vector.h&gt;
 38 
<span class="line-modified"> 39 #if PLATFORM(COCOA)</span>
 40 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 41 #endif
 42 
 43 namespace WebCore {
 44 
 45 class TimerHeapReference;
 46 
 47 // Timers are stored in a heap data structure, used to implement a priority queue.
 48 // This allows us to efficiently determine which timer needs to fire the soonest.
 49 // Then we set a single shared system timer to fire at that time.
 50 //
 51 // When a timer&#39;s &quot;next fire time&quot; changes, we need to move it around in the priority queue.
<span class="line-modified"> 52 #if ASSERT_ENABLED</span>
 53 static ThreadTimerHeap&amp; threadGlobalTimerHeap()
 54 {
 55     return threadGlobalData().threadTimers().timerHeap();
 56 }
 57 #endif
 58 
 59 inline ThreadTimerHeapItem::ThreadTimerHeapItem(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 60     : time(time)
 61     , insertionOrder(insertionOrder)
 62     , m_threadTimers(threadGlobalData().threadTimers())
 63     , m_timer(&amp;timer)
 64 {
 65     ASSERT(m_timer);
 66 }
 67 
 68 inline RefPtr&lt;ThreadTimerHeapItem&gt; ThreadTimerHeapItem::create(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 69 {
 70     return adoptRef(*new ThreadTimerHeapItem { timer, time, insertionOrder });
 71 }
 72 
</pre>
<hr />
<pre>
241 
242 // ----------------
243 
244 static bool shouldSuppressThreadSafetyCheck()
245 {
246 #if PLATFORM(IOS_FAMILY)
247     return WebThreadIsEnabled() || applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0;
248 #elif PLATFORM(MAC)
249     return !isInWebProcess() &amp;&amp; applicationSDKVersion() &lt; DYLD_MACOSX_VERSION_10_14;
250 #else
251     return false;
252 #endif
253 }
254 
255 TimerBase::TimerBase()
256 {
257 }
258 
259 TimerBase::~TimerBase()
260 {
<span class="line-modified">261     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
<span class="line-modified">262     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());</span>
263     stop();
264     ASSERT(!inHeap());
265     if (m_heapItem)
266         m_heapItem-&gt;clearTimer();
267     m_unalignedNextFireTime = MonotonicTime::nan();
268 }
269 
270 void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
271 {
<span class="line-modified">272     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
273 
274     m_repeatInterval = repeatInterval;
275     setNextFireTime(MonotonicTime::now() + nextFireInterval);
276 }
277 
278 void TimerBase::stop()
279 {
<span class="line-modified">280     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
281 
282     m_repeatInterval = 0_s;
283     setNextFireTime(MonotonicTime { });
284 
285     ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
286     ASSERT(m_repeatInterval == 0_s);
287     ASSERT(!inHeap());
288 }
289 
290 Seconds TimerBase::nextFireInterval() const
291 {
292     ASSERT(isActive());
293     ASSERT(m_heapItem);
294     MonotonicTime current = MonotonicTime::now();
295     auto fireTime = nextFireTime();
296     if (fireTime &lt; current)
297         return 0_s;
298     return fireTime - current;
299 }
300 
301 inline void TimerBase::checkHeapIndex() const
302 {
<span class="line-modified">303 #if ASSERT_ENABLED</span>
304     ASSERT(m_heapItem);
305     auto&amp; heap = m_heapItem-&gt;timerHeap();
306     ASSERT(&amp;heap == &amp;threadGlobalTimerHeap());
307     ASSERT(!heap.isEmpty());
308     ASSERT(m_heapItem-&gt;isInHeap());
309     ASSERT(m_heapItem-&gt;heapIndex() &lt; m_heapItem-&gt;timerHeap().size());
310     ASSERT(heap[m_heapItem-&gt;heapIndex()] == m_heapItem);
311     for (unsigned i = 0, size = heap.size(); i &lt; size; i++)
312         ASSERT(heap[i]-&gt;heapIndex() == i);
313 #endif
314 }
315 
316 inline void TimerBase::checkConsistency() const
317 {
318     // Timers should be in the heap if and only if they have a non-zero next fire time.
319     ASSERT(inHeap() == static_cast&lt;bool&gt;(nextFireTime()));
320     if (inHeap())
321         checkHeapIndex();
322 }
323 
</pre>
<hr />
<pre>
417     if (!inHeap())
418         return false;
419     // Check if the heap property still holds with the new fire time. If it does we don&#39;t need to do anything.
420     // This assumes that the STL heap is a standard binary heap. In an unlikely event it is not, the assertions
421     // in updateHeapIfNeeded() will get hit.
422     const auto&amp; heap = m_heapItem-&gt;timerHeap();
423     unsigned heapIndex = m_heapItem-&gt;heapIndex();
424     if (!parentHeapPropertyHolds(this, heap, heapIndex))
425         return false;
426     unsigned childIndex1 = 2 * heapIndex + 1;
427     unsigned childIndex2 = childIndex1 + 1;
428     return childHeapPropertyHolds(this, heap, childIndex1) &amp;&amp; childHeapPropertyHolds(this, heap, childIndex2);
429 }
430 
431 void TimerBase::updateHeapIfNeeded(MonotonicTime oldTime)
432 {
433     auto fireTime = nextFireTime();
434     if (fireTime &amp;&amp; hasValidHeapPosition())
435         return;
436 
<span class="line-modified">437 #if ASSERT_ENABLED</span>
438     Optional&lt;unsigned&gt; oldHeapIndex;
439     if (m_heapItem-&gt;isInHeap())
440         oldHeapIndex = m_heapItem-&gt;heapIndex();
441 #endif
442 
443     if (!oldTime)
444         heapInsert();
445     else if (!fireTime)
446         heapDelete();
447     else if (fireTime &lt; oldTime)
448         heapDecreaseKey();
449     else
450         heapIncreaseKey();
451 
<span class="line-modified">452 #if ASSERT_ENABLED</span>
453     Optional&lt;unsigned&gt; newHeapIndex;
454     if (m_heapItem-&gt;isInHeap())
455         newHeapIndex = m_heapItem-&gt;heapIndex();
456     ASSERT(newHeapIndex != oldHeapIndex);
457 #endif
458 
459     ASSERT(!inHeap() || hasValidHeapPosition());
460 }
461 
462 void TimerBase::setNextFireTime(MonotonicTime newTime)
463 {
<span class="line-modified">464     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
<span class="line-modified">465     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());</span>
466     bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
467     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
468 
469     if (m_unalignedNextFireTime != newTime) {
470         RELEASE_ASSERT(!std::isnan(newTime));
471         m_unalignedNextFireTime = newTime;
472     }
473 
474     // Keep heap valid while changing the next-fire time.
475     MonotonicTime oldTime = nextFireTime();
476     // Don&#39;t realign zero-delay timers.
477     if (newTime) {
478         if (auto newAlignedTime = alignedFireTime(newTime))
479             newTime = newAlignedTime.value();
480     }
481 
482     if (oldTime != newTime) {
<span class="line-modified">483         auto newOrder = threadGlobalData().threadTimers().nextHeapInsertionCount();</span>


484 
485         if (!m_heapItem)
486             m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
487         m_heapItem-&gt;time = newTime;
488         m_heapItem-&gt;insertionOrder = newOrder;
489 
490         bool wasFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
491 
492         updateHeapIfNeeded(oldTime);
493 
494         bool isFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
495 
496         if (wasFirstTimerInHeap || isFirstTimerInHeap)
497             threadGlobalData().threadTimers().updateSharedTimer();
498     }
499 
500     checkConsistency();
501 }
502 
503 void TimerBase::fireTimersInNestedEventLoop()
</pre>
</td>
</tr>
</table>
<center><a href="ThreadTimers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserAgentQuirks.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
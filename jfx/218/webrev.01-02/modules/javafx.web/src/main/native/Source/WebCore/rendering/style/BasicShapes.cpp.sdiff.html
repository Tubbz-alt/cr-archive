<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../shapes/ShapeOutsideInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicShapes.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/BasicShapes.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
<span class="line-removed"> 31 </span>
 32 #include &quot;BasicShapes.h&quot;
 33 
 34 #include &quot;BasicShapeFunctions.h&quot;
 35 #include &quot;CalculationValue.h&quot;
 36 #include &quot;FloatRect.h&quot;
 37 #include &quot;FloatRoundedRect.h&quot;
 38 #include &quot;LengthFunctions.h&quot;
 39 #include &quot;Path.h&quot;
 40 #include &quot;RenderBox.h&quot;
 41 #include &quot;SVGPathByteStream.h&quot;
 42 #include &quot;SVGPathUtilities.h&quot;
<span class="line-modified"> 43 </span>
 44 #include &lt;wtf/NeverDestroyed.h&gt;
 45 #include &lt;wtf/TinyLRUCache.h&gt;

 46 
 47 namespace WebCore {
 48 
 49 void BasicShapeCenterCoordinate::updateComputedLength()
 50 {
 51     if (m_direction == TopLeft) {
 52         m_computedLength = m_length.isUndefined() ? Length(0, Fixed) : m_length;
 53         return;
 54     }
 55 
 56     if (m_length.isUndefined()) {
 57         m_computedLength = Length(100, Percent);
 58         return;
 59     }
 60 
 61     m_computedLength = convertTo100PercentMinusLength(m_length);
 62 }
 63 
 64 struct SVGPathTranslatedByteStream {
 65     SVGPathTranslatedByteStream(const FloatPoint&amp; offset, const SVGPathByteStream&amp; rawStream)
</pre>
<hr />
<pre>
141 static const Path&amp; cachedTranslatedByteStreamPath(const SVGPathByteStream&amp; stream, const FloatPoint&amp; offset)
142 {
143     static NeverDestroyed&lt;TinyLRUCache&lt;SVGPathTranslatedByteStream, Path, 4, TranslatedByteStreamPathPolicy&gt;&gt; cache;
144     return cache.get().get(SVGPathTranslatedByteStream(offset, stream));
145 }
146 
147 bool BasicShapeCircle::operator==(const BasicShape&amp; other) const
148 {
149     if (type() != other.type())
150         return false;
151 
152     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
153     return m_centerX == otherCircle.m_centerX
154         &amp;&amp; m_centerY == otherCircle.m_centerY
155         &amp;&amp; m_radius == otherCircle.m_radius;
156 }
157 
158 float BasicShapeCircle::floatValueForRadiusInBox(float boxWidth, float boxHeight) const
159 {
160     if (m_radius.type() == BasicShapeRadius::Value)
<span class="line-modified">161         return floatValueForLength(m_radius.value(), sqrtf((boxWidth * boxWidth + boxHeight * boxHeight) / 2));</span>
162 
163     float centerX = floatValueForCenterCoordinate(m_centerX, boxWidth);
164     float centerY = floatValueForCenterCoordinate(m_centerY, boxHeight);
165 
166     float widthDelta = std::abs(boxWidth - centerX);
167     float heightDelta = std::abs(boxHeight - centerY);
168     if (m_radius.type() == BasicShapeRadius::ClosestSide)
169         return std::min(std::min(std::abs(centerX), widthDelta), std::min(std::abs(centerY), heightDelta));
170 
171     // If radius.type() == BasicShapeRadius::FarthestSide.
172     return std::max(std::max(std::abs(centerX), widthDelta), std::max(std::abs(centerY), heightDelta));
173 }
174 
175 const Path&amp; BasicShapeCircle::path(const FloatRect&amp; boundingBox)
176 {
177     float centerX = floatValueForCenterCoordinate(m_centerX, boundingBox.width());
178     float centerY = floatValueForCenterCoordinate(m_centerY, boundingBox.height());
179     float radius = floatValueForRadiusInBox(boundingBox.width(), boundingBox.height());
180 
181     return cachedEllipsePath(FloatRect(centerX - radius + boundingBox.x(), centerY - radius + boundingBox.y(), radius * 2, radius * 2));
</pre>
<hr />
<pre>
184 bool BasicShapeCircle::canBlend(const BasicShape&amp; other) const
185 {
186     if (type() != other.type())
187         return false;
188 
189     return radius().canBlend(downcast&lt;BasicShapeCircle&gt;(other).radius());
190 }
191 
192 Ref&lt;BasicShape&gt; BasicShapeCircle::blend(const BasicShape&amp; other, double progress) const
193 {
194     ASSERT(type() == other.type());
195     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
196     auto result =  BasicShapeCircle::create();
197 
198     result-&gt;setCenterX(m_centerX.blend(otherCircle.centerX(), progress));
199     result-&gt;setCenterY(m_centerY.blend(otherCircle.centerY(), progress));
200     result-&gt;setRadius(m_radius.blend(otherCircle.radius(), progress));
201     return result;
202 }
203 







204 bool BasicShapeEllipse::operator==(const BasicShape&amp; other) const
205 {
206     if (type() != other.type())
207         return false;
208 
209     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
210     return m_centerX == otherEllipse.m_centerX
211         &amp;&amp; m_centerY == otherEllipse.m_centerY
212         &amp;&amp; m_radiusX == otherEllipse.m_radiusX
213         &amp;&amp; m_radiusY == otherEllipse.m_radiusY;
214 }
215 
216 float BasicShapeEllipse::floatValueForRadiusInBox(const BasicShapeRadius&amp; radius, float center, float boxWidthOrHeight) const
217 {
218     if (radius.type() == BasicShapeRadius::Value)
219         return floatValueForLength(radius.value(), std::abs(boxWidthOrHeight));
220 
221     float widthOrHeightDelta = std::abs(boxWidthOrHeight - center);
222     if (radius.type() == BasicShapeRadius::ClosestSide)
223         return std::min(std::abs(center), widthOrHeightDelta);
</pre>
<hr />
<pre>
250     ASSERT(type() == other.type());
251     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
252     auto result = BasicShapeEllipse::create();
253 
254     if (m_radiusX.type() != BasicShapeRadius::Value || otherEllipse.radiusX().type() != BasicShapeRadius::Value
255         || m_radiusY.type() != BasicShapeRadius::Value || otherEllipse.radiusY().type() != BasicShapeRadius::Value) {
256         result-&gt;setCenterX(otherEllipse.centerX());
257         result-&gt;setCenterY(otherEllipse.centerY());
258         result-&gt;setRadiusX(otherEllipse.radiusX());
259         result-&gt;setRadiusY(otherEllipse.radiusY());
260         return result;
261     }
262 
263     result-&gt;setCenterX(m_centerX.blend(otherEllipse.centerX(), progress));
264     result-&gt;setCenterY(m_centerY.blend(otherEllipse.centerY(), progress));
265     result-&gt;setRadiusX(m_radiusX.blend(otherEllipse.radiusX(), progress));
266     result-&gt;setRadiusY(m_radiusY.blend(otherEllipse.radiusY(), progress));
267     return result;
268 }
269 








270 bool BasicShapePolygon::operator==(const BasicShape&amp; other) const
271 {
272     if (type() != other.type())
273         return false;
274 
275     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
276     return m_windRule == otherPolygon.m_windRule
277         &amp;&amp; m_values == otherPolygon.m_values;
278 }
279 
280 const Path&amp; BasicShapePolygon::path(const FloatRect&amp; boundingBox)
281 {
282     ASSERT(!(m_values.size() % 2));
283     size_t length = m_values.size();
284 
285     Vector&lt;FloatPoint&gt; points(length / 2);
286     for (size_t i = 0; i &lt; points.size(); ++i) {
287         points[i].setX(floatValueForLength(m_values.at(i * 2), boundingBox.width()) + boundingBox.x());
288         points[i].setY(floatValueForLength(m_values.at(i * 2 + 1), boundingBox.height()) + boundingBox.y());
289     }
</pre>
<hr />
<pre>
307     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
308     ASSERT(m_values.size() == otherPolygon.values().size());
309     ASSERT(!(m_values.size() % 2));
310 
311     size_t length = m_values.size();
312     auto result = BasicShapePolygon::create();
313     if (!length)
314         return result;
315 
316     result-&gt;setWindRule(otherPolygon.windRule());
317 
318     for (size_t i = 0; i &lt; length; i = i + 2) {
319         result-&gt;appendPoint(
320             WebCore::blend(otherPolygon.values().at(i), m_values.at(i), progress),
321             WebCore::blend(otherPolygon.values().at(i + 1), m_values.at(i + 1), progress));
322     }
323 
324     return result;
325 }
326 






327 BasicShapePath::BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
328     : m_byteStream(WTFMove(byteStream))
329 {
330 }
331 
332 const Path&amp; BasicShapePath::path(const FloatRect&amp; boundingBox)
333 {
334     return cachedTranslatedByteStreamPath(*m_byteStream, boundingBox.location());
335 }
336 
337 bool BasicShapePath::operator==(const BasicShape&amp; other) const
338 {
339     if (type() != other.type())
340         return false;
341 
342     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
343     return m_windRule == otherPath.m_windRule &amp;&amp; *m_byteStream == *otherPath.m_byteStream;
344 }
345 
346 bool BasicShapePath::canBlend(const BasicShape&amp; other) const
</pre>
<hr />
<pre>
349         return false;
350 
351     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
352     return windRule() == otherPath.windRule() &amp;&amp; canBlendSVGPathByteStreams(*m_byteStream, *otherPath.pathData());
353 }
354 
355 Ref&lt;BasicShape&gt; BasicShapePath::blend(const BasicShape&amp; from, double progress) const
356 {
357     ASSERT(type() == from.type());
358 
359     auto&amp; fromPath = downcast&lt;BasicShapePath&gt;(from);
360 
361     auto resultingPathBytes = makeUnique&lt;SVGPathByteStream&gt;();
362     buildAnimatedSVGPathByteStream(*fromPath.m_byteStream, *m_byteStream, *resultingPathBytes, progress);
363 
364     auto result = BasicShapePath::create(WTFMove(resultingPathBytes));
365     result-&gt;setWindRule(windRule());
366     return result;
367 }
368 






369 bool BasicShapeInset::operator==(const BasicShape&amp; other) const
370 {
371     if (type() != other.type())
372         return false;
373 
374     auto&amp; otherInset = downcast&lt;BasicShapeInset&gt;(other);
375     return m_right == otherInset.m_right
376         &amp;&amp; m_top == otherInset.m_top
377         &amp;&amp; m_bottom == otherInset.m_bottom
378         &amp;&amp; m_left == otherInset.m_left
379         &amp;&amp; m_topLeftRadius == otherInset.m_topLeftRadius
380         &amp;&amp; m_topRightRadius == otherInset.m_topRightRadius
381         &amp;&amp; m_bottomRightRadius == otherInset.m_bottomRightRadius
382         &amp;&amp; m_bottomLeftRadius == otherInset.m_bottomLeftRadius;
383 }
384 
385 static FloatSize floatSizeForLengthSize(const LengthSize&amp; lengthSize, const FloatRect&amp; boundingBox)
386 {
387     return { floatValueForLength(lengthSize.width, boundingBox.width()),
388         floatValueForLength(lengthSize.height, boundingBox.height()) };
</pre>
<hr />
<pre>
410 }
411 
412 Ref&lt;BasicShape&gt; BasicShapeInset::blend(const BasicShape&amp; from, double progress) const
413 {
414     ASSERT(type() == from.type());
415 
416     auto&amp; fromInset = downcast&lt;BasicShapeInset&gt;(from);
417     auto result =  BasicShapeInset::create();
418     result-&gt;setTop(WebCore::blend(fromInset.top(), top(), progress));
419     result-&gt;setRight(WebCore::blend(fromInset.right(), right(), progress));
420     result-&gt;setBottom(WebCore::blend(fromInset.bottom(), bottom(), progress));
421     result-&gt;setLeft(WebCore::blend(fromInset.left(), left(), progress));
422 
423     result-&gt;setTopLeftRadius(WebCore::blend(fromInset.topLeftRadius(), topLeftRadius(), progress));
424     result-&gt;setTopRightRadius(WebCore::blend(fromInset.topRightRadius(), topRightRadius(), progress));
425     result-&gt;setBottomRightRadius(WebCore::blend(fromInset.bottomRightRadius(), bottomRightRadius(), progress));
426     result-&gt;setBottomLeftRadius(WebCore::blend(fromInset.bottomLeftRadius(), bottomLeftRadius(), progress));
427 
428     return result;
429 }





























430 }















</pre>
</td>
<td>
<hr />
<pre>
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER &quot;AS IS&quot; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 27  * SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;

 31 #include &quot;BasicShapes.h&quot;
 32 
 33 #include &quot;BasicShapeFunctions.h&quot;
 34 #include &quot;CalculationValue.h&quot;
 35 #include &quot;FloatRect.h&quot;
 36 #include &quot;FloatRoundedRect.h&quot;
 37 #include &quot;LengthFunctions.h&quot;
 38 #include &quot;Path.h&quot;
 39 #include &quot;RenderBox.h&quot;
 40 #include &quot;SVGPathByteStream.h&quot;
 41 #include &quot;SVGPathUtilities.h&quot;
<span class="line-modified"> 42 #include &lt;wtf/MathExtras.h&gt;</span>
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/TinyLRUCache.h&gt;
<span class="line-added"> 45 #include &lt;wtf/text/TextStream.h&gt;</span>
 46 
 47 namespace WebCore {
 48 
 49 void BasicShapeCenterCoordinate::updateComputedLength()
 50 {
 51     if (m_direction == TopLeft) {
 52         m_computedLength = m_length.isUndefined() ? Length(0, Fixed) : m_length;
 53         return;
 54     }
 55 
 56     if (m_length.isUndefined()) {
 57         m_computedLength = Length(100, Percent);
 58         return;
 59     }
 60 
 61     m_computedLength = convertTo100PercentMinusLength(m_length);
 62 }
 63 
 64 struct SVGPathTranslatedByteStream {
 65     SVGPathTranslatedByteStream(const FloatPoint&amp; offset, const SVGPathByteStream&amp; rawStream)
</pre>
<hr />
<pre>
141 static const Path&amp; cachedTranslatedByteStreamPath(const SVGPathByteStream&amp; stream, const FloatPoint&amp; offset)
142 {
143     static NeverDestroyed&lt;TinyLRUCache&lt;SVGPathTranslatedByteStream, Path, 4, TranslatedByteStreamPathPolicy&gt;&gt; cache;
144     return cache.get().get(SVGPathTranslatedByteStream(offset, stream));
145 }
146 
147 bool BasicShapeCircle::operator==(const BasicShape&amp; other) const
148 {
149     if (type() != other.type())
150         return false;
151 
152     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
153     return m_centerX == otherCircle.m_centerX
154         &amp;&amp; m_centerY == otherCircle.m_centerY
155         &amp;&amp; m_radius == otherCircle.m_radius;
156 }
157 
158 float BasicShapeCircle::floatValueForRadiusInBox(float boxWidth, float boxHeight) const
159 {
160     if (m_radius.type() == BasicShapeRadius::Value)
<span class="line-modified">161         return floatValueForLength(m_radius.value(), std::hypot(boxWidth, boxHeight) / sqrtOfTwoFloat);</span>
162 
163     float centerX = floatValueForCenterCoordinate(m_centerX, boxWidth);
164     float centerY = floatValueForCenterCoordinate(m_centerY, boxHeight);
165 
166     float widthDelta = std::abs(boxWidth - centerX);
167     float heightDelta = std::abs(boxHeight - centerY);
168     if (m_radius.type() == BasicShapeRadius::ClosestSide)
169         return std::min(std::min(std::abs(centerX), widthDelta), std::min(std::abs(centerY), heightDelta));
170 
171     // If radius.type() == BasicShapeRadius::FarthestSide.
172     return std::max(std::max(std::abs(centerX), widthDelta), std::max(std::abs(centerY), heightDelta));
173 }
174 
175 const Path&amp; BasicShapeCircle::path(const FloatRect&amp; boundingBox)
176 {
177     float centerX = floatValueForCenterCoordinate(m_centerX, boundingBox.width());
178     float centerY = floatValueForCenterCoordinate(m_centerY, boundingBox.height());
179     float radius = floatValueForRadiusInBox(boundingBox.width(), boundingBox.height());
180 
181     return cachedEllipsePath(FloatRect(centerX - radius + boundingBox.x(), centerY - radius + boundingBox.y(), radius * 2, radius * 2));
</pre>
<hr />
<pre>
184 bool BasicShapeCircle::canBlend(const BasicShape&amp; other) const
185 {
186     if (type() != other.type())
187         return false;
188 
189     return radius().canBlend(downcast&lt;BasicShapeCircle&gt;(other).radius());
190 }
191 
192 Ref&lt;BasicShape&gt; BasicShapeCircle::blend(const BasicShape&amp; other, double progress) const
193 {
194     ASSERT(type() == other.type());
195     auto&amp; otherCircle = downcast&lt;BasicShapeCircle&gt;(other);
196     auto result =  BasicShapeCircle::create();
197 
198     result-&gt;setCenterX(m_centerX.blend(otherCircle.centerX(), progress));
199     result-&gt;setCenterY(m_centerY.blend(otherCircle.centerY(), progress));
200     result-&gt;setRadius(m_radius.blend(otherCircle.radius(), progress));
201     return result;
202 }
203 
<span class="line-added">204 void BasicShapeCircle::dump(TextStream&amp; ts) const</span>
<span class="line-added">205 {</span>
<span class="line-added">206     ts.dumpProperty(&quot;center-x&quot;, centerX());</span>
<span class="line-added">207     ts.dumpProperty(&quot;center-y&quot;, centerY());</span>
<span class="line-added">208     ts.dumpProperty(&quot;radius&quot;, radius());</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
211 bool BasicShapeEllipse::operator==(const BasicShape&amp; other) const
212 {
213     if (type() != other.type())
214         return false;
215 
216     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
217     return m_centerX == otherEllipse.m_centerX
218         &amp;&amp; m_centerY == otherEllipse.m_centerY
219         &amp;&amp; m_radiusX == otherEllipse.m_radiusX
220         &amp;&amp; m_radiusY == otherEllipse.m_radiusY;
221 }
222 
223 float BasicShapeEllipse::floatValueForRadiusInBox(const BasicShapeRadius&amp; radius, float center, float boxWidthOrHeight) const
224 {
225     if (radius.type() == BasicShapeRadius::Value)
226         return floatValueForLength(radius.value(), std::abs(boxWidthOrHeight));
227 
228     float widthOrHeightDelta = std::abs(boxWidthOrHeight - center);
229     if (radius.type() == BasicShapeRadius::ClosestSide)
230         return std::min(std::abs(center), widthOrHeightDelta);
</pre>
<hr />
<pre>
257     ASSERT(type() == other.type());
258     auto&amp; otherEllipse = downcast&lt;BasicShapeEllipse&gt;(other);
259     auto result = BasicShapeEllipse::create();
260 
261     if (m_radiusX.type() != BasicShapeRadius::Value || otherEllipse.radiusX().type() != BasicShapeRadius::Value
262         || m_radiusY.type() != BasicShapeRadius::Value || otherEllipse.radiusY().type() != BasicShapeRadius::Value) {
263         result-&gt;setCenterX(otherEllipse.centerX());
264         result-&gt;setCenterY(otherEllipse.centerY());
265         result-&gt;setRadiusX(otherEllipse.radiusX());
266         result-&gt;setRadiusY(otherEllipse.radiusY());
267         return result;
268     }
269 
270     result-&gt;setCenterX(m_centerX.blend(otherEllipse.centerX(), progress));
271     result-&gt;setCenterY(m_centerY.blend(otherEllipse.centerY(), progress));
272     result-&gt;setRadiusX(m_radiusX.blend(otherEllipse.radiusX(), progress));
273     result-&gt;setRadiusY(m_radiusY.blend(otherEllipse.radiusY(), progress));
274     return result;
275 }
276 
<span class="line-added">277 void BasicShapeEllipse::dump(TextStream&amp; ts) const</span>
<span class="line-added">278 {</span>
<span class="line-added">279     ts.dumpProperty(&quot;center-x&quot;, centerX());</span>
<span class="line-added">280     ts.dumpProperty(&quot;center-y&quot;, centerY());</span>
<span class="line-added">281     ts.dumpProperty(&quot;radius-x&quot;, radiusX());</span>
<span class="line-added">282     ts.dumpProperty(&quot;radius-y&quot;, radiusY());</span>
<span class="line-added">283 }</span>
<span class="line-added">284 </span>
285 bool BasicShapePolygon::operator==(const BasicShape&amp; other) const
286 {
287     if (type() != other.type())
288         return false;
289 
290     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
291     return m_windRule == otherPolygon.m_windRule
292         &amp;&amp; m_values == otherPolygon.m_values;
293 }
294 
295 const Path&amp; BasicShapePolygon::path(const FloatRect&amp; boundingBox)
296 {
297     ASSERT(!(m_values.size() % 2));
298     size_t length = m_values.size();
299 
300     Vector&lt;FloatPoint&gt; points(length / 2);
301     for (size_t i = 0; i &lt; points.size(); ++i) {
302         points[i].setX(floatValueForLength(m_values.at(i * 2), boundingBox.width()) + boundingBox.x());
303         points[i].setY(floatValueForLength(m_values.at(i * 2 + 1), boundingBox.height()) + boundingBox.y());
304     }
</pre>
<hr />
<pre>
322     auto&amp; otherPolygon = downcast&lt;BasicShapePolygon&gt;(other);
323     ASSERT(m_values.size() == otherPolygon.values().size());
324     ASSERT(!(m_values.size() % 2));
325 
326     size_t length = m_values.size();
327     auto result = BasicShapePolygon::create();
328     if (!length)
329         return result;
330 
331     result-&gt;setWindRule(otherPolygon.windRule());
332 
333     for (size_t i = 0; i &lt; length; i = i + 2) {
334         result-&gt;appendPoint(
335             WebCore::blend(otherPolygon.values().at(i), m_values.at(i), progress),
336             WebCore::blend(otherPolygon.values().at(i + 1), m_values.at(i + 1), progress));
337     }
338 
339     return result;
340 }
341 
<span class="line-added">342 void BasicShapePolygon::dump(TextStream&amp; ts) const</span>
<span class="line-added">343 {</span>
<span class="line-added">344     ts.dumpProperty(&quot;wind-rule&quot;, windRule());</span>
<span class="line-added">345     ts.dumpProperty(&quot;path&quot;, values());</span>
<span class="line-added">346 }</span>
<span class="line-added">347 </span>
348 BasicShapePath::BasicShapePath(std::unique_ptr&lt;SVGPathByteStream&gt;&amp;&amp; byteStream)
349     : m_byteStream(WTFMove(byteStream))
350 {
351 }
352 
353 const Path&amp; BasicShapePath::path(const FloatRect&amp; boundingBox)
354 {
355     return cachedTranslatedByteStreamPath(*m_byteStream, boundingBox.location());
356 }
357 
358 bool BasicShapePath::operator==(const BasicShape&amp; other) const
359 {
360     if (type() != other.type())
361         return false;
362 
363     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
364     return m_windRule == otherPath.m_windRule &amp;&amp; *m_byteStream == *otherPath.m_byteStream;
365 }
366 
367 bool BasicShapePath::canBlend(const BasicShape&amp; other) const
</pre>
<hr />
<pre>
370         return false;
371 
372     auto&amp; otherPath = downcast&lt;BasicShapePath&gt;(other);
373     return windRule() == otherPath.windRule() &amp;&amp; canBlendSVGPathByteStreams(*m_byteStream, *otherPath.pathData());
374 }
375 
376 Ref&lt;BasicShape&gt; BasicShapePath::blend(const BasicShape&amp; from, double progress) const
377 {
378     ASSERT(type() == from.type());
379 
380     auto&amp; fromPath = downcast&lt;BasicShapePath&gt;(from);
381 
382     auto resultingPathBytes = makeUnique&lt;SVGPathByteStream&gt;();
383     buildAnimatedSVGPathByteStream(*fromPath.m_byteStream, *m_byteStream, *resultingPathBytes, progress);
384 
385     auto result = BasicShapePath::create(WTFMove(resultingPathBytes));
386     result-&gt;setWindRule(windRule());
387     return result;
388 }
389 
<span class="line-added">390 void BasicShapePath::dump(TextStream&amp; ts) const</span>
<span class="line-added">391 {</span>
<span class="line-added">392     ts.dumpProperty(&quot;wind-rule&quot;, windRule());</span>
<span class="line-added">393     // FIXME: print the byte stream?</span>
<span class="line-added">394 }</span>
<span class="line-added">395 </span>
396 bool BasicShapeInset::operator==(const BasicShape&amp; other) const
397 {
398     if (type() != other.type())
399         return false;
400 
401     auto&amp; otherInset = downcast&lt;BasicShapeInset&gt;(other);
402     return m_right == otherInset.m_right
403         &amp;&amp; m_top == otherInset.m_top
404         &amp;&amp; m_bottom == otherInset.m_bottom
405         &amp;&amp; m_left == otherInset.m_left
406         &amp;&amp; m_topLeftRadius == otherInset.m_topLeftRadius
407         &amp;&amp; m_topRightRadius == otherInset.m_topRightRadius
408         &amp;&amp; m_bottomRightRadius == otherInset.m_bottomRightRadius
409         &amp;&amp; m_bottomLeftRadius == otherInset.m_bottomLeftRadius;
410 }
411 
412 static FloatSize floatSizeForLengthSize(const LengthSize&amp; lengthSize, const FloatRect&amp; boundingBox)
413 {
414     return { floatValueForLength(lengthSize.width, boundingBox.width()),
415         floatValueForLength(lengthSize.height, boundingBox.height()) };
</pre>
<hr />
<pre>
437 }
438 
439 Ref&lt;BasicShape&gt; BasicShapeInset::blend(const BasicShape&amp; from, double progress) const
440 {
441     ASSERT(type() == from.type());
442 
443     auto&amp; fromInset = downcast&lt;BasicShapeInset&gt;(from);
444     auto result =  BasicShapeInset::create();
445     result-&gt;setTop(WebCore::blend(fromInset.top(), top(), progress));
446     result-&gt;setRight(WebCore::blend(fromInset.right(), right(), progress));
447     result-&gt;setBottom(WebCore::blend(fromInset.bottom(), bottom(), progress));
448     result-&gt;setLeft(WebCore::blend(fromInset.left(), left(), progress));
449 
450     result-&gt;setTopLeftRadius(WebCore::blend(fromInset.topLeftRadius(), topLeftRadius(), progress));
451     result-&gt;setTopRightRadius(WebCore::blend(fromInset.topRightRadius(), topRightRadius(), progress));
452     result-&gt;setBottomRightRadius(WebCore::blend(fromInset.bottomRightRadius(), bottomRightRadius(), progress));
453     result-&gt;setBottomLeftRadius(WebCore::blend(fromInset.bottomLeftRadius(), bottomLeftRadius(), progress));
454 
455     return result;
456 }
<span class="line-added">457 </span>
<span class="line-added">458 void BasicShapeInset::dump(TextStream&amp; ts) const</span>
<span class="line-added">459 {</span>
<span class="line-added">460     ts.dumpProperty(&quot;top&quot;, top());</span>
<span class="line-added">461     ts.dumpProperty(&quot;right&quot;, right());</span>
<span class="line-added">462     ts.dumpProperty(&quot;bottom&quot;, bottom());</span>
<span class="line-added">463     ts.dumpProperty(&quot;left&quot;, left());</span>
<span class="line-added">464 </span>
<span class="line-added">465     ts.dumpProperty(&quot;top-left-radius&quot;, topLeftRadius());</span>
<span class="line-added">466     ts.dumpProperty(&quot;top-right-radius&quot;, topRightRadius());</span>
<span class="line-added">467     ts.dumpProperty(&quot;bottom-right-radius&quot;, bottomRightRadius());</span>
<span class="line-added">468     ts.dumpProperty(&quot;bottom-left-radius&quot;, bottomLeftRadius());</span>
<span class="line-added">469 }</span>
<span class="line-added">470 </span>
<span class="line-added">471 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, BasicShapeRadius::Type radiusType)</span>
<span class="line-added">472 {</span>
<span class="line-added">473     switch (radiusType) {</span>
<span class="line-added">474     case BasicShapeRadius::Value: ts &lt;&lt; &quot;value&quot;; break;</span>
<span class="line-added">475     case BasicShapeRadius::ClosestSide: ts &lt;&lt; &quot;closest-side&quot;; break;</span>
<span class="line-added">476     case BasicShapeRadius::FarthestSide: ts &lt;&lt; &quot;farthest-side&quot;; break;</span>
<span class="line-added">477     }</span>
<span class="line-added">478     return ts;</span>
<span class="line-added">479 }</span>
<span class="line-added">480 </span>
<span class="line-added">481 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShapeRadius&amp; radius)</span>
<span class="line-added">482 {</span>
<span class="line-added">483     ts.dumpProperty(&quot;value&quot;, radius.value());</span>
<span class="line-added">484     ts.dumpProperty(&quot;type&quot;, radius.type());</span>
<span class="line-added">485     return ts;</span>
486 }
<span class="line-added">487 </span>
<span class="line-added">488 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShapeCenterCoordinate&amp; coordinate)</span>
<span class="line-added">489 {</span>
<span class="line-added">490     ts.dumpProperty(&quot;direction&quot;, coordinate.direction() == BasicShapeCenterCoordinate::TopLeft ? &quot;top left&quot; : &quot;bottom right&quot;);</span>
<span class="line-added">491     ts.dumpProperty(&quot;length&quot;, coordinate.length());</span>
<span class="line-added">492     return ts;</span>
<span class="line-added">493 }</span>
<span class="line-added">494 </span>
<span class="line-added">495 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const BasicShape&amp; shape)</span>
<span class="line-added">496 {</span>
<span class="line-added">497     shape.dump(ts);</span>
<span class="line-added">498     return ts;</span>
<span class="line-added">499 }</span>
<span class="line-added">500 </span>
<span class="line-added">501 } // namespace WebCore</span>
</pre>
</td>
</tr>
</table>
<center><a href="../shapes/ShapeOutsideInfo.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BasicShapes.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
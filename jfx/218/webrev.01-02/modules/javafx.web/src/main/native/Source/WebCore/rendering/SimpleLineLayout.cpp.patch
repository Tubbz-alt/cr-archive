diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/SimpleLineLayout.cpp
@@ -160,11 +160,11 @@
     const auto& style = flow.style();
     auto& fontCascade = style.fontCascade();
     if (fontCascade.primaryFont().isInterstitial())
         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsMissingPrimaryFont, reasons, includeReasons);
     Optional<float> lineHeightConstraint;
-    if (style.lineBoxContain() & LineBoxContainGlyphs)
+    if (style.lineBoxContain().contains(LineBoxContain::Glyphs))
         lineHeightConstraint = lineHeightFromFlow(flow).toFloat();
     bool flowIsJustified = style.textAlign() == TextAlignMode::Justify;
     for (const auto& textRenderer : childrenOfType<RenderText>(flow)) {
         // FIXME: Do not return until after checking all children.
         if (textRenderer.text().isEmpty())
@@ -206,11 +206,11 @@
     // Non-visible overflow should be pretty easy to support.
     if (style.overflowX() != Overflow::Visible || style.overflowY() != Overflow::Visible)
         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasOverflowNotVisible, reasons, includeReasons);
     if (!style.isLeftToRightDirection())
         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotLTR, reasons, includeReasons);
-    if (!(style.lineBoxContain() & LineBoxContainBlock))
+    if (!(style.lineBoxContain().contains(LineBoxContain::Block)))
         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBoxContainProperty, reasons, includeReasons);
     if (style.writingMode() != TopToBottomWritingMode)
         SET_REASON_AND_RETURN_IF_NEEDED(FlowIsNotTopToBottom, reasons, includeReasons);
     if (style.lineBreak() != LineBreak::Auto)
         SET_REASON_AND_RETURN_IF_NEEDED(FlowHasLineBreak, reasons, includeReasons);
@@ -353,34 +353,10 @@
 bool canUseFor(const RenderBlockFlow& flow)
 {
     return canUseForWithReason(flow, IncludeReasons::First) == NoReason;
 }
 
-static float computeLineLeft(TextAlignMode textAlign, float availableWidth, float committedWidth, float logicalLeftOffset)
-{
-    float remainingWidth = availableWidth - committedWidth;
-    float left = logicalLeftOffset;
-    switch (textAlign) {
-    case TextAlignMode::Left:
-    case TextAlignMode::WebKitLeft:
-    case TextAlignMode::Start:
-        return left;
-    case TextAlignMode::Right:
-    case TextAlignMode::WebKitRight:
-    case TextAlignMode::End:
-        return left + std::max<float>(remainingWidth, 0);
-    case TextAlignMode::Center:
-    case TextAlignMode::WebKitCenter:
-        return left + std::max<float>(remainingWidth / 2, 0);
-    case TextAlignMode::Justify:
-        ASSERT_NOT_REACHED();
-        break;
-    }
-    ASSERT_NOT_REACHED();
-    return 0;
-}
-
 static void revertAllRunsOnCurrentLine(Layout::RunVector& runs)
 {
     while (!runs.isEmpty() && !runs.last().isEndOfLine)
         runs.removeLast();
 }
@@ -471,11 +447,11 @@
         // Adjust end position while collapsing.
         unsigned endPosition = endPositionForCollapsedFragment(fragment);
         // New line needs new run.
         if (!m_runsWidth) {
             ASSERT(!m_uncompletedWidth);
-            runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));
+            runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));
         } else {
             // Advance last completed fragment when the previous fragment is all set (including multiple parts across renderers)
             if ((m_lastFragment.type() != fragment.type()) || !m_lastFragment.overlapsToNextRenderer()) {
                 m_lastCompleteFragment = m_lastFragment;
                 m_uncompletedWidth = fragment.width();
@@ -489,14 +465,14 @@
                     m_runsWidth -= (m_lastFragment.width() - m_collapsedWhitespaceWidth);
                 }
                 // This fragment is collapsed completely. No run is needed.
                 return;
             }
-            if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed())
-                runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen()));
+            Run& lastRun = runs.last();
+            if (m_lastFragment.isLastInRenderer() || m_lastFragment.isCollapsed() || fragment.isLineBreak() || lastRun.isLineBreak)
+                runs.append(Run(fragment.start(), endPosition, m_runsWidth, m_runsWidth + fragment.width(), false, fragment.hasHyphen(), fragment.isLineBreak()));
             else {
-                Run& lastRun = runs.last();
                 lastRun.end = endPosition;
                 lastRun.logicalRight += fragment.width();
                 ASSERT(!lastRun.hasHyphen);
                 lastRun.hasHyphen = fragment.hasHyphen();
             }
@@ -532,11 +508,11 @@
         return m_lastCompleteFragment;
     }
 
     void removeTrailingWhitespace(Layout::RunVector& runs)
     {
-        if (m_lastFragment.type() != TextFragmentIterator::TextFragment::Whitespace)
+        if (!hasTrailingWhitespace())
             return;
         if (m_lastNonWhitespaceFragment) {
             auto needsReverting = m_lastNonWhitespaceFragment->end() != m_lastFragment.end();
             // Trailing whitespace fragment might actually have zero length.
             ASSERT(needsReverting || !m_trailingWhitespaceWidth);
@@ -554,10 +530,12 @@
         m_trailingWhitespaceWidth = 0;
         // FIXME: Make m_lastFragment optional.
         m_lastFragment = TextFragmentIterator::TextFragment();
     }
 
+    float trailingWhitespaceWidth() const { return m_trailingWhitespaceWidth; }
+
 private:
     bool expansionOpportunity(TextFragmentIterator::TextFragment::Type currentFragmentType, TextFragmentIterator::TextFragment::Type previousFragmentType) const
     {
         return (currentFragmentType == TextFragmentIterator::TextFragment::Whitespace
             || (currentFragmentType == TextFragmentIterator::TextFragment::NonWhitespace && previousFragmentType == TextFragmentIterator::TextFragment::NonWhitespace));
@@ -579,28 +557,41 @@
     bool m_firstCharacterFits { false };
     bool m_hyphenationDisabled { false };
     Optional<Vector<TextFragmentIterator::TextFragment, 30>> m_fragments;
 };
 
-static bool preWrap(const TextFragmentIterator::Style& style)
+static float computeLineLeft(const LineState& line, TextAlignMode textAlign, float& hangingWhitespaceWidth)
 {
-    return style.wrapLines && !style.collapseWhitespace;
+    float totalWidth = line.width() - hangingWhitespaceWidth;
+    float remainingWidth = line.availableWidth() - totalWidth;
+    float left = line.logicalLeftOffset();
+    switch (textAlign) {
+    case TextAlignMode::Left:
+    case TextAlignMode::WebKitLeft:
+    case TextAlignMode::Start:
+        hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, remainingWidth));
+        return left;
+    case TextAlignMode::Right:
+    case TextAlignMode::WebKitRight:
+    case TextAlignMode::End:
+        hangingWhitespaceWidth = 0;
+        return left + std::max<float>(remainingWidth, 0);
+    case TextAlignMode::Center:
+    case TextAlignMode::WebKitCenter:
+        hangingWhitespaceWidth = std::max(0.f, std::min(hangingWhitespaceWidth, (remainingWidth + 1) / 2));
+        return left + std::max<float>(remainingWidth / 2, 0);
+    case TextAlignMode::Justify:
+        ASSERT_NOT_REACHED();
+        break;
+    }
+    ASSERT_NOT_REACHED();
+    return 0;
 }
 
-static void removeTrailingWhitespace(LineState& lineState, Layout::RunVector& runs, const TextFragmentIterator& textFragmentIterator)
+static bool preWrap(const TextFragmentIterator::Style& style)
 {
-    if (!lineState.hasTrailingWhitespace())
-        return;
-    // Remove collapsed whitespace, or non-collapsed pre-wrap whitespace, unless it's the only content on the line -so removing the whitesapce
-    // would produce an empty line.
-    const auto& style = textFragmentIterator.style();
-    bool collapseWhitespace = style.collapseWhitespace || (!style.breakSpaces && preWrap(style));
-    if (!collapseWhitespace)
-        return;
-    if (preWrap(style) && lineState.isWhitespaceOnly())
-        return;
-    lineState.removeTrailingWhitespace(runs);
+    return style.wrapLines && !style.collapseWhitespace && !style.breakSpaces;
 }
 
 static void updateLineConstrains(const RenderBlockFlow& flow, LineState& line, const LineState& previousLine, unsigned& numberOfPrecedingLinesWithHyphen, const TextFragmentIterator::Style& style, bool isFirstLine)
 {
     bool shouldApplyTextIndent = !flow.isAnonymous() || flow.parent()->firstChild() == &flow;
@@ -756,15 +747,14 @@
         if (style.breakFirstWordOnOverflow || previousLine.hasTrailingWhitespace())
             return overflowedFragment;
     }
     // Special overflow pre-wrap whitespace handling: skip the overflowed whitespace (even when style says not-collapsible)
     // if we manage to fit at least one character on the previous line.
-    auto preWrapIsOn = preWrap(style);
-    if ((style.collapseWhitespace || preWrapIsOn) && previousLine.firstCharacterFits()) {
+    if ((style.collapseWhitespace || style.wrapLines) && previousLine.firstCharacterFits()) {
         // If skipping the whitespace puts us on a newline, skip the newline too as we already wrapped the line.
         auto firstFragmentCandidate = consumeLineBreakIfNeeded(textFragmentIterator.nextTextFragment(), textFragmentIterator, currentLine, runs,
-            preWrapIsOn ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);
+            preWrap(style) ? PreWrapLineBreakRule::Ignore : PreWrapLineBreakRule::Preserve);
         return skipWhitespaceIfNeeded(firstFragmentCandidate, textFragmentIterator);
     }
     return skipWhitespaceIfNeeded(overflowedFragment, textFragmentIterator);
 }
 
@@ -797,11 +787,11 @@
     auto fragment = firstFragment(textFragmentIterator, line, previousLine, runs);
     while (fragment.type() != TextFragmentIterator::TextFragment::ContentEnd) {
         // Hard and soft linebreaks.
         if (fragment.isLineBreak()) {
             // Add the new line fragment only if there's nothing on the line. (otherwise the extra new line character would show up at the end of the content.)
-            if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak) {
+            if (line.isEmpty() || fragment.type() == TextFragmentIterator::TextFragment::HardLineBreak || preWrap(style) || style.preserveNewline) {
                 if (style.textAlign == TextAlignMode::Right || style.textAlign == TextAlignMode::WebKitRight)
                     line.removeTrailingWhitespace(runs);
                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
             }
             break;
@@ -824,10 +814,18 @@
                 if (style.breakSpaces && line.hasWhitespaceFragments() && fragment.length() == 1) {
                     // Breaking before the first space after a word is not allowed if there are previous breaking opportunities in the line.
                     textFragmentIterator.revertToEndOfFragment(line.revertToLastCompleteFragment(runs));
                     break;
                 }
+                if (preWrap(style)) {
+                    line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
+                    fragment = textFragmentIterator.nextTextFragment(line.width());
+                    if (fragment.isLineBreak())
+                        continue;
+                    line.setOverflowedFragment(fragment);
+                    break;
+                }
                 // Split the whitespace; left part stays on this line, right is pushed to next line.
                 line.setOverflowedFragment(splitFragmentToFitLine(fragment, line, textFragmentIterator));
                 line.appendFragmentAndCreateRunIfNeeded(fragment, runs);
                 break;
             }
@@ -929,26 +927,42 @@
 static void closeLineEndingAndAdjustRuns(LineState& line, Layout::RunVector& runs, Optional<unsigned> lastRunIndexOfPreviousLine, unsigned& lineCount,
     const TextFragmentIterator& textFragmentIterator, bool lastLineInFlow)
 {
     if (!runs.size() || (lastRunIndexOfPreviousLine && runs.size() - 1 == lastRunIndexOfPreviousLine.value()))
         return;
-    removeTrailingWhitespace(line, runs, textFragmentIterator);
+
+    const auto& style = textFragmentIterator.style();
+
+    if (style.collapseWhitespace)
+        line.removeTrailingWhitespace(runs);
+
     if (!runs.size())
         return;
+
     // Adjust runs' position by taking line's alignment into account.
-    const auto& style = textFragmentIterator.style();
     auto firstRunIndex = lastRunIndexOfPreviousLine ? lastRunIndexOfPreviousLine.value() + 1 : 0;
     auto lineLogicalLeft = line.logicalLeftOffset();
     auto textAlign = textAlignForLine(style, lastLineInFlow || (line.lastFragment().isValid() && line.lastFragment().type() == TextFragmentIterator::TextFragment::HardLineBreak));
-    if (textAlign == TextAlignMode::Justify)
+
+    // https://www.w3.org/TR/css-text-3/#white-space-phase-2
+    bool shouldHangTrailingWhitespace = style.wrapLines && line.trailingWhitespaceWidth();
+    auto hangingWhitespaceWidth = shouldHangTrailingWhitespace ? line.trailingWhitespaceWidth() : 0;
+
+    if (textAlign == TextAlignMode::Justify) {
         justifyRuns(line, runs, firstRunIndex);
-    else
-        lineLogicalLeft = computeLineLeft(textAlign, line.availableWidth(), line.width(), line.logicalLeftOffset());
+        hangingWhitespaceWidth = 0;
+    } else
+        lineLogicalLeft = computeLineLeft(line, textAlign, hangingWhitespaceWidth);
+
     for (auto i = firstRunIndex; i < runs.size(); ++i) {
         runs[i].logicalLeft += lineLogicalLeft;
         runs[i].logicalRight += lineLogicalLeft;
     }
+
+    if (shouldHangTrailingWhitespace && hangingWhitespaceWidth < line.trailingWhitespaceWidth())
+        runs.last().logicalRight = runs.last().logicalRight - (line.trailingWhitespaceWidth() - hangingWhitespaceWidth);
+
     runs.last().isEndOfLine = true;
     ++lineCount;
 }
 
 static void createTextRuns(Layout::RunVector& runs, RenderBlockFlow& flow, unsigned& lineCount)
@@ -970,22 +984,22 @@
         if (runs.size())
             lastRunIndexOfPreviousLine = runs.size() - 1;
     } while (!isEndOfContent);
 }
 
-std::unique_ptr<Layout> create(RenderBlockFlow& flow)
+Ref<Layout> create(RenderBlockFlow& flow)
 {
     unsigned lineCount = 0;
     Layout::RunVector runs;
     createTextRuns(runs, flow, lineCount);
     return Layout::create(runs, lineCount, flow);
 }
 
-std::unique_ptr<Layout> Layout::create(const RunVector& runVector, unsigned lineCount, const RenderBlockFlow& blockFlow)
+Ref<Layout> Layout::create(const RunVector& runVector, unsigned lineCount, const RenderBlockFlow& blockFlow)
 {
     void* slot = WTF::fastMalloc(sizeof(Layout) + sizeof(Run) * runVector.size());
-    return std::unique_ptr<Layout>(new (NotNull, slot) Layout(runVector, lineCount, blockFlow));
+    return adoptRef(*new (NotNull, slot) Layout(runVector, lineCount, blockFlow));
 }
 
 Layout::Layout(const RunVector& runVector, unsigned lineCount, const RenderBlockFlow& blockFlow)
     : m_lineCount(lineCount)
     , m_runCount(runVector.size())

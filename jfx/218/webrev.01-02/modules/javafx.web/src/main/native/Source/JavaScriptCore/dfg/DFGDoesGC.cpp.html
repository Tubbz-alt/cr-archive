<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGDoesGC.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGDoesGC.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;DFGClobberize.h&quot;
 32 #include &quot;DFGGraph.h&quot;
 33 #include &quot;DFGNode.h&quot;
 34 #include &quot;Operations.h&quot;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 bool doesGC(Graph&amp; graph, Node* node)
 39 {
 40     if (clobbersHeap(graph, node))
 41         return true;
 42 
 43     // Now consider nodes that don&#39;t clobber the world but that still may GC. This includes all
 44     // nodes. By default, we should assume every node can GC and return true. This includes the
 45     // world-clobbering nodes. We should only return false if we have proven that the node cannot
 46     // GC. Typical examples of how a node can GC is if the code emitted for the node does any of the
 47     // following:
 48     //     1. Allocates any objects.
 49     //     2. Resolves a rope string, which allocates a string.
 50     //     3. Produces a string (which allocates the string) except when we can prove that
 51     //        the string will always be one of the pre-allcoated SmallStrings.
 52     //     4. Triggers a structure transition (which can allocate a new structure)
 53     //        unless it is a known transition between previously allocated structures
 54     //        such as between Array types.
 55     //     5. Calls to a JS function, which can execute arbitrary code including allocating objects.
 56     //     6. Calls operations that uses DeferGC, because it may GC in its destructor.
 57 
 58     switch (node-&gt;op()) {
 59     case JSConstant:
 60     case DoubleConstant:
 61     case Int52Constant:
 62     case LazyJSConstant:
 63     case Identity:
 64     case IdentityWithProfile:
 65     case GetCallee:
 66     case SetCallee:
 67     case GetArgumentCountIncludingThis:
 68     case SetArgumentCountIncludingThis:
 69     case GetRestLength:
 70     case GetLocal:
 71     case SetLocal:
 72     case MovHint:
 73     case InitializeEntrypointArguments:
 74     case ZombieHint:
 75     case ExitOK:
 76     case Phantom:
 77     case Upsilon:
 78     case Phi:
 79     case Flush:
 80     case PhantomLocal:
 81     case SetArgumentDefinitely:
 82     case SetArgumentMaybe:
 83     case ArithBitNot:
 84     case ArithBitAnd:
 85     case ArithBitOr:
 86     case ArithBitXor:
 87     case ArithBitLShift:
 88     case ArithBitRShift:
 89     case BitURShift:
 90     case ValueToInt32:
 91     case UInt32ToNumber:
 92     case DoubleAsInt32:
 93     case ArithAdd:
 94     case ArithClz32:
 95     case ArithSub:
 96     case ArithNegate:
 97     case ArithMul:
 98     case ArithIMul:
 99     case ArithDiv:
100     case ArithMod:
101     case ArithAbs:
102     case ArithMin:
103     case ArithMax:
104     case ArithPow:
105     case ArithSqrt:
106     case ArithRandom:
107     case ArithRound:
108     case ArithFloor:
109     case ArithCeil:
110     case ArithTrunc:
111     case ArithFRound:
112     case ArithUnary:
113     case CheckStructure:
114     case CheckStructureOrEmpty:
115     case CheckStructureImmediate:
116     case GetExecutable:
117     case GetButterfly:
118     case CheckSubClass:
119     case CheckArray:
120     case CheckArrayOrEmpty:
121     case CheckNeutered:
122     case GetScope:
123     case SkipScope:
124     case GetGlobalObject:
125     case GetGlobalThis:
126     case GetClosureVar:
127     case PutClosureVar:
128     case GetInternalField:
129     case PutInternalField:
130     case GetRegExpObjectLastIndex:
131     case SetRegExpObjectLastIndex:
132     case RecordRegExpCachedResult:
133     case GetGlobalVar:
134     case GetGlobalLexicalVariable:
135     case PutGlobalVariable:
136     case CheckCell:
137     case CheckNotEmpty:
138     case AssertNotEmpty:
139     case CheckIdent:
140     case CompareBelow:
141     case CompareBelowEq:
142     case CompareEqPtr:
143     case ProfileControlFlow:
144     case OverridesHasInstance:
145     case IsEmpty:
146     case IsUndefined:
147     case IsUndefinedOrNull:
148     case IsBoolean:
149     case IsNumber:
150     case NumberIsInteger:
151     case IsObject:
152     case IsObjectOrNull:
153     case IsFunction:
154     case IsCellWithType:
155     case IsTypedArrayView:
156     case TypeOf:
157     case LogicalNot:
158     case Jump:
159     case Branch:
160     case EntrySwitch:
161     case CountExecution:
162     case SuperSamplerBegin:
163     case SuperSamplerEnd:
164     case CPUIntrinsic:
165     case NormalizeMapKey:
166     case GetMapBucketHead:
167     case GetMapBucketNext:
168     case LoadKeyFromMapBucket:
169     case LoadValueFromMapBucket:
170     case ExtractValueFromWeakMapGet:
171     case WeakMapGet:
172     case WeakSetAdd:
173     case WeakMapSet:
174     case Unreachable:
175     case ExtractOSREntryLocal:
176     case ExtractCatchLocal:
177     case ClearCatchLocals:
178     case LoopHint:
179     case StoreBarrier:
180     case FencedStoreBarrier:
181     case InvalidationPoint:
182     case NotifyWrite:
183     case CheckInBounds:
184     case ConstantStoragePointer:
185     case Check:
186     case CheckVarargs:
187     case CheckTypeInfoFlags:
188     case MultiGetByOffset:
189     case ValueRep:
190     case DoubleRep:
191     case Int52Rep:
192     case GetGetter:
193     case GetSetter:
194     case GetArrayLength:
195     case GetVectorLength:
196     case StringCharCodeAt:
197     case StringCodePointAt:
198     case GetTypedArrayByteOffset:
199     case GetPrototypeOf:
200     case PutStructure:
201     case GetByOffset:
202     case GetGetterSetterByOffset:
203     case GetEnumerableLength:
204     case FiatInt52:
205     case BooleanToNumber:
206     case CheckBadCell:
207     case BottomValue:
208     case PhantomNewObject:
209     case PhantomNewFunction:
210     case PhantomNewGeneratorFunction:
211     case PhantomNewAsyncFunction:
212     case PhantomNewAsyncGeneratorFunction:
213     case PhantomNewArrayIterator:
214     case PhantomCreateActivation:
215     case PhantomDirectArguments:
216     case PhantomCreateRest:
217     case PhantomNewArrayWithSpread:
218     case PhantomNewArrayBuffer:
219     case PhantomSpread:
220     case PhantomClonedArguments:
221     case PhantomNewRegexp:
222     case GetMyArgumentByVal:
223     case GetMyArgumentByValOutOfBounds:
224     case ForwardVarargs:
225     case PutHint:
226     case KillStack:
227     case GetStack:
228     case GetFromArguments:
229     case GetArgument:
230     case LogShadowChickenPrologue:
231     case LogShadowChickenTail:
232     case NukeStructureAndSetButterfly:
233     case AtomicsAdd:
234     case AtomicsAnd:
235     case AtomicsCompareExchange:
236     case AtomicsExchange:
237     case AtomicsLoad:
238     case AtomicsOr:
239     case AtomicsStore:
240     case AtomicsSub:
241     case AtomicsXor:
242     case AtomicsIsLockFree:
243     case MatchStructure:
244     case FilterCallLinkStatus:
245     case FilterGetByStatus:
246     case FilterPutByIdStatus:
247     case FilterInByIdStatus:
248     case DateGetInt32OrNaN:
249     case DateGetTime:
250     case DataViewGetInt:
251     case DataViewGetFloat:
252     case DataViewSet:
253         return false;
254 
255 #if ASSERT_ENABLED
256     case ArrayPush:
257     case ArrayPop:
258     case PushWithScope:
259     case CreateActivation:
260     case CreateDirectArguments:
261     case CreateScopedArguments:
262     case CreateClonedArguments:
263     case CreateArgumentsButterfly:
264     case Call:
265     case CallEval:
266     case CallForwardVarargs:
267     case CallObjectConstructor:
268     case CallVarargs:
269     case CheckTierUpAndOSREnter:
270     case CheckTierUpAtReturn:
271     case CheckTierUpInLoop:
272     case Construct:
273     case ConstructForwardVarargs:
274     case ConstructVarargs:
275     case DefineDataProperty:
276     case DefineAccessorProperty:
277     case DeleteById:
278     case DeleteByVal:
279     case DirectCall:
280     case DirectConstruct:
281     case DirectTailCall:
282     case DirectTailCallInlinedCaller:
283     case ForceOSRExit:
284     case GetById:
285     case GetByIdDirect:
286     case GetByIdDirectFlush:
287     case GetByIdFlush:
288     case GetByIdWithThis:
289     case GetByValWithThis:
290     case GetDirectPname:
291     case GetDynamicVar:
292     case GetMapBucket:
293     case HasGenericProperty:
294     case HasIndexedProperty:
295     case HasOwnProperty:
296     case HasStructureProperty:
297     case InById:
298     case InByVal:
299     case InstanceOf:
300     case InstanceOfCustom:
301     case VarargsLength:
302     case LoadVarargs:
303     case NumberToStringWithRadix:
304     case NumberToStringWithValidRadixConstant:
305     case ProfileType:
306     case PutById:
307     case PutByIdDirect:
308     case PutByIdFlush:
309     case PutByIdWithThis:
310     case PutByOffset:
311     case PutByValWithThis:
312     case PutDynamicVar:
313     case PutGetterById:
314     case PutGetterByVal:
315     case PutGetterSetterById:
316     case PutSetterById:
317     case PutSetterByVal:
318     case PutStack:
319     case PutToArguments:
320     case RegExpExec:
321     case RegExpExecNonGlobalOrSticky:
322     case RegExpMatchFast:
323     case RegExpMatchFastGlobal:
324     case RegExpTest:
325     case ResolveScope:
326     case ResolveScopeForHoistingFuncDeclInEval:
327     case Return:
328     case StringCharAt:
329     case TailCall:
330     case TailCallForwardVarargs:
331     case TailCallForwardVarargsInlinedCaller:
332     case TailCallInlinedCaller:
333     case TailCallVarargs:
334     case TailCallVarargsInlinedCaller:
335     case Throw:
336     case ToNumber:
337     case ToNumeric:
338     case ToObject:
339     case ToPrimitive:
340     case ToPropertyKey:
341     case ToThis:
342     case TryGetById:
343     case CreateThis:
344     case CreatePromise:
345     case CreateGenerator:
346     case CreateAsyncGenerator:
347     case ObjectCreate:
348     case ObjectKeys:
349     case AllocatePropertyStorage:
350     case ReallocatePropertyStorage:
351     case Arrayify:
352     case ArrayifyToStructure:
353     case NewObject:
354     case NewPromise:
355     case NewGenerator:
356     case NewAsyncGenerator:
357     case NewArray:
358     case NewArrayWithSpread:
359     case NewArrayIterator:
360     case Spread:
361     case NewArrayWithSize:
362     case NewArrayBuffer:
363     case NewRegexp:
364     case NewStringObject:
365     case NewSymbol:
366     case MakeRope:
367     case NewFunction:
368     case NewGeneratorFunction:
369     case NewAsyncGeneratorFunction:
370     case NewAsyncFunction:
371     case NewTypedArray:
372     case ThrowStaticError:
373     case GetPropertyEnumerator:
374     case GetEnumeratorStructurePname:
375     case GetEnumeratorGenericPname:
376     case ToIndexString:
377     case MaterializeNewObject:
378     case MaterializeNewInternalFieldObject:
379     case MaterializeCreateActivation:
380     case SetFunctionName:
381     case StrCat:
382     case StringReplace:
383     case StringReplaceRegExp:
384     case StringSlice:
385     case StringValueOf:
386     case CreateRest:
387     case ToLowerCase:
388     case CallDOMGetter:
389     case CallDOM:
390     case ArraySlice:
391     case ArrayIndexOf:
392     case ParseInt: // We might resolve a rope even though we don&#39;t clobber anything.
393     case SetAdd:
394     case MapSet:
395     case ValueBitAnd:
396     case ValueBitOr:
397     case ValueBitXor:
398     case ValueBitLShift:
399     case ValueBitRShift:
400     case ValueAdd:
401     case ValueSub:
402     case ValueMul:
403     case ValueDiv:
404     case ValueMod:
405     case ValuePow:
406     case ValueBitNot:
407     case ValueNegate:
408 #else // not ASSERT_ENABLED
409     // See comment at the top for why the default for all nodes should be to
410     // return true.
411     default:
412 #endif // not ASSERT_ENABLED
413         return true;
414 
415     case CallStringConstructor:
416     case ToString:
417         switch (node-&gt;child1().useKind()) {
418         case StringObjectUse:
419         case StringOrStringObjectUse:
420             return false;
421         default:
422             break;
423         }
424         return true;
425 
426     case CheckTraps:
427         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=194323
428         ASSERT(Options::usePollingTraps());
429         return true;
430 
431     case CompareEq:
432     case CompareLess:
433     case CompareLessEq:
434     case CompareGreater:
435     case CompareGreaterEq:
436         if (node-&gt;isBinaryUseKind(Int32Use)
437 #if USE(JSVALUE64)
438             || node-&gt;isBinaryUseKind(Int52RepUse)
439 #endif
440             || node-&gt;isBinaryUseKind(DoubleRepUse)
441             || node-&gt;isBinaryUseKind(StringIdentUse)
442             )
443             return false;
444         if (node-&gt;op() == CompareEq) {
445             if (node-&gt;isBinaryUseKind(BooleanUse)
446                 || node-&gt;isBinaryUseKind(SymbolUse)
447                 || node-&gt;isBinaryUseKind(ObjectUse)
448                 || node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse) || node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse))
449                 return false;
450         }
451         return true;
452 
453     case CompareStrictEq:
454         if (node-&gt;isBinaryUseKind(BooleanUse)
455             || node-&gt;isBinaryUseKind(Int32Use)
456 #if USE(JSVALUE64)
457             || node-&gt;isBinaryUseKind(Int52RepUse)
458 #endif
459             || node-&gt;isBinaryUseKind(DoubleRepUse)
460             || node-&gt;isBinaryUseKind(SymbolUse)
461             || node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)
462             || node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)
463             || node-&gt;isBinaryUseKind(StringIdentUse)
464             || node-&gt;isBinaryUseKind(ObjectUse, UntypedUse) || node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)
465             || node-&gt;isBinaryUseKind(ObjectUse)
466             || node-&gt;isBinaryUseKind(MiscUse, UntypedUse) || node-&gt;isBinaryUseKind(UntypedUse, MiscUse)
467             || node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse) || node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse))
468             return false;
469         return true;
470 
471     case GetIndexedPropertyStorage:
472     case GetByVal:
473         if (node-&gt;arrayMode().type() == Array::String)
474             return true;
475         return false;
476 
477     case PutByValDirect:
478     case PutByVal:
479     case PutByValAlias:
480         if (!graph.m_plan.isFTL()) {
481             switch (node-&gt;arrayMode().modeForPut().type()) {
482             case Array::Int8Array:
483             case Array::Int16Array:
484             case Array::Int32Array:
485             case Array::Uint8Array:
486             case Array::Uint8ClampedArray:
487             case Array::Uint16Array:
488             case Array::Uint32Array:
489                 return true;
490             default:
491                 break;
492             }
493         }
494         return false;
495 
496     case MapHash:
497         switch (node-&gt;child1().useKind()) {
498         case BooleanUse:
499         case Int32Use:
500         case SymbolUse:
501         case ObjectUse:
502             return false;
503         default:
504             // We might resolve a rope.
505             return true;
506         }
507 
508     case MultiPutByOffset:
509         return node-&gt;multiPutByOffsetData().reallocatesStorage();
510 
511     case SameValue:
512         if (node-&gt;isBinaryUseKind(DoubleRepUse))
513             return false;
514         return true;
515 
516     case StringFromCharCode:
517         // FIXME: Should we constant fold this case?
518         // https://bugs.webkit.org/show_bug.cgi?id=194308
519         if (node-&gt;child1()-&gt;isInt32Constant() &amp;&amp; (node-&gt;child1()-&gt;asUInt32() &lt;= maxSingleCharacterString))
520             return false;
521         return true;
522 
523     case Switch:
524         switch (node-&gt;switchData()-&gt;kind) {
525         case SwitchCell:
526             ASSERT(graph.m_plan.isFTL());
527             FALLTHROUGH;
528         case SwitchImm:
529             return false;
530         case SwitchChar:
531             return true;
532         case SwitchString:
533             if (node-&gt;child1().useKind() == StringIdentUse)
534                 return false;
535             ASSERT(node-&gt;child1().useKind() == StringUse || node-&gt;child1().useKind() == UntypedUse);
536             return true;
537         }
538         RELEASE_ASSERT_NOT_REACHED();
539 
540     case Inc:
541     case Dec:
542         switch (node-&gt;child1().useKind()) {
543         case Int32Use:
544         case Int52RepUse:
545         case DoubleRepUse:
546             return false;
547         default:
548             return true;
549         }
550 
551     case LastNodeType:
552         RELEASE_ASSERT_NOT_REACHED();
553     }
554 
555     RELEASE_ASSERT_NOT_REACHED();
556 }
557 
558 } } // namespace JSC::DFG
559 
560 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
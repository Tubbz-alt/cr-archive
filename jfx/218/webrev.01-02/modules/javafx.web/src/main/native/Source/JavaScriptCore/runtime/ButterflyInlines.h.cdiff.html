<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ButterflyInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Butterfly.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachePayload.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ButterflyInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2012-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,11 ***</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-modified">! #include &quot;ArrayStorage.h&quot;</span>
  #include &quot;Butterfly.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;VM.h&quot;
  
<span class="line-new-header">--- 23,11 ---</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-modified">! #include &quot;ArrayStorageInlines.h&quot;</span>
  #include &quot;Butterfly.h&quot;
  #include &quot;JSObject.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;VM.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,11 ***</span>
      if (!base)
          return nullptr;
      Butterfly* result = fromBase(base, preCapacity, propertyCapacity);
      if (hasIndexingHeader)
          *result-&gt;indexingHeader() = indexingHeader;
<span class="line-modified">!     memset(result-&gt;propertyStorage() - propertyCapacity, 0, propertyCapacity * sizeof(EncodedJSValue));</span>
      return result;
  }
  
  inline Butterfly* Butterfly::create(VM&amp; vm, JSObject* intendedOwner, size_t preCapacity, size_t propertyCapacity, bool hasIndexingHeader, const IndexingHeader&amp; indexingHeader, size_t indexingPayloadSizeInBytes)
  {
<span class="line-new-header">--- 102,11 ---</span>
      if (!base)
          return nullptr;
      Butterfly* result = fromBase(base, preCapacity, propertyCapacity);
      if (hasIndexingHeader)
          *result-&gt;indexingHeader() = indexingHeader;
<span class="line-modified">!     gcSafeZeroMemory(result-&gt;propertyStorage() - propertyCapacity, propertyCapacity * sizeof(EncodedJSValue));</span>
      return result;
  }
  
  inline Butterfly* Butterfly::create(VM&amp; vm, JSObject* intendedOwner, size_t preCapacity, size_t propertyCapacity, bool hasIndexingHeader, const IndexingHeader&amp; indexingHeader, size_t indexingPayloadSizeInBytes)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,17 ***</span>
  
      size_t preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
      size_t indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
      bool hasIndexingHeader = structure-&gt;hasIndexingHeader(intendedOwner);
      Butterfly* result = createUninitialized(vm, intendedOwner, preCapacity, newPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes);
<span class="line-modified">!     memcpy(</span>
          result-&gt;propertyStorage() - oldPropertyCapacity,
          oldButterfly-&gt;propertyStorage() - oldPropertyCapacity,
          totalSize(0, oldPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes));
<span class="line-modified">!     memset(</span>
          result-&gt;propertyStorage() - newPropertyCapacity,
<span class="line-removed">-         0,</span>
          (newPropertyCapacity - oldPropertyCapacity) * sizeof(EncodedJSValue));
      return result;
  }
  
  inline Butterfly* Butterfly::createOrGrowArrayRight(
<span class="line-new-header">--- 137,16 ---</span>
  
      size_t preCapacity = oldButterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
      size_t indexingPayloadSizeInBytes = oldButterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
      bool hasIndexingHeader = structure-&gt;hasIndexingHeader(intendedOwner);
      Butterfly* result = createUninitialized(vm, intendedOwner, preCapacity, newPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes);
<span class="line-modified">!     gcSafeMemcpy(</span>
          result-&gt;propertyStorage() - oldPropertyCapacity,
          oldButterfly-&gt;propertyStorage() - oldPropertyCapacity,
          totalSize(0, oldPropertyCapacity, hasIndexingHeader, indexingPayloadSizeInBytes));
<span class="line-modified">!     gcSafeZeroMemory(</span>
          result-&gt;propertyStorage() - newPropertyCapacity,
          (newPropertyCapacity - oldPropertyCapacity) * sizeof(EncodedJSValue));
      return result;
  }
  
  inline Butterfly* Butterfly::createOrGrowArrayRight(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,11 ***</span>
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, nullptr, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
      // FIXME: This probably shouldn&#39;t be a memcpy.
<span class="line-modified">!     memcpy(newBase, theBase, oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::growArrayRight(
      VM&amp; vm, JSObject* intendedOwner, Structure* oldStructure,
<span class="line-new-header">--- 176,11 ---</span>
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, nullptr, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
      // FIXME: This probably shouldn&#39;t be a memcpy.
<span class="line-modified">!     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(theBase), oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::growArrayRight(
      VM&amp; vm, JSObject* intendedOwner, Structure* oldStructure,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,25 ***</span>
      void* theBase = base(0, propertyCapacity);
      size_t oldSize = totalSize(0, propertyCapacity, hadIndexingHeader, oldIndexingPayloadSizeInBytes);
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      ASSERT(newSize &gt;= oldSize);
  
<span class="line-modified">!     // We can eagerly destroy butterfly backed by LargeAllocation if (1) concurrent collector is not active and (2) the butterfly does not contain any property storage.</span>
      // This is because during deallocation concurrent collector can access butterfly and DFG concurrent compilers accesses properties.
      // Objects with no properties are common in arrays, and we are focusing on very large array crafted by repeating Array#push, so... that&#39;s fine!
<span class="line-modified">!     bool canRealloc = !propertyCapacity &amp;&amp; !vm.heap.mutatorShouldBeFenced() &amp;&amp; bitwise_cast&lt;HeapCell*&gt;(theBase)-&gt;isLargeAllocation();</span>
      if (canRealloc) {
<span class="line-modified">!         void* newBase = vm.jsValueGigacageAuxiliarySpace.reallocateLargeAllocationNonVirtual(vm, bitwise_cast&lt;HeapCell*&gt;(theBase), newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);</span>
          if (!newBase)
              return nullptr;
          return fromBase(newBase, 0, propertyCapacity);
      }
  
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
<span class="line-modified">!     memcpy(newBase, theBase, oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, size_t propertyCapacity, bool oldHasIndexingHeader,
<span class="line-new-header">--- 204,25 ---</span>
      void* theBase = base(0, propertyCapacity);
      size_t oldSize = totalSize(0, propertyCapacity, hadIndexingHeader, oldIndexingPayloadSizeInBytes);
      size_t newSize = totalSize(0, propertyCapacity, true, newIndexingPayloadSizeInBytes);
      ASSERT(newSize &gt;= oldSize);
  
<span class="line-modified">!     // We can eagerly destroy butterfly backed by PreciseAllocation if (1) concurrent collector is not active and (2) the butterfly does not contain any property storage.</span>
      // This is because during deallocation concurrent collector can access butterfly and DFG concurrent compilers accesses properties.
      // Objects with no properties are common in arrays, and we are focusing on very large array crafted by repeating Array#push, so... that&#39;s fine!
<span class="line-modified">!     bool canRealloc = !propertyCapacity &amp;&amp; !vm.heap.mutatorShouldBeFenced() &amp;&amp; bitwise_cast&lt;HeapCell*&gt;(theBase)-&gt;isPreciseAllocation();</span>
      if (canRealloc) {
<span class="line-modified">!         void* newBase = vm.jsValueGigacageAuxiliarySpace.reallocatePreciseAllocationNonVirtual(vm, bitwise_cast&lt;HeapCell*&gt;(theBase), newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);</span>
          if (!newBase)
              return nullptr;
          return fromBase(newBase, 0, propertyCapacity);
      }
  
      void* newBase = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, newSize, &amp;deferralContext, AllocationFailureMode::ReturnNull);
      if (!newBase)
          return nullptr;
<span class="line-modified">!     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(newBase), static_cast&lt;JSValue*&gt;(theBase), oldSize);</span>
      return fromBase(newBase, 0, propertyCapacity);
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, size_t propertyCapacity, bool oldHasIndexingHeader,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,11 ***</span>
      void* to = result-&gt;propertyStorage() - propertyCapacity;
      void* from = propertyStorage() - propertyCapacity;
      size_t size = std::min(
          totalSize(0, propertyCapacity, oldHasIndexingHeader, oldIndexingPayloadSizeInBytes),
          totalSize(0, propertyCapacity, newHasIndexingHeader, newIndexingPayloadSizeInBytes));
<span class="line-modified">!     memcpy(to, from, size);</span>
      return result;
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, Structure* structure, size_t newPreCapacity,
<span class="line-new-header">--- 235,11 ---</span>
      void* to = result-&gt;propertyStorage() - propertyCapacity;
      void* from = propertyStorage() - propertyCapacity;
      size_t size = std::min(
          totalSize(0, propertyCapacity, oldHasIndexingHeader, oldIndexingPayloadSizeInBytes),
          totalSize(0, propertyCapacity, newHasIndexingHeader, newIndexingPayloadSizeInBytes));
<span class="line-modified">!     gcSafeMemcpy(static_cast&lt;JSValue*&gt;(to), static_cast&lt;JSValue*&gt;(from), size);</span>
      return result;
  }
  
  inline Butterfly* Butterfly::resizeArray(
      VM&amp; vm, JSObject* intendedOwner, Structure* structure, size_t newPreCapacity,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 263,11 ***</span>
      // moving a small amount of memory in the common case so the throughput of memmove won&#39;t
      // amortize the overhead of calling it. And no, we cannot rely on the C++ compiler to
      // inline memmove (particularly since the size argument is likely to be variable), nor can
      // we rely on the compiler to recognize the ordering of the pointer arguments (since
      // propertyCapacity is variable and could cause wrap-around as far as the compiler knows).
<span class="line-modified">!     memmove(</span>
          propertyStorage() - numberOfSlots - propertyCapacity,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() - numberOfSlots)-&gt;butterfly();
  }
<span class="line-new-header">--- 262,11 ---</span>
      // moving a small amount of memory in the common case so the throughput of memmove won&#39;t
      // amortize the overhead of calling it. And no, we cannot rely on the C++ compiler to
      // inline memmove (particularly since the size argument is likely to be variable), nor can
      // we rely on the compiler to recognize the ordering of the pointer arguments (since
      // propertyCapacity is variable and could cause wrap-around as far as the compiler knows).
<span class="line-modified">!     gcSafeMemmove(</span>
          propertyStorage() - numberOfSlots - propertyCapacity,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() - numberOfSlots)-&gt;butterfly();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
  inline Butterfly* Butterfly::shift(Structure* structure, size_t numberOfSlots)
  {
      ASSERT(hasAnyArrayStorage(structure-&gt;indexingType()));
      unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
      // FIXME: See comment in unshift(), above.
<span class="line-modified">!     memmove(</span>
          propertyStorage() - propertyCapacity + numberOfSlots,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() + numberOfSlots)-&gt;butterfly();
  }
<span class="line-new-header">--- 274,11 ---</span>
  inline Butterfly* Butterfly::shift(Structure* structure, size_t numberOfSlots)
  {
      ASSERT(hasAnyArrayStorage(structure-&gt;indexingType()));
      unsigned propertyCapacity = structure-&gt;outOfLineCapacity();
      // FIXME: See comment in unshift(), above.
<span class="line-modified">!     gcSafeMemmove(</span>
          propertyStorage() - propertyCapacity + numberOfSlots,
          propertyStorage() - propertyCapacity,
          sizeof(EncodedJSValue) * propertyCapacity + sizeof(IndexingHeader) + ArrayStorage::sizeFor(0));
      return IndexingHeader::fromEndOf(propertyStorage() + numberOfSlots)-&gt;butterfly();
  }
</pre>
<center><a href="Butterfly.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CachePayload.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
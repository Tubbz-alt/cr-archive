<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2 *  Copyright (C) 1999-2002 Harri Porten (porten@kde.org)
   3 *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4 *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5 *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6 *  Copyright (C) 2007 Maks Orlovich
   7 *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2012 Igalia, S.L.
   9 *
  10 *  This library is free software; you can redistribute it and/or
  11 *  modify it under the terms of the GNU Library General Public
  12 *  License as published by the Free Software Foundation; either
  13 *  version 2 of the License, or (at your option) any later version.
  14 *
  15 *  This library is distributed in the hope that it will be useful,
  16 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  17 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18 *  Library General Public License for more details.
  19 *
  20 *  You should have received a copy of the GNU Library General Public License
  21 *  along with this library; see the file COPYING.LIB.  If not, write to
  22 *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  23 *  Boston, MA 02110-1301, USA.
  24 *
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;NodeConstructors.h&quot;
  30 
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  33 #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  34 #include &quot;CallFrame.h&quot;
  35 #include &quot;JIT.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  36 #include &quot;JSArrayIterator.h&quot;</span>
<span class="line-added">  37 #include &quot;JSAsyncGenerator.h&quot;</span>
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSFunction.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  40 #include &quot;JSGenerator.h&quot;</span>
  41 #include &quot;JSGlobalObject.h&quot;
  42 #include &quot;JSImmutableButterfly.h&quot;
<a name="4" id="anc4"></a><span class="line-added">  43 #include &quot;JSStringIterator.h&quot;</span>
  44 #include &quot;LabelScope.h&quot;
  45 #include &quot;Lexer.h&quot;
  46 #include &quot;Parser.h&quot;
  47 #include &quot;StackAlignment.h&quot;
  48 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  49 #include &quot;YarrFlags.h&quot;
  50 #include &lt;wtf/Assertions.h&gt;
  51 #include &lt;wtf/Threading.h&gt;
  52 #include &lt;wtf/text/StringBuilder.h&gt;
  53 
  54 namespace JSC {
  55 
  56 /*
  57     Details of the emitBytecode function.
  58 
  59     Return value: The register holding the production&#39;s value.
  60              dst: An optional parameter specifying the most efficient destination at
  61                   which to store the production&#39;s value. The callee must honor dst.
  62 
  63     The dst argument provides for a crude form of copy propagation. For example,
  64 
  65         x = 1
  66 
  67     becomes
  68 
  69         load r[x], 1
  70 
  71     instead of
  72 
  73         load r0, 1
  74         mov r[x], r0
  75 
  76     because the assignment node, &quot;x =&quot;, passes r[x] as dst to the number node, &quot;1&quot;.
  77 */
  78 
  79 void ExpressionNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
  80 {
  81     RegisterID* result = generator.emitNode(this);
  82     if (fallThroughMode == FallThroughMeansTrue)
  83         generator.emitJumpIfFalse(result, falseTarget);
  84     else
  85         generator.emitJumpIfTrue(result, trueTarget);
  86 }
  87 
  88 // ------------------------------ ThrowableExpressionData --------------------------------
  89 
  90 RegisterID* ThrowableExpressionData::emitThrowReferenceError(BytecodeGenerator&amp; generator, const String&amp; message)
  91 {
  92     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
  93     generator.emitThrowReferenceError(message);
  94     return generator.newTemporary();
  95 }
  96 
  97 // ------------------------------ ConstantNode ----------------------------------
  98 
  99 void ConstantNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
 100 {
 101     TriState value = jsValue(generator).pureToBoolean();
 102 
 103     if (UNLIKELY(needsDebugHook())) {
 104         if (value != MixedTriState)
 105             generator.emitDebugHook(this);
 106     }
 107 
 108     if (value == MixedTriState)
 109         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
 110     else if (value == TrueTriState &amp;&amp; fallThroughMode == FallThroughMeansFalse)
 111         generator.emitJump(trueTarget);
 112     else if (value == FalseTriState &amp;&amp; fallThroughMode == FallThroughMeansTrue)
 113         generator.emitJump(falseTarget);
 114 
 115     // All other cases are unconditional fall-throughs, like &quot;if (true)&quot;.
 116 }
 117 
 118 RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 119 {
 120     if (dst == generator.ignoredResult())
 121         return 0;
<a name="5" id="anc5"></a><span class="line-modified"> 122     JSValue constant = jsValue(generator);</span>
<span class="line-added"> 123     if (UNLIKELY(!constant)) {</span>
<span class="line-added"> 124         // This can happen if we try to parse a string or BigInt so enormous that we OOM.</span>
<span class="line-added"> 125         return generator.emitThrowExpressionTooDeepException();</span>
<span class="line-added"> 126     }</span>
<span class="line-added"> 127     return generator.emitLoad(dst, constant);</span>
 128 }
 129 
 130 JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
 131 {
 132     return generator.addStringConstant(m_value);
 133 }
 134 
 135 JSValue BigIntNode::jsValue(BytecodeGenerator&amp; generator) const
 136 {
 137     return generator.addBigIntConstant(m_value, m_radix, m_sign);
 138 }
 139 
 140 // ------------------------------ NumberNode ----------------------------------
 141 
 142 RegisterID* NumberNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 143 {
 144     if (dst == generator.ignoredResult())
 145         return nullptr;
 146     return generator.emitLoad(dst, jsValue(generator), isIntegerNode() ? SourceCodeRepresentation::Integer : SourceCodeRepresentation::Double);
 147 }
 148 
 149 // ------------------------------ RegExpNode -----------------------------------
 150 
 151 RegisterID* RegExpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 152 {
 153     if (dst == generator.ignoredResult())
 154         return nullptr;
 155 
 156     auto flags = Yarr::parseFlags(m_flags.string());
 157     ASSERT(flags.hasValue());
 158     RegExp* regExp = RegExp::create(generator.vm(), m_pattern.string(), flags.value());
 159     if (regExp-&gt;isValid())
 160         return generator.emitNewRegExp(generator.finalDestination(dst), regExp);
 161 
 162     const char* messageCharacters = regExp-&gt;errorMessage();
 163     const Identifier&amp; message = generator.parserArena().identifierArena().makeIdentifier(generator.vm(), bitwise_cast&lt;const LChar*&gt;(messageCharacters), strlen(messageCharacters));
 164     generator.emitThrowStaticError(ErrorType::SyntaxError, message);
 165     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
 166 }
 167 
 168 // ------------------------------ ThisNode -------------------------------------
 169 
 170 RegisterID* ThisNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 171 {
 172     generator.ensureThis();
 173     if (dst == generator.ignoredResult())
 174         return 0;
 175 
 176     RegisterID* result = generator.move(dst, generator.thisRegister());
<a name="6" id="anc6"></a><span class="line-modified"> 177     static const unsigned thisLength = strlen(&quot;this&quot;);</span>
<span class="line-modified"> 178     generator.emitProfileType(generator.thisRegister(), position(), position() + thisLength);</span>
 179     return result;
 180 }
 181 
 182 // ------------------------------ SuperNode -------------------------------------
 183 
 184 static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
 185 {
<a name="7" id="anc7"></a><span class="line-modified"> 186     if ((generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) &amp;&amp; generator.parseMode() != SourceParseMode::InstanceFieldInitializerMode) {</span>
 187         RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
 188         return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
 189     }
 190 
 191     RegisterID callee;
 192     callee.setIndex(CallFrameSlot::callee);
 193     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().builtinNames().homeObjectPrivateName());
 194 }
 195 
 196 static RegisterID* emitSuperBaseForCallee(BytecodeGenerator&amp; generator)
 197 {
 198     RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
 199     return generator.emitGetById(generator.newTemporary(), homeObject.get(), generator.propertyNames().underscoreProto);
 200 }
 201 
 202 static RegisterID* emitGetSuperFunctionForConstruct(BytecodeGenerator&amp; generator)
 203 {
 204     if (generator.isDerivedConstructorContext())
 205         return generator.emitGetById(generator.newTemporary(), generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment(), generator.propertyNames().underscoreProto);
 206 
 207     RegisterID callee;
 208     callee.setIndex(CallFrameSlot::callee);
 209     return generator.emitGetById(generator.newTemporary(), &amp;callee, generator.propertyNames().underscoreProto);
 210 }
 211 
 212 RegisterID* SuperNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 213 {
 214     RegisterID* result = emitSuperBaseForCallee(generator);
 215     return generator.move(generator.finalDestination(dst), result);
 216 }
 217 
 218 // ------------------------------ ImportNode -------------------------------------
 219 
 220 RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 221 {
<a name="8" id="anc8"></a><span class="line-modified"> 222     RefPtr&lt;RegisterID&gt; importModule = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::importModule);</span>
 223     CallArguments arguments(generator, nullptr, 1);
 224     generator.emitLoad(arguments.thisRegister(), jsUndefined());
 225     generator.emitNode(arguments.argumentRegister(0), m_expr);
 226     return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 227 }
 228 
 229 // ------------------------------ NewTargetNode ----------------------------------
 230 
 231 RegisterID* NewTargetNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 232 {
 233     if (dst == generator.ignoredResult())
 234         return nullptr;
 235 
 236     return generator.move(dst, generator.newTarget());
 237 }
 238 
 239 // ------------------------------ ImportMetaNode ---------------------------------
 240 
 241 RegisterID* ImportMetaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 242 {
 243     return generator.emitNode(dst, m_expr);
 244 }
 245 
 246 // ------------------------------ ResolveNode ----------------------------------
 247 
 248 bool ResolveNode::isPure(BytecodeGenerator&amp; generator) const
 249 {
 250     return generator.variable(m_ident).offset().isStack();
 251 }
 252 
 253 RegisterID* ResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 254 {
 255     Variable var = generator.variable(m_ident);
 256     if (RegisterID* local = var.local()) {
 257         generator.emitTDZCheckIfNecessary(var, local, nullptr);
 258         if (dst == generator.ignoredResult())
 259             return nullptr;
 260 
<a name="9" id="anc9"></a><span class="line-modified"> 261         generator.emitProfileType(local, var, m_position, m_position + m_ident.length());</span>
 262         return generator.move(dst, local);
 263     }
 264 
 265     JSTextPosition divot = m_start + m_ident.length();
 266     generator.emitExpressionInfo(divot, m_start, divot);
 267     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
 268     RegisterID* finalDest = generator.finalDestination(dst);
 269     RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
 270     generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
 271     generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
 272     generator.move(finalDest, uncheckedResult.get());
<a name="10" id="anc10"></a><span class="line-modified"> 273     generator.emitProfileType(finalDest, var, m_position, m_position + m_ident.length());</span>
 274     return finalDest;
 275 }
 276 
 277 // ------------------------------ TemplateStringNode -----------------------------------
 278 
 279 RegisterID* TemplateStringNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 280 {
 281     if (dst == generator.ignoredResult())
 282         return nullptr;
 283     ASSERT(cooked());
 284     return generator.emitLoad(dst, JSValue(generator.addStringConstant(*cooked())));
 285 }
 286 
 287 // ------------------------------ TemplateLiteralNode -----------------------------------
 288 
 289 RegisterID* TemplateLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 290 {
 291     if (!m_templateExpressions) {
 292         TemplateStringNode* templateString = m_templateStrings-&gt;value();
 293         ASSERT_WITH_MESSAGE(!m_templateStrings-&gt;next(), &quot;Only one template element exists because there&#39;s no expression in a given template literal.&quot;);
 294         return generator.emitNode(dst, templateString);
 295     }
 296 
 297     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
 298 
 299     TemplateStringListNode* templateString = m_templateStrings;
 300     TemplateExpressionListNode* templateExpression = m_templateExpressions;
 301     for (; templateExpression; templateExpression = templateExpression-&gt;next(), templateString = templateString-&gt;next()) {
 302         // Evaluate TemplateString.
 303         ASSERT(templateString-&gt;value()-&gt;cooked());
 304         if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 305             temporaryRegisters.append(generator.newTemporary());
 306             generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 307         }
 308 
 309         // Evaluate Expression.
 310         temporaryRegisters.append(generator.newTemporary());
 311         generator.emitNode(temporaryRegisters.last().get(), templateExpression-&gt;value());
 312         generator.emitToString(temporaryRegisters.last().get(), temporaryRegisters.last().get());
 313     }
 314 
 315     // Evaluate tail TemplateString.
 316     ASSERT(templateString-&gt;value()-&gt;cooked());
 317     if (!templateString-&gt;value()-&gt;cooked()-&gt;isEmpty()) {
 318         temporaryRegisters.append(generator.newTemporary());
 319         generator.emitNode(temporaryRegisters.last().get(), templateString-&gt;value());
 320     }
 321 
 322     if (temporaryRegisters.size() == 1)
 323         return generator.emitToString(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get());
 324 
 325     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
 326 }
 327 
 328 // ------------------------------ TaggedTemplateNode -----------------------------------
 329 
 330 RegisterID* TaggedTemplateNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 331 {
 332     ExpectedFunction expectedFunction = NoExpectedFunction;
 333     RefPtr&lt;RegisterID&gt; tag = nullptr;
 334     RefPtr&lt;RegisterID&gt; base = nullptr;
 335     if (!m_tag-&gt;isLocation()) {
 336         tag = generator.newTemporary();
 337         tag = generator.emitNode(tag.get(), m_tag);
 338     } else if (m_tag-&gt;isResolveNode()) {
 339         ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_tag);
 340         const Identifier&amp; identifier = resolve-&gt;identifier();
 341         expectedFunction = generator.expectedFunctionForIdentifier(identifier);
 342 
 343         Variable var = generator.variable(identifier);
 344         if (RegisterID* local = var.local()) {
 345             generator.emitTDZCheckIfNecessary(var, local, nullptr);
 346             tag = generator.move(generator.newTemporary(), local);
 347         } else {
 348             tag = generator.newTemporary();
 349             base = generator.newTemporary();
 350 
 351             JSTextPosition newDivot = divotStart() + identifier.length();
 352             generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 353             generator.move(base.get(), generator.emitResolveScope(base.get(), var));
 354             generator.emitGetFromScope(tag.get(), base.get(), var, ThrowIfNotFound);
 355             generator.emitTDZCheckIfNecessary(var, tag.get(), nullptr);
 356         }
 357     } else if (m_tag-&gt;isBracketAccessorNode()) {
 358         BracketAccessorNode* bracket = static_cast&lt;BracketAccessorNode*&gt;(m_tag);
 359         base = generator.newTemporary();
 360         base = generator.emitNode(base.get(), bracket-&gt;base());
 361         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(bracket-&gt;subscript());
 362         if (bracket-&gt;base()-&gt;isSuperNode()) {
 363             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 364             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
 365         } else
 366             tag = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
 367     } else {
 368         ASSERT(m_tag-&gt;isDotAccessorNode());
 369         DotAccessorNode* dot = static_cast&lt;DotAccessorNode*&gt;(m_tag);
 370         base = generator.newTemporary();
 371         base = generator.emitNode(base.get(), dot-&gt;base());
 372         if (dot-&gt;base()-&gt;isSuperNode()) {
 373             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 374             tag = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), dot-&gt;identifier());
 375         } else
 376             tag = generator.emitGetById(generator.newTemporary(), base.get(), dot-&gt;identifier());
 377     }
 378 
 379     RefPtr&lt;RegisterID&gt; templateObject = generator.emitGetTemplateObject(nullptr, this);
 380 
 381     unsigned expressionsCount = 0;
 382     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 383         ++expressionsCount;
 384 
 385     CallArguments callArguments(generator, nullptr, 1 + expressionsCount);
 386     if (base)
 387         generator.move(callArguments.thisRegister(), base.get());
 388     else
 389         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 390 
 391     unsigned argumentIndex = 0;
 392     generator.move(callArguments.argumentRegister(argumentIndex++), templateObject.get());
 393     for (TemplateExpressionListNode* templateExpression = m_templateLiteral-&gt;templateExpressions(); templateExpression; templateExpression = templateExpression-&gt;next())
 394         generator.emitNode(callArguments.argumentRegister(argumentIndex++), templateExpression-&gt;value());
 395 
 396     return generator.emitCallInTailPosition(generator.finalDestination(dst, tag.get()), tag.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 397 }
 398 
 399 // ------------------------------ ArrayNode ------------------------------------
 400 
 401 RegisterID* ArrayNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 402 {
 403     bool hadVariableExpression = false;
 404     unsigned length = 0;
 405 
 406     IndexingType recommendedIndexingType = ArrayWithUndecided;
 407     ElementNode* firstPutElement;
 408     for (firstPutElement = m_element; firstPutElement; firstPutElement = firstPutElement-&gt;next()) {
 409         if (firstPutElement-&gt;elision() || firstPutElement-&gt;value()-&gt;isSpreadExpression())
 410             break;
 411         if (!firstPutElement-&gt;value()-&gt;isConstant())
 412             hadVariableExpression = true;
 413         else
 414             recommendedIndexingType = leastUpperBoundOfIndexingTypeAndValue(recommendedIndexingType, static_cast&lt;ConstantNode*&gt;(firstPutElement-&gt;value())-&gt;jsValue(generator));
 415 
 416         ++length;
 417     }
 418 
 419     auto newArray = [&amp;] (RegisterID* dst, ElementNode* elements, unsigned length, bool hadVariableExpression) {
 420         if (length &amp;&amp; !hadVariableExpression) {
 421             recommendedIndexingType |= CopyOnWrite;
 422             ASSERT(generator.vm().heap.isDeferred()); // We run bytecode generator under a DeferGC. If we stopped doing that, we&#39;d need to put a DeferGC here as we filled in these slots.
 423             auto* array = JSImmutableButterfly::create(generator.vm(), recommendedIndexingType, length);
 424             unsigned index = 0;
 425             for (ElementNode* element = elements; index &lt; length; element = element-&gt;next()) {
 426                 ASSERT(element-&gt;value()-&gt;isConstant());
 427                 array-&gt;setIndex(generator.vm(), index++, static_cast&lt;ConstantNode*&gt;(element-&gt;value())-&gt;jsValue(generator));
 428             }
 429             return generator.emitNewArrayBuffer(dst, array, recommendedIndexingType);
 430         }
 431         return generator.emitNewArray(dst, elements, length, recommendedIndexingType);
 432     };
 433 
 434     if (!firstPutElement &amp;&amp; !m_elision)
 435         return newArray(generator.finalDestination(dst), m_element, length, hadVariableExpression);
 436 
 437     if (firstPutElement &amp;&amp; firstPutElement-&gt;value()-&gt;isSpreadExpression()) {
 438         bool hasElision = m_elision;
 439         if (!hasElision) {
 440             for (ElementNode* node = firstPutElement; node; node = node-&gt;next()) {
 441                 if (node-&gt;elision()) {
 442                     hasElision = true;
 443                     break;
 444                 }
 445             }
 446         }
 447 
 448         if (!hasElision)
 449             return generator.emitNewArrayWithSpread(generator.finalDestination(dst), m_element);
 450     }
 451 
 452     RefPtr&lt;RegisterID&gt; array = newArray(generator.tempDestination(dst), m_element, length, hadVariableExpression);
 453     ElementNode* n = firstPutElement;
 454     for (; n; n = n-&gt;next()) {
 455         if (n-&gt;value()-&gt;isSpreadExpression())
 456             goto handleSpread;
 457         RefPtr&lt;RegisterID&gt; value = generator.emitNode(n-&gt;value());
 458         length += n-&gt;elision();
 459 
 460         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(length++));
 461         generator.emitDirectPutByVal(array.get(), index.get(), value.get());
 462     }
 463 
 464     if (m_elision) {
 465         RegisterID* value = generator.emitLoad(0, jsNumber(m_elision + length));
 466         generator.emitPutById(array.get(), generator.propertyNames().length, value);
 467     }
 468 
 469     return generator.move(dst, array.get());
 470 
 471 handleSpread:
 472     RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(length));
 473     auto spreader = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([array, index](BytecodeGenerator&amp; generator, RegisterID* value)
 474     {
 475         generator.emitDirectPutByVal(array.get(), index.get(), value);
 476         generator.emitInc(index.get());
 477     });
 478     for (; n; n = n-&gt;next()) {
 479         if (n-&gt;elision())
 480             generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(n-&gt;elision())), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 481         if (n-&gt;value()-&gt;isSpreadExpression()) {
 482             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;value());
 483             generator.emitEnumeration(spread, spread-&gt;expression(), spreader);
 484         } else {
 485             generator.emitDirectPutByVal(array.get(), index.get(), generator.emitNode(n-&gt;value()));
 486             generator.emitInc(index.get());
 487         }
 488     }
 489 
 490     if (m_elision) {
 491         generator.emitBinaryOp&lt;OpAdd&gt;(index.get(), index.get(), generator.emitLoad(0, jsNumber(m_elision)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
 492         generator.emitPutById(array.get(), generator.propertyNames().length, index.get());
 493     }
 494     return generator.move(dst, array.get());
 495 }
 496 
 497 bool ArrayNode::isSimpleArray() const
 498 {
 499     if (m_elision || m_optional)
 500         return false;
 501     for (ElementNode* ptr = m_element; ptr; ptr = ptr-&gt;next()) {
 502         if (ptr-&gt;elision())
 503             return false;
 504         if (ptr-&gt;value()-&gt;isSpreadExpression())
 505             return false;
 506     }
 507     return true;
 508 }
 509 
 510 ArgumentListNode* ArrayNode::toArgumentList(ParserArena&amp; parserArena, int lineNumber, int startPosition) const
 511 {
 512     ASSERT(!m_elision &amp;&amp; !m_optional);
 513     ElementNode* ptr = m_element;
 514     if (!ptr)
 515         return 0;
 516     JSTokenLocation location;
 517     location.line = lineNumber;
 518     location.startOffset = startPosition;
 519     ArgumentListNode* head = new (parserArena) ArgumentListNode(location, ptr-&gt;value());
 520     ArgumentListNode* tail = head;
 521     ptr = ptr-&gt;next();
 522     for (; ptr; ptr = ptr-&gt;next()) {
 523         ASSERT(!ptr-&gt;elision());
 524         tail = new (parserArena) ArgumentListNode(location, tail, ptr-&gt;value());
 525     }
 526     return head;
 527 }
 528 
 529 // ------------------------------ ObjectLiteralNode ----------------------------
 530 
 531 RegisterID* ObjectLiteralNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 532 {
 533     if (!m_list) {
 534         if (dst == generator.ignoredResult())
 535             return 0;
 536         return generator.emitNewObject(generator.finalDestination(dst));
 537     }
 538     RefPtr&lt;RegisterID&gt; newObj = generator.emitNewObject(generator.tempDestination(dst));
 539     generator.emitNode(newObj.get(), m_list);
 540     return generator.move(dst, newObj.get());
 541 }
 542 
 543 // ------------------------------ PropertyListNode -----------------------------
 544 
 545 static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
 546 {
 547     generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
 548 }
 549 
<a name="11" id="anc11"></a><span class="line-modified"> 550 RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype, Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
 551 {
 552     // Fast case: this loop just handles regular value properties.
 553     PropertyListNode* p = this;
 554     RegisterID* dst = nullptr;
 555     for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
 556         dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
<a name="12" id="anc12"></a><span class="line-added"> 557 </span>
<span class="line-added"> 558         if (p-&gt;isComputedClassField())</span>
<span class="line-added"> 559             emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561         if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added"> 562             ASSERT(instanceFieldLocations);</span>
<span class="line-added"> 563             instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added"> 564             continue;</span>
<span class="line-added"> 565         }</span>
<span class="line-added"> 566 </span>
 567         emitPutConstantProperty(generator, dst, *p-&gt;m_node);
 568     }
 569 
 570     // Were there any get/set properties?
 571     if (p) {
 572         // Build a list of getter/setter pairs to try to put them at the same time. If we encounter
 573         // a computed property or a spread, just emit everything as that may override previous values.
 574         bool canOverrideProperties = false;
 575 
 576         typedef std::pair&lt;PropertyNode*, PropertyNode*&gt; GetterSetterPair;
 577         typedef HashMap&lt;UniquedStringImpl*, GetterSetterPair, IdentifierRepHash&gt; GetterSetterMap;
 578         GetterSetterMap instanceMap;
 579         GetterSetterMap staticMap;
 580 
 581         // Build a map, pairing get/set values together.
 582         for (PropertyListNode* q = p; q; q = q-&gt;m_next) {
 583             PropertyNode* node = q-&gt;m_node;
 584             if (node-&gt;m_type &amp; PropertyNode::Computed || node-&gt;m_type &amp; PropertyNode::Spread) {
 585                 canOverrideProperties = true;
 586                 break;
 587             }
 588 
 589             if (node-&gt;m_type &amp; PropertyNode::Constant)
 590                 continue;
 591 
 592             // Duplicates are possible.
 593             GetterSetterPair pair(node, static_cast&lt;PropertyNode*&gt;(nullptr));
 594             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 595             GetterSetterMap::AddResult result = map.add(node-&gt;name()-&gt;impl(), pair);
 596             auto&amp; resultPair = result.iterator-&gt;value;
 597             if (!result.isNewEntry) {
 598                 if (resultPair.first-&gt;m_type == node-&gt;m_type) {
 599                     resultPair.first-&gt;setIsOverriddenByDuplicate();
 600                     resultPair.first = node;
 601                 } else {
 602                     if (resultPair.second)
 603                         resultPair.second-&gt;setIsOverriddenByDuplicate();
 604                     resultPair.second = node;
 605                 }
 606             }
 607         }
 608 
 609         // Iterate over the remaining properties in the list.
 610         for (; p; p = p-&gt;m_next) {
 611             PropertyNode* node = p-&gt;m_node;
 612             dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
 613 
<a name="13" id="anc13"></a><span class="line-added"> 614             if (p-&gt;isComputedClassField())</span>
<span class="line-added"> 615                 emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added"> 616 </span>
<span class="line-added"> 617             if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added"> 618                 ASSERT(instanceFieldLocations);</span>
<span class="line-added"> 619                 ASSERT(node-&gt;m_type &amp; PropertyNode::Constant);</span>
<span class="line-added"> 620                 instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added"> 621                 continue;</span>
<span class="line-added"> 622             }</span>
<span class="line-added"> 623 </span>
 624             // Handle regular values.
 625             if (node-&gt;m_type &amp; PropertyNode::Constant) {
 626                 emitPutConstantProperty(generator, dst, *node);
 627                 continue;
 628             } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
 629                 generator.emitNode(dst, node-&gt;m_assign);
 630                 continue;
 631             }
 632 
 633             RefPtr&lt;RegisterID&gt; value = generator.emitNode(node-&gt;m_assign);
 634             bool needsSuperBinding = node-&gt;needsSuperBinding();
 635             if (needsSuperBinding)
 636                 emitPutHomeObject(generator, value.get(), dst);
 637 
 638             unsigned attributes = node-&gt;isClassProperty() ? (PropertyAttribute::Accessor | PropertyAttribute::DontEnum) : static_cast&lt;unsigned&gt;(PropertyAttribute::Accessor);
 639 
 640             ASSERT(node-&gt;m_type &amp; (PropertyNode::Getter | PropertyNode::Setter));
 641 
 642             // This is a get/set property which may be overridden by a computed property or spread later.
 643             if (canOverrideProperties) {
 644                 // Computed accessors.
 645                 if (node-&gt;m_type &amp; PropertyNode::Computed) {
 646                     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node-&gt;m_expression);
 647                     generator.emitSetFunctionNameIfNeeded(node-&gt;m_assign, value.get(), propertyName.get());
 648                     if (node-&gt;m_type &amp; PropertyNode::Getter)
 649                         generator.emitPutGetterByVal(dst, propertyName.get(), attributes, value.get());
 650                     else
 651                         generator.emitPutSetterByVal(dst, propertyName.get(), attributes, value.get());
 652                     continue;
 653                 }
 654 
 655                 if (node-&gt;m_type &amp; PropertyNode::Getter)
 656                     generator.emitPutGetterById(dst, *node-&gt;name(), attributes, value.get());
 657                 else
 658                     generator.emitPutSetterById(dst, *node-&gt;name(), attributes, value.get());
 659                 continue;
 660             }
 661 
 662             // This is a get/set property pair.
 663             GetterSetterMap&amp; map = node-&gt;isStaticClassProperty() ? staticMap : instanceMap;
 664             GetterSetterMap::iterator it = map.find(node-&gt;name()-&gt;impl());
 665             ASSERT(it != map.end());
 666             GetterSetterPair&amp; pair = it-&gt;value;
 667 
 668             // Was this already generated as a part of its partner?
 669             if (pair.second == node || node-&gt;isOverriddenByDuplicate())
 670                 continue;
 671 
 672             // Generate the paired node now.
 673             RefPtr&lt;RegisterID&gt; getterReg;
 674             RefPtr&lt;RegisterID&gt; setterReg;
 675             RegisterID* secondReg = nullptr;
 676 
 677             if (node-&gt;m_type &amp; PropertyNode::Getter) {
 678                 getterReg = value;
 679                 if (pair.second) {
 680                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Setter);
 681                     setterReg = generator.emitNode(pair.second-&gt;m_assign);
 682                     secondReg = setterReg.get();
 683                 } else {
 684                     setterReg = generator.newTemporary();
 685                     generator.emitLoad(setterReg.get(), jsUndefined());
 686                 }
 687             } else {
 688                 ASSERT(node-&gt;m_type &amp; PropertyNode::Setter);
 689                 setterReg = value;
 690                 if (pair.second) {
 691                     ASSERT(pair.second-&gt;m_type &amp; PropertyNode::Getter);
 692                     getterReg = generator.emitNode(pair.second-&gt;m_assign);
 693                     secondReg = getterReg.get();
 694                 } else {
 695                     getterReg = generator.newTemporary();
 696                     generator.emitLoad(getterReg.get(), jsUndefined());
 697                 }
 698             }
 699 
 700             ASSERT(!pair.second || needsSuperBinding == pair.second-&gt;needsSuperBinding());
 701             if (needsSuperBinding &amp;&amp; pair.second)
 702                 emitPutHomeObject(generator, secondReg, dst);
 703 
 704             generator.emitPutGetterSetter(dst, *node-&gt;name(), attributes, getterReg.get(), setterReg.get());
 705         }
 706     }
 707 
 708     return dstOrConstructor;
 709 }
 710 
 711 void PropertyListNode::emitPutConstantProperty(BytecodeGenerator&amp; generator, RegisterID* newObj, PropertyNode&amp; node)
 712 {
 713     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node.m_assign);
 714     if (node.needsSuperBinding())
 715         emitPutHomeObject(generator, value.get(), newObj);
 716 
 717     if (node.isClassProperty()) {
 718         ASSERT(node.needsSuperBinding());
 719         RefPtr&lt;RegisterID&gt; propertyNameRegister;
 720         if (node.name())
 721             propertyNameRegister = generator.emitLoad(nullptr, *node.name());
 722         else
 723             propertyNameRegister = generator.emitNode(node.m_expression);
 724 
 725         generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyNameRegister.get());
 726         generator.emitCallDefineProperty(newObj, propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
 727         return;
 728     }
 729     if (const auto* identifier = node.name()) {
 730         Optional&lt;uint32_t&gt; optionalIndex = parseIndex(*identifier);
 731         if (!optionalIndex) {
 732             generator.emitDirectPutById(newObj, *identifier, value.get(), node.putType());
 733             return;
 734         }
 735 
 736         RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
 737         generator.emitDirectPutByVal(newObj, index.get(), value.get());
 738         return;
 739     }
 740     RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
 741     generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
 742     generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
 743 }
 744 
<a name="14" id="anc14"></a><span class="line-added"> 745 void PropertyListNode::emitSaveComputedFieldName(BytecodeGenerator&amp; generator, PropertyNode&amp; node)</span>
<span class="line-added"> 746 {</span>
<span class="line-added"> 747     ASSERT(node.isComputedClassField());</span>
<span class="line-added"> 748     RefPtr&lt;RegisterID&gt; propertyExpr;</span>
<span class="line-added"> 749 </span>
<span class="line-added"> 750     // The &#39;name&#39; refers to a synthetic numeric variable name in the private name scope, where the property key is saved for later use.</span>
<span class="line-added"> 751     const Identifier&amp; description = *node.name();</span>
<span class="line-added"> 752     Variable var = generator.variable(description);</span>
<span class="line-added"> 753     ASSERT(!var.local());</span>
<span class="line-added"> 754 </span>
<span class="line-added"> 755     propertyExpr = generator.emitNode(node.m_expression);</span>
<span class="line-added"> 756     RegisterID* propertyName = generator.emitToPropertyKey(generator.newTemporary(), propertyExpr.get());</span>
<span class="line-added"> 757 </span>
<span class="line-added"> 758     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);</span>
<span class="line-added"> 759     generator.emitPutToScope(scope.get(), var, propertyName, ThrowIfNotFound, InitializationMode::ConstInitialization);</span>
<span class="line-added"> 760 }</span>
<span class="line-added"> 761 </span>
 762 // ------------------------------ BracketAccessorNode --------------------------------
 763 
 764 static bool isNonIndexStringElement(ExpressionNode&amp; element)
 765 {
 766     return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
 767 }
 768 
 769 RegisterID* BracketAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 770 {
 771     if (m_base-&gt;isSuperNode()) {
 772         RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 773         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 774         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
 775 
 776         if (isNonIndexStringElement(*m_subscript)) {
 777             const Identifier&amp; id = static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value();
 778             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 779             generator.emitGetById(finalDest.get(), superBase.get(), thisValue.get(), id);
 780         } else  {
 781             RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(m_subscript);
 782             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 783             generator.emitGetByVal(finalDest.get(), superBase.get(), thisValue.get(), subscript.get());
 784         }
 785 
 786         generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 787         return finalDest.get();
 788     }
 789 
 790     RegisterID* ret;
 791     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 792 
 793     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
 794     RefPtr&lt;RegisterID&gt; base = subscriptIsNonIndexString
 795         ? generator.emitNode(m_base)
 796         : generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
 797 
 798     if (m_base-&gt;isOptionalChainBase())
 799         generator.emitOptionalCheck(base.get());
 800 
 801     if (subscriptIsNonIndexString) {
 802         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 803         ret = generator.emitGetById(finalDest.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
 804     } else {
 805         RegisterID* property = generator.emitNodeForProperty(m_subscript);
 806         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 807         ret = generator.emitGetByVal(finalDest.get(), base.get(), property);
 808     }
 809 
 810     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 811     return ret;
 812 }
 813 
 814 // ------------------------------ DotAccessorNode --------------------------------
 815 
 816 RegisterID* DotAccessorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 817 {
 818     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
 819     bool baseIsSuper = m_base-&gt;isSuperNode();
 820 
 821     RefPtr&lt;RegisterID&gt; base;
 822     if (baseIsSuper)
 823         base = emitSuperBaseForCallee(generator);
 824     else {
 825         base = generator.emitNode(m_base);
 826         if (m_base-&gt;isOptionalChainBase())
 827             generator.emitOptionalCheck(base.get());
 828     }
 829 
 830     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
 831     RegisterID* ret;
 832     if (baseIsSuper) {
 833         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
 834         ret = generator.emitGetById(finalDest.get(), base.get(), thisValue.get(), m_ident);
 835     } else
 836         ret = generator.emitGetById(finalDest.get(), base.get(), m_ident);
 837     generator.emitProfileType(finalDest.get(), divotStart(), divotEnd());
 838     return ret;
 839 }
 840 
 841 // ------------------------------ ArgumentListNode -----------------------------
 842 
 843 RegisterID* ArgumentListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 844 {
 845     ASSERT(m_expr);
 846     return generator.emitNode(dst, m_expr);
 847 }
 848 
 849 // ------------------------------ NewExprNode ----------------------------------
 850 
 851 RegisterID* NewExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 852 {
 853     ExpectedFunction expectedFunction;
 854     if (m_expr-&gt;isResolveNode())
 855         expectedFunction = generator.expectedFunctionForIdentifier(static_cast&lt;ResolveNode*&gt;(m_expr)-&gt;identifier());
 856     else
 857         expectedFunction = NoExpectedFunction;
 858     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 859     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 860     CallArguments callArguments(generator, m_args);
 861     return generator.emitConstruct(returnValue.get(), func.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd());
 862 }
 863 
 864 CallArguments::CallArguments(BytecodeGenerator&amp; generator, ArgumentsNode* argumentsNode, unsigned additionalArguments)
 865     : m_argumentsNode(argumentsNode)
 866     , m_padding(0)
 867 {
 868     size_t argumentCountIncludingThis = 1 + additionalArguments; // &#39;this&#39; register.
 869     if (argumentsNode) {
 870         for (ArgumentListNode* node = argumentsNode-&gt;m_listNode; node; node = node-&gt;m_next)
 871             ++argumentCountIncludingThis;
 872     }
 873 
 874     m_argv.grow(argumentCountIncludingThis);
 875     for (int i = argumentCountIncludingThis - 1; i &gt;= 0; --i) {
 876         m_argv[i] = generator.newTemporary();
 877         ASSERT(static_cast&lt;size_t&gt;(i) == m_argv.size() - 1 || m_argv[i]-&gt;index() == m_argv[i + 1]-&gt;index() - 1);
 878     }
 879 
 880     // We need to ensure that the frame size is stack-aligned
 881     while ((CallFrame::headerSizeInRegisters + m_argv.size()) % stackAlignmentRegisters()) {
 882         m_argv.insert(0, generator.newTemporary());
 883         m_padding++;
 884     }
 885 
 886     while (stackOffset() % stackAlignmentRegisters()) {
 887         m_argv.insert(0, generator.newTemporary());
 888         m_padding++;
 889     }
 890 }
 891 
 892 // ------------------------------ EvalFunctionCallNode ----------------------------------
 893 
 894 RegisterID* EvalFunctionCallNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 895 {
 896     // We need try to load &#39;this&#39; before call eval in constructor, because &#39;this&#39; can created by &#39;super&#39; in some of the arrow function
 897     // var A = class A {
 898     //   constructor () { this.id = &#39;A&#39;; }
 899     // }
 900     //
 901     // var B = class B extend A {
 902     //    constructor () {
 903     //       var arrow = () =&gt; super();
 904     //       arrow();
 905     //       eval(&quot;this.id = &#39;B&#39;&quot;);
 906     //    }
 907     // }
 908     if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isThisUsedInInnerArrowFunction())
 909         generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 910 
 911     Variable var = generator.variable(generator.propertyNames().eval);
 912     RefPtr&lt;RegisterID&gt; local = var.local();
 913     RefPtr&lt;RegisterID&gt; func;
 914     if (local) {
 915         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
 916         func = generator.move(generator.tempDestination(dst), local.get());
 917     } else
 918         func = generator.newTemporary();
 919     CallArguments callArguments(generator, m_args);
 920 
 921     if (local)
 922         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 923     else {
 924         JSTextPosition newDivot = divotStart() + 4;
 925         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
 926         generator.move(
 927             callArguments.thisRegister(),
 928             generator.emitResolveScope(callArguments.thisRegister(), var));
 929         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
 930         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
 931     }
 932 
 933     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 934     if (isOptionalChainBase())
 935         generator.emitOptionalCheck(func.get());
 936 
 937     return generator.emitCallEval(returnValue.get(), func.get(), callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
 938 }
 939 
 940 // ------------------------------ FunctionCallValueNode ----------------------------------
 941 
 942 RegisterID* FunctionCallValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 943 {
 944     if (m_expr-&gt;isSuperNode()) {
 945         RefPtr&lt;RegisterID&gt; func = emitGetSuperFunctionForConstruct(generator);
 946         RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 947         CallArguments callArguments(generator, m_args);
 948 
 949         ASSERT(generator.isConstructor() || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 950         ASSERT(generator.constructorKind() == ConstructorKind::Extends || generator.derivedContextType() == DerivedContextType::DerivedConstructorContext);
 951         RegisterID* ret = generator.emitConstruct(returnValue.get(), func.get(), generator.newTarget(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd());
 952 
 953         bool isConstructorKindDerived = generator.constructorKind() == ConstructorKind::Extends;
 954         bool doWeUseArrowFunctionInConstructor = isConstructorKindDerived &amp;&amp; generator.needsToUpdateArrowFunctionContext();
 955 
 956         if (generator.isDerivedConstructorContext() || (doWeUseArrowFunctionInConstructor &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction()))
 957             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
 958 
 959         Ref&lt;Label&gt; thisIsEmptyLabel = generator.newLabel();
 960         generator.emitJumpIfTrue(generator.emitIsEmpty(generator.newTemporary(), generator.thisRegister()), thisIsEmptyLabel.get());
 961         generator.emitThrowReferenceError(&quot;&#39;super()&#39; can&#39;t be called more than once in a constructor.&quot;_s);
 962         generator.emitLabel(thisIsEmptyLabel.get());
 963 
 964         generator.move(generator.thisRegister(), ret);
 965 
 966         if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
 967             generator.emitPutThisToArrowFunctionContextScope();
 968 
<a name="15" id="anc15"></a><span class="line-added"> 969         // Initialize instance fields after super-call.</span>
<span class="line-added"> 970         if (Options::useClassFields() &amp;&amp; generator.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {</span>
<span class="line-added"> 971             ASSERT(generator.isConstructor() || generator.isDerivedConstructorContext());</span>
<span class="line-added"> 972             func = generator.emitLoadDerivedConstructor();</span>
<span class="line-added"> 973             generator.emitInstanceFieldInitializationIfNeeded(generator.thisRegister(), func.get(), divot(), divotStart(), divotEnd());</span>
<span class="line-added"> 974         }</span>
<span class="line-added"> 975 </span>
 976         return ret;
 977     }
 978 
 979     RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
 980     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
 981     if (isOptionalChainBase())
 982         generator.emitOptionalCheck(func.get());
 983 
 984     CallArguments callArguments(generator, m_args);
 985     generator.emitLoad(callArguments.thisRegister(), jsUndefined());
 986     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
 987     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
 988     return ret;
 989 }
 990 
 991 // ------------------------------ FunctionCallResolveNode ----------------------------------
 992 
 993 RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
 994 {
<a name="16" id="anc16"></a><span class="line-modified"> 995     if (!ASSERT_ENABLED) {</span>
<span class="line-modified"> 996         if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName()))</span>
 997             return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
 998     }
 999 
1000     ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
1001 
1002     Variable var = generator.variable(m_ident);
1003     RefPtr&lt;RegisterID&gt; local = var.local();
1004     RefPtr&lt;RegisterID&gt; func;
1005     if (local) {
1006         generator.emitTDZCheckIfNecessary(var, local.get(), nullptr);
1007         func = generator.move(generator.tempDestination(dst), local.get());
1008     } else
1009         func = generator.newTemporary();
1010     CallArguments callArguments(generator, m_args);
1011 
1012     if (local) {
1013         generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1014         // This passes NoExpectedFunction because we expect that if the function is in a
1015         // local variable, then it&#39;s not one of our built-in constructors.
1016         expectedFunction = NoExpectedFunction;
1017     } else {
1018         JSTextPosition newDivot = divotStart() + m_ident.length();
1019         generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
1020         generator.move(
1021             callArguments.thisRegister(),
1022             generator.emitResolveScope(callArguments.thisRegister(), var));
1023         generator.emitGetFromScope(func.get(), callArguments.thisRegister(), var, ThrowIfNotFound);
1024         generator.emitTDZCheckIfNecessary(var, func.get(), nullptr);
1025     }
1026 
1027     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
1028     if (isOptionalChainBase())
1029         generator.emitOptionalCheck(func.get());
1030 
1031     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), func.get(), expectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1032     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1033     return ret;
1034 }
1035 
1036 // ------------------------------ BytecodeIntrinsicNode ----------------------------------
1037 
1038 RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1039 {
<a name="17" id="anc17"></a><span class="line-modified">1040     if (m_entry.type() == BytecodeIntrinsicRegistry::Type::Emitter)</span>
<span class="line-added">1041         return (this-&gt;*m_entry.emitter())(generator, dst);</span>
<span class="line-added">1042     if (dst == generator.ignoredResult())</span>
<span class="line-added">1043         return nullptr;</span>
<span class="line-added">1044     return generator.moveLinkTimeConstant(dst, m_entry.linkTimeConstant());</span>
1045 }
1046 
1047 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1048 {
1049     ArgumentListNode* node = m_args-&gt;m_listNode;
1050     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1051     node = node-&gt;m_next;
1052     ASSERT(node-&gt;m_expr-&gt;isString());
1053     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1054     ASSERT(!node-&gt;m_next);
1055     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), ident);
1056 }
1057 
1058 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1059 {
1060     ArgumentListNode* node = m_args-&gt;m_listNode;
1061     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1062     node = node-&gt;m_next;
1063     ASSERT(node-&gt;m_expr-&gt;isString());
1064     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1065     ASSERT(symbol);
1066     ASSERT(!node-&gt;m_next);
1067     return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
1068 }
1069 
<a name="18" id="anc18"></a><span class="line-added">1070 static JSPromise::Field promiseInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1071 {</span>
<span class="line-added">1072     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1073     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldFlags)</span>
<span class="line-added">1074         return JSPromise::Field::Flags;</span>
<span class="line-added">1075     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldReactionsOrResult)</span>
<span class="line-added">1076         return JSPromise::Field::ReactionsOrResult;</span>
<span class="line-added">1077     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1078     return JSPromise::Field::Flags;</span>
<span class="line-added">1079 }</span>
<span class="line-added">1080 </span>
<span class="line-added">1081 static JSGenerator::Field generatorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1082 {</span>
<span class="line-added">1083     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1084     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">1085         return JSGenerator::Field::State;</span>
<span class="line-added">1086     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">1087         return JSGenerator::Field::Next;</span>
<span class="line-added">1088     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">1089         return JSGenerator::Field::This;</span>
<span class="line-added">1090     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">1091         return JSGenerator::Field::Frame;</span>
<span class="line-added">1092     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1093     return JSGenerator::Field::State;</span>
<span class="line-added">1094 }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096 static JSAsyncGenerator::Field asyncGeneratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1097 {</span>
<span class="line-added">1098     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1099     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">1100         return JSAsyncGenerator::Field::State;</span>
<span class="line-added">1101     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">1102         return JSAsyncGenerator::Field::Next;</span>
<span class="line-added">1103     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">1104         return JSAsyncGenerator::Field::This;</span>
<span class="line-added">1105     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">1106         return JSAsyncGenerator::Field::Frame;</span>
<span class="line-added">1107     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldSuspendReason)</span>
<span class="line-added">1108         return JSAsyncGenerator::Field::SuspendReason;</span>
<span class="line-added">1109     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueFirst)</span>
<span class="line-added">1110         return JSAsyncGenerator::Field::QueueFirst;</span>
<span class="line-added">1111     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueLast)</span>
<span class="line-added">1112         return JSAsyncGenerator::Field::QueueLast;</span>
<span class="line-added">1113     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1114     return JSAsyncGenerator::Field::State;</span>
<span class="line-added">1115 }</span>
<span class="line-added">1116 </span>
<span class="line-added">1117 static JSArrayIterator::Field arrayIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1118 {</span>
<span class="line-added">1119     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1120     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIndex)</span>
<span class="line-added">1121         return JSArrayIterator::Field::Index;</span>
<span class="line-added">1122     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIteratedObject)</span>
<span class="line-added">1123         return JSArrayIterator::Field::IteratedObject;</span>
<span class="line-added">1124     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldKind)</span>
<span class="line-added">1125         return JSArrayIterator::Field::Kind;</span>
<span class="line-added">1126     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1127     return JSArrayIterator::Field::Index;</span>
<span class="line-added">1128 }</span>
<span class="line-added">1129 </span>
<span class="line-added">1130 static JSStringIterator::Field stringIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">1131 {</span>
<span class="line-added">1132     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">1133     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIndex)</span>
<span class="line-added">1134         return JSStringIterator::Field::Index;</span>
<span class="line-added">1135     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIteratedString)</span>
<span class="line-added">1136         return JSStringIterator::Field::IteratedString;</span>
<span class="line-added">1137     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">1138     return JSStringIterator::Field::Index;</span>
<span class="line-added">1139 }</span>
<span class="line-added">1140 </span>
<span class="line-added">1141 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1142 {</span>
<span class="line-added">1143     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1144     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1145     node = node-&gt;m_next;</span>
<span class="line-added">1146     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1147     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1148     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">1149     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1150 </span>
<span class="line-added">1151     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1155 {</span>
<span class="line-added">1156     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1157     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1158     node = node-&gt;m_next;</span>
<span class="line-added">1159     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1160     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1161     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">1162     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1163 </span>
<span class="line-added">1164     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1165 }</span>
<span class="line-added">1166 </span>
<span class="line-added">1167 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1168 {</span>
<span class="line-added">1169     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1170     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1171     node = node-&gt;m_next;</span>
<span class="line-added">1172     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1173     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1174     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">1175     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1176 </span>
<span class="line-added">1177     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1178 }</span>
<span class="line-added">1179 </span>
<span class="line-added">1180 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1181 {</span>
<span class="line-added">1182     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1183     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1184     node = node-&gt;m_next;</span>
<span class="line-added">1185     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1186     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1187     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">1188     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1189 </span>
<span class="line-added">1190     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1191 }</span>
<span class="line-added">1192 </span>
<span class="line-added">1193 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1194 {</span>
<span class="line-added">1195     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1196     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1197     node = node-&gt;m_next;</span>
<span class="line-added">1198     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1199     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1200     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">1201     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1202 </span>
<span class="line-added">1203     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">1204 }</span>
<span class="line-added">1205 </span>
1206 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
1207 {
1208     ArgumentListNode* node = m_args-&gt;m_listNode;
1209     ASSERT(node-&gt;m_expr-&gt;isNumber());
1210     double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
1211     int32_t index = static_cast&lt;int32_t&gt;(value);
1212     ASSERT(value == index);
1213     ASSERT(index &gt;= 0);
1214     ASSERT(!node-&gt;m_next);
1215 
1216     // The body functions of generator and async have different mechanism for arguments.
1217     ASSERT(generator.parseMode() != SourceParseMode::GeneratorBodyMode);
1218     ASSERT(!isAsyncFunctionBodyParseMode(generator.parseMode()));
1219 
1220     return generator.emitGetArgument(generator.finalDestination(dst), index);
1221 }
1222 
1223 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argumentCount(BytecodeGenerator&amp; generator, RegisterID* dst)
1224 {
1225     ASSERT(!m_args-&gt;m_listNode);
1226 
1227     return generator.emitArgumentCount(generator.finalDestination(dst));
1228 }
1229 
1230 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1231 {
1232     ArgumentListNode* node = m_args-&gt;m_listNode;
1233     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1234     node = node-&gt;m_next;
1235     ASSERT(node-&gt;m_expr-&gt;isString());
1236     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1237     node = node-&gt;m_next;
1238     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1239 
1240     ASSERT(!node-&gt;m_next);
1241 
1242     return generator.move(dst, generator.emitDirectPutById(base.get(), ident, value.get(), PropertyNode::KnownDirect));
1243 }
1244 
1245 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByIdDirectPrivate(BytecodeGenerator&amp; generator, RegisterID* dst)
1246 {
1247     ArgumentListNode* node = m_args-&gt;m_listNode;
1248     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1249     node = node-&gt;m_next;
1250     ASSERT(node-&gt;m_expr-&gt;isString());
1251     SymbolImpl* symbol = generator.vm().propertyNames-&gt;lookUpPrivateName(static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value());
1252     ASSERT(symbol);
1253     node = node-&gt;m_next;
1254     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1255 
1256     ASSERT(!node-&gt;m_next);
1257 
1258     return generator.move(dst, generator.emitDirectPutById(base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol), value.get(), PropertyNode::KnownDirect));
1259 }
1260 
1261 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putByValDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
1262 {
1263     ArgumentListNode* node = m_args-&gt;m_listNode;
1264     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1265     node = node-&gt;m_next;
1266     RefPtr&lt;RegisterID&gt; index = generator.emitNodeForProperty(node);
1267     node = node-&gt;m_next;
1268     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1269 
1270     ASSERT(!node-&gt;m_next);
1271 
1272     return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
1273 }
1274 
<a name="19" id="anc19"></a><span class="line-added">1275 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1276 {</span>
<span class="line-added">1277     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1278     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1279     node = node-&gt;m_next;</span>
<span class="line-added">1280     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1281     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1282     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">1283     node = node-&gt;m_next;</span>
<span class="line-added">1284     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1285 </span>
<span class="line-added">1286     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1287 </span>
<span class="line-added">1288     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1289 }</span>
<span class="line-added">1290 </span>
<span class="line-added">1291 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1292 {</span>
<span class="line-added">1293     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1294     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1295     node = node-&gt;m_next;</span>
<span class="line-added">1296     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1297     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1298     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">1299     node = node-&gt;m_next;</span>
<span class="line-added">1300     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1301 </span>
<span class="line-added">1302     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1303 </span>
<span class="line-added">1304     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1305 }</span>
<span class="line-added">1306 </span>
<span class="line-added">1307 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1308 {</span>
<span class="line-added">1309     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1310     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1311     node = node-&gt;m_next;</span>
<span class="line-added">1312     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1313     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1314     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">1315     node = node-&gt;m_next;</span>
<span class="line-added">1316     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1317 </span>
<span class="line-added">1318     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1319 </span>
<span class="line-added">1320     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1321 }</span>
<span class="line-added">1322 </span>
<span class="line-added">1323 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1324 {</span>
<span class="line-added">1325     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1326     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1327     node = node-&gt;m_next;</span>
<span class="line-added">1328     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1329     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1330     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">1331     node = node-&gt;m_next;</span>
<span class="line-added">1332     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1333 </span>
<span class="line-added">1334     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1335 </span>
<span class="line-added">1336     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1337 }</span>
<span class="line-added">1338 </span>
<span class="line-added">1339 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">1340 {</span>
<span class="line-added">1341     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">1342     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">1343     node = node-&gt;m_next;</span>
<span class="line-added">1344     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">1345     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">1346     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">1347     node = node-&gt;m_next;</span>
<span class="line-added">1348     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">1349 </span>
<span class="line-added">1350     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">1351 </span>
<span class="line-added">1352     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">1353 }</span>
<span class="line-added">1354 </span>
1355 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
1356 {
1357     ArgumentListNode* node = m_args-&gt;m_listNode;
1358     RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
1359     node = node-&gt;m_next;
1360     RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(node);
1361     ASSERT(!node-&gt;m_next);
1362 
1363     RefPtr&lt;RegisterID&gt; finalDst = generator.finalDestination(dst);
1364     return generator.emitCallForwardArgumentsInTailPosition(finalDst.get(), function.get(), thisRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::No);
1365 }
1366 
1367 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwTypeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1368 {
1369     ArgumentListNode* node = m_args-&gt;m_listNode;
1370     ASSERT(!node-&gt;m_next);
1371     if (node-&gt;m_expr-&gt;isString()) {
1372         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1373         generator.emitThrowTypeError(ident);
1374     } else {
1375         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1376         generator.emitThrowStaticError(ErrorType::TypeError, message.get());
1377     }
1378     return dst;
1379 }
1380 
1381 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwRangeError(BytecodeGenerator&amp; generator, RegisterID* dst)
1382 {
1383     ArgumentListNode* node = m_args-&gt;m_listNode;
1384     ASSERT(!node-&gt;m_next);
1385     if (node-&gt;m_expr-&gt;isString()) {
1386         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1387         generator.emitThrowRangeError(ident);
1388     } else {
1389         RefPtr&lt;RegisterID&gt; message = generator.emitNode(node);
1390         generator.emitThrowStaticError(ErrorType::RangeError, message.get());
1391     }
1392 
1393     return dst;
1394 }
1395 
1396 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_throwOutOfMemoryError(BytecodeGenerator&amp; generator, RegisterID* dst)
1397 {
1398     ASSERT(!m_args-&gt;m_listNode);
1399 
1400     generator.emitThrowOutOfMemoryError();
1401     return dst;
1402 }
1403 
1404 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tryGetById(BytecodeGenerator&amp; generator, RegisterID* dst)
1405 {
1406     ArgumentListNode* node = m_args-&gt;m_listNode;
1407     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);
1408     node = node-&gt;m_next;
1409 
1410     // Since this is a builtin we expect the creator to use a string literal as the second argument.
1411     ASSERT(node-&gt;m_expr-&gt;isString());
1412     const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1413     ASSERT(!node-&gt;m_next);
1414 
1415     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
1416     return generator.emitTryGetById(finalDest.get(), base.get(), ident);
1417 }
1418 
1419 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toNumber(BytecodeGenerator&amp; generator, RegisterID* dst)
1420 {
1421     ArgumentListNode* node = m_args-&gt;m_listNode;
1422     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1423     ASSERT(!node-&gt;m_next);
1424 
1425     return generator.move(dst, generator.emitToNumber(generator.tempDestination(dst), src.get()));
1426 }
1427 
1428 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toString(BytecodeGenerator&amp; generator, RegisterID* dst)
1429 {
1430     ArgumentListNode* node = m_args-&gt;m_listNode;
1431     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1432     ASSERT(!node-&gt;m_next);
1433 
1434     return generator.move(dst, generator.emitToString(generator.tempDestination(dst), src.get()));
1435 }
1436 
1437 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_toObject(BytecodeGenerator&amp; generator, RegisterID* dst)
1438 {
1439     ArgumentListNode* node = m_args-&gt;m_listNode;
1440     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);
1441     node = node-&gt;m_next;
1442 
1443     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
1444     if (node) {
1445         ASSERT(node-&gt;m_expr-&gt;isString());
1446         const Identifier&amp; message = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1447         ASSERT(!node-&gt;m_next);
1448         return generator.move(dst, generator.emitToObject(temp.get(), src.get(), message));
1449     }
1450     return generator.move(dst, generator.emitToObject(temp.get(), src.get(), generator.vm().propertyNames-&gt;emptyIdentifier));
1451 }
1452 
1453 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_idWithProfile(BytecodeGenerator&amp; generator, RegisterID* dst)
1454 {
1455     ArgumentListNode* node = m_args-&gt;m_listNode;
1456     RefPtr&lt;RegisterID&gt; idValue = generator.newTemporary();
1457     generator.emitNode(idValue.get(), node);
1458     SpeculatedType speculation = SpecNone;
1459     while (node-&gt;m_next) {
1460         node = node-&gt;m_next;
1461         ASSERT(node-&gt;m_expr-&gt;isString());
1462         const Identifier&amp; ident = static_cast&lt;StringNode*&gt;(node-&gt;m_expr)-&gt;value();
1463         speculation |= speculationFromString(ident.utf8().data());
1464     }
1465 
1466     return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
1467 }
1468 
<a name="20" id="anc20"></a><span class="line-modified">1469 #define CREATE_INTRINSIC_FOR_BRAND_CHECK(lowerName, upperName) \</span>
<span class="line-modified">1470     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##lowerName(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst) \</span>
<span class="line-modified">1471     {                                                                                                                      \</span>
<span class="line-modified">1472         ArgumentListNode* node = m_args-&gt;m_listNode;                                                                       \</span>
<span class="line-modified">1473         RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);                                                                 \</span>
<span class="line-modified">1474         ASSERT(!node-&gt;m_next);                                                                                             \</span>
<span class="line-modified">1475         return generator.move(dst, generator.emit##upperName(generator.tempDestination(dst), src.get()));                  \</span>
<span class="line-modified">1476     }</span>



























1477 
<a name="21" id="anc21"></a><span class="line-modified">1478 CREATE_INTRINSIC_FOR_BRAND_CHECK(isObject, IsObject)</span>
<span class="line-modified">1479 CREATE_INTRINSIC_FOR_BRAND_CHECK(isJSArray, IsJSArray)</span>
<span class="line-modified">1480 CREATE_INTRINSIC_FOR_BRAND_CHECK(isProxyObject, IsProxyObject)</span>
<span class="line-modified">1481 CREATE_INTRINSIC_FOR_BRAND_CHECK(isDerivedArray, IsDerivedArray)</span>
<span class="line-modified">1482 CREATE_INTRINSIC_FOR_BRAND_CHECK(isGenerator, IsGenerator)</span>
<span class="line-added">1483 CREATE_INTRINSIC_FOR_BRAND_CHECK(isAsyncGenerator, IsAsyncGenerator)</span>
<span class="line-added">1484 CREATE_INTRINSIC_FOR_BRAND_CHECK(isPromise, IsPromise)</span>
<span class="line-added">1485 CREATE_INTRINSIC_FOR_BRAND_CHECK(isRegExpObject, IsRegExpObject)</span>
<span class="line-added">1486 CREATE_INTRINSIC_FOR_BRAND_CHECK(isMap, IsMap)</span>
<span class="line-added">1487 CREATE_INTRINSIC_FOR_BRAND_CHECK(isSet, IsSet)</span>
<span class="line-added">1488 CREATE_INTRINSIC_FOR_BRAND_CHECK(isStringIterator, IsStringIterator)</span>
<span class="line-added">1489 CREATE_INTRINSIC_FOR_BRAND_CHECK(isArrayIterator, IsArrayIterator)</span>
<span class="line-added">1490 CREATE_INTRINSIC_FOR_BRAND_CHECK(isUndefinedOrNull, IsUndefinedOrNull)</span>
1491 
<a name="22" id="anc22"></a><span class="line-modified">1492 #undef CREATE_INTRINSIC_FOR_BRAND_CHECK</span>

1493 
<a name="23" id="anc23"></a><span class="line-modified">1494 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1495 {
1496     ArgumentListNode* node = m_args-&gt;m_listNode;
<a name="24" id="anc24"></a><span class="line-modified">1497     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);</span>
1498     ASSERT(!node-&gt;m_next);
1499 
<a name="25" id="anc25"></a><span class="line-modified">1500     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-added">1501     generator.emitNewArrayWithSize(finalDestination.get(), size.get());</span>
<span class="line-added">1502     return finalDestination.get();</span>
1503 }
1504 
<a name="26" id="anc26"></a><span class="line-modified">1505 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1506 {
1507     ArgumentListNode* node = m_args-&gt;m_listNode;
<a name="27" id="anc27"></a><span class="line-modified">1508     RefPtr&lt;RegisterID&gt; newTarget = generator.emitNode(node);</span>
<span class="line-added">1509     node = node-&gt;m_next;</span>
<span class="line-added">1510     bool isInternalPromise = static_cast&lt;BooleanNode*&gt;(node-&gt;m_expr)-&gt;value();</span>
1511     ASSERT(!node-&gt;m_next);
1512 
<a name="28" id="anc28"></a><span class="line-modified">1513     return generator.emitCreatePromise(generator.finalDestination(dst), newTarget.get(), isInternalPromise);</span>
1514 }
1515 
<a name="29" id="anc29"></a><span class="line-modified">1516 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1517 {
<a name="30" id="anc30"></a><span class="line-modified">1518     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">1519     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-modified">1520     bool isInternalPromise = false;</span>
<span class="line-modified">1521     generator.emitNewPromise(finalDestination.get(), isInternalPromise);</span>
<span class="line-modified">1522     return finalDestination.get();</span>
1523 }
1524 
<a name="31" id="anc31"></a><span class="line-modified">1525 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createArgumentsButterfly(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
1526 {
<a name="32" id="anc32"></a><span class="line-modified">1527     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">1528     return generator.emitCreateArgumentsButterfly(generator.finalDestination(dst));</span>





1529 }
1530 
1531 RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
1532 {
1533     ArgumentListNode* node = m_args-&gt;m_listNode;
1534     RefPtr&lt;RegisterID&gt; newObj = generator.emitNode(node);
1535     node = node-&gt;m_next;
1536     RefPtr&lt;RegisterID&gt; propertyNameRegister = generator.emitNode(node);
1537     node = node-&gt;m_next;
1538     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);
1539     ASSERT(!node-&gt;m_next);
1540 
1541     generator.emitCallDefineProperty(newObj.get(), propertyNameRegister.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);
1542     return dst;
1543 }
1544 
1545 #define JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS(name) \
1546     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##name(BytecodeGenerator&amp; generator, RegisterID* dst) \
1547     { \
1548         ASSERT(!m_args); \
1549         ASSERT(type() == Type::Constant); \
1550         if (dst == generator.ignoredResult()) \
1551             return nullptr; \
1552         return generator.emitLoad(dst, generator.vm().bytecodeIntrinsicRegistry().name##Value(generator)); \
1553     }
1554     JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS)
1555 #undef JSC_DECLARE_BYTECODE_INTRINSIC_CONSTANT_GENERATORS
1556 
1557 // ------------------------------ FunctionCallBracketNode ----------------------------------
1558 
1559 RegisterID* FunctionCallBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1560 {
1561     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1562     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1563     bool baseIsSuper = m_base-&gt;isSuperNode();
1564     bool subscriptIsNonIndexString = isNonIndexStringElement(*m_subscript);
1565 
1566     RefPtr&lt;RegisterID&gt; base;
1567     if (baseIsSuper)
1568         base = emitSuperBaseForCallee(generator);
1569     else {
1570         if (subscriptIsNonIndexString)
1571             base = generator.emitNode(m_base);
1572         else
1573             base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments, m_subscript-&gt;isPure(generator));
1574 
1575         if (m_base-&gt;isOptionalChainBase())
1576             generator.emitOptionalCheck(base.get());
1577     }
1578 
1579     RefPtr&lt;RegisterID&gt; thisRegister;
1580     if (baseIsSuper) {
1581         // Note that we only need to do this once because we either have a non-TDZ this or we throw. Once we have a non-TDZ this, we can&#39;t change its value back to TDZ.
1582         thisRegister = generator.ensureThis();
1583     }
1584     if (subscriptIsNonIndexString) {
1585         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1586         if (baseIsSuper)
1587             generator.emitGetById(function.get(), base.get(), thisRegister.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
1588         else
1589             generator.emitGetById(function.get(), base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value());
1590     } else {
1591         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(m_subscript);
1592         generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1593         if (baseIsSuper)
1594             generator.emitGetByVal(function.get(), base.get(), thisRegister.get(), property.get());
1595         else
1596             generator.emitGetByVal(function.get(), base.get(), property.get());
1597     }
1598     if (isOptionalChainBase())
1599         generator.emitOptionalCheck(function.get());
1600 
1601     CallArguments callArguments(generator, m_args);
1602     if (baseIsSuper) {
1603         generator.emitTDZCheck(generator.thisRegister());
1604         generator.move(callArguments.thisRegister(), thisRegister.get());
1605     } else
1606         generator.move(callArguments.thisRegister(), base.get());
1607     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1608     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1609     return ret;
1610 }
1611 
1612 // ------------------------------ FunctionCallDotNode ----------------------------------
1613 
1614 RegisterID* FunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1615 {
1616     RefPtr&lt;RegisterID&gt; function = generator.tempDestination(dst);
1617     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, function.get());
1618     CallArguments callArguments(generator, m_args);
1619     bool baseIsSuper = m_base-&gt;isSuperNode();
1620     if (baseIsSuper)
1621         generator.move(callArguments.thisRegister(), generator.ensureThis());
1622     else {
1623         generator.emitNode(callArguments.thisRegister(), m_base);
1624         if (m_base-&gt;isOptionalChainBase())
1625             generator.emitOptionalCheck(callArguments.thisRegister());
1626     }
1627     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1628     if (baseIsSuper) {
1629         RefPtr&lt;RegisterID&gt; superBase = emitSuperBaseForCallee(generator);
1630         generator.emitGetById(function.get(), superBase.get(), callArguments.thisRegister(), m_ident);
1631     } else
1632         generator.emitGetById(function.get(), callArguments.thisRegister(), m_ident);
1633 
1634     if (isOptionalChainBase())
1635         generator.emitOptionalCheck(function.get());
1636 
1637     RegisterID* ret = generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1638     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1639     return ret;
1640 }
1641 
1642 static constexpr size_t maxDistanceToInnermostCallOrApply = 2;
1643 
1644 RegisterID* CallFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1645 {
1646     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
1647     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
1648 
1649     if (m_base-&gt;isOptionalChainBase())
1650         generator.emitOptionalCheck(base.get());
1651 
1652     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1653 
1654     RefPtr&lt;RegisterID&gt; function;
1655     auto makeFunction = [&amp;] {
1656         if (m_base-&gt;isSuperNode()) {
1657             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1658             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().callPublicName());
1659         } else
1660             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().callPublicName());
1661 
1662         if (isOptionalChainBase())
1663             generator.emitOptionalCheck(function.get());
1664     };
1665 
1666     bool emitCallCheck = !generator.isBuiltinFunction();
1667     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1668         makeFunction();
1669         CallArguments callArguments(generator, m_args);
1670         generator.move(callArguments.thisRegister(), base.get());
1671         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1672         generator.move(dst, returnValue.get());
1673         return returnValue.get();
1674     }
1675 
1676     Ref&lt;Label&gt; realCall = generator.newLabel();
1677     Ref&lt;Label&gt; end = generator.newLabel();
1678 
1679     if (emitCallCheck) {
1680         makeFunction();
1681         generator.emitJumpIfNotFunctionCall(function.get(), realCall.get());
1682     }
1683     {
1684         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1685             SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1686             ExpressionNode* subject = spread-&gt;expression();
1687             RefPtr&lt;RegisterID&gt; argumentsRegister;
1688             argumentsRegister = generator.emitNode(subject);
1689             generator.emitExpressionInfo(spread-&gt;divot(), spread-&gt;divotStart(), spread-&gt;divotEnd());
1690             RefPtr&lt;RegisterID&gt; thisRegister = generator.emitGetByVal(generator.newTemporary(), argumentsRegister.get(), generator.emitLoad(0, jsNumber(0)));
1691             generator.emitCallVarargsInTailPosition(returnValue.get(), base.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 1, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1692         } else if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1693             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1694             m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1695 
1696             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1697             CallArguments callArguments(generator, m_args);
1698             generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1699             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1700             m_args-&gt;m_listNode = oldList;
1701         } else {
1702             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1703             CallArguments callArguments(generator, m_args);
1704             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1705             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1706         }
1707     }
1708     if (emitCallCheck) {
1709         generator.emitJump(end.get());
1710         generator.emitLabel(realCall.get());
1711         {
1712             CallArguments callArguments(generator, m_args);
1713             generator.move(callArguments.thisRegister(), base.get());
1714             generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1715         }
1716         generator.emitLabel(end.get());
1717     }
1718     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1719     return returnValue.get();
1720 }
1721 
1722 static bool areTrivialApplyArguments(ArgumentsNode* args)
1723 {
1724     return !args-&gt;m_listNode || !args-&gt;m_listNode-&gt;m_expr || !args-&gt;m_listNode-&gt;m_next
1725         || (!args-&gt;m_listNode-&gt;m_next-&gt;m_next &amp;&amp; args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1726 }
1727 
1728 RegisterID* ApplyFunctionCallDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1729 {
1730     // A few simple cases can be trivially handled as ordinary function calls.
1731     // function.apply(), function.apply(arg) -&gt; identical to function.call
1732     // function.apply(thisArg, [arg0, arg1, ...]) -&gt; can be trivially coerced into function.call(thisArg, arg0, arg1, ...) and saves object allocation
1733     bool mayBeCall = areTrivialApplyArguments(m_args);
1734 
1735     RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst);
1736     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_base);
1737 
1738     if (m_base-&gt;isOptionalChainBase())
1739         generator.emitOptionalCheck(base.get());
1740 
1741     RefPtr&lt;RegisterID&gt; function;
1742     auto makeFunction = [&amp;] {
1743         if (m_base-&gt;isSuperNode()) {
1744             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
1745             function = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), generator.propertyNames().builtinNames().applyPublicName());
1746         } else
1747             function = generator.emitGetById(generator.tempDestination(dst), base.get(), generator.propertyNames().builtinNames().applyPublicName());
1748 
1749         if (isOptionalChainBase())
1750             generator.emitOptionalCheck(function.get());
1751     };
1752 
1753     bool emitCallCheck = !generator.isBuiltinFunction();
1754     if (m_distanceToInnermostCallOrApply &gt; maxDistanceToInnermostCallOrApply &amp;&amp; emitCallCheck) {
1755         makeFunction();
1756         CallArguments callArguments(generator, m_args);
1757         generator.move(callArguments.thisRegister(), base.get());
1758         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1759         generator.move(dst, returnValue.get());
1760         return returnValue.get();
1761     }
1762 
1763     Ref&lt;Label&gt; realCall = generator.newLabel();
1764     Ref&lt;Label&gt; end = generator.newLabel();
1765     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
1766     if (emitCallCheck) {
1767         makeFunction();
1768         ASSERT(!m_base-&gt;isResolveNode() || static_cast&lt;ResolveNode*&gt;(m_base)-&gt;identifier() != &quot;Reflect&quot;);
1769         generator.emitJumpIfNotFunctionApply(function.get(), realCall.get());
1770     }
1771     if (mayBeCall) {
1772         if (m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_expr) {
1773             ArgumentListNode* oldList = m_args-&gt;m_listNode;
1774             if (m_args-&gt;m_listNode-&gt;m_expr-&gt;isSpreadExpression()) {
1775                 SpreadExpressionNode* spread = static_cast&lt;SpreadExpressionNode*&gt;(m_args-&gt;m_listNode-&gt;m_expr);
1776                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.newTemporary(), base.get());
1777                 RefPtr&lt;RegisterID&gt; index = generator.emitLoad(generator.newTemporary(), jsNumber(0));
1778                 RefPtr&lt;RegisterID&gt; thisRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1779                 RefPtr&lt;RegisterID&gt; argumentsRegister = generator.emitLoad(generator.newTemporary(), jsUndefined());
1780 
1781                 auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([&amp;thisRegister, &amp;argumentsRegister, &amp;index](BytecodeGenerator&amp; generator, RegisterID* value)
1782                 {
1783                     Ref&lt;Label&gt; haveThis = generator.newLabel();
1784                     Ref&lt;Label&gt; end = generator.newLabel();
1785                     RefPtr&lt;RegisterID&gt; compareResult = generator.newTemporary();
1786                     RefPtr&lt;RegisterID&gt; indexZeroCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(0)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1787                     generator.emitJumpIfFalse(indexZeroCompareResult.get(), haveThis.get());
1788                     generator.move(thisRegister.get(), value);
1789                     generator.emitLoad(index.get(), jsNumber(1));
1790                     generator.emitJump(end.get());
1791                     generator.emitLabel(haveThis.get());
1792                     RefPtr&lt;RegisterID&gt; indexOneCompareResult = generator.emitBinaryOp&lt;OpEq&gt;(compareResult.get(), index.get(), generator.emitLoad(0, jsNumber(1)), OperandTypes(ResultType::numberTypeIsInt32(), ResultType::numberTypeIsInt32()));
1793                     generator.emitJumpIfFalse(indexOneCompareResult.get(), end.get());
1794                     generator.move(argumentsRegister.get(), value);
1795                     generator.emitLoad(index.get(), jsNumber(2));
1796                     generator.emitLabel(end.get());
1797                 });
1798                 generator.emitEnumeration(this, spread-&gt;expression(), extractor);
1799                 generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argumentsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1800             } else if (m_args-&gt;m_listNode-&gt;m_next) {
1801                 ASSERT(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr-&gt;isSimpleArray());
1802                 ASSERT(!m_args-&gt;m_listNode-&gt;m_next-&gt;m_next);
1803                 m_args-&gt;m_listNode = static_cast&lt;ArrayNode*&gt;(m_args-&gt;m_listNode-&gt;m_next-&gt;m_expr)-&gt;toArgumentList(generator.parserArena(), 0, 0);
1804                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1805                 CallArguments callArguments(generator, m_args);
1806                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1807                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1808             } else {
1809                 m_args-&gt;m_listNode = m_args-&gt;m_listNode-&gt;m_next;
1810                 RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1811                 CallArguments callArguments(generator, m_args);
1812                 generator.emitNode(callArguments.thisRegister(), oldList-&gt;m_expr);
1813                 generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1814             }
1815             m_args-&gt;m_listNode = oldList;
1816         } else {
1817             RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1818             CallArguments callArguments(generator, m_args);
1819             generator.emitLoad(callArguments.thisRegister(), jsUndefined());
1820             generator.emitCallInTailPosition(returnValue.get(), realFunction.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1821         }
1822     } else {
1823         ASSERT(m_args-&gt;m_listNode &amp;&amp; m_args-&gt;m_listNode-&gt;m_next);
1824         RefPtr&lt;RegisterID&gt; realFunction = generator.move(generator.tempDestination(dst), base.get());
1825         RefPtr&lt;RegisterID&gt; thisRegister = generator.emitNode(m_args-&gt;m_listNode-&gt;m_expr);
1826         RefPtr&lt;RegisterID&gt; argsRegister;
1827         ArgumentListNode* args = m_args-&gt;m_listNode-&gt;m_next;
1828         argsRegister = generator.emitNode(args-&gt;m_expr);
1829 
1830         // Function.prototype.apply ignores extra arguments, but we still
1831         // need to evaluate them for side effects.
1832         while ((args = args-&gt;m_next))
1833             generator.emitNode(args-&gt;m_expr);
1834 
1835         generator.emitCallVarargsInTailPosition(returnValue.get(), realFunction.get(), thisRegister.get(), argsRegister.get(), generator.newTemporary(), 0, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1836     }
1837     if (emitCallCheck) {
1838         generator.emitJump(end.get());
1839         generator.emitLabel(realCall.get());
1840         CallArguments callArguments(generator, m_args);
1841         generator.move(callArguments.thisRegister(), base.get());
1842         generator.emitCallInTailPosition(returnValue.get(), function.get(), NoExpectedFunction, callArguments, divot(), divotStart(), divotEnd(), DebuggableCall::Yes);
1843         generator.emitLabel(end.get());
1844     }
1845     generator.emitProfileType(returnValue.get(), divotStart(), divotEnd());
1846     return returnValue.get();
1847 }
1848 
1849 // ------------------------------ PostfixNode ----------------------------------
1850 
1851 static RegisterID* emitIncOrDec(BytecodeGenerator&amp; generator, RegisterID* srcDst, Operator oper)
1852 {
1853     return (oper == OpPlusPlus) ? generator.emitInc(srcDst) : generator.emitDec(srcDst);
1854 }
1855 
1856 static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
1857 {
1858     if (dst == srcDst)
<a name="33" id="anc33"></a><span class="line-modified">1859         return generator.emitToNumeric(generator.finalDestination(dst), srcDst);</span>
<span class="line-modified">1860     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumeric(generator.newTemporary(), srcDst);</span>
<span class="line-modified">1861     RefPtr&lt;RegisterID&gt; result = generator.tempDestination(srcDst);</span>
<span class="line-added">1862     generator.move(result.get(), tmp.get());</span>
<span class="line-added">1863     emitIncOrDec(generator, result.get(), oper);</span>
<span class="line-added">1864     generator.move(srcDst, result.get());</span>
1865     return generator.move(dst, tmp.get());
1866 }
1867 
1868 RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
1869 {
1870     if (dst == generator.ignoredResult())
1871         return PrefixNode::emitResolve(generator, dst);
1872 
1873     ASSERT(m_expr-&gt;isResolveNode());
1874     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
1875     const Identifier&amp; ident = resolve-&gt;identifier();
1876 
1877     Variable var = generator.variable(ident);
1878     if (RegisterID* local = var.local()) {
1879         generator.emitTDZCheckIfNecessary(var, local, nullptr);
1880         RefPtr&lt;RegisterID&gt; localReg = local;
1881         if (var.isReadOnly()) {
1882             generator.emitReadOnlyExceptionIfNeeded(var);
1883             localReg = generator.move(generator.tempDestination(dst), local);
1884         }
1885         RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), localReg.get(), m_operator);
1886         generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
1887         return oldValue.get();
1888     }
1889 
1890     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1891     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
1892     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
1893     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
1894     if (var.isReadOnly()) {
1895         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
1896         if (threwException)
1897             return value.get();
1898     }
1899     RefPtr&lt;RegisterID&gt; oldValue = emitPostIncOrDec(generator, generator.finalDestination(dst), value.get(), m_operator);
1900     if (!var.isReadOnly()) {
1901         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
1902         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
1903     }
1904 
1905     return oldValue.get();
1906 }
1907 
1908 RegisterID* PostfixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
1909 {
1910     if (dst == generator.ignoredResult())
1911         return PrefixNode::emitBracket(generator, dst);
1912 
1913     ASSERT(m_expr-&gt;isBracketAccessorNode());
1914     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
1915     ExpressionNode* baseNode = bracketAccessor-&gt;base();
1916     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
1917 
1918     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
1919     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
1920 
1921     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
1922     RefPtr&lt;RegisterID&gt; value;
1923     RefPtr&lt;RegisterID&gt; thisValue;
1924     if (baseNode-&gt;isSuperNode()) {
1925         thisValue = generator.ensureThis();
1926         value = generator.emitGetByVal(generator.newTemporary(), base.get(), thisValue.get(), property.get());
1927     } else
1928         value = generator.emitGetByVal(generator.newTemporary(), base.get(), property.get());
1929     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1930     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1931     if (baseNode-&gt;isSuperNode())
1932         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value.get());
1933     else
1934         generator.emitPutByVal(base.get(), property.get(), value.get());
1935     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1936     return generator.move(dst, oldValue);
1937 }
1938 
1939 RegisterID* PostfixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
1940 {
1941     if (dst == generator.ignoredResult())
1942         return PrefixNode::emitDot(generator, dst);
1943 
1944     ASSERT(m_expr-&gt;isDotAccessorNode());
1945     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
1946     ExpressionNode* baseNode = dotAccessor-&gt;base();
1947     bool baseIsSuper = baseNode-&gt;isSuperNode();
1948     const Identifier&amp; ident = dotAccessor-&gt;identifier();
1949 
1950     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
1951 
1952     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
1953     RefPtr&lt;RegisterID&gt; value;
1954     RefPtr&lt;RegisterID&gt; thisValue;
1955     if (baseIsSuper) {
1956         thisValue = generator.ensureThis();
1957         value = generator.emitGetById(generator.newTemporary(), base.get(), thisValue.get(), ident);
1958     } else
1959         value = generator.emitGetById(generator.newTemporary(), base.get(), ident);
1960     RegisterID* oldValue = emitPostIncOrDec(generator, generator.tempDestination(dst), value.get(), m_operator);
1961     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1962     if (baseIsSuper)
1963         generator.emitPutById(base.get(), thisValue.get(), ident, value.get());
1964     else
1965         generator.emitPutById(base.get(), ident, value.get());
1966     generator.emitProfileType(value.get(), divotStart(), divotEnd());
1967     return generator.move(dst, oldValue);
1968 }
1969 
1970 RegisterID* PostfixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1971 {
1972     if (m_expr-&gt;isResolveNode())
1973         return emitResolve(generator, dst);
1974 
1975     if (m_expr-&gt;isBracketAccessorNode())
1976         return emitBracket(generator, dst);
1977 
1978     if (m_expr-&gt;isDotAccessorNode())
1979         return emitDot(generator, dst);
1980 
1981     ASSERT(m_expr-&gt;isFunctionCall());
1982     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
1983         ? &quot;Postfix ++ operator applied to value that is not a reference.&quot;_s
1984         : &quot;Postfix -- operator applied to value that is not a reference.&quot;_s);
1985 }
1986 
1987 // ------------------------------ DeleteResolveNode -----------------------------------
1988 
1989 RegisterID* DeleteResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
1990 {
1991     Variable var = generator.variable(m_ident);
1992     if (var.local()) {
1993         generator.emitTDZCheckIfNecessary(var, var.local(), nullptr);
1994         return generator.emitLoad(generator.finalDestination(dst), false);
1995     }
1996 
1997     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
1998     RefPtr&lt;RegisterID&gt; base = generator.emitResolveScope(dst, var);
1999     generator.emitTDZCheckIfNecessary(var, nullptr, base.get());
2000     return generator.emitDeleteById(generator.finalDestination(dst, base.get()), base.get(), m_ident);
2001 }
2002 
2003 // ------------------------------ DeleteBracketNode -----------------------------------
2004 
2005 RegisterID* DeleteBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2006 {
2007     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
2008     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
2009 
2010     if (m_base-&gt;isOptionalChainBase())
2011         generator.emitOptionalCheck(r0.get());
2012 
2013     RefPtr&lt;RegisterID&gt; r1 = generator.emitNode(m_subscript);
2014     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2015     if (m_base-&gt;isSuperNode())
2016         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
2017     return generator.emitDeleteByVal(finalDest.get(), r0.get(), r1.get());
2018 }
2019 
2020 // ------------------------------ DeleteDotNode -----------------------------------
2021 
2022 RegisterID* DeleteDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2023 {
2024     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
2025     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_base);
2026 
2027     if (m_base-&gt;isOptionalChainBase())
2028         generator.emitOptionalCheck(r0.get());
2029 
2030     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2031     if (m_base-&gt;isSuperNode())
2032         return emitThrowReferenceError(generator, &quot;Cannot delete a super property&quot;);
2033     return generator.emitDeleteById(finalDest.get(), r0.get(), m_ident);
2034 }
2035 
2036 // ------------------------------ DeleteValueNode -----------------------------------
2037 
2038 RegisterID* DeleteValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2039 {
2040     generator.emitNode(generator.ignoredResult(), m_expr);
2041 
2042     // delete on a non-location expression ignores the value and returns true
2043     return generator.emitLoad(generator.finalDestination(dst), true);
2044 }
2045 
2046 // ------------------------------ VoidNode -------------------------------------
2047 
2048 RegisterID* VoidNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2049 {
2050     if (dst == generator.ignoredResult()) {
2051         generator.emitNode(generator.ignoredResult(), m_expr);
2052         return 0;
2053     }
2054     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
2055     return generator.emitLoad(dst, jsUndefined());
2056 }
2057 
2058 // ------------------------------ TypeOfResolveNode -----------------------------------
2059 
2060 RegisterID* TypeOfResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2061 {
2062     Variable var = generator.variable(m_ident);
2063     if (RegisterID* local = var.local()) {
2064         generator.emitTDZCheckIfNecessary(var, local, nullptr);
2065         if (dst == generator.ignoredResult())
2066             return 0;
2067         return generator.emitTypeOf(generator.finalDestination(dst), local);
2068     }
2069 
2070     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
2071     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
2072     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
2073     if (dst == generator.ignoredResult())
2074         return 0;
2075     return generator.emitTypeOf(generator.finalDestination(dst, scope.get()), value.get());
2076 }
2077 
2078 // ------------------------------ TypeOfValueNode -----------------------------------
2079 
2080 RegisterID* TypeOfValueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2081 {
2082     if (dst == generator.ignoredResult()) {
2083         generator.emitNode(generator.ignoredResult(), m_expr);
2084         return 0;
2085     }
2086     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
2087     return generator.emitTypeOf(generator.finalDestination(dst), src.get());
2088 }
2089 
2090 // ------------------------------ PrefixNode ----------------------------------
2091 
2092 RegisterID* PrefixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
2093 {
2094     ASSERT(m_expr-&gt;isResolveNode());
2095     ResolveNode* resolve = static_cast&lt;ResolveNode*&gt;(m_expr);
2096     const Identifier&amp; ident = resolve-&gt;identifier();
2097 
2098     Variable var = generator.variable(ident);
2099     if (RegisterID* local = var.local()) {
2100         generator.emitTDZCheckIfNecessary(var, local, nullptr);
2101         RefPtr&lt;RegisterID&gt; localReg = local;
2102         if (var.isReadOnly()) {
2103             generator.emitReadOnlyExceptionIfNeeded(var);
2104             localReg = generator.move(generator.tempDestination(dst), localReg.get());
2105         } else if (generator.shouldEmitTypeProfilerHooks()) {
2106             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
2107             generator.move(tempDst.get(), localReg.get());
2108             emitIncOrDec(generator, tempDst.get(), m_operator);
2109             generator.move(localReg.get(), tempDst.get());
2110             generator.emitProfileType(localReg.get(), var, divotStart(), divotEnd());
2111             return generator.move(dst, tempDst.get());
2112         }
2113         emitIncOrDec(generator, localReg.get(), m_operator);
2114         return generator.move(dst, localReg.get());
2115     }
2116 
2117     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2118     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(dst, var);
2119     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
2120     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
2121     if (var.isReadOnly()) {
2122         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2123         if (threwException)
2124             return value.get();
2125     }
2126 
2127     emitIncOrDec(generator, value.get(), m_operator);
2128     if (!var.isReadOnly()) {
2129         generator.emitPutToScope(scope.get(), var, value.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
2130         generator.emitProfileType(value.get(), var, divotStart(), divotEnd());
2131     }
2132     return generator.move(dst, value.get());
2133 }
2134 
2135 RegisterID* PrefixNode::emitBracket(BytecodeGenerator&amp; generator, RegisterID* dst)
2136 {
2137     ASSERT(m_expr-&gt;isBracketAccessorNode());
2138     BracketAccessorNode* bracketAccessor = static_cast&lt;BracketAccessorNode*&gt;(m_expr);
2139     ExpressionNode* baseNode = bracketAccessor-&gt;base();
2140     ExpressionNode* subscript = bracketAccessor-&gt;subscript();
2141 
2142     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(baseNode, bracketAccessor-&gt;subscriptHasAssignments(), subscript-&gt;isPure(generator));
2143     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForProperty(subscript);
2144     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
2145 
2146     generator.emitExpressionInfo(bracketAccessor-&gt;divot(), bracketAccessor-&gt;divotStart(), bracketAccessor-&gt;divotEnd());
2147     RegisterID* value;
2148     RefPtr&lt;RegisterID&gt; thisValue;
2149     if (baseNode-&gt;isSuperNode()) {
2150         thisValue = generator.ensureThis();
2151         value = generator.emitGetByVal(propDst.get(), base.get(), thisValue.get(), property.get());
2152     } else
2153         value = generator.emitGetByVal(propDst.get(), base.get(), property.get());
2154     emitIncOrDec(generator, value, m_operator);
2155     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2156     if (baseNode-&gt;isSuperNode())
2157         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
2158     else
2159         generator.emitPutByVal(base.get(), property.get(), value);
2160     generator.emitProfileType(value, divotStart(), divotEnd());
2161     return generator.move(dst, propDst.get());
2162 }
2163 
2164 RegisterID* PrefixNode::emitDot(BytecodeGenerator&amp; generator, RegisterID* dst)
2165 {
2166     ASSERT(m_expr-&gt;isDotAccessorNode());
2167     DotAccessorNode* dotAccessor = static_cast&lt;DotAccessorNode*&gt;(m_expr);
2168     ExpressionNode* baseNode = dotAccessor-&gt;base();
2169     const Identifier&amp; ident = dotAccessor-&gt;identifier();
2170 
2171     RefPtr&lt;RegisterID&gt; base = generator.emitNode(baseNode);
2172     RefPtr&lt;RegisterID&gt; propDst = generator.tempDestination(dst);
2173 
2174     generator.emitExpressionInfo(dotAccessor-&gt;divot(), dotAccessor-&gt;divotStart(), dotAccessor-&gt;divotEnd());
2175     RegisterID* value;
2176     RefPtr&lt;RegisterID&gt; thisValue;
2177     if (baseNode-&gt;isSuperNode()) {
2178         thisValue = generator.ensureThis();
2179         value = generator.emitGetById(propDst.get(), base.get(), thisValue.get(), ident);
2180     } else
2181         value = generator.emitGetById(propDst.get(), base.get(), ident);
2182     emitIncOrDec(generator, value, m_operator);
2183     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2184     if (baseNode-&gt;isSuperNode())
2185         generator.emitPutById(base.get(), thisValue.get(), ident, value);
2186     else
2187         generator.emitPutById(base.get(), ident, value);
2188     generator.emitProfileType(value, divotStart(), divotEnd());
2189     return generator.move(dst, propDst.get());
2190 }
2191 
2192 RegisterID* PrefixNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2193 {
2194     if (m_expr-&gt;isResolveNode())
2195         return emitResolve(generator, dst);
2196 
2197     if (m_expr-&gt;isBracketAccessorNode())
2198         return emitBracket(generator, dst);
2199 
2200     if (m_expr-&gt;isDotAccessorNode())
2201         return emitDot(generator, dst);
2202 
2203     ASSERT(m_expr-&gt;isFunctionCall());
2204     return emitThrowReferenceError(generator, m_operator == OpPlusPlus
2205         ? &quot;Prefix ++ operator applied to value that is not a reference.&quot;_s
2206         : &quot;Prefix -- operator applied to value that is not a reference.&quot;_s);
2207 }
2208 
2209 // ------------------------------ Unary Operation Nodes -----------------------------------
2210 
2211 RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2212 {
2213     RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
2214     generator.emitExpressionInfo(position(), position(), position());
<a name="34" id="anc34"></a><span class="line-modified">2215     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), m_expr-&gt;resultDescriptor());</span>
2216 }
2217 
2218 // ------------------------------ UnaryPlusNode -----------------------------------
2219 
2220 RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2221 {
2222     ASSERT(opcodeID() == op_to_number);
2223     RefPtr&lt;RegisterID&gt; src = generator.emitNode(expr());
2224     generator.emitExpressionInfo(position(), position(), position());
2225     return generator.emitToNumber(generator.finalDestination(dst), src.get());
2226 }
2227 
2228 // ------------------------------ LogicalNotNode -----------------------------------
2229 
2230 void LogicalNotNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2231 {
2232     if (UNLIKELY(needsDebugHook()))
2233         generator.emitDebugHook(this);
2234 
2235     // Reverse the true and false targets.
2236     generator.emitNodeInConditionContext(expr(), falseTarget, trueTarget, invert(fallThroughMode));
2237 }
2238 
2239 
2240 // ------------------------------ Binary Operation Nodes -----------------------------------
2241 
2242 // BinaryOpNode::emitStrcat:
2243 //
2244 // This node generates an op_strcat operation.  This opcode can handle concatenation of three or
2245 // more values, where we can determine a set of separate op_add operations would be operating on
2246 // string values.
2247 //
2248 // This function expects to be operating on a graph of AST nodes looking something like this:
2249 //
2250 //     (a)...     (b)
2251 //          \   /
2252 //           (+)     (c)
2253 //              \   /
2254 //      [d]     ((+))
2255 //         \    /
2256 //          [+=]
2257 //
2258 // The assignment operation is optional, if it exists the register holding the value on the
2259 // lefthand side of the assignment should be passing as the optional &#39;lhs&#39; argument.
2260 //
2261 // The method should be called on the node at the root of the tree of regular binary add
2262 // operations (marked in the diagram with a double set of parentheses).  This node must
2263 // be performing a string concatenation (determined by statically detecting that at least
2264 // one child must be a string).
2265 //
2266 // Since the minimum number of values being concatenated together is expected to be 3, if
2267 // a lhs to a concatenating assignment is not provided then the  root add should have at
2268 // least one left child that is also an add that can be determined to be operating on strings.
2269 //
2270 RegisterID* BinaryOpNode::emitStrcat(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* lhs, ReadModifyResolveNode* emitExpressionInfoForMe)
2271 {
2272     ASSERT(isAdd());
2273     ASSERT(resultDescriptor().definitelyIsString());
2274 
2275     // Create a list of expressions for all the adds in the tree of nodes we can convert into
2276     // a string concatenation.  The rightmost node (c) is added first.  The rightmost node is
2277     // added first, and the leftmost child is never added, so the vector produced for the
2278     // example above will be [ c, b ].
2279     Vector&lt;ExpressionNode*, 16&gt; reverseExpressionList;
2280     reverseExpressionList.append(m_expr2);
2281 
2282     // Examine the left child of the add.  So long as this is a string add, add its right-child
2283     // to the list, and keep processing along the left fork.
2284     ExpressionNode* leftMostAddChild = m_expr1;
2285     while (leftMostAddChild-&gt;isAdd() &amp;&amp; leftMostAddChild-&gt;resultDescriptor().definitelyIsString()) {
2286         reverseExpressionList.append(static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr2);
2287         leftMostAddChild = static_cast&lt;AddNode*&gt;(leftMostAddChild)-&gt;m_expr1;
2288     }
2289 
2290     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; temporaryRegisters;
2291 
2292     // If there is an assignment, allocate a temporary to hold the lhs after conversion.
2293     // We could possibly avoid this (the lhs is converted last anyway, we could let the
2294     // op_strcat node handle its conversion if required).
2295     if (lhs)
2296         temporaryRegisters.append(generator.newTemporary());
2297 
2298     // Emit code for the leftmost node ((a) in the example).
2299     temporaryRegisters.append(generator.newTemporary());
2300     RegisterID* leftMostAddChildTempRegister = temporaryRegisters.last().get();
2301     generator.emitNode(leftMostAddChildTempRegister, leftMostAddChild);
2302 
2303     // Note on ordering of conversions:
2304     //
2305     // We maintain the same ordering of conversions as we would see if the concatenations
2306     // was performed as a sequence of adds (otherwise this optimization could change
2307     // behaviour should an object have been provided a valueOf or toString method).
2308     //
2309     // Considering the above example, the sequnce of execution is:
2310     //     * evaluate operand (a)
2311     //     * evaluate operand (b)
2312     //     * convert (a) to primitive   &lt;-  (this would be triggered by the first add)
2313     //     * convert (b) to primitive   &lt;-  (ditto)
2314     //     * evaluate operand (c)
2315     //     * convert (c) to primitive   &lt;-  (this would be triggered by the second add)
2316     // And optionally, if there is an assignment:
2317     //     * convert (d) to primitive   &lt;-  (this would be triggered by the assigning addition)
2318     //
2319     // As such we do not plant an op to convert the leftmost child now.  Instead, use
2320     // &#39;leftMostAddChildTempRegister&#39; as a flag to trigger generation of the conversion
2321     // once the second node has been generated.  However, if the leftmost child is an
2322     // immediate we can trivially determine that no conversion will be required.
2323     // If this is the case
2324     if (leftMostAddChild-&gt;isString())
2325         leftMostAddChildTempRegister = 0;
2326 
2327     while (reverseExpressionList.size()) {
2328         ExpressionNode* node = reverseExpressionList.last();
2329         reverseExpressionList.removeLast();
2330 
2331         // Emit the code for the current node.
2332         temporaryRegisters.append(generator.newTemporary());
2333         generator.emitNode(temporaryRegisters.last().get(), node);
2334 
2335         // On the first iteration of this loop, when we first reach this point we have just
2336         // generated the second node, which means it is time to convert the leftmost operand.
2337         if (leftMostAddChildTempRegister) {
2338             generator.emitToPrimitive(leftMostAddChildTempRegister, leftMostAddChildTempRegister);
2339             leftMostAddChildTempRegister = 0; // Only do this once.
2340         }
2341         // Plant a conversion for this node, if necessary.
2342         if (!node-&gt;isString())
2343             generator.emitToPrimitive(temporaryRegisters.last().get(), temporaryRegisters.last().get());
2344     }
2345     ASSERT(temporaryRegisters.size() &gt;= 3);
2346 
2347     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2348     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2349     if (emitExpressionInfoForMe)
2350         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2351     // If there is an assignment convert the lhs now.  This will also copy lhs to
2352     // the temporary register we allocated for it.
2353     if (lhs)
2354         generator.emitToPrimitive(temporaryRegisters[0].get(), lhs);
2355 
2356     return generator.emitStrcat(generator.finalDestination(dst, temporaryRegisters[0].get()), temporaryRegisters[0].get(), temporaryRegisters.size());
2357 }
2358 
2359 void BinaryOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2360 {
2361     TriState branchCondition;
2362     ExpressionNode* branchExpression;
2363     tryFoldToBranch(generator, branchCondition, branchExpression);
2364 
2365     if (UNLIKELY(needsDebugHook())) {
2366         if (branchCondition != MixedTriState)
2367             generator.emitDebugHook(this);
2368     }
2369 
2370     if (branchCondition == MixedTriState)
2371         ExpressionNode::emitBytecodeInConditionContext(generator, trueTarget, falseTarget, fallThroughMode);
2372     else if (branchCondition == TrueTriState)
2373         generator.emitNodeInConditionContext(branchExpression, trueTarget, falseTarget, fallThroughMode);
2374     else
2375         generator.emitNodeInConditionContext(branchExpression, falseTarget, trueTarget, invert(fallThroughMode));
2376 }
2377 
2378 static inline bool canFoldToBranch(OpcodeID opcodeID, ExpressionNode* branchExpression, JSValue constant)
2379 {
2380     ResultType expressionType = branchExpression-&gt;resultDescriptor();
2381 
2382     if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isBoolean())
2383         return true;
2384     else if (expressionType.definitelyIsBoolean() &amp;&amp; constant.isInt32() &amp;&amp; (constant.asInt32() == 0 || constant.asInt32() == 1))
2385         return opcodeID == op_eq || opcodeID == op_neq; // Strict equality is false in the case of type mismatch.
2386     else if (expressionType.isInt32() &amp;&amp; constant.isInt32() &amp;&amp; constant.asInt32() == 0)
2387         return true;
2388 
2389     return false;
2390 }
2391 
2392 void BinaryOpNode::tryFoldToBranch(BytecodeGenerator&amp; generator, TriState&amp; branchCondition, ExpressionNode*&amp; branchExpression)
2393 {
2394     branchCondition = MixedTriState;
2395     branchExpression = 0;
2396 
2397     ConstantNode* constant = 0;
2398     if (m_expr1-&gt;isConstant()) {
2399         constant = static_cast&lt;ConstantNode*&gt;(m_expr1);
2400         branchExpression = m_expr2;
2401     } else if (m_expr2-&gt;isConstant()) {
2402         constant = static_cast&lt;ConstantNode*&gt;(m_expr2);
2403         branchExpression = m_expr1;
2404     }
2405 
2406     if (!constant)
2407         return;
2408     ASSERT(branchExpression);
2409 
2410     OpcodeID opcodeID = this-&gt;opcodeID();
2411     JSValue value = constant-&gt;jsValue(generator);
2412     bool canFoldToBranch = JSC::canFoldToBranch(opcodeID, branchExpression, value);
2413     if (!canFoldToBranch)
2414         return;
2415 
2416     if (opcodeID == op_eq || opcodeID == op_stricteq)
2417         branchCondition = triState(value.pureToBoolean());
2418     else if (opcodeID == op_neq || opcodeID == op_nstricteq)
2419         branchCondition = triState(!value.pureToBoolean());
2420 }
2421 
2422 RegisterID* BinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2423 {
2424     OpcodeID opcodeID = this-&gt;opcodeID();
2425 
2426     if (opcodeID == op_less || opcodeID == op_lesseq || opcodeID == op_greater || opcodeID == op_greatereq) {
2427         auto isUInt32 = [&amp;] (ExpressionNode* node) -&gt; Optional&lt;UInt32Result&gt; {
2428             if (node-&gt;isBinaryOpNode() &amp;&amp; static_cast&lt;BinaryOpNode*&gt;(node)-&gt;opcodeID() == op_urshift)
2429                 return UInt32Result::UInt32;
2430             if (node-&gt;isNumber() &amp;&amp; static_cast&lt;NumberNode*&gt;(node)-&gt;isIntegerNode()) {
2431                 auto value = jsNumber(static_cast&lt;NumberNode*&gt;(node)-&gt;value());
2432                 if (value.isInt32() &amp;&amp; value.asInt32() &gt;= 0)
2433                     return UInt32Result::Constant;
2434             }
2435             return WTF::nullopt;
2436         };
2437         auto leftResult = isUInt32(m_expr1);
2438         auto rightResult = isUInt32(m_expr2);
2439         if ((leftResult &amp;&amp; rightResult) &amp;&amp; (leftResult.value() == UInt32Result::UInt32 || rightResult.value() == UInt32Result::UInt32)) {
2440             auto* left = m_expr1;
2441             auto* right = m_expr2;
2442             if (left-&gt;isBinaryOpNode()) {
2443                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(left)-&gt;opcodeID() == op_urshift);
2444                 static_cast&lt;BinaryOpNode*&gt;(left)-&gt;m_shouldToUnsignedResult = false;
2445             }
2446             if (right-&gt;isBinaryOpNode()) {
2447                 ASSERT(static_cast&lt;BinaryOpNode*&gt;(right)-&gt;opcodeID() == op_urshift);
2448                 static_cast&lt;BinaryOpNode*&gt;(right)-&gt;m_shouldToUnsignedResult = false;
2449             }
2450             RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2451             RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2452             generator.emitExpressionInfo(position(), position(), position());
2453 
2454             // Since the both sides only accept Int32, replacing operands is not observable to users.
2455             bool replaceOperands = false;
2456             OpcodeID resultOp = opcodeID;
2457             switch (opcodeID) {
2458             case op_less:
2459                 resultOp = op_below;
2460                 break;
2461             case op_lesseq:
2462                 resultOp = op_beloweq;
2463                 break;
2464             case op_greater:
2465                 resultOp = op_below;
2466                 replaceOperands = true;
2467                 break;
2468             case op_greatereq:
2469                 resultOp = op_beloweq;
2470                 replaceOperands = true;
2471                 break;
2472             default:
2473                 RELEASE_ASSERT_NOT_REACHED();
2474             }
2475             OperandTypes operandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor());
2476             if (replaceOperands) {
2477                 std::swap(src1, src2);
2478                 operandTypes = OperandTypes(right-&gt;resultDescriptor(), left-&gt;resultDescriptor());
2479             }
2480             return generator.emitBinaryOp(resultOp, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), operandTypes);
2481         }
2482     }
2483 
2484     if (opcodeID == op_add &amp;&amp; m_expr1-&gt;isAdd() &amp;&amp; m_expr1-&gt;resultDescriptor().definitelyIsString()) {
2485         generator.emitExpressionInfo(position(), position(), position());
2486         return emitStrcat(generator, dst);
2487     }
2488 
2489     if (opcodeID == op_neq) {
2490         if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2491             RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2492             generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2493             return generator.emitUnaryOp&lt;OpNeqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2494         }
2495     }
2496 
2497     ExpressionNode* left = m_expr1;
2498     ExpressionNode* right = m_expr2;
2499     if (opcodeID == op_neq || opcodeID == op_nstricteq) {
2500         if (left-&gt;isString())
2501             std::swap(left, right);
2502     }
2503 
2504     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, right-&gt;isPure(generator));
2505     bool wasTypeof = generator.lastOpcodeID() == op_typeof;
2506     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2507     generator.emitExpressionInfo(position(), position(), position());
2508     if (wasTypeof &amp;&amp; (opcodeID == op_neq || opcodeID == op_nstricteq)) {
2509         RefPtr&lt;RegisterID&gt; tmp = generator.tempDestination(dst);
2510         if (opcodeID == op_neq)
2511             generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2512         else if (opcodeID == op_nstricteq)
2513             generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(tmp.get(), src1.get()), src1.get(), src2.get());
2514         else
2515             RELEASE_ASSERT_NOT_REACHED();
2516         return generator.emitUnaryOp&lt;OpNot&gt;(generator.finalDestination(dst, tmp.get()), tmp.get());
2517     }
2518     RegisterID* result = generator.emitBinaryOp(opcodeID, generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(left-&gt;resultDescriptor(), right-&gt;resultDescriptor()));
2519     if (m_shouldToUnsignedResult) {
2520         if (opcodeID == op_urshift &amp;&amp; dst != generator.ignoredResult())
2521             return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2522     }
2523     return result;
2524 }
2525 
2526 RegisterID* EqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2527 {
2528     if (m_expr1-&gt;isNull() || m_expr2-&gt;isNull()) {
2529         RefPtr&lt;RegisterID&gt; src = generator.tempDestination(dst);
2530         generator.emitNode(src.get(), m_expr1-&gt;isNull() ? m_expr2 : m_expr1);
2531         return generator.emitUnaryOp&lt;OpEqNull&gt;(generator.finalDestination(dst, src.get()), src.get());
2532     }
2533 
2534     ExpressionNode* left = m_expr1;
2535     ExpressionNode* right = m_expr2;
2536     if (left-&gt;isString())
2537         std::swap(left, right);
2538 
2539     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2540     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2541     return generator.emitEqualityOp&lt;OpEq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2542 }
2543 
2544 RegisterID* StrictEqualNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2545 {
2546     ExpressionNode* left = m_expr1;
2547     ExpressionNode* right = m_expr2;
2548     if (left-&gt;isString())
2549         std::swap(left, right);
2550 
2551     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(left, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2552     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(right);
2553     return generator.emitEqualityOp&lt;OpStricteq&gt;(generator.finalDestination(dst, src1.get()), src1.get(), src2.get());
2554 }
2555 
2556 RegisterID* ThrowableBinaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2557 {
2558     RefPtr&lt;RegisterID&gt; src1 = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2559     RefPtr&lt;RegisterID&gt; src2 = generator.emitNode(m_expr2);
2560     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2561     return generator.emitBinaryOp(opcodeID(), generator.finalDestination(dst, src1.get()), src1.get(), src2.get(), OperandTypes(m_expr1-&gt;resultDescriptor(), m_expr2-&gt;resultDescriptor()));
2562 }
2563 
2564 RegisterID* InstanceOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2565 {
2566     RefPtr&lt;RegisterID&gt; hasInstanceValue = generator.newTemporary();
2567     RefPtr&lt;RegisterID&gt; isObject = generator.newTemporary();
2568     RefPtr&lt;RegisterID&gt; isCustom = generator.newTemporary();
2569     RefPtr&lt;RegisterID&gt; prototype = generator.newTemporary();
2570     RefPtr&lt;RegisterID&gt; value = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2571     RefPtr&lt;RegisterID&gt; constructor = generator.emitNode(m_expr2);
2572     RefPtr&lt;RegisterID&gt; dstReg = generator.finalDestination(dst, value.get());
2573     Ref&lt;Label&gt; custom = generator.newLabel();
2574     Ref&lt;Label&gt; done = generator.newLabel();
2575     Ref&lt;Label&gt; typeError = generator.newLabel();
2576 
2577     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2578     generator.emitIsObject(isObject.get(), constructor.get());
2579     generator.emitJumpIfFalse(isObject.get(), typeError.get());
2580 
2581     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2582     generator.emitGetById(hasInstanceValue.get(), constructor.get(), generator.vm().propertyNames-&gt;hasInstanceSymbol);
2583 
2584     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2585     generator.emitOverridesHasInstance(isCustom.get(), constructor.get(), hasInstanceValue.get());
2586 
2587     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2588     generator.emitJumpIfTrue(isCustom.get(), custom.get());
2589 
2590     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2591     generator.emitGetById(prototype.get(), constructor.get(), generator.vm().propertyNames-&gt;prototype);
2592 
2593     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2594     generator.emitInstanceOf(dstReg.get(), value.get(), prototype.get());
2595 
2596     generator.emitJump(done.get());
2597 
2598     generator.emitLabel(typeError.get());
2599     generator.emitThrowTypeError(&quot;Right hand side of instanceof is not an object&quot;);
2600 
2601     generator.emitLabel(custom.get());
2602 
2603     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2604     generator.emitInstanceOfCustom(dstReg.get(), value.get(), constructor.get(), hasInstanceValue.get());
2605 
2606     generator.emitLabel(done.get());
2607 
2608     return dstReg.get();
2609 }
2610 
2611 // ------------------------------ InNode ----------------------------
2612 
2613 RegisterID* InNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2614 {
2615     if (isNonIndexStringElement(*m_expr1)) {
2616         RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2617         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2618         return generator.emitInById(generator.finalDestination(dst, base.get()), base.get(), static_cast&lt;StringNode*&gt;(m_expr1)-&gt;value());
2619     }
2620 
2621     RefPtr&lt;RegisterID&gt; key = generator.emitNodeForLeftHandSide(m_expr1, m_rightHasAssignments, m_expr2-&gt;isPure(generator));
2622     RefPtr&lt;RegisterID&gt; base = generator.emitNode(m_expr2);
2623     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2624     return generator.emitInByVal(generator.finalDestination(dst, key.get()), key.get(), base.get());
2625 }
2626 
2627 
2628 // ------------------------------ LogicalOpNode ----------------------------
2629 
2630 RegisterID* LogicalOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2631 {
2632     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
2633     Ref&lt;Label&gt; target = generator.newLabel();
2634 
2635     generator.emitNode(temp.get(), m_expr1);
2636     if (m_operator == OpLogicalAnd)
2637         generator.emitJumpIfFalse(temp.get(), target.get());
2638     else
2639         generator.emitJumpIfTrue(temp.get(), target.get());
2640     generator.emitNodeInTailPosition(temp.get(), m_expr2);
2641     generator.emitLabel(target.get());
2642 
2643     return generator.move(dst, temp.get());
2644 }
2645 
2646 void LogicalOpNode::emitBytecodeInConditionContext(BytecodeGenerator&amp; generator, Label&amp; trueTarget, Label&amp; falseTarget, FallThroughMode fallThroughMode)
2647 {
2648     if (UNLIKELY(needsDebugHook()))
2649         generator.emitDebugHook(this);
2650 
2651     Ref&lt;Label&gt; afterExpr1 = generator.newLabel();
2652     if (m_operator == OpLogicalAnd)
2653         generator.emitNodeInConditionContext(m_expr1, afterExpr1.get(), falseTarget, FallThroughMeansTrue);
2654     else
2655         generator.emitNodeInConditionContext(m_expr1, trueTarget, afterExpr1.get(), FallThroughMeansFalse);
2656     generator.emitLabel(afterExpr1.get());
2657 
2658     generator.emitNodeInConditionContext(m_expr2, trueTarget, falseTarget, fallThroughMode);
2659 }
2660 
2661 // ------------------------------ CoalesceNode ----------------------------
2662 
2663 RegisterID* CoalesceNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2664 {
2665     RefPtr&lt;RegisterID&gt; temp = generator.tempDestination(dst);
2666     Ref&lt;Label&gt; endLabel = generator.newLabel();
2667 
2668     if (m_hasAbsorbedOptionalChain)
2669         generator.pushOptionalChainTarget();
2670     generator.emitNode(temp.get(), m_expr1);
2671     generator.emitJumpIfFalse(generator.emitIsUndefinedOrNull(generator.newTemporary(), temp.get()), endLabel.get());
2672 
2673     if (m_hasAbsorbedOptionalChain)
2674         generator.popOptionalChainTarget();
2675     generator.emitNodeInTailPosition(temp.get(), m_expr2);
2676 
2677     generator.emitLabel(endLabel.get());
2678     return generator.move(dst, temp.get());
2679 }
2680 
2681 // ------------------------------ OptionalChainNode ----------------------------
2682 
2683 RegisterID* OptionalChainNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2684 {
2685     RefPtr&lt;RegisterID&gt; finalDest = generator.finalDestination(dst);
2686 
2687     if (m_isOutermost)
2688         generator.pushOptionalChainTarget();
2689     generator.emitNodeInTailPosition(finalDest.get(), m_expr);
2690     if (m_isOutermost)
2691         generator.popOptionalChainTarget(finalDest.get(), m_expr-&gt;isDeleteNode());
2692 
2693     return finalDest.get();
2694 }
2695 
2696 // ------------------------------ ConditionalNode ------------------------------
2697 
2698 RegisterID* ConditionalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2699 {
2700     RefPtr&lt;RegisterID&gt; newDst = generator.finalDestination(dst);
2701     Ref&lt;Label&gt; beforeElse = generator.newLabel();
2702     Ref&lt;Label&gt; afterElse = generator.newLabel();
2703 
2704     Ref&lt;Label&gt; beforeThen = generator.newLabel();
2705     generator.emitNodeInConditionContext(m_logical, beforeThen.get(), beforeElse.get(), FallThroughMeansTrue);
2706     generator.emitLabel(beforeThen.get());
2707 
2708     generator.emitProfileControlFlow(m_expr1-&gt;startOffset());
2709     generator.emitNodeInTailPosition(newDst.get(), m_expr1);
2710     generator.emitJump(afterElse.get());
2711 
2712     generator.emitLabel(beforeElse.get());
2713     generator.emitProfileControlFlow(m_expr1-&gt;endOffset() + 1);
2714     generator.emitNodeInTailPosition(newDst.get(), m_expr2);
2715 
2716     generator.emitLabel(afterElse.get());
2717 
2718     generator.emitProfileControlFlow(m_expr2-&gt;endOffset() + 1);
2719 
2720     return newDst.get();
2721 }
2722 
2723 // ------------------------------ ReadModifyResolveNode -----------------------------------
2724 
2725 // FIXME: should this be moved to be a method on BytecodeGenerator?
2726 static ALWAYS_INLINE RegisterID* emitReadModifyAssignment(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* src1, ExpressionNode* m_right, Operator oper, OperandTypes types, ReadModifyResolveNode* emitExpressionInfoForMe = 0)
2727 {
2728     OpcodeID opcodeID;
2729     switch (oper) {
2730         case OpMultEq:
2731             opcodeID = op_mul;
2732             break;
2733         case OpDivEq:
2734             opcodeID = op_div;
2735             break;
2736         case OpPlusEq:
2737             if (m_right-&gt;isAdd() &amp;&amp; m_right-&gt;resultDescriptor().definitelyIsString())
2738                 return static_cast&lt;AddNode*&gt;(m_right)-&gt;emitStrcat(generator, dst, src1, emitExpressionInfoForMe);
2739             opcodeID = op_add;
2740             break;
2741         case OpMinusEq:
2742             opcodeID = op_sub;
2743             break;
2744         case OpLShift:
2745             opcodeID = op_lshift;
2746             break;
2747         case OpRShift:
2748             opcodeID = op_rshift;
2749             break;
2750         case OpURShift:
2751             opcodeID = op_urshift;
2752             break;
2753         case OpAndEq:
2754             opcodeID = op_bitand;
2755             break;
2756         case OpXOrEq:
2757             opcodeID = op_bitxor;
2758             break;
2759         case OpOrEq:
2760             opcodeID = op_bitor;
2761             break;
2762         case OpModEq:
2763             opcodeID = op_mod;
2764             break;
2765         case OpPowEq:
2766             opcodeID = op_pow;
2767             break;
2768         default:
2769             RELEASE_ASSERT_NOT_REACHED();
2770             return dst;
2771     }
2772 
2773     RegisterID* src2 = generator.emitNode(m_right);
2774 
2775     // Certain read-modify nodes require expression info to be emitted *after* m_right has been generated.
2776     // If this is required the node is passed as &#39;emitExpressionInfoForMe&#39;; do so now.
2777     if (emitExpressionInfoForMe)
2778         generator.emitExpressionInfo(emitExpressionInfoForMe-&gt;divot(), emitExpressionInfoForMe-&gt;divotStart(), emitExpressionInfoForMe-&gt;divotEnd());
2779     RegisterID* result = generator.emitBinaryOp(opcodeID, dst, src1, src2, types);
2780     if (oper == OpURShift)
2781         return generator.emitUnaryOp&lt;OpUnsigned&gt;(result, result);
2782     return result;
2783 }
2784 
2785 RegisterID* ReadModifyResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2786 {
2787     JSTextPosition newDivot = divotStart() + m_ident.length();
2788     Variable var = generator.variable(m_ident);
2789     if (RegisterID* local = var.local()) {
2790         generator.emitTDZCheckIfNecessary(var, local, nullptr);
2791         if (var.isReadOnly()) {
2792             generator.emitReadOnlyExceptionIfNeeded(var);
2793             RegisterID* result = emitReadModifyAssignment(generator, generator.finalDestination(dst), local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2794             generator.emitProfileType(result, divotStart(), divotEnd());
2795             return result;
2796         }
2797 
2798         if (generator.leftHandSideNeedsCopy(m_rightHasAssignments, m_right-&gt;isPure(generator))) {
2799             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
2800             generator.move(result.get(), local);
2801             emitReadModifyAssignment(generator, result.get(), result.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2802             generator.move(local, result.get());
2803             generator.emitProfileType(local, divotStart(), divotEnd());
2804             return generator.move(dst, result.get());
2805         }
2806 
2807         RegisterID* result = emitReadModifyAssignment(generator, local, local, m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2808         generator.emitProfileType(result, divotStart(), divotEnd());
2809         return generator.move(dst, result);
2810     }
2811 
2812     generator.emitExpressionInfo(newDivot, divotStart(), newDivot);
2813     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2814     RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);
2815     generator.emitTDZCheckIfNecessary(var, value.get(), nullptr);
2816     if (var.isReadOnly()) {
2817         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2818         if (threwException)
2819             return value.get();
2820     }
2821     RefPtr&lt;RegisterID&gt; result = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, m_operator, OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()), this);
2822     RegisterID* returnResult = result.get();
2823     if (!var.isReadOnly()) {
2824         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
2825         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2826     }
2827     return returnResult;
2828 }
2829 
2830 static InitializationMode initializationModeForAssignmentContext(AssignmentContext assignmentContext)
2831 {
2832     switch (assignmentContext) {
2833     case AssignmentContext::DeclarationStatement:
2834         return InitializationMode::Initialization;
2835     case AssignmentContext::ConstDeclarationStatement:
2836         return InitializationMode::ConstInitialization;
2837     case AssignmentContext::AssignmentExpression:
2838         return InitializationMode::NotInitialization;
2839     }
2840 
2841     ASSERT_NOT_REACHED();
2842     return InitializationMode::NotInitialization;
2843 }
2844 
2845 // ------------------------------ AssignResolveNode -----------------------------------
2846 
2847 RegisterID* AssignResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2848 {
2849     Variable var = generator.variable(m_ident);
2850     bool isReadOnly = var.isReadOnly() &amp;&amp; m_assignmentContext != AssignmentContext::ConstDeclarationStatement;
2851     if (RegisterID* local = var.local()) {
2852         RegisterID* result = nullptr;
2853         if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2854             generator.emitTDZCheckIfNecessary(var, local, nullptr);
2855 
2856         if (isReadOnly) {
2857             result = generator.emitNode(dst, m_right); // Execute side effects first.
2858             generator.emitReadOnlyExceptionIfNeeded(var);
2859             generator.emitProfileType(result, var, divotStart(), divotEnd());
2860         } else if (var.isSpecial()) {
2861             RefPtr&lt;RegisterID&gt; tempDst = generator.tempDestination(dst);
2862             generator.emitNode(tempDst.get(), m_right);
2863             generator.move(local, tempDst.get());
2864             generator.emitProfileType(local, var, divotStart(), divotEnd());
2865             result = generator.move(dst, tempDst.get());
2866         } else {
2867             RegisterID* right = generator.emitNode(local, m_right);
2868             generator.emitProfileType(right, var, divotStart(), divotEnd());
2869             result = generator.move(dst, right);
2870         }
2871 
2872         if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2873             generator.liftTDZCheckIfPossible(var);
2874         return result;
2875     }
2876 
2877     if (generator.isStrictMode())
2878         generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2879     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
2880     if (m_assignmentContext == AssignmentContext::AssignmentExpression)
2881         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
2882     if (dst == generator.ignoredResult())
2883         dst = 0;
2884     RefPtr&lt;RegisterID&gt; result = generator.emitNode(dst, m_right);
2885     if (isReadOnly) {
2886         RegisterID* result = generator.emitNode(dst, m_right); // Execute side effects first.
2887         bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
2888         if (threwException)
2889             return result;
2890     }
2891     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2892     RegisterID* returnResult = result.get();
2893     if (!isReadOnly) {
2894         returnResult = generator.emitPutToScope(scope.get(), var, result.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_assignmentContext));
2895         generator.emitProfileType(result.get(), var, divotStart(), divotEnd());
2896     }
2897 
2898     if (m_assignmentContext == AssignmentContext::DeclarationStatement || m_assignmentContext == AssignmentContext::ConstDeclarationStatement)
2899         generator.liftTDZCheckIfPossible(var);
2900     return returnResult;
2901 }
2902 
2903 // ------------------------------ AssignDotNode -----------------------------------
2904 
2905 RegisterID* AssignDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2906 {
2907     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2908     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2909     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2910     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2911     RefPtr&lt;RegisterID&gt; forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2912     if (m_base-&gt;isSuperNode()) {
2913         RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2914         generator.emitPutById(base.get(), thisValue.get(), m_ident, forwardResult.get());
2915     } else
2916         generator.emitPutById(base.get(), m_ident, forwardResult.get());
2917     generator.emitProfileType(forwardResult.get(), divotStart(), divotEnd());
2918     return generator.move(dst, forwardResult.get());
2919 }
2920 
2921 // ------------------------------ ReadModifyDotNode -----------------------------------
2922 
2923 RegisterID* ReadModifyDotNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2924 {
2925     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_rightHasAssignments, m_right-&gt;isPure(generator));
2926 
2927     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2928     RefPtr&lt;RegisterID&gt; value;
2929     RefPtr&lt;RegisterID&gt; thisValue;
2930     if (m_base-&gt;isSuperNode()) {
2931         thisValue = generator.ensureThis();
2932         value = generator.emitGetById(generator.tempDestination(dst), base.get(), thisValue.get(), m_ident);
2933     } else
2934         value = generator.emitGetById(generator.tempDestination(dst), base.get(), m_ident);
2935     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
2936 
2937     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2938     RegisterID* ret;
2939     if (m_base-&gt;isSuperNode())
2940         ret = generator.emitPutById(base.get(), thisValue.get(), m_ident, updatedValue);
2941     else
2942         ret = generator.emitPutById(base.get(), m_ident, updatedValue);
2943     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
2944     return ret;
2945 }
2946 
2947 // ------------------------------ AssignErrorNode -----------------------------------
2948 
2949 RegisterID* AssignErrorNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
2950 {
2951     return emitThrowReferenceError(generator, &quot;Left side of assignment is not a reference.&quot;_s);
2952 }
2953 
2954 // ------------------------------ AssignBracketNode -----------------------------------
2955 
2956 RegisterID* AssignBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2957 {
2958     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2959     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2960     RefPtr&lt;RegisterID&gt; value = generator.destinationForAssignResult(dst);
2961     RefPtr&lt;RegisterID&gt; result = generator.emitNode(value.get(), m_right);
2962 
2963     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
2964     RegisterID* forwardResult = (dst == generator.ignoredResult()) ? result.get() : generator.move(generator.tempDestination(result.get()), result.get());
2965 
2966     if (isNonIndexStringElement(*m_subscript)) {
2967         if (m_base-&gt;isSuperNode()) {
2968             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2969             generator.emitPutById(base.get(), thisValue.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2970         } else
2971             generator.emitPutById(base.get(), static_cast&lt;StringNode*&gt;(m_subscript)-&gt;value(), forwardResult);
2972     } else {
2973         if (m_base-&gt;isSuperNode()) {
2974             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
2975             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), forwardResult);
2976         } else
2977             generator.emitPutByVal(base.get(), property.get(), forwardResult);
2978     }
2979 
2980     generator.emitProfileType(forwardResult, divotStart(), divotEnd());
2981     return generator.move(dst, forwardResult);
2982 }
2983 
2984 // ------------------------------ ReadModifyBracketNode -----------------------------------
2985 
2986 RegisterID* ReadModifyBracketNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
2987 {
2988     RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(m_base, m_subscriptHasAssignments || m_rightHasAssignments, m_subscript-&gt;isPure(generator) &amp;&amp; m_right-&gt;isPure(generator));
2989     RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(m_subscript, m_rightHasAssignments, m_right-&gt;isPure(generator));
2990 
2991     generator.emitExpressionInfo(subexpressionDivot(), subexpressionStart(), subexpressionEnd());
2992     RefPtr&lt;RegisterID&gt; value;
2993     RefPtr&lt;RegisterID&gt; thisValue;
2994     if (m_base-&gt;isSuperNode()) {
2995         thisValue = generator.ensureThis();
2996         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), thisValue.get(), property.get());
2997     } else
2998         value = generator.emitGetByVal(generator.tempDestination(dst), base.get(), property.get());
2999     RegisterID* updatedValue = emitReadModifyAssignment(generator, generator.finalDestination(dst, value.get()), value.get(), m_right, static_cast&lt;JSC::Operator&gt;(m_operator), OperandTypes(ResultType::unknownType(), m_right-&gt;resultDescriptor()));
3000 
3001     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3002     if (m_base-&gt;isSuperNode())
3003         generator.emitPutByVal(base.get(), thisValue.get(), property.get(), updatedValue);
3004     else
3005         generator.emitPutByVal(base.get(), property.get(), updatedValue);
3006     generator.emitProfileType(updatedValue, divotStart(), divotEnd());
3007 
3008     return updatedValue;
3009 }
3010 
3011 // ------------------------------ CommaNode ------------------------------------
3012 
3013 RegisterID* CommaNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3014 {
3015     CommaNode* node = this;
3016     for (; node &amp;&amp; node-&gt;next(); node = node-&gt;next())
3017         generator.emitNode(generator.ignoredResult(), node-&gt;m_expr);
3018     return generator.emitNodeInTailPosition(dst, node-&gt;m_expr);
3019 }
3020 
3021 // ------------------------------ SourceElements -------------------------------
3022 
3023 inline void SourceElements::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3024 {
3025     StatementNode* lastStatementWithCompletionValue = nullptr;
3026     if (generator.shouldBeConcernedWithCompletionValue()) {
3027         for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
3028             if (statement-&gt;hasCompletionValue())
3029                 lastStatementWithCompletionValue = statement;
3030         }
3031     }
3032 
3033     for (StatementNode* statement = m_head; statement; statement = statement-&gt;next()) {
3034         if (statement == lastStatementWithCompletionValue)
3035             generator.emitLoad(dst, jsUndefined());
3036         generator.emitNodeInTailPosition(dst, statement);
3037     }
3038 }
3039 
3040 // ------------------------------ BlockNode ------------------------------------
3041 
3042 void BlockNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3043 {
3044     if (!m_statements)
3045         return;
3046     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
3047     m_statements-&gt;emitBytecode(generator, dst);
3048     generator.popLexicalScope(this);
3049 }
3050 
3051 // ------------------------------ EmptyStatementNode ---------------------------
3052 
3053 void EmptyStatementNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
3054 {
3055     RELEASE_ASSERT(needsDebugHook());
3056 }
3057 
3058 // ------------------------------ DebuggerStatementNode ---------------------------
3059 
3060 void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3061 {
<a name="35" id="anc35"></a><span class="line-modified">3062     generator.emitDebugHook(DidReachDebuggerStatement, position());</span>
3063 }
3064 
3065 // ------------------------------ ExprStatementNode ----------------------------
3066 
3067 void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3068 {
3069     ASSERT(m_expr);
3070     generator.emitNode(dst, m_expr);
3071 }
3072 
3073 // ------------------------------ DeclarationStatement ----------------------------
3074 
3075 void DeclarationStatement::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3076 {
3077     ASSERT(m_expr);
3078     generator.emitNode(m_expr);
3079 }
3080 
3081 // ------------------------------ EmptyVarExpression ----------------------------
3082 
3083 RegisterID* EmptyVarExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3084 {
3085     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
3086     if (!generator.shouldEmitTypeProfilerHooks())
3087         return nullptr;
3088 
3089     Variable var = generator.variable(m_ident);
3090     if (RegisterID* local = var.local())
<a name="36" id="anc36"></a><span class="line-modified">3091         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
3092     else {
3093         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3094         RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
<a name="37" id="anc37"></a><span class="line-modified">3095         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
3096     }
3097 
3098     return nullptr;
3099 }
3100 
3101 // ------------------------------ EmptyLetExpression ----------------------------
3102 
3103 RegisterID* EmptyLetExpression::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3104 {
3105     // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
3106     // get TDZ errors for situations like this: `let x; x;`
3107     Variable var = generator.variable(m_ident);
3108     if (RegisterID* local = var.local()) {
3109         generator.emitLoad(local, jsUndefined());
<a name="38" id="anc38"></a><span class="line-modified">3110         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
3111     } else {
3112         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3113         RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
3114         generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
<a name="39" id="anc39"></a><span class="line-modified">3115         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
3116     }
3117 
3118     generator.liftTDZCheckIfPossible(var);
3119 
3120     // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
3121     return nullptr;
3122 }
3123 
3124 // ------------------------------ IfElseNode ---------------------------------------
3125 
3126 static inline StatementNode* singleStatement(StatementNode* statementNode)
3127 {
3128     if (statementNode-&gt;isBlock())
3129         return static_cast&lt;BlockNode*&gt;(statementNode)-&gt;singleStatement();
3130     return statementNode;
3131 }
3132 
3133 bool IfElseNode::tryFoldBreakAndContinue(BytecodeGenerator&amp; generator, StatementNode* ifBlock,
3134     Label*&amp; trueTarget, FallThroughMode&amp; fallThroughMode)
3135 {
3136     StatementNode* singleStatement = JSC::singleStatement(ifBlock);
3137     if (!singleStatement)
3138         return false;
3139 
3140     if (singleStatement-&gt;isBreak()) {
3141         BreakNode* breakNode = static_cast&lt;BreakNode*&gt;(singleStatement);
3142         Label* target = breakNode-&gt;trivialTarget(generator);
3143         if (!target)
3144             return false;
3145         trueTarget = target;
3146         fallThroughMode = FallThroughMeansFalse;
3147         return true;
3148     }
3149 
3150     if (singleStatement-&gt;isContinue()) {
3151         ContinueNode* continueNode = static_cast&lt;ContinueNode*&gt;(singleStatement);
3152         Label* target = continueNode-&gt;trivialTarget(generator);
3153         if (!target)
3154             return false;
3155         trueTarget = target;
3156         fallThroughMode = FallThroughMeansFalse;
3157         return true;
3158     }
3159 
3160     return false;
3161 }
3162 
3163 void IfElseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3164 {
3165     if (generator.shouldBeConcernedWithCompletionValue()) {
3166         if (m_ifBlock-&gt;hasEarlyBreakOrContinue() || (m_elseBlock &amp;&amp; m_elseBlock-&gt;hasEarlyBreakOrContinue()))
3167             generator.emitLoad(dst, jsUndefined());
3168     }
3169 
3170     Ref&lt;Label&gt; beforeThen = generator.newLabel();
3171     Ref&lt;Label&gt; beforeElse = generator.newLabel();
3172     Ref&lt;Label&gt; afterElse = generator.newLabel();
3173 
3174     Label* trueTarget = beforeThen.ptr();
3175     Label&amp; falseTarget = beforeElse.get();
3176     FallThroughMode fallThroughMode = FallThroughMeansTrue;
3177     bool didFoldIfBlock = tryFoldBreakAndContinue(generator, m_ifBlock, trueTarget, fallThroughMode);
3178 
3179     generator.emitNodeInConditionContext(m_condition, *trueTarget, falseTarget, fallThroughMode);
3180     generator.emitLabel(beforeThen.get());
3181     generator.emitProfileControlFlow(m_ifBlock-&gt;startOffset());
3182 
3183     if (!didFoldIfBlock) {
3184         generator.emitNodeInTailPosition(dst, m_ifBlock);
3185         if (m_elseBlock)
3186             generator.emitJump(afterElse.get());
3187     }
3188 
3189     generator.emitLabel(beforeElse.get());
3190 
3191     if (m_elseBlock) {
3192         generator.emitProfileControlFlow(m_ifBlock-&gt;endOffset() + (m_ifBlock-&gt;isBlock() ? 1 : 0));
3193         generator.emitNodeInTailPosition(dst, m_elseBlock);
3194     }
3195 
3196     generator.emitLabel(afterElse.get());
3197     StatementNode* endingBlock = m_elseBlock ? m_elseBlock : m_ifBlock;
3198     generator.emitProfileControlFlow(endingBlock-&gt;endOffset() + (endingBlock-&gt;isBlock() ? 1 : 0));
3199 }
3200 
3201 // ------------------------------ DoWhileNode ----------------------------------
3202 
3203 void DoWhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3204 {
3205     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3206         generator.emitLoad(dst, jsUndefined());
3207 
3208     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3209 
3210     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
3211     generator.emitLabel(topOfLoop.get());
3212     generator.emitLoopHint();
3213 
3214     generator.emitNodeInTailPosition(dst, m_statement);
3215 
3216     generator.emitLabel(*scope-&gt;continueTarget());
3217     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
3218 
3219     generator.emitLabel(scope-&gt;breakTarget());
3220 }
3221 
3222 // ------------------------------ WhileNode ------------------------------------
3223 
3224 void WhileNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3225 {
3226     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3227         generator.emitLoad(dst, jsUndefined());
3228 
3229     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3230     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
3231 
3232     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
3233 
3234     generator.emitLabel(topOfLoop.get());
3235     generator.emitLoopHint();
3236 
3237     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3238     generator.emitNodeInTailPosition(dst, m_statement);
3239 
3240     generator.emitLabel(*scope-&gt;continueTarget());
3241 
3242     generator.emitNodeInConditionContext(m_expr, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
3243 
3244     generator.emitLabel(scope-&gt;breakTarget());
3245 
3246     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3247 }
3248 
3249 // ------------------------------ ForNode --------------------------------------
3250 
3251 void ForNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3252 {
3253     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3254         generator.emitLoad(dst, jsUndefined());
3255 
3256     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3257 
3258     RegisterID* forLoopSymbolTable = nullptr;
3259     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3260 
3261     if (m_expr1)
3262         generator.emitNode(generator.ignoredResult(), m_expr1);
3263 
3264     Ref&lt;Label&gt; topOfLoop = generator.newLabel();
3265     if (m_expr2)
3266         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansTrue);
3267 
3268     generator.emitLabel(topOfLoop.get());
3269     generator.emitLoopHint();
3270     generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3271 
3272     generator.emitNodeInTailPosition(dst, m_statement);
3273 
3274     generator.emitLabel(*scope-&gt;continueTarget());
3275     generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3276     if (m_expr3)
3277         generator.emitNode(generator.ignoredResult(), m_expr3);
3278 
3279     if (m_expr2)
3280         generator.emitNodeInConditionContext(m_expr2, topOfLoop.get(), scope-&gt;breakTarget(), FallThroughMeansFalse);
3281     else
3282         generator.emitJump(topOfLoop.get());
3283 
3284     generator.emitLabel(scope-&gt;breakTarget());
3285     generator.popLexicalScope(this);
3286     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3287 }
3288 
3289 // ------------------------------ ForInNode ------------------------------------
3290 
3291 RegisterID* ForInNode::tryGetBoundLocal(BytecodeGenerator&amp; generator)
3292 {
3293     if (m_lexpr-&gt;isResolveNode()) {
3294         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3295         return generator.variable(ident).local();
3296     }
3297 
3298     if (m_lexpr-&gt;isDestructuringNode()) {
3299         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3300         auto binding = assignNode-&gt;bindings();
3301         if (!binding-&gt;isBindingNode())
3302             return nullptr;
3303 
3304         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
3305         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
3306         Variable var = generator.variable(ident);
3307         if (var.isSpecial())
3308             return nullptr;
3309         return var.local();
3310     }
3311 
3312     return nullptr;
3313 }
3314 
3315 void ForInNode::emitLoopHeader(BytecodeGenerator&amp; generator, RegisterID* propertyName)
3316 {
3317     auto lambdaEmitResolveVariable = [&amp;] (const Identifier&amp; ident) {
3318         Variable var = generator.variable(ident);
3319         if (RegisterID* local = var.local()) {
3320             if (var.isReadOnly())
3321                 generator.emitReadOnlyExceptionIfNeeded(var);
3322             generator.move(local, propertyName);
3323         } else {
3324             if (generator.isStrictMode())
3325                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3326             if (var.isReadOnly())
3327                 generator.emitReadOnlyExceptionIfNeeded(var);
3328             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3329             generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3330             generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3331         }
<a name="40" id="anc40"></a><span class="line-modified">3332         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
3333     };
3334 
3335     if (m_lexpr-&gt;isResolveNode()) {
3336         const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3337         lambdaEmitResolveVariable(ident);
3338         return;
3339     }
3340 
3341     if (m_lexpr-&gt;isAssignResolveNode()) {
3342         const Identifier&amp; ident = static_cast&lt;AssignResolveNode*&gt;(m_lexpr)-&gt;identifier();
3343         lambdaEmitResolveVariable(ident);
3344         return;
3345     }
3346 
3347     if (m_lexpr-&gt;isDotAccessorNode()) {
3348         DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3349         const Identifier&amp; ident = assignNode-&gt;identifier();
3350         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3351         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3352         if (assignNode-&gt;base()-&gt;isSuperNode()) {
3353             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3354             generator.emitPutById(base.get(), thisValue.get(), ident, propertyName);
3355         } else
3356             generator.emitPutById(base.get(), ident, propertyName);
3357         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3358         return;
3359     }
3360     if (m_lexpr-&gt;isBracketAccessorNode()) {
3361         BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3362         RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3363         RefPtr&lt;RegisterID&gt; subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3364         generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3365         if (assignNode-&gt;base()-&gt;isSuperNode()) {
3366             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3367             generator.emitPutByVal(base.get(), thisValue.get(), subscript.get(), propertyName);
3368         } else
3369             generator.emitPutByVal(base.get(), subscript.get(), propertyName);
3370         generator.emitProfileType(propertyName, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3371         return;
3372     }
3373 
3374     if (m_lexpr-&gt;isDestructuringNode()) {
3375         DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3376         auto binding = assignNode-&gt;bindings();
3377         if (!binding-&gt;isBindingNode()) {
3378             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3379             return;
3380         }
3381 
3382         auto simpleBinding = static_cast&lt;BindingNode*&gt;(binding);
3383         const Identifier&amp; ident = simpleBinding-&gt;boundProperty();
3384         Variable var = generator.variable(ident);
3385         if (!var.local() || var.isSpecial()) {
3386             assignNode-&gt;bindings()-&gt;bindValue(generator, propertyName);
3387             return;
3388         }
3389         generator.move(var.local(), propertyName);
3390         generator.emitProfileType(propertyName, var, simpleBinding-&gt;divotStart(), simpleBinding-&gt;divotEnd());
3391         return;
3392     }
3393 
3394     RELEASE_ASSERT_NOT_REACHED();
3395 }
3396 
3397 void ForInNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3398 {
3399     if (!m_lexpr-&gt;isAssignResolveNode() &amp;&amp; !m_lexpr-&gt;isAssignmentLocation()) {
3400         emitThrowReferenceError(generator, &quot;Left side of for-in statement is not a reference.&quot;_s);
3401         return;
3402     }
3403 
3404     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3405         generator.emitLoad(dst, jsUndefined());
3406 
3407     Ref&lt;Label&gt; end = generator.newLabel();
3408 
3409     RegisterID* forLoopSymbolTable = nullptr;
3410     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3411 
3412     if (m_lexpr-&gt;isAssignResolveNode())
3413         generator.emitNode(generator.ignoredResult(), m_lexpr);
3414 
3415     RefPtr&lt;RegisterID&gt; base = generator.newTemporary();
3416     RefPtr&lt;RegisterID&gt; length;
3417     RefPtr&lt;RegisterID&gt; enumerator;
3418 
3419     generator.emitNode(base.get(), m_expr);
3420     RefPtr&lt;RegisterID&gt; local = this-&gt;tryGetBoundLocal(generator);
3421     RefPtr&lt;RegisterID&gt; enumeratorIndex;
3422 
3423     // Pause at the assignment expression for each for..in iteration.
3424     generator.emitDebugHook(m_lexpr);
3425 
3426     int profilerStartOffset = m_statement-&gt;startOffset();
3427     int profilerEndOffset = m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0);
3428 
3429     enumerator = generator.emitGetPropertyEnumerator(generator.newTemporary(), base.get());
3430 
3431     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
3432     generator.preserveTDZStack(preservedTDZStack);
3433 
3434     // Indexed property loop.
3435     {
3436         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3437         Ref&lt;Label&gt; loopStart = generator.newLabel();
3438         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3439 
3440         length = generator.emitGetEnumerableLength(generator.newTemporary(), enumerator.get());
3441         RefPtr&lt;RegisterID&gt; i = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3442         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3443 
3444         generator.emitLabel(loopStart.get());
3445         generator.emitLoopHint();
3446 
3447         RefPtr&lt;RegisterID&gt; result = generator.emitEqualityOp&lt;OpLess&gt;(generator.newTemporary(), i.get(), length.get());
3448         generator.emitJumpIfFalse(result.get(), loopEnd.get());
3449         generator.emitHasIndexedProperty(result.get(), base.get(), i.get());
3450         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3451 
3452         generator.emitToIndexString(propertyName.get(), i.get());
3453         this-&gt;emitLoopHeader(generator, propertyName.get());
3454 
3455         generator.emitProfileControlFlow(profilerStartOffset);
3456 
3457         generator.pushIndexedForInScope(local.get(), i.get());
3458         generator.emitNode(dst, m_statement);
3459         generator.popIndexedForInScope(local.get());
3460 
3461         generator.emitProfileControlFlow(profilerEndOffset);
3462 
3463         generator.emitLabel(*scope-&gt;continueTarget());
3464         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3465         generator.emitInc(i.get());
3466         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3467         generator.emitJump(loopStart.get());
3468 
3469         generator.emitLabel(scope-&gt;breakTarget());
3470         generator.emitJump(end.get());
3471         generator.emitLabel(loopEnd.get());
3472     }
3473     generator.restoreTDZStack(preservedTDZStack);
3474 
3475     // Structure property loop.
3476     {
3477         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3478         Ref&lt;Label&gt; loopStart = generator.newLabel();
3479         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3480 
3481         enumeratorIndex = generator.emitLoad(generator.newTemporary(), jsNumber(0));
3482         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3483         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3484 
3485         generator.emitLabel(loopStart.get());
3486         generator.emitLoopHint();
3487 
3488         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3489         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3490         generator.emitHasStructureProperty(result.get(), base.get(), propertyName.get(), enumerator.get());
3491         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3492 
3493         this-&gt;emitLoopHeader(generator, propertyName.get());
3494 
3495         generator.emitProfileControlFlow(profilerStartOffset);
3496 
3497         generator.pushStructureForInScope(local.get(), enumeratorIndex.get(), propertyName.get(), enumerator.get());
3498         generator.emitNode(dst, m_statement);
3499         generator.popStructureForInScope(local.get());
3500 
3501         generator.emitProfileControlFlow(profilerEndOffset);
3502 
3503         generator.emitLabel(*scope-&gt;continueTarget());
3504         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3505         generator.emitInc(enumeratorIndex.get());
3506         generator.emitEnumeratorStructurePropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3507         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3508         generator.emitJump(loopStart.get());
3509 
3510         generator.emitLabel(scope-&gt;breakTarget());
3511         generator.emitJump(end.get());
3512         generator.emitLabel(loopEnd.get());
3513     }
3514     generator.restoreTDZStack(preservedTDZStack);
3515 
3516     // Generic property loop.
3517     {
3518         Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Loop);
3519         Ref&lt;Label&gt; loopStart = generator.newLabel();
3520         Ref&lt;Label&gt; loopEnd = generator.newLabel();
3521 
3522         RefPtr&lt;RegisterID&gt; propertyName = generator.newTemporary();
3523 
3524         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3525 
3526         generator.emitLabel(loopStart.get());
3527         generator.emitLoopHint();
3528 
3529         RefPtr&lt;RegisterID&gt; result = generator.emitUnaryOp&lt;OpEqNull&gt;(generator.newTemporary(), propertyName.get());
3530         generator.emitJumpIfTrue(result.get(), loopEnd.get());
3531 
3532         generator.emitHasGenericProperty(result.get(), base.get(), propertyName.get());
3533         generator.emitJumpIfFalse(result.get(), *scope-&gt;continueTarget());
3534 
3535         this-&gt;emitLoopHeader(generator, propertyName.get());
3536 
3537         generator.emitProfileControlFlow(profilerStartOffset);
3538 
3539         generator.emitNode(dst, m_statement);
3540 
3541         generator.emitLabel(*scope-&gt;continueTarget());
3542         generator.prepareLexicalScopeForNextForLoopIteration(this, forLoopSymbolTable);
3543         generator.emitInc(enumeratorIndex.get());
3544         generator.emitEnumeratorGenericPropertyName(propertyName.get(), enumerator.get(), enumeratorIndex.get());
3545         generator.emitDebugHook(m_lexpr); // Pause at the assignment expression for each for..in iteration.
3546         generator.emitJump(loopStart.get());
3547 
3548         generator.emitLabel(scope-&gt;breakTarget());
3549         generator.emitJump(end.get());
3550         generator.emitLabel(loopEnd.get());
3551     }
3552 
3553     generator.emitLabel(end.get());
3554     generator.popLexicalScope(this);
3555     generator.emitProfileControlFlow(profilerEndOffset);
3556 }
3557 
3558 // ------------------------------ ForOfNode ------------------------------------
3559 void ForOfNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3560 {
3561     if (!m_lexpr-&gt;isAssignmentLocation()) {
3562         emitThrowReferenceError(generator, &quot;Left side of for-of statement is not a reference.&quot;_s);
3563         return;
3564     }
3565 
3566     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3567         generator.emitLoad(dst, jsUndefined());
3568 
3569     RegisterID* forLoopSymbolTable = nullptr;
3570     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested, &amp;forLoopSymbolTable);
3571     auto extractor = scopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;([this, dst](BytecodeGenerator&amp; generator, RegisterID* value)
3572     {
3573         if (m_lexpr-&gt;isResolveNode()) {
3574             const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
3575             Variable var = generator.variable(ident);
3576             if (RegisterID* local = var.local()) {
3577                 if (var.isReadOnly())
3578                     generator.emitReadOnlyExceptionIfNeeded(var);
3579                 generator.move(local, value);
3580             } else {
3581                 if (generator.isStrictMode())
3582                     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3583                 if (var.isReadOnly())
3584                     generator.emitReadOnlyExceptionIfNeeded(var);
3585                 RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
3586                 generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3587                 generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
3588             }
<a name="41" id="anc41"></a><span class="line-modified">3589             generator.emitProfileType(value, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
3590         } else if (m_lexpr-&gt;isDotAccessorNode()) {
3591             DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
3592             const Identifier&amp; ident = assignNode-&gt;identifier();
3593             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3594 
3595             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3596             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3597                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3598                 generator.emitPutById(base.get(), thisValue.get(), ident, value);
3599             } else
3600                 generator.emitPutById(base.get(), ident, value);
3601             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3602         } else if (m_lexpr-&gt;isBracketAccessorNode()) {
3603             BracketAccessorNode* assignNode = static_cast&lt;BracketAccessorNode*&gt;(m_lexpr);
3604             RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
3605             RegisterID* subscript = generator.emitNodeForProperty(assignNode-&gt;subscript());
3606 
3607             generator.emitExpressionInfo(assignNode-&gt;divot(), assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3608             if (assignNode-&gt;base()-&gt;isSuperNode()) {
3609                 RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
3610                 generator.emitPutByVal(base.get(), thisValue.get(), subscript, value);
3611             } else
3612                 generator.emitPutByVal(base.get(), subscript, value);
3613             generator.emitProfileType(value, assignNode-&gt;divotStart(), assignNode-&gt;divotEnd());
3614         } else {
3615             ASSERT(m_lexpr-&gt;isDestructuringNode());
3616             DestructuringAssignmentNode* assignNode = static_cast&lt;DestructuringAssignmentNode*&gt;(m_lexpr);
3617             assignNode-&gt;bindings()-&gt;bindValue(generator, value);
3618         }
3619         generator.emitProfileControlFlow(m_statement-&gt;startOffset());
3620         generator.emitNode(dst, m_statement);
3621     });
3622     generator.emitEnumeration(this, m_expr, extractor, this, forLoopSymbolTable);
3623     generator.popLexicalScope(this);
3624     generator.emitProfileControlFlow(m_statement-&gt;endOffset() + (m_statement-&gt;isBlock() ? 1 : 0));
3625 }
3626 
3627 // ------------------------------ ContinueNode ---------------------------------
3628 
3629 Label* ContinueNode::trivialTarget(BytecodeGenerator&amp; generator)
3630 {
3631     if (generator.shouldEmitDebugHooks())
3632         return nullptr;
3633 
3634     LabelScope* scope = generator.continueTarget(m_ident);
3635     ASSERT(scope);
3636 
3637     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3638         return nullptr;
3639 
3640     return scope-&gt;continueTarget();
3641 }
3642 
3643 void ContinueNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3644 {
3645     LabelScope* scope = generator.continueTarget(m_ident);
3646     ASSERT(scope);
3647 
3648     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), *scope-&gt;continueTarget());
3649     if (!hasFinally) {
3650         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3651         generator.restoreScopeRegister(lexicalScopeIndex);
3652         generator.emitJump(*scope-&gt;continueTarget());
3653     }
3654 
3655     generator.emitProfileControlFlow(endOffset());
3656 }
3657 
3658 // ------------------------------ BreakNode ------------------------------------
3659 
3660 Label* BreakNode::trivialTarget(BytecodeGenerator&amp; generator)
3661 {
3662     if (generator.shouldEmitDebugHooks())
3663         return nullptr;
3664 
3665     LabelScope* scope = generator.breakTarget(m_ident);
3666     ASSERT(scope);
3667 
3668     if (generator.labelScopeDepth() != scope-&gt;scopeDepth())
3669         return nullptr;
3670 
3671     return &amp;scope-&gt;breakTarget();
3672 }
3673 
3674 void BreakNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
3675 {
3676     LabelScope* scope = generator.breakTarget(m_ident);
3677     ASSERT(scope);
3678 
3679     bool hasFinally = generator.emitJumpViaFinallyIfNeeded(scope-&gt;scopeDepth(), scope-&gt;breakTarget());
3680     if (!hasFinally) {
3681         int lexicalScopeIndex = generator.labelScopeDepthToLexicalScopeIndex(scope-&gt;scopeDepth());
3682         generator.restoreScopeRegister(lexicalScopeIndex);
3683         generator.emitJump(scope-&gt;breakTarget());
3684     }
3685 
3686     generator.emitProfileControlFlow(endOffset());
3687 }
3688 
3689 // ------------------------------ ReturnNode -----------------------------------
3690 
3691 void ReturnNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3692 {
3693     ASSERT(generator.codeType() == FunctionCode);
3694 
3695     if (dst == generator.ignoredResult())
3696         dst = 0;
3697 
3698     RefPtr&lt;RegisterID&gt; returnRegister = m_value ? generator.emitNodeInTailPosition(dst, m_value) : generator.emitLoad(dst, jsUndefined());
3699 
3700     generator.emitProfileType(returnRegister.get(), ProfileTypeBytecodeFunctionReturnStatement, divotStart(), divotEnd());
3701 
3702     bool hasFinally = generator.emitReturnViaFinallyIfNeeded(returnRegister.get());
3703     if (!hasFinally) {
3704         if (generator.parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
3705             returnRegister = generator.move(generator.newTemporary(), returnRegister.get());
3706             generator.emitAwait(returnRegister.get());
3707         }
3708 
3709         generator.emitWillLeaveCallFrameDebugHook();
3710         generator.emitReturn(returnRegister.get());
3711     }
3712 
3713     generator.emitProfileControlFlow(endOffset());
3714     // Emitting an unreachable return here is needed in case this op_profile_control_flow is the
3715     // last opcode in a CodeBlock because a CodeBlock&#39;s instructions must end with a terminal opcode.
3716     if (generator.shouldEmitControlFlowProfilerHooks())
3717         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
3718 }
3719 
3720 // ------------------------------ WithNode -------------------------------------
3721 
3722 void WithNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3723 {
3724     RefPtr&lt;RegisterID&gt; scope = generator.emitNode(m_expr);
3725     generator.emitExpressionInfo(m_divot, m_divot - m_expressionLength, m_divot);
3726     generator.emitPushWithScope(scope.get());
3727     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_statement-&gt;hasEarlyBreakOrContinue())
3728         generator.emitLoad(dst, jsUndefined());
3729     generator.emitNodeInTailPosition(dst, m_statement);
3730     generator.emitPopWithScope();
3731 }
3732 
3733 // ------------------------------ CaseClauseNode --------------------------------
3734 
3735 inline void CaseClauseNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3736 {
3737     generator.emitProfileControlFlow(m_startOffset);
3738     if (!m_statements)
3739         return;
3740     m_statements-&gt;emitBytecode(generator, dst);
3741 }
3742 
3743 // ------------------------------ CaseBlockNode --------------------------------
3744 
3745 enum SwitchKind {
3746     SwitchUnset = 0,
3747     SwitchNumber = 1,
3748     SwitchString = 2,
3749     SwitchNeither = 3
3750 };
3751 
3752 static void processClauseList(ClauseListNode* list, Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, SwitchKind&amp; typeForTable, bool&amp; singleCharacterSwitch, int32_t&amp; min_num, int32_t&amp; max_num)
3753 {
3754     for (; list; list = list-&gt;getNext()) {
3755         ExpressionNode* clauseExpression = list-&gt;getClause()-&gt;expr();
3756         literalVector.append(clauseExpression);
3757         if (clauseExpression-&gt;isNumber()) {
3758             double value = static_cast&lt;NumberNode*&gt;(clauseExpression)-&gt;value();
3759             int32_t intVal = static_cast&lt;int32_t&gt;(value);
3760             if ((typeForTable &amp; ~SwitchNumber) || (intVal != value)) {
3761                 typeForTable = SwitchNeither;
3762                 break;
3763             }
3764             if (intVal &lt; min_num)
3765                 min_num = intVal;
3766             if (intVal &gt; max_num)
3767                 max_num = intVal;
3768             typeForTable = SwitchNumber;
3769             continue;
3770         }
3771         if (clauseExpression-&gt;isString()) {
3772             if (typeForTable &amp; ~SwitchString) {
3773                 typeForTable = SwitchNeither;
3774                 break;
3775             }
3776             const String&amp; value = static_cast&lt;StringNode*&gt;(clauseExpression)-&gt;value().string();
3777             if (singleCharacterSwitch &amp;= value.length() == 1) {
3778                 int32_t intVal = value[0];
3779                 if (intVal &lt; min_num)
3780                     min_num = intVal;
3781                 if (intVal &gt; max_num)
3782                     max_num = intVal;
3783             }
3784             typeForTable = SwitchString;
3785             continue;
3786         }
3787         typeForTable = SwitchNeither;
3788         break;
3789     }
3790 }
3791 
3792 static inline size_t length(ClauseListNode* list1, ClauseListNode* list2)
3793 {
3794     size_t length = 0;
3795     for (ClauseListNode* node = list1; node; node = node-&gt;getNext())
3796         ++length;
3797     for (ClauseListNode* node = list2; node; node = node-&gt;getNext())
3798         ++length;
3799     return length;
3800 }
3801 
3802 SwitchInfo::SwitchType CaseBlockNode::tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num)
3803 {
3804     if (length(m_list1, m_list2) &lt; s_tableSwitchMinimum)
3805         return SwitchInfo::SwitchNone;
3806 
3807     SwitchKind typeForTable = SwitchUnset;
3808     bool singleCharacterSwitch = true;
3809 
3810     processClauseList(m_list1, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3811     processClauseList(m_list2, literalVector, typeForTable, singleCharacterSwitch, min_num, max_num);
3812 
3813     if (typeForTable == SwitchUnset || typeForTable == SwitchNeither)
3814         return SwitchInfo::SwitchNone;
3815 
3816     if (typeForTable == SwitchNumber) {
3817         int32_t range = max_num - min_num;
3818         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3819             return SwitchInfo::SwitchImmediate;
3820         return SwitchInfo::SwitchNone;
3821     }
3822 
3823     ASSERT(typeForTable == SwitchString);
3824 
3825     if (singleCharacterSwitch) {
3826         int32_t range = max_num - min_num;
3827         if (min_num &lt;= max_num &amp;&amp; range &lt;= 1000 &amp;&amp; (range / literalVector.size()) &lt; 10)
3828             return SwitchInfo::SwitchCharacter;
3829     }
3830 
3831     return SwitchInfo::SwitchString;
3832 }
3833 
3834 void CaseBlockNode::emitBytecodeForBlock(BytecodeGenerator&amp; generator, RegisterID* switchExpression, RegisterID* dst)
3835 {
3836     Vector&lt;Ref&lt;Label&gt;, 8&gt; labelVector;
3837     Vector&lt;ExpressionNode*, 8&gt; literalVector;
3838     int32_t min_num = std::numeric_limits&lt;int32_t&gt;::max();
3839     int32_t max_num = std::numeric_limits&lt;int32_t&gt;::min();
3840     SwitchInfo::SwitchType switchType = tryTableSwitch(literalVector, min_num, max_num);
3841 
3842     Ref&lt;Label&gt; defaultLabel = generator.newLabel();
3843     if (switchType != SwitchInfo::SwitchNone) {
3844         // Prepare the various labels
3845         for (uint32_t i = 0; i &lt; literalVector.size(); i++)
3846             labelVector.append(generator.newLabel());
3847         generator.beginSwitch(switchExpression, switchType);
3848     } else {
3849         // Setup jumps
3850         for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3851             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3852             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3853             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3854             labelVector.append(generator.newLabel());
3855             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3856         }
3857 
3858         for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3859             RefPtr&lt;RegisterID&gt; clauseVal = generator.newTemporary();
3860             generator.emitNode(clauseVal.get(), list-&gt;getClause()-&gt;expr());
3861             generator.emitBinaryOp&lt;OpStricteq&gt;(clauseVal.get(), clauseVal.get(), switchExpression, OperandTypes());
3862             labelVector.append(generator.newLabel());
3863             generator.emitJumpIfTrue(clauseVal.get(), labelVector[labelVector.size() - 1].get());
3864         }
3865         generator.emitJump(defaultLabel.get());
3866     }
3867 
3868     size_t i = 0;
3869     for (ClauseListNode* list = m_list1; list; list = list-&gt;getNext()) {
3870         generator.emitLabel(labelVector[i++].get());
3871         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3872     }
3873 
3874     if (m_defaultClause) {
3875         generator.emitLabel(defaultLabel.get());
3876         m_defaultClause-&gt;emitBytecode(generator, dst);
3877     }
3878 
3879     for (ClauseListNode* list = m_list2; list; list = list-&gt;getNext()) {
3880         generator.emitLabel(labelVector[i++].get());
3881         list-&gt;getClause()-&gt;emitBytecode(generator, dst);
3882     }
3883     if (!m_defaultClause)
3884         generator.emitLabel(defaultLabel.get());
3885 
3886     ASSERT(i == labelVector.size());
3887     if (switchType != SwitchInfo::SwitchNone) {
3888         ASSERT(labelVector.size() == literalVector.size());
3889         generator.endSwitch(labelVector.size(), labelVector, literalVector.data(), defaultLabel.get(), min_num, max_num);
3890     }
3891 }
3892 
3893 // ------------------------------ SwitchNode -----------------------------------
3894 
3895 void SwitchNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3896 {
3897     if (generator.shouldBeConcernedWithCompletionValue())
3898         generator.emitLoad(dst, jsUndefined());
3899 
3900     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::Switch);
3901 
3902     RefPtr&lt;RegisterID&gt; r0 = generator.emitNode(m_expr);
3903 
3904     generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::DoNotOptimize, BytecodeGenerator::NestedScopeType::IsNested);
3905     m_block-&gt;emitBytecodeForBlock(generator, r0.get(), dst);
3906     generator.popLexicalScope(this);
3907 
3908     generator.emitLabel(scope-&gt;breakTarget());
3909     generator.emitProfileControlFlow(endOffset());
3910 }
3911 
3912 // ------------------------------ LabelNode ------------------------------------
3913 
3914 void LabelNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3915 {
3916     ASSERT(!generator.breakTarget(m_name));
3917 
3918     Ref&lt;LabelScope&gt; scope = generator.newLabelScope(LabelScope::NamedLabel, &amp;m_name);
3919     generator.emitNodeInTailPosition(dst, m_statement);
3920 
3921     generator.emitLabel(scope-&gt;breakTarget());
3922 }
3923 
3924 // ------------------------------ ThrowNode ------------------------------------
3925 
3926 void ThrowNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3927 {
3928     if (dst == generator.ignoredResult())
3929         dst = 0;
3930     RefPtr&lt;RegisterID&gt; expr = generator.emitNode(m_expr);
3931     generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
3932     generator.emitThrow(expr.get());
3933 
3934     generator.emitProfileControlFlow(endOffset());
3935 }
3936 
3937 // ------------------------------ TryNode --------------------------------------
3938 
3939 void TryNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
3940 {
3941     // NOTE: The catch and finally blocks must be labeled explicitly, so the
3942     // optimizer knows they may be jumped to from anywhere.
3943 
3944     if (generator.shouldBeConcernedWithCompletionValue() &amp;&amp; m_tryBlock-&gt;hasEarlyBreakOrContinue())
3945         generator.emitLoad(dst, jsUndefined());
3946 
3947     ASSERT(m_catchBlock || m_finallyBlock);
3948 
3949     RefPtr&lt;Label&gt; catchLabel;
3950     RefPtr&lt;Label&gt; catchEndLabel;
3951     RefPtr&lt;Label&gt; finallyLabel;
3952     RefPtr&lt;Label&gt; finallyEndLabel;
3953     Optional&lt;FinallyContext&gt; finallyContext;
3954 
3955     if (m_finallyBlock) {
3956         finallyLabel = generator.newLabel();
3957         finallyEndLabel = generator.newLabel();
3958 
3959         finallyContext.emplace(generator, *finallyLabel);
3960         generator.pushFinallyControlFlowScope(finallyContext.value());
3961     }
3962     if (m_catchBlock) {
3963         catchLabel = generator.newLabel();
3964         catchEndLabel = generator.newLabel();
3965     }
3966 
3967     Ref&lt;Label&gt; tryLabel = generator.newEmittedLabel();
3968     Label&amp; tryHandlerLabel = m_catchBlock ? *catchLabel : *finallyLabel;
3969     HandlerType tryHandlerType = m_catchBlock ? HandlerType::Catch : HandlerType::Finally;
3970     TryData* tryData = generator.pushTry(tryLabel.get(), tryHandlerLabel, tryHandlerType);
3971     TryData* finallyTryData = nullptr;
3972     if (!m_catchBlock &amp;&amp; m_finallyBlock)
3973         finallyTryData = tryData;
3974 
3975     generator.emitNode(dst, m_tryBlock);
3976 
3977     if (m_finallyBlock)
3978         generator.emitJump(*finallyLabel);
3979     else
3980         generator.emitJump(*catchEndLabel);
3981 
3982     Ref&lt;Label&gt; tryEndLabel = generator.newEmittedLabel();
3983     generator.popTry(tryData, tryEndLabel.get());
3984 
3985     if (m_catchBlock) {
3986         // Uncaught exception path: the catch block.
3987         generator.emitLabel(*catchLabel);
3988         RefPtr&lt;RegisterID&gt; thrownValueRegister = generator.newTemporary();
3989         RegisterID* completionTypeRegister = m_finallyBlock ? finallyContext-&gt;completionTypeRegister() : nullptr;
3990         generator.emitOutOfLineCatchHandler(thrownValueRegister.get(), completionTypeRegister, tryData);
3991         generator.restoreScopeRegister();
3992 
3993         if (m_finallyBlock) {
3994             // If the catch block throws an exception and we have a finally block, then the finally
3995             // block should &quot;catch&quot; that exception.
3996             finallyTryData = generator.pushTry(*catchLabel, *finallyLabel, HandlerType::Finally);
3997         }
3998 
3999         if (m_catchPattern) {
4000             generator.emitPushCatchScope(m_lexicalVariables);
4001             m_catchPattern-&gt;bindValue(generator, thrownValueRegister.get());
4002         }
4003 
4004         generator.emitProfileControlFlow(m_tryBlock-&gt;endOffset() + 1);
4005         if (m_finallyBlock)
4006             generator.emitNode(dst, m_catchBlock);
4007         else
4008             generator.emitNodeInTailPosition(dst, m_catchBlock);
4009         generator.emitLoad(thrownValueRegister.get(), jsUndefined());
4010 
4011         if (m_catchPattern)
4012             generator.emitPopCatchScope(m_lexicalVariables);
4013 
4014         if (m_finallyBlock) {
4015             generator.emitLoad(finallyContext-&gt;completionTypeRegister(), CompletionType::Normal);
4016             generator.emitJump(*finallyLabel);
4017             generator.popTry(finallyTryData, *finallyLabel);
4018         }
4019 
4020         generator.emitLabel(*catchEndLabel);
4021         generator.emitProfileControlFlow(m_catchBlock-&gt;endOffset() + 1);
4022     }
4023 
4024     if (m_finallyBlock) {
4025         generator.popFinallyControlFlowScope();
4026 
4027         // Entry to the finally block for CompletionType::Throw to be generated later.
4028         generator.emitOutOfLineFinallyHandler(finallyContext-&gt;completionValueRegister(), finallyContext-&gt;completionTypeRegister(), finallyTryData);
4029 
4030         // Entry to the finally block for CompletionTypes other than Throw.
4031         generator.emitLabel(*finallyLabel);
4032         generator.restoreScopeRegister();
4033 
4034         int finallyStartOffset = m_catchBlock ? m_catchBlock-&gt;endOffset() + 1 : m_tryBlock-&gt;endOffset() + 1;
4035         generator.emitProfileControlFlow(finallyStartOffset);
4036         generator.emitNodeInTailPosition(m_finallyBlock);
4037 
4038         generator.emitFinallyCompletion(finallyContext.value(), *finallyEndLabel);
4039         generator.emitLabel(*finallyEndLabel);
4040         generator.emitProfileControlFlow(m_finallyBlock-&gt;endOffset() + 1);
4041     }
4042 }
4043 
4044 // ------------------------------ ScopeNode -----------------------------
4045 
4046 inline void ScopeNode::emitStatementsBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4047 {
4048     if (!m_statements)
4049         return;
4050     m_statements-&gt;emitBytecode(generator, dst);
4051 }
4052 
4053 static void emitProgramNodeBytecode(BytecodeGenerator&amp; generator, ScopeNode&amp; scopeNode)
4054 {
4055     generator.emitDebugHook(WillExecuteProgram, scopeNode.startLine(), scopeNode.startStartOffset(), scopeNode.startLineStartOffset());
4056 
4057     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
4058     generator.emitLoad(dstRegister.get(), jsUndefined());
4059     generator.emitProfileControlFlow(scopeNode.startStartOffset());
4060     scopeNode.emitStatementsBytecode(generator, dstRegister.get());
4061 
4062     generator.emitDebugHook(DidExecuteProgram, scopeNode.lastLine(), scopeNode.startOffset(), scopeNode.lineStartOffset());
4063     generator.emitEnd(dstRegister.get());
4064 }
4065 
4066 // ------------------------------ ProgramNode -----------------------------
4067 
4068 void ProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4069 {
4070     emitProgramNodeBytecode(generator, *this);
4071 }
4072 
4073 // ------------------------------ ModuleProgramNode --------------------
4074 
4075 void ModuleProgramNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4076 {
4077     emitProgramNodeBytecode(generator, *this);
4078 }
4079 
4080 // ------------------------------ EvalNode -----------------------------
4081 
4082 void EvalNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4083 {
4084     generator.emitDebugHook(WillExecuteProgram, startLine(), startStartOffset(), startLineStartOffset());
4085 
4086     RefPtr&lt;RegisterID&gt; dstRegister = generator.newTemporary();
4087     generator.emitLoad(dstRegister.get(), jsUndefined());
4088     emitStatementsBytecode(generator, dstRegister.get());
4089 
4090     generator.emitDebugHook(DidExecuteProgram, lastLine(), startOffset(), lineStartOffset());
4091     generator.emitEnd(dstRegister.get());
4092 }
4093 
4094 // ------------------------------ FunctionNode -----------------------------
4095 
4096 void FunctionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4097 {
4098     if (generator.shouldEmitTypeProfilerHooks()) {
4099         // If the parameter list is non simple one, it is handled in bindValue&#39;s code.
4100         if (m_parameters-&gt;isSimpleParameterList()) {
4101             for (size_t i = 0; i &lt; m_parameters-&gt;size(); i++) {
4102                 BindingNode* bindingNode = static_cast&lt;BindingNode*&gt;(m_parameters-&gt;at(i).first);
4103                 RegisterID reg(CallFrame::argumentOffset(i));
4104                 generator.emitProfileType(&amp;reg, ProfileTypeBytecodeFunctionArgument, bindingNode-&gt;divotStart(), bindingNode-&gt;divotEnd());
4105             }
4106         }
4107     }
4108 
4109     generator.emitProfileControlFlow(startStartOffset());
4110     generator.emitDebugHook(DidEnterCallFrame, startLine(), startStartOffset(), startLineStartOffset());
4111 
4112     switch (generator.parseMode()) {
4113     case SourceParseMode::GeneratorWrapperFunctionMode:
4114     case SourceParseMode::GeneratorWrapperMethodMode:
4115     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
4116     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
4117         StatementNode* singleStatement = this-&gt;singleStatement();
4118         ASSERT(singleStatement-&gt;isExprStatement());
4119         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
4120         ExpressionNode* expr = exprStatement-&gt;expr();
4121         ASSERT(expr-&gt;isFuncExprNode());
4122         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
4123 
4124         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
4125         generator.emitNode(next.get(), funcExpr);
4126 
4127         if (generator.superBinding() == SuperBinding::Needed) {
4128             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
4129             emitPutHomeObject(generator, next.get(), homeObject.get());
4130         }
4131 
4132         if (isGeneratorWrapperParseMode(generator.parseMode()))
4133             generator.emitPutGeneratorFields(next.get());
4134         else {
4135             ASSERT(isAsyncGeneratorWrapperParseMode(generator.parseMode()));
4136             generator.emitPutAsyncGeneratorFields(next.get());
4137         }
4138 
4139         ASSERT(startOffset() &gt;= lineStartOffset());
4140         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
4141         generator.emitReturn(generator.generatorRegister());
4142         break;
4143     }
4144 
4145     case SourceParseMode::AsyncFunctionMode:
4146     case SourceParseMode::AsyncMethodMode:
4147     case SourceParseMode::AsyncArrowFunctionMode: {
4148         StatementNode* singleStatement = this-&gt;singleStatement();
4149         ASSERT(singleStatement-&gt;isExprStatement());
4150         ExprStatementNode* exprStatement = static_cast&lt;ExprStatementNode*&gt;(singleStatement);
4151         ExpressionNode* expr = exprStatement-&gt;expr();
4152         ASSERT(expr-&gt;isFuncExprNode());
4153         FuncExprNode* funcExpr = static_cast&lt;FuncExprNode*&gt;(expr);
4154 
4155         RefPtr&lt;RegisterID&gt; next = generator.newTemporary();
4156         generator.emitNode(next.get(), funcExpr);
4157 
4158         if (generator.superBinding() == SuperBinding::Needed || (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isSuperUsedInInnerArrowFunction())) {
4159             RefPtr&lt;RegisterID&gt; homeObject = emitHomeObjectForCallee(generator);
4160             emitPutHomeObject(generator, next.get(), homeObject.get());
4161         }
4162 
4163         if (generator.parseMode() == SourceParseMode::AsyncArrowFunctionMode &amp;&amp; generator.isThisUsedInInnerArrowFunction())
4164             generator.emitLoadThisFromArrowFunctionLexicalEnvironment();
4165 
4166         generator.emitPutGeneratorFields(next.get());
4167 
4168         ASSERT(startOffset() &gt;= lineStartOffset());
4169         generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
4170 
4171         // load and call @asyncFunctionResume
<a name="42" id="anc42"></a><span class="line-modified">4172         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::asyncFunctionResume);</span>



4173 
4174         CallArguments args(generator, nullptr, 4);
4175         unsigned argumentCount = 0;
4176         generator.emitLoad(args.thisRegister(), jsUndefined());
4177         generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
<a name="43" id="anc43"></a><span class="line-modified">4178         generator.move(args.argumentRegister(argumentCount++), generator.promiseRegister());</span>
4179         generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
<a name="44" id="anc44"></a><span class="line-modified">4180         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode)));</span>
4181         // JSTextPosition(int _line, int _offset, int _lineStartOffset)
4182         JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
4183 
4184         RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4185         generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4186         generator.emitReturn(result.get());
4187         break;
4188     }
4189 
4190     case SourceParseMode::AsyncGeneratorBodyMode:
4191     case SourceParseMode::AsyncArrowFunctionBodyMode:
4192     case SourceParseMode::AsyncFunctionBodyMode:
4193     case SourceParseMode::GeneratorBodyMode: {
4194         Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
4195         {
4196             RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
<a name="45" id="anc45"></a><span class="line-modified">4197             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4198             generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
4199 
4200             Ref&lt;Label&gt; throwLabel = generator.newLabel();
<a name="46" id="anc46"></a><span class="line-modified">4201             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
4202             generator.emitJumpIfTrue(condition.get(), throwLabel.get());
4203 
4204             generator.emitReturn(generator.generatorValueRegister());
4205 
4206             generator.emitLabel(throwLabel.get());
4207             generator.emitThrow(generator.generatorValueRegister());
4208         }
4209 
4210         generator.emitLabel(generatorBodyLabel.get());
4211 
4212         emitStatementsBytecode(generator, generator.ignoredResult());
4213 
4214         Ref&lt;Label&gt; done = generator.newLabel();
4215         generator.emitLabel(done.get());
4216         generator.emitReturn(generator.emitLoad(nullptr, jsUndefined()));
4217         break;
4218     }
4219 
4220     default: {
4221         emitStatementsBytecode(generator, generator.ignoredResult());
4222 
4223         StatementNode* singleStatement = this-&gt;singleStatement();
4224         ReturnNode* returnNode = 0;
4225 
4226         // Check for a return statement at the end of a function composed of a single block.
4227         if (singleStatement &amp;&amp; singleStatement-&gt;isBlock()) {
4228             StatementNode* lastStatementInBlock = static_cast&lt;BlockNode*&gt;(singleStatement)-&gt;lastStatement();
4229             if (lastStatementInBlock &amp;&amp; lastStatementInBlock-&gt;isReturnNode())
4230                 returnNode = static_cast&lt;ReturnNode*&gt;(lastStatementInBlock);
4231         }
4232 
4233         // If there is no return we must automatically insert one.
4234         if (!returnNode) {
4235             if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
4236                 generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
4237 
<a name="47" id="anc47"></a><span class="line-modified">4238             RegisterID* r0 = nullptr;</span>
<span class="line-added">4239             if (generator.isConstructor() &amp;&amp; generator.constructorKind() != ConstructorKind::Naked)</span>
<span class="line-added">4240                 r0 = generator.thisRegister();</span>
<span class="line-added">4241             else</span>
<span class="line-added">4242                 r0 = generator.emitLoad(0, jsUndefined());</span>
4243             generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
4244             ASSERT(startOffset() &gt;= lineStartOffset());
4245             generator.emitWillLeaveCallFrameDebugHook();
4246             generator.emitReturn(r0);
4247             return;
4248         }
4249         break;
4250     }
4251     }
4252 }
4253 
4254 // ------------------------------ FuncDeclNode ---------------------------------
4255 
4256 void FuncDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4257 {
4258     generator.hoistSloppyModeFunctionIfNecessary(metadata()-&gt;ident());
4259 }
4260 
4261 // ------------------------------ FuncExprNode ---------------------------------
4262 
4263 RegisterID* FuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4264 {
4265     return generator.emitNewFunctionExpression(generator.finalDestination(dst), this);
4266 }
4267 
4268 // ------------------------------ ArrowFuncExprNode ---------------------------------
4269 
4270 RegisterID* ArrowFuncExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4271 {
4272     return generator.emitNewArrowFunctionExpression(generator.finalDestination(dst), this);
4273 }
4274 
4275 // ------------------------------ MethodDefinitionNode ---------------------------------
4276 
4277 RegisterID* MethodDefinitionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4278 {
4279     return generator.emitNewMethodDefinition(generator.finalDestination(dst), this);
4280 }
4281 
4282 // ------------------------------ YieldExprNode --------------------------------
4283 
4284 RegisterID* YieldExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4285 {
4286     if (!delegate()) {
4287         RefPtr&lt;RegisterID&gt; arg = nullptr;
4288         if (argument()) {
4289             arg = generator.newTemporary();
4290             generator.emitNode(arg.get(), argument());
4291         } else
4292             arg = generator.emitLoad(nullptr, jsUndefined());
<a name="48" id="anc48"></a><span class="line-modified">4293         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
4294         if (dst == generator.ignoredResult())
4295             return nullptr;
4296         return generator.move(generator.finalDestination(dst), value.get());
4297     }
4298     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4299     generator.emitNode(arg.get(), argument());
4300     RefPtr&lt;RegisterID&gt; value = generator.emitDelegateYield(arg.get(), this);
4301     if (dst == generator.ignoredResult())
4302         return nullptr;
4303     return generator.move(generator.finalDestination(dst), value.get());
4304 }
4305 
4306 // ------------------------------ AwaitExprNode --------------------------------
4307 
4308 RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4309 {
4310     RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
4311     generator.emitNode(arg.get(), argument());
<a name="49" id="anc49"></a><span class="line-modified">4312     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
4313     if (dst == generator.ignoredResult())
4314         return nullptr;
4315     return generator.move(generator.finalDestination(dst), value.get());
4316 }
4317 
<a name="50" id="anc50"></a><span class="line-added">4318 // ------------------------------ DefineFieldNode ---------------------------------</span>
<span class="line-added">4319 </span>
<span class="line-added">4320 void DefineFieldNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)</span>
<span class="line-added">4321 {</span>
<span class="line-added">4322     RefPtr&lt;RegisterID&gt; value = generator.newTemporary();</span>
<span class="line-added">4323 </span>
<span class="line-added">4324     if (!m_assign)</span>
<span class="line-added">4325         generator.emitLoad(value.get(), jsUndefined());</span>
<span class="line-added">4326     else {</span>
<span class="line-added">4327         generator.emitNode(value.get(), m_assign);</span>
<span class="line-added">4328         if (m_ident)</span>
<span class="line-added">4329             generator.emitSetFunctionNameIfNeeded(m_assign, value.get(), *m_ident);</span>
<span class="line-added">4330     }</span>
<span class="line-added">4331 </span>
<span class="line-added">4332     switch (m_type) {</span>
<span class="line-added">4333     case DefineFieldNode::Type::Name: {</span>
<span class="line-added">4334         // FIXME: Improve performance of public class fields</span>
<span class="line-added">4335         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">4336         RefPtr&lt;RegisterID&gt; propertyName = generator.emitLoad(nullptr, *m_ident);</span>
<span class="line-added">4337         generator.emitCallDefineProperty(generator.thisRegister(), propertyName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">4338         break;</span>
<span class="line-added">4339     }</span>
<span class="line-added">4340     case DefineFieldNode::Type::ComputedName: {</span>
<span class="line-added">4341         // FIXME: Improve performance of public class fields</span>
<span class="line-added">4342         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">4343 </span>
<span class="line-added">4344         // For ComputedNames, the expression has already been evaluated earlier during evaluation of a ClassExprNode.</span>
<span class="line-added">4345         // Here, `m_ident` refers to an integer ID in a class lexical scope, containing the value already converted to an Expression.</span>
<span class="line-added">4346         Variable var = generator.variable(*m_ident);</span>
<span class="line-added">4347         ASSERT_WITH_MESSAGE(!var.local(), &quot;Computed names must be stored in captured variables&quot;);</span>
<span class="line-added">4348 </span>
<span class="line-added">4349         generator.emitExpressionInfo(position(), position(), position() + 1);</span>
<span class="line-added">4350         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(generator.newTemporary(), var);</span>
<span class="line-added">4351         RefPtr&lt;RegisterID&gt; privateName = generator.newTemporary();</span>
<span class="line-added">4352         generator.emitGetFromScope(privateName.get(), scope.get(), var, ThrowIfNotFound);</span>
<span class="line-added">4353         generator.emitProfileType(privateName.get(), var, m_position, m_position + m_ident-&gt;length());</span>
<span class="line-added">4354         generator.emitCallDefineProperty(generator.thisRegister(), privateName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">4355         break;</span>
<span class="line-added">4356     }</span>
<span class="line-added">4357     }</span>
<span class="line-added">4358 }</span>
<span class="line-added">4359 </span>
4360 // ------------------------------ ClassDeclNode ---------------------------------
4361 
4362 void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
4363 {
4364     generator.emitNode(m_classDeclaration);
4365 }
4366 
4367 // ------------------------------ ClassExprNode ---------------------------------
4368 
4369 RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4370 {
<a name="51" id="anc51"></a><span class="line-modified">4371     if (m_needsLexicalScope)</span>
4372         generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
4373 
4374     RefPtr&lt;RegisterID&gt; superclass;
4375     if (m_classHeritage) {
4376         superclass = generator.newTemporary();
4377         generator.emitNode(superclass.get(), m_classHeritage);
4378     }
4379 
4380     RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
4381     bool needsHomeObject = false;
4382 
<a name="52" id="anc52"></a><span class="line-added">4383     auto needsClassFieldInitializer = this-&gt;hasInstanceFields() ? NeedsClassFieldInitializer::Yes : NeedsClassFieldInitializer::No;</span>
<span class="line-added">4384 </span>
4385     if (m_constructorExpression) {
4386         ASSERT(m_constructorExpression-&gt;isFuncExprNode());
4387         FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
4388         metadata-&gt;setEcmaName(ecmaName());
4389         metadata-&gt;setClassSource(m_classSource);
<a name="53" id="anc53"></a><span class="line-added">4390         metadata-&gt;setNeedsClassFieldInitializer(needsClassFieldInitializer == NeedsClassFieldInitializer::Yes);</span>
4391         constructor = generator.emitNode(constructor.get(), m_constructorExpression);
4392         needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
4393     } else
<a name="54" id="anc54"></a><span class="line-modified">4394         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource, needsClassFieldInitializer);</span>
4395 
4396     const auto&amp; propertyNames = generator.propertyNames();
4397     RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
4398 
4399     if (superclass) {
4400         RefPtr&lt;RegisterID&gt; protoParent = generator.newTemporary();
4401         generator.emitLoad(protoParent.get(), jsNull());
4402 
4403         RefPtr&lt;RegisterID&gt; tempRegister = generator.newTemporary();
4404 
4405         // FIXME: Throw TypeError if it&#39;s a generator function.
4406         Ref&lt;Label&gt; superclassIsUndefinedLabel = generator.newLabel();
4407         generator.emitJumpIfTrue(generator.emitIsUndefined(tempRegister.get(), superclass.get()), superclassIsUndefinedLabel.get());
4408 
4409         Ref&lt;Label&gt; superclassIsNullLabel = generator.newLabel();
4410         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpEqNull&gt;(tempRegister.get(), superclass.get()), superclassIsNullLabel.get());
4411 
4412         Ref&lt;Label&gt; superclassIsObjectLabel = generator.newLabel();
4413         generator.emitJumpIfTrue(generator.emitIsObject(tempRegister.get(), superclass.get()), superclassIsObjectLabel.get());
4414         generator.emitLabel(superclassIsUndefinedLabel.get());
4415         generator.emitThrowTypeError(&quot;The superclass is not an object.&quot;_s);
4416         generator.emitLabel(superclassIsObjectLabel.get());
4417         generator.emitGetById(protoParent.get(), superclass.get(), generator.propertyNames().prototype);
4418 
4419         Ref&lt;Label&gt; protoParentIsObjectOrNullLabel = generator.newLabel();
4420         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsObjectOrNull&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4421         generator.emitJumpIfTrue(generator.emitUnaryOp&lt;OpIsFunction&gt;(tempRegister.get(), protoParent.get()), protoParentIsObjectOrNullLabel.get());
4422         generator.emitThrowTypeError(&quot;The value of the superclass&#39;s prototype property is not an object.&quot;_s);
4423         generator.emitLabel(protoParentIsObjectOrNullLabel.get());
4424 
4425         generator.emitDirectPutById(constructor.get(), generator.propertyNames().underscoreProto, superclass.get(), PropertyNode::Unknown);
4426         generator.emitLabel(superclassIsNullLabel.get());
4427         generator.emitDirectPutById(prototype.get(), generator.propertyNames().underscoreProto, protoParent.get(), PropertyNode::Unknown);
4428     }
4429 
4430     if (needsHomeObject)
4431         emitPutHomeObject(generator, constructor.get(), prototype.get());
4432 
4433     RefPtr&lt;RegisterID&gt; constructorNameRegister = generator.emitLoad(nullptr, propertyNames.constructor);
4434     generator.emitCallDefineProperty(prototype.get(), constructorNameRegister.get(), constructor.get(), nullptr, nullptr,
4435         BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
4436 
4437     RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
4438     generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
4439 
<a name="55" id="anc55"></a><span class="line-modified">4440     if (m_classElements) {</span>
<span class="line-modified">4441         Vector&lt;JSTextPosition&gt; instanceFieldLocations;</span>
<span class="line-added">4442         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get(), instanceFieldLocations);</span>
<span class="line-added">4443         if (!instanceFieldLocations.isEmpty()) {</span>
<span class="line-added">4444             RefPtr&lt;RegisterID&gt; instanceFieldInitializer = generator.emitNewInstanceFieldInitializerFunction(generator.newTemporary(), WTFMove(instanceFieldLocations), m_classHeritage);</span>
<span class="line-added">4445 </span>
<span class="line-added">4446             // FIXME: Skip this if the initializer function isn&#39;t going to need a home object (no eval or super properties)</span>
<span class="line-added">4447             // https://bugs.webkit.org/show_bug.cgi?id=196867</span>
<span class="line-added">4448             emitPutHomeObject(generator, instanceFieldInitializer.get(), prototype.get());</span>
4449 
<a name="56" id="anc56"></a><span class="line-modified">4450             generator.emitDirectPutById(constructor.get(), generator.propertyNames().builtinNames().instanceFieldInitializerPrivateName(), instanceFieldInitializer.get(), PropertyNode::Unknown);</span>
<span class="line-modified">4451         }</span>
<span class="line-modified">4452     }</span>
<span class="line-modified">4453 </span>
<span class="line-modified">4454     if (m_needsLexicalScope) {</span>
<span class="line-added">4455         if (!m_name.isNull()) {</span>
<span class="line-added">4456             Variable classNameVar = generator.variable(m_name);</span>
<span class="line-added">4457             RELEASE_ASSERT(classNameVar.isResolved());</span>
<span class="line-added">4458             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);</span>
<span class="line-added">4459             generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);</span>
<span class="line-added">4460         }</span>
4461         generator.popLexicalScope(this);
4462     }
4463 
4464     return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
4465 }
4466 
4467 // ------------------------------ ImportDeclarationNode -----------------------
4468 
4469 void ImportDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4470 {
4471     // Do nothing at runtime.
4472 }
4473 
4474 // ------------------------------ ExportAllDeclarationNode --------------------
4475 
4476 void ExportAllDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4477 {
4478     // Do nothing at runtime.
4479 }
4480 
4481 // ------------------------------ ExportDefaultDeclarationNode ----------------
4482 
4483 void ExportDefaultDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4484 {
4485     ASSERT(m_declaration);
4486     generator.emitNode(dst, m_declaration);
4487 }
4488 
4489 // ------------------------------ ExportLocalDeclarationNode ------------------
4490 
4491 void ExportLocalDeclarationNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4492 {
4493     ASSERT(m_declaration);
4494     generator.emitNode(dst, m_declaration);
4495 }
4496 
4497 // ------------------------------ ExportNamedDeclarationNode ------------------
4498 
4499 void ExportNamedDeclarationNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4500 {
4501     // Do nothing at runtime.
4502 }
4503 
4504 // ------------------------------ DestructuringAssignmentNode -----------------
4505 RegisterID* DestructuringAssignmentNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4506 {
4507     if (RegisterID* result = m_bindings-&gt;emitDirectBinding(generator, dst, m_initializer))
4508         return result;
4509     RefPtr&lt;RegisterID&gt; initializer = generator.tempDestination(dst);
4510     generator.emitNode(initializer.get(), m_initializer);
4511     m_bindings-&gt;bindValue(generator, initializer.get());
4512     return generator.move(dst, initializer.get());
4513 }
4514 
4515 static void assignDefaultValueIfUndefined(BytecodeGenerator&amp; generator, RegisterID* maybeUndefined, ExpressionNode* defaultValue)
4516 {
4517     ASSERT(defaultValue);
4518     Ref&lt;Label&gt; isNotUndefined = generator.newLabel();
4519     generator.emitJumpIfFalse(generator.emitIsUndefined(generator.newTemporary(), maybeUndefined), isNotUndefined.get());
4520     generator.emitNode(maybeUndefined, defaultValue);
4521     generator.emitLabel(isNotUndefined.get());
4522 }
4523 
4524 void ArrayPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4525 {
4526     RefPtr&lt;RegisterID&gt; iterator = generator.newTemporary();
4527     {
4528         generator.emitGetById(iterator.get(), rhs, generator.propertyNames().iteratorSymbol);
4529         CallArguments args(generator, nullptr);
4530         generator.move(args.thisRegister(), rhs);
4531         generator.emitCall(iterator.get(), iterator.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4532     }
4533     RefPtr&lt;RegisterID&gt; nextMethod = generator.emitGetById(generator.newTemporary(), iterator.get(), generator.propertyNames().next);
4534 
4535     if (m_targetPatterns.isEmpty()) {
4536         generator.emitIteratorClose(iterator.get(), this);
4537         return;
4538     }
4539 
4540     RefPtr&lt;RegisterID&gt; done;
4541     for (auto&amp; target : m_targetPatterns) {
4542         switch (target.bindingType) {
4543         case BindingType::Elision:
4544         case BindingType::Element: {
4545             Ref&lt;Label&gt; iterationSkipped = generator.newLabel();
4546             if (!done)
4547                 done = generator.newTemporary();
4548             else
4549                 generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4550 
4551             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4552             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4553             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4554             generator.emitJumpIfTrue(done.get(), iterationSkipped.get());
4555             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4556 
4557             {
4558                 Ref&lt;Label&gt; valueIsSet = generator.newLabel();
4559                 generator.emitJump(valueIsSet.get());
4560                 generator.emitLabel(iterationSkipped.get());
4561                 generator.emitLoad(value.get(), jsUndefined());
4562                 generator.emitLabel(valueIsSet.get());
4563             }
4564 
4565             if (target.bindingType == BindingType::Element) {
4566                 if (target.defaultValue)
4567                     assignDefaultValueIfUndefined(generator, value.get(), target.defaultValue);
4568                 target.pattern-&gt;bindValue(generator, value.get());
4569             }
4570             break;
4571         }
4572 
4573         case BindingType::RestElement: {
4574             RefPtr&lt;RegisterID&gt; array = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4575 
4576             Ref&lt;Label&gt; iterationDone = generator.newLabel();
4577             if (!done)
4578                 done = generator.newTemporary();
4579             else
4580                 generator.emitJumpIfTrue(done.get(), iterationDone.get());
4581 
4582             RefPtr&lt;RegisterID&gt; index = generator.newTemporary();
4583             generator.emitLoad(index.get(), jsNumber(0));
4584             Ref&lt;Label&gt; loopStart = generator.newLabel();
4585             generator.emitLabel(loopStart.get());
4586 
4587             RefPtr&lt;RegisterID&gt; value = generator.newTemporary();
4588             generator.emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), this);
4589             generator.emitGetById(done.get(), value.get(), generator.propertyNames().done);
4590             generator.emitJumpIfTrue(done.get(), iterationDone.get());
4591             generator.emitGetById(value.get(), value.get(), generator.propertyNames().value);
4592 
4593             generator.emitDirectPutByVal(array.get(), index.get(), value.get());
4594             generator.emitInc(index.get());
4595             generator.emitJump(loopStart.get());
4596 
4597             generator.emitLabel(iterationDone.get());
4598             target.pattern-&gt;bindValue(generator, array.get());
4599             break;
4600         }
4601         }
4602     }
4603 
4604     Ref&lt;Label&gt; iteratorClosed = generator.newLabel();
4605     generator.emitJumpIfTrue(done.get(), iteratorClosed.get());
4606     generator.emitIteratorClose(iterator.get(), this);
4607     generator.emitLabel(iteratorClosed.get());
4608 }
4609 
4610 RegisterID* ArrayPatternNode::emitDirectBinding(BytecodeGenerator&amp; generator, RegisterID* dst, ExpressionNode* rhs)
4611 {
4612     if (!rhs-&gt;isSimpleArray())
4613         return nullptr;
4614 
4615     ElementNode* elementNodes = static_cast&lt;ArrayNode*&gt;(rhs)-&gt;elements();
4616     Vector&lt;ExpressionNode*&gt; elements;
4617     for (; elementNodes; elementNodes = elementNodes-&gt;next()) {
4618         ExpressionNode* value = elementNodes-&gt;value();
4619         if (value-&gt;isSpreadExpression())
4620             return nullptr;
4621         elements.append(value);
4622     }
4623 
4624     RefPtr&lt;RegisterID&gt; resultRegister;
4625     if (dst != generator.ignoredResult())
4626         resultRegister = generator.emitNewArray(generator.newTemporary(), nullptr, 0, ArrayWithUndecided);
4627     if (m_targetPatterns.size() != elements.size())
4628         return nullptr;
4629     Vector&lt;RefPtr&lt;RegisterID&gt;&gt; registers;
4630     registers.reserveCapacity(m_targetPatterns.size());
4631     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4632         registers.uncheckedAppend(generator.newTemporary());
4633         generator.emitNode(registers.last().get(), elements[i]);
4634         if (m_targetPatterns[i].defaultValue)
4635             assignDefaultValueIfUndefined(generator, registers.last().get(), m_targetPatterns[i].defaultValue);
4636         if (resultRegister) {
4637             RefPtr&lt;RegisterID&gt; index = generator.emitLoad(nullptr, jsNumber(i));
4638             generator.emitDirectPutByVal(resultRegister.get(), index.get(), registers.last().get());
4639         }
4640     }
4641 
4642     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4643         if (m_targetPatterns[i].pattern)
4644             m_targetPatterns[i].pattern-&gt;bindValue(generator, registers[i].get());
4645     }
4646     if (resultRegister)
4647         return generator.move(generator.finalDestination(dst, resultRegister.get()), resultRegister.get());
4648     return generator.emitLoad(generator.finalDestination(dst), jsUndefined());
4649 }
4650 
4651 void ArrayPatternNode::toString(StringBuilder&amp; builder) const
4652 {
4653     builder.append(&#39;[&#39;);
4654     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4655         const auto&amp; target = m_targetPatterns[i];
4656 
4657         switch (target.bindingType) {
4658         case BindingType::Elision:
4659             builder.append(&#39;,&#39;);
4660             break;
4661 
4662         case BindingType::Element:
4663             target.pattern-&gt;toString(builder);
4664             if (i &lt; m_targetPatterns.size() - 1)
4665                 builder.append(&#39;,&#39;);
4666             break;
4667 
4668         case BindingType::RestElement:
4669             builder.appendLiteral(&quot;...&quot;);
4670             target.pattern-&gt;toString(builder);
4671             break;
4672         }
4673     }
4674     builder.append(&#39;]&#39;);
4675 }
4676 
4677 void ArrayPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4678 {
4679     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4680         if (DestructuringPatternNode* node = m_targetPatterns[i].pattern)
4681             node-&gt;collectBoundIdentifiers(identifiers);
4682     }
4683 }
4684 
4685 void ObjectPatternNode::toString(StringBuilder&amp; builder) const
4686 {
4687     builder.append(&#39;{&#39;);
4688     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4689         if (m_targetPatterns[i].wasString)
4690             builder.appendQuotedJSONString(m_targetPatterns[i].propertyName.string());
4691         else
4692             builder.append(m_targetPatterns[i].propertyName.string());
4693         builder.append(&#39;:&#39;);
4694         m_targetPatterns[i].pattern-&gt;toString(builder);
4695         if (i &lt; m_targetPatterns.size() - 1)
4696             builder.append(&#39;,&#39;);
4697     }
4698     builder.append(&#39;}&#39;);
4699 }
4700 
4701 void ObjectPatternNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* rhs) const
4702 {
4703     generator.emitRequireObjectCoercible(rhs, &quot;Right side of assignment cannot be destructured&quot;_s);
4704 
4705     RefPtr&lt;RegisterID&gt; excludedList;
4706     IdentifierSet excludedSet;
4707     RefPtr&lt;RegisterID&gt; addMethod;
4708     if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
<a name="57" id="anc57"></a><span class="line-modified">4709         RefPtr&lt;RegisterID&gt; setConstructor = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::Set);</span>




4710 
4711         CallArguments args(generator, nullptr, 0);
4712         excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
4713 
4714         addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
4715     }
4716 
4717     BytecodeGenerator::PreservedTDZStack preservedTDZStack;
4718     generator.preserveTDZStack(preservedTDZStack);
4719 
4720     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++) {
4721         const auto&amp; target = m_targetPatterns[i];
4722         if (target.bindingType == BindingType::Element) {
4723             RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4724             RefPtr&lt;RegisterID&gt; propertyName;
4725             if (!target.propertyExpression) {
4726                 Optional&lt;uint32_t&gt; optionalIndex = parseIndex(target.propertyName);
4727                 if (!optionalIndex)
4728                     generator.emitGetById(temp.get(), rhs, target.propertyName);
4729                 else {
4730                     RefPtr&lt;RegisterID&gt; propertyIndex = generator.emitLoad(nullptr, jsNumber(optionalIndex.value()));
4731                     generator.emitGetByVal(temp.get(), rhs, propertyIndex.get());
4732                 }
4733             } else {
4734                 propertyName = generator.emitNodeForProperty(target.propertyExpression);
4735                 generator.emitGetByVal(temp.get(), rhs, propertyName.get());
4736             }
4737 
4738             if (m_containsRestElement) {
4739                 if (m_containsComputedProperty) {
4740                     if (!target.propertyExpression)
4741                         propertyName = generator.emitLoad(nullptr, target.propertyName);
4742 
4743                     CallArguments args(generator, nullptr, 1);
4744                     generator.move(args.thisRegister(), excludedList.get());
4745                     generator.move(args.argumentRegister(0), propertyName.get());
4746                     generator.emitCall(generator.newTemporary(), addMethod.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4747                 } else
4748                     excludedSet.add(target.propertyName.impl());
4749             }
4750 
4751             if (target.defaultValue)
4752                 assignDefaultValueIfUndefined(generator, temp.get(), target.defaultValue);
4753             target.pattern-&gt;bindValue(generator, temp.get());
4754         } else {
4755             ASSERT(target.bindingType == BindingType::RestElement);
4756             ASSERT(i == m_targetPatterns.size() - 1);
4757             RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
4758 
4759             // load and call @copyDataProperties
<a name="58" id="anc58"></a><span class="line-modified">4760             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataProperties);</span>




4761 
4762             CallArguments args(generator, nullptr, 3);
4763             generator.emitLoad(args.thisRegister(), jsUndefined());
4764             generator.move(args.argumentRegister(0), newObject.get());
4765             generator.move(args.argumentRegister(1), rhs);
4766             if (m_containsComputedProperty)
4767                 generator.move(args.argumentRegister(2), excludedList.get());
4768             else {
4769                 RefPtr&lt;RegisterID&gt; excludedSetReg = generator.emitLoad(generator.newTemporary(), excludedSet);
4770                 generator.move(args.argumentRegister(2), excludedSetReg.get());
4771             }
4772 
4773             RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
4774             generator.emitCall(result.get(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4775             target.pattern-&gt;bindValue(generator, result.get());
4776         }
4777     }
4778 
4779     generator.restoreTDZStack(preservedTDZStack);
4780 }
4781 
4782 void ObjectPatternNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4783 {
4784     for (size_t i = 0; i &lt; m_targetPatterns.size(); i++)
4785         m_targetPatterns[i].pattern-&gt;collectBoundIdentifiers(identifiers);
4786 }
4787 
4788 void BindingNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4789 {
4790     Variable var = generator.variable(m_boundProperty);
4791     bool isReadOnly = var.isReadOnly() &amp;&amp; m_bindingContext != AssignmentContext::ConstDeclarationStatement;
4792     if (RegisterID* local = var.local()) {
4793         if (m_bindingContext == AssignmentContext::AssignmentExpression)
4794             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4795         if (isReadOnly) {
4796             generator.emitReadOnlyExceptionIfNeeded(var);
4797             return;
4798         }
4799         generator.move(local, value);
4800         generator.emitProfileType(local, var, divotStart(), divotEnd());
4801         if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4802             generator.liftTDZCheckIfPossible(var);
4803         return;
4804     }
4805     if (generator.isStrictMode())
4806         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4807     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4808     generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4809     if (m_bindingContext == AssignmentContext::AssignmentExpression)
4810         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4811     if (isReadOnly) {
4812         generator.emitReadOnlyExceptionIfNeeded(var);
4813         return;
4814     }
4815     generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, initializationModeForAssignmentContext(m_bindingContext));
4816     generator.emitProfileType(value, var, divotStart(), divotEnd());
4817     if (m_bindingContext == AssignmentContext::DeclarationStatement || m_bindingContext == AssignmentContext::ConstDeclarationStatement)
4818         generator.liftTDZCheckIfPossible(var);
4819     return;
4820 }
4821 
4822 void BindingNode::toString(StringBuilder&amp; builder) const
4823 {
4824     builder.append(m_boundProperty.string());
4825 }
4826 
4827 void BindingNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4828 {
4829     identifiers.append(m_boundProperty);
4830 }
4831 
4832 void AssignmentElementNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const
4833 {
4834 }
4835 
4836 void AssignmentElementNode::bindValue(BytecodeGenerator&amp; generator, RegisterID* value) const
4837 {
4838     if (m_assignmentTarget-&gt;isResolveNode()) {
4839         ResolveNode* lhs = static_cast&lt;ResolveNode*&gt;(m_assignmentTarget);
4840         Variable var = generator.variable(lhs-&gt;identifier());
4841         bool isReadOnly = var.isReadOnly();
4842         if (RegisterID* local = var.local()) {
4843             generator.emitTDZCheckIfNecessary(var, local, nullptr);
4844 
4845             if (isReadOnly)
4846                 generator.emitReadOnlyExceptionIfNeeded(var);
4847             else {
4848                 generator.move(local, value);
4849                 generator.emitProfileType(local, divotStart(), divotEnd());
4850             }
4851             return;
4852         }
4853         if (generator.isStrictMode())
4854             generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4855         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
4856         generator.emitTDZCheckIfNecessary(var, nullptr, scope.get());
4857         if (isReadOnly) {
4858             bool threwException = generator.emitReadOnlyExceptionIfNeeded(var);
4859             if (threwException)
4860                 return;
4861         }
4862         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4863         if (!isReadOnly) {
4864             generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
4865             generator.emitProfileType(value, var, divotStart(), divotEnd());
4866         }
4867     } else if (m_assignmentTarget-&gt;isDotAccessorNode()) {
4868         DotAccessorNode* lhs = static_cast&lt;DotAccessorNode*&gt;(m_assignmentTarget);
4869         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4870         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4871         if (lhs-&gt;base()-&gt;isSuperNode()) {
4872             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4873             generator.emitPutById(base.get(), thisValue.get(), lhs-&gt;identifier(), value);
4874         } else
4875             generator.emitPutById(base.get(), lhs-&gt;identifier(), value);
4876         generator.emitProfileType(value, divotStart(), divotEnd());
4877     } else if (m_assignmentTarget-&gt;isBracketAccessorNode()) {
4878         BracketAccessorNode* lhs = static_cast&lt;BracketAccessorNode*&gt;(m_assignmentTarget);
4879         RefPtr&lt;RegisterID&gt; base = generator.emitNodeForLeftHandSide(lhs-&gt;base(), true, false);
4880         RefPtr&lt;RegisterID&gt; property = generator.emitNodeForLeftHandSideForProperty(lhs-&gt;subscript(), true, false);
4881         generator.emitExpressionInfo(divotEnd(), divotStart(), divotEnd());
4882         if (lhs-&gt;base()-&gt;isSuperNode()) {
4883             RefPtr&lt;RegisterID&gt; thisValue = generator.ensureThis();
4884             generator.emitPutByVal(base.get(), thisValue.get(), property.get(), value);
4885         } else
4886             generator.emitPutByVal(base.get(), property.get(), value);
4887         generator.emitProfileType(value, divotStart(), divotEnd());
4888     }
4889 }
4890 
4891 void AssignmentElementNode::toString(StringBuilder&amp; builder) const
4892 {
4893     if (m_assignmentTarget-&gt;isResolveNode())
4894         builder.append(static_cast&lt;ResolveNode*&gt;(m_assignmentTarget)-&gt;identifier().string());
4895 }
4896 
4897 void RestParameterNode::collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp; identifiers) const
4898 {
4899     m_pattern-&gt;collectBoundIdentifiers(identifiers);
4900 }
4901 
4902 void RestParameterNode::toString(StringBuilder&amp; builder) const
4903 {
4904     builder.appendLiteral(&quot;...&quot;);
4905     m_pattern-&gt;toString(builder);
4906 }
4907 
4908 void RestParameterNode::bindValue(BytecodeGenerator&amp;, RegisterID*) const
4909 {
4910     RELEASE_ASSERT_NOT_REACHED();
4911 }
4912 
4913 void RestParameterNode::emit(BytecodeGenerator&amp; generator)
4914 {
4915     RefPtr&lt;RegisterID&gt; temp = generator.newTemporary();
4916     generator.emitRestParameter(temp.get(), m_numParametersToSkip);
4917     m_pattern-&gt;bindValue(generator, temp.get());
4918 }
4919 
4920 
4921 RegisterID* SpreadExpressionNode::emitBytecode(BytecodeGenerator&amp;, RegisterID*)
4922 {
4923     RELEASE_ASSERT_NOT_REACHED();
4924     return 0;
4925 }
4926 
4927 RegisterID* ObjectSpreadExpressionNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
4928 {
4929     RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
4930     generator.emitNode(src.get(), m_expression);
4931 
4932     // load and call @copyDataPropertiesNoExclusions
<a name="59" id="anc59"></a><span class="line-modified">4933     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataPropertiesNoExclusions);</span>




4934 
4935     CallArguments args(generator, nullptr, 2);
4936     generator.emitLoad(args.thisRegister(), jsUndefined());
4937     generator.move(args.argumentRegister(0), dst);
4938     generator.move(args.argumentRegister(1), src.get());
4939 
4940     generator.emitCall(generator.newTemporary(), copyDataProperties.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd(), DebuggableCall::No);
4941 
4942     return dst;
4943 }
4944 
4945 } // namespace JSC
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
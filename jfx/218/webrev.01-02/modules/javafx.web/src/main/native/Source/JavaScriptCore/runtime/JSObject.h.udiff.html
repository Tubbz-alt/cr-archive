<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObject.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -53,11 +53,11 @@</span>
  
  inline JSCell* getJSFunction(JSValue value)
  {
      if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
          return value.asCell();
<span class="udiff-line-modified-removed">-     return 0;</span>
<span class="udiff-line-modified-added">+     return nullptr;</span>
  }
  
  class Exception;
  class GetterSetter;
  class InternalFunction;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -69,11 +69,11 @@</span>
  class Structure;
  class ThrowScope;
  struct HashTable;
  struct HashTableValue;
  
<span class="udiff-line-modified-removed">- JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&amp;, const String&amp;);</span>
<span class="udiff-line-modified-added">+ JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&amp;, const String&amp;);</span>
  extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101,15 +101,21 @@</span>
          PutModePut,
          PutModeDefineOwnProperty,
      };
  
  public:
<span class="udiff-line-modified-removed">-     typedef JSCell Base;</span>
<span class="udiff-line-modified-added">+     using Base = JSCell;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Don&#39;t call this directly. Call JSC::subspaceFor&lt;Type&gt;(vm) instead.</span>
<span class="udiff-line-added">+     // FIXME: Refer to Subspace by reference.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=166988</span>
<span class="udiff-line-added">+     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="udiff-line-added">+     static CompleteSubspace* subspaceFor(VM&amp;);</span>
  
      // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
      // JSFinalObject or a JSArray. This is the method that will do that.
<span class="udiff-line-modified-removed">-     static JSObject* createRawObject(ExecState* exec, Structure* structure, Butterfly* = nullptr);</span>
<span class="udiff-line-modified-added">+     static JSObject* createRawObject(VM&amp; vm, Structure* structure, Butterfly* = nullptr);</span>
  
      JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
      JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
      JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -118,17 +124,17 @@</span>
  
      // This function is what Object.prototype.toString() will use to get the name of
      // an object when using Symbol.toStringTag fails. For the most part there is no
      // difference between this and className(). The main use case is for new JS language
      // objects to set the default tag to &quot;Object&quot;.
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, ExecState*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, JSGlobalObject*);</span>
  
      // This is the fully virtual [[GetPrototypeOf]] internal function defined
      // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
      // operation as dictated in the specification.
<span class="udiff-line-modified-removed">-     JSValue getPrototype(VM&amp;, ExecState*);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, ExecState*);</span>
<span class="udiff-line-modified-added">+     JSValue getPrototype(VM&amp;, JSGlobalObject*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, JSGlobalObject*);</span>
      // This gets the prototype directly off of the structure. This does not do
      // dynamic dispatch on the getPrototype method table method. It is not valid
      // to use this when performing a [[GetPrototypeOf]] operation in the specification.
      // It is valid to use though when you know that you want to directly get it
      // without consulting the method table. This is akin to getting the [[Prototype]]
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -144,38 +150,38 @@</span>
      // [[Prototype]] internal field directly as described in the specification.
      JS_EXPORT_PRIVATE void setPrototypeDirect(VM&amp;, JSValue prototype);
  private:
      // This is OrdinarySetPrototypeOf in the specification. Section 9.1.2.1
      // https://tc39.github.io/ecma262/#sec-ordinarysetprototypeof
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);</span>
  public:
      // This is the fully virtual [[SetPrototypeOf]] internal function defined
      // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
      // operation as dictated in the specification.
<span class="udiff-line-modified-removed">-     bool setPrototype(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet = false);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);</span>
<span class="udiff-line-modified-added">+     bool setPrototype(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet = false);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);</span>
  
      inline bool mayInterceptIndexedAccesses(VM&amp;);
  
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, PropertyName) const;</span>
<span class="udiff-line-modified-removed">-     JSValue get(ExecState*, unsigned propertyName) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, PropertyName) const;</span>
<span class="udiff-line-modified-added">+     JSValue get(JSGlobalObject*, unsigned propertyName) const;</span>
  
      template&lt;bool checkNullStructure = false&gt;
<span class="udiff-line-modified-removed">-     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-removed">-     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-added">+     bool getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     bool getPropertySlot(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, CallbackWhenNoException) const;</span>
<span class="udiff-line-modified-added">+     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
  
<span class="udiff-line-modified-removed">-     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     bool getOwnPropertySlotInline(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-removed">-     static void doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     bool getOwnPropertySlotInline(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     static void doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;);</span>
  
      // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
      // currently returns incorrect results for the DOM window (with non-own properties)
      // being returned. Once this is fixed we should migrate code &amp; remove this method.
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(JSGlobalObject*, PropertyName, PropertyDescriptor&amp;);</span>
  
      unsigned getArrayLength() const
      {
          if (!hasIndexedProperties(indexingType()))
              return 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -187,34 +193,34 @@</span>
          if (!hasIndexedProperties(indexingType()))
              return 0;
          return m_butterfly-&gt;vectorLength();
      }
  
<span class="udiff-line-modified-removed">-     static bool putInlineForJSObject(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     static bool putInlineForJSObject(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
      // putByIndex assumes that the receiver is this JSCell object.
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
  
      // This performs the ECMAScript Set() operation.
<span class="udiff-line-modified-removed">-     ALWAYS_INLINE bool putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
<span class="udiff-line-modified-added">+     ALWAYS_INLINE bool putByIndexInline(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
      {
<span class="udiff-line-modified-removed">-         VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+         VM&amp; vm = getVM(globalObject);</span>
          if (canSetIndexQuickly(propertyName, value)) {
              setIndexQuickly(vm, propertyName, value);
              return true;
          }
<span class="udiff-line-modified-removed">-         return methodTable(vm)-&gt;putByIndex(this, exec, propertyName, value, shouldThrow);</span>
<span class="udiff-line-modified-added">+         return methodTable(vm)-&gt;putByIndex(this, globalObject, propertyName, value, shouldThrow);</span>
      }
  
      // This is similar to the putDirect* methods:
      //  - the prototype chain is not consulted
      //  - accessors are not called.
      //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
      // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
      // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
<span class="udiff-line-modified-removed">-     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
<span class="udiff-line-modified-added">+     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
      {
          ASSERT(!value.isCustomGetterSetter());
          auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
              switch (indexingMode()) {
              case ALL_BLANK_INDEXING_TYPES:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -232,28 +238,28 @@</span>
                  return false;
              }
          };
  
          if (!attributes &amp;&amp; canSetIndexQuicklyForPutDirect()) {
<span class="udiff-line-modified-removed">-             setIndexQuickly(exec-&gt;vm(), propertyName, value);</span>
<span class="udiff-line-modified-added">+             setIndexQuickly(getVM(globalObject), propertyName, value);</span>
              return true;
          }
<span class="udiff-line-modified-removed">-         return putDirectIndexSlowOrBeyondVectorLength(exec, propertyName, value, attributes, mode);</span>
<span class="udiff-line-modified-added">+         return putDirectIndexSlowOrBeyondVectorLength(globalObject, propertyName, value, attributes, mode);</span>
      }
      // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
<span class="udiff-line-modified-removed">-     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value)</span>
<span class="udiff-line-modified-added">+     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value)</span>
      {
<span class="udiff-line-modified-removed">-         return putDirectIndex(exec, propertyName, value, 0, PutDirectIndexLikePutDirect);</span>
<span class="udiff-line-modified-added">+         return putDirectIndex(globalObject, propertyName, value, 0, PutDirectIndexLikePutDirect);</span>
      }
  
      // A generally non-throwing version of putDirect and putDirectIndex.
      // However, it&#39;s only guaranteed to not throw based on what the receiver is.
      // For example, if the receiver is a ProxyObject, this is not guaranteed, since
      // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
      // this API to ensure that the receiver object is a well known type if they
      // want to ensure that this won&#39;t throw an exception.
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(ExecState*, PropertyName, JSValue);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(JSGlobalObject*, PropertyName, JSValue);</span>
  
      bool hasIndexingHeader(VM&amp; vm) const
      {
          return structure(vm)-&gt;hasIndexingHeader(this);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -346,25 +352,25 @@</span>
              break;
          }
          return JSValue();
      }
  
<span class="udiff-line-modified-removed">-     JSValue getDirectIndex(ExecState* exec, unsigned i)</span>
<span class="udiff-line-modified-added">+     JSValue getDirectIndex(JSGlobalObject* globalObject, unsigned i)</span>
      {
          if (JSValue result = tryGetIndexQuickly(i))
              return result;
          PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="udiff-line-modified-removed">-         if (methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(this, exec, i, slot))</span>
<span class="udiff-line-modified-removed">-             return slot.getValue(exec, i);</span>
<span class="udiff-line-modified-added">+         if (methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(this, globalObject, i, slot))</span>
<span class="udiff-line-modified-added">+             return slot.getValue(globalObject, i);</span>
          return JSValue();
      }
  
<span class="udiff-line-modified-removed">-     JSValue getIndex(ExecState* exec, unsigned i) const</span>
<span class="udiff-line-modified-added">+     JSValue getIndex(JSGlobalObject* globalObject, unsigned i) const</span>
      {
          if (JSValue result = tryGetIndexQuickly(i))
              return result;
<span class="udiff-line-modified-removed">-         return get(exec, i);</span>
<span class="udiff-line-modified-added">+         return get(globalObject, i);</span>
      }
  
      bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;
      void setIndexQuicklyForTypedArray(unsigned, JSValue);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -407,13 +413,14 @@</span>
              }
              FALLTHROUGH;
          }
          case ALL_CONTIGUOUS_INDEXING_TYPES: {
              ASSERT(i &lt; butterfly-&gt;vectorLength());
<span class="udiff-line-modified-removed">-             butterfly-&gt;contiguous().at(this, i).set(vm, this, v);</span>
<span class="udiff-line-modified-added">+             butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);</span>
              if (i &gt;= butterfly-&gt;publicLength())
                  butterfly-&gt;setPublicLength(i + 1);
<span class="udiff-line-added">+             vm.heap.writeBarrier(this, v);</span>
              break;
          }
          case ALL_DOUBLE_INDEXING_TYPES: {
              ASSERT(i &lt; butterfly-&gt;vectorLength());
              if (!v.isNumber()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -600,48 +607,48 @@</span>
      bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
      bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
      void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
      bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
      void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
<span class="udiff-line-modified-removed">-     bool putDirectAccessor(ExecState*, PropertyName, GetterSetter*, unsigned attributes);</span>
<span class="udiff-line-modified-added">+     bool putDirectAccessor(JSGlobalObject*, PropertyName, GetterSetter*, unsigned attributes);</span>
      JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
  
<span class="udiff-line-modified-removed">-     bool putGetter(ExecState*, PropertyName, JSValue, unsigned attributes);</span>
<span class="udiff-line-modified-removed">-     bool putSetter(ExecState*, PropertyName, JSValue, unsigned attributes);</span>
<span class="udiff-line-modified-added">+     bool putGetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);</span>
<span class="udiff-line-modified-added">+     bool putSetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, PropertyName) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, unsigned propertyName) const;</span>
<span class="udiff-line-modified-removed">-     bool hasPropertyGeneric(ExecState*, PropertyName, PropertySlot::InternalMethodType) const;</span>
<span class="udiff-line-modified-removed">-     bool hasPropertyGeneric(ExecState*, unsigned propertyName, PropertySlot::InternalMethodType) const;</span>
<span class="udiff-line-modified-removed">-     bool hasOwnProperty(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-removed">-     bool hasOwnProperty(ExecState*, PropertyName) const;</span>
<span class="udiff-line-modified-removed">-     bool hasOwnProperty(ExecState*, unsigned) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, PropertyName) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, unsigned propertyName) const;</span>
<span class="udiff-line-modified-added">+     bool hasPropertyGeneric(JSGlobalObject*, PropertyName, PropertySlot::InternalMethodType) const;</span>
<span class="udiff-line-modified-added">+     bool hasPropertyGeneric(JSGlobalObject*, unsigned propertyName, PropertySlot::InternalMethodType) const;</span>
<span class="udiff-line-modified-added">+     bool hasOwnProperty(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="udiff-line-modified-added">+     bool hasOwnProperty(JSGlobalObject*, PropertyName) const;</span>
<span class="udiff-line-modified-added">+     bool hasOwnProperty(JSGlobalObject*, unsigned) const;</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);</span>
<span class="udiff-line-modified-removed">-     JSValue ordinaryToPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, JSGlobalObject*, PreferredPrimitiveType);</span>
<span class="udiff-line-modified-added">+     JSValue ordinaryToPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue value, JSValue hasInstanceValue);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue);</span>
<span class="udiff-line-modified-removed">-     static bool defaultHasInstance(ExecState*, JSValue, JSValue prototypeProperty);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue value, JSValue hasInstanceValue);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue);</span>
<span class="udiff-line-modified-added">+     static bool defaultHasInstance(JSGlobalObject*, JSValue, JSValue prototypeProperty);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(ExecState*, JSObject*);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(JSGlobalObject*, JSObject*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="udiff-line-modified-removed">-     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE double toNumber(ExecState*) const;</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSString* toString(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="udiff-line-modified-added">+     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE double toNumber(JSGlobalObject*) const;</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSString* toString(JSGlobalObject*) const;</span>
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, ExecState*, ECMAMode);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, JSGlobalObject*, ECMAMode);</span>
  
      // This get function only looks at the property map.
      JSValue getDirect(VM&amp; vm, PropertyName propertyName) const
      {
          Structure* structure = this-&gt;structure(vm);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -724,11 +731,14 @@</span>
      //  - assumes the object contains no own getter/setter properties.
      //  - provides no special handling for __proto__
      //  - does not walk the prototype chain (to check for accessors or non-writable properties).
      // This is used by JSLexicalEnvironment.
      bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
<span class="udiff-line-modified-removed">-     bool putOwnDataPropertyMayBeIndex(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     bool putOwnDataPropertyMayBeIndex(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     void validatePutOwnDataProperty(VM&amp;, PropertyName, JSValue);</span>
<span class="udiff-line-added">+ public:</span>
  
      // Fast access to known property offsets.
      ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
      JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
      void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -742,11 +752,11 @@</span>
      JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
  
      JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
      JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
  
      bool isEnvironment() const;
      bool isGlobalObject() const;
      bool isJSLexicalEnvironment() const;
      bool isGlobalLexicalEnvironment() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -755,12 +765,12 @@</span>
  
      bool isErrorInstance() const;
  
      JS_EXPORT_PRIVATE void seal(VM&amp;);
      JS_EXPORT_PRIVATE void freeze(VM&amp;);
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, ExecState*);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, ExecState*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, JSGlobalObject*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, JSGlobalObject*);</span>
      bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
      bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
  
      JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;
      JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -776,19 +786,19 @@</span>
      //   overridden.
      ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
      // You should call this when performing [[IsExtensible]] trap in a place
      // that is described in the specification. This performs the fully virtual
      // [[IsExtensible]] trap.
<span class="udiff-line-modified-removed">-     bool isExtensible(ExecState*);</span>
<span class="udiff-line-modified-added">+     bool isExtensible(JSGlobalObject*);</span>
      bool indexingShouldBeSparse(VM&amp; vm)
      {
          return !isStructureExtensible(vm)
              || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
      }
  
      bool staticPropertiesReified(VM&amp; vm) { return structure(vm)-&gt;staticPropertiesReified(); }
<span class="udiff-line-modified-removed">-     void reifyAllStaticProperties(ExecState*);</span>
<span class="udiff-line-modified-added">+     void reifyAllStaticProperties(JSGlobalObject*);</span>
  
      JS_EXPORT_PRIVATE Butterfly* allocateMoreOutOfLineStorage(VM&amp;, size_t oldSize, size_t newSize);
  
      // Call this when you do not need to change the structure.
      void setButterfly(VM&amp;, Butterfly*);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -828,11 +838,11 @@</span>
      // asObject(foo-&gt;structure()-&gt;storedPrototype())-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(...)
      //
      // is equivalent to:
      //
      // foo-&gt;attemptToInterceptPutByIndexOnHole(...);
<span class="udiff-line-modified-removed">-     bool attemptToInterceptPutByIndexOnHoleForPrototype(ExecState*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);</span>
<span class="udiff-line-modified-added">+     bool attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);</span>
  
      // Returns 0 if int32 storage cannot be created - either because
      // indexing should be sparse, we&#39;re having a bad time, or because
      // we already have a more general form of storage (double,
      // contiguous, array storage).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -893,18 +903,20 @@</span>
      void* butterflyAddress()
      {
          return &amp;m_butterfly;
      }
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE JSValue getMethod(ExecState*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE JSValue getMethod(JSGlobalObject*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);</span>
  
      bool canPerformFastPutInline(VM&amp;, PropertyName);
      bool canPerformFastPutInlineExcludingProto(VM&amp;);
  
      bool mayBePrototype() const;
      void didBecomePrototype();
  
<span class="udiff-line-added">+     Optional&lt;Structure::PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;</span>
<span class="udiff-line-added">+ </span>
      DECLARE_EXPORT_INFO;
  
  protected:
      void finishCreation(VM&amp; vm)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -927,11 +939,11 @@</span>
      // Visits the butterfly unless there is a race. Returns the structure if there was no race.
      Structure* visitButterfly(SlotVisitor&amp;);
  
      Structure* visitButterflyImpl(SlotVisitor&amp;);
  
<span class="udiff-line-modified-removed">-     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset lastOffset);</span>
<span class="udiff-line-modified-added">+     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset maxOffset);</span>
  
      // Call this if you know that the object is in a mode where it has array
      // storage. This will assert otherwise.
      ArrayStorage* arrayStorage()
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -989,24 +1001,24 @@</span>
      ArrayStorage* convertContiguousToArrayStorage(VM&amp;);
  
  
      ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp;);
  
<span class="udiff-line-modified-removed">-     bool defineOwnNonIndexProperty(ExecState*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
<span class="udiff-line-modified-added">+     bool defineOwnNonIndexProperty(JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
  
      template&lt;IndexingType indexingShape&gt;
<span class="udiff-line-modified-removed">-     bool putByIndexBeyondVectorLengthWithoutAttributes(ExecState*, unsigned propertyName, JSValue);</span>
<span class="udiff-line-modified-removed">-     bool putByIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);</span>
<span class="udiff-line-modified-added">+     bool putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject*, unsigned propertyName, JSValue);</span>
<span class="udiff-line-modified-added">+     bool putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);</span>
  
      bool increaseVectorLength(VM&amp;, unsigned newLength);
      void deallocateSparseIndexMap();
<span class="udiff-line-modified-removed">-     bool defineOwnIndexedProperty(ExecState*, unsigned, const PropertyDescriptor&amp;, bool throwException);</span>
<span class="udiff-line-modified-added">+     bool defineOwnIndexedProperty(JSGlobalObject*, unsigned, const PropertyDescriptor&amp;, bool throwException);</span>
      SparseArrayValueMap* allocateSparseIndexMap(VM&amp;);
  
      void notifyPresenceOfIndexedAccessors(VM&amp;);
  
<span class="udiff-line-modified-removed">-     bool attemptToInterceptPutByIndexOnHole(ExecState*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);</span>
<span class="udiff-line-modified-added">+     bool attemptToInterceptPutByIndexOnHole(JSGlobalObject*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);</span>
  
      // Call this if you want setIndexQuickly to succeed and you&#39;re sure that
      // the array is contiguous.
      bool WARN_UNUSED_RETURN ensureLength(VM&amp; vm, unsigned length)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1039,38 +1051,33 @@</span>
  
      // Nobody should ever ask any of these questions on something already known to be a JSObject.
      using JSCell::isAPIValueWrapper;
      using JSCell::isGetterSetter;
      void getObject();
<span class="udiff-line-modified-removed">-     void getString(ExecState* exec);</span>
<span class="udiff-line-modified-added">+     void getString(JSGlobalObject* globalObject);</span>
      void isObject();
      void isString();
  
      Butterfly* createInitialIndexedStorage(VM&amp;, unsigned length);
  
      ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp;, ArrayStorage*);
  
      template&lt;PutMode&gt;
      bool putDirectInternal(VM&amp;, PropertyName, JSValue, unsigned attr, PutPropertySlot&amp;);
  
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
  
<span class="udiff-line-modified-removed">-     bool getNonIndexPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="udiff-line-modified-added">+     bool getNonIndexPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
      bool getOwnNonIndexPropertySlot(VM&amp;, Structure*, PropertyName, PropertySlot&amp;);
      JS_EXPORT_PRIVATE void fillGetterPropertySlot(VM&amp;, PropertySlot&amp;, JSCell*, unsigned, PropertyOffset);
      void fillCustomGetterPropertySlot(VM&amp;, PropertySlot&amp;, CustomGetterSetter*, unsigned, Structure*);
  
      JS_EXPORT_PRIVATE bool getOwnStaticPropertySlot(VM&amp;, PropertyName, PropertySlot&amp;);
<span class="udiff-line-removed">-     struct PropertyHashEntry {</span>
<span class="udiff-line-removed">-         const HashTable* table;</span>
<span class="udiff-line-removed">-         const HashTableValue* value;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">-     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;</span>
  
<span class="udiff-line-modified-removed">-     bool putByIndexBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-removed">-     bool putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);</span>
<span class="udiff-line-modified-removed">-     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);</span>
<span class="udiff-line-modified-added">+     bool putByIndexBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+     bool putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);</span>
<span class="udiff-line-modified-added">+     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);</span>
  
      unsigned getNewVectorLength(VM&amp;, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
      unsigned getNewVectorLength(VM&amp;, unsigned desiredLength);
  
      ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(VM&amp;, unsigned neededLength);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1129,34 +1136,33 @@</span>
  class JSFinalObject final : public JSObject {
      friend class JSObject;
  
  public:
      typedef JSObject Base;
<span class="udiff-line-modified-removed">-     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
      {
          return (sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase&lt;Unknown&gt;)).unsafeGet();
      }
  
      static inline const TypeInfo typeInfo() { return TypeInfo(FinalObjectType, StructureFlags); }
<span class="udiff-line-modified-removed">-     static const IndexingType defaultIndexingType = NonArray;</span>
<span class="udiff-line-modified-added">+     static constexpr IndexingType defaultIndexingType = NonArray;</span>
  
<span class="udiff-line-modified-removed">-     static const unsigned defaultSize = 64;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned defaultSize = 64;</span>
      static inline unsigned defaultInlineCapacity()
      {
          return (defaultSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
      }
  
<span class="udiff-line-modified-removed">-     static const unsigned maxSize = 512;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned maxSize = 512;</span>
      static inline unsigned maxInlineCapacity()
      {
          return (maxSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
      }
  
<span class="udiff-line-modified-removed">-     static JSFinalObject* create(ExecState*, Structure*, Butterfly* = nullptr);</span>
<span class="udiff-line-removed">-     static JSFinalObject* create(VM&amp;, Structure*);</span>
<span class="udiff-line-modified-added">+     static JSFinalObject* create(VM&amp;, Structure*, Butterfly* = nullptr);</span>
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, unsigned inlineCapacity)
      {
          return Structure::create(vm, globalObject, prototype, typeInfo(), info(), defaultIndexingType, inlineCapacity);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1178,20 +1184,18 @@</span>
      friend class LLIntOffsetsExtractor;
  
      explicit JSFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = nullptr)
          : JSObject(vm, structure, butterfly)
      {
<span class="udiff-line-modified-removed">-         memset(inlineStorageUnsafe(), 0, structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));</span>
<span class="udiff-line-modified-added">+         gcSafeZeroMemory(inlineStorageUnsafe(), structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));</span>
      }
  };
  
<span class="udiff-line-modified-removed">- JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState*);</span>
<span class="udiff-line-modified-added">+ JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject*, CallFrame*);</span>
  
<span class="udiff-line-modified-removed">- inline JSObject* JSObject::createRawObject(</span>
<span class="udiff-line-removed">-     ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
<span class="udiff-line-modified-added">+ inline JSObject* JSObject::createRawObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span>
  {
<span class="udiff-line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      JSObject* finalObject = new (
          NotNull,
          allocateCell&lt;JSFinalObject&gt;(
              vm.heap,
              JSFinalObject::allocationSize(structure-&gt;inlineCapacity())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1199,14 +1203,12 @@</span>
      ) JSObject(vm, structure, butterfly);
      finalObject-&gt;finishCreation(vm);
      return finalObject;
  }
  
<span class="udiff-line-modified-removed">- inline JSFinalObject* JSFinalObject::create(</span>
<span class="udiff-line-removed">-     ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
<span class="udiff-line-modified-added">+ inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span>
  {
<span class="udiff-line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      JSFinalObject* finalObject = new (
          NotNull,
          allocateCell&lt;JSFinalObject&gt;(
              vm.heap,
              allocationSize(structure-&gt;inlineCapacity())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1214,17 +1216,10 @@</span>
      ) JSFinalObject(vm, structure, butterfly);
      finalObject-&gt;finishCreation(vm);
      return finalObject;
  }
  
<span class="udiff-line-removed">- inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     JSFinalObject* finalObject = new (NotNull, allocateCell&lt;JSFinalObject&gt;(vm.heap, allocationSize(structure-&gt;inlineCapacity()))) JSFinalObject(vm, structure);</span>
<span class="udiff-line-removed">-     finalObject-&gt;finishCreation(vm);</span>
<span class="udiff-line-removed">-     return finalObject;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline size_t JSObject::offsetOfInlineStorage()
  {
      return sizeof(JSObject);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1295,24 +1290,10 @@</span>
      }
  
      m_butterfly.set(vm, this, butterfly);
  }
  
<span class="udiff-line-removed">- inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     CallType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getCallData(value.asCell(), callData) : CallType::None;</span>
<span class="udiff-line-removed">-     ASSERT(result == CallType::None || value.isValidCallee());</span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ConstructType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getConstructData(value.asCell(), constructData) : ConstructType::None;</span>
<span class="udiff-line-removed">-     ASSERT(result == ConstructType::None || value.isValidCallee());</span>
<span class="udiff-line-removed">-     return result;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline JSObject* asObject(JSCell* cell)
  {
      ASSERT(cell-&gt;isObject());
      return jsCast&lt;JSObject*&gt;(cell);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1331,17 +1312,17 @@</span>
  inline JSValue JSObject::getPrototypeDirect(VM&amp; vm) const
  {
      return structure(vm)-&gt;storedPrototype(this);
  }
  
<span class="udiff-line-modified-removed">- inline JSValue JSObject::getPrototype(VM&amp; vm, ExecState* exec)</span>
<span class="udiff-line-modified-added">+ inline JSValue JSObject::getPrototype(VM&amp; vm, JSGlobalObject* globalObject)</span>
  {
      auto getPrototypeMethod = methodTable(vm)-&gt;getPrototype;
      MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
      if (LIKELY(getPrototypeMethod == defaultGetPrototype))
          return getPrototypeDirect(vm);
<span class="udiff-line-modified-removed">-     return getPrototypeMethod(this, exec);</span>
<span class="udiff-line-modified-added">+     return getPrototypeMethod(this, globalObject);</span>
  }
  
  // Normally, we never shrink the butterfly so if we know an offset is valid for some
  // past structure then it should be valid for any new structure. However, we may sometimes
  // shrink the butterfly when we are holding the Structure&#39;s ConcurrentJSLock, such as when we
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1409,44 +1390,44 @@</span>
  }
  
  // It may seem crazy to inline a function this large, especially a virtual function,
  // but it makes a big difference to property lookup that derived classes can inline their
  // base class call to this.
<span class="udiff-line-modified-removed">- ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = getVM(globalObject);</span>
      Structure* structure = object-&gt;structure(vm);
      if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
          return true;
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-         return getOwnPropertySlotByIndex(object, exec, index.value(), slot);</span>
<span class="udiff-line-modified-added">+         return getOwnPropertySlotByIndex(object, globalObject, index.value(), slot);</span>
      return false;
  }
  
<span class="udiff-line-modified-removed">- ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;)</span>
  {
  }
  
  // It may seem crazy to inline a function this large but it makes a big difference
  // since this is function very hot in variable lookup
  template&lt;bool checkNullStructure&gt;
<span class="udiff-line-modified-removed">- ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
<span class="udiff-line-modified-added">+ ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = getVM(globalObject);</span>
      auto&amp; structureIDTable = vm.heap.structureIDTable();
      JSObject* object = this;
      while (true) {
          if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
              // If propertyName is an index then we may have missed it (as this loop is using
              // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
              // (lest we return a property from a prototype that is shadowed). Check now for an index,
              // if so we need to start afresh from this object.
              if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-                 return getPropertySlot(exec, index.value(), slot);</span>
<span class="udiff-line-modified-added">+                 return getPropertySlot(globalObject, index.value(), slot);</span>
              // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
              // parsing the int again.
<span class="udiff-line-modified-removed">-             return object-&gt;getNonIndexPropertySlot(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+             return object-&gt;getNonIndexPropertySlot(globalObject, propertyName, slot);</span>
          }
          ASSERT(object-&gt;type() != ProxyObjectType);
          Structure* structure = structureIDTable.get(object-&gt;structureID());
  #if USE(JSVALUE64)
          if (checkNullStructure &amp;&amp; UNLIKELY(!structure))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1461,64 +1442,40 @@</span>
              break;
          object = asObject(prototype);
      }
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="udiff-line-modified-removed">-         return getPropertySlot(exec, index.value(), slot);</span>
<span class="udiff-line-modified-added">+         return getPropertySlot(globalObject, index.value(), slot);</span>
      return false;
  }
  
<span class="udiff-line-modified-removed">- inline JSValue JSObject::get(ExecState* exec, PropertyName propertyName) const</span>
<span class="udiff-line-modified-added">+ inline JSValue JSObject::get(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="udiff-line-modified-removed">-     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty)
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
  
      return jsUndefined();
  }
  
<span class="udiff-line-modified-removed">- inline JSValue JSObject::get(ExecState* exec, unsigned propertyName) const</span>
<span class="udiff-line-modified-added">+ inline JSValue JSObject::get(JSGlobalObject* globalObject, unsigned propertyName) const</span>
  {
<span class="udiff-line-modified-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     VM&amp; vm = getVM(globalObject);</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="udiff-line-modified-removed">-     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
<span class="udiff-line-modified-added">+     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
      EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
      if (hasProperty)
<span class="udiff-line-modified-removed">-         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
<span class="udiff-line-modified-added">+         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
  
      return jsUndefined();
  }
  
<span class="udiff-line-removed">- inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(value);</span>
<span class="udiff-line-removed">-     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="udiff-line-removed">-     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());</span>
<span class="udiff-line-removed">-     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- inline bool JSObject::putOwnDataPropertyMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-removed">-     ASSERT(value);</span>
<span class="udiff-line-removed">-     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="udiff-line-removed">-     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());</span>
<span class="udiff-line-removed">-     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))</span>
<span class="udiff-line-removed">-         return putDirectIndex(exec, index.value(), value, 0, PutDirectIndexLikePutDirect);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
  {
      ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
      ASSERT(!value.isCustomGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
      PutPropertySlot slot(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1530,21 +1487,10 @@</span>
      ASSERT(!value.isGetterSetter());
      ASSERT(!value.isCustomGetterSetter());
      return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, 0, slot);
  }
  
<span class="udiff-line-removed">- ALWAYS_INLINE JSObject* Register::object() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return asObject(jsValue());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- ALWAYS_INLINE Register&amp; Register::operator=(JSObject* object)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     u.value = JSValue::encode(JSValue(object));</span>
<span class="udiff-line-removed">-     return *this;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  inline size_t offsetInButterfly(PropertyOffset offset)
  {
      return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1618,18 +1564,18 @@</span>
  ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
  {
      return name;
  }
  
<span class="udiff-line-modified-removed">- bool validateAndApplyPropertyDescriptor(ExecState*, JSObject*, PropertyName, bool isExtensible,</span>
<span class="udiff-line-modified-added">+ bool validateAndApplyPropertyDescriptor(JSGlobalObject*, JSObject*, PropertyName, bool isExtensible,</span>
      const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
  
<span class="udiff-line-modified-removed">- JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(ExecState*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);</span>
<span class="udiff-line-modified-added">+ JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(JSGlobalObject*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);</span>
  
  // Helper for defining native functions, if you&#39;re not using a static hash table.
  // Use this macro from within finishCreation() methods in prototypes. This assumes
<span class="udiff-line-modified-removed">- // you&#39;ve defined variables called exec, globalObject, and vm, and they</span>
<span class="udiff-line-modified-added">+ // you&#39;ve defined variables called globalObject, globalObject, and vm, and they</span>
  // have the expected meanings.
  #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
      putDirectNativeFunction(\
          vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
          (intrinsic), (attributes))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1672,6 +1618,11 @@</span>
      JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
  
  #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \
      JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)
  
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #define STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(DerivedClass, BaseClass) \</span>
<span class="udiff-line-added">+     static_assert(sizeof(DerivedClass) == sizeof(BaseClass)); \</span>
<span class="udiff-line-added">+     static_assert(DerivedClass::destroy == BaseClass::destroy);</span>
<span class="udiff-line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="JSObject.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
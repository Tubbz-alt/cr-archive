<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
<a name="1" id="anc1"></a><span class="line-modified"> 25 #if ENABLE(AUTOCAPITALIZE)</span>
 26 #include &quot;Autocapitalize.h&quot;
 27 #endif
 28 
 29 #include &quot;InputMode.h&quot;
 30 #include &quot;StyledElement.h&quot;
 31 
 32 namespace WebCore {
 33 
 34 class DocumentFragment;
 35 class FormAssociatedElement;
 36 class FormNamedItem;
 37 class HTMLCollection;
 38 class HTMLFormElement;
 39 
<a name="2" id="anc2"></a><span class="line-added"> 40 enum class EnterKeyHint : uint8_t;</span>
<span class="line-added"> 41 </span>
 42 class HTMLElement : public StyledElement {
 43     WTF_MAKE_ISO_ALLOCATED(HTMLElement);
 44 public:
 45     static Ref&lt;HTMLElement&gt; create(const QualifiedName&amp; tagName, Document&amp;);
 46 
 47     WEBCORE_EXPORT String title() const final;
 48 
 49     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerText(const String&amp;);
 50     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterText(const String&amp;);
 51 
 52     virtual bool hasCustomFocusLogic() const;
 53     bool supportsFocus() const override;
 54 
 55     WEBCORE_EXPORT String contentEditable() const;
 56     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setContentEditable(const String&amp;);
 57 
 58     static Editability editabilityFromContentEditableAttr(const Node&amp;);
 59 
 60     virtual bool draggable() const;
 61     WEBCORE_EXPORT void setDraggable(bool);
 62 
 63     WEBCORE_EXPORT bool spellcheck() const;
 64     WEBCORE_EXPORT void setSpellcheck(bool);
 65 
 66     WEBCORE_EXPORT bool translate() const;
 67     WEBCORE_EXPORT void setTranslate(bool);
 68 
 69     WEBCORE_EXPORT void click();
 70 
 71     void accessKeyAction(bool sendMouseEvents) override;
 72 
<a name="3" id="anc3"></a>
 73     RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
<a name="4" id="anc4"></a><span class="line-added"> 74     bool rendererIsEverNeeded() final;</span>
 75 
 76     WEBCORE_EXPORT virtual HTMLFormElement* form() const;
 77 
 78     WEBCORE_EXPORT const AtomString&amp; dir() const;
 79     WEBCORE_EXPORT void setDir(const AtomString&amp;);
 80 
 81     bool hasDirectionAuto() const;
 82     TextDirection directionalityIfhasDirAutoAttribute(bool&amp; isAuto) const;
 83 
 84     virtual bool isHTMLUnknownElement() const { return false; }
 85     virtual bool isTextControlInnerTextElement() const { return false; }
 86 
 87     bool willRespondToMouseMoveEvents() override;
 88     bool willRespondToMouseWheelEvents() override;
 89     bool willRespondToMouseClickEvents() override;
 90 
 91     virtual bool isLabelable() const { return false; }
 92     virtual FormNamedItem* asFormNamedItem();
 93     virtual FormAssociatedElement* asFormAssociatedElement();
 94 
 95     virtual bool isInteractiveContent() const { return false; }
 96 
 97     bool hasTagName(const HTMLQualifiedName&amp; name) const { return hasLocalName(name.localName()); }
 98 
 99     static const AtomString&amp; eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName);
100 
101     // Only some element types can be disabled: https://html.spec.whatwg.org/multipage/scripting.html#concept-element-disabled
102     bool canBeActuallyDisabled() const;
103     bool isActuallyDisabled() const;
104 
<a name="5" id="anc5"></a><span class="line-modified">105 #if ENABLE(AUTOCAPITALIZE)</span>
106     WEBCORE_EXPORT virtual AutocapitalizeType autocapitalizeType() const;
107     WEBCORE_EXPORT const AtomString&amp; autocapitalize() const;
108     WEBCORE_EXPORT void setAutocapitalize(const AtomString&amp; value);
<a name="6" id="anc6"></a><span class="line-added">109 #endif</span>
110 
<a name="7" id="anc7"></a><span class="line-added">111 #if ENABLE(AUTOCORRECT)</span>
112     bool autocorrect() const { return shouldAutocorrect(); }
113     WEBCORE_EXPORT virtual bool shouldAutocorrect() const;
114     WEBCORE_EXPORT void setAutocorrect(bool);
115 #endif
116 
117     WEBCORE_EXPORT InputMode canonicalInputMode() const;
118     const AtomString&amp; inputMode() const;
119     void setInputMode(const AtomString&amp; value);
120 
<a name="8" id="anc8"></a><span class="line-added">121     WEBCORE_EXPORT EnterKeyHint canonicalEnterKeyHint() const;</span>
<span class="line-added">122     String enterKeyHint() const;</span>
<span class="line-added">123     void setEnterKeyHint(const String&amp; value);</span>
<span class="line-added">124 </span>
125 protected:
126     HTMLElement(const QualifiedName&amp; tagName, Document&amp;, ConstructionType);
127 
128     void addHTMLLengthToStyle(MutableStyleProperties&amp;, CSSPropertyID, const String&amp; value);
129     void addHTMLColorToStyle(MutableStyleProperties&amp;, CSSPropertyID, const String&amp; color);
130 
131     void applyAlignmentAttributeToStyle(const AtomString&amp;, MutableStyleProperties&amp;);
132     void applyBorderAttributeToStyle(const AtomString&amp;, MutableStyleProperties&amp;);
133 
134     bool matchesReadWritePseudoClass() const override;
135     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
136     bool isPresentationAttribute(const QualifiedName&amp;) const override;
137     void collectStyleForPresentationAttribute(const QualifiedName&amp;, const AtomString&amp;, MutableStyleProperties&amp;) override;
138     unsigned parseBorderWidthAttribute(const AtomString&amp;) const;
139 
140     void childrenChanged(const ChildChange&amp;) override;
141     void calculateAndAdjustDirectionality();
142 
143     typedef HashMap&lt;AtomStringImpl*, AtomString&gt; EventHandlerNameMap;
144     template&lt;size_t tableSize&gt; static void populateEventHandlerNameMap(EventHandlerNameMap&amp;, const QualifiedName* const (&amp;table)[tableSize]);
145     static const AtomString&amp; eventNameForEventHandlerAttribute(const QualifiedName&amp; attributeName, const EventHandlerNameMap&amp;);
146 
147 private:
148     String nodeName() const final;
149 
150     void mapLanguageAttributeToLocale(const AtomString&amp;, MutableStyleProperties&amp;);
151 
152     void dirAttributeChanged(const AtomString&amp;);
153     void adjustDirectionalityIfNeededAfterChildAttributeChanged(Element* child);
154     void adjustDirectionalityIfNeededAfterChildrenChanged(Element* beforeChange, ChildChangeType);
155     TextDirection directionality(Node** strongDirectionalityTextNode= 0) const;
156 
157     static void populateEventHandlerNameMap(EventHandlerNameMap&amp;, const QualifiedName* const table[], size_t tableSize);
158     static EventHandlerNameMap createEventHandlerNameMap();
159 };
160 
161 inline HTMLElement::HTMLElement(const QualifiedName&amp; tagName, Document&amp; document, ConstructionType type = CreateHTMLElement)
162     : StyledElement(tagName, document, type)
163 {
164     ASSERT(tagName.localName().impl());
165 }
166 
167 template&lt;size_t tableSize&gt; inline void HTMLElement::populateEventHandlerNameMap(EventHandlerNameMap&amp; map, const QualifiedName* const (&amp;table)[tableSize])
168 {
169     populateEventHandlerNameMap(map, table, tableSize);
170 }
171 
172 inline bool Node::hasTagName(const HTMLQualifiedName&amp; name) const
173 {
174     return is&lt;HTMLElement&gt;(*this) &amp;&amp; downcast&lt;HTMLElement&gt;(*this).hasTagName(name);
175 }
176 
177 } // namespace WebCore
178 
179 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLElement)
180     static bool isType(const WebCore::Node&amp; node) { return node.isHTMLElement(); }
181     static bool isType(const WebCore::EventTarget&amp; target) { return is&lt;WebCore::Node&gt;(target) &amp;&amp; isType(downcast&lt;WebCore::Node&gt;(target)); }
182 SPECIALIZE_TYPE_TRAITS_END()
183 
184 #include &quot;HTMLElementTypeHelpers.h&quot;
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
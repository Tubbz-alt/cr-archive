<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallFrameShuffleData.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 59,15 ***</span>
      // on 32-bit architectures yet.
      m_lockedRegisters.exclude(RegisterSet::vmCalleeSaveRegisters());
  #endif
  
      ASSERT(!data.callee.isInJSStack() || data.callee.virtualRegister().isLocal());
<span class="line-modified">!     addNew(VirtualRegister(CallFrameSlot::callee), data.callee);</span>
  
      for (size_t i = 0; i &lt; data.args.size(); ++i) {
          ASSERT(!data.args[i].isInJSStack() || data.args[i].virtualRegister().isLocal());
<span class="line-modified">!         addNew(virtualRegisterForArgument(i), data.args[i]);</span>
      }
  
  #if USE(JSVALUE64)
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!data.registers[reg].isSet())
<span class="line-new-header">--- 59,15 ---</span>
      // on 32-bit architectures yet.
      m_lockedRegisters.exclude(RegisterSet::vmCalleeSaveRegisters());
  #endif
  
      ASSERT(!data.callee.isInJSStack() || data.callee.virtualRegister().isLocal());
<span class="line-modified">!     addNew(CallFrameSlot::callee, data.callee);</span>
  
      for (size_t i = 0; i &lt; data.args.size(); ++i) {
          ASSERT(!data.args[i].isInJSStack() || data.args[i].virtualRegister().isLocal());
<span class="line-modified">!         addNew(virtualRegisterForArgumentIncludingThis(i), data.args[i]);</span>
      }
  
  #if USE(JSVALUE64)
      for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
          if (!data.registers[reg].isSet())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,13 ***</span>
              addNew(JSValueRegs(reg.gpr()), data.registers[reg]);
          else
              addNew(reg.fpr(), data.registers[reg]);
      }
  
<span class="line-modified">!     m_tagTypeNumber = data.tagTypeNumber;</span>
<span class="line-modified">!     if (m_tagTypeNumber != InvalidGPRReg)</span>
<span class="line-modified">!         lockGPR(m_tagTypeNumber);</span>
  #endif
  }
  
  void CallFrameShuffler::dump(PrintStream&amp; out) const
  {
<span class="line-new-header">--- 77,13 ---</span>
              addNew(JSValueRegs(reg.gpr()), data.registers[reg]);
          else
              addNew(reg.fpr(), data.registers[reg]);
      }
  
<span class="line-modified">!     m_numberTagRegister = data.numberTagRegister;</span>
<span class="line-modified">!     if (m_numberTagRegister != InvalidGPRReg)</span>
<span class="line-modified">!         lockGPR(m_numberTagRegister);</span>
  #endif
  }
  
  void CallFrameShuffler::dump(PrintStream&amp; out) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,11 ***</span>
                  else {
                      auto recoveryStr = toCString(getNew(newReg)-&gt;recovery());
                      out.printf(&quot; %c%8s &lt;- %18s %c &quot;, d, str.data(),
                          recoveryStr.data(), d);
                  }
<span class="line-modified">!             } else if (newReg == VirtualRegister { CallFrameSlot::argumentCount })</span>
                  out.printf(&quot; %c%8s &lt;- %18zu %c &quot;, d, str.data(), argCount(), d);
              else
                  out.printf(&quot; %c%30s %c &quot;, d, &quot;&quot;, d);
          } else
              out.print(emptySpace);
<span class="line-new-header">--- 150,11 ---</span>
                  else {
                      auto recoveryStr = toCString(getNew(newReg)-&gt;recovery());
                      out.printf(&quot; %c%8s &lt;- %18s %c &quot;, d, str.data(),
                          recoveryStr.data(), d);
                  }
<span class="line-modified">!             } else if (newReg == VirtualRegister { CallFrameSlot::argumentCountIncludingThis })</span>
                  out.printf(&quot; %c%8s &lt;- %18zu %c &quot;, d, str.data(), argCount(), d);
              else
                  out.printf(&quot; %c%30s %c &quot;, d, &quot;&quot;, d);
          } else
              out.print(emptySpace);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,12 ***</span>
      if (m_oldFrameOffset)
          out.print(&quot;   Old frame offset is &quot;, m_oldFrameOffset, &quot;\n&quot;);
      if (m_newFrameOffset)
          out.print(&quot;   New frame offset is &quot;, m_newFrameOffset, &quot;\n&quot;);
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_tagTypeNumber != InvalidGPRReg)</span>
<span class="line-modified">!         out.print(&quot;   TagTypeNumber is currently in &quot;, m_tagTypeNumber, &quot;\n&quot;);</span>
  #endif
  }
  
  CachedRecovery* CallFrameShuffler::getCachedRecovery(ValueRecovery recovery)
  {
<span class="line-new-header">--- 214,12 ---</span>
      if (m_oldFrameOffset)
          out.print(&quot;   Old frame offset is &quot;, m_oldFrameOffset, &quot;\n&quot;);
      if (m_newFrameOffset)
          out.print(&quot;   New frame offset is &quot;, m_newFrameOffset, &quot;\n&quot;);
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_numberTagRegister != InvalidGPRReg)</span>
<span class="line-modified">!         out.print(&quot;   NumberTag is currently in &quot;, m_numberTagRegister, &quot;\n&quot;);</span>
  #endif
  }
  
  CachedRecovery* CallFrameShuffler::getCachedRecovery(ValueRecovery recovery)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,11 ***</span>
      updateRecovery(cachedRecovery, ValueRecovery::displacedInJSStack(spillSlot, format));
  }
  
  void CallFrameShuffler::emitDeltaCheck()
  {
<span class="line-modified">!     if (ASSERT_DISABLED)</span>
          return;
  
      GPRReg scratchGPR { getFreeGPR() };
      if (scratchGPR != InvalidGPRReg) {
          if (verbose)
<span class="line-new-header">--- 290,11 ---</span>
      updateRecovery(cachedRecovery, ValueRecovery::displacedInJSStack(spillSlot, format));
  }
  
  void CallFrameShuffler::emitDeltaCheck()
  {
<span class="line-modified">!     if (!ASSERT_ENABLED)</span>
          return;
  
      GPRReg scratchGPR { getFreeGPR() };
      if (scratchGPR != InvalidGPRReg) {
          if (verbose)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,23 ***</span>
      // We&#39;ll use sp-based indexing so that we can load the
      // caller&#39;s frame pointer into the fpr immediately
      m_oldFrameBase = MacroAssembler::stackPointerRegister;
      m_oldFrameOffset = numLocals();
      m_newFrameBase = acquireGPR();
<span class="line-modified">! #if CPU(X86)</span>
<span class="line-removed">-     // We load the frame pointer manually, but we need to ask the</span>
<span class="line-removed">-     // algorithm to move the return PC for us (it&#39;d probably</span>
<span class="line-removed">-     // require a write to the danger zone). Since it&#39;d be awkward</span>
<span class="line-removed">-     // to ask for half a value move, we ask that the whole thing</span>
<span class="line-removed">-     // be moved for us.</span>
<span class="line-removed">-     addNew(VirtualRegister { 0 },</span>
<span class="line-removed">-         ValueRecovery::displacedInJSStack(VirtualRegister(0), DataFormatJS));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // sp will point to head0 and we will move it up half a slot</span>
<span class="line-removed">-     // manually</span>
<span class="line-removed">-     m_newFrameOffset = 0;</span>
<span class="line-removed">- #elif CPU(ARM_THUMB2) || CPU(MIPS)</span>
      // We load the frame pointer and link register
      // manually. We could ask the algorithm to load them for us,
      // and it would allow us to use the link register as an extra
      // temporary - but it&#39;d mean that the frame pointer can also
      // be used as an extra temporary, so we keep the link register
<span class="line-new-header">--- 375,11 ---</span>
      // We&#39;ll use sp-based indexing so that we can load the
      // caller&#39;s frame pointer into the fpr immediately
      m_oldFrameBase = MacroAssembler::stackPointerRegister;
      m_oldFrameOffset = numLocals();
      m_newFrameBase = acquireGPR();
<span class="line-modified">! #if CPU(ARM_THUMB2) || CPU(MIPS)</span>
      // We load the frame pointer and link register
      // manually. We could ask the algorithm to load them for us,
      // and it would allow us to use the link register as an extra
      // temporary - but it&#39;d mean that the frame pointer can also
      // be used as an extra temporary, so we keep the link register
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,11 ***</span>
  
      // We compute the new frame base by first computing the top of the
      // old frame (taking into account an argument count higher than
      // the number of parameters), then substracting to it the aligned
      // new frame size (adjusted).
<span class="line-modified">!     m_jit.load32(MacroAssembler::Address(GPRInfo::callFrameRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), m_newFrameBase);</span>
      MacroAssembler::Jump argumentCountOK =
          m_jit.branch32(MacroAssembler::BelowOrEqual, m_newFrameBase,
              MacroAssembler::TrustedImm32(m_jit.codeBlock()-&gt;numParameters()));
      m_jit.add32(MacroAssembler::TrustedImm32(stackAlignmentRegisters() - 1 + CallFrame::headerSizeInRegisters), m_newFrameBase);
      m_jit.and32(MacroAssembler::TrustedImm32(-stackAlignmentRegisters()), m_newFrameBase);
<span class="line-new-header">--- 416,11 ---</span>
  
      // We compute the new frame base by first computing the top of the
      // old frame (taking into account an argument count higher than
      // the number of parameters), then substracting to it the aligned
      // new frame size (adjusted).
<span class="line-modified">!     m_jit.load32(MacroAssembler::Address(GPRInfo::callFrameRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), m_newFrameBase);</span>
      MacroAssembler::Jump argumentCountOK =
          m_jit.branch32(MacroAssembler::BelowOrEqual, m_newFrameBase,
              MacroAssembler::TrustedImm32(m_jit.codeBlock()-&gt;numParameters()));
      m_jit.add32(MacroAssembler::TrustedImm32(stackAlignmentRegisters() - 1 + CallFrame::headerSizeInRegisters), m_newFrameBase);
      m_jit.and32(MacroAssembler::TrustedImm32(-stackAlignmentRegisters()), m_newFrameBase);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 474,16 ***</span>
      if (verbose)
          dataLog(&quot;Preparing frame for tail call:\n&quot;, *this);
  
      prepareAny();
  
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-     if (verbose)</span>
<span class="line-removed">-         dataLog(&quot;  Simulating pop of the call frame register\n&quot;);</span>
<span class="line-removed">-     m_jit.addPtr(MacroAssembler::TrustedImm32(sizeof(void*)), MacroAssembler::stackPointerRegister);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      if (verbose)
          dataLog(&quot;Ready for tail call!\n&quot;);
  }
  
  bool CallFrameShuffler::tryWrites(CachedRecovery&amp; cachedRecovery)
<span class="line-new-header">--- 462,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,12 ***</span>
          bool writesOK = tryWrites(*cachedRecovery);
          ASSERT_UNUSED(writesOK, writesOK);
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_tagTypeNumber != InvalidGPRReg &amp;&amp; m_newRegisters[m_tagTypeNumber])</span>
<span class="line-modified">!         releaseGPR(m_tagTypeNumber);</span>
  #endif
  
      // Handle 2) by loading all registers. We don&#39;t have to do any
      // writes, since they have been taken care of above.
      if (verbose)
<span class="line-new-header">--- 696,12 ---</span>
          bool writesOK = tryWrites(*cachedRecovery);
          ASSERT_UNUSED(writesOK, writesOK);
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_numberTagRegister != InvalidGPRReg &amp;&amp; m_newRegisters[m_numberTagRegister])</span>
<span class="line-modified">!         releaseGPR(m_numberTagRegister);</span>
  #endif
  
      // Handle 2) by loading all registers. We don&#39;t have to do any
      // writes, since they have been taken care of above.
      if (verbose)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 733,19 ***</span>
          emitBox(*cachedRecovery);
          ASSERT(cachedRecovery-&gt;targets().isEmpty());
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_tagTypeNumber != InvalidGPRReg)</span>
<span class="line-modified">!         releaseGPR(m_tagTypeNumber);</span>
  #endif
  
      // At this point, we have read everything we cared about from the
      // stack, and written everything we had to to the stack.
      if (verbose)
          dataLog(&quot;  Callee frame is fully set up\n&quot;);
<span class="line-modified">!     if (!ASSERT_DISABLED) {</span>
          for (VirtualRegister reg = firstNew(); reg &lt;= lastNew(); reg += 1)
              ASSERT_UNUSED(reg, !getNew(reg));
  
          for (CachedRecovery* cachedRecovery : m_cachedRecoveries) {
              ASSERT_UNUSED(cachedRecovery, cachedRecovery-&gt;targets().isEmpty());
<span class="line-new-header">--- 715,19 ---</span>
          emitBox(*cachedRecovery);
          ASSERT(cachedRecovery-&gt;targets().isEmpty());
      }
  
  #if USE(JSVALUE64)
<span class="line-modified">!     if (m_numberTagRegister != InvalidGPRReg)</span>
<span class="line-modified">!         releaseGPR(m_numberTagRegister);</span>
  #endif
  
      // At this point, we have read everything we cared about from the
      // stack, and written everything we had to to the stack.
      if (verbose)
          dataLog(&quot;  Callee frame is fully set up\n&quot;);
<span class="line-modified">!     if (ASSERT_ENABLED) {</span>
          for (VirtualRegister reg = firstNew(); reg &lt;= lastNew(); reg += 1)
              ASSERT_UNUSED(reg, !getNew(reg));
  
          for (CachedRecovery* cachedRecovery : m_cachedRecoveries) {
              ASSERT_UNUSED(cachedRecovery, cachedRecovery-&gt;targets().isEmpty());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,16 ***</span>
      }
  
      // We need to handle 4) first because it implies releasing
      // m_newFrameBase, which could be a wanted register.
      if (verbose)
<span class="line-modified">!         dataLog(&quot;   * Storing the argument count into &quot;, VirtualRegister { CallFrameSlot::argumentCount }, &quot;\n&quot;);</span>
      m_jit.store32(MacroAssembler::TrustedImm32(0),
<span class="line-modified">!         addressForNew(VirtualRegister { CallFrameSlot::argumentCount }).withOffset(TagOffset));</span>
      RELEASE_ASSERT(m_numPassedArgs != UINT_MAX);
      m_jit.store32(MacroAssembler::TrustedImm32(m_numPassedArgs),
<span class="line-modified">!         addressForNew(VirtualRegister { CallFrameSlot::argumentCount }).withOffset(PayloadOffset));</span>
  
      if (!isSlowPath()) {
          ASSERT(m_newFrameBase != MacroAssembler::stackPointerRegister);
          if (verbose)
              dataLog(&quot;  Releasing the new frame base pointer\n&quot;);
<span class="line-new-header">--- 736,16 ---</span>
      }
  
      // We need to handle 4) first because it implies releasing
      // m_newFrameBase, which could be a wanted register.
      if (verbose)
<span class="line-modified">!         dataLog(&quot;   * Storing the argument count into &quot;, VirtualRegister { CallFrameSlot::argumentCountIncludingThis }, &quot;\n&quot;);</span>
      m_jit.store32(MacroAssembler::TrustedImm32(0),
<span class="line-modified">!         addressForNew(VirtualRegister { CallFrameSlot::argumentCountIncludingThis }).withOffset(TagOffset));</span>
      RELEASE_ASSERT(m_numPassedArgs != UINT_MAX);
      m_jit.store32(MacroAssembler::TrustedImm32(m_numPassedArgs),
<span class="line-modified">!         addressForNew(VirtualRegister { CallFrameSlot::argumentCountIncludingThis }).withOffset(PayloadOffset));</span>
  
      if (!isSlowPath()) {
          ASSERT(m_newFrameBase != MacroAssembler::stackPointerRegister);
          if (verbose)
              dataLog(&quot;  Releasing the new frame base pointer\n&quot;);
</pre>
<center><a href="CallFrameShuffleData.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallFrameShuffler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
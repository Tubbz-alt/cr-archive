<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentThreadableLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentThreadableLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;DocumentThreadableLoader.h&quot;
 33 
 34 #include &quot;CachedRawResource.h&quot;
 35 #include &quot;CachedResourceLoader.h&quot;
 36 #include &quot;CachedResourceRequest.h&quot;
 37 #include &quot;CachedResourceRequestInitiators.h&quot;
 38 #include &quot;CrossOriginAccessControl.h&quot;
 39 #include &quot;CrossOriginPreflightChecker.h&quot;
 40 #include &quot;CrossOriginPreflightResultCache.h&quot;
 41 #include &quot;DOMWindow.h&quot;
 42 #include &quot;Document.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;

 46 #include &quot;LoadTiming.h&quot;
 47 #include &quot;LoaderStrategy.h&quot;
 48 #include &quot;Performance.h&quot;
 49 #include &quot;PlatformStrategies.h&quot;
 50 #include &quot;ProgressTracker.h&quot;
 51 #include &quot;ResourceError.h&quot;
 52 #include &quot;ResourceRequest.h&quot;
 53 #include &quot;ResourceTiming.h&quot;
 54 #include &quot;RuntimeApplicationChecks.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
<span class="line-removed"> 56 #include &quot;SchemeRegistry.h&quot;</span>
 57 #include &quot;SecurityOrigin.h&quot;

 58 #include &quot;SharedBuffer.h&quot;
 59 #include &quot;SubresourceIntegrity.h&quot;
 60 #include &quot;SubresourceLoader.h&quot;
 61 #include &quot;ThreadableLoaderClient.h&quot;
 62 #include &lt;wtf/Assertions.h&gt;
 63 #include &lt;wtf/Ref.h&gt;
 64 
 65 #if PLATFORM(IOS_FAMILY)
 66 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 67 #endif
 68 
 69 namespace WebCore {
 70 
 71 void DocumentThreadableLoader::loadResourceSynchronously(Document&amp; document, ResourceRequest&amp;&amp; request, ThreadableLoaderClient&amp; client, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy)
 72 {
 73     // The loader will be deleted as soon as this function exits.
 74     Ref&lt;DocumentThreadableLoader&gt; loader = adoptRef(*new DocumentThreadableLoader(document, client, LoadSynchronously, WTFMove(request), options, WTFMove(origin), WTFMove(contentSecurityPolicy), String(), ShouldLogError::Yes));
 75     ASSERT(loader-&gt;hasOneRef());
 76 }
 77 
</pre>
<hr />
<pre>
114 }
115 
116 DocumentThreadableLoader::DocumentThreadableLoader(Document&amp; document, ThreadableLoaderClient&amp; client, BlockingBehavior blockingBehavior, ResourceRequest&amp;&amp; request, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy, String&amp;&amp; referrer, ShouldLogError shouldLogError)
117     : m_client(&amp;client)
118     , m_document(document)
119     , m_options(options)
120     , m_origin(WTFMove(origin))
121     , m_referrer(WTFMove(referrer))
122     , m_sameOriginRequest(securityOrigin().canRequest(request.url()))
123     , m_simpleRequest(true)
124     , m_async(blockingBehavior == LoadAsynchronously)
125     , m_delayCallbacksForIntegrityCheck(!m_options.integrity.isEmpty())
126     , m_contentSecurityPolicy(WTFMove(contentSecurityPolicy))
127     , m_shouldLogError(shouldLogError)
128 {
129     relaxAdoptionRequirement();
130 
131     // Setting a referrer header is only supported in the async code path.
132     ASSERT(m_async || m_referrer.isEmpty());
133 






134     // Referrer and Origin headers should be set after the preflight if any.
135     ASSERT(!request.hasHTTPReferrer() &amp;&amp; !request.hasHTTPOrigin());
136 
137     ASSERT_WITH_SECURITY_IMPLICATION(isAllowedByContentSecurityPolicy(request.url(), ContentSecurityPolicy::RedirectResponseReceived::No));
138 
139     m_options.storedCredentialsPolicy = (m_options.credentials == FetchOptions::Credentials::Include || (m_options.credentials == FetchOptions::Credentials::SameOrigin &amp;&amp; m_sameOriginRequest)) ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse;
140 
141     ASSERT(!request.httpHeaderFields().contains(HTTPHeaderName::Origin));
142 
143     // Copy headers if we need to replay the request after a redirection.
144     if (m_options.mode == FetchOptions::Mode::Cors)
145         m_originalHeaders = request.httpHeaderFields();
146 
147     if (shouldSetHTTPHeadersToKeep())
148         m_options.httpHeadersToKeep = httpHeadersToKeepFromCleaning(request.httpHeaderFields());
149 
<span class="line-modified">150     if (document.isRunningUserScripts() &amp;&amp; SchemeRegistry::isUserExtensionScheme(request.url().protocol().toStringWithoutCopying())) {</span>




151         m_options.mode = FetchOptions::Mode::NoCors;
152         m_options.filteringPolicy = ResponseFilteringPolicy::Disable;
153     }
154 
155     m_options.cspResponseHeaders = m_options.contentSecurityPolicyEnforcement != ContentSecurityPolicyEnforcement::DoNotEnforce ? this-&gt;contentSecurityPolicy().responseHeaders() : ContentSecurityPolicyResponseHeaders { };
156 
157     // As per step 11 of https://fetch.spec.whatwg.org/#main-fetch, data scheme (if same-origin data-URL flag is set) and about scheme are considered same-origin.
158     if (request.url().protocolIsData())
159         m_sameOriginRequest = options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
160 
161     if (m_sameOriginRequest || m_options.mode == FetchOptions::Mode::NoCors || m_options.mode == FetchOptions::Mode::Navigate) {
162         loadRequest(WTFMove(request), SecurityCheckPolicy::DoSecurityCheck);
163         return;
164     }
165 
166     if (m_options.mode == FetchOptions::Mode::SameOrigin) {
167         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Cross origin requests are not allowed when using same-origin fetch mode.&quot;));
168         return;
169     }
170 
171     makeCrossOriginAccessRequest(WTFMove(request));
172 }
173 
174 bool DocumentThreadableLoader::checkURLSchemeAsCORSEnabled(const URL&amp; url)
175 {
176     // Cross-origin requests are only allowed for HTTP and registered schemes. We would catch this when checking response headers later, but there is no reason to send a request that&#39;s guaranteed to be denied.
<span class="line-modified">177     if (!SchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(url.protocol().toStringWithoutCopying())) {</span>
178         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross origin requests are only supported for HTTP.&quot;, ResourceError::Type::AccessControl));
179         return false;
180     }
181     return true;
182 }
183 
184 void DocumentThreadableLoader::makeCrossOriginAccessRequest(ResourceRequest&amp;&amp; request)
185 {
186     ASSERT(m_options.mode == FetchOptions::Mode::Cors);
187 
188 #if PLATFORM(IOS_FAMILY)
189     bool needsPreflightQuirk = IOSApplication::isMoviStarPlus() &amp;&amp; applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0 &amp;&amp; (m_options.preflightPolicy == PreflightPolicy::Consider || m_options.preflightPolicy == PreflightPolicy::Force);
190 #else
191     bool needsPreflightQuirk = false;
192 #endif
193 
194     if ((m_options.preflightPolicy == PreflightPolicy::Consider &amp;&amp; isSimpleCrossOriginAccessRequest(request.httpMethod(), request.httpHeaderFields())) || m_options.preflightPolicy == PreflightPolicy::Prevent || (shouldPerformSecurityChecks() &amp;&amp; !needsPreflightQuirk)) {
195         if (checkURLSchemeAsCORSEnabled(request.url()))
196             makeSimpleCrossOriginAccessRequest(WTFMove(request));
197     } else {
</pre>
<hr />
<pre>
425     m_client-&gt;didFinishTiming(resourceTiming);
426 }
427 
428 void DocumentThreadableLoader::notifyFinished(CachedResource&amp; resource)
429 {
430     ASSERT(m_client);
431     ASSERT_UNUSED(resource, &amp;resource == m_resource);
432 
433     if (m_resource-&gt;errorOccurred())
434         didFail(m_resource-&gt;identifier(), m_resource-&gt;resourceError());
435     else
436         didFinishLoading(m_resource-&gt;identifier());
437 }
438 
439 void DocumentThreadableLoader::didFinishLoading(unsigned long identifier)
440 {
441     ASSERT(m_client);
442 
443     if (m_delayCallbacksForIntegrityCheck) {
444         if (!matchIntegrityMetadata(*m_resource, m_options.integrity)) {
<span class="line-modified">445             reportIntegrityMetadataError(m_resource-&gt;url());</span>
446             return;
447         }
448 
449         auto response = m_resource-&gt;response();
450 
451         if (options().filteringPolicy == ResponseFilteringPolicy::Disable) {
452             m_client-&gt;didReceiveResponse(identifier, response);
453             if (m_resource-&gt;resourceBuffer())
454                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
455         } else {
456             ASSERT(response.type() == ResourceResponse::Type::Default);
457 
458             m_client-&gt;didReceiveResponse(identifier, ResourceResponseBase::filter(response));
459             if (m_resource-&gt;resourceBuffer())
460                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
461         }
462     }
463 
464     m_client-&gt;didFinishLoading(identifier);
465 }
</pre>
<hr />
<pre>
638         return true;
639     case ContentSecurityPolicyEnforcement::EnforceChildSrcDirective:
640         return contentSecurityPolicy().allowChildContextFromSource(url, redirectResponseReceived);
641     case ContentSecurityPolicyEnforcement::EnforceConnectSrcDirective:
642         return contentSecurityPolicy().allowConnectToSource(url, redirectResponseReceived);
643     case ContentSecurityPolicyEnforcement::EnforceScriptSrcDirective:
644         return contentSecurityPolicy().allowScriptFromSource(url, redirectResponseReceived);
645     }
646     ASSERT_NOT_REACHED();
647     return false;
648 }
649 
650 bool DocumentThreadableLoader::isAllowedRedirect(const URL&amp; url)
651 {
652     if (m_options.mode == FetchOptions::Mode::NoCors)
653         return true;
654 
655     return m_sameOriginRequest &amp;&amp; securityOrigin().canRequest(url);
656 }
657 
<span class="line-removed">658 bool DocumentThreadableLoader::isXMLHttpRequest() const</span>
<span class="line-removed">659 {</span>
<span class="line-removed">660     return m_options.initiator == cachedResourceRequestInitiators().xmlhttprequest;</span>
<span class="line-removed">661 }</span>
<span class="line-removed">662 </span>
663 SecurityOrigin&amp; DocumentThreadableLoader::securityOrigin() const
664 {
665     return m_origin ? *m_origin : m_document.securityOrigin();
666 }
667 
668 const ContentSecurityPolicy&amp; DocumentThreadableLoader::contentSecurityPolicy() const
669 {
670     if (m_contentSecurityPolicy)
671         return *m_contentSecurityPolicy.get();
672     ASSERT(m_document.contentSecurityPolicy());
673     return *m_document.contentSecurityPolicy();
674 }
675 
676 void DocumentThreadableLoader::reportRedirectionWithBadScheme(const URL&amp; url)
677 {
678     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Redirection to URL with a scheme that is not HTTP(S).&quot;_s, ResourceError::Type::AccessControl));
679 }
680 
681 void DocumentThreadableLoader::reportContentSecurityPolicyError(const URL&amp; url)
682 {
683     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Blocked by Content Security Policy.&quot;_s, ResourceError::Type::AccessControl));
684 }
685 
686 void DocumentThreadableLoader::reportCrossOriginResourceSharingError(const URL&amp; url)
687 {
688     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross-origin redirection denied by Cross-Origin Resource Sharing policy.&quot;_s, ResourceError::Type::AccessControl));
689 }
690 
<span class="line-modified">691 void DocumentThreadableLoader::reportIntegrityMetadataError(const URL&amp; url)</span>
692 {
<span class="line-modified">693     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Failed integrity metadata check.&quot;_s, ResourceError::Type::General));</span>
694 }
695 
696 void DocumentThreadableLoader::logErrorAndFail(const ResourceError&amp; error)
697 {
698     if (m_shouldLogError == ShouldLogError::Yes) {
699         if (error.isAccessControl() &amp;&amp; !error.localizedDescription().isEmpty())
700             m_document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
701         logError(m_document, error, m_options.initiator);
702     }
703     ASSERT(m_client);
704     m_client-&gt;didFail(error);
705 }
706 
707 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;DocumentThreadableLoader.h&quot;
 33 
 34 #include &quot;CachedRawResource.h&quot;
 35 #include &quot;CachedResourceLoader.h&quot;
 36 #include &quot;CachedResourceRequest.h&quot;
 37 #include &quot;CachedResourceRequestInitiators.h&quot;
 38 #include &quot;CrossOriginAccessControl.h&quot;
 39 #include &quot;CrossOriginPreflightChecker.h&quot;
 40 #include &quot;CrossOriginPreflightResultCache.h&quot;
 41 #include &quot;DOMWindow.h&quot;
 42 #include &quot;Document.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added"> 46 #include &quot;LegacySchemeRegistry.h&quot;</span>
 47 #include &quot;LoadTiming.h&quot;
 48 #include &quot;LoaderStrategy.h&quot;
 49 #include &quot;Performance.h&quot;
 50 #include &quot;PlatformStrategies.h&quot;
 51 #include &quot;ProgressTracker.h&quot;
 52 #include &quot;ResourceError.h&quot;
 53 #include &quot;ResourceRequest.h&quot;
 54 #include &quot;ResourceTiming.h&quot;
 55 #include &quot;RuntimeApplicationChecks.h&quot;
 56 #include &quot;RuntimeEnabledFeatures.h&quot;

 57 #include &quot;SecurityOrigin.h&quot;
<span class="line-added"> 58 #include &quot;Settings.h&quot;</span>
 59 #include &quot;SharedBuffer.h&quot;
 60 #include &quot;SubresourceIntegrity.h&quot;
 61 #include &quot;SubresourceLoader.h&quot;
 62 #include &quot;ThreadableLoaderClient.h&quot;
 63 #include &lt;wtf/Assertions.h&gt;
 64 #include &lt;wtf/Ref.h&gt;
 65 
 66 #if PLATFORM(IOS_FAMILY)
 67 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 68 #endif
 69 
 70 namespace WebCore {
 71 
 72 void DocumentThreadableLoader::loadResourceSynchronously(Document&amp; document, ResourceRequest&amp;&amp; request, ThreadableLoaderClient&amp; client, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy)
 73 {
 74     // The loader will be deleted as soon as this function exits.
 75     Ref&lt;DocumentThreadableLoader&gt; loader = adoptRef(*new DocumentThreadableLoader(document, client, LoadSynchronously, WTFMove(request), options, WTFMove(origin), WTFMove(contentSecurityPolicy), String(), ShouldLogError::Yes));
 76     ASSERT(loader-&gt;hasOneRef());
 77 }
 78 
</pre>
<hr />
<pre>
115 }
116 
117 DocumentThreadableLoader::DocumentThreadableLoader(Document&amp; document, ThreadableLoaderClient&amp; client, BlockingBehavior blockingBehavior, ResourceRequest&amp;&amp; request, const ThreadableLoaderOptions&amp; options, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; origin, std::unique_ptr&lt;ContentSecurityPolicy&gt;&amp;&amp; contentSecurityPolicy, String&amp;&amp; referrer, ShouldLogError shouldLogError)
118     : m_client(&amp;client)
119     , m_document(document)
120     , m_options(options)
121     , m_origin(WTFMove(origin))
122     , m_referrer(WTFMove(referrer))
123     , m_sameOriginRequest(securityOrigin().canRequest(request.url()))
124     , m_simpleRequest(true)
125     , m_async(blockingBehavior == LoadAsynchronously)
126     , m_delayCallbacksForIntegrityCheck(!m_options.integrity.isEmpty())
127     , m_contentSecurityPolicy(WTFMove(contentSecurityPolicy))
128     , m_shouldLogError(shouldLogError)
129 {
130     relaxAdoptionRequirement();
131 
132     // Setting a referrer header is only supported in the async code path.
133     ASSERT(m_async || m_referrer.isEmpty());
134 
<span class="line-added">135     if (document.settings().disallowSyncXHRDuringPageDismissalEnabled() &amp;&amp; !m_async &amp;&amp; (!document.page() || !document.page()-&gt;areSynchronousLoadsAllowed())) {</span>
<span class="line-added">136         document.didRejectSyncXHRDuringPageDismissal();</span>
<span class="line-added">137         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Synchronous loads are not allowed at this time&quot;));</span>
<span class="line-added">138         return;</span>
<span class="line-added">139     }</span>
<span class="line-added">140 </span>
141     // Referrer and Origin headers should be set after the preflight if any.
142     ASSERT(!request.hasHTTPReferrer() &amp;&amp; !request.hasHTTPOrigin());
143 
144     ASSERT_WITH_SECURITY_IMPLICATION(isAllowedByContentSecurityPolicy(request.url(), ContentSecurityPolicy::RedirectResponseReceived::No));
145 
146     m_options.storedCredentialsPolicy = (m_options.credentials == FetchOptions::Credentials::Include || (m_options.credentials == FetchOptions::Credentials::SameOrigin &amp;&amp; m_sameOriginRequest)) ? StoredCredentialsPolicy::Use : StoredCredentialsPolicy::DoNotUse;
147 
148     ASSERT(!request.httpHeaderFields().contains(HTTPHeaderName::Origin));
149 
150     // Copy headers if we need to replay the request after a redirection.
151     if (m_options.mode == FetchOptions::Mode::Cors)
152         m_originalHeaders = request.httpHeaderFields();
153 
154     if (shouldSetHTTPHeadersToKeep())
155         m_options.httpHeadersToKeep = httpHeadersToKeepFromCleaning(request.httpHeaderFields());
156 
<span class="line-modified">157     bool shouldDisableCORS = document.isRunningUserScripts() &amp;&amp; LegacySchemeRegistry::isUserExtensionScheme(request.url().protocol().toStringWithoutCopying());</span>
<span class="line-added">158     if (auto* page = document.page())</span>
<span class="line-added">159         shouldDisableCORS |= page-&gt;shouldDisableCorsForRequestTo(request.url());</span>
<span class="line-added">160 </span>
<span class="line-added">161     if (shouldDisableCORS) {</span>
162         m_options.mode = FetchOptions::Mode::NoCors;
163         m_options.filteringPolicy = ResponseFilteringPolicy::Disable;
164     }
165 
166     m_options.cspResponseHeaders = m_options.contentSecurityPolicyEnforcement != ContentSecurityPolicyEnforcement::DoNotEnforce ? this-&gt;contentSecurityPolicy().responseHeaders() : ContentSecurityPolicyResponseHeaders { };
167 
168     // As per step 11 of https://fetch.spec.whatwg.org/#main-fetch, data scheme (if same-origin data-URL flag is set) and about scheme are considered same-origin.
169     if (request.url().protocolIsData())
170         m_sameOriginRequest = options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
171 
172     if (m_sameOriginRequest || m_options.mode == FetchOptions::Mode::NoCors || m_options.mode == FetchOptions::Mode::Navigate) {
173         loadRequest(WTFMove(request), SecurityCheckPolicy::DoSecurityCheck);
174         return;
175     }
176 
177     if (m_options.mode == FetchOptions::Mode::SameOrigin) {
178         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, request.url(), &quot;Cross origin requests are not allowed when using same-origin fetch mode.&quot;));
179         return;
180     }
181 
182     makeCrossOriginAccessRequest(WTFMove(request));
183 }
184 
185 bool DocumentThreadableLoader::checkURLSchemeAsCORSEnabled(const URL&amp; url)
186 {
187     // Cross-origin requests are only allowed for HTTP and registered schemes. We would catch this when checking response headers later, but there is no reason to send a request that&#39;s guaranteed to be denied.
<span class="line-modified">188     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsCORSEnabled(url.protocol().toStringWithoutCopying())) {</span>
189         logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross origin requests are only supported for HTTP.&quot;, ResourceError::Type::AccessControl));
190         return false;
191     }
192     return true;
193 }
194 
195 void DocumentThreadableLoader::makeCrossOriginAccessRequest(ResourceRequest&amp;&amp; request)
196 {
197     ASSERT(m_options.mode == FetchOptions::Mode::Cors);
198 
199 #if PLATFORM(IOS_FAMILY)
200     bool needsPreflightQuirk = IOSApplication::isMoviStarPlus() &amp;&amp; applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0 &amp;&amp; (m_options.preflightPolicy == PreflightPolicy::Consider || m_options.preflightPolicy == PreflightPolicy::Force);
201 #else
202     bool needsPreflightQuirk = false;
203 #endif
204 
205     if ((m_options.preflightPolicy == PreflightPolicy::Consider &amp;&amp; isSimpleCrossOriginAccessRequest(request.httpMethod(), request.httpHeaderFields())) || m_options.preflightPolicy == PreflightPolicy::Prevent || (shouldPerformSecurityChecks() &amp;&amp; !needsPreflightQuirk)) {
206         if (checkURLSchemeAsCORSEnabled(request.url()))
207             makeSimpleCrossOriginAccessRequest(WTFMove(request));
208     } else {
</pre>
<hr />
<pre>
436     m_client-&gt;didFinishTiming(resourceTiming);
437 }
438 
439 void DocumentThreadableLoader::notifyFinished(CachedResource&amp; resource)
440 {
441     ASSERT(m_client);
442     ASSERT_UNUSED(resource, &amp;resource == m_resource);
443 
444     if (m_resource-&gt;errorOccurred())
445         didFail(m_resource-&gt;identifier(), m_resource-&gt;resourceError());
446     else
447         didFinishLoading(m_resource-&gt;identifier());
448 }
449 
450 void DocumentThreadableLoader::didFinishLoading(unsigned long identifier)
451 {
452     ASSERT(m_client);
453 
454     if (m_delayCallbacksForIntegrityCheck) {
455         if (!matchIntegrityMetadata(*m_resource, m_options.integrity)) {
<span class="line-modified">456             reportIntegrityMetadataError(*m_resource, m_options.integrity);</span>
457             return;
458         }
459 
460         auto response = m_resource-&gt;response();
461 
462         if (options().filteringPolicy == ResponseFilteringPolicy::Disable) {
463             m_client-&gt;didReceiveResponse(identifier, response);
464             if (m_resource-&gt;resourceBuffer())
465                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
466         } else {
467             ASSERT(response.type() == ResourceResponse::Type::Default);
468 
469             m_client-&gt;didReceiveResponse(identifier, ResourceResponseBase::filter(response));
470             if (m_resource-&gt;resourceBuffer())
471                 m_client-&gt;didReceiveData(m_resource-&gt;resourceBuffer()-&gt;data(), m_resource-&gt;resourceBuffer()-&gt;size());
472         }
473     }
474 
475     m_client-&gt;didFinishLoading(identifier);
476 }
</pre>
<hr />
<pre>
649         return true;
650     case ContentSecurityPolicyEnforcement::EnforceChildSrcDirective:
651         return contentSecurityPolicy().allowChildContextFromSource(url, redirectResponseReceived);
652     case ContentSecurityPolicyEnforcement::EnforceConnectSrcDirective:
653         return contentSecurityPolicy().allowConnectToSource(url, redirectResponseReceived);
654     case ContentSecurityPolicyEnforcement::EnforceScriptSrcDirective:
655         return contentSecurityPolicy().allowScriptFromSource(url, redirectResponseReceived);
656     }
657     ASSERT_NOT_REACHED();
658     return false;
659 }
660 
661 bool DocumentThreadableLoader::isAllowedRedirect(const URL&amp; url)
662 {
663     if (m_options.mode == FetchOptions::Mode::NoCors)
664         return true;
665 
666     return m_sameOriginRequest &amp;&amp; securityOrigin().canRequest(url);
667 }
668 





669 SecurityOrigin&amp; DocumentThreadableLoader::securityOrigin() const
670 {
671     return m_origin ? *m_origin : m_document.securityOrigin();
672 }
673 
674 const ContentSecurityPolicy&amp; DocumentThreadableLoader::contentSecurityPolicy() const
675 {
676     if (m_contentSecurityPolicy)
677         return *m_contentSecurityPolicy.get();
678     ASSERT(m_document.contentSecurityPolicy());
679     return *m_document.contentSecurityPolicy();
680 }
681 
682 void DocumentThreadableLoader::reportRedirectionWithBadScheme(const URL&amp; url)
683 {
684     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Redirection to URL with a scheme that is not HTTP(S).&quot;_s, ResourceError::Type::AccessControl));
685 }
686 
687 void DocumentThreadableLoader::reportContentSecurityPolicyError(const URL&amp; url)
688 {
689     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Blocked by Content Security Policy.&quot;_s, ResourceError::Type::AccessControl));
690 }
691 
692 void DocumentThreadableLoader::reportCrossOriginResourceSharingError(const URL&amp; url)
693 {
694     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, url, &quot;Cross-origin redirection denied by Cross-Origin Resource Sharing policy.&quot;_s, ResourceError::Type::AccessControl));
695 }
696 
<span class="line-modified">697 void DocumentThreadableLoader::reportIntegrityMetadataError(const CachedResource&amp; resource, const String&amp; expectedMetadata)</span>
698 {
<span class="line-modified">699     logErrorAndFail(ResourceError(errorDomainWebKitInternal, 0, resource.url(), makeString(&quot;Failed integrity metadata check. &quot;_s, integrityMismatchDescription(resource, expectedMetadata)), ResourceError::Type::General));</span>
700 }
701 
702 void DocumentThreadableLoader::logErrorAndFail(const ResourceError&amp; error)
703 {
704     if (m_shouldLogError == ShouldLogError::Yes) {
705         if (error.isAccessControl() &amp;&amp; !error.localizedDescription().isEmpty())
706             m_document.addConsoleMessage(MessageSource::Security, MessageLevel::Error, error.localizedDescription());
707         logError(m_document, error, m_options.initiator);
708     }
709     ASSERT(m_client);
710     m_client-&gt;didFail(error);
711 }
712 
713 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="DocumentLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DocumentThreadableLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
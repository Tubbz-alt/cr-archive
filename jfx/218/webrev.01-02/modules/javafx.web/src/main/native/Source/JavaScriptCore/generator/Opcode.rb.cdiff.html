<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/Opcode.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Metadata.rb.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.rb.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/Opcode.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,10 ***</span>
<span class="line-new-header">--- 27,12 ---</span>
  
  class Opcode
      attr_reader :id
      attr_reader :args
      attr_reader :metadata
<span class="line-added">+     attr_reader :extras</span>
<span class="line-added">+     attr_reader :checkpoints</span>
  
      module Size
          Narrow = &quot;OpcodeSize::Narrow&quot;
          Wide16 = &quot;OpcodeSize::Wide16&quot;
          Wide32 = &quot;OpcodeSize::Wide32&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,15 ***</span>
          tid = @@id
          @@id = @@id + 1
          tid
      end
  
<span class="line-modified">!     def initialize(section, name, args, metadata, metadata_initializers)</span>
          @section = section
          @name = name
          @metadata = Metadata.new metadata, metadata_initializers
<span class="line-modified">!         @args = args.map.with_index { |(arg_name, type), index| Argument.new arg_name, type, index + 1 } unless args.nil?</span>
      end
  
      def create_id!
          @id = self.class.id
      end
<span class="line-new-header">--- 44,18 ---</span>
          tid = @@id
          @@id = @@id + 1
          tid
      end
  
<span class="line-modified">!     def initialize(section, name, extras, args, metadata, metadata_initializers, tmps, checkpoints)</span>
          @section = section
          @name = name
<span class="line-added">+         @extras = extras || {}</span>
          @metadata = Metadata.new metadata, metadata_initializers
<span class="line-modified">!         @args = args.map.with_index { |(arg_name, type), index| Argument.new arg_name, type, index } unless args.nil?</span>
<span class="line-added">+         @tmps = tmps</span>
<span class="line-added">+         @checkpoints = checkpoints.map { |(checkpoint, _)| checkpoint } unless checkpoints.nil?</span>
      end
  
      def create_id!
          @id = self.class.id
      end
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,12 ***</span>
          return if @args.nil?
  
          @args.map(&amp;:name).unshift(&quot;&quot;).join(&quot;, &quot;)
      end
  
      def map_fields_with_size(prefix, size, &amp;block)
<span class="line-modified">!         args = [Argument.new(&quot;opcodeID&quot;, :OpcodeID, 0)]</span>
          args += @args.dup if @args
          unless @metadata.empty?
              args &lt;&lt; @metadata.emitter_local
          end
          args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }
<span class="line-new-header">--- 90,37 ---</span>
          return if @args.nil?
  
          @args.map(&amp;:name).unshift(&quot;&quot;).join(&quot;, &quot;)
      end
  
<span class="line-added">+     def opcodeIDType</span>
<span class="line-added">+       @section.is_wasm? ? :WasmOpcodeID : :OpcodeID</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def wide16</span>
<span class="line-added">+       @section.is_wasm? ? :wasm_wide16 : :op_wide16</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def wide32</span>
<span class="line-added">+       @section.is_wasm? ? :wasm_wide32 : :op_wide32</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def traits</span>
<span class="line-added">+       @section.is_wasm? ? &quot;WasmOpcodeTraits&quot; : &quot;JSOpcodeTraits&quot;</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
      def map_fields_with_size(prefix, size, &amp;block)
<span class="line-modified">!         args = [Argument.new(&quot;opcodeID&quot;, opcodeIDType, 0)]</span>
<span class="line-added">+         args += @args.dup if @args</span>
<span class="line-added">+         unless @metadata.empty?</span>
<span class="line-added">+             args &lt;&lt; @metadata.emitter_local</span>
<span class="line-added">+         end</span>
<span class="line-added">+         args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def map_operands_with_size(prefix, size, &amp;block)</span>
<span class="line-added">+         args = []</span>
          args += @args.dup if @args
          unless @metadata.empty?
              args &lt;&lt; @metadata.emitter_local
          end
          args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,10 ***</span>
<span class="line-new-header">--- 128,12 ---</span>
  
      def struct
          &lt;&lt;-EOF
  struct #{capitalized_name} : public Instruction {
      #{opcodeID}
<span class="line-added">+     #{temps}</span>
<span class="line-added">+     #{checkpointValues}</span>
  
  #{emitter}
  #{dumper}
  #{constructors}
  #{setters}#{metadata_struct_and_accessor}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,92 ***</span>
  };
  EOF
      end
  
      def opcodeID
<span class="line-modified">!         &quot;static constexpr OpcodeID opcodeID = #{name};&quot;</span>
      end
  
      def emitter
<span class="line-modified">!         op_wide16 = Argument.new(&quot;op_wide16&quot;, :OpcodeID, 0)</span>
<span class="line-modified">!         op_wide32 = Argument.new(&quot;op_wide32&quot;, :OpcodeID, 0)</span>
          metadata_param = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.create_param}&quot;
          metadata_arg = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.name}&quot;
          &lt;&lt;-EOF.chomp
      static void emit(BytecodeGenerator* gen#{typed_args})
      {
<span class="line-modified">!         emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(gen#{untyped_args});</span>
      }
  #{%{
<span class="line-modified">!     template&lt;OpcodeSize size, FitsAssertion shouldAssert = Assert&gt;</span>
      static bool emit(BytecodeGenerator* gen#{typed_args})
      {#{@metadata.create_emitter_local}
<span class="line-modified">!         return emit&lt;size, shouldAssert&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  
<span class="line-modified">!     template&lt;OpcodeSize size&gt;</span>
      static bool checkWithoutMetadataID(BytecodeGenerator* gen#{typed_args})
      {
          decltype(gen-&gt;addMetadataFor(opcodeID)) __metadataID { };
<span class="line-modified">!         return checkImpl&lt;size&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  } unless @metadata.empty?}
<span class="line-modified">!     template&lt;OpcodeSize size, FitsAssertion shouldAssert = Assert, bool recordOpcode = true&gt;</span>
      static bool emit(BytecodeGenerator* gen#{typed_args}#{metadata_param})
      {
<span class="line-modified">!         bool didEmit = emitImpl&lt;size, recordOpcode&gt;(gen#{untyped_args}#{metadata_arg});</span>
          if (shouldAssert == Assert)
              ASSERT(didEmit);
          return didEmit;
      }
  
<span class="line-modified">!     template&lt;OpcodeSize size&gt;</span>
      static void emitWithSmallestSizeRequirement(BytecodeGenerator* gen#{typed_args})
      {
          #{@metadata.create_emitter_local}
<span class="line-modified">!         if (static_cast&lt;unsigned&gt;(size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Narrow)) {</span>
<span class="line-modified">!             if (emit&lt;OpcodeSize::Narrow, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
                  return;
          }
<span class="line-modified">!         if (static_cast&lt;unsigned&gt;(size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Wide16)) {</span>
<span class="line-modified">!             if (emit&lt;OpcodeSize::Wide16, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
                  return;
          }
<span class="line-modified">!         emit&lt;OpcodeSize::Wide32, Assert, true&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  
  private:
<span class="line-modified">!     template&lt;OpcodeSize size&gt;</span>
      static bool checkImpl(BytecodeGenerator* gen#{typed_reference_args}#{metadata_param})
      {
          UNUSED_PARAM(gen);
  #if OS(WINDOWS) &amp;&amp; ENABLE(C_LOOP)
          // FIXME: Disable wide16 optimization for Windows CLoop
          // https://bugs.webkit.org/show_bug.cgi?id=198283
<span class="line-modified">!         if (size == OpcodeSize::Wide16)</span>
              return false;
  #endif
<span class="line-modified">!         return #{map_fields_with_size(&quot;&quot;, &quot;size&quot;, &amp;:fits_check).join &quot;\n            &amp;&amp; &quot;}</span>
<span class="line-modified">!             &amp;&amp; (size == OpcodeSize::Wide16 ? #{op_wide16.fits_check(Size::Narrow)} : true)</span>
<span class="line-modified">!             &amp;&amp; (size == OpcodeSize::Wide32 ? #{op_wide32.fits_check(Size::Narrow)} : true);</span>
      }
  
<span class="line-modified">!     template&lt;OpcodeSize size, bool recordOpcode&gt;</span>
      static bool emitImpl(BytecodeGenerator* gen#{typed_args}#{metadata_param})
      {
<span class="line-modified">!         if (size == OpcodeSize::Wide16)</span>
              gen-&gt;alignWideOpcode16();
<span class="line-modified">!         else if (size == OpcodeSize::Wide32)</span>
              gen-&gt;alignWideOpcode32();
<span class="line-modified">!         if (checkImpl&lt;size&gt;(gen#{untyped_args}#{metadata_arg})) {</span>
              if (recordOpcode)
                  gen-&gt;recordOpcode(opcodeID);
<span class="line-modified">!             if (size == OpcodeSize::Wide16)</span>
                  #{op_wide16.fits_write Size::Narrow}
<span class="line-modified">!             else if (size == OpcodeSize::Wide32)</span>
                  #{op_wide32.fits_write Size::Narrow}
<span class="line-modified">! #{map_fields_with_size(&quot;            &quot;, &quot;size&quot;, &amp;:fits_write).join &quot;\n&quot;}</span>
              return true;
          }
          return false;
      }
  
<span class="line-new-header">--- 141,107 ---</span>
  };
  EOF
      end
  
      def opcodeID
<span class="line-modified">!         &quot;static constexpr #{opcodeIDType} opcodeID = #{name};&quot;</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def checkpointValues</span>
<span class="line-added">+         return if @checkpoints.nil?</span>
<span class="line-added">+ </span>
<span class="line-added">+         [&quot;enum Checkpoints : uint8_t {&quot;].concat(checkpoints.map{ |checkpoint| &quot;        #{checkpoint},&quot; }).concat([&quot;        numberOfCheckpoints,&quot;, &quot;    };&quot;]).join(&quot;\n&quot;)</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
<span class="line-added">+     def temps</span>
<span class="line-added">+         return if @tmps.nil?</span>
<span class="line-added">+ </span>
<span class="line-added">+         [&quot;enum Tmps : uint8_t {&quot;].concat(@tmps.map {|(tmp, type)| &quot;        #{tmp},&quot;}).push(&quot;    };&quot;).join(&quot;\n&quot;)</span>
      end
  
      def emitter
<span class="line-modified">!         op_wide16 = Argument.new(wide16, opcodeIDType, 0)</span>
<span class="line-modified">!         op_wide32 = Argument.new(wide32, opcodeIDType, 0)</span>
          metadata_param = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.create_param}&quot;
          metadata_arg = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.name}&quot;
          &lt;&lt;-EOF.chomp
<span class="line-added">+     template&lt;typename BytecodeGenerator&gt;</span>
      static void emit(BytecodeGenerator* gen#{typed_args})
      {
<span class="line-modified">!         emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow, BytecodeGenerator&gt;(gen#{untyped_args});</span>
      }
  #{%{
<span class="line-modified">!     template&lt;OpcodeSize __size, typename BytecodeGenerator, FitsAssertion shouldAssert = Assert&gt;</span>
      static bool emit(BytecodeGenerator* gen#{typed_args})
      {#{@metadata.create_emitter_local}
<span class="line-modified">!         return emit&lt;__size, BytecodeGenerator, shouldAssert&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  
<span class="line-modified">!     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
      static bool checkWithoutMetadataID(BytecodeGenerator* gen#{typed_args})
      {
          decltype(gen-&gt;addMetadataFor(opcodeID)) __metadataID { };
<span class="line-modified">!         return checkImpl&lt;__size, BytecodeGenerator&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  } unless @metadata.empty?}
<span class="line-modified">!     template&lt;OpcodeSize __size, typename BytecodeGenerator, FitsAssertion shouldAssert = Assert, bool recordOpcode = true&gt;</span>
      static bool emit(BytecodeGenerator* gen#{typed_args}#{metadata_param})
      {
<span class="line-modified">!         bool didEmit = emitImpl&lt;__size, recordOpcode, BytecodeGenerator&gt;(gen#{untyped_args}#{metadata_arg});</span>
          if (shouldAssert == Assert)
              ASSERT(didEmit);
          return didEmit;
      }
  
<span class="line-modified">!     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
      static void emitWithSmallestSizeRequirement(BytecodeGenerator* gen#{typed_args})
      {
          #{@metadata.create_emitter_local}
<span class="line-modified">!         if (static_cast&lt;unsigned&gt;(__size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Narrow)) {</span>
<span class="line-modified">!             if (emit&lt;OpcodeSize::Narrow, BytecodeGenerator, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
                  return;
          }
<span class="line-modified">!         if (static_cast&lt;unsigned&gt;(__size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Wide16)) {</span>
<span class="line-modified">!             if (emit&lt;OpcodeSize::Wide16, BytecodeGenerator, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
                  return;
          }
<span class="line-modified">!         emit&lt;OpcodeSize::Wide32, BytecodeGenerator, Assert, true&gt;(gen#{untyped_args}#{metadata_arg});</span>
      }
  
  private:
<span class="line-modified">!     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
      static bool checkImpl(BytecodeGenerator* gen#{typed_reference_args}#{metadata_param})
      {
          UNUSED_PARAM(gen);
  #if OS(WINDOWS) &amp;&amp; ENABLE(C_LOOP)
          // FIXME: Disable wide16 optimization for Windows CLoop
          // https://bugs.webkit.org/show_bug.cgi?id=198283
<span class="line-modified">!         if (__size == OpcodeSize::Wide16)</span>
              return false;
  #endif
<span class="line-modified">!         return #{map_fields_with_size(&quot;&quot;, &quot;__size&quot;, &amp;:fits_check).join &quot;\n            &amp;&amp; &quot;}</span>
<span class="line-modified">!             &amp;&amp; (__size == OpcodeSize::Wide16 ? #{op_wide16.fits_check(Size::Narrow)} : true)</span>
<span class="line-modified">!             &amp;&amp; (__size == OpcodeSize::Wide32 ? #{op_wide32.fits_check(Size::Narrow)} : true);</span>
      }
  
<span class="line-modified">!     template&lt;OpcodeSize __size, bool recordOpcode, typename BytecodeGenerator&gt;</span>
      static bool emitImpl(BytecodeGenerator* gen#{typed_args}#{metadata_param})
      {
<span class="line-modified">!         #{!@checkpoints.nil? ? &quot;gen-&gt;setUsesCheckpoints();&quot; : &quot;&quot;}</span>
<span class="line-added">+         if (__size == OpcodeSize::Wide16)</span>
              gen-&gt;alignWideOpcode16();
<span class="line-modified">!         else if (__size == OpcodeSize::Wide32)</span>
              gen-&gt;alignWideOpcode32();
<span class="line-modified">!         if (checkImpl&lt;__size&gt;(gen#{untyped_args}#{metadata_arg})) {</span>
              if (recordOpcode)
                  gen-&gt;recordOpcode(opcodeID);
<span class="line-modified">!             if (__size == OpcodeSize::Wide16)</span>
                  #{op_wide16.fits_write Size::Narrow}
<span class="line-modified">!             else if (__size == OpcodeSize::Wide32)</span>
                  #{op_wide32.fits_write Size::Narrow}
<span class="line-modified">!             #{Argument.new(&quot;opcodeID&quot;, opcodeIDType, 0).fits_write Size::Narrow}</span>
<span class="line-added">+ #{map_operands_with_size(&quot;            &quot;, &quot;__size&quot;, &amp;:fits_write).join &quot;\n&quot;}</span>
              return true;
          }
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,60 ***</span>
  EOF
      end
  
      def dumper
          &lt;&lt;-EOF
<span class="line-modified">!     template&lt;typename Block&gt;</span>
<span class="line-removed">-     void dump(BytecodeDumper&lt;Block&gt;* dumper, InstructionStream::Offset __location, int __sizeShiftAmount)</span>
      {
          dumper-&gt;printLocationAndOp(__location, &amp;&quot;**#{@name}&quot;[2 - __sizeShiftAmount]);
  #{print_args { |arg|
  &lt;&lt;-EOF.chomp
<span class="line-modified">!         dumper-&gt;dumpOperand(#{arg.field_name}, #{arg.index == 1});</span>
  EOF
      }}
      }
  EOF
      end
  
      def constructors
          fields = (@args || []) + (@metadata.empty? ? [] : [@metadata])
<span class="line-modified">!         init = -&gt;(size) { fields.empty?  ? &quot;&quot; : &quot;: #{fields.map.with_index { |arg, i| arg.load_from_stream(i + 1, size) }.join &quot;\n        , &quot; }&quot; }</span>
  
          &lt;&lt;-EOF
      #{capitalized_name}(const uint8_t* stream)
          #{init.call(&quot;OpcodeSize::Narrow&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
      }
  
      #{capitalized_name}(const uint16_t* stream)
          #{init.call(&quot;OpcodeSize::Wide16&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
      }
  
  
      #{capitalized_name}(const uint32_t* stream)
          #{init.call(&quot;OpcodeSize::Wide32&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
      }
  
      static #{capitalized_name} decode(const uint8_t* stream)
      {
<span class="line-modified">!         if (*stream == op_wide32) </span>
<span class="line-modified">!             return { bitwise_cast&lt;const uint32_t*&gt;(stream + 1) };</span>
<span class="line-modified">!         if (*stream == op_wide16) </span>
<span class="line-modified">!             return { bitwise_cast&lt;const uint16_t*&gt;(stream + 1) };</span>
<span class="line-modified">!         return { stream };</span>
      }
  EOF
      end
  
      def setters
<span class="line-modified">!         print_args(&amp;:setter)</span>
      end
  
      def metadata_struct_and_accessor
          &lt;&lt;-EOF.chomp
  #{@metadata.struct(self)}#{@metadata.accessor}
<span class="line-new-header">--- 249,60 ---</span>
  EOF
      end
  
      def dumper
          &lt;&lt;-EOF
<span class="line-modified">!     void dump(BytecodeDumperBase* dumper, InstructionStream::Offset __location, int __sizeShiftAmount)</span>
      {
          dumper-&gt;printLocationAndOp(__location, &amp;&quot;**#{@name}&quot;[2 - __sizeShiftAmount]);
  #{print_args { |arg|
  &lt;&lt;-EOF.chomp
<span class="line-modified">!         dumper-&gt;dumpOperand(#{arg.field_name}, #{arg.index == 0});</span>
  EOF
      }}
      }
  EOF
      end
  
      def constructors
          fields = (@args || []) + (@metadata.empty? ? [] : [@metadata])
<span class="line-modified">!         init = -&gt;(size) { fields.empty?  ? &quot;&quot; : &quot;: #{fields.map.with_index { |arg, i| arg.load_from_stream(i, size) }.join &quot;\n        , &quot; }&quot; }</span>
  
          &lt;&lt;-EOF
      #{capitalized_name}(const uint8_t* stream)
          #{init.call(&quot;OpcodeSize::Narrow&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
      }
  
      #{capitalized_name}(const uint16_t* stream)
          #{init.call(&quot;OpcodeSize::Wide16&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
      }
  
  
      #{capitalized_name}(const uint32_t* stream)
          #{init.call(&quot;OpcodeSize::Wide32&quot;)}
      {
<span class="line-modified">!         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
      }
  
      static #{capitalized_name} decode(const uint8_t* stream)
      {
<span class="line-modified">!         // A pointer is pointing to the first operand (opcode and prefix are not included).</span>
<span class="line-modified">!         if (*stream == #{wide32})</span>
<span class="line-modified">!             return { bitwise_cast&lt;const uint32_t*&gt;(stream + 2) };</span>
<span class="line-modified">!         if (*stream == #{wide16})</span>
<span class="line-modified">!             return { bitwise_cast&lt;const uint16_t*&gt;(stream + 2) };</span>
<span class="line-added">+         return { stream + 1 };</span>
      }
  EOF
      end
  
      def setters
<span class="line-modified">!         print_args { |a| a.setter(traits) }</span>
      end
  
      def metadata_struct_and_accessor
          &lt;&lt;-EOF.chomp
  #{@metadata.struct(self)}#{@metadata.accessor}
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,11 ***</span>
      def struct_indices
          out = []
          out += @args.map(&amp;:field_name) unless @args.nil?
          out &lt;&lt; Metadata.field_name unless @metadata.empty?
          out.map.with_index do |name, index|
<span class="line-modified">!             &quot;const unsigned #{capitalized_name}_#{name}_index = #{index + 1};&quot;</span>
          end
      end
  
      def full_name
          &quot;#{@section.config[:asm_prefix]}#{@section.config[:op_prefix]}#{@name}&quot;
<span class="line-new-header">--- 330,11 ---</span>
      def struct_indices
          out = []
          out += @args.map(&amp;:field_name) unless @args.nil?
          out &lt;&lt; Metadata.field_name unless @metadata.empty?
          out.map.with_index do |name, index|
<span class="line-modified">!             &quot;const unsigned #{capitalized_name}_#{name}_index = #{index};&quot;</span>
          end
      end
  
      def full_name
          &quot;#{@section.config[:asm_prefix]}#{@section.config[:op_prefix]}#{@name}&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,24 ***</span>
  
      def name
          &quot;#{@section.config[:op_prefix]}#{@name}&quot;
      end
  
      def length
          1 + (@args.nil? ? 0 : @args.length) + (@metadata.empty? ? 0 : 1)
      end
  
<span class="line-modified">!     def self.dump_bytecode(opcodes)</span>
          &lt;&lt;-EOF.chomp
<span class="line-modified">! template&lt;typename Block&gt;</span>
<span class="line-removed">- static void dumpBytecode(BytecodeDumper&lt;Block&gt;* dumper, InstructionStream::Offset __location, const Instruction* __instruction)</span>
  {
<span class="line-modified">!     switch (__instruction-&gt;opcodeID()) {</span>
  #{opcodes.map { |op|
          &lt;&lt;-EOF.chomp
      case #{op.name}:
<span class="line-modified">!         __instruction-&gt;as&lt;#{op.capitalized_name}&gt;().dump(dumper, __location, __instruction-&gt;sizeShiftAmount());</span>
          break;
  EOF
      }.join &quot;\n&quot;}
      default:
          ASSERT_NOT_REACHED();
<span class="line-new-header">--- 342,27 ---</span>
  
      def name
          &quot;#{@section.config[:op_prefix]}#{@name}&quot;
      end
  
<span class="line-added">+     def unprefixed_name</span>
<span class="line-added">+       @name</span>
<span class="line-added">+     end</span>
<span class="line-added">+ </span>
      def length
          1 + (@args.nil? ? 0 : @args.length) + (@metadata.empty? ? 0 : 1)
      end
  
<span class="line-modified">!     def self.dump_bytecode(name, opcode_traits, opcodes)</span>
          &lt;&lt;-EOF.chomp
<span class="line-modified">! void dump#{name}(BytecodeDumperBase* dumper, InstructionStream::Offset __location, const Instruction* __instruction)</span>
  {
<span class="line-modified">!     switch (__instruction-&gt;opcodeID&lt;#{opcode_traits}&gt;()) {</span>
  #{opcodes.map { |op|
          &lt;&lt;-EOF.chomp
      case #{op.name}:
<span class="line-modified">!         __instruction-&gt;as&lt;#{op.capitalized_name}, #{opcode_traits}&gt;().dump(dumper, __location, __instruction-&gt;sizeShiftAmount&lt;#{opcode_traits}&gt;());</span>
          break;
  EOF
      }.join &quot;\n&quot;}
      default:
          ASSERT_NOT_REACHED();
</pre>
<center><a href="Metadata.rb.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.rb.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
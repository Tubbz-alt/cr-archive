<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webauthn/fido/DeviceResponseConverter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 // Copyright 2018 The Chromium Authors. All rights reserved.
  2 // Copyright (C) 2018 Apple Inc. All rights reserved.
  3 //
  4 // Redistribution and use in source and binary forms, with or without
  5 // modification, are permitted provided that the following conditions are
  6 // met:
  7 //
  8 //    * Redistributions of source code must retain the above copyright
  9 // notice, this list of conditions and the following disclaimer.
 10 //    * Redistributions in binary form must reproduce the above
 11 // copyright notice, this list of conditions and the following disclaimer
 12 // in the documentation and/or other materials provided with the
 13 // distribution.
 14 //    * Neither the name of Google Inc. nor the names of its
 15 // contributors may be used to endorse or promote products derived from
 16 // this software without specific prior written permission.
 17 //
 18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;DeviceResponseConverter.h&quot;
 32 
 33 #if ENABLE(WEB_AUTHN)
 34 
 35 #include &quot;AuthenticatorSupportedOptions.h&quot;
 36 #include &quot;CBORReader.h&quot;
 37 #include &quot;CBORWriter.h&quot;
 38 #include &quot;WebAuthenticationConstants.h&quot;
 39 #include &quot;WebAuthenticationUtils.h&quot;
 40 #include &lt;wtf/StdSet.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 namespace fido {
 44 using namespace WebCore;
 45 using CBOR = cbor::CBORValue;
 46 
<a name="1" id="anc1"></a>

 47 static ProtocolVersion convertStringToProtocolVersion(const String&amp; version)
 48 {
 49     if (version == kCtap2Version)
 50         return ProtocolVersion::kCtap;
 51     if (version == kU2fVersion)
 52         return ProtocolVersion::kU2f;
 53 
 54     return ProtocolVersion::kUnknown;
 55 }
 56 
 57 CtapDeviceResponseCode getResponseCode(const Vector&lt;uint8_t&gt;&amp; buffer)
 58 {
 59     if (buffer.isEmpty())
 60         return CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 61 
 62     auto code = static_cast&lt;CtapDeviceResponseCode&gt;(buffer[0]);
 63     return isCtapDeviceResponseCode(code) ? code : CtapDeviceResponseCode::kCtap2ErrInvalidCBOR;
 64 }
 65 
 66 static Vector&lt;uint8_t&gt; getCredentialId(const Vector&lt;uint8_t&gt;&amp; authenticatorData)
 67 {
 68     const size_t credentialIdLengthOffset = rpIdHashLength + flagsLength + signCounterLength + aaguidLength;
 69 
 70     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength)
 71         return { };
 72     size_t credentialIdLength = (static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset]) &lt;&lt; 8) | static_cast&lt;size_t&gt;(authenticatorData[credentialIdLengthOffset + 1]);
 73 
 74     if (authenticatorData.size() &lt; credentialIdLengthOffset + credentialIdLengthLength + credentialIdLength)
 75         return { };
 76     Vector&lt;uint8_t&gt; credentialId;
 77     credentialId.reserveInitialCapacity(credentialIdLength);
 78     auto beginIt = authenticatorData.begin() + credentialIdLengthOffset + credentialIdLengthLength;
 79     credentialId.appendRange(beginIt, beginIt + credentialIdLength);
 80     return credentialId;
 81 }
 82 
 83 
 84 // Decodes byte array response from authenticator to CBOR value object and
 85 // checks for correct encoding format.
<a name="2" id="anc2"></a><span class="line-modified"> 86 RefPtr&lt;AuthenticatorAttestationResponse&gt; readCTAPMakeCredentialResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer, const AttestationConveyancePreference&amp; attestation)</span>
 87 {
 88     if (inBuffer.size() &lt;= kResponseCodeLength)
<a name="3" id="anc3"></a><span class="line-modified"> 89         return nullptr;</span>
 90 
 91     Vector&lt;uint8_t&gt; buffer;
 92     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
 93     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
 94     if (!decodedResponse || !decodedResponse-&gt;isMap())
<a name="4" id="anc4"></a><span class="line-modified"> 95         return nullptr;</span>
 96     const auto&amp; decodedMap = decodedResponse-&gt;getMap();
 97 
 98     auto it = decodedMap.find(CBOR(1));
 99     if (it == decodedMap.end() || !it-&gt;second.isString())
<a name="5" id="anc5"></a><span class="line-modified">100         return nullptr;</span>
101     auto format = it-&gt;second.clone();
102 
103     it = decodedMap.find(CBOR(2));
104     if (it == decodedMap.end() || !it-&gt;second.isByteString())
<a name="6" id="anc6"></a><span class="line-modified">105         return nullptr;</span>
106     auto authenticatorData = it-&gt;second.clone();
107 
108     auto credentialId = getCredentialId(authenticatorData.getByteString());
109     if (credentialId.isEmpty())
<a name="7" id="anc7"></a><span class="line-modified">110         return nullptr;</span>
111 
112     it = decodedMap.find(CBOR(3));
113     if (it == decodedMap.end() || !it-&gt;second.isMap())
<a name="8" id="anc8"></a><span class="line-modified">114         return nullptr;</span>
115     auto attStmt = it-&gt;second.clone();
116 
117     Optional&lt;Vector&lt;uint8_t&gt;&gt; attestationObject;
118     if (attestation == AttestationConveyancePreference::None) {
119         // The reason why we can&#39;t directly pass authenticatorData/format/attStmt to buildAttestationObject
120         // is that they are CBORValue instead of the raw type.
121         // Also, format and attStmt are omitted as they are not useful in none attestation.
122         attestationObject = buildAttestationObject(Vector&lt;uint8_t&gt;(authenticatorData.getByteString()), &quot;&quot;, { }, attestation);
123     } else {
124         CBOR::MapValue attestationObjectMap;
125         attestationObjectMap[CBOR(&quot;authData&quot;)] = WTFMove(authenticatorData);
126         attestationObjectMap[CBOR(&quot;fmt&quot;)] = WTFMove(format);
127         attestationObjectMap[CBOR(&quot;attStmt&quot;)] = WTFMove(attStmt);
128         attestationObject = cbor::CBORWriter::write(CBOR(WTFMove(attestationObjectMap)));
129     }
130 
<a name="9" id="anc9"></a><span class="line-modified">131     return AuthenticatorAttestationResponse::create(credentialId, *attestationObject);</span>
132 }
133 
<a name="10" id="anc10"></a><span class="line-modified">134 RefPtr&lt;AuthenticatorAssertionResponse&gt; readCTAPGetAssertionResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)</span>
135 {
136     if (inBuffer.size() &lt;= kResponseCodeLength)
<a name="11" id="anc11"></a><span class="line-modified">137         return nullptr;</span>
138 
139     Vector&lt;uint8_t&gt; buffer;
140     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
141     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
142 
143     if (!decodedResponse || !decodedResponse-&gt;isMap())
<a name="12" id="anc12"></a><span class="line-modified">144         return nullptr;</span>
145 
146     auto&amp; responseMap = decodedResponse-&gt;getMap();
147 
<a name="13" id="anc13"></a>
148     auto it = responseMap.find(CBOR(1));
<a name="14" id="anc14"></a><span class="line-modified">149     if (it == responseMap.end() || !it-&gt;second.isMap())</span>
<span class="line-modified">150         return nullptr;</span>
<span class="line-modified">151     auto&amp; credential = it-&gt;second.getMap();</span>
<span class="line-modified">152     auto itr = credential.find(CBOR(kCredentialIdKey));</span>
<span class="line-modified">153     if (itr == credential.end() || !itr-&gt;second.isByteString())</span>
<span class="line-modified">154         return nullptr;</span>
<span class="line-modified">155     auto&amp; credentialId = itr-&gt;second.getByteString();</span>

156 
157     it = responseMap.find(CBOR(2));
158     if (it == responseMap.end() || !it-&gt;second.isByteString())
<a name="15" id="anc15"></a><span class="line-modified">159         return nullptr;</span>
160     auto&amp; authData = it-&gt;second.getByteString();
161 
162     it = responseMap.find(CBOR(3));
163     if (it == responseMap.end() || !it-&gt;second.isByteString())
<a name="16" id="anc16"></a><span class="line-modified">164         return nullptr;</span>
165     auto&amp; signature = it-&gt;second.getByteString();
166 
<a name="17" id="anc17"></a><span class="line-modified">167     RefPtr&lt;AuthenticatorAssertionResponse&gt; response;</span>
168     it = responseMap.find(CBOR(4));
169     if (it != responseMap.end() &amp;&amp; it-&gt;second.isMap()) {
170         auto&amp; user = it-&gt;second.getMap();
171         auto itr = user.find(CBOR(kEntityIdMapKey));
172         if (itr == user.end() || !itr-&gt;second.isByteString())
<a name="18" id="anc18"></a><span class="line-modified">173             return nullptr;</span>
<span class="line-modified">174         auto&amp; userHandle = itr-&gt;second.getByteString();</span>
<span class="line-modified">175         response = AuthenticatorAssertionResponse::create(credentialId, authData, signature, userHandle);</span>
<span class="line-added">176 </span>
<span class="line-added">177         itr = user.find(CBOR(kEntityNameMapKey));</span>
<span class="line-added">178         if (itr != user.end()) {</span>
<span class="line-added">179             if (!itr-&gt;second.isString())</span>
<span class="line-added">180                 return nullptr;</span>
<span class="line-added">181             response-&gt;setName(itr-&gt;second.getString());</span>
<span class="line-added">182         }</span>
<span class="line-added">183 </span>
<span class="line-added">184         itr = user.find(CBOR(kDisplayNameMapKey));</span>
<span class="line-added">185         if (itr != user.end()) {</span>
<span class="line-added">186             if (!itr-&gt;second.isString())</span>
<span class="line-added">187                 return nullptr;</span>
<span class="line-added">188             response-&gt;setDisplayName(itr-&gt;second.getString());</span>
<span class="line-added">189         }</span>
<span class="line-added">190     } else {</span>
<span class="line-added">191         response = AuthenticatorAssertionResponse::create(credentialId, authData, signature, { });</span>
192     }
193 
<a name="19" id="anc19"></a><span class="line-modified">194     it = responseMap.find(CBOR(5));</span>
<span class="line-added">195     if (it != responseMap.end() &amp;&amp; it-&gt;second.isUnsigned())</span>
<span class="line-added">196         response-&gt;setNumberOfCredentials(it-&gt;second.getUnsigned());</span>
<span class="line-added">197 </span>
<span class="line-added">198     return response;</span>
199 }
200 
201 Optional&lt;AuthenticatorGetInfoResponse&gt; readCTAPGetInfoResponse(const Vector&lt;uint8_t&gt;&amp; inBuffer)
202 {
203     if (inBuffer.size() &lt;= kResponseCodeLength || getResponseCode(inBuffer) != CtapDeviceResponseCode::kSuccess)
204         return WTF::nullopt;
205 
206     Vector&lt;uint8_t&gt; buffer;
207     buffer.append(inBuffer.data() + 1, inBuffer.size() - 1);
208     Optional&lt;CBOR&gt; decodedResponse = cbor::CBORReader::read(buffer);
209     if (!decodedResponse || !decodedResponse-&gt;isMap())
210         return WTF::nullopt;
211     const auto&amp; responseMap = decodedResponse-&gt;getMap();
212 
213     auto it = responseMap.find(CBOR(1));
<a name="20" id="anc20"></a><span class="line-modified">214     if (it == responseMap.end() || !it-&gt;second.isArray())</span>
215         return WTF::nullopt;
216     StdSet&lt;ProtocolVersion&gt; protocolVersions;
217     for (const auto&amp; version : it-&gt;second.getArray()) {
218         if (!version.isString())
219             return WTF::nullopt;
220 
221         auto protocol = convertStringToProtocolVersion(version.getString());
222         if (protocol == ProtocolVersion::kUnknown) {
223             LOG_ERROR(&quot;Unexpected protocol version received.&quot;);
224             continue;
225         }
226 
227         if (!protocolVersions.insert(protocol).second)
228             return WTF::nullopt;
229     }
230     if (protocolVersions.empty())
231         return WTF::nullopt;
232 
233     it = responseMap.find(CBOR(3));
234     if (it == responseMap.end() || !it-&gt;second.isByteString() || it-&gt;second.getByteString().size() != aaguidLength)
235         return WTF::nullopt;
236 
237     AuthenticatorGetInfoResponse response(WTFMove(protocolVersions), Vector&lt;uint8_t&gt;(it-&gt;second.getByteString()));
238 
239     it = responseMap.find(CBOR(2));
240     if (it != responseMap.end()) {
241         if (!it-&gt;second.isArray())
242             return WTF::nullopt;
243 
244         Vector&lt;String&gt; extensions;
245         for (const auto&amp; extension : it-&gt;second.getArray()) {
246             if (!extension.isString())
247                 return WTF::nullopt;
248 
249             extensions.append(extension.getString());
250         }
251         response.setExtensions(WTFMove(extensions));
252     }
253 
254     AuthenticatorSupportedOptions options;
255     it = responseMap.find(CBOR(4));
256     if (it != responseMap.end()) {
257         if (!it-&gt;second.isMap())
258             return WTF::nullopt;
259         const auto&amp; optionMap = it-&gt;second.getMap();
260         auto optionMapIt = optionMap.find(CBOR(kPlatformDeviceMapKey));
261         if (optionMapIt != optionMap.end()) {
262             if (!optionMapIt-&gt;second.isBool())
263                 return WTF::nullopt;
264 
265             options.setIsPlatformDevice(optionMapIt-&gt;second.getBool());
266         }
267 
268         optionMapIt = optionMap.find(CBOR(kResidentKeyMapKey));
269         if (optionMapIt != optionMap.end()) {
270             if (!optionMapIt-&gt;second.isBool())
271                 return WTF::nullopt;
272 
273             options.setSupportsResidentKey(optionMapIt-&gt;second.getBool());
274         }
275 
276         optionMapIt = optionMap.find(CBOR(kUserPresenceMapKey));
277         if (optionMapIt != optionMap.end()) {
278             if (!optionMapIt-&gt;second.isBool())
279                 return WTF::nullopt;
280 
281             options.setUserPresenceRequired(optionMapIt-&gt;second.getBool());
282         }
283 
284         optionMapIt = optionMap.find(CBOR(kUserVerificationMapKey));
285         if (optionMapIt != optionMap.end()) {
286             if (!optionMapIt-&gt;second.isBool())
287                 return WTF::nullopt;
288 
289             if (optionMapIt-&gt;second.getBool())
290                 options.setUserVerificationAvailability(AuthenticatorSupportedOptions::UserVerificationAvailability::kSupportedAndConfigured);
291             else
292                 options.setUserVerificationAvailability(AuthenticatorSupportedOptions::UserVerificationAvailability::kSupportedButNotConfigured);
293         }
294 
295         optionMapIt = optionMap.find(CBOR(kClientPinMapKey));
296         if (optionMapIt != optionMap.end()) {
297             if (!optionMapIt-&gt;second.isBool())
298                 return WTF::nullopt;
299 
300             if (optionMapIt-&gt;second.getBool())
301                 options.setClientPinAvailability(AuthenticatorSupportedOptions::ClientPinAvailability::kSupportedAndPinSet);
302             else
303                 options.setClientPinAvailability(AuthenticatorSupportedOptions::ClientPinAvailability::kSupportedButPinNotSet);
304         }
305         response.setOptions(WTFMove(options));
306     }
307 
308     it = responseMap.find(CBOR(5));
309     if (it != responseMap.end()) {
310         if (!it-&gt;second.isUnsigned())
311             return WTF::nullopt;
312 
313         response.setMaxMsgSize(it-&gt;second.getUnsigned());
314     }
315 
316     it = responseMap.find(CBOR(6));
317     if (it != responseMap.end()) {
318         if (!it-&gt;second.isArray())
319             return WTF::nullopt;
320 
321         Vector&lt;uint8_t&gt; supportedPinProtocols;
322         for (const auto&amp; protocol : it-&gt;second.getArray()) {
323             if (!protocol.isUnsigned())
324                 return WTF::nullopt;
325 
326             supportedPinProtocols.append(protocol.getUnsigned());
327         }
328         response.setPinProtocols(WTFMove(supportedPinProtocols));
329     }
330 
331     return WTFMove(response);
332 }
333 
334 } // namespace fido
335 
336 #endif // ENABLE(WEB_AUTHN)
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
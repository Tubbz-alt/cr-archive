<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../inlineformatting/text/TextUtil.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutBox.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 

 31 #include &quot;LayoutContainer.h&quot;
 32 #include &quot;LayoutPhase.h&quot;

 33 #include &quot;RenderStyle.h&quot;
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 
 36 namespace WebCore {
 37 namespace Layout {
 38 
 39 WTF_MAKE_ISO_ALLOCATED_IMPL(Box);
 40 
<span class="line-modified"> 41 Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)</span>
 42     : m_style(WTFMove(style))
 43     , m_elementAttributes(attributes)

 44     , m_baseTypeFlags(baseTypeFlags)
 45     , m_hasRareData(false)
 46     , m_isAnonymous(false)
 47 {
 48     if (isReplaced())
 49         ensureRareData().replaced = makeUnique&lt;Replaced&gt;(*this);
 50 }
 51 
 52 Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style)
<span class="line-modified"> 53     : Box(attributes, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 54 {
 55 }
 56 
<span class="line-modified"> 57 Box::Box(String textContent, RenderStyle&amp;&amp; style)</span>
<span class="line-modified"> 58     : Box({ }, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 59 {
<span class="line-modified"> 60     setTextContent(textContent);</span>
 61 }
 62 
 63 Box::~Box()
 64 {
<span class="line-modified"> 65     removeRareData();</span>






 66 }
 67 
 68 bool Box::establishesFormattingContext() const
 69 {
 70     // We need the final tree structure to tell whether a box establishes a certain formatting context.
 71     ASSERT(!Phase::isInTreeBuilding());
<span class="line-modified"> 72     return establishesBlockFormattingContext() || establishesInlineFormattingContext() || establishesTableFormattingContext();</span>
 73 }
 74 
 75 bool Box::establishesBlockFormattingContext() const
 76 {
 77     // Initial Containing Block always creates a new (inital) block formatting context.
 78     if (!parent())
 79         return true;
 80 
 81     // 9.4.1 Block formatting contexts
 82     // Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions)
 83     // that are not block boxes, and block boxes with &#39;overflow&#39; other than &#39;visible&#39; (except when that value has been propagated to the viewport)
 84     // establish new block formatting contexts for their contents.
 85     if (isFloatingPositioned() || isAbsolutelyPositioned())
 86         return true;
 87 
 88     if (isBlockContainerBox() &amp;&amp; !isBlockLevelBox())
 89         return true;
 90 
 91     if (isBlockLevelBox() &amp;&amp; !isOverflowVisible())
 92         return true;
 93 



 94     return false;
 95 }
 96 
 97 bool Box::establishesInlineFormattingContext() const
 98 {
 99     // 9.4.2 Inline formatting contexts
100     // An inline formatting context is established by a block container box that contains no block-level boxes.
101     if (!isBlockContainerBox())
102         return false;
103 
104     if (!isContainer())
105         return false;
106 
107     // FIXME ???
108     if (!downcast&lt;Container&gt;(*this).firstInFlowChild())
109         return false;
110 
111     // It&#39;s enough to check the first in-flow child since we can&#39;t have both block and inline level sibling boxes.
112     return downcast&lt;Container&gt;(*this).firstInFlowChild()-&gt;isInlineLevelBox();
113 }
114 
<span class="line-removed">115 bool Box::establishesInlineFormattingContextOnly() const</span>
<span class="line-removed">116 {</span>
<span class="line-removed">117     return establishesInlineFormattingContext() &amp;&amp; !establishesBlockFormattingContext();</span>
<span class="line-removed">118 }</span>
<span class="line-removed">119 </span>
120 bool Box::establishesTableFormattingContext() const
121 {
122     return isTableBox();
123 }
124 
<span class="line-modified">125 bool Box::establishesBlockFormattingContextOnly() const</span>
126 {
<span class="line-modified">127     return establishesBlockFormattingContext() &amp;&amp; !establishesInlineFormattingContext();</span>

128 }
129 
130 bool Box::isRelativelyPositioned() const
131 {
132     return m_style.position() == PositionType::Relative;
133 }
134 
135 bool Box::isStickyPositioned() const
136 {
137     return m_style.position() == PositionType::Sticky;
138 }
139 
140 bool Box::isAbsolutelyPositioned() const
141 {
142     return m_style.position() == PositionType::Absolute || isFixedPositioned();
143 }
144 
145 bool Box::isFixedPositioned() const
146 {
147     return m_style.position() == PositionType::Fixed;
</pre>
<hr />
<pre>
159 {
160     if (!isFloatingPositioned())
161         return false;
162     return m_style.floating() == Float::Left;
163 }
164 
165 bool Box::isRightFloatingPositioned() const
166 {
167     if (!isFloatingPositioned())
168         return false;
169     return m_style.floating() == Float::Right;
170 }
171 
172 bool Box::hasFloatClear() const
173 {
174     return m_style.clear() != Clear::None;
175 }
176 
177 bool Box::isFloatAvoider() const
178 {
<span class="line-modified">179     return establishesBlockFormattingContext() || isFloatingPositioned();</span>

180 }
181 
182 const Container* Box::containingBlock() const
183 {
184     // Finding the containing block by traversing the tree during tree construction could provide incorrect result.
185     ASSERT(!Phase::isInTreeBuilding());
186     // The containing block in which the root element lives is a rectangle called the initial containing block.
187     // For other elements, if the element&#39;s position is &#39;relative&#39; or &#39;static&#39;, the containing block is formed by the
<span class="line-modified">188     // content edge of the nearest block container ancestor box.</span>
189     // If the element has &#39;position: fixed&#39;, the containing block is established by the viewport
190     // If the element has &#39;position: absolute&#39;, the containing block is established by the nearest ancestor with a
191     // &#39;position&#39; of &#39;absolute&#39;, &#39;relative&#39; or &#39;fixed&#39;.
192     if (!parent())
193         return nullptr;
194 
195     if (!isPositioned() || isInFlowPositioned()) {
<span class="line-modified">196         auto* nearestBlockContainer = parent();</span>
<span class="line-modified">197         for (; nearestBlockContainer-&gt;parent() &amp;&amp; !nearestBlockContainer-&gt;isBlockContainerBox(); nearestBlockContainer = nearestBlockContainer-&gt;parent()) { }</span>
<span class="line-modified">198         return nearestBlockContainer;</span>




199     }
200 
201     if (isFixedPositioned()) {
202         auto* ancestor = parent();
203         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
204         return ancestor;
205     }
206 
207     if (isOutOfFlowPositioned()) {
208         auto* ancestor = parent();
209         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;isPositioned() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
210         return ancestor;
211     }
212 
213     ASSERT_NOT_REACHED();
214     return nullptr;
215 }
216 
217 const Container&amp; Box::formattingContextRoot() const
218 {
</pre>
<hr />
<pre>
255         if (ancestor == &amp;ancestorCandidate)
256             return true;
257     }
258     return false;
259 }
260 
261 bool Box::isContainingBlockDescendantOf(const Container&amp; ancestorCandidate) const
262 {
263     for (auto* ancestor = containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
264         if (ancestor == &amp;ancestorCandidate)
265             return true;
266     }
267     return false;
268 }
269 
270 bool Box::isInlineBlockBox() const
271 {
272     return m_style.display() == DisplayType::InlineBlock;
273 }
274 





275 bool Box::isBlockLevelBox() const
276 {
277     // Block level elements generate block level boxes.
278     auto display = m_style.display();
<span class="line-modified">279     return display == DisplayType::Block || display == DisplayType::ListItem || (display == DisplayType::Table &amp;&amp; !isTableWrapperBox());</span>
280 }
281 
282 bool Box::isInlineLevelBox() const
283 {
284     // Inline level elements generate inline level boxes.
285     auto display = m_style.display();
<span class="line-modified">286     return display == DisplayType::Inline || isInlineBlockBox() || display == DisplayType::InlineTable;</span>














287 }
288 
289 bool Box::isBlockContainerBox() const
290 {
291     auto display = m_style.display();
292     return display == DisplayType::Block || display == DisplayType::ListItem || isInlineBlockBox() || isTableWrapperBox() || isTableCell() || isTableCaption(); // TODO &amp;&amp; !replaced element
293 }
294 
295 bool Box::isInitialContainingBlock() const
296 {
297     return !parent();
298 }
299 
300 const Box* Box::nextInFlowSibling() const
301 {
302     auto* nextSibling = this-&gt;nextSibling();
303     while (nextSibling &amp;&amp; !nextSibling-&gt;isInFlow())
304         nextSibling = nextSibling-&gt;nextSibling();
305     return nextSibling;
306 }
</pre>
<hr />
<pre>
349     if (isInitialContainingBlock()) {
350         auto* documentBox = downcast&lt;Container&gt;(*this).firstChild();
351         if (!documentBox || !documentBox-&gt;isDocumentBox() || !is&lt;Container&gt;(documentBox))
352             return isOverflowVisible;
353         auto* bodyBox = downcast&lt;Container&gt;(documentBox)-&gt;firstChild();
354         if (!bodyBox || !bodyBox-&gt;isBodyBox())
355             return isOverflowVisible;
356         auto&amp; bodyBoxStyle = bodyBox-&gt;style();
357         return bodyBoxStyle.overflowX() == Overflow::Visible || bodyBoxStyle.overflowY() == Overflow::Visible;
358     }
359     return isOverflowVisible;
360 }
361 
362 bool Box::isPaddingApplicable() const
363 {
364     // 8.4 Padding properties:
365     // Applies to: all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column
366     if (isAnonymous())
367         return false;
368 
<span class="line-modified">369     auto elementType = m_elementAttributes.value().elementType;</span>
<span class="line-modified">370     return elementType != ElementType::TableHeaderGroup</span>
<span class="line-modified">371         &amp;&amp; elementType != ElementType::TableBodyGroup</span>
<span class="line-modified">372         &amp;&amp; elementType != ElementType::TableFooterGroup</span>
<span class="line-modified">373         &amp;&amp; elementType != ElementType::TableRow</span>
<span class="line-modified">374         &amp;&amp; elementType != ElementType::TableColumnGroup</span>
<span class="line-removed">375         &amp;&amp; elementType != ElementType::TableColumn;</span>
<span class="line-removed">376 }</span>
<span class="line-removed">377 </span>
<span class="line-removed">378 void Box::setTextContent(String textContent)</span>
<span class="line-removed">379 {</span>
<span class="line-removed">380     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">381     ensureRareData().textContent = textContent;</span>
<span class="line-removed">382 }</span>
<span class="line-removed">383 </span>
<span class="line-removed">384 bool Box::hasTextContent() const</span>
<span class="line-removed">385 {</span>
<span class="line-removed">386     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">387     return hasRareData() &amp;&amp; !rareData().textContent.isNull();</span>
<span class="line-removed">388 }</span>
<span class="line-removed">389 </span>
<span class="line-removed">390 String Box::textContent() const</span>
<span class="line-removed">391 {</span>
<span class="line-removed">392     ASSERT(hasRareData());</span>
<span class="line-removed">393     ASSERT(isInlineLevelBox());</span>
<span class="line-removed">394     return rareData().textContent;</span>
395 }
396 
397 const Replaced* Box::replaced() const
398 {
399     return const_cast&lt;Box*&gt;(this)-&gt;replaced();
400 }
401 
402 Replaced* Box::replaced()
403 {
404     if (!isReplaced()) {
405         ASSERT(!hasRareData() || !rareData().replaced.get());
406         return nullptr;
407     }
408     ASSERT(hasRareData() &amp;&amp; rareData().replaced.get());
409     return rareData().replaced.get();
410 }
411 
412 void Box::setRowSpan(unsigned rowSpan)
413 {
414     ensureRareData().rowSpan = rowSpan;
</pre>
<hr />
<pre>
416 
417 void Box::setColumnSpan(unsigned columnSpan)
418 {
419     ensureRareData().columnSpan = columnSpan;
420 }
421 
422 unsigned Box::rowSpan() const
423 {
424     if (!hasRareData())
425         return 1;
426     return rareData().rowSpan;
427 }
428 
429 unsigned Box::columnSpan() const
430 {
431     if (!hasRareData())
432         return 1;
433     return rareData().columnSpan;
434 }
435 



















436 Box::RareDataMap&amp; Box::rareDataMap()
437 {
438     static NeverDestroyed&lt;RareDataMap&gt; map;
439     return map;
440 }
441 
442 const Box::BoxRareData&amp; Box::rareData() const
443 {
444     ASSERT(hasRareData());
445     return *rareDataMap().get(this);
446 }
447 
448 Box::BoxRareData&amp; Box::ensureRareData()
449 {
450     setHasRareData(true);
451     return *rareDataMap().ensure(this, [] { return makeUnique&lt;BoxRareData&gt;(); }).iterator-&gt;value;
452 }
453 
454 void Box::removeRareData()
455 {
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LayoutBox.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<span class="line-added"> 31 #include &quot;DisplayBox.h&quot;</span>
 32 #include &quot;LayoutContainer.h&quot;
 33 #include &quot;LayoutPhase.h&quot;
<span class="line-added"> 34 #include &quot;LayoutState.h&quot;</span>
 35 #include &quot;RenderStyle.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 namespace WebCore {
 39 namespace Layout {
 40 
 41 WTF_MAKE_ISO_ALLOCATED_IMPL(Box);
 42 
<span class="line-modified"> 43 Box::Box(Optional&lt;ElementAttributes&gt; attributes, Optional&lt;TextContext&gt; textContext, RenderStyle&amp;&amp; style, BaseTypeFlags baseTypeFlags)</span>
 44     : m_style(WTFMove(style))
 45     , m_elementAttributes(attributes)
<span class="line-added"> 46     , m_textContext(textContext)</span>
 47     , m_baseTypeFlags(baseTypeFlags)
 48     , m_hasRareData(false)
 49     , m_isAnonymous(false)
 50 {
 51     if (isReplaced())
 52         ensureRareData().replaced = makeUnique&lt;Replaced&gt;(*this);
 53 }
 54 
 55 Box::Box(Optional&lt;ElementAttributes&gt; attributes, RenderStyle&amp;&amp; style)
<span class="line-modified"> 56     : Box(attributes, { }, WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 57 {
 58 }
 59 
<span class="line-modified"> 60 Box::Box(TextContext&amp;&amp; textContext, RenderStyle&amp;&amp; style)</span>
<span class="line-modified"> 61     : Box({ }, WTFMove(textContext), WTFMove(style), BaseTypeFlag::BoxFlag)</span>
 62 {
<span class="line-modified"> 63     ASSERT(isInlineLevelBox());</span>
 64 }
 65 
 66 Box::~Box()
 67 {
<span class="line-modified"> 68     if (UNLIKELY(m_hasRareData))</span>
<span class="line-added"> 69         removeRareData();</span>
<span class="line-added"> 70 }</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72 void Box::updateStyle(const RenderStyle&amp; newStyle)</span>
<span class="line-added"> 73 {</span>
<span class="line-added"> 74     m_style = RenderStyle::clone(newStyle);</span>
 75 }
 76 
 77 bool Box::establishesFormattingContext() const
 78 {
 79     // We need the final tree structure to tell whether a box establishes a certain formatting context.
 80     ASSERT(!Phase::isInTreeBuilding());
<span class="line-modified"> 81     return establishesBlockFormattingContext() || establishesInlineFormattingContext() || establishesTableFormattingContext() || establishesIndependentFormattingContext();</span>
 82 }
 83 
 84 bool Box::establishesBlockFormattingContext() const
 85 {
 86     // Initial Containing Block always creates a new (inital) block formatting context.
 87     if (!parent())
 88         return true;
 89 
 90     // 9.4.1 Block formatting contexts
 91     // Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions)
 92     // that are not block boxes, and block boxes with &#39;overflow&#39; other than &#39;visible&#39; (except when that value has been propagated to the viewport)
 93     // establish new block formatting contexts for their contents.
 94     if (isFloatingPositioned() || isAbsolutelyPositioned())
 95         return true;
 96 
 97     if (isBlockContainerBox() &amp;&amp; !isBlockLevelBox())
 98         return true;
 99 
100     if (isBlockLevelBox() &amp;&amp; !isOverflowVisible())
101         return true;
102 
<span class="line-added">103     if (isTableWrapperBox())</span>
<span class="line-added">104         return true;</span>
<span class="line-added">105 </span>
106     return false;
107 }
108 
109 bool Box::establishesInlineFormattingContext() const
110 {
111     // 9.4.2 Inline formatting contexts
112     // An inline formatting context is established by a block container box that contains no block-level boxes.
113     if (!isBlockContainerBox())
114         return false;
115 
116     if (!isContainer())
117         return false;
118 
119     // FIXME ???
120     if (!downcast&lt;Container&gt;(*this).firstInFlowChild())
121         return false;
122 
123     // It&#39;s enough to check the first in-flow child since we can&#39;t have both block and inline level sibling boxes.
124     return downcast&lt;Container&gt;(*this).firstInFlowChild()-&gt;isInlineLevelBox();
125 }
126 





127 bool Box::establishesTableFormattingContext() const
128 {
129     return isTableBox();
130 }
131 
<span class="line-modified">132 bool Box::establishesIndependentFormattingContext() const</span>
133 {
<span class="line-modified">134     // FIXME: This is where we would check for &#39;contain&#39; property.</span>
<span class="line-added">135     return isAbsolutelyPositioned();</span>
136 }
137 
138 bool Box::isRelativelyPositioned() const
139 {
140     return m_style.position() == PositionType::Relative;
141 }
142 
143 bool Box::isStickyPositioned() const
144 {
145     return m_style.position() == PositionType::Sticky;
146 }
147 
148 bool Box::isAbsolutelyPositioned() const
149 {
150     return m_style.position() == PositionType::Absolute || isFixedPositioned();
151 }
152 
153 bool Box::isFixedPositioned() const
154 {
155     return m_style.position() == PositionType::Fixed;
</pre>
<hr />
<pre>
167 {
168     if (!isFloatingPositioned())
169         return false;
170     return m_style.floating() == Float::Left;
171 }
172 
173 bool Box::isRightFloatingPositioned() const
174 {
175     if (!isFloatingPositioned())
176         return false;
177     return m_style.floating() == Float::Right;
178 }
179 
180 bool Box::hasFloatClear() const
181 {
182     return m_style.clear() != Clear::None;
183 }
184 
185 bool Box::isFloatAvoider() const
186 {
<span class="line-modified">187     return (establishesBlockFormattingContext() &amp;&amp; !establishesInlineFormattingContext())</span>
<span class="line-added">188         || establishesTableFormattingContext() || establishesIndependentFormattingContext() || hasFloatClear();</span>
189 }
190 
191 const Container* Box::containingBlock() const
192 {
193     // Finding the containing block by traversing the tree during tree construction could provide incorrect result.
194     ASSERT(!Phase::isInTreeBuilding());
195     // The containing block in which the root element lives is a rectangle called the initial containing block.
196     // For other elements, if the element&#39;s position is &#39;relative&#39; or &#39;static&#39;, the containing block is formed by the
<span class="line-modified">197     // content edge of the nearest block container ancestor box or which establishes a formatting context.</span>
198     // If the element has &#39;position: fixed&#39;, the containing block is established by the viewport
199     // If the element has &#39;position: absolute&#39;, the containing block is established by the nearest ancestor with a
200     // &#39;position&#39; of &#39;absolute&#39;, &#39;relative&#39; or &#39;fixed&#39;.
201     if (!parent())
202         return nullptr;
203 
204     if (!isPositioned() || isInFlowPositioned()) {
<span class="line-modified">205         for (auto* nearestBlockContainerOrFormattingContextRoot = parent(); nearestBlockContainerOrFormattingContextRoot; nearestBlockContainerOrFormattingContextRoot = nearestBlockContainerOrFormattingContextRoot-&gt;parent()) {</span>
<span class="line-modified">206             if (nearestBlockContainerOrFormattingContextRoot-&gt;isBlockContainerBox() || nearestBlockContainerOrFormattingContextRoot-&gt;establishesFormattingContext())</span>
<span class="line-modified">207                 return nearestBlockContainerOrFormattingContextRoot;</span>
<span class="line-added">208         }</span>
<span class="line-added">209         // We should always manage to find the ICB.</span>
<span class="line-added">210         ASSERT_NOT_REACHED();</span>
<span class="line-added">211         return nullptr;</span>
212     }
213 
214     if (isFixedPositioned()) {
215         auto* ancestor = parent();
216         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
217         return ancestor;
218     }
219 
220     if (isOutOfFlowPositioned()) {
221         auto* ancestor = parent();
222         for (; ancestor-&gt;parent() &amp;&amp; !ancestor-&gt;isPositioned() &amp;&amp; !ancestor-&gt;style().hasTransform(); ancestor = ancestor-&gt;parent()) { }
223         return ancestor;
224     }
225 
226     ASSERT_NOT_REACHED();
227     return nullptr;
228 }
229 
230 const Container&amp; Box::formattingContextRoot() const
231 {
</pre>
<hr />
<pre>
268         if (ancestor == &amp;ancestorCandidate)
269             return true;
270     }
271     return false;
272 }
273 
274 bool Box::isContainingBlockDescendantOf(const Container&amp; ancestorCandidate) const
275 {
276     for (auto* ancestor = containingBlock(); ancestor; ancestor = ancestor-&gt;containingBlock()) {
277         if (ancestor == &amp;ancestorCandidate)
278             return true;
279     }
280     return false;
281 }
282 
283 bool Box::isInlineBlockBox() const
284 {
285     return m_style.display() == DisplayType::InlineBlock;
286 }
287 
<span class="line-added">288 bool Box::isInlineTableBox() const</span>
<span class="line-added">289 {</span>
<span class="line-added">290     return m_style.display() == DisplayType::InlineTable;</span>
<span class="line-added">291 }</span>
<span class="line-added">292 </span>
293 bool Box::isBlockLevelBox() const
294 {
295     // Block level elements generate block level boxes.
296     auto display = m_style.display();
<span class="line-modified">297     return display == DisplayType::Block || display == DisplayType::ListItem || display == DisplayType::Table;</span>
298 }
299 
300 bool Box::isInlineLevelBox() const
301 {
302     // Inline level elements generate inline level boxes.
303     auto display = m_style.display();
<span class="line-modified">304     return display == DisplayType::Inline || isInlineBlockBox() || isInlineTableBox();</span>
<span class="line-added">305 }</span>
<span class="line-added">306 </span>
<span class="line-added">307 bool Box::isInlineBox() const</span>
<span class="line-added">308 {</span>
<span class="line-added">309     // An inline box is one that is both inline-level and whose contents participate in its containing inline formatting context.</span>
<span class="line-added">310     // A non-replaced element with a &#39;display&#39; value of &#39;inline&#39; generates an inline box.</span>
<span class="line-added">311     return m_style.display() == DisplayType::Inline &amp;&amp; !isReplaced();</span>
<span class="line-added">312 }</span>
<span class="line-added">313 </span>
<span class="line-added">314 bool Box::isAtomicInlineLevelBox() const</span>
<span class="line-added">315 {</span>
<span class="line-added">316     // Inline-level boxes that are not inline boxes (such as replaced inline-level elements, inline-block elements, and inline-table elements)</span>
<span class="line-added">317     // are called atomic inline-level boxes because they participate in their inline formatting context as a single opaque box.</span>
<span class="line-added">318     return isInlineLevelBox() &amp;&amp; !isInlineBox();</span>
319 }
320 
321 bool Box::isBlockContainerBox() const
322 {
323     auto display = m_style.display();
324     return display == DisplayType::Block || display == DisplayType::ListItem || isInlineBlockBox() || isTableWrapperBox() || isTableCell() || isTableCaption(); // TODO &amp;&amp; !replaced element
325 }
326 
327 bool Box::isInitialContainingBlock() const
328 {
329     return !parent();
330 }
331 
332 const Box* Box::nextInFlowSibling() const
333 {
334     auto* nextSibling = this-&gt;nextSibling();
335     while (nextSibling &amp;&amp; !nextSibling-&gt;isInFlow())
336         nextSibling = nextSibling-&gt;nextSibling();
337     return nextSibling;
338 }
</pre>
<hr />
<pre>
381     if (isInitialContainingBlock()) {
382         auto* documentBox = downcast&lt;Container&gt;(*this).firstChild();
383         if (!documentBox || !documentBox-&gt;isDocumentBox() || !is&lt;Container&gt;(documentBox))
384             return isOverflowVisible;
385         auto* bodyBox = downcast&lt;Container&gt;(documentBox)-&gt;firstChild();
386         if (!bodyBox || !bodyBox-&gt;isBodyBox())
387             return isOverflowVisible;
388         auto&amp; bodyBoxStyle = bodyBox-&gt;style();
389         return bodyBoxStyle.overflowX() == Overflow::Visible || bodyBoxStyle.overflowY() == Overflow::Visible;
390     }
391     return isOverflowVisible;
392 }
393 
394 bool Box::isPaddingApplicable() const
395 {
396     // 8.4 Padding properties:
397     // Applies to: all elements except table-row-group, table-header-group, table-footer-group, table-row, table-column-group and table-column
398     if (isAnonymous())
399         return false;
400 
<span class="line-modified">401     return !isTableHeader()</span>
<span class="line-modified">402         &amp;&amp; !isTableBody()</span>
<span class="line-modified">403         &amp;&amp; !isTableFooter()</span>
<span class="line-modified">404         &amp;&amp; !isTableRow()</span>
<span class="line-modified">405         &amp;&amp; !isTableColumnGroup()</span>
<span class="line-modified">406         &amp;&amp; !isTableColumn();</span>




















407 }
408 
409 const Replaced* Box::replaced() const
410 {
411     return const_cast&lt;Box*&gt;(this)-&gt;replaced();
412 }
413 
414 Replaced* Box::replaced()
415 {
416     if (!isReplaced()) {
417         ASSERT(!hasRareData() || !rareData().replaced.get());
418         return nullptr;
419     }
420     ASSERT(hasRareData() &amp;&amp; rareData().replaced.get());
421     return rareData().replaced.get();
422 }
423 
424 void Box::setRowSpan(unsigned rowSpan)
425 {
426     ensureRareData().rowSpan = rowSpan;
</pre>
<hr />
<pre>
428 
429 void Box::setColumnSpan(unsigned columnSpan)
430 {
431     ensureRareData().columnSpan = columnSpan;
432 }
433 
434 unsigned Box::rowSpan() const
435 {
436     if (!hasRareData())
437         return 1;
438     return rareData().rowSpan;
439 }
440 
441 unsigned Box::columnSpan() const
442 {
443     if (!hasRareData())
444         return 1;
445     return rareData().columnSpan;
446 }
447 
<span class="line-added">448 void Box::setColumnWidth(LayoutUnit columnWidth)</span>
<span class="line-added">449 {</span>
<span class="line-added">450     ensureRareData().columnWidth = columnWidth;</span>
<span class="line-added">451 }</span>
<span class="line-added">452 </span>
<span class="line-added">453 Optional&lt;LayoutUnit&gt; Box::columnWidth() const</span>
<span class="line-added">454 {</span>
<span class="line-added">455     if (!hasRareData())</span>
<span class="line-added">456         return { };</span>
<span class="line-added">457     return rareData().columnWidth;</span>
<span class="line-added">458 }</span>
<span class="line-added">459 </span>
<span class="line-added">460 void Box::setCachedDisplayBoxForLayoutState(LayoutState&amp; layoutState, std::unique_ptr&lt;Display::Box&gt; box) const</span>
<span class="line-added">461 {</span>
<span class="line-added">462     ASSERT(!m_cachedLayoutState);</span>
<span class="line-added">463     m_cachedLayoutState = makeWeakPtr(layoutState);</span>
<span class="line-added">464     m_cachedDisplayBoxForLayoutState = WTFMove(box);</span>
<span class="line-added">465 }</span>
<span class="line-added">466 </span>
467 Box::RareDataMap&amp; Box::rareDataMap()
468 {
469     static NeverDestroyed&lt;RareDataMap&gt; map;
470     return map;
471 }
472 
473 const Box::BoxRareData&amp; Box::rareData() const
474 {
475     ASSERT(hasRareData());
476     return *rareDataMap().get(this);
477 }
478 
479 Box::BoxRareData&amp; Box::ensureRareData()
480 {
481     setHasRareData(true);
482     return *rareDataMap().ensure(this, [] { return makeUnique&lt;BoxRareData&gt;(); }).iterator-&gt;value;
483 }
484 
485 void Box::removeRareData()
486 {
</pre>
</td>
</tr>
</table>
<center><a href="../inlineformatting/text/TextUtil.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
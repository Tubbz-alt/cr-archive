<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedRawResourceClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResource.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -36,18 +36,19 @@</span>
  #include &quot;DocumentLoader.h&quot;
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;HTTPHeaderNames.h&quot;
<span class="udiff-line-added">+ #include &quot;HTTPHeaderValues.h&quot;</span>
  #include &quot;InspectorInstrumentation.h&quot;
<span class="udiff-line-added">+ #include &quot;LegacySchemeRegistry.h&quot;</span>
  #include &quot;LoaderStrategy.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;MemoryCache.h&quot;
  #include &quot;PlatformStrategies.h&quot;
  #include &quot;ProgressTracker.h&quot;
  #include &quot;ResourceHandle.h&quot;
<span class="udiff-line-removed">- #include &quot;SchemeRegistry.h&quot;</span>
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SubresourceLoader.h&quot;
  #include &lt;wtf/CompletionHandler.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/RefCountedLeakCounter.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62,10 +63,12 @@</span>
  
  #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(cachedResourceLoader.isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResource::&quot; fmt, this, ##__VA_ARGS__)
  
  namespace WebCore {
  
<span class="udiff-line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CachedResource);</span>
<span class="udiff-line-added">+ </span>
  ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)
  {
      switch (type) {
      case Type::MainResource:
          return ResourceLoadPriority::VeryHigh;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -124,14 +127,21 @@</span>
      , m_cookieJar(cookieJar)
      , m_responseTimestamp(WallTime::now())
      , m_fragmentIdentifierForRequest(request.releaseFragmentIdentifier())
      , m_origin(request.releaseOrigin())
      , m_initiatorName(request.initiatorName())
<span class="udiff-line-removed">-     , m_loadPriority(defaultPriorityForResourceType(type))</span>
      , m_type(type)
<span class="udiff-line-added">+     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="udiff-line-added">+     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="udiff-line-added">+     , m_loadPriority(defaultPriorityForResourceType(type))</span>
<span class="udiff-line-added">+     , m_status(Pending)</span>
<span class="udiff-line-added">+     , m_requestedFromNetworkingLayer(false)</span>
<span class="udiff-line-added">+     , m_inCache(false)</span>
<span class="udiff-line-added">+     , m_loading(false)</span>
      , m_isLinkPreload(request.isLinkPreload())
      , m_hasUnknownEncoding(request.isLinkPreload())
<span class="udiff-line-added">+     , m_switchingClientsToRevalidatedResource(false)</span>
      , m_ignoreForRequestCount(request.ignoreForRequestCount())
  {
      ASSERT(m_sessionID.isValid());
  
      setLoadPriority(request.priority());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,12 +162,21 @@</span>
      , m_decodedDataDeletionTimer(*this, &amp;CachedResource::destroyDecodedData, deadDecodedDataDeletionIntervalForResourceType(type))
      , m_sessionID(sessionID)
      , m_cookieJar(cookieJar)
      , m_responseTimestamp(WallTime::now())
      , m_fragmentIdentifierForRequest(CachedResourceRequest::splitFragmentIdentifierFromRequestURL(m_resourceRequest))
<span class="udiff-line-removed">-     , m_status(Cached)</span>
      , m_type(type)
<span class="udiff-line-added">+     , m_preloadResult(PreloadResult::PreloadNotReferenced)</span>
<span class="udiff-line-added">+     , m_responseTainting(ResourceResponse::Tainting::Basic)</span>
<span class="udiff-line-added">+     , m_status(Cached)</span>
<span class="udiff-line-added">+     , m_requestedFromNetworkingLayer(false)</span>
<span class="udiff-line-added">+     , m_inCache(false)</span>
<span class="udiff-line-added">+     , m_loading(false)</span>
<span class="udiff-line-added">+     , m_isLinkPreload(false)</span>
<span class="udiff-line-added">+     , m_hasUnknownEncoding(false)</span>
<span class="udiff-line-added">+     , m_switchingClientsToRevalidatedResource(false)</span>
<span class="udiff-line-added">+     , m_ignoreForRequestCount(false)</span>
  {
      ASSERT(m_sessionID.isValid());
  #ifndef NDEBUG
      cachedResourceLeakCounter.increment();
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -193,27 +212,27 @@</span>
          failBeforeStarting();
          return;
      }
      Frame&amp; frame = *cachedResourceLoader.frame();
  
<span class="udiff-line-modified-removed">-     // Prevent new loads if we are in the PageCache or being added to the PageCache.</span>
<span class="udiff-line-modified-added">+     // Prevent new loads if we are in the BackForwardCache or being added to the BackForwardCache.</span>
      // We query the top document because new frames may be created in pagehide event handlers
<span class="udiff-line-modified-removed">-     // and their pageCacheState will not reflect the fact that they are about to enter page</span>
<span class="udiff-line-modified-added">+     // and their backForwardCacheState will not reflect the fact that they are about to enter page</span>
      // cache.
      if (auto* topDocument = frame.mainFrame().document()) {
<span class="udiff-line-modified-removed">-         switch (topDocument-&gt;pageCacheState()) {</span>
<span class="udiff-line-modified-removed">-         case Document::NotInPageCache:</span>
<span class="udiff-line-modified-added">+         switch (topDocument-&gt;backForwardCacheState()) {</span>
<span class="udiff-line-modified-added">+         case Document::NotInBackForwardCache:</span>
              break;
<span class="udiff-line-modified-removed">-         case Document::AboutToEnterPageCache:</span>
<span class="udiff-line-modified-added">+         case Document::AboutToEnterBackForwardCache:</span>
              // Beacons are allowed to go through in &#39;pagehide&#39; event handlers.
              if (shouldUsePingLoad(type()))
                  break;
<span class="udiff-line-modified-removed">-             RELEASE_LOG_IF_ALLOWED(&quot;load: About to enter page cache (frame = %p)&quot;, &amp;frame);</span>
<span class="udiff-line-modified-added">+             RELEASE_LOG_IF_ALLOWED(&quot;load: About to enter back/forward cache (frame = %p)&quot;, &amp;frame);</span>
              failBeforeStarting();
              return;
<span class="udiff-line-modified-removed">-         case Document::InPageCache:</span>
<span class="udiff-line-modified-removed">-             RELEASE_LOG_IF_ALLOWED(&quot;load: Already in page cache (frame = %p)&quot;, &amp;frame);</span>
<span class="udiff-line-modified-added">+         case Document::InBackForwardCache:</span>
<span class="udiff-line-modified-added">+             RELEASE_LOG_IF_ALLOWED(&quot;load: Already in back/forward cache (frame = %p)&quot;, &amp;frame);</span>
              failBeforeStarting();
              return;
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -242,11 +261,11 @@</span>
          const String&amp; lastModified = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::LastModified);
          const String&amp; eTag = resourceToRevalidate-&gt;response().httpHeaderField(HTTPHeaderName::ETag);
          if (!lastModified.isEmpty() || !eTag.isEmpty()) {
              ASSERT(cachedResourceLoader.cachePolicy(type(), url()) != CachePolicyReload);
              if (cachedResourceLoader.cachePolicy(type(), url()) == CachePolicyRevalidate)
<span class="udiff-line-modified-removed">-                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::CacheControl, &quot;max-age=0&quot;);</span>
<span class="udiff-line-modified-added">+                 m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());</span>
              if (!lastModified.isEmpty())
                  m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfModifiedSince, lastModified);
              if (!eTag.isEmpty())
                  m_resourceRequest.setHTTPHeaderField(HTTPHeaderName::IfNoneMatch, eTag);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -307,11 +326,11 @@</span>
          if (!m_loader) {
              RELEASE_LOG_IF(loggingAllowed, Network, &quot;%p - CachedResource::load: Unable to create SubresourceLoader (frame = %p)&quot;, this, frame.ptr());
              failBeforeStarting();
              return;
          }
<span class="udiff-line-modified-removed">-         m_status = Pending;</span>
<span class="udiff-line-modified-added">+         setStatus(Pending);</span>
      });
  }
  
  void CachedResource::loadFrom(const CachedResource&amp; resource)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -394,11 +413,11 @@</span>
  }
  
  void CachedResource::finish()
  {
      if (!errorOccurred())
<span class="udiff-line-modified-removed">-         m_status = Cached;</span>
<span class="udiff-line-modified-added">+         setStatus(Cached);</span>
  }
  
  void CachedResource::setCrossOrigin()
  {
      ASSERT(m_options.mode != FetchOptions::Mode::SameOrigin);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -452,11 +471,11 @@</span>
          StringView protocol = response.url().protocol();
          if (!shouldCacheSchemeIndefinitely(protocol)) {
              // Don&#39;t cache non-HTTP main resources since we can&#39;t check for freshness.
              // FIXME: We should not cache subresources either, but when we tried this
              // it caused performance and flakiness issues in our test infrastructure.
<span class="udiff-line-modified-removed">-             if (m_type == Type::MainResource || SchemeRegistry::shouldAlwaysRevalidateURLScheme(protocol.toStringWithoutCopying()))</span>
<span class="udiff-line-modified-added">+             if (m_type == Type::MainResource || LegacySchemeRegistry::shouldAlwaysRevalidateURLScheme(protocol.toStringWithoutCopying()))</span>
                  return 0_us;
          }
  
          return Seconds::infinity();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -476,11 +495,11 @@</span>
  
  void CachedResource::setResponse(const ResourceResponse&amp; response)
  {
      ASSERT(m_response.type() == ResourceResponse::Type::Default);
      m_response = response;
<span class="udiff-line-modified-removed">-     m_varyingHeaderValues = collectVaryingRequestHeaders(cookieJar(), m_resourceRequest, m_response, sessionID());</span>
<span class="udiff-line-modified-added">+     m_varyingHeaderValues = collectVaryingRequestHeaders(cookieJar(), m_resourceRequest, m_response);</span>
  
  #if ENABLE(SERVICE_WORKER)
      if (m_response.source() == ResourceResponse::Source::ServiceWorker) {
          m_responseTainting = m_response.tainting();
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -858,31 +877,19 @@</span>
  bool CachedResource::varyHeaderValuesMatch(const ResourceRequest&amp; request)
  {
      if (m_varyingHeaderValues.isEmpty())
          return true;
  
<span class="udiff-line-modified-removed">-     return verifyVaryingRequestHeaders(cookieJar(), m_varyingHeaderValues, request, sessionID());</span>
<span class="udiff-line-modified-added">+     return verifyVaryingRequestHeaders(cookieJar(), m_varyingHeaderValues, request);</span>
  }
  
  unsigned CachedResource::overheadSize() const
  {
      static const int kAverageClientsHashMapSize = 384;
      return sizeof(CachedResource) + m_response.memoryUsage() + kAverageClientsHashMapSize + m_resourceRequest.url().string().length() * 2;
  }
  
<span class="udiff-line-removed">- bool CachedResource::areAllClientsXMLHttpRequests() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (type() != Type::RawResource)</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (auto&amp; client : m_clients) {</span>
<span class="udiff-line-removed">-         if (!client.key-&gt;isXMLHttpRequest())</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void CachedResource::setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp; loadPriority)
  {
      if (loadPriority)
          m_loadPriority = loadPriority.value();
      else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -929,6 +936,16 @@</span>
      didReplaceSharedBufferContents();
  }
  
  #endif
  
<span class="udiff-line-added">+ #if USE(QUICK_LOOK)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void CachedResource::previewResponseReceived(const ResourceResponse&amp; response)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(response.url().protocolIs(QLPreviewProtocol));</span>
<span class="udiff-line-added">+     CachedResource::responseReceived(response);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  }
</pre>
<center><a href="CachedRawResourceClient.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResource.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Region.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010, 2011 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Region.h&quot;
 28 
 29 #include &lt;stdio.h&gt;
 30 #include &lt;wtf/text/TextStream.h&gt;
 31 
 32 // A region class based on the paper &quot;Scanline Coherent Shape Algebra&quot;
 33 // by Jonathan E. Steinhart from the book &quot;Graphics Gems II&quot;.
 34 //
 35 // This implementation uses two vectors instead of linked list, and
 36 // also compresses regions when possible.
 37 
 38 namespace WebCore {
 39 
<a name="1" id="anc1"></a><span class="line-added"> 40 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Region);</span>
<span class="line-added"> 41 </span>
 42 Region::Region()
 43 {
 44 }
 45 
 46 Region::Region(const IntRect&amp; rect)
 47     : m_bounds(rect)
 48 {
 49 }
 50 
 51 Region::Region(const Region&amp; other)
 52     : m_bounds(other.m_bounds)
 53     , m_shape(other.copyShape())
 54 {
 55 }
 56 
 57 Region::Region(Region&amp;&amp; other)
 58     : m_bounds(WTFMove(other.m_bounds))
 59     , m_shape(WTFMove(other.m_shape))
 60 {
 61 }
 62 
 63 Region::~Region()
 64 {
 65 }
 66 
 67 Region&amp; Region::operator=(const Region&amp; other)
 68 {
 69     m_bounds = other.m_bounds;
 70     m_shape = other.copyShape();
 71     return *this;
 72 }
 73 
 74 Region&amp; Region::operator=(Region&amp;&amp; other)
 75 {
 76     m_bounds = WTFMove(other.m_bounds);
 77     m_shape = WTFMove(other.m_shape);
 78     return *this;
 79 }
 80 
 81 Vector&lt;IntRect, 1&gt; Region::rects() const
 82 {
 83     Vector&lt;IntRect, 1&gt; rects;
 84 
 85     if (!m_shape) {
 86         if (!m_bounds.isEmpty())
 87             rects.uncheckedAppend(m_bounds);
 88         return rects;
 89     }
 90 
 91     for (Shape::SpanIterator span = m_shape-&gt;spans_begin(), end = m_shape-&gt;spans_end(); span != end &amp;&amp; span + 1 != end; ++span) {
 92         int y = span-&gt;y;
 93         int height = (span + 1)-&gt;y - y;
 94 
 95         for (Shape::SegmentIterator segment = m_shape-&gt;segments_begin(span), end = m_shape-&gt;segments_end(span); segment != end &amp;&amp; segment + 1 != end; segment += 2) {
 96             int x = *segment;
 97             int width = *(segment + 1) - x;
 98 
 99             rects.append(IntRect(x, y, width, height));
100         }
101     }
102 
103     return rects;
104 }
105 
106 bool Region::contains(const Region&amp; region) const
107 {
108     if (!m_bounds.contains(region.m_bounds))
109         return false;
110 
111     if (!m_shape)
112         return true;
113 
114     return Shape::compareShapes&lt;Shape::CompareContainsOperation&gt;(*m_shape, region.m_shape ? *region.m_shape : Shape(region.m_bounds));
115 }
116 
117 bool Region::contains(const IntPoint&amp; point) const
118 {
119     if (!m_bounds.contains(point))
120         return false;
121 
122     if (!m_shape)
123         return true;
124 
125     for (Shape::SpanIterator span = m_shape-&gt;spans_begin(), end = m_shape-&gt;spans_end(); span != end &amp;&amp; span + 1 != end; ++span) {
126         int y = span-&gt;y;
127         int maxY = (span + 1)-&gt;y;
128 
129         if (y &gt; point.y())
130             break;
131         if (maxY &lt;= point.y())
132             continue;
133 
134         for (Shape::SegmentIterator segment = m_shape-&gt;segments_begin(span), end = m_shape-&gt;segments_end(span); segment != end &amp;&amp; segment + 1 != end; segment += 2) {
135             int x = *segment;
136             int maxX = *(segment + 1);
137 
138             if (x &gt; point.x())
139                 break;
140             if (maxX &gt; point.x())
141                 return true;
142         }
143     }
144 
145     return false;
146 }
147 
148 bool Region::intersects(const Region&amp; region) const
149 {
150     if (!m_bounds.intersects(region.m_bounds))
151         return false;
152 
153     if (!m_shape &amp;&amp; !region.m_shape)
154         return true;
155 
156     return Shape::compareShapes&lt;Shape::CompareIntersectsOperation&gt;(m_shape ? *m_shape : m_bounds, region.m_shape ? *region.m_shape : region.m_bounds);
157 }
158 
159 uint64_t Region::totalArea() const
160 {
161     uint64_t totalArea = 0;
162 
163     for (auto&amp; rect : rects())
164         totalArea += (rect.width() * rect.height());
165 
166     return totalArea;
167 }
168 
169 template&lt;typename CompareOperation&gt;
170 bool Region::Shape::compareShapes(const Shape&amp; aShape, const Shape&amp; bShape)
171 {
172     bool result = CompareOperation::defaultResult;
173 
174     Shape::SpanIterator aSpan = aShape.spans_begin();
175     Shape::SpanIterator aSpanEnd = aShape.spans_end();
176     Shape::SpanIterator bSpan = bShape.spans_begin();
177     Shape::SpanIterator bSpanEnd = bShape.spans_end();
178 
179     bool aHadSegmentInPreviousSpan = false;
180     bool bHadSegmentInPreviousSpan = false;
181     while (aSpan != aSpanEnd &amp;&amp; aSpan + 1 != aSpanEnd &amp;&amp; bSpan != bSpanEnd &amp;&amp; bSpan + 1 != bSpanEnd) {
182         int aY = aSpan-&gt;y;
183         int aMaxY = (aSpan + 1)-&gt;y;
184         int bY = bSpan-&gt;y;
185         int bMaxY = (bSpan + 1)-&gt;y;
186 
187         Shape::SegmentIterator aSegment = aShape.segments_begin(aSpan);
188         Shape::SegmentIterator aSegmentEnd = aShape.segments_end(aSpan);
189         Shape::SegmentIterator bSegment = bShape.segments_begin(bSpan);
190         Shape::SegmentIterator bSegmentEnd = bShape.segments_end(bSpan);
191 
192         // Look for a non-overlapping part of the spans. If B had a segment in its previous span, then we already tested A against B within that span.
193         bool aHasSegmentInSpan = aSegment != aSegmentEnd;
194         bool bHasSegmentInSpan = bSegment != bSegmentEnd;
195         if (aY &lt; bY &amp;&amp; !bHadSegmentInPreviousSpan &amp;&amp; aHasSegmentInSpan &amp;&amp; CompareOperation::aOutsideB(result))
196             return result;
197         if (bY &lt; aY &amp;&amp; !aHadSegmentInPreviousSpan &amp;&amp; bHasSegmentInSpan &amp;&amp; CompareOperation::bOutsideA(result))
198             return result;
199 
200         aHadSegmentInPreviousSpan = aHasSegmentInSpan;
201         bHadSegmentInPreviousSpan = bHasSegmentInSpan;
202 
203         bool spansOverlap = bMaxY &gt; aY &amp;&amp; bY &lt; aMaxY;
204         if (spansOverlap) {
205             while (aSegment != aSegmentEnd &amp;&amp; bSegment != bSegmentEnd) {
206                 int aX = *aSegment;
207                 int aMaxX = *(aSegment + 1);
208                 int bX = *bSegment;
209                 int bMaxX = *(bSegment + 1);
210 
211                 bool segmentsOverlap = bMaxX &gt; aX &amp;&amp; bX &lt; aMaxX;
212                 if (segmentsOverlap &amp;&amp; CompareOperation::aOverlapsB(result))
213                     return result;
214                 if (aX &lt; bX &amp;&amp; CompareOperation::aOutsideB(result))
215                     return result;
216                 if (bX &lt; aX &amp;&amp; CompareOperation::bOutsideA(result))
217                     return result;
218 
219                 if (aMaxX &lt; bMaxX)
220                     aSegment += 2;
221                 else if (bMaxX &lt; aMaxX)
222                     bSegment += 2;
223                 else {
224                     aSegment += 2;
225                     bSegment += 2;
226                 }
227             }
228 
229             if (aSegment != aSegmentEnd &amp;&amp; CompareOperation::aOutsideB(result))
230                 return result;
231             if (bSegment != bSegmentEnd &amp;&amp; CompareOperation::bOutsideA(result))
232                 return result;
233         }
234 
235         if (aMaxY &lt; bMaxY)
236             aSpan += 1;
237         else if (bMaxY &lt; aMaxY)
238             bSpan += 1;
239         else {
240             aSpan += 1;
241             bSpan += 1;
242         }
243     }
244 
245     if (aSpan != aSpanEnd &amp;&amp; aSpan + 1 != aSpanEnd &amp;&amp; CompareOperation::aOutsideB(result))
246         return result;
247     if (bSpan != bSpanEnd &amp;&amp; bSpan + 1 != bSpanEnd &amp;&amp; CompareOperation::bOutsideA(result))
248         return result;
249 
250     return result;
251 }
252 
253 struct Region::Shape::CompareContainsOperation {
<a name="2" id="anc2"></a><span class="line-modified">254     static constexpr bool defaultResult = true;</span>
255     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
256     inline static bool bOutsideA(bool&amp; result) { result = false; return true; }
257     inline static bool aOverlapsB(bool&amp; /* result */) { return false; }
258 };
259 
260 struct Region::Shape::CompareIntersectsOperation {
<a name="3" id="anc3"></a><span class="line-modified">261     static constexpr bool defaultResult = false;</span>
262     inline static bool aOutsideB(bool&amp; /* result */) { return false; }
263     inline static bool bOutsideA(bool&amp; /* result */) { return false; }
264     inline static bool aOverlapsB(bool&amp; result) { result = true; return true; }
265 };
266 
267 Region::Shape::Shape(const IntRect&amp; rect)
268     : m_segments({ rect.x(), rect.maxX() })
269     , m_spans({ { rect.y(), 0 }, { rect.maxY(), 2 } })
270 {
271 }
272 
273 void Region::Shape::appendSpan(int y)
274 {
275     m_spans.append({ y, m_segments.size() });
276 }
277 
278 bool Region::Shape::canCoalesce(SegmentIterator begin, SegmentIterator end)
279 {
280     if (m_spans.isEmpty())
281         return false;
282 
283     SegmentIterator lastSpanBegin = m_segments.data() + m_spans.last().segmentIndex;
284     SegmentIterator lastSpanEnd = m_segments.data() + m_segments.size();
285 
286     // Check if both spans have an equal number of segments.
287     if (lastSpanEnd - lastSpanBegin != end - begin)
288         return false;
289 
290     // Check if both spans are equal.
291     if (!std::equal(begin, end, lastSpanBegin))
292         return false;
293 
294     // Since the segments are equal the second segment can just be ignored.
295     return true;
296 }
297 
298 void Region::Shape::appendSpan(int y, SegmentIterator begin, SegmentIterator end)
299 {
300     if (canCoalesce(begin, end))
301         return;
302 
303     appendSpan(y);
304     m_segments.appendRange(begin, end);
305 }
306 
307 void Region::Shape::appendSpans(const Shape&amp; shape, SpanIterator begin, SpanIterator end)
308 {
309     for (SpanIterator it = begin; it != end; ++it)
310         appendSpan(it-&gt;y, shape.segments_begin(it), shape.segments_end(it));
311 }
312 
313 void Region::Shape::appendSegment(int x)
314 {
315     m_segments.append(x);
316 }
317 
318 Region::Shape::SpanIterator Region::Shape::spans_begin() const
319 {
320     return m_spans.data();
321 }
322 
323 Region::Shape::SpanIterator Region::Shape::spans_end() const
324 {
325     return m_spans.data() + m_spans.size();
326 }
327 
328 Region::Shape::SegmentIterator Region::Shape::segments_begin(SpanIterator it) const
329 {
330     ASSERT(it &gt;= m_spans.data());
331     ASSERT(it &lt; m_spans.data() + m_spans.size());
332 
333     // Check if this span has any segments.
334     if (it-&gt;segmentIndex == m_segments.size())
335         return 0;
336 
337     return &amp;m_segments[it-&gt;segmentIndex];
338 }
339 
340 Region::Shape::SegmentIterator Region::Shape::segments_end(SpanIterator it) const
341 {
342     ASSERT(it &gt;= m_spans.data());
343     ASSERT(it &lt; m_spans.data() + m_spans.size());
344 
345     // Check if this span has any segments.
346     if (it-&gt;segmentIndex == m_segments.size())
347         return 0;
348 
349     ASSERT(it + 1 &lt; m_spans.data() + m_spans.size());
350     size_t segmentIndex = (it + 1)-&gt;segmentIndex;
351 
352     ASSERT_WITH_SECURITY_IMPLICATION(segmentIndex &lt;= m_segments.size());
353     return m_segments.data() + segmentIndex;
354 }
355 
356 #ifndef NDEBUG
357 void Region::Shape::dump() const
358 {
359     for (auto span = spans_begin(), end = spans_end(); span != end; ++span) {
360         printf(&quot;%6d: (&quot;, span-&gt;y);
361 
362         for (auto segment = segments_begin(span), end = segments_end(span); segment != end; ++segment)
363             printf(&quot;%d &quot;, *segment);
364         printf(&quot;)\n&quot;);
365     }
366 
367     printf(&quot;\n&quot;);
368 }
369 #endif
370 
371 IntRect Region::Shape::bounds() const
372 {
373     if (isEmpty())
374         return IntRect();
375 
376     SpanIterator span = spans_begin();
377     int minY = span-&gt;y;
378 
379     SpanIterator lastSpan = spans_end() - 1;
380     int maxY = lastSpan-&gt;y;
381 
382     int minX = std::numeric_limits&lt;int&gt;::max();
383     int maxX = std::numeric_limits&lt;int&gt;::min();
384 
385     while (span != lastSpan) {
386         SegmentIterator firstSegment = segments_begin(span);
387         SegmentIterator lastSegment = segments_end(span) - 1;
388 
389         if (firstSegment &amp;&amp; lastSegment) {
390             ASSERT(firstSegment != lastSegment);
391 
392             if (*firstSegment &lt; minX)
393                 minX = *firstSegment;
394 
395             if (*lastSegment &gt; maxX)
396                 maxX = *lastSegment;
397         }
398 
399         ++span;
400     }
401 
402     ASSERT(minX &lt;= maxX);
403     ASSERT(minY &lt;= maxY);
404 
405     return IntRect(minX, minY, maxX - minX, maxY - minY);
406 }
407 
408 void Region::Shape::translate(const IntSize&amp; offset)
409 {
410     for (size_t i = 0; i &lt; m_segments.size(); ++i)
411         m_segments[i] += offset.width();
412     for (size_t i = 0; i &lt; m_spans.size(); ++i)
413         m_spans[i].y += offset.height();
414 }
415 
416 enum {
417     Shape1,
418     Shape2,
419 };
420 
421 template&lt;typename Operation&gt;
422 Region::Shape Region::Shape::shapeOperation(const Shape&amp; shape1, const Shape&amp; shape2)
423 {
424     COMPILE_ASSERT(!(!Operation::shouldAddRemainingSegmentsFromSpan1 &amp;&amp; Operation::shouldAddRemainingSegmentsFromSpan2), invalid_segment_combination);
425     COMPILE_ASSERT(!(!Operation::shouldAddRemainingSpansFromShape1 &amp;&amp; Operation::shouldAddRemainingSpansFromShape2), invalid_span_combination);
426 
427     Shape result;
428     if (Operation::trySimpleOperation(shape1, shape2, result))
429         return result;
430 
431     SpanIterator spans1 = shape1.spans_begin();
432     SpanIterator spans1End = shape1.spans_end();
433 
434     SpanIterator spans2 = shape2.spans_begin();
435     SpanIterator spans2End = shape2.spans_end();
436 
437     SegmentIterator segments1 = 0;
438     SegmentIterator segments1End = 0;
439 
440     SegmentIterator segments2 = 0;
441     SegmentIterator segments2End = 0;
442 
443     // Iterate over all spans.
444     while (spans1 != spans1End &amp;&amp; spans2 != spans2End) {
445         int y = 0;
446         int test = spans1-&gt;y - spans2-&gt;y;
447 
448         if (test &lt;= 0) {
449             y = spans1-&gt;y;
450 
451             segments1 = shape1.segments_begin(spans1);
452             segments1End = shape1.segments_end(spans1);
453             ++spans1;
454         }
455         if (test &gt;= 0) {
456             y = spans2-&gt;y;
457 
458             segments2 = shape2.segments_begin(spans2);
459             segments2End = shape2.segments_end(spans2);
460             ++spans2;
461         }
462 
463         int flag = 0;
464         int oldFlag = 0;
465 
466         SegmentIterator s1 = segments1;
467         SegmentIterator s2 = segments2;
468 
469         Vector&lt;int, 32&gt; segments;
470 
471         // Now iterate over the segments in each span and construct a new vector of segments.
472         while (s1 != segments1End &amp;&amp; s2 != segments2End) {
473             int test = *s1 - *s2;
474             int x;
475 
476             if (test &lt;= 0) {
477                 x = *s1;
478                 flag = flag ^ 1;
479                 ++s1;
480             }
481             if (test &gt;= 0) {
482                 x = *s2;
483                 flag = flag ^ 2;
484                 ++s2;
485             }
486 
487             if (flag == Operation::opCode || oldFlag == Operation::opCode)
488                 segments.append(x);
489 
490             oldFlag = flag;
491         }
492 
493         // Add any remaining segments.
494         if (Operation::shouldAddRemainingSegmentsFromSpan1 &amp;&amp; s1 != segments1End)
495             segments.appendRange(s1, segments1End);
496         else if (Operation::shouldAddRemainingSegmentsFromSpan2 &amp;&amp; s2 != segments2End)
497             segments.appendRange(s2, segments2End);
498 
499         // Add the span.
500         if (!segments.isEmpty() || !result.isEmpty())
501             result.appendSpan(y, segments.data(), segments.data() + segments.size());
502     }
503 
504     // Add any remaining spans.
505     if (Operation::shouldAddRemainingSpansFromShape1 &amp;&amp; spans1 != spans1End)
506         result.appendSpans(shape1, spans1, spans1End);
507     else if (Operation::shouldAddRemainingSpansFromShape2 &amp;&amp; spans2 != spans2End)
508         result.appendSpans(shape2, spans2, spans2End);
509 
510     return result;
511 }
512 
513 struct Region::Shape::UnionOperation {
514     static bool trySimpleOperation(const Shape&amp; shape1, const Shape&amp; shape2, Shape&amp; result)
515     {
516         if (shape1.isEmpty()) {
517             result = shape2;
518             return true;
519         }
520 
521         return false;
522     }
523 
524     static const int opCode = 0;
525 
526     static const bool shouldAddRemainingSegmentsFromSpan1 = true;
527     static const bool shouldAddRemainingSegmentsFromSpan2 = true;
528     static const bool shouldAddRemainingSpansFromShape1 = true;
529     static const bool shouldAddRemainingSpansFromShape2 = true;
530 };
531 
532 Region::Shape Region::Shape::unionShapes(const Shape&amp; shape1, const Shape&amp; shape2)
533 {
534     return shapeOperation&lt;UnionOperation&gt;(shape1, shape2);
535 }
536 
537 struct Region::Shape::IntersectOperation {
538     static bool trySimpleOperation(const Shape&amp;, const Shape&amp;, Shape&amp;)
539     {
540         return false;
541     }
542 
543     static const int opCode = 3;
544 
545     static const bool shouldAddRemainingSegmentsFromSpan1 = false;
546     static const bool shouldAddRemainingSegmentsFromSpan2 = false;
547     static const bool shouldAddRemainingSpansFromShape1 = false;
548     static const bool shouldAddRemainingSpansFromShape2 = false;
549 };
550 
551 Region::Shape Region::Shape::intersectShapes(const Shape&amp; shape1, const Shape&amp; shape2)
552 {
553     return shapeOperation&lt;IntersectOperation&gt;(shape1, shape2);
554 }
555 
556 struct Region::Shape::SubtractOperation {
557     static bool trySimpleOperation(const Shape&amp;, const Shape&amp;, Region::Shape&amp;)
558     {
559         return false;
560     }
561 
562     static const int opCode = 1;
563 
564     static const bool shouldAddRemainingSegmentsFromSpan1 = true;
565     static const bool shouldAddRemainingSegmentsFromSpan2 = false;
566     static const bool shouldAddRemainingSpansFromShape1 = true;
567     static const bool shouldAddRemainingSpansFromShape2 = false;
568 };
569 
570 Region::Shape Region::Shape::subtractShapes(const Shape&amp; shape1, const Shape&amp; shape2)
571 {
572     return shapeOperation&lt;SubtractOperation&gt;(shape1, shape2);
573 }
574 
575 #ifndef NDEBUG
576 void Region::dump() const
577 {
578     printf(&quot;Bounds: (%d, %d, %d, %d)\n&quot;,
579            m_bounds.x(), m_bounds.y(), m_bounds.width(), m_bounds.height());
580     if (m_shape)
581         m_shape-&gt;dump();
582 }
583 #endif
584 
585 void Region::intersect(const Region&amp; region)
586 {
587     if (m_bounds.isEmpty())
588         return;
589     if (!m_bounds.intersects(region.m_bounds)) {
590         m_shape = nullptr;
591         m_bounds = IntRect();
592         return;
593     }
594     if (!m_shape &amp;&amp; !region.m_shape) {
595         m_bounds = intersection(m_bounds, region.m_bounds);
596         return;
597     }
598 
599     setShape(Shape::intersectShapes(m_shape ? *m_shape : m_bounds, region.m_shape ? *region.m_shape : region.m_bounds));
600 }
601 
602 void Region::unite(const Region&amp; region)
603 {
604     if (region.isEmpty())
605         return;
606     if (isEmpty()) {
607         m_bounds = region.m_bounds;
608         m_shape = region.copyShape();
609         return;
610     }
611     if (region.isRect() &amp;&amp; region.m_bounds.contains(m_bounds)) {
612         m_bounds = region.m_bounds;
613         m_shape = nullptr;
614         return;
615     }
616     if (contains(region))
617         return;
618 
619     setShape(Shape::unionShapes(m_shape ? *m_shape : m_bounds, region.m_shape ? *region.m_shape : region.m_bounds));
620 }
621 
622 void Region::subtract(const Region&amp; region)
623 {
624     if (isEmpty())
625         return;
626     if (region.isEmpty())
627         return;
628     if (!m_bounds.intersects(region.m_bounds))
629         return;
630 
631     setShape(Shape::subtractShapes(m_shape ? *m_shape : m_bounds, region.m_shape ? *region.m_shape : region.m_bounds));
632 }
633 
634 void Region::translate(const IntSize&amp; offset)
635 {
636     m_bounds.move(offset);
637     if (m_shape)
638         m_shape-&gt;translate(offset);
639 }
640 
641 void Region::setShape(Shape&amp;&amp; shape)
642 {
643     m_bounds = shape.bounds();
644 
645     if (shape.isRect()) {
646         m_shape = nullptr;
647         return;
648     }
649 
650     if (!m_shape)
651         m_shape = makeUnique&lt;Shape&gt;(WTFMove(shape));
652     else
653         *m_shape = WTFMove(shape);
654 }
655 
656 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Region&amp; region)
657 {
658     ts &lt;&lt; &quot;\n&quot;;
659     {
660         TextStream::IndentScope indentScope(ts);
661         for (auto&amp; rect : region.rects())
662             ts &lt;&lt; indent &lt;&lt; &quot;(rect &quot; &lt;&lt; rect &lt;&lt; &quot;)\n&quot;;
663     }
664 
665     return ts;
666 }
667 
668 } // namespace WebCore
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
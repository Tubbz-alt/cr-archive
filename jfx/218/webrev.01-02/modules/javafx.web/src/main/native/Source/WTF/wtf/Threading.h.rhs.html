<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007 Justin Haygood &lt;jhaygood@reaktix.com&gt;
  4  * Copyright (C) 2017 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 16  *     its contributors may be used to endorse or promote products derived
 17  *     from this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &lt;mutex&gt;
 34 #include &lt;stdint.h&gt;
 35 #include &lt;wtf/Atomics.h&gt;
 36 #include &lt;wtf/Expected.h&gt;
 37 #include &lt;wtf/FastTLS.h&gt;
 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/PlatformRegisters.h&gt;
 42 #include &lt;wtf/Ref.h&gt;
 43 #include &lt;wtf/RefPtr.h&gt;
 44 #include &lt;wtf/StackBounds.h&gt;
 45 #include &lt;wtf/StackStats.h&gt;
 46 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 47 #include &lt;wtf/Vector.h&gt;
 48 #include &lt;wtf/WordLock.h&gt;
 49 #include &lt;wtf/text/AtomStringTable.h&gt;
 50 
 51 #if USE(PTHREADS) &amp;&amp; !OS(DARWIN)
 52 #include &lt;signal.h&gt;
 53 #endif
 54 
<a name="1" id="anc1"></a><span class="line-added"> 55 #if OS(WINDOWS)</span>
<span class="line-added"> 56 #include &lt;array&gt;</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 </span>
 59 namespace WTF {
 60 
 61 class AbstractLocker;
 62 class ThreadMessageData;
 63 
 64 enum class ThreadGroupAddResult;
 65 
 66 class ThreadGroup;
 67 class PrintStream;
 68 
 69 // This function can be called from any threads.
 70 WTF_EXPORT_PRIVATE void initializeThreading();
 71 
 72 #if USE(PTHREADS)
 73 
 74 // We use SIGUSR1 to suspend and resume machine threads in JavaScriptCore.
 75 constexpr const int SigThreadSuspendResume = SIGUSR1;
 76 
 77 #endif
 78 
 79 enum class GCThreadType : uint8_t {
 80     None = 0,
 81     Main,
 82     Helper,
 83 };
 84 
 85 class Thread : public ThreadSafeRefCounted&lt;Thread&gt; {
 86 public:
 87     friend class ThreadGroup;
 88     friend WTF_EXPORT_PRIVATE void initializeThreading();
 89 
 90     WTF_EXPORT_PRIVATE ~Thread();
 91 
 92     // Returns nullptr if thread creation failed.
 93     // The thread name must be a literal since on some platforms it&#39;s passed in to the thread.
 94     WTF_EXPORT_PRIVATE static Ref&lt;Thread&gt; create(const char* threadName, Function&lt;void()&gt;&amp;&amp;);
 95 
 96     // Returns Thread object.
 97     static Thread&amp; current();
 98 
 99     // Set of all WTF::Thread created threads.
100     WTF_EXPORT_PRIVATE static HashSet&lt;Thread*&gt;&amp; allThreads(const LockHolder&amp;);
101     WTF_EXPORT_PRIVATE static Lock&amp; allThreadsMutex();
102 
103     WTF_EXPORT_PRIVATE unsigned numberOfThreadGroups();
104 
105 #if OS(WINDOWS)
106     // Returns ThreadIdentifier directly. It is useful if the user only cares about identity
107     // of threads. At that time, users should know that holding this ThreadIdentifier does not ensure
108     // that the thread information is alive. While Thread::current() is not safe if it is called
109     // from the destructor of the other TLS data, currentID() always returns meaningful thread ID.
110     WTF_EXPORT_PRIVATE static ThreadIdentifier currentID();
111 
112     ThreadIdentifier id() const { return m_id; }
<a name="2" id="anc2"></a><span class="line-added">113 </span>
<span class="line-added">114     class SpecificStorage {</span>
<span class="line-added">115     public:</span>
<span class="line-added">116         using DestroyFunction = void (*)(void*);</span>
<span class="line-added">117         WTF_EXPORT_PRIVATE static bool allocateKey(int&amp; key, DestroyFunction);</span>
<span class="line-added">118         WTF_EXPORT_PRIVATE void* get(int key);</span>
<span class="line-added">119         WTF_EXPORT_PRIVATE void set(int key, void* value);</span>
<span class="line-added">120         void destroySlots();</span>
<span class="line-added">121 </span>
<span class="line-added">122     private:</span>
<span class="line-added">123         static constexpr size_t s_maxKeys = 32;</span>
<span class="line-added">124         static Atomic&lt;int&gt; s_numberOfKeys;</span>
<span class="line-added">125         static std::array&lt;Atomic&lt;DestroyFunction&gt;, s_maxKeys&gt; s_destroyFunctions;</span>
<span class="line-added">126         std::array&lt;void*, s_maxKeys&gt; m_slots { };</span>
<span class="line-added">127     };</span>
<span class="line-added">128 </span>
<span class="line-added">129     SpecificStorage&amp; specificStorage() { return m_specificStorage; };</span>
<span class="line-added">130 </span>
<span class="line-added">131     class ThreadHolder;</span>
132 #endif
133 
134     WTF_EXPORT_PRIVATE void changePriority(int);
135     WTF_EXPORT_PRIVATE int waitForCompletion();
136     WTF_EXPORT_PRIVATE void detach();
137 
138 #if OS(DARWIN)
139     using PlatformSuspendError = kern_return_t;
140 #elif USE(PTHREADS)
141     using PlatformSuspendError = int;
142 #elif OS(WINDOWS)
143     using PlatformSuspendError = DWORD;
144 #endif
145 
146     WTF_EXPORT_PRIVATE Expected&lt;void, PlatformSuspendError&gt; suspend();
147     WTF_EXPORT_PRIVATE void resume();
148     WTF_EXPORT_PRIVATE size_t getRegisters(PlatformRegisters&amp;);
149 
150 #if USE(PTHREADS)
151     WTF_EXPORT_PRIVATE bool signal(int signalNumber);
152 #endif
153 
154     // Mark the current thread as requiring UI responsiveness.
155     // relativePriority is a value in the range [-15, 0] where a lower value indicates a lower priority.
156     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInteractive(int relativePriority = 0);
157     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInitiated(int relativePriority = 0);
158 
159 #if HAVE(QOS_CLASSES)
160     WTF_EXPORT_PRIVATE static void setGlobalMaxQOSClass(qos_class_t);
161     WTF_EXPORT_PRIVATE static qos_class_t adjustedQOSClass(qos_class_t);
162 #endif
163 
164     // Called in the thread during initialization.
165     // Helpful for platforms where the thread name must be set from within the thread.
166     static void initializeCurrentThreadInternal(const char* threadName);
167     static void initializeCurrentThreadEvenIfNonWTFCreated();
168 
<a name="3" id="anc3"></a>
169     WTF_EXPORT_PRIVATE static void yield();
170 
171     WTF_EXPORT_PRIVATE static bool exchangeIsCompilationThread(bool newValue);
172     WTF_EXPORT_PRIVATE static void registerGCThread(GCThreadType);
173     WTF_EXPORT_PRIVATE static bool mayBeGCThread();
174 
175     WTF_EXPORT_PRIVATE void dump(PrintStream&amp; out) const;
176 
177     static void initializePlatformThreading();
178 
179     const StackBounds&amp; stack() const
180     {
181         return m_stack;
182     }
183 
184     AtomStringTable* atomStringTable()
185     {
186         return m_currentAtomStringTable;
187     }
188 
189     AtomStringTable* setCurrentAtomStringTable(AtomStringTable* atomStringTable)
190     {
191         AtomStringTable* oldAtomStringTable = m_currentAtomStringTable;
192         m_currentAtomStringTable = atomStringTable;
193         return oldAtomStringTable;
194     }
195 
196 #if ENABLE(STACK_STATS)
197     StackStats::PerThreadStats&amp; stackStats()
198     {
199         return m_stackStats;
200     }
201 #endif
202 
203     void* savedStackPointerAtVMEntry()
204     {
205         return m_savedStackPointerAtVMEntry;
206     }
207 
208     void setSavedStackPointerAtVMEntry(void* stackPointerAtVMEntry)
209     {
210         m_savedStackPointerAtVMEntry = stackPointerAtVMEntry;
211     }
212 
213     void* savedLastStackTop()
214     {
215         return m_savedLastStackTop;
216     }
217 
218     void setSavedLastStackTop(void* lastStackTop)
219     {
220         m_savedLastStackTop = lastStackTop;
221     }
222 
223 #if OS(DARWIN)
224     mach_port_t machThread() { return m_platformThread; }
225 #endif
226 
227     bool isCompilationThread() const { return m_isCompilationThread; }
228     GCThreadType gcThreadType() const { return static_cast&lt;GCThreadType&gt;(m_gcThreadType); }
229 
230     struct NewThreadContext;
231     static void entryPoint(NewThreadContext*);
232 protected:
233     Thread();
234 
235     void initializeInThread();
236 
237     // Internal platform-specific Thread establishment implementation.
238     bool establishHandle(NewThreadContext*);
239 
240 #if USE(PTHREADS)
241     void establishPlatformSpecificHandle(PlatformThreadHandle);
242 #else
243     void establishPlatformSpecificHandle(PlatformThreadHandle, ThreadIdentifier);
244 #endif
245 
246 #if USE(PTHREADS) &amp;&amp; !OS(DARWIN)
247     static void signalHandlerSuspendResume(int, siginfo_t*, void* ucontext);
248 #endif
249 
250     static const char* normalizeThreadName(const char* threadName);
251 
252     enum JoinableState : uint8_t {
253         // The default thread state. The thread can be joined on.
254         Joinable,
255 
256         // Somebody waited on this thread to exit and this thread finally exited. This state is here because there can be a
257         // period of time between when the thread exits (which causes pthread_join to return and the remainder of waitOnThreadCompletion to run)
258         // and when threadDidExit is called. We need threadDidExit to take charge and delete the thread data since there&#39;s
259         // nobody else to pick up the slack in this case (since waitOnThreadCompletion has already returned).
260         Joined,
261 
262         // The thread has been detached and can no longer be joined on. At this point, the thread must take care of cleaning up after itself.
263         Detached,
264     };
265 
266     JoinableState joinableState() const { return m_joinableState; }
267     void didBecomeDetached() { m_joinableState = Detached; }
268     void didExit();
269     void didJoin() { m_joinableState = Joined; }
270     bool hasExited() const { return m_didExit; }
271 
272     // These functions are only called from ThreadGroup.
273     ThreadGroupAddResult addToThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
274     void removeFromThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
275 
<a name="4" id="anc4"></a><span class="line-modified">276     // For pthread, the Thread instance is ref&#39;ed and held in thread-specific storage. It will be deref&#39;ed by destructTLS at thread destruction time.</span>
<span class="line-modified">277     // It employs pthreads-specific 2-pass destruction to reliably remove Thread.</span>


278 
<a name="5" id="anc5"></a><span class="line-modified">279 #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
280     static WTF_EXPORT_PRIVATE ThreadSpecificKey s_key;
281     // One time initialization for this class as a whole.
282     // This method must be called before initializeTLS() and it is not thread-safe.
283     static void initializeTLSKey();
284 #endif
<a name="6" id="anc6"></a><span class="line-added">285     // This thread-specific destructor is called 2 times when thread terminates:</span>
<span class="line-added">286     // - first, when all the other thread-specific destructors are called, it simply remembers it was &#39;destroyed once&#39;</span>
<span class="line-added">287     // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.</span>
<span class="line-added">288     // - second, after all thread-specific destructors were invoked, it gets called again - this time, we deref the</span>
<span class="line-added">289     // Thread in the TLS, completing the cleanup.</span>
<span class="line-added">290     static void destructTLS(void* data);</span>
291 
292     // Creates and puts an instance of Thread into thread-specific storage.
293     static Thread&amp; initializeTLS(Ref&lt;Thread&gt;&amp;&amp;);
294     WTF_EXPORT_PRIVATE static Thread&amp; initializeCurrentTLS();
295 
296     // Returns nullptr if thread-specific storage was not initialized.
<a name="7" id="anc7"></a>

297 #if OS(WINDOWS)
<a name="8" id="anc8"></a><span class="line-modified">298     WTF_EXPORT_PRIVATE static Thread* currentMayBeNull();</span>
<span class="line-modified">299 #else</span>
<span class="line-added">300     static Thread* currentMayBeNull();</span>
301 #endif
302 
<a name="9" id="anc9"></a>






303     JoinableState m_joinableState { Joinable };
304     bool m_isShuttingDown : 1;
305     bool m_didExit : 1;
306     bool m_isDestroyedOnce : 1;
307     bool m_isCompilationThread: 1;
308     unsigned m_gcThreadType : 2;
309 
310     // Lock &amp; ParkingLot rely on ThreadSpecific. But Thread object can be destroyed even after ThreadSpecific things are destroyed.
311     // Use WordLock since WordLock does not depend on ThreadSpecific and this &quot;Thread&quot;.
312     WordLock m_mutex;
313     StackBounds m_stack { StackBounds::emptyBounds() };
314     HashMap&lt;ThreadGroup*, std::weak_ptr&lt;ThreadGroup&gt;&gt; m_threadGroupMap;
315     PlatformThreadHandle m_handle;
316 #if OS(WINDOWS)
317     ThreadIdentifier m_id { 0 };
318 #elif OS(DARWIN)
319     mach_port_t m_platformThread { MACH_PORT_NULL };
320 #elif USE(PTHREADS)
321     PlatformRegisters* m_platformRegisters { nullptr };
322     unsigned m_suspendCount { 0 };
323 #endif
324 
<a name="10" id="anc10"></a><span class="line-added">325 #if OS(WINDOWS)</span>
<span class="line-added">326     SpecificStorage m_specificStorage;</span>
<span class="line-added">327 #endif</span>
<span class="line-added">328 </span>
329     AtomStringTable* m_currentAtomStringTable { nullptr };
330     AtomStringTable m_defaultAtomStringTable;
331 
332 #if ENABLE(STACK_STATS)
333     StackStats::PerThreadStats m_stackStats;
334 #endif
335     void* m_savedStackPointerAtVMEntry { nullptr };
336     void* m_savedLastStackTop;
337 public:
338     void* m_apiData { nullptr };
339 };
340 
341 inline Thread::Thread()
342     : m_isShuttingDown(false)
343     , m_didExit(false)
344     , m_isDestroyedOnce(false)
345     , m_isCompilationThread(false)
346     , m_gcThreadType(static_cast&lt;unsigned&gt;(GCThreadType::None))
347 {
348 }
349 
<a name="11" id="anc11"></a><span class="line-added">350 #if !OS(WINDOWS)</span>
351 inline Thread* Thread::currentMayBeNull()
352 {
353 #if !HAVE(FAST_TLS)
354     ASSERT(s_key != InvalidThreadSpecificKey);
355     return static_cast&lt;Thread*&gt;(threadSpecificGet(s_key));
356 #else
357     return static_cast&lt;Thread*&gt;(_pthread_getspecific_direct(WTF_THREAD_DATA_KEY));
358 #endif
359 }
<a name="12" id="anc12"></a><span class="line-added">360 #endif</span>
361 
362 inline Thread&amp; Thread::current()
363 {
364     // WRT WebCore:
365     //    Thread::current() is used on main thread before it could possibly be used
366     //    on secondary ones, so there is no need for synchronization here.
367     // WRT JavaScriptCore:
368     //    Thread::initializeTLSKey() is initially called from initializeThreading(), ensuring
369     //    this is initially called in a std::call_once locked context.
<a name="13" id="anc13"></a><span class="line-modified">370 #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
371     if (UNLIKELY(Thread::s_key == InvalidThreadSpecificKey))
372         WTF::initializeThreading();
373 #endif
374     if (auto* thread = currentMayBeNull())
375         return *thread;
<a name="14" id="anc14"></a>



376     return initializeCurrentTLS();
377 }
378 
379 } // namespace WTF
380 
381 using WTF::Thread;
382 using WTF::GCThreadType;
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/RunLoop.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010-2019 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  4  * Portions Copyright (c) 2010 Motorola Mobility, Inc.  All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25  * THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &lt;wtf/Condition.h&gt;
 31 #include &lt;wtf/Deque.h&gt;
 32 #include &lt;wtf/Forward.h&gt;
 33 #include &lt;wtf/FunctionDispatcher.h&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/RetainPtr.h&gt;
 36 #include &lt;wtf/Seconds.h&gt;
 37 #include &lt;wtf/ThreadingPrimitives.h&gt;
 38 #include &lt;wtf/text/WTFString.h&gt;
 39 
 40 #if USE(CF)
 41 #include &lt;CoreFoundation/CFRunLoop.h&gt;
 42 #endif
 43 
 44 #if USE(GLIB_EVENT_LOOP)
 45 #include &lt;wtf/glib/GRefPtr.h&gt;
 46 #endif
 47 
 48 namespace WTF {
 49 
 50 #if USE(CF)
 51 using RunLoopMode = CFStringRef;
 52 #define DefaultRunLoopMode kCFRunLoopDefaultMode
 53 #else
 54 using RunLoopMode = unsigned;
 55 #define DefaultRunLoopMode 0
 56 #endif
 57 
 58 class RunLoop : public FunctionDispatcher {
 59     WTF_MAKE_NONCOPYABLE(RunLoop);
 60 public:
 61     // Must be called from the main thread (except for the Mac platform, where it
 62     // can be called from any thread).
 63     WTF_EXPORT_PRIVATE static void initializeMainRunLoop();
 64 
 65     WTF_EXPORT_PRIVATE static RunLoop&amp; current();
 66     WTF_EXPORT_PRIVATE static RunLoop&amp; main();
 67     WTF_EXPORT_PRIVATE static bool isMain();
 68     ~RunLoop();
 69 
 70     void dispatch(Function&lt;void()&gt;&amp;&amp;) override;
 71 
 72     WTF_EXPORT_PRIVATE static void run();
 73     WTF_EXPORT_PRIVATE void stop();
 74     WTF_EXPORT_PRIVATE void wakeUp();
 75 
 76     enum class CycleResult { Continue, Stop };
 77     WTF_EXPORT_PRIVATE CycleResult static cycle(RunLoopMode = DefaultRunLoopMode);
 78 
 79 #if USE(COCOA_EVENT_LOOP)
 80     WTF_EXPORT_PRIVATE void runForDuration(Seconds duration);
 81 #endif
 82 
 83 #if USE(GLIB_EVENT_LOOP)
 84     WTF_EXPORT_PRIVATE GMainContext* mainContext() const { return m_mainContext.get(); }
 85 #endif
 86 
 87 #if USE(GENERIC_EVENT_LOOP) || USE(WINDOWS_EVENT_LOOP)
 88     // Run the single iteration of the RunLoop. It consumes the pending tasks and expired timers, but it won&#39;t be blocked.
 89     WTF_EXPORT_PRIVATE static void iterate();
 90 #endif
 91 
 92 #if USE(WINDOWS_EVENT_LOOP)
 93     static void registerRunLoopMessageWindowClass();
 94 #endif
 95 
 96 #if USE(GLIB_EVENT_LOOP) || USE(GENERIC_EVENT_LOOP)
 97     WTF_EXPORT_PRIVATE void dispatchAfter(Seconds, Function&lt;void()&gt;&amp;&amp;);
 98 #endif
 99 
100     class TimerBase {
101         WTF_MAKE_FAST_ALLOCATED;
102         friend class RunLoop;
103     public:
104         WTF_EXPORT_PRIVATE explicit TimerBase(RunLoop&amp;);
105         WTF_EXPORT_PRIVATE virtual ~TimerBase();
106 
107         void startRepeating(Seconds repeatInterval) { startInternal(repeatInterval, true); }
108         void startOneShot(Seconds interval) { startInternal(interval, false); }
109 
110         WTF_EXPORT_PRIVATE void stop();
111         WTF_EXPORT_PRIVATE bool isActive() const;
112         WTF_EXPORT_PRIVATE Seconds secondsUntilFire() const;
113 
114         virtual void fired() = 0;
115 
116 #if USE(GLIB_EVENT_LOOP)
117         void setName(const char*);
118         void setPriority(int);
119 #endif
120 
121     private:
122         void startInternal(Seconds nextFireInterval, bool repeat)
123         {
124             start(std::max(nextFireInterval, 0_s), repeat);
125         }
126 
127         WTF_EXPORT_PRIVATE void start(Seconds nextFireInterval, bool repeat);
128 
129         Ref&lt;RunLoop&gt; m_runLoop;
130 
131 #if USE(WINDOWS_EVENT_LOOP)
132         bool isActive(const AbstractLocker&amp;) const;
133         void timerFired();
134         MonotonicTime m_nextFireDate;
135         Seconds m_interval;
136         bool m_isRepeating { false };
137         bool m_isActive { false };
138 #elif USE(COCOA_EVENT_LOOP)
139         static void timerFired(CFRunLoopTimerRef, void*);
140         RetainPtr&lt;CFRunLoopTimerRef&gt; m_timer;
141 #elif USE(GLIB_EVENT_LOOP)
142         void updateReadyTime();
143         GRefPtr&lt;GSource&gt; m_source;
144         bool m_isRepeating { false };
145         Seconds m_fireInterval { 0 };
146 #elif USE(GENERIC_EVENT_LOOP)
147         bool isActive(const AbstractLocker&amp;) const;
148         void stop(const AbstractLocker&amp;);
149 
150         class ScheduledTask;
151         RefPtr&lt;ScheduledTask&gt; m_scheduledTask;
152 #endif
153     };
154 
155     template &lt;typename TimerFiredClass&gt;
156     class Timer : public TimerBase {
157     public:
158         typedef void (TimerFiredClass::*TimerFiredFunction)();
159 
160         Timer(RunLoop&amp; runLoop, TimerFiredClass* o, TimerFiredFunction f)
161             : TimerBase(runLoop)
162             , m_function(f)
163             , m_object(o)
164         {
165         }
166 
167     private:
168         void fired() override { (m_object-&gt;*m_function)(); }
169 
170         // This order should be maintained due to MSVC bug.
171         // http://computer-programming-forum.com/7-vc.net/6fbc30265f860ad1.htm
172         TimerFiredFunction m_function;
173         TimerFiredClass* m_object;
174     };
175 
176     class Holder;
177 
178 private:
179     RunLoop();
180 
181     void performWork();
182 
183     Lock m_functionQueueLock;
184     Deque&lt;Function&lt;void()&gt;&gt; m_functionQueue;
185 
186 #if USE(WINDOWS_EVENT_LOOP)
187     static LRESULT CALLBACK RunLoopWndProc(HWND, UINT, WPARAM, LPARAM);
188     LRESULT wndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
189     HWND m_runLoopMessageWindow;
190 
191     Lock m_loopLock;
192 #elif USE(COCOA_EVENT_LOOP)
193     static void performWork(void*);
194     RetainPtr&lt;CFRunLoopRef&gt; m_runLoop;
195     RetainPtr&lt;CFRunLoopSourceRef&gt; m_runLoopSource;
196 #elif USE(GLIB_EVENT_LOOP)
197     GRefPtr&lt;GMainContext&gt; m_mainContext;
198     Vector&lt;GRefPtr&lt;GMainLoop&gt;&gt; m_mainLoops;
199     GRefPtr&lt;GSource&gt; m_source;
200 #elif USE(GENERIC_EVENT_LOOP)
201     void schedule(Ref&lt;TimerBase::ScheduledTask&gt;&amp;&amp;);
202     void schedule(const AbstractLocker&amp;, Ref&lt;TimerBase::ScheduledTask&gt;&amp;&amp;);
203     void wakeUp(const AbstractLocker&amp;);
204     void scheduleAndWakeUp(const AbstractLocker&amp;, Ref&lt;TimerBase::ScheduledTask&gt;&amp;&amp;);
205 
206     enum class RunMode {
207         Iterate,
208         Drain
209     };
210 
211     enum class Status {
212         Clear,
213         Stopping,
214     };
215     void runImpl(RunMode);
216     bool populateTasks(RunMode, Status&amp;, Deque&lt;RefPtr&lt;TimerBase::ScheduledTask&gt;&gt;&amp;);
217 
218     friend class TimerBase;
219 
220     Lock m_loopLock;
221     Condition m_readyToRun;
222     Condition m_stopCondition;
223     Vector&lt;RefPtr&lt;TimerBase::ScheduledTask&gt;&gt; m_schedules;
224     Vector&lt;Status*&gt; m_mainLoops;
225     bool m_shutdown { false };
226     bool m_pendingTasks { false };
227 #endif
228 };
229 
230 } // namespace WTF
231 
232 using WTF::RunLoop;
233 using WTF::RunLoopMode;
    </pre>
  </body>
</html>
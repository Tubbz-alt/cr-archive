<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSArrayBufferPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferView.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSArrayBufferView.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSArrayBufferView.h&quot;
 28 
 29 #include &quot;GenericTypedArrayViewInlines.h&quot;
 30 #include &quot;JSArrayBuffer.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 33 #include &quot;JSTypedArrays.h&quot;
 34 #include &quot;TypeError.h&quot;
 35 #include &quot;TypedArrayController.h&quot;
 36 #include &quot;TypedArrays.h&quot;
 37 #include &lt;wtf/Gigacage.h&gt;
 38 
 39 namespace JSC {
 40 
 41 const ClassInfo JSArrayBufferView::s_info = {
 42     &quot;ArrayBufferView&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferView)
 43 };
 44 
<span class="line-modified"> 45 String JSArrayBufferView::toStringName(const JSObject*, ExecState*)</span>
 46 {
 47     return &quot;Object&quot;_s;
 48 }
 49 
 50 JSArrayBufferView::ConstructionContext::ConstructionContext(
 51     Structure* structure, uint32_t length, void* vector)
 52     : m_structure(structure)
 53     , m_vector(vector, length)
 54     , m_length(length)
 55     , m_mode(FastTypedArray)
 56     , m_butterfly(nullptr)
 57 {
 58     ASSERT(vector == removeArrayPtrTag(vector));
 59     RELEASE_ASSERT(length &lt;= fastSizeLimit);
 60 }
 61 
 62 JSArrayBufferView::ConstructionContext::ConstructionContext(
 63     VM&amp; vm, Structure* structure, uint32_t length, uint32_t elementSize,
 64     InitializationMode mode)
 65     : m_structure(0)
</pre>
<hr />
<pre>
159         return;
160     }
161     RELEASE_ASSERT_NOT_REACHED();
162 }
163 
164 void JSArrayBufferView::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
165 {
166     JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
167     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
168     Base::visitChildren(cell, visitor);
169 
170     if (thisObject-&gt;hasArrayBuffer()) {
171         WTF::loadLoadFence();
172         ArrayBuffer* buffer = thisObject-&gt;possiblySharedBuffer();
173         RELEASE_ASSERT(buffer);
174         visitor.addOpaqueRoot(buffer);
175     }
176 }
177 
178 bool JSArrayBufferView::put(
<span class="line-modified">179     JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,</span>
180     PutPropertySlot&amp; slot)
181 {
182     JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
183 
184     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">185         return ordinarySetSlow(exec, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
186 
<span class="line-modified">187     return Base::put(thisObject, exec, propertyName, value, slot);</span>
188 }
189 
190 ArrayBuffer* JSArrayBufferView::unsharedBuffer()
191 {
192     ArrayBuffer* result = possiblySharedBuffer();
193     RELEASE_ASSERT(!result-&gt;isShared());
194     return result;
195 }
196 
197 void JSArrayBufferView::finalize(JSCell* cell)
198 {
199     JSArrayBufferView* thisObject = static_cast&lt;JSArrayBufferView*&gt;(cell);
200     ASSERT(thisObject-&gt;m_mode == OversizeTypedArray || thisObject-&gt;m_mode == WastefulTypedArray);
201     if (thisObject-&gt;m_mode == OversizeTypedArray)
202         Gigacage::free(Gigacage::Primitive, thisObject-&gt;vector());
203 }
204 
<span class="line-modified">205 JSArrayBuffer* JSArrayBufferView::unsharedJSBuffer(ExecState* exec)</span>
206 {
<span class="line-modified">207     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">208     return vm.m_typedArrayController-&gt;toJS(exec, globalObject(vm), unsharedBuffer());</span>
209 }
210 
<span class="line-modified">211 JSArrayBuffer* JSArrayBufferView::possiblySharedJSBuffer(ExecState* exec)</span>
212 {
<span class="line-modified">213     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">214     return vm.m_typedArrayController-&gt;toJS(exec, globalObject(vm), possiblySharedBuffer());</span>
215 }
216 
217 void JSArrayBufferView::neuter()
218 {
219     auto locker = holdLock(cellLock());
220     RELEASE_ASSERT(hasArrayBuffer());
221     RELEASE_ASSERT(!isShared());
222     m_length = 0;
223     m_vector.clear();
224 }
225 
226 static const constexpr size_t ElementSizeData[] = {
227 #define FACTORY(type) sizeof(typename type ## Adaptor::Type),
228     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY)
229 #undef FACTORY
230 };
231 
232 #define FACTORY(type) static_assert(std::is_final&lt;JS ## type ## Array&gt;::value, &quot;&quot;);
233 FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY)
234 #undef FACTORY
235 
236 static inline size_t elementSize(JSType type)
237 {
238     ASSERT(type &gt;= Int8ArrayType &amp;&amp; type &lt;= Float64ArrayType);
239     return ElementSizeData[type - Int8ArrayType];
240 }
241 
242 ArrayBuffer* JSArrayBufferView::slowDownAndWasteMemory()
243 {
244     ASSERT(m_mode == FastTypedArray || m_mode == OversizeTypedArray);
245 
246     // We play this game because we want this to be callable even from places that
<span class="line-modified">247     // don&#39;t have access to ExecState* or the VM, and we only allocate so little</span>
248     // memory here that it&#39;s not necessary to trigger a GC - just accounting what
249     // we have done is good enough. The sort of bizarre exception to the &quot;allocating
250     // little memory&quot; is when we transfer a backing buffer into the C heap; this
251     // will temporarily get counted towards heap footprint (incorrectly, in the case
252     // of adopting an oversize typed array) but we don&#39;t GC here anyway. That&#39;s
253     // almost certainly fine. The worst case is if you created a ton of fast typed
254     // arrays, and did nothing but caused all of them to slow down and waste memory.
255     // In that case, your memory footprint will double before the GC realizes what&#39;s
256     // up. But if you do *anything* to trigger a GC watermark check, it will know
257     // that you *had* done those allocations and it will GC appropriately.
258     Heap* heap = Heap::heap(this);
259     VM&amp; vm = heap-&gt;vm();
260     DeferGCForAWhile deferGC(*heap);
261 
262     RELEASE_ASSERT(!hasIndexingHeader(vm));
263     Structure* structure = this-&gt;structure(vm);
264     setButterfly(vm, Butterfly::createOrGrowArrayRight(
265         butterfly(), vm, this, structure,
266         structure-&gt;outOfLineCapacity(), false, 0, 0));
267 
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSArrayBufferView.h&quot;
 28 
 29 #include &quot;GenericTypedArrayViewInlines.h&quot;
 30 #include &quot;JSArrayBuffer.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 33 #include &quot;JSTypedArrays.h&quot;
 34 #include &quot;TypeError.h&quot;
 35 #include &quot;TypedArrayController.h&quot;
 36 #include &quot;TypedArrays.h&quot;
 37 #include &lt;wtf/Gigacage.h&gt;
 38 
 39 namespace JSC {
 40 
 41 const ClassInfo JSArrayBufferView::s_info = {
 42     &quot;ArrayBufferView&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSArrayBufferView)
 43 };
 44 
<span class="line-modified"> 45 String JSArrayBufferView::toStringName(const JSObject*, JSGlobalObject*)</span>
 46 {
 47     return &quot;Object&quot;_s;
 48 }
 49 
 50 JSArrayBufferView::ConstructionContext::ConstructionContext(
 51     Structure* structure, uint32_t length, void* vector)
 52     : m_structure(structure)
 53     , m_vector(vector, length)
 54     , m_length(length)
 55     , m_mode(FastTypedArray)
 56     , m_butterfly(nullptr)
 57 {
 58     ASSERT(vector == removeArrayPtrTag(vector));
 59     RELEASE_ASSERT(length &lt;= fastSizeLimit);
 60 }
 61 
 62 JSArrayBufferView::ConstructionContext::ConstructionContext(
 63     VM&amp; vm, Structure* structure, uint32_t length, uint32_t elementSize,
 64     InitializationMode mode)
 65     : m_structure(0)
</pre>
<hr />
<pre>
159         return;
160     }
161     RELEASE_ASSERT_NOT_REACHED();
162 }
163 
164 void JSArrayBufferView::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
165 {
166     JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
167     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
168     Base::visitChildren(cell, visitor);
169 
170     if (thisObject-&gt;hasArrayBuffer()) {
171         WTF::loadLoadFence();
172         ArrayBuffer* buffer = thisObject-&gt;possiblySharedBuffer();
173         RELEASE_ASSERT(buffer);
174         visitor.addOpaqueRoot(buffer);
175     }
176 }
177 
178 bool JSArrayBufferView::put(
<span class="line-modified">179     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,</span>
180     PutPropertySlot&amp; slot)
181 {
182     JSArrayBufferView* thisObject = jsCast&lt;JSArrayBufferView*&gt;(cell);
183 
184     if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">185         return ordinarySetSlow(globalObject, thisObject, propertyName, value, slot.thisValue(), slot.isStrictMode());</span>
186 
<span class="line-modified">187     return Base::put(thisObject, globalObject, propertyName, value, slot);</span>
188 }
189 
190 ArrayBuffer* JSArrayBufferView::unsharedBuffer()
191 {
192     ArrayBuffer* result = possiblySharedBuffer();
193     RELEASE_ASSERT(!result-&gt;isShared());
194     return result;
195 }
196 
197 void JSArrayBufferView::finalize(JSCell* cell)
198 {
199     JSArrayBufferView* thisObject = static_cast&lt;JSArrayBufferView*&gt;(cell);
200     ASSERT(thisObject-&gt;m_mode == OversizeTypedArray || thisObject-&gt;m_mode == WastefulTypedArray);
201     if (thisObject-&gt;m_mode == OversizeTypedArray)
202         Gigacage::free(Gigacage::Primitive, thisObject-&gt;vector());
203 }
204 
<span class="line-modified">205 JSArrayBuffer* JSArrayBufferView::unsharedJSBuffer(JSGlobalObject* globalObject)</span>
206 {
<span class="line-modified">207     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">208     return vm.m_typedArrayController-&gt;toJS(globalObject, this-&gt;globalObject(vm), unsharedBuffer());</span>
209 }
210 
<span class="line-modified">211 JSArrayBuffer* JSArrayBufferView::possiblySharedJSBuffer(JSGlobalObject* globalObject)</span>
212 {
<span class="line-modified">213     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">214     return vm.m_typedArrayController-&gt;toJS(globalObject, this-&gt;globalObject(vm), possiblySharedBuffer());</span>
215 }
216 
217 void JSArrayBufferView::neuter()
218 {
219     auto locker = holdLock(cellLock());
220     RELEASE_ASSERT(hasArrayBuffer());
221     RELEASE_ASSERT(!isShared());
222     m_length = 0;
223     m_vector.clear();
224 }
225 
226 static const constexpr size_t ElementSizeData[] = {
227 #define FACTORY(type) sizeof(typename type ## Adaptor::Type),
228     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY)
229 #undef FACTORY
230 };
231 
232 #define FACTORY(type) static_assert(std::is_final&lt;JS ## type ## Array&gt;::value, &quot;&quot;);
233 FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(FACTORY)
234 #undef FACTORY
235 
236 static inline size_t elementSize(JSType type)
237 {
238     ASSERT(type &gt;= Int8ArrayType &amp;&amp; type &lt;= Float64ArrayType);
239     return ElementSizeData[type - Int8ArrayType];
240 }
241 
242 ArrayBuffer* JSArrayBufferView::slowDownAndWasteMemory()
243 {
244     ASSERT(m_mode == FastTypedArray || m_mode == OversizeTypedArray);
245 
246     // We play this game because we want this to be callable even from places that
<span class="line-modified">247     // don&#39;t have access to CallFrame* or the VM, and we only allocate so little</span>
248     // memory here that it&#39;s not necessary to trigger a GC - just accounting what
249     // we have done is good enough. The sort of bizarre exception to the &quot;allocating
250     // little memory&quot; is when we transfer a backing buffer into the C heap; this
251     // will temporarily get counted towards heap footprint (incorrectly, in the case
252     // of adopting an oversize typed array) but we don&#39;t GC here anyway. That&#39;s
253     // almost certainly fine. The worst case is if you created a ton of fast typed
254     // arrays, and did nothing but caused all of them to slow down and waste memory.
255     // In that case, your memory footprint will double before the GC realizes what&#39;s
256     // up. But if you do *anything* to trigger a GC watermark check, it will know
257     // that you *had* done those allocations and it will GC appropriately.
258     Heap* heap = Heap::heap(this);
259     VM&amp; vm = heap-&gt;vm();
260     DeferGCForAWhile deferGC(*heap);
261 
262     RELEASE_ASSERT(!hasIndexingHeader(vm));
263     Structure* structure = this-&gt;structure(vm);
264     setButterfly(vm, Butterfly::createOrGrowArrayRight(
265         butterfly(), vm, this, structure,
266         structure-&gt;outOfLineCapacity(), false, 0, 0));
267 
</pre>
</td>
</tr>
</table>
<center><a href="JSArrayBufferPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSArrayBufferView.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jsc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntData.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,35 ***</span>
  
  namespace LLInt {
  
  
  uint8_t Data::s_exceptionInstructions[maxOpcodeLength + 1] = { };
<span class="line-modified">! Opcode g_opcodeMap[numOpcodeIDs] = { };</span>
<span class="line-modified">! Opcode g_opcodeMapWide16[numOpcodeIDs] = { };</span>
<span class="line-modified">! Opcode g_opcodeMapWide32[numOpcodeIDs] = { };</span>
  
  #if !ENABLE(C_LOOP)
  extern &quot;C&quot; void llint_entry(void*, void*, void*);
<span class="line-modified">! #endif</span>
  
  void initialize()
  {
  #if ENABLE(C_LOOP)
      CLoop::initialize();
  
  #else // !ENABLE(C_LOOP)
      llint_entry(&amp;g_opcodeMap, &amp;g_opcodeMapWide16, &amp;g_opcodeMapWide32);
  
<span class="line-modified">!     for (int i = 0; i &lt; numOpcodeIDs; ++i) {</span>
          g_opcodeMap[i] = tagCodePtr(g_opcodeMap[i], BytecodePtrTag);
          g_opcodeMapWide16[i] = tagCodePtr(g_opcodeMapWide16[i], BytecodePtrTag);
          g_opcodeMapWide32[i] = tagCodePtr(g_opcodeMapWide32[i], BytecodePtrTag);
      }
  
      ASSERT(llint_throw_from_slow_path_trampoline &lt; UINT8_MAX);
<span class="line-modified">!     for (int i = 0; i &lt; maxOpcodeLength + 1; ++i)</span>
          Data::s_exceptionInstructions[i] = llint_throw_from_slow_path_trampoline;
  #endif // ENABLE(C_LOOP)
  }
  
  IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
  void Data::performAssertions(VM&amp; vm)
<span class="line-new-header">--- 46,47 ---</span>
  
  namespace LLInt {
  
  
  uint8_t Data::s_exceptionInstructions[maxOpcodeLength + 1] = { };
<span class="line-modified">! uint8_t Data::s_wasmExceptionInstructions[maxOpcodeLength + 1] = { };</span>
<span class="line-modified">! Opcode g_opcodeMap[numOpcodeIDs + numWasmOpcodeIDs] = { };</span>
<span class="line-modified">! Opcode g_opcodeMapWide16[numOpcodeIDs + numWasmOpcodeIDs] = { };</span>
<span class="line-added">+ Opcode g_opcodeMapWide32[numOpcodeIDs + numWasmOpcodeIDs] = { };</span>
  
  #if !ENABLE(C_LOOP)
  extern &quot;C&quot; void llint_entry(void*, void*, void*);
<span class="line-modified">! </span>
<span class="line-added">+ #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ extern &quot;C&quot; void wasm_entry(void*, void*, void*);</span>
<span class="line-added">+ #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif // !ENABLE(C_LOOP)</span>
  
  void initialize()
  {
  #if ENABLE(C_LOOP)
      CLoop::initialize();
  
  #else // !ENABLE(C_LOOP)
      llint_entry(&amp;g_opcodeMap, &amp;g_opcodeMapWide16, &amp;g_opcodeMapWide32);
  
<span class="line-modified">! #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+     wasm_entry(&amp;g_opcodeMap[numOpcodeIDs], &amp;g_opcodeMapWide16[numOpcodeIDs], &amp;g_opcodeMapWide32[numOpcodeIDs]);</span>
<span class="line-added">+ #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (int i = 0; i &lt; numOpcodeIDs + numWasmOpcodeIDs; ++i) {</span>
          g_opcodeMap[i] = tagCodePtr(g_opcodeMap[i], BytecodePtrTag);
          g_opcodeMapWide16[i] = tagCodePtr(g_opcodeMapWide16[i], BytecodePtrTag);
          g_opcodeMapWide32[i] = tagCodePtr(g_opcodeMapWide32[i], BytecodePtrTag);
      }
  
      ASSERT(llint_throw_from_slow_path_trampoline &lt; UINT8_MAX);
<span class="line-modified">!     for (unsigned i = 0; i &lt; maxOpcodeLength + 1; ++i) {</span>
          Data::s_exceptionInstructions[i] = llint_throw_from_slow_path_trampoline;
<span class="line-added">+         Data::s_wasmExceptionInstructions[i] = wasm_throw_from_slow_path_trampoline;</span>
<span class="line-added">+     }</span>
  #endif // ENABLE(C_LOOP)
  }
  
  IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
  void Data::performAssertions(VM&amp; vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,12 ***</span>
      ASSERT(!CallFrame::callerFrameOffset());
      STATIC_ASSERT(CallerFrameAndPC::sizeInRegisters == (MachineRegisterSize * 2) / SlotSize);
      ASSERT(CallFrame::returnPCOffset() == CallFrame::callerFrameOffset() + MachineRegisterSize);
      ASSERT(CallFrameSlot::codeBlock * sizeof(Register) == CallFrame::returnPCOffset() + MachineRegisterSize);
      STATIC_ASSERT(CallFrameSlot::callee * sizeof(Register) == CallFrameSlot::codeBlock * sizeof(Register) + SlotSize);
<span class="line-modified">!     STATIC_ASSERT(CallFrameSlot::argumentCount * sizeof(Register) == CallFrameSlot::callee * sizeof(Register) + SlotSize);</span>
<span class="line-modified">!     STATIC_ASSERT(CallFrameSlot::thisArgument * sizeof(Register) == CallFrameSlot::argumentCount * sizeof(Register) + SlotSize);</span>
      STATIC_ASSERT(CallFrame::headerSizeInRegisters == CallFrameSlot::thisArgument);
  
      ASSERT(CallFrame::argumentOffsetIncludingThis(0) == CallFrameSlot::thisArgument);
  
  #if CPU(BIG_ENDIAN)
<span class="line-new-header">--- 110,12 ---</span>
      ASSERT(!CallFrame::callerFrameOffset());
      STATIC_ASSERT(CallerFrameAndPC::sizeInRegisters == (MachineRegisterSize * 2) / SlotSize);
      ASSERT(CallFrame::returnPCOffset() == CallFrame::callerFrameOffset() + MachineRegisterSize);
      ASSERT(CallFrameSlot::codeBlock * sizeof(Register) == CallFrame::returnPCOffset() + MachineRegisterSize);
      STATIC_ASSERT(CallFrameSlot::callee * sizeof(Register) == CallFrameSlot::codeBlock * sizeof(Register) + SlotSize);
<span class="line-modified">!     STATIC_ASSERT(CallFrameSlot::argumentCountIncludingThis * sizeof(Register) == CallFrameSlot::callee * sizeof(Register) + SlotSize);</span>
<span class="line-modified">!     STATIC_ASSERT(CallFrameSlot::thisArgument * sizeof(Register) == CallFrameSlot::argumentCountIncludingThis * sizeof(Register) + SlotSize);</span>
      STATIC_ASSERT(CallFrame::headerSizeInRegisters == CallFrameSlot::thisArgument);
  
      ASSERT(CallFrame::argumentOffsetIncludingThis(0) == CallFrameSlot::thisArgument);
  
  #if CPU(BIG_ENDIAN)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,29 ***</span>
      STATIC_ASSERT(PayloadOffset == 4);
  #else
      STATIC_ASSERT(TagOffset == 4);
      STATIC_ASSERT(PayloadOffset == 0);
  #endif
<span class="line-removed">- #if USE(JSVALUE32_64)</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::Int32Tag == static_cast&lt;unsigned&gt;(-1));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::BooleanTag == static_cast&lt;unsigned&gt;(-2));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::NullTag == static_cast&lt;unsigned&gt;(-3));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::UndefinedTag == static_cast&lt;unsigned&gt;(-4));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::CellTag == static_cast&lt;unsigned&gt;(-5));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::EmptyValueTag == static_cast&lt;unsigned&gt;(-6));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::DeletedValueTag == static_cast&lt;unsigned&gt;(-7));</span>
<span class="line-removed">-     STATIC_ASSERT(JSValue::LowestTag == static_cast&lt;unsigned&gt;(-7));</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     STATIC_ASSERT(TagBitTypeOther == 0x2);</span>
<span class="line-removed">-     STATIC_ASSERT(TagBitBool == 0x4);</span>
<span class="line-removed">-     STATIC_ASSERT(TagBitUndefined == 0x8);</span>
<span class="line-removed">-     STATIC_ASSERT(ValueEmpty == 0x0);</span>
<span class="line-removed">-     STATIC_ASSERT(ValueFalse == (TagBitTypeOther | TagBitBool));</span>
<span class="line-removed">-     STATIC_ASSERT(ValueTrue == (TagBitTypeOther | TagBitBool | 1));</span>
<span class="line-removed">-     STATIC_ASSERT(ValueUndefined == (TagBitTypeOther | TagBitUndefined));</span>
<span class="line-removed">-     STATIC_ASSERT(ValueNull == TagBitTypeOther);</span>
<span class="line-removed">- #endif</span>
  
  #if ENABLE(C_LOOP)
      ASSERT(CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters() == 1);
  #elif USE(JSVALUE32_64)
      ASSERT(CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters() == 1);
<span class="line-new-header">--- 123,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,48 ***</span>
  #endif
  
      ASSERT(!(reinterpret_cast&lt;ptrdiff_t&gt;((reinterpret_cast&lt;WriteBarrier&lt;JSCell&gt;*&gt;(0x4000)-&gt;slot())) - 0x4000));
  
      // FIXME: make these assertions less horrible.
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      Vector&lt;int&gt; testVector;
      testVector.resize(42);
      ASSERT(bitwise_cast&lt;uint32_t*&gt;(&amp;testVector)[sizeof(void*)/sizeof(uint32_t) + 1] == 42);
      ASSERT(bitwise_cast&lt;int**&gt;(&amp;testVector)[0] == testVector.begin());
  #endif
  
      {
<span class="line-modified">!         ArithProfile arithProfile;</span>
          arithProfile.lhsSawInt32();
          arithProfile.rhsSawInt32();
<span class="line-modified">!         ASSERT(arithProfile.bits() == ArithProfile::observedBinaryIntInt().bits());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryIntInt().lhsObservedType().isOnlyInt32());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryIntInt().rhsObservedType().isOnlyInt32());</span>
      }
      {
<span class="line-modified">!         ArithProfile arithProfile;</span>
          arithProfile.lhsSawNumber();
          arithProfile.rhsSawInt32();
<span class="line-modified">!         ASSERT(arithProfile.bits() == ArithProfile::observedBinaryNumberInt().bits());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryNumberInt().lhsObservedType().isOnlyNumber());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryNumberInt().rhsObservedType().isOnlyInt32());</span>
      }
      {
<span class="line-modified">!         ArithProfile arithProfile;</span>
          arithProfile.lhsSawNumber();
          arithProfile.rhsSawNumber();
<span class="line-modified">!         ASSERT(arithProfile.bits() == ArithProfile::observedBinaryNumberNumber().bits());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryNumberNumber().lhsObservedType().isOnlyNumber());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryNumberNumber().rhsObservedType().isOnlyNumber());</span>
      }
      {
<span class="line-modified">!         ArithProfile arithProfile;</span>
          arithProfile.lhsSawInt32();
          arithProfile.rhsSawNumber();
<span class="line-modified">!         ASSERT(arithProfile.bits() == ArithProfile::observedBinaryIntNumber().bits());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryIntNumber().lhsObservedType().isOnlyInt32());</span>
<span class="line-modified">!         STATIC_ASSERT(ArithProfile::observedBinaryIntNumber().rhsObservedType().isOnlyNumber());</span>
      }
  }
  IGNORE_WARNINGS_END
  
  } } // namespace JSC::LLInt
<span class="line-new-header">--- 137,61 ---</span>
  #endif
  
      ASSERT(!(reinterpret_cast&lt;ptrdiff_t&gt;((reinterpret_cast&lt;WriteBarrier&lt;JSCell&gt;*&gt;(0x4000)-&gt;slot())) - 0x4000));
  
      // FIXME: make these assertions less horrible.
<span class="line-modified">! #if ASSERT_ENABLED</span>
      Vector&lt;int&gt; testVector;
      testVector.resize(42);
      ASSERT(bitwise_cast&lt;uint32_t*&gt;(&amp;testVector)[sizeof(void*)/sizeof(uint32_t) + 1] == 42);
      ASSERT(bitwise_cast&lt;int**&gt;(&amp;testVector)[0] == testVector.begin());
  #endif
  
      {
<span class="line-modified">!         UnaryArithProfile arithProfile;</span>
<span class="line-added">+         arithProfile.argSawInt32();</span>
<span class="line-added">+         ASSERT(arithProfile.bits() == UnaryArithProfile::observedIntBits());</span>
<span class="line-added">+         ASSERT(arithProfile.argObservedType().isOnlyInt32());</span>
<span class="line-added">+     }</span>
<span class="line-added">+     {</span>
<span class="line-added">+         UnaryArithProfile arithProfile;</span>
<span class="line-added">+         arithProfile.argSawNumber();</span>
<span class="line-added">+         ASSERT(arithProfile.bits() == UnaryArithProfile::observedNumberBits());</span>
<span class="line-added">+         ASSERT(arithProfile.argObservedType().isOnlyNumber());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     {</span>
<span class="line-added">+         BinaryArithProfile arithProfile;</span>
          arithProfile.lhsSawInt32();
          arithProfile.rhsSawInt32();
<span class="line-modified">!         ASSERT(arithProfile.bits() == BinaryArithProfile::observedIntIntBits());</span>
<span class="line-modified">!         ASSERT(arithProfile.lhsObservedType().isOnlyInt32());</span>
<span class="line-modified">!         ASSERT(arithProfile.rhsObservedType().isOnlyInt32());</span>
      }
      {
<span class="line-modified">!         BinaryArithProfile arithProfile;</span>
          arithProfile.lhsSawNumber();
          arithProfile.rhsSawInt32();
<span class="line-modified">!         ASSERT(arithProfile.bits() == BinaryArithProfile::observedNumberIntBits());</span>
<span class="line-modified">!         ASSERT(arithProfile.lhsObservedType().isOnlyNumber());</span>
<span class="line-modified">!         ASSERT(arithProfile.rhsObservedType().isOnlyInt32());</span>
      }
      {
<span class="line-modified">!         BinaryArithProfile arithProfile;</span>
          arithProfile.lhsSawNumber();
          arithProfile.rhsSawNumber();
<span class="line-modified">!         ASSERT(arithProfile.bits() == BinaryArithProfile::observedNumberNumberBits());</span>
<span class="line-modified">!         ASSERT(arithProfile.lhsObservedType().isOnlyNumber());</span>
<span class="line-modified">!         ASSERT(arithProfile.rhsObservedType().isOnlyNumber());</span>
      }
      {
<span class="line-modified">!         BinaryArithProfile arithProfile;</span>
          arithProfile.lhsSawInt32();
          arithProfile.rhsSawNumber();
<span class="line-modified">!         ASSERT(arithProfile.bits() == BinaryArithProfile::observedIntNumberBits());</span>
<span class="line-modified">!         ASSERT(arithProfile.lhsObservedType().isOnlyInt32());</span>
<span class="line-modified">!         ASSERT(arithProfile.rhsObservedType().isOnlyNumber());</span>
      }
  }
  IGNORE_WARNINGS_END
  
  } } // namespace JSC::LLInt
</pre>
<center><a href="../jsc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LLIntData.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
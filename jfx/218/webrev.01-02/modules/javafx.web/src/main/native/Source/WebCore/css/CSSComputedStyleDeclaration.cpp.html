<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/CSSComputedStyleDeclaration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2004 Zack Rusin &lt;zack@kde.org&gt;
   3  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   4  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   5  * Copyright (C) 2007 Nicholas Shanks &lt;webkit@nickshanks.com&gt;
   6  * Copyright (C) 2011 Sencha, Inc. All rights reserved.
   7  * Copyright (C) 2013 Adobe Systems Incorporated. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Lesser General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Lesser General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, write to the Free Software
  21  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  22  * 02110-1301  USA
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 
  28 #include &quot;BasicShapeFunctions.h&quot;
  29 #include &quot;CSSAnimationController.h&quot;
  30 #include &quot;CSSAspectRatioValue.h&quot;
  31 #include &quot;CSSBasicShapes.h&quot;
  32 #include &quot;CSSBorderImage.h&quot;
  33 #include &quot;CSSBorderImageSliceValue.h&quot;
  34 #include &quot;CSSFontFeatureValue.h&quot;
  35 #include &quot;CSSFontStyleValue.h&quot;
  36 #include &quot;CSSFontValue.h&quot;
  37 #include &quot;CSSFontVariationValue.h&quot;
  38 #include &quot;CSSFunctionValue.h&quot;
  39 #include &quot;CSSGridAutoRepeatValue.h&quot;
  40 #include &quot;CSSLineBoxContainValue.h&quot;
  41 #include &quot;CSSPrimitiveValue.h&quot;
  42 #include &quot;CSSPrimitiveValueMappings.h&quot;
  43 #include &quot;CSSPropertyNames.h&quot;
  44 #include &quot;CSSPropertyParser.h&quot;
  45 #include &quot;CSSReflectValue.h&quot;
  46 #include &quot;CSSSelector.h&quot;
  47 #include &quot;CSSShadowValue.h&quot;
  48 #include &quot;CSSTimingFunctionValue.h&quot;
  49 #include &quot;CSSValueList.h&quot;
  50 #include &quot;CSSValuePool.h&quot;
  51 #include &quot;ComposedTreeAncestorIterator.h&quot;
  52 #include &quot;ContentData.h&quot;
  53 #include &quot;CursorList.h&quot;
  54 #include &quot;DeprecatedCSSOMValue.h&quot;
  55 #include &quot;Document.h&quot;
  56 #include &quot;DocumentTimeline.h&quot;
  57 #include &quot;FontCascade.h&quot;
  58 #include &quot;FontSelectionValueInlines.h&quot;
  59 #include &quot;FontTaggedSettings.h&quot;
  60 #include &quot;NodeRenderStyle.h&quot;
  61 #include &quot;Pair.h&quot;
  62 #include &quot;Rect.h&quot;
  63 #include &quot;RenderBlock.h&quot;
  64 #include &quot;RenderBox.h&quot;
  65 #include &quot;RenderInline.h&quot;
  66 #include &quot;RenderStyle.h&quot;
  67 #include &quot;SVGElement.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;ShapeValue.h&quot;
  70 #include &quot;StyleProperties.h&quot;
  71 #include &quot;StylePropertyShorthand.h&quot;
  72 #include &quot;StylePropertyShorthandFunctions.h&quot;
  73 #include &quot;StyleResolver.h&quot;
  74 #include &quot;StyleScope.h&quot;
  75 #include &quot;StyleScrollSnapPoints.h&quot;
  76 #include &quot;TouchAction.h&quot;
  77 #include &quot;WebKitFontFamilyNames.h&quot;
  78 #include &quot;WillChangeData.h&quot;
  79 #include &lt;wtf/IsoMallocInlines.h&gt;
  80 #include &lt;wtf/NeverDestroyed.h&gt;
  81 #include &lt;wtf/text/StringBuilder.h&gt;
  82 
  83 #include &quot;CSSGridLineNamesValue.h&quot;
  84 #include &quot;CSSGridTemplateAreasValue.h&quot;
  85 #include &quot;RenderGrid.h&quot;
  86 
  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(CSSComputedStyleDeclaration);
  90 
  91 static CSSValueID valueForRepeatRule(NinePieceImageRule rule)
  92 {
  93     switch (rule) {
  94     case NinePieceImageRule::Repeat:
  95         return CSSValueRepeat;
  96     case NinePieceImageRule::Round:
  97         return CSSValueRound;
  98     case NinePieceImageRule::Space:
  99         return CSSValueSpace;
 100     default:
 101         return CSSValueStretch;
 102     }
 103 }
 104 
 105 static Ref&lt;CSSPrimitiveValue&gt; valueForImageSliceSide(const Length&amp; length)
 106 {
 107     // These values can be percentages, numbers, or while an animation of mixed types is in progress,
 108     // a calculation that combines a percentage and a number.
 109     if (length.isPercent())
 110         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);
 111     if (length.isFixed())
 112         return CSSValuePool::singleton().createValue(length.value(), CSSUnitType::CSS_NUMBER);
 113 
 114     // Calculating the actual length currently in use would require most of the code from RenderBoxModelObject::paintNinePieceImage.
 115     // And even if we could do that, it&#39;s not clear if that&#39;s exactly what we&#39;d want during animation.
 116     // FIXME: For now, just return 0.
 117     ASSERT(length.isCalculated());
 118     return CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_NUMBER);
 119 }
 120 
 121 static Ref&lt;CSSBorderImageSliceValue&gt; valueForNinePieceImageSlice(const NinePieceImage&amp; image)
 122 {
 123     auto&amp; slices = image.imageSlices();
 124 
 125     RefPtr&lt;CSSPrimitiveValue&gt; top = valueForImageSliceSide(slices.top());
 126 
 127     RefPtr&lt;CSSPrimitiveValue&gt; right;
 128     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 129     RefPtr&lt;CSSPrimitiveValue&gt; left;
 130 
 131     if (slices.right() == slices.top() &amp;&amp; slices.bottom() == slices.top() &amp;&amp; slices.left() == slices.top()) {
 132         right = top;
 133         bottom = top;
 134         left = top;
 135     } else {
 136         right = valueForImageSliceSide(slices.right());
 137 
 138         if (slices.bottom() == slices.top() &amp;&amp; slices.right() == slices.left()) {
 139             bottom = top;
 140             left = right;
 141         } else {
 142             bottom = valueForImageSliceSide(slices.bottom());
 143 
 144             if (slices.left() == slices.right())
 145                 left = right;
 146             else
 147                 left = valueForImageSliceSide(slices.left());
 148         }
 149     }
 150 
 151     auto quad = Quad::create();
 152     quad-&gt;setTop(WTFMove(top));
 153     quad-&gt;setRight(WTFMove(right));
 154     quad-&gt;setBottom(WTFMove(bottom));
 155     quad-&gt;setLeft(WTFMove(left));
 156 
 157     return CSSBorderImageSliceValue::create(CSSValuePool::singleton().createValue(WTFMove(quad)), image.fill());
 158 }
 159 
 160 static Ref&lt;CSSPrimitiveValue&gt; valueForNinePieceImageQuad(const LengthBox&amp; box)
 161 {
 162     RefPtr&lt;CSSPrimitiveValue&gt; top;
 163     RefPtr&lt;CSSPrimitiveValue&gt; right;
 164     RefPtr&lt;CSSPrimitiveValue&gt; bottom;
 165     RefPtr&lt;CSSPrimitiveValue&gt; left;
 166 
 167     auto&amp; cssValuePool = CSSValuePool::singleton();
 168 
 169     if (box.top().isRelative())
 170         top = cssValuePool.createValue(box.top().value(), CSSUnitType::CSS_NUMBER);
 171     else
 172         top = cssValuePool.createValue(box.top());
 173 
 174     if (box.right() == box.top() &amp;&amp; box.bottom() == box.top() &amp;&amp; box.left() == box.top()) {
 175         right = top;
 176         bottom = top;
 177         left = top;
 178     } else {
 179         if (box.right().isRelative())
 180             right = cssValuePool.createValue(box.right().value(), CSSUnitType::CSS_NUMBER);
 181         else
 182             right = cssValuePool.createValue(box.right());
 183 
 184         if (box.bottom() == box.top() &amp;&amp; box.right() == box.left()) {
 185             bottom = top;
 186             left = right;
 187         } else {
 188             if (box.bottom().isRelative())
 189                 bottom = cssValuePool.createValue(box.bottom().value(), CSSUnitType::CSS_NUMBER);
 190             else
 191                 bottom = cssValuePool.createValue(box.bottom());
 192 
 193             if (box.left() == box.right())
 194                 left = right;
 195             else {
 196                 if (box.left().isRelative())
 197                     left = cssValuePool.createValue(box.left().value(), CSSUnitType::CSS_NUMBER);
 198                 else
 199                     left = cssValuePool.createValue(box.left());
 200             }
 201         }
 202     }
 203 
 204     auto quad = Quad::create();
 205     quad-&gt;setTop(WTFMove(top));
 206     quad-&gt;setRight(WTFMove(right));
 207     quad-&gt;setBottom(WTFMove(bottom));
 208     quad-&gt;setLeft(WTFMove(left));
 209 
 210     return cssValuePool.createValue(WTFMove(quad));
 211 }
 212 
 213 static Ref&lt;CSSValue&gt; valueForNinePieceImageRepeat(const NinePieceImage&amp; image)
 214 {
 215     auto&amp; cssValuePool = CSSValuePool::singleton();
 216     auto horizontalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.horizontalRule()));
 217     RefPtr&lt;CSSPrimitiveValue&gt; verticalRepeat;
 218     if (image.horizontalRule() == image.verticalRule())
 219         verticalRepeat = horizontalRepeat.copyRef();
 220     else
 221         verticalRepeat = cssValuePool.createIdentifierValue(valueForRepeatRule(image.verticalRule()));
 222     return cssValuePool.createValue(Pair::create(WTFMove(horizontalRepeat), WTFMove(verticalRepeat)));
 223 }
 224 
 225 static Ref&lt;CSSValue&gt; valueForNinePieceImage(const NinePieceImage&amp; image)
 226 {
 227     if (!image.hasImage())
 228         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 229 
 230     // Image first.
 231     RefPtr&lt;CSSValue&gt; imageValue;
 232     if (image.image())
 233         imageValue = image.image()-&gt;cssValue();
 234 
 235     // Create the image slice.
 236     RefPtr&lt;CSSBorderImageSliceValue&gt; imageSlices = valueForNinePieceImageSlice(image);
 237 
 238     // Create the border area slices.
 239     RefPtr&lt;CSSValue&gt; borderSlices = valueForNinePieceImageQuad(image.borderSlices());
 240 
 241     // Create the border outset.
 242     RefPtr&lt;CSSValue&gt; outset = valueForNinePieceImageQuad(image.outset());
 243 
 244     // Create the repeat rules.
 245     RefPtr&lt;CSSValue&gt; repeat = valueForNinePieceImageRepeat(image);
 246 
 247     return createBorderImageValue(WTFMove(imageValue), WTFMove(imageSlices), WTFMove(borderSlices), WTFMove(outset), WTFMove(repeat));
 248 }
 249 
 250 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValue(double value, const RenderStyle&amp; style)
 251 {
 252     return CSSValuePool::singleton().createValue(adjustFloatForAbsoluteZoom(value, style), CSSUnitType::CSS_PX);
 253 }
 254 
 255 inline static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedNumberValue(double value, const RenderStyle&amp; style)
 256 {
 257     return CSSValuePool::singleton().createValue(value / style.effectiveZoom(), CSSUnitType::CSS_NUMBER);
 258 }
 259 
 260 static Ref&lt;CSSPrimitiveValue&gt; zoomAdjustedPixelValueForLength(const Length&amp; length, const RenderStyle&amp; style)
 261 {
 262     if (length.isFixed())
 263         return zoomAdjustedPixelValue(length.value(), style);
 264     return CSSValuePool::singleton().createValue(length, style);
 265 }
 266 
 267 static Ref&lt;CSSValue&gt; valueForReflection(const StyleReflection* reflection, const RenderStyle&amp; style)
 268 {
 269     if (!reflection)
 270         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 271 
 272     RefPtr&lt;CSSPrimitiveValue&gt; offset;
 273     if (reflection-&gt;offset().isPercentOrCalculated())
 274         offset = CSSValuePool::singleton().createValue(reflection-&gt;offset().percent(), CSSUnitType::CSS_PERCENTAGE);
 275     else
 276         offset = zoomAdjustedPixelValue(reflection-&gt;offset().value(), style);
 277 
 278     RefPtr&lt;CSSPrimitiveValue&gt; direction;
 279     switch (reflection-&gt;direction()) {
 280     case ReflectionDirection::Below:
 281         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueBelow);
 282         break;
 283     case ReflectionDirection::Above:
 284         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueAbove);
 285         break;
 286     case ReflectionDirection::Left:
 287         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueLeft);
 288         break;
 289     case ReflectionDirection::Right:
 290         direction = CSSValuePool::singleton().createIdentifierValue(CSSValueRight);
 291         break;
 292     }
 293 
 294     return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), valueForNinePieceImage(reflection-&gt;mask()));
 295 }
 296 
 297 static Ref&lt;CSSValueList&gt; createPositionListForLayer(CSSPropertyID propertyID, const FillLayer&amp; layer, const RenderStyle&amp; style)
 298 {
 299     auto list = CSSValueList::createSpaceSeparated();
 300     if (layer.isBackgroundXOriginSet()) {
 301         ASSERT_UNUSED(propertyID, propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 302         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundXOrigin()));
 303     }
 304     list-&gt;append(zoomAdjustedPixelValueForLength(layer.xPosition(), style));
 305     if (layer.isBackgroundYOriginSet()) {
 306         ASSERT(propertyID == CSSPropertyBackgroundPosition || propertyID == CSSPropertyWebkitMaskPosition);
 307         list-&gt;append(CSSValuePool::singleton().createValue(layer.backgroundYOrigin()));
 308     }
 309     list-&gt;append(zoomAdjustedPixelValueForLength(layer.yPosition(), style));
 310     return list;
 311 }
 312 
 313 static Length getOffsetComputedLength(const RenderStyle&amp; style, CSSPropertyID propertyID)
 314 {
 315     // If specified as a length, the corresponding absolute length; if specified as
 316     // a percentage, the specified value; otherwise, &#39;auto&#39;. Hence, we can just
 317     // return the value in the style.
 318     //
 319     // See http://www.w3.org/TR/CSS21/cascade.html#computed-value
 320     switch (propertyID) {
 321     case CSSPropertyLeft:
 322         return style.left();
 323     case CSSPropertyRight:
 324         return style.right();
 325     case CSSPropertyTop:
 326         return style.top();
 327     case CSSPropertyBottom:
 328         return style.bottom();
 329     default:
 330         ASSERT_NOT_REACHED();
 331     }
 332 
 333     return { };
 334 }
 335 
 336 static LayoutUnit getOffsetUsedStyleRelative(RenderBox&amp; box, CSSPropertyID propertyID)
 337 {
 338     // For relatively positioned boxes, the offset is with respect to the top edges
 339     // of the box itself. This ties together top/bottom and left/right to be
 340     // opposites of each other.
 341     //
 342     // See http://www.w3.org/TR/CSS2/visuren.html#relative-positioning
 343     //
 344     // Specifically;
 345     //   Since boxes are not split or stretched as a result of &#39;left&#39; or
 346     //   &#39;right&#39;, the used values are always: left = -right.
 347     // and
 348     //   Since boxes are not split or stretched as a result of &#39;top&#39; or
 349     //   &#39;bottom&#39;, the used values are always: top = -bottom.
 350     switch (propertyID) {
 351     case CSSPropertyTop:
 352         return box.relativePositionOffset().height();
 353     case CSSPropertyBottom:
 354         return -(box.relativePositionOffset().height());
 355     case CSSPropertyLeft:
 356         return box.relativePositionOffset().width();
 357     case CSSPropertyRight:
 358         return -(box.relativePositionOffset().width());
 359     default:
 360         ASSERT_NOT_REACHED();
 361     }
 362 
 363     return 0;
 364 }
 365 
 366 static LayoutUnit getOffsetUsedStyleOutOfFlowPositioned(RenderBlock&amp; container, RenderBox&amp; box, CSSPropertyID propertyID)
 367 {
 368     // For out-of-flow positioned boxes, the offset is how far an box&#39;s margin
 369     // edge is offset below the edge of the box&#39;s containing block.
 370     // See http://www.w3.org/TR/CSS2/visuren.html#position-props
 371 
 372     // Margins are included in offsetTop/offsetLeft so we need to remove them here.
 373     switch (propertyID) {
 374     case CSSPropertyTop:
 375         return box.offsetTop() - box.marginTop();
 376     case CSSPropertyBottom:
 377         return container.clientHeight() - (box.offsetTop() + box.offsetHeight()) - box.marginBottom();
 378     case CSSPropertyLeft:
 379         return box.offsetLeft() - box.marginLeft();
 380     case CSSPropertyRight:
 381         return container.clientWidth() - (box.offsetLeft() + box.offsetWidth()) - box.marginRight();
 382     default:
 383         ASSERT_NOT_REACHED();
 384     }
 385 
 386     return 0;
 387 }
 388 
 389 static RefPtr&lt;CSSValue&gt; positionOffsetValue(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderObject* renderer)
 390 {
 391     auto offset = getOffsetComputedLength(style, propertyID);
 392 
 393     // If the element is not displayed; return the &quot;computed value&quot;.
 394     if (!renderer || !renderer-&gt;isBox())
 395         return zoomAdjustedPixelValueForLength(offset, style);
 396 
 397     auto&amp; box = downcast&lt;RenderBox&gt;(*renderer);
 398     auto* containingBlock = box.containingBlock();
 399 
 400     // Resolve a &quot;computed value&quot; percentage if the element is positioned.
 401     if (containingBlock &amp;&amp; offset.isPercentOrCalculated() &amp;&amp; box.isPositioned()) {
 402         bool isVerticalProperty;
 403         if (propertyID == CSSPropertyTop || propertyID == CSSPropertyBottom)
 404             isVerticalProperty = true;
 405         else {
 406             ASSERT(propertyID == CSSPropertyLeft || propertyID == CSSPropertyRight);
 407             isVerticalProperty = false;
 408         }
 409         LayoutUnit containingBlockSize;
 410         if (box.isStickilyPositioned()) {
 411             auto&amp; enclosingClippingBox = box.enclosingClippingBoxForStickyPosition();
 412             if (isVerticalProperty == enclosingClippingBox.isHorizontalWritingMode())
 413                 containingBlockSize = enclosingClippingBox.contentLogicalHeight();
 414             else
 415                 containingBlockSize = enclosingClippingBox.contentLogicalWidth();
 416         } else {
 417             if (isVerticalProperty == containingBlock-&gt;isHorizontalWritingMode()) {
 418                 containingBlockSize = box.isOutOfFlowPositioned()
 419                     ? box.containingBlockLogicalHeightForPositioned(*containingBlock, false)
 420                     : box.containingBlockLogicalHeightForContent(ExcludeMarginBorderPadding);
 421             } else {
 422                 containingBlockSize = box.isOutOfFlowPositioned()
 423                     ? box.containingBlockLogicalWidthForPositioned(*containingBlock, nullptr, false)
 424                     : box.containingBlockLogicalWidthForContent();
 425             }
 426         }
 427         return zoomAdjustedPixelValue(floatValueForLength(offset, containingBlockSize), style);
 428     }
 429 
 430     // Return a &quot;computed value&quot; length.
 431     if (!offset.isAuto())
 432         return zoomAdjustedPixelValueForLength(offset, style);
 433 
 434     // The property won&#39;t be overconstrained if its computed value is &quot;auto&quot;, so the &quot;used value&quot; can be returned.
 435     if (box.isRelativelyPositioned())
 436         return zoomAdjustedPixelValue(getOffsetUsedStyleRelative(box, propertyID), style);
 437 
 438     if (containingBlock &amp;&amp; box.isOutOfFlowPositioned())
 439         return zoomAdjustedPixelValue(getOffsetUsedStyleOutOfFlowPositioned(*containingBlock, box, propertyID), style);
 440 
 441     return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 442 }
 443 
 444 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::currentColorOrValidColor(const RenderStyle* style, const Color&amp; color) const
 445 {
 446     // This function does NOT look at visited information, so that computed style doesn&#39;t expose that.
 447     if (!color.isValid())
 448         return CSSValuePool::singleton().createColorValue(style-&gt;color());
 449     return CSSValuePool::singleton().createColorValue(color);
 450 }
 451 
 452 static Ref&lt;CSSPrimitiveValue&gt; percentageOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 453 {
 454     if (length.isPercent())
 455         return CSSValuePool::singleton().createValue(length.percent(), CSSUnitType::CSS_PERCENTAGE);
 456 
 457     return zoomAdjustedPixelValueForLength(length, style);
 458 }
 459 
 460 static Ref&lt;CSSPrimitiveValue&gt; autoOrZoomAdjustedValue(Length length, const RenderStyle&amp; style)
 461 {
 462     if (length.isAuto())
 463         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 464 
 465     return zoomAdjustedPixelValueForLength(length, style);
 466 }
 467 
 468 static Ref&lt;CSSValueList&gt; borderRadiusCornerValues(const LengthSize&amp; radius, const RenderStyle&amp; style)
 469 {
 470     auto list = CSSValueList::createSpaceSeparated();
 471     list-&gt;append(percentageOrZoomAdjustedValue(radius.width, style));
 472     list-&gt;append(percentageOrZoomAdjustedValue(radius.height, style));
 473     return list;
 474 }
 475 
 476 static Ref&lt;CSSValue&gt; borderRadiusCornerValue(const LengthSize&amp; radius, const RenderStyle&amp; style)
 477 {
 478     if (radius.width == radius.height)
 479         return percentageOrZoomAdjustedValue(radius.width, style);
 480     return borderRadiusCornerValues(radius, style);
 481 }
 482 
 483 static Ref&lt;CSSValueList&gt; borderRadiusShorthandValue(const RenderStyle&amp; style)
 484 {
 485     auto list = CSSValueList::createSlashSeparated();
 486     bool showHorizontalBottomLeft = style.borderTopRightRadius().width != style.borderBottomLeftRadius().width;
 487     bool showHorizontalBottomRight = showHorizontalBottomLeft || (style.borderBottomRightRadius().width != style.borderTopLeftRadius().width);
 488     bool showHorizontalTopRight = showHorizontalBottomRight || (style.borderTopRightRadius().width != style.borderTopLeftRadius().width);
 489 
 490     bool showVerticalBottomLeft = style.borderTopRightRadius().height != style.borderBottomLeftRadius().height;
 491     bool showVerticalBottomRight = showVerticalBottomLeft || (style.borderBottomRightRadius().height != style.borderTopLeftRadius().height);
 492     bool showVerticalTopRight = showVerticalBottomRight || (style.borderTopRightRadius().height != style.borderTopLeftRadius().height);
 493 
 494     auto topLeftRadius = borderRadiusCornerValues(style.borderTopLeftRadius(), style);
 495     auto topRightRadius = borderRadiusCornerValues(style.borderTopRightRadius(), style);
 496     auto bottomRightRadius = borderRadiusCornerValues(style.borderBottomRightRadius(), style);
 497     auto bottomLeftRadius = borderRadiusCornerValues(style.borderBottomLeftRadius(), style);
 498 
 499     auto horizontalRadii = CSSValueList::createSpaceSeparated();
 500     horizontalRadii-&gt;append(*topLeftRadius-&gt;item(0));
 501     if (showHorizontalTopRight)
 502         horizontalRadii-&gt;append(*topRightRadius-&gt;item(0));
 503     if (showHorizontalBottomRight)
 504         horizontalRadii-&gt;append(*bottomRightRadius-&gt;item(0));
 505     if (showHorizontalBottomLeft)
 506         horizontalRadii-&gt;append(*bottomLeftRadius-&gt;item(0));
 507 
 508     list-&gt;append(WTFMove(horizontalRadii));
 509 
 510     auto verticalRadiiList = CSSValueList::createSpaceSeparated();
 511     verticalRadiiList-&gt;append(*topLeftRadius-&gt;item(1));
 512     if (showVerticalTopRight)
 513         verticalRadiiList-&gt;append(*topRightRadius-&gt;item(1));
 514     if (showVerticalBottomRight)
 515         verticalRadiiList-&gt;append(*bottomRightRadius-&gt;item(1));
 516     if (showVerticalBottomLeft)
 517         verticalRadiiList-&gt;append(*bottomLeftRadius-&gt;item(1));
 518 
 519     if (!verticalRadiiList-&gt;equals(downcast&lt;CSSValueList&gt;(*list-&gt;item(0))))
 520         list-&gt;append(WTFMove(verticalRadiiList));
 521 
 522     return list;
 523 }
 524 
 525 static LayoutRect sizingBox(RenderObject&amp; renderer)
 526 {
 527     if (!is&lt;RenderBox&gt;(renderer))
 528         return LayoutRect();
 529 
 530     auto&amp; box = downcast&lt;RenderBox&gt;(renderer);
 531     return box.style().boxSizing() == BoxSizing::BorderBox ? box.borderBoxRect() : box.computedCSSContentBoxRect();
 532 }
 533 
 534 static Ref&lt;CSSFunctionValue&gt; matrixTransformValue(const TransformationMatrix&amp; transform, const RenderStyle&amp; style)
 535 {
 536     RefPtr&lt;CSSFunctionValue&gt; transformValue;
 537     auto&amp; cssValuePool = CSSValuePool::singleton();
 538     if (transform.isAffine()) {
 539         transformValue = CSSFunctionValue::create(CSSValueMatrix);
 540 
 541         transformValue-&gt;append(cssValuePool.createValue(transform.a(), CSSUnitType::CSS_NUMBER));
 542         transformValue-&gt;append(cssValuePool.createValue(transform.b(), CSSUnitType::CSS_NUMBER));
 543         transformValue-&gt;append(cssValuePool.createValue(transform.c(), CSSUnitType::CSS_NUMBER));
 544         transformValue-&gt;append(cssValuePool.createValue(transform.d(), CSSUnitType::CSS_NUMBER));
 545         transformValue-&gt;append(zoomAdjustedNumberValue(transform.e(), style));
 546         transformValue-&gt;append(zoomAdjustedNumberValue(transform.f(), style));
 547     } else {
 548         transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
 549 
 550         transformValue-&gt;append(cssValuePool.createValue(transform.m11(), CSSUnitType::CSS_NUMBER));
 551         transformValue-&gt;append(cssValuePool.createValue(transform.m12(), CSSUnitType::CSS_NUMBER));
 552         transformValue-&gt;append(cssValuePool.createValue(transform.m13(), CSSUnitType::CSS_NUMBER));
 553         transformValue-&gt;append(cssValuePool.createValue(transform.m14(), CSSUnitType::CSS_NUMBER));
 554 
 555         transformValue-&gt;append(cssValuePool.createValue(transform.m21(), CSSUnitType::CSS_NUMBER));
 556         transformValue-&gt;append(cssValuePool.createValue(transform.m22(), CSSUnitType::CSS_NUMBER));
 557         transformValue-&gt;append(cssValuePool.createValue(transform.m23(), CSSUnitType::CSS_NUMBER));
 558         transformValue-&gt;append(cssValuePool.createValue(transform.m24(), CSSUnitType::CSS_NUMBER));
 559 
 560         transformValue-&gt;append(cssValuePool.createValue(transform.m31(), CSSUnitType::CSS_NUMBER));
 561         transformValue-&gt;append(cssValuePool.createValue(transform.m32(), CSSUnitType::CSS_NUMBER));
 562         transformValue-&gt;append(cssValuePool.createValue(transform.m33(), CSSUnitType::CSS_NUMBER));
 563         transformValue-&gt;append(cssValuePool.createValue(transform.m34(), CSSUnitType::CSS_NUMBER));
 564 
 565         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m41(), style));
 566         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m42(), style));
 567         transformValue-&gt;append(zoomAdjustedNumberValue(transform.m43(), style));
 568         transformValue-&gt;append(cssValuePool.createValue(transform.m44(), CSSUnitType::CSS_NUMBER));
 569     }
 570 
 571     return transformValue.releaseNonNull();
 572 }
 573 
 574 static Ref&lt;CSSValue&gt; computedTransform(RenderObject* renderer, const RenderStyle&amp; style)
 575 {
 576     // Inline renderers do not support transforms.
 577     if (!renderer || is&lt;RenderInline&gt;(*renderer) || !style.hasTransform())
 578         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 579 
 580     FloatRect pixelSnappedRect;
 581     if (is&lt;RenderBox&gt;(*renderer))
 582         pixelSnappedRect = snapRectToDevicePixels(downcast&lt;RenderBox&gt;(*renderer).borderBoxRect(), renderer-&gt;document().deviceScaleFactor());
 583 
 584     TransformationMatrix transform;
 585     style.applyTransform(transform, pixelSnappedRect, RenderStyle::ExcludeTransformOrigin);
 586     // Note that this does not flatten to an affine transform if ENABLE(3D_TRANSFORMS) is off, by design.
 587 
 588     // FIXME: Need to print out individual functions (https://bugs.webkit.org/show_bug.cgi?id=23924)
 589     auto list = CSSValueList::createSpaceSeparated();
 590     list-&gt;append(matrixTransformValue(transform, style));
 591     return list;
 592 }
 593 
 594 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(double length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 595 {
 596     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length, style) : CSSValuePool::singleton().createValue(length, CSSUnitType::CSS_PX);
 597 }
 598 
 599 static inline Ref&lt;CSSPrimitiveValue&gt; adjustLengthForZoom(const Length&amp; length, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 600 {
 601     return adjust == AdjustPixelValues ? zoomAdjustedPixelValue(length.value(), style) : CSSValuePool::singleton().createValue(length);
 602 }
 603 
 604 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForShadow(const ShadowData* shadow, CSSPropertyID propertyID, const RenderStyle&amp; style, AdjustPixelValuesForComputedStyle adjust)
 605 {
 606     auto&amp; cssValuePool = CSSValuePool::singleton();
 607     if (!shadow)
 608         return cssValuePool.createIdentifierValue(CSSValueNone);
 609 
 610     auto list = CSSValueList::createCommaSeparated();
 611     for (const ShadowData* currShadowData = shadow; currShadowData; currShadowData = currShadowData-&gt;next()) {
 612         auto x = adjustLengthForZoom(currShadowData-&gt;x(), style, adjust);
 613         auto y = adjustLengthForZoom(currShadowData-&gt;y(), style, adjust);
 614         auto blur = adjustLengthForZoom(currShadowData-&gt;radius(), style, adjust);
 615         auto spread = propertyID == CSSPropertyTextShadow ? RefPtr&lt;CSSPrimitiveValue&gt;() : adjustLengthForZoom(currShadowData-&gt;spread(), style, adjust);
 616         auto style = propertyID == CSSPropertyTextShadow || currShadowData-&gt;style() == ShadowStyle::Normal ? RefPtr&lt;CSSPrimitiveValue&gt;() : cssValuePool.createIdentifierValue(CSSValueInset);
 617         auto color = cssValuePool.createColorValue(currShadowData-&gt;color());
 618         list-&gt;prepend(CSSShadowValue::create(WTFMove(x), WTFMove(y), WTFMove(blur), WTFMove(spread), WTFMove(style), WTFMove(color)));
 619     }
 620     return list;
 621 }
 622 
 623 Ref&lt;CSSValue&gt; ComputedStyleExtractor::valueForFilter(const RenderStyle&amp; style, const FilterOperations&amp; filterOperations, AdjustPixelValuesForComputedStyle adjust)
 624 {
 625     auto&amp; cssValuePool = CSSValuePool::singleton();
 626     if (filterOperations.operations().isEmpty())
 627         return cssValuePool.createIdentifierValue(CSSValueNone);
 628 
 629     auto list = CSSValueList::createSpaceSeparated();
 630 
 631     Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator end = filterOperations.operations().end();
 632     for (Vector&lt;RefPtr&lt;FilterOperation&gt;&gt;::const_iterator it = filterOperations.operations().begin(); it != end; ++it) {
 633         FilterOperation&amp; filterOperation = **it;
 634 
 635         if (filterOperation.type() == FilterOperation::REFERENCE) {
 636             ReferenceFilterOperation&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
 637             list-&gt;append(cssValuePool.createValue(referenceOperation.url(), CSSUnitType::CSS_URI));
 638         } else {
 639             RefPtr&lt;CSSFunctionValue&gt; filterValue;
 640             switch (filterOperation.type()) {
 641             case FilterOperation::GRAYSCALE: {
 642                 filterValue = CSSFunctionValue::create(CSSValueGrayscale);
 643                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 644                 break;
 645             }
 646             case FilterOperation::SEPIA: {
 647                 filterValue = CSSFunctionValue::create(CSSValueSepia);
 648                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 649                 break;
 650             }
 651             case FilterOperation::SATURATE: {
 652                 filterValue = CSSFunctionValue::create(CSSValueSaturate);
 653                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 654                 break;
 655             }
 656             case FilterOperation::HUE_ROTATE: {
 657                 filterValue = CSSFunctionValue::create(CSSValueHueRotate);
 658                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_DEG));
 659                 break;
 660             }
 661             case FilterOperation::INVERT: {
 662                 filterValue = CSSFunctionValue::create(CSSValueInvert);
 663                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 664                 break;
 665             }
 666             case FilterOperation::APPLE_INVERT_LIGHTNESS: {
 667                 filterValue = CSSFunctionValue::create(CSSValueAppleInvertLightness);
 668                 break;
 669             }
 670             case FilterOperation::OPACITY: {
 671                 filterValue = CSSFunctionValue::create(CSSValueOpacity);
 672                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 673                 break;
 674             }
 675             case FilterOperation::BRIGHTNESS: {
 676                 filterValue = CSSFunctionValue::create(CSSValueBrightness);
 677                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 678                 break;
 679             }
 680             case FilterOperation::CONTRAST: {
 681                 filterValue = CSSFunctionValue::create(CSSValueContrast);
 682                 filterValue-&gt;append(cssValuePool.createValue(downcast&lt;BasicComponentTransferFilterOperation&gt;(filterOperation).amount(), CSSUnitType::CSS_NUMBER));
 683                 break;
 684             }
 685             case FilterOperation::BLUR: {
 686                 filterValue = CSSFunctionValue::create(CSSValueBlur);
 687                 filterValue-&gt;append(adjustLengthForZoom(downcast&lt;BlurFilterOperation&gt;(filterOperation).stdDeviation(), style, adjust));
 688                 break;
 689             }
 690             case FilterOperation::DROP_SHADOW: {
 691                 DropShadowFilterOperation&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
 692                 filterValue = CSSFunctionValue::create(CSSValueDropShadow);
 693                 // We want our computed style to look like that of a text shadow (has neither spread nor inset style).
 694                 ShadowData shadowData = ShadowData(dropShadowOperation.location(), dropShadowOperation.stdDeviation(), 0, ShadowStyle::Normal, false, dropShadowOperation.color());
 695                 filterValue-&gt;append(valueForShadow(&amp;shadowData, CSSPropertyTextShadow, style, adjust));
 696                 break;
 697             }
 698             default:
 699                 ASSERT_NOT_REACHED();
 700                 filterValue = CSSFunctionValue::create(CSSValueInvalid);
 701                 break;
 702             }
 703             list-&gt;append(filterValue.releaseNonNull());
 704         }
 705     }
 706     return list;
 707 }
 708 
 709 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackBreadth(const GridLength&amp; trackBreadth, const RenderStyle&amp; style)
 710 {
 711     if (!trackBreadth.isLength())
 712         return CSSValuePool::singleton().createValue(trackBreadth.flex(), CSSUnitType::CSS_FR);
 713 
 714     const Length&amp; trackBreadthLength = trackBreadth.length();
 715     if (trackBreadthLength.isAuto())
 716         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
 717     return zoomAdjustedPixelValueForLength(trackBreadthLength, style);
 718 }
 719 
 720 static Ref&lt;CSSValue&gt; specifiedValueForGridTrackSize(const GridTrackSize&amp; trackSize, const RenderStyle&amp; style)
 721 {
 722     switch (trackSize.type()) {
 723     case LengthTrackSizing:
 724         return specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style);
 725     case FitContentTrackSizing: {
 726         auto fitContentTrackSize = CSSFunctionValue::create(CSSValueFitContent);
 727         fitContentTrackSize-&gt;append(zoomAdjustedPixelValueForLength(trackSize.fitContentTrackBreadth().length(), style));
 728         return fitContentTrackSize;
 729     }
 730     default:
 731         ASSERT(trackSize.type() == MinMaxTrackSizing);
 732         if (trackSize.minTrackBreadth().isAuto() &amp;&amp; trackSize.maxTrackBreadth().isFlex())
 733             return CSSValuePool::singleton().createValue(trackSize.maxTrackBreadth().flex(), CSSUnitType::CSS_FR);
 734 
 735         auto minMaxTrackBreadths = CSSFunctionValue::create(CSSValueMinmax);
 736         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.minTrackBreadth(), style));
 737         minMaxTrackBreadths-&gt;append(specifiedValueForGridTrackBreadth(trackSize.maxTrackBreadth(), style));
 738         return minMaxTrackBreadths;
 739     }
 740 }
 741 
 742 class OrderedNamedLinesCollector {
 743     WTF_MAKE_NONCOPYABLE(OrderedNamedLinesCollector);
 744 public:
 745     OrderedNamedLinesCollector(const RenderStyle&amp; style, bool isRowAxis)
 746         : m_orderedNamedGridLines(isRowAxis ? style.orderedNamedGridColumnLines() : style.orderedNamedGridRowLines())
 747         , m_orderedNamedAutoRepeatGridLines(isRowAxis ? style.autoRepeatOrderedNamedGridColumnLines() : style.autoRepeatOrderedNamedGridRowLines())
 748     {
 749     }
 750     virtual ~OrderedNamedLinesCollector() = default;
 751 
 752     bool isEmpty() const { return m_orderedNamedGridLines.isEmpty() &amp;&amp; m_orderedNamedAutoRepeatGridLines.isEmpty(); }
 753     virtual void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const;
 754 
 755 protected:
 756 
 757     enum NamedLinesType { NamedLines, AutoRepeatNamedLines };
 758     void appendLines(CSSGridLineNamesValue&amp;, unsigned index, NamedLinesType) const;
 759 
 760     const OrderedNamedGridLinesMap&amp; m_orderedNamedGridLines;
 761     const OrderedNamedGridLinesMap&amp; m_orderedNamedAutoRepeatGridLines;
 762 };
 763 
 764 class OrderedNamedLinesCollectorInsideRepeat : public OrderedNamedLinesCollector {
 765 public:
 766     OrderedNamedLinesCollectorInsideRepeat(const RenderStyle&amp; style, bool isRowAxis)
 767         : OrderedNamedLinesCollector(style, isRowAxis)
 768     {
 769     }
 770 
 771     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;
 772 };
 773 
 774 class OrderedNamedLinesCollectorInGridLayout : public OrderedNamedLinesCollector {
 775 public:
 776     OrderedNamedLinesCollectorInGridLayout(const RenderStyle&amp; style, bool isRowAxis, unsigned autoRepeatTracksCount, unsigned autoRepeatTrackListLength)
 777         : OrderedNamedLinesCollector(style, isRowAxis)
 778         , m_insertionPoint(isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint())
 779         , m_autoRepeatTotalTracks(autoRepeatTracksCount)
 780         , m_autoRepeatTrackListLength(autoRepeatTrackListLength)
 781     {
 782     }
 783 
 784     void collectLineNamesForIndex(CSSGridLineNamesValue&amp;, unsigned index) const override;
 785 
 786 private:
 787     unsigned m_insertionPoint;
 788     unsigned m_autoRepeatTotalTracks;
 789     unsigned m_autoRepeatTrackListLength;
 790 };
 791 
 792 void OrderedNamedLinesCollector::appendLines(CSSGridLineNamesValue&amp; lineNamesValue, unsigned index, NamedLinesType type) const
 793 {
 794     auto iter = type == NamedLines ? m_orderedNamedGridLines.find(index) : m_orderedNamedAutoRepeatGridLines.find(index);
 795     auto endIter = type == NamedLines ? m_orderedNamedGridLines.end() : m_orderedNamedAutoRepeatGridLines.end();
 796     if (iter == endIter)
 797         return;
 798 
 799     auto&amp; cssValuePool = CSSValuePool::singleton();
 800     for (const auto&amp; lineName : iter-&gt;value)
 801         lineNamesValue.append(cssValuePool.createValue(lineName, CSSUnitType::CSS_STRING));
 802 }
 803 
 804 void OrderedNamedLinesCollector::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
 805 {
 806     ASSERT(!isEmpty());
 807     appendLines(lineNamesValue, i, NamedLines);
 808 }
 809 
 810 void OrderedNamedLinesCollectorInsideRepeat::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
 811 {
 812     ASSERT(!isEmpty());
 813     appendLines(lineNamesValue, i, AutoRepeatNamedLines);
 814 }
 815 
 816 void OrderedNamedLinesCollectorInGridLayout::collectLineNamesForIndex(CSSGridLineNamesValue&amp; lineNamesValue, unsigned i) const
 817 {
 818     ASSERT(!isEmpty());
 819     if (!m_autoRepeatTrackListLength || i &lt; m_insertionPoint) {
 820         appendLines(lineNamesValue, i, NamedLines);
 821         return;
 822     }
 823 
 824     ASSERT(m_autoRepeatTotalTracks);
 825 
 826     if (i &gt; m_insertionPoint + m_autoRepeatTotalTracks) {
 827         appendLines(lineNamesValue, i - (m_autoRepeatTotalTracks - 1), NamedLines);
 828         return;
 829     }
 830 
 831     if (i == m_insertionPoint) {
 832         appendLines(lineNamesValue, i, NamedLines);
 833         appendLines(lineNamesValue, 0, AutoRepeatNamedLines);
 834         return;
 835     }
 836 
 837     if (i == m_insertionPoint + m_autoRepeatTotalTracks) {
 838         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
 839         appendLines(lineNamesValue, m_insertionPoint + 1, NamedLines);
 840         return;
 841     }
 842 
 843     unsigned autoRepeatIndexInFirstRepetition = (i - m_insertionPoint) % m_autoRepeatTrackListLength;
 844     if (!autoRepeatIndexInFirstRepetition &amp;&amp; i &gt; m_insertionPoint)
 845         appendLines(lineNamesValue, m_autoRepeatTrackListLength, AutoRepeatNamedLines);
 846     appendLines(lineNamesValue, autoRepeatIndexInFirstRepetition, AutoRepeatNamedLines);
 847 }
 848 
 849 static void addValuesForNamedGridLinesAtIndex(OrderedNamedLinesCollector&amp; collector, unsigned i, CSSValueList&amp; list)
 850 {
 851     if (collector.isEmpty())
 852         return;
 853 
 854     auto lineNames = CSSGridLineNamesValue::create();
 855     collector.collectLineNamesForIndex(lineNames.get(), i);
 856     if (lineNames-&gt;length())
 857         list.append(WTFMove(lineNames));
 858 }
 859 
 860 static Ref&lt;CSSValueList&gt; valueForGridTrackSizeList(GridTrackSizingDirection direction, const RenderStyle&amp; style)
 861 {
 862     auto&amp; autoTrackSizes = direction == ForColumns ? style.gridAutoColumns() : style.gridAutoRows();
 863 
 864     auto list = CSSValueList::createSpaceSeparated();
 865     for (auto&amp; trackSize : autoTrackSizes)
 866         list-&gt;append(specifiedValueForGridTrackSize(trackSize, style));
 867     return list;
 868 }
 869 
 870 template &lt;typename T, typename F&gt;
 871 void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize, unsigned start, unsigned end, unsigned offset = 0)
 872 {
 873     ASSERT(end &lt;= tracks.size());
 874     for (unsigned i = start; i &lt; end; ++i) {
 875         addValuesForNamedGridLinesAtIndex(collector, i + offset, list);
 876         list.append(getTrackSize(tracks[i]));
 877     }
 878     addValuesForNamedGridLinesAtIndex(collector, end + offset, list);
 879 }
 880 
 881 template &lt;typename T, typename F&gt;
 882 void populateGridTrackList(CSSValueList&amp; list, OrderedNamedLinesCollector&amp; collector, const Vector&lt;T&gt;&amp; tracks, F getTrackSize)
 883 {
 884     populateGridTrackList&lt;T&gt;(list, collector, tracks, getTrackSize, 0, tracks.size());
 885 }
 886 
 887 static Ref&lt;CSSValue&gt; valueForGridTrackList(GridTrackSizingDirection direction, RenderObject* renderer, const RenderStyle&amp; style)
 888 {
 889     bool isRowAxis = direction == ForColumns;
 890     bool isRenderGrid = is&lt;RenderGrid&gt;(renderer);
 891     auto&amp; trackSizes = isRowAxis ? style.gridColumns() : style.gridRows();
 892     auto&amp; autoRepeatTrackSizes = isRowAxis ? style.gridAutoRepeatColumns() : style.gridAutoRepeatRows();
 893 
 894     // Handle the &#39;none&#39; case.
 895     if (trackSizes.isEmpty() &amp;&amp; autoRepeatTrackSizes.isEmpty())
 896         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 897 
 898     auto list = CSSValueList::createSpaceSeparated();
 899 
 900     // If the element is a grid container, the resolved value is the used value,
 901     // specifying track sizes in pixels and expanding the repeat() notation.
 902     if (isRenderGrid) {
 903         auto* grid = downcast&lt;RenderGrid&gt;(renderer);
 904         OrderedNamedLinesCollectorInGridLayout collector(style, isRowAxis, grid-&gt;autoRepeatCountForDirection(direction), autoRepeatTrackSizes.size());
 905         populateGridTrackList(list.get(), collector, grid-&gt;trackSizesForComputedStyle(direction), [&amp;](const LayoutUnit&amp; v) {
 906             return zoomAdjustedPixelValue(v, style);
 907         });
 908         return list;
 909     }
 910 
 911     // Otherwise, the resolved value is the computed value, preserving repeat().
 912     OrderedNamedLinesCollector collector(style, isRowAxis);
 913     auto getTrackSize = [&amp;](const GridTrackSize&amp; v) {
 914         return specifiedValueForGridTrackSize(v, style);
 915     };
 916 
 917     if (autoRepeatTrackSizes.isEmpty()) {
 918         // If there&#39;s no auto repeat(), just add all the line names and track sizes.
 919         populateGridTrackList(list.get(), collector, trackSizes, getTrackSize);
 920         return list;
 921     }
 922 
 923     // Add the line names and track sizes that precede the auto repeat().
 924     unsigned autoRepeatInsertionPoint = isRowAxis ? style.gridAutoRepeatColumnsInsertionPoint() : style.gridAutoRepeatRowsInsertionPoint();
 925     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, 0, autoRepeatInsertionPoint);
 926 
 927     // Add a CSSGridAutoRepeatValue with the contents of the auto repeat().
 928     AutoRepeatType autoRepeatType = isRowAxis ? style.gridAutoRepeatColumnsType() : style.gridAutoRepeatRowsType();
 929     auto repeatedValues = CSSGridAutoRepeatValue::create(autoRepeatType == AutoRepeatType::Fill ? CSSValueAutoFill : CSSValueAutoFit);
 930     OrderedNamedLinesCollectorInsideRepeat repeatCollector(style, isRowAxis);
 931     populateGridTrackList(repeatedValues.get(), repeatCollector, autoRepeatTrackSizes, getTrackSize);
 932     list-&gt;append(repeatedValues.get());
 933 
 934     // Add the line names and track sizes that follow the auto repeat().
 935     populateGridTrackList(list.get(), collector, trackSizes, getTrackSize, autoRepeatInsertionPoint, trackSizes.size(), 1);
 936     return list;
 937 }
 938 
 939 static Ref&lt;CSSValue&gt; valueForGridPosition(const GridPosition&amp; position)
 940 {
 941     auto&amp; cssValuePool = CSSValuePool::singleton();
 942     if (position.isAuto())
 943         return cssValuePool.createIdentifierValue(CSSValueAuto);
 944 
 945     if (position.isNamedGridArea())
 946         return cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING);
 947 
 948     auto list = CSSValueList::createSpaceSeparated();
 949     if (position.isSpan()) {
 950         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpan));
 951         list-&gt;append(cssValuePool.createValue(position.spanPosition(), CSSUnitType::CSS_NUMBER));
 952     } else
 953         list-&gt;append(cssValuePool.createValue(position.integerPosition(), CSSUnitType::CSS_NUMBER));
 954 
 955     if (!position.namedGridLine().isNull())
 956         list-&gt;append(cssValuePool.createValue(position.namedGridLine(), CSSUnitType::CSS_STRING));
 957     return list;
 958 }
 959 
 960 static Ref&lt;CSSValue&gt; createTransitionPropertyValue(const Animation&amp; animation)
 961 {
 962     switch (animation.animationMode()) {
 963     case Animation::AnimateNone:
 964         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 965     case Animation::AnimateAll:
 966         return CSSValuePool::singleton().createIdentifierValue(CSSValueAll);
 967     case Animation::AnimateSingleProperty:
 968         return CSSValuePool::singleton().createValue(getPropertyNameString(animation.property()), CSSUnitType::CSS_STRING);
 969     case Animation::AnimateUnknownProperty:
 970         return CSSValuePool::singleton().createValue(animation.unknownProperty(), CSSUnitType::CSS_STRING);
 971     }
 972     ASSERT_NOT_REACHED();
 973     return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
 974 }
 975 
 976 static Ref&lt;CSSValueList&gt; transitionPropertyValue(const AnimationList* animationList)
 977 {
 978     auto list = CSSValueList::createCommaSeparated();
 979     if (animationList) {
 980         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
 981             list-&gt;append(createTransitionPropertyValue(animationList-&gt;animation(i)));
 982     } else
 983         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAll));
 984     return list;
 985 }
 986 
 987 #if ENABLE(CSS_SCROLL_SNAP)
 988 
 989 static Ref&lt;CSSValueList&gt; valueForScrollSnapType(const ScrollSnapType&amp; type)
 990 {
 991     auto value = CSSValueList::createSpaceSeparated();
 992     if (type.strictness == ScrollSnapStrictness::None)
 993         value-&gt;append(CSSValuePool::singleton().createValue(CSSValueNone));
 994     else {
 995         value-&gt;append(CSSPrimitiveValue::create(type.axis));
 996         value-&gt;append(CSSPrimitiveValue::create(type.strictness));
 997     }
 998     return value;
 999 }
1000 
1001 static Ref&lt;CSSValueList&gt; valueForScrollSnapAlignment(const ScrollSnapAlign&amp; alignment)
1002 {
1003     auto value = CSSValueList::createSpaceSeparated();
1004     value-&gt;append(CSSPrimitiveValue::create(alignment.x));
1005     value-&gt;append(CSSPrimitiveValue::create(alignment.y));
1006     return value;
1007 }
1008 
1009 #endif
1010 
1011 static Ref&lt;CSSValue&gt; willChangePropertyValue(const WillChangeData* willChangeData)
1012 {
1013     auto&amp; cssValuePool = CSSValuePool::singleton();
1014     if (!willChangeData || !willChangeData-&gt;numFeatures())
1015         return cssValuePool.createIdentifierValue(CSSValueAuto);
1016 
1017     auto list = CSSValueList::createCommaSeparated();
1018     for (size_t i = 0; i &lt; willChangeData-&gt;numFeatures(); ++i) {
1019         WillChangeData::FeaturePropertyPair feature = willChangeData-&gt;featureAt(i);
1020         switch (feature.first) {
1021         case WillChangeData::ScrollPosition:
1022             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueScrollPosition));
1023             break;
1024         case WillChangeData::Contents:
1025             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueContents));
1026             break;
1027         case WillChangeData::Property:
1028             list-&gt;append(cssValuePool.createIdentifierValue(feature.second));
1029             break;
1030         case WillChangeData::Invalid:
1031             ASSERT_NOT_REACHED();
1032             break;
1033         }
1034     }
1035 
1036     return list;
1037 }
1038 
1039 static inline void appendLigaturesValue(CSSValueList&amp; list, FontVariantLigatures value, CSSValueID yesValue, CSSValueID noValue)
1040 {
1041     switch (value) {
1042     case FontVariantLigatures::Normal:
1043         return;
1044     case FontVariantLigatures::No:
1045         list.append(CSSValuePool::singleton().createIdentifierValue(noValue));
1046         return;
1047     case FontVariantLigatures::Yes:
1048         list.append(CSSValuePool::singleton().createIdentifierValue(yesValue));
1049         return;
1050     }
1051     ASSERT_NOT_REACHED();
1052 }
1053 
1054 static Ref&lt;CSSValue&gt; fontVariantLigaturesPropertyValue(FontVariantLigatures common, FontVariantLigatures discretionary, FontVariantLigatures historical, FontVariantLigatures contextualAlternates)
1055 {
1056     auto&amp; cssValuePool = CSSValuePool::singleton();
1057     if (common == FontVariantLigatures::No &amp;&amp; discretionary == FontVariantLigatures::No &amp;&amp; historical == FontVariantLigatures::No &amp;&amp; contextualAlternates == FontVariantLigatures::No)
1058         return cssValuePool.createIdentifierValue(CSSValueNone);
1059     if (common == FontVariantLigatures::Normal &amp;&amp; discretionary == FontVariantLigatures::Normal &amp;&amp; historical == FontVariantLigatures::Normal &amp;&amp; contextualAlternates == FontVariantLigatures::Normal)
1060         return cssValuePool.createIdentifierValue(CSSValueNormal);
1061 
1062     auto valueList = CSSValueList::createSpaceSeparated();
1063     appendLigaturesValue(valueList, common, CSSValueCommonLigatures, CSSValueNoCommonLigatures);
1064     appendLigaturesValue(valueList, discretionary, CSSValueDiscretionaryLigatures, CSSValueNoDiscretionaryLigatures);
1065     appendLigaturesValue(valueList, historical, CSSValueHistoricalLigatures, CSSValueNoHistoricalLigatures);
1066     appendLigaturesValue(valueList, contextualAlternates, CSSValueContextual, CSSValueNoContextual);
1067     return valueList;
1068 }
1069 
1070 static Ref&lt;CSSValue&gt; fontVariantPositionPropertyValue(FontVariantPosition position)
1071 {
1072     auto&amp; cssValuePool = CSSValuePool::singleton();
1073     CSSValueID valueID = CSSValueNormal;
1074     switch (position) {
1075     case FontVariantPosition::Normal:
1076         break;
1077     case FontVariantPosition::Subscript:
1078         valueID = CSSValueSub;
1079         break;
1080     case FontVariantPosition::Superscript:
1081         valueID = CSSValueSuper;
1082         break;
1083     }
1084     return cssValuePool.createIdentifierValue(valueID);
1085 }
1086 
1087 static Ref&lt;CSSValue&gt; fontVariantCapsPropertyValue(FontVariantCaps caps)
1088 {
1089     auto&amp; cssValuePool = CSSValuePool::singleton();
1090     CSSValueID valueID = CSSValueNormal;
1091     switch (caps) {
1092     case FontVariantCaps::Normal:
1093         break;
1094     case FontVariantCaps::Small:
1095         valueID = CSSValueSmallCaps;
1096         break;
1097     case FontVariantCaps::AllSmall:
1098         valueID = CSSValueAllSmallCaps;
1099         break;
1100     case FontVariantCaps::Petite:
1101         valueID = CSSValuePetiteCaps;
1102         break;
1103     case FontVariantCaps::AllPetite:
1104         valueID = CSSValueAllPetiteCaps;
1105         break;
1106     case FontVariantCaps::Unicase:
1107         valueID = CSSValueUnicase;
1108         break;
1109     case FontVariantCaps::Titling:
1110         valueID = CSSValueTitlingCaps;
1111         break;
1112     }
1113     return cssValuePool.createIdentifierValue(valueID);
1114 }
1115 
1116 static Ref&lt;CSSValue&gt; fontVariantNumericPropertyValue(FontVariantNumericFigure figure, FontVariantNumericSpacing spacing, FontVariantNumericFraction fraction, FontVariantNumericOrdinal ordinal, FontVariantNumericSlashedZero slashedZero)
1117 {
1118     auto&amp; cssValuePool = CSSValuePool::singleton();
1119     if (figure == FontVariantNumericFigure::Normal &amp;&amp; spacing == FontVariantNumericSpacing::Normal &amp;&amp; fraction == FontVariantNumericFraction::Normal &amp;&amp; ordinal == FontVariantNumericOrdinal::Normal &amp;&amp; slashedZero == FontVariantNumericSlashedZero::Normal)
1120         return cssValuePool.createIdentifierValue(CSSValueNormal);
1121 
1122     auto valueList = CSSValueList::createSpaceSeparated();
1123     switch (figure) {
1124     case FontVariantNumericFigure::Normal:
1125         break;
1126     case FontVariantNumericFigure::LiningNumbers:
1127         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiningNums));
1128         break;
1129     case FontVariantNumericFigure::OldStyleNumbers:
1130         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOldstyleNums));
1131         break;
1132     }
1133 
1134     switch (spacing) {
1135     case FontVariantNumericSpacing::Normal:
1136         break;
1137     case FontVariantNumericSpacing::ProportionalNumbers:
1138         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalNums));
1139         break;
1140     case FontVariantNumericSpacing::TabularNumbers:
1141         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTabularNums));
1142         break;
1143     }
1144 
1145     switch (fraction) {
1146     case FontVariantNumericFraction::Normal:
1147         break;
1148     case FontVariantNumericFraction::DiagonalFractions:
1149         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueDiagonalFractions));
1150         break;
1151     case FontVariantNumericFraction::StackedFractions:
1152         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueStackedFractions));
1153         break;
1154     }
1155 
1156     if (ordinal == FontVariantNumericOrdinal::Yes)
1157         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueOrdinal));
1158     if (slashedZero == FontVariantNumericSlashedZero::Yes)
1159         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSlashedZero));
1160 
1161     return valueList;
1162 }
1163 
1164 static Ref&lt;CSSValue&gt; fontVariantAlternatesPropertyValue(FontVariantAlternates alternates)
1165 {
1166     auto&amp; cssValuePool = CSSValuePool::singleton();
1167     CSSValueID valueID = CSSValueNormal;
1168     switch (alternates) {
1169     case FontVariantAlternates::Normal:
1170         break;
1171     case FontVariantAlternates::HistoricalForms:
1172         valueID = CSSValueHistoricalForms;
1173         break;
1174     }
1175     return cssValuePool.createIdentifierValue(valueID);
1176 }
1177 
1178 static Ref&lt;CSSValue&gt; fontVariantEastAsianPropertyValue(FontVariantEastAsianVariant variant, FontVariantEastAsianWidth width, FontVariantEastAsianRuby ruby)
1179 {
1180     auto&amp; cssValuePool = CSSValuePool::singleton();
1181     if (variant == FontVariantEastAsianVariant::Normal &amp;&amp; width == FontVariantEastAsianWidth::Normal &amp;&amp; ruby == FontVariantEastAsianRuby::Normal)
1182         return cssValuePool.createIdentifierValue(CSSValueNormal);
1183 
1184     auto valueList = CSSValueList::createSpaceSeparated();
1185     switch (variant) {
1186     case FontVariantEastAsianVariant::Normal:
1187         break;
1188     case FontVariantEastAsianVariant::Jis78:
1189         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis78));
1190         break;
1191     case FontVariantEastAsianVariant::Jis83:
1192         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis83));
1193         break;
1194     case FontVariantEastAsianVariant::Jis90:
1195         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis90));
1196         break;
1197     case FontVariantEastAsianVariant::Jis04:
1198         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueJis04));
1199         break;
1200     case FontVariantEastAsianVariant::Simplified:
1201         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueSimplified));
1202         break;
1203     case FontVariantEastAsianVariant::Traditional:
1204         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueTraditional));
1205         break;
1206     }
1207 
1208     switch (width) {
1209     case FontVariantEastAsianWidth::Normal:
1210         break;
1211     case FontVariantEastAsianWidth::Full:
1212         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueFullWidth));
1213         break;
1214     case FontVariantEastAsianWidth::Proportional:
1215         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueProportionalWidth));
1216         break;
1217     }
1218 
1219     if (ruby == FontVariantEastAsianRuby::Yes)
1220         valueList-&gt;append(cssValuePool.createIdentifierValue(CSSValueRuby));
1221 
1222     return valueList;
1223 }
1224 
1225 static Ref&lt;CSSValueList&gt; delayValue(const AnimationList* animationList)
1226 {
1227     auto&amp; cssValuePool = CSSValuePool::singleton();
1228     auto list = CSSValueList::createCommaSeparated();
1229     if (animationList) {
1230         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1231             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).delay(), CSSUnitType::CSS_S));
1232     } else {
1233         // Note that initialAnimationDelay() is used for both transitions and animations
1234         list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));
1235     }
1236     return list;
1237 }
1238 
1239 static Ref&lt;CSSValueList&gt; durationValue(const AnimationList* animationList)
1240 {
1241     auto&amp; cssValuePool = CSSValuePool::singleton();
1242     auto list = CSSValueList::createCommaSeparated();
1243     if (animationList) {
1244         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1245             list-&gt;append(cssValuePool.createValue(animationList-&gt;animation(i).duration(), CSSUnitType::CSS_S));
1246     } else {
1247         // Note that initialAnimationDuration() is used for both transitions and animations
1248         list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));
1249     }
1250     return list;
1251 }
1252 
1253 static Ref&lt;CSSValue&gt; createTimingFunctionValue(const TimingFunction&amp; timingFunction)
1254 {
1255     switch (timingFunction.type()) {
1256     case TimingFunction::CubicBezierFunction: {
1257         auto&amp; function = downcast&lt;CubicBezierTimingFunction&gt;(timingFunction);
1258         if (function.timingFunctionPreset() != CubicBezierTimingFunction::Custom) {
1259             CSSValueID valueId = CSSValueInvalid;
1260             switch (function.timingFunctionPreset()) {
1261             case CubicBezierTimingFunction::Ease:
1262                 valueId = CSSValueEase;
1263                 break;
1264             case CubicBezierTimingFunction::EaseIn:
1265                 valueId = CSSValueEaseIn;
1266                 break;
1267             case CubicBezierTimingFunction::EaseOut:
1268                 valueId = CSSValueEaseOut;
1269                 break;
1270             default:
1271                 ASSERT(function.timingFunctionPreset() == CubicBezierTimingFunction::EaseInOut);
1272                 valueId = CSSValueEaseInOut;
1273                 break;
1274             }
1275             return CSSValuePool::singleton().createIdentifierValue(valueId);
1276         }
1277         return CSSCubicBezierTimingFunctionValue::create(function.x1(), function.y1(), function.x2(), function.y2());
1278     }
1279     case TimingFunction::StepsFunction: {
1280         auto&amp; function = downcast&lt;StepsTimingFunction&gt;(timingFunction);
1281         return CSSStepsTimingFunctionValue::create(function.numberOfSteps(), function.stepAtStart());
1282     }
1283     case TimingFunction::SpringFunction: {
1284         auto&amp; function = downcast&lt;SpringTimingFunction&gt;(timingFunction);
1285         return CSSSpringTimingFunctionValue::create(function.mass(), function.stiffness(), function.damping(), function.initialVelocity());
1286     }
1287     default:
1288         ASSERT(timingFunction.type() == TimingFunction::LinearFunction);
1289         return CSSValuePool::singleton().createIdentifierValue(CSSValueLinear);
1290     }
1291 }
1292 
1293 static Ref&lt;CSSValueList&gt; timingFunctionValue(const AnimationList* animationList)
1294 {
1295     auto list = CSSValueList::createCommaSeparated();
1296     if (animationList) {
1297         for (size_t i = 0; i &lt; animationList-&gt;size(); ++i)
1298             list-&gt;append(createTimingFunctionValue(*animationList-&gt;animation(i).timingFunction()));
1299     } else
1300         // Note that initialAnimationTimingFunction() is used for both transitions and animations
1301         list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
1302     return list;
1303 }
1304 
1305 static Ref&lt;CSSValue&gt; createLineBoxContainValue(OptionSet&lt;LineBoxContain&gt; lineBoxContain)
1306 {
1307     if (!lineBoxContain)
1308         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1309     return CSSLineBoxContainValue::create(lineBoxContain);
1310 }
1311 
1312 static Element* styleElementForNode(Node* node)
1313 {
1314     if (!node)
1315         return nullptr;
1316     if (is&lt;Element&gt;(*node))
1317         return downcast&lt;Element&gt;(node);
1318     return composedTreeAncestors(*node).first();
1319 }
1320 
1321 ComputedStyleExtractor::ComputedStyleExtractor(Node* node, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1322     : m_element(styleElementForNode(node))
1323     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1324     , m_allowVisitedStyle(allowVisitedStyle)
1325 {
1326 }
1327 
1328 ComputedStyleExtractor::ComputedStyleExtractor(Element* element, bool allowVisitedStyle, PseudoId pseudoElementSpecifier)
1329     : m_element(element)
1330     , m_pseudoElementSpecifier(pseudoElementSpecifier)
1331     , m_allowVisitedStyle(allowVisitedStyle)
1332 {
1333 }
1334 
1335 CSSComputedStyleDeclaration::CSSComputedStyleDeclaration(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)
1336     : m_element(element)
1337     , m_allowVisitedStyle(allowVisitedStyle)
1338 {
1339     StringView name = pseudoElementName;
1340     if (name.startsWith(&#39;:&#39;))
1341         name = name.substring(1);
1342     if (name.startsWith(&#39;:&#39;))
1343         name = name.substring(1);
1344     m_pseudoElementSpecifier = CSSSelector::pseudoId(CSSSelector::parsePseudoElementType(name));
1345 }
1346 
1347 CSSComputedStyleDeclaration::~CSSComputedStyleDeclaration() = default;
1348 
1349 Ref&lt;CSSComputedStyleDeclaration&gt; CSSComputedStyleDeclaration::create(Element&amp; element, bool allowVisitedStyle, StringView pseudoElementName)
1350 {
1351     return adoptRef(*new CSSComputedStyleDeclaration(element, allowVisitedStyle, pseudoElementName));
1352 }
1353 
1354 void CSSComputedStyleDeclaration::ref()
1355 {
1356     ++m_refCount;
1357 }
1358 
1359 void CSSComputedStyleDeclaration::deref()
1360 {
1361     ASSERT(m_refCount);
1362     if (!--m_refCount)
1363         delete this;
1364 }
1365 
1366 String CSSComputedStyleDeclaration::cssText() const
1367 {
1368     StringBuilder result;
1369     for (unsigned i = 0; i &lt; numComputedPropertyIDs; i++) {
1370         if (i)
1371             result.append(&#39; &#39;);
1372         result.append(getPropertyName(computedPropertyIDs[i]), &quot;: &quot;, getPropertyValue(computedPropertyIDs[i]), &#39;;&#39;);
1373     }
1374     return result.toString();
1375 }
1376 
1377 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setCssText(const String&amp;)
1378 {
1379     return Exception { NoModificationAllowedError };
1380 }
1381 
1382 RefPtr&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::getFontSizeCSSValuePreferringKeyword()
1383 {
1384     if (!m_element)
1385         return nullptr;
1386 
1387     m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
1388 
1389     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1390     if (!style)
1391         return nullptr;
1392 
1393     if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier())
1394         return CSSValuePool::singleton().createIdentifierValue(sizeIdentifier);
1395 
1396     return zoomAdjustedPixelValue(style-&gt;fontDescription().computedSize(), *style);
1397 }
1398 
1399 bool ComputedStyleExtractor::useFixedFontDefaultSize()
1400 {
1401     if (!m_element)
1402         return false;
1403     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
1404     if (!style)
1405         return false;
1406 
1407     return style-&gt;fontDescription().useFixedDefaultSize();
1408 }
1409 
1410 static CSSValueID identifierForFamily(const AtomString&amp; family)
1411 {
1412     if (family == cursiveFamily)
1413         return CSSValueCursive;
1414     if (family == fantasyFamily)
1415         return CSSValueFantasy;
1416     if (family == monospaceFamily)
1417         return CSSValueMonospace;
1418     if (family == pictographFamily)
1419         return CSSValueWebkitPictograph;
1420     if (family == sansSerifFamily)
1421         return CSSValueSansSerif;
1422     if (family == serifFamily)
1423         return CSSValueSerif;
1424     if (family == systemUiFamily)
1425         return CSSValueSystemUi;
1426     return CSSValueInvalid;
1427 }
1428 
1429 static Ref&lt;CSSPrimitiveValue&gt; valueForFamily(const AtomString&amp; family)
1430 {
1431     if (CSSValueID familyIdentifier = identifierForFamily(family))
1432         return CSSValuePool::singleton().createIdentifierValue(familyIdentifier);
1433     return CSSValuePool::singleton().createFontFamilyValue(family);
1434 }
1435 
1436 #if ENABLE(POINTER_EVENTS)
1437 static Ref&lt;CSSValue&gt; touchActionFlagsToCSSValue(OptionSet&lt;TouchAction&gt; touchActions)
1438 {
1439     auto&amp; cssValuePool = CSSValuePool::singleton();
1440 
1441     if (touchActions &amp; TouchAction::Auto)
1442         return cssValuePool.createIdentifierValue(CSSValueAuto);
1443     if (touchActions &amp; TouchAction::None)
1444         return cssValuePool.createIdentifierValue(CSSValueNone);
1445     if (touchActions &amp; TouchAction::Manipulation)
1446         return cssValuePool.createIdentifierValue(CSSValueManipulation);
1447 
1448     auto list = CSSValueList::createSpaceSeparated();
1449     if (touchActions &amp; TouchAction::PanX)
1450         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanX));
1451     if (touchActions &amp; TouchAction::PanY)
1452         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePanY));
1453     if (touchActions &amp; TouchAction::PinchZoom)
1454         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePinchZoom));
1455 
1456     if (!list-&gt;length())
1457         return cssValuePool.createIdentifierValue(CSSValueAuto);
1458     return list;
1459 }
1460 #endif
1461 
1462 static Ref&lt;CSSValue&gt; renderTextDecorationFlagsToCSSValue(OptionSet&lt;TextDecoration&gt; textDecoration)
1463 {
1464     auto&amp; cssValuePool = CSSValuePool::singleton();
1465     // Blink value is ignored.
1466     auto list = CSSValueList::createSpaceSeparated();
1467     if (textDecoration &amp; TextDecoration::Underline)
1468         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnderline));
1469     if (textDecoration &amp; TextDecoration::Overline)
1470         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOverline));
1471     if (textDecoration &amp; TextDecoration::LineThrough)
1472         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLineThrough));
1473 #if ENABLE(LETTERPRESS)
1474     if (textDecoration &amp; TextDecoration::Letterpress)
1475         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitLetterpress));
1476 #endif
1477 
1478     if (!list-&gt;length())
1479         return cssValuePool.createIdentifierValue(CSSValueNone);
1480     return list;
1481 }
1482 
1483 static Ref&lt;CSSValue&gt; renderTextDecorationStyleFlagsToCSSValue(TextDecorationStyle textDecorationStyle)
1484 {
1485     switch (textDecorationStyle) {
1486     case TextDecorationStyle::Solid:
1487         return CSSValuePool::singleton().createIdentifierValue(CSSValueSolid);
1488     case TextDecorationStyle::Double:
1489         return CSSValuePool::singleton().createIdentifierValue(CSSValueDouble);
1490     case TextDecorationStyle::Dotted:
1491         return CSSValuePool::singleton().createIdentifierValue(CSSValueDotted);
1492     case TextDecorationStyle::Dashed:
1493         return CSSValuePool::singleton().createIdentifierValue(CSSValueDashed);
1494     case TextDecorationStyle::Wavy:
1495         return CSSValuePool::singleton().createIdentifierValue(CSSValueWavy);
1496     }
1497 
1498     ASSERT_NOT_REACHED();
1499     return CSSValuePool::singleton().createExplicitInitialValue();
1500 }
1501 
1502 static Ref&lt;CSSValue&gt; renderTextDecorationSkipFlagsToCSSValue(OptionSet&lt;TextDecorationSkip&gt; textDecorationSkip)
1503 {
1504     // FIXME: This should probably return a CSSValueList with the set of all TextDecorationSkips.
1505     switch (static_cast&lt;TextDecorationSkip&gt;(textDecorationSkip.toRaw())) {
1506     case TextDecorationSkip::Auto:
1507         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1508     case TextDecorationSkip::None:
1509         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1510     case TextDecorationSkip::Ink:
1511         return CSSValuePool::singleton().createIdentifierValue(CSSValueInk);
1512     case TextDecorationSkip::Objects:
1513         return CSSValuePool::singleton().createIdentifierValue(CSSValueObjects);
1514     }
1515 
1516     ASSERT_NOT_REACHED();
1517     return CSSValuePool::singleton().createExplicitInitialValue();
1518 }
1519 
1520 static Ref&lt;CSSValue&gt; textUnderlineOffsetToCSSValue(const TextUnderlineOffset&amp; textUnderlineOffset)
1521 {
1522     if (textUnderlineOffset.isAuto())
1523         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1524     ASSERT(textUnderlineOffset.isLength());
1525     return CSSValuePool::singleton().createValue(textUnderlineOffset.lengthValue(), CSSUnitType::CSS_PX);
1526 }
1527 
1528 static Ref&lt;CSSValue&gt; textDecorationThicknessToCSSValue(const TextDecorationThickness&amp; textDecorationThickness)
1529 {
1530     if (textDecorationThickness.isAuto())
1531         return CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);
1532     if (textDecorationThickness.isFromFont())
1533         return CSSValuePool::singleton().createIdentifierValue(CSSValueFromFont);
1534     ASSERT(textDecorationThickness.isLength());
1535     return CSSValuePool::singleton().createValue(textDecorationThickness.lengthValue(), CSSUnitType::CSS_PX);
1536 }
1537 
1538 static Ref&lt;CSSValue&gt; renderEmphasisPositionFlagsToCSSValue(OptionSet&lt;TextEmphasisPosition&gt; textEmphasisPosition)
1539 {
1540     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Over) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Under)));
1541     ASSERT(!((textEmphasisPosition &amp; TextEmphasisPosition::Left) &amp;&amp; (textEmphasisPosition &amp; TextEmphasisPosition::Right)));
1542     auto&amp; cssValuePool = CSSValuePool::singleton();
1543     auto list = CSSValueList::createSpaceSeparated();
1544     if (textEmphasisPosition &amp; TextEmphasisPosition::Over)
1545         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOver));
1546     if (textEmphasisPosition &amp; TextEmphasisPosition::Under)
1547         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueUnder));
1548     if (textEmphasisPosition &amp; TextEmphasisPosition::Left)
1549         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLeft));
1550     if (textEmphasisPosition &amp; TextEmphasisPosition::Right)
1551         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRight));
1552     if (!list-&gt;length())
1553         return cssValuePool.createIdentifierValue(CSSValueNone);
1554     return list;
1555 }
1556 
1557 static Ref&lt;CSSValue&gt; speakAsToCSSValue(OptionSet&lt;SpeakAs&gt; speakAs)
1558 {
1559     auto&amp; cssValuePool = CSSValuePool::singleton();
1560     auto list = CSSValueList::createSpaceSeparated();
1561     if (speakAs &amp; SpeakAs::SpellOut)
1562         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueSpellOut));
1563     if (speakAs &amp; SpeakAs::Digits)
1564         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDigits));
1565     if (speakAs &amp; SpeakAs::LiteralPunctuation)
1566         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLiteralPunctuation));
1567     if (speakAs &amp; SpeakAs::NoPunctuation)
1568         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNoPunctuation));
1569     if (!list-&gt;length())
1570         return cssValuePool.createIdentifierValue(CSSValueNormal);
1571     return list;
1572 }
1573 
1574 static Ref&lt;CSSValue&gt; hangingPunctuationToCSSValue(OptionSet&lt;HangingPunctuation&gt; hangingPunctuation)
1575 {
1576     auto&amp; cssValuePool = CSSValuePool::singleton();
1577     auto list = CSSValueList::createSpaceSeparated();
1578     if (hangingPunctuation &amp; HangingPunctuation::First)
1579         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueFirst));
1580     if (hangingPunctuation &amp; HangingPunctuation::AllowEnd)
1581         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAllowEnd));
1582     if (hangingPunctuation &amp; HangingPunctuation::ForceEnd)
1583         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForceEnd));
1584     if (hangingPunctuation &amp; HangingPunctuation::Last)
1585         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
1586     if (!list-&gt;length())
1587         return cssValuePool.createIdentifierValue(CSSValueNone);
1588     return list;
1589 }
1590 
1591 static Ref&lt;CSSValue&gt; fillRepeatToCSSValue(FillRepeat xRepeat, FillRepeat yRepeat)
1592 {
1593     // For backwards compatibility, if both values are equal, just return one of them. And
1594     // if the two values are equivalent to repeat-x or repeat-y, just return the shorthand.
1595     auto&amp; cssValuePool = CSSValuePool::singleton();
1596     if (xRepeat == yRepeat)
1597         return cssValuePool.createValue(xRepeat);
1598     if (xRepeat == FillRepeat::Repeat &amp;&amp; yRepeat == FillRepeat::NoRepeat)
1599         return cssValuePool.createIdentifierValue(CSSValueRepeatX);
1600     if (xRepeat == FillRepeat::NoRepeat &amp;&amp; yRepeat == FillRepeat::Repeat)
1601         return cssValuePool.createIdentifierValue(CSSValueRepeatY);
1602 
1603     auto list = CSSValueList::createSpaceSeparated();
1604     list-&gt;append(cssValuePool.createValue(xRepeat));
1605     list-&gt;append(cssValuePool.createValue(yRepeat));
1606     return list;
1607 }
1608 
1609 static Ref&lt;CSSValue&gt; fillSourceTypeToCSSValue(MaskSourceType type)
1610 {
1611     switch (type) {
1612     case MaskSourceType::Alpha:
1613         return CSSValuePool::singleton().createValue(CSSValueAlpha);
1614     default:
1615         ASSERT(type == MaskSourceType::Luminance);
1616         return CSSValuePool::singleton().createValue(CSSValueLuminance);
1617     }
1618 }
1619 
1620 static Ref&lt;CSSValue&gt; fillSizeToCSSValue(const FillSize&amp; fillSize, const RenderStyle&amp; style)
1621 {
1622     if (fillSize.type == FillSizeType::Contain)
1623         return CSSValuePool::singleton().createIdentifierValue(CSSValueContain);
1624 
1625     if (fillSize.type == FillSizeType::Cover)
1626         return CSSValuePool::singleton().createIdentifierValue(CSSValueCover);
1627 
1628     if (fillSize.size.height.isAuto())
1629         return zoomAdjustedPixelValueForLength(fillSize.size.width, style);
1630 
1631     auto list = CSSValueList::createSpaceSeparated();
1632     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.width, style));
1633     list-&gt;append(zoomAdjustedPixelValueForLength(fillSize.size.height, style));
1634     return list;
1635 }
1636 
1637 static Ref&lt;CSSValue&gt; altTextToCSSValue(const RenderStyle&amp; style)
1638 {
1639     return CSSValuePool::singleton().createValue(style.contentAltText(), CSSUnitType::CSS_STRING);
1640 }
1641 
1642 static Ref&lt;CSSValueList&gt; contentToCSSValue(const RenderStyle&amp; style)
1643 {
1644     auto&amp; cssValuePool = CSSValuePool::singleton();
1645     auto list = CSSValueList::createSpaceSeparated();
1646     for (auto* contentData = style.contentData(); contentData; contentData = contentData-&gt;next()) {
1647         if (is&lt;CounterContentData&gt;(*contentData))
1648             list-&gt;append(cssValuePool.createValue(downcast&lt;CounterContentData&gt;(*contentData).counter().identifier(), CSSUnitType::CSS_COUNTER_NAME));
1649         else if (is&lt;ImageContentData&gt;(*contentData))
1650             list-&gt;append(downcast&lt;ImageContentData&gt;(*contentData).image().cssValue());
1651         else if (is&lt;TextContentData&gt;(*contentData))
1652             list-&gt;append(cssValuePool.createValue(downcast&lt;TextContentData&gt;(*contentData).text(), CSSUnitType::CSS_STRING));
1653     }
1654     return list;
1655 }
1656 
1657 static Ref&lt;CSSValue&gt; counterToCSSValue(const RenderStyle&amp; style, CSSPropertyID propertyID)
1658 {
1659     auto* map = style.counterDirectives();
1660     if (!map)
1661         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1662 
1663     auto&amp; cssValuePool = CSSValuePool::singleton();
1664     auto list = CSSValueList::createSpaceSeparated();
1665     for (auto&amp; keyValue : *map) {
1666         list-&gt;append(cssValuePool.createValue(keyValue.key, CSSUnitType::CSS_STRING));
1667         double number = (propertyID == CSSPropertyCounterIncrement ? keyValue.value.incrementValue : keyValue.value.resetValue).valueOr(0);
1668         list-&gt;append(cssValuePool.createValue(number, CSSUnitType::CSS_NUMBER));
1669     }
1670     return list;
1671 }
1672 
1673 static Ref&lt;CSSValueList&gt; fontFamilyListFromStyle(const RenderStyle&amp; style)
1674 {
1675     auto list = CSSValueList::createCommaSeparated();
1676     for (unsigned i = 0; i &lt; style.fontCascade().familyCount(); ++i)
1677         list-&gt;append(valueForFamily(style.fontCascade().familyAt(i)));
1678     return list;
1679 }
1680 
1681 static Ref&lt;CSSValue&gt; fontFamilyFromStyle(const RenderStyle&amp; style)
1682 {
1683     if (style.fontCascade().familyCount() == 1)
1684         return valueForFamily(style.fontCascade().familyAt(0));
1685     return fontFamilyListFromStyle(style);
1686 }
1687 
1688 static Ref&lt;CSSPrimitiveValue&gt; lineHeightFromStyle(const RenderStyle&amp; style)
1689 {
1690     Length length = style.lineHeight();
1691     if (length.isNegative())
1692         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
1693     if (length.isPercent()) {
1694         // This is imperfect, because it doesn&#39;t include the zoom factor and the real computation
1695         // for how high to be in pixels does include things like minimum font size and the zoom factor.
1696         // On the other hand, since font-size doesn&#39;t include the zoom factor, we really can&#39;t do
1697         // that here either.
1698         return zoomAdjustedPixelValue(static_cast&lt;int&gt;(length.percent() * style.fontDescription().computedSize()) / 100, style);
1699     }
1700     return zoomAdjustedPixelValue(floatValueForLength(length, 0), style);
1701 }
1702 
1703 static Ref&lt;CSSPrimitiveValue&gt; fontSizeFromStyle(const RenderStyle&amp; style)
1704 {
1705     return zoomAdjustedPixelValue(style.fontDescription().computedSize(), style);
1706 }
1707 
1708 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordWeightFromStyleValue(FontSelectionValue weight)
1709 {
1710     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);
1711 }
1712 
1713 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontWeightFromStyleValue(FontSelectionValue weight)
1714 {
1715     if (auto value = fontWeightKeyword(weight))
1716         return CSSValuePool::singleton().createIdentifierValue(value.value());
1717     return fontNonKeywordWeightFromStyleValue(weight);
1718 }
1719 
1720 static Ref&lt;CSSPrimitiveValue&gt; fontWeightFromStyle(const RenderStyle&amp; style)
1721 {
1722     return ComputedStyleExtractor::fontWeightFromStyleValue(style.fontDescription().weight());
1723 }
1724 
1725 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontNonKeywordStretchFromStyleValue(FontSelectionValue stretch)
1726 {
1727     return CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(stretch), CSSUnitType::CSS_PERCENTAGE);
1728 }
1729 
1730 Ref&lt;CSSPrimitiveValue&gt; ComputedStyleExtractor::fontStretchFromStyleValue(FontSelectionValue stretch)
1731 {
1732     if (auto keyword = fontStretchKeyword(stretch))
1733         return CSSValuePool::singleton().createIdentifierValue(keyword.value());
1734     return fontNonKeywordStretchFromStyleValue(stretch);
1735 }
1736 
1737 static Ref&lt;CSSPrimitiveValue&gt; fontStretchFromStyle(const RenderStyle&amp; style)
1738 {
1739     return ComputedStyleExtractor::fontStretchFromStyleValue(style.fontDescription().stretch());
1740 }
1741 
1742 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontNonKeywordStyleFromStyleValue(FontSelectionValue italic)
1743 {
1744     return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(italic), CSSUnitType::CSS_DEG));
1745 }
1746 
1747 Ref&lt;CSSFontStyleValue&gt; ComputedStyleExtractor::fontStyleFromStyleValue(Optional&lt;FontSelectionValue&gt; italic, FontStyleAxis fontStyleAxis)
1748 {
1749     if (auto keyword = fontStyleKeyword(italic, fontStyleAxis))
1750         return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(keyword.value()));
1751     return fontNonKeywordStyleFromStyleValue(italic.value());
1752 }
1753 
1754 static Ref&lt;CSSFontStyleValue&gt; fontStyleFromStyle(const RenderStyle&amp; style)
1755 {
1756     return ComputedStyleExtractor::fontStyleFromStyleValue(style.fontDescription().italic(), style.fontDescription().fontStyleAxis());
1757 }
1758 
1759 static Ref&lt;CSSValue&gt; fontVariantFromStyle(const RenderStyle&amp; style)
1760 {
1761     if (style.fontDescription().variantSettings().isAllNormal())
1762         return CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
1763 
1764     auto list = CSSValueList::createSpaceSeparated();
1765 
1766     switch (style.fontDescription().variantCommonLigatures()) {
1767     case FontVariantLigatures::Normal:
1768         break;
1769     case FontVariantLigatures::Yes:
1770         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueCommonLigatures));
1771         break;
1772     case FontVariantLigatures::No:
1773         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoCommonLigatures));
1774         break;
1775     }
1776 
1777     switch (style.fontDescription().variantDiscretionaryLigatures()) {
1778     case FontVariantLigatures::Normal:
1779         break;
1780     case FontVariantLigatures::Yes:
1781         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiscretionaryLigatures));
1782         break;
1783     case FontVariantLigatures::No:
1784         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoDiscretionaryLigatures));
1785         break;
1786     }
1787 
1788     switch (style.fontDescription().variantHistoricalLigatures()) {
1789     case FontVariantLigatures::Normal:
1790         break;
1791     case FontVariantLigatures::Yes:
1792         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalLigatures));
1793         break;
1794     case FontVariantLigatures::No:
1795         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoHistoricalLigatures));
1796         break;
1797     }
1798 
1799     switch (style.fontDescription().variantContextualAlternates()) {
1800     case FontVariantLigatures::Normal:
1801         break;
1802     case FontVariantLigatures::Yes:
1803         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueContextual));
1804         break;
1805     case FontVariantLigatures::No:
1806         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueNoContextual));
1807         break;
1808     }
1809 
1810     switch (style.fontDescription().variantPosition()) {
1811     case FontVariantPosition::Normal:
1812         break;
1813     case FontVariantPosition::Subscript:
1814         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSub));
1815         break;
1816     case FontVariantPosition::Superscript:
1817         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSuper));
1818         break;
1819     }
1820 
1821     switch (style.fontDescription().variantCaps()) {
1822     case FontVariantCaps::Normal:
1823         break;
1824     case FontVariantCaps::Small:
1825         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
1826         break;
1827     case FontVariantCaps::AllSmall:
1828         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllSmallCaps));
1829         break;
1830     case FontVariantCaps::Petite:
1831         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValuePetiteCaps));
1832         break;
1833     case FontVariantCaps::AllPetite:
1834         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueAllPetiteCaps));
1835         break;
1836     case FontVariantCaps::Unicase:
1837         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueUnicase));
1838         break;
1839     case FontVariantCaps::Titling:
1840         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTitlingCaps));
1841         break;
1842     }
1843 
1844     switch (style.fontDescription().variantNumericFigure()) {
1845     case FontVariantNumericFigure::Normal:
1846         break;
1847     case FontVariantNumericFigure::LiningNumbers:
1848         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueLiningNums));
1849         break;
1850     case FontVariantNumericFigure::OldStyleNumbers:
1851         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOldstyleNums));
1852         break;
1853     }
1854 
1855     switch (style.fontDescription().variantNumericSpacing()) {
1856     case FontVariantNumericSpacing::Normal:
1857         break;
1858     case FontVariantNumericSpacing::ProportionalNumbers:
1859         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalNums));
1860         break;
1861     case FontVariantNumericSpacing::TabularNumbers:
1862         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTabularNums));
1863         break;
1864     }
1865 
1866     switch (style.fontDescription().variantNumericFraction()) {
1867     case FontVariantNumericFraction::Normal:
1868         break;
1869     case FontVariantNumericFraction::DiagonalFractions:
1870         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueDiagonalFractions));
1871         break;
1872     case FontVariantNumericFraction::StackedFractions:
1873         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStackedFractions));
1874         break;
1875     }
1876 
1877     switch (style.fontDescription().variantNumericOrdinal()) {
1878     case FontVariantNumericOrdinal::Normal:
1879         break;
1880     case FontVariantNumericOrdinal::Yes:
1881         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueOrdinal));
1882         break;
1883     }
1884 
1885     switch (style.fontDescription().variantNumericSlashedZero()) {
1886     case FontVariantNumericSlashedZero::Normal:
1887         break;
1888     case FontVariantNumericSlashedZero::Yes:
1889         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSlashedZero));
1890         break;
1891     }
1892 
1893     switch (style.fontDescription().variantAlternates()) {
1894     case FontVariantAlternates::Normal:
1895         break;
1896     case FontVariantAlternates::HistoricalForms:
1897         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueHistoricalForms));
1898         break;
1899     }
1900 
1901     switch (style.fontDescription().variantEastAsianVariant()) {
1902     case FontVariantEastAsianVariant::Normal:
1903         break;
1904     case FontVariantEastAsianVariant::Jis78:
1905         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis78));
1906         break;
1907     case FontVariantEastAsianVariant::Jis83:
1908         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis83));
1909         break;
1910     case FontVariantEastAsianVariant::Jis90:
1911         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis90));
1912         break;
1913     case FontVariantEastAsianVariant::Jis04:
1914         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueJis04));
1915         break;
1916     case FontVariantEastAsianVariant::Simplified:
1917         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSimplified));
1918         break;
1919     case FontVariantEastAsianVariant::Traditional:
1920         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueTraditional));
1921         break;
1922     }
1923 
1924     switch (style.fontDescription().variantEastAsianWidth()) {
1925     case FontVariantEastAsianWidth::Normal:
1926         break;
1927     case FontVariantEastAsianWidth::Full:
1928         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueFullWidth));
1929         break;
1930     case FontVariantEastAsianWidth::Proportional:
1931         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueProportionalWidth));
1932         break;
1933     }
1934 
1935     switch (style.fontDescription().variantEastAsianRuby()) {
1936     case FontVariantEastAsianRuby::Normal:
1937         break;
1938     case FontVariantEastAsianRuby::Yes:
1939         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueRuby));
1940         break;
1941     }
1942 
1943     return list;
1944 }
1945 
1946 static Ref&lt;CSSValue&gt; fontSynthesisFromStyle(const RenderStyle&amp; style)
1947 {
1948     if (style.fontDescription().fontSynthesis() == FontSynthesisNone)
1949         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
1950 
1951     auto list = CSSValueList::createSpaceSeparated();
1952     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisStyle)
1953         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueStyle));
1954     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisWeight)
1955         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueWeight));
1956     if (style.fontDescription().fontSynthesis() &amp; FontSynthesisSmallCaps)
1957         list-&gt;append(CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps));
1958     return list;
1959 }
1960 
1961 typedef const Length&amp; (RenderStyle::*RenderStyleLengthGetter)() const;
1962 typedef LayoutUnit (RenderBoxModelObject::*RenderBoxComputedCSSValueGetter)() const;
1963 
1964 template&lt;RenderStyleLengthGetter lengthGetter, RenderBoxComputedCSSValueGetter computedCSSValueGetter&gt;
1965 static RefPtr&lt;CSSValue&gt; zoomAdjustedPaddingOrMarginPixelValue(const RenderStyle&amp; style, RenderObject* renderer)
1966 {
1967     Length unzoomzedLength = (style.*lengthGetter)();
1968     if (!is&lt;RenderBox&gt;(renderer) || unzoomzedLength.isFixed())
1969         return zoomAdjustedPixelValueForLength(unzoomzedLength, style);
1970     return zoomAdjustedPixelValue((downcast&lt;RenderBox&gt;(*renderer).*computedCSSValueGetter)(), style);
1971 }
1972 
1973 template&lt;RenderStyleLengthGetter lengthGetter&gt;
1974 static bool paddingOrMarginIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
1975 {
1976     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox() &amp;&amp; !(style-&gt;*lengthGetter)().isFixed();
1977 }
1978 
1979 static bool positionOffsetValueIsRendererDependent(const RenderStyle* style, RenderObject* renderer)
1980 {
1981     return renderer &amp;&amp; style &amp;&amp; renderer-&gt;isBox();
1982 }
1983 
1984 static CSSValueID convertToPageBreak(BreakBetween value)
1985 {
1986     if (value == BreakBetween::Page || value == BreakBetween::LeftPage || value == BreakBetween::RightPage
1987         || value == BreakBetween::RectoPage || value == BreakBetween::VersoPage)
1988         return CSSValueAlways; // CSS 2.1 allows us to map these to always.
1989     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidPage)
1990         return CSSValueAvoid;
1991     return CSSValueAuto;
1992 }
1993 
1994 static CSSValueID convertToColumnBreak(BreakBetween value)
1995 {
1996     if (value == BreakBetween::Column)
1997         return CSSValueAlways;
1998     if (value == BreakBetween::Avoid || value == BreakBetween::AvoidColumn)
1999         return CSSValueAvoid;
2000     return CSSValueAuto;
2001 }
2002 
2003 static CSSValueID convertToPageBreak(BreakInside value)
2004 {
2005     if (value == BreakInside::Avoid || value == BreakInside::AvoidPage)
2006         return CSSValueAvoid;
2007     return CSSValueAuto;
2008 }
2009 
2010 static CSSValueID convertToColumnBreak(BreakInside value)
2011 {
2012     if (value == BreakInside::Avoid || value == BreakInside::AvoidColumn)
2013         return CSSValueAvoid;
2014     return CSSValueAuto;
2015 }
2016 
2017 static inline bool isNonReplacedInline(RenderObject&amp; renderer)
2018 {
2019     return renderer.isInline() &amp;&amp; !renderer.isReplaced();
2020 }
2021 
2022 static bool isLayoutDependent(CSSPropertyID propertyID, const RenderStyle* style, RenderObject* renderer)
2023 {
2024     switch (propertyID) {
2025     case CSSPropertyTop:
2026     case CSSPropertyBottom:
2027     case CSSPropertyLeft:
2028     case CSSPropertyRight:
2029     case CSSPropertyInsetBlockStart:
2030     case CSSPropertyInsetBlockEnd:
2031     case CSSPropertyInsetInlineStart:
2032     case CSSPropertyInsetInlineEnd:
2033         return positionOffsetValueIsRendererDependent(style, renderer);
2034     case CSSPropertyWidth:
2035     case CSSPropertyHeight:
2036     case CSSPropertyInlineSize:
2037     case CSSPropertyBlockSize:
2038         return renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject() &amp;&amp; !isNonReplacedInline(*renderer);
2039     case CSSPropertyPerspectiveOrigin:
2040     case CSSPropertyTransformOrigin:
2041     case CSSPropertyTransform:
2042     case CSSPropertyFilter: // Why are filters layout-dependent?
2043 #if ENABLE(FILTERS_LEVEL_2)
2044     case CSSPropertyWebkitBackdropFilter: // Ditto for backdrop-filter.
2045 #endif
2046         return true;
2047     case CSSPropertyMargin: {
2048         if (!renderer || !renderer-&gt;isBox())
2049             return false;
2050         return !(style &amp;&amp; style-&gt;marginTop().isFixed() &amp;&amp; style-&gt;marginRight().isFixed()
2051             &amp;&amp; style-&gt;marginBottom().isFixed() &amp;&amp; style-&gt;marginLeft().isFixed());
2052     }
2053     case CSSPropertyMarginTop:
2054         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginTop&gt;(style, renderer);
2055     case CSSPropertyMarginRight:
2056         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginRight&gt;(style, renderer);
2057     case CSSPropertyMarginBottom:
2058         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginBottom&gt;(style, renderer);
2059     case CSSPropertyMarginLeft:
2060         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::marginLeft&gt;(style, renderer);
2061     case CSSPropertyPadding: {
2062         if (!renderer || !renderer-&gt;isBox())
2063             return false;
2064         return !(style &amp;&amp; style-&gt;paddingTop().isFixed() &amp;&amp; style-&gt;paddingRight().isFixed()
2065             &amp;&amp; style-&gt;paddingBottom().isFixed() &amp;&amp; style-&gt;paddingLeft().isFixed());
2066     }
2067     case CSSPropertyPaddingTop:
2068         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingTop&gt;(style, renderer);
2069     case CSSPropertyPaddingRight:
2070         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingRight&gt;(style, renderer);
2071     case CSSPropertyPaddingBottom:
2072         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingBottom&gt;(style, renderer);
2073     case CSSPropertyPaddingLeft:
2074         return paddingOrMarginIsRendererDependent&lt;&amp;RenderStyle::paddingLeft&gt;(style, renderer);
2075     case CSSPropertyGridTemplateColumns:
2076     case CSSPropertyGridTemplateRows:
2077     case CSSPropertyGridTemplate:
2078     case CSSPropertyGrid:
2079         return renderer &amp;&amp; renderer-&gt;isRenderGrid();
2080     default:
2081         return false;
2082     }
2083 }
2084 
2085 Element* ComputedStyleExtractor::styledElement() const
2086 {
2087     if (!m_element)
2088         return nullptr;
2089     PseudoElement* pseudoElement;
2090     if (m_pseudoElementSpecifier == PseudoId::Before &amp;&amp; (pseudoElement = m_element-&gt;beforePseudoElement()))
2091         return pseudoElement;
2092     if (m_pseudoElementSpecifier == PseudoId::After &amp;&amp; (pseudoElement = m_element-&gt;afterPseudoElement()))
2093         return pseudoElement;
2094     return m_element.get();
2095 }
2096 
2097 RenderElement* ComputedStyleExtractor::styledRenderer() const
2098 {
2099     auto* element = styledElement();
2100     if (!element)
2101         return nullptr;
2102     if (m_pseudoElementSpecifier != PseudoId::None &amp;&amp; element == m_element.get())
2103         return nullptr;
2104     if (element-&gt;hasDisplayContents())
2105         return nullptr;
2106     return element-&gt;renderer();
2107 }
2108 
2109 static bool isImplicitlyInheritedGridOrFlexProperty(CSSPropertyID propertyID)
2110 {
2111     // It would be nice if grid and flex worked within normal CSS mechanisms and not invented their own inheritance system.
2112     switch (propertyID) {
2113     case CSSPropertyAlignSelf:
2114     case CSSPropertyJustifySelf:
2115     case CSSPropertyJustifyItems:
2116     // FIXME: In StyleResolver::adjustRenderStyle z-index is adjusted based on the parent display property for grid/flex.
2117     case CSSPropertyZIndex:
2118         return true;
2119     default:
2120         return false;
2121     }
2122 }
2123 
2124 // In CSS 2.1 the returned object should actually contain the &quot;used values&quot;
2125 // rather then the &quot;computed values&quot; (despite the name saying otherwise).
2126 //
2127 // See;
2128 // http://www.w3.org/TR/CSS21/cascade.html#used-value
2129 // http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSStyleDeclaration
2130 // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle#Notes
2131 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(CSSPropertyID propertyID, EUpdateLayout updateLayout) const
2132 {
2133     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).propertyValue(propertyID, updateLayout);
2134 }
2135 
2136 Ref&lt;MutableStyleProperties&gt; CSSComputedStyleDeclaration::copyProperties() const
2137 {
2138     return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).copyProperties();
2139 }
2140 
2141 static inline bool hasValidStyleForProperty(Element&amp; element, CSSPropertyID propertyID)
2142 {
2143     if (element.styleValidity() != Style::Validity::Valid)
2144         return false;
2145     if (element.document().hasPendingFullStyleRebuild())
2146         return false;
2147     if (!element.document().childNeedsStyleRecalc())
2148         return true;
2149 
2150     bool isInherited = CSSProperty::isInheritedProperty(propertyID) || isImplicitlyInheritedGridOrFlexProperty(propertyID);
2151     bool maybeExplicitlyInherited = !isInherited;
2152 
2153     const auto* currentElement = &amp;element;
2154     for (auto&amp; ancestor : composedTreeAncestors(element)) {
2155         if (ancestor.styleValidity() &gt;= Style::Validity::SubtreeInvalid)
2156             return false;
2157 
2158         if (maybeExplicitlyInherited) {
2159             auto* style = currentElement-&gt;renderStyle();
2160             maybeExplicitlyInherited = !style || style-&gt;hasExplicitlyInheritedProperties();
2161         }
2162 
2163         if ((isInherited || maybeExplicitlyInherited) &amp;&amp; ancestor.styleValidity() == Style::Validity::ElementInvalid)
2164             return false;
2165 
2166         if (ancestor.directChildNeedsStyleRecalc() &amp;&amp; currentElement-&gt;styleIsAffectedByPreviousSibling())
2167             return false;
2168 
2169         currentElement = &amp;ancestor;
2170     }
2171 
2172     return true;
2173 }
2174 
2175 static bool updateStyleIfNeededForProperty(Element&amp; element, CSSPropertyID propertyID)
2176 {
2177     auto&amp; document = element.document();
2178 
2179     document.styleScope().flushPendingUpdate();
2180 
2181     if (hasValidStyleForProperty(element, propertyID))
2182         return false;
2183 
2184     document.updateStyleIfNeeded();
2185     return true;
2186 }
2187 
2188 static inline const RenderStyle* computeRenderStyleForProperty(Element&amp; element, PseudoId pseudoElementSpecifier, CSSPropertyID propertyID, std::unique_ptr&lt;RenderStyle&gt;&amp; ownedStyle)
2189 {
2190     auto* renderer = element.renderer();
2191 
2192     if (renderer &amp;&amp; renderer-&gt;isComposited() &amp;&amp; CSSAnimationController::supportsAcceleratedAnimationOfProperty(propertyID)) {
2193         if (auto timeline = element.document().existingTimeline())
2194             ownedStyle = timeline-&gt;animatedStyleForRenderer(*renderer);
2195         else
2196             ownedStyle = renderer-&gt;animation().animatedStyleForRenderer(*renderer);
2197         if (pseudoElementSpecifier != PseudoId::None &amp;&amp; !element.isPseudoElement()) {
2198             // FIXME: This cached pseudo style will only exist if the animation has been run at least once.
2199             return ownedStyle-&gt;getCachedPseudoStyle(pseudoElementSpecifier);
2200         }
2201         return ownedStyle.get();
2202     }
2203 
2204     return element.computedStyle(element.isPseudoElement() ? PseudoId::None : pseudoElementSpecifier);
2205 }
2206 
2207 static Ref&lt;CSSValue&gt; shapePropertyValue(const RenderStyle&amp; style, const ShapeValue* shapeValue)
2208 {
2209     if (!shapeValue)
2210         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2211 
2212     if (shapeValue-&gt;type() == ShapeValue::Type::Box)
2213         return CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox());
2214 
2215     if (shapeValue-&gt;type() == ShapeValue::Type::Image) {
2216         if (shapeValue-&gt;image())
2217             return shapeValue-&gt;image()-&gt;cssValue();
2218         return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
2219     }
2220 
2221     ASSERT(shapeValue-&gt;type() == ShapeValue::Type::Shape);
2222 
2223     auto list = CSSValueList::createSpaceSeparated();
2224     list-&gt;append(valueForBasicShape(style, *shapeValue-&gt;shape()));
2225     if (shapeValue-&gt;cssBox() != CSSBoxType::BoxMissing)
2226         list-&gt;append(CSSValuePool::singleton().createValue(shapeValue-&gt;cssBox()));
2227     return list;
2228 }
2229 
2230 static Ref&lt;CSSValueList&gt; valueForItemPositionWithOverflowAlignment(const StyleSelfAlignmentData&amp; data)
2231 {
2232     auto&amp; cssValuePool = CSSValuePool::singleton();
2233     auto result = CSSValueList::createSpaceSeparated();
2234     if (data.positionType() == ItemPositionType::Legacy)
2235         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLegacy));
2236     if (data.position() == ItemPosition::Baseline)
2237         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2238     else if (data.position() == ItemPosition::LastBaseline) {
2239         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2240         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2241     } else {
2242         if (data.position() &gt;= ItemPosition::Center &amp;&amp; data.overflow() != OverflowAlignment::Default)
2243             result-&gt;append(cssValuePool.createValue(data.overflow()));
2244         if (data.position() == ItemPosition::Legacy)
2245             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2246         else
2247             result-&gt;append(cssValuePool.createValue(data.position()));
2248     }
2249     ASSERT(result-&gt;length() &lt;= 2);
2250     return result;
2251 }
2252 
2253 static Ref&lt;CSSValueList&gt; valueForContentPositionAndDistributionWithOverflowAlignment(const StyleContentAlignmentData&amp; data)
2254 {
2255     auto&amp; cssValuePool = CSSValuePool::singleton();
2256     auto result = CSSValueList::createSpaceSeparated();
2257     // Handle content-distribution values
2258     if (data.distribution() != ContentDistribution::Default)
2259         result-&gt;append(cssValuePool.createValue(data.distribution()));
2260 
2261     // Handle content-position values (either as fallback or actual value)
2262     switch (data.position()) {
2263     case ContentPosition::Normal:
2264         // Handle &#39;normal&#39; value, not valid as content-distribution fallback.
2265         if (data.distribution() == ContentDistribution::Default)
2266             result-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
2267         break;
2268     case ContentPosition::LastBaseline:
2269         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueLast));
2270         result-&gt;append(cssValuePool.createIdentifierValue(CSSValueBaseline));
2271         break;
2272     default:
2273         // Handle overflow-alignment (only allowed for content-position values)
2274         if ((data.position() &gt;= ContentPosition::Center || data.distribution() != ContentDistribution::Default) &amp;&amp; data.overflow() != OverflowAlignment::Default)
2275             result-&gt;append(cssValuePool.createValue(data.overflow()));
2276         result-&gt;append(cssValuePool.createValue(data.position()));
2277     }
2278 
2279     ASSERT(result-&gt;length() &gt; 0);
2280     ASSERT(result-&gt;length() &lt;= 3);
2281     return result;
2282 }
2283 
2284 static Ref&lt;CSSValue&gt; paintOrder(PaintOrder paintOrder)
2285 {
2286     if (paintOrder == PaintOrder::Normal)
2287         return CSSPrimitiveValue::createIdentifier(CSSValueNormal);
2288 
2289     auto paintOrderList = CSSValueList::createSpaceSeparated();
2290     switch (paintOrder) {
2291     case PaintOrder::Normal:
2292         ASSERT_NOT_REACHED();
2293         break;
2294     case PaintOrder::Fill:
2295         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2296         break;
2297     case PaintOrder::FillMarkers:
2298         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueFill));
2299         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2300         break;
2301     case PaintOrder::Stroke:
2302         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2303         break;
2304     case PaintOrder::StrokeMarkers:
2305         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2306         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2307         break;
2308     case PaintOrder::Markers:
2309         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2310         break;
2311     case PaintOrder::MarkersStroke:
2312         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueMarkers));
2313         paintOrderList-&gt;append(CSSPrimitiveValue::createIdentifier(CSSValueStroke));
2314         break;
2315     }
2316     return paintOrderList;
2317 }
2318 
2319 inline static bool isFlexOrGrid(ContainerNode* element)
2320 {
2321     return element &amp;&amp; element-&gt;computedStyle() &amp;&amp; element-&gt;computedStyle()-&gt;isDisplayFlexibleOrGridBox();
2322 }
2323 
2324 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::customPropertyValue(const String&amp; propertyName)
2325 {
2326     Element* styledElement = this-&gt;styledElement();
2327     if (!styledElement)
2328         return nullptr;
2329 
2330     if (updateStyleIfNeededForProperty(*styledElement, CSSPropertyCustom)) {
2331         // Style update may change styledElement() to PseudoElement or back.
2332         styledElement = this-&gt;styledElement();
2333     }
2334 
2335     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2336     auto* style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, CSSPropertyCustom, ownedStyle);
2337     if (!style)
2338         return nullptr;
2339 
2340     auto* registered = styledElement-&gt;document().getCSSRegisteredCustomPropertySet().get(propertyName);
2341     auto* value = style-&gt;getCustomProperty(propertyName);
2342 
2343     if (registered &amp;&amp; !value)
2344         return registered-&gt;initialValueCopy();
2345 
2346     if (!value)
2347         return nullptr;
2348 
2349     return WTF::switchOn(value-&gt;value(), [&amp;](const Ref&lt;CSSVariableReferenceValue&gt;&amp;) {
2350         ASSERT_NOT_REACHED();
2351         return RefPtr&lt;CSSValue&gt;();
2352     }, [&amp;](const CSSValueID&amp;) {
2353         return CSSCustomPropertyValue::create(*value);
2354     }, [&amp;](const Ref&lt;CSSVariableData&gt;&amp;) {
2355         return CSSCustomPropertyValue::create(*value);
2356     }, [&amp;](const Length&amp; value) {
2357         return zoomAdjustedPixelValueForLength(value, *style);
2358     }, [&amp;](const Ref&lt;StyleImage&gt;&amp;) {
2359         return CSSCustomPropertyValue::create(*value);
2360     });
2361 }
2362 
2363 String ComputedStyleExtractor::customPropertyText(const String&amp; propertyName)
2364 {
2365     RefPtr&lt;CSSValue&gt; propertyValue = customPropertyValue(propertyName);
2366     return propertyValue ? propertyValue-&gt;cssText() : emptyString();
2367 }
2368 
2369 static Ref&lt;CSSFontValue&gt; fontShorthandValueForSelectionProperties(const FontDescription&amp; fontDescription)
2370 {
2371     auto computedFont = CSSFontValue::create();
2372 
2373     auto variantCaps = fontDescription.variantCaps();
2374     if (variantCaps == FontVariantCaps::Small)
2375         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueSmallCaps);
2376     else if (variantCaps == FontVariantCaps::Normal)
2377         computedFont-&gt;variant = CSSValuePool::singleton().createIdentifierValue(CSSValueNormal);
2378     else
2379         return CSSFontValue::create();
2380 
2381     auto weight = fontDescription.weight();
2382     if (auto value = fontWeightKeyword(weight))
2383         computedFont-&gt;weight = CSSValuePool::singleton().createIdentifierValue(value.value());
2384     else if (isCSS21Weight(weight))
2385         computedFont-&gt;weight = CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(weight), CSSUnitType::CSS_NUMBER);
2386     else
2387         return CSSFontValue::create();
2388 
2389     if (auto keyword = fontStretchKeyword(fontDescription.stretch()))
2390         computedFont-&gt;stretch = CSSValuePool::singleton().createIdentifierValue(keyword.value());
2391     else
2392         return CSSFontValue::create();
2393 
2394     if (auto italic = fontStyleKeyword(fontDescription.italic(), fontDescription.fontStyleAxis()))
2395         computedFont-&gt;style = CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(italic.value()));
2396     else
2397         return CSSFontValue::create();
2398 
2399     return computedFont;
2400 }
2401 
2402 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::propertyValue(CSSPropertyID propertyID, EUpdateLayout updateLayout)
2403 {
2404     auto* styledElement = this-&gt;styledElement();
2405     if (!styledElement)
2406         return nullptr;
2407 
2408     std::unique_ptr&lt;RenderStyle&gt; ownedStyle;
2409     const RenderStyle* style = nullptr;
2410     RenderElement* renderer = nullptr;
2411     bool forceFullLayout = false;
2412     if (updateLayout) {
2413         Document&amp; document = m_element-&gt;document();
2414 
2415         if (updateStyleIfNeededForProperty(*styledElement, propertyID)) {
2416             // Style update may change styledElement() to PseudoElement or back.
2417             styledElement = this-&gt;styledElement();
2418         }
2419         renderer = styledRenderer();
2420 
2421         if (propertyID == CSSPropertyDisplay &amp;&amp; !renderer &amp;&amp; is&lt;SVGElement&gt;(*styledElement) &amp;&amp; !downcast&lt;SVGElement&gt;(*styledElement).isValid())
2422             return nullptr;
2423 
2424         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2425 
2426         // FIXME: Some of these cases could be narrowed down or optimized better.
2427         forceFullLayout = isLayoutDependent(propertyID, style, renderer)
2428             || styledElement-&gt;isInShadowTree()
2429             || (document.styleScope().resolverIfExists() &amp;&amp; document.styleScope().resolverIfExists()-&gt;hasViewportDependentMediaQueries() &amp;&amp; document.ownerElement());
2430 
2431         if (forceFullLayout) {
2432             document.updateLayoutIgnorePendingStylesheets();
2433             styledElement = this-&gt;styledElement();
2434         }
2435     }
2436 
2437     if (!updateLayout || forceFullLayout) {
2438         style = computeRenderStyleForProperty(*styledElement, m_pseudoElementSpecifier, propertyID, ownedStyle);
2439         renderer = styledRenderer();
2440     }
2441 
2442     if (!style)
2443         return nullptr;
2444 
2445     return valueForPropertyInStyle(*style, propertyID, renderer);
2446 }
2447 
2448 RefPtr&lt;CSSValue&gt; ComputedStyleExtractor::valueForPropertyInStyle(const RenderStyle&amp; style, CSSPropertyID propertyID, RenderElement* renderer)
2449 {
2450     auto&amp; cssValuePool = CSSValuePool::singleton();
2451     propertyID = CSSProperty::resolveDirectionAwareProperty(propertyID, style.direction(), style.writingMode());
2452 
2453     switch (propertyID) {
2454         case CSSPropertyInvalid:
2455 #if ENABLE(TEXT_AUTOSIZING)
2456         case CSSPropertyInternalTextAutosizingStatus:
2457 #endif
2458             break;
2459 
2460         case CSSPropertyBackgroundColor:
2461             return cssValuePool.createColorValue(m_allowVisitedStyle? style.visitedDependentColor(CSSPropertyBackgroundColor) : style.backgroundColor());
2462         case CSSPropertyBackgroundImage:
2463         case CSSPropertyWebkitMaskImage: {
2464             auto&amp; layers = propertyID == CSSPropertyWebkitMaskImage ? style.maskLayers() : style.backgroundLayers();
2465             if (!layers.next()) {
2466                 if (layers.image())
2467                     return layers.image()-&gt;cssValue();
2468                 return cssValuePool.createIdentifierValue(CSSValueNone);
2469             }
2470             auto list = CSSValueList::createCommaSeparated();
2471             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next()) {
2472                 if (currLayer-&gt;image())
2473                     list-&gt;append(currLayer-&gt;image()-&gt;cssValue());
2474                 else
2475                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
2476             }
2477             return list;
2478         }
2479         case CSSPropertyBackgroundSize:
2480         case CSSPropertyWebkitBackgroundSize:
2481         case CSSPropertyWebkitMaskSize: {
2482             auto&amp; layers = propertyID == CSSPropertyWebkitMaskSize ? style.maskLayers() : style.backgroundLayers();
2483             if (!layers.next())
2484                 return fillSizeToCSSValue(layers.size(), style);
2485             auto list = CSSValueList::createCommaSeparated();
2486             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2487                 list-&gt;append(fillSizeToCSSValue(currLayer-&gt;size(), style));
2488             return list;
2489         }
2490         case CSSPropertyBackgroundRepeat:
2491         case CSSPropertyWebkitMaskRepeat: {
2492             auto&amp; layers = propertyID == CSSPropertyWebkitMaskRepeat ? style.maskLayers() : style.backgroundLayers();
2493             if (!layers.next())
2494                 return fillRepeatToCSSValue(layers.repeatX(), layers.repeatY());
2495             auto list = CSSValueList::createCommaSeparated();
2496             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2497                 list-&gt;append(fillRepeatToCSSValue(currLayer-&gt;repeatX(), currLayer-&gt;repeatY()));
2498             return list;
2499         }
2500         case CSSPropertyWebkitMaskSourceType: {
2501             auto&amp; layers = style.maskLayers();
2502             if (!layers.next())
2503                 return fillSourceTypeToCSSValue(layers.maskSourceType());
2504             auto list = CSSValueList::createCommaSeparated();
2505             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2506                 list-&gt;append(fillSourceTypeToCSSValue(currLayer-&gt;maskSourceType()));
2507             return list;
2508         }
2509         case CSSPropertyWebkitBackgroundComposite:
2510         case CSSPropertyWebkitMaskComposite: {
2511             auto&amp; layers = propertyID == CSSPropertyWebkitMaskComposite ? style.maskLayers() : style.backgroundLayers();
2512             if (!layers.next())
2513                 return cssValuePool.createValue(layers.composite());
2514             auto list = CSSValueList::createCommaSeparated();
2515             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2516                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;composite()));
2517             return list;
2518         }
2519         case CSSPropertyBackgroundAttachment: {
2520             auto&amp; layers = style.backgroundLayers();
2521             if (!layers.next())
2522                 return cssValuePool.createValue(layers.attachment());
2523             auto list = CSSValueList::createCommaSeparated();
2524             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2525                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;attachment()));
2526             return list;
2527         }
2528         case CSSPropertyBackgroundClip:
2529         case CSSPropertyBackgroundOrigin:
2530         case CSSPropertyWebkitBackgroundClip:
2531         case CSSPropertyWebkitBackgroundOrigin:
2532         case CSSPropertyWebkitMaskClip:
2533         case CSSPropertyWebkitMaskOrigin: {
2534             auto&amp; layers = (propertyID == CSSPropertyWebkitMaskClip || propertyID == CSSPropertyWebkitMaskOrigin) ? style.maskLayers() : style.backgroundLayers();
2535             bool isClip = propertyID == CSSPropertyBackgroundClip || propertyID == CSSPropertyWebkitBackgroundClip || propertyID == CSSPropertyWebkitMaskClip;
2536             if (!layers.next())
2537                 return cssValuePool.createValue(isClip ? layers.clip() : layers.origin());
2538             auto list = CSSValueList::createCommaSeparated();
2539             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2540                 list-&gt;append(cssValuePool.createValue(isClip ? currLayer-&gt;clip() : currLayer-&gt;origin()));
2541             return list;
2542         }
2543         case CSSPropertyBackgroundPosition:
2544         case CSSPropertyWebkitMaskPosition: {
2545             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPosition ? style.maskLayers() : style.backgroundLayers();
2546             if (!layers.next())
2547                 return createPositionListForLayer(propertyID, layers, style);
2548 
2549             auto list = CSSValueList::createCommaSeparated();
2550             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2551                 list-&gt;append(createPositionListForLayer(propertyID, *currLayer, style));
2552             return list;
2553         }
2554         case CSSPropertyBackgroundPositionX:
2555         case CSSPropertyWebkitMaskPositionX: {
2556             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionX ? style.maskLayers() : style.backgroundLayers();
2557             if (!layers.next())
2558                 return cssValuePool.createValue(layers.xPosition());
2559 
2560             auto list = CSSValueList::createCommaSeparated();
2561             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2562                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;xPosition()));
2563 
2564             return list;
2565         }
2566         case CSSPropertyBackgroundPositionY:
2567         case CSSPropertyWebkitMaskPositionY: {
2568             auto&amp; layers = propertyID == CSSPropertyWebkitMaskPositionY ? style.maskLayers() : style.backgroundLayers();
2569             if (!layers.next())
2570                 return cssValuePool.createValue(layers.yPosition());
2571 
2572             auto list = CSSValueList::createCommaSeparated();
2573             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
2574                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;yPosition()));
2575 
2576             return list;
2577         }
2578         case CSSPropertyBorderCollapse:
2579             if (style.borderCollapse() == BorderCollapse::Collapse)
2580                 return cssValuePool.createIdentifierValue(CSSValueCollapse);
2581             return cssValuePool.createIdentifierValue(CSSValueSeparate);
2582         case CSSPropertyBorderSpacing: {
2583             auto list = CSSValueList::createSpaceSeparated();
2584             list-&gt;append(zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style));
2585             list-&gt;append(zoomAdjustedPixelValue(style.verticalBorderSpacing(), style));
2586             return list;
2587         }
2588         case CSSPropertyWebkitBorderHorizontalSpacing:
2589             return zoomAdjustedPixelValue(style.horizontalBorderSpacing(), style);
2590         case CSSPropertyWebkitBorderVerticalSpacing:
2591             return zoomAdjustedPixelValue(style.verticalBorderSpacing(), style);
2592         case CSSPropertyBorderImageSource:
2593             if (style.borderImageSource())
2594                 return style.borderImageSource()-&gt;cssValue();
2595             return cssValuePool.createIdentifierValue(CSSValueNone);
2596         case CSSPropertyBorderTopColor:
2597             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderTopColor)) : currentColorOrValidColor(&amp;style, style.borderTopColor());
2598         case CSSPropertyBorderRightColor:
2599             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderRightColor)) : currentColorOrValidColor(&amp;style, style.borderRightColor());
2600         case CSSPropertyBorderBottomColor:
2601             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderBottomColor)) : currentColorOrValidColor(&amp;style, style.borderBottomColor());
2602         case CSSPropertyBorderLeftColor:
2603             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyBorderLeftColor)) : currentColorOrValidColor(&amp;style, style.borderLeftColor());
2604         case CSSPropertyBorderTopStyle:
2605             return cssValuePool.createValue(style.borderTopStyle());
2606         case CSSPropertyBorderRightStyle:
2607             return cssValuePool.createValue(style.borderRightStyle());
2608         case CSSPropertyBorderBottomStyle:
2609             return cssValuePool.createValue(style.borderBottomStyle());
2610         case CSSPropertyBorderLeftStyle:
2611             return cssValuePool.createValue(style.borderLeftStyle());
2612         case CSSPropertyBorderTopWidth:
2613             return zoomAdjustedPixelValue(style.borderTopWidth(), style);
2614         case CSSPropertyBorderRightWidth:
2615             return zoomAdjustedPixelValue(style.borderRightWidth(), style);
2616         case CSSPropertyBorderBottomWidth:
2617             return zoomAdjustedPixelValue(style.borderBottomWidth(), style);
2618         case CSSPropertyBorderLeftWidth:
2619             return zoomAdjustedPixelValue(style.borderLeftWidth(), style);
2620         case CSSPropertyBottom:
2621             return positionOffsetValue(style, CSSPropertyBottom, renderer);
2622         case CSSPropertyWebkitBoxAlign:
2623             return cssValuePool.createValue(style.boxAlign());
2624 #if ENABLE(CSS_BOX_DECORATION_BREAK)
2625         case CSSPropertyWebkitBoxDecorationBreak:
2626             if (style.boxDecorationBreak() == BoxDecorationBreak::Slice)
2627                 return cssValuePool.createIdentifierValue(CSSValueSlice);
2628         return cssValuePool.createIdentifierValue(CSSValueClone);
2629 #endif
2630         case CSSPropertyWebkitBoxDirection:
2631             return cssValuePool.createValue(style.boxDirection());
2632         case CSSPropertyWebkitBoxFlex:
2633             return cssValuePool.createValue(style.boxFlex(), CSSUnitType::CSS_NUMBER);
2634         case CSSPropertyWebkitBoxFlexGroup:
2635             return cssValuePool.createValue(style.boxFlexGroup(), CSSUnitType::CSS_NUMBER);
2636         case CSSPropertyWebkitBoxLines:
2637             return cssValuePool.createValue(style.boxLines());
2638         case CSSPropertyWebkitBoxOrdinalGroup:
2639             return cssValuePool.createValue(style.boxOrdinalGroup(), CSSUnitType::CSS_NUMBER);
2640         case CSSPropertyWebkitBoxOrient:
2641             return cssValuePool.createValue(style.boxOrient());
2642         case CSSPropertyWebkitBoxPack:
2643             return cssValuePool.createValue(style.boxPack());
2644         case CSSPropertyWebkitBoxReflect:
2645             return valueForReflection(style.boxReflect(), style);
2646         case CSSPropertyBoxShadow:
2647         case CSSPropertyWebkitBoxShadow:
2648             return valueForShadow(style.boxShadow(), propertyID, style);
2649         case CSSPropertyCaptionSide:
2650             return cssValuePool.createValue(style.captionSide());
2651         case CSSPropertyCaretColor:
2652             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyCaretColor)) : currentColorOrValidColor(&amp;style, style.caretColor());
2653         case CSSPropertyClear:
2654             return cssValuePool.createValue(style.clear());
2655         case CSSPropertyColor:
2656             return cssValuePool.createColorValue(m_allowVisitedStyle ? style.visitedDependentColor(CSSPropertyColor) : style.color());
2657         case CSSPropertyWebkitPrintColorAdjust:
2658             return cssValuePool.createValue(style.printColorAdjust());
2659         case CSSPropertyWebkitColumnAxis:
2660             return cssValuePool.createValue(style.columnAxis());
2661         case CSSPropertyColumnCount:
2662             if (style.hasAutoColumnCount())
2663                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2664             return cssValuePool.createValue(style.columnCount(), CSSUnitType::CSS_NUMBER);
2665         case CSSPropertyColumnFill:
2666             return cssValuePool.createValue(style.columnFill());
2667         case CSSPropertyColumnGap:
2668             if (style.columnGap().isNormal())
2669                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2670             return zoomAdjustedPixelValueForLength(style.columnGap().length(), style);
2671         case CSSPropertyRowGap:
2672             if (style.rowGap().isNormal())
2673                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2674             return zoomAdjustedPixelValueForLength(style.rowGap().length(), style);
2675         case CSSPropertyWebkitColumnProgression:
2676             return cssValuePool.createValue(style.columnProgression());
2677         case CSSPropertyColumnRuleColor:
2678             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.columnRuleColor());
2679         case CSSPropertyColumnRuleStyle:
2680             return cssValuePool.createValue(style.columnRuleStyle());
2681         case CSSPropertyColumnRuleWidth:
2682             return zoomAdjustedPixelValue(style.columnRuleWidth(), style);
2683         case CSSPropertyColumnSpan:
2684             return cssValuePool.createIdentifierValue(style.columnSpan() == ColumnSpan::All ? CSSValueAll : CSSValueNone);
2685         case CSSPropertyWebkitColumnBreakAfter:
2686             return cssValuePool.createValue(convertToColumnBreak(style.breakAfter()));
2687         case CSSPropertyWebkitColumnBreakBefore:
2688             return cssValuePool.createValue(convertToColumnBreak(style.breakBefore()));
2689         case CSSPropertyWebkitColumnBreakInside:
2690             return cssValuePool.createValue(convertToColumnBreak(style.breakInside()));
2691         case CSSPropertyColumnWidth:
2692             if (style.hasAutoColumnWidth())
2693                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2694             return zoomAdjustedPixelValue(style.columnWidth(), style);
2695         case CSSPropertyTabSize:
2696             return cssValuePool.createValue(style.tabSize().widthInPixels(1.0), style.tabSize().isSpaces() ? CSSUnitType::CSS_NUMBER : CSSUnitType::CSS_PX);
2697         case CSSPropertyCursor: {
2698             RefPtr&lt;CSSValueList&gt; list;
2699             auto* cursors = style.cursors();
2700             if (cursors &amp;&amp; cursors-&gt;size() &gt; 0) {
2701                 list = CSSValueList::createCommaSeparated();
2702                 for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i)
2703                     if (StyleImage* image = cursors-&gt;at(i).image())
2704                         list-&gt;append(image-&gt;cssValue());
2705             }
2706             auto value = cssValuePool.createValue(style.cursor());
2707             if (list) {
2708                 list-&gt;append(WTFMove(value));
2709                 return list;
2710             }
2711             return value;
2712         }
2713 #if ENABLE(CURSOR_VISIBILITY)
2714         case CSSPropertyWebkitCursorVisibility:
2715             return cssValuePool.createValue(style.cursorVisibility());
2716 #endif
2717         case CSSPropertyDirection:
2718             return cssValuePool.createValue(style.direction());
2719         case CSSPropertyDisplay:
2720             return cssValuePool.createValue(style.display());
2721         case CSSPropertyEmptyCells:
2722             return cssValuePool.createValue(style.emptyCells());
2723         case CSSPropertyAlignContent:
2724             return valueForContentPositionAndDistributionWithOverflowAlignment(style.alignContent());
2725         case CSSPropertyAlignItems:
2726             return valueForItemPositionWithOverflowAlignment(style.alignItems());
2727         case CSSPropertyAlignSelf:
2728             return valueForItemPositionWithOverflowAlignment(style.alignSelf());
2729         case CSSPropertyFlex:
2730             return getCSSPropertyValuesForShorthandProperties(flexShorthand());
2731         case CSSPropertyFlexBasis:
2732             return cssValuePool.createValue(style.flexBasis(), style);
2733         case CSSPropertyFlexDirection:
2734             return cssValuePool.createValue(style.flexDirection());
2735         case CSSPropertyFlexFlow:
2736             return getCSSPropertyValuesForShorthandProperties(flexFlowShorthand());
2737         case CSSPropertyFlexGrow:
2738             return cssValuePool.createValue(style.flexGrow());
2739         case CSSPropertyFlexShrink:
2740             return cssValuePool.createValue(style.flexShrink());
2741         case CSSPropertyFlexWrap:
2742             return cssValuePool.createValue(style.flexWrap());
2743         case CSSPropertyJustifyContent:
2744             return valueForContentPositionAndDistributionWithOverflowAlignment(style.justifyContent());
2745         case CSSPropertyJustifyItems:
2746             return valueForItemPositionWithOverflowAlignment(style.justifyItems());
2747         case CSSPropertyJustifySelf:
2748             return valueForItemPositionWithOverflowAlignment(style.justifySelf());
2749         case CSSPropertyPlaceContent:
2750             return getCSSPropertyValuesForShorthandProperties(placeContentShorthand());
2751         case CSSPropertyPlaceItems:
2752             return getCSSPropertyValuesForShorthandProperties(placeItemsShorthand());
2753         case CSSPropertyPlaceSelf:
2754             return getCSSPropertyValuesForShorthandProperties(placeSelfShorthand());
2755         case CSSPropertyOrder:
2756             return cssValuePool.createValue(style.order(), CSSUnitType::CSS_NUMBER);
2757         case CSSPropertyFloat:
2758             if (style.display() != DisplayType::None &amp;&amp; style.hasOutOfFlowPosition())
2759                 return cssValuePool.createIdentifierValue(CSSValueNone);
2760             return cssValuePool.createValue(style.floating());
2761         case CSSPropertyFont: {
2762             auto computedFont = fontShorthandValueForSelectionProperties(style.fontDescription());
2763             computedFont-&gt;size = fontSizeFromStyle(style);
2764             computedFont-&gt;lineHeight = lineHeightFromStyle(style);
2765             computedFont-&gt;family = fontFamilyListFromStyle(style);
2766             return computedFont;
2767         }
2768         case CSSPropertyFontFamily:
2769             return fontFamilyFromStyle(style);
2770         case CSSPropertyFontSize:
2771             return fontSizeFromStyle(style);
2772         case CSSPropertyFontStyle:
2773             return fontStyleFromStyle(style);
2774         case CSSPropertyFontStretch:
2775             return fontStretchFromStyle(style);
2776         case CSSPropertyFontVariant:
2777             return fontVariantFromStyle(style);
2778         case CSSPropertyFontWeight:
2779             return fontWeightFromStyle(style);
2780         case CSSPropertyFontSynthesis:
2781             return fontSynthesisFromStyle(style);
2782         case CSSPropertyFontFeatureSettings: {
2783             const FontFeatureSettings&amp; featureSettings = style.fontDescription().featureSettings();
2784             if (!featureSettings.size())
2785                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2786             auto list = CSSValueList::createCommaSeparated();
2787             for (auto&amp; feature : featureSettings)
2788                 list-&gt;append(CSSFontFeatureValue::create(FontTag(feature.tag()), feature.value()));
2789             return list;
2790         }
2791 #if ENABLE(VARIATION_FONTS)
2792         case CSSPropertyFontVariationSettings: {
2793             const FontVariationSettings&amp; variationSettings = style.fontDescription().variationSettings();
2794             if (variationSettings.isEmpty())
2795                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2796             auto list = CSSValueList::createCommaSeparated();
2797             for (auto&amp; feature : variationSettings)
2798                 list-&gt;append(CSSFontVariationValue::create(feature.tag(), feature.value()));
2799             return list;
2800         }
2801         case CSSPropertyFontOpticalSizing:
2802             return cssValuePool.createValue(style.fontDescription().opticalSizing());
2803 #endif
2804         case CSSPropertyGridAutoFlow: {
2805             auto list = CSSValueList::createSpaceSeparated();
2806             ASSERT(style.isGridAutoFlowDirectionRow() || style.isGridAutoFlowDirectionColumn());
2807             if (style.isGridAutoFlowDirectionRow())
2808                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRow));
2809             else
2810                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueColumn));
2811 
2812             if (style.isGridAutoFlowAlgorithmDense())
2813                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDense));
2814 
2815             return list;
2816         }
2817 
2818         // Specs mention that getComputedStyle() should return the used value of the property instead of the computed
2819         // one for grid-template-{rows|columns} but not for the grid-auto-{rows|columns} as things like
2820         // grid-auto-columns: 2fr; cannot be resolved to a value in pixels as the &#39;2fr&#39; means very different things
2821         // depending on the size of the explicit grid or the number of implicit tracks added to the grid. See
2822         // http://lists.w3.org/Archives/Public/www-style/2013Nov/0014.html
2823         case CSSPropertyGridAutoColumns:
2824             return valueForGridTrackSizeList(ForColumns, style);
2825         case CSSPropertyGridAutoRows:
2826             return valueForGridTrackSizeList(ForRows, style);
2827 
2828         case CSSPropertyGridTemplateColumns:
2829             return valueForGridTrackList(ForColumns, renderer, style);
2830         case CSSPropertyGridTemplateRows:
2831             return valueForGridTrackList(ForRows, renderer, style);
2832 
2833         case CSSPropertyGridColumnStart:
2834             return valueForGridPosition(style.gridItemColumnStart());
2835         case CSSPropertyGridColumnEnd:
2836             return valueForGridPosition(style.gridItemColumnEnd());
2837         case CSSPropertyGridRowStart:
2838             return valueForGridPosition(style.gridItemRowStart());
2839         case CSSPropertyGridRowEnd:
2840             return valueForGridPosition(style.gridItemRowEnd());
2841         case CSSPropertyGridArea:
2842             return getCSSPropertyValuesForGridShorthand(gridAreaShorthand());
2843         case CSSPropertyGridTemplate:
2844             return getCSSPropertyValuesForGridShorthand(gridTemplateShorthand());
2845         case CSSPropertyGrid:
2846             return getCSSPropertyValuesForGridShorthand(gridShorthand());
2847         case CSSPropertyGridColumn:
2848             return getCSSPropertyValuesForGridShorthand(gridColumnShorthand());
2849         case CSSPropertyGridRow:
2850             return getCSSPropertyValuesForGridShorthand(gridRowShorthand());
2851         case CSSPropertyGridTemplateAreas:
2852             if (!style.namedGridAreaRowCount()) {
2853                 ASSERT(!style.namedGridAreaColumnCount());
2854                 return cssValuePool.createIdentifierValue(CSSValueNone);
2855             }
2856             return CSSGridTemplateAreasValue::create(style.namedGridArea(), style.namedGridAreaRowCount(), style.namedGridAreaColumnCount());
2857         case CSSPropertyGap:
2858             return getCSSPropertyValuesForShorthandProperties(gapShorthand());
2859         case CSSPropertyHeight:
2860             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
2861                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-height-property,
2862                 // the &quot;height&quot; property does not apply for non-replaced inline elements.
2863                 if (!isNonReplacedInline(*renderer))
2864                     return zoomAdjustedPixelValue(sizingBox(*renderer).height(), style);
2865             }
2866             return zoomAdjustedPixelValueForLength(style.height(), style);
2867         case CSSPropertyWebkitHyphens:
2868             return cssValuePool.createValue(style.hyphens());
2869         case CSSPropertyWebkitHyphenateCharacter:
2870             if (style.hyphenationString().isNull())
2871                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2872             return cssValuePool.createValue(style.hyphenationString(), CSSUnitType::CSS_STRING);
2873         case CSSPropertyWebkitHyphenateLimitAfter:
2874             if (style.hyphenationLimitAfter() &lt; 0)
2875                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
2876             return CSSPrimitiveValue::create(style.hyphenationLimitAfter(), CSSUnitType::CSS_NUMBER);
2877         case CSSPropertyWebkitHyphenateLimitBefore:
2878             if (style.hyphenationLimitBefore() &lt; 0)
2879                 return CSSPrimitiveValue::createIdentifier(CSSValueAuto);
2880             return CSSPrimitiveValue::create(style.hyphenationLimitBefore(), CSSUnitType::CSS_NUMBER);
2881         case CSSPropertyWebkitHyphenateLimitLines:
2882             if (style.hyphenationLimitLines() &lt; 0)
2883                 return CSSPrimitiveValue::createIdentifier(CSSValueNoLimit);
2884             return CSSPrimitiveValue::create(style.hyphenationLimitLines(), CSSUnitType::CSS_NUMBER);
2885         case CSSPropertyWebkitBorderFit:
2886             if (style.borderFit() == BorderFit::Border)
2887                 return cssValuePool.createIdentifierValue(CSSValueBorder);
2888             return cssValuePool.createIdentifierValue(CSSValueLines);
2889         case CSSPropertyImageOrientation:
2890             if (style.imageOrientation() == ImageOrientation::FromImage)
2891                 return cssValuePool.createIdentifierValue(CSSValueFromImage);
2892             return cssValuePool.createIdentifierValue(CSSValueNone);
2893         case CSSPropertyImageRendering:
2894             return CSSPrimitiveValue::create(style.imageRendering());
2895 #if ENABLE(CSS_IMAGE_RESOLUTION)
2896         case CSSPropertyImageResolution:
2897             return cssValuePool.createValue(style.imageResolution(), CSSUnitType::CSS_DPPX);
2898 #endif
2899         case CSSPropertyLeft:
2900             return positionOffsetValue(style, CSSPropertyLeft, renderer);
2901         case CSSPropertyLetterSpacing:
2902             if (!style.letterSpacing())
2903                 return cssValuePool.createIdentifierValue(CSSValueNormal);
2904             return zoomAdjustedPixelValue(style.letterSpacing(), style);
2905         case CSSPropertyWebkitLineClamp:
2906             if (style.lineClamp().isNone())
2907                 return cssValuePool.createIdentifierValue(CSSValueNone);
2908             return cssValuePool.createValue(style.lineClamp().value(), style.lineClamp().isPercentage() ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);
2909         case CSSPropertyLineHeight:
2910             return lineHeightFromStyle(style);
2911         case CSSPropertyListStyleImage:
2912             if (style.listStyleImage())
2913                 return style.listStyleImage()-&gt;cssValue();
2914             return cssValuePool.createIdentifierValue(CSSValueNone);
2915         case CSSPropertyListStylePosition:
2916             return cssValuePool.createValue(style.listStylePosition());
2917         case CSSPropertyListStyleType:
2918             return cssValuePool.createValue(style.listStyleType());
2919         case CSSPropertyWebkitLocale:
2920             if (style.locale().isNull())
2921                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2922             return cssValuePool.createValue(style.locale(), CSSUnitType::CSS_STRING);
2923         case CSSPropertyMarginTop:
2924             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginTop, &amp;RenderBoxModelObject::marginTop&gt;(style, renderer);
2925         case CSSPropertyMarginRight: {
2926             Length marginRight = style.marginRight();
2927             if (marginRight.isFixed() || !is&lt;RenderBox&gt;(renderer))
2928                 return zoomAdjustedPixelValueForLength(marginRight, style);
2929             float value;
2930             if (marginRight.isPercentOrCalculated()) {
2931                 // RenderBox gives a marginRight() that is the distance between the right-edge of the child box
2932                 // and the right-edge of the containing box, when display == DisplayType::Block. Let&#39;s calculate the absolute
2933                 // value of the specified margin-right % instead of relying on RenderBox&#39;s marginRight() value.
2934                 value = minimumValueForLength(marginRight, downcast&lt;RenderBox&gt;(*renderer).containingBlockLogicalWidthForContent());
2935             } else
2936                 value = downcast&lt;RenderBox&gt;(*renderer).marginRight();
2937             return zoomAdjustedPixelValue(value, style);
2938         }
2939         case CSSPropertyMarginBottom:
2940             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginBottom, &amp;RenderBoxModelObject::marginBottom&gt;(style, renderer);
2941         case CSSPropertyMarginLeft:
2942             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::marginLeft, &amp;RenderBoxModelObject::marginLeft&gt;(style, renderer);
2943         case CSSPropertyWebkitUserModify:
2944             return cssValuePool.createValue(style.userModify());
2945         case CSSPropertyMaxHeight: {
2946             const Length&amp; maxHeight = style.maxHeight();
2947             if (maxHeight.isUndefined())
2948                 return cssValuePool.createIdentifierValue(CSSValueNone);
2949             return zoomAdjustedPixelValueForLength(maxHeight, style);
2950         }
2951         case CSSPropertyMaxWidth: {
2952             const Length&amp; maxWidth = style.maxWidth();
2953             if (maxWidth.isUndefined())
2954                 return cssValuePool.createIdentifierValue(CSSValueNone);
2955             return zoomAdjustedPixelValueForLength(maxWidth, style);
2956         }
2957         case CSSPropertyMinHeight:
2958             if (style.minHeight().isAuto()) {
2959                 auto* styledElement = this-&gt;styledElement();
2960                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
2961                     return cssValuePool.createIdentifierValue(CSSValueAuto);
2962                 return zoomAdjustedPixelValue(0, style);
2963             }
2964             return zoomAdjustedPixelValueForLength(style.minHeight(), style);
2965         case CSSPropertyMinWidth:
2966             if (style.minWidth().isAuto()) {
2967                 auto* styledElement = this-&gt;styledElement();
2968                 if (styledElement &amp;&amp; isFlexOrGrid(styledElement-&gt;parentNode()))
2969                     return cssValuePool.createIdentifierValue(CSSValueAuto);
2970                 return zoomAdjustedPixelValue(0, style);
2971             }
2972             return zoomAdjustedPixelValueForLength(style.minWidth(), style);
2973         case CSSPropertyObjectFit:
2974             return cssValuePool.createValue(style.objectFit());
2975         case CSSPropertyObjectPosition: {
2976             auto list = CSSValueList::createSpaceSeparated();
2977             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().x(), style));
2978             list-&gt;append(zoomAdjustedPixelValueForLength(style.objectPosition().y(), style));
2979             return list;
2980         }
2981         case CSSPropertyOpacity:
2982             return cssValuePool.createValue(style.opacity(), CSSUnitType::CSS_NUMBER);
2983         case CSSPropertyOrphans:
2984             if (style.hasAutoOrphans())
2985                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2986             return cssValuePool.createValue(style.orphans(), CSSUnitType::CSS_NUMBER);
2987         case CSSPropertyOutlineColor:
2988             return m_allowVisitedStyle ? cssValuePool.createColorValue(style.visitedDependentColor(CSSPropertyOutlineColor)) : currentColorOrValidColor(&amp;style, style.outlineColor());
2989         case CSSPropertyOutlineOffset:
2990             return zoomAdjustedPixelValue(style.outlineOffset(), style);
2991         case CSSPropertyOutlineStyle:
2992             if (style.outlineStyleIsAuto() == OutlineIsAuto::On)
2993                 return cssValuePool.createIdentifierValue(CSSValueAuto);
2994             return cssValuePool.createValue(style.outlineStyle());
2995         case CSSPropertyOutlineWidth:
2996             return zoomAdjustedPixelValue(style.outlineWidth(), style);
2997         case CSSPropertyOverflow:
2998             return getCSSPropertyValuesFor2SidesShorthand(overflowShorthand());
2999         case CSSPropertyOverflowWrap:
3000             return cssValuePool.createValue(style.overflowWrap());
3001         case CSSPropertyOverflowX:
3002             return cssValuePool.createValue(style.overflowX());
3003         case CSSPropertyOverflowY:
3004             return cssValuePool.createValue(style.overflowY());
3005         case CSSPropertyPaddingTop:
3006             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingTop, &amp;RenderBoxModelObject::computedCSSPaddingTop&gt;(style, renderer);
3007         case CSSPropertyPaddingRight:
3008             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingRight, &amp;RenderBoxModelObject::computedCSSPaddingRight&gt;(style, renderer);
3009         case CSSPropertyPaddingBottom:
3010             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingBottom, &amp;RenderBoxModelObject::computedCSSPaddingBottom&gt;(style, renderer);
3011         case CSSPropertyPaddingLeft:
3012             return zoomAdjustedPaddingOrMarginPixelValue&lt;&amp;RenderStyle::paddingLeft, &amp;RenderBoxModelObject::computedCSSPaddingLeft&gt;(style, renderer);
3013         case CSSPropertyPageBreakAfter:
3014             return cssValuePool.createValue(convertToPageBreak(style.breakAfter()));
3015         case CSSPropertyPageBreakBefore:
3016             return cssValuePool.createValue(convertToPageBreak(style.breakBefore()));
3017         case CSSPropertyPageBreakInside:
3018             return cssValuePool.createValue(convertToPageBreak(style.breakInside()));
3019         case CSSPropertyBreakAfter:
3020             return cssValuePool.createValue(style.breakAfter());
3021         case CSSPropertyBreakBefore:
3022             return cssValuePool.createValue(style.breakBefore());
3023         case CSSPropertyBreakInside:
3024             return cssValuePool.createValue(style.breakInside());
3025         case CSSPropertyHangingPunctuation:
3026             return hangingPunctuationToCSSValue(style.hangingPunctuation());
3027         case CSSPropertyPosition:
3028             return cssValuePool.createValue(style.position());
3029         case CSSPropertyRight:
3030             return positionOffsetValue(style, CSSPropertyRight, renderer);
3031         case CSSPropertyWebkitRubyPosition:
3032             return cssValuePool.createValue(style.rubyPosition());
3033         case CSSPropertyTableLayout:
3034             return cssValuePool.createValue(style.tableLayout());
3035         case CSSPropertyTextAlign:
3036             return cssValuePool.createValue(style.textAlign());
3037         case CSSPropertyTextDecoration:
3038             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3039 #if ENABLE(CSS3_TEXT)
3040         case CSSPropertyWebkitTextAlignLast:
3041             return cssValuePool.createValue(style.textAlignLast());
3042         case CSSPropertyWebkitTextJustify:
3043             return cssValuePool.createValue(style.textJustify());
3044 #endif // CSS3_TEXT
3045         case CSSPropertyWebkitTextDecoration:
3046             return getCSSPropertyValuesForShorthandProperties(webkitTextDecorationShorthand());
3047         case CSSPropertyTextDecorationLine:
3048             return renderTextDecorationFlagsToCSSValue(style.textDecoration());
3049         case CSSPropertyTextDecorationStyle:
3050             return renderTextDecorationStyleFlagsToCSSValue(style.textDecorationStyle());
3051         case CSSPropertyTextDecorationColor:
3052             return currentColorOrValidColor(&amp;style, style.textDecorationColor());
3053         case CSSPropertyTextDecorationSkip:
3054             return renderTextDecorationSkipFlagsToCSSValue(style.textDecorationSkip());
3055         case CSSPropertyTextUnderlinePosition:
3056             return cssValuePool.createValue(style.textUnderlinePosition());
3057         case CSSPropertyTextUnderlineOffset:
3058             return textUnderlineOffsetToCSSValue(style.textUnderlineOffset());
3059         case CSSPropertyTextDecorationThickness:
3060             return textDecorationThicknessToCSSValue(style.textDecorationThickness());
3061         case CSSPropertyWebkitTextDecorationsInEffect:
3062             return renderTextDecorationFlagsToCSSValue(style.textDecorationsInEffect());
3063         case CSSPropertyWebkitTextFillColor:
3064             return currentColorOrValidColor(&amp;style, style.textFillColor());
3065         case CSSPropertyWebkitTextEmphasisColor:
3066             return currentColorOrValidColor(&amp;style, style.textEmphasisColor());
3067         case CSSPropertyWebkitTextEmphasisPosition:
3068             return renderEmphasisPositionFlagsToCSSValue(style.textEmphasisPosition());
3069         case CSSPropertyWebkitTextEmphasisStyle:
3070             switch (style.textEmphasisMark()) {
3071             case TextEmphasisMark::None:
3072                 return cssValuePool.createIdentifierValue(CSSValueNone);
3073             case TextEmphasisMark::Custom:
3074                 return cssValuePool.createValue(style.textEmphasisCustomMark(), CSSUnitType::CSS_STRING);
3075             case TextEmphasisMark::Auto:
3076                 ASSERT_NOT_REACHED();
3077 #if !ASSERT_ENABLED
3078                 FALLTHROUGH;
3079 #endif
3080             case TextEmphasisMark::Dot:
3081             case TextEmphasisMark::Circle:
3082             case TextEmphasisMark::DoubleCircle:
3083             case TextEmphasisMark::Triangle:
3084             case TextEmphasisMark::Sesame:
3085                 auto list = CSSValueList::createSpaceSeparated();
3086                 list-&gt;append(cssValuePool.createValue(style.textEmphasisFill()));
3087                 list-&gt;append(cssValuePool.createValue(style.textEmphasisMark()));
3088                 return list;
3089             }
3090             RELEASE_ASSERT_NOT_REACHED();
3091         case CSSPropertyTextIndent: {
3092             // If CSS3_TEXT is disabled or text-indent has only one value(&lt;length&gt; | &lt;percentage&gt;),
3093             // getPropertyCSSValue() returns CSSValue.
3094             auto textIndent = zoomAdjustedPixelValueForLength(style.textIndent(), style);
3095 #if ENABLE(CSS3_TEXT)
3096             // If CSS3_TEXT is enabled and text-indent has -webkit-each-line or -webkit-hanging,
3097             // getPropertyCSSValue() returns CSSValueList.
3098             if (style.textIndentLine() == TextIndentLine::EachLine || style.textIndentType() == TextIndentType::Hanging) {
3099                 auto list = CSSValueList::createSpaceSeparated();
3100                 list-&gt;append(WTFMove(textIndent));
3101                 if (style.textIndentLine() == TextIndentLine::EachLine)
3102                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitEachLine));
3103                 if (style.textIndentType() == TextIndentType::Hanging)
3104                     list-&gt;append(cssValuePool.createIdentifierValue(CSSValueWebkitHanging));
3105                 return list;
3106             }
3107 #endif
3108             return textIndent;
3109         }
3110         case CSSPropertyTextShadow:
3111             return valueForShadow(style.textShadow(), propertyID, style);
3112         case CSSPropertyTextRendering:
3113             return cssValuePool.createValue(style.fontDescription().textRenderingMode());
3114         case CSSPropertyTextOverflow:
3115             if (style.textOverflow() == TextOverflow::Ellipsis)
3116                 return cssValuePool.createIdentifierValue(CSSValueEllipsis);
3117             return cssValuePool.createIdentifierValue(CSSValueClip);
3118         case CSSPropertyWebkitTextSecurity:
3119             return cssValuePool.createValue(style.textSecurity());
3120 #if ENABLE(TEXT_AUTOSIZING)
3121         case CSSPropertyWebkitTextSizeAdjust:
3122             if (style.textSizeAdjust().isAuto())
3123                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3124             if (style.textSizeAdjust().isNone())
3125                 return cssValuePool.createIdentifierValue(CSSValueNone);
3126             return CSSPrimitiveValue::create(style.textSizeAdjust().percentage(), CSSUnitType::CSS_PERCENTAGE);
3127 #endif
3128         case CSSPropertyWebkitTextStrokeColor:
3129             return currentColorOrValidColor(&amp;style, style.textStrokeColor());
3130         case CSSPropertyWebkitTextStrokeWidth:
3131             return zoomAdjustedPixelValue(style.textStrokeWidth(), style);
3132         case CSSPropertyTextTransform:
3133             return cssValuePool.createValue(style.textTransform());
3134         case CSSPropertyTop:
3135             return positionOffsetValue(style, CSSPropertyTop, renderer);
3136         case CSSPropertyUnicodeBidi:
3137             return cssValuePool.createValue(style.unicodeBidi());
3138         case CSSPropertyVerticalAlign:
3139             switch (style.verticalAlign()) {
3140             case VerticalAlign::Baseline:
3141                 return cssValuePool.createIdentifierValue(CSSValueBaseline);
3142             case VerticalAlign::Middle:
3143                 return cssValuePool.createIdentifierValue(CSSValueMiddle);
3144             case VerticalAlign::Sub:
3145                 return cssValuePool.createIdentifierValue(CSSValueSub);
3146             case VerticalAlign::Super:
3147                 return cssValuePool.createIdentifierValue(CSSValueSuper);
3148             case VerticalAlign::TextTop:
3149                 return cssValuePool.createIdentifierValue(CSSValueTextTop);
3150             case VerticalAlign::TextBottom:
3151                 return cssValuePool.createIdentifierValue(CSSValueTextBottom);
3152             case VerticalAlign::Top:
3153                 return cssValuePool.createIdentifierValue(CSSValueTop);
3154             case VerticalAlign::Bottom:
3155                 return cssValuePool.createIdentifierValue(CSSValueBottom);
3156             case VerticalAlign::BaselineMiddle:
3157                 return cssValuePool.createIdentifierValue(CSSValueWebkitBaselineMiddle);
3158             case VerticalAlign::Length:
3159                 return cssValuePool.createValue(style.verticalAlignLength());
3160             }
3161             ASSERT_NOT_REACHED();
3162             return nullptr;
3163         case CSSPropertyVisibility:
3164             return cssValuePool.createValue(style.visibility());
3165         case CSSPropertyWhiteSpace:
3166             return cssValuePool.createValue(style.whiteSpace());
3167         case CSSPropertyWidows:
3168             if (style.hasAutoWidows())
3169                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3170             return cssValuePool.createValue(style.widows(), CSSUnitType::CSS_NUMBER);
3171         case CSSPropertyWidth:
3172             if (renderer &amp;&amp; !renderer-&gt;isRenderSVGModelObject()) {
3173                 // According to http://www.w3.org/TR/CSS2/visudet.html#the-width-property,
3174                 // the &quot;width&quot; property does not apply for non-replaced inline elements.
3175                 if (!isNonReplacedInline(*renderer))
3176                     return zoomAdjustedPixelValue(sizingBox(*renderer).width(), style);
3177             }
3178             return zoomAdjustedPixelValueForLength(style.width(), style);
3179         case CSSPropertyWillChange:
3180             return willChangePropertyValue(style.willChange());
3181         case CSSPropertyWordBreak:
3182             return cssValuePool.createValue(style.wordBreak());
3183         case CSSPropertyWordSpacing:
3184             return zoomAdjustedPixelValue(style.fontCascade().wordSpacing(), style);
3185         case CSSPropertyWordWrap:
3186             return cssValuePool.createValue(style.overflowWrap());
3187         case CSSPropertyLineBreak:
3188             return cssValuePool.createValue(style.lineBreak());
3189         case CSSPropertyWebkitNbspMode:
3190             return cssValuePool.createValue(style.nbspMode());
3191         case CSSPropertyResize:
3192             return cssValuePool.createValue(style.resize());
3193         case CSSPropertyWebkitFontKerning:
3194             return cssValuePool.createValue(style.fontDescription().kerning());
3195         case CSSPropertyWebkitFontSmoothing:
3196             return cssValuePool.createValue(style.fontDescription().fontSmoothing());
3197         case CSSPropertyFontVariantLigatures:
3198             return fontVariantLigaturesPropertyValue(style.fontDescription().variantCommonLigatures(), style.fontDescription().variantDiscretionaryLigatures(), style.fontDescription().variantHistoricalLigatures(), style.fontDescription().variantContextualAlternates());
3199         case CSSPropertyFontVariantPosition:
3200             return fontVariantPositionPropertyValue(style.fontDescription().variantPosition());
3201         case CSSPropertyFontVariantCaps:
3202             return fontVariantCapsPropertyValue(style.fontDescription().variantCaps());
3203         case CSSPropertyFontVariantNumeric:
3204             return fontVariantNumericPropertyValue(style.fontDescription().variantNumericFigure(), style.fontDescription().variantNumericSpacing(), style.fontDescription().variantNumericFraction(), style.fontDescription().variantNumericOrdinal(), style.fontDescription().variantNumericSlashedZero());
3205         case CSSPropertyFontVariantAlternates:
3206             return fontVariantAlternatesPropertyValue(style.fontDescription().variantAlternates());
3207         case CSSPropertyFontVariantEastAsian:
3208             return fontVariantEastAsianPropertyValue(style.fontDescription().variantEastAsianVariant(), style.fontDescription().variantEastAsianWidth(), style.fontDescription().variantEastAsianRuby());
3209         case CSSPropertyZIndex:
3210             if (style.hasAutoSpecifiedZIndex())
3211                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3212             return cssValuePool.createValue(style.specifiedZIndex(), CSSUnitType::CSS_NUMBER);
3213         case CSSPropertyZoom:
3214             return cssValuePool.createValue(style.zoom(), CSSUnitType::CSS_NUMBER);
3215         case CSSPropertyBoxSizing:
3216             if (style.boxSizing() == BoxSizing::ContentBox)
3217                 return cssValuePool.createIdentifierValue(CSSValueContentBox);
3218             return cssValuePool.createIdentifierValue(CSSValueBorderBox);
3219         case CSSPropertyAnimationDelay:
3220             return delayValue(style.animations());
3221         case CSSPropertyAnimationDirection: {
3222             auto list = CSSValueList::createCommaSeparated();
3223             const AnimationList* t = style.animations();
3224             if (t) {
3225                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3226                     switch (t-&gt;animation(i).direction()) {
3227                     case Animation::AnimationDirectionNormal:
3228                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3229                         break;
3230                     case Animation::AnimationDirectionAlternate:
3231                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternate));
3232                         break;
3233                     case Animation::AnimationDirectionReverse:
3234                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueReverse));
3235                         break;
3236                     case Animation::AnimationDirectionAlternateReverse:
3237                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAlternateReverse));
3238                         break;
3239                     }
3240                 }
3241             } else
3242                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNormal));
3243             return list;
3244         }
3245         case CSSPropertyAnimationDuration:
3246             return durationValue(style.animations());
3247         case CSSPropertyAnimationFillMode: {
3248             auto list = CSSValueList::createCommaSeparated();
3249             const AnimationList* t = style.animations();
3250             if (t) {
3251                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3252                     switch (t-&gt;animation(i).fillMode()) {
3253                     case AnimationFillMode::None:
3254                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3255                         break;
3256                     case AnimationFillMode::Forwards:
3257                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueForwards));
3258                         break;
3259                     case AnimationFillMode::Backwards:
3260                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBackwards));
3261                         break;
3262                     case AnimationFillMode::Both:
3263                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueBoth));
3264                         break;
3265                     }
3266                 }
3267             } else
3268                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3269             return list;
3270         }
3271         case CSSPropertyAnimationIterationCount: {
3272             auto list = CSSValueList::createCommaSeparated();
3273             const AnimationList* t = style.animations();
3274             if (t) {
3275                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3276                     double iterationCount = t-&gt;animation(i).iterationCount();
3277                     if (iterationCount == Animation::IterationCountInfinite)
3278                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueInfinite));
3279                     else
3280                         list-&gt;append(cssValuePool.createValue(iterationCount, CSSUnitType::CSS_NUMBER));
3281                 }
3282             } else
3283                 list-&gt;append(cssValuePool.createValue(Animation::initialIterationCount(), CSSUnitType::CSS_NUMBER));
3284             return list;
3285         }
3286         case CSSPropertyAnimationName: {
3287             auto list = CSSValueList::createCommaSeparated();
3288             const AnimationList* t = style.animations();
3289             if (t) {
3290                 for (size_t i = 0; i &lt; t-&gt;size(); ++i)
3291                     list-&gt;append(cssValuePool.createValue(t-&gt;animation(i).name(), CSSUnitType::CSS_STRING));
3292             } else
3293                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueNone));
3294             return list;
3295         }
3296         case CSSPropertyAnimationPlayState: {
3297             auto list = CSSValueList::createCommaSeparated();
3298             const AnimationList* t = style.animations();
3299             if (t) {
3300                 for (size_t i = 0; i &lt; t-&gt;size(); ++i) {
3301                     switch (t-&gt;animation(i).playState()) {
3302                     case AnimationPlayState::Playing:
3303                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3304                         break;
3305                     case AnimationPlayState::Paused:
3306                         list-&gt;append(cssValuePool.createIdentifierValue(CSSValuePaused));
3307                         break;
3308                     }
3309                 }
3310             } else
3311                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueRunning));
3312             return list;
3313         }
3314         case CSSPropertyAnimationTimingFunction:
3315             return timingFunctionValue(style.animations());
3316         case CSSPropertyWebkitAppearance:
3317             return cssValuePool.createValue(style.appearance());
3318         case CSSPropertyWebkitAspectRatio:
3319             switch (style.aspectRatioType()) {
3320             case AspectRatioType::Auto:
3321                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3322             case AspectRatioType::FromDimensions:
3323                 return cssValuePool.createIdentifierValue(CSSValueFromDimensions);
3324             case AspectRatioType::FromIntrinsic:
3325                 return cssValuePool.createIdentifierValue(CSSValueFromIntrinsic);
3326             case AspectRatioType::Specified:
3327                 return CSSAspectRatioValue::create(style.aspectRatioNumerator(), style.aspectRatioDenominator());
3328             }
3329             ASSERT_NOT_REACHED();
3330             return nullptr;
3331         case CSSPropertyWebkitBackfaceVisibility:
3332             return cssValuePool.createIdentifierValue((style.backfaceVisibility() == BackfaceVisibility::Hidden) ? CSSValueHidden : CSSValueVisible);
3333         case CSSPropertyWebkitBorderImage:
3334             return valueForNinePieceImage(style.borderImage());
3335         case CSSPropertyBorderImageOutset:
3336             return valueForNinePieceImageQuad(style.borderImage().outset());
3337         case CSSPropertyBorderImageRepeat:
3338             return valueForNinePieceImageRepeat(style.borderImage());
3339         case CSSPropertyBorderImageSlice:
3340             return valueForNinePieceImageSlice(style.borderImage());
3341         case CSSPropertyBorderImageWidth:
3342             return valueForNinePieceImageQuad(style.borderImage().borderSlices());
3343         case CSSPropertyWebkitMaskBoxImage:
3344             return valueForNinePieceImage(style.maskBoxImage());
3345         case CSSPropertyWebkitMaskBoxImageOutset:
3346             return valueForNinePieceImageQuad(style.maskBoxImage().outset());
3347         case CSSPropertyWebkitMaskBoxImageRepeat:
3348             return valueForNinePieceImageRepeat(style.maskBoxImage());
3349         case CSSPropertyWebkitMaskBoxImageSlice:
3350             return valueForNinePieceImageSlice(style.maskBoxImage());
3351         case CSSPropertyWebkitMaskBoxImageWidth:
3352             return valueForNinePieceImageQuad(style.maskBoxImage().borderSlices());
3353         case CSSPropertyWebkitMaskBoxImageSource:
3354             if (style.maskBoxImageSource())
3355                 return style.maskBoxImageSource()-&gt;cssValue();
3356             return cssValuePool.createIdentifierValue(CSSValueNone);
3357         case CSSPropertyWebkitFontSizeDelta:
3358             // Not a real style property -- used by the editing engine -- so has no computed value.
3359             break;
3360         case CSSPropertyWebkitInitialLetter: {
3361             auto drop = !style.initialLetterDrop() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterDrop(), CSSUnitType::CSS_NUMBER);
3362             auto size = !style.initialLetterHeight() ? cssValuePool.createIdentifierValue(CSSValueNormal) : cssValuePool.createValue(style.initialLetterHeight(), CSSUnitType::CSS_NUMBER);
3363             return cssValuePool.createValue(Pair::create(WTFMove(drop), WTFMove(size)));
3364         }
3365         case CSSPropertyWebkitMarginBottomCollapse:
3366         case CSSPropertyWebkitMarginAfterCollapse:
3367             return cssValuePool.createValue(style.marginAfterCollapse());
3368         case CSSPropertyWebkitMarginTopCollapse:
3369         case CSSPropertyWebkitMarginBeforeCollapse:
3370             return cssValuePool.createValue(style.marginBeforeCollapse());
3371 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
3372         case CSSPropertyWebkitOverflowScrolling:
3373             if (!style.useTouchOverflowScrolling())
3374                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3375             return cssValuePool.createIdentifierValue(CSSValueTouch);
3376 #endif
3377         case CSSPropertyScrollBehavior:
3378             if (!style.useSmoothScrolling())
3379                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3380             return cssValuePool.createIdentifierValue(CSSValueSmooth);
3381         case CSSPropertyPerspective:
3382             if (!style.hasPerspective())
3383                 return cssValuePool.createIdentifierValue(CSSValueNone);
3384             return zoomAdjustedPixelValue(style.perspective(), style);
3385         case CSSPropertyPerspectiveOrigin: {
3386             auto list = CSSValueList::createSpaceSeparated();
3387             if (renderer) {
3388                 LayoutRect box;
3389                 if (is&lt;RenderBox&gt;(*renderer))
3390                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3391 
3392                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginX(), box.width()), style));
3393                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.perspectiveOriginY(), box.height()), style));
3394             } else {
3395                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginX(), style));
3396                 list-&gt;append(zoomAdjustedPixelValueForLength(style.perspectiveOriginY(), style));
3397             }
3398             return list;
3399         }
3400         case CSSPropertyWebkitRtlOrdering:
3401             return cssValuePool.createIdentifierValue(style.rtlOrdering() == Order::Visual ? CSSValueVisual : CSSValueLogical);
3402 #if ENABLE(TOUCH_EVENTS)
3403         case CSSPropertyWebkitTapHighlightColor:
3404             return currentColorOrValidColor(&amp;style, style.tapHighlightColor());
3405 #endif
3406 #if ENABLE(POINTER_EVENTS)
3407         case CSSPropertyTouchAction:
3408             return touchActionFlagsToCSSValue(style.touchActions());
3409 #endif
3410 #if PLATFORM(IOS_FAMILY)
3411         case CSSPropertyWebkitTouchCallout:
3412             return cssValuePool.createIdentifierValue(style.touchCalloutEnabled() ? CSSValueDefault : CSSValueNone);
3413 #endif
3414         case CSSPropertyWebkitUserDrag:
3415             return cssValuePool.createValue(style.userDrag());
3416         case CSSPropertyWebkitUserSelect:
3417             return cssValuePool.createValue(style.userSelect());
3418         case CSSPropertyBorderBottomLeftRadius:
3419             return borderRadiusCornerValue(style.borderBottomLeftRadius(), style);
3420         case CSSPropertyBorderBottomRightRadius:
3421             return borderRadiusCornerValue(style.borderBottomRightRadius(), style);
3422         case CSSPropertyBorderTopLeftRadius:
3423             return borderRadiusCornerValue(style.borderTopLeftRadius(), style);
3424         case CSSPropertyBorderTopRightRadius:
3425             return borderRadiusCornerValue(style.borderTopRightRadius(), style);
3426         case CSSPropertyClip: {
3427             if (!style.hasClip())
3428                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3429             auto rect = Rect::create();
3430             rect-&gt;setTop(autoOrZoomAdjustedValue(style.clip().top(), style));
3431             rect-&gt;setRight(autoOrZoomAdjustedValue(style.clip().right(), style));
3432             rect-&gt;setBottom(autoOrZoomAdjustedValue(style.clip().bottom(), style));
3433             rect-&gt;setLeft(autoOrZoomAdjustedValue(style.clip().left(), style));
3434             return cssValuePool.createValue(WTFMove(rect));
3435         }
3436         case CSSPropertySpeakAs:
3437             return speakAsToCSSValue(style.speakAs());
3438         case CSSPropertyTransform:
3439             return computedTransform(renderer, style);
3440         case CSSPropertyTransformBox:
3441             return CSSPrimitiveValue::create(style.transformBox());
3442         case CSSPropertyTransformOrigin: {
3443             auto list = CSSValueList::createSpaceSeparated();
3444             if (renderer) {
3445                 LayoutRect box;
3446                 if (is&lt;RenderBox&gt;(*renderer))
3447                     box = downcast&lt;RenderBox&gt;(*renderer).borderBoxRect();
3448 
3449                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginX(), box.width()), style));
3450                 list-&gt;append(zoomAdjustedPixelValue(minimumValueForLength(style.transformOriginY(), box.height()), style));
3451                 if (style.transformOriginZ())
3452                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3453             } else {
3454                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginX(), style));
3455                 list-&gt;append(zoomAdjustedPixelValueForLength(style.transformOriginY(), style));
3456                 if (style.transformOriginZ())
3457                     list-&gt;append(zoomAdjustedPixelValue(style.transformOriginZ(), style));
3458             }
3459             return list;
3460         }
3461         case CSSPropertyTransformStyle:
3462         case CSSPropertyWebkitTransformStyle:
3463             return cssValuePool.createIdentifierValue((style.transformStyle3D() == TransformStyle3D::Preserve3D) ? CSSValuePreserve3d : CSSValueFlat);
3464         case CSSPropertyTransitionDelay:
3465             return delayValue(style.transitions());
3466         case CSSPropertyTransitionDuration:
3467             return durationValue(style.transitions());
3468         case CSSPropertyTransitionProperty:
3469             return transitionPropertyValue(style.transitions());
3470         case CSSPropertyTransitionTimingFunction:
3471             return timingFunctionValue(style.transitions());
3472         case CSSPropertyTransition: {
3473             if (auto* animationList = style.transitions()) {
3474                 auto transitionsList = CSSValueList::createCommaSeparated();
3475                 for (size_t i = 0; i &lt; animationList-&gt;size(); ++i) {
3476                     auto list = CSSValueList::createSpaceSeparated();
3477                     auto&amp; animation = animationList-&gt;animation(i);
3478                     list-&gt;append(createTransitionPropertyValue(animation));
3479                     list-&gt;append(cssValuePool.createValue(animation.duration(), CSSUnitType::CSS_S));
3480                     list-&gt;append(createTimingFunctionValue(*animation.timingFunction()));
3481                     list-&gt;append(cssValuePool.createValue(animation.delay(), CSSUnitType::CSS_S));
3482                     transitionsList-&gt;append(WTFMove(list));
3483                 }
3484                 return transitionsList;
3485             }
3486 
3487             auto list = CSSValueList::createSpaceSeparated();
3488             // transition-property default value.
3489             list-&gt;append(cssValuePool.createIdentifierValue(CSSValueAll));
3490             list-&gt;append(cssValuePool.createValue(Animation::initialDuration(), CSSUnitType::CSS_S));
3491             list-&gt;append(createTimingFunctionValue(Animation::initialTimingFunction()));
3492             list-&gt;append(cssValuePool.createValue(Animation::initialDelay(), CSSUnitType::CSS_S));
3493             return list;
3494         }
3495         case CSSPropertyPointerEvents:
3496             return cssValuePool.createValue(style.pointerEvents());
3497         case CSSPropertyWebkitLineGrid:
3498             if (style.lineGrid().isNull())
3499                 return cssValuePool.createIdentifierValue(CSSValueNone);
3500             return cssValuePool.createValue(style.lineGrid(), CSSUnitType::CSS_STRING);
3501         case CSSPropertyWebkitLineSnap:
3502             return CSSPrimitiveValue::create(style.lineSnap());
3503         case CSSPropertyWebkitLineAlign:
3504             return CSSPrimitiveValue::create(style.lineAlign());
3505         case CSSPropertyWritingMode:
3506             return cssValuePool.createValue(style.writingMode());
3507         case CSSPropertyWebkitTextCombine:
3508             return cssValuePool.createValue(style.textCombine());
3509         case CSSPropertyWebkitTextOrientation:
3510             return CSSPrimitiveValue::create(style.textOrientation());
3511         case CSSPropertyWebkitLineBoxContain:
3512             return createLineBoxContainValue(style.lineBoxContain());
3513         case CSSPropertyAlt:
3514             return altTextToCSSValue(style);
3515         case CSSPropertyContent:
3516             return contentToCSSValue(style);
3517         case CSSPropertyCounterIncrement:
3518             return counterToCSSValue(style, propertyID);
3519         case CSSPropertyCounterReset:
3520             return counterToCSSValue(style, propertyID);
3521         case CSSPropertyClipPath: {
3522             auto* operation = style.clipPath();
3523             if (!operation)
3524                 return cssValuePool.createIdentifierValue(CSSValueNone);
3525             if (is&lt;ReferenceClipPathOperation&gt;(*operation))
3526                 return CSSPrimitiveValue::create(downcast&lt;ReferenceClipPathOperation&gt;(*operation).url(), CSSUnitType::CSS_URI);
3527             auto list = CSSValueList::createSpaceSeparated();
3528             if (is&lt;ShapeClipPathOperation&gt;(*operation)) {
3529                 auto&amp; shapeOperation = downcast&lt;ShapeClipPathOperation&gt;(*operation);
3530                 list-&gt;append(valueForBasicShape(style, shapeOperation.basicShape()));
3531                 if (shapeOperation.referenceBox() != CSSBoxType::BoxMissing)
3532                     list-&gt;append(cssValuePool.createValue(shapeOperation.referenceBox()));
3533             }
3534             if (is&lt;BoxClipPathOperation&gt;(*operation))
3535                 list-&gt;append(cssValuePool.createValue(downcast&lt;BoxClipPathOperation&gt;(*operation).referenceBox()));
3536             return list;
3537         }
3538         case CSSPropertyShapeMargin:
3539             return cssValuePool.createValue(style.shapeMargin(), style);
3540         case CSSPropertyShapeImageThreshold:
3541             return cssValuePool.createValue(style.shapeImageThreshold(), CSSUnitType::CSS_NUMBER);
3542         case CSSPropertyShapeOutside:
3543             return shapePropertyValue(style, style.shapeOutside());
3544         case CSSPropertyFilter:
3545             return valueForFilter(style, style.filter());
3546         case CSSPropertyAppleColorFilter:
3547             return valueForFilter(style, style.appleColorFilter());
3548 #if ENABLE(FILTERS_LEVEL_2)
3549         case CSSPropertyWebkitBackdropFilter:
3550             return valueForFilter(style, style.backdropFilter());
3551 #endif
3552 #if ENABLE(CSS_COMPOSITING)
3553         case CSSPropertyMixBlendMode:
3554             return cssValuePool.createValue(style.blendMode());
3555         case CSSPropertyIsolation:
3556             return cssValuePool.createValue(style.isolation());
3557 #endif
3558         case CSSPropertyBackgroundBlendMode: {
3559             auto&amp; layers = style.backgroundLayers();
3560             if (!layers.next())
3561                 return cssValuePool.createValue(layers.blendMode());
3562             auto list = CSSValueList::createCommaSeparated();
3563             for (auto* currLayer = &amp;layers; currLayer; currLayer = currLayer-&gt;next())
3564                 list-&gt;append(cssValuePool.createValue(currLayer-&gt;blendMode()));
3565             return list;
3566         }
3567         case CSSPropertyBackground:
3568             return getBackgroundShorthandValue();
3569         case CSSPropertyBorder: {
3570             auto value = propertyValue(CSSPropertyBorderTop, DoNotUpdateLayout);
3571             const CSSPropertyID properties[3] = { CSSPropertyBorderRight, CSSPropertyBorderBottom, CSSPropertyBorderLeft };
3572             for (auto&amp; property : properties) {
3573                 if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(property, DoNotUpdateLayout)))
3574                     return nullptr;
3575             }
3576             return value;
3577         }
3578         case CSSPropertyBorderBlock: {
3579             auto value = propertyValue(CSSPropertyBorderBlockStart, DoNotUpdateLayout);
3580             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderBlockEnd, DoNotUpdateLayout)))
3581                 return nullptr;
3582             return value;
3583         }
3584         case CSSPropertyBorderBlockColor:
3585             return getCSSPropertyValuesFor2SidesShorthand(borderBlockColorShorthand());
3586         case CSSPropertyBorderBlockStyle:
3587             return getCSSPropertyValuesFor2SidesShorthand(borderBlockStyleShorthand());
3588         case CSSPropertyBorderBlockWidth:
3589             return getCSSPropertyValuesFor2SidesShorthand(borderBlockWidthShorthand());
3590         case CSSPropertyBorderBottom:
3591             return getCSSPropertyValuesForShorthandProperties(borderBottomShorthand());
3592         case CSSPropertyBorderColor:
3593             return getCSSPropertyValuesFor4SidesShorthand(borderColorShorthand());
3594         case CSSPropertyBorderLeft:
3595             return getCSSPropertyValuesForShorthandProperties(borderLeftShorthand());
3596         case CSSPropertyBorderImage:
3597             return valueForNinePieceImage(style.borderImage());
3598         case CSSPropertyBorderInline: {
3599             auto value = propertyValue(CSSPropertyBorderInlineStart, DoNotUpdateLayout);
3600             if (!compareCSSValuePtr&lt;CSSValue&gt;(value, propertyValue(CSSPropertyBorderInlineEnd, DoNotUpdateLayout)))
3601                 return nullptr;
3602             return value;
3603         }
3604         case CSSPropertyBorderInlineColor:
3605             return getCSSPropertyValuesFor2SidesShorthand(borderInlineColorShorthand());
3606         case CSSPropertyBorderInlineStyle:
3607             return getCSSPropertyValuesFor2SidesShorthand(borderInlineStyleShorthand());
3608         case CSSPropertyBorderInlineWidth:
3609             return getCSSPropertyValuesFor2SidesShorthand(borderInlineWidthShorthand());
3610         case CSSPropertyBorderRadius:
3611             return borderRadiusShorthandValue(style);
3612         case CSSPropertyBorderRight:
3613             return getCSSPropertyValuesForShorthandProperties(borderRightShorthand());
3614         case CSSPropertyBorderStyle:
3615             return getCSSPropertyValuesFor4SidesShorthand(borderStyleShorthand());
3616         case CSSPropertyBorderTop:
3617             return getCSSPropertyValuesForShorthandProperties(borderTopShorthand());
3618         case CSSPropertyBorderWidth:
3619             return getCSSPropertyValuesFor4SidesShorthand(borderWidthShorthand());
3620         case CSSPropertyColumnRule:
3621             return getCSSPropertyValuesForShorthandProperties(columnRuleShorthand());
3622         case CSSPropertyColumns:
3623             return getCSSPropertyValuesForShorthandProperties(columnsShorthand());
3624         case CSSPropertyInset:
3625             return getCSSPropertyValuesFor4SidesShorthand(insetShorthand());
3626         case CSSPropertyInsetBlock:
3627             return getCSSPropertyValuesFor2SidesShorthand(insetBlockShorthand());
3628         case CSSPropertyInsetInline:
3629             return getCSSPropertyValuesFor2SidesShorthand(insetInlineShorthand());
3630         case CSSPropertyListStyle:
3631             return getCSSPropertyValuesForShorthandProperties(listStyleShorthand());
3632         case CSSPropertyMargin:
3633             return getCSSPropertyValuesFor4SidesShorthand(marginShorthand());
3634         case CSSPropertyMarginBlock:
3635             return getCSSPropertyValuesFor2SidesShorthand(marginBlockShorthand());
3636         case CSSPropertyMarginInline:
3637             return getCSSPropertyValuesFor2SidesShorthand(marginInlineShorthand());
3638         case CSSPropertyOutline:
3639             return getCSSPropertyValuesForShorthandProperties(outlineShorthand());
3640         case CSSPropertyPadding:
3641             return getCSSPropertyValuesFor4SidesShorthand(paddingShorthand());
3642         case CSSPropertyPaddingBlock:
3643             return getCSSPropertyValuesFor2SidesShorthand(paddingBlockShorthand());
3644         case CSSPropertyPaddingInline:
3645             return getCSSPropertyValuesFor2SidesShorthand(paddingInlineShorthand());
3646 #if ENABLE(CSS_SCROLL_SNAP)
3647         case CSSPropertyScrollSnapMargin:
3648             return getCSSPropertyValuesFor4SidesShorthand(scrollSnapMarginShorthand());
3649         case CSSPropertyScrollSnapMarginBottom:
3650             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginBottom(), style);
3651         case CSSPropertyScrollSnapMarginTop:
3652             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginTop(), style);
3653         case CSSPropertyScrollSnapMarginRight:
3654             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginRight(), style);
3655         case CSSPropertyScrollSnapMarginLeft:
3656             return zoomAdjustedPixelValueForLength(style.scrollSnapMarginLeft(), style);
3657         case CSSPropertyScrollPadding:
3658             return getCSSPropertyValuesFor4SidesShorthand(scrollPaddingShorthand());
3659         case CSSPropertyScrollPaddingBottom:
3660             return zoomAdjustedPixelValueForLength(style.scrollPaddingBottom(), style);
3661         case CSSPropertyScrollPaddingTop:
3662             return zoomAdjustedPixelValueForLength(style.scrollPaddingTop(), style);
3663         case CSSPropertyScrollPaddingRight:
3664             return zoomAdjustedPixelValueForLength(style.scrollPaddingRight(), style);
3665         case CSSPropertyScrollPaddingLeft:
3666             return zoomAdjustedPixelValueForLength(style.scrollPaddingLeft(), style);
3667         case CSSPropertyScrollSnapType:
3668             return valueForScrollSnapType(style.scrollSnapType());
3669         case CSSPropertyScrollSnapAlign:
3670             return valueForScrollSnapAlignment(style.scrollSnapAlign());
3671 #endif
3672 
3673 #if ENABLE(CSS_TRAILING_WORD)
3674         case CSSPropertyAppleTrailingWord:
3675             return cssValuePool.createValue(style.trailingWord());
3676 #endif
3677 
3678 #if ENABLE(APPLE_PAY)
3679         case CSSPropertyApplePayButtonStyle:
3680             return cssValuePool.createValue(style.applePayButtonStyle());
3681         case CSSPropertyApplePayButtonType:
3682             return cssValuePool.createValue(style.applePayButtonType());
3683 #endif
3684 
3685 #if ENABLE(DARK_MODE_CSS)
3686         case CSSPropertyColorScheme: {
3687             auto colorScheme = style.colorScheme();
3688             if (colorScheme.isAuto())
3689                 return cssValuePool.createIdentifierValue(CSSValueAuto);
3690 
3691             auto list = CSSValueList::createSpaceSeparated();
3692             if (colorScheme.contains(ColorScheme::Light))
3693                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueLight));
3694             if (colorScheme.contains(ColorScheme::Dark))
3695                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueDark));
3696             if (!colorScheme.allowsTransformations())
3697                 list-&gt;append(cssValuePool.createIdentifierValue(CSSValueOnly));
3698             ASSERT(list-&gt;length());
3699             return list;
3700         }
3701 #endif
3702 
3703         /* Individual properties not part of the spec */
3704         case CSSPropertyBackgroundRepeatX:
3705         case CSSPropertyBackgroundRepeatY:
3706             break;
3707 
3708         // Length properties for SVG.
3709         case CSSPropertyCx:
3710             return zoomAdjustedPixelValueForLength(style.svgStyle().cx(), style);
3711         case CSSPropertyCy:
3712             return zoomAdjustedPixelValueForLength(style.svgStyle().cy(), style);
3713         case CSSPropertyR:
3714             return zoomAdjustedPixelValueForLength(style.svgStyle().r(), style);
3715         case CSSPropertyRx:
3716             return zoomAdjustedPixelValueForLength(style.svgStyle().rx(), style);
3717         case CSSPropertyRy:
3718             return zoomAdjustedPixelValueForLength(style.svgStyle().ry(), style);
3719         case CSSPropertyStrokeDashoffset:
3720             return zoomAdjustedPixelValueForLength(style.svgStyle().strokeDashOffset(), style);
3721         case CSSPropertyX:
3722             return zoomAdjustedPixelValueForLength(style.svgStyle().x(), style);
3723         case CSSPropertyY:
3724             return zoomAdjustedPixelValueForLength(style.svgStyle().y(), style);
3725         case CSSPropertyWebkitTextZoom:
3726             return cssValuePool.createValue(style.textZoom());
3727 
3728         case CSSPropertyPaintOrder:
3729             return paintOrder(style.paintOrder());
3730         case CSSPropertyStrokeLinecap:
3731             return CSSPrimitiveValue::create(style.capStyle());
3732         case CSSPropertyStrokeLinejoin:
3733             return CSSPrimitiveValue::create(style.joinStyle());
3734         case CSSPropertyStrokeWidth:
3735             return zoomAdjustedPixelValueForLength(style.strokeWidth(), style);
3736         case CSSPropertyStrokeColor:
3737             return currentColorOrValidColor(&amp;style, style.strokeColor());
3738         case CSSPropertyStrokeMiterlimit:
3739             return CSSPrimitiveValue::create(style.strokeMiterLimit(), CSSUnitType::CSS_NUMBER);
3740 
3741         /* Unimplemented CSS 3 properties (including CSS3 shorthand properties) */
3742         case CSSPropertyAll:
3743         case CSSPropertyAnimation:
3744         case CSSPropertyWebkitTextEmphasis:
3745             break;
3746 
3747         /* Directional properties are resolved by resolveDirectionAwareProperty() before the switch. */
3748         case CSSPropertyBorderBlockEnd:
3749         case CSSPropertyBorderBlockEndColor:
3750         case CSSPropertyBorderBlockEndStyle:
3751         case CSSPropertyBorderBlockEndWidth:
3752         case CSSPropertyBorderBlockStart:
3753         case CSSPropertyBorderBlockStartColor:
3754         case CSSPropertyBorderBlockStartStyle:
3755         case CSSPropertyBorderBlockStartWidth:
3756         case CSSPropertyBorderInlineEnd:
3757         case CSSPropertyBorderInlineEndColor:
3758         case CSSPropertyBorderInlineEndStyle:
3759         case CSSPropertyBorderInlineEndWidth:
3760         case CSSPropertyBorderInlineStart:
3761         case CSSPropertyBorderInlineStartColor:
3762         case CSSPropertyBorderInlineStartStyle:
3763         case CSSPropertyBorderInlineStartWidth:
3764         case CSSPropertyInsetBlockEnd:
3765         case CSSPropertyInsetBlockStart:
3766         case CSSPropertyInsetInlineEnd:
3767         case CSSPropertyInsetInlineStart:
3768         case CSSPropertyMarginBlockEnd:
3769         case CSSPropertyMarginBlockStart:
3770         case CSSPropertyMarginInlineEnd:
3771         case CSSPropertyMarginInlineStart:
3772         case CSSPropertyPaddingBlockEnd:
3773         case CSSPropertyPaddingBlockStart:
3774         case CSSPropertyPaddingInlineEnd:
3775         case CSSPropertyPaddingInlineStart:
3776         case CSSPropertyBlockSize:
3777         case CSSPropertyInlineSize:
3778         case CSSPropertyMaxBlockSize:
3779         case CSSPropertyMaxInlineSize:
3780         case CSSPropertyMinBlockSize:
3781         case CSSPropertyMinInlineSize:
3782             ASSERT_NOT_REACHED();
3783             break;
3784 
3785         /* Unimplemented @font-face properties */
3786         case CSSPropertySrc:
3787         case CSSPropertyUnicodeRange:
3788         case CSSPropertyFontDisplay:
3789             break;
3790 
3791         /* Other unimplemented properties */
3792         case CSSPropertyPage: // for @page
3793         case CSSPropertyQuotes: // FIXME: needs implementation
3794         case CSSPropertySize: // for @page
3795             break;
3796 
3797         /* Unimplemented -webkit- properties */
3798         case CSSPropertyWebkitBorderRadius:
3799         case CSSPropertyWebkitMarginCollapse:
3800         case CSSPropertyWebkitMarqueeDirection:
3801         case CSSPropertyWebkitMarqueeIncrement:
3802         case CSSPropertyWebkitMarqueeRepetition:
3803         case CSSPropertyWebkitMarqueeStyle:
3804         case CSSPropertyWebkitMarqueeSpeed:
3805         case CSSPropertyWebkitMask:
3806         case CSSPropertyWebkitMaskRepeatX:
3807         case CSSPropertyWebkitMaskRepeatY:
3808         case CSSPropertyPerspectiveOriginX:
3809         case CSSPropertyPerspectiveOriginY:
3810         case CSSPropertyWebkitTextStroke:
3811         case CSSPropertyTransformOriginX:
3812         case CSSPropertyTransformOriginY:
3813         case CSSPropertyTransformOriginZ:
3814             break;
3815 
3816 #if ENABLE(CSS_DEVICE_ADAPTATION)
3817         case CSSPropertyMaxZoom:
3818         case CSSPropertyMinZoom:
3819         case CSSPropertyOrientation:
3820         case CSSPropertyUserZoom:
3821             break;
3822 #endif
3823 
3824         case CSSPropertyBufferedRendering:
3825         case CSSPropertyClipRule:
3826         case CSSPropertyMask:
3827         case CSSPropertyEnableBackground:
3828         case CSSPropertyFloodColor:
3829         case CSSPropertyFloodOpacity:
3830         case CSSPropertyLightingColor:
3831         case CSSPropertyStopColor:
3832         case CSSPropertyStopOpacity:
3833         case CSSPropertyColorInterpolation:
3834         case CSSPropertyColorInterpolationFilters:
3835         case CSSPropertyColorProfile:
3836         case CSSPropertyColorRendering:
3837         case CSSPropertyFill:
3838         case CSSPropertyFillOpacity:
3839         case CSSPropertyFillRule:
3840         case CSSPropertyMarker:
3841         case CSSPropertyMarkerEnd:
3842         case CSSPropertyMarkerMid:
3843         case CSSPropertyMarkerStart:
3844         case CSSPropertyMaskType:
3845         case CSSPropertyShapeRendering:
3846         case CSSPropertyStroke:
3847         case CSSPropertyStrokeDasharray:
3848         case CSSPropertyStrokeOpacity:
3849         case CSSPropertyAlignmentBaseline:
3850         case CSSPropertyBaselineShift:
3851         case CSSPropertyDominantBaseline:
3852         case CSSPropertyGlyphOrientationHorizontal:
3853         case CSSPropertyGlyphOrientationVertical:
3854         case CSSPropertyKerning:
3855         case CSSPropertyTextAnchor:
3856         case CSSPropertyVectorEffect:
3857             return svgPropertyValue(propertyID);
3858         case CSSPropertyCustom:
3859             ASSERT_NOT_REACHED();
3860             return nullptr;
3861     }
3862 
3863     return nullptr;
3864 }
3865 
3866 String CSSComputedStyleDeclaration::getPropertyValue(CSSPropertyID propertyID) const
3867 {
3868     auto value = getPropertyCSSValue(propertyID);
3869     if (!value)
3870         return emptyString(); // FIXME: Should this be null instead, as it is in StyleProperties::getPropertyValue?
3871     return value-&gt;cssText();
3872 }
3873 
3874 unsigned CSSComputedStyleDeclaration::length() const
3875 {
3876     updateStyleIfNeededForProperty(m_element.get(), CSSPropertyCustom);
3877 
3878     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
3879     if (!style)
3880         return 0;
3881 
3882     return numComputedPropertyIDs + style-&gt;inheritedCustomProperties().size() + style-&gt;nonInheritedCustomProperties().size();
3883 }
3884 
3885 String CSSComputedStyleDeclaration::item(unsigned i) const
3886 {
3887     if (i &gt;= length())
3888         return String();
3889 
3890     if (i &lt; numComputedPropertyIDs)
3891         return getPropertyNameString(computedPropertyIDs[i]);
3892 
3893     auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier);
3894     if (!style)
3895         return String();
3896 
3897     const auto&amp; inheritedCustomProperties = style-&gt;inheritedCustomProperties();
3898 
3899     if (i &lt; numComputedPropertyIDs + inheritedCustomProperties.size()) {
3900         auto results = copyToVector(inheritedCustomProperties.keys());
3901         return results.at(i - numComputedPropertyIDs);
3902     }
3903 
3904     const auto&amp; nonInheritedCustomProperties = style-&gt;nonInheritedCustomProperties();
3905     auto results = copyToVector(nonInheritedCustomProperties.keys());
3906     return results.at(i - inheritedCustomProperties.size() - numComputedPropertyIDs);
3907 }
3908 
3909 bool ComputedStyleExtractor::propertyMatches(CSSPropertyID propertyID, const CSSValue* value)
3910 {
3911     if (!m_element)
3912         return false;
3913     if (propertyID == CSSPropertyFontSize &amp;&amp; is&lt;CSSPrimitiveValue&gt;(*value)) {
3914         m_element-&gt;document().updateLayoutIgnorePendingStylesheets();
3915         if (auto* style = m_element-&gt;computedStyle(m_pseudoElementSpecifier)) {
3916             if (CSSValueID sizeIdentifier = style-&gt;fontDescription().keywordSizeAsIdentifier()) {
3917                 auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
3918                 if (primitiveValue.isValueID() &amp;&amp; primitiveValue.valueID() == sizeIdentifier)
3919                     return true;
3920             }
3921         }
3922     }
3923     RefPtr&lt;CSSValue&gt; computedValue = propertyValue(propertyID);
3924     return computedValue &amp;&amp; value &amp;&amp; computedValue-&gt;equals(*value);
3925 }
3926 
3927 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForShorthandProperties(const StylePropertyShorthand&amp; shorthand)
3928 {
3929     auto list = CSSValueList::createSpaceSeparated();
3930     for (size_t i = 0; i &lt; shorthand.length(); ++i)
3931         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
3932     return list;
3933 }
3934 
3935 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor2SidesShorthand(const StylePropertyShorthand&amp; shorthand)
3936 {
3937     auto list = CSSValueList::createSpaceSeparated();
3938 
3939     // Assume the properties are in the usual order start, end.
3940     auto startValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
3941     auto endValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
3942 
3943     // All 2 properties must be specified.
3944     if (!startValue || !endValue)
3945         return nullptr;
3946 
3947     bool showEnd = !compareCSSValuePtr(startValue, endValue);
3948 
3949     list-&gt;append(startValue.releaseNonNull());
3950     if (showEnd)
3951         list-&gt;append(endValue.releaseNonNull());
3952 
3953     return list;
3954 }
3955 
3956 RefPtr&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesFor4SidesShorthand(const StylePropertyShorthand&amp; shorthand)
3957 {
3958     auto list = CSSValueList::createSpaceSeparated();
3959 
3960     // Assume the properties are in the usual order top, right, bottom, left.
3961     auto topValue = propertyValue(shorthand.properties()[0], DoNotUpdateLayout);
3962     auto rightValue = propertyValue(shorthand.properties()[1], DoNotUpdateLayout);
3963     auto bottomValue = propertyValue(shorthand.properties()[2], DoNotUpdateLayout);
3964     auto leftValue = propertyValue(shorthand.properties()[3], DoNotUpdateLayout);
3965 
3966     // All 4 properties must be specified.
3967     if (!topValue || !rightValue || !bottomValue || !leftValue)
3968         return nullptr;
3969 
3970     bool showLeft = !compareCSSValuePtr(rightValue, leftValue);
3971     bool showBottom = !compareCSSValuePtr(topValue, bottomValue) || showLeft;
3972     bool showRight = !compareCSSValuePtr(topValue, rightValue) || showBottom;
3973 
3974     list-&gt;append(topValue.releaseNonNull());
3975     if (showRight)
3976         list-&gt;append(rightValue.releaseNonNull());
3977     if (showBottom)
3978         list-&gt;append(bottomValue.releaseNonNull());
3979     if (showLeft)
3980         list-&gt;append(leftValue.releaseNonNull());
3981 
3982     return list;
3983 }
3984 
3985 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getCSSPropertyValuesForGridShorthand(const StylePropertyShorthand&amp; shorthand)
3986 {
3987     auto list = CSSValueList::createSlashSeparated();
3988     for (size_t i = 0; i &lt; shorthand.length(); ++i)
3989         list-&gt;append(propertyValue(shorthand.properties()[i], DoNotUpdateLayout).releaseNonNull());
3990     return list;
3991 }
3992 
3993 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyPropertiesInSet(const CSSPropertyID* set, unsigned length)
3994 {
3995     Vector&lt;CSSProperty&gt; list;
3996     list.reserveInitialCapacity(length);
3997     for (unsigned i = 0; i &lt; length; ++i) {
3998         if (auto value = propertyValue(set[i]))
3999             list.append(CSSProperty(set[i], WTFMove(value), false));
4000     }
4001     return MutableStyleProperties::create(WTFMove(list));
4002 }
4003 
4004 Ref&lt;MutableStyleProperties&gt; ComputedStyleExtractor::copyProperties()
4005 {
4006     Vector&lt;CSSProperty&gt; list;
4007     list.reserveInitialCapacity(numCSSProperties);
4008     for (unsigned i = firstCSSProperty; i &lt; lastCSSProperty; ++i) {
4009         auto propertyID = convertToCSSPropertyID(i);
4010         if (auto value = propertyValue(propertyID))
4011             list.append(CSSProperty(propertyID, WTFMove(value)));
4012     }
4013     return MutableStyleProperties::create(WTFMove(list));
4014 }
4015 
4016 CSSRule* CSSComputedStyleDeclaration::parentRule() const
4017 {
4018     return nullptr;
4019 }
4020 
4021 RefPtr&lt;DeprecatedCSSOMValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValue(const String&amp; propertyName)
4022 {
4023     if (isCustomPropertyName(propertyName)) {
4024         auto value = ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyValue(propertyName);
4025         if (!value)
4026             return nullptr;
4027         return value-&gt;createDeprecatedCSSOMWrapper(*this);
4028     }
4029 
4030     CSSPropertyID propertyID = cssPropertyID(propertyName);
4031     if (!propertyID)
4032         return nullptr;
4033     auto value = getPropertyCSSValue(propertyID);
4034     if (!value)
4035         return nullptr;
4036     return value-&gt;createDeprecatedCSSOMWrapper(*this);
4037 }
4038 
4039 String CSSComputedStyleDeclaration::getPropertyValue(const String &amp;propertyName)
4040 {
4041     if (isCustomPropertyName(propertyName))
4042         return ComputedStyleExtractor(m_element.ptr(), m_allowVisitedStyle, m_pseudoElementSpecifier).customPropertyText(propertyName);
4043 
4044     CSSPropertyID propertyID = cssPropertyID(propertyName);
4045     if (!propertyID)
4046         return String();
4047     return getPropertyValue(propertyID);
4048 }
4049 
4050 String CSSComputedStyleDeclaration::getPropertyPriority(const String&amp;)
4051 {
4052     // All computed styles have a priority of not &quot;important&quot;.
4053     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4054 }
4055 
4056 String CSSComputedStyleDeclaration::getPropertyShorthand(const String&amp;)
4057 {
4058     return emptyString(); // FIXME: Should this sometimes be null instead of empty, to match a normal style declaration?
4059 }
4060 
4061 bool CSSComputedStyleDeclaration::isPropertyImplicit(const String&amp;)
4062 {
4063     return false;
4064 }
4065 
4066 ExceptionOr&lt;void&gt; CSSComputedStyleDeclaration::setProperty(const String&amp;, const String&amp;, const String&amp;)
4067 {
4068     return Exception { NoModificationAllowedError };
4069 }
4070 
4071 ExceptionOr&lt;String&gt; CSSComputedStyleDeclaration::removeProperty(const String&amp;)
4072 {
4073     return Exception { NoModificationAllowedError };
4074 }
4075 
4076 RefPtr&lt;CSSValue&gt; CSSComputedStyleDeclaration::getPropertyCSSValueInternal(CSSPropertyID propertyID)
4077 {
4078     return getPropertyCSSValue(propertyID);
4079 }
4080 
4081 String CSSComputedStyleDeclaration::getPropertyValueInternal(CSSPropertyID propertyID)
4082 {
4083     return getPropertyValue(propertyID);
4084 }
4085 
4086 ExceptionOr&lt;bool&gt; CSSComputedStyleDeclaration::setPropertyInternal(CSSPropertyID, const String&amp;, bool)
4087 {
4088     return Exception { NoModificationAllowedError };
4089 }
4090 
4091 Ref&lt;CSSValueList&gt; ComputedStyleExtractor::getBackgroundShorthandValue()
4092 {
4093     static const CSSPropertyID propertiesBeforeSlashSeperator[5] = { CSSPropertyBackgroundColor, CSSPropertyBackgroundImage, CSSPropertyBackgroundRepeat, CSSPropertyBackgroundAttachment, CSSPropertyBackgroundPosition };
4094     static const CSSPropertyID propertiesAfterSlashSeperator[3] = { CSSPropertyBackgroundSize, CSSPropertyBackgroundOrigin, CSSPropertyBackgroundClip };
4095 
4096     auto list = CSSValueList::createSlashSeparated();
4097     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesBeforeSlashSeperator)));
4098     list-&gt;append(getCSSPropertyValuesForShorthandProperties(StylePropertyShorthand(CSSPropertyBackground, propertiesAfterSlashSeperator)));
4099     return list;
4100 }
4101 
4102 } // namespace WebCore
    </pre>
  </body>
</html>
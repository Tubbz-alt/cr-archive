<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 #include &quot;WebGLDrawBuffers.h&quot;
 30 
 31 #include &quot;Extensions3D.h&quot;
 32 
 33 namespace WebCore {
 34 
 35 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
 36     : WebGLExtension(context)
 37 {
 38 }
 39 
 40 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 41 
 42 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
 43 {
 44     return WebGLExtension::WebGLDrawBuffersName;
 45 }
 46 
 47 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
 48 {
 49     return context.graphicsContext3D()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)
 50         &amp;&amp; satisfiesWebGLRequirements(context);
 51 }
 52 
 53 void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GC3Denum&gt;&amp; buffers)
 54 {
 55     if (m_context.isContextLost())
 56         return;
 57     GC3Dsizei n = buffers.size();
 58     const GC3Denum* bufs = buffers.data();
 59     if (!m_context.m_framebufferBinding) {
 60         if (n != 1) {
 61             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);
 62             return;
 63         }
 64         if (bufs[0] != GraphicsContext3D::BACK &amp;&amp; bufs[0] != GraphicsContext3D::NONE) {
 65             m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);
 66             return;
 67         }
 68         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
 69         GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;
 70         m_context.graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);
 71         m_context.setBackDrawBuffer(bufs[0]);
 72     } else {
 73         if (n &gt; m_context.getMaxDrawBuffers()) {
 74             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);
 75             return;
 76         }
 77         for (GC3Dsizei i = 0; i &lt; n; ++i) {
 78             if (bufs[i] != GraphicsContext3D::NONE &amp;&amp; bufs[i] != static_cast&lt;GC3Denum&gt;(Extensions3D::COLOR_ATTACHMENT0_EXT + i)) {
 79                 m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);
 80                 return;
 81             }
 82         }
 83         m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
 84     }
 85 }
 86 
 87 // static
 88 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
 89 {
 90     GraphicsContext3D* context = webglContext.graphicsContext3D();
 91 
 92     // This is called after we make sure GL_EXT_draw_buffers is supported.
 93     GC3Dint maxDrawBuffers = 0;
 94     GC3Dint maxColorAttachments = 0;
 95     context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);
 96     context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);
 97     if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
 98         return false;
 99 
100     Platform3DObject fbo = context-&gt;createFramebuffer();
101     context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, fbo);
102 
103     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
104     bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
105         || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
106     bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
107         || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
108     Platform3DObject depthStencil = 0;
109     if (supportsDepthStencil) {
110         depthStencil = context-&gt;createTexture();
111         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depthStencil);
112         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_STENCIL, 1, 1, 0, GraphicsContext3D::DEPTH_STENCIL, GraphicsContext3D::UNSIGNED_INT_24_8, buffer);
113     }
114     Platform3DObject depth = 0;
115     if (supportsDepth) {
116         depth = context-&gt;createTexture();
117         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depth);
118         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_COMPONENT, 1, 1, 0, GraphicsContext3D::DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT, buffer);
119     }
120 
121     Vector&lt;Platform3DObject&gt; colors;
122     bool ok = true;
123     GC3Dint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);
124     for (GC3Dint i = 0; i &lt; maxAllowedBuffers; ++i) {
125         Platform3DObject color = context-&gt;createTexture();
126         colors.append(color);
127         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, color);
128         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1, 0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, buffer);
129         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0 + i, GraphicsContext3D::TEXTURE_2D, color, 0);
130         if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
131             ok = false;
132             break;
133         }
134         if (supportsDepth) {
135             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depth, 0);
136             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
137                 ok = false;
138                 break;
139             }
140             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
141         }
142         if (supportsDepthStencil) {
143             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);
144             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);
145             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {
146                 ok = false;
147                 break;
148             }
149             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
150             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);
151         }
152     }
153 
154     webglContext.restoreCurrentFramebuffer();
155     context-&gt;deleteFramebuffer(fbo);
156     webglContext.restoreCurrentTexture2D();
157     if (supportsDepth)
158         context-&gt;deleteTexture(depth);
159     if (supportsDepthStencil)
160         context-&gt;deleteTexture(depthStencil);
161     for (auto&amp; color : colors)
162         context-&gt;deleteTexture(color);
163     return ok;
164 }
165 
166 } // namespace WebCore
167 
168 #endif // ENABLE(WEBGL)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLLowerDFGToB3.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;FTLLowerDFGToB3.h&quot;
   28 
   29 #if ENABLE(FTL_JIT)
   30 
   31 #include &quot;AirCode.h&quot;
   32 #include &quot;AirGenerationContext.h&quot;
   33 #include &quot;AllowMacroScratchRegisterUsage.h&quot;
   34 #include &quot;AllowMacroScratchRegisterUsageIf.h&quot;
   35 #include &quot;AtomicsObject.h&quot;
   36 #include &quot;B3CheckValue.h&quot;
   37 #include &quot;B3FenceValue.h&quot;
   38 #include &quot;B3PatchpointValue.h&quot;
   39 #include &quot;B3SlotBaseValue.h&quot;
   40 #include &quot;B3StackmapGenerationParams.h&quot;
   41 #include &quot;B3ValueInlines.h&quot;
<a name="1" id="anc1"></a><span class="line-added">   42 #include &quot;ButterflyInlines.h&quot;</span>
   43 #include &quot;CallFrameShuffler.h&quot;
   44 #include &quot;CodeBlockWithJITType.h&quot;
   45 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   46 #include &quot;DFGCapabilities.h&quot;
   47 #include &quot;DFGDoesGC.h&quot;
   48 #include &quot;DFGDominators.h&quot;
   49 #include &quot;DFGInPlaceAbstractState.h&quot;
   50 #include &quot;DFGLivenessAnalysisPhase.h&quot;
   51 #include &quot;DFGMayExit.h&quot;
   52 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
   53 #include &quot;DFGOSRExitFuzz.h&quot;
   54 #include &quot;DirectArguments.h&quot;
   55 #include &quot;FTLAbstractHeapRepository.h&quot;
   56 #include &quot;FTLAvailableRecovery.h&quot;
   57 #include &quot;FTLExceptionTarget.h&quot;
   58 #include &quot;FTLForOSREntryJITCode.h&quot;
   59 #include &quot;FTLFormattedValue.h&quot;
   60 #include &quot;FTLLazySlowPathCall.h&quot;
   61 #include &quot;FTLLoweredNodeValue.h&quot;
   62 #include &quot;FTLOperations.h&quot;
   63 #include &quot;FTLOutput.h&quot;
   64 #include &quot;FTLPatchpointExceptionHandle.h&quot;
   65 #include &quot;FTLSnippetParams.h&quot;
   66 #include &quot;FTLThunks.h&quot;
   67 #include &quot;FTLWeightedTarget.h&quot;
   68 #include &quot;JITAddGenerator.h&quot;
   69 #include &quot;JITBitAndGenerator.h&quot;
   70 #include &quot;JITBitOrGenerator.h&quot;
   71 #include &quot;JITBitXorGenerator.h&quot;
   72 #include &quot;JITDivGenerator.h&quot;
   73 #include &quot;JITInlineCacheGenerator.h&quot;
   74 #include &quot;JITLeftShiftGenerator.h&quot;
   75 #include &quot;JITMathIC.h&quot;
   76 #include &quot;JITMulGenerator.h&quot;
   77 #include &quot;JITRightShiftGenerator.h&quot;
   78 #include &quot;JITSubGenerator.h&quot;
<a name="2" id="anc2"></a><span class="line-added">   79 #include &quot;JSArrayIterator.h&quot;</span>
   80 #include &quot;JSAsyncFunction.h&quot;
<a name="3" id="anc3"></a><span class="line-added">   81 #include &quot;JSAsyncGenerator.h&quot;</span>
   82 #include &quot;JSAsyncGeneratorFunction.h&quot;
   83 #include &quot;JSCInlines.h&quot;
<a name="4" id="anc4"></a><span class="line-added">   84 #include &quot;JSGenerator.h&quot;</span>
   85 #include &quot;JSGeneratorFunction.h&quot;
   86 #include &quot;JSImmutableButterfly.h&quot;
   87 #include &quot;JSLexicalEnvironment.h&quot;
   88 #include &quot;JSMap.h&quot;
   89 #include &quot;OperandsInlines.h&quot;
   90 #include &quot;ProbeContext.h&quot;
   91 #include &quot;RegExpObject.h&quot;
   92 #include &quot;ScopedArguments.h&quot;
   93 #include &quot;ScopedArgumentsTable.h&quot;
   94 #include &quot;ScratchRegisterAllocator.h&quot;
   95 #include &quot;SetupVarargsFrame.h&quot;
   96 #include &quot;ShadowChicken.h&quot;
   97 #include &quot;StructureStubInfo.h&quot;
   98 #include &quot;SuperSampler.h&quot;
   99 #include &quot;ThunkGenerators.h&quot;
  100 #include &quot;VirtualRegister.h&quot;
  101 #include &quot;Watchdog.h&quot;
  102 #include &lt;atomic&gt;
  103 #include &lt;wtf/Box.h&gt;
  104 #include &lt;wtf/Gigacage.h&gt;
  105 #include &lt;wtf/RecursableLambda.h&gt;
  106 #include &lt;wtf/StdUnorderedSet.h&gt;
  107 
  108 #undef RELEASE_ASSERT
  109 #define RELEASE_ASSERT(assertion) do { \
  110     if (!(assertion)) { \
  111         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
  112         CRASH(); \
  113     } \
  114 } while (0)
  115 
  116 namespace JSC { namespace FTL {
  117 
  118 using namespace B3;
  119 using namespace DFG;
  120 
  121 namespace {
  122 
  123 std::atomic&lt;int&gt; compileCounter;
  124 
<a name="5" id="anc5"></a><span class="line-modified">  125 #if ASSERT_ENABLED</span>
  126 NO_RETURN_DUE_TO_CRASH static void ftlUnreachable(
  127     CodeBlock* codeBlock, BlockIndex blockIndex, unsigned nodeIndex)
  128 {
  129     dataLog(&quot;Crashing in thought-to-be-unreachable FTL-generated code for &quot;, pointerDump(codeBlock), &quot; at basic block #&quot;, blockIndex);
  130     if (nodeIndex != UINT_MAX)
  131         dataLog(&quot;, node @&quot;, nodeIndex);
  132     dataLog(&quot;.\n&quot;);
  133     CRASH();
  134 }
<a name="6" id="anc6"></a><span class="line-modified">  135 #endif // ASSERT_ENABLED</span>
  136 
  137 // Using this instead of typeCheck() helps to reduce the load on B3, by creating
  138 // significantly less dead code.
  139 #define FTL_TYPE_CHECK_WITH_EXIT_KIND(exitKind, lowValue, highValue, typesPassedThrough, failCondition) do { \
  140         FormattedValue _ftc_lowValue = (lowValue);                      \
  141         Edge _ftc_highValue = (highValue);                              \
  142         SpeculatedType _ftc_typesPassedThrough = (typesPassedThrough);  \
  143         if (!m_interpreter.needsTypeCheck(_ftc_highValue, _ftc_typesPassedThrough)) \
  144             break;                                                      \
  145         typeCheck(_ftc_lowValue, _ftc_highValue, _ftc_typesPassedThrough, (failCondition), exitKind); \
  146     } while (false)
  147 
  148 #define FTL_TYPE_CHECK(lowValue, highValue, typesPassedThrough, failCondition) \
  149     FTL_TYPE_CHECK_WITH_EXIT_KIND(BadType, lowValue, highValue, typesPassedThrough, failCondition)
  150 
  151 class LowerDFGToB3 {
  152     WTF_MAKE_NONCOPYABLE(LowerDFGToB3);
  153 public:
  154     LowerDFGToB3(State&amp; state)
  155         : m_graph(state.graph)
  156         , m_ftlState(state)
  157         , m_out(state)
  158         , m_proc(*state.proc)
  159         , m_availabilityCalculator(m_graph)
  160         , m_state(state.graph)
  161         , m_interpreter(state.graph, m_state)
<a name="7" id="anc7"></a>
  162     {
  163         if (Options::validateAbstractInterpreterState()) {
  164             performLivenessAnalysis(m_graph);
  165 
  166             // We only use node liveness here, not combined liveness, as we only track
  167             // AI state for live nodes.
  168             for (DFG::BasicBlock* block : m_graph.blocksInNaturalOrder()) {
  169                 NodeSet live;
  170 
  171                 for (NodeFlowProjection node : block-&gt;ssa-&gt;liveAtTail) {
  172                     if (node.kind() == NodeFlowProjection::Primary)
  173                         live.addVoid(node.node());
  174                 }
  175 
  176                 for (unsigned i = block-&gt;size(); i--; ) {
  177                     Node* node = block-&gt;at(i);
  178                     live.remove(node);
  179                     m_graph.doToChildren(node, [&amp;] (Edge child) {
  180                         live.addVoid(child.node());
  181                     });
  182                     m_liveInToNode.add(node, live);
  183                 }
  184             }
  185         }
  186     }
  187 
  188     void lower()
  189     {
  190         State* state = &amp;m_ftlState;
  191 
  192         CString name;
  193         if (verboseCompilationEnabled()) {
  194             name = toCString(
  195                 &quot;jsBody_&quot;, ++compileCounter, &quot;_&quot;, codeBlock()-&gt;inferredName(),
  196                 &quot;_&quot;, codeBlock()-&gt;hash());
  197         } else
  198             name = &quot;jsBody&quot;;
  199 
  200         {
  201             m_proc.setNumEntrypoints(m_graph.m_numberOfEntrypoints);
  202             CodeBlock* codeBlock = m_graph.m_codeBlock;
  203 
  204             Ref&lt;B3::Air::PrologueGenerator&gt; catchPrologueGenerator = createSharedTask&lt;B3::Air::PrologueGeneratorFunction&gt;(
  205                 [codeBlock] (CCallHelpers&amp; jit, B3::Air::Code&amp; code) {
  206                     AllowMacroScratchRegisterUsage allowScratch(jit);
  207                     jit.addPtr(CCallHelpers::TrustedImm32(-code.frameSize()), GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
<a name="8" id="anc8"></a>

  208 
  209                     jit.emitSave(code.calleeSaveRegisterAtOffsetList());
<a name="9" id="anc9"></a><span class="line-modified">  210                     jit.emitPutToCallFrameHeader(codeBlock, VirtualRegister(CallFrameSlot::codeBlock));</span>
  211                 });
  212 
<a name="10" id="anc10"></a><span class="line-modified">  213             for (unsigned catchEntrypointIndex : m_graph.m_entrypointIndexToCatchBytecodeIndex.keys()) {</span>
  214                 RELEASE_ASSERT(catchEntrypointIndex != 0);
  215                 m_proc.code().setPrologueForEntrypoint(catchEntrypointIndex, catchPrologueGenerator.copyRef());
  216             }
  217 
  218             if (m_graph.m_maxLocalsForCatchOSREntry) {
  219                 uint32_t numberOfLiveLocals = std::max(*m_graph.m_maxLocalsForCatchOSREntry, 1u); // Make sure we always allocate a non-null catchOSREntryBuffer.
  220                 m_ftlState.jitCode-&gt;common.catchOSREntryBuffer = m_graph.m_vm.scratchBufferForSize(sizeof(JSValue) * numberOfLiveLocals);
  221             }
  222         }
  223 
  224         m_graph.ensureSSADominators();
  225 
  226         if (verboseCompilationEnabled())
  227             dataLog(&quot;Function ready, beginning lowering.\n&quot;);
  228 
  229         m_out.initialize(m_heaps);
  230 
  231         // We use prologue frequency for all of the initialization code.
  232         m_out.setFrequency(1);
  233 
  234         bool hasMultipleEntrypoints = m_graph.m_numberOfEntrypoints &gt; 1;
  235 
  236         LBasicBlock prologue = m_out.newBlock();
  237         LBasicBlock callEntrypointArgumentSpeculations = hasMultipleEntrypoints ? m_out.newBlock() : nullptr;
  238         m_handleExceptions = m_out.newBlock();
  239 
  240         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
  241             m_highBlock = m_graph.block(blockIndex);
  242             if (!m_highBlock)
  243                 continue;
  244             m_out.setFrequency(m_highBlock-&gt;executionCount);
  245             m_blocks.add(m_highBlock, m_out.newBlock());
  246         }
  247 
  248         // Back to prologue frequency for any bocks that get sneakily created in the initialization code.
  249         m_out.setFrequency(1);
  250 
  251         m_out.appendTo(prologue, hasMultipleEntrypoints ? callEntrypointArgumentSpeculations : m_handleExceptions);
  252         m_out.initializeConstants(m_proc, prologue);
  253         createPhiVariables();
  254 
  255         size_t sizeOfCaptured = sizeof(JSValue) * m_graph.m_nextMachineLocal;
  256         B3::SlotBaseValue* capturedBase = m_out.lockedStackSlot(sizeOfCaptured);
  257         m_captured = m_out.add(capturedBase, m_out.constIntPtr(sizeOfCaptured));
  258         state-&gt;capturedValue = capturedBase-&gt;slot();
  259 
  260         auto preOrder = m_graph.blocksInPreOrder();
  261 
<a name="11" id="anc11"></a><span class="line-added">  262         VM* vm = &amp;this-&gt;vm();</span>
<span class="line-added">  263 </span>
  264         m_callFrame = m_out.framePointer();
<a name="12" id="anc12"></a><span class="line-modified">  265         m_vmValue = m_out.constIntPtr(vm);</span>
<span class="line-modified">  266         m_numberTag = m_out.constInt64(JSValue::NumberTag);</span>
<span class="line-added">  267         m_notCellMask = m_out.constInt64(JSValue::NotCellMask);</span>
  268 
  269         // Make sure that B3 knows that we really care about the mask registers. This forces the
  270         // constants to be materialized in registers.
<a name="13" id="anc13"></a><span class="line-modified">  271         m_proc.addFastConstant(m_numberTag-&gt;key());</span>
<span class="line-modified">  272         m_proc.addFastConstant(m_notCellMask-&gt;key());</span>
  273 
  274         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
  275         // that would cause it to always get collected.
<a name="14" id="anc14"></a><span class="line-modified">  276         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), addressFor(VirtualRegister(CallFrameSlot::codeBlock)));</span>


  277 
  278         // Stack Overflow Check.
  279         unsigned exitFrameSize = m_graph.requiredRegisterCountForExit() * sizeof(Register);
  280         MacroAssembler::AbsoluteAddress addressOfStackLimit(vm-&gt;addressOfSoftStackLimit());
  281         PatchpointValue* stackOverflowHandler = m_out.patchpoint(Void);
<a name="15" id="anc15"></a><span class="line-modified">  282         CallSiteIndex callSiteIndex = callSiteIndexForCodeOrigin(m_ftlState, CodeOrigin(BytecodeIndex(0)));</span>
  283         stackOverflowHandler-&gt;appendSomeRegister(m_callFrame);
  284         stackOverflowHandler-&gt;clobber(RegisterSet::macroScratchRegisters());
  285         stackOverflowHandler-&gt;numGPScratchRegisters = 1;
  286         stackOverflowHandler-&gt;setGenerator(
  287             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
  288                 AllowMacroScratchRegisterUsage allowScratch(jit);
  289                 GPRReg fp = params[0].gpr();
  290                 GPRReg scratch = params.gpScratch(0);
  291 
  292                 unsigned ftlFrameSize = params.proc().frameSize();
  293                 unsigned maxFrameSize = std::max(exitFrameSize, ftlFrameSize);
  294 
  295                 jit.addPtr(MacroAssembler::TrustedImm32(-maxFrameSize), fp, scratch);
  296                 MacroAssembler::JumpList stackOverflow;
  297                 if (UNLIKELY(maxFrameSize &gt; Options::reservedZoneSize()))
  298                     stackOverflow.append(jit.branchPtr(MacroAssembler::Above, scratch, fp));
  299                 stackOverflow.append(jit.branchPtr(MacroAssembler::Above, addressOfStackLimit, scratch));
  300 
  301                 params.addLatePath([=] (CCallHelpers&amp; jit) {
  302                     AllowMacroScratchRegisterUsage allowScratch(jit);
  303 
  304                     stackOverflow.link(&amp;jit);
  305 
  306                     // FIXME: We would not have to do this if the stack check was part of the Air
  307                     // prologue. Then, we would know that there is no way for the callee-saves to
  308                     // get clobbered.
  309                     // https://bugs.webkit.org/show_bug.cgi?id=172456
  310                     jit.emitRestore(params.proc().calleeSaveRegisterAtOffsetList());
  311 
  312                     jit.store32(
  313                         MacroAssembler::TrustedImm32(callSiteIndex.bits()),
<a name="16" id="anc16"></a><span class="line-modified">  314                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
  315                     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);
  316 
<a name="17" id="anc17"></a><span class="line-modified">  317                     jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()), GPRInfo::argumentGPR0);</span>
<span class="line-modified">  318                     jit.prepareCallOperation(*vm);</span>
  319                     CCallHelpers::Call throwCall = jit.call(OperationPtrTag);
  320 
  321                     jit.move(CCallHelpers::TrustedImmPtr(vm), GPRInfo::argumentGPR0);
<a name="18" id="anc18"></a><span class="line-modified">  322                     jit.prepareCallOperation(*vm);</span>
  323                     CCallHelpers::Call lookupExceptionHandlerCall = jit.call(OperationPtrTag);
  324                     jit.jumpToExceptionHandler(*vm);
  325 
  326                     jit.addLinkTask(
  327                         [=] (LinkBuffer&amp; linkBuffer) {
  328                             linkBuffer.link(throwCall, FunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowError));
<a name="19" id="anc19"></a><span class="line-modified">  329                             linkBuffer.link(lookupExceptionHandlerCall, FunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandlerFromCallerFrame));</span>
  330                     });
  331                 });
  332             });
  333 
  334         LBasicBlock firstDFGBasicBlock = lowBlock(m_graph.block(0));
  335 
  336         {
  337             if (hasMultipleEntrypoints) {
  338                 Vector&lt;LBasicBlock&gt; successors(m_graph.m_numberOfEntrypoints);
  339                 successors[0] = callEntrypointArgumentSpeculations;
  340                 for (unsigned i = 1; i &lt; m_graph.m_numberOfEntrypoints; ++i) {
  341                     // Currently, the only other entrypoint is an op_catch entrypoint.
  342                     // We do OSR entry at op_catch, and we prove argument formats before
  343                     // jumping to FTL code, so we don&#39;t need to check argument types here
  344                     // for these entrypoints.
  345                     successors[i] = firstDFGBasicBlock;
  346                 }
  347 
  348                 m_out.entrySwitch(successors);
  349                 m_out.appendTo(callEntrypointArgumentSpeculations, m_handleExceptions);
  350             }
  351 
  352             m_node = nullptr;
<a name="20" id="anc20"></a><span class="line-modified">  353             m_origin = NodeOrigin(CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), true);</span>
  354 
  355             // Check Arguments.
  356             availabilityMap().clear();
<a name="21" id="anc21"></a><span class="line-modified">  357             availabilityMap().m_locals = Operands&lt;Availability&gt;(codeBlock()-&gt;numParameters(), 0, 0);</span>
  358             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  359                 availabilityMap().m_locals.argument(i) =
<a name="22" id="anc22"></a><span class="line-modified">  360                     Availability(FlushedAt(FlushedJSValue, virtualRegisterForArgumentIncludingThis(i)));</span>
  361             }
  362 
  363             for (unsigned i = codeBlock()-&gt;numParameters(); i--;) {
  364                 MethodOfGettingAValueProfile profile(&amp;m_graph.m_profiledBlock-&gt;valueProfileForArgument(i));
<a name="23" id="anc23"></a><span class="line-modified">  365                 VirtualRegister operand = virtualRegisterForArgumentIncludingThis(i);</span>
  366                 LValue jsValue = m_out.load64(addressFor(operand));
  367 
  368                 switch (m_graph.m_argumentFormats[0][i]) {
  369                 case FlushedInt32:
  370                     speculate(BadType, jsValueValue(jsValue), profile, isNotInt32(jsValue));
  371                     break;
  372                 case FlushedBoolean:
  373                     speculate(BadType, jsValueValue(jsValue), profile, isNotBoolean(jsValue));
  374                     break;
  375                 case FlushedCell:
  376                     speculate(BadType, jsValueValue(jsValue), profile, isNotCell(jsValue));
  377                     break;
  378                 case FlushedJSValue:
  379                     break;
  380                 default:
  381                     DFG_CRASH(m_graph, nullptr, &quot;Bad flush format for argument&quot;);
  382                     break;
  383                 }
  384             }
  385             m_out.jump(firstDFGBasicBlock);
  386         }
  387 
  388 
  389         m_out.appendTo(m_handleExceptions, firstDFGBasicBlock);
  390         Box&lt;CCallHelpers::Label&gt; exceptionHandler = state-&gt;exceptionHandler;
  391         m_out.patchpoint(Void)-&gt;setGenerator(
  392             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
  393                 CCallHelpers::Jump jump = jit.jump();
  394                 jit.addLinkTask(
  395                     [=] (LinkBuffer&amp; linkBuffer) {
  396                         linkBuffer.link(jump, linkBuffer.locationOf&lt;ExceptionHandlerPtrTag&gt;(*exceptionHandler));
  397                     });
  398             });
  399         m_out.unreachable();
  400 
  401         for (DFG::BasicBlock* block : preOrder)
  402             compileBlock(block);
  403 
  404         // Make sure everything is decorated. This does a bunch of deferred decorating. This has
  405         // to happen last because our abstract heaps are generated lazily. They have to be
  406         // generated lazily because we have an infinite number of numbered, indexed, and
  407         // absolute heaps. We only become aware of the ones we actually mention while lowering.
  408         m_heaps.computeRangesAndDecorateInstructions();
  409 
  410         // We create all Phi&#39;s up front, but we may then decide not to compile the basic block
  411         // that would have contained one of them. So this creates orphans, which triggers B3
  412         // validation failures. Calling this fixes the issue.
  413         //
  414         // Note that you should avoid the temptation to make this call conditional upon
  415         // validation being enabled. B3 makes no guarantees of any kind of correctness when
  416         // dealing with IR that would have failed validation. For example, it would be valid to
  417         // write a B3 phase that so aggressively assumes the lack of orphans that it would crash
  418         // if any orphans were around. We might even have such phases already.
  419         m_proc.deleteOrphans();
  420 
  421         // We put the blocks into the B3 procedure in a super weird order. Now we reorder them.
  422         m_out.applyBlockOrder();
  423     }
  424 
  425 private:
  426 
  427     void createPhiVariables()
  428     {
  429         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  430             DFG::BasicBlock* block = m_graph.block(blockIndex);
  431             if (!block)
  432                 continue;
  433             for (unsigned nodeIndex = block-&gt;size(); nodeIndex--;) {
  434                 Node* node = block-&gt;at(nodeIndex);
  435                 if (node-&gt;op() != DFG::Phi)
  436                     continue;
  437                 LType type;
  438                 switch (node-&gt;flags() &amp; NodeResultMask) {
  439                 case NodeResultDouble:
  440                     type = Double;
  441                     break;
  442                 case NodeResultInt32:
  443                     type = Int32;
  444                     break;
  445                 case NodeResultInt52:
  446                     type = Int64;
  447                     break;
  448                 case NodeResultBoolean:
  449                     type = Int32;
  450                     break;
  451                 case NodeResultJS:
  452                     type = Int64;
  453                     break;
  454                 default:
  455                     DFG_CRASH(m_graph, node, &quot;Bad Phi node result type&quot;);
  456                     break;
  457                 }
  458                 m_phis.add(node, m_proc.add&lt;Value&gt;(B3::Phi, type, Origin(node)));
  459             }
  460         }
  461     }
  462 
  463     void compileBlock(DFG::BasicBlock* block)
  464     {
  465         if (!block)
  466             return;
  467 
  468         if (verboseCompilationEnabled())
  469             dataLog(&quot;Compiling block &quot;, *block, &quot;\n&quot;);
  470 
  471         m_highBlock = block;
  472 
  473         // Make sure that any blocks created while lowering code in the high block have the frequency of
  474         // the high block. This is appropriate because B3 doesn&#39;t need precise frequencies. It just needs
  475         // something roughly approximate for things like register allocation.
  476         m_out.setFrequency(m_highBlock-&gt;executionCount);
  477 
  478         LBasicBlock lowBlock = m_blocks.get(m_highBlock);
  479 
  480         m_nextHighBlock = 0;
  481         for (BlockIndex nextBlockIndex = m_highBlock-&gt;index + 1; nextBlockIndex &lt; m_graph.numBlocks(); ++nextBlockIndex) {
  482             m_nextHighBlock = m_graph.block(nextBlockIndex);
  483             if (m_nextHighBlock)
  484                 break;
  485         }
  486         m_nextLowBlock = m_nextHighBlock ? m_blocks.get(m_nextHighBlock) : 0;
  487 
  488         // All of this effort to find the next block gives us the ability to keep the
  489         // generated IR in roughly program order. This ought not affect the performance
  490         // of the generated code (since we expect B3 to reorder things) but it will
  491         // make IR dumps easier to read.
  492         m_out.appendTo(lowBlock, m_nextLowBlock);
  493 
  494         if (Options::ftlCrashes())
  495             m_out.trap();
  496 
  497         if (!m_highBlock-&gt;cfaHasVisited) {
  498             if (verboseCompilationEnabled())
  499                 dataLog(&quot;Bailing because CFA didn&#39;t reach.\n&quot;);
  500             crash(m_highBlock, nullptr);
  501             return;
  502         }
  503 
  504         m_aiCheckedNodes.clear();
  505 
  506         m_availabilityCalculator.beginBlock(m_highBlock);
  507 
  508         m_state.reset();
  509         m_state.beginBasicBlock(m_highBlock);
  510 
  511         for (m_nodeIndex = 0; m_nodeIndex &lt; m_highBlock-&gt;size(); ++m_nodeIndex) {
  512             if (!compileNode(m_nodeIndex))
  513                 break;
  514         }
  515     }
  516 
  517     void safelyInvalidateAfterTermination()
  518     {
  519         if (verboseCompilationEnabled())
  520             dataLog(&quot;Bailing.\n&quot;);
  521         crash();
  522 
  523         // Invalidate dominated blocks. Under normal circumstances we would expect
  524         // them to be invalidated already. But you can have the CFA become more
  525         // precise over time because the structures of objects change on the main
  526         // thread. Failing to do this would result in weird crashes due to a value
  527         // being used but not defined. Race conditions FTW!
  528         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  529             DFG::BasicBlock* target = m_graph.block(blockIndex);
  530             if (!target)
  531                 continue;
  532             if (m_graph.m_ssaDominators-&gt;dominates(m_highBlock, target)) {
  533                 if (verboseCompilationEnabled())
  534                     dataLog(&quot;Block &quot;, *target, &quot; will bail also.\n&quot;);
  535                 target-&gt;cfaHasVisited = false;
  536             }
  537         }
  538     }
  539 
  540     void validateAIState(Node* node)
  541     {
  542         if (!m_graphDump) {
  543             StringPrintStream out;
  544             m_graph.dump(out);
  545             m_graphDump = out.toString();
  546         }
  547 
  548         switch (node-&gt;op()) {
  549         case MovHint:
  550         case ZombieHint:
  551         case JSConstant:
  552         case LazyJSConstant:
  553         case DoubleConstant:
  554         case Int52Constant:
  555         case GetStack:
  556         case PutStack:
  557         case KillStack:
  558         case ExitOK:
  559             return;
  560         default:
  561             break;
  562         }
  563 
  564         // Before we execute node.
  565         NodeSet&amp; live = m_liveInToNode.find(node)-&gt;value;
  566         unsigned highParentIndex = node-&gt;index();
  567         {
  568             uint64_t hash = WTF::intHash(highParentIndex);
  569             if (hash &gt;= static_cast&lt;uint64_t&gt;((static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max()) + 1) * Options::validateAbstractInterpreterStateProbability()))
  570                 return;
  571         }
  572 
  573         for (Node* node : live) {
  574             if (node-&gt;isPhantomAllocation())
  575                 continue;
  576 
  577             if (node-&gt;op() == CheckInBounds)
  578                 continue;
  579 
  580             AbstractValue value = m_interpreter.forNode(node);
  581             {
  582                 auto iter = m_aiCheckedNodes.find(node);
  583                 if (iter != m_aiCheckedNodes.end()) {
  584                     AbstractValue checkedValue = iter-&gt;value;
  585                     if (checkedValue == value) {
  586                         if (!(value.m_type &amp; SpecCell))
  587                             continue;
  588                     }
  589                 }
  590                 m_aiCheckedNodes.set(node, value);
  591             }
  592 
  593             FlushFormat flushFormat;
  594             LValue input;
  595             if (node-&gt;hasJSResult()) {
  596                 input = lowJSValue(Edge(node, UntypedUse));
  597                 flushFormat = FlushedJSValue;
  598             } else if (node-&gt;hasDoubleResult()) {
  599                 input = lowDouble(Edge(node, DoubleRepUse));
  600                 flushFormat = FlushedDouble;
  601             } else if (node-&gt;hasInt52Result()) {
  602                 input = strictInt52ToJSValue(lowStrictInt52(Edge(node, Int52RepUse)));
  603                 flushFormat = FlushedInt52;
  604             } else
  605                 continue;
  606 
  607             unsigned highChildIndex = node-&gt;index();
  608 
  609             String graphDump = m_graphDump;
  610 
  611             PatchpointValue* patchpoint = m_out.patchpoint(Void);
  612             patchpoint-&gt;effects = Effects::none();
  613             patchpoint-&gt;effects.writesLocalState = true;
  614             patchpoint-&gt;appendSomeRegister(input);
  615             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
  616                 GPRReg reg = InvalidGPRReg;
  617                 FPRReg fpReg = InvalidFPRReg;
  618                 if (flushFormat == FlushedDouble)
  619                     fpReg = params[0].fpr();
  620                 else
  621                     reg = params[0].gpr();
  622                 jit.probe([=] (Probe::Context&amp; context) {
  623                     JSValue input;
  624                     double doubleInput;
  625 
  626                     auto dumpAndCrash = [&amp;] {
  627                         dataLogLn(&quot;Validation failed at node: @&quot;, highParentIndex);
  628                         dataLogLn(&quot;Failed validating live value: @&quot;, highChildIndex);
  629                         dataLogLn();
  630                         dataLogLn(&quot;Expected AI value = &quot;, value);
  631                         if (flushFormat != FlushedDouble)
  632                             dataLogLn(&quot;Unexpected value = &quot;, input);
  633                         else
  634                             dataLogLn(&quot;Unexpected double value = &quot;, doubleInput);
  635                         dataLogLn();
  636                         dataLogLn(graphDump);
  637                         CRASH();
  638                     };
  639 
  640                     if (flushFormat == FlushedDouble) {
  641                         doubleInput = context.fpr(fpReg);
  642                         SpeculatedType type;
  643                         if (!std::isnan(doubleInput))
  644                             type = speculationFromValue(jsDoubleNumber(doubleInput));
  645                         else if (isImpureNaN(doubleInput))
  646                             type = SpecDoubleImpureNaN;
  647                         else
  648                             type = SpecDoublePureNaN;
  649 
  650                         if (!value.couldBeType(type))
  651                             dumpAndCrash();
  652                     } else {
  653                         input = JSValue::decode(context.gpr(reg));
  654                         if (flushFormat == FlushedInt52) {
  655                             RELEASE_ASSERT(input.isAnyInt());
  656                             input = jsDoubleNumber(input.asAnyInt());
  657                         }
  658                         if (!value.validateOSREntryValue(input, flushFormat))
  659                             dumpAndCrash();
  660                     }
  661 
  662                 });
  663             });
  664         }
  665     }
  666 
  667     bool compileNode(unsigned nodeIndex)
  668     {
  669         if (!m_state.isValid()) {
  670             safelyInvalidateAfterTermination();
  671             return false;
  672         }
  673 
  674         m_node = m_highBlock-&gt;at(nodeIndex);
  675         m_origin = m_node-&gt;origin;
  676         m_out.setOrigin(m_node);
  677 
  678         if (verboseCompilationEnabled())
  679             dataLog(&quot;Lowering &quot;, m_node, &quot;\n&quot;);
  680 
  681         m_interpreter.startExecuting();
  682         m_interpreter.executeKnownEdgeTypes(m_node);
  683 
  684         if (Options::validateAbstractInterpreterState())
  685             validateAIState(m_node);
  686 
  687         if (validateDFGDoesGC) {
  688             bool expectDoesGC = doesGC(m_graph, m_node);
  689             m_out.store(m_out.constBool(expectDoesGC), m_out.absolute(vm().heap.addressOfExpectDoesGC()));
  690         }
  691 
  692         switch (m_node-&gt;op()) {
  693         case DFG::Upsilon:
  694             compileUpsilon();
  695             break;
  696         case DFG::Phi:
  697             compilePhi();
  698             break;
  699         case JSConstant:
  700             break;
  701         case DoubleConstant:
  702             compileDoubleConstant();
  703             break;
  704         case Int52Constant:
  705             compileInt52Constant();
  706             break;
  707         case LazyJSConstant:
  708             compileLazyJSConstant();
  709             break;
  710         case DoubleRep:
  711             compileDoubleRep();
  712             break;
  713         case DoubleAsInt32:
  714             compileDoubleAsInt32();
  715             break;
  716         case DFG::ValueRep:
  717             compileValueRep();
  718             break;
  719         case Int52Rep:
  720             compileInt52Rep();
  721             break;
  722         case ValueToInt32:
  723             compileValueToInt32();
  724             break;
  725         case BooleanToNumber:
  726             compileBooleanToNumber();
  727             break;
  728         case ExtractOSREntryLocal:
  729             compileExtractOSREntryLocal();
  730             break;
  731         case ExtractCatchLocal:
  732             compileExtractCatchLocal();
  733             break;
  734         case ClearCatchLocals:
  735             compileClearCatchLocals();
  736             break;
  737         case GetStack:
  738             compileGetStack();
  739             break;
  740         case PutStack:
  741             compilePutStack();
  742             break;
  743         case DFG::Check:
  744         case CheckVarargs:
  745             compileNoOp();
  746             break;
  747         case ToObject:
  748         case CallObjectConstructor:
  749             compileToObjectOrCallObjectConstructor();
  750             break;
  751         case ToThis:
  752             compileToThis();
  753             break;
<a name="24" id="anc24"></a><span class="line-added">  754         case Inc:</span>
<span class="line-added">  755         case Dec:</span>
<span class="line-added">  756             compileIncOrDec();</span>
<span class="line-added">  757             break;</span>
  758         case ValueNegate:
  759             compileValueNegate();
  760             break;
  761         case ValueAdd:
  762             compileValueAdd();
  763             break;
  764         case ValueSub:
  765             compileValueSub();
  766             break;
  767         case ValueMul:
  768             compileValueMul();
  769             break;
  770         case StrCat:
  771             compileStrCat();
  772             break;
  773         case ArithAdd:
  774         case ArithSub:
  775             compileArithAddOrSub();
  776             break;
  777         case ArithClz32:
  778             compileArithClz32();
  779             break;
  780         case ArithMul:
  781             compileArithMul();
  782             break;
  783         case ValueDiv:
  784             compileValueDiv();
  785             break;
  786         case ArithDiv:
  787             compileArithDiv();
  788             break;
  789         case ValueMod:
  790             compileValueMod();
  791             break;
  792         case ArithMod:
  793             compileArithMod();
  794             break;
  795         case ArithMin:
  796         case ArithMax:
  797             compileArithMinOrMax();
  798             break;
  799         case ArithAbs:
  800             compileArithAbs();
  801             break;
  802         case ValuePow:
  803             compileValuePow();
  804             break;
  805         case ArithPow:
  806             compileArithPow();
  807             break;
  808         case ArithRandom:
  809             compileArithRandom();
  810             break;
  811         case ArithRound:
  812             compileArithRound();
  813             break;
  814         case ArithFloor:
  815             compileArithFloor();
  816             break;
  817         case ArithCeil:
  818             compileArithCeil();
  819             break;
  820         case ArithTrunc:
  821             compileArithTrunc();
  822             break;
  823         case ArithSqrt:
  824             compileArithSqrt();
  825             break;
  826         case ArithFRound:
  827             compileArithFRound();
  828             break;
  829         case ArithNegate:
  830             compileArithNegate();
  831             break;
  832         case ArithUnary:
  833             compileArithUnary();
  834             break;
  835         case ValueBitNot:
  836             compileValueBitNot();
  837             break;
  838         case ArithBitNot:
  839             compileArithBitNot();
  840             break;
  841         case ValueBitAnd:
  842             compileValueBitAnd();
  843             break;
  844         case ArithBitAnd:
  845             compileArithBitAnd();
  846             break;
  847         case ValueBitOr:
  848             compileValueBitOr();
  849             break;
  850         case ArithBitOr:
  851             compileArithBitOr();
  852             break;
  853         case ArithBitXor:
  854             compileArithBitXor();
  855             break;
  856         case ValueBitXor:
  857             compileValueBitXor();
  858             break;
<a name="25" id="anc25"></a><span class="line-modified">  859         case ValueBitRShift:</span>
<span class="line-modified">  860             compileValueBitRShift();</span>
<span class="line-added">  861             break;</span>
<span class="line-added">  862         case ArithBitRShift:</span>
<span class="line-added">  863             compileArithBitRShift();</span>
  864             break;
  865         case ArithBitLShift:
  866             compileArithBitLShift();
  867             break;
  868         case ValueBitLShift:
  869             compileValueBitLShift();
  870             break;
  871         case BitURShift:
  872             compileBitURShift();
  873             break;
  874         case UInt32ToNumber:
  875             compileUInt32ToNumber();
  876             break;
  877         case CheckStructure:
  878             compileCheckStructure();
  879             break;
  880         case CheckStructureOrEmpty:
  881             compileCheckStructureOrEmpty();
  882             break;
  883         case CheckCell:
  884             compileCheckCell();
  885             break;
  886         case CheckNotEmpty:
  887             compileCheckNotEmpty();
  888             break;
  889         case AssertNotEmpty:
  890             compileAssertNotEmpty();
  891             break;
  892         case CheckBadCell:
  893             compileCheckBadCell();
  894             break;
<a name="26" id="anc26"></a><span class="line-modified">  895         case CheckIdent:</span>
<span class="line-modified">  896             compileCheckIdent();</span>
  897             break;
  898         case GetExecutable:
  899             compileGetExecutable();
  900             break;
  901         case Arrayify:
  902         case ArrayifyToStructure:
  903             compileArrayify();
  904             break;
  905         case PutStructure:
  906             compilePutStructure();
  907             break;
  908         case TryGetById:
<a name="27" id="anc27"></a><span class="line-modified">  909             compileGetById(AccessType::TryGetById);</span>
  910             break;
  911         case GetById:
  912         case GetByIdFlush:
<a name="28" id="anc28"></a><span class="line-modified">  913             compileGetById(AccessType::GetById);</span>
  914             break;
  915         case GetByIdWithThis:
  916             compileGetByIdWithThis();
  917             break;
  918         case GetByIdDirect:
  919         case GetByIdDirectFlush:
<a name="29" id="anc29"></a><span class="line-modified">  920             compileGetById(AccessType::GetByIdDirect);</span>
  921             break;
  922         case InById:
  923             compileInById();
  924             break;
  925         case InByVal:
  926             compileInByVal();
  927             break;
  928         case HasOwnProperty:
  929             compileHasOwnProperty();
  930             break;
  931         case PutById:
  932         case PutByIdDirect:
  933         case PutByIdFlush:
  934             compilePutById();
  935             break;
  936         case PutByIdWithThis:
  937             compilePutByIdWithThis();
  938             break;
  939         case PutGetterById:
  940         case PutSetterById:
  941             compilePutAccessorById();
  942             break;
  943         case PutGetterSetterById:
  944             compilePutGetterSetterById();
  945             break;
  946         case PutGetterByVal:
  947         case PutSetterByVal:
  948             compilePutAccessorByVal();
  949             break;
  950         case DeleteById:
  951             compileDeleteById();
  952             break;
  953         case DeleteByVal:
  954             compileDeleteByVal();
  955             break;
  956         case GetButterfly:
  957             compileGetButterfly();
  958             break;
  959         case ConstantStoragePointer:
  960             compileConstantStoragePointer();
  961             break;
  962         case GetIndexedPropertyStorage:
  963             compileGetIndexedPropertyStorage();
  964             break;
  965         case CheckArray:
  966             compileCheckArray();
  967             break;
<a name="30" id="anc30"></a><span class="line-added">  968         case CheckArrayOrEmpty:</span>
<span class="line-added">  969             compileCheckArrayOrEmpty();</span>
<span class="line-added">  970             break;</span>
<span class="line-added">  971         case CheckNeutered:</span>
<span class="line-added">  972             compileCheckNeutered();</span>
<span class="line-added">  973             break;</span>
  974         case GetArrayLength:
  975             compileGetArrayLength();
  976             break;
  977         case GetVectorLength:
  978             compileGetVectorLength();
  979             break;
  980         case CheckInBounds:
  981             compileCheckInBounds();
  982             break;
  983         case GetByVal:
  984             compileGetByVal();
  985             break;
  986         case GetMyArgumentByVal:
  987         case GetMyArgumentByValOutOfBounds:
  988             compileGetMyArgumentByVal();
  989             break;
  990         case GetByValWithThis:
  991             compileGetByValWithThis();
  992             break;
  993         case PutByVal:
  994         case PutByValAlias:
  995         case PutByValDirect:
  996             compilePutByVal();
  997             break;
  998         case PutByValWithThis:
  999             compilePutByValWithThis();
 1000             break;
 1001         case AtomicsAdd:
 1002         case AtomicsAnd:
 1003         case AtomicsCompareExchange:
 1004         case AtomicsExchange:
 1005         case AtomicsLoad:
 1006         case AtomicsOr:
 1007         case AtomicsStore:
 1008         case AtomicsSub:
 1009         case AtomicsXor:
 1010             compileAtomicsReadModifyWrite();
 1011             break;
 1012         case AtomicsIsLockFree:
 1013             compileAtomicsIsLockFree();
 1014             break;
 1015         case DefineDataProperty:
 1016             compileDefineDataProperty();
 1017             break;
 1018         case DefineAccessorProperty:
 1019             compileDefineAccessorProperty();
 1020             break;
 1021         case ArrayPush:
 1022             compileArrayPush();
 1023             break;
 1024         case ArrayPop:
 1025             compileArrayPop();
 1026             break;
 1027         case ArraySlice:
 1028             compileArraySlice();
 1029             break;
 1030         case ArrayIndexOf:
 1031             compileArrayIndexOf();
 1032             break;
 1033         case CreateActivation:
 1034             compileCreateActivation();
 1035             break;
 1036         case PushWithScope:
 1037             compilePushWithScope();
 1038             break;
 1039         case NewFunction:
 1040         case NewGeneratorFunction:
 1041         case NewAsyncGeneratorFunction:
 1042         case NewAsyncFunction:
 1043             compileNewFunction();
 1044             break;
 1045         case CreateDirectArguments:
 1046             compileCreateDirectArguments();
 1047             break;
 1048         case CreateScopedArguments:
 1049             compileCreateScopedArguments();
 1050             break;
 1051         case CreateClonedArguments:
 1052             compileCreateClonedArguments();
 1053             break;
<a name="31" id="anc31"></a><span class="line-added"> 1054         case CreateArgumentsButterfly:</span>
<span class="line-added"> 1055             compileCreateArgumentsButterfly();</span>
<span class="line-added"> 1056             break;</span>
 1057         case ObjectCreate:
 1058             compileObjectCreate();
 1059             break;
 1060         case ObjectKeys:
 1061             compileObjectKeys();
 1062             break;
 1063         case NewObject:
 1064             compileNewObject();
 1065             break;
<a name="32" id="anc32"></a><span class="line-added"> 1066         case NewPromise:</span>
<span class="line-added"> 1067             compileNewPromise();</span>
<span class="line-added"> 1068             break;</span>
<span class="line-added"> 1069         case NewGenerator:</span>
<span class="line-added"> 1070             compileNewGenerator();</span>
<span class="line-added"> 1071             break;</span>
<span class="line-added"> 1072         case NewAsyncGenerator:</span>
<span class="line-added"> 1073             compileNewAsyncGenerator();</span>
<span class="line-added"> 1074             break;</span>
<span class="line-added"> 1075         case NewArrayIterator:</span>
<span class="line-added"> 1076             compileNewArrayIterator();</span>
<span class="line-added"> 1077             break;</span>
 1078         case NewStringObject:
 1079             compileNewStringObject();
 1080             break;
 1081         case NewSymbol:
 1082             compileNewSymbol();
 1083             break;
 1084         case NewArray:
 1085             compileNewArray();
 1086             break;
 1087         case NewArrayWithSpread:
 1088             compileNewArrayWithSpread();
 1089             break;
 1090         case CreateThis:
 1091             compileCreateThis();
 1092             break;
<a name="33" id="anc33"></a><span class="line-added"> 1093         case CreatePromise:</span>
<span class="line-added"> 1094             compileCreatePromise();</span>
<span class="line-added"> 1095             break;</span>
<span class="line-added"> 1096         case CreateGenerator:</span>
<span class="line-added"> 1097             compileCreateGenerator();</span>
<span class="line-added"> 1098             break;</span>
<span class="line-added"> 1099         case CreateAsyncGenerator:</span>
<span class="line-added"> 1100             compileCreateAsyncGenerator();</span>
<span class="line-added"> 1101             break;</span>
 1102         case Spread:
 1103             compileSpread();
 1104             break;
 1105         case NewArrayBuffer:
 1106             compileNewArrayBuffer();
 1107             break;
 1108         case NewArrayWithSize:
 1109             compileNewArrayWithSize();
 1110             break;
 1111         case NewTypedArray:
 1112             compileNewTypedArray();
 1113             break;
 1114         case GetTypedArrayByteOffset:
 1115             compileGetTypedArrayByteOffset();
 1116             break;
 1117         case GetPrototypeOf:
 1118             compileGetPrototypeOf();
 1119             break;
 1120         case AllocatePropertyStorage:
 1121             compileAllocatePropertyStorage();
 1122             break;
 1123         case ReallocatePropertyStorage:
 1124             compileReallocatePropertyStorage();
 1125             break;
 1126         case NukeStructureAndSetButterfly:
 1127             compileNukeStructureAndSetButterfly();
 1128             break;
 1129         case ToNumber:
 1130             compileToNumber();
 1131             break;
<a name="34" id="anc34"></a><span class="line-added"> 1132         case ToNumeric:</span>
<span class="line-added"> 1133             compileToNumeric();</span>
<span class="line-added"> 1134             break;</span>
 1135         case ToString:
 1136         case CallStringConstructor:
 1137         case StringValueOf:
 1138             compileToStringOrCallStringConstructorOrStringValueOf();
 1139             break;
 1140         case ToPrimitive:
 1141             compileToPrimitive();
 1142             break;
<a name="35" id="anc35"></a><span class="line-added"> 1143         case ToPropertyKey:</span>
<span class="line-added"> 1144             compileToPropertyKey();</span>
<span class="line-added"> 1145             break;</span>
 1146         case MakeRope:
 1147             compileMakeRope();
 1148             break;
 1149         case StringCharAt:
 1150             compileStringCharAt();
 1151             break;
 1152         case StringCharCodeAt:
 1153             compileStringCharCodeAt();
 1154             break;
<a name="36" id="anc36"></a><span class="line-added"> 1155         case StringCodePointAt:</span>
<span class="line-added"> 1156             compileStringCodePointAt();</span>
<span class="line-added"> 1157             break;</span>
 1158         case StringFromCharCode:
 1159             compileStringFromCharCode();
 1160             break;
 1161         case GetByOffset:
 1162         case GetGetterSetterByOffset:
 1163             compileGetByOffset();
 1164             break;
 1165         case GetGetter:
 1166             compileGetGetter();
 1167             break;
 1168         case GetSetter:
 1169             compileGetSetter();
 1170             break;
 1171         case MultiGetByOffset:
 1172             compileMultiGetByOffset();
 1173             break;
 1174         case PutByOffset:
 1175             compilePutByOffset();
 1176             break;
 1177         case MultiPutByOffset:
 1178             compileMultiPutByOffset();
 1179             break;
 1180         case MatchStructure:
 1181             compileMatchStructure();
 1182             break;
 1183         case GetGlobalVar:
 1184         case GetGlobalLexicalVariable:
 1185             compileGetGlobalVariable();
 1186             break;
 1187         case PutGlobalVariable:
 1188             compilePutGlobalVariable();
 1189             break;
 1190         case NotifyWrite:
 1191             compileNotifyWrite();
 1192             break;
 1193         case GetCallee:
 1194             compileGetCallee();
 1195             break;
 1196         case SetCallee:
 1197             compileSetCallee();
 1198             break;
 1199         case GetArgumentCountIncludingThis:
 1200             compileGetArgumentCountIncludingThis();
 1201             break;
 1202         case SetArgumentCountIncludingThis:
 1203             compileSetArgumentCountIncludingThis();
 1204             break;
 1205         case GetScope:
 1206             compileGetScope();
 1207             break;
 1208         case SkipScope:
 1209             compileSkipScope();
 1210             break;
 1211         case GetGlobalObject:
 1212             compileGetGlobalObject();
 1213             break;
 1214         case GetGlobalThis:
 1215             compileGetGlobalThis();
 1216             break;
 1217         case GetClosureVar:
 1218             compileGetClosureVar();
 1219             break;
 1220         case PutClosureVar:
 1221             compilePutClosureVar();
 1222             break;
<a name="37" id="anc37"></a><span class="line-added"> 1223         case GetInternalField:</span>
<span class="line-added"> 1224             compileGetInternalField();</span>
<span class="line-added"> 1225             break;</span>
<span class="line-added"> 1226         case PutInternalField:</span>
<span class="line-added"> 1227             compilePutInternalField();</span>
<span class="line-added"> 1228             break;</span>
 1229         case GetFromArguments:
 1230             compileGetFromArguments();
 1231             break;
 1232         case PutToArguments:
 1233             compilePutToArguments();
 1234             break;
 1235         case GetArgument:
 1236             compileGetArgument();
 1237             break;
 1238         case CompareEq:
 1239             compileCompareEq();
 1240             break;
 1241         case CompareStrictEq:
 1242             compileCompareStrictEq();
 1243             break;
 1244         case CompareLess:
 1245             compileCompareLess();
 1246             break;
 1247         case CompareLessEq:
 1248             compileCompareLessEq();
 1249             break;
 1250         case CompareGreater:
 1251             compileCompareGreater();
 1252             break;
 1253         case CompareGreaterEq:
 1254             compileCompareGreaterEq();
 1255             break;
 1256         case CompareBelow:
 1257             compileCompareBelow();
 1258             break;
 1259         case CompareBelowEq:
 1260             compileCompareBelowEq();
 1261             break;
 1262         case CompareEqPtr:
 1263             compileCompareEqPtr();
 1264             break;
 1265         case SameValue:
 1266             compileSameValue();
 1267             break;
 1268         case LogicalNot:
 1269             compileLogicalNot();
 1270             break;
 1271         case Call:
 1272         case TailCallInlinedCaller:
 1273         case Construct:
 1274             compileCallOrConstruct();
 1275             break;
 1276         case DirectCall:
 1277         case DirectTailCallInlinedCaller:
 1278         case DirectConstruct:
 1279         case DirectTailCall:
 1280             compileDirectCallOrConstruct();
 1281             break;
 1282         case TailCall:
 1283             compileTailCall();
 1284             break;
 1285         case CallVarargs:
 1286         case CallForwardVarargs:
 1287         case TailCallVarargs:
 1288         case TailCallVarargsInlinedCaller:
 1289         case TailCallForwardVarargs:
 1290         case TailCallForwardVarargsInlinedCaller:
 1291         case ConstructVarargs:
 1292         case ConstructForwardVarargs:
 1293             compileCallOrConstructVarargs();
 1294             break;
 1295         case CallEval:
 1296             compileCallEval();
 1297             break;
<a name="38" id="anc38"></a><span class="line-added"> 1298         case VarargsLength:</span>
<span class="line-added"> 1299             compileVarargsLength();</span>
<span class="line-added"> 1300             break;</span>
 1301         case LoadVarargs:
 1302             compileLoadVarargs();
 1303             break;
 1304         case ForwardVarargs:
 1305             compileForwardVarargs();
 1306             break;
 1307         case DFG::Jump:
 1308             compileJump();
 1309             break;
 1310         case DFG::Branch:
 1311             compileBranch();
 1312             break;
 1313         case DFG::Switch:
 1314             compileSwitch();
 1315             break;
 1316         case DFG::EntrySwitch:
 1317             compileEntrySwitch();
 1318             break;
 1319         case DFG::Return:
 1320             compileReturn();
 1321             break;
 1322         case ForceOSRExit:
 1323             compileForceOSRExit();
 1324             break;
 1325         case CPUIntrinsic:
 1326 #if CPU(X86_64)
 1327             compileCPUIntrinsic();
 1328 #else
 1329             RELEASE_ASSERT_NOT_REACHED();
 1330 #endif
 1331             break;
 1332         case Throw:
 1333             compileThrow();
 1334             break;
 1335         case ThrowStaticError:
 1336             compileThrowStaticError();
 1337             break;
 1338         case InvalidationPoint:
 1339             compileInvalidationPoint();
 1340             break;
 1341         case IsEmpty:
 1342             compileIsEmpty();
 1343             break;
 1344         case IsUndefined:
 1345             compileIsUndefined();
 1346             break;
 1347         case IsUndefinedOrNull:
 1348             compileIsUndefinedOrNull();
 1349             break;
 1350         case IsBoolean:
 1351             compileIsBoolean();
 1352             break;
 1353         case IsNumber:
 1354             compileIsNumber();
 1355             break;
 1356         case NumberIsInteger:
 1357             compileNumberIsInteger();
 1358             break;
 1359         case IsCellWithType:
 1360             compileIsCellWithType();
 1361             break;
 1362         case MapHash:
 1363             compileMapHash();
 1364             break;
 1365         case NormalizeMapKey:
 1366             compileNormalizeMapKey();
 1367             break;
 1368         case GetMapBucket:
 1369             compileGetMapBucket();
 1370             break;
 1371         case GetMapBucketHead:
 1372             compileGetMapBucketHead();
 1373             break;
 1374         case GetMapBucketNext:
 1375             compileGetMapBucketNext();
 1376             break;
 1377         case LoadKeyFromMapBucket:
 1378             compileLoadKeyFromMapBucket();
 1379             break;
 1380         case LoadValueFromMapBucket:
 1381             compileLoadValueFromMapBucket();
 1382             break;
 1383         case ExtractValueFromWeakMapGet:
 1384             compileExtractValueFromWeakMapGet();
 1385             break;
 1386         case SetAdd:
 1387             compileSetAdd();
 1388             break;
 1389         case MapSet:
 1390             compileMapSet();
 1391             break;
 1392         case WeakMapGet:
 1393             compileWeakMapGet();
 1394             break;
 1395         case WeakSetAdd:
 1396             compileWeakSetAdd();
 1397             break;
 1398         case WeakMapSet:
 1399             compileWeakMapSet();
 1400             break;
 1401         case IsObject:
 1402             compileIsObject();
 1403             break;
 1404         case IsObjectOrNull:
 1405             compileIsObjectOrNull();
 1406             break;
 1407         case IsFunction:
 1408             compileIsFunction();
 1409             break;
 1410         case IsTypedArrayView:
 1411             compileIsTypedArrayView();
 1412             break;
 1413         case ParseInt:
 1414             compileParseInt();
 1415             break;
 1416         case TypeOf:
 1417             compileTypeOf();
 1418             break;
 1419         case CheckTypeInfoFlags:
 1420             compileCheckTypeInfoFlags();
 1421             break;
 1422         case OverridesHasInstance:
 1423             compileOverridesHasInstance();
 1424             break;
 1425         case InstanceOf:
 1426             compileInstanceOf();
 1427             break;
 1428         case InstanceOfCustom:
 1429             compileInstanceOfCustom();
 1430             break;
 1431         case CountExecution:
 1432             compileCountExecution();
 1433             break;
 1434         case SuperSamplerBegin:
 1435             compileSuperSamplerBegin();
 1436             break;
 1437         case SuperSamplerEnd:
 1438             compileSuperSamplerEnd();
 1439             break;
 1440         case StoreBarrier:
 1441         case FencedStoreBarrier:
 1442             compileStoreBarrier();
 1443             break;
 1444         case HasIndexedProperty:
 1445             compileHasIndexedProperty();
 1446             break;
 1447         case HasGenericProperty:
 1448             compileHasGenericProperty();
 1449             break;
 1450         case HasStructureProperty:
 1451             compileHasStructureProperty();
 1452             break;
 1453         case GetDirectPname:
 1454             compileGetDirectPname();
 1455             break;
 1456         case GetEnumerableLength:
 1457             compileGetEnumerableLength();
 1458             break;
 1459         case GetPropertyEnumerator:
 1460             compileGetPropertyEnumerator();
 1461             break;
 1462         case GetEnumeratorStructurePname:
 1463             compileGetEnumeratorStructurePname();
 1464             break;
 1465         case GetEnumeratorGenericPname:
 1466             compileGetEnumeratorGenericPname();
 1467             break;
 1468         case ToIndexString:
 1469             compileToIndexString();
 1470             break;
 1471         case CheckStructureImmediate:
 1472             compileCheckStructureImmediate();
 1473             break;
 1474         case MaterializeNewObject:
 1475             compileMaterializeNewObject();
 1476             break;
 1477         case MaterializeCreateActivation:
 1478             compileMaterializeCreateActivation();
 1479             break;
<a name="39" id="anc39"></a><span class="line-added"> 1480         case MaterializeNewInternalFieldObject:</span>
<span class="line-added"> 1481             compileMaterializeNewInternalFieldObject();</span>
<span class="line-added"> 1482             break;</span>
 1483         case CheckTraps:
 1484             compileCheckTraps();
 1485             break;
 1486         case CreateRest:
 1487             compileCreateRest();
 1488             break;
 1489         case GetRestLength:
 1490             compileGetRestLength();
 1491             break;
 1492         case RegExpExec:
 1493             compileRegExpExec();
 1494             break;
 1495         case RegExpExecNonGlobalOrSticky:
 1496             compileRegExpExecNonGlobalOrSticky();
 1497             break;
 1498         case RegExpTest:
 1499             compileRegExpTest();
 1500             break;
 1501         case RegExpMatchFast:
 1502             compileRegExpMatchFast();
 1503             break;
 1504         case RegExpMatchFastGlobal:
 1505             compileRegExpMatchFastGlobal();
 1506             break;
 1507         case NewRegexp:
 1508             compileNewRegexp();
 1509             break;
 1510         case SetFunctionName:
 1511             compileSetFunctionName();
 1512             break;
 1513         case StringReplace:
 1514         case StringReplaceRegExp:
 1515             compileStringReplace();
 1516             break;
 1517         case GetRegExpObjectLastIndex:
 1518             compileGetRegExpObjectLastIndex();
 1519             break;
 1520         case SetRegExpObjectLastIndex:
 1521             compileSetRegExpObjectLastIndex();
 1522             break;
 1523         case LogShadowChickenPrologue:
 1524             compileLogShadowChickenPrologue();
 1525             break;
 1526         case LogShadowChickenTail:
 1527             compileLogShadowChickenTail();
 1528             break;
 1529         case RecordRegExpCachedResult:
 1530             compileRecordRegExpCachedResult();
 1531             break;
 1532         case ResolveScopeForHoistingFuncDeclInEval:
 1533             compileResolveScopeForHoistingFuncDeclInEval();
 1534             break;
 1535         case ResolveScope:
 1536             compileResolveScope();
 1537             break;
 1538         case GetDynamicVar:
 1539             compileGetDynamicVar();
 1540             break;
 1541         case PutDynamicVar:
 1542             compilePutDynamicVar();
 1543             break;
 1544         case Unreachable:
 1545             compileUnreachable();
 1546             break;
 1547         case StringSlice:
 1548             compileStringSlice();
 1549             break;
 1550         case ToLowerCase:
 1551             compileToLowerCase();
 1552             break;
 1553         case NumberToStringWithRadix:
 1554             compileNumberToStringWithRadix();
 1555             break;
 1556         case NumberToStringWithValidRadixConstant:
 1557             compileNumberToStringWithValidRadixConstant();
 1558             break;
 1559         case CheckSubClass:
 1560             compileCheckSubClass();
 1561             break;
 1562         case CallDOM:
 1563             compileCallDOM();
 1564             break;
 1565         case CallDOMGetter:
 1566             compileCallDOMGetter();
 1567             break;
 1568         case FilterCallLinkStatus:
<a name="40" id="anc40"></a><span class="line-modified"> 1569         case FilterGetByStatus:</span>
 1570         case FilterPutByIdStatus:
 1571         case FilterInByIdStatus:
 1572             compileFilterICStatus();
 1573             break;
<a name="41" id="anc41"></a><span class="line-added"> 1574         case DateGetInt32OrNaN:</span>
<span class="line-added"> 1575         case DateGetTime:</span>
<span class="line-added"> 1576             compileDateGet();</span>
<span class="line-added"> 1577             break;</span>
 1578         case DataViewGetInt:
 1579         case DataViewGetFloat:
 1580             compileDataViewGet();
 1581             break;
 1582         case DataViewSet:
 1583             compileDataViewSet();
 1584             break;
 1585 
 1586         case PhantomLocal:
 1587         case LoopHint:
 1588         case MovHint:
 1589         case ZombieHint:
 1590         case ExitOK:
 1591         case PhantomNewObject:
 1592         case PhantomNewFunction:
 1593         case PhantomNewGeneratorFunction:
 1594         case PhantomNewAsyncGeneratorFunction:
 1595         case PhantomNewAsyncFunction:
<a name="42" id="anc42"></a><span class="line-added"> 1596         case PhantomNewArrayIterator:</span>
 1597         case PhantomCreateActivation:
 1598         case PhantomDirectArguments:
 1599         case PhantomCreateRest:
 1600         case PhantomSpread:
 1601         case PhantomNewArrayWithSpread:
 1602         case PhantomNewArrayBuffer:
 1603         case PhantomClonedArguments:
 1604         case PhantomNewRegexp:
 1605         case PutHint:
 1606         case BottomValue:
 1607         case KillStack:
 1608         case InitializeEntrypointArguments:
 1609             break;
 1610         default:
 1611             DFG_CRASH(m_graph, m_node, &quot;Unrecognized node in FTL backend&quot;);
 1612             break;
 1613         }
 1614 
 1615         if (m_node-&gt;isTerminal())
 1616             return false;
 1617 
 1618         if (!m_state.isValid()) {
 1619             safelyInvalidateAfterTermination();
 1620             return false;
 1621         }
 1622 
 1623         m_availabilityCalculator.executeNode(m_node);
 1624         m_interpreter.executeEffects(nodeIndex);
 1625 
 1626         return true;
 1627     }
 1628 
 1629     void compileUpsilon()
 1630     {
 1631         LValue upsilonValue = nullptr;
 1632         switch (m_node-&gt;child1().useKind()) {
 1633         case DoubleRepUse:
 1634             upsilonValue = lowDouble(m_node-&gt;child1());
 1635             break;
 1636         case Int32Use:
 1637         case KnownInt32Use:
 1638             upsilonValue = lowInt32(m_node-&gt;child1());
 1639             break;
 1640         case Int52RepUse:
 1641             upsilonValue = lowInt52(m_node-&gt;child1());
 1642             break;
 1643         case BooleanUse:
 1644         case KnownBooleanUse:
 1645             upsilonValue = lowBoolean(m_node-&gt;child1());
 1646             break;
 1647         case CellUse:
 1648         case KnownCellUse:
 1649             upsilonValue = lowCell(m_node-&gt;child1());
 1650             break;
 1651         case UntypedUse:
 1652             upsilonValue = lowJSValue(m_node-&gt;child1());
 1653             break;
 1654         default:
 1655             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1656             break;
 1657         }
 1658         ValueFromBlock upsilon = m_out.anchor(upsilonValue);
 1659         LValue phiNode = m_phis.get(m_node-&gt;phi());
 1660         m_out.addIncomingToPhi(phiNode, upsilon);
 1661     }
 1662 
 1663     void compilePhi()
 1664     {
 1665         LValue phi = m_phis.get(m_node);
 1666         m_out.m_block-&gt;append(phi);
 1667 
 1668         switch (m_node-&gt;flags() &amp; NodeResultMask) {
 1669         case NodeResultDouble:
 1670             setDouble(phi);
 1671             break;
 1672         case NodeResultInt32:
 1673             setInt32(phi);
 1674             break;
 1675         case NodeResultInt52:
 1676             setInt52(phi);
 1677             break;
 1678         case NodeResultBoolean:
 1679             setBoolean(phi);
 1680             break;
 1681         case NodeResultJS:
 1682             setJSValue(phi);
 1683             break;
 1684         default:
 1685             DFG_CRASH(m_graph, m_node, &quot;Bad result type&quot;);
 1686             break;
 1687         }
 1688     }
 1689 
 1690     void compileDoubleConstant()
 1691     {
 1692         setDouble(m_out.constDouble(m_node-&gt;asNumber()));
 1693     }
 1694 
 1695     void compileInt52Constant()
 1696     {
 1697         int64_t value = m_node-&gt;asAnyInt();
 1698 
 1699         setInt52(m_out.constInt64(value &lt;&lt; JSValue::int52ShiftAmount));
 1700         setStrictInt52(m_out.constInt64(value));
 1701     }
 1702 
 1703     void compileLazyJSConstant()
 1704     {
 1705         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 1706         LazyJSValue value = m_node-&gt;lazyJSValue();
 1707         patchpoint-&gt;setGenerator(
 1708             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 1709                 value.emit(jit, JSValueRegs(params[0].gpr()));
 1710             });
 1711         patchpoint-&gt;effects = Effects::none();
 1712         setJSValue(patchpoint);
 1713     }
 1714 
 1715     void compileDoubleRep()
 1716     {
 1717         switch (m_node-&gt;child1().useKind()) {
 1718         case RealNumberUse: {
 1719             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1720 
 1721             LValue doubleValue = unboxDouble(value);
 1722 
 1723             LBasicBlock intCase = m_out.newBlock();
 1724             LBasicBlock continuation = m_out.newBlock();
 1725 
 1726             ValueFromBlock fastResult = m_out.anchor(doubleValue);
 1727             m_out.branch(
 1728                 m_out.doubleEqual(doubleValue, doubleValue),
 1729                 usually(continuation), rarely(intCase));
 1730 
 1731             LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
 1732 
 1733             FTL_TYPE_CHECK(
 1734                 jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
 1735                 isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecDoubleReal));
 1736             ValueFromBlock slowResult = m_out.anchor(m_out.intToDouble(unboxInt32(value)));
 1737             m_out.jump(continuation);
 1738 
 1739             m_out.appendTo(continuation, lastNext);
 1740 
 1741             setDouble(m_out.phi(Double, fastResult, slowResult));
 1742             return;
 1743         }
 1744 
 1745         case NotCellUse:
 1746         case NumberUse: {
 1747             bool shouldConvertNonNumber = m_node-&gt;child1().useKind() == NotCellUse;
 1748 
 1749             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 1750 
 1751             LBasicBlock intCase = m_out.newBlock();
 1752             LBasicBlock doubleTesting = m_out.newBlock();
 1753             LBasicBlock doubleCase = m_out.newBlock();
 1754             LBasicBlock nonDoubleCase = m_out.newBlock();
 1755             LBasicBlock continuation = m_out.newBlock();
 1756 
 1757             m_out.branch(
 1758                 isNotInt32(value, provenType(m_node-&gt;child1())),
 1759                 unsure(doubleTesting), unsure(intCase));
 1760 
 1761             LBasicBlock lastNext = m_out.appendTo(intCase, doubleTesting);
 1762 
 1763             ValueFromBlock intToDouble = m_out.anchor(
 1764                 m_out.intToDouble(unboxInt32(value)));
 1765             m_out.jump(continuation);
 1766 
 1767             m_out.appendTo(doubleTesting, doubleCase);
 1768             LValue valueIsNumber = isNumber(value, provenType(m_node-&gt;child1()));
 1769             m_out.branch(valueIsNumber, usually(doubleCase), rarely(nonDoubleCase));
 1770 
 1771             m_out.appendTo(doubleCase, nonDoubleCase);
 1772             ValueFromBlock unboxedDouble = m_out.anchor(unboxDouble(value));
 1773             m_out.jump(continuation);
 1774 
 1775             if (shouldConvertNonNumber) {
 1776                 LBasicBlock undefinedCase = m_out.newBlock();
 1777                 LBasicBlock testNullCase = m_out.newBlock();
 1778                 LBasicBlock nullCase = m_out.newBlock();
 1779                 LBasicBlock testBooleanTrueCase = m_out.newBlock();
 1780                 LBasicBlock convertBooleanTrueCase = m_out.newBlock();
 1781                 LBasicBlock convertBooleanFalseCase = m_out.newBlock();
 1782 
 1783                 m_out.appendTo(nonDoubleCase, undefinedCase);
<a name="43" id="anc43"></a><span class="line-modified"> 1784                 LValue valueIsUndefined = m_out.equal(value, m_out.constInt64(JSValue::ValueUndefined));</span>
 1785                 m_out.branch(valueIsUndefined, unsure(undefinedCase), unsure(testNullCase));
 1786 
 1787                 m_out.appendTo(undefinedCase, testNullCase);
 1788                 ValueFromBlock convertedUndefined = m_out.anchor(m_out.constDouble(PNaN));
 1789                 m_out.jump(continuation);
 1790 
 1791                 m_out.appendTo(testNullCase, nullCase);
<a name="44" id="anc44"></a><span class="line-modified"> 1792                 LValue valueIsNull = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
 1793                 m_out.branch(valueIsNull, unsure(nullCase), unsure(testBooleanTrueCase));
 1794 
 1795                 m_out.appendTo(nullCase, testBooleanTrueCase);
 1796                 ValueFromBlock convertedNull = m_out.anchor(m_out.constDouble(0));
 1797                 m_out.jump(continuation);
 1798 
 1799                 m_out.appendTo(testBooleanTrueCase, convertBooleanTrueCase);
<a name="45" id="anc45"></a><span class="line-modified"> 1800                 LValue valueIsBooleanTrue = m_out.equal(value, m_out.constInt64(JSValue::ValueTrue));</span>
 1801                 m_out.branch(valueIsBooleanTrue, unsure(convertBooleanTrueCase), unsure(convertBooleanFalseCase));
 1802 
 1803                 m_out.appendTo(convertBooleanTrueCase, convertBooleanFalseCase);
 1804                 ValueFromBlock convertedTrue = m_out.anchor(m_out.constDouble(1));
 1805                 m_out.jump(continuation);
 1806 
 1807                 m_out.appendTo(convertBooleanFalseCase, continuation);
 1808 
<a name="46" id="anc46"></a><span class="line-modified"> 1809                 LValue valueIsNotBooleanFalse = m_out.notEqual(value, m_out.constInt64(JSValue::ValueFalse));</span>
 1810                 FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), ~SpecCellCheck, valueIsNotBooleanFalse);
 1811                 ValueFromBlock convertedFalse = m_out.anchor(m_out.constDouble(0));
 1812                 m_out.jump(continuation);
 1813 
 1814                 m_out.appendTo(continuation, lastNext);
 1815                 setDouble(m_out.phi(Double, intToDouble, unboxedDouble, convertedUndefined, convertedNull, convertedTrue, convertedFalse));
 1816                 return;
 1817             }
 1818             m_out.appendTo(nonDoubleCase, continuation);
 1819             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecBytecodeNumber, m_out.booleanTrue);
 1820             m_out.unreachable();
 1821 
 1822             m_out.appendTo(continuation, lastNext);
 1823 
 1824             setDouble(m_out.phi(Double, intToDouble, unboxedDouble));
 1825             return;
 1826         }
 1827 
 1828         case Int52RepUse: {
 1829             setDouble(strictInt52ToDouble(lowStrictInt52(m_node-&gt;child1())));
 1830             return;
 1831         }
 1832 
 1833         default:
 1834             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1835         }
 1836     }
 1837 
 1838     void compileDoubleAsInt32()
 1839     {
 1840         LValue integerValue = convertDoubleToInt32(lowDouble(m_node-&gt;child1()), shouldCheckNegativeZero(m_node-&gt;arithMode()));
 1841         setInt32(integerValue);
 1842     }
 1843 
 1844     void compileValueRep()
 1845     {
 1846         switch (m_node-&gt;child1().useKind()) {
 1847         case DoubleRepUse: {
 1848             LValue value = lowDouble(m_node-&gt;child1());
 1849 
 1850             if (m_interpreter.needsTypeCheck(m_node-&gt;child1(), ~SpecDoubleImpureNaN)) {
 1851                 value = m_out.select(
 1852                     m_out.doubleEqual(value, value), value, m_out.constDouble(PNaN));
 1853             }
 1854 
 1855             setJSValue(boxDouble(value));
 1856             return;
 1857         }
 1858 
 1859         case Int52RepUse: {
 1860             setJSValue(strictInt52ToJSValue(lowStrictInt52(m_node-&gt;child1())));
 1861             return;
 1862         }
 1863 
 1864         default:
 1865             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1866         }
 1867     }
 1868 
 1869     void compileInt52Rep()
 1870     {
 1871         switch (m_node-&gt;child1().useKind()) {
 1872         case Int32Use:
 1873             setStrictInt52(m_out.signExt32To64(lowInt32(m_node-&gt;child1())));
 1874             return;
 1875 
 1876         case AnyIntUse:
 1877             setStrictInt52(
 1878                 jsValueToStrictInt52(
 1879                     m_node-&gt;child1(), lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1880             return;
 1881 
 1882         case DoubleRepAnyIntUse:
 1883             setStrictInt52(
 1884                 doubleToStrictInt52(
 1885                     m_node-&gt;child1(), lowDouble(m_node-&gt;child1())));
 1886             return;
 1887 
 1888         default:
 1889             RELEASE_ASSERT_NOT_REACHED();
 1890         }
 1891     }
 1892 
 1893     void compileValueToInt32()
 1894     {
 1895         switch (m_node-&gt;child1().useKind()) {
 1896         case Int52RepUse:
 1897             setInt32(m_out.castToInt32(lowStrictInt52(m_node-&gt;child1())));
 1898             break;
 1899 
 1900         case DoubleRepUse:
 1901             setInt32(doubleToInt32(lowDouble(m_node-&gt;child1())));
 1902             break;
 1903 
 1904         case NumberUse:
 1905         case NotCellUse: {
 1906             LoweredNodeValue value = m_int32Values.get(m_node-&gt;child1().node());
 1907             if (isValid(value)) {
 1908                 setInt32(value.value());
 1909                 break;
 1910             }
 1911 
 1912             value = m_jsValueValues.get(m_node-&gt;child1().node());
 1913             if (isValid(value)) {
 1914                 setInt32(numberOrNotCellToInt32(m_node-&gt;child1(), value.value()));
 1915                 break;
 1916             }
 1917 
 1918             // We&#39;ll basically just get here for constants. But it&#39;s good to have this
 1919             // catch-all since we often add new representations into the mix.
 1920             setInt32(
 1921                 numberOrNotCellToInt32(
 1922                     m_node-&gt;child1(),
 1923                     lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation)));
 1924             break;
 1925         }
 1926 
 1927         default:
 1928             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 1929             break;
 1930         }
 1931     }
 1932 
 1933     void compileBooleanToNumber()
 1934     {
 1935         switch (m_node-&gt;child1().useKind()) {
 1936         case BooleanUse: {
 1937             setInt32(m_out.zeroExt(lowBoolean(m_node-&gt;child1()), Int32));
 1938             return;
 1939         }
 1940 
 1941         case UntypedUse: {
 1942             LValue value = lowJSValue(m_node-&gt;child1());
 1943 
 1944             if (!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
 1945                 setInt32(m_out.bitAnd(m_out.castToInt32(value), m_out.int32One));
 1946                 return;
 1947             }
 1948 
 1949             LBasicBlock booleanCase = m_out.newBlock();
 1950             LBasicBlock continuation = m_out.newBlock();
 1951 
 1952             ValueFromBlock notBooleanResult = m_out.anchor(value);
 1953             m_out.branch(
 1954                 isBoolean(value, provenType(m_node-&gt;child1())),
 1955                 unsure(booleanCase), unsure(continuation));
 1956 
 1957             LBasicBlock lastNext = m_out.appendTo(booleanCase, continuation);
 1958             ValueFromBlock booleanResult = m_out.anchor(m_out.bitOr(
<a name="47" id="anc47"></a><span class="line-modified"> 1959                 m_out.zeroExt(unboxBoolean(value), Int64), m_numberTag));</span>
 1960             m_out.jump(continuation);
 1961 
 1962             m_out.appendTo(continuation, lastNext);
 1963             setJSValue(m_out.phi(Int64, booleanResult, notBooleanResult));
 1964             return;
 1965         }
 1966 
 1967         default:
 1968             RELEASE_ASSERT_NOT_REACHED();
 1969             return;
 1970         }
 1971     }
 1972 
 1973     void compileExtractOSREntryLocal()
 1974     {
 1975         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(
 1976             m_ftlState.jitCode-&gt;ftlForOSREntry()-&gt;entryBuffer()-&gt;dataBuffer());
<a name="48" id="anc48"></a><span class="line-modified"> 1977         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;unlinkedOperand().virtualRegister().toLocal())));</span>
 1978     }
 1979 
 1980     void compileExtractCatchLocal()
 1981     {
 1982         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(m_ftlState.jitCode-&gt;common.catchOSREntryBuffer-&gt;dataBuffer());
 1983         setJSValue(m_out.load64(m_out.absolute(buffer + m_node-&gt;catchOSREntryIndex())));
 1984     }
 1985 
 1986     void compileClearCatchLocals()
 1987     {
 1988         ScratchBuffer* scratchBuffer = m_ftlState.jitCode-&gt;common.catchOSREntryBuffer;
 1989         ASSERT(scratchBuffer);
 1990         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 1991     }
 1992 
 1993     void compileGetStack()
 1994     {
 1995         StackAccessData* data = m_node-&gt;stackAccessData();
<a name="49" id="anc49"></a><span class="line-modified"> 1996         AbstractValue&amp; value = m_state.operand(data-&gt;operand);</span>
 1997 
 1998         DFG_ASSERT(m_graph, m_node, isConcrete(data-&gt;format), data-&gt;format);
 1999 
 2000         switch (data-&gt;format) {
 2001         case FlushedDouble:
 2002             setDouble(m_out.loadDouble(addressFor(data-&gt;machineLocal)));
 2003             break;
 2004         case FlushedInt52:
 2005             setInt52(m_out.load64(addressFor(data-&gt;machineLocal)));
 2006             break;
 2007         default:
 2008             if (isInt32Speculation(value.m_type))
 2009                 setInt32(m_out.load32(payloadFor(data-&gt;machineLocal)));
 2010             else
 2011                 setJSValue(m_out.load64(addressFor(data-&gt;machineLocal)));
 2012             break;
 2013         }
 2014     }
 2015 
 2016     void compilePutStack()
 2017     {
 2018         StackAccessData* data = m_node-&gt;stackAccessData();
 2019         switch (data-&gt;format) {
 2020         case FlushedJSValue: {
 2021             LValue value = lowJSValue(m_node-&gt;child1());
 2022             m_out.store64(value, addressFor(data-&gt;machineLocal));
 2023             break;
 2024         }
 2025 
 2026         case FlushedDouble: {
 2027             LValue value = lowDouble(m_node-&gt;child1());
 2028             m_out.storeDouble(value, addressFor(data-&gt;machineLocal));
 2029             break;
 2030         }
 2031 
 2032         case FlushedInt32: {
 2033             LValue value = lowInt32(m_node-&gt;child1());
 2034             m_out.store32(value, payloadFor(data-&gt;machineLocal));
 2035             break;
 2036         }
 2037 
 2038         case FlushedInt52: {
 2039             LValue value = lowInt52(m_node-&gt;child1());
 2040             m_out.store64(value, addressFor(data-&gt;machineLocal));
 2041             break;
 2042         }
 2043 
 2044         case FlushedCell: {
 2045             LValue value = lowCell(m_node-&gt;child1());
 2046             m_out.store64(value, addressFor(data-&gt;machineLocal));
 2047             break;
 2048         }
 2049 
 2050         case FlushedBoolean: {
 2051             speculateBoolean(m_node-&gt;child1());
 2052             m_out.store64(
 2053                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2054                 addressFor(data-&gt;machineLocal));
 2055             break;
 2056         }
 2057 
 2058         default:
 2059             DFG_CRASH(m_graph, m_node, &quot;Bad flush format&quot;);
 2060             break;
 2061         }
 2062     }
 2063 
 2064     void compileNoOp()
 2065     {
 2066         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, speculate);
 2067     }
 2068 
 2069     void compileToObjectOrCallObjectConstructor()
 2070     {
 2071         LValue value = lowJSValue(m_node-&gt;child1());
 2072 
 2073         LBasicBlock isCellCase = m_out.newBlock();
 2074         LBasicBlock slowCase = m_out.newBlock();
 2075         LBasicBlock continuation = m_out.newBlock();
 2076 
 2077         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 2078 
 2079         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 2080         ValueFromBlock fastResult = m_out.anchor(value);
 2081         m_out.branch(isObject(value), usually(continuation), rarely(slowCase));
 2082 
 2083         m_out.appendTo(slowCase, continuation);
 2084 
 2085         ValueFromBlock slowResult;
 2086         if (m_node-&gt;op() == ToObject) {
<a name="50" id="anc50"></a><span class="line-added"> 2087             UniquedStringImpl* errorMessage = nullptr;</span>
<span class="line-added"> 2088             if (m_node-&gt;identifierNumber() != UINT32_MAX)</span>
<span class="line-added"> 2089                 errorMessage = m_graph.identifiers()[m_node-&gt;identifierNumber()];</span>
 2090             auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<a name="51" id="anc51"></a><span class="line-modified"> 2091             slowResult = m_out.anchor(vmCall(Int64, operationToObject, weakPointer(globalObject), value, m_out.constIntPtr(errorMessage)));</span>
 2092         } else
<a name="52" id="anc52"></a><span class="line-modified"> 2093             slowResult = m_out.anchor(vmCall(Int64, operationCallObjectConstructor, frozenPointer(m_node-&gt;cellOperand()), value));</span>
 2094         m_out.jump(continuation);
 2095 
 2096         m_out.appendTo(continuation, lastNext);
 2097         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 2098     }
 2099 
 2100     void compileToThis()
 2101     {
<a name="53" id="anc53"></a><span class="line-added"> 2102         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 2103 </span>
 2104         LValue value = lowJSValue(m_node-&gt;child1());
 2105 
 2106         LBasicBlock isCellCase = m_out.newBlock();
 2107         LBasicBlock slowCase = m_out.newBlock();
 2108         LBasicBlock continuation = m_out.newBlock();
 2109 
 2110         m_out.branch(
 2111             isCell(value, provenType(m_node-&gt;child1())), usually(isCellCase), rarely(slowCase));
 2112 
 2113         LBasicBlock lastNext = m_out.appendTo(isCellCase, slowCase);
 2114         ValueFromBlock fastResult = m_out.anchor(value);
 2115         m_out.branch(
 2116             m_out.testIsZero32(
 2117                 m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
 2118                 m_out.constInt32(OverridesToThis)),
 2119             usually(continuation), rarely(slowCase));
 2120 
 2121         m_out.appendTo(slowCase, continuation);
<a name="54" id="anc54"></a><span class="line-modified"> 2122         J_JITOperation_GJ function;</span>
 2123         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 2124             function = operationToThisStrict;
 2125         else
 2126             function = operationToThis;
<a name="55" id="anc55"></a><span class="line-modified"> 2127         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, function, weakPointer(globalObject), value));</span>

 2128         m_out.jump(continuation);
 2129 
 2130         m_out.appendTo(continuation, lastNext);
 2131         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 2132     }
 2133 
 2134     void compileValueAdd()
 2135     {
<a name="56" id="anc56"></a><span class="line-added"> 2136         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 2137 </span>
 2138         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2139             LValue left = lowBigInt(m_node-&gt;child1());
 2140             LValue right = lowBigInt(m_node-&gt;child2());
 2141 
<a name="57" id="anc57"></a><span class="line-modified"> 2142             LValue result = vmCall(pointerType(), operationAddBigInt, weakPointer(globalObject), left, right);</span>
 2143             setJSValue(result);
 2144             return;
 2145         }
 2146 
 2147         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="58" id="anc58"></a><span class="line-modified"> 2148         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2149         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 2150         auto repatchingFunction = operationValueAddOptimize;
 2151         auto nonRepatchingFunction = operationValueAdd;
 2152         compileBinaryMathIC&lt;JITAddGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2153     }
 2154 
 2155     void compileValueSub()
 2156     {
<a name="59" id="anc59"></a><span class="line-added"> 2157         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 2158 </span>
 2159         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2160             LValue left = lowBigInt(m_node-&gt;child1());
 2161             LValue right = lowBigInt(m_node-&gt;child2());
 2162 
<a name="60" id="anc60"></a><span class="line-modified"> 2163             LValue result = vmCall(pointerType(), operationSubBigInt, weakPointer(globalObject), left, right);</span>
 2164             setJSValue(result);
 2165             return;
 2166         }
 2167 
 2168         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="61" id="anc61"></a><span class="line-modified"> 2169         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2170         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 2171         auto repatchingFunction = operationValueSubOptimize;
 2172         auto nonRepatchingFunction = operationValueSub;
 2173         compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2174     }
 2175 
 2176     void compileValueMul()
 2177     {
<a name="62" id="anc62"></a><span class="line-added"> 2178         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 2179 </span>
 2180         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2181             LValue left = lowBigInt(m_node-&gt;child1());
 2182             LValue right = lowBigInt(m_node-&gt;child2());
 2183 
<a name="63" id="anc63"></a><span class="line-modified"> 2184             LValue result = vmCall(Int64, operationMulBigInt, weakPointer(globalObject), left, right);</span>
 2185             setJSValue(result);
 2186             return;
 2187         }
 2188 
 2189         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="64" id="anc64"></a><span class="line-modified"> 2190         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2191         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 2192         auto repatchingFunction = operationValueMulOptimize;
 2193         auto nonRepatchingFunction = operationValueMul;
 2194         compileBinaryMathIC&lt;JITMulGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2195     }
 2196 
 2197     template &lt;typename Generator, typename Func1, typename Func2,
 2198         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<a name="65" id="anc65"></a><span class="line-modified"> 2199     void compileUnaryMathIC(UnaryArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2200     {
 2201         Node* node = m_node;
 2202 
 2203         LValue operand = lowJSValue(node-&gt;child1());
 2204 
 2205         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2206         patchpoint-&gt;appendSomeRegister(operand);
<a name="66" id="anc66"></a><span class="line-modified"> 2207         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 2208         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
 2209         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 2210         patchpoint-&gt;numGPScratchRegisters = 1;
 2211         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2212         State* state = &amp;m_ftlState;
 2213         patchpoint-&gt;setGenerator(
 2214             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2215                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2216 
 2217                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2218                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2219 
 2220 #if ENABLE(MATH_IC_STATS)
 2221                 auto inlineStart = jit.label();
 2222 #endif
 2223 
 2224                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 2225                 JITUnaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);
 2226                 mathIC-&gt;m_generator = Generator(JSValueRegs(params[0].gpr()), JSValueRegs(params[1].gpr()), params.gpScratch(0));
 2227 
 2228                 bool shouldEmitProfiling = false;
 2229                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2230 
 2231                 if (generatedInline) {
 2232                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2233                     auto done = jit.label();
 2234                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2235                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2236                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2237                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2238 #if ENABLE(MATH_IC_STATS)
 2239                         auto slowPathStart = jit.label();
 2240 #endif
 2241 
 2242                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2243                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<a name="67" id="anc67"></a><span class="line-modified"> 2244                                 repatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
 2245                             mathICGenerationState-&gt;slowPathCall = call.call();
 2246                         } else {
 2247                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<a name="68" id="anc68"></a><span class="line-modified"> 2248                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr());</span>
 2249                             mathICGenerationState-&gt;slowPathCall = call.call();
 2250                         }
 2251                         jit.jump().linkTo(done, &amp;jit);
 2252 
 2253                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2254                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2255                         });
 2256 
 2257 #if ENABLE(MATH_IC_STATS)
 2258                         auto slowPathEnd = jit.label();
 2259                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2260                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2261                             mathIC-&gt;m_generatedCodeSize += size;
 2262                         });
 2263 #endif
 2264                     });
 2265                 } else {
 2266                     callOperation(
 2267                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<a name="69" id="anc69"></a><span class="line-modified"> 2268                         nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr());</span>
 2269                 }
 2270 
 2271 #if ENABLE(MATH_IC_STATS)
 2272                 auto inlineEnd = jit.label();
 2273                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2274                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2275                     mathIC-&gt;m_generatedCodeSize += size;
 2276                 });
 2277 #endif
 2278             });
 2279 
 2280         setJSValue(patchpoint);
 2281     }
 2282 
 2283     template &lt;typename Generator, typename Func1, typename Func2,
 2284         typename = std::enable_if_t&lt;std::is_function&lt;typename std::remove_pointer&lt;Func1&gt;::type&gt;::value &amp;&amp; std::is_function&lt;typename std::remove_pointer&lt;Func2&gt;::type&gt;::value&gt;&gt;
<a name="70" id="anc70"></a><span class="line-modified"> 2285     void compileBinaryMathIC(BinaryArithProfile* arithProfile, Func1 repatchingFunction, Func2 nonRepatchingFunction)</span>
 2286     {
 2287         Node* node = m_node;
 2288 
 2289         LValue left = lowJSValue(node-&gt;child1());
 2290         LValue right = lowJSValue(node-&gt;child2());
 2291 
 2292         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
 2293         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
 2294 
 2295         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 2296         patchpoint-&gt;appendSomeRegister(left);
 2297         patchpoint-&gt;appendSomeRegister(right);
<a name="71" id="anc71"></a><span class="line-modified"> 2298         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 2299         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
 2300         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 2301             preparePatchpointForExceptions(patchpoint);
 2302         patchpoint-&gt;numGPScratchRegisters = 1;
 2303         patchpoint-&gt;numFPScratchRegisters = 2;
 2304         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 2305         State* state = &amp;m_ftlState;
 2306         patchpoint-&gt;setGenerator(
 2307             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 2308                 AllowMacroScratchRegisterUsage allowScratch(jit);
 2309 
 2310 
 2311                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 2312                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 2313 
 2314 #if ENABLE(MATH_IC_STATS)
 2315                 auto inlineStart = jit.label();
 2316 #endif
 2317 
 2318                 Box&lt;MathICGenerationState&gt; mathICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 2319                 JITBinaryMathIC&lt;Generator&gt;* mathIC = jit.codeBlock()-&gt;addMathIC&lt;Generator&gt;(arithProfile);
 2320                 mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
 2321                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.fpScratch(0),
 2322                     params.fpScratch(1), params.gpScratch(0), InvalidFPRReg);
 2323 
 2324                 bool shouldEmitProfiling = false;
 2325                 bool generatedInline = mathIC-&gt;generateInline(jit, *mathICGenerationState, shouldEmitProfiling);
 2326 
 2327                 if (generatedInline) {
 2328                     ASSERT(!mathICGenerationState-&gt;slowPathJumps.empty());
 2329                     auto done = jit.label();
 2330                     params.addLatePath([=] (CCallHelpers&amp; jit) {
 2331                         AllowMacroScratchRegisterUsage allowScratch(jit);
 2332                         mathICGenerationState-&gt;slowPathJumps.link(&amp;jit);
 2333                         mathICGenerationState-&gt;slowPathStart = jit.label();
 2334 #if ENABLE(MATH_IC_STATS)
 2335                         auto slowPathStart = jit.label();
 2336 #endif
 2337 
 2338                         if (mathICGenerationState-&gt;shouldSlowPathRepatch) {
 2339                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<a name="72" id="anc72"></a><span class="line-modified"> 2340                                 repatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr(), CCallHelpers::TrustedImmPtr(mathIC));</span>
 2341                             mathICGenerationState-&gt;slowPathCall = call.call();
 2342                         } else {
 2343                             SlowPathCall call = callOperation(*state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<a name="73" id="anc73"></a><span class="line-modified"> 2344                                 exceptions.get(), nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr());</span>
 2345                             mathICGenerationState-&gt;slowPathCall = call.call();
 2346                         }
 2347                         jit.jump().linkTo(done, &amp;jit);
 2348 
 2349                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2350                             mathIC-&gt;finalizeInlineCode(*mathICGenerationState, linkBuffer);
 2351                         });
 2352 
 2353 #if ENABLE(MATH_IC_STATS)
 2354                         auto slowPathEnd = jit.label();
 2355                         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2356                             size_t size = linkBuffer.locationOf(slowPathEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(slowPathStart).executableAddress&lt;char*&gt;();
 2357                             mathIC-&gt;m_generatedCodeSize += size;
 2358                         });
 2359 #endif
 2360                     });
 2361                 } else {
 2362                     callOperation(
 2363                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic, exceptions.get(),
<a name="74" id="anc74"></a><span class="line-modified"> 2364                         nonRepatchingFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(), params[2].gpr());</span>
 2365                 }
 2366 
 2367 #if ENABLE(MATH_IC_STATS)
 2368                 auto inlineEnd = jit.label();
 2369                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 2370                     size_t size = linkBuffer.locationOf(inlineEnd).executableAddress&lt;char*&gt;() - linkBuffer.locationOf(inlineStart).executableAddress&lt;char*&gt;();
 2371                     mathIC-&gt;m_generatedCodeSize += size;
 2372                 });
 2373 #endif
 2374             });
 2375 
 2376         setJSValue(patchpoint);
 2377     }
 2378 
 2379     void compileStrCat()
 2380     {
<a name="75" id="anc75"></a><span class="line-added"> 2381         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 2382 </span>
 2383         LValue result;
 2384         if (m_node-&gt;child3()) {
 2385             result = vmCall(
<a name="76" id="anc76"></a><span class="line-modified"> 2386                 Int64, operationStrCat3, weakPointer(globalObject),</span>
 2387                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2388                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation),
 2389                 lowJSValue(m_node-&gt;child3(), ManualOperandSpeculation));
 2390         } else {
 2391             result = vmCall(
<a name="77" id="anc77"></a><span class="line-modified"> 2392                 Int64, operationStrCat2, weakPointer(globalObject),</span>
 2393                 lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation),
 2394                 lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation));
 2395         }
 2396         setJSValue(result);
 2397     }
 2398 
 2399     void compileArithAddOrSub()
 2400     {
 2401         bool isSub =  m_node-&gt;op() == ArithSub;
 2402         switch (m_node-&gt;binaryUseKind()) {
 2403         case Int32Use: {
 2404             LValue left = lowInt32(m_node-&gt;child1());
 2405             LValue right = lowInt32(m_node-&gt;child2());
 2406 
 2407             if (!shouldCheckOverflow(m_node-&gt;arithMode())) {
 2408                 setInt32(isSub ? m_out.sub(left, right) : m_out.add(left, right));
 2409                 break;
 2410             }
 2411 
 2412             CheckValue* result =
 2413                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2414             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2415             setInt32(result);
 2416             break;
 2417         }
 2418 
 2419         case Int52RepUse: {
 2420             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)
 2421                 &amp;&amp; !abstractValue(m_node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {
 2422                 Int52Kind kind;
 2423                 LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2424                 LValue right = lowInt52(m_node-&gt;child2(), kind);
 2425                 setInt52(isSub ? m_out.sub(left, right) : m_out.add(left, right), kind);
 2426                 break;
 2427             }
 2428 
 2429             LValue left = lowInt52(m_node-&gt;child1());
 2430             LValue right = lowInt52(m_node-&gt;child2());
 2431             CheckValue* result =
 2432                 isSub ? m_out.speculateSub(left, right) : m_out.speculateAdd(left, right);
 2433             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2434             setInt52(result);
 2435             break;
 2436         }
 2437 
 2438         case DoubleRepUse: {
 2439             LValue C1 = lowDouble(m_node-&gt;child1());
 2440             LValue C2 = lowDouble(m_node-&gt;child2());
 2441 
 2442             setDouble(isSub ? m_out.doubleSub(C1, C2) : m_out.doubleAdd(C1, C2));
 2443             break;
 2444         }
 2445 
 2446         case UntypedUse: {
 2447             if (!isSub) {
 2448                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2449                 break;
 2450             }
 2451 
 2452             CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="78" id="anc78"></a><span class="line-modified"> 2453             BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 2454             BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 2455             auto repatchingFunction = operationValueSubOptimize;
 2456             auto nonRepatchingFunction = operationValueSub;
 2457             compileBinaryMathIC&lt;JITSubGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 2458             break;
 2459         }
 2460 
 2461         default:
 2462             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2463             break;
 2464         }
 2465     }
 2466 
 2467     void compileArithClz32()
 2468     {
<a name="79" id="anc79"></a><span class="line-added"> 2469         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2470         if (m_node-&gt;child1().useKind() == Int32Use || m_node-&gt;child1().useKind() == KnownInt32Use) {
 2471             LValue operand = lowInt32(m_node-&gt;child1());
 2472             setInt32(m_out.ctlz32(operand));
 2473             return;
 2474         }
 2475         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2476         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="80" id="anc80"></a><span class="line-modified"> 2477         LValue result = vmCall(Int32, operationArithClz32, weakPointer(globalObject), argument);</span>
 2478         setInt32(result);
 2479     }
 2480 
 2481     void compileArithMul()
 2482     {
 2483         switch (m_node-&gt;binaryUseKind()) {
 2484         case Int32Use: {
 2485             LValue left = lowInt32(m_node-&gt;child1());
 2486             LValue right = lowInt32(m_node-&gt;child2());
 2487 
 2488             LValue result;
 2489 
 2490             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 2491                 result = m_out.mul(left, right);
 2492             else {
 2493                 CheckValue* speculation = m_out.speculateMul(left, right);
 2494                 blessSpeculation(speculation, Overflow, noValue(), nullptr, m_origin);
 2495                 result = speculation;
 2496             }
 2497 
 2498             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2499                 LBasicBlock slowCase = m_out.newBlock();
 2500                 LBasicBlock continuation = m_out.newBlock();
 2501 
 2502                 m_out.branch(
 2503                     m_out.notZero32(result), usually(continuation), rarely(slowCase));
 2504 
 2505                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2506                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int32Zero));
 2507                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int32Zero));
 2508                 m_out.jump(continuation);
 2509                 m_out.appendTo(continuation, lastNext);
 2510             }
 2511 
 2512             setInt32(result);
 2513             break;
 2514         }
 2515 
 2516         case Int52RepUse: {
 2517             Int52Kind kind;
 2518             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 2519             LValue right = lowInt52(m_node-&gt;child2(), opposite(kind));
 2520 
 2521             CheckValue* result = m_out.speculateMul(left, right);
 2522             blessSpeculation(result, Overflow, noValue(), nullptr, m_origin);
 2523 
 2524             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2525                 LBasicBlock slowCase = m_out.newBlock();
 2526                 LBasicBlock continuation = m_out.newBlock();
 2527 
 2528                 m_out.branch(
 2529                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 2530 
 2531                 LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
 2532                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(left, m_out.int64Zero));
 2533                 speculate(NegativeZero, noValue(), nullptr, m_out.lessThan(right, m_out.int64Zero));
 2534                 m_out.jump(continuation);
 2535                 m_out.appendTo(continuation, lastNext);
 2536             }
 2537 
 2538             setInt52(result);
 2539             break;
 2540         }
 2541 
 2542         case DoubleRepUse: {
 2543             setDouble(
 2544                 m_out.doubleMul(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2545             break;
 2546         }
 2547 
 2548         default:
 2549             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2550             break;
 2551         }
 2552     }
 2553 
 2554     void compileValueDiv()
 2555     {
<a name="81" id="anc81"></a><span class="line-added"> 2556         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2557         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2558             LValue left = lowBigInt(m_node-&gt;child1());
 2559             LValue right = lowBigInt(m_node-&gt;child2());
 2560 
<a name="82" id="anc82"></a><span class="line-modified"> 2561             LValue result = vmCall(pointerType(), operationDivBigInt, weakPointer(globalObject), left, right);</span>
 2562             setJSValue(result);
 2563             return;
 2564         }
 2565 
 2566         emitBinarySnippet&lt;JITDivGenerator, NeedScratchFPR&gt;(operationValueDiv);
 2567     }
 2568 
 2569     void compileArithDiv()
 2570     {
 2571         switch (m_node-&gt;binaryUseKind()) {
 2572         case Int32Use: {
 2573             LValue numerator = lowInt32(m_node-&gt;child1());
 2574             LValue denominator = lowInt32(m_node-&gt;child2());
 2575 
 2576             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2577                 LBasicBlock zeroNumerator = m_out.newBlock();
 2578                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2579 
 2580                 m_out.branch(
 2581                     m_out.isZero32(numerator),
 2582                     rarely(zeroNumerator), usually(numeratorContinuation));
 2583 
 2584                 LBasicBlock innerLastNext = m_out.appendTo(zeroNumerator, numeratorContinuation);
 2585 
 2586                 speculate(
 2587                     NegativeZero, noValue(), 0, m_out.lessThan(denominator, m_out.int32Zero));
 2588 
 2589                 m_out.jump(numeratorContinuation);
 2590 
 2591                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2592             }
 2593 
 2594             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2595                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2596                 LBasicBlock continuation = m_out.newBlock();
 2597 
 2598                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2599                 m_out.branch(
 2600                     m_out.above(adjustedDenominator, m_out.int32One),
 2601                     usually(continuation), rarely(unsafeDenominator));
 2602 
 2603                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2604                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2605                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2606                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2607                 m_out.jump(continuation);
 2608 
 2609                 m_out.appendTo(continuation, lastNext);
 2610                 LValue result = m_out.div(numerator, denominator);
 2611                 speculate(
 2612                     Overflow, noValue(), 0,
 2613                     m_out.notEqual(m_out.mul(result, denominator), numerator));
 2614                 setInt32(result);
 2615             } else
 2616                 setInt32(m_out.chillDiv(numerator, denominator));
 2617 
 2618             break;
 2619         }
 2620 
 2621         case DoubleRepUse: {
 2622             setDouble(m_out.doubleDiv(
 2623                 lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2624             break;
 2625         }
 2626 
 2627         default:
 2628             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2629             break;
 2630         }
 2631     }
 2632 
 2633     void compileValueMod()
 2634     {
<a name="83" id="anc83"></a><span class="line-added"> 2635         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2636         if (m_node-&gt;binaryUseKind() == BigIntUse) {
 2637             LValue left = lowBigInt(m_node-&gt;child1());
 2638             LValue right = lowBigInt(m_node-&gt;child2());
 2639 
<a name="84" id="anc84"></a><span class="line-modified"> 2640             LValue result = vmCall(pointerType(), operationModBigInt, weakPointer(globalObject), left, right);</span>
 2641             setJSValue(result);
 2642             return;
 2643         }
 2644 
 2645         DFG_ASSERT(m_graph, m_node, m_node-&gt;binaryUseKind() == UntypedUse, m_node-&gt;binaryUseKind());
 2646         LValue left = lowJSValue(m_node-&gt;child1());
 2647         LValue right = lowJSValue(m_node-&gt;child2());
<a name="85" id="anc85"></a><span class="line-modified"> 2648         LValue result = vmCall(Int64, operationValueMod, weakPointer(globalObject), left, right);</span>
 2649         setJSValue(result);
 2650     }
 2651 
 2652     void compileArithMod()
 2653     {
 2654         switch (m_node-&gt;binaryUseKind()) {
 2655         case Int32Use: {
 2656             LValue numerator = lowInt32(m_node-&gt;child1());
 2657             LValue denominator = lowInt32(m_node-&gt;child2());
 2658 
 2659             LValue remainder;
 2660             if (shouldCheckOverflow(m_node-&gt;arithMode())) {
 2661                 LBasicBlock unsafeDenominator = m_out.newBlock();
 2662                 LBasicBlock continuation = m_out.newBlock();
 2663 
 2664                 LValue adjustedDenominator = m_out.add(denominator, m_out.int32One);
 2665                 m_out.branch(
 2666                     m_out.above(adjustedDenominator, m_out.int32One),
 2667                     usually(continuation), rarely(unsafeDenominator));
 2668 
 2669                 LBasicBlock lastNext = m_out.appendTo(unsafeDenominator, continuation);
 2670                 LValue neg2ToThe31 = m_out.constInt32(-2147483647-1);
 2671                 speculate(Overflow, noValue(), nullptr, m_out.isZero32(denominator));
 2672                 speculate(Overflow, noValue(), nullptr, m_out.equal(numerator, neg2ToThe31));
 2673                 m_out.jump(continuation);
 2674 
 2675                 m_out.appendTo(continuation, lastNext);
 2676                 LValue result = m_out.mod(numerator, denominator);
 2677                 remainder = result;
 2678             } else
 2679                 remainder = m_out.chillMod(numerator, denominator);
 2680 
 2681             if (shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 2682                 LBasicBlock negativeNumerator = m_out.newBlock();
 2683                 LBasicBlock numeratorContinuation = m_out.newBlock();
 2684 
 2685                 m_out.branch(
 2686                     m_out.lessThan(numerator, m_out.int32Zero),
 2687                     unsure(negativeNumerator), unsure(numeratorContinuation));
 2688 
 2689                 LBasicBlock innerLastNext = m_out.appendTo(negativeNumerator, numeratorContinuation);
 2690 
 2691                 speculate(NegativeZero, noValue(), 0, m_out.isZero32(remainder));
 2692 
 2693                 m_out.jump(numeratorContinuation);
 2694 
 2695                 m_out.appendTo(numeratorContinuation, innerLastNext);
 2696             }
 2697 
 2698             setInt32(remainder);
 2699             break;
 2700         }
 2701 
 2702         case DoubleRepUse: {
 2703             setDouble(
 2704                 m_out.doubleMod(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 2705             break;
 2706         }
 2707 
 2708         default:
 2709             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2710             break;
 2711         }
 2712     }
 2713 
 2714     void compileArithMinOrMax()
 2715     {
 2716         switch (m_node-&gt;binaryUseKind()) {
 2717         case Int32Use: {
 2718             LValue left = lowInt32(m_node-&gt;child1());
 2719             LValue right = lowInt32(m_node-&gt;child2());
 2720 
 2721             setInt32(
 2722                 m_out.select(
 2723                     m_node-&gt;op() == ArithMin
 2724                         ? m_out.lessThan(left, right)
 2725                         : m_out.lessThan(right, left),
 2726                     left, right));
 2727             break;
 2728         }
 2729 
 2730         case DoubleRepUse: {
 2731             LValue left = lowDouble(m_node-&gt;child1());
 2732             LValue right = lowDouble(m_node-&gt;child2());
 2733 
 2734             LBasicBlock notLessThan = m_out.newBlock();
 2735             LBasicBlock continuation = m_out.newBlock();
 2736 
 2737             Vector&lt;ValueFromBlock, 2&gt; results;
 2738 
 2739             results.append(m_out.anchor(left));
 2740             m_out.branch(
 2741                 m_node-&gt;op() == ArithMin
 2742                     ? m_out.doubleLessThan(left, right)
 2743                     : m_out.doubleGreaterThan(left, right),
 2744                 unsure(continuation), unsure(notLessThan));
 2745 
 2746             LBasicBlock lastNext = m_out.appendTo(notLessThan, continuation);
 2747             results.append(m_out.anchor(m_out.select(
 2748                 m_node-&gt;op() == ArithMin
 2749                     ? m_out.doubleGreaterThanOrEqual(left, right)
 2750                     : m_out.doubleLessThanOrEqual(left, right),
 2751                 right, m_out.constDouble(PNaN))));
 2752             m_out.jump(continuation);
 2753 
 2754             m_out.appendTo(continuation, lastNext);
 2755             setDouble(m_out.phi(Double, results));
 2756             break;
 2757         }
 2758 
 2759         default:
 2760             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 2761             break;
 2762         }
 2763     }
 2764 
 2765     void compileArithAbs()
 2766     {
<a name="86" id="anc86"></a><span class="line-added"> 2767         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2768         switch (m_node-&gt;child1().useKind()) {
 2769         case Int32Use: {
 2770             LValue value = lowInt32(m_node-&gt;child1());
 2771 
 2772             LValue mask = m_out.aShr(value, m_out.constInt32(31));
 2773             LValue result = m_out.bitXor(mask, m_out.add(mask, value));
 2774 
 2775             if (shouldCheckOverflow(m_node-&gt;arithMode()))
 2776                 speculate(Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
 2777 
 2778             setInt32(result);
 2779             break;
 2780         }
 2781 
 2782         case DoubleRepUse: {
 2783             setDouble(m_out.doubleAbs(lowDouble(m_node-&gt;child1())));
 2784             break;
 2785         }
 2786 
 2787         default: {
 2788             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 2789             LValue argument = lowJSValue(m_node-&gt;child1());
<a name="87" id="anc87"></a><span class="line-modified"> 2790             LValue result = vmCall(Double, operationArithAbs, weakPointer(globalObject), argument);</span>
 2791             setDouble(result);
 2792             break;
 2793         }
 2794         }
 2795     }
 2796 
 2797     void compileArithUnary()
 2798     {
<a name="88" id="anc88"></a><span class="line-added"> 2799         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2800         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 2801             setDouble(m_out.doubleUnary(m_node-&gt;arithUnaryType(), lowDouble(m_node-&gt;child1())));
 2802             return;
 2803         }
 2804         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="89" id="anc89"></a><span class="line-modified"> 2805         LValue result = vmCall(Double, DFG::arithUnaryOperation(m_node-&gt;arithUnaryType()), weakPointer(globalObject), argument);</span>
 2806         setDouble(result);
 2807     }
 2808 
 2809     void compileValuePow()
 2810     {
<a name="90" id="anc90"></a><span class="line-added"> 2811         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 2812         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 2813             LValue base = lowBigInt(m_node-&gt;child1());
 2814             LValue exponent = lowBigInt(m_node-&gt;child2());
 2815 
<a name="91" id="anc91"></a><span class="line-modified"> 2816             LValue result = vmCall(pointerType(), operationPowBigInt, weakPointer(globalObject), base, exponent);</span>
 2817             setJSValue(result);
 2818             return;
 2819         }
 2820 
 2821         LValue base = lowJSValue(m_node-&gt;child1());
 2822         LValue exponent = lowJSValue(m_node-&gt;child2());
<a name="92" id="anc92"></a><span class="line-modified"> 2823         LValue result = vmCall(Int64, operationValuePow, weakPointer(globalObject), base, exponent);</span>
 2824         setJSValue(result);
 2825     }
 2826 
 2827     void compileArithPow()
 2828     {
 2829         if (m_node-&gt;child2().useKind() == Int32Use)
 2830             setDouble(m_out.doublePowi(lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 2831         else {
 2832             LValue base = lowDouble(m_node-&gt;child1());
 2833             LValue exponent = lowDouble(m_node-&gt;child2());
 2834 
 2835             LBasicBlock integerExponentIsSmallBlock = m_out.newBlock();
 2836             LBasicBlock integerExponentPowBlock = m_out.newBlock();
 2837             LBasicBlock doubleExponentPowBlockEntry = m_out.newBlock();
 2838             LBasicBlock nanExceptionBaseIsOne = m_out.newBlock();
 2839             LBasicBlock nanExceptionExponentIsInfinity = m_out.newBlock();
 2840             LBasicBlock testExponentIsOneHalf = m_out.newBlock();
 2841             LBasicBlock handleBaseZeroExponentIsOneHalf = m_out.newBlock();
 2842             LBasicBlock handleInfinityForExponentIsOneHalf = m_out.newBlock();
 2843             LBasicBlock exponentIsOneHalfNormal = m_out.newBlock();
 2844             LBasicBlock exponentIsOneHalfInfinity = m_out.newBlock();
 2845             LBasicBlock testExponentIsNegativeOneHalf = m_out.newBlock();
 2846             LBasicBlock testBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2847             LBasicBlock handleBaseZeroExponentIsNegativeOneHalf = m_out.newBlock();
 2848             LBasicBlock handleInfinityForExponentIsNegativeOneHalf = m_out.newBlock();
 2849             LBasicBlock exponentIsNegativeOneHalfNormal = m_out.newBlock();
 2850             LBasicBlock exponentIsNegativeOneHalfInfinity = m_out.newBlock();
 2851             LBasicBlock powBlock = m_out.newBlock();
 2852             LBasicBlock nanExceptionResultIsNaN = m_out.newBlock();
 2853             LBasicBlock continuation = m_out.newBlock();
 2854 
 2855             LValue integerExponent = m_out.doubleToInt(exponent);
 2856             LValue integerExponentConvertedToDouble = m_out.intToDouble(integerExponent);
 2857             LValue exponentIsInteger = m_out.doubleEqual(exponent, integerExponentConvertedToDouble);
 2858             m_out.branch(exponentIsInteger, unsure(integerExponentIsSmallBlock), unsure(doubleExponentPowBlockEntry));
 2859 
 2860             LBasicBlock lastNext = m_out.appendTo(integerExponentIsSmallBlock, integerExponentPowBlock);
 2861             LValue integerExponentBelowMax = m_out.belowOrEqual(integerExponent, m_out.constInt32(maxExponentForIntegerMathPow));
 2862             m_out.branch(integerExponentBelowMax, usually(integerExponentPowBlock), rarely(doubleExponentPowBlockEntry));
 2863 
 2864             m_out.appendTo(integerExponentPowBlock, doubleExponentPowBlockEntry);
 2865             ValueFromBlock powDoubleIntResult = m_out.anchor(m_out.doublePowi(base, integerExponent));
 2866             m_out.jump(continuation);
 2867 
 2868             // If y is NaN, the result is NaN.
 2869             m_out.appendTo(doubleExponentPowBlockEntry, nanExceptionBaseIsOne);
 2870             LValue exponentIsNaN;
 2871             if (provenType(m_node-&gt;child2()) &amp; SpecDoubleNaN)
 2872                 exponentIsNaN = m_out.doubleNotEqualOrUnordered(exponent, exponent);
 2873             else
 2874                 exponentIsNaN = m_out.booleanFalse;
 2875             m_out.branch(exponentIsNaN, rarely(nanExceptionResultIsNaN), usually(nanExceptionBaseIsOne));
 2876 
 2877             // If abs(x) is 1 and y is +infinity, the result is NaN.
 2878             // If abs(x) is 1 and y is -infinity, the result is NaN.
 2879 
 2880             //     Test if base == 1.
 2881             m_out.appendTo(nanExceptionBaseIsOne, nanExceptionExponentIsInfinity);
 2882             LValue absoluteBase = m_out.doubleAbs(base);
 2883             LValue absoluteBaseIsOne = m_out.doubleEqual(absoluteBase, m_out.constDouble(1));
 2884             m_out.branch(absoluteBaseIsOne, rarely(nanExceptionExponentIsInfinity), usually(testExponentIsOneHalf));
 2885 
 2886             //     Test if abs(y) == Infinity.
 2887             m_out.appendTo(nanExceptionExponentIsInfinity, testExponentIsOneHalf);
 2888             LValue absoluteExponent = m_out.doubleAbs(exponent);
 2889             LValue absoluteExponentIsInfinity = m_out.doubleEqual(absoluteExponent, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2890             m_out.branch(absoluteExponentIsInfinity, rarely(nanExceptionResultIsNaN), usually(testExponentIsOneHalf));
 2891 
 2892             // If y == 0.5 or y == -0.5, handle it through SQRT.
 2893             // We have be carefuly with -0 and -Infinity.
 2894 
 2895             //     Test if y == 0.5
 2896             m_out.appendTo(testExponentIsOneHalf, handleBaseZeroExponentIsOneHalf);
 2897             LValue exponentIsOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(0.5));
 2898             m_out.branch(exponentIsOneHalf, rarely(handleBaseZeroExponentIsOneHalf), usually(testExponentIsNegativeOneHalf));
 2899 
 2900             //     Handle x == -0.
 2901             m_out.appendTo(handleBaseZeroExponentIsOneHalf, handleInfinityForExponentIsOneHalf);
 2902             LValue baseIsZeroExponentIsOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2903             ValueFromBlock zeroResultExponentIsOneHalf = m_out.anchor(m_out.doubleZero);
 2904             m_out.branch(baseIsZeroExponentIsOneHalf, rarely(continuation), usually(handleInfinityForExponentIsOneHalf));
 2905 
 2906             //     Test if abs(x) == Infinity.
 2907             m_out.appendTo(handleInfinityForExponentIsOneHalf, exponentIsOneHalfNormal);
 2908             LValue absoluteBaseIsInfinityOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2909             m_out.branch(absoluteBaseIsInfinityOneHalf, rarely(exponentIsOneHalfInfinity), usually(exponentIsOneHalfNormal));
 2910 
 2911             //     The exponent is 0.5, the base is finite or NaN, we can use SQRT.
 2912             m_out.appendTo(exponentIsOneHalfNormal, exponentIsOneHalfInfinity);
 2913             ValueFromBlock sqrtResult = m_out.anchor(m_out.doubleSqrt(base));
 2914             m_out.jump(continuation);
 2915 
 2916             //     The exponent is 0.5, the base is infinite, the result is always infinite.
 2917             m_out.appendTo(exponentIsOneHalfInfinity, testExponentIsNegativeOneHalf);
 2918             ValueFromBlock sqrtInfinityResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2919             m_out.jump(continuation);
 2920 
 2921             //     Test if y == -0.5
 2922             m_out.appendTo(testExponentIsNegativeOneHalf, testBaseZeroExponentIsNegativeOneHalf);
 2923             LValue exponentIsNegativeOneHalf = m_out.doubleEqual(exponent, m_out.constDouble(-0.5));
 2924             m_out.branch(exponentIsNegativeOneHalf, rarely(testBaseZeroExponentIsNegativeOneHalf), usually(powBlock));
 2925 
 2926             //     Handle x == -0.
 2927             m_out.appendTo(testBaseZeroExponentIsNegativeOneHalf, handleBaseZeroExponentIsNegativeOneHalf);
 2928             LValue baseIsZeroExponentIsNegativeOneHalf = m_out.doubleEqual(base, m_out.doubleZero);
 2929             m_out.branch(baseIsZeroExponentIsNegativeOneHalf, rarely(handleBaseZeroExponentIsNegativeOneHalf), usually(handleInfinityForExponentIsNegativeOneHalf));
 2930 
 2931             m_out.appendTo(handleBaseZeroExponentIsNegativeOneHalf, handleInfinityForExponentIsNegativeOneHalf);
 2932             ValueFromBlock oneOverSqrtZeroResult = m_out.anchor(m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2933             m_out.jump(continuation);
 2934 
 2935             //     Test if abs(x) == Infinity.
 2936             m_out.appendTo(handleInfinityForExponentIsNegativeOneHalf, exponentIsNegativeOneHalfNormal);
 2937             LValue absoluteBaseIsInfinityNegativeOneHalf = m_out.doubleEqual(absoluteBase, m_out.constDouble(std::numeric_limits&lt;double&gt;::infinity()));
 2938             m_out.branch(absoluteBaseIsInfinityNegativeOneHalf, rarely(exponentIsNegativeOneHalfInfinity), usually(exponentIsNegativeOneHalfNormal));
 2939 
 2940             //     The exponent is -0.5, the base is finite or NaN, we can use 1/SQRT.
 2941             m_out.appendTo(exponentIsNegativeOneHalfNormal, exponentIsNegativeOneHalfInfinity);
 2942             LValue sqrtBase = m_out.doubleSqrt(base);
 2943             ValueFromBlock oneOverSqrtResult = m_out.anchor(m_out.div(m_out.constDouble(1.), sqrtBase));
 2944             m_out.jump(continuation);
 2945 
 2946             //     The exponent is -0.5, the base is infinite, the result is always zero.
 2947             m_out.appendTo(exponentIsNegativeOneHalfInfinity, powBlock);
 2948             ValueFromBlock oneOverSqrtInfinityResult = m_out.anchor(m_out.doubleZero);
 2949             m_out.jump(continuation);
 2950 
 2951             m_out.appendTo(powBlock, nanExceptionResultIsNaN);
 2952             ValueFromBlock powResult = m_out.anchor(m_out.doublePow(base, exponent));
 2953             m_out.jump(continuation);
 2954 
 2955             m_out.appendTo(nanExceptionResultIsNaN, continuation);
 2956             ValueFromBlock pureNan = m_out.anchor(m_out.constDouble(PNaN));
 2957             m_out.jump(continuation);
 2958 
 2959             m_out.appendTo(continuation, lastNext);
 2960             setDouble(m_out.phi(Double, powDoubleIntResult, zeroResultExponentIsOneHalf, sqrtResult, sqrtInfinityResult, oneOverSqrtZeroResult, oneOverSqrtResult, oneOverSqrtInfinityResult, powResult, pureNan));
 2961         }
 2962     }
 2963 
 2964     void compileArithRandom()
 2965     {
 2966         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 2967 
 2968         // Inlined WeakRandom::advance().
 2969         // uint64_t x = m_low;
 2970         void* lowAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::lowOffset();
 2971         LValue low = m_out.load64(m_out.absolute(lowAddress));
 2972         // uint64_t y = m_high;
 2973         void* highAddress = reinterpret_cast&lt;uint8_t*&gt;(globalObject) + JSGlobalObject::weakRandomOffset() + WeakRandom::highOffset();
 2974         LValue high = m_out.load64(m_out.absolute(highAddress));
 2975         // m_low = y;
 2976         m_out.store64(high, m_out.absolute(lowAddress));
 2977 
 2978         // x ^= x &lt;&lt; 23;
 2979         LValue phase1 = m_out.bitXor(m_out.shl(low, m_out.constInt64(23)), low);
 2980 
 2981         // x ^= x &gt;&gt; 17;
 2982         LValue phase2 = m_out.bitXor(m_out.lShr(phase1, m_out.constInt64(17)), phase1);
 2983 
 2984         // x ^= y ^ (y &gt;&gt; 26);
 2985         LValue phase3 = m_out.bitXor(m_out.bitXor(high, m_out.lShr(high, m_out.constInt64(26))), phase2);
 2986 
 2987         // m_high = x;
 2988         m_out.store64(phase3, m_out.absolute(highAddress));
 2989 
 2990         // return x + y;
 2991         LValue random64 = m_out.add(phase3, high);
 2992 
 2993         // Extract random 53bit. [0, 53] bit is safe integer number ranges in double representation.
 2994         LValue random53 = m_out.bitAnd(random64, m_out.constInt64((1ULL &lt;&lt; 53) - 1));
 2995 
 2996         LValue double53Integer = m_out.intToDouble(random53);
 2997 
 2998         // Convert `(53bit double integer value) / (1 &lt;&lt; 53)` to `(53bit double integer value) * (1.0 / (1 &lt;&lt; 53))`.
 2999         // In latter case, `1.0 / (1 &lt;&lt; 53)` will become a double value represented as (mantissa = 0 &amp; exp = 970, it means 1e-(2**54)).
<a name="93" id="anc93"></a><span class="line-modified"> 3000         static constexpr double scale = 1.0 / (1ULL &lt;&lt; 53);</span>
 3001 
 3002         // Multiplying 1e-(2**54) with the double integer does not change anything of the mantissa part of the double integer.
 3003         // It just reduces the exp part of the given 53bit double integer.
 3004         // (Except for 0.0. This is specially handled and in this case, exp just becomes 0.)
 3005         // Now we get 53bit precision random double value in [0, 1).
 3006         LValue result = m_out.doubleMul(double53Integer, m_out.constDouble(scale));
 3007 
 3008         setDouble(result);
 3009     }
 3010 
 3011     void compileArithRound()
 3012     {
<a name="94" id="anc94"></a><span class="line-added"> 3013         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3014         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3015             LValue result = nullptr;
 3016             if (producesInteger(m_node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())) {
 3017                 LValue value = lowDouble(m_node-&gt;child1());
 3018                 result = m_out.doubleFloor(m_out.doubleAdd(value, m_out.constDouble(0.5)));
 3019             } else {
<a name="95" id="anc95"></a><span class="line-modified"> 3020                 LBasicBlock shouldRoundDown = m_out.newBlock();</span>
 3021                 LBasicBlock continuation = m_out.newBlock();
 3022 
 3023                 LValue value = lowDouble(m_node-&gt;child1());
 3024                 LValue integerValue = m_out.doubleCeil(value);
 3025                 ValueFromBlock integerValueResult = m_out.anchor(integerValue);
 3026 
<a name="96" id="anc96"></a><span class="line-modified"> 3027                 LValue ceilMinusHalf = m_out.doubleSub(integerValue, m_out.constDouble(0.5));</span>
<span class="line-added"> 3028                 m_out.branch(m_out.doubleGreaterThanOrUnordered(ceilMinusHalf, value), unsure(shouldRoundDown), unsure(continuation));</span>
 3029 
<a name="97" id="anc97"></a><span class="line-modified"> 3030                 LBasicBlock lastNext = m_out.appendTo(shouldRoundDown, continuation);</span>


 3031                 LValue integerValueRoundedDown = m_out.doubleSub(integerValue, m_out.constDouble(1));
 3032                 ValueFromBlock integerValueRoundedDownResult = m_out.anchor(integerValueRoundedDown);
 3033                 m_out.jump(continuation);
 3034                 m_out.appendTo(continuation, lastNext);
 3035 
 3036                 result = m_out.phi(Double, integerValueResult, integerValueRoundedDownResult);
 3037             }
 3038 
 3039             if (producesInteger(m_node-&gt;arithRoundingMode())) {
 3040                 LValue integerValue = convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode()));
 3041                 setInt32(integerValue);
 3042             } else
 3043                 setDouble(result);
 3044             return;
 3045         }
 3046 
 3047         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 3048         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="98" id="anc98"></a><span class="line-modified"> 3049         setJSValue(vmCall(Int64, operationArithRound, weakPointer(globalObject), argument));</span>
 3050     }
 3051 
 3052     void compileArithFloor()
 3053     {
<a name="99" id="anc99"></a><span class="line-added"> 3054         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3055         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3056             LValue value = lowDouble(m_node-&gt;child1());
 3057             LValue integerValue = m_out.doubleFloor(value);
 3058             if (producesInteger(m_node-&gt;arithRoundingMode()))
 3059                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 3060             else
 3061                 setDouble(integerValue);
 3062             return;
 3063         }
 3064         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 3065         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="100" id="anc100"></a><span class="line-modified"> 3066         setJSValue(vmCall(Int64, operationArithFloor, weakPointer(globalObject), argument));</span>
 3067     }
 3068 
 3069     void compileArithCeil()
 3070     {
<a name="101" id="anc101"></a><span class="line-added"> 3071         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3072         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3073             LValue value = lowDouble(m_node-&gt;child1());
 3074             LValue integerValue = m_out.doubleCeil(value);
 3075             if (producesInteger(m_node-&gt;arithRoundingMode()))
 3076                 setInt32(convertDoubleToInt32(integerValue, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 3077             else
 3078                 setDouble(integerValue);
 3079             return;
 3080         }
 3081         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 3082         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="102" id="anc102"></a><span class="line-modified"> 3083         setJSValue(vmCall(Int64, operationArithCeil, weakPointer(globalObject), argument));</span>
 3084     }
 3085 
 3086     void compileArithTrunc()
 3087     {
<a name="103" id="anc103"></a><span class="line-added"> 3088         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3089         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3090             LValue value = lowDouble(m_node-&gt;child1());
 3091             LValue result = m_out.doubleTrunc(value);
 3092             if (producesInteger(m_node-&gt;arithRoundingMode()))
 3093                 setInt32(convertDoubleToInt32(result, shouldCheckNegativeZero(m_node-&gt;arithRoundingMode())));
 3094             else
 3095                 setDouble(result);
 3096             return;
 3097         }
 3098         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse, m_node-&gt;child1().useKind());
 3099         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="104" id="anc104"></a><span class="line-modified"> 3100         setJSValue(vmCall(Int64, operationArithTrunc, weakPointer(globalObject), argument));</span>
 3101     }
 3102 
 3103     void compileArithSqrt()
 3104     {
<a name="105" id="anc105"></a><span class="line-added"> 3105         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3106         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3107             setDouble(m_out.doubleSqrt(lowDouble(m_node-&gt;child1())));
 3108             return;
 3109         }
 3110         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="106" id="anc106"></a><span class="line-modified"> 3111         LValue result = vmCall(Double, operationArithSqrt, weakPointer(globalObject), argument);</span>
 3112         setDouble(result);
 3113     }
 3114 
 3115     void compileArithFRound()
 3116     {
<a name="107" id="anc107"></a><span class="line-added"> 3117         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3118         if (m_node-&gt;child1().useKind() == DoubleRepUse) {
 3119             setDouble(m_out.fround(lowDouble(m_node-&gt;child1())));
 3120             return;
 3121         }
 3122         LValue argument = lowJSValue(m_node-&gt;child1());
<a name="108" id="anc108"></a><span class="line-modified"> 3123         LValue result = vmCall(Double, operationArithFRound, weakPointer(globalObject), argument);</span>
 3124         setDouble(result);
 3125     }
 3126 
<a name="109" id="anc109"></a><span class="line-added"> 3127     void compileIncOrDec()</span>
<span class="line-added"> 3128     {</span>
<span class="line-added"> 3129         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added"> 3130         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 3131         LValue operand = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 3132         LValue result = vmCall(Int64, m_node-&gt;op() == Inc ? operationInc : operationDec, weakPointer(globalObject), operand);</span>
<span class="line-added"> 3133         setJSValue(result);</span>
<span class="line-added"> 3134     }</span>
<span class="line-added"> 3135 </span>
 3136     void compileValueNegate()
 3137     {
 3138         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
 3139         CodeBlock* baselineCodeBlock = m_ftlState.graph.baselineCodeBlockFor(m_node-&gt;origin.semantic);
<a name="110" id="anc110"></a><span class="line-modified"> 3140         BytecodeIndex bytecodeIndex = m_node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 3141         UnaryArithProfile* arithProfile = baselineCodeBlock-&gt;unaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 3142         auto repatchingFunction = operationArithNegateOptimize;
 3143         auto nonRepatchingFunction = operationArithNegate;
 3144         compileUnaryMathIC&lt;JITNegGenerator&gt;(arithProfile, repatchingFunction, nonRepatchingFunction);
 3145     }
 3146 
 3147     void compileArithNegate()
 3148     {
 3149         switch (m_node-&gt;child1().useKind()) {
 3150         case Int32Use: {
 3151             LValue value = lowInt32(m_node-&gt;child1());
 3152 
 3153             LValue result;
 3154             if (!shouldCheckOverflow(m_node-&gt;arithMode()))
 3155                 result = m_out.neg(value);
 3156             else if (!shouldCheckNegativeZero(m_node-&gt;arithMode())) {
 3157                 CheckValue* check = m_out.speculateSub(m_out.int32Zero, value);
 3158                 blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 3159                 result = check;
 3160             } else {
 3161                 speculate(Overflow, noValue(), 0, m_out.testIsZero32(value, m_out.constInt32(0x7fffffff)));
 3162                 result = m_out.neg(value);
 3163             }
 3164 
 3165             setInt32(result);
 3166             break;
 3167         }
 3168 
 3169         case Int52RepUse: {
 3170             if (!abstractValue(m_node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {
 3171                 Int52Kind kind;
 3172                 LValue value = lowWhicheverInt52(m_node-&gt;child1(), kind);
 3173                 LValue result = m_out.neg(value);
 3174                 if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3175                     speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3176                 setInt52(result, kind);
 3177                 break;
 3178             }
 3179 
 3180             LValue value = lowInt52(m_node-&gt;child1());
 3181             CheckValue* result = m_out.speculateSub(m_out.int64Zero, value);
 3182             blessSpeculation(result, Int52Overflow, noValue(), nullptr, m_origin);
 3183             if (shouldCheckNegativeZero(m_node-&gt;arithMode()))
 3184                 speculate(NegativeZero, noValue(), 0, m_out.isZero64(result));
 3185             setInt52(result);
 3186             break;
 3187         }
 3188 
 3189         case DoubleRepUse: {
 3190             setDouble(m_out.doubleNeg(lowDouble(m_node-&gt;child1())));
 3191             break;
 3192         }
 3193 
 3194         default:
 3195             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3196             break;
 3197         }
 3198     }
 3199 
 3200     void compileValueBitNot()
 3201     {
<a name="111" id="anc111"></a><span class="line-added"> 3202         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3203         if (m_node-&gt;child1().useKind() == BigIntUse) {
 3204             LValue operand = lowBigInt(m_node-&gt;child1());
<a name="112" id="anc112"></a><span class="line-modified"> 3205             LValue result = vmCall(pointerType(), operationBitNotBigInt, weakPointer(globalObject), operand);</span>
 3206             setJSValue(result);
 3207             return;
 3208         }
 3209 
 3210         LValue operand = lowJSValue(m_node-&gt;child1());
<a name="113" id="anc113"></a><span class="line-modified"> 3211         LValue result = vmCall(Int64, operationValueBitNot, weakPointer(globalObject), operand);</span>
 3212         setJSValue(result);
 3213     }
 3214 
 3215     void compileArithBitNot()
 3216     {
 3217         setInt32(m_out.bitNot(lowInt32(m_node-&gt;child1())));
 3218     }
 3219 
 3220     void compileValueBitAnd()
 3221     {
<a name="114" id="anc114"></a><span class="line-added"> 3222         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3223         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3224             LValue left = lowBigInt(m_node-&gt;child1());
 3225             LValue right = lowBigInt(m_node-&gt;child2());
 3226 
<a name="115" id="anc115"></a><span class="line-modified"> 3227             LValue result = vmCall(pointerType(), operationBitAndBigInt, weakPointer(globalObject), left, right);</span>
 3228             setJSValue(result);
 3229             return;
 3230         }
 3231 
 3232         emitBinaryBitOpSnippet&lt;JITBitAndGenerator&gt;(operationValueBitAnd);
 3233     }
 3234 
 3235     void compileArithBitAnd()
 3236     {
 3237         setInt32(m_out.bitAnd(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3238     }
 3239 
 3240     void compileValueBitOr()
 3241     {
<a name="116" id="anc116"></a><span class="line-added"> 3242         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3243         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3244             LValue left = lowBigInt(m_node-&gt;child1());
 3245             LValue right = lowBigInt(m_node-&gt;child2());
 3246 
<a name="117" id="anc117"></a><span class="line-modified"> 3247             LValue result = vmCall(pointerType(), operationBitOrBigInt, weakPointer(globalObject), left, right);</span>
 3248             setJSValue(result);
 3249             return;
 3250         }
 3251 
 3252         emitBinaryBitOpSnippet&lt;JITBitOrGenerator&gt;(operationValueBitOr);
 3253     }
 3254 
 3255     void compileArithBitOr()
 3256     {
 3257         setInt32(m_out.bitOr(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3258     }
 3259 
 3260     void compileValueBitXor()
 3261     {
<a name="118" id="anc118"></a><span class="line-added"> 3262         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3263         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3264             LValue left = lowBigInt(m_node-&gt;child1());
 3265             LValue right = lowBigInt(m_node-&gt;child2());
 3266 
<a name="119" id="anc119"></a><span class="line-modified"> 3267             LValue result = vmCall(pointerType(), operationBitXorBigInt, weakPointer(globalObject), left, right);</span>
 3268             setJSValue(result);
 3269             return;
 3270         }
 3271 
 3272         emitBinaryBitOpSnippet&lt;JITBitXorGenerator&gt;(operationValueBitXor);
 3273     }
 3274 
 3275     void compileArithBitXor()
 3276     {
 3277         setInt32(m_out.bitXor(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 3278     }
 3279 
<a name="120" id="anc120"></a><span class="line-modified"> 3280     void compileValueBitRShift()</span>
 3281     {
<a name="121" id="anc121"></a><span class="line-modified"> 3282         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-modified"> 3283         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added"> 3284             LValue left = lowBigInt(m_node-&gt;child1());</span>
<span class="line-added"> 3285             LValue right = lowBigInt(m_node-&gt;child2());</span>
<span class="line-added"> 3286 </span>
<span class="line-added"> 3287             LValue result = vmCall(pointerType(), operationBitRShiftBigInt, weakPointer(globalObject), left, right);</span>
<span class="line-added"> 3288             setJSValue(result);</span>
 3289             return;
 3290         }
<a name="122" id="anc122"></a><span class="line-added"> 3291 </span>
<span class="line-added"> 3292         emitRightShiftSnippet(JITRightShiftGenerator::SignedShift);</span>
<span class="line-added"> 3293     }</span>
<span class="line-added"> 3294 </span>
<span class="line-added"> 3295     void compileArithBitRShift()</span>
<span class="line-added"> 3296     {</span>
 3297         setInt32(m_out.aShr(
 3298             lowInt32(m_node-&gt;child1()),
 3299             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3300     }
 3301 
 3302     void compileArithBitLShift()
 3303     {
 3304         setInt32(m_out.shl(
 3305             lowInt32(m_node-&gt;child1()),
 3306             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3307     }
 3308 
 3309     void compileValueBitLShift()
 3310     {
<a name="123" id="anc123"></a><span class="line-added"> 3311         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3312         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 3313             LValue left = lowBigInt(m_node-&gt;child1());
 3314             LValue right = lowBigInt(m_node-&gt;child2());
 3315 
<a name="124" id="anc124"></a><span class="line-modified"> 3316             LValue result = vmCall(pointerType(), operationBitLShiftBigInt, weakPointer(globalObject), left, right);</span>
 3317             setJSValue(result);
 3318             return;
 3319         }
 3320 
 3321         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
 3322         emitBinaryBitOpSnippet&lt;JITLeftShiftGenerator&gt;(operationValueBitLShift);
 3323     }
 3324 
 3325     void compileBitURShift()
 3326     {
 3327         if (m_node-&gt;isBinaryUseKind(UntypedUse)) {
 3328             emitRightShiftSnippet(JITRightShiftGenerator::UnsignedShift);
 3329             return;
 3330         }
 3331         setInt32(m_out.lShr(
 3332             lowInt32(m_node-&gt;child1()),
 3333             m_out.bitAnd(lowInt32(m_node-&gt;child2()), m_out.constInt32(31))));
 3334     }
 3335 
 3336     void compileUInt32ToNumber()
 3337     {
 3338         LValue value = lowInt32(m_node-&gt;child1());
 3339 
 3340         if (doesOverflow(m_node-&gt;arithMode())) {
 3341             setStrictInt52(m_out.zeroExtPtr(value));
 3342             return;
 3343         }
 3344 
 3345         speculate(Overflow, noValue(), 0, m_out.lessThan(value, m_out.int32Zero));
 3346         setInt32(value);
 3347     }
 3348 
 3349     void compileCheckStructure()
 3350     {
 3351         ExitKind exitKind;
 3352         if (m_node-&gt;child1()-&gt;hasConstant())
 3353             exitKind = BadConstantCache;
 3354         else
 3355             exitKind = BadCache;
 3356 
 3357         switch (m_node-&gt;child1().useKind()) {
 3358         case CellUse:
 3359         case KnownCellUse: {
 3360             LValue cell = lowCell(m_node-&gt;child1());
 3361 
 3362             checkStructure(
 3363                 m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3364                 exitKind, m_node-&gt;structureSet(),
 3365                 [&amp;] (RegisteredStructure structure) {
 3366                     return weakStructureID(structure);
 3367                 });
 3368             return;
 3369         }
 3370 
 3371         case CellOrOtherUse: {
 3372             LValue value = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 3373 
 3374             LBasicBlock cellCase = m_out.newBlock();
 3375             LBasicBlock notCellCase = m_out.newBlock();
 3376             LBasicBlock continuation = m_out.newBlock();
 3377 
 3378             m_out.branch(
 3379                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3380 
 3381             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3382             checkStructure(
 3383                 m_out.load32(value, m_heaps.JSCell_structureID), jsValueValue(value),
 3384                 exitKind, m_node-&gt;structureSet(),
 3385                 [&amp;] (RegisteredStructure structure) {
 3386                     return weakStructureID(structure);
 3387                 });
 3388             m_out.jump(continuation);
 3389 
 3390             m_out.appendTo(notCellCase, continuation);
 3391             FTL_TYPE_CHECK(jsValueValue(value), m_node-&gt;child1(), SpecCell | SpecOther, isNotOther(value));
 3392             m_out.jump(continuation);
 3393 
 3394             m_out.appendTo(continuation, lastNext);
 3395             return;
 3396         }
 3397 
 3398         default:
 3399             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3400             return;
 3401         }
 3402     }
 3403 
 3404     void compileCheckStructureOrEmpty()
 3405     {
 3406         ExitKind exitKind;
 3407         if (m_node-&gt;child1()-&gt;hasConstant())
 3408             exitKind = BadConstantCache;
 3409         else
 3410             exitKind = BadCache;
 3411 
 3412         LValue cell = lowCell(m_node-&gt;child1());
 3413         bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;
<a name="125" id="anc125"></a><span class="line-modified"> 3414         LBasicBlock continuation = nullptr;</span>
<span class="line-modified"> 3415         LBasicBlock lastNext = nullptr;</span>

 3416         if (maySeeEmptyValue) {
<a name="126" id="anc126"></a><span class="line-modified"> 3417             LBasicBlock notEmpty = m_out.newBlock();</span>
 3418             continuation = m_out.newBlock();
 3419             m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));
 3420             lastNext = m_out.appendTo(notEmpty, continuation);
 3421         }
 3422 
 3423         checkStructure(
 3424             m_out.load32(cell, m_heaps.JSCell_structureID), jsValueValue(cell),
 3425             exitKind, m_node-&gt;structureSet(),
 3426             [&amp;] (RegisteredStructure structure) {
 3427                 return weakStructureID(structure);
 3428             });
 3429 
 3430         if (maySeeEmptyValue) {
 3431             m_out.jump(continuation);
 3432             m_out.appendTo(continuation, lastNext);
 3433         }
 3434     }
 3435 
 3436     void compileCheckCell()
 3437     {
 3438         LValue cell = lowCell(m_node-&gt;child1());
 3439 
 3440         speculate(
 3441             BadCell, jsValueValue(cell), m_node-&gt;child1().node(),
 3442             m_out.notEqual(cell, weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 3443     }
 3444 
 3445     void compileCheckBadCell()
 3446     {
 3447         terminate(BadCell);
 3448     }
 3449 
 3450     void compileCheckNotEmpty()
 3451     {
 3452         speculate(TDZFailure, noValue(), nullptr, m_out.isZero64(lowJSValue(m_node-&gt;child1())));
 3453     }
 3454 
 3455     void compileAssertNotEmpty()
 3456     {
 3457         if (!validationEnabled())
 3458             return;
 3459 
 3460         LValue val = lowJSValue(m_node-&gt;child1());
 3461         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3462         patchpoint-&gt;appendSomeRegister(val);
 3463         patchpoint-&gt;setGenerator(
 3464             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3465                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3466                 GPRReg input =  params[0].gpr();
 3467                 CCallHelpers::Jump done = jit.branchIfNotEmpty(input);
 3468                 jit.breakpoint();
 3469                 done.link(&amp;jit);
 3470             });
 3471     }
 3472 
<a name="127" id="anc127"></a><span class="line-modified"> 3473     void compileCheckIdent()</span>
 3474     {
 3475         UniquedStringImpl* uid = m_node-&gt;uidOperand();
<a name="128" id="anc128"></a><span class="line-modified"> 3476         LValue stringImpl;</span>
<span class="line-added"> 3477         if (m_node-&gt;child1().useKind() == StringIdentUse)</span>
<span class="line-added"> 3478             stringImpl = lowStringIdent(m_node-&gt;child1());</span>
<span class="line-added"> 3479         else {</span>
<span class="line-added"> 3480             ASSERT(m_node-&gt;child1().useKind() == SymbolUse);</span>
<span class="line-added"> 3481             stringImpl = m_out.loadPtr(lowSymbol(m_node-&gt;child1()), m_heaps.Symbol_symbolImpl);</span>
<span class="line-added"> 3482         }</span>
 3483         speculate(BadIdent, noValue(), nullptr, m_out.notEqual(stringImpl, m_out.constIntPtr(uid)));
 3484     }
 3485 
 3486     void compileGetExecutable()
 3487     {
<a name="129" id="anc129"></a><span class="line-added"> 3488         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 3489         LBasicBlock hasRareData = m_out.newBlock();</span>
 3490         LValue cell = lowCell(m_node-&gt;child1());
 3491         speculateFunction(m_node-&gt;child1(), cell);
<a name="130" id="anc130"></a><span class="line-modified"> 3492 </span>
<span class="line-added"> 3493         LValue rareDataTags = m_out.loadPtr(cell, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added"> 3494         ValueFromBlock fastExecutable = m_out.anchor(rareDataTags);</span>
<span class="line-added"> 3495         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), unsure(continuation), unsure(hasRareData));</span>
<span class="line-added"> 3496 </span>
<span class="line-added"> 3497         LBasicBlock lastNext = m_out.appendTo(hasRareData, continuation);</span>
<span class="line-added"> 3498         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added"> 3499         ValueFromBlock slowExecutable = m_out.anchor(m_out.loadPtr(rareData, m_heaps.FunctionRareData_executable));</span>
<span class="line-added"> 3500         m_out.jump(continuation);</span>
<span class="line-added"> 3501 </span>
<span class="line-added"> 3502         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 3503         setJSValue(m_out.phi(pointerType(), fastExecutable, slowExecutable));</span>
 3504     }
 3505 
 3506     void compileArrayify()
 3507     {
 3508         LValue cell = lowCell(m_node-&gt;child1());
 3509         LValue property = !!m_node-&gt;child2() ? lowInt32(m_node-&gt;child2()) : 0;
 3510 
 3511         LBasicBlock unexpectedStructure = m_out.newBlock();
 3512         LBasicBlock continuation = m_out.newBlock();
 3513 
 3514         auto isUnexpectedArray = [&amp;] (LValue cell) {
 3515             if (m_node-&gt;op() == Arrayify)
 3516                 return m_out.logicalNot(isArrayTypeForArrayify(cell, m_node-&gt;arrayMode()));
 3517 
 3518             ASSERT(m_node-&gt;op() == ArrayifyToStructure);
 3519             return m_out.notEqual(m_out.load32(cell, m_heaps.JSCell_structureID), weakStructureID(m_node-&gt;structure()));
 3520         };
 3521 
 3522         m_out.branch(isUnexpectedArray(cell), rarely(unexpectedStructure), usually(continuation));
 3523 
 3524         LBasicBlock lastNext = m_out.appendTo(unexpectedStructure, continuation);
 3525 
 3526         if (property) {
 3527             switch (m_node-&gt;arrayMode().type()) {
 3528             case Array::Int32:
 3529             case Array::Double:
 3530             case Array::Contiguous:
 3531                 speculate(
 3532                     Uncountable, noValue(), 0,
 3533                     m_out.aboveOrEqual(property, m_out.constInt32(MIN_SPARSE_ARRAY_INDEX)));
 3534                 break;
 3535             default:
 3536                 break;
 3537             }
 3538         }
 3539 
 3540         switch (m_node-&gt;arrayMode().type()) {
 3541         case Array::Int32:
<a name="131" id="anc131"></a><span class="line-modified"> 3542             vmCall(Void, operationEnsureInt32, m_vmValue, cell);</span>
 3543             break;
 3544         case Array::Double:
<a name="132" id="anc132"></a><span class="line-modified"> 3545             vmCall(Void, operationEnsureDouble, m_vmValue, cell);</span>
 3546             break;
 3547         case Array::Contiguous:
<a name="133" id="anc133"></a><span class="line-modified"> 3548             vmCall(Void, operationEnsureContiguous, m_vmValue, cell);</span>
 3549             break;
 3550         case Array::ArrayStorage:
 3551         case Array::SlowPutArrayStorage:
<a name="134" id="anc134"></a><span class="line-modified"> 3552             vmCall(Void, operationEnsureArrayStorage, m_vmValue, cell);</span>
 3553             break;
 3554         default:
 3555             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 3556             break;
 3557         }
 3558 
 3559         speculate(BadIndexingType, jsValueValue(cell), 0, isUnexpectedArray(cell));
 3560         m_out.jump(continuation);
 3561 
 3562         m_out.appendTo(continuation, lastNext);
 3563     }
 3564 
 3565     void compilePutStructure()
 3566     {
 3567         m_ftlState.jitCode-&gt;common.notifyCompilingStructureTransition(m_graph.m_plan, codeBlock(), m_node);
 3568 
 3569         RegisteredStructure oldStructure = m_node-&gt;transition()-&gt;previous;
 3570         RegisteredStructure newStructure = m_node-&gt;transition()-&gt;next;
 3571         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
 3572         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
 3573         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
 3574 
 3575         LValue cell = lowCell(m_node-&gt;child1());
 3576         m_out.store32(
 3577             weakStructureID(newStructure),
 3578             cell, m_heaps.JSCell_structureID);
 3579     }
 3580 
 3581     void compileGetById(AccessType type)
 3582     {
<a name="135" id="anc135"></a><span class="line-modified"> 3583         ASSERT(type == AccessType::GetById || type == AccessType::TryGetById || type == AccessType::GetByIdDirect);</span>
<span class="line-added"> 3584         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3585         switch (m_node-&gt;child1().useKind()) {
 3586         case CellUse: {
 3587             setJSValue(getById(lowCell(m_node-&gt;child1()), type));
 3588             return;
 3589         }
 3590 
 3591         case UntypedUse: {
 3592             // This is pretty weird, since we duplicate the slow path both here and in the
 3593             // code generated by the IC. We should investigate making this less bad.
 3594             // https://bugs.webkit.org/show_bug.cgi?id=127830
 3595             LValue value = lowJSValue(m_node-&gt;child1());
 3596 
 3597             LBasicBlock cellCase = m_out.newBlock();
 3598             LBasicBlock notCellCase = m_out.newBlock();
 3599             LBasicBlock continuation = m_out.newBlock();
 3600 
 3601             m_out.branch(
 3602                 isCell(value, provenType(m_node-&gt;child1())), unsure(cellCase), unsure(notCellCase));
 3603 
 3604             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
 3605             ValueFromBlock cellResult = m_out.anchor(getById(value, type));
 3606             m_out.jump(continuation);
 3607 
<a name="136" id="anc136"></a><span class="line-modified"> 3608             J_JITOperation_GJI getByIdFunction = appropriateGenericGetByIdFunction(type);</span>
 3609 
 3610             m_out.appendTo(notCellCase, continuation);
 3611             ValueFromBlock notCellResult = m_out.anchor(vmCall(
<a name="137" id="anc137"></a><span class="line-modified"> 3612                 Int64, getByIdFunction,</span>
<span class="line-modified"> 3613                 weakPointer(globalObject), value,</span>
 3614                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3615             m_out.jump(continuation);
 3616 
 3617             m_out.appendTo(continuation, lastNext);
 3618             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3619             return;
 3620         }
 3621 
 3622         default:
 3623             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 3624             return;
 3625         }
 3626     }
 3627 
 3628     void compileGetByIdWithThis()
 3629     {
<a name="138" id="anc138"></a><span class="line-added"> 3630         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3631         if (m_node-&gt;child1().useKind() == CellUse &amp;&amp; m_node-&gt;child2().useKind() == CellUse)
 3632             setJSValue(getByIdWithThis(lowCell(m_node-&gt;child1()), lowCell(m_node-&gt;child2())));
 3633         else {
 3634             LValue base = lowJSValue(m_node-&gt;child1());
 3635             LValue thisValue = lowJSValue(m_node-&gt;child2());
 3636 
 3637             LBasicBlock baseCellCase = m_out.newBlock();
 3638             LBasicBlock notCellCase = m_out.newBlock();
 3639             LBasicBlock thisValueCellCase = m_out.newBlock();
 3640             LBasicBlock continuation = m_out.newBlock();
 3641 
 3642             m_out.branch(
 3643                 isCell(base, provenType(m_node-&gt;child1())), unsure(baseCellCase), unsure(notCellCase));
 3644 
 3645             LBasicBlock lastNext = m_out.appendTo(baseCellCase, thisValueCellCase);
 3646 
 3647             m_out.branch(
 3648                 isCell(thisValue, provenType(m_node-&gt;child2())), unsure(thisValueCellCase), unsure(notCellCase));
 3649 
 3650             m_out.appendTo(thisValueCellCase, notCellCase);
 3651             ValueFromBlock cellResult = m_out.anchor(getByIdWithThis(base, thisValue));
 3652             m_out.jump(continuation);
 3653 
 3654             m_out.appendTo(notCellCase, continuation);
 3655             ValueFromBlock notCellResult = m_out.anchor(vmCall(
<a name="139" id="anc139"></a><span class="line-modified"> 3656                 Int64, operationGetByIdWithThisGeneric,</span>
<span class="line-modified"> 3657                 weakPointer(globalObject), base, thisValue,</span>
 3658                 m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()])));
 3659             m_out.jump(continuation);
 3660 
 3661             m_out.appendTo(continuation, lastNext);
 3662             setJSValue(m_out.phi(Int64, cellResult, notCellResult));
 3663         }
 3664 
 3665     }
 3666 
 3667     void compileGetByValWithThis()
 3668     {
<a name="140" id="anc140"></a><span class="line-added"> 3669         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3670         LValue base = lowJSValue(m_node-&gt;child1());
 3671         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3672         LValue subscript = lowJSValue(m_node-&gt;child3());
 3673 
<a name="141" id="anc141"></a><span class="line-modified"> 3674         LValue result = vmCall(Int64, operationGetByValWithThis, weakPointer(globalObject), base, thisValue, subscript);</span>
 3675         setJSValue(result);
 3676     }
 3677 
 3678     void compilePutByIdWithThis()
 3679     {
<a name="142" id="anc142"></a><span class="line-added"> 3680         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3681         LValue base = lowJSValue(m_node-&gt;child1());
 3682         LValue thisValue = lowJSValue(m_node-&gt;child2());
 3683         LValue value = lowJSValue(m_node-&gt;child3());
 3684 
<a name="143" id="anc143"></a><span class="line-modified"> 3685         vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,</span>
<span class="line-modified"> 3686             weakPointer(globalObject), base, thisValue, value, m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;identifierNumber()]));</span>
 3687     }
 3688 
 3689     void compilePutByValWithThis()
 3690     {
<a name="144" id="anc144"></a><span class="line-added"> 3691         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3692         LValue base = lowJSValue(m_graph.varArgChild(m_node, 0));
 3693         LValue thisValue = lowJSValue(m_graph.varArgChild(m_node, 1));
 3694         LValue property = lowJSValue(m_graph.varArgChild(m_node, 2));
 3695         LValue value = lowJSValue(m_graph.varArgChild(m_node, 3));
 3696 
<a name="145" id="anc145"></a><span class="line-modified"> 3697         vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis,</span>
<span class="line-modified"> 3698             weakPointer(globalObject), base, thisValue, property, value);</span>
 3699     }
 3700 
 3701     void compileAtomicsReadModifyWrite()
 3702     {
<a name="146" id="anc146"></a><span class="line-added"> 3703         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3704         TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 3705         unsigned numExtraArgs = numExtraAtomicsArgs(m_node-&gt;op());
 3706         Edge baseEdge = m_graph.child(m_node, 0);
 3707         Edge indexEdge = m_graph.child(m_node, 1);
 3708         Edge argEdges[maxNumExtraAtomicsArgs];
 3709         for (unsigned i = numExtraArgs; i--;)
 3710             argEdges[i] = m_graph.child(m_node, 2 + i);
 3711         Edge storageEdge = m_graph.child(m_node, 2 + numExtraArgs);
 3712 
<a name="147" id="anc147"></a><span class="line-modified"> 3713         if (!storageEdge) {</span>
<span class="line-added"> 3714             auto callWith0 = [&amp;] (auto* operation) {</span>
<span class="line-added"> 3715                 ASSERT(numExtraArgs == 0);</span>
<span class="line-added"> 3716                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge));</span>
<span class="line-added"> 3717             };</span>
<span class="line-added"> 3718 </span>
<span class="line-added"> 3719             auto callWith1 = [&amp;] (auto* operation) {</span>
<span class="line-added"> 3720                 ASSERT(numExtraArgs == 1);</span>
<span class="line-added"> 3721                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge), lowJSValue(argEdges[0]));</span>
<span class="line-added"> 3722             };</span>
<span class="line-added"> 3723 </span>
<span class="line-added"> 3724             auto callWith2 = [&amp;] (auto* operation) {</span>
<span class="line-added"> 3725                 ASSERT(numExtraArgs == 2);</span>
<span class="line-added"> 3726                 return vmCall(Int64, operation, weakPointer(globalObject), lowJSValue(baseEdge), lowJSValue(indexEdge), lowJSValue(argEdges[0]), lowJSValue(argEdges[1]));</span>
<span class="line-added"> 3727             };</span>
<span class="line-added"> 3728 </span>
<span class="line-added"> 3729             LValue result;</span>
 3730             switch (m_node-&gt;op()) {
 3731             case AtomicsAdd:
<a name="148" id="anc148"></a><span class="line-modified"> 3732                 result = callWith1(operationAtomicsAdd);</span>
<span class="line-added"> 3733                 break;</span>
 3734             case AtomicsAnd:
<a name="149" id="anc149"></a><span class="line-modified"> 3735                 result = callWith1(operationAtomicsAnd);</span>
<span class="line-added"> 3736                 break;</span>
 3737             case AtomicsCompareExchange:
<a name="150" id="anc150"></a><span class="line-modified"> 3738                 result = callWith2(operationAtomicsCompareExchange);</span>
<span class="line-added"> 3739                 break;</span>
 3740             case AtomicsExchange:
<a name="151" id="anc151"></a><span class="line-modified"> 3741                 result = callWith1(operationAtomicsExchange);</span>
<span class="line-added"> 3742                 break;</span>
 3743             case AtomicsLoad:
<a name="152" id="anc152"></a><span class="line-modified"> 3744                 result = callWith0(operationAtomicsLoad);</span>
<span class="line-added"> 3745                 break;</span>
 3746             case AtomicsOr:
<a name="153" id="anc153"></a><span class="line-modified"> 3747                 result = callWith1(operationAtomicsOr);</span>
<span class="line-added"> 3748                 break;</span>
 3749             case AtomicsStore:
<a name="154" id="anc154"></a><span class="line-modified"> 3750                 result = callWith1(operationAtomicsStore);</span>
<span class="line-added"> 3751                 break;</span>
 3752             case AtomicsSub:
<a name="155" id="anc155"></a><span class="line-modified"> 3753                 result = callWith1(operationAtomicsSub);</span>
<span class="line-added"> 3754                 break;</span>
 3755             case AtomicsXor:
<a name="156" id="anc156"></a><span class="line-modified"> 3756                 result = callWith1(operationAtomicsXor);</span>
<span class="line-added"> 3757                 break;</span>
 3758             default:
 3759                 RELEASE_ASSERT_NOT_REACHED();
<a name="157" id="anc157"></a>
 3760             }
<a name="158" id="anc158"></a>









 3761             setJSValue(result);
 3762             return;
 3763         }
 3764 
 3765         LValue index = lowInt32(indexEdge);
 3766         LValue args[2];
 3767         for (unsigned i = numExtraArgs; i--;)
 3768             args[i] = getIntTypedArrayStoreOperand(argEdges[i]);
 3769         LValue storage = lowStorage(storageEdge);
 3770 
 3771         TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 3772         Width width = widthForBytes(elementSize(type));
 3773 
 3774         LValue atomicValue;
 3775         LValue result;
 3776 
 3777         auto sanitizeResult = [&amp;] (LValue value) -&gt; LValue {
 3778             if (isSigned(type)) {
 3779                 switch (elementSize(type)) {
 3780                 case 1:
 3781                     value = m_out.bitAnd(value, m_out.constInt32(0xff));
 3782                     break;
 3783                 case 2:
 3784                     value = m_out.bitAnd(value, m_out.constInt32(0xffff));
 3785                     break;
 3786                 case 4:
 3787                     break;
 3788                 default:
 3789                     RELEASE_ASSERT_NOT_REACHED();
 3790                     break;
 3791                 }
 3792             }
 3793             return value;
 3794         };
 3795 
 3796         switch (m_node-&gt;op()) {
 3797         case AtomicsAdd:
 3798             atomicValue = m_out.atomicXchgAdd(args[0], pointer, width);
 3799             result = sanitizeResult(atomicValue);
 3800             break;
 3801         case AtomicsAnd:
 3802             atomicValue = m_out.atomicXchgAnd(args[0], pointer, width);
 3803             result = sanitizeResult(atomicValue);
 3804             break;
 3805         case AtomicsCompareExchange:
 3806             atomicValue = m_out.atomicStrongCAS(args[0], args[1], pointer, width);
 3807             result = sanitizeResult(atomicValue);
 3808             break;
 3809         case AtomicsExchange:
 3810             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3811             result = sanitizeResult(atomicValue);
 3812             break;
 3813         case AtomicsLoad:
 3814             atomicValue = m_out.atomicXchgAdd(m_out.int32Zero, pointer, width);
 3815             result = sanitizeResult(atomicValue);
 3816             break;
 3817         case AtomicsOr:
 3818             atomicValue = m_out.atomicXchgOr(args[0], pointer, width);
 3819             result = sanitizeResult(atomicValue);
 3820             break;
 3821         case AtomicsStore:
 3822             atomicValue = m_out.atomicXchg(args[0], pointer, width);
 3823             result = args[0];
 3824             break;
 3825         case AtomicsSub:
 3826             atomicValue = m_out.atomicXchgSub(args[0], pointer, width);
 3827             result = sanitizeResult(atomicValue);
 3828             break;
 3829         case AtomicsXor:
 3830             atomicValue = m_out.atomicXchgXor(args[0], pointer, width);
 3831             result = sanitizeResult(atomicValue);
 3832             break;
 3833         default:
 3834             RELEASE_ASSERT_NOT_REACHED();
 3835             break;
 3836         }
 3837         // Signify that the state against which the atomic operations are serialized is confined to just
 3838         // the typed array storage, since that&#39;s as precise of an abstraction as we can have of shared
 3839         // array buffer storage.
 3840         m_heaps.decorateFencedAccess(&amp;m_heaps.typedArrayProperties, atomicValue);
 3841 
 3842         setIntTypedArrayLoadResult(result, type);
 3843     }
 3844 
 3845     void compileAtomicsIsLockFree()
 3846     {
<a name="159" id="anc159"></a><span class="line-added"> 3847         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3848         if (m_node-&gt;child1().useKind() != Int32Use) {
<a name="160" id="anc160"></a><span class="line-modified"> 3849             setJSValue(vmCall(Int64, operationAtomicsIsLockFree, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
 3850             return;
 3851         }
 3852 
 3853         LValue bytes = lowInt32(m_node-&gt;child1());
 3854 
 3855         LBasicBlock trueCase = m_out.newBlock();
 3856         LBasicBlock falseCase = m_out.newBlock();
 3857         LBasicBlock continuation = m_out.newBlock();
 3858 
 3859         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueCase);
 3860 
 3861         Vector&lt;SwitchCase&gt; cases;
 3862         cases.append(SwitchCase(m_out.constInt32(1), trueCase, Weight()));
 3863         cases.append(SwitchCase(m_out.constInt32(2), trueCase, Weight()));
 3864         cases.append(SwitchCase(m_out.constInt32(4), trueCase, Weight()));
 3865         m_out.switchInstruction(bytes, cases, falseCase, Weight());
 3866 
 3867         m_out.appendTo(trueCase, falseCase);
 3868         ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
 3869         m_out.jump(continuation);
 3870         m_out.appendTo(falseCase, continuation);
 3871         ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
 3872         m_out.jump(continuation);
 3873 
 3874         m_out.appendTo(continuation, lastNext);
 3875         setBoolean(m_out.phi(Int32, trueValue, falseValue));
 3876     }
 3877 
 3878     void compileDefineDataProperty()
 3879     {
<a name="161" id="anc161"></a><span class="line-added"> 3880         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3881         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3882         LValue value  = lowJSValue(m_graph.varArgChild(m_node, 2));
 3883         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 3));
 3884         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3885         switch (propertyEdge.useKind()) {
 3886         case StringUse: {
 3887             LValue property = lowString(propertyEdge);
<a name="162" id="anc162"></a><span class="line-modified"> 3888             vmCall(Void, operationDefineDataPropertyString, weakPointer(globalObject), base, property, value, attributes);</span>
 3889             break;
 3890         }
 3891         case StringIdentUse: {
 3892             LValue property = lowStringIdent(propertyEdge);
<a name="163" id="anc163"></a><span class="line-modified"> 3893             vmCall(Void, operationDefineDataPropertyStringIdent, weakPointer(globalObject), base, property, value, attributes);</span>
 3894             break;
 3895         }
 3896         case SymbolUse: {
 3897             LValue property = lowSymbol(propertyEdge);
<a name="164" id="anc164"></a><span class="line-modified"> 3898             vmCall(Void, operationDefineDataPropertySymbol, weakPointer(globalObject), base, property, value, attributes);</span>
 3899             break;
 3900         }
 3901         case UntypedUse: {
 3902             LValue property = lowJSValue(propertyEdge);
<a name="165" id="anc165"></a><span class="line-modified"> 3903             vmCall(Void, operationDefineDataProperty, weakPointer(globalObject), base, property, value, attributes);</span>
 3904             break;
 3905         }
 3906         default:
 3907             RELEASE_ASSERT_NOT_REACHED();
 3908         }
 3909     }
 3910 
 3911     void compileDefineAccessorProperty()
 3912     {
<a name="166" id="anc166"></a><span class="line-added"> 3913         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 3914         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 3915         LValue getter = lowCell(m_graph.varArgChild(m_node, 2));
 3916         LValue setter = lowCell(m_graph.varArgChild(m_node, 3));
 3917         LValue attributes = lowInt32(m_graph.varArgChild(m_node, 4));
 3918         Edge&amp; propertyEdge = m_graph.varArgChild(m_node, 1);
 3919         switch (propertyEdge.useKind()) {
 3920         case StringUse: {
 3921             LValue property = lowString(propertyEdge);
<a name="167" id="anc167"></a><span class="line-modified"> 3922             vmCall(Void, operationDefineAccessorPropertyString, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
 3923             break;
 3924         }
 3925         case StringIdentUse: {
 3926             LValue property = lowStringIdent(propertyEdge);
<a name="168" id="anc168"></a><span class="line-modified"> 3927             vmCall(Void, operationDefineAccessorPropertyStringIdent, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
 3928             break;
 3929         }
 3930         case SymbolUse: {
 3931             LValue property = lowSymbol(propertyEdge);
<a name="169" id="anc169"></a><span class="line-modified"> 3932             vmCall(Void, operationDefineAccessorPropertySymbol, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
 3933             break;
 3934         }
 3935         case UntypedUse: {
 3936             LValue property = lowJSValue(propertyEdge);
<a name="170" id="anc170"></a><span class="line-modified"> 3937             vmCall(Void, operationDefineAccessorProperty, weakPointer(globalObject), base, property, getter, setter, attributes);</span>
 3938             break;
 3939         }
 3940         default:
 3941             RELEASE_ASSERT_NOT_REACHED();
 3942         }
 3943     }
 3944 
 3945     void compilePutById()
 3946     {
 3947         DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == CellUse, m_node-&gt;child1().useKind());
 3948 
 3949         Node* node = m_node;
 3950         LValue base = lowCell(node-&gt;child1());
 3951         LValue value = lowJSValue(node-&gt;child2());
 3952         auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
 3953 
 3954         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 3955         patchpoint-&gt;appendSomeRegister(base);
 3956         patchpoint-&gt;appendSomeRegister(value);
<a name="171" id="anc171"></a><span class="line-modified"> 3957         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 3958         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 3959         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 3960 
 3961         // FIXME: If this is a PutByIdFlush, we might want to late-clobber volatile registers.
 3962         // https://bugs.webkit.org/show_bug.cgi?id=152848
 3963 
 3964         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 3965             preparePatchpointForExceptions(patchpoint);
 3966 
 3967         State* state = &amp;m_ftlState;
 3968         ECMAMode ecmaMode = m_graph.executableFor(node-&gt;origin.semantic)-&gt;ecmaMode();
 3969 
 3970         patchpoint-&gt;setGenerator(
 3971             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 3972                 AllowMacroScratchRegisterUsage allowScratch(jit);
 3973 
 3974                 CallSiteIndex callSiteIndex =
 3975                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
 3976 
 3977                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 3978                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 3979 
 3980                 // JS setter call ICs generated by the PutById IC will need this.
 3981                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 3982 
 3983                 auto generator = Box&lt;JITPutByIdGenerator&gt;::create(
 3984                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
 3985                     params.unavailableRegisters(), JSValueRegs(params[0].gpr()),
 3986                     JSValueRegs(params[1].gpr()), GPRInfo::patchpointScratchRegister, ecmaMode,
 3987                     node-&gt;op() == PutByIdDirect ? Direct : NotDirect);
 3988 
 3989                 generator-&gt;generateFastPath(jit);
 3990                 CCallHelpers::Label done = jit.label();
 3991 
 3992                 params.addLatePath(
 3993                     [=] (CCallHelpers&amp; jit) {
 3994                         AllowMacroScratchRegisterUsage allowScratch(jit);
 3995 
 3996                         generator-&gt;slowPathJump().link(&amp;jit);
 3997                         CCallHelpers::Label slowPathBegin = jit.label();
 3998                         CCallHelpers::Call slowPathCall = callOperation(
 3999                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
 4000                             exceptions.get(), generator-&gt;slowPathFunction(), InvalidGPRReg,
<a name="172" id="anc172"></a><span class="line-added"> 4001                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
 4002                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
 4003                             params[0].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
 4004                         jit.jump().linkTo(done, &amp;jit);
 4005 
 4006                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
 4007 
 4008                         jit.addLinkTask(
 4009                             [=] (LinkBuffer&amp; linkBuffer) {
 4010                                 generator-&gt;finalize(linkBuffer, linkBuffer);
 4011                             });
 4012                     });
 4013             });
 4014     }
 4015 
 4016     void compileGetButterfly()
 4017     {
 4018         LValue butterfly = m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSObject_butterfly);
 4019         setStorage(butterfly);
 4020     }
 4021 
 4022     void compileConstantStoragePointer()
 4023     {
 4024         setStorage(m_out.constIntPtr(m_node-&gt;storagePointer()));
 4025     }
 4026 
 4027     void compileGetIndexedPropertyStorage()
 4028     {
<a name="173" id="anc173"></a><span class="line-added"> 4029         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 4030         LValue cell = lowCell(m_node-&gt;child1());
 4031 
 4032         if (m_node-&gt;arrayMode().type() == Array::String) {
 4033             LBasicBlock slowPath = m_out.newBlock();
 4034             LBasicBlock continuation = m_out.newBlock();
 4035 
 4036             LValue fastResultValue = m_out.loadPtr(cell, m_heaps.JSString_value);
 4037             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 4038 
 4039             m_out.branch(isRopeString(cell, m_node-&gt;child1()), rarely(slowPath), usually(continuation));
 4040 
 4041             LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
 4042 
<a name="174" id="anc174"></a><span class="line-modified"> 4043             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationResolveRope, weakPointer(globalObject), cell));</span>

 4044 
 4045             m_out.jump(continuation);
 4046 
 4047             m_out.appendTo(continuation, lastNext);
 4048 
 4049             setStorage(m_out.loadPtr(m_out.phi(pointerType(), fastResult, slowResult), m_heaps.StringImpl_data));
 4050             return;
 4051         }
 4052 
 4053         DFG_ASSERT(m_graph, m_node, isTypedView(m_node-&gt;arrayMode().typedArrayType()), m_node-&gt;arrayMode().typedArrayType());
 4054         LValue vector = m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector);
 4055         setStorage(caged(Gigacage::Primitive, vector, cell));
 4056     }
 4057 
 4058     void compileCheckArray()
 4059     {
 4060         Edge edge = m_node-&gt;child1();
 4061         LValue cell = lowCell(edge);
 4062 
 4063         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge)))
 4064             return;
 4065 
 4066         speculate(
 4067             BadIndexingType, jsValueValue(cell), 0,
 4068             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));
 4069     }
 4070 
<a name="175" id="anc175"></a><span class="line-added"> 4071     void compileCheckArrayOrEmpty()</span>
<span class="line-added"> 4072     {</span>
<span class="line-added"> 4073         Edge edge = m_node-&gt;child1();</span>
<span class="line-added"> 4074         LValue cell = lowCell(edge);</span>
<span class="line-added"> 4075 </span>
<span class="line-added"> 4076         if (m_node-&gt;arrayMode().alreadyChecked(m_graph, m_node, abstractValue(edge))) {</span>
<span class="line-added"> 4077             // We can purge Empty check of CheckArrayOrEmpty completely in this case since CellUse only accepts SpecCell | SpecEmpty.</span>
<span class="line-added"> 4078             ASSERT(typeFilterFor(m_node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
<span class="line-added"> 4079             return;</span>
<span class="line-added"> 4080         }</span>
<span class="line-added"> 4081 </span>
<span class="line-added"> 4082         bool maySeeEmptyValue = m_interpreter.forNode(m_node-&gt;child1()).m_type &amp; SpecEmpty;</span>
<span class="line-added"> 4083         LBasicBlock continuation = nullptr;</span>
<span class="line-added"> 4084         LBasicBlock lastNext = nullptr;</span>
<span class="line-added"> 4085         if (maySeeEmptyValue) {</span>
<span class="line-added"> 4086             LBasicBlock notEmpty = m_out.newBlock();</span>
<span class="line-added"> 4087             continuation = m_out.newBlock();</span>
<span class="line-added"> 4088             m_out.branch(m_out.isZero64(cell), unsure(continuation), unsure(notEmpty));</span>
<span class="line-added"> 4089             lastNext = m_out.appendTo(notEmpty, continuation);</span>
<span class="line-added"> 4090         }</span>
<span class="line-added"> 4091 </span>
<span class="line-added"> 4092         speculate(</span>
<span class="line-added"> 4093             BadIndexingType, jsValueValue(cell), 0,</span>
<span class="line-added"> 4094             m_out.logicalNot(isArrayTypeForCheckArray(cell, m_node-&gt;arrayMode())));</span>
<span class="line-added"> 4095 </span>
<span class="line-added"> 4096         if (maySeeEmptyValue) {</span>
<span class="line-added"> 4097             m_out.jump(continuation);</span>
<span class="line-added"> 4098             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 4099         }</span>
<span class="line-added"> 4100     }</span>
<span class="line-added"> 4101 </span>
<span class="line-added"> 4102     void compileCheckNeutered()</span>
<span class="line-added"> 4103     {</span>
<span class="line-added"> 4104         Edge edge = m_node-&gt;child1();</span>
<span class="line-added"> 4105         LValue cell = lowCell(edge);</span>
<span class="line-added"> 4106 </span>
<span class="line-added"> 4107         speculate(</span>
<span class="line-added"> 4108             BadIndexingType, jsValueValue(cell), edge.node(),</span>
<span class="line-added"> 4109             m_out.isNull(m_out.loadPtr(cell, m_heaps.JSArrayBufferView_vector)));</span>
<span class="line-added"> 4110     }</span>
<span class="line-added"> 4111 </span>
 4112     void compileGetTypedArrayByteOffset()
 4113     {
 4114         LValue basePtr = lowCell(m_node-&gt;child1());
 4115 
 4116         LBasicBlock simpleCase = m_out.newBlock();
 4117         LBasicBlock wastefulCase = m_out.newBlock();
 4118         LBasicBlock notNull = m_out.newBlock();
 4119         LBasicBlock continuation = m_out.newBlock();
 4120 
 4121         LValue mode = m_out.load32(basePtr, m_heaps.JSArrayBufferView_mode);
 4122         m_out.branch(
 4123             m_out.notEqual(mode, m_out.constInt32(WastefulTypedArray)),
 4124             unsure(simpleCase), unsure(wastefulCase));
 4125 
 4126         LBasicBlock lastNext = m_out.appendTo(simpleCase, wastefulCase);
 4127 
 4128         ValueFromBlock simpleOut = m_out.anchor(m_out.constIntPtr(0));
 4129 
 4130         m_out.jump(continuation);
 4131 
 4132         m_out.appendTo(wastefulCase, notNull);
 4133 
 4134         LValue vector = m_out.loadPtr(basePtr, m_heaps.JSArrayBufferView_vector);
 4135         ValueFromBlock nullVectorOut = m_out.anchor(vector);
 4136         m_out.branch(vector, unsure(notNull), unsure(continuation));
 4137 
 4138         m_out.appendTo(notNull, continuation);
 4139 
 4140         LValue butterflyPtr = caged(Gigacage::JSValue, m_out.loadPtr(basePtr, m_heaps.JSObject_butterfly), basePtr);
 4141         LValue arrayBufferPtr = m_out.loadPtr(butterflyPtr, m_heaps.Butterfly_arrayBuffer);
 4142 
 4143         LValue vectorPtr = caged(Gigacage::Primitive, vector, basePtr);
 4144 
 4145         // FIXME: This needs caging.
 4146         // https://bugs.webkit.org/show_bug.cgi?id=175515
 4147         LValue dataPtr = m_out.loadPtr(arrayBufferPtr, m_heaps.ArrayBuffer_data);
 4148         dataPtr = removeArrayPtrTag(dataPtr);
 4149 
 4150         ValueFromBlock wastefulOut = m_out.anchor(m_out.sub(vectorPtr, dataPtr));
 4151 
 4152         m_out.jump(continuation);
 4153         m_out.appendTo(continuation, lastNext);
 4154 
 4155         setInt32(m_out.castToInt32(m_out.phi(pointerType(), simpleOut, nullVectorOut, wastefulOut)));
 4156     }
 4157 
 4158     void compileGetPrototypeOf()
 4159     {
<a name="176" id="anc176"></a><span class="line-added"> 4160         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 4161         switch (m_node-&gt;child1().useKind()) {
 4162         case ArrayUse:
 4163         case FunctionUse:
 4164         case FinalObjectUse: {
 4165             LValue object = lowCell(m_node-&gt;child1());
 4166             switch (m_node-&gt;child1().useKind()) {
 4167             case ArrayUse:
 4168                 speculateArray(m_node-&gt;child1(), object);
 4169                 break;
 4170             case FunctionUse:
 4171                 speculateFunction(m_node-&gt;child1(), object);
 4172                 break;
 4173             case FinalObjectUse:
 4174                 speculateFinalObject(m_node-&gt;child1(), object);
 4175                 break;
 4176             default:
 4177                 RELEASE_ASSERT_NOT_REACHED();
 4178                 break;
 4179             }
 4180 
 4181             LValue structure = loadStructure(object);
 4182 
 4183             AbstractValue&amp; value = m_state.forNode(m_node-&gt;child1());
 4184             if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
 4185                 bool hasPolyProto = false;
 4186                 bool hasMonoProto = false;
 4187                 value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
 4188                     if (structure-&gt;hasPolyProto())
 4189                         hasPolyProto = true;
 4190                     else
 4191                         hasMonoProto = true;
 4192                 });
 4193 
 4194                 if (hasMonoProto &amp;&amp; !hasPolyProto) {
 4195                     setJSValue(m_out.load64(structure, m_heaps.Structure_prototype));
 4196                     return;
 4197                 }
 4198 
 4199                 if (hasPolyProto &amp;&amp; !hasMonoProto) {
 4200                     setJSValue(m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 4201                     return;
 4202                 }
 4203             }
 4204 
 4205             LBasicBlock continuation = m_out.newBlock();
 4206             LBasicBlock loadPolyProto = m_out.newBlock();
 4207 
 4208             LValue prototypeBits = m_out.load64(structure, m_heaps.Structure_prototype);
 4209             ValueFromBlock directPrototype = m_out.anchor(prototypeBits);
 4210             m_out.branch(m_out.isZero64(prototypeBits), unsure(loadPolyProto), unsure(continuation));
 4211 
 4212             LBasicBlock lastNext = m_out.appendTo(loadPolyProto, continuation);
 4213             ValueFromBlock polyProto = m_out.anchor(
 4214                 m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), object, m_out.constInt64(knownPolyProtoOffset), ScaleEight, JSObject::offsetOfInlineStorage())));
 4215             m_out.jump(continuation);
 4216 
 4217             m_out.appendTo(continuation, lastNext);
 4218             setJSValue(m_out.phi(Int64, directPrototype, polyProto));
 4219             return;
 4220         }
 4221         case ObjectUse: {
<a name="177" id="anc177"></a><span class="line-modified"> 4222             setJSValue(vmCall(Int64, operationGetPrototypeOfObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
 4223             return;
 4224         }
 4225         default: {
<a name="178" id="anc178"></a><span class="line-modified"> 4226             setJSValue(vmCall(Int64, operationGetPrototypeOf, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
 4227             return;
 4228         }
 4229         }
 4230     }
 4231 
 4232     void compileGetArrayLength()
 4233     {
 4234         switch (m_node-&gt;arrayMode().type()) {
 4235         case Array::Undecided:
 4236         case Array::Int32:
 4237         case Array::Double:
 4238         case Array::Contiguous: {
 4239             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.Butterfly_publicLength));
 4240             return;
 4241         }
 4242 
 4243         case Array::ArrayStorage:
 4244         case Array::SlowPutArrayStorage: {
 4245             LValue length = m_out.load32(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_publicLength);
 4246             speculate(Uncountable, noValue(), nullptr, m_out.lessThan(length, m_out.int32Zero));
 4247             setInt32(length);
 4248             return;
 4249         }
 4250 
 4251         case Array::String: {
 4252             LValue string = lowCell(m_node-&gt;child1());
 4253 
 4254             LBasicBlock ropePath = m_out.newBlock();
 4255             LBasicBlock nonRopePath = m_out.newBlock();
 4256             LBasicBlock continuation = m_out.newBlock();
 4257 
 4258             m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropePath), usually(nonRopePath));
 4259 
 4260             LBasicBlock lastNext = m_out.appendTo(ropePath, nonRopePath);
 4261             ValueFromBlock ropeLength = m_out.anchor(m_out.load32NonNegative(string, m_heaps.JSRopeString_length));
 4262             m_out.jump(continuation);
 4263 
 4264             m_out.appendTo(nonRopePath, continuation);
 4265             ValueFromBlock nonRopeLength = m_out.anchor(m_out.load32NonNegative(m_out.loadPtr(string, m_heaps.JSString_value), m_heaps.StringImpl_length));
 4266             m_out.jump(continuation);
 4267 
 4268             m_out.appendTo(continuation, lastNext);
 4269             setInt32(m_out.phi(Int32, ropeLength, nonRopeLength));
 4270             return;
 4271         }
 4272 
 4273         case Array::DirectArguments: {
 4274             LValue arguments = lowCell(m_node-&gt;child1());
 4275             speculate(
 4276                 ExoticObjectMode, noValue(), nullptr,
 4277                 m_out.notNull(m_out.loadPtr(arguments, m_heaps.DirectArguments_mappedArguments)));
 4278             setInt32(m_out.load32NonNegative(arguments, m_heaps.DirectArguments_length));
 4279             return;
 4280         }
 4281 
 4282         case Array::ScopedArguments: {
 4283             LValue arguments = lowCell(m_node-&gt;child1());
<a name="179" id="anc179"></a>
 4284             speculate(
 4285                 ExoticObjectMode, noValue(), nullptr,
<a name="180" id="anc180"></a><span class="line-modified"> 4286                 m_out.notZero32(m_out.load8ZeroExt32(arguments, m_heaps.ScopedArguments_overrodeThings)));</span>
<span class="line-modified"> 4287             setInt32(m_out.load32NonNegative(arguments, m_heaps.ScopedArguments_totalLength));</span>
 4288             return;
 4289         }
 4290 
 4291         default:
 4292             if (m_node-&gt;arrayMode().isSomeTypedArrayView()) {
 4293                 setInt32(
 4294                     m_out.load32NonNegative(lowCell(m_node-&gt;child1()), m_heaps.JSArrayBufferView_length));
 4295                 return;
 4296             }
 4297 
 4298             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4299             return;
 4300         }
 4301     }
 4302 
 4303     void compileGetVectorLength()
 4304     {
 4305         switch (m_node-&gt;arrayMode().type()) {
 4306         case Array::ArrayStorage:
 4307         case Array::SlowPutArrayStorage:
 4308             setInt32(m_out.load32NonNegative(lowStorage(m_node-&gt;child2()), m_heaps.ArrayStorage_vectorLength));
 4309             return;
 4310         default:
 4311             return;
 4312         }
 4313     }
 4314 
 4315     void compileCheckInBounds()
 4316     {
 4317         speculate(
 4318             OutOfBounds, noValue(), 0,
 4319             m_out.aboveOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 4320 
 4321         // Even though we claim to have JSValue result, no user of us should
 4322         // depend on our value. Users of this node just need to maintain that
 4323         // we dominate them.
 4324     }
 4325 
 4326     void compileGetByVal()
 4327     {
<a name="181" id="anc181"></a><span class="line-added"> 4328         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 4329         switch (m_node-&gt;arrayMode().type()) {
 4330         case Array::Int32:
 4331         case Array::Contiguous: {
 4332             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4333             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4334 
 4335             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
 4336                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
 4337 
 4338             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4339 
 4340             if (m_node-&gt;arrayMode().isInBounds()) {
 4341                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4342                 LValue isHole = m_out.isZero64(result);
 4343                 if (m_node-&gt;arrayMode().isSaneChain()) {
 4344                     DFG_ASSERT(
 4345                         m_graph, m_node, m_node-&gt;arrayMode().type() == Array::Contiguous, m_node-&gt;arrayMode().type());
 4346                     result = m_out.select(
 4347                         isHole, m_out.constInt64(JSValue::encode(jsUndefined())), result);
 4348                 } else
 4349                     speculate(LoadFromHole, noValue(), 0, isHole);
 4350                 setJSValue(result);
 4351                 return;
 4352             }
 4353 
 4354             LBasicBlock fastCase = m_out.newBlock();
 4355             LBasicBlock slowCase = m_out.newBlock();
 4356             LBasicBlock continuation = m_out.newBlock();
 4357 
 4358             m_out.branch(
 4359                 m_out.aboveOrEqual(
 4360                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 4361                 rarely(slowCase), usually(fastCase));
 4362 
 4363             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 4364 
 4365             LValue fastResultValue = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4366             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 4367             m_out.branch(
 4368                 m_out.isZero64(fastResultValue), rarely(slowCase), usually(continuation));
 4369 
 4370             m_out.appendTo(slowCase, continuation);
<a name="182" id="anc182"></a><span class="line-modified"> 4371             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>

 4372             m_out.jump(continuation);
 4373 
 4374             m_out.appendTo(continuation, lastNext);
 4375             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4376             return;
 4377         }
 4378 
 4379         case Array::Double: {
 4380             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4381             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4382             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4383 
 4384             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
 4385 
 4386             if (m_node-&gt;arrayMode().isInBounds()) {
 4387                 LValue result = m_out.loadDouble(
 4388                     baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4389 
 4390                 if (!m_node-&gt;arrayMode().isSaneChain()) {
 4391                     speculate(
 4392                         LoadFromHole, noValue(), 0,
 4393                         m_out.doubleNotEqualOrUnordered(result, result));
 4394                 }
 4395                 setDouble(result);
 4396                 break;
 4397             }
 4398 
 4399             LBasicBlock inBounds = m_out.newBlock();
 4400             LBasicBlock boxPath = m_out.newBlock();
 4401             LBasicBlock slowCase = m_out.newBlock();
 4402             LBasicBlock continuation = m_out.newBlock();
 4403 
 4404             m_out.branch(
 4405                 m_out.aboveOrEqual(
 4406                     index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
 4407                 rarely(slowCase), usually(inBounds));
 4408 
 4409             LBasicBlock lastNext = m_out.appendTo(inBounds, boxPath);
 4410             LValue doubleValue = m_out.loadDouble(
 4411                 baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4412             m_out.branch(
 4413                 m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue),
 4414                 rarely(slowCase), usually(boxPath));
 4415 
 4416             m_out.appendTo(boxPath, slowCase);
 4417             ValueFromBlock fastResult = m_out.anchor(boxDouble(doubleValue));
 4418             m_out.jump(continuation);
 4419 
 4420             m_out.appendTo(slowCase, continuation);
<a name="183" id="anc183"></a><span class="line-modified"> 4421             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>

 4422             m_out.jump(continuation);
 4423 
 4424             m_out.appendTo(continuation, lastNext);
 4425             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4426             return;
 4427         }
 4428 
 4429         case Array::Undecided: {
 4430             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4431 
 4432             speculate(OutOfBounds, noValue(), m_node, m_out.lessThan(index, m_out.int32Zero));
<a name="184" id="anc184"></a><span class="line-modified"> 4433             setJSValue(m_out.constInt64(JSValue::ValueUndefined));</span>
 4434             return;
 4435         }
 4436 
 4437         case Array::DirectArguments: {
 4438             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4439             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4440 
 4441             speculate(
 4442                 ExoticObjectMode, noValue(), nullptr,
 4443                 m_out.notNull(m_out.loadPtr(base, m_heaps.DirectArguments_mappedArguments)));
 4444 
 4445             LValue length = m_out.load32NonNegative(base, m_heaps.DirectArguments_length);
 4446             auto isOutOfBounds = m_out.aboveOrEqual(index, length);
 4447             if (m_node-&gt;arrayMode().isInBounds()) {
 4448                 speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4449                 TypedPointer address = m_out.baseIndex(
 4450                     m_heaps.DirectArguments_storage, base, m_out.zeroExtPtr(index));
 4451                 setJSValue(m_out.load64(address));
 4452                 return;
 4453             }
 4454 
 4455             LBasicBlock inBounds = m_out.newBlock();
 4456             LBasicBlock slowCase = m_out.newBlock();
 4457             LBasicBlock continuation = m_out.newBlock();
 4458 
 4459             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBounds));
 4460 
 4461             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4462             TypedPointer address = m_out.baseIndex(
 4463                 m_heaps.DirectArguments_storage,
 4464                 base,
 4465                 m_out.zeroExt(index, pointerType()));
 4466             ValueFromBlock fastResult = m_out.anchor(m_out.load64(address));
 4467             m_out.jump(continuation);
 4468 
 4469             m_out.appendTo(slowCase, continuation);
<a name="185" id="anc185"></a><span class="line-modified"> 4470             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>

 4471             m_out.jump(continuation);
 4472 
 4473             m_out.appendTo(continuation, lastNext);
 4474             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4475             return;
 4476         }
 4477 
 4478         case Array::ScopedArguments: {
 4479             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4480             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4481 
<a name="186" id="anc186"></a>


 4482             speculate(
 4483                 ExoticObjectMode, noValue(), nullptr,
<a name="187" id="anc187"></a><span class="line-modified"> 4484                 m_out.aboveOrEqual(</span>
<span class="line-added"> 4485                     index,</span>
<span class="line-added"> 4486                     m_out.load32NonNegative(base, m_heaps.ScopedArguments_totalLength)));</span>
 4487 
 4488             LValue table = m_out.loadPtr(base, m_heaps.ScopedArguments_table);
 4489             LValue namedLength = m_out.load32(table, m_heaps.ScopedArgumentsTable_length);
 4490 
 4491             LBasicBlock namedCase = m_out.newBlock();
 4492             LBasicBlock overflowCase = m_out.newBlock();
 4493             LBasicBlock continuation = m_out.newBlock();
 4494 
 4495             m_out.branch(
 4496                 m_out.aboveOrEqual(index, namedLength), unsure(overflowCase), unsure(namedCase));
 4497 
 4498             LBasicBlock lastNext = m_out.appendTo(namedCase, overflowCase);
 4499 
 4500             LValue scope = m_out.loadPtr(base, m_heaps.ScopedArguments_scope);
 4501             LValue arguments = m_out.loadPtr(table, m_heaps.ScopedArgumentsTable_arguments);
 4502 
 4503             TypedPointer address = m_out.baseIndex(
 4504                 m_heaps.scopedArgumentsTableArguments, arguments, m_out.zeroExtPtr(index));
 4505             LValue scopeOffset = m_out.load32(address);
 4506 
 4507             speculate(
 4508                 ExoticObjectMode, noValue(), nullptr,
 4509                 m_out.equal(scopeOffset, m_out.constInt32(ScopeOffset::invalidOffset)));
 4510 
 4511             address = m_out.baseIndex(
 4512                 m_heaps.JSLexicalEnvironment_variables, scope, m_out.zeroExtPtr(scopeOffset));
 4513             ValueFromBlock namedResult = m_out.anchor(m_out.load64(address));
 4514             m_out.jump(continuation);
 4515 
 4516             m_out.appendTo(overflowCase, continuation);
 4517 
<a name="188" id="anc188"></a><span class="line-added"> 4518             LValue storage = m_out.loadPtr(base, m_heaps.ScopedArguments_storage);</span>
 4519             address = m_out.baseIndex(
 4520                 m_heaps.ScopedArguments_Storage_storage, storage,
 4521                 m_out.zeroExtPtr(m_out.sub(index, namedLength)));
 4522             LValue overflowValue = m_out.load64(address);
 4523             speculate(ExoticObjectMode, noValue(), nullptr, m_out.isZero64(overflowValue));
 4524             ValueFromBlock overflowResult = m_out.anchor(overflowValue);
 4525             m_out.jump(continuation);
 4526 
 4527             m_out.appendTo(continuation, lastNext);
<a name="189" id="anc189"></a><span class="line-modified"> 4528             setJSValue(m_out.phi(Int64, namedResult, overflowResult));</span>




 4529             return;
 4530         }
 4531 
 4532         case Array::Generic: {
<a name="190" id="anc190"></a><span class="line-modified"> 4533             if (m_graph.m_slowGetByVal.contains(m_node)) {</span>
<span class="line-modified"> 4534                 if (m_graph.varArgChild(m_node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified"> 4535                     if (m_graph.varArgChild(m_node, 1).useKind() == StringUse) {</span>
<span class="line-modified"> 4536                         setJSValue(vmCall(</span>
<span class="line-modified"> 4537                             Int64, operationGetByValObjectString, weakPointer(globalObject),</span>
<span class="line-modified"> 4538                             lowObject(m_graph.varArgChild(m_node, 0)), lowString(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified"> 4539                         return;</span>
<span class="line-added"> 4540                     }</span>
 4541 
<a name="191" id="anc191"></a><span class="line-modified"> 4542                     if (m_graph.varArgChild(m_node, 1).useKind() == SymbolUse) {</span>
<span class="line-modified"> 4543                         setJSValue(vmCall(</span>
<span class="line-modified"> 4544                             Int64, operationGetByValObjectSymbol, weakPointer(globalObject),</span>
<span class="line-modified"> 4545                             lowObject(m_graph.varArgChild(m_node, 0)), lowSymbol(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-modified"> 4546                         return;</span>
<span class="line-added"> 4547                     }</span>
 4548                 }
<a name="192" id="anc192"></a><span class="line-added"> 4549 </span>
<span class="line-added"> 4550                 setJSValue(vmCall(</span>
<span class="line-added"> 4551                     Int64, operationGetByVal, weakPointer(globalObject),</span>
<span class="line-added"> 4552                     lowJSValue(m_graph.varArgChild(m_node, 0)), lowJSValue(m_graph.varArgChild(m_node, 1))));</span>
<span class="line-added"> 4553                 return;</span>
 4554             }
<a name="193" id="anc193"></a><span class="line-modified"> 4555 </span>
<span class="line-modified"> 4556             Node* node = m_node;</span>
<span class="line-modified"> 4557 </span>
<span class="line-added"> 4558             LValue base = lowJSValue(m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="line-added"> 4559             LValue property = lowJSValue(m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="line-added"> 4560 </span>
<span class="line-added"> 4561             speculate(m_graph.varArgChild(node, 0));</span>
<span class="line-added"> 4562             speculate(m_graph.varArgChild(node, 1));</span>
<span class="line-added"> 4563             bool baseIsCell = abstractValue(m_graph.varArgChild(node, 0)).isType(SpecCell);</span>
<span class="line-added"> 4564             bool propertyIsString = false;</span>
<span class="line-added"> 4565             bool propertyIsInt32 = false;</span>
<span class="line-added"> 4566             bool propertyIsSymbol = false;</span>
<span class="line-added"> 4567             if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="line-added"> 4568                 propertyIsString = true;</span>
<span class="line-added"> 4569             else if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="line-added"> 4570                 propertyIsInt32 = true;</span>
<span class="line-added"> 4571             else if (abstractValue(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="line-added"> 4572                 propertyIsSymbol = true;</span>
<span class="line-added"> 4573 </span>
<span class="line-added"> 4574             PatchpointValue* patchpoint = m_out.patchpoint(Int64);</span>
<span class="line-added"> 4575             patchpoint-&gt;appendSomeRegister(base);</span>
<span class="line-added"> 4576             patchpoint-&gt;appendSomeRegister(property);</span>
<span class="line-added"> 4577             patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-added"> 4578             patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
<span class="line-added"> 4579             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());</span>
<span class="line-added"> 4580 </span>
<span class="line-added"> 4581             RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);</span>
<span class="line-added"> 4582 </span>
<span class="line-added"> 4583             State* state = &amp;m_ftlState;</span>
<span class="line-added"> 4584             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {</span>
<span class="line-added"> 4585                 AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added"> 4586 </span>
<span class="line-added"> 4587                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);</span>
<span class="line-added"> 4588 </span>
<span class="line-added"> 4589                 // This is the direct exit target for operation calls.</span>
<span class="line-added"> 4590                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);</span>
<span class="line-added"> 4591 </span>
<span class="line-added"> 4592                 // This is the exit for call IC&#39;s created by the IC for getters. We don&#39;t have</span>
<span class="line-added"> 4593                 // to do anything weird other than call this, since it will associate the exit with</span>
<span class="line-added"> 4594                 // the callsite index.</span>
<span class="line-added"> 4595                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);</span>
<span class="line-added"> 4596 </span>
<span class="line-added"> 4597                 GPRReg resultGPR = params[0].gpr();</span>
<span class="line-added"> 4598                 GPRReg baseGPR = params[1].gpr();</span>
<span class="line-added"> 4599                 GPRReg propertyGPR = params[2].gpr();</span>
<span class="line-added"> 4600 </span>
<span class="line-added"> 4601                 auto generator = Box&lt;JITGetByValGenerator&gt;::create(</span>
<span class="line-added"> 4602                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, params.unavailableRegisters(),</span>
<span class="line-added"> 4603                     JSValueRegs(baseGPR), JSValueRegs(propertyGPR), JSValueRegs(resultGPR));</span>
<span class="line-added"> 4604 </span>
<span class="line-added"> 4605                 generator-&gt;stubInfo()-&gt;propertyIsString = propertyIsString;</span>
<span class="line-added"> 4606                 generator-&gt;stubInfo()-&gt;propertyIsInt32 = propertyIsInt32;</span>
<span class="line-added"> 4607                 generator-&gt;stubInfo()-&gt;propertyIsSymbol = propertyIsSymbol;</span>
<span class="line-added"> 4608 </span>
<span class="line-added"> 4609                 CCallHelpers::Jump notCell;</span>
<span class="line-added"> 4610                 if (!baseIsCell)</span>
<span class="line-added"> 4611                     notCell = jit.branchIfNotCell(baseGPR);</span>
<span class="line-added"> 4612 </span>
<span class="line-added"> 4613                 generator-&gt;generateFastPath(jit);</span>
<span class="line-added"> 4614                 CCallHelpers::Label done = jit.label();</span>
<span class="line-added"> 4615 </span>
<span class="line-added"> 4616                 params.addLatePath([=] (CCallHelpers&amp; jit) {</span>
<span class="line-added"> 4617                     AllowMacroScratchRegisterUsage allowScratch(jit);</span>
<span class="line-added"> 4618 </span>
<span class="line-added"> 4619                     if (notCell.isSet())</span>
<span class="line-added"> 4620                         notCell.link(&amp;jit);</span>
<span class="line-added"> 4621                     generator-&gt;slowPathJump().link(&amp;jit);</span>
<span class="line-added"> 4622                     CCallHelpers::Label slowPathBegin = jit.label();</span>
<span class="line-added"> 4623                     CCallHelpers::Call slowPathCall = callOperation(</span>
<span class="line-added"> 4624                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,</span>
<span class="line-added"> 4625                         exceptions.get(), operationGetByValOptimize, resultGPR,</span>
<span class="line-added"> 4626                         jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
<span class="line-added"> 4627                         CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), CCallHelpers::TrustedImmPtr(nullptr), baseGPR, propertyGPR).call();</span>
<span class="line-added"> 4628                     jit.jump().linkTo(done, &amp;jit);</span>
<span class="line-added"> 4629 </span>
<span class="line-added"> 4630                     generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);</span>
<span class="line-added"> 4631 </span>
<span class="line-added"> 4632                     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-added"> 4633                         generator-&gt;finalize(linkBuffer, linkBuffer);</span>
<span class="line-added"> 4634                     });</span>
<span class="line-added"> 4635                 });</span>
<span class="line-added"> 4636             });</span>
<span class="line-added"> 4637 </span>
<span class="line-added"> 4638             setJSValue(patchpoint);</span>
 4639             return;
 4640         }
 4641 
 4642         case Array::ArrayStorage:
 4643         case Array::SlowPutArrayStorage: {
 4644             LValue base = lowCell(m_graph.varArgChild(m_node, 0));
 4645             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4646             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4647 
 4648             IndexedAbstractHeap&amp; heap = m_heaps.ArrayStorage_vector;
 4649 
 4650             if (m_node-&gt;arrayMode().isInBounds()) {
 4651                 LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4652                 speculate(LoadFromHole, noValue(), 0, m_out.isZero64(result));
 4653                 setJSValue(result);
 4654                 break;
 4655             }
 4656 
 4657             LBasicBlock inBounds = m_out.newBlock();
 4658             LBasicBlock slowCase = m_out.newBlock();
 4659             LBasicBlock continuation = m_out.newBlock();
 4660 
 4661             m_out.branch(
 4662                 m_out.aboveOrEqual(index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
 4663                 rarely(slowCase), usually(inBounds));
 4664 
 4665             LBasicBlock lastNext = m_out.appendTo(inBounds, slowCase);
 4666             LValue result = m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
 4667             ValueFromBlock fastResult = m_out.anchor(result);
 4668             m_out.branch(
 4669                 m_out.isZero64(result),
 4670                 rarely(slowCase), usually(continuation));
 4671 
 4672             m_out.appendTo(slowCase, continuation);
 4673             ValueFromBlock slowResult = m_out.anchor(
<a name="194" id="anc194"></a><span class="line-modified"> 4674                 vmCall(Int64, operationGetByValObjectInt, weakPointer(globalObject), base, index));</span>
 4675             m_out.jump(continuation);
 4676 
 4677             m_out.appendTo(continuation, lastNext);
 4678             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 4679             return;
 4680         }
 4681 
 4682         case Array::String: {
 4683             compileStringCharAt();
 4684             return;
 4685         }
 4686 
 4687         case Array::Int8Array:
 4688         case Array::Int16Array:
 4689         case Array::Int32Array:
 4690         case Array::Uint8Array:
 4691         case Array::Uint8ClampedArray:
 4692         case Array::Uint16Array:
 4693         case Array::Uint32Array:
 4694         case Array::Float32Array:
 4695         case Array::Float64Array: {
 4696             LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
 4697             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
 4698 
 4699             TypedArrayType type = m_node-&gt;arrayMode().typedArrayType();
 4700             ASSERT(isTypedView(type));
 4701             {
 4702                 TypedPointer pointer = pointerIntoTypedArray(storage, index, type);
 4703 
 4704                 if (isInt(type)) {
 4705                     LValue result = loadFromIntTypedArray(pointer, type);
 4706                     bool canSpeculate = true;
 4707                     setIntTypedArrayLoadResult(result, type, canSpeculate);
 4708                     return;
 4709                 }
 4710 
 4711                 ASSERT(isFloat(type));
 4712 
 4713                 LValue result;
 4714                 switch (type) {
 4715                 case TypeFloat32:
 4716                     result = m_out.floatToDouble(m_out.loadFloat(pointer));
 4717                     break;
 4718                 case TypeFloat64:
 4719                     result = m_out.loadDouble(pointer);
 4720                     break;
 4721                 default:
 4722                     DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 4723                 }
 4724 
 4725                 setDouble(result);
 4726                 return;
 4727             }
 4728         }
 4729 
 4730         case Array::AnyTypedArray:
 4731         case Array::ForceExit:
 4732         case Array::SelectUsingArguments:
 4733         case Array::SelectUsingPredictions:
 4734         case Array::Unprofiled:
 4735             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4736             return;
 4737         }
 4738     }
 4739 
 4740     void compileGetMyArgumentByVal()
 4741     {
 4742         InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 4743 
 4744         LValue originalIndex = lowInt32(m_node-&gt;child2());
 4745 
 4746         LValue numberOfArgsIncludingThis;
 4747         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
 4748             numberOfArgsIncludingThis = m_out.constInt32(inlineCallFrame-&gt;argumentCountIncludingThis);
 4749         else {
 4750             VirtualRegister argumentCountRegister = AssemblyHelpers::argumentCount(inlineCallFrame);
 4751             numberOfArgsIncludingThis = m_out.load32(payloadFor(argumentCountRegister));
 4752         }
 4753 
 4754         LValue numberOfArgs = m_out.sub(numberOfArgsIncludingThis, m_out.int32One);
 4755         LValue indexToCheck = originalIndex;
 4756         LValue numberOfArgumentsToSkip = m_out.int32Zero;
 4757         if (m_node-&gt;numberOfArgumentsToSkip()) {
 4758             numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 4759             CheckValue* check = m_out.speculateAdd(indexToCheck, numberOfArgumentsToSkip);
 4760             blessSpeculation(check, Overflow, noValue(), nullptr, m_origin);
 4761             indexToCheck = check;
 4762         }
 4763 
 4764         LValue isOutOfBounds = m_out.bitOr(m_out.aboveOrEqual(indexToCheck, numberOfArgs), m_out.below(indexToCheck, numberOfArgumentsToSkip));
 4765         LBasicBlock continuation = nullptr;
 4766         LBasicBlock lastNext = nullptr;
 4767         ValueFromBlock slowResult;
 4768         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4769             LBasicBlock normalCase = m_out.newBlock();
 4770             continuation = m_out.newBlock();
 4771 
 4772             slowResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined())));
 4773             m_out.branch(isOutOfBounds, unsure(continuation), unsure(normalCase));
 4774 
 4775             lastNext = m_out.appendTo(normalCase, continuation);
 4776         } else
 4777             speculate(OutOfBounds, noValue(), nullptr, isOutOfBounds);
 4778 
 4779         LValue index = m_out.add(indexToCheck, m_out.int32One);
 4780 
 4781         TypedPointer base;
 4782         if (inlineCallFrame) {
 4783             if (inlineCallFrame-&gt;argumentCountIncludingThis &gt; 1)
 4784                 base = addressFor(inlineCallFrame-&gt;argumentsWithFixup[0].virtualRegister());
 4785         } else
<a name="195" id="anc195"></a><span class="line-modified"> 4786             base = addressFor(virtualRegisterForArgumentIncludingThis(0));</span>
 4787 
 4788         LValue result;
 4789         if (base) {
 4790             LValue pointer = m_out.baseIndex(
 4791                 base.value(), m_out.zeroExt(index, pointerType()), ScaleEight);
 4792             result = m_out.load64(TypedPointer(m_heaps.variables.atAnyIndex(), pointer));
<a name="196" id="anc196"></a>
 4793         } else
 4794             result = m_out.constInt64(JSValue::encode(jsUndefined()));
 4795 
 4796         if (m_node-&gt;op() == GetMyArgumentByValOutOfBounds) {
 4797             ValueFromBlock normalResult = m_out.anchor(result);
 4798             m_out.jump(continuation);
 4799 
 4800             m_out.appendTo(continuation, lastNext);
 4801             result = m_out.phi(Int64, slowResult, normalResult);
 4802         }
 4803 
 4804         setJSValue(result);
 4805     }
 4806 
 4807     void compilePutByVal()
 4808     {
<a name="197" id="anc197"></a><span class="line-added"> 4809         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 4810         Edge child1 = m_graph.varArgChild(m_node, 0);
 4811         Edge child2 = m_graph.varArgChild(m_node, 1);
 4812         Edge child3 = m_graph.varArgChild(m_node, 2);
 4813         Edge child4 = m_graph.varArgChild(m_node, 3);
 4814         Edge child5 = m_graph.varArgChild(m_node, 4);
 4815 
 4816         ArrayMode arrayMode = m_node-&gt;arrayMode().modeForPut();
 4817         switch (arrayMode.type()) {
 4818         case Array::Generic: {
 4819             if (child1.useKind() == CellUse) {
<a name="198" id="anc198"></a><span class="line-modified"> 4820                 V_JITOperation_GCCJ operation = nullptr;</span>
 4821                 if (child2.useKind() == StringUse) {
 4822                     if (m_node-&gt;op() == PutByValDirect) {
 4823                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4824                             operation = operationPutByValDirectCellStringStrict;
 4825                         else
 4826                             operation = operationPutByValDirectCellStringNonStrict;
 4827                     } else {
 4828                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4829                             operation = operationPutByValCellStringStrict;
 4830                         else
 4831                             operation = operationPutByValCellStringNonStrict;
 4832                     }
<a name="199" id="anc199"></a><span class="line-modified"> 4833                     vmCall(Void, operation, weakPointer(globalObject), lowCell(child1), lowString(child2), lowJSValue(child3));</span>
 4834                     return;
 4835                 }
 4836 
 4837                 if (child2.useKind() == SymbolUse) {
 4838                     if (m_node-&gt;op() == PutByValDirect) {
 4839                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4840                             operation = operationPutByValDirectCellSymbolStrict;
 4841                         else
 4842                             operation = operationPutByValDirectCellSymbolNonStrict;
 4843                     } else {
 4844                         if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4845                             operation = operationPutByValCellSymbolStrict;
 4846                         else
 4847                             operation = operationPutByValCellSymbolNonStrict;
 4848                     }
<a name="200" id="anc200"></a><span class="line-modified"> 4849                     vmCall(Void, operation, weakPointer(globalObject), lowCell(child1), lowSymbol(child2), lowJSValue(child3));</span>
 4850                     return;
 4851                 }
 4852             }
 4853 
<a name="201" id="anc201"></a><span class="line-modified"> 4854             V_JITOperation_GJJJ operation;</span>
 4855             if (m_node-&gt;op() == PutByValDirect) {
 4856                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4857                     operation = operationPutByValDirectStrict;
 4858                 else
 4859                     operation = operationPutByValDirectNonStrict;
 4860             } else {
 4861                 if (m_graph.isStrictModeFor(m_node-&gt;origin.semantic))
 4862                     operation = operationPutByValStrict;
 4863                 else
 4864                     operation = operationPutByValNonStrict;
 4865             }
 4866 
 4867             vmCall(
<a name="202" id="anc202"></a><span class="line-modified"> 4868                 Void, operation, weakPointer(globalObject),</span>
 4869                 lowJSValue(child1), lowJSValue(child2), lowJSValue(child3));
 4870             return;
 4871         }
 4872 
 4873         default:
 4874             break;
 4875         }
 4876 
 4877         LValue base = lowCell(child1);
 4878         LValue index = lowInt32(child2);
 4879         LValue storage = lowStorage(child4);
 4880 
 4881         switch (arrayMode.type()) {
 4882         case Array::Int32:
 4883         case Array::Double:
 4884         case Array::Contiguous: {
 4885             LBasicBlock continuation = m_out.newBlock();
 4886             LBasicBlock outerLastNext = m_out.appendTo(m_out.m_block, continuation);
 4887 
 4888             switch (arrayMode.type()) {
 4889             case Array::Int32:
 4890             case Array::Contiguous: {
 4891                 LValue value = lowJSValue(child3, ManualOperandSpeculation);
 4892 
 4893                 if (arrayMode.type() == Array::Int32)
 4894                     FTL_TYPE_CHECK(jsValueValue(value), child3, SpecInt32Only, isNotInt32(value));
 4895 
 4896                 TypedPointer elementPointer = m_out.baseIndex(
 4897                     arrayMode.type() == Array::Int32 ?
 4898                     m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties,
 4899                     storage, m_out.zeroExtPtr(index), provenValue(child2));
 4900 
 4901                 if (m_node-&gt;op() == PutByValAlias) {
 4902                     m_out.store64(value, elementPointer);
 4903                     break;
 4904                 }
 4905 
 4906                 contiguousPutByValOutOfBounds(
 4907                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4908                         ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4909                         : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
 4910                     base, storage, index, value, continuation);
 4911 
 4912                 m_out.store64(value, elementPointer);
 4913                 break;
 4914             }
 4915 
 4916             case Array::Double: {
 4917                 LValue value = lowDouble(child3);
 4918 
 4919                 FTL_TYPE_CHECK(
 4920                     doubleValue(value), child3, SpecDoubleReal,
 4921                     m_out.doubleNotEqualOrUnordered(value, value));
 4922 
 4923                 TypedPointer elementPointer = m_out.baseIndex(
 4924                     m_heaps.indexedDoubleProperties, storage, m_out.zeroExtPtr(index),
 4925                     provenValue(child2));
 4926 
 4927                 if (m_node-&gt;op() == PutByValAlias) {
 4928                     m_out.storeDouble(value, elementPointer);
 4929                     break;
 4930                 }
 4931 
 4932                 contiguousPutByValOutOfBounds(
 4933                     m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4934                         ? (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 4935                         : (m_node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
 4936                     base, storage, index, value, continuation);
 4937 
 4938                 m_out.storeDouble(value, elementPointer);
 4939                 break;
 4940             }
 4941 
 4942             default:
 4943                 DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 4944             }
 4945 
 4946             m_out.jump(continuation);
 4947             m_out.appendTo(continuation, outerLastNext);
 4948             return;
 4949         }
 4950 
 4951         case Array::ArrayStorage:
 4952         case Array::SlowPutArrayStorage: {
 4953             LValue value = lowJSValue(child3);
 4954 
 4955             TypedPointer elementPointer = m_out.baseIndex(
 4956                 m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(index),
 4957                 provenValue(child2));
 4958 
 4959             if (m_node-&gt;op() == PutByValAlias) {
 4960                 m_out.store64(value, elementPointer);
 4961                 return;
 4962             }
 4963 
 4964             if (arrayMode.isInBounds()) {
 4965                 speculate(StoreToHole, noValue(), 0, m_out.isZero64(m_out.load64(elementPointer)));
 4966                 m_out.store64(value, elementPointer);
 4967                 return;
 4968             }
 4969 
 4970             LValue isOutOfBounds = m_out.aboveOrEqual(
 4971                 index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength));
 4972 
 4973             auto slowPathFunction = m_graph.isStrictModeFor(m_node-&gt;origin.semantic)
 4974                 ? (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
 4975                 : (m_node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict);
 4976             if (!arrayMode.isOutOfBounds()) {
 4977                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
 4978                 isOutOfBounds = m_out.booleanFalse;
 4979             }
 4980 
 4981             LBasicBlock inBoundCase = m_out.newBlock();
 4982             LBasicBlock slowCase = m_out.newBlock();
 4983             LBasicBlock holeCase = m_out.newBlock();
 4984             LBasicBlock doStoreCase = m_out.newBlock();
 4985             LBasicBlock lengthUpdateCase = m_out.newBlock();
 4986             LBasicBlock continuation = m_out.newBlock();
 4987 
 4988             m_out.branch(isOutOfBounds, rarely(slowCase), usually(inBoundCase));
 4989 
 4990             LBasicBlock lastNext = m_out.appendTo(slowCase, inBoundCase);
 4991             vmCall(
<a name="203" id="anc203"></a><span class="line-modified"> 4992                 Void, slowPathFunction,</span>
<span class="line-modified"> 4993                 weakPointer(globalObject), base, index, value);</span>
 4994             m_out.jump(continuation);
 4995 
 4996 
 4997             if (arrayMode.isSlowPut()) {
 4998                 m_out.appendTo(inBoundCase, doStoreCase);
 4999                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(slowCase), usually(doStoreCase));
 5000             } else {
 5001                 m_out.appendTo(inBoundCase, holeCase);
 5002                 m_out.branch(m_out.isZero64(m_out.load64(elementPointer)), rarely(holeCase), usually(doStoreCase));
 5003 
 5004                 m_out.appendTo(holeCase, lengthUpdateCase);
 5005                 m_out.store32(
 5006                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5007                     storage, m_heaps.ArrayStorage_numValuesInVector);
 5008                 m_out.branch(
 5009                     m_out.below(
 5010                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_publicLength)),
 5011                     unsure(doStoreCase), unsure(lengthUpdateCase));
 5012 
 5013                 m_out.appendTo(lengthUpdateCase, doStoreCase);
 5014                 m_out.store32(
 5015                     m_out.add(index, m_out.int32One),
 5016                     storage, m_heaps.ArrayStorage_publicLength);
 5017                 m_out.jump(doStoreCase);
 5018             }
 5019 
 5020             m_out.appendTo(doStoreCase, continuation);
 5021             m_out.store64(value, elementPointer);
 5022             m_out.jump(continuation);
 5023 
 5024             m_out.appendTo(continuation, lastNext);
 5025             return;
 5026         }
 5027 
 5028         case Array::Int8Array:
 5029         case Array::Int16Array:
 5030         case Array::Int32Array:
 5031         case Array::Uint8Array:
 5032         case Array::Uint8ClampedArray:
 5033         case Array::Uint16Array:
 5034         case Array::Uint32Array:
 5035         case Array::Float32Array:
 5036         case Array::Float64Array: {
 5037             TypedArrayType type = arrayMode.typedArrayType();
 5038 
 5039             ASSERT(isTypedView(type));
 5040             {
 5041                 TypedPointer pointer = TypedPointer(
 5042                     m_heaps.typedArrayProperties,
 5043                     m_out.add(
 5044                         storage,
 5045                         m_out.shl(
 5046                             m_out.zeroExt(index, pointerType()),
 5047                             m_out.constIntPtr(logElementSize(type)))));
 5048 
 5049                 LValue valueToStore;
 5050 
 5051                 if (isInt(type)) {
 5052                     LValue intValue = getIntTypedArrayStoreOperand(child3, isClamped(type));
 5053 
 5054                     valueToStore = intValue;
 5055                 } else /* !isInt(type) */ {
 5056                     LValue value = lowDouble(child3);
 5057                     switch (type) {
 5058                     case TypeFloat32:
 5059                         valueToStore = m_out.doubleToFloat(value);
 5060                         break;
 5061                     case TypeFloat64:
 5062                         valueToStore = value;
 5063                         break;
 5064                     default:
 5065                         DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
 5066                     }
 5067                 }
 5068 
 5069                 if (arrayMode.isInBounds() || m_node-&gt;op() == PutByValAlias)
 5070                     m_out.store(valueToStore, pointer, storeType(type));
 5071                 else {
 5072                     LBasicBlock isInBounds = m_out.newBlock();
 5073                     LBasicBlock isOutOfBounds = m_out.newBlock();
 5074                     LBasicBlock continuation = m_out.newBlock();
 5075 
 5076                     m_out.branch(
 5077                         m_out.aboveOrEqual(index, lowInt32(child5)),
 5078                         unsure(isOutOfBounds), unsure(isInBounds));
 5079 
 5080                     LBasicBlock lastNext = m_out.appendTo(isInBounds, isOutOfBounds);
 5081                     m_out.store(valueToStore, pointer, storeType(type));
 5082                     m_out.jump(continuation);
 5083 
 5084                     m_out.appendTo(isOutOfBounds, continuation);
 5085                     speculateTypedArrayIsNotNeutered(base);
 5086                     m_out.jump(continuation);
 5087 
 5088                     m_out.appendTo(continuation, lastNext);
 5089                 }
 5090 
 5091                 return;
 5092             }
 5093         }
 5094 
 5095         case Array::AnyTypedArray:
 5096         case Array::String:
 5097         case Array::DirectArguments:
 5098         case Array::ForceExit:
 5099         case Array::Generic:
 5100         case Array::ScopedArguments:
 5101         case Array::SelectUsingArguments:
 5102         case Array::SelectUsingPredictions:
 5103         case Array::Undecided:
 5104         case Array::Unprofiled:
 5105             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5106             break;
 5107         }
 5108     }
 5109 
 5110     void compilePutAccessorById()
 5111     {
<a name="204" id="anc204"></a><span class="line-added"> 5112         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5113         LValue base = lowCell(m_node-&gt;child1());
 5114         LValue accessor = lowCell(m_node-&gt;child2());
 5115         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 5116         vmCall(
 5117             Void,
<a name="205" id="anc205"></a><span class="line-modified"> 5118             m_node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById,</span>
<span class="line-modified"> 5119             weakPointer(globalObject), base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
 5120     }
 5121 
 5122     void compilePutGetterSetterById()
 5123     {
<a name="206" id="anc206"></a><span class="line-added"> 5124         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5125         LValue base = lowCell(m_node-&gt;child1());
 5126         LValue getter = lowJSValue(m_node-&gt;child2());
 5127         LValue setter = lowJSValue(m_node-&gt;child3());
 5128         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
 5129         vmCall(
<a name="207" id="anc207"></a><span class="line-modified"> 5130             Void, operationPutGetterSetter,</span>
<span class="line-modified"> 5131             weakPointer(globalObject), base, m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;accessorAttributes()), getter, setter);</span>
 5132 
 5133     }
 5134 
 5135     void compilePutAccessorByVal()
 5136     {
<a name="208" id="anc208"></a><span class="line-added"> 5137         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5138         LValue base = lowCell(m_node-&gt;child1());
 5139         LValue subscript = lowJSValue(m_node-&gt;child2());
 5140         LValue accessor = lowCell(m_node-&gt;child3());
 5141         vmCall(
 5142             Void,
<a name="209" id="anc209"></a><span class="line-modified"> 5143             m_node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal,</span>
<span class="line-modified"> 5144             weakPointer(globalObject), base, subscript, m_out.constInt32(m_node-&gt;accessorAttributes()), accessor);</span>
 5145     }
 5146 
 5147     void compileDeleteById()
 5148     {
<a name="210" id="anc210"></a><span class="line-added"> 5149         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5150         LValue base = lowJSValue(m_node-&gt;child1());
 5151         auto uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="211" id="anc211"></a><span class="line-modified"> 5152         setBoolean(m_out.notZero64(vmCall(Int64, operationDeleteById, weakPointer(globalObject), base, m_out.constIntPtr(uid))));</span>
 5153     }
 5154 
 5155     void compileDeleteByVal()
 5156     {
<a name="212" id="anc212"></a><span class="line-added"> 5157         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5158         LValue base = lowJSValue(m_node-&gt;child1());
 5159         LValue subscript = lowJSValue(m_node-&gt;child2());
<a name="213" id="anc213"></a><span class="line-modified"> 5160         setBoolean(m_out.notZero64(vmCall(Int64, operationDeleteByVal, weakPointer(globalObject), base, subscript)));</span>
 5161     }
 5162 
 5163     void compileArrayPush()
 5164     {
<a name="214" id="anc214"></a><span class="line-added"> 5165         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5166         LValue base = lowCell(m_graph.varArgChild(m_node, 1));
 5167         LValue storage = lowStorage(m_graph.varArgChild(m_node, 0));
 5168         unsigned elementOffset = 2;
 5169         unsigned elementCount = m_node-&gt;numChildren() - elementOffset;
 5170 
 5171         switch (m_node-&gt;arrayMode().type()) {
 5172         case Array::Int32:
 5173         case Array::Contiguous:
 5174         case Array::Double: {
 5175             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 5176 
 5177             if (elementCount == 1) {
 5178                 LValue value;
 5179                 Output::StoreType storeType;
 5180 
 5181                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
 5182                 speculate(element);
 5183                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 5184                     value = lowJSValue(element, ManualOperandSpeculation);
 5185                     storeType = Output::Store64;
 5186                 } else {
 5187                     value = lowDouble(element);
 5188                     storeType = Output::StoreDouble;
 5189                 }
 5190 
 5191                 LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5192 
 5193                 LBasicBlock fastPath = m_out.newBlock();
 5194                 LBasicBlock slowPath = m_out.newBlock();
 5195                 LBasicBlock continuation = m_out.newBlock();
 5196 
 5197                 m_out.branch(
 5198                     m_out.aboveOrEqual(
 5199                         prevLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength)),
 5200                     unsure(slowPath), unsure(fastPath));
 5201 
 5202                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5203                 m_out.store(
 5204                     value, m_out.baseIndex(heap, storage, m_out.zeroExtPtr(prevLength)), storeType);
 5205                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 5206                 m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 5207 
 5208                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5209                 m_out.jump(continuation);
 5210 
 5211                 m_out.appendTo(slowPath, continuation);
<a name="215" id="anc215"></a><span class="line-modified"> 5212                 LValue result;</span>
 5213                 if (m_node-&gt;arrayMode().type() != Array::Double)
<a name="216" id="anc216"></a><span class="line-modified"> 5214                     result = vmCall(Int64, operationArrayPush, weakPointer(globalObject), value, base);</span>
 5215                 else
<a name="217" id="anc217"></a><span class="line-modified"> 5216                     result = vmCall(Int64, operationArrayPushDouble, weakPointer(globalObject), value, base);</span>
<span class="line-modified"> 5217                 ValueFromBlock slowResult = m_out.anchor(result);</span>

 5218                 m_out.jump(continuation);
 5219 
 5220                 m_out.appendTo(continuation, lastNext);
 5221                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5222                 return;
 5223             }
 5224 
 5225             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 5226                 Edge element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 5227                 speculate(element);
 5228             }
 5229 
 5230             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5231             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 5232 
 5233             LBasicBlock fastPath = m_out.newBlock();
 5234             LBasicBlock slowPath = m_out.newBlock();
 5235             LBasicBlock setup = m_out.newBlock();
 5236             LBasicBlock slowCallPath = m_out.newBlock();
 5237             LBasicBlock continuation = m_out.newBlock();
 5238 
 5239             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.Butterfly_vectorLength));
 5240 
 5241             m_out.branch(beyondVectorLength, unsure(slowPath), unsure(fastPath));
 5242 
 5243             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5244             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 5245             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight));
 5246             m_out.jump(setup);
 5247 
 5248             m_out.appendTo(slowPath, setup);
 5249             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 5250             static_assert(sizeof(EncodedJSValue) == sizeof(double), &quot;&quot;);
 5251             ASSERT(scratchSize);
 5252             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 5253             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5254             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 5255             m_out.jump(setup);
 5256 
 5257             m_out.appendTo(setup, slowCallPath);
 5258             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 5259             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 5260                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 5261 
 5262                 LValue value;
 5263                 Output::StoreType storeType;
 5264                 if (m_node-&gt;arrayMode().type() != Array::Double) {
 5265                     value = lowJSValue(element, ManualOperandSpeculation);
 5266                     storeType = Output::Store64;
 5267                 } else {
 5268                     value = lowDouble(element);
 5269                     storeType = Output::StoreDouble;
 5270                 }
 5271 
 5272                 m_out.store(value, m_out.baseIndex(heap, buffer, m_out.constInt32(elementIndex), jsNumber(elementIndex)), storeType);
 5273             }
 5274             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5275 
 5276             m_out.branch(beyondVectorLength, unsure(slowCallPath), unsure(continuation));
 5277 
 5278             m_out.appendTo(slowCallPath, continuation);
<a name="218" id="anc218"></a><span class="line-modified"> 5279             auto* operation = &amp;operationArrayPushMultiple;</span>
<span class="line-modified"> 5280             if (m_node-&gt;arrayMode().type() == Array::Double)</span>
<span class="line-modified"> 5281                 operation = &amp;operationArrayPushDoubleMultiple;</span>
<span class="line-modified"> 5282             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, weakPointer(globalObject), base, buffer, m_out.constInt32(elementCount)));</span>


 5283             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5284             m_out.jump(continuation);
 5285 
 5286             m_out.appendTo(continuation, lastNext);
 5287             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5288             return;
 5289         }
 5290 
 5291         case Array::ArrayStorage: {
 5292             // This ensures that the result of ArrayPush is Int32 in AI.
 5293             int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 5294 
 5295             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 5296             // Refuse to handle bizarre lengths.
 5297             speculate(Uncountable, noValue(), nullptr, m_out.above(prevLength, m_out.constInt32(largestPositiveInt32Length)));
 5298 
 5299             if (elementCount == 1) {
 5300                 Edge&amp; element = m_graph.varArgChild(m_node, elementOffset);
 5301 
 5302                 LValue value = lowJSValue(element);
 5303 
 5304                 LBasicBlock fastPath = m_out.newBlock();
 5305                 LBasicBlock slowPath = m_out.newBlock();
 5306                 LBasicBlock continuation = m_out.newBlock();
 5307 
 5308                 m_out.branch(
 5309                     m_out.aboveOrEqual(
 5310                         prevLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)),
 5311                     rarely(slowPath), usually(fastPath));
 5312 
 5313                 LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5314                 m_out.store64(
 5315                     value, m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(prevLength)));
 5316                 LValue newLength = m_out.add(prevLength, m_out.int32One);
 5317                 m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5318                 m_out.store32(
 5319                     m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5320                     storage, m_heaps.ArrayStorage_numValuesInVector);
 5321 
 5322                 ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5323                 m_out.jump(continuation);
 5324 
 5325                 m_out.appendTo(slowPath, continuation);
 5326                 ValueFromBlock slowResult = m_out.anchor(
<a name="219" id="anc219"></a><span class="line-modified"> 5327                     vmCall(Int64, operationArrayPush, weakPointer(globalObject), value, base));</span>
 5328                 m_out.jump(continuation);
 5329 
 5330                 m_out.appendTo(continuation, lastNext);
 5331                 setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5332                 return;
 5333             }
 5334 
 5335             LValue newLength = m_out.add(prevLength, m_out.constInt32(elementCount));
 5336 
 5337             LBasicBlock fastPath = m_out.newBlock();
 5338             LBasicBlock slowPath = m_out.newBlock();
 5339             LBasicBlock setup = m_out.newBlock();
 5340             LBasicBlock slowCallPath = m_out.newBlock();
 5341             LBasicBlock continuation = m_out.newBlock();
 5342 
 5343             LValue beyondVectorLength = m_out.above(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength));
 5344 
 5345             m_out.branch(beyondVectorLength, rarely(slowPath), usually(fastPath));
 5346 
 5347             LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 5348             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5349             m_out.store32(
 5350                 m_out.add(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.constInt32(elementCount)),
 5351                 storage, m_heaps.ArrayStorage_numValuesInVector);
 5352             ValueFromBlock fastBufferResult = m_out.anchor(m_out.baseIndex(storage, m_out.zeroExtPtr(prevLength), ScaleEight, ArrayStorage::vectorOffset()));
 5353             m_out.jump(setup);
 5354 
 5355             m_out.appendTo(slowPath, setup);
 5356             size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 5357             ASSERT(scratchSize);
 5358             ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 5359             m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5360             ValueFromBlock slowBufferResult = m_out.anchor(m_out.constIntPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 5361             m_out.jump(setup);
 5362 
 5363             m_out.appendTo(setup, slowCallPath);
 5364             LValue buffer = m_out.phi(pointerType(), fastBufferResult, slowBufferResult);
 5365             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 5366                 Edge&amp; element = m_graph.varArgChild(m_node, elementIndex + elementOffset);
 5367 
 5368                 LValue value = lowJSValue(element);
 5369                 m_out.store64(value, m_out.baseIndex(m_heaps.ArrayStorage_vector.atAnyIndex(), buffer, m_out.constIntPtr(elementIndex), ScaleEight));
 5370             }
 5371             ValueFromBlock fastResult = m_out.anchor(boxInt32(newLength));
 5372 
 5373             m_out.branch(beyondVectorLength, rarely(slowCallPath), usually(continuation));
 5374 
 5375             m_out.appendTo(slowCallPath, continuation);
<a name="220" id="anc220"></a><span class="line-modified"> 5376             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationArrayPushMultiple, weakPointer(globalObject), base, buffer, m_out.constInt32(elementCount)));</span>
 5377             m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 5378             m_out.jump(continuation);
 5379 
 5380             m_out.appendTo(continuation, lastNext);
 5381             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 5382             return;
 5383         }
 5384 
 5385         default:
 5386             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5387             return;
 5388         }
 5389     }
 5390 
 5391     std::pair&lt;LValue, LValue&gt; populateSliceRange(LValue start, LValue end, LValue length)
 5392     {
 5393         // end can be nullptr.
 5394         ASSERT(start);
 5395         ASSERT(length);
 5396 
 5397         auto pickIndex = [&amp;] (LValue index) {
 5398             return m_out.select(m_out.greaterThanOrEqual(index, m_out.int32Zero),
 5399                 m_out.select(m_out.above(index, length), length, index),
 5400                 m_out.select(m_out.lessThan(m_out.add(length, index), m_out.int32Zero), m_out.int32Zero, m_out.add(length, index)));
 5401         };
 5402 
 5403         LValue endBoundary = length;
 5404         if (end)
 5405             endBoundary = pickIndex(end);
 5406         LValue startIndex = pickIndex(start);
 5407         return std::make_pair(startIndex, endBoundary);
 5408     }
 5409 
 5410     void compileArraySlice()
 5411     {
 5412         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5413 
 5414         LValue sourceArray = lowCell(m_graph.varArgChild(m_node, 0));
 5415         LValue sourceStorage = lowStorage(m_graph.varArgChild(m_node, m_node-&gt;numChildren() - 1));
 5416         LValue inputLength = m_out.load32(sourceStorage, m_heaps.Butterfly_publicLength);
 5417 
 5418         LValue startIndex = nullptr;
 5419         LValue resultLength = nullptr;
 5420         if (m_node-&gt;numChildren() == 2) {
 5421             startIndex = m_out.constInt32(0);
 5422             resultLength = inputLength;
 5423         } else {
 5424             LValue start = lowInt32(m_graph.varArgChild(m_node, 1));
 5425             LValue end = nullptr;
 5426             if (m_node-&gt;numChildren() != 3)
 5427                 end = lowInt32(m_graph.varArgChild(m_node, 2));
 5428 
 5429             auto range = populateSliceRange(start, end, inputLength);
 5430             startIndex = range.first;
 5431             LValue endBoundary = range.second;
 5432 
 5433             resultLength = m_out.select(m_out.belowOrEqual(startIndex, endBoundary),
 5434                 m_out.sub(endBoundary, startIndex),
 5435                 m_out.constInt32(0));
 5436         }
 5437 
 5438         ArrayValues arrayResult;
 5439         {
 5440             LValue indexingType = m_out.load8ZeroExt32(sourceArray, m_heaps.JSCell_indexingTypeAndMisc);
 5441             // We can ignore the writability of the cell since we won&#39;t write to the source.
 5442             indexingType = m_out.bitAnd(indexingType, m_out.constInt32(AllWritableArrayTypesAndHistory));
 5443             // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 5444             // to ensure the incoming array is one to be one of the original array structures
 5445             // with one of the following indexing shapes: Int32, Contiguous, Double.
 5446             LValue structure = m_out.select(
 5447                 m_out.equal(indexingType, m_out.constInt32(ArrayWithInt32)),
 5448                 weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))),
 5449                 m_out.select(m_out.equal(indexingType, m_out.constInt32(ArrayWithContiguous)),
 5450                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))),
 5451                     weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble)))));
 5452             arrayResult = allocateJSArray(resultLength, resultLength, structure, indexingType, false, false);
 5453         }
 5454 
 5455         // Keep the sourceArray alive at least until after anything that can GC.
 5456         keepAlive(sourceArray);
 5457 
 5458         LBasicBlock loop = m_out.newBlock();
 5459         LBasicBlock continuation = m_out.newBlock();
 5460 
 5461         resultLength = m_out.zeroExtPtr(resultLength);
 5462         ValueFromBlock startLoadIndex = m_out.anchor(m_out.zeroExtPtr(startIndex));
 5463         ValueFromBlock startStoreIndex = m_out.anchor(m_out.constIntPtr(0));
 5464 
 5465         m_out.branch(
 5466             m_out.below(m_out.constIntPtr(0), resultLength), unsure(loop), unsure(continuation));
 5467 
 5468         LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 5469         LValue storeIndex = m_out.phi(pointerType(), startStoreIndex);
 5470         LValue loadIndex = m_out.phi(pointerType(), startLoadIndex);
 5471         LValue value = m_out.load64(m_out.baseIndex(m_heaps.root, sourceStorage, loadIndex, ScaleEight));
 5472         m_out.store64(value, m_out.baseIndex(m_heaps.root, arrayResult.butterfly, storeIndex, ScaleEight));
 5473         LValue nextStoreIndex = m_out.add(storeIndex, m_out.constIntPtr(1));
 5474         m_out.addIncomingToPhi(storeIndex, m_out.anchor(nextStoreIndex));
 5475         m_out.addIncomingToPhi(loadIndex, m_out.anchor(m_out.add(loadIndex, m_out.constIntPtr(1))));
 5476         m_out.branch(
 5477             m_out.below(nextStoreIndex, resultLength), unsure(loop), unsure(continuation));
 5478 
 5479         m_out.appendTo(continuation, lastNext);
 5480 
 5481         mutatorFence();
 5482         setJSValue(arrayResult.array);
 5483     }
 5484 
 5485     void compileArrayIndexOf()
 5486     {
<a name="221" id="anc221"></a><span class="line-added"> 5487         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5488         LValue storage = lowStorage(m_node-&gt;numChildren() == 3 ? m_graph.varArgChild(m_node, 2) : m_graph.varArgChild(m_node, 3));
 5489         LValue length = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5490 
 5491         LValue startIndex;
 5492         if (m_node-&gt;numChildren() == 4) {
 5493             startIndex = lowInt32(m_graph.varArgChild(m_node, 2));
 5494             startIndex = m_out.select(m_out.greaterThanOrEqual(startIndex, m_out.int32Zero),
 5495                 m_out.select(m_out.above(startIndex, length), length, startIndex),
 5496                 m_out.select(m_out.lessThan(m_out.add(length, startIndex), m_out.int32Zero), m_out.int32Zero, m_out.add(length, startIndex)));
 5497         } else
 5498             startIndex = m_out.int32Zero;
 5499 
 5500         Edge&amp; searchElementEdge = m_graph.varArgChild(m_node, 1);
 5501         switch (searchElementEdge.useKind()) {
 5502         case Int32Use:
 5503         case ObjectUse:
 5504         case SymbolUse:
 5505         case OtherUse:
 5506         case DoubleRepUse: {
 5507             LBasicBlock loopHeader = m_out.newBlock();
 5508             LBasicBlock loopBody = m_out.newBlock();
 5509             LBasicBlock loopNext = m_out.newBlock();
 5510             LBasicBlock notFound = m_out.newBlock();
 5511             LBasicBlock continuation = m_out.newBlock();
 5512 
 5513             LValue searchElement;
 5514             switch (searchElementEdge.useKind()) {
 5515             case Int32Use:
 5516                 ASSERT(m_node-&gt;arrayMode().type() == Array::Int32);
 5517                 speculate(searchElementEdge);
 5518                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5519                 break;
 5520             case ObjectUse:
 5521                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5522                 searchElement = lowObject(searchElementEdge);
 5523                 break;
 5524             case SymbolUse:
 5525                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5526                 searchElement = lowSymbol(searchElementEdge);
 5527                 break;
 5528             case OtherUse:
 5529                 ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
 5530                 speculate(searchElementEdge);
 5531                 searchElement = lowJSValue(searchElementEdge, ManualOperandSpeculation);
 5532                 break;
 5533             case DoubleRepUse:
 5534                 ASSERT(m_node-&gt;arrayMode().type() == Array::Double);
 5535                 searchElement = lowDouble(searchElementEdge);
 5536                 break;
 5537             default:
 5538                 RELEASE_ASSERT_NOT_REACHED();
 5539                 break;
 5540             }
 5541 
 5542             startIndex = m_out.zeroExtPtr(startIndex);
 5543             length = m_out.zeroExtPtr(length);
 5544 
 5545             ValueFromBlock initialStartIndex = m_out.anchor(startIndex);
 5546             m_out.jump(loopHeader);
 5547 
 5548             LBasicBlock lastNext = m_out.appendTo(loopHeader, loopBody);
 5549             LValue index = m_out.phi(pointerType(), initialStartIndex);
 5550             m_out.branch(m_out.notEqual(index, length), unsure(loopBody), unsure(notFound));
 5551 
 5552             m_out.appendTo(loopBody, loopNext);
 5553             ValueFromBlock foundResult = m_out.anchor(index);
 5554             switch (searchElementEdge.useKind()) {
 5555             case Int32Use: {
<a name="222" id="anc222"></a><span class="line-modified"> 5556                 // Empty value is ignored because of JSValue::NumberTag.</span>
 5557                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedInt32Properties, storage, index));
 5558                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5559                 break;
 5560             }
 5561             case ObjectUse:
 5562             case SymbolUse:
 5563             case OtherUse: {
 5564                 // Empty value never matches against non-empty JS values.
 5565                 LValue value = m_out.load64(m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, index));
 5566                 m_out.branch(m_out.equal(value, searchElement), unsure(continuation), unsure(loopNext));
 5567                 break;
 5568             }
 5569             case DoubleRepUse: {
 5570                 // Empty value is ignored because of NaN.
 5571                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, storage, index));
 5572                 m_out.branch(m_out.doubleEqual(value, searchElement), unsure(continuation), unsure(loopNext));
 5573                 break;
 5574             }
 5575             default:
 5576                 RELEASE_ASSERT_NOT_REACHED();
 5577                 break;
 5578             }
 5579 
 5580             m_out.appendTo(loopNext, notFound);
 5581             LValue nextIndex = m_out.add(index, m_out.intPtrOne);
 5582             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 5583             m_out.jump(loopHeader);
 5584 
 5585             m_out.appendTo(notFound, continuation);
 5586             ValueFromBlock notFoundResult = m_out.anchor(m_out.constIntPtr(-1));
 5587             m_out.jump(continuation);
 5588 
 5589             m_out.appendTo(continuation, lastNext);
 5590             setInt32(m_out.castToInt32(m_out.phi(pointerType(), notFoundResult, foundResult)));
 5591             break;
 5592         }
 5593 
 5594         case StringUse:
 5595             ASSERT(m_node-&gt;arrayMode().type() == Array::Contiguous);
<a name="223" id="anc223"></a><span class="line-modified"> 5596             setInt32(vmCall(Int32, operationArrayIndexOfString, weakPointer(globalObject), storage, lowString(searchElementEdge), startIndex));</span>
 5597             break;
 5598 
 5599         case UntypedUse:
 5600             switch (m_node-&gt;arrayMode().type()) {
 5601             case Array::Double:
<a name="224" id="anc224"></a><span class="line-modified"> 5602                 setInt32(vmCall(Int32, operationArrayIndexOfValueDouble, weakPointer(globalObject), storage, lowJSValue(searchElementEdge), startIndex));</span>
 5603                 break;
 5604             case Array::Int32:
 5605             case Array::Contiguous:
<a name="225" id="anc225"></a><span class="line-modified"> 5606                 setInt32(vmCall(Int32, operationArrayIndexOfValueInt32OrContiguous, weakPointer(globalObject), storage, lowJSValue(searchElementEdge), startIndex));</span>
 5607                 break;
 5608             default:
 5609                 RELEASE_ASSERT_NOT_REACHED();
 5610                 break;
 5611             }
 5612             break;
 5613 
 5614         default:
 5615             RELEASE_ASSERT_NOT_REACHED();
 5616             break;
 5617         }
 5618     }
 5619 
 5620 
 5621     void compileArrayPop()
 5622     {
<a name="226" id="anc226"></a><span class="line-added"> 5623         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5624         LValue base = lowCell(m_node-&gt;child1());
 5625         LValue storage = lowStorage(m_node-&gt;child2());
 5626 
 5627         switch (m_node-&gt;arrayMode().type()) {
 5628         case Array::Int32:
 5629         case Array::Double:
 5630         case Array::Contiguous: {
 5631             IndexedAbstractHeap&amp; heap = m_heaps.forArrayType(m_node-&gt;arrayMode().type());
 5632 
 5633             LBasicBlock fastCase = m_out.newBlock();
 5634             LBasicBlock slowCase = m_out.newBlock();
 5635             LBasicBlock continuation = m_out.newBlock();
 5636 
 5637             LValue prevLength = m_out.load32(storage, m_heaps.Butterfly_publicLength);
 5638 
 5639             Vector&lt;ValueFromBlock, 3&gt; results;
 5640             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5641             m_out.branch(
 5642                 m_out.isZero32(prevLength), rarely(continuation), usually(fastCase));
 5643 
 5644             LBasicBlock lastNext = m_out.appendTo(fastCase, slowCase);
 5645             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5646             m_out.store32(newLength, storage, m_heaps.Butterfly_publicLength);
 5647             TypedPointer pointer = m_out.baseIndex(heap, storage, m_out.zeroExtPtr(newLength));
 5648             if (m_node-&gt;arrayMode().type() != Array::Double) {
 5649                 LValue result = m_out.load64(pointer);
 5650                 m_out.store64(m_out.int64Zero, pointer);
 5651                 results.append(m_out.anchor(result));
 5652                 m_out.branch(
 5653                     m_out.notZero64(result), usually(continuation), rarely(slowCase));
 5654             } else {
 5655                 LValue result = m_out.loadDouble(pointer);
 5656                 m_out.store64(m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)), pointer);
 5657                 results.append(m_out.anchor(boxDouble(result)));
 5658                 m_out.branch(
 5659                     m_out.doubleEqual(result, result),
 5660                     usually(continuation), rarely(slowCase));
 5661             }
 5662 
 5663             m_out.appendTo(slowCase, continuation);
 5664             results.append(m_out.anchor(vmCall(
<a name="227" id="anc227"></a><span class="line-modified"> 5665                 Int64, operationArrayPopAndRecoverLength, weakPointer(globalObject), base)));</span>
 5666             m_out.jump(continuation);
 5667 
 5668             m_out.appendTo(continuation, lastNext);
 5669             setJSValue(m_out.phi(Int64, results));
 5670             return;
 5671         }
 5672 
 5673         case Array::ArrayStorage: {
 5674             LBasicBlock vectorLengthCheckCase = m_out.newBlock();
 5675             LBasicBlock popCheckCase = m_out.newBlock();
 5676             LBasicBlock fastCase = m_out.newBlock();
 5677             LBasicBlock slowCase = m_out.newBlock();
 5678             LBasicBlock continuation = m_out.newBlock();
 5679 
 5680             LValue prevLength = m_out.load32(storage, m_heaps.ArrayStorage_publicLength);
 5681 
 5682             Vector&lt;ValueFromBlock, 3&gt; results;
 5683             results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 5684             m_out.branch(
 5685                 m_out.isZero32(prevLength), rarely(continuation), usually(vectorLengthCheckCase));
 5686 
 5687             LBasicBlock lastNext = m_out.appendTo(vectorLengthCheckCase, popCheckCase);
 5688             LValue newLength = m_out.sub(prevLength, m_out.int32One);
 5689             m_out.branch(
 5690                 m_out.aboveOrEqual(newLength, m_out.load32(storage, m_heaps.ArrayStorage_vectorLength)), rarely(slowCase), usually(popCheckCase));
 5691 
 5692             m_out.appendTo(popCheckCase, fastCase);
 5693             TypedPointer pointer = m_out.baseIndex(m_heaps.ArrayStorage_vector, storage, m_out.zeroExtPtr(newLength));
 5694             LValue result = m_out.load64(pointer);
 5695             m_out.branch(m_out.notZero64(result), usually(fastCase), rarely(slowCase));
 5696 
 5697             m_out.appendTo(fastCase, slowCase);
 5698             m_out.store32(newLength, storage, m_heaps.ArrayStorage_publicLength);
 5699             m_out.store64(m_out.int64Zero, pointer);
 5700             m_out.store32(
 5701                 m_out.sub(m_out.load32(storage, m_heaps.ArrayStorage_numValuesInVector), m_out.int32One),
 5702                 storage, m_heaps.ArrayStorage_numValuesInVector);
 5703             results.append(m_out.anchor(result));
 5704             m_out.jump(continuation);
 5705 
 5706             m_out.appendTo(slowCase, continuation);
<a name="228" id="anc228"></a><span class="line-modified"> 5707             results.append(m_out.anchor(vmCall(Int64, operationArrayPop, weakPointer(globalObject), base)));</span>

 5708             m_out.jump(continuation);
 5709 
 5710             m_out.appendTo(continuation, lastNext);
 5711             setJSValue(m_out.phi(Int64, results));
 5712             return;
 5713         }
 5714 
 5715         default:
 5716             DFG_CRASH(m_graph, m_node, &quot;Bad array type&quot;);
 5717             return;
 5718         }
 5719     }
 5720 
 5721     void compilePushWithScope()
 5722     {
<a name="229" id="anc229"></a><span class="line-added"> 5723         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5724         LValue parentScope = lowCell(m_node-&gt;child1());
 5725         auto objectEdge = m_node-&gt;child2();
 5726         if (objectEdge.useKind() == ObjectUse) {
 5727             LValue object = lowNonNullObject(objectEdge);
<a name="230" id="anc230"></a><span class="line-modified"> 5728             LValue result = vmCall(Int64, operationPushWithScopeObject, weakPointer(globalObject), parentScope, object);</span>
 5729             setJSValue(result);
 5730         } else {
 5731             ASSERT(objectEdge.useKind() == UntypedUse);
 5732             LValue object = lowJSValue(m_node-&gt;child2());
<a name="231" id="anc231"></a><span class="line-modified"> 5733             LValue result = vmCall(Int64, operationPushWithScope, weakPointer(globalObject), parentScope, object);</span>
 5734             setJSValue(result);
 5735         }
 5736     }
 5737 
 5738     void compileCreateActivation()
 5739     {
 5740         LValue scope = lowCell(m_node-&gt;child1());
 5741         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
 5742         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
 5743         JSValue initializationValue = m_node-&gt;initializationValueForActivation();
 5744         ASSERT(initializationValue.isUndefined() || initializationValue == jsTDZValue());
 5745         if (table-&gt;singleton().isStillValid()) {
 5746             LValue callResult = vmCall(
 5747                 Int64,
<a name="232" id="anc232"></a><span class="line-modified"> 5748                 operationCreateActivationDirect, m_vmValue, weakStructure(structure),</span>
 5749                 scope, weakPointer(table), m_out.constInt64(JSValue::encode(initializationValue)));
 5750             setJSValue(callResult);
 5751             return;
 5752         }
 5753 
 5754         LBasicBlock slowPath = m_out.newBlock();
 5755         LBasicBlock continuation = m_out.newBlock();
 5756 
 5757         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5758 
 5759         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
 5760             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
 5761 
 5762         // We don&#39;t need memory barriers since we just fast-created the activation, so the
 5763         // activation must be young.
 5764         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
 5765         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
 5766 
 5767         for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 5768             m_out.store64(
 5769                 m_out.constInt64(JSValue::encode(initializationValue)),
 5770                 fastObject, m_heaps.JSLexicalEnvironment_variables[i]);
 5771         }
 5772 
 5773         mutatorFence();
 5774 
 5775         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5776         m_out.jump(continuation);
 5777 
 5778         m_out.appendTo(slowPath, continuation);
 5779         VM&amp; vm = this-&gt;vm();
 5780         LValue callResult = lazySlowPath(
 5781             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5782                 return createLazyCallGenerator(vm,
<a name="233" id="anc233"></a><span class="line-modified"> 5783                     operationCreateActivationDirect, locations[0].directGPR(), &amp;vm,</span>
 5784                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5785                     CCallHelpers::TrustedImmPtr(table),
 5786                     CCallHelpers::TrustedImm64(JSValue::encode(initializationValue)));
 5787             },
 5788             scope);
 5789         ValueFromBlock slowResult = m_out.anchor(callResult);
 5790         m_out.jump(continuation);
 5791 
 5792         m_out.appendTo(continuation, lastNext);
 5793         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5794     }
 5795 
 5796     void compileNewFunction()
 5797     {
 5798         ASSERT(m_node-&gt;op() == NewFunction || m_node-&gt;op() == NewGeneratorFunction || m_node-&gt;op() == NewAsyncGeneratorFunction || m_node-&gt;op() == NewAsyncFunction);
 5799         bool isGeneratorFunction = m_node-&gt;op() == NewGeneratorFunction;
 5800         bool isAsyncFunction = m_node-&gt;op() == NewAsyncFunction;
 5801         bool isAsyncGeneratorFunction =  m_node-&gt;op() == NewAsyncGeneratorFunction;
 5802 
 5803         LValue scope = lowCell(m_node-&gt;child1());
 5804 
 5805         FunctionExecutable* executable = m_node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 5806         if (executable-&gt;singleton().isStillValid()) {
 5807             LValue callResult =
<a name="234" id="anc234"></a><span class="line-modified"> 5808                 isGeneratorFunction ? vmCall(Int64, operationNewGeneratorFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified"> 5809                 isAsyncFunction ? vmCall(Int64, operationNewAsyncFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified"> 5810                 isAsyncGeneratorFunction ? vmCall(Int64, operationNewAsyncGeneratorFunction, m_vmValue, scope, weakPointer(executable)) :</span>
<span class="line-modified"> 5811                 vmCall(Int64, operationNewFunction, m_vmValue, scope, weakPointer(executable));</span>
 5812             setJSValue(callResult);
 5813             return;
 5814         }
 5815 
 5816         RegisteredStructure structure = m_graph.registerStructure(
 5817             [&amp;] () {
 5818                 JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 5819                 switch (m_node-&gt;op()) {
 5820                 case NewGeneratorFunction:
 5821                     return globalObject-&gt;generatorFunctionStructure();
 5822                 case NewAsyncFunction:
 5823                     return globalObject-&gt;asyncFunctionStructure();
 5824                 case NewAsyncGeneratorFunction:
 5825                     return globalObject-&gt;asyncGeneratorFunctionStructure();
 5826                 case NewFunction:
 5827                     return JSFunction::selectStructureForNewFuncExp(globalObject, m_node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 5828                 default:
 5829                     RELEASE_ASSERT_NOT_REACHED();
 5830                 }
 5831             }());
 5832 
 5833         LBasicBlock slowPath = m_out.newBlock();
 5834         LBasicBlock continuation = m_out.newBlock();
 5835 
 5836         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5837 
 5838         LValue fastObject =
 5839             isGeneratorFunction ? allocateObject&lt;JSGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5840             isAsyncFunction ? allocateObject&lt;JSAsyncFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5841             isAsyncGeneratorFunction ? allocateObject&lt;JSAsyncGeneratorFunction&gt;(structure, m_out.intPtrZero, slowPath) :
 5842             allocateObject&lt;JSFunction&gt;(structure, m_out.intPtrZero, slowPath);
 5843 
 5844 
 5845         // We don&#39;t need memory barriers since we just fast-created the function, so it
 5846         // must be young.
 5847         m_out.storePtr(scope, fastObject, m_heaps.JSFunction_scope);
<a name="235" id="anc235"></a><span class="line-modified"> 5848         m_out.storePtr(weakPointer(executable), fastObject, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-modified"> 5849         mutatorFence();</span>



















 5850 
 5851         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5852         m_out.jump(continuation);
 5853 
 5854         m_out.appendTo(slowPath, continuation);
 5855 
 5856         Vector&lt;LValue&gt; slowPathArguments;
 5857         slowPathArguments.append(scope);
<a name="236" id="anc236"></a><span class="line-added"> 5858         VM&amp; vm = this-&gt;vm();</span>
 5859         LValue callResult = lazySlowPath(
 5860             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5861                 auto* operation = operationNewFunctionWithInvalidatedReallocationWatchpoint;
 5862                 if (isGeneratorFunction)
 5863                     operation = operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5864                 else if (isAsyncFunction)
 5865                     operation = operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint;
 5866                 else if (isAsyncGeneratorFunction)
 5867                     operation = operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint;
 5868 
 5869                 return createLazyCallGenerator(vm, operation,
<a name="237" id="anc237"></a><span class="line-modified"> 5870                     locations[0].directGPR(), &amp;vm, locations[1].directGPR(),</span>
 5871                     CCallHelpers::TrustedImmPtr(executable));
 5872             },
 5873             slowPathArguments);
 5874         ValueFromBlock slowResult = m_out.anchor(callResult);
 5875         m_out.jump(continuation);
 5876 
 5877         m_out.appendTo(continuation, lastNext);
 5878         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 5879     }
 5880 
 5881     void compileCreateDirectArguments()
 5882     {
 5883         // FIXME: A more effective way of dealing with the argument count and callee is to have
 5884         // them be explicit arguments to this node.
 5885         // https://bugs.webkit.org/show_bug.cgi?id=142207
 5886 
 5887         RegisteredStructure structure =
 5888             m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 5889 
 5890         unsigned minCapacity = m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic)-&gt;numParameters() - 1;
 5891 
 5892         LBasicBlock slowPath = m_out.newBlock();
 5893         LBasicBlock continuation = m_out.newBlock();
 5894 
 5895         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
 5896 
 5897         ArgumentsLength length = getArgumentsLength();
 5898 
 5899         LValue fastObject;
 5900         if (length.isKnown) {
 5901             fastObject = allocateObject&lt;DirectArguments&gt;(
 5902                 DirectArguments::allocationSize(std::max(length.known, minCapacity)), structure,
 5903                 m_out.intPtrZero, slowPath);
 5904         } else {
 5905             LValue size = m_out.add(
 5906                 m_out.shl(length.value, m_out.constInt32(3)),
 5907                 m_out.constInt32(DirectArguments::storageOffset()));
 5908 
 5909             size = m_out.select(
 5910                 m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5911                 size, m_out.constInt32(DirectArguments::allocationSize(minCapacity)));
 5912 
 5913             fastObject = allocateVariableSizedObject&lt;DirectArguments&gt;(
 5914                 m_out.zeroExtPtr(size), structure, m_out.intPtrZero, slowPath);
 5915         }
 5916 
 5917         m_out.store32(length.value, fastObject, m_heaps.DirectArguments_length);
 5918         m_out.store32(m_out.constInt32(minCapacity), fastObject, m_heaps.DirectArguments_minCapacity);
 5919         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_mappedArguments);
 5920         m_out.storePtr(m_out.intPtrZero, fastObject, m_heaps.DirectArguments_modifiedArgumentsDescriptor);
 5921 
 5922         ValueFromBlock fastResult = m_out.anchor(fastObject);
 5923         m_out.jump(continuation);
 5924 
 5925         m_out.appendTo(slowPath, continuation);
 5926         VM&amp; vm = this-&gt;vm();
 5927         LValue callResult = lazySlowPath(
 5928             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 5929                 return createLazyCallGenerator(vm,
<a name="238" id="anc238"></a><span class="line-modified"> 5930                     operationCreateDirectArguments, locations[0].directGPR(), &amp;vm,</span>
 5931                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 5932                     CCallHelpers::TrustedImm32(minCapacity));
 5933             }, length.value);
 5934         ValueFromBlock slowResult = m_out.anchor(callResult);
 5935         m_out.jump(continuation);
 5936 
 5937         m_out.appendTo(continuation, lastNext);
 5938         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
 5939 
 5940         m_out.storePtr(getCurrentCallee(), result, m_heaps.DirectArguments_callee);
 5941 
 5942         if (length.isKnown) {
 5943             VirtualRegister start = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic);
 5944             for (unsigned i = 0; i &lt; std::max(length.known, minCapacity); ++i) {
 5945                 m_out.store64(
 5946                     m_out.load64(addressFor(start + i)),
 5947                     result, m_heaps.DirectArguments_storage[i]);
 5948             }
 5949         } else {
 5950             LValue stackBase = getArgumentsStart();
 5951 
 5952             LBasicBlock loop = m_out.newBlock();
 5953             LBasicBlock end = m_out.newBlock();
 5954 
 5955             ValueFromBlock originalLength;
 5956             if (minCapacity) {
 5957                 LValue capacity = m_out.select(
 5958                     m_out.aboveOrEqual(length.value, m_out.constInt32(minCapacity)),
 5959                     length.value,
 5960                     m_out.constInt32(minCapacity));
 5961                 LValue originalLengthValue = m_out.zeroExtPtr(capacity);
 5962                 originalLength = m_out.anchor(originalLengthValue);
 5963                 m_out.jump(loop);
 5964             } else {
 5965                 LValue originalLengthValue = m_out.zeroExtPtr(length.value);
 5966                 originalLength = m_out.anchor(originalLengthValue);
 5967                 m_out.branch(m_out.isNull(originalLengthValue), unsure(end), unsure(loop));
 5968             }
 5969 
 5970             lastNext = m_out.appendTo(loop, end);
 5971             LValue previousIndex = m_out.phi(pointerType(), originalLength);
 5972             LValue index = m_out.sub(previousIndex, m_out.intPtrOne);
 5973             m_out.store64(
 5974                 m_out.load64(m_out.baseIndex(m_heaps.variables, stackBase, index)),
 5975                 m_out.baseIndex(m_heaps.DirectArguments_storage, result, index));
 5976             ValueFromBlock nextIndex = m_out.anchor(index);
 5977             m_out.addIncomingToPhi(previousIndex, nextIndex);
 5978             m_out.branch(m_out.isNull(index), unsure(end), unsure(loop));
 5979 
 5980             m_out.appendTo(end, lastNext);
 5981         }
 5982 
 5983         mutatorFence();
 5984 
 5985         setJSValue(result);
 5986     }
 5987 
 5988     void compileCreateScopedArguments()
 5989     {
<a name="239" id="anc239"></a><span class="line-added"> 5990         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 5991         LValue scope = lowCell(m_node-&gt;child1());
 5992 
 5993         LValue result = vmCall(
<a name="240" id="anc240"></a><span class="line-modified"> 5994             Int64, operationCreateScopedArguments, weakPointer(globalObject),</span>
 5995             weakPointer(
 5996                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;scopedArgumentsStructure()),
 5997             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee(), scope);
 5998 
 5999         setJSValue(result);
 6000     }
 6001 
 6002     void compileCreateClonedArguments()
 6003     {
<a name="241" id="anc241"></a><span class="line-added"> 6004         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6005         LValue result = vmCall(
<a name="242" id="anc242"></a><span class="line-modified"> 6006             Int64, operationCreateClonedArguments, weakPointer(globalObject),</span>
 6007             weakPointer(
 6008                 m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;clonedArgumentsStructure()),
 6009             getArgumentsStart(), getArgumentsLength().value, getCurrentCallee());
 6010 
 6011         setJSValue(result);
 6012     }
 6013 
<a name="243" id="anc243"></a><span class="line-added"> 6014     void compileCreateArgumentsButterfly()</span>
<span class="line-added"> 6015     {</span>
<span class="line-added"> 6016         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 6017         LValue result = vmCall(Int64, operationCreateArgumentsButterfly, weakPointer(globalObject), getArgumentsStart(), getArgumentsLength().value);</span>
<span class="line-added"> 6018         setJSValue(result);</span>
<span class="line-added"> 6019     }</span>
<span class="line-added"> 6020 </span>
 6021     void compileCreateRest()
 6022     {
<a name="244" id="anc244"></a><span class="line-added"> 6023         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6024         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 6025             LBasicBlock continuation = m_out.newBlock();
 6026             LValue arrayLength = lowInt32(m_node-&gt;child1());
 6027             LBasicBlock loopStart = m_out.newBlock();
<a name="245" id="anc245"></a>
 6028             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalRestParameterStructure());
 6029             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(arrayLength, structure);
 6030             LValue array = arrayValues.array;
 6031             LValue butterfly = arrayValues.butterfly;
 6032             ValueFromBlock startLength = m_out.anchor(arrayLength);
 6033             LValue argumentRegion = m_out.add(getArgumentsStart(), m_out.constInt64(sizeof(Register) * m_node-&gt;numberOfArgumentsToSkip()));
 6034             m_out.branch(m_out.equal(arrayLength, m_out.constInt32(0)),
 6035                 unsure(continuation), unsure(loopStart));
 6036 
 6037             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6038             LValue phiOffset = m_out.phi(Int32, startLength);
 6039             LValue currentOffset = m_out.sub(phiOffset, m_out.int32One);
 6040             m_out.addIncomingToPhi(phiOffset, m_out.anchor(currentOffset));
 6041             LValue loadedValue = m_out.load64(m_out.baseIndex(m_heaps.variables, argumentRegion, m_out.zeroExtPtr(currentOffset)));
 6042             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6043             m_out.store64(loadedValue, m_out.baseIndex(heap, butterfly, m_out.zeroExtPtr(currentOffset)));
 6044             m_out.branch(m_out.equal(currentOffset, m_out.constInt32(0)), unsure(continuation), unsure(loopStart));
 6045 
 6046             m_out.appendTo(continuation, lastNext);
 6047             mutatorFence();
 6048             setJSValue(array);
 6049             return;
 6050         }
 6051 
 6052         LValue arrayLength = lowInt32(m_node-&gt;child1());
 6053         LValue argumentStart = getArgumentsStart();
 6054         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 6055         setJSValue(vmCall(
<a name="246" id="anc246"></a><span class="line-modified"> 6056             Int64, operationCreateRest, weakPointer(globalObject), argumentStart, numberOfArgumentsToSkip, arrayLength));</span>
 6057     }
 6058 
 6059     void compileGetRestLength()
 6060     {
 6061         LBasicBlock nonZeroLength = m_out.newBlock();
 6062         LBasicBlock continuation = m_out.newBlock();
 6063 
 6064         ValueFromBlock zeroLengthResult = m_out.anchor(m_out.constInt32(0));
 6065 
 6066         LValue numberOfArgumentsToSkip = m_out.constInt32(m_node-&gt;numberOfArgumentsToSkip());
 6067         LValue argumentsLength = getArgumentsLength().value;
 6068         m_out.branch(m_out.above(argumentsLength, numberOfArgumentsToSkip),
 6069             unsure(nonZeroLength), unsure(continuation));
 6070 
 6071         LBasicBlock lastNext = m_out.appendTo(nonZeroLength, continuation);
 6072         ValueFromBlock nonZeroLengthResult = m_out.anchor(m_out.sub(argumentsLength, numberOfArgumentsToSkip));
 6073         m_out.jump(continuation);
 6074 
 6075         m_out.appendTo(continuation, lastNext);
 6076         setInt32(m_out.phi(Int32, zeroLengthResult, nonZeroLengthResult));
 6077     }
 6078 
 6079     void compileObjectKeys()
 6080     {
<a name="247" id="anc247"></a><span class="line-added"> 6081         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6082         switch (m_node-&gt;child1().useKind()) {
 6083         case ObjectUse: {
 6084             if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 6085                 LBasicBlock notNullCase = m_out.newBlock();
 6086                 LBasicBlock rareDataCase = m_out.newBlock();
 6087                 LBasicBlock useCacheCase = m_out.newBlock();
 6088                 LBasicBlock slowButArrayBufferCase = m_out.newBlock();
 6089                 LBasicBlock slowCase = m_out.newBlock();
 6090                 LBasicBlock continuation = m_out.newBlock();
 6091 
 6092                 LValue object = lowObject(m_node-&gt;child1());
 6093                 LValue structure = loadStructure(object);
 6094                 LValue previousOrRareData = m_out.loadPtr(structure, m_heaps.Structure_previousOrRareData);
 6095                 m_out.branch(m_out.notNull(previousOrRareData), unsure(notNullCase), unsure(slowCase));
 6096 
 6097                 LBasicBlock lastNext = m_out.appendTo(notNullCase, rareDataCase);
 6098                 m_out.branch(
 6099                     m_out.notEqual(m_out.load32(previousOrRareData, m_heaps.JSCell_structureID), m_out.constInt32(m_graph.m_vm.structureStructure-&gt;structureID())),
 6100                     unsure(rareDataCase), unsure(slowCase));
 6101 
 6102                 m_out.appendTo(rareDataCase, useCacheCase);
 6103                 ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
 6104                 LValue cachedOwnKeys = m_out.loadPtr(previousOrRareData, m_heaps.StructureRareData_cachedOwnKeys);
 6105                 m_out.branch(m_out.belowOrEqual(cachedOwnKeys, m_out.constIntPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))), unsure(slowCase), unsure(useCacheCase));
 6106 
 6107                 m_out.appendTo(useCacheCase, slowButArrayBufferCase);
<a name="248" id="anc248"></a>
 6108                 RegisteredStructure arrayStructure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
 6109                 LValue fastArray = allocateObject&lt;JSArray&gt;(arrayStructure, m_out.addPtr(cachedOwnKeys, JSImmutableButterfly::offsetOfData()), slowButArrayBufferCase);
 6110                 ValueFromBlock fastResult = m_out.anchor(fastArray);
 6111                 m_out.jump(continuation);
 6112 
 6113                 m_out.appendTo(slowButArrayBufferCase, slowCase);
<a name="249" id="anc249"></a><span class="line-modified"> 6114                 LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(arrayStructure), cachedOwnKeys);</span>
 6115                 ValueFromBlock slowButArrayBufferResult = m_out.anchor(slowArray);
 6116                 m_out.jump(continuation);
 6117 
 6118                 m_out.appendTo(slowCase, continuation);
 6119                 VM&amp; vm = this-&gt;vm();
 6120                 LValue slowResultValue = lazySlowPath(
 6121                     [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6122                         return createLazyCallGenerator(vm,
<a name="250" id="anc250"></a><span class="line-modified"> 6123                             operationObjectKeysObject, locations[0].directGPR(), globalObject, locations[1].directGPR());</span>
 6124                     },
 6125                     object);
 6126                 ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6127                 m_out.jump(continuation);
 6128 
 6129                 m_out.appendTo(continuation, lastNext);
 6130                 setJSValue(m_out.phi(pointerType(), fastResult, slowButArrayBufferResult, slowResult));
 6131                 break;
 6132             }
<a name="251" id="anc251"></a><span class="line-modified"> 6133             setJSValue(vmCall(Int64, operationObjectKeysObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
 6134             break;
 6135         }
 6136         case UntypedUse:
<a name="252" id="anc252"></a><span class="line-modified"> 6137             setJSValue(vmCall(Int64, operationObjectKeys, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
 6138             break;
 6139         default:
 6140             RELEASE_ASSERT_NOT_REACHED();
 6141             break;
 6142         }
 6143     }
 6144 
 6145     void compileObjectCreate()
 6146     {
<a name="253" id="anc253"></a><span class="line-added"> 6147         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6148         switch (m_node-&gt;child1().useKind()) {
 6149         case ObjectUse:
<a name="254" id="anc254"></a><span class="line-modified"> 6150             setJSValue(vmCall(Int64, operationObjectCreateObject, weakPointer(globalObject), lowObject(m_node-&gt;child1())));</span>
 6151             break;
 6152         case UntypedUse:
<a name="255" id="anc255"></a><span class="line-modified"> 6153             setJSValue(vmCall(Int64, operationObjectCreate, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
 6154             break;
 6155         default:
 6156             RELEASE_ASSERT_NOT_REACHED();
 6157             break;
 6158         }
 6159     }
 6160 
 6161     void compileNewObject()
 6162     {
 6163         setJSValue(allocateObject(m_node-&gt;structure()));
 6164         mutatorFence();
 6165     }
 6166 
<a name="256" id="anc256"></a><span class="line-added"> 6167     void compileNewPromise()</span>
<span class="line-added"> 6168     {</span>
<span class="line-added"> 6169         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added"> 6170         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6171 </span>
<span class="line-added"> 6172         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);</span>
<span class="line-added"> 6173 </span>
<span class="line-added"> 6174         LValue promise;</span>
<span class="line-added"> 6175         if (m_node-&gt;isInternalPromise())</span>
<span class="line-added"> 6176             promise = allocateObject&lt;JSInternalPromise&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6177         else</span>
<span class="line-added"> 6178             promise = allocateObject&lt;JSPromise&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6179         m_out.store64(m_out.constInt64(JSValue::encode(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)))), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::Flags)]);</span>
<span class="line-added"> 6180         m_out.store64(m_out.constInt64(JSValue::encode(jsUndefined())), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult)]);</span>
<span class="line-added"> 6181         mutatorFence();</span>
<span class="line-added"> 6182         ValueFromBlock fastResult = m_out.anchor(promise);</span>
<span class="line-added"> 6183         m_out.jump(continuation);</span>
<span class="line-added"> 6184 </span>
<span class="line-added"> 6185         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added"> 6186         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), m_node-&gt;isInternalPromise() ? operationNewInternalPromise : operationNewPromise, m_vmValue, frozenPointer(m_graph.freezeStrong(m_node-&gt;structure().get()))));</span>
<span class="line-added"> 6187         m_out.jump(continuation);</span>
<span class="line-added"> 6188 </span>
<span class="line-added"> 6189         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 6190         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));</span>
<span class="line-added"> 6191     }</span>
<span class="line-added"> 6192 </span>
<span class="line-added"> 6193     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added"> 6194     void compileNewInternalFieldObject(Operation operation)</span>
<span class="line-added"> 6195     {</span>
<span class="line-added"> 6196         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added"> 6197         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6198 </span>
<span class="line-added"> 6199         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);</span>
<span class="line-added"> 6200 </span>
<span class="line-added"> 6201         LValue object = allocateObject&lt;JSClass&gt;(m_node-&gt;structure(), m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6202         auto initialValues = JSClass::initialValues();</span>
<span class="line-added"> 6203         static_assert(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added"> 6204         for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added"> 6205             m_out.store64(m_out.constInt64(JSValue::encode(initialValues[index])), object, m_heaps.JSInternalFieldObjectImpl_internalFields[index]);</span>
<span class="line-added"> 6206         mutatorFence();</span>
<span class="line-added"> 6207         ValueFromBlock fastResult = m_out.anchor(object);</span>
<span class="line-added"> 6208         m_out.jump(continuation);</span>
<span class="line-added"> 6209 </span>
<span class="line-added"> 6210         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added"> 6211         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operation, m_vmValue, frozenPointer(m_graph.freezeStrong(m_node-&gt;structure().get()))));</span>
<span class="line-added"> 6212         m_out.jump(continuation);</span>
<span class="line-added"> 6213 </span>
<span class="line-added"> 6214         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 6215         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));</span>
<span class="line-added"> 6216     }</span>
<span class="line-added"> 6217 </span>
<span class="line-added"> 6218     void compileNewGenerator()</span>
<span class="line-added"> 6219     {</span>
<span class="line-added"> 6220         compileNewInternalFieldObject&lt;JSGenerator&gt;(operationNewGenerator);</span>
<span class="line-added"> 6221     }</span>
<span class="line-added"> 6222 </span>
<span class="line-added"> 6223     void compileNewAsyncGenerator()</span>
<span class="line-added"> 6224     {</span>
<span class="line-added"> 6225         compileNewInternalFieldObject&lt;JSAsyncGenerator&gt;(operationNewAsyncGenerator);</span>
<span class="line-added"> 6226     }</span>
<span class="line-added"> 6227 </span>
<span class="line-added"> 6228     void compileNewArrayIterator()</span>
<span class="line-added"> 6229     {</span>
<span class="line-added"> 6230         compileNewInternalFieldObject&lt;JSArrayIterator&gt;(operationNewArrayIterator);</span>
<span class="line-added"> 6231     }</span>
<span class="line-added"> 6232 </span>
 6233     void compileNewStringObject()
 6234     {
 6235         RegisteredStructure structure = m_node-&gt;structure();
 6236         LValue string = lowString(m_node-&gt;child1());
 6237 
 6238         LBasicBlock slowCase = m_out.newBlock();
 6239         LBasicBlock continuation = m_out.newBlock();
 6240 
 6241         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
 6242 
 6243         LValue fastResultValue = allocateObject&lt;StringObject&gt;(structure, m_out.intPtrZero, slowCase);
 6244         m_out.storePtr(m_out.constIntPtr(StringObject::info()), fastResultValue, m_heaps.JSDestructibleObject_classInfo);
 6245         m_out.store64(string, fastResultValue, m_heaps.JSWrapperObject_internalValue);
 6246         mutatorFence();
 6247         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 6248         m_out.jump(continuation);
 6249 
 6250         m_out.appendTo(slowCase, continuation);
 6251         VM&amp; vm = this-&gt;vm();
 6252         LValue slowResultValue = lazySlowPath(
 6253             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 6254                 return createLazyCallGenerator(vm,
<a name="257" id="anc257"></a><span class="line-modified"> 6255                     operationNewStringObject, locations[0].directGPR(), &amp;vm, locations[1].directGPR(),</span>
 6256                     CCallHelpers::TrustedImmPtr(structure.get()));
 6257             },
 6258             string);
 6259         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 6260         m_out.jump(continuation);
 6261 
 6262         m_out.appendTo(continuation, lastNext);
 6263         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 6264     }
 6265 
 6266     void compileNewSymbol()
 6267     {
<a name="258" id="anc258"></a><span class="line-added"> 6268         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6269         if (!m_node-&gt;child1()) {
<a name="259" id="anc259"></a><span class="line-modified"> 6270             setJSValue(vmCall(pointerType(), operationNewSymbol, m_vmValue));</span>
 6271             return;
 6272         }
 6273         ASSERT(m_node-&gt;child1().useKind() == KnownStringUse);
<a name="260" id="anc260"></a><span class="line-modified"> 6274         setJSValue(vmCall(pointerType(), operationNewSymbolWithDescription, weakPointer(globalObject), lowString(m_node-&gt;child1())));</span>
 6275     }
 6276 
 6277     void compileNewArray()
 6278     {
 6279         // First speculate appropriately on all of the children. Do this unconditionally up here
 6280         // because some of the slow paths may otherwise forget to do it. It&#39;s sort of arguable
 6281         // that doing the speculations up here might be unprofitable for RA - so we can consider
 6282         // sinking this to below the allocation fast path if we find that this has a lot of
 6283         // register pressure.
 6284         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex)
 6285             speculate(m_graph.varArgChild(m_node, operandIndex));
 6286 
 6287         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6288         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6289             m_node-&gt;indexingType()));
 6290 
 6291         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 6292             unsigned numElements = m_node-&gt;numChildren();
 6293             unsigned vectorLengthHint = m_node-&gt;vectorLengthHint();
 6294             ASSERT(vectorLengthHint &gt;= numElements);
 6295 
 6296             ArrayValues arrayValues =
 6297                 allocateUninitializedContiguousJSArray(numElements, vectorLengthHint, structure);
 6298 
 6299             for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 6300                 Edge edge = m_graph.varArgChild(m_node, operandIndex);
 6301 
 6302                 switch (m_node-&gt;indexingType()) {
 6303                 case ALL_BLANK_INDEXING_TYPES:
 6304                 case ALL_UNDECIDED_INDEXING_TYPES:
 6305                     DFG_CRASH(m_graph, m_node, &quot;Bad indexing type&quot;);
 6306                     break;
 6307 
 6308                 case ALL_DOUBLE_INDEXING_TYPES:
 6309                     m_out.storeDouble(
 6310                         lowDouble(edge),
 6311                         arrayValues.butterfly, m_heaps.indexedDoubleProperties[operandIndex]);
 6312                     break;
 6313 
 6314                 case ALL_INT32_INDEXING_TYPES:
 6315                 case ALL_CONTIGUOUS_INDEXING_TYPES:
 6316                     m_out.store64(
 6317                         lowJSValue(edge, ManualOperandSpeculation),
 6318                         arrayValues.butterfly,
 6319                         m_heaps.forIndexingType(m_node-&gt;indexingType())-&gt;at(operandIndex));
 6320                     break;
 6321 
 6322                 default:
 6323                     DFG_CRASH(m_graph, m_node, &quot;Corrupt indexing type&quot;);
 6324                     break;
 6325                 }
 6326             }
 6327 
 6328             setJSValue(arrayValues.array);
 6329             mutatorFence();
 6330             return;
 6331         }
 6332 
 6333         if (!m_node-&gt;numChildren()) {
 6334             setJSValue(vmCall(
<a name="261" id="anc261"></a><span class="line-modified"> 6335                 Int64, operationNewEmptyArray, m_vmValue,</span>
 6336                 weakStructure(structure)));
 6337             return;
 6338         }
 6339 
 6340         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 6341         ASSERT(scratchSize);
 6342         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 6343         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 6344 
 6345         for (unsigned operandIndex = 0; operandIndex &lt; m_node-&gt;numChildren(); ++operandIndex) {
 6346             Edge edge = m_graph.varArgChild(m_node, operandIndex);
 6347             LValue valueToStore;
 6348             switch (m_node-&gt;indexingType()) {
 6349             case ALL_DOUBLE_INDEXING_TYPES:
 6350                 valueToStore = boxDouble(lowDouble(edge));
 6351                 break;
 6352             default:
 6353                 valueToStore = lowJSValue(edge, ManualOperandSpeculation);
 6354                 break;
 6355             }
 6356             m_out.store64(valueToStore, m_out.absolute(buffer + operandIndex));
 6357         }
 6358 
 6359         m_out.storePtr(
 6360             m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6361 
 6362         LValue result = vmCall(
<a name="262" id="anc262"></a><span class="line-modified"> 6363             Int64, operationNewArray, weakPointer(globalObject),</span>
 6364             weakStructure(structure), m_out.constIntPtr(buffer),
 6365             m_out.constIntPtr(m_node-&gt;numChildren()));
 6366 
 6367         m_out.storePtr(m_out.intPtrZero, m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6368 
 6369         setJSValue(result);
 6370     }
 6371 
 6372     void compileNewArrayWithSpread()
 6373     {
<a name="263" id="anc263"></a><span class="line-added"> 6374         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6375         if (m_graph.isWatchingHavingABadTimeWatchpoint(m_node)) {
 6376             CheckedInt32 startLength = 0;
 6377             BitVector* bitVector = m_node-&gt;bitVector();
 6378             HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 6379 
<a name="264" id="anc264"></a><span class="line-added"> 6380             if (m_node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added"> 6381                 Edge use = m_graph.varArgChild(m_node, 0);</span>
<span class="line-added"> 6382                 if (use-&gt;op() == PhantomSpread) {</span>
<span class="line-added"> 6383                     if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {</span>
<span class="line-added"> 6384                         auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added"> 6385                         if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added"> 6386                             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 6387                             LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added"> 6388                             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6389 </span>
<span class="line-added"> 6390                             LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);</span>
<span class="line-added"> 6391                             ValueFromBlock fastResult = m_out.anchor(fastArray);</span>
<span class="line-added"> 6392                             m_out.jump(continuation);</span>
<span class="line-added"> 6393 </span>
<span class="line-added"> 6394                             m_out.appendTo(slowPath, continuation);</span>
<span class="line-added"> 6395                             LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), frozenPointer(use-&gt;child1()-&gt;cellOperand()));</span>
<span class="line-added"> 6396                             ValueFromBlock slowResult = m_out.anchor(slowArray);</span>
<span class="line-added"> 6397                             m_out.jump(continuation);</span>
<span class="line-added"> 6398 </span>
<span class="line-added"> 6399                             m_out.appendTo(continuation);</span>
<span class="line-added"> 6400 </span>
<span class="line-added"> 6401                             mutatorFence();</span>
<span class="line-added"> 6402                             setJSValue(m_out.phi(pointerType(), slowResult, fastResult));</span>
<span class="line-added"> 6403                             return;</span>
<span class="line-added"> 6404                         }</span>
<span class="line-added"> 6405                     }</span>
<span class="line-added"> 6406                 } else {</span>
<span class="line-added"> 6407                     // If a node is producing JSImmutableButterfly, it must be contiguous.</span>
<span class="line-added"> 6408                     LValue immutableButterfly = lowCell(use);</span>
<span class="line-added"> 6409 </span>
<span class="line-added"> 6410                     RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 6411                     LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added"> 6412                     LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6413 </span>
<span class="line-added"> 6414                     LValue fastArray = allocateObject&lt;JSArray&gt;(structure, toButterfly(immutableButterfly), slowPath);</span>
<span class="line-added"> 6415                     ValueFromBlock fastResult = m_out.anchor(fastArray);</span>
<span class="line-added"> 6416                     m_out.jump(continuation);</span>
<span class="line-added"> 6417 </span>
<span class="line-added"> 6418                     m_out.appendTo(slowPath, continuation);</span>
<span class="line-added"> 6419                     LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), immutableButterfly);</span>
<span class="line-added"> 6420                     ValueFromBlock slowResult = m_out.anchor(slowArray);</span>
<span class="line-added"> 6421                     m_out.jump(continuation);</span>
<span class="line-added"> 6422 </span>
<span class="line-added"> 6423                     m_out.appendTo(continuation);</span>
<span class="line-added"> 6424 </span>
<span class="line-added"> 6425                     mutatorFence();</span>
<span class="line-added"> 6426                     setJSValue(m_out.phi(pointerType(), slowResult, fastResult));</span>
<span class="line-added"> 6427                     return;</span>
<span class="line-added"> 6428                 }</span>
<span class="line-added"> 6429             }</span>
<span class="line-added"> 6430 </span>
 6431             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6432                 if (!bitVector-&gt;get(i))
 6433                     ++startLength;
 6434                 else {
 6435                     Edge&amp; child = m_graph.varArgChild(m_node, i);
 6436                     if (child-&gt;op() == PhantomSpread &amp;&amp; child-&gt;child1()-&gt;op() == PhantomNewArrayBuffer)
 6437                         startLength += child-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 6438                 }
 6439             }
 6440 
 6441             if (startLength.hasOverflowed()) {
 6442                 terminate(Overflow);
 6443                 return;
 6444             }
 6445 
 6446             LValue length = m_out.constInt32(startLength.unsafeGet());
 6447 
 6448             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6449                 if (bitVector-&gt;get(i)) {
 6450                     Edge use = m_graph.varArgChild(m_node, i);
 6451                     CheckValue* lengthCheck = nullptr;
 6452                     if (use-&gt;op() == PhantomSpread) {
 6453                         if (use-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6454                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6455                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6456                             LValue spreadLength = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 6457                                 return getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6458                             }).iterator-&gt;value;
 6459                             lengthCheck = m_out.speculateAdd(length, spreadLength);
 6460                         }
 6461                     } else {
<a name="265" id="anc265"></a><span class="line-modified"> 6462                         LValue immutableButterfly = lowCell(use);</span>
<span class="line-modified"> 6463                         lengthCheck = m_out.speculateAdd(length, m_out.load32(toButterfly(immutableButterfly), m_heaps.Butterfly_publicLength));</span>
 6464                     }
 6465 
 6466                     if (lengthCheck) {
 6467                         blessSpeculation(lengthCheck, Overflow, noValue(), nullptr, m_origin);
 6468                         length = lengthCheck;
 6469                     }
 6470                 }
 6471             }
 6472 
 6473             LValue exceedsMaxAllowedLength = m_out.aboveOrEqual(length, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
 6474             blessSpeculation(m_out.speculate(exceedsMaxAllowedLength), Overflow, noValue(), nullptr, m_origin);
 6475 
 6476             RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
 6477             ArrayValues arrayValues = allocateUninitializedContiguousJSArray(length, structure);
 6478             LValue result = arrayValues.array;
 6479             LValue storage = arrayValues.butterfly;
 6480             LValue index = m_out.constIntPtr(0);
 6481 
 6482             for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6483                 Edge use = m_graph.varArgChild(m_node, i);
 6484                 if (bitVector-&gt;get(i)) {
 6485                     if (use-&gt;op() == PhantomSpread) {
 6486                         if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
 6487                             IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6488                             auto* array = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6489                             for (unsigned i = 0; i &lt; array-&gt;length(); ++i) {
 6490                                 // Because resulted array from NewArrayWithSpread is always contiguous, we should not generate value
 6491                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6492                                 int64_t value = JSValue::encode(array-&gt;get(i));
 6493                                 m_out.store64(m_out.constInt64(value), m_out.baseIndex(heap, storage, index, JSValue(), (Checked&lt;int32_t&gt;(sizeof(JSValue)) * i).unsafeGet()));
 6494                             }
 6495                             index = m_out.add(index, m_out.constIntPtr(array-&gt;length()));
 6496                         } else {
 6497                             RELEASE_ASSERT(use-&gt;child1()-&gt;op() == PhantomCreateRest);
 6498                             InlineCallFrame* inlineCallFrame = use-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6499                             unsigned numberOfArgumentsToSkip = use-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6500 
 6501                             LValue length = m_out.zeroExtPtr(cachedSpreadLengths.get(inlineCallFrame));
 6502                             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6503 
 6504                             LBasicBlock loopStart = m_out.newBlock();
 6505                             LBasicBlock continuation = m_out.newBlock();
 6506 
 6507                             ValueFromBlock loadIndexStart = m_out.anchor(m_out.constIntPtr(0));
 6508                             ValueFromBlock arrayIndexStart = m_out.anchor(index);
 6509                             ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 6510 
 6511                             m_out.branch(
 6512                                 m_out.isZero64(length),
 6513                                 unsure(continuation), unsure(loopStart));
 6514 
 6515                             LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6516 
 6517                             LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
 6518                             LValue loadIndex = m_out.phi(pointerType(), loadIndexStart);
 6519 
 6520                             LValue item = m_out.load64(m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 6521                             m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 6522 
 6523                             LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
 6524                             LValue nextLoadIndex = m_out.add(loadIndex, m_out.constIntPtr(1));
 6525                             ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 6526 
 6527                             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 6528                             m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 6529 
 6530                             m_out.branch(
 6531                                 m_out.below(nextLoadIndex, length),
 6532                                 unsure(loopStart), unsure(continuation));
 6533 
 6534                             m_out.appendTo(continuation, lastNext);
 6535                             index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 6536                         }
 6537                     } else {
 6538                         LBasicBlock loopStart = m_out.newBlock();
 6539                         LBasicBlock continuation = m_out.newBlock();
 6540 
<a name="266" id="anc266"></a><span class="line-modified"> 6541                         LValue immutableButterfly = lowCell(use);</span>
<span class="line-added"> 6542                         LValue immutableButterflyStorage = toButterfly(immutableButterfly);</span>
 6543 
<a name="267" id="anc267"></a><span class="line-modified"> 6544                         ValueFromBlock immutableButterflyIndexStart = m_out.anchor(m_out.constIntPtr(0));</span>
 6545                         ValueFromBlock arrayIndexStart = m_out.anchor(index);
 6546                         ValueFromBlock arrayIndexStartForFinish = m_out.anchor(index);
 6547 
<a name="268" id="anc268"></a><span class="line-modified"> 6548                         LValue immutableButterflySize = m_out.zeroExtPtr(m_out.load32(immutableButterflyStorage, m_heaps.Butterfly_publicLength));</span>
 6549 
 6550                         m_out.branch(
<a name="269" id="anc269"></a><span class="line-modified"> 6551                             m_out.isZero64(immutableButterflySize),</span>
 6552                             unsure(continuation), unsure(loopStart));
 6553 
 6554                         LBasicBlock lastNext = m_out.appendTo(loopStart, continuation);
 6555 
 6556                         LValue arrayIndex = m_out.phi(pointerType(), arrayIndexStart);
<a name="270" id="anc270"></a><span class="line-modified"> 6557                         LValue immutableButterflyIndex = m_out.phi(pointerType(), immutableButterflyIndexStart);</span>
 6558 
<a name="271" id="anc271"></a><span class="line-modified"> 6559                         LValue item = m_out.load64(m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, immutableButterflyIndex));</span>
 6560                         m_out.store64(item, m_out.baseIndex(m_heaps.indexedContiguousProperties, storage, arrayIndex));
 6561 
 6562                         LValue nextArrayIndex = m_out.add(arrayIndex, m_out.constIntPtr(1));
<a name="272" id="anc272"></a><span class="line-modified"> 6563                         LValue nextImmutableButterflyIndex = m_out.add(immutableButterflyIndex, m_out.constIntPtr(1));</span>
 6564                         ValueFromBlock arrayIndexLoopForFinish = m_out.anchor(nextArrayIndex);
 6565 
<a name="273" id="anc273"></a><span class="line-modified"> 6566                         m_out.addIncomingToPhi(immutableButterflyIndex, m_out.anchor(nextImmutableButterflyIndex));</span>
 6567                         m_out.addIncomingToPhi(arrayIndex, m_out.anchor(nextArrayIndex));
 6568 
 6569                         m_out.branch(
<a name="274" id="anc274"></a><span class="line-modified"> 6570                             m_out.below(nextImmutableButterflyIndex, immutableButterflySize),</span>
 6571                             unsure(loopStart), unsure(continuation));
 6572 
 6573                         m_out.appendTo(continuation, lastNext);
 6574                         index = m_out.phi(pointerType(), arrayIndexStartForFinish, arrayIndexLoopForFinish);
 6575                     }
 6576                 } else {
 6577                     IndexedAbstractHeap&amp; heap = m_heaps.indexedContiguousProperties;
 6578                     LValue item = lowJSValue(use);
 6579                     m_out.store64(item, m_out.baseIndex(heap, storage, index));
 6580                     index = m_out.add(index, m_out.constIntPtr(1));
 6581                 }
 6582             }
 6583 
 6584             mutatorFence();
 6585             setJSValue(result);
 6586             return;
 6587         }
 6588 
 6589         ASSERT(m_node-&gt;numChildren());
 6590         size_t scratchSize = sizeof(EncodedJSValue) * m_node-&gt;numChildren();
 6591         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 6592         EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 6593         BitVector* bitVector = m_node-&gt;bitVector();
 6594         for (unsigned i = 0; i &lt; m_node-&gt;numChildren(); ++i) {
 6595             Edge use = m_graph.m_varArgChildren[m_node-&gt;firstChild() + i];
 6596             LValue value;
 6597             if (bitVector-&gt;get(i))
 6598                 value = lowCell(use);
 6599             else
 6600                 value = lowJSValue(use);
 6601             m_out.store64(value, m_out.absolute(&amp;buffer[i]));
 6602         }
 6603 
 6604         m_out.storePtr(m_out.constIntPtr(scratchSize), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
<a name="275" id="anc275"></a><span class="line-modified"> 6605         LValue result = vmCall(Int64, operationNewArrayWithSpreadSlow, weakPointer(globalObject), m_out.constIntPtr(buffer), m_out.constInt32(m_node-&gt;numChildren()));</span>
 6606         m_out.storePtr(m_out.constIntPtr(0), m_out.absolute(scratchBuffer-&gt;addressOfActiveLength()));
 6607 
 6608         setJSValue(result);
 6609     }
 6610 
 6611     void compileCreateThis()
 6612     {
<a name="276" id="anc276"></a><span class="line-added"> 6613         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6614         LValue callee = lowCell(m_node-&gt;child1());
 6615 
 6616         LBasicBlock isFunctionBlock = m_out.newBlock();
 6617         LBasicBlock hasRareData = m_out.newBlock();
 6618         LBasicBlock slowPath = m_out.newBlock();
 6619         LBasicBlock continuation = m_out.newBlock();
 6620 
 6621         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowPath));
 6622 
 6623         LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);
<a name="277" id="anc277"></a><span class="line-modified"> 6624         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-modified"> 6625         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowPath), usually(hasRareData));</span>
 6626 
 6627         m_out.appendTo(hasRareData, slowPath);
<a name="278" id="anc278"></a><span class="line-added"> 6628         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
 6629         LValue allocator = m_out.loadPtr(rareData, m_heaps.FunctionRareData_allocator);
 6630         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_structure);
 6631         LValue butterfly = m_out.constIntPtr(0);
 6632         ValueFromBlock fastResult = m_out.anchor(allocateObject(allocator, structure, butterfly, slowPath));
 6633         m_out.jump(continuation);
 6634 
 6635         m_out.appendTo(slowPath, continuation);
 6636         ValueFromBlock slowResult = m_out.anchor(vmCall(
<a name="279" id="anc279"></a><span class="line-modified"> 6637             Int64, operationCreateThis, weakPointer(globalObject), callee, m_out.constInt32(m_node-&gt;inlineCapacity())));</span>
 6638         m_out.jump(continuation);
 6639 
 6640         m_out.appendTo(continuation, lastNext);
 6641         LValue result = m_out.phi(Int64, fastResult, slowResult);
 6642 
 6643         mutatorFence();
 6644         setJSValue(result);
 6645     }
 6646 
<a name="280" id="anc280"></a><span class="line-added"> 6647     void compileCreatePromise()</span>
<span class="line-added"> 6648     {</span>
<span class="line-added"> 6649         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 6650 </span>
<span class="line-added"> 6651         LValue callee = lowCell(m_node-&gt;child1());</span>
<span class="line-added"> 6652 </span>
<span class="line-added"> 6653         LBasicBlock derivedCase = m_out.newBlock();</span>
<span class="line-added"> 6654         LBasicBlock isFunctionBlock = m_out.newBlock();</span>
<span class="line-added"> 6655         LBasicBlock hasRareData = m_out.newBlock();</span>
<span class="line-added"> 6656         LBasicBlock hasStructure = m_out.newBlock();</span>
<span class="line-added"> 6657         LBasicBlock checkGlobalObjectCase = m_out.newBlock();</span>
<span class="line-added"> 6658         LBasicBlock fastAllocationCase = m_out.newBlock();</span>
<span class="line-added"> 6659         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added"> 6660         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6661 </span>
<span class="line-added"> 6662         ValueFromBlock promiseStructure = m_out.anchor(weakStructure(m_graph.registerStructure(m_node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())));</span>
<span class="line-added"> 6663         m_out.branch(m_out.equal(callee, weakPointer(m_node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())), unsure(fastAllocationCase), unsure(derivedCase));</span>
<span class="line-added"> 6664 </span>
<span class="line-added"> 6665         LBasicBlock lastNext = m_out.appendTo(derivedCase, isFunctionBlock);</span>
<span class="line-added"> 6666         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowCase));</span>
<span class="line-added"> 6667 </span>
<span class="line-added"> 6668         m_out.appendTo(isFunctionBlock, hasRareData);</span>
<span class="line-added"> 6669         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added"> 6670         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowCase), usually(hasRareData));</span>
<span class="line-added"> 6671 </span>
<span class="line-added"> 6672         m_out.appendTo(hasRareData, hasStructure);</span>
<span class="line-added"> 6673         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added"> 6674         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added"> 6675         m_out.branch(m_out.isZero64(structure), rarely(slowCase), usually(hasStructure));</span>
<span class="line-added"> 6676 </span>
<span class="line-added"> 6677         m_out.appendTo(hasStructure, checkGlobalObjectCase);</span>
<span class="line-added"> 6678         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_classInfo), m_out.constIntPtr(m_node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())), usually(checkGlobalObjectCase), rarely(slowCase));</span>
<span class="line-added"> 6679 </span>
<span class="line-added"> 6680         m_out.appendTo(checkGlobalObjectCase, fastAllocationCase);</span>
<span class="line-added"> 6681         ValueFromBlock derivedStructure = m_out.anchor(structure);</span>
<span class="line-added"> 6682         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_globalObject), weakPointer(globalObject)), usually(fastAllocationCase), rarely(slowCase));</span>
<span class="line-added"> 6683 </span>
<span class="line-added"> 6684         m_out.appendTo(fastAllocationCase, slowCase);</span>
<span class="line-added"> 6685         LValue promise;</span>
<span class="line-added"> 6686         if (m_node-&gt;isInternalPromise())</span>
<span class="line-added"> 6687             promise = allocateObject&lt;JSInternalPromise&gt;(m_out.phi(pointerType(), promiseStructure, derivedStructure), m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6688         else</span>
<span class="line-added"> 6689             promise = allocateObject&lt;JSPromise&gt;(m_out.phi(pointerType(), promiseStructure, derivedStructure), m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6690         m_out.store64(m_out.constInt64(JSValue::encode(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)))), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::Flags)]);</span>
<span class="line-added"> 6691         m_out.store64(m_out.constInt64(JSValue::encode(jsUndefined())), promise, m_heaps.JSInternalFieldObjectImpl_internalFields[static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult)]);</span>
<span class="line-added"> 6692         mutatorFence();</span>
<span class="line-added"> 6693         ValueFromBlock fastResult = m_out.anchor(promise);</span>
<span class="line-added"> 6694         m_out.jump(continuation);</span>
<span class="line-added"> 6695 </span>
<span class="line-added"> 6696         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added"> 6697         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, m_node-&gt;isInternalPromise() ? operationCreateInternalPromise : operationCreatePromise, weakPointer(globalObject), callee));</span>
<span class="line-added"> 6698         m_out.jump(continuation);</span>
<span class="line-added"> 6699 </span>
<span class="line-added"> 6700         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 6701         LValue result = m_out.phi(Int64, fastResult, slowResult);</span>
<span class="line-added"> 6702 </span>
<span class="line-added"> 6703         setJSValue(result);</span>
<span class="line-added"> 6704     }</span>
<span class="line-added"> 6705 </span>
<span class="line-added"> 6706     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added"> 6707     void compileCreateInternalFieldObject(Operation operation)</span>
<span class="line-added"> 6708     {</span>
<span class="line-added"> 6709         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 6710 </span>
<span class="line-added"> 6711         LValue callee = lowCell(m_node-&gt;child1());</span>
<span class="line-added"> 6712 </span>
<span class="line-added"> 6713         LBasicBlock isFunctionBlock = m_out.newBlock();</span>
<span class="line-added"> 6714         LBasicBlock hasRareData = m_out.newBlock();</span>
<span class="line-added"> 6715         LBasicBlock hasStructure = m_out.newBlock();</span>
<span class="line-added"> 6716         LBasicBlock checkGlobalObjectCase = m_out.newBlock();</span>
<span class="line-added"> 6717         LBasicBlock fastAllocationCase = m_out.newBlock();</span>
<span class="line-added"> 6718         LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added"> 6719         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 6720 </span>
<span class="line-added"> 6721         m_out.branch(isFunction(callee, provenType(m_node-&gt;child1())), usually(isFunctionBlock), rarely(slowCase));</span>
<span class="line-added"> 6722 </span>
<span class="line-added"> 6723         LBasicBlock lastNext = m_out.appendTo(isFunctionBlock, hasRareData);</span>
<span class="line-added"> 6724         LValue rareDataTags = m_out.loadPtr(callee, m_heaps.JSFunction_executableOrRareData);</span>
<span class="line-added"> 6725         m_out.branch(m_out.testIsZeroPtr(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag)), rarely(slowCase), usually(hasRareData));</span>
<span class="line-added"> 6726 </span>
<span class="line-added"> 6727         m_out.appendTo(hasRareData, hasStructure);</span>
<span class="line-added"> 6728         LValue rareData = m_out.sub(rareDataTags, m_out.constIntPtr(JSFunction::rareDataTag));</span>
<span class="line-added"> 6729         LValue structure = m_out.loadPtr(rareData, m_heaps.FunctionRareData_internalFunctionAllocationProfile_structure);</span>
<span class="line-added"> 6730         m_out.branch(m_out.isZero64(structure), rarely(slowCase), usually(hasStructure));</span>
<span class="line-added"> 6731 </span>
<span class="line-added"> 6732         m_out.appendTo(hasStructure, checkGlobalObjectCase);</span>
<span class="line-added"> 6733         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_classInfo), m_out.constIntPtr(JSClass::info())), usually(checkGlobalObjectCase), rarely(slowCase));</span>
<span class="line-added"> 6734 </span>
<span class="line-added"> 6735         m_out.appendTo(checkGlobalObjectCase, fastAllocationCase);</span>
<span class="line-added"> 6736         m_out.branch(m_out.equal(m_out.loadPtr(structure, m_heaps.Structure_globalObject), weakPointer(globalObject)), usually(fastAllocationCase), rarely(slowCase));</span>
<span class="line-added"> 6737 </span>
<span class="line-added"> 6738         m_out.appendTo(fastAllocationCase, slowCase);</span>
<span class="line-added"> 6739         LValue object = allocateObject&lt;JSClass&gt;(structure, m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 6740         auto initialValues = JSClass::initialValues();</span>
<span class="line-added"> 6741         static_assert(initialValues.size() == JSClass::numberOfInternalFields, &quot;We don&#39;t support non-constant fields in create yet.&quot;);</span>
<span class="line-added"> 6742         for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added"> 6743             m_out.store64(m_out.constInt64(JSValue::encode(initialValues[index])), object, m_heaps.JSInternalFieldObjectImpl_internalFields[index]);</span>
<span class="line-added"> 6744         mutatorFence();</span>
<span class="line-added"> 6745         ValueFromBlock fastResult = m_out.anchor(object);</span>
<span class="line-added"> 6746         m_out.jump(continuation);</span>
<span class="line-added"> 6747 </span>
<span class="line-added"> 6748         m_out.appendTo(slowCase, continuation);</span>
<span class="line-added"> 6749         ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, weakPointer(globalObject), callee));</span>
<span class="line-added"> 6750         m_out.jump(continuation);</span>
<span class="line-added"> 6751 </span>
<span class="line-added"> 6752         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 6753         LValue result = m_out.phi(Int64, fastResult, slowResult);</span>
<span class="line-added"> 6754 </span>
<span class="line-added"> 6755         setJSValue(result);</span>
<span class="line-added"> 6756     }</span>
<span class="line-added"> 6757 </span>
<span class="line-added"> 6758     void compileCreateGenerator()</span>
<span class="line-added"> 6759     {</span>
<span class="line-added"> 6760         compileCreateInternalFieldObject&lt;JSGenerator&gt;(operationCreateGenerator);</span>
<span class="line-added"> 6761     }</span>
<span class="line-added"> 6762 </span>
<span class="line-added"> 6763     void compileCreateAsyncGenerator()</span>
<span class="line-added"> 6764     {</span>
<span class="line-added"> 6765         compileCreateInternalFieldObject&lt;JSAsyncGenerator&gt;(operationCreateAsyncGenerator);</span>
<span class="line-added"> 6766     }</span>
<span class="line-added"> 6767 </span>
 6768     void compileSpread()
 6769     {
<a name="281" id="anc281"></a><span class="line-added"> 6770         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 6771         if (m_node-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
<a name="282" id="anc282"></a><span class="line-added"> 6772             ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(m_node-&gt;child1().node()));</span>
<span class="line-added"> 6773 </span>
<span class="line-added"> 6774             // FIXME: JSImmutableButterfly::createFromArray should support re-using non contiguous indexing types as well.</span>
<span class="line-added"> 6775             auto* immutableButterfly = m_node-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();</span>
<span class="line-added"> 6776             if (hasContiguous(immutableButterfly-&gt;indexingType())) {</span>
<span class="line-added"> 6777                 setJSValue(frozenPointer(m_node-&gt;child1()-&gt;cellOperand()));</span>
<span class="line-added"> 6778                 return;</span>
<span class="line-added"> 6779             }</span>
<span class="line-added"> 6780 </span>
 6781             LBasicBlock slowAllocation = m_out.newBlock();
 6782             LBasicBlock continuation = m_out.newBlock();
 6783 
<a name="283" id="anc283"></a><span class="line-modified"> 6784             ASSERT(immutableButterfly-&gt;length() &lt;= MAX_STORAGE_VECTOR_LENGTH);</span>
 6785 
<a name="284" id="anc284"></a><span class="line-modified"> 6786             LValue fastImmutableButterflyValue = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(</span>
<span class="line-modified"> 6787                 m_out.constIntPtr(JSImmutableButterfly::allocationSize(immutableButterfly-&gt;length()).unsafeGet()),</span>
<span class="line-modified"> 6788                 m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowAllocation);</span>
<span class="line-modified"> 6789             LValue fastImmutableButterflyStorage = toButterfly(fastImmutableButterflyValue);</span>
<span class="line-modified"> 6790             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastImmutableButterflyStorage, m_heaps.Butterfly_publicLength);</span>
<span class="line-added"> 6791             m_out.store32(m_out.constInt32(immutableButterfly-&gt;length()), fastImmutableButterflyStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added"> 6792             ValueFromBlock fastImmutableButterfly = m_out.anchor(fastImmutableButterflyValue);</span>
 6793             m_out.jump(continuation);
 6794 
 6795             LBasicBlock lastNext = m_out.appendTo(slowAllocation, continuation);
<a name="285" id="anc285"></a><span class="line-modified"> 6796             ValueFromBlock slowImmutableButterfly = m_out.anchor(vmCall(pointerType(), operationCreateImmutableButterfly, weakPointer(globalObject), m_out.constInt32(immutableButterfly-&gt;length())));</span>
 6797             m_out.jump(continuation);
 6798 
 6799             m_out.appendTo(continuation, lastNext);
<a name="286" id="anc286"></a><span class="line-modified"> 6800             LValue immutableButterflyValue = m_out.phi(pointerType(), fastImmutableButterfly, slowImmutableButterfly);</span>
<span class="line-added"> 6801             LValue immutableButterflyStorage = toButterfly(immutableButterflyValue);</span>
 6802             for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); i++) {
 6803                 // Because forwarded values are drained as JSValue, we should not generate value
 6804                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 6805                 int64_t value = JSValue::encode(immutableButterfly-&gt;get(i));
 6806                 m_out.store64(
 6807                     m_out.constInt64(value),
<a name="287" id="anc287"></a><span class="line-modified"> 6808                     m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, m_out.constIntPtr(i), jsNumber(i)));</span>
 6809             }
 6810             mutatorFence();
<a name="288" id="anc288"></a><span class="line-modified"> 6811             setJSValue(immutableButterflyValue);</span>
 6812             return;
 6813         }
 6814 
 6815         if (m_node-&gt;child1()-&gt;op() == PhantomCreateRest) {
 6816             // This IR is rare to generate since it requires escaping the Spread
 6817             // but not the CreateRest. In bytecode, we have only few operations that
 6818             // accept Spread&#39;s result as input. This usually leads to the Spread node not
 6819             // escaping. However, this can happen if for example we generate a PutStack on
 6820             // the Spread but nothing escapes the CreateRest.
<a name="289" id="anc289"></a><span class="line-added"> 6821 </span>
<span class="line-added"> 6822             ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(m_node-&gt;child1().node()));</span>
<span class="line-added"> 6823 </span>
<span class="line-added"> 6824             LBasicBlock fastAllocation = m_out.newBlock();</span>
 6825             LBasicBlock loopHeader = m_out.newBlock();
 6826             LBasicBlock loopBody = m_out.newBlock();
 6827             LBasicBlock slowAllocation = m_out.newBlock();
 6828             LBasicBlock continuation = m_out.newBlock();
<a name="290" id="anc290"></a>
 6829 
 6830             InlineCallFrame* inlineCallFrame = m_node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
 6831             unsigned numberOfArgumentsToSkip = m_node-&gt;child1()-&gt;numberOfArgumentsToSkip();
 6832             LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 6833             LValue length = getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip);
 6834             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6835             LValue size = m_out.add(
 6836                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<a name="291" id="anc291"></a><span class="line-modified"> 6837                 m_out.constIntPtr(JSImmutableButterfly::offsetOfData()));</span>
<span class="line-modified"> 6838             m_out.branch(m_out.above(length, m_out.constInt32(MAX_STORAGE_VECTOR_LENGTH)), rarely(slowAllocation), usually(fastAllocation));</span>
<span class="line-modified"> 6839 </span>
<span class="line-modified"> 6840             LBasicBlock lastNext = m_out.appendTo(fastAllocation, slowAllocation);</span>
<span class="line-added"> 6841             LValue fastArrayValue = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(size, m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowAllocation);</span>
<span class="line-added"> 6842             LValue fastArrayStorage = toButterfly(fastArrayValue);</span>
<span class="line-added"> 6843             m_out.store32(length, fastArrayStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added"> 6844             m_out.store32(length, fastArrayStorage, m_heaps.Butterfly_publicLength);</span>
 6845             ValueFromBlock fastArray = m_out.anchor(fastArrayValue);
 6846             m_out.jump(loopHeader);
 6847 
 6848             m_out.appendTo(slowAllocation, loopHeader);
<a name="292" id="anc292"></a><span class="line-modified"> 6849             ValueFromBlock slowArray = m_out.anchor(vmCall(pointerType(), operationCreateImmutableButterfly, weakPointer(globalObject), length));</span>
 6850             m_out.jump(loopHeader);
 6851 
 6852             m_out.appendTo(loopHeader, loopBody);
<a name="293" id="anc293"></a><span class="line-modified"> 6853             LValue immutableButterfly = m_out.phi(pointerType(), fastArray, slowArray);</span>
<span class="line-added"> 6854             LValue immutableButterflyStorage = toButterfly(immutableButterfly);</span>
 6855             ValueFromBlock startIndex = m_out.anchor(m_out.constIntPtr(0));
 6856             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopBody));
 6857 
 6858             m_out.appendTo(loopBody, continuation);
 6859             LValue index = m_out.phi(pointerType(), startIndex);
 6860             LValue value = m_out.load64(
 6861                 m_out.baseIndex(m_heaps.variables, sourceStart, index));
<a name="294" id="anc294"></a><span class="line-modified"> 6862             m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, immutableButterflyStorage, index));</span>
 6863             LValue nextIndex = m_out.add(m_out.constIntPtr(1), index);
 6864             m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6865             m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)), unsure(loopBody), unsure(continuation));
 6866 
 6867             m_out.appendTo(continuation, lastNext);
 6868             mutatorFence();
<a name="295" id="anc295"></a><span class="line-modified"> 6869             setJSValue(immutableButterfly);</span>
 6870             return;
 6871         }
 6872 
 6873         LValue argument = lowCell(m_node-&gt;child1());
 6874 
 6875         LValue result;
 6876 
 6877         if (m_node-&gt;child1().useKind() == ArrayUse)
 6878             speculateArray(m_node-&gt;child1());
 6879 
 6880         if (m_graph.canDoFastSpread(m_node, m_state.forNode(m_node-&gt;child1()))) {
<a name="296" id="anc296"></a><span class="line-added"> 6881             LBasicBlock copyOnWriteContiguousCheck = m_out.newBlock();</span>
<span class="line-added"> 6882             LBasicBlock copyOnWritePropagation = m_out.newBlock();</span>
 6883             LBasicBlock preLoop = m_out.newBlock();
 6884             LBasicBlock loopSelection = m_out.newBlock();
 6885             LBasicBlock contiguousLoopStart = m_out.newBlock();
 6886             LBasicBlock doubleLoopStart = m_out.newBlock();
<a name="297" id="anc297"></a><span class="line-added"> 6887             LBasicBlock fastPath = m_out.newBlock();</span>
 6888             LBasicBlock slowPath = m_out.newBlock();
 6889             LBasicBlock continuation = m_out.newBlock();
 6890 
<a name="298" id="anc298"></a><span class="line-modified"> 6891             LValue indexingMode = m_out.load8ZeroExt32(argument, m_heaps.JSCell_indexingTypeAndMisc);</span>
<span class="line-modified"> 6892             LValue indexingShape = m_out.bitAnd(indexingMode, m_out.constInt32(IndexingShapeMask));</span>
 6893             LValue isOKIndexingType = m_out.belowOrEqual(
 6894                 m_out.sub(indexingShape, m_out.constInt32(Int32Shape)),
 6895                 m_out.constInt32(ContiguousShape - Int32Shape));
 6896 
<a name="299" id="anc299"></a><span class="line-modified"> 6897             m_out.branch(isOKIndexingType, unsure(copyOnWriteContiguousCheck), unsure(slowPath));</span>
<span class="line-modified"> 6898             LBasicBlock lastNext = m_out.appendTo(copyOnWriteContiguousCheck, copyOnWritePropagation);</span>

 6899             LValue butterfly = m_out.loadPtr(argument, m_heaps.JSObject_butterfly);
<a name="300" id="anc300"></a><span class="line-added"> 6900             m_out.branch(m_out.equal(m_out.bitAnd(indexingMode, m_out.constInt32(IndexingModeMask)), m_out.constInt32(CopyOnWriteArrayWithContiguous)), unsure(copyOnWritePropagation), unsure(preLoop));</span>
<span class="line-added"> 6901 </span>
<span class="line-added"> 6902             m_out.appendTo(copyOnWritePropagation, preLoop);</span>
<span class="line-added"> 6903             ValueFromBlock sharedResult = m_out.anchor(m_out.add(butterfly, m_out.constIntPtr(-JSImmutableButterfly::offsetOfData())));</span>
<span class="line-added"> 6904             m_out.jump(continuation);</span>
<span class="line-added"> 6905 </span>
<span class="line-added"> 6906             m_out.appendTo(preLoop, fastPath);</span>
 6907             LValue length = m_out.load32NonNegative(butterfly, m_heaps.Butterfly_publicLength);
 6908             static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;Assumed in the code below.&quot;);
 6909             LValue size = m_out.add(
 6910                 m_out.shl(m_out.zeroExtPtr(length), m_out.constInt32(3)),
<a name="301" id="anc301"></a><span class="line-modified"> 6911                 m_out.constIntPtr(JSImmutableButterfly::offsetOfData()));</span>
<span class="line-modified"> 6912             m_out.branch(m_out.above(length, m_out.constInt32(MAX_STORAGE_VECTOR_LENGTH)), rarely(slowPath), usually(fastPath));</span>
<span class="line-modified"> 6913 </span>
<span class="line-added"> 6914             m_out.appendTo(fastPath, loopSelection);</span>
<span class="line-added"> 6915             LValue fastAllocation = allocateVariableSizedCell&lt;JSImmutableButterfly&gt;(size, m_graph.m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), slowPath);</span>
<span class="line-added"> 6916             LValue fastStorage = toButterfly(fastAllocation);</span>
<span class="line-added"> 6917             m_out.store32(length, fastStorage, m_heaps.Butterfly_vectorLength);</span>
<span class="line-added"> 6918             m_out.store32(length, fastStorage, m_heaps.Butterfly_publicLength);</span>
 6919             ValueFromBlock fastResult = m_out.anchor(fastAllocation);
<a name="302" id="anc302"></a>
 6920 
 6921             ValueFromBlock startIndexForContiguous = m_out.anchor(m_out.constIntPtr(0));
 6922             ValueFromBlock startIndexForDouble = m_out.anchor(m_out.constIntPtr(0));
 6923 
 6924             m_out.branch(m_out.isZero32(length), unsure(continuation), unsure(loopSelection));
 6925 
 6926             m_out.appendTo(loopSelection, contiguousLoopStart);
 6927             m_out.branch(m_out.equal(indexingShape, m_out.constInt32(DoubleShape)),
 6928                 unsure(doubleLoopStart), unsure(contiguousLoopStart));
 6929 
 6930             {
 6931                 m_out.appendTo(contiguousLoopStart, doubleLoopStart);
 6932                 LValue index = m_out.phi(pointerType(), startIndexForContiguous);
 6933 
 6934                 TypedPointer loadSite = m_out.baseIndex(m_heaps.root, butterfly, index, ScaleEight); // We read TOP here since we can be reading either int32 or contiguous properties.
 6935                 LValue value = m_out.load64(loadSite);
 6936                 value = m_out.select(m_out.isZero64(value), m_out.constInt64(JSValue::encode(jsUndefined())), value);
<a name="303" id="anc303"></a><span class="line-modified"> 6937                 m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, fastStorage, index));</span>
 6938 
 6939                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6940                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6941 
 6942                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6943                     unsure(contiguousLoopStart), unsure(continuation));
 6944             }
 6945 
 6946             {
 6947                 m_out.appendTo(doubleLoopStart, slowPath);
 6948                 LValue index = m_out.phi(pointerType(), startIndexForDouble);
 6949 
 6950                 LValue value = m_out.loadDouble(m_out.baseIndex(m_heaps.indexedDoubleProperties, butterfly, index));
 6951                 LValue isNaN = m_out.doubleNotEqualOrUnordered(value, value);
 6952                 LValue holeResult = m_out.constInt64(JSValue::encode(jsUndefined()));
 6953                 LValue normalResult = boxDouble(value);
 6954                 value = m_out.select(isNaN, holeResult, normalResult);
<a name="304" id="anc304"></a><span class="line-modified"> 6955                 m_out.store64(value, m_out.baseIndex(m_heaps.indexedContiguousProperties, fastStorage, index));</span>
 6956 
 6957                 LValue nextIndex = m_out.add(index, m_out.constIntPtr(1));
 6958                 m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
 6959 
 6960                 m_out.branch(m_out.below(nextIndex, m_out.zeroExtPtr(length)),
 6961                     unsure(doubleLoopStart), unsure(continuation));
 6962             }
 6963 
 6964             m_out.appendTo(slowPath, continuation);
<a name="305" id="anc305"></a><span class="line-modified"> 6965             ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationSpreadFastArray, weakPointer(globalObject), argument));</span>
 6966             m_out.jump(continuation);
 6967 
 6968             m_out.appendTo(continuation, lastNext);
<a name="306" id="anc306"></a><span class="line-modified"> 6969             result = m_out.phi(pointerType(), sharedResult, fastResult, slowResult);</span>
 6970             mutatorFence();
 6971         } else
<a name="307" id="anc307"></a><span class="line-modified"> 6972             result = vmCall(pointerType(), operationSpreadGeneric, weakPointer(globalObject), argument);</span>
 6973 
 6974         setJSValue(result);
 6975     }
 6976 
 6977     void compileNewArrayBuffer()
 6978     {
 6979         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 6980         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 6981             m_node-&gt;indexingMode()));
 6982         auto* immutableButterfly = m_node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 6983 
 6984         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingMode())) {
 6985             LBasicBlock slowPath = m_out.newBlock();
 6986             LBasicBlock continuation = m_out.newBlock();
 6987 
 6988             LValue fastArray = allocateObject&lt;JSArray&gt;(structure, m_out.constIntPtr(immutableButterfly-&gt;toButterfly()), slowPath);
 6989             ValueFromBlock fastResult = m_out.anchor(fastArray);
 6990             m_out.jump(continuation);
 6991 
 6992             m_out.appendTo(slowPath, continuation);
<a name="308" id="anc308"></a><span class="line-modified"> 6993             LValue slowArray = vmCall(Int64, operationNewArrayBuffer, m_vmValue, weakStructure(structure), frozenPointer(m_node-&gt;cellOperand()));</span>
 6994             ValueFromBlock slowResult = m_out.anchor(slowArray);
 6995             m_out.jump(continuation);
 6996 
 6997             m_out.appendTo(continuation);
 6998 
 6999             mutatorFence();
 7000             setJSValue(m_out.phi(pointerType(), slowResult, fastResult));
 7001             return;
 7002         }
 7003 
 7004         setJSValue(vmCall(
<a name="309" id="anc309"></a><span class="line-modified"> 7005             Int64, operationNewArrayBuffer, m_vmValue,</span>
<span class="line-modified"> 7006             weakStructure(structure), frozenPointer(m_node-&gt;cellOperand())));</span>
 7007     }
 7008 
 7009     void compileNewArrayWithSize()
 7010     {
 7011         LValue publicLength = lowInt32(m_node-&gt;child1());
 7012 
 7013         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 7014         RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(
 7015             m_node-&gt;indexingType()));
 7016 
 7017         if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(m_node-&gt;indexingType())) {
 7018             IndexingType indexingType = m_node-&gt;indexingType();
 7019             setJSValue(
 7020                 allocateJSArray(
 7021                     publicLength, publicLength, weakPointer(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType)), m_out.constInt32(indexingType)).array);
 7022             mutatorFence();
 7023             return;
 7024         }
 7025 
 7026         LValue structureValue = m_out.select(
 7027             m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)),
 7028             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))),
 7029             weakStructure(structure));
<a name="310" id="anc310"></a><span class="line-modified"> 7030         setJSValue(vmCall(Int64, operationNewArrayWithSize, weakPointer(globalObject), structureValue, publicLength, m_out.intPtrZero));</span>
 7031     }
 7032 
 7033     void compileNewTypedArray()
 7034     {
 7035         TypedArrayType typedArrayType = m_node-&gt;typedArrayType();
 7036         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 7037 
 7038         switch (m_node-&gt;child1().useKind()) {
 7039         case Int32Use: {
 7040             RegisteredStructure structure = m_graph.registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 7041 
 7042             LValue size = lowInt32(m_node-&gt;child1());
 7043 
 7044             LBasicBlock smallEnoughCase = m_out.newBlock();
 7045             LBasicBlock slowCase = m_out.newBlock();
 7046             LBasicBlock continuation = m_out.newBlock();
 7047 
 7048             ValueFromBlock noStorage = m_out.anchor(m_out.intPtrZero);
 7049 
 7050             m_out.branch(
 7051                 m_out.above(size, m_out.constInt32(JSArrayBufferView::fastSizeLimit)),
 7052                 rarely(slowCase), usually(smallEnoughCase));
 7053 
 7054             LBasicBlock lastNext = m_out.appendTo(smallEnoughCase, slowCase);
 7055 
 7056             LValue byteSize =
 7057                 m_out.shl(m_out.zeroExtPtr(size), m_out.constInt32(logElementSize(typedArrayType)));
 7058             if (elementSize(typedArrayType) &lt; 8) {
 7059                 byteSize = m_out.bitAnd(
 7060                     m_out.add(byteSize, m_out.constIntPtr(7)),
 7061                     m_out.constIntPtr(~static_cast&lt;intptr_t&gt;(7)));
 7062             }
 7063 
 7064             LValue allocator = allocatorForSize(vm().primitiveGigacageAuxiliarySpace, byteSize, slowCase);
 7065             LValue storage = allocateHeapCell(allocator, slowCase);
 7066 
 7067             splatWords(
 7068                 storage,
 7069                 m_out.int32Zero,
 7070                 m_out.castToInt32(m_out.lShr(byteSize, m_out.constIntPtr(3))),
 7071                 m_out.int64Zero,
 7072                 m_heaps.typedArrayProperties);
 7073 
 7074 #if CPU(ARM64E)
 7075             {
 7076                 LValue sizePtr = m_out.zeroExtPtr(size);
 7077                 PatchpointValue* authenticate = m_out.patchpoint(pointerType());
 7078                 authenticate-&gt;appendSomeRegister(storage);
 7079                 authenticate-&gt;append(sizePtr, B3::ValueRep(B3::ValueRep::SomeLateRegister));
 7080                 authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 7081                     jit.move(params[1].gpr(), params[0].gpr());
 7082                     jit.tagArrayPtr(params[2].gpr(), params[0].gpr());
 7083                 });
 7084                 storage = authenticate;
 7085             }
 7086 #endif
 7087 
 7088             ValueFromBlock haveStorage = m_out.anchor(storage);
 7089 
<a name="311" id="anc311"></a><span class="line-modified"> 7090             LValue fastResultValue = nullptr;</span>
<span class="line-modified"> 7091             switch (typedArrayType) {</span>
<span class="line-added"> 7092 #define TYPED_ARRAY_TYPE_CASE(name) \</span>
<span class="line-added"> 7093             case Type ## name: \</span>
<span class="line-added"> 7094                 fastResultValue = allocateObject&lt;JS##name##Array&gt;(structure, m_out.intPtrZero, slowCase); \</span>
<span class="line-added"> 7095                 break;</span>
<span class="line-added"> 7096             FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(TYPED_ARRAY_TYPE_CASE)</span>
<span class="line-added"> 7097 #undef TYPED_ARRAY_TYPE_CASE</span>
<span class="line-added"> 7098             case TypeDataView:</span>
<span class="line-added"> 7099                 fastResultValue = allocateObject&lt;JSDataView&gt;(structure, m_out.intPtrZero, slowCase);</span>
<span class="line-added"> 7100                 break;</span>
<span class="line-added"> 7101             default:</span>
<span class="line-added"> 7102                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added"> 7103                 break;</span>
<span class="line-added"> 7104             }</span>
 7105 
 7106             m_out.storePtr(storage, fastResultValue, m_heaps.JSArrayBufferView_vector);
 7107             m_out.store32(size, fastResultValue, m_heaps.JSArrayBufferView_length);
 7108             m_out.store32(m_out.constInt32(FastTypedArray), fastResultValue, m_heaps.JSArrayBufferView_mode);
 7109 
 7110             mutatorFence();
 7111             ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 7112             m_out.jump(continuation);
 7113 
 7114             m_out.appendTo(slowCase, continuation);
 7115             LValue storageValue = m_out.phi(pointerType(), noStorage, haveStorage);
 7116 
 7117             VM&amp; vm = this-&gt;vm();
 7118             LValue slowResultValue = lazySlowPath(
 7119                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 7120                     return createLazyCallGenerator(vm,
<a name="312" id="anc312"></a><span class="line-modified"> 7121                         operationNewTypedArrayWithSizeForType(typedArrayType), locations[0].directGPR(), globalObject,</span>
 7122                         CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
 7123                         locations[2].directGPR());
 7124                 },
 7125                 size, storageValue);
 7126             ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 7127             m_out.jump(continuation);
 7128 
 7129             m_out.appendTo(continuation, lastNext);
 7130             setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
 7131             return;
 7132         }
 7133 
 7134         case UntypedUse: {
 7135             LValue argument = lowJSValue(m_node-&gt;child1());
 7136 
 7137             LValue result = vmCall(
<a name="313" id="anc313"></a><span class="line-modified"> 7138                 pointerType(), operationNewTypedArrayWithOneArgumentForType(typedArrayType),</span>
<span class="line-modified"> 7139                 weakPointer(globalObject), weakPointer(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType)), argument);</span>
 7140 
 7141             setJSValue(result);
 7142             return;
 7143         }
 7144 
 7145         default:
 7146             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 7147             return;
 7148         }
 7149     }
 7150 
 7151     void compileAllocatePropertyStorage()
 7152     {
 7153         LValue object = lowCell(m_node-&gt;child1());
 7154         setStorage(allocatePropertyStorage(object, m_node-&gt;transition()-&gt;previous.get()));
 7155     }
 7156 
 7157     void compileReallocatePropertyStorage()
 7158     {
 7159         Transition* transition = m_node-&gt;transition();
 7160         LValue object = lowCell(m_node-&gt;child1());
 7161         LValue oldStorage = lowStorage(m_node-&gt;child2());
 7162 
 7163         setStorage(
 7164             reallocatePropertyStorage(
 7165                 object, oldStorage, transition-&gt;previous.get(), transition-&gt;next.get()));
 7166     }
 7167 
 7168     void compileNukeStructureAndSetButterfly()
 7169     {
 7170         nukeStructureAndSetButterfly(lowStorage(m_node-&gt;child2()), lowCell(m_node-&gt;child1()));
 7171     }
 7172 
 7173     void compileToNumber()
 7174     {
<a name="314" id="anc314"></a><span class="line-added"> 7175         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 7176         LValue value = lowJSValue(m_node-&gt;child1());
 7177 
 7178         if (!(abstractValue(m_node-&gt;child1()).m_type &amp; SpecBytecodeNumber))
<a name="315" id="anc315"></a><span class="line-modified"> 7179             setJSValue(vmCall(Int64, operationToNumber, weakPointer(globalObject), value));</span>
 7180         else {
 7181             LBasicBlock notNumber = m_out.newBlock();
 7182             LBasicBlock continuation = m_out.newBlock();
 7183 
 7184             ValueFromBlock fastResult = m_out.anchor(value);
 7185             m_out.branch(isNumber(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notNumber));
 7186 
 7187             // notNumber case.
 7188             LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);
 7189             // We have several attempts to remove ToNumber. But ToNumber still exists.
 7190             // It means that converting non-numbers to numbers by this ToNumber is not rare.
 7191             // Instead of the lazy slow path generator, we call the operation here.
<a name="316" id="anc316"></a><span class="line-modified"> 7192             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationToNumber, weakPointer(globalObject), value));</span>
 7193             m_out.jump(continuation);
 7194 
 7195             // continuation case.
 7196             m_out.appendTo(continuation, lastNext);
 7197             setJSValue(m_out.phi(Int64, fastResult, slowResult));
 7198         }
 7199     }
 7200 
<a name="317" id="anc317"></a><span class="line-added"> 7201     void compileToNumeric()</span>
<span class="line-added"> 7202     {</span>
<span class="line-added"> 7203         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 7204         LValue value = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 7205 </span>
<span class="line-added"> 7206         if (abstractValue(m_node-&gt;child1()).m_type &amp; (SpecBytecodeNumber | SpecBigInt)) {</span>
<span class="line-added"> 7207             LBasicBlock notNumber = m_out.newBlock();</span>
<span class="line-added"> 7208             LBasicBlock isCellPath = m_out.newBlock();</span>
<span class="line-added"> 7209             LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added"> 7210             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 7211 </span>
<span class="line-added"> 7212             ValueFromBlock fastResult = m_out.anchor(value);</span>
<span class="line-added"> 7213             m_out.branch(isNumber(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notNumber));</span>
<span class="line-added"> 7214 </span>
<span class="line-added"> 7215             // notNumber case.</span>
<span class="line-added"> 7216             LBasicBlock lastNext = m_out.appendTo(notNumber, continuation);</span>
<span class="line-added"> 7217             m_out.branch(isCell(value, provenType(m_node-&gt;child1())), unsure(isCellPath), unsure(slowPath));</span>
<span class="line-added"> 7218 </span>
<span class="line-added"> 7219             m_out.appendTo(isCellPath);</span>
<span class="line-added"> 7220             m_out.branch(isBigInt(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(slowPath));</span>
<span class="line-added"> 7221 </span>
<span class="line-added"> 7222             m_out.appendTo(slowPath);</span>
<span class="line-added"> 7223             // We have several attempts to remove ToNumeric. But ToNumeric still exists.</span>
<span class="line-added"> 7224             // It means that the slow path is not rare.</span>
<span class="line-added"> 7225             // Instead of the lazy slow path generator, we call the operation here.</span>
<span class="line-added"> 7226             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operationToNumeric, weakPointer(globalObject), value));</span>
<span class="line-added"> 7227             m_out.jump(continuation);</span>
<span class="line-added"> 7228 </span>
<span class="line-added"> 7229             // continuation case.</span>
<span class="line-added"> 7230             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 7231             setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
<span class="line-added"> 7232         } else</span>
<span class="line-added"> 7233             setJSValue(vmCall(Int64, operationToNumeric, weakPointer(globalObject), value));</span>
<span class="line-added"> 7234     }</span>
<span class="line-added"> 7235 </span>
 7236     void compileToStringOrCallStringConstructorOrStringValueOf()
 7237     {
 7238         ASSERT(m_node-&gt;op() != StringValueOf || m_node-&gt;child1().useKind() == UntypedUse);
<a name="318" id="anc318"></a><span class="line-added"> 7239         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 7240         switch (m_node-&gt;child1().useKind()) {
 7241         case StringObjectUse: {
 7242             LValue cell = lowCell(m_node-&gt;child1());
 7243             speculateStringObjectForCell(m_node-&gt;child1(), cell);
 7244             setJSValue(m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 7245             return;
 7246         }
 7247 
 7248         case StringOrStringObjectUse: {
 7249             LValue cell = lowCell(m_node-&gt;child1());
 7250             LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
 7251 
 7252             LBasicBlock notString = m_out.newBlock();
 7253             LBasicBlock continuation = m_out.newBlock();
 7254 
 7255             ValueFromBlock simpleResult = m_out.anchor(cell);
 7256             m_out.branch(
 7257                 m_out.equal(type, m_out.constInt32(StringType)),
 7258                 unsure(continuation), unsure(notString));
 7259 
 7260             LBasicBlock lastNext = m_out.appendTo(notString, continuation);
 7261             speculate(
 7262                 BadType, jsValueValue(cell), m_node-&gt;child1().node(),
 7263                 m_out.notEqual(type, m_out.constInt32(StringObjectType)));
 7264             ValueFromBlock unboxedResult = m_out.anchor(
 7265                 m_out.loadPtr(cell, m_heaps.JSWrapperObject_internalValue));
 7266             m_out.jump(continuation);
 7267 
 7268             m_out.appendTo(continuation, lastNext);
 7269             setJSValue(m_out.phi(Int64, simpleResult, unboxedResult));
 7270 
 7271             m_interpreter.filter(m_node-&gt;child1(), SpecString | SpecStringObject);
 7272             return;
 7273         }
 7274 
 7275         case CellUse:
 7276         case NotCellUse:
 7277         case UntypedUse: {
 7278             LValue value;
 7279             if (m_node-&gt;child1().useKind() == CellUse)
 7280                 value = lowCell(m_node-&gt;child1());
 7281             else if (m_node-&gt;child1().useKind() == NotCellUse)
 7282                 value = lowNotCell(m_node-&gt;child1());
 7283             else
 7284                 value = lowJSValue(m_node-&gt;child1());
 7285 
 7286             LBasicBlock isCell = m_out.newBlock();
 7287             LBasicBlock notString = m_out.newBlock();
 7288             LBasicBlock continuation = m_out.newBlock();
 7289 
 7290             LValue isCellPredicate;
 7291             if (m_node-&gt;child1().useKind() == CellUse)
 7292                 isCellPredicate = m_out.booleanTrue;
 7293             else if (m_node-&gt;child1().useKind() == NotCellUse)
 7294                 isCellPredicate = m_out.booleanFalse;
 7295             else
 7296                 isCellPredicate = this-&gt;isCell(value, provenType(m_node-&gt;child1()));
 7297             m_out.branch(isCellPredicate, unsure(isCell), unsure(notString));
 7298 
 7299             LBasicBlock lastNext = m_out.appendTo(isCell, notString);
 7300             ValueFromBlock simpleResult = m_out.anchor(value);
 7301             LValue isStringPredicate;
 7302             if (m_node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 7303                 isStringPredicate = isString(value, provenType(m_node-&gt;child1()));
 7304             } else
 7305                 isStringPredicate = m_out.booleanFalse;
 7306             m_out.branch(isStringPredicate, unsure(continuation), unsure(notString));
 7307 
 7308             m_out.appendTo(notString, continuation);
<a name="319" id="anc319"></a><span class="line-modified"> 7309             LValue result;</span>
 7310             if (m_node-&gt;child1().useKind() == CellUse) {
 7311                 ASSERT(m_node-&gt;op() != StringValueOf);
<a name="320" id="anc320"></a><span class="line-modified"> 7312                 result = vmCall(Int64, m_node-&gt;op() == ToString ? operationToStringOnCell : operationCallStringConstructorOnCell, weakPointer(globalObject), value);</span>
 7313             } else {
<a name="321" id="anc321"></a><span class="line-modified"> 7314                 auto* operation = m_node-&gt;op() == ToString</span>
 7315                     ? operationToString : m_node-&gt;op() == StringValueOf
<a name="322" id="anc322"></a><span class="line-modified"> 7316                     ? operationStringValueOf : operationCallStringConstructor;</span>
<span class="line-added"> 7317                 result = vmCall(Int64, operation, weakPointer(globalObject), value);</span>
 7318             }
<a name="323" id="anc323"></a><span class="line-modified"> 7319             ValueFromBlock convertedResult = m_out.anchor(result);</span>
 7320             m_out.jump(continuation);
 7321 
 7322             m_out.appendTo(continuation, lastNext);
 7323             setJSValue(m_out.phi(Int64, simpleResult, convertedResult));
 7324             return;
 7325         }
 7326 
 7327         case Int32Use:
<a name="324" id="anc324"></a><span class="line-modified"> 7328             setJSValue(vmCall(Int64, operationInt32ToStringWithValidRadix, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), m_out.constInt32(10)));</span>
 7329             return;
 7330 
 7331         case Int52RepUse:
<a name="325" id="anc325"></a><span class="line-modified"> 7332             setJSValue(vmCall(Int64, operationInt52ToStringWithValidRadix, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(10)));</span>
 7333             return;
 7334 
 7335         case DoubleRepUse:
<a name="326" id="anc326"></a><span class="line-modified"> 7336             setJSValue(vmCall(Int64, operationDoubleToStringWithValidRadix, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), m_out.constInt32(10)));</span>
 7337             return;
 7338 
 7339         default:
 7340             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 7341             break;
 7342         }
 7343     }
 7344 
 7345     void compileToPrimitive()
 7346     {
<a name="327" id="anc327"></a><span class="line-added"> 7347         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 7348         LValue value = lowJSValue(m_node-&gt;child1());
 7349 
 7350         LBasicBlock isCellCase = m_out.newBlock();
 7351         LBasicBlock isObjectCase = m_out.newBlock();
 7352         LBasicBlock continuation = m_out.newBlock();
 7353 
 7354         Vector&lt;ValueFromBlock, 3&gt; results;
 7355 
 7356         results.append(m_out.anchor(value));
 7357         m_out.branch(
 7358             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
 7359 
 7360         LBasicBlock lastNext = m_out.appendTo(isCellCase, isObjectCase);
 7361         results.append(m_out.anchor(value));
 7362         m_out.branch(
 7363             isObject(value, provenType(m_node-&gt;child1())),
 7364             unsure(isObjectCase), unsure(continuation));
 7365 
 7366         m_out.appendTo(isObjectCase, continuation);
 7367         results.append(m_out.anchor(vmCall(
<a name="328" id="anc328"></a><span class="line-modified"> 7368             Int64, operationToPrimitive, weakPointer(globalObject), value)));</span>
<span class="line-added"> 7369         m_out.jump(continuation);</span>
<span class="line-added"> 7370 </span>
<span class="line-added"> 7371         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 7372         setJSValue(m_out.phi(Int64, results));</span>
<span class="line-added"> 7373     }</span>
<span class="line-added"> 7374 </span>
<span class="line-added"> 7375     void compileToPropertyKey()</span>
<span class="line-added"> 7376     {</span>
<span class="line-added"> 7377         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added"> 7378         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 7379         LValue value = lowJSValue(m_node-&gt;child1());</span>
<span class="line-added"> 7380 </span>
<span class="line-added"> 7381         LBasicBlock isCellCase = m_out.newBlock();</span>
<span class="line-added"> 7382         LBasicBlock notStringCase = m_out.newBlock();</span>
<span class="line-added"> 7383         LBasicBlock slowPathCase = m_out.newBlock();</span>
<span class="line-added"> 7384         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 7385 </span>
<span class="line-added"> 7386         Vector&lt;ValueFromBlock, 3&gt; results;</span>
<span class="line-added"> 7387         m_out.branch(</span>
<span class="line-added"> 7388             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(slowPathCase));</span>
<span class="line-added"> 7389 </span>
<span class="line-added"> 7390         LBasicBlock lastNext = m_out.appendTo(isCellCase, notStringCase);</span>
<span class="line-added"> 7391         results.append(m_out.anchor(value));</span>
<span class="line-added"> 7392         m_out.branch(isString(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notStringCase));</span>
<span class="line-added"> 7393 </span>
<span class="line-added"> 7394         m_out.appendTo(notStringCase, slowPathCase);</span>
<span class="line-added"> 7395         results.append(m_out.anchor(value));</span>
<span class="line-added"> 7396         m_out.branch(isSymbol(value, provenType(m_node-&gt;child1())), unsure(continuation), unsure(slowPathCase));</span>
<span class="line-added"> 7397 </span>
<span class="line-added"> 7398         m_out.appendTo(slowPathCase, continuation);</span>
<span class="line-added"> 7399         results.append(m_out.anchor(vmCall(</span>
<span class="line-added"> 7400             Int64, operationToPropertyKey, weakPointer(globalObject), value)));</span>
 7401         m_out.jump(continuation);
 7402 
 7403         m_out.appendTo(continuation, lastNext);
 7404         setJSValue(m_out.phi(Int64, results));
 7405     }
 7406 
 7407     void compileMakeRope()
 7408     {
<a name="329" id="anc329"></a><span class="line-added"> 7409         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 7410 </span>
 7411         struct FlagsAndLength {
 7412             LValue flags;
 7413             LValue length;
 7414         };
 7415 
 7416         Edge edges[3] = {
 7417             m_node-&gt;child1(),
 7418             m_node-&gt;child2(),
 7419             m_node-&gt;child3(),
 7420         };
 7421         LValue kids[3];
 7422         unsigned numKids;
 7423         kids[0] = lowCell(edges[0]);
 7424         kids[1] = lowCell(edges[1]);
 7425         if (edges[2]) {
 7426             kids[2] = lowCell(edges[2]);
 7427             numKids = 3;
 7428         } else {
 7429             kids[2] = 0;
 7430             numKids = 2;
 7431         }
 7432 
 7433         LBasicBlock emptyCase = m_out.newBlock();
 7434         LBasicBlock slowPath = m_out.newBlock();
 7435         LBasicBlock continuation = m_out.newBlock();
 7436 
 7437         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
 7438 
 7439         LValue result = allocateCell(
 7440             m_out.constIntPtr(allocator.localAllocator()), vm().stringStructure.get(), slowPath);
 7441 
 7442         // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.
 7443         m_out.storePtr(m_out.constIntPtr(JSString::isRopeInPointer), result, m_heaps.JSRopeString_fiber0);
 7444 
 7445         auto getFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child) {
 7446             if (JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
 7447                 return FlagsAndLength {
 7448                     m_out.constInt32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0),
 7449                     m_out.constInt32(string-&gt;length())
 7450                 };
 7451             }
 7452 
 7453             LBasicBlock continuation = m_out.newBlock();
 7454             LBasicBlock ropeCase = m_out.newBlock();
 7455             LBasicBlock notRopeCase = m_out.newBlock();
 7456 
 7457             m_out.branch(isRopeString(child, edge), unsure(ropeCase), unsure(notRopeCase));
 7458 
 7459             LBasicBlock lastNext = m_out.appendTo(ropeCase, notRopeCase);
 7460             ValueFromBlock flagsForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_flags));
 7461             ValueFromBlock lengthForRope = m_out.anchor(m_out.load32NonNegative(child, m_heaps.JSRopeString_length));
 7462             m_out.jump(continuation);
 7463 
 7464             m_out.appendTo(notRopeCase, continuation);
 7465             LValue stringImpl = m_out.loadPtr(child, m_heaps.JSString_value);
 7466             ValueFromBlock flagsForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_hashAndFlags));
 7467             ValueFromBlock lengthForNonRope = m_out.anchor(m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length));
 7468             m_out.jump(continuation);
 7469 
 7470             m_out.appendTo(continuation, lastNext);
 7471             return FlagsAndLength {
 7472                 m_out.phi(Int32, flagsForRope, flagsForNonRope),
 7473                 m_out.phi(Int32, lengthForRope, lengthForNonRope)
 7474             };
 7475         };
 7476 
 7477         FlagsAndLength flagsAndLength = getFlagsAndLength(edges[0], kids[0]);
 7478         for (unsigned i = 1; i &lt; numKids; ++i) {
 7479             auto mergeFlagsAndLength = [&amp;] (Edge&amp; edge, LValue child, FlagsAndLength previousFlagsAndLength) {
 7480                 FlagsAndLength flagsAndLength = getFlagsAndLength(edge, child);
 7481                 LValue flags = m_out.bitAnd(previousFlagsAndLength.flags, flagsAndLength.flags);
 7482                 CheckValue* lengthCheck = m_out.speculateAdd(previousFlagsAndLength.length, flagsAndLength.length);
 7483                 blessSpeculation(lengthCheck, Uncountable, noValue(), nullptr, m_origin);
 7484                 return FlagsAndLength {
 7485                     flags,
 7486                     lengthCheck
 7487                 };
 7488             };
 7489             flagsAndLength = mergeFlagsAndLength(edges[i], kids[i], flagsAndLength);
 7490         }
 7491 
 7492         m_out.storePtr(
 7493             m_out.bitOr(
 7494                 m_out.bitOr(kids[0], m_out.constIntPtr(JSString::isRopeInPointer)),
 7495                 m_out.bitAnd(m_out.constIntPtr(JSRopeString::is8BitInPointer), m_out.zeroExtPtr(flagsAndLength.flags))),
 7496             result, m_heaps.JSRopeString_fiber0);
 7497         m_out.storePtr(
 7498             m_out.bitOr(m_out.zeroExtPtr(flagsAndLength.length), m_out.shl(kids[1], m_out.constInt32(32))),
 7499             result, m_heaps.JSRopeString_fiber1);
 7500         if (numKids == 2)
 7501             m_out.storePtr(m_out.lShr(kids[1], m_out.constInt32(32)), result, m_heaps.JSRopeString_fiber2);
 7502         else
 7503             m_out.storePtr(m_out.bitOr(m_out.lShr(kids[1], m_out.constInt32(32)), m_out.shl(kids[2], m_out.constInt32(16))), result, m_heaps.JSRopeString_fiber2);
 7504 
 7505         mutatorFence();
 7506         ValueFromBlock fastResult = m_out.anchor(result);
 7507         m_out.branch(m_out.isZero32(flagsAndLength.length), rarely(emptyCase), usually(continuation));
 7508 
 7509         LBasicBlock lastNext = m_out.appendTo(emptyCase, slowPath);
 7510         ValueFromBlock emptyResult = m_out.anchor(weakPointer(jsEmptyString(m_graph.m_vm)));
 7511         m_out.jump(continuation);
 7512 
 7513         m_out.appendTo(slowPath, continuation);
 7514         LValue slowResultValue;
 7515         VM&amp; vm = this-&gt;vm();
 7516         switch (numKids) {
 7517         case 2:
 7518             slowResultValue = lazySlowPath(
 7519                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 7520                     return createLazyCallGenerator(vm,
<a name="330" id="anc330"></a><span class="line-modified"> 7521                         operationMakeRope2, locations[0].directGPR(), globalObject, locations[1].directGPR(),</span>
 7522                         locations[2].directGPR());
 7523                 }, kids[0], kids[1]);
 7524             break;
 7525         case 3:
 7526             slowResultValue = lazySlowPath(
 7527                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 7528                     return createLazyCallGenerator(vm,
<a name="331" id="anc331"></a><span class="line-modified"> 7529                         operationMakeRope3, locations[0].directGPR(), globalObject, locations[1].directGPR(),</span>
 7530                         locations[2].directGPR(), locations[3].directGPR());
 7531                 }, kids[0], kids[1], kids[2]);
 7532             break;
 7533         default:
 7534             DFG_CRASH(m_graph, m_node, &quot;Bad number of children&quot;);
 7535             break;
 7536         }
 7537         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 7538         m_out.jump(continuation);
 7539 
 7540         m_out.appendTo(continuation, lastNext);
 7541         setJSValue(m_out.phi(Int64, fastResult, emptyResult, slowResult));
 7542     }
 7543 
 7544     void compileStringCharAt()
 7545     {
 7546         LValue base = lowString(m_graph.child(m_node, 0));
 7547         LValue index = lowInt32(m_graph.child(m_node, 1));
 7548         LValue storage = lowStorage(m_graph.child(m_node, 2));
 7549 
 7550         LBasicBlock fastPath = m_out.newBlock();
 7551         LBasicBlock slowPath = m_out.newBlock();
 7552         LBasicBlock continuation = m_out.newBlock();
 7553 
 7554         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 7555         m_out.branch(
 7556             m_out.aboveOrEqual(
 7557                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)),
 7558             rarely(slowPath), usually(fastPath));
 7559 
 7560         LBasicBlock lastNext = m_out.appendTo(fastPath, slowPath);
 7561 
 7562         LBasicBlock is8Bit = m_out.newBlock();
 7563         LBasicBlock is16Bit = m_out.newBlock();
 7564         LBasicBlock bitsContinuation = m_out.newBlock();
 7565         LBasicBlock bigCharacter = m_out.newBlock();
 7566 
 7567         m_out.branch(
 7568             m_out.testIsZero32(
 7569                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 7570                 m_out.constInt32(StringImpl::flagIs8Bit())),
 7571             unsure(is16Bit), unsure(is8Bit));
 7572 
 7573         m_out.appendTo(is8Bit, is16Bit);
 7574 
 7575         // FIXME: Need to cage strings!
 7576         // https://bugs.webkit.org/show_bug.cgi?id=174924
 7577         ValueFromBlock char8Bit = m_out.anchor(
 7578             m_out.load8ZeroExt32(m_out.baseIndex(
 7579                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 7580                 provenValue(m_graph.child(m_node, 1)))));
 7581         m_out.jump(bitsContinuation);
 7582 
 7583         m_out.appendTo(is16Bit, bigCharacter);
 7584 
 7585         LValue char16BitValue = m_out.load16ZeroExt32(
 7586             m_out.baseIndex(
 7587                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 7588                 provenValue(m_graph.child(m_node, 1))));
 7589         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
 7590         m_out.branch(
 7591             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
 7592             rarely(bigCharacter), usually(bitsContinuation));
 7593 
 7594         m_out.appendTo(bigCharacter, bitsContinuation);
 7595 
 7596         Vector&lt;ValueFromBlock, 4&gt; results;
 7597         results.append(m_out.anchor(vmCall(
<a name="332" id="anc332"></a><span class="line-modified"> 7598             Int64, operationSingleCharacterString,</span>
<span class="line-modified"> 7599             m_vmValue, char16BitValue)));</span>
 7600         m_out.jump(continuation);
 7601 
 7602         m_out.appendTo(bitsContinuation, slowPath);
 7603 
 7604         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
 7605 
 7606         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 7607 
 7608         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
 7609             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
 7610         m_out.jump(continuation);
 7611 
 7612         m_out.appendTo(slowPath, continuation);
 7613 
 7614         if (m_node-&gt;arrayMode().isInBounds()) {
 7615             speculate(OutOfBounds, noValue(), 0, m_out.booleanTrue);
 7616             results.append(m_out.anchor(m_out.intPtrZero));
 7617         } else {
<a name="333" id="anc333"></a><span class="line-added"> 7618             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added"> 7619             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
 7620             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 7621             Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm());
 7622             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
 7623             WTF::loadLoadFence();
 7624 
 7625             if (globalObject-&gt;stringPrototypeChainIsSane()) {
 7626                 // FIXME: This could be captured using a Speculation mode that means
 7627                 // &quot;out-of-bounds loads return a trivial value&quot;, something like
 7628                 // SaneChainOutOfBounds.
 7629                 // https://bugs.webkit.org/show_bug.cgi?id=144668
 7630 
 7631                 m_graph.registerAndWatchStructureTransition(stringPrototypeStructure);
 7632                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 7633 
 7634                 LBasicBlock negativeIndex = m_out.newBlock();
 7635 
 7636                 results.append(m_out.anchor(m_out.constInt64(JSValue::encode(jsUndefined()))));
 7637                 m_out.branch(
 7638                     m_out.lessThan(index, m_out.int32Zero),
 7639                     rarely(negativeIndex), usually(continuation));
 7640 
 7641                 m_out.appendTo(negativeIndex, continuation);
 7642             }
 7643 
<a name="334" id="anc334"></a><span class="line-modified"> 7644             results.append(m_out.anchor(vmCall(Int64, operationGetByValStringInt, weakPointer(globalObject), base, index)));</span>

 7645         }
 7646 
 7647         m_out.jump(continuation);
 7648 
 7649         m_out.appendTo(continuation, lastNext);
 7650         setJSValue(m_out.phi(Int64, results));
 7651     }
 7652 
 7653     void compileStringCharCodeAt()
 7654     {
 7655         LBasicBlock is8Bit = m_out.newBlock();
 7656         LBasicBlock is16Bit = m_out.newBlock();
 7657         LBasicBlock continuation = m_out.newBlock();
 7658 
 7659         LValue base = lowString(m_node-&gt;child1());
 7660         LValue index = lowInt32(m_node-&gt;child2());
 7661         LValue storage = lowStorage(m_node-&gt;child3());
 7662 
 7663         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);
 7664 
 7665         speculate(
 7666             Uncountable, noValue(), 0,
 7667             m_out.aboveOrEqual(
 7668                 index, m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length)));
 7669 
 7670         m_out.branch(
 7671             m_out.testIsZero32(
 7672                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
 7673                 m_out.constInt32(StringImpl::flagIs8Bit())),
 7674             unsure(is16Bit), unsure(is8Bit));
 7675 
 7676         LBasicBlock lastNext = m_out.appendTo(is8Bit, is16Bit);
 7677 
 7678         // FIXME: need to cage strings!
 7679         // https://bugs.webkit.org/show_bug.cgi?id=174924
 7680         ValueFromBlock char8Bit = m_out.anchor(
 7681             m_out.load8ZeroExt32(m_out.baseIndex(
 7682                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),
 7683                 provenValue(m_node-&gt;child2()))));
 7684         m_out.jump(continuation);
 7685 
 7686         m_out.appendTo(is16Bit, continuation);
 7687 
 7688         ValueFromBlock char16Bit = m_out.anchor(
 7689             m_out.load16ZeroExt32(m_out.baseIndex(
 7690                 m_heaps.characters16, storage, m_out.zeroExtPtr(index),
 7691                 provenValue(m_node-&gt;child2()))));
 7692         m_out.jump(continuation);
 7693 
 7694         m_out.appendTo(continuation, lastNext);
 7695 
 7696         setInt32(m_out.phi(Int32, char8Bit, char16Bit));
 7697     }
 7698 
<a name="335" id="anc335"></a><span class="line-added"> 7699     void compileStringCodePointAt()</span>
<span class="line-added"> 7700     {</span>
<span class="line-added"> 7701         LBasicBlock is8Bit = m_out.newBlock();</span>
<span class="line-added"> 7702         LBasicBlock is16Bit = m_out.newBlock();</span>
<span class="line-added"> 7703         LBasicBlock isLeadSurrogate = m_out.newBlock();</span>
<span class="line-added"> 7704         LBasicBlock mayHaveTrailSurrogate = m_out.newBlock();</span>
<span class="line-added"> 7705         LBasicBlock hasTrailSurrogate = m_out.newBlock();</span>
<span class="line-added"> 7706         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added"> 7707 </span>
<span class="line-added"> 7708         LValue base = lowString(m_node-&gt;child1());</span>
<span class="line-added"> 7709         LValue index = lowInt32(m_node-&gt;child2());</span>
<span class="line-added"> 7710         LValue storage = lowStorage(m_node-&gt;child3());</span>
<span class="line-added"> 7711 </span>
<span class="line-added"> 7712         LValue stringImpl = m_out.loadPtr(base, m_heaps.JSString_value);</span>
<span class="line-added"> 7713         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);</span>
<span class="line-added"> 7714 </span>
<span class="line-added"> 7715         speculate(Uncountable, noValue(), 0, m_out.aboveOrEqual(index, length));</span>
<span class="line-added"> 7716 </span>
<span class="line-added"> 7717         m_out.branch(</span>
<span class="line-added"> 7718             m_out.testIsZero32(</span>
<span class="line-added"> 7719                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),</span>
<span class="line-added"> 7720                 m_out.constInt32(StringImpl::flagIs8Bit())),</span>
<span class="line-added"> 7721             unsure(is16Bit), unsure(is8Bit));</span>
<span class="line-added"> 7722 </span>
<span class="line-added"> 7723         LBasicBlock lastNext = m_out.appendTo(is8Bit, is16Bit);</span>
<span class="line-added"> 7724         // FIXME: Need to cage strings!</span>
<span class="line-added"> 7725         // https://bugs.webkit.org/show_bug.cgi?id=174924</span>
<span class="line-added"> 7726         ValueFromBlock char8Bit = m_out.anchor(</span>
<span class="line-added"> 7727             m_out.load8ZeroExt32(m_out.baseIndex(</span>
<span class="line-added"> 7728                 m_heaps.characters8, storage, m_out.zeroExtPtr(index),</span>
<span class="line-added"> 7729                 provenValue(m_node-&gt;child2()))));</span>
<span class="line-added"> 7730         m_out.jump(continuation);</span>
<span class="line-added"> 7731 </span>
<span class="line-added"> 7732         m_out.appendTo(is16Bit, isLeadSurrogate);</span>
<span class="line-added"> 7733         LValue leadCharacter = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(index), provenValue(m_node-&gt;child2())));</span>
<span class="line-added"> 7734         ValueFromBlock char16Bit = m_out.anchor(leadCharacter);</span>
<span class="line-added"> 7735         LValue nextIndex = m_out.add(index, m_out.int32One);</span>
<span class="line-added"> 7736         m_out.branch(m_out.aboveOrEqual(nextIndex, length), unsure(continuation), unsure(isLeadSurrogate));</span>
<span class="line-added"> 7737 </span>
<span class="line-added"> 7738         m_out.appendTo(isLeadSurrogate, mayHaveTrailSurrogate);</span>
<span class="line-added"> 7739         m_out.branch(m_out.notEqual(m_out.bitAnd(leadCharacter, m_out.constInt32(0xfffffc00)), m_out.constInt32(0xd800)), unsure(continuation), unsure(mayHaveTrailSurrogate));</span>
<span class="line-added"> 7740 </span>
<span class="line-added"> 7741         m_out.appendTo(mayHaveTrailSurrogate, hasTrailSurrogate);</span>
<span class="line-added"> 7742         JSValue indexValue = provenValue(m_node-&gt;child2());</span>
<span class="line-added"> 7743         JSValue nextIndexValue;</span>
<span class="line-added"> 7744         if (indexValue &amp;&amp; indexValue.isInt32() &amp;&amp; indexValue.asInt32() != INT32_MAX)</span>
<span class="line-added"> 7745             nextIndexValue = jsNumber(indexValue.asInt32() + 1);</span>
<span class="line-added"> 7746         LValue trailCharacter = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(nextIndex), nextIndexValue));</span>
<span class="line-added"> 7747         m_out.branch(m_out.notEqual(m_out.bitAnd(trailCharacter, m_out.constInt32(0xfffffc00)), m_out.constInt32(0xdc00)), unsure(continuation), unsure(hasTrailSurrogate));</span>
<span class="line-added"> 7748 </span>
<span class="line-added"> 7749         m_out.appendTo(hasTrailSurrogate, continuation);</span>
<span class="line-added"> 7750         ValueFromBlock charSurrogatePair = m_out.anchor(m_out.sub(m_out.add(m_out.shl(leadCharacter, m_out.constInt32(10)), trailCharacter), m_out.constInt32(U16_SURROGATE_OFFSET)));</span>
<span class="line-added"> 7751         m_out.jump(continuation);</span>
<span class="line-added"> 7752 </span>
<span class="line-added"> 7753         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added"> 7754         setInt32(m_out.phi(Int32, char8Bit, char16Bit, charSurrogatePair));</span>
<span class="line-added"> 7755     }</span>
<span class="line-added"> 7756 </span>
 7757     void compileStringFromCharCode()
 7758     {
<a name="336" id="anc336"></a><span class="line-added"> 7759         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 7760         Edge childEdge = m_node-&gt;child1();
 7761 
 7762         if (childEdge.useKind() == UntypedUse) {
 7763             LValue result = vmCall(
<a name="337" id="anc337"></a><span class="line-modified"> 7764                 Int64, operationStringFromCharCodeUntyped, weakPointer(globalObject),</span>
 7765                 lowJSValue(childEdge));
 7766             setJSValue(result);
 7767             return;
 7768         }
 7769 
 7770         DFG_ASSERT(m_graph, m_node, childEdge.useKind() == Int32Use, childEdge.useKind());
 7771 
 7772         LValue value = lowInt32(childEdge);
 7773 
 7774         LBasicBlock smallIntCase = m_out.newBlock();
 7775         LBasicBlock slowCase = m_out.newBlock();
 7776         LBasicBlock continuation = m_out.newBlock();
 7777 
 7778         m_out.branch(
 7779             m_out.above(value, m_out.constInt32(maxSingleCharacterString)),
 7780             rarely(slowCase), usually(smallIntCase));
 7781 
 7782         LBasicBlock lastNext = m_out.appendTo(smallIntCase, slowCase);
 7783 
 7784         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
 7785         LValue fastResultValue = m_out.loadPtr(
 7786             m_out.baseIndex(m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(value)));
 7787         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
 7788         m_out.jump(continuation);
 7789 
 7790         m_out.appendTo(slowCase, continuation);
 7791 
 7792         LValue slowResultValue = vmCall(
<a name="338" id="anc338"></a><span class="line-modified"> 7793             pointerType(), operationStringFromCharCode, weakPointer(globalObject), value);</span>
 7794         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
 7795         m_out.jump(continuation);
 7796 
 7797         m_out.appendTo(continuation, lastNext);
 7798 
 7799         setJSValue(m_out.phi(Int64, fastResult, slowResult));
 7800     }
 7801 
 7802     void compileGetByOffset()
 7803     {
 7804         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 7805 
 7806         setJSValue(loadProperty(
 7807             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset));
 7808     }
 7809 
 7810     void compileGetGetter()
 7811     {
 7812         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_getter));
 7813     }
 7814 
 7815     void compileGetSetter()
 7816     {
 7817         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.GetterSetter_setter));
 7818     }
 7819 
 7820     void compileMultiGetByOffset()
 7821     {
 7822         LValue base = lowCell(m_node-&gt;child1());
 7823 
 7824         MultiGetByOffsetData&amp; data = m_node-&gt;multiGetByOffsetData();
 7825 
 7826         Vector&lt;LBasicBlock, 2&gt; blocks(data.cases.size());
 7827         for (unsigned i = data.cases.size(); i--;)
 7828             blocks[i] = m_out.newBlock();
 7829         LBasicBlock exit = m_out.newBlock();
 7830         LBasicBlock continuation = m_out.newBlock();
 7831 
 7832         Vector&lt;SwitchCase, 2&gt; cases;
 7833         RegisteredStructureSet baseSet;
 7834         for (unsigned i = data.cases.size(); i--;) {
 7835             MultiGetByOffsetCase getCase = data.cases[i];
 7836             for (unsigned j = getCase.set().size(); j--;) {
 7837                 RegisteredStructure structure = getCase.set()[j];
 7838                 baseSet.add(structure);
 7839                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 7840             }
 7841         }
 7842         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7843         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 7844 
 7845         LBasicBlock lastNext = m_out.m_nextBlock;
 7846 
 7847         Vector&lt;ValueFromBlock, 2&gt; results;
 7848         for (unsigned i = data.cases.size(); i--;) {
 7849             MultiGetByOffsetCase getCase = data.cases[i];
 7850             GetByOffsetMethod method = getCase.method();
 7851 
 7852             m_out.appendTo(blocks[i], i + 1 &lt; data.cases.size() ? blocks[i + 1] : exit);
 7853 
 7854             LValue result;
 7855 
 7856             switch (method.kind()) {
 7857             case GetByOffsetMethod::Invalid:
 7858                 RELEASE_ASSERT_NOT_REACHED();
 7859                 break;
 7860 
 7861             case GetByOffsetMethod::Constant:
 7862                 result = m_out.constInt64(JSValue::encode(method.constant()-&gt;value()));
 7863                 break;
 7864 
 7865             case GetByOffsetMethod::Load:
 7866             case GetByOffsetMethod::LoadFromPrototype: {
 7867                 LValue propertyBase;
 7868                 if (method.kind() == GetByOffsetMethod::Load)
 7869                     propertyBase = base;
 7870                 else
 7871                     propertyBase = weakPointer(method.prototype()-&gt;value().asCell());
 7872                 if (!isInlineOffset(method.offset()))
 7873                     propertyBase = m_out.loadPtr(propertyBase, m_heaps.JSObject_butterfly);
 7874                 result = loadProperty(
 7875                     propertyBase, data.identifierNumber, method.offset());
 7876                 break;
 7877             } }
 7878 
 7879             results.append(m_out.anchor(result));
 7880             m_out.jump(continuation);
 7881         }
 7882 
 7883         m_out.appendTo(exit, continuation);
 7884         if (!structuresChecked)
 7885             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7886         m_out.unreachable();
 7887 
 7888         m_out.appendTo(continuation, lastNext);
 7889         setJSValue(m_out.phi(Int64, results));
 7890     }
 7891 
 7892     void compilePutByOffset()
 7893     {
 7894         StorageAccessData&amp; data = m_node-&gt;storageAccessData();
 7895 
 7896         storeProperty(
 7897             lowJSValue(m_node-&gt;child3()),
 7898             lowStorage(m_node-&gt;child1()), data.identifierNumber, data.offset);
 7899     }
 7900 
 7901     void compileMultiPutByOffset()
 7902     {
 7903         LValue base = lowCell(m_node-&gt;child1());
 7904         LValue value = lowJSValue(m_node-&gt;child2());
 7905 
 7906         MultiPutByOffsetData&amp; data = m_node-&gt;multiPutByOffsetData();
 7907 
 7908         Vector&lt;LBasicBlock, 2&gt; blocks(data.variants.size());
 7909         for (unsigned i = data.variants.size(); i--;)
 7910             blocks[i] = m_out.newBlock();
 7911         LBasicBlock exit = m_out.newBlock();
 7912         LBasicBlock continuation = m_out.newBlock();
 7913 
 7914         Vector&lt;SwitchCase, 2&gt; cases;
 7915         RegisteredStructureSet baseSet;
 7916         for (unsigned i = data.variants.size(); i--;) {
 7917             PutByIdVariant variant = data.variants[i];
 7918             for (unsigned j = variant.oldStructure().size(); j--;) {
 7919                 RegisteredStructure structure = m_graph.registerStructure(variant.oldStructure()[j]);
 7920                 baseSet.add(structure);
 7921                 cases.append(SwitchCase(weakStructureID(structure), blocks[i], Weight(1)));
 7922             }
 7923         }
 7924         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7925         emitSwitchForMultiByOffset(base, structuresChecked, cases, exit);
 7926 
 7927         LBasicBlock lastNext = m_out.m_nextBlock;
 7928 
 7929         for (unsigned i = data.variants.size(); i--;) {
 7930             m_out.appendTo(blocks[i], i + 1 &lt; data.variants.size() ? blocks[i + 1] : exit);
 7931 
 7932             PutByIdVariant variant = data.variants[i];
 7933 
 7934             LValue storage;
 7935             if (variant.kind() == PutByIdVariant::Replace) {
 7936                 if (isInlineOffset(variant.offset()))
 7937                     storage = base;
 7938                 else
 7939                     storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
 7940             } else {
 7941                 DFG_ASSERT(m_graph, m_node, variant.kind() == PutByIdVariant::Transition, variant.kind());
 7942                 m_graph.m_plan.transitions().addLazily(
 7943                     codeBlock(), m_node-&gt;origin.semantic.codeOriginOwner(),
 7944                     variant.oldStructureForTransition(), variant.newStructure());
 7945 
 7946                 storage = storageForTransition(
 7947                     base, variant.offset(),
 7948                     variant.oldStructureForTransition(), variant.newStructure());
 7949             }
 7950 
 7951             storeProperty(value, storage, data.identifierNumber, variant.offset());
 7952 
 7953             if (variant.kind() == PutByIdVariant::Transition) {
 7954                 ASSERT(variant.oldStructureForTransition()-&gt;indexingType() == variant.newStructure()-&gt;indexingType());
 7955                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().inlineTypeFlags() == variant.newStructure()-&gt;typeInfo().inlineTypeFlags());
 7956                 ASSERT(variant.oldStructureForTransition()-&gt;typeInfo().type() == variant.newStructure()-&gt;typeInfo().type());
 7957                 m_out.store32(
 7958                     weakStructureID(m_graph.registerStructure(variant.newStructure())), base, m_heaps.JSCell_structureID);
 7959             }
 7960 
 7961             m_out.jump(continuation);
 7962         }
 7963 
 7964         m_out.appendTo(exit, continuation);
 7965         if (!structuresChecked)
 7966             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 7967         m_out.unreachable();
 7968 
 7969         m_out.appendTo(continuation, lastNext);
 7970     }
 7971 
 7972     void compileMatchStructure()
 7973     {
 7974         LValue base = lowCell(m_node-&gt;child1());
 7975 
 7976         MatchStructureData&amp; data = m_node-&gt;matchStructureData();
 7977 
 7978         LBasicBlock trueBlock = m_out.newBlock();
 7979         LBasicBlock falseBlock = m_out.newBlock();
 7980         LBasicBlock exitBlock = m_out.newBlock();
 7981         LBasicBlock continuation = m_out.newBlock();
 7982 
 7983         LBasicBlock lastNext = m_out.insertNewBlocksBefore(trueBlock);
 7984 
 7985         Vector&lt;SwitchCase, 2&gt; cases;
 7986         RegisteredStructureSet baseSet;
 7987         for (MatchStructureVariant&amp; variant : data.variants) {
 7988             baseSet.add(variant.structure);
 7989             cases.append(SwitchCase(
 7990                 weakStructureID(variant.structure),
 7991                 variant.result ? trueBlock : falseBlock, Weight(1)));
 7992         }
 7993         bool structuresChecked = m_interpreter.forNode(m_node-&gt;child1()).m_structure.isSubsetOf(baseSet);
 7994         emitSwitchForMultiByOffset(base, structuresChecked, cases, exitBlock);
 7995 
 7996         m_out.appendTo(trueBlock, falseBlock);
 7997         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
 7998         m_out.jump(continuation);
 7999 
 8000         m_out.appendTo(falseBlock, exitBlock);
 8001         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
 8002         m_out.jump(continuation);
 8003 
 8004         m_out.appendTo(exitBlock, continuation);
 8005         if (!structuresChecked)
 8006             speculate(BadCache, noValue(), nullptr, m_out.booleanTrue);
 8007         m_out.unreachable();
 8008 
 8009         m_out.appendTo(continuation, lastNext);
 8010         setBoolean(m_out.phi(Int32, trueResult, falseResult));
 8011     }
 8012 
 8013     void compileGetGlobalVariable()
 8014     {
 8015         setJSValue(m_out.load64(m_out.absolute(m_node-&gt;variablePointer())));
 8016     }
 8017 
 8018     void compilePutGlobalVariable()
 8019     {
 8020         m_out.store64(
 8021             lowJSValue(m_node-&gt;child2()), m_out.absolute(m_node-&gt;variablePointer()));
 8022     }
 8023 
 8024     void compileNotifyWrite()
 8025     {
 8026         WatchpointSet* set = m_node-&gt;watchpointSet();
 8027 
 8028         LBasicBlock isNotInvalidated = m_out.newBlock();
 8029         LBasicBlock continuation = m_out.newBlock();
 8030 
 8031         LValue state = m_out.load8ZeroExt32(m_out.absolute(set-&gt;addressOfState()));
 8032         m_out.branch(
 8033             m_out.equal(state, m_out.constInt32(IsInvalidated)),
 8034             usually(continuation), rarely(isNotInvalidated));
 8035 
 8036         LBasicBlock lastNext = m_out.appendTo(isNotInvalidated, continuation);
 8037 
 8038         VM&amp; vm = this-&gt;vm();
 8039         lazySlowPath(
 8040             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
 8041                 return createLazyCallGenerator(vm,
<a name="339" id="anc339"></a><span class="line-modified"> 8042                     operationNotifyWrite, InvalidGPRReg, &amp;vm, CCallHelpers::TrustedImmPtr(set));</span>
 8043             });
 8044         m_out.jump(continuation);
 8045 
 8046         m_out.appendTo(continuation, lastNext);
 8047     }
 8048 
 8049     void compileGetCallee()
 8050     {
<a name="340" id="anc340"></a><span class="line-modified"> 8051         setJSValue(m_out.loadPtr(addressFor(VirtualRegister(CallFrameSlot::callee))));</span>
 8052     }
 8053 
 8054     void compileSetCallee()
 8055     {
 8056         auto callee = lowCell(m_node-&gt;child1());
<a name="341" id="anc341"></a><span class="line-modified"> 8057         m_out.storePtr(callee, payloadFor(VirtualRegister(CallFrameSlot::callee)));</span>
 8058     }
 8059 
 8060     void compileGetArgumentCountIncludingThis()
 8061     {
 8062         VirtualRegister argumentCountRegister;
 8063         if (InlineCallFrame* inlineCallFrame = m_node-&gt;argumentsInlineCallFrame())
 8064             argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
 8065         else
<a name="342" id="anc342"></a><span class="line-modified"> 8066             argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCountIncludingThis);</span>
 8067         setInt32(m_out.load32(payloadFor(argumentCountRegister)));
 8068     }
 8069 
 8070     void compileSetArgumentCountIncludingThis()
 8071     {
<a name="343" id="anc343"></a><span class="line-modified"> 8072         m_out.store32(m_out.constInt32(m_node-&gt;argumentCountIncludingThis()), payloadFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 8073     }
 8074 
 8075     void compileGetScope()
 8076     {
 8077         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSFunction_scope));
 8078     }
 8079 
 8080     void compileSkipScope()
 8081     {
 8082         setJSValue(m_out.loadPtr(lowCell(m_node-&gt;child1()), m_heaps.JSScope_next));
 8083     }
 8084 
 8085     void compileGetGlobalObject()
 8086     {
 8087         LValue structure = loadStructure(lowCell(m_node-&gt;child1()));
 8088         setJSValue(m_out.loadPtr(structure, m_heaps.Structure_globalObject));
 8089     }
 8090 
 8091     void compileGetGlobalThis()
 8092     {
 8093         auto* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
 8094         setJSValue(m_out.loadPtr(m_out.absolute(globalObject-&gt;addressOfGlobalThis())));
 8095     }
 8096 
 8097     void compileGetClosureVar()
 8098     {
 8099         setJSValue(
 8100             m_out.load64(
 8101                 lowCell(m_node-&gt;child1()),
 8102                 m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]));
 8103     }
 8104 
 8105     void compilePutClosureVar()
 8106     {
 8107         m_out.store64(
 8108             lowJSValue(m_node-&gt;child2()),
 8109             lowCell(m_node-&gt;child1()),
 8110             m_heaps.JSLexicalEnvironment_variables[m_node-&gt;scopeOffset().offset()]);
 8111     }
 8112 
<a name="344" id="anc344"></a><span class="line-added"> 8113     void compileGetInternalField()</span>
<span class="line-added"> 8114     {</span>
<span class="line-added"> 8115         setJSValue(</span>
<span class="line-added"> 8116             m_out.load64(</span>
<span class="line-added"> 8117                 lowCell(m_node-&gt;child1()),</span>
<span class="line-added"> 8118                 m_heaps.JSInternalFieldObjectImpl_internalFields[m_node-&gt;internalFieldIndex()]));</span>
<span class="line-added"> 8119     }</span>
<span class="line-added"> 8120 </span>
<span class="line-added"> 8121     void compilePutInternalField()</span>
<span class="line-added"> 8122     {</span>
<span class="line-added"> 8123         m_out.store64(</span>
<span class="line-added"> 8124             lowJSValue(m_node-&gt;child2()),</span>
<span class="line-added"> 8125             lowCell(m_node-&gt;child1()),</span>
<span class="line-added"> 8126             m_heaps.JSInternalFieldObjectImpl_internalFields[m_node-&gt;internalFieldIndex()]);</span>
<span class="line-added"> 8127     }</span>
<span class="line-added"> 8128 </span>
 8129     void compileGetFromArguments()
 8130     {
 8131         setJSValue(
 8132             m_out.load64(
 8133                 lowCell(m_node-&gt;child1()),
 8134                 m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]));
 8135     }
 8136 
 8137     void compilePutToArguments()
 8138     {
 8139         m_out.store64(
 8140             lowJSValue(m_node-&gt;child2()),
 8141             lowCell(m_node-&gt;child1()),
 8142             m_heaps.DirectArguments_storage[m_node-&gt;capturedArgumentsOffset().offset()]);
 8143     }
 8144 
 8145     void compileGetArgument()
 8146     {
 8147         LValue argumentCount = m_out.load32(payloadFor(AssemblyHelpers::argumentCount(m_node-&gt;origin.semantic)));
 8148 
 8149         LBasicBlock inBounds = m_out.newBlock();
 8150         LBasicBlock outOfBounds = m_out.newBlock();
 8151         LBasicBlock continuation = m_out.newBlock();
 8152 
 8153         m_out.branch(m_out.lessThanOrEqual(argumentCount, m_out.constInt32(m_node-&gt;argumentIndex())), unsure(outOfBounds), unsure(inBounds));
 8154 
 8155         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
 8156         VirtualRegister arg = AssemblyHelpers::argumentsStart(m_node-&gt;origin.semantic) + m_node-&gt;argumentIndex() - 1;
 8157         ValueFromBlock inBoundsResult = m_out.anchor(m_out.load64(addressFor(arg)));
 8158         m_out.jump(continuation);
 8159 
 8160         m_out.appendTo(outOfBounds, continuation);
<a name="345" id="anc345"></a><span class="line-modified"> 8161         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueUndefined));</span>
 8162         m_out.jump(continuation);
 8163 
 8164         m_out.appendTo(continuation, lastNext);
 8165         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
 8166     }
 8167 
 8168     void compileCompareEq()
 8169     {
 8170         if (m_node-&gt;isBinaryUseKind(Int32Use)
 8171             || m_node-&gt;isBinaryUseKind(Int52RepUse)
 8172             || m_node-&gt;isBinaryUseKind(DoubleRepUse)
 8173             || m_node-&gt;isBinaryUseKind(ObjectUse)
 8174             || m_node-&gt;isBinaryUseKind(BooleanUse)
 8175             || m_node-&gt;isBinaryUseKind(SymbolUse)
 8176             || m_node-&gt;isBinaryUseKind(StringIdentUse)
 8177             || m_node-&gt;isBinaryUseKind(StringUse)) {
 8178             compileCompareStrictEq();
 8179             return;
 8180         }
 8181 
 8182         if (m_node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 8183             compareEqObjectOrOtherToObject(m_node-&gt;child2(), m_node-&gt;child1());
 8184             return;
 8185         }
 8186 
 8187         if (m_node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 8188             compareEqObjectOrOtherToObject(m_node-&gt;child1(), m_node-&gt;child2());
 8189             return;
 8190         }
 8191 
 8192         if (m_node-&gt;child1().useKind() == KnownOtherUse) {
 8193             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child1(), SpecOther));
 8194             setBoolean(equalNullOrUndefined(m_node-&gt;child2(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 8195             return;
 8196         }
 8197 
 8198         if (m_node-&gt;child2().useKind() == KnownOtherUse) {
 8199             ASSERT(!m_interpreter.needsTypeCheck(m_node-&gt;child2(), SpecOther));
 8200             setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualNullOrUndefined, ManualOperandSpeculation));
 8201             return;
 8202         }
 8203 
 8204         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 8205         nonSpeculativeCompare(
 8206             [&amp;] (LValue left, LValue right) {
 8207                 return m_out.equal(left, right);
 8208             },
 8209             operationCompareEq);
 8210     }
 8211 
 8212     void compileCompareStrictEq()
 8213     {
<a name="346" id="anc346"></a><span class="line-added"> 8214         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 8215         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
 8216             setBoolean(
 8217                 m_out.equal(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 8218             return;
 8219         }
 8220 
 8221         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
 8222             Int52Kind kind;
 8223             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
 8224             LValue right = lowInt52(m_node-&gt;child2(), kind);
 8225             setBoolean(m_out.equal(left, right));
 8226             return;
 8227         }
 8228 
 8229         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 8230             setBoolean(
 8231                 m_out.doubleEqual(lowDouble(m_node-&gt;child1()), lowDouble(m_node-&gt;child2())));
 8232             return;
 8233         }
 8234 
 8235         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
 8236             setBoolean(
 8237                 m_out.equal(lowStringIdent(m_node-&gt;child1()), lowStringIdent(m_node-&gt;child2())));
 8238             return;
 8239         }
 8240 
 8241         if (m_node-&gt;isBinaryUseKind(StringUse)) {
 8242             LValue left = lowCell(m_node-&gt;child1());
 8243             LValue right = lowCell(m_node-&gt;child2());
 8244 
 8245             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 8246             LBasicBlock continuation = m_out.newBlock();
 8247 
 8248             speculateString(m_node-&gt;child1(), left);
 8249 
 8250             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 8251             m_out.branch(
 8252                 m_out.equal(left, right), unsure(continuation), unsure(notTriviallyEqualCase));
 8253 
 8254             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 8255 
 8256             speculateString(m_node-&gt;child2(), right);
 8257 
 8258             ValueFromBlock slowResult = m_out.anchor(stringsEqual(left, right, m_node-&gt;child1(), m_node-&gt;child2()));
 8259             m_out.jump(continuation);
 8260 
 8261             m_out.appendTo(continuation, lastNext);
 8262             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 8263             return;
 8264         }
 8265 
 8266         if (m_node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 8267             setBoolean(
 8268                 m_out.equal(
 8269                     lowNonNullObject(m_node-&gt;child1()),
 8270                     lowJSValue(m_node-&gt;child2())));
 8271             return;
 8272         }
 8273 
 8274         if (m_node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 8275             setBoolean(
 8276                 m_out.equal(
 8277                     lowNonNullObject(m_node-&gt;child2()),
 8278                     lowJSValue(m_node-&gt;child1())));
 8279             return;
 8280         }
 8281 
 8282         if (m_node-&gt;isBinaryUseKind(ObjectUse)) {
 8283             setBoolean(
 8284                 m_out.equal(
 8285                     lowNonNullObject(m_node-&gt;child1()),
 8286                     lowNonNullObject(m_node-&gt;child2())));
 8287             return;
 8288         }
 8289 
 8290         if (m_node-&gt;isBinaryUseKind(BooleanUse)) {
 8291             setBoolean(
 8292                 m_out.equal(lowBoolean(m_node-&gt;child1()), lowBoolean(m_node-&gt;child2())));
 8293             return;
 8294         }
 8295 
 8296         if (m_node-&gt;isBinaryUseKind(SymbolUse)) {
 8297             LValue leftSymbol = lowSymbol(m_node-&gt;child1());
 8298             LValue rightSymbol = lowSymbol(m_node-&gt;child2());
 8299             setBoolean(m_out.equal(leftSymbol, rightSymbol));
 8300             return;
 8301         }
 8302 
 8303         if (m_node-&gt;isBinaryUseKind(BigIntUse)) {
 8304             // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
 8305             // https://bugs.webkit.org/show_bug.cgi?id=182895
 8306             LValue left = lowBigInt(m_node-&gt;child1());
 8307             LValue right = lowBigInt(m_node-&gt;child2());
 8308 
 8309             LBasicBlock notTriviallyEqualCase = m_out.newBlock();
 8310             LBasicBlock continuation = m_out.newBlock();
 8311 
 8312             ValueFromBlock fastResult = m_out.anchor(m_out.booleanTrue);
 8313             m_out.branch(m_out.equal(left, right), rarely(continuation), usually(notTriviallyEqualCase));
 8314 
 8315             LBasicBlock lastNext = m_out.appendTo(notTriviallyEqualCase, continuation);
 8316 
 8317             ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<a name="347" id="anc347"></a><span class="line-modified"> 8318                 pointerType(), operationCompareStrictEq, weakPointer(globalObject), left, right)));</span>
 8319             m_out.jump(continuation);
 8320 
 8321             m_out.appendTo(continuation, lastNext);
 8322             setBoolean(m_out.phi(Int32, fastResult, slowResult));
 8323             return;
 8324         }
 8325 
 8326         if (m_node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)
 8327             || m_node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 8328             Edge symbolEdge = m_node-&gt;child1();
 8329             Edge untypedEdge = m_node-&gt;child2();
 8330             if (symbolEdge.useKind() != SymbolUse)
 8331                 std::swap(symbolEdge, untypedEdge);
 8332 
 8333             LValue leftSymbol = lowSymbol(symbolEdge);
 8334             LValue untypedValue = lowJSValue(untypedEdge);
 8335 
 8336             setBoolean(m_out.equal(leftSymbol, untypedValue));
 8337             return;
 8338         }
 8339 
 8340         if (m_node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 8341             || m_node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 8342             speculate(m_node-&gt;child1());
 8343             speculate(m_node-&gt;child2());
 8344             LValue left = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
 8345             LValue right = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
 8346             setBoolean(m_out.equal(left, right));
 8347             return;
 8348         }
 8349 
 8350         if (m_node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)
 8351             || m_node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 8352             Edge leftEdge = m_node-&gt;childFor(StringIdentUse);
 8353             Edge rightEdge = m_node-&gt;childFor(NotStringVarUse);
 8354 
 8355             LValue left = lowStringIdent(leftEdge);
 8356             LValue rightValue = lowJSValue(rightEdge, ManualOperandSpeculation);
 8357 
 8358             LBasicBlock isCellCase = m_out.newBlock();
 8359             LBasicBlock isStringCase = m_out.newBlock();
 8360             LBasicBlock continuation = m_out.newBlock();
 8361 
 8362             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
 8363             m_out.branch(
 8364                 isCell(rightValue, provenType(rightEdge)),
 8365                 unsure(isCellCase), unsure(continuation));
 8366 
 8367             LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
 8368             ValueFromBlock notStringResult = m_out.anchor(m_out.booleanFalse);
 8369             m_out.branch(
 8370                 isString(rightValue, provenType(rightEdge)),
 8371                 unsure(isStringCase), unsure(continuation));
 8372 
 8373             m_out.appendTo(isStringCase, continuation);
 8374             LValue right = m_out.loadPtr(rightValue, m_heaps.JSString_value);
 8375             speculateStringIdent(rightEdge, rightValue, right);
 8376             ValueFromBlock isStringResult = m_out.anchor(m_out.equal(left, right));
 8377             m_out.jump(continuation);
 8378 
 8379             m_out.appendTo(continuation, lastNext);
 8380             setBoolean(m_out.phi(Int32, notCellResult, notStringResult, isStringResult));
 8381             return;
 8382         }
 8383 
 8384         if (m_node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 8385             compileStringToUntypedStrictEquality(m_node-&gt;child1(), m_node-&gt;child2());
 8386             return;
 8387         }
 8388         if (m_node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 8389             compileStringToUntypedStrictEquality(m_node-&gt;child2(), m_node-&gt;child1());
 8390             return;
 8391         }
 8392 
 8393         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
 8394         nonSpeculativeCompare(
 8395             [&amp;] (LValue left, LValue right) {
 8396                 return m_out.equal(left, right);
 8397             },
 8398             operationCompareStrictEq);
 8399     }
 8400 
 8401     void compileStringToUntypedStrictEquality(Edge stringEdge, Edge untypedEdge)
 8402     {
 8403         ASSERT(stringEdge.useKind() == StringUse);
 8404         ASSERT(untypedEdge.useKind() == UntypedUse);
 8405 
 8406         LValue leftString = lowCell(stringEdge);
 8407         LValue rightValue = lowJSValue(untypedEdge);
 8408         SpeculatedType rightValueType = provenType(untypedEdge);
 8409 
 8410         // Verify left is string.
 8411         speculateString(stringEdge, leftString);
 8412 
 8413         LBasicBlock testUntypedEdgeIsCell = m_out.newBlock();
 8414         LBasicBlock testUntypedEdgeIsString = m_out.newBlock();
 8415         LBasicBlock testStringEquality = m_out.newBlock();
 8416         LBasicBlock continuation = m_out.newBlock();
 8417 
 8418         // Given left is string. If the value are strictly equal, rightValue has to be the same string.
 8419         ValueFromBlock fastTrue = m_out.anchor(m_out.booleanTrue);
 8420         m_out.branch(m_out.equal(leftString, rightValue), unsure(continuation), unsure(testUntypedEdgeIsCell));
 8421 
 8422         LBasicBlock lastNext = m_out.appendTo(testUntypedEdgeIsCell, testUntypedEdgeIsString);
 8423         ValueFromBlock fastFalse = m_out.anchor(m_out.booleanFalse);
 8424         m_out.branch(isNotCell(rightValue, rightValueType), unsure(continuation), unsure(testUntypedEdgeIsString));
 8425 
 8426         // Check if the untyped edge is a string.
 8427         m_out.appendTo(testUntypedEdgeIsString, testStringEquality);
 8428         m_out.branch(isNotString(rightValue, rightValueType), unsure(continuation), unsure(testStringEquality));
 8429 
 8430         // Full String compare.
 8431         m_out.appendTo(testStringEquality, continuation);
 8432         ValueFromBlock slowResult = m_out.anchor(stringsEqual(leftString, rightValue, stringEdge, untypedEdge));
 8433         m_out.jump(continuation);
 8434 
 8435         // Continuation.
 8436         m_out.appendTo(continuation, lastNext);
 8437         setBoolean(m_out.phi(Int32, fastTrue, fastFalse, slowResult));
 8438     }
 8439 
 8440     void compileCompareEqPtr()
 8441     {
 8442         setBoolean(
 8443             m_out.equal(
 8444                 lowJSValue(m_node-&gt;child1()),
 8445                 weakPointer(m_node-&gt;cellOperand()-&gt;cell())));
 8446     }
 8447 
 8448     void compileCompareLess()
 8449     {
 8450         compare(
 8451             [&amp;] (LValue left, LValue right) {
 8452                 return m_out.lessThan(left, right);
 8453             },
 8454             [&amp;] (LValue left, LValue right) {
 8455                 return m_out.doubleLessThan(left, right);
 8456             },
 8457             operationCompareStringImplLess,
 8458             operationCompareStringLess,
 8459             operationCompareLess);
 8460     }
 8461 
 8462     void compileCompareLessEq()
 8463     {
 8464         compare(
 8465             [&amp;] (LValue left, LValue right) {
 8466                 return m_out.lessThanOrEqual(left, right);
 8467             },
 8468             [&amp;] (LValue left, LValue right) {
 8469                 return m_out.doubleLessThanOrEqual(left, right);
 8470             },
 8471             operationCompareStringImplLessEq,
 8472             operationCompareStringLessEq,
 8473             operationCompareLessEq);
 8474     }
 8475 
 8476     void compileCompareGreater()
 8477     {
 8478         compare(
 8479             [&amp;] (LValue left, LValue right) {
 8480                 return m_out.greaterThan(left, right);
 8481             },
 8482             [&amp;] (LValue left, LValue right) {
 8483                 return m_out.doubleGreaterThan(left, right);
 8484             },
 8485             operationCompareStringImplGreater,
 8486             operationCompareStringGreater,
 8487             operationCompareGreater);
 8488     }
 8489 
 8490     void compileCompareGreaterEq()
 8491     {
 8492         compare(
 8493             [&amp;] (LValue left, LValue right) {
 8494                 return m_out.greaterThanOrEqual(left, right);
 8495             },
 8496             [&amp;] (LValue left, LValue right) {
 8497                 return m_out.doubleGreaterThanOrEqual(left, right);
 8498             },
 8499             operationCompareStringImplGreaterEq,
 8500             operationCompareStringGreaterEq,
 8501             operationCompareGreaterEq);
 8502     }
 8503 
 8504     void compileCompareBelow()
 8505     {
 8506         setBoolean(m_out.below(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 8507     }
 8508 
 8509     void compileCompareBelowEq()
 8510     {
 8511         setBoolean(m_out.belowOrEqual(lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));
 8512     }
 8513 
 8514     void compileSameValue()
 8515     {
<a name="348" id="anc348"></a><span class="line-added"> 8516         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 8517         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
 8518             LValue arg1 = lowDouble(m_node-&gt;child1());
 8519             LValue arg2 = lowDouble(m_node-&gt;child2());
 8520 
 8521             LBasicBlock numberCase = m_out.newBlock();
 8522             LBasicBlock continuation = m_out.newBlock();
 8523 
 8524             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
 8525             patchpoint-&gt;append(arg1, ValueRep::SomeRegister);
 8526             patchpoint-&gt;append(arg2, ValueRep::SomeRegister);
 8527             patchpoint-&gt;numGPScratchRegisters = 1;
 8528             patchpoint-&gt;setGenerator(
 8529                 [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8530                     GPRReg scratchGPR = params.gpScratch(0);
 8531                     jit.moveDoubleTo64(params[1].fpr(), scratchGPR);
 8532                     jit.moveDoubleTo64(params[2].fpr(), params[0].gpr());
 8533                     jit.compare64(CCallHelpers::Equal, scratchGPR, params[0].gpr(), params[0].gpr());
 8534                 });
 8535             patchpoint-&gt;effects = Effects::none();
 8536             ValueFromBlock compareResult = m_out.anchor(patchpoint);
 8537             m_out.branch(patchpoint, unsure(continuation), unsure(numberCase));
 8538 
 8539             LBasicBlock lastNext = m_out.appendTo(numberCase, continuation);
 8540             LValue isArg1NaN = m_out.doubleNotEqualOrUnordered(arg1, arg1);
 8541             LValue isArg2NaN = m_out.doubleNotEqualOrUnordered(arg2, arg2);
 8542             ValueFromBlock nanResult = m_out.anchor(m_out.bitAnd(isArg1NaN, isArg2NaN));
 8543             m_out.jump(continuation);
 8544 
 8545             m_out.appendTo(continuation, lastNext);
 8546             setBoolean(m_out.phi(Int32, compareResult, nanResult));
 8547             return;
 8548         }
 8549 
 8550         ASSERT(m_node-&gt;isBinaryUseKind(UntypedUse));
<a name="349" id="anc349"></a><span class="line-modified"> 8551         setBoolean(vmCall(Int32, operationSameValue, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
 8552     }
 8553 
 8554     void compileLogicalNot()
 8555     {
 8556         setBoolean(m_out.logicalNot(boolify(m_node-&gt;child1())));
 8557     }
 8558 
 8559     void compileCallOrConstruct()
 8560     {
 8561         Node* node = m_node;
 8562         unsigned numArgs = node-&gt;numChildren() - 1;
 8563 
 8564         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8565 
 8566         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 8567         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 8568 
 8569         // JS-&gt;JS calling convention requires that the caller allows this much space on top of stack to
 8570         // get trashed by the callee, even if not all of that space is used to pass arguments. We tell
 8571         // B3 this explicitly for two reasons:
 8572         //
 8573         // - We will only pass frameSize worth of stuff.
 8574         // - The trashed stack guarantee is logically separate from the act of passing arguments, so we
 8575         //   shouldn&#39;t rely on Air to infer the trashed stack property based on the arguments it ends
 8576         //   up seeing.
 8577         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 8578 
 8579         // Collect the arguments, since this can generate code and we want to generate it before we emit
 8580         // the call.
 8581         Vector&lt;ConstrainedValue&gt; arguments;
 8582 
 8583         // Make sure that the callee goes into GPR0 because that&#39;s where the slow path thunks expect the
 8584         // callee to be.
 8585         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 8586 
 8587         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8588             intptr_t offsetFromSP =
 8589                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8590             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8591         };
 8592 
 8593         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<a name="350" id="anc350"></a><span class="line-modified"> 8594         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
 8595         for (unsigned i = 0; i &lt; numArgs; ++i)
<a name="351" id="anc351"></a><span class="line-modified"> 8596             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
 8597 
 8598         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 8599         patchpoint-&gt;appendVector(arguments);
 8600 
 8601         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 8602             preparePatchpointForExceptions(patchpoint);
 8603 
<a name="352" id="anc352"></a><span class="line-modified"> 8604         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 8605         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 8606         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8607         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 8608         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8609 
 8610         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8611         State* state = &amp;m_ftlState;
 8612         VM* vm = &amp;this-&gt;vm();
 8613         patchpoint-&gt;setGenerator(
 8614             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8615                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8616                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8617 
 8618                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8619 
 8620                 jit.store32(
 8621                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="353" id="anc353"></a><span class="line-modified"> 8622                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 8623 
 8624                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8625 
 8626                 CCallHelpers::DataLabelPtr targetToCheck;
 8627                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8628                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8629                     CCallHelpers::TrustedImmPtr(nullptr));
 8630 
 8631                 CCallHelpers::Call fastCall = jit.nearCall();
 8632                 CCallHelpers::Jump done = jit.jump();
 8633 
 8634                 slowPath.link(&amp;jit);
 8635 
 8636                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<a name="354" id="anc354"></a><span class="line-added"> 8637                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
 8638                 CCallHelpers::Call slowCall = jit.nearCall();
 8639                 done.link(&amp;jit);
 8640 
 8641                 callLinkInfo-&gt;setUpCall(
 8642                     node-&gt;op() == Construct ? CallLinkInfo::Construct : CallLinkInfo::Call,
 8643                     node-&gt;origin.semantic, GPRInfo::regT0);
 8644 
 8645                 jit.addPtr(
 8646                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 8647                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8648 
 8649                 jit.addLinkTask(
 8650                     [=] (LinkBuffer&amp; linkBuffer) {
 8651                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8652                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8653 
 8654                         callLinkInfo-&gt;setCallLocations(
 8655                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8656                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8657                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8658                     });
 8659             });
 8660 
 8661         setJSValue(patchpoint);
 8662     }
 8663 
 8664     void compileDirectCallOrConstruct()
 8665     {
 8666         Node* node = m_node;
 8667         bool isTail = node-&gt;op() == DirectTailCall;
 8668         bool isConstruct = node-&gt;op() == DirectConstruct;
 8669 
 8670         ExecutableBase* executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 8671         FunctionExecutable* functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 8672 
 8673         unsigned numPassedArgs = node-&gt;numChildren() - 1;
 8674         unsigned numAllocatedArgs = numPassedArgs;
 8675 
 8676         if (functionExecutable) {
 8677             numAllocatedArgs = std::max(
 8678                 numAllocatedArgs,
 8679                 std::min(
 8680                     static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1,
 8681                     Options::maximumDirectCallStackSize()));
 8682         }
 8683 
 8684         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8685 
 8686         if (!isTail) {
 8687             unsigned frameSize = (CallFrame::headerSizeInRegisters + numAllocatedArgs) * sizeof(EncodedJSValue);
 8688             unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 8689 
 8690             m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 8691         }
 8692 
 8693         Vector&lt;ConstrainedValue&gt; arguments;
 8694 
 8695         arguments.append(ConstrainedValue(jsCallee, ValueRep::SomeRegister));
 8696         if (!isTail) {
 8697             auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 8698                 intptr_t offsetFromSP =
 8699                     (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 8700                 arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 8701             };
 8702 
 8703             addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<a name="355" id="anc355"></a><span class="line-modified"> 8704             addArgument(m_out.constInt32(numPassedArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
 8705             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
<a name="356" id="anc356"></a><span class="line-modified"> 8706                 addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
 8707             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
<a name="357" id="anc357"></a><span class="line-modified"> 8708                 addArgument(m_out.constInt64(JSValue::encode(jsUndefined())), virtualRegisterForArgumentIncludingThis(i), 0);</span>
 8709         } else {
 8710             for (unsigned i = 0; i &lt; numPassedArgs; ++i)
 8711                 arguments.append(ConstrainedValue(lowJSValue(m_graph.varArgChild(node, 1 + i)), ValueRep::WarmAny));
 8712         }
 8713 
 8714         PatchpointValue* patchpoint = m_out.patchpoint(isTail ? Void : Int64);
 8715         patchpoint-&gt;appendVector(arguments);
 8716 
 8717         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 8718 
 8719         if (isTail) {
 8720             // The shuffler needs tags.
<a name="358" id="anc358"></a><span class="line-modified"> 8721             patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 8722             patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 8723         }
 8724 
 8725         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 8726         if (!isTail) {
 8727             patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 8728             patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 8729         }
 8730 
 8731         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8732         State* state = &amp;m_ftlState;
 8733         patchpoint-&gt;setGenerator(
 8734             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8735                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8736                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8737 
 8738                 GPRReg calleeGPR = params[!isTail].gpr();
 8739 
 8740                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 8741 
 8742                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 8743                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 8744 
 8745                 if (isTail) {
 8746                     CallFrameShuffleData shuffleData;
 8747                     shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 8748 
 8749                     RegisterSet toSave = params.unavailableRegisters();
 8750                     shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatCell);
 8751                     toSave.set(calleeGPR);
 8752                     for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 8753                         ValueRecovery recovery = params[1 + i].recoveryForJSValue();
 8754                         shuffleData.args.append(recovery);
 8755                         recovery.forEachReg(
 8756                             [&amp;] (Reg reg) {
 8757                                 toSave.set(reg);
 8758                             });
 8759                     }
 8760                     for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 8761                         shuffleData.args.append(ValueRecovery::constant(jsUndefined()));
 8762                     shuffleData.numPassedArgs = numPassedArgs;
 8763                     shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 8764 
 8765                     CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8766 
 8767                     CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
 8768                     CCallHelpers::Label mainPath = jit.label();
 8769 
 8770                     jit.store32(
 8771                         CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="359" id="anc359"></a><span class="line-modified"> 8772                         CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 8773 
 8774                     callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 8775                     CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 8776 
 8777                     CCallHelpers::Call call = jit.nearTailCall();
 8778 
 8779                     jit.abortWithReason(JITDidReturnFromTailCall);
 8780 
 8781                     CCallHelpers::Label slowPath = jit.label();
 8782                     patchableJump.m_jump.linkTo(slowPath, &amp;jit);
 8783                     callOperation(
 8784                         *state, toSave, jit,
 8785                         node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 8786                         InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo), calleeGPR).call();
 8787                     jit.jump().linkTo(mainPath, &amp;jit);
 8788 
 8789                     callLinkInfo-&gt;setUpCall(
 8790                         CallLinkInfo::DirectTailCall, node-&gt;origin.semantic, InvalidGPRReg);
 8791                     callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 8792                     if (numAllocatedArgs &gt; numPassedArgs)
<a name="360" id="anc360"></a><span class="line-modified"> 8793                         callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
 8794 
 8795                     jit.addLinkTask(
 8796                         [=] (LinkBuffer&amp; linkBuffer) {
 8797                             CodeLocationLabel&lt;JSInternalPtrTag&gt; patchableJumpLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump);
 8798                             CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 8799                             CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 8800 
 8801                             callLinkInfo-&gt;setCallLocations(
 8802                                 patchableJumpLocation,
 8803                                 slowPathLocation,
 8804                                 callLocation);
 8805                         });
 8806                     return;
 8807                 }
 8808 
 8809                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8810 
 8811                 CCallHelpers::Label mainPath = jit.label();
 8812 
 8813                 jit.store32(
 8814                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="361" id="anc361"></a><span class="line-modified"> 8815                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 8816 
 8817                 CCallHelpers::Call call = jit.nearCall();
 8818                 jit.addPtr(
 8819                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 8820                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 8821 
 8822                 callLinkInfo-&gt;setUpCall(
 8823                     isConstruct ? CallLinkInfo::DirectConstruct : CallLinkInfo::DirectCall,
 8824                     node-&gt;origin.semantic, InvalidGPRReg);
 8825                 callLinkInfo-&gt;setExecutableDuringCompilation(executable);
 8826                 if (numAllocatedArgs &gt; numPassedArgs)
<a name="362" id="anc362"></a><span class="line-modified"> 8827                     callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
 8828 
 8829                 params.addLatePath(
 8830                     [=] (CCallHelpers&amp; jit) {
 8831                         AllowMacroScratchRegisterUsage allowScratch(jit);
 8832 
 8833                         CCallHelpers::Label slowPath = jit.label();
 8834                         if (isX86())
 8835                             jit.pop(CCallHelpers::selectScratchGPR(calleeGPR));
 8836 
 8837                         callOperation(
 8838                             *state, params.unavailableRegisters(), jit,
 8839                             node-&gt;origin.semantic, exceptions.get(), operationLinkDirectCall,
 8840                             InvalidGPRReg, CCallHelpers::TrustedImmPtr(callLinkInfo),
 8841                             calleeGPR).call();
 8842                         jit.jump().linkTo(mainPath, &amp;jit);
 8843 
 8844                         jit.addLinkTask(
 8845                             [=] (LinkBuffer&amp; linkBuffer) {
 8846                                 CodeLocationNearCall&lt;JSInternalPtrTag&gt; callLocation = linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(call);
 8847                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(slowPath);
 8848 
 8849                                 linkBuffer.link(call, slowPathLocation);
 8850 
 8851                                 callLinkInfo-&gt;setCallLocations(
 8852                                     CodeLocationLabel&lt;JSInternalPtrTag&gt;(),
 8853                                     slowPathLocation,
 8854                                     callLocation);
 8855                             });
 8856                     });
 8857             });
 8858 
 8859         if (isTail)
 8860             patchpoint-&gt;effects.terminal = true;
 8861         else
 8862             setJSValue(patchpoint);
 8863     }
 8864 
 8865     void compileTailCall()
 8866     {
 8867         Node* node = m_node;
 8868         unsigned numArgs = node-&gt;numChildren() - 1;
 8869 
 8870         // It seems counterintuitive that this is needed given that tail calls don&#39;t create a new frame
 8871         // on the stack. However, the tail call slow path builds the frame at SP instead of FP before
 8872         // calling into the slow path C code. This slow path may decide to throw an exception because
 8873         // the callee we&#39;re trying to call is not callable. Throwing an exception will cause us to walk
 8874         // the stack, which may read, for the sake of the correctness of this code, arbitrary slots on the
 8875         // stack to recover state. This call arg area ensures the call frame shuffler does not overwrite
 8876         // any of the slots the stack walking code requires when on the slow path.
 8877         m_proc.requestCallArgAreaSizeInBytes(
 8878             WTF::roundUpToMultipleOf(stackAlignmentBytes(), (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue)));
 8879 
 8880         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 8881 
 8882         // We want B3 to give us all of the arguments using whatever mechanism it thinks is
 8883         // convenient. The generator then shuffles those arguments into our own call frame,
 8884         // destroying our frame in the process.
 8885 
 8886         // Note that we don&#39;t have to do anything special for exceptions. A tail call is only a
 8887         // tail call if it is not inside a try block.
 8888 
 8889         Vector&lt;ConstrainedValue&gt; arguments;
 8890 
 8891         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 8892 
 8893         for (unsigned i = 0; i &lt; numArgs; ++i) {
 8894             // Note: we could let the shuffler do boxing for us, but it&#39;s not super clear that this
 8895             // would be better. Also, if we wanted to do that, then we&#39;d have to teach the shuffler
 8896             // that 32-bit values could land at 4-byte alignment but not 8-byte alignment.
 8897 
 8898             ConstrainedValue constrainedValue(
 8899                 lowJSValue(m_graph.varArgChild(node, 1 + i)),
 8900                 ValueRep::WarmAny);
 8901             arguments.append(constrainedValue);
 8902         }
 8903 
 8904         PatchpointValue* patchpoint = m_out.patchpoint(Void);
 8905         patchpoint-&gt;appendVector(arguments);
 8906 
<a name="363" id="anc363"></a><span class="line-modified"> 8907         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 8908         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 8909 
 8910         // Prevent any of the arguments from using the scratch register.
 8911         patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());
 8912 
 8913         patchpoint-&gt;effects.terminal = true;
 8914 
 8915         // We don&#39;t have to tell the patchpoint that we will clobber registers, since we won&#39;t return
 8916         // anyway.
 8917 
 8918         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 8919         State* state = &amp;m_ftlState;
 8920         VM* vm = &amp;this-&gt;vm();
 8921         patchpoint-&gt;setGenerator(
 8922             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 8923                 AllowMacroScratchRegisterUsage allowScratch(jit);
 8924                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 8925 
 8926                 // Yes, this is really necessary. You could throw an exception in a host call on the
<a name="364" id="anc364"></a><span class="line-modified"> 8927                 // slow path. That&#39;ll route us to operationLookupExceptionHandler(), which unwinds starting</span>
 8928                 // with the call site index of our frame. Bad things happen if it&#39;s not set.
 8929                 jit.store32(
 8930                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="365" id="anc365"></a><span class="line-modified"> 8931                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 8932 
 8933                 CallFrameShuffleData shuffleData;
 8934                 shuffleData.numLocals = state-&gt;jitCode-&gt;common.frameRegisterCount;
 8935                 shuffleData.callee = ValueRecovery::inGPR(GPRInfo::regT0, DataFormatJS);
 8936 
 8937                 for (unsigned i = 0; i &lt; numArgs; ++i)
 8938                     shuffleData.args.append(params[1 + i].recoveryForJSValue());
 8939 
 8940                 shuffleData.numPassedArgs = numArgs;
 8941 
 8942                 shuffleData.setupCalleeSaveRegisters(jit.codeBlock());
 8943 
 8944                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 8945 
 8946                 CCallHelpers::DataLabelPtr targetToCheck;
 8947                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 8948                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 8949                     CCallHelpers::TrustedImmPtr(nullptr));
 8950 
 8951                 callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 8952                 CallFrameShuffler(jit, shuffleData).prepareForTailCall();
 8953 
 8954                 CCallHelpers::Call fastCall = jit.nearTailCall();
 8955 
 8956                 slowPath.link(&amp;jit);
 8957 
 8958                 CallFrameShuffler slowPathShuffler(jit, shuffleData);
 8959                 slowPathShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 8960                 slowPathShuffler.prepareForSlowPath();
 8961 
 8962                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<a name="366" id="anc366"></a><span class="line-added"> 8963                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
 8964                 CCallHelpers::Call slowCall = jit.nearCall();
 8965 
 8966                 jit.abortWithReason(JITDidReturnFromTailCall);
 8967 
 8968                 callLinkInfo-&gt;setUpCall(CallLinkInfo::TailCall, codeOrigin, GPRInfo::regT0);
 8969 
 8970                 jit.addLinkTask(
 8971                     [=] (LinkBuffer&amp; linkBuffer) {
 8972                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 8973                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 8974 
 8975                         callLinkInfo-&gt;setCallLocations(
 8976                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 8977                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 8978                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 8979                     });
 8980             });
 8981     }
 8982 
 8983     void compileCallOrConstructVarargsSpread()
 8984     {
 8985         Node* node = m_node;
 8986         Node* arguments = node-&gt;child3().node();
 8987 
 8988         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 8989         LValue thisArg = lowJSValue(m_node-&gt;child2());
 8990 
 8991         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomSpread || arguments-&gt;op() == PhantomNewArrayBuffer);
 8992 
 8993         unsigned staticArgumentCount = 0;
 8994         Vector&lt;LValue, 2&gt; spreadLengths;
 8995         Vector&lt;LValue, 8&gt; patchpointArguments;
 8996         HashMap&lt;InlineCallFrame*, LValue, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt; cachedSpreadLengths;
 8997         auto pushAndCountArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 8998             if (target-&gt;op() == PhantomSpread) {
 8999                 self(target-&gt;child1().node());
 9000                 return;
 9001             }
 9002 
 9003             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9004                 BitVector* bitVector = target-&gt;bitVector();
 9005                 for (unsigned i = target-&gt;numChildren(); i--; ) {
 9006                     if (bitVector-&gt;get(i))
 9007                         self(m_graph.varArgChild(target, i).node());
 9008                     else {
 9009                         ++staticArgumentCount;
 9010                         LValue argument = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 9011                         patchpointArguments.append(argument);
 9012                     }
 9013                 }
 9014                 return;
 9015             }
 9016 
 9017             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9018                 staticArgumentCount += target-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 9019                 return;
 9020             }
 9021 
 9022             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 9023             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 9024             unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 9025             LValue length = cachedSpreadLengths.ensure(inlineCallFrame, [&amp;] () {
 9026                 return m_out.zeroExtPtr(this-&gt;getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));
 9027             }).iterator-&gt;value;
 9028             patchpointArguments.append(length);
 9029             spreadLengths.append(length);
 9030         });
 9031 
 9032         pushAndCountArgumentsFromRightToLeft(arguments);
 9033         LValue argumentCountIncludingThis = m_out.constIntPtr(staticArgumentCount + 1);
 9034         for (LValue length : spreadLengths)
 9035             argumentCountIncludingThis = m_out.add(length, argumentCountIncludingThis);
 9036 
 9037         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 9038 
 9039         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 9040         patchpoint-&gt;append(thisArg, ValueRep::WarmAny);
 9041         patchpoint-&gt;append(argumentCountIncludingThis, ValueRep::WarmAny);
 9042         patchpoint-&gt;appendVectorWithRep(patchpointArguments, ValueRep::WarmAny);
<a name="367" id="anc367"></a><span class="line-modified"> 9043         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 9044         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 9045 
 9046         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 9047 
 9048         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 9049         patchpoint-&gt;clobber(RegisterSet::volatileRegistersForJSCall()); // No inputs will be in a volatile register.
 9050         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 9051 
 9052         patchpoint-&gt;numGPScratchRegisters = 0;
 9053 
 9054         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 9055         unsigned minimumJSCallAreaSize =
 9056             sizeof(CallerFrameAndPC) +
 9057             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 9058 
 9059         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 9060 
 9061         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 9062         State* state = &amp;m_ftlState;
 9063         VM* vm = &amp;this-&gt;vm();
 9064         patchpoint-&gt;setGenerator(
 9065             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9066                 AllowMacroScratchRegisterUsage allowScratch(jit);
 9067                 CallSiteIndex callSiteIndex =
 9068                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 9069 
 9070                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 9071                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 9072 
 9073                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 9074 
 9075                 jit.store32(
 9076                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="368" id="anc368"></a><span class="line-modified"> 9077                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 9078 
 9079                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 9080 
 9081                 RegisterSet usedRegisters = RegisterSet::allRegisters();
 9082                 usedRegisters.exclude(RegisterSet::volatileRegistersForJSCall());
 9083                 GPRReg calleeGPR = params[1].gpr();
 9084                 usedRegisters.set(calleeGPR);
 9085 
 9086                 ScratchRegisterAllocator allocator(usedRegisters);
 9087                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 9088                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 9089                 GPRReg scratchGPR3 = allocator.allocateScratchGPR();
 9090                 GPRReg scratchGPR4 = allocator.allocateScratchGPR();
 9091                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 9092 
 9093                 auto getValueFromRep = [&amp;] (B3::ValueRep rep, GPRReg result) {
 9094                     ASSERT(!usedRegisters.get(result));
 9095 
 9096                     if (rep.isConstant()) {
 9097                         jit.move(CCallHelpers::Imm64(rep.value()), result);
 9098                         return;
 9099                     }
 9100 
 9101                     // Note: in this function, we only request 64 bit values.
 9102                     if (rep.isStack()) {
 9103                         jit.load64(
 9104                             CCallHelpers::Address(GPRInfo::callFrameRegister, rep.offsetFromFP()),
 9105                             result);
 9106                         return;
 9107                     }
 9108 
 9109                     RELEASE_ASSERT(rep.isGPR());
 9110                     ASSERT(usedRegisters.get(rep.gpr()));
 9111                     jit.move(rep.gpr(), result);
 9112                 };
 9113 
 9114                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 9115                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 9116                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 9117                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 9118                 };
 9119 
 9120                 CCallHelpers::JumpList slowCase;
 9121                 unsigned originalStackHeight = params.proc().frameSize();
 9122 
 9123                 {
 9124                     unsigned numUsedSlots = WTF::roundUpToMultipleOf(stackAlignmentRegisters(), originalStackHeight / sizeof(EncodedJSValue));
 9125                     B3::ValueRep argumentCountIncludingThisRep = params[3];
 9126                     getValueFromRep(argumentCountIncludingThisRep, scratchGPR2);
 9127                     slowCase.append(jit.branch32(CCallHelpers::Above, scratchGPR2, CCallHelpers::TrustedImm32(JSC::maxArguments + 1)));
 9128 
 9129                     jit.move(scratchGPR2, scratchGPR1);
 9130                     jit.addPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(numUsedSlots + CallFrame::headerSizeInRegisters)), scratchGPR1);
 9131                     // scratchGPR1 now has the required frame size in Register units
 9132                     // Round scratchGPR1 to next multiple of stackAlignmentRegisters()
 9133                     jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentRegisters() - 1), scratchGPR1);
 9134                     jit.andPtr(CCallHelpers::TrustedImm32(~(stackAlignmentRegisters() - 1)), scratchGPR1);
 9135                     jit.negPtr(scratchGPR1);
 9136                     jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR1, CCallHelpers::TimesEight), scratchGPR1);
 9137 
 9138                     // Before touching stack values, we should update the stack pointer to protect them from signal stack.
 9139                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), scratchGPR1, CCallHelpers::stackPointerRegister);
 9140 
<a name="369" id="anc369"></a><span class="line-modified"> 9141                     jit.store32(scratchGPR2, CCallHelpers::Address(scratchGPR1, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
 9142 
 9143                     int storeOffset = CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register));
 9144 
 9145                     unsigned paramsOffset = 4;
 9146                     unsigned index = 0;
 9147                     auto emitArgumentsFromRightToLeft = recursableLambda([&amp;](auto self, Node* target) -&gt; void {
 9148                         if (target-&gt;op() == PhantomSpread) {
 9149                             self(target-&gt;child1().node());
 9150                             return;
 9151                         }
 9152 
 9153                         if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9154                             BitVector* bitVector = target-&gt;bitVector();
 9155                             for (unsigned i = target-&gt;numChildren(); i--; ) {
 9156                                 if (bitVector-&gt;get(i))
 9157                                     self(state-&gt;graph.varArgChild(target, i).node());
 9158                                 else {
 9159                                     jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 9160                                     getValueFromRep(params[paramsOffset + (index++)], scratchGPR3);
 9161                                     jit.store64(scratchGPR3,
 9162                                         CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 9163                                 }
 9164                             }
 9165                             return;
 9166                         }
 9167 
 9168                         if (target-&gt;op() == PhantomNewArrayBuffer) {
 9169                             auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 9170                             Checked&lt;int32_t&gt; offsetCount { 1 };
 9171                             for (unsigned i = array-&gt;length(); i--; ++offsetCount) {
 9172                                 // Because varargs values are drained as JSValue, we should not generate value
 9173                                 // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 9174                                 int64_t value = JSValue::encode(array-&gt;get(i));
 9175                                 jit.move(CCallHelpers::TrustedImm64(value), scratchGPR3);
 9176                                 Checked&lt;int32_t&gt; currentStoreOffset { storeOffset };
 9177                                 currentStoreOffset -= (offsetCount * static_cast&lt;int32_t&gt;(sizeof(Register)));
 9178                                 jit.store64(scratchGPR3,
 9179                                     CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, currentStoreOffset.unsafeGet()));
 9180                             }
 9181                             jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(array-&gt;length())), scratchGPR2);
 9182                             return;
 9183                         }
 9184 
 9185                         RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 9186                         InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 9187 
 9188                         unsigned numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();
 9189 
 9190                         B3::ValueRep numArgumentsToCopy = params[paramsOffset + (index++)];
 9191                         getValueFromRep(numArgumentsToCopy, scratchGPR3);
 9192                         int loadOffset = (AssemblyHelpers::argumentsStart(inlineCallFrame).offset() + numberOfArgumentsToSkip) * static_cast&lt;int&gt;(sizeof(Register));
 9193 
 9194                         auto done = jit.branchTestPtr(MacroAssembler::Zero, scratchGPR3);
 9195                         auto loopStart = jit.label();
 9196                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR3);
 9197                         jit.subPtr(CCallHelpers::TrustedImmPtr(static_cast&lt;size_t&gt;(1)), scratchGPR2);
 9198                         jit.load64(CCallHelpers::BaseIndex(GPRInfo::callFrameRegister, scratchGPR3, CCallHelpers::TimesEight, loadOffset), scratchGPR4);
 9199                         jit.store64(scratchGPR4,
 9200                             CCallHelpers::BaseIndex(scratchGPR1, scratchGPR2, CCallHelpers::TimesEight, storeOffset));
 9201                         jit.branchTestPtr(CCallHelpers::NonZero, scratchGPR3).linkTo(loopStart, &amp;jit);
 9202                         done.link(&amp;jit);
 9203                     });
 9204                     emitArgumentsFromRightToLeft(arguments);
 9205                 }
 9206 
 9207                 {
 9208                     CCallHelpers::Jump dontThrow = jit.jump();
 9209                     slowCase.link(&amp;jit);
<a name="370" id="anc370"></a><span class="line-modified"> 9210                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic));</span>
<span class="line-added"> 9211                     jit.prepareCallOperation(jit.vm());</span>
 9212                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 9213                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 9214 
 9215                     dontThrow.link(&amp;jit);
 9216                 }
 9217 
 9218                 ASSERT(calleeGPR == GPRInfo::regT0);
 9219                 jit.store64(calleeGPR, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 9220                 getValueFromRep(params[2], scratchGPR3);
 9221                 jit.store64(scratchGPR3, CCallHelpers::calleeArgumentSlot(0));
 9222 
 9223                 CallLinkInfo::CallType callType;
 9224                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 9225                     callType = CallLinkInfo::ConstructVarargs;
 9226                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 9227                     callType = CallLinkInfo::TailCallVarargs;
 9228                 else
 9229                     callType = CallLinkInfo::CallVarargs;
 9230 
 9231                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 9232 
 9233                 CCallHelpers::DataLabelPtr targetToCheck;
 9234                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 9235                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 9236                     CCallHelpers::TrustedImmPtr(nullptr));
 9237 
 9238                 CCallHelpers::Call fastCall;
 9239                 CCallHelpers::Jump done;
 9240 
 9241                 if (isTailCall) {
 9242                     jit.emitRestoreCalleeSaves();
 9243                     jit.prepareForTailCallSlow();
 9244                     fastCall = jit.nearTailCall();
 9245                 } else {
 9246                     fastCall = jit.nearCall();
 9247                     done = jit.jump();
 9248                 }
 9249 
 9250                 slowPath.link(&amp;jit);
 9251 
 9252                 if (isTailCall)
 9253                     jit.emitRestoreCalleeSaves();
 9254                 ASSERT(!usedRegisters.get(GPRInfo::regT2));
 9255                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<a name="371" id="anc371"></a><span class="line-added"> 9256                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
 9257                 CCallHelpers::Call slowCall = jit.nearCall();
 9258 
 9259                 if (isTailCall)
 9260                     jit.abortWithReason(JITDidReturnFromTailCall);
 9261                 else
 9262                     done.link(&amp;jit);
 9263 
 9264                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 9265 
 9266                 jit.addPtr(
 9267                     CCallHelpers::TrustedImm32(-originalStackHeight),
 9268                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 9269 
 9270                 jit.addLinkTask(
 9271                     [=] (LinkBuffer&amp; linkBuffer) {
 9272                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 9273                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 9274 
 9275                         callLinkInfo-&gt;setCallLocations(
 9276                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 9277                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 9278                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 9279                     });
 9280             });
 9281 
 9282         switch (node-&gt;op()) {
 9283         case TailCallForwardVarargs:
 9284             m_out.unreachable();
 9285             break;
 9286 
 9287         default:
 9288             setJSValue(patchpoint);
 9289             break;
 9290         }
 9291     }
 9292 
 9293     void compileCallOrConstructVarargs()
 9294     {
 9295         Node* node = m_node;
 9296         LValue jsCallee = lowJSValue(m_node-&gt;child1());
 9297         LValue thisArg = lowJSValue(m_node-&gt;child2());
 9298 
 9299         LValue jsArguments = nullptr;
 9300         bool forwarding = false;
 9301 
 9302         switch (node-&gt;op()) {
 9303         case CallVarargs:
 9304         case TailCallVarargs:
 9305         case TailCallVarargsInlinedCaller:
 9306         case ConstructVarargs:
 9307             jsArguments = lowJSValue(node-&gt;child3());
 9308             break;
 9309         case CallForwardVarargs:
 9310         case TailCallForwardVarargs:
 9311         case TailCallForwardVarargsInlinedCaller:
 9312         case ConstructForwardVarargs:
 9313             forwarding = true;
 9314             break;
 9315         default:
 9316             DFG_CRASH(m_graph, node, &quot;bad node type&quot;);
 9317             break;
 9318         }
 9319 
 9320         if (forwarding &amp;&amp; m_node-&gt;child3()) {
 9321             Node* arguments = m_node-&gt;child3().node();
 9322             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 9323                 compileCallOrConstructVarargsSpread();
 9324                 return;
 9325             }
 9326         }
 9327 
 9328 
 9329         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 9330 
 9331         // Append the forms of the arguments that we will use before any clobbering happens.
 9332         patchpoint-&gt;append(jsCallee, ValueRep::reg(GPRInfo::regT0));
 9333         if (jsArguments)
 9334             patchpoint-&gt;appendSomeRegister(jsArguments);
 9335         patchpoint-&gt;appendSomeRegister(thisArg);
 9336 
 9337         if (!forwarding) {
 9338             // Now append them again for after clobbering. Note that the compiler may ask us to use a
 9339             // different register for the late for the post-clobbering version of the value. This gives
 9340             // the compiler a chance to spill these values without having to burn any callee-saves.
 9341             patchpoint-&gt;append(jsCallee, ValueRep::LateColdAny);
 9342             patchpoint-&gt;append(jsArguments, ValueRep::LateColdAny);
 9343             patchpoint-&gt;append(thisArg, ValueRep::LateColdAny);
 9344         }
 9345 
 9346         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
 9347             preparePatchpointForExceptions(patchpoint);
 9348 
<a name="372" id="anc372"></a><span class="line-modified"> 9349         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 9350         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 9351 
 9352         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 9353         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 9354         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 9355 
 9356         // This is the minimum amount of call arg area stack space that all JS-&gt;JS calls always have.
 9357         unsigned minimumJSCallAreaSize =
 9358             sizeof(CallerFrameAndPC) +
 9359             WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(EncodedJSValue));
 9360 
 9361         m_proc.requestCallArgAreaSizeInBytes(minimumJSCallAreaSize);
 9362 
 9363         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 9364         State* state = &amp;m_ftlState;
 9365         VM* vm = &amp;this-&gt;vm();
 9366         patchpoint-&gt;setGenerator(
 9367             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9368                 AllowMacroScratchRegisterUsage allowScratch(jit);
 9369                 CallSiteIndex callSiteIndex =
 9370                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 9371 
 9372                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
 9373                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 9374 
 9375                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 9376 
 9377                 jit.store32(
 9378                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="373" id="anc373"></a><span class="line-modified"> 9379                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 9380 
 9381                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 9382                 CallVarargsData* data = node-&gt;callVarargsData();
 9383 
 9384                 unsigned argIndex = 1;
 9385                 GPRReg calleeGPR = params[argIndex++].gpr();
 9386                 ASSERT(calleeGPR == GPRInfo::regT0);
 9387                 GPRReg argumentsGPR = jsArguments ? params[argIndex++].gpr() : InvalidGPRReg;
 9388                 GPRReg thisGPR = params[argIndex++].gpr();
 9389 
 9390                 B3::ValueRep calleeLateRep;
 9391                 B3::ValueRep argumentsLateRep;
 9392                 B3::ValueRep thisLateRep;
 9393                 if (!forwarding) {
 9394                     // If we&#39;re not forwarding then we&#39;ll need callee, arguments, and this after we
 9395                     // have potentially clobbered calleeGPR, argumentsGPR, and thisGPR. Our technique
 9396                     // for this is to supply all of those operands as late uses in addition to
 9397                     // specifying them as early uses. It&#39;s possible that the late use uses a spill
 9398                     // while the early use uses a register, and it&#39;s possible for the late and early
 9399                     // uses to use different registers. We do know that the late uses interfere with
 9400                     // all volatile registers and so won&#39;t use those, but the early uses may use
 9401                     // volatile registers and in the case of calleeGPR, it&#39;s pinned to regT0 so it
 9402                     // definitely will.
 9403                     //
 9404                     // Note that we have to be super careful with these. It&#39;s possible that these
 9405                     // use a shuffling of the registers used for calleeGPR, argumentsGPR, and
 9406                     // thisGPR. If that happens and we do for example:
 9407                     //
 9408                     //     calleeLateRep.emitRestore(jit, calleeGPR);
 9409                     //     argumentsLateRep.emitRestore(jit, calleeGPR);
 9410                     //
 9411                     // Then we might end up with garbage if calleeLateRep.gpr() == argumentsGPR and
 9412                     // argumentsLateRep.gpr() == calleeGPR.
 9413                     //
 9414                     // We do a variety of things to prevent this from happening. For example, we use
 9415                     // argumentsLateRep before needing the other two and after we&#39;ve already stopped
 9416                     // using the *GPRs. Also, we pin calleeGPR to regT0, and rely on the fact that
 9417                     // the *LateReps cannot use volatile registers (so they cannot be regT0, so
 9418                     // calleeGPR != argumentsLateRep.gpr() and calleeGPR != thisLateRep.gpr()).
 9419                     //
 9420                     // An alternative would have been to just use early uses and early-clobber all
 9421                     // volatile registers. But that would force callee, arguments, and this into
 9422                     // callee-save registers even if we have to spill them. We don&#39;t want spilling to
 9423                     // use up three callee-saves.
 9424                     //
 9425                     // TL;DR: The way we use LateReps here is dangerous and barely works but achieves
 9426                     // some desirable performance properties, so don&#39;t mistake the cleverness for
 9427                     // elegance.
 9428                     calleeLateRep = params[argIndex++];
 9429                     argumentsLateRep = params[argIndex++];
 9430                     thisLateRep = params[argIndex++];
 9431                 }
 9432 
 9433                 // Get some scratch registers.
 9434                 RegisterSet usedRegisters;
 9435                 usedRegisters.merge(RegisterSet::stackRegisters());
 9436                 usedRegisters.merge(RegisterSet::reservedHardwareRegisters());
 9437                 usedRegisters.merge(RegisterSet::calleeSaveRegisters());
 9438                 usedRegisters.set(calleeGPR);
 9439                 if (argumentsGPR != InvalidGPRReg)
 9440                     usedRegisters.set(argumentsGPR);
 9441                 usedRegisters.set(thisGPR);
 9442                 if (calleeLateRep.isReg())
 9443                     usedRegisters.set(calleeLateRep.reg());
 9444                 if (argumentsLateRep.isReg())
 9445                     usedRegisters.set(argumentsLateRep.reg());
 9446                 if (thisLateRep.isReg())
 9447                     usedRegisters.set(thisLateRep.reg());
 9448                 ScratchRegisterAllocator allocator(usedRegisters);
 9449                 GPRReg scratchGPR1 = allocator.allocateScratchGPR();
 9450                 GPRReg scratchGPR2 = allocator.allocateScratchGPR();
 9451                 GPRReg scratchGPR3 = forwarding ? allocator.allocateScratchGPR() : InvalidGPRReg;
 9452                 RELEASE_ASSERT(!allocator.numberOfReusedRegisters());
 9453 
 9454                 auto callWithExceptionCheck = [&amp;] (void* callee) {
 9455                     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(callee)), GPRInfo::nonPreservedNonArgumentGPR0);
 9456                     jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 9457                     exceptions-&gt;append(jit.emitExceptionCheck(*vm, AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 9458                 };
 9459 
 9460                 unsigned originalStackHeight = params.proc().frameSize();
 9461 
 9462                 if (forwarding) {
 9463                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 9464 
 9465                     CCallHelpers::JumpList slowCase;
 9466                     InlineCallFrame* inlineCallFrame;
 9467                     if (node-&gt;child3())
 9468                         inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 9469                     else
 9470                         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 9471 
 9472                     // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 9473                     emitSetupVarargsFrameFastCase(*vm, jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 9474 
 9475                     CCallHelpers::Jump done = jit.jump();
 9476                     slowCase.link(&amp;jit);
<a name="374" id="anc374"></a><span class="line-modified"> 9477                     jit.setupArguments&lt;decltype(operationThrowStackOverflowForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic));</span>
<span class="line-added"> 9478                     jit.prepareCallOperation(jit.vm());</span>
 9479                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationThrowStackOverflowForVarargs));
 9480                     jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 9481 
 9482                     done.link(&amp;jit);
 9483                 } else {
 9484                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR1);
<a name="375" id="anc375"></a><span class="line-modified"> 9485                     jit.setupArguments&lt;decltype(operationSizeFrameForVarargs)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), argumentsGPR, scratchGPR1, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset));</span>
<span class="line-added"> 9486                     jit.prepareCallOperation(jit.vm());</span>
 9487                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSizeFrameForVarargs));
 9488 
 9489                     jit.move(GPRInfo::returnValueGPR, scratchGPR1);
 9490                     jit.move(CCallHelpers::TrustedImm32(originalStackHeight / sizeof(EncodedJSValue)), scratchGPR2);
 9491                     argumentsLateRep.emitRestore(jit, argumentsGPR);
 9492                     emitSetVarargsFrame(jit, scratchGPR1, false, scratchGPR2, scratchGPR2);
 9493                     jit.addPtr(CCallHelpers::TrustedImm32(-minimumJSCallAreaSize), scratchGPR2, CCallHelpers::stackPointerRegister);
<a name="376" id="anc376"></a><span class="line-modified"> 9494                     jit.setupArguments&lt;decltype(operationSetupVarargsFrame)&gt;(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), scratchGPR2, argumentsGPR, CCallHelpers::TrustedImm32(data-&gt;firstVarArgOffset), scratchGPR1);</span>
<span class="line-added"> 9495                     jit.prepareCallOperation(jit.vm());</span>
 9496                     callWithExceptionCheck(bitwise_cast&lt;void*&gt;(operationSetupVarargsFrame));
 9497 
 9498                     jit.addPtr(CCallHelpers::TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister);
 9499 
 9500                     calleeLateRep.emitRestore(jit, GPRInfo::regT0);
 9501 
 9502                     // This may not emit code if thisGPR got a callee-save. Also, we&#39;re guaranteed
 9503                     // that thisGPR != GPRInfo::regT0 because regT0 interferes with it.
 9504                     thisLateRep.emitRestore(jit, thisGPR);
 9505                 }
 9506 
 9507                 jit.store64(GPRInfo::regT0, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));
 9508                 jit.store64(thisGPR, CCallHelpers::calleeArgumentSlot(0));
 9509 
 9510                 CallLinkInfo::CallType callType;
 9511                 if (node-&gt;op() == ConstructVarargs || node-&gt;op() == ConstructForwardVarargs)
 9512                     callType = CallLinkInfo::ConstructVarargs;
 9513                 else if (node-&gt;op() == TailCallVarargs || node-&gt;op() == TailCallForwardVarargs)
 9514                     callType = CallLinkInfo::TailCallVarargs;
 9515                 else
 9516                     callType = CallLinkInfo::CallVarargs;
 9517 
 9518                 bool isTailCall = CallLinkInfo::callModeFor(callType) == CallMode::Tail;
 9519 
 9520                 CCallHelpers::DataLabelPtr targetToCheck;
 9521                 CCallHelpers::Jump slowPath = jit.branchPtrWithPatch(
 9522                     CCallHelpers::NotEqual, GPRInfo::regT0, targetToCheck,
 9523                     CCallHelpers::TrustedImmPtr(nullptr));
 9524 
 9525                 CCallHelpers::Call fastCall;
 9526                 CCallHelpers::Jump done;
 9527 
 9528                 if (isTailCall) {
 9529                     jit.emitRestoreCalleeSaves();
 9530                     jit.prepareForTailCallSlow();
 9531                     fastCall = jit.nearTailCall();
 9532                 } else {
 9533                     fastCall = jit.nearCall();
 9534                     done = jit.jump();
 9535                 }
 9536 
 9537                 slowPath.link(&amp;jit);
 9538 
 9539                 if (isTailCall)
 9540                     jit.emitRestoreCalleeSaves();
 9541                 jit.move(CCallHelpers::TrustedImmPtr(callLinkInfo), GPRInfo::regT2);
<a name="377" id="anc377"></a><span class="line-added"> 9542                 jit.move(CCallHelpers::TrustedImmPtr(jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic)), GPRInfo::regT3);</span>
 9543                 CCallHelpers::Call slowCall = jit.nearCall();
 9544 
 9545                 if (isTailCall)
 9546                     jit.abortWithReason(JITDidReturnFromTailCall);
 9547                 else
 9548                     done.link(&amp;jit);
 9549 
 9550                 callLinkInfo-&gt;setUpCall(callType, node-&gt;origin.semantic, GPRInfo::regT0);
 9551 
 9552                 jit.addPtr(
 9553                     CCallHelpers::TrustedImm32(-originalStackHeight),
 9554                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 9555 
 9556                 jit.addLinkTask(
 9557                     [=] (LinkBuffer&amp; linkBuffer) {
 9558                         MacroAssemblerCodePtr&lt;JITThunkPtrTag&gt; linkCall = vm-&gt;getCTIStub(linkCallThunkGenerator).code();
 9559                         linkBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(linkCall));
 9560 
 9561                         callLinkInfo-&gt;setCallLocations(
 9562                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall)),
 9563                             CodeLocationLabel&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck)),
 9564                             linkBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall));
 9565                     });
 9566             });
 9567 
 9568         switch (node-&gt;op()) {
 9569         case TailCallVarargs:
 9570         case TailCallForwardVarargs:
 9571             m_out.unreachable();
 9572             break;
 9573 
 9574         default:
 9575             setJSValue(patchpoint);
 9576             break;
 9577         }
 9578     }
 9579 
 9580     void compileCallEval()
 9581     {
 9582         Node* node = m_node;
 9583         unsigned numArgs = node-&gt;numChildren() - 1;
 9584 
 9585         LValue jsCallee = lowJSValue(m_graph.varArgChild(node, 0));
 9586 
 9587         unsigned frameSize = (CallFrame::headerSizeInRegisters + numArgs) * sizeof(EncodedJSValue);
 9588         unsigned alignedFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), frameSize);
 9589 
 9590         m_proc.requestCallArgAreaSizeInBytes(alignedFrameSize);
 9591 
 9592         Vector&lt;ConstrainedValue&gt; arguments;
 9593         arguments.append(ConstrainedValue(jsCallee, ValueRep::reg(GPRInfo::regT0)));
 9594 
 9595         auto addArgument = [&amp;] (LValue value, VirtualRegister reg, int offset) {
 9596             intptr_t offsetFromSP =
 9597                 (reg.offset() - CallerFrameAndPC::sizeInRegisters) * sizeof(EncodedJSValue) + offset;
 9598             arguments.append(ConstrainedValue(value, ValueRep::stackArgument(offsetFromSP)));
 9599         };
 9600 
 9601         addArgument(jsCallee, VirtualRegister(CallFrameSlot::callee), 0);
<a name="378" id="anc378"></a><span class="line-modified"> 9602         addArgument(m_out.constInt32(numArgs), VirtualRegister(CallFrameSlot::argumentCountIncludingThis), PayloadOffset);</span>
 9603         for (unsigned i = 0; i &lt; numArgs; ++i)
<a name="379" id="anc379"></a><span class="line-modified"> 9604             addArgument(lowJSValue(m_graph.varArgChild(node, 1 + i)), virtualRegisterForArgumentIncludingThis(i), 0);</span>
 9605 
 9606         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
 9607         patchpoint-&gt;appendVector(arguments);
 9608 
 9609         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
 9610 
<a name="380" id="anc380"></a><span class="line-modified"> 9611         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified"> 9612         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
 9613         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
 9614         patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());
 9615         patchpoint-&gt;resultConstraints = { ValueRep::reg(GPRInfo::returnValueGPR) };
 9616 
 9617         CodeOrigin codeOrigin = codeOriginDescriptionOfCallSite();
 9618         State* state = &amp;m_ftlState;
 9619         VM&amp; vm = this-&gt;vm();
<a name="381" id="anc381"></a><span class="line-added"> 9620         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 9621         patchpoint-&gt;setGenerator(
 9622             [=, &amp;vm] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
 9623                 AllowMacroScratchRegisterUsage allowScratch(jit);
 9624                 CallSiteIndex callSiteIndex = state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(codeOrigin);
 9625 
 9626                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
 9627 
 9628                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
 9629 
 9630                 jit.store32(
 9631                     CCallHelpers::TrustedImm32(callSiteIndex.bits()),
<a name="382" id="anc382"></a><span class="line-modified"> 9632                     CCallHelpers::tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
 9633 
 9634                 CallLinkInfo* callLinkInfo = jit.codeBlock()-&gt;addCallLinkInfo();
 9635                 callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, node-&gt;origin.semantic, GPRInfo::regT0);
 9636 
 9637                 jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), CCallHelpers::stackPointerRegister, GPRInfo::regT1);
 9638                 jit.storePtr(GPRInfo::callFrameRegister, CCallHelpers::Address(GPRInfo::regT1, CallFrame::callerFrameOffset()));
 9639 
 9640                 // Now we need to make room for:
 9641                 // - The caller frame and PC for a call to operationCallEval.
 9642                 // - Potentially two arguments on the stack.
<a name="383" id="anc383"></a><span class="line-modified"> 9643                 unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
 9644                 requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 9645                 jit.subPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
<a name="384" id="anc384"></a><span class="line-modified"> 9646                 jit.setupArguments&lt;decltype(operationCallEval)&gt;(globalObject, GPRInfo::regT1);</span>
<span class="line-added"> 9647                 jit.prepareCallOperation(vm);</span>
 9648                 jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationCallEval)), GPRInfo::nonPreservedNonArgumentGPR0);
 9649                 jit.call(GPRInfo::nonPreservedNonArgumentGPR0, OperationPtrTag);
 9650                 exceptions-&gt;append(jit.emitExceptionCheck(state-&gt;vm(), AssemblyHelpers::NormalExceptionCheck, AssemblyHelpers::FarJumpWidth));
 9651 
 9652                 CCallHelpers::Jump done = jit.branchTest64(CCallHelpers::NonZero, GPRInfo::returnValueGPR);
 9653 
 9654                 jit.addPtr(CCallHelpers::TrustedImm32(requiredBytes), CCallHelpers::stackPointerRegister);
 9655                 jit.load64(CCallHelpers::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<a name="385" id="anc385"></a><span class="line-modified"> 9656                 jit.emitDumbVirtualCall(vm, globalObject, callLinkInfo);</span>
 9657 
 9658                 done.link(&amp;jit);
 9659                 jit.addPtr(
 9660                     CCallHelpers::TrustedImm32(-params.proc().frameSize()),
 9661                     GPRInfo::callFrameRegister, CCallHelpers::stackPointerRegister);
 9662             });
 9663 
 9664         setJSValue(patchpoint);
 9665     }
 9666 
<a name="386" id="anc386"></a><span class="line-modified"> 9667     void compileVarargsLength()</span>
 9668     {
<a name="387" id="anc387"></a><span class="line-added"> 9669         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 9670         LoadVarargsData* data = m_node-&gt;loadVarargsData();
<a name="388" id="anc388"></a><span class="line-modified"> 9671         LValue jsArguments = lowJSValue(m_node-&gt;argumentsChild());</span>
 9672 
 9673         LValue length = vmCall(
<a name="389" id="anc389"></a><span class="line-modified"> 9674             Int32, operationSizeOfVarargs, weakPointer(globalObject), jsArguments,</span>
 9675             m_out.constInt32(data-&gt;offset));
 9676 
<a name="390" id="anc390"></a>





 9677         LValue lengthIncludingThis = m_out.add(length, m_out.int32One);
 9678 
<a name="391" id="anc391"></a><span class="line-modified"> 9679         setInt32(lengthIncludingThis);</span>
<span class="line-modified"> 9680     }</span>
<span class="line-modified"> 9681 </span>
<span class="line-added"> 9682     void compileLoadVarargs()</span>
<span class="line-added"> 9683     {</span>
<span class="line-added"> 9684         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added"> 9685         LoadVarargsData* data = m_node-&gt;loadVarargsData();</span>
<span class="line-added"> 9686         LValue jsArguments = lowJSValue(m_node-&gt;argumentsChild());</span>
<span class="line-added"> 9687         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>
 9688 
 9689         speculate(
 9690             VarargsOverflow, noValue(), nullptr,
<a name="392" id="anc392"></a><span class="line-modified"> 9691             m_out.bitOr(m_out.isZero32(lengthIncludingThis), m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit))));</span>
 9692 
 9693         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9694 
<a name="393" id="anc393"></a><span class="line-modified"> 9695         // FIXME: This computation is rather silly. If operationLoadVarargs just took a pointer instead</span>
 9696         // of a VirtualRegister, we wouldn&#39;t have to do this.
 9697         // https://bugs.webkit.org/show_bug.cgi?id=141660
 9698         LValue machineStart = m_out.lShr(
<a name="394" id="anc394"></a><span class="line-modified"> 9699             m_out.sub(addressFor(data-&gt;machineStart).value(), m_callFrame),</span>
 9700             m_out.constIntPtr(3));
 9701 
 9702         vmCall(
<a name="395" id="anc395"></a><span class="line-modified"> 9703             Void, operationLoadVarargs, weakPointer(globalObject),</span>
 9704             m_out.castToInt32(machineStart), jsArguments, m_out.constInt32(data-&gt;offset),
<a name="396" id="anc396"></a><span class="line-modified"> 9705             lengthIncludingThis, m_out.constInt32(data-&gt;mandatoryMinimum));</span>
 9706     }
 9707 
 9708     void compileForwardVarargs()
 9709     {
<a name="397" id="anc397"></a><span class="line-modified"> 9710         if (m_node-&gt;argumentsChild()) {</span>
<span class="line-modified"> 9711             Node* arguments = m_node-&gt;argumentsChild().node();</span>
 9712             if (arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread) {
 9713                 compileForwardVarargsWithSpread();
 9714                 return;
 9715             }
 9716         }
 9717 
 9718         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 9719         InlineCallFrame* inlineCallFrame;
<a name="398" id="anc398"></a><span class="line-modified"> 9720         if (m_node-&gt;argumentsChild())</span>
<span class="line-modified"> 9721             inlineCallFrame = m_node-&gt;argumentsChild()-&gt;origin.semantic.inlineCallFrame();</span>
 9722         else
 9723             inlineCallFrame = m_node-&gt;origin.semantic.inlineCallFrame();
 9724 
<a name="399" id="anc399"></a><span class="line-modified"> 9725         unsigned numberOfArgumentsToSkip = data-&gt;offset;</span>
<span class="line-modified"> 9726         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>





























 9727 
<a name="400" id="anc400"></a><span class="line-added"> 9728         LValue length = m_out.sub(lengthIncludingThis, m_out.int32One);</span>
 9729         speculate(
 9730             VarargsOverflow, noValue(), nullptr,
 9731             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 9732 
 9733         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9734 
<a name="401" id="anc401"></a>
 9735         LValue sourceStart = getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);
 9736         LValue targetStart = addressFor(data-&gt;machineStart).value();
 9737 
 9738         LBasicBlock undefinedLoop = m_out.newBlock();
 9739         LBasicBlock mainLoopEntry = m_out.newBlock();
 9740         LBasicBlock mainLoop = m_out.newBlock();
 9741         LBasicBlock continuation = m_out.newBlock();
 9742 
 9743         LValue lengthAsPtr = m_out.zeroExtPtr(length);
 9744         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 9745         ValueFromBlock loopBound = m_out.anchor(loopBoundValue);
 9746         m_out.branch(
 9747             m_out.above(loopBoundValue, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 9748 
 9749         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, mainLoopEntry);
 9750         LValue previousIndex = m_out.phi(pointerType(), loopBound);
 9751         LValue currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 9752         m_out.store64(
 9753             m_out.constInt64(JSValue::encode(jsUndefined())),
 9754             m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 9755         ValueFromBlock nextIndex = m_out.anchor(currentIndex);
 9756         m_out.addIncomingToPhi(previousIndex, nextIndex);
 9757         m_out.branch(
 9758             m_out.above(currentIndex, lengthAsPtr), unsure(undefinedLoop), unsure(mainLoopEntry));
 9759 
 9760         m_out.appendTo(mainLoopEntry, mainLoop);
 9761         loopBound = m_out.anchor(lengthAsPtr);
 9762         m_out.branch(m_out.notNull(lengthAsPtr), unsure(mainLoop), unsure(continuation));
 9763 
 9764         m_out.appendTo(mainLoop, continuation);
 9765         previousIndex = m_out.phi(pointerType(), loopBound);
 9766         currentIndex = m_out.sub(previousIndex, m_out.intPtrOne);
 9767         LValue value = m_out.load64(
 9768             m_out.baseIndex(m_heaps.variables, sourceStart, currentIndex));
 9769         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, currentIndex));
 9770         nextIndex = m_out.anchor(currentIndex);
 9771         m_out.addIncomingToPhi(previousIndex, nextIndex);
 9772         m_out.branch(m_out.isNull(currentIndex), unsure(continuation), unsure(mainLoop));
 9773 
 9774         m_out.appendTo(continuation, lastNext);
 9775     }
 9776 
 9777     LValue getSpreadLengthFromInlineCallFrame(InlineCallFrame* inlineCallFrame, unsigned numberOfArgumentsToSkip)
 9778     {
 9779         ArgumentsLength argumentsLength = getArgumentsLength(inlineCallFrame);
 9780         if (argumentsLength.isKnown) {
 9781             unsigned knownLength = argumentsLength.known;
 9782             if (knownLength &gt;= numberOfArgumentsToSkip)
 9783                 knownLength = knownLength - numberOfArgumentsToSkip;
 9784             else
 9785                 knownLength = 0;
 9786             return m_out.constInt32(knownLength);
 9787         }
 9788 
 9789 
 9790         // We need to perform the same logical operation as the code above, but through dynamic operations.
 9791         if (!numberOfArgumentsToSkip)
 9792             return argumentsLength.value;
 9793 
<a name="402" id="anc402"></a><span class="line-modified"> 9794         RELEASE_ASSERT(numberOfArgumentsToSkip &lt; static_cast&lt;unsigned&gt;(INT32_MIN));</span>

 9795 
<a name="403" id="anc403"></a><span class="line-modified"> 9796         LValue fixedLength = m_out.sub(argumentsLength.value, m_out.constInt32(numberOfArgumentsToSkip));</span>





 9797 
<a name="404" id="anc404"></a><span class="line-modified"> 9798         return m_out.select(m_out.greaterThanOrEqual(fixedLength, m_out.int32Zero), fixedLength, m_out.int32Zero, SelectPredictability::Predictable);</span>

 9799     }
 9800 
 9801     void compileForwardVarargsWithSpread()
 9802     {
<a name="405" id="anc405"></a><span class="line-modified"> 9803         Node* arguments = m_node-&gt;argumentsChild().node();</span>


 9804         RELEASE_ASSERT(arguments-&gt;op() == PhantomNewArrayWithSpread || arguments-&gt;op() == PhantomNewArrayBuffer || arguments-&gt;op() == PhantomSpread);
 9805 
<a name="406" id="anc406"></a><span class="line-modified"> 9806         LValue lengthIncludingThis = lowInt32(m_node-&gt;child1());</span>




































 9807 
 9808         LoadVarargsData* data = m_node-&gt;loadVarargsData();
 9809         speculate(
 9810             VarargsOverflow, noValue(), nullptr,
 9811             m_out.above(lengthIncludingThis, m_out.constInt32(data-&gt;limit)));
 9812 
 9813         m_out.store32(lengthIncludingThis, payloadFor(data-&gt;machineCount));
 9814 
 9815         LValue targetStart = addressFor(data-&gt;machineStart).value();
 9816 
<a name="407" id="anc407"></a><span class="line-modified"> 9817         auto forwardSpread = recursableLambda([this, &amp;targetStart](auto self, Node* target, LValue storeIndex) -&gt; LValue {</span>
 9818             if (target-&gt;op() == PhantomSpread)
 9819                 return self(target-&gt;child1().node(), storeIndex);
 9820 
 9821             if (target-&gt;op() == PhantomNewArrayWithSpread) {
 9822                 BitVector* bitVector = target-&gt;bitVector();
 9823                 for (unsigned i = 0; i &lt; target-&gt;numChildren(); i++) {
 9824                     if (bitVector-&gt;get(i))
 9825                         storeIndex = self(m_graph.varArgChild(target, i).node(), storeIndex);
 9826                     else {
 9827                         LValue value = this-&gt;lowJSValue(m_graph.varArgChild(target, i));
 9828                         m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, storeIndex));
 9829                         storeIndex = m_out.add(m_out.constIntPtr(1), storeIndex);
 9830                     }
 9831                 }
 9832                 return storeIndex;
 9833             }
 9834 
 9835             if (target-&gt;op() == PhantomNewArrayBuffer) {
 9836                 auto* array = target-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 9837                 for (unsigned i = 0; i &lt; array-&gt;length(); i++) {
 9838                     // Because forwarded values are drained as JSValue, we should not generate value
 9839                     // in Double form even if PhantomNewArrayBuffer&#39;s indexingType is ArrayWithDouble.
 9840                     int64_t value = JSValue::encode(array-&gt;get(i));
 9841                     m_out.store64(m_out.constInt64(value), m_out.baseIndex(m_heaps.variables, targetStart, storeIndex, JSValue(), (Checked&lt;int32_t&gt;(sizeof(Register)) * i).unsafeGet()));
 9842                 }
 9843                 return m_out.add(m_out.constIntPtr(array-&gt;length()), storeIndex);
 9844             }
 9845 
 9846             RELEASE_ASSERT(target-&gt;op() == PhantomCreateRest);
 9847             InlineCallFrame* inlineCallFrame = target-&gt;origin.semantic.inlineCallFrame();
 9848 
<a name="408" id="anc408"></a><span class="line-modified"> 9849             auto numberOfArgumentsToSkip = target-&gt;numberOfArgumentsToSkip();</span>
<span class="line-modified"> 9850             LValue sourceStart = this-&gt;getArgumentsStart(inlineCallFrame, numberOfArgumentsToSkip);</span>
<span class="line-added"> 9851             LValue spreadLength = m_out.zeroExtPtr(getSpreadLengthFromInlineCallFrame(inlineCallFrame, numberOfArgumentsToSkip));</span>
 9852 
 9853             LBasicBlock loop = m_out.newBlock();
 9854             LBasicBlock continuation = m_out.newBlock();
 9855             ValueFromBlock startLoadIndex = m_out.anchor(m_out.constIntPtr(0));
 9856             ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 9857             ValueFromBlock startStoreIndexForEnd = m_out.anchor(storeIndex);
 9858 
 9859             m_out.branch(m_out.isZero64(spreadLength), unsure(continuation), unsure(loop));
 9860 
 9861             LBasicBlock lastNext = m_out.appendTo(loop, continuation);
 9862             LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 9863             LValue loadIndex = m_out.phi(Int64, startLoadIndex);
 9864             LValue value = m_out.load64(
 9865                 m_out.baseIndex(m_heaps.variables, sourceStart, loadIndex));
 9866             m_out.store64(value, m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 9867             LValue nextLoadIndex = m_out.add(m_out.constIntPtr(1), loadIndex);
 9868             m_out.addIncomingToPhi(loadIndex, m_out.anchor(nextLoadIndex));
 9869             LValue nextStoreIndex = m_out.add(m_out.constIntPtr(1), loopStoreIndex);
 9870             m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextStoreIndex));
 9871             ValueFromBlock loopStoreIndexForEnd = m_out.anchor(nextStoreIndex);
 9872             m_out.branch(m_out.below(nextLoadIndex, spreadLength), unsure(loop), unsure(continuation));
 9873 
 9874             m_out.appendTo(continuation, lastNext);
 9875             return m_out.phi(Int64, startStoreIndexForEnd, loopStoreIndexForEnd);
 9876         });
 9877 
 9878         LValue storeIndex = forwardSpread(arguments, m_out.constIntPtr(0));
 9879 
 9880         LBasicBlock undefinedLoop = m_out.newBlock();
 9881         LBasicBlock continuation = m_out.newBlock();
 9882 
 9883         ValueFromBlock startStoreIndex = m_out.anchor(storeIndex);
 9884         LValue loopBoundValue = m_out.constIntPtr(data-&gt;mandatoryMinimum);
 9885         m_out.branch(m_out.below(storeIndex, loopBoundValue),
 9886             unsure(undefinedLoop), unsure(continuation));
 9887 
 9888         LBasicBlock lastNext = m_out.appendTo(undefinedLoop, continuation);
 9889         LValue loopStoreIndex = m_out.phi(Int64, startStoreIndex);
 9890         m_out.store64(
 9891             m_out.constInt64(JSValue::encode(jsUndefined())),
 9892             m_out.baseIndex(m_heaps.variables, targetStart, loopStoreIndex));
 9893         LValue nextIndex = m_out.add(loopStoreIndex, m_out.constIntPtr(1));
 9894         m_out.addIncomingToPhi(loopStoreIndex, m_out.anchor(nextIndex));
 9895         m_out.branch(
 9896             m_out.below(nextIndex, loopBoundValue), unsure(undefinedLoop), unsure(continuation));
 9897 
 9898         m_out.appendTo(continuation, lastNext);
 9899     }
 9900 
 9901     void compileJump()
 9902     {
 9903         m_out.jump(lowBlock(m_node-&gt;targetBlock()));
 9904     }
 9905 
 9906     void compileBranch()
 9907     {
 9908         m_out.branch(
 9909             boolify(m_node-&gt;child1()),
 9910             WeightedTarget(
 9911                 lowBlock(m_node-&gt;branchData()-&gt;taken.block),
 9912                 m_node-&gt;branchData()-&gt;taken.count),
 9913             WeightedTarget(
 9914                 lowBlock(m_node-&gt;branchData()-&gt;notTaken.block),
 9915                 m_node-&gt;branchData()-&gt;notTaken.count));
 9916     }
 9917 
 9918     void compileSwitch()
 9919     {
<a name="409" id="anc409"></a><span class="line-added"> 9920         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
 9921         SwitchData* data = m_node-&gt;switchData();
 9922         switch (data-&gt;kind) {
 9923         case SwitchImm: {
 9924             Vector&lt;ValueFromBlock, 2&gt; intValues;
 9925             LBasicBlock switchOnInts = m_out.newBlock();
 9926 
 9927             LBasicBlock lastNext = m_out.appendTo(m_out.m_block, switchOnInts);
 9928 
 9929             switch (m_node-&gt;child1().useKind()) {
 9930             case Int32Use: {
 9931                 intValues.append(m_out.anchor(lowInt32(m_node-&gt;child1())));
 9932                 m_out.jump(switchOnInts);
 9933                 break;
 9934             }
 9935 
 9936             case UntypedUse: {
 9937                 LBasicBlock isInt = m_out.newBlock();
 9938                 LBasicBlock isNotInt = m_out.newBlock();
 9939                 LBasicBlock isDouble = m_out.newBlock();
 9940 
 9941                 LValue boxedValue = lowJSValue(m_node-&gt;child1());
 9942                 m_out.branch(isNotInt32(boxedValue), unsure(isNotInt), unsure(isInt));
 9943 
 9944                 LBasicBlock innerLastNext = m_out.appendTo(isInt, isNotInt);
 9945 
 9946                 intValues.append(m_out.anchor(unboxInt32(boxedValue)));
 9947                 m_out.jump(switchOnInts);
 9948 
 9949                 m_out.appendTo(isNotInt, isDouble);
 9950                 m_out.branch(
 9951                     isCellOrMisc(boxedValue, provenType(m_node-&gt;child1())),
 9952                     usually(lowBlock(data-&gt;fallThrough.block)), rarely(isDouble));
 9953 
 9954                 m_out.appendTo(isDouble, innerLastNext);
 9955                 LValue doubleValue = unboxDouble(boxedValue);
 9956                 LValue intInDouble = m_out.doubleToInt(doubleValue);
 9957                 intValues.append(m_out.anchor(intInDouble));
 9958                 m_out.branch(
 9959                     m_out.doubleEqual(m_out.intToDouble(intInDouble), doubleValue),
 9960                     unsure(switchOnInts), unsure(lowBlock(data-&gt;fallThrough.block)));
 9961                 break;
 9962             }
 9963 
 9964             default:
 9965                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
 9966                 break;
 9967             }
 9968 
 9969             m_out.appendTo(switchOnInts, lastNext);
 9970             buildSwitch(data, Int32, m_out.phi(Int32, intValues));
 9971             return;
 9972         }
 9973 
 9974         case SwitchChar: {
 9975             LValue stringValue;
 9976 
 9977             // FIXME: We should use something other than unsure() for the branch weight
 9978             // of the fallThrough block. The main challenge is just that we have multiple
 9979             // branches to fallThrough but a single count, so we would need to divvy it up
 9980             // among the different lowered branches.
 9981             // https://bugs.webkit.org/show_bug.cgi?id=129082
 9982 
 9983             switch (m_node-&gt;child1().useKind()) {
 9984             case StringUse: {
 9985                 stringValue = lowString(m_node-&gt;child1());
 9986                 break;
 9987             }
 9988 
 9989             case UntypedUse: {
 9990                 LValue unboxedValue = lowJSValue(m_node-&gt;child1());
 9991 
 9992                 LBasicBlock isCellCase = m_out.newBlock();
 9993                 LBasicBlock isStringCase = m_out.newBlock();
 9994 
 9995                 m_out.branch(
 9996                     isNotCell(unboxedValue, provenType(m_node-&gt;child1())),
 9997                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isCellCase));
 9998 
 9999                 LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
10000                 LValue cellValue = unboxedValue;
10001                 m_out.branch(
10002                     isNotString(cellValue, provenType(m_node-&gt;child1())),
10003                     unsure(lowBlock(data-&gt;fallThrough.block)), unsure(isStringCase));
10004 
10005                 m_out.appendTo(isStringCase, lastNext);
10006                 stringValue = cellValue;
10007                 break;
10008             }
10009 
10010             default:
10011                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
10012                 break;
10013             }
10014 
10015             LBasicBlock lengthIs1 = m_out.newBlock();
10016             LBasicBlock needResolution = m_out.newBlock();
10017             LBasicBlock resolved = m_out.newBlock();
10018             LBasicBlock is8Bit = m_out.newBlock();
10019             LBasicBlock is16Bit = m_out.newBlock();
10020             LBasicBlock continuation = m_out.newBlock();
10021 
10022             ValueFromBlock fastValue = m_out.anchor(m_out.loadPtr(stringValue, m_heaps.JSString_value));
10023             m_out.branch(
10024                 isRopeString(stringValue, m_node-&gt;child1()),
10025                 rarely(needResolution), usually(resolved));
10026 
10027             LBasicBlock lastNext = m_out.appendTo(needResolution, resolved);
10028             ValueFromBlock slowValue = m_out.anchor(
<a name="410" id="anc410"></a><span class="line-modified">10029                 vmCall(pointerType(), operationResolveRope, weakPointer(globalObject), stringValue));</span>
10030             m_out.jump(resolved);
10031 
10032             m_out.appendTo(resolved, lengthIs1);
10033             LValue value = m_out.phi(pointerType(), fastValue, slowValue);
10034             m_out.branch(
10035                 m_out.notEqual(
10036                     m_out.load32NonNegative(value, m_heaps.StringImpl_length),
10037                     m_out.int32One),
10038                 unsure(lowBlock(data-&gt;fallThrough.block)), unsure(lengthIs1));
10039 
10040             m_out.appendTo(lengthIs1, is8Bit);
10041             LValue characterData = m_out.loadPtr(value, m_heaps.StringImpl_data);
10042             m_out.branch(
10043                 m_out.testNonZero32(
10044                     m_out.load32(value, m_heaps.StringImpl_hashAndFlags),
10045                     m_out.constInt32(StringImpl::flagIs8Bit())),
10046                 unsure(is8Bit), unsure(is16Bit));
10047 
10048             Vector&lt;ValueFromBlock, 2&gt; characters;
10049             m_out.appendTo(is8Bit, is16Bit);
10050             characters.append(m_out.anchor(m_out.load8ZeroExt32(characterData, m_heaps.characters8[0])));
10051             m_out.jump(continuation);
10052 
10053             m_out.appendTo(is16Bit, continuation);
10054             characters.append(m_out.anchor(m_out.load16ZeroExt32(characterData, m_heaps.characters16[0])));
10055             m_out.jump(continuation);
10056 
10057             m_out.appendTo(continuation, lastNext);
10058             buildSwitch(data, Int32, m_out.phi(Int32, characters));
10059             return;
10060         }
10061 
10062         case SwitchString: {
10063             switch (m_node-&gt;child1().useKind()) {
10064             case StringIdentUse: {
10065                 LValue stringImpl = lowStringIdent(m_node-&gt;child1());
10066 
10067                 Vector&lt;SwitchCase&gt; cases;
10068                 for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
10069                     LValue value = m_out.constIntPtr(data-&gt;cases[i].value.stringImpl());
10070                     LBasicBlock block = lowBlock(data-&gt;cases[i].target.block);
10071                     Weight weight = Weight(data-&gt;cases[i].target.count);
10072                     cases.append(SwitchCase(value, block, weight));
10073                 }
10074 
10075                 m_out.switchInstruction(
10076                     stringImpl, cases, lowBlock(data-&gt;fallThrough.block),
10077                     Weight(data-&gt;fallThrough.count));
10078                 return;
10079             }
10080 
10081             case StringUse: {
10082                 switchString(data, lowString(m_node-&gt;child1()), m_node-&gt;child1());
10083                 return;
10084             }
10085 
10086             case UntypedUse: {
10087                 LValue value = lowJSValue(m_node-&gt;child1());
10088 
10089                 LBasicBlock isCellBlock = m_out.newBlock();
10090                 LBasicBlock isStringBlock = m_out.newBlock();
10091 
10092                 m_out.branch(
10093                     isCell(value, provenType(m_node-&gt;child1())),
10094                     unsure(isCellBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
10095 
10096                 LBasicBlock lastNext = m_out.appendTo(isCellBlock, isStringBlock);
10097 
10098                 m_out.branch(
10099                     isString(value, provenType(m_node-&gt;child1())),
10100                     unsure(isStringBlock), unsure(lowBlock(data-&gt;fallThrough.block)));
10101 
10102                 m_out.appendTo(isStringBlock, lastNext);
10103 
10104                 switchString(data, value, m_node-&gt;child1());
10105                 return;
10106             }
10107 
10108             default:
10109                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
10110                 return;
10111             }
10112             return;
10113         }
10114 
10115         case SwitchCell: {
10116             LValue cell;
10117             switch (m_node-&gt;child1().useKind()) {
10118             case CellUse: {
10119                 cell = lowCell(m_node-&gt;child1());
10120                 break;
10121             }
10122 
10123             case UntypedUse: {
10124                 LValue value = lowJSValue(m_node-&gt;child1());
10125                 LBasicBlock cellCase = m_out.newBlock();
10126                 m_out.branch(
10127                     isCell(value, provenType(m_node-&gt;child1())),
10128                     unsure(cellCase), unsure(lowBlock(data-&gt;fallThrough.block)));
10129                 m_out.appendTo(cellCase);
10130                 cell = value;
10131                 break;
10132             }
10133 
10134             default:
10135                 DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
10136                 return;
10137             }
10138 
10139             buildSwitch(m_node-&gt;switchData(), pointerType(), cell);
10140             return;
10141         } }
10142 
10143         DFG_CRASH(m_graph, m_node, &quot;Bad switch kind&quot;);
10144     }
10145 
10146     void compileEntrySwitch()
10147     {
10148         Vector&lt;LBasicBlock&gt; successors;
10149         for (DFG::BasicBlock* successor : m_node-&gt;entrySwitchData()-&gt;cases)
10150             successors.append(lowBlock(successor));
10151         m_out.entrySwitch(successors);
10152     }
10153 
10154     void compileReturn()
10155     {
10156         m_out.ret(lowJSValue(m_node-&gt;child1()));
10157     }
10158 
10159     void compileForceOSRExit()
10160     {
10161         terminate(InadequateCoverage);
10162     }
10163 
10164     void compileCPUIntrinsic()
10165     {
10166 #if CPU(X86_64)
10167         Intrinsic intrinsic = m_node-&gt;intrinsic();
10168         switch (intrinsic) {
10169         case CPUMfenceIntrinsic:
10170         case CPUCpuidIntrinsic:
10171         case CPUPauseIntrinsic: {
10172             PatchpointValue* patchpoint = m_out.patchpoint(Void);
10173             patchpoint-&gt;effects = Effects::forCall();
10174             if (intrinsic == CPUCpuidIntrinsic)
10175                 patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::ebx, X86Registers::ecx, X86Registers::edx });
10176 
10177             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
10178                 switch (intrinsic) {
10179                 case CPUMfenceIntrinsic:
10180                     jit.mfence();
10181                     break;
10182                 case CPUCpuidIntrinsic:
10183                     jit.cpuid();
10184                     break;
10185                 case CPUPauseIntrinsic:
10186                     jit.pause();
10187                     break;
10188                 default:
10189                     RELEASE_ASSERT_NOT_REACHED();
10190                 }
10191             });
10192             setJSValue(m_out.constInt64(JSValue::encode(jsUndefined())));
10193             break;
10194         }
10195         case CPURdtscIntrinsic: {
10196             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
10197             patchpoint-&gt;effects = Effects::forCall();
10198             patchpoint-&gt;clobber(RegisterSet { X86Registers::eax, X86Registers::edx });
10199             // The low 32-bits of rdtsc go into rax.
10200             patchpoint-&gt;resultConstraints = { ValueRep::reg(X86Registers::eax) };
10201             patchpoint-&gt;setGenerator( [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
10202                 jit.rdtsc();
10203             });
10204             setJSValue(boxInt32(patchpoint));
10205             break;
10206         }
10207         default:
10208             RELEASE_ASSERT_NOT_REACHED();
10209 
10210         }
10211 #endif
10212     }
10213 
10214     void compileThrow()
10215     {
<a name="411" id="anc411"></a><span class="line-added">10216         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10217         LValue error = lowJSValue(m_node-&gt;child1());
<a name="412" id="anc412"></a><span class="line-modified">10218         vmCall(Void, operationThrowDFG, weakPointer(globalObject), error);</span>
10219         // vmCall() does an exception check so we should never reach this.
10220         m_out.unreachable();
10221     }
10222 
10223     void compileThrowStaticError()
10224     {
<a name="413" id="anc413"></a><span class="line-added">10225         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10226         LValue errorMessage = lowString(m_node-&gt;child1());
10227         LValue errorType = m_out.constInt32(m_node-&gt;errorType());
<a name="414" id="anc414"></a><span class="line-modified">10228         vmCall(Void, operationThrowStaticError, weakPointer(globalObject), errorMessage, errorType);</span>
10229         // vmCall() does an exception check so we should never reach this.
10230         m_out.unreachable();
10231     }
10232 
10233     void compileInvalidationPoint()
10234     {
10235         if (verboseCompilationEnabled())
10236             dataLog(&quot;    Invalidation point with availability: &quot;, availabilityMap(), &quot;\n&quot;);
10237 
10238         DFG_ASSERT(m_graph, m_node, m_origin.exitOK);
10239 
10240         PatchpointValue* patchpoint = m_out.patchpoint(Void);
10241         OSRExitDescriptor* descriptor = appendOSRExitDescriptor(noValue(), nullptr);
10242         NodeOrigin origin = m_origin;
10243         patchpoint-&gt;appendColdAnys(buildExitArguments(descriptor, origin.forExit, noValue()));
10244 
10245         State* state = &amp;m_ftlState;
10246 
10247         patchpoint-&gt;setGenerator(
10248             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
10249                 // The MacroAssembler knows more about this than B3 does. The watchpointLabel() method
10250                 // will ensure that this is followed by a nop shadow but only when this is actually
10251                 // necessary.
10252                 CCallHelpers::Label label = jit.watchpointLabel();
10253 
10254                 RefPtr&lt;OSRExitHandle&gt; handle = descriptor-&gt;emitOSRExitLater(
10255                     *state, UncountableInvalidation, origin, params);
10256 
10257                 RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode.get();
10258 
10259                 jit.addLinkTask(
10260                     [=] (LinkBuffer&amp; linkBuffer) {
10261                         JumpReplacement jumpReplacement(
10262                             linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(label),
10263                             linkBuffer.locationOf&lt;OSRExitPtrTag&gt;(handle-&gt;label));
10264                         jitCode-&gt;common.jumpReplacements.append(jumpReplacement);
10265                     });
10266             });
10267 
10268         // Set some obvious things.
10269         patchpoint-&gt;effects.terminal = false;
10270         patchpoint-&gt;effects.writesLocalState = false;
10271         patchpoint-&gt;effects.readsLocalState = false;
10272 
10273         // This is how we tell B3 about the possibility of jump replacement.
10274         patchpoint-&gt;effects.exitsSideways = true;
10275 
10276         // It&#39;s not possible for some prior branch to determine the safety of this operation. It&#39;s always
10277         // fine to execute this on some path that wouldn&#39;t have originally executed it before
10278         // optimization.
10279         patchpoint-&gt;effects.controlDependent = false;
10280 
10281         // If this falls through then it won&#39;t write anything.
10282         patchpoint-&gt;effects.writes = HeapRange();
10283 
10284         // When this abruptly terminates, it could read any heap location.
10285         patchpoint-&gt;effects.reads = HeapRange::top();
10286     }
10287 
10288     void compileIsEmpty()
10289     {
10290         setBoolean(m_out.isZero64(lowJSValue(m_node-&gt;child1())));
10291     }
10292 
10293     void compileIsUndefined()
10294     {
10295         setBoolean(equalNullOrUndefined(m_node-&gt;child1(), AllCellsAreFalse, EqualUndefined));
10296     }
10297 
10298     void compileIsUndefinedOrNull()
10299     {
10300         setBoolean(isOther(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
10301     }
10302 
10303     void compileIsBoolean()
10304     {
10305         setBoolean(isBoolean(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
10306     }
10307 
10308     void compileIsNumber()
10309     {
10310         setBoolean(isNumber(lowJSValue(m_node-&gt;child1()), provenType(m_node-&gt;child1())));
10311     }
10312 
10313     void compileNumberIsInteger()
10314     {
10315         LBasicBlock notInt32 = m_out.newBlock();
10316         LBasicBlock doubleCase = m_out.newBlock();
10317         LBasicBlock doubleNotNanOrInf = m_out.newBlock();
10318         LBasicBlock continuation = m_out.newBlock();
10319 
10320         LValue input = lowJSValue(m_node-&gt;child1());
10321 
10322         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
10323         m_out.branch(
10324             isInt32(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(notInt32));
10325 
10326         LBasicBlock lastNext = m_out.appendTo(notInt32, doubleCase);
10327         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
10328         m_out.branch(
10329             isNotNumber(input, provenType(m_node-&gt;child1())), unsure(continuation), unsure(doubleCase));
10330 
10331         m_out.appendTo(doubleCase, doubleNotNanOrInf);
10332         LValue doubleAsInt;
10333         LValue asDouble = unboxDouble(input, &amp;doubleAsInt);
10334         LValue expBits = m_out.bitAnd(m_out.lShr(doubleAsInt, m_out.constInt32(52)), m_out.constInt64(0x7ff));
10335         m_out.branch(
10336             m_out.equal(expBits, m_out.constInt64(0x7ff)),
10337             unsure(continuation), unsure(doubleNotNanOrInf));
10338 
10339         m_out.appendTo(doubleNotNanOrInf, continuation);
10340         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
10341         patchpoint-&gt;appendSomeRegister(asDouble);
10342         patchpoint-&gt;numFPScratchRegisters = 1;
10343         patchpoint-&gt;effects = Effects::none();
10344         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
10345             GPRReg result = params[0].gpr();
10346             FPRReg input = params[1].fpr();
10347             FPRReg temp = params.fpScratch(0);
10348             jit.roundTowardZeroDouble(input, temp);
10349             jit.compareDouble(MacroAssembler::DoubleEqual, input, temp, result);
10350         });
10351         ValueFromBlock patchpointResult = m_out.anchor(patchpoint);
10352         m_out.jump(continuation);
10353 
10354         m_out.appendTo(continuation, lastNext);
10355         setBoolean(m_out.phi(Int32, trueResult, falseResult, patchpointResult));
10356     }
10357 
10358     void compileIsCellWithType()
10359     {
10360         if (m_node-&gt;child1().useKind() == UntypedUse) {
10361             LValue value = lowJSValue(m_node-&gt;child1());
10362 
10363             LBasicBlock isCellCase = m_out.newBlock();
10364             LBasicBlock continuation = m_out.newBlock();
10365 
10366             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10367             m_out.branch(
10368                 isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
10369 
10370             LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
10371             ValueFromBlock cellResult = m_out.anchor(isCellWithType(value, m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
10372             m_out.jump(continuation);
10373 
10374             m_out.appendTo(continuation, lastNext);
10375             setBoolean(m_out.phi(Int32, notCellResult, cellResult));
10376         } else {
10377             ASSERT(m_node-&gt;child1().useKind() == CellUse);
10378             setBoolean(isCellWithType(lowCell(m_node-&gt;child1()), m_node-&gt;queriedType(), m_node-&gt;speculatedTypeForQuery(), provenType(m_node-&gt;child1())));
10379         }
10380     }
10381 
10382     void compileIsObject()
10383     {
10384         LValue value = lowJSValue(m_node-&gt;child1());
10385 
10386         LBasicBlock isCellCase = m_out.newBlock();
10387         LBasicBlock continuation = m_out.newBlock();
10388 
10389         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10390         m_out.branch(
10391             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
10392 
10393         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
10394         ValueFromBlock cellResult = m_out.anchor(isObject(value, provenType(m_node-&gt;child1())));
10395         m_out.jump(continuation);
10396 
10397         m_out.appendTo(continuation, lastNext);
10398         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
10399     }
10400 
10401     LValue wangsInt64Hash(LValue input)
10402     {
10403         // key += ~(key &lt;&lt; 32);
10404         LValue key = input;
10405         LValue temp = key;
10406         temp = m_out.shl(temp, m_out.constInt32(32));
10407         temp = m_out.bitNot(temp);
10408         key = m_out.add(key, temp);
10409         // key ^= (key &gt;&gt; 22);
10410         temp = key;
10411         temp = m_out.lShr(temp, m_out.constInt32(22));
10412         key = m_out.bitXor(key, temp);
10413         // key += ~(key &lt;&lt; 13);
10414         temp = key;
10415         temp = m_out.shl(temp, m_out.constInt32(13));
10416         temp = m_out.bitNot(temp);
10417         key = m_out.add(key, temp);
10418         // key ^= (key &gt;&gt; 8);
10419         temp = key;
10420         temp = m_out.lShr(temp, m_out.constInt32(8));
10421         key = m_out.bitXor(key, temp);
10422         // key += (key &lt;&lt; 3);
10423         temp = key;
10424         temp = m_out.shl(temp, m_out.constInt32(3));
10425         key = m_out.add(key, temp);
10426         // key ^= (key &gt;&gt; 15);
10427         temp = key;
10428         temp = m_out.lShr(temp, m_out.constInt32(15));
10429         key = m_out.bitXor(key, temp);
10430         // key += ~(key &lt;&lt; 27);
10431         temp = key;
10432         temp = m_out.shl(temp, m_out.constInt32(27));
10433         temp = m_out.bitNot(temp);
10434         key = m_out.add(key, temp);
10435         // key ^= (key &gt;&gt; 31);
10436         temp = key;
10437         temp = m_out.lShr(temp, m_out.constInt32(31));
10438         key = m_out.bitXor(key, temp);
10439         key = m_out.castToInt32(key);
10440 
10441         return key;
10442     }
10443 
10444     LValue mapHashString(LValue string, Edge&amp; edge)
10445     {
<a name="415" id="anc415"></a><span class="line-added">10446         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10447         LBasicBlock nonEmptyStringCase = m_out.newBlock();
10448         LBasicBlock slowCase = m_out.newBlock();
10449         LBasicBlock continuation = m_out.newBlock();
10450 
10451         m_out.branch(isRopeString(string, edge), rarely(slowCase), usually(nonEmptyStringCase));
10452 
10453         LBasicBlock lastNext = m_out.appendTo(nonEmptyStringCase, slowCase);
10454         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
10455         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10456         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
10457         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
10458             unsure(slowCase), unsure(continuation));
10459 
10460         m_out.appendTo(slowCase, continuation);
10461         ValueFromBlock slowResult = m_out.anchor(
<a name="416" id="anc416"></a><span class="line-modified">10462             vmCall(Int32, operationMapHash, weakPointer(globalObject), string));</span>
10463         m_out.jump(continuation);
10464 
10465         m_out.appendTo(continuation, lastNext);
10466         return m_out.phi(Int32, slowResult, nonEmptyStringHashResult);
10467     }
10468 
10469     void compileMapHash()
10470     {
<a name="417" id="anc417"></a><span class="line-added">10471         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10472         switch (m_node-&gt;child1().useKind()) {
10473         case BooleanUse:
10474         case Int32Use:
10475         case SymbolUse:
10476         case ObjectUse: {
10477             LValue key = lowJSValue(m_node-&gt;child1(), ManualOperandSpeculation);
10478             speculate(m_node-&gt;child1());
10479             setInt32(wangsInt64Hash(key));
10480             return;
10481         }
10482 
10483         case CellUse: {
10484             LBasicBlock isString = m_out.newBlock();
10485             LBasicBlock notString = m_out.newBlock();
10486             LBasicBlock continuation = m_out.newBlock();
10487 
10488             LValue value = lowCell(m_node-&gt;child1());
10489             LValue isStringValue = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
10490             m_out.branch(
10491                 isStringValue, unsure(isString), unsure(notString));
10492 
10493             LBasicBlock lastNext = m_out.appendTo(isString, notString);
10494             ValueFromBlock stringResult = m_out.anchor(mapHashString(value, m_node-&gt;child1()));
10495             m_out.jump(continuation);
10496 
10497             m_out.appendTo(notString, continuation);
10498             ValueFromBlock notStringResult = m_out.anchor(wangsInt64Hash(value));
10499             m_out.jump(continuation);
10500 
10501             m_out.appendTo(continuation, lastNext);
10502             setInt32(m_out.phi(Int32, stringResult, notStringResult));
10503             return;
10504         }
10505 
10506         case StringUse: {
10507             LValue string = lowString(m_node-&gt;child1());
10508             setInt32(mapHashString(string, m_node-&gt;child1()));
10509             return;
10510         }
10511 
10512         default:
10513             RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
10514             break;
10515         }
10516 
10517         LValue value = lowJSValue(m_node-&gt;child1());
10518 
10519         LBasicBlock isCellCase = m_out.newBlock();
10520         LBasicBlock slowCase = m_out.newBlock();
10521         LBasicBlock straightHash = m_out.newBlock();
10522         LBasicBlock isStringCase = m_out.newBlock();
10523         LBasicBlock nonEmptyStringCase = m_out.newBlock();
10524         LBasicBlock continuation = m_out.newBlock();
10525 
10526         m_out.branch(
10527             isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(straightHash));
10528 
10529         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
10530         LValue isString = m_out.equal(m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoType), m_out.constInt32(StringType));
10531         m_out.branch(
10532             isString, unsure(isStringCase), unsure(straightHash));
10533 
10534         m_out.appendTo(isStringCase, nonEmptyStringCase);
10535         m_out.branch(isRopeString(value, m_node-&gt;child1()), rarely(slowCase), usually(nonEmptyStringCase));
10536 
10537         m_out.appendTo(nonEmptyStringCase, straightHash);
10538         LValue stringImpl = m_out.loadPtr(value, m_heaps.JSString_value);
10539         LValue hash = m_out.lShr(m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
10540         ValueFromBlock nonEmptyStringHashResult = m_out.anchor(hash);
10541         m_out.branch(m_out.equal(hash, m_out.constInt32(0)),
10542             unsure(slowCase), unsure(continuation));
10543 
10544         m_out.appendTo(straightHash, slowCase);
10545         ValueFromBlock fastResult = m_out.anchor(wangsInt64Hash(value));
10546         m_out.jump(continuation);
10547 
10548         m_out.appendTo(slowCase, continuation);
10549         ValueFromBlock slowResult = m_out.anchor(
<a name="418" id="anc418"></a><span class="line-modified">10550             vmCall(Int32, operationMapHash, weakPointer(globalObject), value));</span>
10551         m_out.jump(continuation);
10552 
10553         m_out.appendTo(continuation, lastNext);
10554         setInt32(m_out.phi(Int32, fastResult, slowResult, nonEmptyStringHashResult));
10555     }
10556 
10557     void compileNormalizeMapKey()
10558     {
10559         ASSERT(m_node-&gt;child1().useKind() == UntypedUse);
10560 
10561         LBasicBlock isNumberCase = m_out.newBlock();
10562         LBasicBlock notInt32NumberCase = m_out.newBlock();
10563         LBasicBlock notNaNCase = m_out.newBlock();
10564         LBasicBlock convertibleCase = m_out.newBlock();
10565         LBasicBlock continuation = m_out.newBlock();
10566 
10567         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isNumberCase);
10568 
10569         LValue key = lowJSValue(m_node-&gt;child1());
10570         ValueFromBlock fastResult = m_out.anchor(key);
10571         m_out.branch(isNotNumber(key), unsure(continuation), unsure(isNumberCase));
10572 
10573         m_out.appendTo(isNumberCase, notInt32NumberCase);
10574         m_out.branch(isInt32(key), unsure(continuation), unsure(notInt32NumberCase));
10575 
10576         m_out.appendTo(notInt32NumberCase, notNaNCase);
10577         LValue doubleValue = unboxDouble(key);
10578         ValueFromBlock normalizedNaNResult = m_out.anchor(m_out.constInt64(JSValue::encode(jsNaN())));
10579         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, doubleValue), unsure(continuation), unsure(notNaNCase));
10580 
10581         m_out.appendTo(notNaNCase, convertibleCase);
10582         LValue integerValue = m_out.doubleToInt(doubleValue);
10583         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
10584         ValueFromBlock doubleResult = m_out.anchor(key);
10585         m_out.branch(m_out.doubleNotEqualOrUnordered(doubleValue, integerValueConvertedToDouble), unsure(continuation), unsure(convertibleCase));
10586 
10587         m_out.appendTo(convertibleCase, continuation);
10588         ValueFromBlock boxedIntResult = m_out.anchor(boxInt32(integerValue));
10589         m_out.jump(continuation);
10590 
10591         m_out.appendTo(continuation, lastNext);
10592         setJSValue(m_out.phi(Int64, fastResult, normalizedNaNResult, doubleResult, boxedIntResult));
10593     }
10594 
10595     void compileGetMapBucket()
10596     {
<a name="419" id="anc419"></a><span class="line-added">10597         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10598         LBasicBlock loopStart = m_out.newBlock();
10599         LBasicBlock loopAround = m_out.newBlock();
10600         LBasicBlock slowPath = m_out.newBlock();
10601         LBasicBlock notPresentInTable = m_out.newBlock();
10602         LBasicBlock notEmptyValue = m_out.newBlock();
10603         LBasicBlock notDeletedValue = m_out.newBlock();
10604         LBasicBlock continuation = m_out.newBlock();
10605 
10606         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
10607 
10608         LValue map;
10609         if (m_node-&gt;child1().useKind() == MapObjectUse)
10610             map = lowMapObject(m_node-&gt;child1());
10611         else if (m_node-&gt;child1().useKind() == SetObjectUse)
10612             map = lowSetObject(m_node-&gt;child1());
10613         else
10614             RELEASE_ASSERT_NOT_REACHED();
10615 
10616         LValue key = lowJSValue(m_node-&gt;child2(), ManualOperandSpeculation);
10617         if (m_node-&gt;child2().useKind() != UntypedUse)
10618             speculate(m_node-&gt;child2());
10619 
10620         LValue hash = lowInt32(m_node-&gt;child3());
10621 
10622         LValue buffer = m_out.loadPtr(map, m_heaps.HashMapImpl_buffer);
10623         LValue mask = m_out.sub(m_out.load32(map, m_heaps.HashMapImpl_capacity), m_out.int32One);
10624 
10625         ValueFromBlock indexStart = m_out.anchor(hash);
10626         m_out.jump(loopStart);
10627 
10628         m_out.appendTo(loopStart, notEmptyValue);
10629         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
10630         LValue index = m_out.bitAnd(mask, unmaskedIndex);
10631         // FIXME: I think these buffers are caged?
10632         // https://bugs.webkit.org/show_bug.cgi?id=174925
10633         LValue hashMapBucket = m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), buffer, m_out.zeroExt(index, Int64), ScaleEight));
10634         ValueFromBlock bucketResult = m_out.anchor(hashMapBucket);
10635         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue()))),
10636             unsure(notPresentInTable), unsure(notEmptyValue));
10637 
10638         m_out.appendTo(notEmptyValue, notDeletedValue);
10639         m_out.branch(m_out.equal(hashMapBucket, m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))),
10640             unsure(loopAround), unsure(notDeletedValue));
10641 
10642         m_out.appendTo(notDeletedValue, loopAround);
10643         LValue bucketKey = m_out.load64(hashMapBucket, m_heaps.HashMapBucket_key);
10644 
10645         // Perform Object.is()
10646         switch (m_node-&gt;child2().useKind()) {
10647         case BooleanUse:
10648         case Int32Use:
10649         case SymbolUse:
10650         case ObjectUse: {
10651             m_out.branch(m_out.equal(key, bucketKey),
10652                 unsure(continuation), unsure(loopAround));
10653             break;
10654         }
10655         case StringUse: {
10656             LBasicBlock notBitEqual = m_out.newBlock();
10657             LBasicBlock bucketKeyIsCell = m_out.newBlock();
10658 
10659             m_out.branch(m_out.equal(key, bucketKey),
10660                 unsure(continuation), unsure(notBitEqual));
10661 
10662             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10663             m_out.branch(isCell(bucketKey),
10664                 unsure(bucketKeyIsCell), unsure(loopAround));
10665 
10666             m_out.appendTo(bucketKeyIsCell, loopAround);
10667             m_out.branch(isString(bucketKey),
10668                 unsure(slowPath), unsure(loopAround));
10669             break;
10670         }
10671         case CellUse: {
10672             LBasicBlock notBitEqual = m_out.newBlock();
10673             LBasicBlock bucketKeyIsCell = m_out.newBlock();
10674             LBasicBlock bucketKeyIsString = m_out.newBlock();
10675 
10676             m_out.branch(m_out.equal(key, bucketKey),
10677                 unsure(continuation), unsure(notBitEqual));
10678 
10679             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10680             m_out.branch(isCell(bucketKey),
10681                 unsure(bucketKeyIsCell), unsure(loopAround));
10682 
10683             m_out.appendTo(bucketKeyIsCell, bucketKeyIsString);
10684             m_out.branch(isString(bucketKey),
10685                 unsure(bucketKeyIsString), unsure(loopAround));
10686 
10687             m_out.appendTo(bucketKeyIsString, loopAround);
10688             m_out.branch(isString(key),
10689                 unsure(slowPath), unsure(loopAround));
10690             break;
10691         }
10692         case UntypedUse: {
10693             LBasicBlock notBitEqual = m_out.newBlock();
10694             LBasicBlock bucketKeyIsCell = m_out.newBlock();
10695             LBasicBlock bothAreCells = m_out.newBlock();
10696             LBasicBlock bucketKeyIsString = m_out.newBlock();
10697 
10698             m_out.branch(m_out.equal(key, bucketKey),
10699                 unsure(continuation), unsure(notBitEqual));
10700 
10701             m_out.appendTo(notBitEqual, bucketKeyIsCell);
10702             m_out.branch(isCell(bucketKey),
10703                 unsure(bucketKeyIsCell), unsure(loopAround));
10704 
10705             m_out.appendTo(bucketKeyIsCell, bothAreCells);
10706             m_out.branch(isCell(key),
10707                 unsure(bothAreCells), unsure(loopAround));
10708 
10709             m_out.appendTo(bothAreCells, bucketKeyIsString);
10710             m_out.branch(isString(bucketKey),
10711                 unsure(bucketKeyIsString), unsure(loopAround));
10712 
10713             m_out.appendTo(bucketKeyIsString, loopAround);
10714             m_out.branch(isString(key),
10715                 unsure(slowPath), unsure(loopAround));
10716             break;
10717         }
10718         default:
10719             RELEASE_ASSERT_NOT_REACHED();
10720         }
10721 
10722         m_out.appendTo(loopAround, slowPath);
10723         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
10724         m_out.jump(loopStart);
10725 
10726         m_out.appendTo(slowPath, notPresentInTable);
10727         ValueFromBlock slowPathResult = m_out.anchor(vmCall(pointerType(),
<a name="420" id="anc420"></a><span class="line-modified">10728             m_node-&gt;child1().useKind() == MapObjectUse ? operationJSMapFindBucket : operationJSSetFindBucket, weakPointer(globalObject), map, key, hash));</span>
10729         m_out.jump(continuation);
10730 
10731         m_out.appendTo(notPresentInTable, continuation);
10732         ValueFromBlock notPresentResult;
10733         if (m_node-&gt;child1().useKind() == MapObjectUse)
10734             notPresentResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
10735         else if (m_node-&gt;child1().useKind() == SetObjectUse)
10736             notPresentResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
10737         else
10738             RELEASE_ASSERT_NOT_REACHED();
10739         m_out.jump(continuation);
10740 
10741         m_out.appendTo(continuation, lastNext);
10742         setJSValue(m_out.phi(pointerType(), bucketResult, slowPathResult, notPresentResult));
10743     }
10744 
10745     void compileGetMapBucketHead()
10746     {
10747         LValue map;
10748         if (m_node-&gt;child1().useKind() == MapObjectUse)
10749             map = lowMapObject(m_node-&gt;child1());
10750         else if (m_node-&gt;child1().useKind() == SetObjectUse)
10751             map = lowSetObject(m_node-&gt;child1());
10752         else
10753             RELEASE_ASSERT_NOT_REACHED();
10754 
10755         ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
10756         setJSValue(m_out.loadPtr(map, m_heaps.HashMapImpl_head));
10757     }
10758 
10759     void compileGetMapBucketNext()
10760     {
10761         LBasicBlock loopStart = m_out.newBlock();
10762         LBasicBlock continuation = m_out.newBlock();
10763         LBasicBlock noBucket = m_out.newBlock();
10764         LBasicBlock hasBucket = m_out.newBlock();
10765         LBasicBlock nextBucket = m_out.newBlock();
10766 
10767         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
10768 
10769         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
10770         ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
10771         LValue mapBucketPrev = lowCell(m_node-&gt;child1());
10772         ValueFromBlock mapBucketStart = m_out.anchor(m_out.loadPtr(mapBucketPrev, m_heaps.HashMapBucket_next));
10773         m_out.jump(loopStart);
10774 
10775         m_out.appendTo(loopStart, noBucket);
10776         LValue mapBucket = m_out.phi(pointerType(), mapBucketStart);
10777         m_out.branch(m_out.isNull(mapBucket), unsure(noBucket), unsure(hasBucket));
10778 
10779         m_out.appendTo(noBucket, hasBucket);
10780         ValueFromBlock noBucketResult;
10781         if (m_node-&gt;bucketOwnerType() == BucketOwnerType::Map)
10782             noBucketResult = m_out.anchor(weakPointer(vm().sentinelMapBucket()));
10783         else {
10784             ASSERT(m_node-&gt;bucketOwnerType() == BucketOwnerType::Set);
10785             noBucketResult = m_out.anchor(weakPointer(vm().sentinelSetBucket()));
10786         }
10787         m_out.jump(continuation);
10788 
10789         m_out.appendTo(hasBucket, nextBucket);
10790         ValueFromBlock bucketResult = m_out.anchor(mapBucket);
10791         m_out.branch(m_out.isZero64(m_out.load64(mapBucket, m_heaps.HashMapBucket_key)), unsure(nextBucket), unsure(continuation));
10792 
10793         m_out.appendTo(nextBucket, continuation);
10794         m_out.addIncomingToPhi(mapBucket, m_out.anchor(m_out.loadPtr(mapBucket, m_heaps.HashMapBucket_next)));
10795         m_out.jump(loopStart);
10796 
10797         m_out.appendTo(continuation, lastNext);
10798         setJSValue(m_out.phi(pointerType(), noBucketResult, bucketResult));
10799     }
10800 
10801     void compileLoadValueFromMapBucket()
10802     {
10803         LValue mapBucket = lowCell(m_node-&gt;child1());
10804         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_value));
10805     }
10806 
10807     void compileExtractValueFromWeakMapGet()
10808     {
10809         LValue value = lowJSValue(m_node-&gt;child1());
10810         setJSValue(m_out.select(m_out.isZero64(value),
10811             m_out.constInt64(JSValue::encode(jsUndefined())),
10812             value));
10813     }
10814 
10815     void compileLoadKeyFromMapBucket()
10816     {
10817         LValue mapBucket = lowCell(m_node-&gt;child1());
10818         setJSValue(m_out.load64(mapBucket, m_heaps.HashMapBucket_key));
10819     }
10820 
10821     void compileSetAdd()
10822     {
<a name="421" id="anc421"></a><span class="line-added">10823         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10824         LValue set = lowSetObject(m_node-&gt;child1());
10825         LValue key = lowJSValue(m_node-&gt;child2());
10826         LValue hash = lowInt32(m_node-&gt;child3());
10827 
<a name="422" id="anc422"></a><span class="line-modified">10828         setJSValue(vmCall(pointerType(), operationSetAdd, weakPointer(globalObject), set, key, hash));</span>
10829     }
10830 
10831     void compileMapSet()
10832     {
<a name="423" id="anc423"></a><span class="line-added">10833         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
10834         LValue map = lowMapObject(m_graph.varArgChild(m_node, 0));
10835         LValue key = lowJSValue(m_graph.varArgChild(m_node, 1));
10836         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
10837         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
10838 
<a name="424" id="anc424"></a><span class="line-modified">10839         setJSValue(vmCall(pointerType(), operationMapSet, weakPointer(globalObject), map, key, value, hash));</span>
10840     }
10841 
10842     void compileWeakMapGet()
10843     {
10844         LBasicBlock loopStart = m_out.newBlock();
10845         LBasicBlock loopAround = m_out.newBlock();
10846         LBasicBlock notEqualValue = m_out.newBlock();
10847         LBasicBlock continuation = m_out.newBlock();
10848 
10849         LBasicBlock lastNext = m_out.insertNewBlocksBefore(loopStart);
10850 
10851         LValue weakMap;
10852         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
10853             weakMap = lowWeakMapObject(m_node-&gt;child1());
10854         else if (m_node-&gt;child1().useKind() == WeakSetObjectUse)
10855             weakMap = lowWeakSetObject(m_node-&gt;child1());
10856         else
10857             RELEASE_ASSERT_NOT_REACHED();
10858         LValue key = lowObject(m_node-&gt;child2());
10859         LValue hash = lowInt32(m_node-&gt;child3());
10860 
10861         LValue buffer = m_out.loadPtr(weakMap, m_heaps.WeakMapImpl_buffer);
10862         LValue mask = m_out.sub(m_out.load32(weakMap, m_heaps.WeakMapImpl_capacity), m_out.int32One);
10863 
10864         ValueFromBlock indexStart = m_out.anchor(hash);
10865         m_out.jump(loopStart);
10866 
10867         m_out.appendTo(loopStart, notEqualValue);
10868         LValue unmaskedIndex = m_out.phi(Int32, indexStart);
10869         LValue index = m_out.bitAnd(mask, unmaskedIndex);
10870 
10871         LValue bucket;
10872 
10873         if (m_node-&gt;child1().useKind() == WeakMapObjectUse) {
10874             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)), &quot;Should be a power of 2&quot;);
10875             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;)))));
10876         } else {
10877             static_assert(hasOneBitSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)), &quot;Should be a power of 2&quot;);
10878             bucket = m_out.add(buffer, m_out.shl(m_out.zeroExt(index, Int64), m_out.constInt32(getLSBSet(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;)))));
10879         }
10880 
10881         LValue bucketKey = m_out.load64(bucket, m_heaps.WeakMapBucket_key);
10882         m_out.branch(m_out.equal(key, bucketKey), unsure(continuation), unsure(notEqualValue));
10883 
10884         m_out.appendTo(notEqualValue, loopAround);
10885         m_out.branch(m_out.isNull(bucketKey), unsure(continuation), unsure(loopAround));
10886 
10887         m_out.appendTo(loopAround, continuation);
10888         m_out.addIncomingToPhi(unmaskedIndex, m_out.anchor(m_out.add(index, m_out.int32One)));
10889         m_out.jump(loopStart);
10890 
10891         m_out.appendTo(continuation, lastNext);
10892         LValue result;
10893         if (m_node-&gt;child1().useKind() == WeakMapObjectUse)
10894             result = m_out.load64(bucket, m_heaps.WeakMapBucket_value);
10895         else
10896             result = bucketKey;
10897         setJSValue(result);
10898     }
10899 
10900     void compileWeakSetAdd()
10901     {
10902         LValue set = lowWeakSetObject(m_node-&gt;child1());
10903         LValue key = lowObject(m_node-&gt;child2());
10904         LValue hash = lowInt32(m_node-&gt;child3());
10905 
<a name="425" id="anc425"></a><span class="line-modified">10906         vmCall(Void, operationWeakSetAdd, m_vmValue, set, key, hash);</span>
10907     }
10908 
10909     void compileWeakMapSet()
10910     {
10911         LValue map = lowWeakMapObject(m_graph.varArgChild(m_node, 0));
10912         LValue key = lowObject(m_graph.varArgChild(m_node, 1));
10913         LValue value = lowJSValue(m_graph.varArgChild(m_node, 2));
10914         LValue hash = lowInt32(m_graph.varArgChild(m_node, 3));
10915 
<a name="426" id="anc426"></a><span class="line-modified">10916         vmCall(Void, operationWeakMapSet, m_vmValue, map, key, value, hash);</span>
10917     }
10918 
10919     void compileIsObjectOrNull()
10920     {
10921         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10922 
10923         Edge child = m_node-&gt;child1();
10924         LValue value = lowJSValue(child);
10925 
10926         LBasicBlock cellCase = m_out.newBlock();
10927         LBasicBlock notFunctionCase = m_out.newBlock();
10928         LBasicBlock objectCase = m_out.newBlock();
10929         LBasicBlock slowPath = m_out.newBlock();
10930         LBasicBlock notCellCase = m_out.newBlock();
10931         LBasicBlock continuation = m_out.newBlock();
10932 
10933         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
10934 
10935         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10936         ValueFromBlock isFunctionResult = m_out.anchor(m_out.booleanFalse);
10937         m_out.branch(
10938             isFunction(value, provenType(child)),
10939             unsure(continuation), unsure(notFunctionCase));
10940 
10941         m_out.appendTo(notFunctionCase, objectCase);
10942         ValueFromBlock notObjectResult = m_out.anchor(m_out.booleanFalse);
10943         m_out.branch(
10944             isObject(value, provenType(child)),
10945             unsure(objectCase), unsure(continuation));
10946 
10947         m_out.appendTo(objectCase, slowPath);
10948         ValueFromBlock objectResult = m_out.anchor(m_out.booleanTrue);
10949         m_out.branch(
10950             isExoticForTypeof(value, provenType(child)),
10951             rarely(slowPath), usually(continuation));
10952 
10953         m_out.appendTo(slowPath, notCellCase);
10954         VM&amp; vm = this-&gt;vm();
10955         LValue slowResultValue = lazySlowPath(
10956             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
10957                 return createLazyCallGenerator(vm,
10958                     operationObjectIsObject, locations[0].directGPR(),
10959                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
10960             }, value);
10961         ValueFromBlock slowResult = m_out.anchor(m_out.notZero64(slowResultValue));
10962         m_out.jump(continuation);
10963 
10964         m_out.appendTo(notCellCase, continuation);
10965         LValue notCellResultValue = m_out.equal(value, m_out.constInt64(JSValue::encode(jsNull())));
10966         ValueFromBlock notCellResult = m_out.anchor(notCellResultValue);
10967         m_out.jump(continuation);
10968 
10969         m_out.appendTo(continuation, lastNext);
10970         LValue result = m_out.phi(
10971             Int32,
10972             isFunctionResult, notObjectResult, objectResult, slowResult, notCellResult);
10973         setBoolean(result);
10974     }
10975 
10976     void compileIsFunction()
10977     {
10978         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
10979 
10980         Edge child = m_node-&gt;child1();
10981         LValue value = lowJSValue(child);
10982 
10983         LBasicBlock cellCase = m_out.newBlock();
10984         LBasicBlock notFunctionCase = m_out.newBlock();
10985         LBasicBlock slowPath = m_out.newBlock();
10986         LBasicBlock continuation = m_out.newBlock();
10987 
10988         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
10989         m_out.branch(
10990             isCell(value, provenType(child)), unsure(cellCase), unsure(continuation));
10991 
10992         LBasicBlock lastNext = m_out.appendTo(cellCase, notFunctionCase);
10993         ValueFromBlock functionResult = m_out.anchor(m_out.booleanTrue);
10994         m_out.branch(
10995             isFunction(value, provenType(child)),
10996             unsure(continuation), unsure(notFunctionCase));
10997 
10998         m_out.appendTo(notFunctionCase, slowPath);
10999         ValueFromBlock objectResult = m_out.anchor(m_out.booleanFalse);
11000         m_out.branch(
11001             isExoticForTypeof(value, provenType(child)),
11002             rarely(slowPath), usually(continuation));
11003 
11004         m_out.appendTo(slowPath, continuation);
11005         VM&amp; vm = this-&gt;vm();
11006         LValue slowResultValue = lazySlowPath(
11007             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11008                 return createLazyCallGenerator(vm,
11009                     operationObjectIsFunction, locations[0].directGPR(),
11010                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
11011             }, value);
11012         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(slowResultValue));
11013         m_out.jump(continuation);
11014 
11015         m_out.appendTo(continuation, lastNext);
11016         LValue result = m_out.phi(
11017             Int32, notCellResult, functionResult, objectResult, slowResult);
11018         setBoolean(result);
11019     }
11020 
11021     void compileIsTypedArrayView()
11022     {
11023         LValue value = lowJSValue(m_node-&gt;child1());
11024 
11025         LBasicBlock isCellCase = m_out.newBlock();
11026         LBasicBlock continuation = m_out.newBlock();
11027 
11028         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
11029         m_out.branch(isCell(value, provenType(m_node-&gt;child1())), unsure(isCellCase), unsure(continuation));
11030 
11031         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
11032         ValueFromBlock cellResult = m_out.anchor(isTypedArrayView(value, provenType(m_node-&gt;child1())));
11033         m_out.jump(continuation);
11034 
11035         m_out.appendTo(continuation, lastNext);
11036         setBoolean(m_out.phi(Int32, notCellResult, cellResult));
11037     }
11038 
11039     void compileTypeOf()
11040     {
11041         Edge child = m_node-&gt;child1();
11042         LValue value = lowJSValue(child);
11043 
11044         LBasicBlock continuation = m_out.newBlock();
11045         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
11046 
11047         Vector&lt;ValueFromBlock&gt; results;
11048 
11049         buildTypeOf(
11050             child, value,
11051             [&amp;] (TypeofType type) {
11052                 results.append(m_out.anchor(weakPointer(vm().smallStrings.typeString(type))));
11053                 m_out.jump(continuation);
11054             });
11055 
11056         m_out.appendTo(continuation, lastNext);
11057         setJSValue(m_out.phi(Int64, results));
11058     }
11059 
11060     void compileInByVal()
11061     {
<a name="427" id="anc427"></a><span class="line-modified">11062         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">11063         setJSValue(vmCall(Int64, operationInByVal, weakPointer(globalObject), lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2())));</span>
11064     }
11065 
11066     void compileInById()
11067     {
11068         Node* node = m_node;
11069         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
11070         LValue base = lowCell(m_node-&gt;child1());
11071 
11072         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
11073         patchpoint-&gt;appendSomeRegister(base);
<a name="428" id="anc428"></a><span class="line-modified">11074         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">11075         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
11076 
11077         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
11078 
11079         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
11080             preparePatchpointForExceptions(patchpoint);
11081 
11082         State* state = &amp;m_ftlState;
11083         patchpoint-&gt;setGenerator(
11084             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
11085                 AllowMacroScratchRegisterUsage allowScratch(jit);
11086 
11087                 CallSiteIndex callSiteIndex =
11088                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
11089 
11090                 // This is the direct exit target for operation calls.
11091                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
11092                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
11093 
11094                 auto generator = Box&lt;JITInByIdGenerator&gt;::create(
11095                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
11096                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
11097                     JSValueRegs(params[0].gpr()));
11098 
11099                 generator-&gt;generateFastPath(jit);
11100                 CCallHelpers::Label done = jit.label();
11101 
11102                 params.addLatePath(
11103                     [=] (CCallHelpers&amp; jit) {
11104                         AllowMacroScratchRegisterUsage allowScratch(jit);
11105 
11106                         generator-&gt;slowPathJump().link(&amp;jit);
11107                         CCallHelpers::Label slowPathBegin = jit.label();
11108                         CCallHelpers::Call slowPathCall = callOperation(
11109                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
11110                             exceptions.get(), operationInByIdOptimize, params[0].gpr(),
<a name="429" id="anc429"></a><span class="line-added">11111                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
11112                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
11113                             CCallHelpers::TrustedImmPtr(uid)).call();
11114                         jit.jump().linkTo(done, &amp;jit);
11115 
11116                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
11117 
11118                         jit.addLinkTask(
11119                             [=] (LinkBuffer&amp; linkBuffer) {
11120                                 generator-&gt;finalize(linkBuffer, linkBuffer);
11121                             });
11122                     });
11123             });
11124 
11125         setJSValue(patchpoint);
11126     }
11127 
11128     void compileHasOwnProperty()
11129     {
<a name="430" id="anc430"></a><span class="line-added">11130         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11131         LBasicBlock slowCase = m_out.newBlock();
11132         LBasicBlock continuation = m_out.newBlock();
11133         LBasicBlock lastNext = nullptr;
11134 
11135         LValue object = lowObject(m_node-&gt;child1());
11136         LValue uniquedStringImpl;
11137         LValue keyAsValue = nullptr;
11138         switch (m_node-&gt;child2().useKind()) {
11139         case StringUse: {
11140             LBasicBlock isNonEmptyString = m_out.newBlock();
11141             LBasicBlock isAtomString = m_out.newBlock();
11142 
11143             keyAsValue = lowString(m_node-&gt;child2());
11144             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
11145 
11146             lastNext = m_out.appendTo(isNonEmptyString, isAtomString);
11147             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
11148             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));
11149             m_out.branch(isNotAtomic, rarely(slowCase), usually(isAtomString));
11150 
11151             m_out.appendTo(isAtomString, slowCase);
11152             break;
11153         }
11154         case SymbolUse: {
11155             keyAsValue = lowSymbol(m_node-&gt;child2());
11156             uniquedStringImpl = m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl);
11157             lastNext = m_out.insertNewBlocksBefore(slowCase);
11158             break;
11159         }
11160         case UntypedUse: {
11161             LBasicBlock isCellCase = m_out.newBlock();
11162             LBasicBlock isStringCase = m_out.newBlock();
11163             LBasicBlock notStringCase = m_out.newBlock();
11164             LBasicBlock isNonEmptyString = m_out.newBlock();
11165             LBasicBlock isSymbolCase = m_out.newBlock();
11166             LBasicBlock hasUniquedStringImpl = m_out.newBlock();
11167 
11168             keyAsValue = lowJSValue(m_node-&gt;child2());
11169             m_out.branch(isCell(keyAsValue), usually(isCellCase), rarely(slowCase));
11170 
11171             lastNext = m_out.appendTo(isCellCase, isStringCase);
11172             m_out.branch(isString(keyAsValue), unsure(isStringCase), unsure(notStringCase));
11173 
11174             m_out.appendTo(isStringCase, isNonEmptyString);
11175             m_out.branch(isNotRopeString(keyAsValue, m_node-&gt;child2()), usually(isNonEmptyString), rarely(slowCase));
11176 
11177             m_out.appendTo(isNonEmptyString, notStringCase);
11178             LValue implFromString = m_out.loadPtr(keyAsValue, m_heaps.JSString_value);
11179             ValueFromBlock stringResult = m_out.anchor(implFromString);
11180             LValue isNotAtomic = m_out.testIsZero32(m_out.load32(implFromString, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::flagIsAtom()));
11181             m_out.branch(isNotAtomic, rarely(slowCase), usually(hasUniquedStringImpl));
11182 
11183             m_out.appendTo(notStringCase, isSymbolCase);
11184             m_out.branch(isSymbol(keyAsValue), unsure(isSymbolCase), unsure(slowCase));
11185 
11186             m_out.appendTo(isSymbolCase, hasUniquedStringImpl);
11187             ValueFromBlock symbolResult = m_out.anchor(m_out.loadPtr(keyAsValue, m_heaps.Symbol_symbolImpl));
11188             m_out.jump(hasUniquedStringImpl);
11189 
11190             m_out.appendTo(hasUniquedStringImpl, slowCase);
11191             uniquedStringImpl = m_out.phi(pointerType(), stringResult, symbolResult);
11192             break;
11193         }
11194         default:
11195             RELEASE_ASSERT_NOT_REACHED();
11196         }
11197 
11198         ASSERT(keyAsValue);
11199 
11200         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero
11201         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
11202         // ever load the result from the cache if the cache entry matches what we are querying for.
11203         // So we either get super lucky and use zero for the hash and somehow collide with the entity
11204         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
11205         // slow path anyways.
11206         LValue hash = m_out.lShr(m_out.load32(uniquedStringImpl, m_heaps.StringImpl_hashAndFlags), m_out.constInt32(StringImpl::s_flagCount));
11207 
11208         LValue structureID = m_out.load32(object, m_heaps.JSCell_structureID);
11209         LValue index = m_out.add(hash, structureID);
11210         index = m_out.zeroExtPtr(m_out.bitAnd(index, m_out.constInt32(HasOwnPropertyCache::mask)));
11211         ASSERT(vm().hasOwnPropertyCache());
11212         LValue cache = m_out.constIntPtr(vm().hasOwnPropertyCache());
11213 
11214         IndexedAbstractHeap&amp; heap = m_heaps.HasOwnPropertyCache;
11215         LValue sameStructureID = m_out.equal(structureID, m_out.load32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfStructureID())));
11216         LValue sameImpl = m_out.equal(uniquedStringImpl, m_out.loadPtr(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfImpl())));
11217         ValueFromBlock fastResult = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(heap, cache, index, JSValue(), HasOwnPropertyCache::Entry::offsetOfResult())));
11218         LValue cacheHit = m_out.bitAnd(sameStructureID, sameImpl);
11219 
11220         m_out.branch(m_out.notZero32(cacheHit), usually(continuation), rarely(slowCase));
11221 
11222         m_out.appendTo(slowCase, continuation);
11223         ValueFromBlock slowResult;
<a name="431" id="anc431"></a><span class="line-modified">11224         slowResult = m_out.anchor(vmCall(Int32, operationHasOwnProperty, weakPointer(globalObject), object, keyAsValue));</span>
11225         m_out.jump(continuation);
11226 
11227         m_out.appendTo(continuation, lastNext);
11228         setBoolean(m_out.phi(Int32, fastResult, slowResult));
11229     }
11230 
11231     void compileParseInt()
11232     {
11233         RELEASE_ASSERT(m_node-&gt;child1().useKind() == UntypedUse || m_node-&gt;child1().useKind() == StringUse);
<a name="432" id="anc432"></a><span class="line-added">11234         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11235         LValue result;
11236         if (m_node-&gt;child2()) {
11237             LValue radix = lowInt32(m_node-&gt;child2());
11238             if (m_node-&gt;child1().useKind() == UntypedUse)
<a name="433" id="anc433"></a><span class="line-modified">11239                 result = vmCall(Int64, operationParseIntGeneric, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()), radix);</span>
11240             else
<a name="434" id="anc434"></a><span class="line-modified">11241                 result = vmCall(Int64, operationParseIntString, weakPointer(globalObject), lowString(m_node-&gt;child1()), radix);</span>
11242         } else {
11243             if (m_node-&gt;child1().useKind() == UntypedUse)
<a name="435" id="anc435"></a><span class="line-modified">11244                 result = vmCall(Int64, operationParseIntNoRadixGeneric, weakPointer(globalObject), lowJSValue(m_node-&gt;child1()));</span>
11245             else
<a name="436" id="anc436"></a><span class="line-modified">11246                 result = vmCall(Int64, operationParseIntStringNoRadix, weakPointer(globalObject), lowString(m_node-&gt;child1()));</span>
11247         }
11248         setJSValue(result);
11249     }
11250 
11251     void compileOverridesHasInstance()
11252     {
11253         FrozenValue* defaultHasInstanceFunction = m_node-&gt;cellOperand();
11254         ASSERT(defaultHasInstanceFunction-&gt;cell()-&gt;inherits&lt;JSFunction&gt;(vm()));
11255 
11256         LValue constructor = lowCell(m_node-&gt;child1());
11257         LValue hasInstance = lowJSValue(m_node-&gt;child2());
11258 
11259         LBasicBlock defaultHasInstance = m_out.newBlock();
11260         LBasicBlock continuation = m_out.newBlock();
11261 
11262         // Unlike in the DFG, we don&#39;t worry about cleaning this code up for the case where we have proven the hasInstanceValue is a constant as B3 should fix it for us.
11263 
11264         ValueFromBlock notDefaultHasInstanceResult = m_out.anchor(m_out.booleanTrue);
11265         m_out.branch(m_out.notEqual(hasInstance, frozenPointer(defaultHasInstanceFunction)), unsure(continuation), unsure(defaultHasInstance));
11266 
11267         LBasicBlock lastNext = m_out.appendTo(defaultHasInstance, continuation);
11268         ValueFromBlock implementsDefaultHasInstanceResult = m_out.anchor(m_out.testIsZero32(
11269             m_out.load8ZeroExt32(constructor, m_heaps.JSCell_typeInfoFlags),
11270             m_out.constInt32(ImplementsDefaultHasInstance)));
11271         m_out.jump(continuation);
11272 
11273         m_out.appendTo(continuation, lastNext);
11274         setBoolean(m_out.phi(Int32, implementsDefaultHasInstanceResult, notDefaultHasInstanceResult));
11275     }
11276 
11277     void compileCheckTypeInfoFlags()
11278     {
11279         speculate(
11280             BadTypeInfoFlags, noValue(), 0,
11281             m_out.testIsZero32(
11282                 m_out.load8ZeroExt32(lowCell(m_node-&gt;child1()), m_heaps.JSCell_typeInfoFlags),
11283                 m_out.constInt32(m_node-&gt;typeInfoOperand())));
11284     }
11285 
11286     void compileInstanceOf()
11287     {
11288         Node* node = m_node;
11289         State* state = &amp;m_ftlState;
11290 
11291         LValue value;
11292         LValue prototype;
11293         bool valueIsCell;
11294         bool prototypeIsCell;
11295         if (m_node-&gt;child1().useKind() == CellUse
11296             &amp;&amp; m_node-&gt;child2().useKind() == CellUse) {
11297             value = lowCell(m_node-&gt;child1());
11298             prototype = lowCell(m_node-&gt;child2());
11299 
11300             valueIsCell = true;
11301             prototypeIsCell = true;
11302         } else {
11303             DFG_ASSERT(m_graph, m_node, m_node-&gt;child1().useKind() == UntypedUse);
11304             DFG_ASSERT(m_graph, m_node, m_node-&gt;child2().useKind() == UntypedUse);
11305 
11306             value = lowJSValue(m_node-&gt;child1());
11307             prototype = lowJSValue(m_node-&gt;child2());
11308 
11309             valueIsCell = abstractValue(m_node-&gt;child1()).isType(SpecCell);
11310             prototypeIsCell = abstractValue(m_node-&gt;child2()).isType(SpecCell);
11311         }
11312 
11313         bool prototypeIsObject = abstractValue(m_node-&gt;child2()).isType(SpecObject | ~SpecCell);
11314 
11315         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
11316         patchpoint-&gt;appendSomeRegister(value);
11317         patchpoint-&gt;appendSomeRegister(prototype);
<a name="437" id="anc437"></a><span class="line-modified">11318         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">11319         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
11320         patchpoint-&gt;numGPScratchRegisters = 2;
11321         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
11322         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
11323 
11324         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
11325             preparePatchpointForExceptions(patchpoint);
11326 
11327         patchpoint-&gt;setGenerator(
11328             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
11329                 AllowMacroScratchRegisterUsage allowScratch(jit);
11330 
11331                 GPRReg resultGPR = params[0].gpr();
11332                 GPRReg valueGPR = params[1].gpr();
11333                 GPRReg prototypeGPR = params[2].gpr();
11334                 GPRReg scratchGPR = params.gpScratch(0);
11335                 GPRReg scratch2GPR = params.gpScratch(1);
11336 
11337                 CCallHelpers::Jump doneJump;
11338                 if (!valueIsCell) {
11339                     CCallHelpers::Jump isCell = jit.branchIfCell(valueGPR);
11340                     jit.boxBooleanPayload(false, resultGPR);
11341                     doneJump = jit.jump();
11342                     isCell.link(&amp;jit);
11343                 }
11344 
11345                 CCallHelpers::JumpList slowCases;
11346                 if (!prototypeIsCell)
11347                     slowCases.append(jit.branchIfNotCell(prototypeGPR));
11348 
11349                 CallSiteIndex callSiteIndex =
11350                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
11351 
11352                 // This is the direct exit target for operation calls.
11353                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
11354                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
11355 
11356                 auto generator = Box&lt;JITInstanceOfGenerator&gt;::create(
11357                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
11358                     params.unavailableRegisters(), resultGPR, valueGPR, prototypeGPR, scratchGPR,
11359                     scratch2GPR, prototypeIsObject);
11360                 generator-&gt;generateFastPath(jit);
11361                 CCallHelpers::Label done = jit.label();
11362 
11363                 params.addLatePath(
11364                     [=] (CCallHelpers&amp; jit) {
11365                         AllowMacroScratchRegisterUsage allowScratch(jit);
11366 
<a name="438" id="anc438"></a><span class="line-modified">11367                         J_JITOperation_GSsiJJ optimizationFunction = operationInstanceOfOptimize;</span>
11368 
11369                         slowCases.link(&amp;jit);
11370                         CCallHelpers::Label slowPathBegin = jit.label();
11371                         CCallHelpers::Call slowPathCall = callOperation(
11372                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
11373                             exceptions.get(), optimizationFunction, resultGPR,
<a name="439" id="anc439"></a><span class="line-added">11374                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
11375                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), valueGPR,
11376                             prototypeGPR).call();
11377                         jit.jump().linkTo(done, &amp;jit);
11378 
11379                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
11380 
11381                         jit.addLinkTask(
11382                             [=] (LinkBuffer&amp; linkBuffer) {
11383                                 generator-&gt;finalize(linkBuffer, linkBuffer);
11384                             });
11385                     });
11386 
11387                 if (doneJump.isSet())
11388                     doneJump.link(&amp;jit);
11389             });
11390 
11391         // This returns a boxed boolean.
11392         setJSValue(patchpoint);
11393     }
11394 
11395     void compileInstanceOfCustom()
11396     {
<a name="440" id="anc440"></a><span class="line-added">11397         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11398         LValue value = lowJSValue(m_node-&gt;child1());
11399         LValue constructor = lowCell(m_node-&gt;child2());
11400         LValue hasInstance = lowJSValue(m_node-&gt;child3());
11401 
<a name="441" id="anc441"></a><span class="line-modified">11402         setBoolean(m_out.logicalNot(m_out.equal(m_out.constInt32(0), vmCall(Int32, operationInstanceOfCustom, weakPointer(globalObject), value, constructor, hasInstance))));</span>
11403     }
11404 
11405     void compileCountExecution()
11406     {
11407         TypedPointer counter = m_out.absolute(m_node-&gt;executionCounter()-&gt;address());
11408         m_out.store64(m_out.add(m_out.load64(counter), m_out.constInt64(1)), counter);
11409     }
11410 
11411     void compileSuperSamplerBegin()
11412     {
11413         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
11414         m_out.store32(m_out.add(m_out.load32(counter), m_out.constInt32(1)), counter);
11415     }
11416 
11417     void compileSuperSamplerEnd()
11418     {
11419         TypedPointer counter = m_out.absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
11420         m_out.store32(m_out.sub(m_out.load32(counter), m_out.constInt32(1)), counter);
11421     }
11422 
11423     void compileStoreBarrier()
11424     {
11425         emitStoreBarrier(lowCell(m_node-&gt;child1()), m_node-&gt;op() == FencedStoreBarrier);
11426     }
11427 
11428     void compileHasIndexedProperty()
11429     {
<a name="442" id="anc442"></a><span class="line-added">11430         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11431         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
11432         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
11433 
11434         switch (m_node-&gt;arrayMode().type()) {
11435         case Array::Int32:
11436         case Array::Contiguous: {
11437             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
11438             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
11439 
11440             IndexedAbstractHeap&amp; heap = m_node-&gt;arrayMode().type() == Array::Int32 ?
11441                 m_heaps.indexedInt32Properties : m_heaps.indexedContiguousProperties;
11442 
11443             LBasicBlock slowCase = m_out.newBlock();
11444             LBasicBlock continuation = m_out.newBlock();
11445             LBasicBlock lastNext = nullptr;
11446 
11447             if (!m_node-&gt;arrayMode().isInBounds()) {
11448                 LBasicBlock checkHole = m_out.newBlock();
11449                 m_out.branch(
11450                     m_out.aboveOrEqual(
11451                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
11452                     rarely(slowCase), usually(checkHole));
11453                 lastNext = m_out.appendTo(checkHole, slowCase);
11454             } else
11455                 lastNext = m_out.insertNewBlocksBefore(slowCase);
11456 
11457             LValue checkHoleResultValue =
11458                 m_out.notZero64(m_out.load64(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1))));
11459             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
11460             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
11461 
11462             m_out.appendTo(slowCase, continuation);
11463             ValueFromBlock slowResult = m_out.anchor(
<a name="443" id="anc443"></a><span class="line-modified">11464                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
11465             m_out.jump(continuation);
11466 
11467             m_out.appendTo(continuation, lastNext);
11468             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
11469             return;
11470         }
11471         case Array::Double: {
11472             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
11473             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
11474 
11475             IndexedAbstractHeap&amp; heap = m_heaps.indexedDoubleProperties;
11476 
11477             LBasicBlock slowCase = m_out.newBlock();
11478             LBasicBlock continuation = m_out.newBlock();
11479             LBasicBlock lastNext = nullptr;
11480 
11481             if (!m_node-&gt;arrayMode().isInBounds()) {
11482                 LBasicBlock checkHole = m_out.newBlock();
11483                 m_out.branch(
11484                     m_out.aboveOrEqual(
11485                         index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength)),
11486                     rarely(slowCase), usually(checkHole));
11487                 lastNext = m_out.appendTo(checkHole, slowCase);
11488             } else
11489                 lastNext = m_out.insertNewBlocksBefore(slowCase);
11490 
11491             LValue doubleValue = m_out.loadDouble(baseIndex(heap, storage, index, m_graph.varArgChild(m_node, 1)));
11492             LValue checkHoleResultValue = m_out.doubleEqual(doubleValue, doubleValue);
11493             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
11494             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
11495 
11496             m_out.appendTo(slowCase, continuation);
11497             ValueFromBlock slowResult = m_out.anchor(
<a name="444" id="anc444"></a><span class="line-modified">11498                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
11499             m_out.jump(continuation);
11500 
11501             m_out.appendTo(continuation, lastNext);
11502             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
11503             return;
11504         }
11505 
11506         case Array::ArrayStorage: {
11507             LValue storage = lowStorage(m_graph.varArgChild(m_node, 2));
11508             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
11509 
11510             LBasicBlock slowCase = m_out.newBlock();
11511             LBasicBlock continuation = m_out.newBlock();
11512             LBasicBlock lastNext = nullptr;
11513 
11514             if (!m_node-&gt;arrayMode().isInBounds()) {
11515                 LBasicBlock checkHole = m_out.newBlock();
11516                 m_out.branch(
11517                     m_out.aboveOrEqual(
11518                         index, m_out.load32NonNegative(storage, m_heaps.ArrayStorage_vectorLength)),
11519                     rarely(slowCase), usually(checkHole));
11520                 lastNext = m_out.appendTo(checkHole, slowCase);
11521             } else
11522                 lastNext = m_out.insertNewBlocksBefore(slowCase);
11523 
11524             LValue checkHoleResultValue =
11525                 m_out.notZero64(m_out.load64(baseIndex(m_heaps.ArrayStorage_vector, storage, index, m_graph.varArgChild(m_node, 1))));
11526             ValueFromBlock checkHoleResult = m_out.anchor(checkHoleResultValue);
11527             m_out.branch(checkHoleResultValue, usually(continuation), rarely(slowCase));
11528 
11529             m_out.appendTo(slowCase, continuation);
11530             ValueFromBlock slowResult = m_out.anchor(
<a name="445" id="anc445"></a><span class="line-modified">11531                 m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
11532             m_out.jump(continuation);
11533 
11534             m_out.appendTo(continuation, lastNext);
11535             setBoolean(m_out.phi(Int32, checkHoleResult, slowResult));
11536             break;
11537         }
11538 
11539         default: {
11540             LValue internalMethodType = m_out.constInt32(static_cast&lt;int32_t&gt;(m_node-&gt;internalMethodType()));
<a name="446" id="anc446"></a><span class="line-modified">11541             setBoolean(m_out.notZero64(vmCall(Int64, operationHasIndexedPropertyByInt, weakPointer(globalObject), base, index, internalMethodType)));</span>
11542             break;
11543         }
11544         }
11545     }
11546 
11547     void compileHasGenericProperty()
11548     {
<a name="447" id="anc447"></a><span class="line-added">11549         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11550         LValue base = lowJSValue(m_node-&gt;child1());
11551         LValue property = lowCell(m_node-&gt;child2());
<a name="448" id="anc448"></a><span class="line-modified">11552         setJSValue(vmCall(Int64, operationHasGenericProperty, weakPointer(globalObject), base, property));</span>
11553     }
11554 
11555     void compileHasStructureProperty()
11556     {
<a name="449" id="anc449"></a><span class="line-added">11557         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11558         LValue base = lowJSValue(m_node-&gt;child1());
11559         LValue property = lowString(m_node-&gt;child2());
11560         LValue enumerator = lowCell(m_node-&gt;child3());
11561 
11562         LBasicBlock correctStructure = m_out.newBlock();
11563         LBasicBlock wrongStructure = m_out.newBlock();
11564         LBasicBlock continuation = m_out.newBlock();
11565 
11566         m_out.branch(m_out.notEqual(
11567             m_out.load32(base, m_heaps.JSCell_structureID),
11568             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
11569             rarely(wrongStructure), usually(correctStructure));
11570 
11571         LBasicBlock lastNext = m_out.appendTo(correctStructure, wrongStructure);
11572         ValueFromBlock correctStructureResult = m_out.anchor(m_out.booleanTrue);
11573         m_out.jump(continuation);
11574 
11575         m_out.appendTo(wrongStructure, continuation);
11576         ValueFromBlock wrongStructureResult = m_out.anchor(
11577             m_out.equal(
11578                 m_out.constInt64(JSValue::encode(jsBoolean(true))),
<a name="450" id="anc450"></a><span class="line-modified">11579                 vmCall(Int64, operationHasGenericProperty, weakPointer(globalObject), base, property)));</span>
11580         m_out.jump(continuation);
11581 
11582         m_out.appendTo(continuation, lastNext);
11583         setBoolean(m_out.phi(Int32, correctStructureResult, wrongStructureResult));
11584     }
11585 
11586     void compileGetDirectPname()
11587     {
<a name="451" id="anc451"></a><span class="line-added">11588         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11589         LValue base = lowCell(m_graph.varArgChild(m_node, 0));
11590         LValue property = lowCell(m_graph.varArgChild(m_node, 1));
11591         LValue index = lowInt32(m_graph.varArgChild(m_node, 2));
11592         LValue enumerator = lowCell(m_graph.varArgChild(m_node, 3));
11593 
11594         LBasicBlock checkOffset = m_out.newBlock();
11595         LBasicBlock inlineLoad = m_out.newBlock();
11596         LBasicBlock outOfLineLoad = m_out.newBlock();
11597         LBasicBlock slowCase = m_out.newBlock();
11598         LBasicBlock continuation = m_out.newBlock();
11599 
11600         m_out.branch(m_out.notEqual(
11601             m_out.load32(base, m_heaps.JSCell_structureID),
11602             m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedStructureID)),
11603             rarely(slowCase), usually(checkOffset));
11604 
11605         LBasicBlock lastNext = m_out.appendTo(checkOffset, inlineLoad);
11606         m_out.branch(m_out.aboveOrEqual(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity)),
11607             unsure(outOfLineLoad), unsure(inlineLoad));
11608 
11609         m_out.appendTo(inlineLoad, outOfLineLoad);
11610         ValueFromBlock inlineResult = m_out.anchor(
11611             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(),
11612                 base, m_out.zeroExt(index, Int64), ScaleEight, JSObject::offsetOfInlineStorage())));
11613         m_out.jump(continuation);
11614 
11615         m_out.appendTo(outOfLineLoad, slowCase);
11616         LValue storage = m_out.loadPtr(base, m_heaps.JSObject_butterfly);
11617         LValue realIndex = m_out.signExt32To64(
11618             m_out.neg(m_out.sub(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_cachedInlineCapacity))));
11619         int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
11620         ValueFromBlock outOfLineResult = m_out.anchor(
11621             m_out.load64(m_out.baseIndex(m_heaps.properties.atAnyNumber(), storage, realIndex, ScaleEight, offsetOfFirstProperty)));
11622         m_out.jump(continuation);
11623 
11624         m_out.appendTo(slowCase, continuation);
11625         ValueFromBlock slowCaseResult = m_out.anchor(
<a name="452" id="anc452"></a><span class="line-modified">11626             vmCall(Int64, operationGetByVal, weakPointer(globalObject), base, property));</span>
11627         m_out.jump(continuation);
11628 
11629         m_out.appendTo(continuation, lastNext);
11630         setJSValue(m_out.phi(Int64, inlineResult, outOfLineResult, slowCaseResult));
11631     }
11632 
11633     void compileGetEnumerableLength()
11634     {
11635         LValue enumerator = lowCell(m_node-&gt;child1());
11636         setInt32(m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_indexLength));
11637     }
11638 
11639     void compileGetPropertyEnumerator()
11640     {
<a name="453" id="anc453"></a><span class="line-added">11641         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11642         if (m_node-&gt;child1().useKind() == CellUse)
<a name="454" id="anc454"></a><span class="line-modified">11643             setJSValue(vmCall(Int64, operationGetPropertyEnumeratorCell, weakPointer(globalObject), lowCell(m_node-&gt;child1())));</span>
11644         else
<a name="455" id="anc455"></a><span class="line-modified">11645             setJSValue(vmCall(Int64, operationGetPropertyEnumerator, weakPointer(globalObject), lowJSValue(m_node-&gt;child1())));</span>
11646     }
11647 
11648     void compileGetEnumeratorStructurePname()
11649     {
11650         LValue enumerator = lowCell(m_node-&gt;child1());
11651         LValue index = lowInt32(m_node-&gt;child2());
11652 
11653         LBasicBlock inBounds = m_out.newBlock();
11654         LBasicBlock outOfBounds = m_out.newBlock();
11655         LBasicBlock continuation = m_out.newBlock();
11656 
11657         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endStructurePropertyIndex)),
11658             usually(inBounds), rarely(outOfBounds));
11659 
11660         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
11661         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
11662         ValueFromBlock inBoundsResult = m_out.anchor(
11663             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
11664         m_out.jump(continuation);
11665 
11666         m_out.appendTo(outOfBounds, continuation);
<a name="456" id="anc456"></a><span class="line-modified">11667         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueNull));</span>
11668         m_out.jump(continuation);
11669 
11670         m_out.appendTo(continuation, lastNext);
11671         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
11672     }
11673 
11674     void compileGetEnumeratorGenericPname()
11675     {
11676         LValue enumerator = lowCell(m_node-&gt;child1());
11677         LValue index = lowInt32(m_node-&gt;child2());
11678 
11679         LBasicBlock inBounds = m_out.newBlock();
11680         LBasicBlock outOfBounds = m_out.newBlock();
11681         LBasicBlock continuation = m_out.newBlock();
11682 
11683         m_out.branch(m_out.below(index, m_out.load32(enumerator, m_heaps.JSPropertyNameEnumerator_endGenericPropertyIndex)),
11684             usually(inBounds), rarely(outOfBounds));
11685 
11686         LBasicBlock lastNext = m_out.appendTo(inBounds, outOfBounds);
11687         LValue storage = m_out.loadPtr(enumerator, m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVector);
11688         ValueFromBlock inBoundsResult = m_out.anchor(
11689             m_out.loadPtr(m_out.baseIndex(m_heaps.JSPropertyNameEnumerator_cachedPropertyNamesVectorContents, storage, m_out.zeroExtPtr(index))));
11690         m_out.jump(continuation);
11691 
11692         m_out.appendTo(outOfBounds, continuation);
<a name="457" id="anc457"></a><span class="line-modified">11693         ValueFromBlock outOfBoundsResult = m_out.anchor(m_out.constInt64(JSValue::ValueNull));</span>
11694         m_out.jump(continuation);
11695 
11696         m_out.appendTo(continuation, lastNext);
11697         setJSValue(m_out.phi(Int64, inBoundsResult, outOfBoundsResult));
11698     }
11699 
11700     void compileToIndexString()
11701     {
<a name="458" id="anc458"></a><span class="line-added">11702         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
11703         LValue index = lowInt32(m_node-&gt;child1());
<a name="459" id="anc459"></a><span class="line-modified">11704         setJSValue(vmCall(Int64, operationToIndexString, weakPointer(globalObject), index));</span>
11705     }
11706 
11707     void compileCheckStructureImmediate()
11708     {
11709         LValue structure = lowCell(m_node-&gt;child1());
11710         checkStructure(
11711             structure, noValue(), BadCache, m_node-&gt;structureSet(),
11712             [this] (RegisteredStructure structure) {
11713                 return weakStructure(structure);
11714             });
11715     }
11716 
11717     void compileMaterializeNewObject()
11718     {
11719         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
11720 
11721         // Lower the values first, to avoid creating values inside a control flow diamond.
11722 
11723         Vector&lt;LValue, 8&gt; values;
11724         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
11725             Edge edge = m_graph.varArgChild(m_node, 1 + i);
11726             switch (data.m_properties[i].kind()) {
11727             case PublicLengthPLoc:
11728             case VectorLengthPLoc:
11729                 values.append(lowInt32(edge));
11730                 break;
11731             default:
11732                 values.append(lowJSValue(edge));
11733                 break;
11734             }
11735         }
11736 
11737         RegisteredStructureSet set = m_node-&gt;structureSet();
11738 
11739         Vector&lt;LBasicBlock, 1&gt; blocks(set.size());
11740         for (unsigned i = set.size(); i--;)
11741             blocks[i] = m_out.newBlock();
11742         LBasicBlock dummyDefault = m_out.newBlock();
11743         LBasicBlock outerContinuation = m_out.newBlock();
11744 
11745         Vector&lt;SwitchCase, 1&gt; cases(set.size());
11746         for (unsigned i = set.size(); i--;)
11747             cases[i] = SwitchCase(weakStructure(set.at(i)), blocks[i], Weight(1));
11748         m_out.switchInstruction(
11749             lowCell(m_graph.varArgChild(m_node, 0)), cases, dummyDefault, Weight(0));
11750 
11751         LBasicBlock outerLastNext = m_out.m_nextBlock;
11752 
11753         Vector&lt;ValueFromBlock, 1&gt; results;
11754 
11755         for (unsigned i = set.size(); i--;) {
11756             m_out.appendTo(blocks[i], i + 1 &lt; set.size() ? blocks[i + 1] : dummyDefault);
11757 
11758             RegisteredStructure structure = set.at(i);
11759 
11760             LValue object;
11761             LValue butterfly;
11762 
11763             if (structure-&gt;outOfLineCapacity() || hasIndexedProperties(structure-&gt;indexingType())) {
11764                 size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
11765                 Allocator cellAllocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
11766 
11767                 bool hasIndexingHeader = hasIndexedProperties(structure-&gt;indexingType());
11768                 unsigned indexingHeaderSize = 0;
11769                 LValue indexingPayloadSizeInBytes = m_out.intPtrZero;
11770                 LValue vectorLength = m_out.int32Zero;
11771                 LValue publicLength = m_out.int32Zero;
11772                 if (hasIndexingHeader) {
11773                     indexingHeaderSize = sizeof(IndexingHeader);
11774                     for (unsigned i = data.m_properties.size(); i--;) {
11775                         PromotedLocationDescriptor descriptor = data.m_properties[i];
11776                         switch (descriptor.kind()) {
11777                         case PublicLengthPLoc:
11778                             publicLength = values[i];
11779                             break;
11780                         case VectorLengthPLoc:
11781                             vectorLength = values[i];
11782                             break;
11783                         default:
11784                             break;
11785                         }
11786                     }
11787                     indexingPayloadSizeInBytes =
11788                         m_out.mul(m_out.zeroExtPtr(vectorLength), m_out.intPtrEight);
11789                 }
11790 
11791                 LValue butterflySize = m_out.add(
11792                     m_out.constIntPtr(
11793                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + indexingHeaderSize),
11794                     indexingPayloadSizeInBytes);
11795 
11796                 LBasicBlock slowPath = m_out.newBlock();
11797                 LBasicBlock continuation = m_out.newBlock();
11798 
11799                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
11800 
11801                 ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
11802 
11803                 LValue startOfStorage = allocateHeapCell(
11804                     allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, slowPath),
11805                     slowPath);
11806 
11807                 LValue fastButterflyValue = m_out.add(
11808                     startOfStorage,
11809                     m_out.constIntPtr(
11810                         structure-&gt;outOfLineCapacity() * sizeof(JSValue) + sizeof(IndexingHeader)));
11811 
11812                 ValueFromBlock haveButterfly = m_out.anchor(fastButterflyValue);
11813 
11814                 splatWords(
11815                     fastButterflyValue,
11816                     m_out.constInt32(-structure-&gt;outOfLineCapacity() - 1),
11817                     m_out.constInt32(-1),
11818                     m_out.int64Zero, m_heaps.properties.atAnyNumber());
11819 
11820                 m_out.store32(vectorLength, fastButterflyValue, m_heaps.Butterfly_vectorLength);
11821 
11822                 LValue fastObjectValue = allocateObject(
11823                     m_out.constIntPtr(cellAllocator.localAllocator()), structure, fastButterflyValue,
11824                     slowPath);
11825 
11826                 ValueFromBlock fastObject = m_out.anchor(fastObjectValue);
11827                 ValueFromBlock fastButterfly = m_out.anchor(fastButterflyValue);
11828                 m_out.jump(continuation);
11829 
11830                 m_out.appendTo(slowPath, continuation);
11831 
11832                 LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
11833 
11834                 VM&amp; vm = this-&gt;vm();
11835                 LValue slowObjectValue;
11836                 if (hasIndexingHeader) {
11837                     slowObjectValue = lazySlowPath(
11838                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11839                             return createLazyCallGenerator(vm,
11840                                 operationNewObjectWithButterflyWithIndexingHeaderAndVectorLength,
<a name="460" id="anc460"></a><span class="line-modified">11841                                 locations[0].directGPR(), &amp;vm, CCallHelpers::TrustedImmPtr(structure.get()),</span>
11842                                 locations[1].directGPR(), locations[2].directGPR());
11843                         },
11844                         vectorLength, butterflyValue);
11845                 } else {
11846                     slowObjectValue = lazySlowPath(
11847                         [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
11848                             return createLazyCallGenerator(vm,
<a name="461" id="anc461"></a><span class="line-modified">11849                                 operationNewObjectWithButterfly, locations[0].directGPR(), &amp;vm,</span>
11850                                 CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR());
11851                         },
11852                         butterflyValue);
11853                 }
11854                 ValueFromBlock slowObject = m_out.anchor(slowObjectValue);
11855                 ValueFromBlock slowButterfly = m_out.anchor(
11856                     m_out.loadPtr(slowObjectValue, m_heaps.JSObject_butterfly));
11857 
11858                 m_out.jump(continuation);
11859 
11860                 m_out.appendTo(continuation, lastNext);
11861 
11862                 object = m_out.phi(pointerType(), fastObject, slowObject);
11863                 butterfly = m_out.phi(pointerType(), fastButterfly, slowButterfly);
11864 
11865                 m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
11866 
11867                 initializeArrayElements(m_out.constInt32(structure-&gt;indexingType()), m_out.int32Zero, vectorLength, butterfly);
11868 
11869                 HashMap&lt;int32_t, LValue, DefaultHash&lt;int32_t&gt;::Hash, WTF::UnsignedWithZeroKeyHashTraits&lt;int32_t&gt;&gt; indexMap;
11870                 Vector&lt;int32_t&gt; indices;
11871                 for (unsigned i = data.m_properties.size(); i--;) {
11872                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11873                     if (descriptor.kind() != IndexedPropertyPLoc)
11874                         continue;
11875                     int32_t index = static_cast&lt;int32_t&gt;(descriptor.info());
11876 
11877                     auto result = indexMap.add(index, values[i]);
11878                     DFG_ASSERT(m_graph, m_node, result); // Duplicates are illegal.
11879 
11880                     indices.append(index);
11881                 }
11882 
11883                 if (!indices.isEmpty()) {
11884                     std::sort(indices.begin(), indices.end());
11885 
11886                     Vector&lt;LBasicBlock&gt; blocksWithStores(indices.size());
11887                     Vector&lt;LBasicBlock&gt; blocksWithChecks(indices.size());
11888 
11889                     for (unsigned i = indices.size(); i--;) {
11890                         blocksWithStores[i] = m_out.newBlock();
11891                         blocksWithChecks[i] = m_out.newBlock(); // blocksWithChecks[0] is the continuation.
11892                     }
11893 
11894                     LBasicBlock indexLastNext = m_out.m_nextBlock;
11895 
11896                     for (unsigned i = indices.size(); i--;) {
11897                         int32_t index = indices[i];
11898                         LValue value = indexMap.get(index);
11899 
11900                         m_out.branch(
11901                             m_out.below(m_out.constInt32(index), publicLength),
11902                             unsure(blocksWithStores[i]), unsure(blocksWithChecks[i]));
11903 
11904                         m_out.appendTo(blocksWithStores[i], blocksWithChecks[i]);
11905 
11906                         // This has to type-check and convert its inputs, but it cannot do so in a
11907                         // way that updates AI. That&#39;s a bit annoying, but if you think about how
11908                         // sinking works, it&#39;s actually not a bad thing. We are virtually guaranteed
11909                         // that these type checks will not fail, since the type checks that guarded
11910                         // the original stores to the array are still somewhere above this point.
11911                         Output::StoreType storeType;
11912                         IndexedAbstractHeap* heap;
11913                         switch (structure-&gt;indexingType()) {
11914                         case ALL_INT32_INDEXING_TYPES:
11915                             // FIXME: This could use the proven type if we had the Edge for the
11916                             // value. https://bugs.webkit.org/show_bug.cgi?id=155311
11917                             speculate(BadType, noValue(), nullptr, isNotInt32(value));
11918                             storeType = Output::Store64;
11919                             heap = &amp;m_heaps.indexedInt32Properties;
11920                             break;
11921 
11922                         case ALL_DOUBLE_INDEXING_TYPES: {
11923                             // FIXME: If the source is ValueRep, we should avoid emitting any
11924                             // checks. We could also avoid emitting checks if we had the Edge of
11925                             // this value. https://bugs.webkit.org/show_bug.cgi?id=155311
11926 
11927                             LBasicBlock intCase = m_out.newBlock();
11928                             LBasicBlock doubleCase = m_out.newBlock();
11929                             LBasicBlock continuation = m_out.newBlock();
11930 
11931                             m_out.branch(isInt32(value), unsure(intCase), unsure(doubleCase));
11932 
11933                             LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
11934 
11935                             ValueFromBlock intResult =
11936                                 m_out.anchor(m_out.intToDouble(unboxInt32(value)));
11937                             m_out.jump(continuation);
11938 
11939                             m_out.appendTo(doubleCase, continuation);
11940 
11941                             speculate(BadType, noValue(), nullptr, isNumber(value));
11942                             ValueFromBlock doubleResult = m_out.anchor(unboxDouble(value));
11943                             m_out.jump(continuation);
11944 
11945                             m_out.appendTo(continuation, lastNext);
11946                             value = m_out.phi(Double, intResult, doubleResult);
11947                             storeType = Output::StoreDouble;
11948                             heap = &amp;m_heaps.indexedDoubleProperties;
11949                             break;
11950                         }
11951 
11952                         case ALL_CONTIGUOUS_INDEXING_TYPES:
11953                             storeType = Output::Store64;
11954                             heap = &amp;m_heaps.indexedContiguousProperties;
11955                             break;
11956 
11957                         default:
11958                             DFG_CRASH(m_graph, m_node, &quot;Invalid indexing type&quot;);
11959                             break;
11960                         }
11961 
11962                         m_out.store(value, m_out.address(butterfly, heap-&gt;at(index)), storeType);
11963 
11964                         m_out.jump(blocksWithChecks[i]);
11965                         m_out.appendTo(
11966                             blocksWithChecks[i], i ? blocksWithStores[i - 1] : indexLastNext);
11967                     }
11968                 }
11969             } else {
11970                 // In the easy case where we can do a one-shot allocation, we simply allocate the
11971                 // object to directly have the desired structure.
11972                 object = allocateObject(structure);
11973                 butterfly = nullptr; // Don&#39;t have one, don&#39;t need one.
11974             }
11975 
11976             BitVector setInlineOffsets;
11977             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11978                 for (unsigned i = data.m_properties.size(); i--;) {
11979                     PromotedLocationDescriptor descriptor = data.m_properties[i];
11980                     if (descriptor.kind() != NamedPropertyPLoc)
11981                         continue;
11982                     if (m_graph.identifiers()[descriptor.info()] != entry.key)
11983                         continue;
11984 
11985                     LValue base;
11986                     if (isInlineOffset(entry.offset)) {
11987                         setInlineOffsets.set(entry.offset);
11988                         base = object;
11989                     } else
11990                         base = butterfly;
11991                     storeProperty(values[i], base, descriptor.info(), entry.offset);
11992                     break;
11993                 }
11994             }
11995             for (unsigned i = structure-&gt;inlineCapacity(); i--;) {
11996                 if (!setInlineOffsets.get(i))
11997                     m_out.store64(m_out.int64Zero, m_out.address(m_heaps.properties.atAnyNumber(), object, offsetRelativeToBase(i)));
11998             }
11999 
12000             results.append(m_out.anchor(object));
12001             m_out.jump(outerContinuation);
12002         }
12003 
12004         m_out.appendTo(dummyDefault, outerContinuation);
12005         m_out.unreachable();
12006 
12007         m_out.appendTo(outerContinuation, outerLastNext);
12008         setJSValue(m_out.phi(pointerType(), results));
12009         mutatorFence();
12010     }
12011 
12012     void compileMaterializeCreateActivation()
12013     {
12014         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();
12015 
12016         Vector&lt;LValue, 8&gt; values;
12017         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)
12018             values.append(lowJSValue(m_graph.varArgChild(m_node, 2 + i)));
12019 
12020         LValue scope = lowCell(m_graph.varArgChild(m_node, 1));
12021         SymbolTable* table = m_node-&gt;castOperand&lt;SymbolTable*&gt;();
12022         RegisteredStructure structure = m_graph.registerStructure(m_graph.globalObjectFor(m_node-&gt;origin.semantic)-&gt;activationStructure());
12023 
12024         LBasicBlock slowPath = m_out.newBlock();
12025         LBasicBlock continuation = m_out.newBlock();
12026 
12027         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
12028 
12029         LValue fastObject = allocateObject&lt;JSLexicalEnvironment&gt;(
12030             JSLexicalEnvironment::allocationSize(table), structure, m_out.intPtrZero, slowPath);
12031 
12032         m_out.storePtr(scope, fastObject, m_heaps.JSScope_next);
12033         m_out.storePtr(weakPointer(table), fastObject, m_heaps.JSSymbolTableObject_symbolTable);
12034 
12035 
12036         ValueFromBlock fastResult = m_out.anchor(fastObject);
12037         m_out.jump(continuation);
12038 
12039         m_out.appendTo(slowPath, continuation);
12040         // We ensure allocation sinking explictly sets bottom values for all field members.
12041         // Therefore, it doesn&#39;t matter what JSValue we pass in as the initialization value
12042         // because all fields will be overwritten.
12043         // FIXME: It may be worth creating an operation that calls a constructor on JSLexicalEnvironment that
12044         // doesn&#39;t initialize every slot because we are guaranteed to do that here.
12045         VM&amp; vm = this-&gt;vm();
12046         LValue callResult = lazySlowPath(
12047             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12048                 return createLazyCallGenerator(vm,
<a name="462" id="anc462"></a><span class="line-modified">12049                     operationCreateActivationDirect, locations[0].directGPR(), &amp;vm,</span>
12050                     CCallHelpers::TrustedImmPtr(structure.get()), locations[1].directGPR(),
12051                     CCallHelpers::TrustedImmPtr(table),
12052                     CCallHelpers::TrustedImm64(JSValue::encode(jsUndefined())));
12053             }, scope);
12054         ValueFromBlock slowResult =  m_out.anchor(callResult);
12055         m_out.jump(continuation);
12056 
12057         m_out.appendTo(continuation, lastNext);
12058         LValue activation = m_out.phi(pointerType(), fastResult, slowResult);
12059         RELEASE_ASSERT(data.m_properties.size() == table-&gt;scopeSize());
12060         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
12061             PromotedLocationDescriptor descriptor = data.m_properties[i];
12062             ASSERT(descriptor.kind() == ClosureVarPLoc);
12063             m_out.store64(
12064                 values[i], activation,
12065                 m_heaps.JSLexicalEnvironment_variables[descriptor.info()]);
12066         }
12067 
12068         if (validationEnabled()) {
12069             // Validate to make sure every slot in the scope has one value.
12070             ConcurrentJSLocker locker(table-&gt;m_lock);
12071             for (auto iter = table-&gt;begin(locker), end = table-&gt;end(locker); iter != end; ++iter) {
12072                 bool found = false;
12073                 for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {
12074                     PromotedLocationDescriptor descriptor = data.m_properties[i];
12075                     ASSERT(descriptor.kind() == ClosureVarPLoc);
12076                     if (iter-&gt;value.scopeOffset().offset() == descriptor.info()) {
12077                         found = true;
12078                         break;
12079                     }
12080                 }
12081                 ASSERT_UNUSED(found, found);
12082             }
12083         }
12084 
12085         mutatorFence();
12086         setJSValue(activation);
12087     }
12088 
<a name="463" id="anc463"></a><span class="line-added">12089     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">12090     void compileMaterializeNewInternalFieldObjectImpl(Operation operation)</span>
<span class="line-added">12091     {</span>
<span class="line-added">12092         ObjectMaterializationData&amp; data = m_node-&gt;objectMaterializationData();</span>
<span class="line-added">12093 </span>
<span class="line-added">12094         Vector&lt;LValue, JSClass::numberOfInternalFields&gt; values;</span>
<span class="line-added">12095         ASSERT(data.m_properties.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">12096         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i)</span>
<span class="line-added">12097             values.append(lowJSValue(m_graph.varArgChild(m_node, 1 + i)));</span>
<span class="line-added">12098 </span>
<span class="line-added">12099         RegisteredStructure structure = m_node-&gt;structure();</span>
<span class="line-added">12100 </span>
<span class="line-added">12101         LBasicBlock slowPath = m_out.newBlock();</span>
<span class="line-added">12102         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">12103 </span>
<span class="line-added">12104         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);</span>
<span class="line-added">12105 </span>
<span class="line-added">12106         RELEASE_ASSERT(data.m_properties.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">12107         LValue fastObject = allocateObject&lt;JSClass&gt;(structure, m_out.intPtrZero, slowPath);</span>
<span class="line-added">12108         ValueFromBlock fastResult = m_out.anchor(fastObject);</span>
<span class="line-added">12109         m_out.jump(continuation);</span>
<span class="line-added">12110 </span>
<span class="line-added">12111         m_out.appendTo(slowPath, continuation);</span>
<span class="line-added">12112         VM&amp; vm = this-&gt;vm();</span>
<span class="line-added">12113         LValue callResult = lazySlowPath(</span>
<span class="line-added">12114             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {</span>
<span class="line-added">12115                 return createLazyCallGenerator(vm,</span>
<span class="line-added">12116                     operation, locations[0].directGPR(), &amp;vm,</span>
<span class="line-added">12117                     CCallHelpers::TrustedImmPtr(structure.get()));</span>
<span class="line-added">12118             });</span>
<span class="line-added">12119         ValueFromBlock slowResult = m_out.anchor(callResult);</span>
<span class="line-added">12120         m_out.jump(continuation);</span>
<span class="line-added">12121 </span>
<span class="line-added">12122         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">12123         LValue object = m_out.phi(pointerType(), fastResult, slowResult);</span>
<span class="line-added">12124         for (unsigned i = 0; i &lt; data.m_properties.size(); ++i) {</span>
<span class="line-added">12125             PromotedLocationDescriptor descriptor = data.m_properties[i];</span>
<span class="line-added">12126             ASSERT(descriptor.kind() == InternalFieldObjectPLoc);</span>
<span class="line-added">12127             RELEASE_ASSERT(descriptor.info() &lt; JSClass::numberOfInternalFields);</span>
<span class="line-added">12128             m_out.store64(values[i], object, m_heaps.JSInternalFieldObjectImpl_internalFields[descriptor.info()]);</span>
<span class="line-added">12129         }</span>
<span class="line-added">12130 </span>
<span class="line-added">12131         mutatorFence();</span>
<span class="line-added">12132         setJSValue(object);</span>
<span class="line-added">12133     }</span>
<span class="line-added">12134 </span>
<span class="line-added">12135     void compileMaterializeNewInternalFieldObject()</span>
<span class="line-added">12136     {</span>
<span class="line-added">12137         switch (m_node-&gt;structure()-&gt;typeInfo().type()) {</span>
<span class="line-added">12138         case JSArrayIteratorType:</span>
<span class="line-added">12139             compileMaterializeNewInternalFieldObjectImpl&lt;JSArrayIterator&gt;(operationNewArrayIterator);</span>
<span class="line-added">12140             break;</span>
<span class="line-added">12141         default:</span>
<span class="line-added">12142             DFG_CRASH(m_graph, m_node, &quot;Bad structure&quot;);</span>
<span class="line-added">12143         }</span>
<span class="line-added">12144     }</span>
<span class="line-added">12145 </span>
12146     void compileCheckTraps()
12147     {
12148         ASSERT(Options::usePollingTraps());
12149         LBasicBlock needTrapHandling = m_out.newBlock();
12150         LBasicBlock continuation = m_out.newBlock();
12151 
12152         LValue state = m_out.load8ZeroExt32(m_out.absolute(vm().needTrapHandlingAddress()));
12153         m_out.branch(m_out.isZero32(state),
12154             usually(continuation), rarely(needTrapHandling));
12155 
12156         LBasicBlock lastNext = m_out.appendTo(needTrapHandling, continuation);
12157 
12158         VM&amp; vm = this-&gt;vm();
<a name="464" id="anc464"></a><span class="line-added">12159         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
12160         lazySlowPath(
12161             [=, &amp;vm] (const Vector&lt;Location&gt;&amp;) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
<a name="465" id="anc465"></a><span class="line-modified">12162                 return createLazyCallGenerator(vm, operationHandleTraps, InvalidGPRReg, globalObject);</span>
12163             });
12164         m_out.jump(continuation);
12165 
12166         m_out.appendTo(continuation, lastNext);
12167     }
12168 
12169     void compileRegExpExec()
12170     {
12171         LValue globalObject = lowCell(m_node-&gt;child1());
12172 
12173         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
12174             LValue base = lowRegExpObject(m_node-&gt;child2());
12175 
12176             if (m_node-&gt;child3().useKind() == StringUse) {
12177                 LValue argument = lowString(m_node-&gt;child3());
<a name="466" id="anc466"></a><span class="line-modified">12178                 LValue result = vmCall(Int64, operationRegExpExecString, globalObject, base, argument);</span>


12179                 setJSValue(result);
12180                 return;
12181             }
12182 
12183             LValue argument = lowJSValue(m_node-&gt;child3());
<a name="467" id="anc467"></a><span class="line-modified">12184             LValue result = vmCall(Int64, operationRegExpExec, globalObject, base, argument);</span>


12185             setJSValue(result);
12186             return;
12187         }
12188 
12189         LValue base = lowJSValue(m_node-&gt;child2());
12190         LValue argument = lowJSValue(m_node-&gt;child3());
<a name="468" id="anc468"></a><span class="line-modified">12191         LValue result = vmCall(Int64, operationRegExpExecGeneric, globalObject, base, argument);</span>


12192         setJSValue(result);
12193     }
12194 
12195     void compileRegExpExecNonGlobalOrSticky()
12196     {
12197         LValue globalObject = lowCell(m_node-&gt;child1());
12198         LValue argument = lowString(m_node-&gt;child2());
<a name="469" id="anc469"></a><span class="line-modified">12199         LValue result = vmCall(Int64, operationRegExpExecNonGlobalOrSticky, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>

12200         setJSValue(result);
12201     }
12202 
12203     void compileRegExpMatchFastGlobal()
12204     {
12205         LValue globalObject = lowCell(m_node-&gt;child1());
12206         LValue argument = lowString(m_node-&gt;child2());
<a name="470" id="anc470"></a><span class="line-modified">12207         LValue result = vmCall(Int64, operationRegExpMatchFastGlobalString, globalObject, frozenPointer(m_node-&gt;cellOperand()), argument);</span>

12208         setJSValue(result);
12209     }
12210 
12211     void compileRegExpTest()
12212     {
12213         LValue globalObject = lowCell(m_node-&gt;child1());
12214 
12215         if (m_node-&gt;child2().useKind() == RegExpObjectUse) {
12216             LValue base = lowRegExpObject(m_node-&gt;child2());
12217 
12218             if (m_node-&gt;child3().useKind() == StringUse) {
12219                 LValue argument = lowString(m_node-&gt;child3());
<a name="471" id="anc471"></a><span class="line-modified">12220                 LValue result = vmCall(Int32, operationRegExpTestString, globalObject, base, argument);</span>


12221                 setBoolean(result);
12222                 return;
12223             }
12224 
12225             LValue argument = lowJSValue(m_node-&gt;child3());
<a name="472" id="anc472"></a><span class="line-modified">12226             LValue result = vmCall(Int32, operationRegExpTest, globalObject, base, argument);</span>


12227             setBoolean(result);
12228             return;
12229         }
12230 
12231         LValue base = lowJSValue(m_node-&gt;child2());
12232         LValue argument = lowJSValue(m_node-&gt;child3());
<a name="473" id="anc473"></a><span class="line-modified">12233         LValue result = vmCall(Int32, operationRegExpTestGeneric, globalObject, base, argument);</span>


12234         setBoolean(result);
12235     }
12236 
12237     void compileRegExpMatchFast()
12238     {
12239         LValue globalObject = lowCell(m_node-&gt;child1());
12240         LValue base = lowRegExpObject(m_node-&gt;child2());
12241         LValue argument = lowString(m_node-&gt;child3());
<a name="474" id="anc474"></a><span class="line-modified">12242         LValue result = vmCall(Int64, operationRegExpMatchFastString, globalObject, base, argument);</span>


12243         setJSValue(result);
12244     }
12245 
12246     void compileNewRegexp()
12247     {
<a name="475" id="anc475"></a><span class="line-added">12248         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
12249         FrozenValue* regexp = m_node-&gt;cellOperand();
12250         LValue lastIndex = lowJSValue(m_node-&gt;child1());
12251         ASSERT(regexp-&gt;cell()-&gt;inherits&lt;RegExp&gt;(vm()));
12252 
12253         LBasicBlock slowCase = m_out.newBlock();
12254         LBasicBlock continuation = m_out.newBlock();
12255 
12256         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowCase);
12257 
<a name="476" id="anc476"></a><span class="line-modified">12258         auto structure = m_graph.registerStructure(globalObject-&gt;regExpStructure());</span>
12259         LValue fastResultValue = allocateObject&lt;RegExpObject&gt;(structure, m_out.intPtrZero, slowCase);
12260         m_out.storePtr(frozenPointer(regexp), fastResultValue, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag);
12261         m_out.store64(lastIndex, fastResultValue, m_heaps.RegExpObject_lastIndex);
12262         mutatorFence();
12263         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
12264         m_out.jump(continuation);
12265 
12266         m_out.appendTo(slowCase, continuation);
12267         VM&amp; vm = this-&gt;vm();
12268         RegExp* regexpCell = regexp-&gt;cast&lt;RegExp*&gt;();
12269         LValue slowResultValue = lazySlowPath(
12270             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12271                 return createLazyCallGenerator(vm,
<a name="477" id="anc477"></a><span class="line-modified">12272                     operationNewRegexpWithLastIndex, locations[0].directGPR(), globalObject,</span>
12273                     CCallHelpers::TrustedImmPtr(regexpCell), locations[1].directGPR());
12274             }, lastIndex);
12275         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
12276         m_out.jump(continuation);
12277 
12278         m_out.appendTo(continuation, lastNext);
12279         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
12280     }
12281 
12282     void compileSetFunctionName()
12283     {
<a name="478" id="anc478"></a><span class="line-modified">12284         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">12285         vmCall(Void, operationSetFunctionName, weakPointer(globalObject),</span>
12286             lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()));
12287     }
12288 
12289     void compileStringReplace()
12290     {
<a name="479" id="anc479"></a><span class="line-added">12291         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
12292         if (m_node-&gt;child1().useKind() == StringUse
12293             &amp;&amp; m_node-&gt;child2().useKind() == RegExpObjectUse
12294             &amp;&amp; m_node-&gt;child3().useKind() == StringUse) {
12295 
12296             if (JSString* replace = m_node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
12297                 if (!replace-&gt;length()) {
12298                     LValue string = lowString(m_node-&gt;child1());
12299                     LValue regExp = lowRegExpObject(m_node-&gt;child2());
12300 
<a name="480" id="anc480"></a><span class="line-modified">12301                     LValue result = vmCall(pointerType(), operationStringProtoFuncReplaceRegExpEmptyStr, weakPointer(globalObject), string, regExp);</span>


12302 
12303                     setJSValue(result);
12304                     return;
12305                 }
12306             }
12307 
12308             LValue string = lowString(m_node-&gt;child1());
12309             LValue regExp = lowRegExpObject(m_node-&gt;child2());
12310             LValue replace = lowString(m_node-&gt;child3());
12311 
<a name="481" id="anc481"></a><span class="line-modified">12312             LValue result = vmCall(pointerType(), operationStringProtoFuncReplaceRegExpString, weakPointer(globalObject), string, regExp, replace);</span>


12313 
12314             setJSValue(result);
12315             return;
12316         }
12317 
12318         LValue search;
12319         if (m_node-&gt;child2().useKind() == StringUse)
12320             search = lowString(m_node-&gt;child2());
12321         else
12322             search = lowJSValue(m_node-&gt;child2());
12323 
12324         LValue result = vmCall(
<a name="482" id="anc482"></a><span class="line-modified">12325             pointerType(), operationStringProtoFuncReplaceGeneric,</span>
<span class="line-added">12326             weakPointer(globalObject),</span>
12327             lowJSValue(m_node-&gt;child1()), search,
12328             lowJSValue(m_node-&gt;child3()));
12329 
12330         setJSValue(result);
12331     }
12332 
12333     void compileGetRegExpObjectLastIndex()
12334     {
12335         setJSValue(m_out.load64(lowRegExpObject(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex));
12336     }
12337 
12338     void compileSetRegExpObjectLastIndex()
12339     {
12340         if (!m_node-&gt;ignoreLastIndexIsWritable()) {
12341             LValue regExp = lowRegExpObject(m_node-&gt;child1());
12342             LValue value = lowJSValue(m_node-&gt;child2());
12343 
12344             speculate(
12345                 ExoticObjectMode, noValue(), nullptr,
12346                 m_out.testNonZeroPtr(
12347                     m_out.loadPtr(regExp, m_heaps.RegExpObject_regExpAndLastIndexIsNotWritableFlag),
12348                     m_out.constIntPtr(RegExpObject::lastIndexIsNotWritableFlag)));
12349 
12350             m_out.store64(value, regExp, m_heaps.RegExpObject_lastIndex);
12351             return;
12352         }
12353 
12354         m_out.store64(lowJSValue(m_node-&gt;child2()), lowCell(m_node-&gt;child1()), m_heaps.RegExpObject_lastIndex);
12355     }
12356 
12357     void compileLogShadowChickenPrologue()
12358     {
12359         LValue packet = ensureShadowChickenPacket();
12360         LValue scope = lowCell(m_node-&gt;child1());
12361 
12362         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
<a name="483" id="anc483"></a><span class="line-modified">12363         m_out.storePtr(m_out.loadPtr(addressFor(VirtualRegister(0))), packet, m_heaps.ShadowChicken_Packet_callerFrame);</span>
<span class="line-modified">12364         m_out.storePtr(m_out.loadPtr(payloadFor(VirtualRegister(CallFrameSlot::callee))), packet, m_heaps.ShadowChicken_Packet_callee);</span>
12365         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
12366     }
12367 
12368     void compileLogShadowChickenTail()
12369     {
12370         LValue packet = ensureShadowChickenPacket();
12371         LValue thisValue = lowJSValue(m_node-&gt;child1());
12372         LValue scope = lowCell(m_node-&gt;child2());
12373         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(m_node-&gt;origin.semantic);
12374 
12375         m_out.storePtr(m_callFrame, packet, m_heaps.ShadowChicken_Packet_frame);
12376         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(ShadowChicken::Packet::tailMarker())), packet, m_heaps.ShadowChicken_Packet_callee);
12377         m_out.store64(thisValue, packet, m_heaps.ShadowChicken_Packet_thisValue);
12378         m_out.storePtr(scope, packet, m_heaps.ShadowChicken_Packet_scope);
12379         // We don&#39;t want the CodeBlock to have a weak pointer to itself because
12380         // that would cause it to always get collected.
12381         m_out.storePtr(m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), packet, m_heaps.ShadowChicken_Packet_codeBlock);
12382         m_out.store32(m_out.constInt32(callSiteIndex.bits()), packet, m_heaps.ShadowChicken_Packet_callSiteIndex);
12383     }
12384 
12385     void compileRecordRegExpCachedResult()
12386     {
12387         Edge globalObjectEdge = m_graph.varArgChild(m_node, 0);
12388         Edge regExpEdge = m_graph.varArgChild(m_node, 1);
12389         Edge stringEdge = m_graph.varArgChild(m_node, 2);
12390         Edge startEdge = m_graph.varArgChild(m_node, 3);
12391         Edge endEdge = m_graph.varArgChild(m_node, 4);
12392 
12393         LValue globalObject = lowCell(globalObjectEdge);
12394         LValue regExp = lowCell(regExpEdge);
12395         LValue string = lowCell(stringEdge);
12396         LValue start = lowInt32(startEdge);
12397         LValue end = lowInt32(endEdge);
12398 
12399         m_out.storePtr(regExp, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastRegExp);
12400         m_out.storePtr(string, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_lastInput);
12401         m_out.store32(start, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_start);
12402         m_out.store32(end, globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_result_end);
12403         m_out.store32As8(
12404             m_out.constInt32(0),
12405             m_out.address(globalObject, m_heaps.JSGlobalObject_regExpGlobalData_cachedResult_reified));
12406     }
12407 
12408     struct ArgumentsLength {
12409         ArgumentsLength()
12410             : isKnown(false)
12411             , known(UINT_MAX)
12412             , value(nullptr)
12413         {
12414         }
12415 
12416         bool isKnown;
12417         unsigned known;
12418         LValue value;
12419     };
12420     ArgumentsLength getArgumentsLength(InlineCallFrame* inlineCallFrame)
12421     {
12422         ArgumentsLength length;
12423 
12424         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<a name="484" id="anc484"></a><span class="line-modified">12425             length.known = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
12426             length.isKnown = true;
12427             length.value = m_out.constInt32(length.known);
12428         } else {
12429             length.known = UINT_MAX;
12430             length.isKnown = false;
12431 
12432             VirtualRegister argumentCountRegister;
12433             if (!inlineCallFrame)
<a name="485" id="anc485"></a><span class="line-modified">12434                 argumentCountRegister = VirtualRegister(CallFrameSlot::argumentCountIncludingThis);</span>
12435             else
12436                 argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12437             length.value = m_out.sub(m_out.load32(payloadFor(argumentCountRegister)), m_out.int32One);
12438         }
12439 
12440         return length;
12441     }
12442 
12443     ArgumentsLength getArgumentsLength()
12444     {
12445         return getArgumentsLength(m_node-&gt;origin.semantic.inlineCallFrame());
12446     }
12447 
12448     LValue getCurrentCallee()
12449     {
12450         if (InlineCallFrame* frame = m_node-&gt;origin.semantic.inlineCallFrame()) {
12451             if (frame-&gt;isClosureCall)
12452                 return m_out.loadPtr(addressFor(frame-&gt;calleeRecovery.virtualRegister()));
12453             return weakPointer(frame-&gt;calleeRecovery.constant().asCell());
12454         }
<a name="486" id="anc486"></a><span class="line-modified">12455         return m_out.loadPtr(addressFor(VirtualRegister(CallFrameSlot::callee)));</span>
12456     }
12457 
12458     LValue getArgumentsStart(InlineCallFrame* inlineCallFrame, unsigned offset = 0)
12459     {
12460         VirtualRegister start = AssemblyHelpers::argumentsStart(inlineCallFrame) + offset;
12461         return addressFor(start).value();
12462     }
12463 
12464     LValue getArgumentsStart()
12465     {
12466         return getArgumentsStart(m_node-&gt;origin.semantic.inlineCallFrame());
12467     }
12468 
12469     template&lt;typename Functor&gt;
12470     void checkStructure(
12471         LValue structureDiscriminant, const FormattedValue&amp; formattedValue, ExitKind exitKind,
12472         const RegisteredStructureSet&amp; set, const Functor&amp; weakStructureDiscriminant)
12473     {
12474         if (set.isEmpty()) {
12475             terminate(exitKind);
12476             return;
12477         }
12478 
12479         if (set.size() == 1) {
12480             speculate(
12481                 exitKind, formattedValue, 0,
12482                 m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set[0])));
12483             return;
12484         }
12485 
12486         LBasicBlock continuation = m_out.newBlock();
12487 
12488         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
12489         for (unsigned i = 0; i &lt; set.size() - 1; ++i) {
12490             LBasicBlock nextStructure = m_out.newBlock();
12491             m_out.branch(
12492                 m_out.equal(structureDiscriminant, weakStructureDiscriminant(set[i])),
12493                 unsure(continuation), unsure(nextStructure));
12494             m_out.appendTo(nextStructure);
12495         }
12496 
12497         speculate(
12498             exitKind, formattedValue, 0,
12499             m_out.notEqual(structureDiscriminant, weakStructureDiscriminant(set.last())));
12500 
12501         m_out.jump(continuation);
12502         m_out.appendTo(continuation, lastNext);
12503     }
12504 
12505     LValue numberOrNotCellToInt32(Edge edge, LValue value)
12506     {
12507         LBasicBlock intCase = m_out.newBlock();
12508         LBasicBlock notIntCase = m_out.newBlock();
12509         LBasicBlock doubleCase = 0;
12510         LBasicBlock notNumberCase = 0;
12511         if (edge.useKind() == NotCellUse) {
12512             doubleCase = m_out.newBlock();
12513             notNumberCase = m_out.newBlock();
12514         }
12515         LBasicBlock continuation = m_out.newBlock();
12516 
12517         Vector&lt;ValueFromBlock&gt; results;
12518 
12519         m_out.branch(isNotInt32(value), unsure(notIntCase), unsure(intCase));
12520 
12521         LBasicBlock lastNext = m_out.appendTo(intCase, notIntCase);
12522         results.append(m_out.anchor(unboxInt32(value)));
12523         m_out.jump(continuation);
12524 
12525         if (edge.useKind() == NumberUse) {
12526             m_out.appendTo(notIntCase, continuation);
12527             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isCellOrMisc(value));
12528             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
12529             m_out.jump(continuation);
12530         } else {
12531             m_out.appendTo(notIntCase, doubleCase);
12532             m_out.branch(
12533                 isCellOrMisc(value, provenType(edge)), unsure(notNumberCase), unsure(doubleCase));
12534 
12535             m_out.appendTo(doubleCase, notNumberCase);
12536             results.append(m_out.anchor(doubleToInt32(unboxDouble(value))));
12537             m_out.jump(continuation);
12538 
12539             m_out.appendTo(notNumberCase, continuation);
12540 
12541             FTL_TYPE_CHECK(jsValueValue(value), edge, ~SpecCellCheck, isCell(value));
12542 
12543             LValue specialResult = m_out.select(
12544                 m_out.equal(value, m_out.constInt64(JSValue::encode(jsBoolean(true)))),
12545                 m_out.int32One, m_out.int32Zero);
12546             results.append(m_out.anchor(specialResult));
12547             m_out.jump(continuation);
12548         }
12549 
12550         m_out.appendTo(continuation, lastNext);
12551         return m_out.phi(Int32, results);
12552     }
12553 
12554     LValue loadProperty(LValue storage, unsigned identifierNumber, PropertyOffset offset)
12555     {
12556         return m_out.load64(addressOfProperty(storage, identifierNumber, offset));
12557     }
12558 
12559     void storeProperty(
12560         LValue value, LValue storage, unsigned identifierNumber, PropertyOffset offset)
12561     {
12562         m_out.store64(value, addressOfProperty(storage, identifierNumber, offset));
12563     }
12564 
12565     TypedPointer addressOfProperty(
12566         LValue storage, unsigned identifierNumber, PropertyOffset offset)
12567     {
12568         return m_out.address(
12569             m_heaps.properties[identifierNumber], storage, offsetRelativeToBase(offset));
12570     }
12571 
12572     LValue storageForTransition(
12573         LValue object, PropertyOffset offset,
12574         Structure* previousStructure, Structure* nextStructure)
12575     {
12576         if (isInlineOffset(offset))
12577             return object;
12578 
12579         if (previousStructure-&gt;outOfLineCapacity() == nextStructure-&gt;outOfLineCapacity())
12580             return m_out.loadPtr(object, m_heaps.JSObject_butterfly);
12581 
12582         LValue result;
12583         if (!previousStructure-&gt;outOfLineCapacity())
12584             result = allocatePropertyStorage(object, previousStructure);
12585         else {
12586             result = reallocatePropertyStorage(
12587                 object, m_out.loadPtr(object, m_heaps.JSObject_butterfly),
12588                 previousStructure, nextStructure);
12589         }
12590 
12591         nukeStructureAndSetButterfly(result, object);
12592         return result;
12593     }
12594 
12595     void initializeArrayElements(LValue indexingType, LValue begin, LValue end, LValue butterfly)
12596     {
12597 
12598         if (begin == end)
12599             return;
12600 
12601         if (indexingType-&gt;hasInt32()) {
12602             IndexingType rawIndexingType = static_cast&lt;IndexingType&gt;(indexingType-&gt;asInt32());
12603             if (hasUndecided(rawIndexingType))
12604                 return;
12605             IndexedAbstractHeap* heap = m_heaps.forIndexingType(rawIndexingType);
12606             DFG_ASSERT(m_graph, m_node, heap);
12607 
12608             LValue hole;
12609             if (hasDouble(rawIndexingType))
12610                 hole = m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN));
12611             else
12612                 hole = m_out.constInt64(JSValue::encode(JSValue()));
12613 
12614             splatWords(butterfly, begin, end, hole, heap-&gt;atAnyIndex());
12615         } else {
12616             LValue hole = m_out.select(
12617                 m_out.equal(m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)), m_out.constInt32(DoubleShape)),
12618                 m_out.constInt64(bitwise_cast&lt;int64_t&gt;(PNaN)),
12619                 m_out.constInt64(JSValue::encode(JSValue())));
12620             splatWords(butterfly, begin, end, hole, m_heaps.root);
12621         }
12622     }
12623 
12624     void splatWords(LValue base, LValue begin, LValue end, LValue value, const AbstractHeap&amp; heap)
12625     {
12626         const uint64_t unrollingLimit = 10;
12627         if (begin-&gt;hasInt() &amp;&amp; end-&gt;hasInt()) {
12628             uint64_t beginConst = static_cast&lt;uint64_t&gt;(begin-&gt;asInt());
12629             uint64_t endConst = static_cast&lt;uint64_t&gt;(end-&gt;asInt());
12630 
12631             if (endConst - beginConst &lt;= unrollingLimit) {
12632                 for (uint64_t i = beginConst; i &lt; endConst; ++i) {
12633                     LValue pointer = m_out.add(base, m_out.constIntPtr(i * sizeof(uint64_t)));
12634                     m_out.store64(value, TypedPointer(heap, pointer));
12635                 }
12636                 return;
12637             }
12638         }
12639 
12640         LBasicBlock initLoop = m_out.newBlock();
12641         LBasicBlock initDone = m_out.newBlock();
12642 
12643         LBasicBlock lastNext = m_out.insertNewBlocksBefore(initLoop);
12644 
12645         ValueFromBlock originalIndex = m_out.anchor(end);
12646         ValueFromBlock originalPointer = m_out.anchor(
12647             m_out.add(base, m_out.shl(m_out.signExt32ToPtr(begin), m_out.constInt32(3))));
12648         m_out.branch(m_out.notEqual(end, begin), unsure(initLoop), unsure(initDone));
12649 
12650         m_out.appendTo(initLoop, initDone);
12651         LValue index = m_out.phi(Int32, originalIndex);
12652         LValue pointer = m_out.phi(pointerType(), originalPointer);
12653 
12654         m_out.store64(value, TypedPointer(heap, pointer));
12655 
12656         LValue nextIndex = m_out.sub(index, m_out.int32One);
12657         m_out.addIncomingToPhi(index, m_out.anchor(nextIndex));
12658         m_out.addIncomingToPhi(pointer, m_out.anchor(m_out.add(pointer, m_out.intPtrEight)));
12659         m_out.branch(
12660             m_out.notEqual(nextIndex, begin), unsure(initLoop), unsure(initDone));
12661 
12662         m_out.appendTo(initDone, lastNext);
12663     }
12664 
12665     LValue allocatePropertyStorage(LValue object, Structure* previousStructure)
12666     {
12667         if (previousStructure-&gt;couldHaveIndexingHeader()) {
12668             return vmCall(
12669                 pointerType(),
<a name="487" id="anc487"></a><span class="line-modified">12670                 operationAllocateComplexPropertyStorageWithInitialCapacity,</span>
<span class="line-modified">12671                 m_vmValue, object);</span>
12672         }
12673 
12674         LValue result = allocatePropertyStorageWithSizeImpl(initialOutOfLineCapacity);
12675 
12676         splatWords(
12677             result,
12678             m_out.constInt32(-initialOutOfLineCapacity - 1), m_out.constInt32(-1),
12679             m_out.int64Zero, m_heaps.properties.atAnyNumber());
12680 
12681         return result;
12682     }
12683 
12684     LValue reallocatePropertyStorage(
12685         LValue object, LValue oldStorage, Structure* previous, Structure* next)
12686     {
12687         size_t oldSize = previous-&gt;outOfLineCapacity();
12688         size_t newSize = oldSize * outOfLineGrowthFactor;
12689 
12690         ASSERT_UNUSED(next, newSize == next-&gt;outOfLineCapacity());
12691 
12692         if (previous-&gt;couldHaveIndexingHeader()) {
12693             LValue newAllocSize = m_out.constIntPtr(newSize);
<a name="488" id="anc488"></a><span class="line-modified">12694             return vmCall(pointerType(), operationAllocateComplexPropertyStorage, m_vmValue, object, newAllocSize);</span>
12695         }
12696 
12697         LValue result = allocatePropertyStorageWithSizeImpl(newSize);
12698 
12699         ptrdiff_t headerSize = -sizeof(IndexingHeader) - sizeof(void*);
12700         ptrdiff_t endStorage = headerSize - static_cast&lt;ptrdiff_t&gt;(oldSize * sizeof(JSValue));
12701 
12702         for (ptrdiff_t offset = headerSize; offset &gt; endStorage; offset -= sizeof(void*)) {
12703             LValue loaded =
12704                 m_out.loadPtr(m_out.address(m_heaps.properties.atAnyNumber(), oldStorage, offset));
12705             m_out.storePtr(loaded, m_out.address(m_heaps.properties.atAnyNumber(), result, offset));
12706         }
12707 
12708         splatWords(
12709             result,
12710             m_out.constInt32(-newSize - 1), m_out.constInt32(-oldSize - 1),
12711             m_out.int64Zero, m_heaps.properties.atAnyNumber());
12712 
12713         return result;
12714     }
12715 
12716     LValue allocatePropertyStorageWithSizeImpl(size_t sizeInValues)
12717     {
12718         LBasicBlock slowPath = m_out.newBlock();
12719         LBasicBlock continuation = m_out.newBlock();
12720 
12721         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
12722 
12723         size_t sizeInBytes = sizeInValues * sizeof(JSValue);
12724         Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(sizeInBytes, AllocatorForMode::AllocatorIfExists);
12725         LValue startOfStorage = allocateHeapCell(
12726             m_out.constIntPtr(allocator.localAllocator()), slowPath);
12727         ValueFromBlock fastButterfly = m_out.anchor(
12728             m_out.add(m_out.constIntPtr(sizeInBytes + sizeof(IndexingHeader)), startOfStorage));
12729         m_out.jump(continuation);
12730 
12731         m_out.appendTo(slowPath, continuation);
12732 
12733         LValue slowButterflyValue;
12734         VM&amp; vm = this-&gt;vm();
12735         if (sizeInValues == initialOutOfLineCapacity) {
12736             slowButterflyValue = lazySlowPath(
12737                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12738                     return createLazyCallGenerator(vm,
12739                         operationAllocateSimplePropertyStorageWithInitialCapacity,
<a name="489" id="anc489"></a><span class="line-modified">12740                         locations[0].directGPR(), &amp;vm);</span>
12741                 });
12742         } else {
12743             slowButterflyValue = lazySlowPath(
12744                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
12745                     return createLazyCallGenerator(vm,
<a name="490" id="anc490"></a><span class="line-modified">12746                         operationAllocateSimplePropertyStorage, locations[0].directGPR(), &amp;vm,</span>
12747                         CCallHelpers::TrustedImmPtr(sizeInValues));
12748                 });
12749         }
12750         ValueFromBlock slowButterfly = m_out.anchor(slowButterflyValue);
12751 
12752         m_out.jump(continuation);
12753 
12754         m_out.appendTo(continuation, lastNext);
12755 
12756         return m_out.phi(pointerType(), fastButterfly, slowButterfly);
12757     }
12758 
12759     LValue getById(LValue base, AccessType type)
12760     {
12761         Node* node = m_node;
12762         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
12763 
12764         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12765         patchpoint-&gt;appendSomeRegister(base);
<a name="491" id="anc491"></a><span class="line-modified">12766         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">12767         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
12768 
12769         // FIXME: If this is a GetByIdFlush/GetByIdDirectFlush, we might get some performance boost if we claim that it
12770         // clobbers volatile registers late. It&#39;s not necessary for correctness, though, since the
12771         // IC code is super smart about saving registers.
12772         // https://bugs.webkit.org/show_bug.cgi?id=152848
12773 
12774         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12775 
12776         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12777             preparePatchpointForExceptions(patchpoint);
12778 
12779         State* state = &amp;m_ftlState;
12780         patchpoint-&gt;setGenerator(
12781             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12782                 AllowMacroScratchRegisterUsage allowScratch(jit);
12783 
12784                 CallSiteIndex callSiteIndex =
12785                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
12786 
12787                 // This is the direct exit target for operation calls.
12788                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12789                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12790 
12791                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
12792                 // to do anything weird other than call this, since it will associate the exit with
12793                 // the callsite index.
12794                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
12795 
12796                 auto generator = Box&lt;JITGetByIdGenerator&gt;::create(
12797                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
12798                     params.unavailableRegisters(), uid, JSValueRegs(params[1].gpr()),
12799                     JSValueRegs(params[0].gpr()), type);
12800 
12801                 generator-&gt;generateFastPath(jit);
12802                 CCallHelpers::Label done = jit.label();
12803 
12804                 params.addLatePath(
12805                     [=] (CCallHelpers&amp; jit) {
12806                         AllowMacroScratchRegisterUsage allowScratch(jit);
12807 
<a name="492" id="anc492"></a><span class="line-modified">12808                         J_JITOperation_GSsiJI optimizationFunction = appropriateOptimizingGetByIdFunction(type);</span>
12809 
12810                         generator-&gt;slowPathJump().link(&amp;jit);
12811                         CCallHelpers::Label slowPathBegin = jit.label();
12812                         CCallHelpers::Call slowPathCall = callOperation(
12813                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
12814                             exceptions.get(), optimizationFunction, params[0].gpr(),
<a name="493" id="anc493"></a><span class="line-added">12815                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
12816                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
12817                             CCallHelpers::TrustedImmPtr(uid)).call();
12818                         jit.jump().linkTo(done, &amp;jit);
12819 
12820                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
12821 
12822                         jit.addLinkTask(
12823                             [=] (LinkBuffer&amp; linkBuffer) {
12824                                 generator-&gt;finalize(linkBuffer, linkBuffer);
12825                             });
12826                     });
12827             });
12828 
12829         return patchpoint;
12830     }
12831 
12832     LValue getByIdWithThis(LValue base, LValue thisValue)
12833     {
12834         Node* node = m_node;
12835         UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
12836 
12837         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
12838         patchpoint-&gt;appendSomeRegister(base);
12839         patchpoint-&gt;appendSomeRegister(thisValue);
<a name="494" id="anc494"></a><span class="line-modified">12840         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">12841         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
12842 
12843         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
12844 
12845         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
12846             preparePatchpointForExceptions(patchpoint);
12847 
12848         State* state = &amp;m_ftlState;
12849         patchpoint-&gt;setGenerator(
12850             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
12851                 AllowMacroScratchRegisterUsage allowScratch(jit);
12852 
12853                 CallSiteIndex callSiteIndex =
12854                     state-&gt;jitCode-&gt;common.addUniqueCallSiteIndex(node-&gt;origin.semantic);
12855 
12856                 // This is the direct exit target for operation calls.
12857                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
12858                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
12859 
12860                 // This is the exit for call IC&#39;s created by the getById for getters. We don&#39;t have
12861                 // to do anything weird other than call this, since it will associate the exit with
12862                 // the callsite index.
12863                 exceptionHandle-&gt;scheduleExitCreationForUnwind(params, callSiteIndex);
12864 
12865                 auto generator = Box&lt;JITGetByIdWithThisGenerator&gt;::create(
12866                     jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex,
12867                     params.unavailableRegisters(), uid, JSValueRegs(params[0].gpr()),
<a name="495" id="anc495"></a><span class="line-modified">12868                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()));</span>
12869 
12870                 generator-&gt;generateFastPath(jit);
12871                 CCallHelpers::Label done = jit.label();
12872 
12873                 params.addLatePath(
12874                     [=] (CCallHelpers&amp; jit) {
12875                         AllowMacroScratchRegisterUsage allowScratch(jit);
12876 
<a name="496" id="anc496"></a><span class="line-modified">12877                         J_JITOperation_GSsiJJI optimizationFunction = operationGetByIdWithThisOptimize;</span>
12878 
12879                         generator-&gt;slowPathJump().link(&amp;jit);
12880                         CCallHelpers::Label slowPathBegin = jit.label();
12881                         CCallHelpers::Call slowPathCall = callOperation(
12882                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
12883                             exceptions.get(), optimizationFunction, params[0].gpr(),
<a name="497" id="anc497"></a><span class="line-added">12884                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
12885                             CCallHelpers::TrustedImmPtr(generator-&gt;stubInfo()), params[1].gpr(),
12886                             params[2].gpr(), CCallHelpers::TrustedImmPtr(uid)).call();
12887                         jit.jump().linkTo(done, &amp;jit);
12888 
12889                         generator-&gt;reportSlowPathCall(slowPathBegin, slowPathCall);
12890 
12891                         jit.addLinkTask(
12892                             [=] (LinkBuffer&amp; linkBuffer) {
12893                                 generator-&gt;finalize(linkBuffer, linkBuffer);
12894                             });
12895                     });
12896             });
12897 
12898         return patchpoint;
12899     }
12900 
12901     LValue isFastTypedArray(LValue object)
12902     {
12903         return m_out.equal(
12904             m_out.load32(object, m_heaps.JSArrayBufferView_mode),
12905             m_out.constInt32(FastTypedArray));
12906     }
12907 
12908     TypedPointer baseIndex(IndexedAbstractHeap&amp; heap, LValue storage, LValue index, Edge edge, ptrdiff_t offset = 0)
12909     {
12910         return m_out.baseIndex(
12911             heap, storage, m_out.zeroExtPtr(index), provenValue(edge), offset);
12912     }
12913 
12914     template&lt;typename IntFunctor, typename DoubleFunctor&gt;
12915     void compare(
12916         const IntFunctor&amp; intFunctor, const DoubleFunctor&amp; doubleFunctor,
12917         C_JITOperation_TT stringIdentFunction,
<a name="498" id="anc498"></a><span class="line-modified">12918         C_JITOperation_B_GJssJss stringFunction,</span>
<span class="line-modified">12919         S_JITOperation_GJJ fallbackFunction)</span>
12920     {
<a name="499" id="anc499"></a><span class="line-added">12921         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
12922         if (m_node-&gt;isBinaryUseKind(Int32Use)) {
12923             LValue left = lowInt32(m_node-&gt;child1());
12924             LValue right = lowInt32(m_node-&gt;child2());
12925             setBoolean(intFunctor(left, right));
12926             return;
12927         }
12928 
12929         if (m_node-&gt;isBinaryUseKind(Int52RepUse)) {
12930             Int52Kind kind;
12931             LValue left = lowWhicheverInt52(m_node-&gt;child1(), kind);
12932             LValue right = lowInt52(m_node-&gt;child2(), kind);
12933             setBoolean(intFunctor(left, right));
12934             return;
12935         }
12936 
12937         if (m_node-&gt;isBinaryUseKind(DoubleRepUse)) {
12938             LValue left = lowDouble(m_node-&gt;child1());
12939             LValue right = lowDouble(m_node-&gt;child2());
12940             setBoolean(doubleFunctor(left, right));
12941             return;
12942         }
12943 
12944         if (m_node-&gt;isBinaryUseKind(StringIdentUse)) {
12945             LValue left = lowStringIdent(m_node-&gt;child1());
12946             LValue right = lowStringIdent(m_node-&gt;child2());
12947             setBoolean(m_out.callWithoutSideEffects(Int32, stringIdentFunction, left, right));
12948             return;
12949         }
12950 
12951         if (m_node-&gt;isBinaryUseKind(StringUse)) {
12952             LValue left = lowCell(m_node-&gt;child1());
12953             LValue right = lowCell(m_node-&gt;child2());
12954             speculateString(m_node-&gt;child1(), left);
12955             speculateString(m_node-&gt;child2(), right);
12956 
12957             LValue result = vmCall(
<a name="500" id="anc500"></a><span class="line-modified">12958                 Int32, stringFunction,</span>
<span class="line-modified">12959                 weakPointer(globalObject), left, right);</span>
12960             setBoolean(result);
12961             return;
12962         }
12963 
12964         DFG_ASSERT(m_graph, m_node, m_node-&gt;isBinaryUseKind(UntypedUse), m_node-&gt;child1().useKind(), m_node-&gt;child2().useKind());
12965         nonSpeculativeCompare(intFunctor, fallbackFunction);
12966     }
12967 
12968     void compileStringSlice()
12969     {
<a name="501" id="anc501"></a><span class="line-added">12970         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
12971         LBasicBlock lengthCheckCase = m_out.newBlock();
12972         LBasicBlock emptyCase = m_out.newBlock();
12973         LBasicBlock notEmptyCase = m_out.newBlock();
12974         LBasicBlock oneCharCase = m_out.newBlock();
12975         LBasicBlock is8Bit = m_out.newBlock();
12976         LBasicBlock is16Bit = m_out.newBlock();
12977         LBasicBlock bitsContinuation = m_out.newBlock();
12978         LBasicBlock bigCharacter = m_out.newBlock();
12979         LBasicBlock slowCase = m_out.newBlock();
12980         LBasicBlock ropeSlowCase = m_out.newBlock();
12981         LBasicBlock continuation = m_out.newBlock();
12982 
12983         LValue string = lowString(m_node-&gt;child1());
12984         LValue start = lowInt32(m_node-&gt;child2());
12985         LValue end = nullptr;
12986         if (m_node-&gt;child3())
12987             end = lowInt32(m_node-&gt;child3());
12988         else
12989             end = m_out.constInt32(std::numeric_limits&lt;int32_t&gt;::max());
12990         m_out.branch(isRopeString(string, m_node-&gt;child1()), rarely(ropeSlowCase), usually(lengthCheckCase));
12991 
12992         LBasicBlock lastNext = m_out.appendTo(lengthCheckCase, emptyCase);
12993         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
12994         LValue length = m_out.load32NonNegative(stringImpl, m_heaps.StringImpl_length);
12995         auto range = populateSliceRange(start, end, length);
12996         LValue from = range.first;
12997         LValue to = range.second;
12998         LValue span = m_out.sub(to, from);
12999         m_out.branch(m_out.lessThanOrEqual(span, m_out.int32Zero), unsure(emptyCase), unsure(notEmptyCase));
13000 
13001         Vector&lt;ValueFromBlock, 5&gt; results;
13002 
13003         m_out.appendTo(emptyCase, notEmptyCase);
13004         results.append(m_out.anchor(weakPointer(jsEmptyString(vm()))));
13005         m_out.jump(continuation);
13006 
13007         m_out.appendTo(notEmptyCase, oneCharCase);
13008         m_out.branch(m_out.equal(span, m_out.int32One), unsure(oneCharCase), unsure(slowCase));
13009 
13010         m_out.appendTo(oneCharCase, is8Bit);
13011         LValue storage = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
13012         m_out.branch(
13013             m_out.testIsZero32(
13014                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
13015                 m_out.constInt32(StringImpl::flagIs8Bit())),
13016             unsure(is16Bit), unsure(is8Bit));
13017 
13018         m_out.appendTo(is8Bit, is16Bit);
13019         ValueFromBlock char8Bit = m_out.anchor(m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, storage, m_out.zeroExtPtr(from))));
13020         m_out.jump(bitsContinuation);
13021 
13022         m_out.appendTo(is16Bit, bigCharacter);
13023         LValue char16BitValue = m_out.load16ZeroExt32(m_out.baseIndex(m_heaps.characters16, storage, m_out.zeroExtPtr(from)));
13024         ValueFromBlock char16Bit = m_out.anchor(char16BitValue);
13025         m_out.branch(
13026             m_out.above(char16BitValue, m_out.constInt32(maxSingleCharacterString)),
13027             rarely(bigCharacter), usually(bitsContinuation));
13028 
13029         m_out.appendTo(bigCharacter, bitsContinuation);
13030         results.append(m_out.anchor(vmCall(
<a name="502" id="anc502"></a><span class="line-modified">13031             Int64, operationSingleCharacterString,</span>
<span class="line-modified">13032             m_vmValue, char16BitValue)));</span>
13033         m_out.jump(continuation);
13034 
13035         m_out.appendTo(bitsContinuation, slowCase);
13036         LValue character = m_out.phi(Int32, char8Bit, char16Bit);
13037         LValue smallStrings = m_out.constIntPtr(vm().smallStrings.singleCharacterStrings());
13038         results.append(m_out.anchor(m_out.loadPtr(m_out.baseIndex(
13039             m_heaps.singleCharacterStrings, smallStrings, m_out.zeroExtPtr(character)))));
13040         m_out.jump(continuation);
13041 
13042         m_out.appendTo(slowCase, ropeSlowCase);
<a name="503" id="anc503"></a><span class="line-modified">13043         results.append(m_out.anchor(vmCall(pointerType(), operationStringSubstr, weakPointer(globalObject), string, from, span)));</span>
13044         m_out.jump(continuation);
13045 
13046         m_out.appendTo(ropeSlowCase, continuation);
<a name="504" id="anc504"></a><span class="line-modified">13047         results.append(m_out.anchor(vmCall(pointerType(), operationStringSlice, weakPointer(globalObject), string, start, end)));</span>
13048         m_out.jump(continuation);
13049 
13050         m_out.appendTo(continuation, lastNext);
13051         setJSValue(m_out.phi(pointerType(), results));
13052     }
13053 
13054     void compileToLowerCase()
13055     {
<a name="505" id="anc505"></a><span class="line-added">13056         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13057         LBasicBlock notRope = m_out.newBlock();
13058         LBasicBlock is8Bit = m_out.newBlock();
13059         LBasicBlock loopTop = m_out.newBlock();
13060         LBasicBlock loopBody = m_out.newBlock();
13061         LBasicBlock slowPath = m_out.newBlock();
13062         LBasicBlock continuation = m_out.newBlock();
13063 
13064         LValue string = lowString(m_node-&gt;child1());
13065         ValueFromBlock startIndex = m_out.anchor(m_out.constInt32(0));
13066         ValueFromBlock startIndexForCall = m_out.anchor(m_out.constInt32(0));
13067         m_out.branch(isRopeString(string, m_node-&gt;child1()),
13068             unsure(slowPath), unsure(notRope));
13069 
13070         LBasicBlock lastNext = m_out.appendTo(notRope, is8Bit);
13071         LValue impl = m_out.loadPtr(string, m_heaps.JSString_value);
13072         m_out.branch(
13073             m_out.testIsZero32(
13074                 m_out.load32(impl, m_heaps.StringImpl_hashAndFlags),
13075                 m_out.constInt32(StringImpl::flagIs8Bit())),
13076             unsure(slowPath), unsure(is8Bit));
13077 
13078         m_out.appendTo(is8Bit, loopTop);
13079         LValue length = m_out.load32(impl, m_heaps.StringImpl_length);
13080         LValue buffer = m_out.loadPtr(impl, m_heaps.StringImpl_data);
13081         ValueFromBlock fastResult = m_out.anchor(string);
13082         m_out.jump(loopTop);
13083 
13084         m_out.appendTo(loopTop, loopBody);
13085         LValue index = m_out.phi(Int32, startIndex);
13086         ValueFromBlock indexFromBlock = m_out.anchor(index);
13087         m_out.branch(m_out.below(index, length),
13088             unsure(loopBody), unsure(continuation));
13089 
13090         m_out.appendTo(loopBody, slowPath);
13091 
13092         // FIXME: Strings needs to be caged.
13093         // https://bugs.webkit.org/show_bug.cgi?id=174924
13094         LValue byte = m_out.load8ZeroExt32(m_out.baseIndex(m_heaps.characters8, buffer, m_out.zeroExtPtr(index)));
13095         LValue isInvalidAsciiRange = m_out.bitAnd(byte, m_out.constInt32(~0x7F));
13096         LValue isUpperCase = m_out.belowOrEqual(m_out.sub(byte, m_out.constInt32(&#39;A&#39;)), m_out.constInt32(&#39;Z&#39; - &#39;A&#39;));
13097         LValue isBadCharacter = m_out.bitOr(isInvalidAsciiRange, isUpperCase);
13098         m_out.addIncomingToPhi(index, m_out.anchor(m_out.add(index, m_out.int32One)));
13099         m_out.branch(isBadCharacter, unsure(slowPath), unsure(loopTop));
13100 
13101         m_out.appendTo(slowPath, continuation);
13102         LValue slowPathIndex = m_out.phi(Int32, startIndexForCall, indexFromBlock);
<a name="506" id="anc506"></a><span class="line-modified">13103         ValueFromBlock slowResult = m_out.anchor(vmCall(pointerType(), operationToLowerCase, weakPointer(globalObject), string, slowPathIndex));</span>
13104         m_out.jump(continuation);
13105 
13106         m_out.appendTo(continuation, lastNext);
13107         setJSValue(m_out.phi(pointerType(), fastResult, slowResult));
13108     }
13109 
13110     void compileNumberToStringWithRadix()
13111     {
13112         bool validRadixIsGuaranteed = false;
13113         if (m_node-&gt;child2()-&gt;isInt32Constant()) {
13114             int32_t radix = m_node-&gt;child2()-&gt;asInt32();
13115             if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
13116                 validRadixIsGuaranteed = true;
13117         }
13118 
<a name="507" id="anc507"></a><span class="line-added">13119         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13120         switch (m_node-&gt;child1().useKind()) {
13121         case Int32Use:
<a name="508" id="anc508"></a><span class="line-modified">13122             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
13123             break;
13124         case Int52RepUse:
<a name="509" id="anc509"></a><span class="line-modified">13125             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
13126             break;
13127         case DoubleRepUse:
<a name="510" id="anc510"></a><span class="line-modified">13128             setJSValue(vmCall(pointerType(), validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), lowInt32(m_node-&gt;child2())));</span>
13129             break;
13130         default:
13131             RELEASE_ASSERT_NOT_REACHED();
13132         }
13133     }
13134 
13135     void compileNumberToStringWithValidRadixConstant()
13136     {
<a name="511" id="anc511"></a><span class="line-added">13137         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13138         switch (m_node-&gt;child1().useKind()) {
13139         case Int32Use:
<a name="512" id="anc512"></a><span class="line-modified">13140             setJSValue(vmCall(pointerType(), operationInt32ToStringWithValidRadix, weakPointer(globalObject), lowInt32(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
13141             break;
13142         case Int52RepUse:
<a name="513" id="anc513"></a><span class="line-modified">13143             setJSValue(vmCall(pointerType(), operationInt52ToStringWithValidRadix, weakPointer(globalObject), lowStrictInt52(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
13144             break;
13145         case DoubleRepUse:
<a name="514" id="anc514"></a><span class="line-modified">13146             setJSValue(vmCall(pointerType(), operationDoubleToStringWithValidRadix, weakPointer(globalObject), lowDouble(m_node-&gt;child1()), m_out.constInt32(m_node-&gt;validRadixConstant())));</span>
13147             break;
13148         default:
13149             RELEASE_ASSERT_NOT_REACHED();
13150         }
13151     }
13152 
13153     void compileResolveScopeForHoistingFuncDeclInEval()
13154     {
<a name="515" id="anc515"></a><span class="line-added">13155         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13156         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="516" id="anc516"></a><span class="line-modified">13157         setJSValue(vmCall(pointerType(), operationResolveScopeForHoistingFuncDeclInEval, weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
13158     }
13159 
13160     void compileResolveScope()
13161     {
<a name="517" id="anc517"></a><span class="line-added">13162         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13163         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="518" id="anc518"></a><span class="line-modified">13164         setJSValue(vmCall(pointerType(), operationResolveScope,</span>
<span class="line-modified">13165             weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid)));</span>
13166     }
13167 
13168     void compileGetDynamicVar()
13169     {
<a name="519" id="anc519"></a><span class="line-added">13170         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13171         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="520" id="anc520"></a><span class="line-modified">13172         setJSValue(vmCall(Int64, operationGetDynamicVar,</span>
<span class="line-modified">13173             weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
13174     }
13175 
13176     void compilePutDynamicVar()
13177     {
<a name="521" id="anc521"></a><span class="line-added">13178         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13179         UniquedStringImpl* uid = m_graph.identifiers()[m_node-&gt;identifierNumber()];
<a name="522" id="anc522"></a><span class="line-modified">13180         setJSValue(vmCall(Void, m_graph.isStrictModeFor(m_node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict,</span>
<span class="line-modified">13181             weakPointer(globalObject), lowCell(m_node-&gt;child1()), lowJSValue(m_node-&gt;child2()), m_out.constIntPtr(uid), m_out.constInt32(m_node-&gt;getPutInfo())));</span>
13182     }
13183 
13184     void compileUnreachable()
13185     {
13186         // It&#39;s so tempting to assert that AI has proved that this is unreachable. But that&#39;s
13187         // simply not a requirement of the Unreachable opcode at all. If you emit an opcode that
13188         // *you* know will not return, then it&#39;s fine to end the basic block with Unreachable
13189         // after that opcode. You don&#39;t have to also prove to AI that your opcode does not return.
13190         // Hence, there is nothing to do here but emit code that will crash, so that we catch
13191         // cases where you said Unreachable but you lied.
13192         //
13193         // It&#39;s also also worth noting that some clients emit this opcode because they&#39;re not 100% sure
13194         // if the code is unreachable, but they would really prefer if we crashed rather than kept going
13195         // if it did turn out to be reachable. Hence, this needs to deterministically crash.
13196 
13197         crash();
13198     }
13199 
13200     void compileCheckSubClass()
13201     {
13202         LValue cell = lowCell(m_node-&gt;child1());
13203 
13204         const ClassInfo* classInfo = m_node-&gt;classInfo();
13205         if (!classInfo-&gt;checkSubClassSnippet) {
13206             LBasicBlock loop = m_out.newBlock();
13207             LBasicBlock parentClass = m_out.newBlock();
13208             LBasicBlock continuation = m_out.newBlock();
13209 
13210             LValue structure = loadStructure(cell);
13211             LValue classInfo = m_out.loadPtr(structure, m_heaps.Structure_classInfo);
13212             ValueFromBlock otherAtStart = m_out.anchor(classInfo);
13213             m_out.jump(loop);
13214 
13215             LBasicBlock lastNext = m_out.appendTo(loop, parentClass);
13216             LValue other = m_out.phi(pointerType(), otherAtStart);
13217             m_out.branch(m_out.equal(other, m_out.constIntPtr(classInfo)), unsure(continuation), unsure(parentClass));
13218 
13219             m_out.appendTo(parentClass, continuation);
13220             LValue parent = m_out.loadPtr(other, m_heaps.ClassInfo_parentClass);
13221             speculate(BadType, jsValueValue(cell), m_node-&gt;child1().node(), m_out.isNull(parent));
13222             m_out.addIncomingToPhi(other, m_out.anchor(parent));
13223             m_out.jump(loop);
13224 
13225             m_out.appendTo(continuation, lastNext);
13226             return;
13227         }
13228 
13229         RefPtr&lt;Snippet&gt; domJIT = classInfo-&gt;checkSubClassSnippet();
13230         PatchpointValue* patchpoint = m_out.patchpoint(Void);
13231         patchpoint-&gt;appendSomeRegister(cell);
<a name="523" id="anc523"></a><span class="line-modified">13232         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">13233         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
13234 
13235         NodeOrigin origin = m_origin;
13236         unsigned osrExitArgumentOffset = patchpoint-&gt;numChildren();
13237         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(jsValueValue(cell), m_node-&gt;child1().node());
13238         patchpoint-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, jsValueValue(cell)));
13239 
13240         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
13241         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
13242         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13243 
13244         State* state = &amp;m_ftlState;
13245         Node* node = m_node;
13246         JSValue child1Constant = m_state.forNode(m_node-&gt;child1()).value();
13247 
13248         patchpoint-&gt;setGenerator(
13249             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13250                 AllowMacroScratchRegisterUsage allowScratch(jit);
13251 
13252                 Vector&lt;GPRReg&gt; gpScratch;
13253                 Vector&lt;FPRReg&gt; fpScratch;
13254                 Vector&lt;SnippetParams::Value&gt; regs;
13255 
13256                 regs.append(SnippetParams::Value(params[0].gpr(), child1Constant));
13257 
13258                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
13259                     gpScratch.append(params.gpScratch(i));
13260 
13261                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
13262                     fpScratch.append(params.fpScratch(i));
13263 
13264                 RefPtr&lt;OSRExitHandle&gt; handle = exitDescriptor-&gt;emitOSRExitLater(*state, BadType, origin, params, osrExitArgumentOffset);
13265 
13266                 SnippetParams domJITParams(*state, params, node, nullptr, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
13267                 CCallHelpers::JumpList failureCases = domJIT-&gt;generator()-&gt;run(jit, domJITParams);
13268 
13269                 jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
13270                     linkBuffer.link(failureCases, linkBuffer.locationOf&lt;NoPtrTag&gt;(handle-&gt;label));
13271                 });
13272             });
13273         patchpoint-&gt;effects = Effects::forCheck();
13274     }
13275 
13276     void compileCallDOM()
13277     {
<a name="524" id="anc524"></a><span class="line-added">13278         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13279         const DOMJIT::Signature* signature = m_node-&gt;signature();
13280 
13281         // FIXME: We should have a way to call functions with the vector of registers.
13282         // https://bugs.webkit.org/show_bug.cgi?id=163099
13283         Vector&lt;LValue, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
13284 
13285         unsigned index = 0;
13286         DFG_NODE_DO_TO_CHILDREN(m_graph, m_node, [&amp;](Node*, Edge edge) {
13287             if (!index)
13288                 operands.append(lowCell(edge));
13289             else {
13290                 switch (signature-&gt;arguments[index - 1]) {
13291                 case SpecString:
13292                     operands.append(lowString(edge));
13293                     break;
13294                 case SpecInt32Only:
13295                     operands.append(lowInt32(edge));
13296                     break;
13297                 case SpecBoolean:
13298                     operands.append(lowBoolean(edge));
13299                     break;
13300                 default:
13301                     RELEASE_ASSERT_NOT_REACHED();
13302                     break;
13303                 }
13304             }
13305             ++index;
13306         });
13307 
13308         unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
13309         LValue result;
<a name="525" id="anc525"></a><span class="line-added">13310         // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">13311         // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
13312         auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
13313         switch (argumentCountIncludingThis) {
13314         case 1:
<a name="526" id="anc526"></a><span class="line-modified">13315             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GP&gt;(function.get()), weakPointer(globalObject), operands[0]);</span>
13316             break;
13317         case 2:
<a name="527" id="anc527"></a><span class="line-modified">13318             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GPP&gt;(function.get()), weakPointer(globalObject), operands[0], operands[1]);</span>
13319             break;
13320         case 3:
<a name="528" id="anc528"></a><span class="line-modified">13321             result = vmCall(Int64, reinterpret_cast&lt;J_JITOperation_GPPP&gt;(function.get()), weakPointer(globalObject), operands[0], operands[1], operands[2]);</span>
13322             break;
13323         default:
13324             RELEASE_ASSERT_NOT_REACHED();
13325             break;
13326         }
13327 
13328         setJSValue(result);
13329     }
13330 
13331     void compileCallDOMGetter()
13332     {
13333         DOMJIT::CallDOMGetterSnippet* domJIT = m_node-&gt;callDOMGetterData()-&gt;snippet;
13334         if (!domJIT) {
13335             // The following function is not an operation: we directly call a custom accessor getter.
13336             // Since the getter does not have code setting topCallFrame, As is the same to IC, we should set topCallFrame in caller side.
<a name="529" id="anc529"></a><span class="line-added">13337             // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">13338             // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
<span class="line-added">13339             JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13340             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));
13341             setJSValue(
<a name="530" id="anc530"></a><span class="line-modified">13342                 vmCall(Int64, bitwise_cast&lt;CustomGetterSetter::CustomGetter&gt;(m_node-&gt;callDOMGetterData()-&gt;customAccessorGetter.retaggedExecutableAddress&lt;CFunctionPtrTag&gt;()),</span>
<span class="line-modified">13343                     weakPointer(globalObject), lowCell(m_node-&gt;child1()), m_out.constIntPtr(m_graph.identifiers()[m_node-&gt;callDOMGetterData()-&gt;identifierNumber])));</span>
13344             return;
13345         }
13346 
13347         Edge&amp; baseEdge = m_node-&gt;child1();
13348         LValue base = lowCell(baseEdge);
13349         JSValue baseConstant = m_state.forNode(baseEdge).value();
13350 
<a name="531" id="anc531"></a><span class="line-modified">13351         LValue globalObject = nullptr;</span>
13352         JSValue globalObjectConstant;
13353         if (domJIT-&gt;requireGlobalObject) {
13354             Edge&amp; globalObjectEdge = m_node-&gt;child2();
13355             globalObject = lowCell(globalObjectEdge);
13356             globalObjectConstant = m_state.forNode(globalObjectEdge).value();
13357         }
13358 
13359         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13360         patchpoint-&gt;appendSomeRegister(base);
13361         if (domJIT-&gt;requireGlobalObject)
13362             patchpoint-&gt;appendSomeRegister(globalObject);
<a name="532" id="anc532"></a><span class="line-modified">13363         patchpoint-&gt;append(m_notCellMask, ValueRep::reg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">13364         patchpoint-&gt;append(m_numberTag, ValueRep::reg(GPRInfo::numberTagRegister));</span>
13365         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle = preparePatchpointForExceptions(patchpoint);
13366         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
13367         patchpoint-&gt;numGPScratchRegisters = domJIT-&gt;numGPScratchRegisters;
13368         patchpoint-&gt;numFPScratchRegisters = domJIT-&gt;numFPScratchRegisters;
13369         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
13370 
13371         State* state = &amp;m_ftlState;
13372         Node* node = m_node;
13373         patchpoint-&gt;setGenerator(
13374             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13375                 AllowMacroScratchRegisterUsage allowScratch(jit);
13376 
13377                 Vector&lt;GPRReg&gt; gpScratch;
13378                 Vector&lt;FPRReg&gt; fpScratch;
13379                 Vector&lt;SnippetParams::Value&gt; regs;
13380 
13381                 regs.append(JSValueRegs(params[0].gpr()));
13382                 regs.append(SnippetParams::Value(params[1].gpr(), baseConstant));
13383                 if (domJIT-&gt;requireGlobalObject)
13384                     regs.append(SnippetParams::Value(params[2].gpr(), globalObjectConstant));
13385 
13386                 for (unsigned i = 0; i &lt; domJIT-&gt;numGPScratchRegisters; ++i)
13387                     gpScratch.append(params.gpScratch(i));
13388 
13389                 for (unsigned i = 0; i &lt; domJIT-&gt;numFPScratchRegisters; ++i)
13390                     fpScratch.append(params.fpScratch(i));
13391 
13392                 Box&lt;CCallHelpers::JumpList&gt; exceptions = exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
13393 
13394                 SnippetParams domJITParams(*state, params, node, exceptions, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
13395                 domJIT-&gt;generator()-&gt;run(jit, domJITParams);
13396             });
13397         patchpoint-&gt;effects = Effects::forCall();
13398         setJSValue(patchpoint);
13399     }
13400 
13401     void compileFilterICStatus()
13402     {
13403         m_interpreter.filterICStatus(m_node);
13404     }
13405 
13406     LValue byteSwap32(LValue value)
13407     {
13408         // FIXME: teach B3 byteswap
13409         // https://bugs.webkit.org/show_bug.cgi?id=188759
13410 
13411         RELEASE_ASSERT(value-&gt;type() == Int32);
13412         PatchpointValue* patchpoint = m_out.patchpoint(Int32);
13413         patchpoint-&gt;appendSomeRegister(value);
13414         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13415             jit.move(params[1].gpr(), params[0].gpr());
13416             jit.byteSwap32(params[0].gpr());
13417         });
13418         patchpoint-&gt;effects = Effects::none();
13419         return patchpoint;
13420     }
13421 
13422     LValue byteSwap64(LValue value)
13423     {
13424         // FIXME: teach B3 byteswap
13425         // https://bugs.webkit.org/show_bug.cgi?id=188759
13426 
13427         RELEASE_ASSERT(value-&gt;type() == Int64);
13428         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
13429         patchpoint-&gt;appendSomeRegister(value);
13430         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13431             jit.move(params[1].gpr(), params[0].gpr());
13432             jit.byteSwap64(params[0].gpr());
13433         });
13434         patchpoint-&gt;effects = Effects::none();
13435         return patchpoint;
13436     }
13437 
13438     template &lt;typename F1, typename F2&gt;
13439     LValue emitCodeBasedOnEndiannessBranch(LValue isLittleEndian, const F1&amp; emitLittleEndianCode, const F2&amp; emitBigEndianCode)
13440     {
13441         LType type;
13442 
13443         LBasicBlock bigEndianCase = m_out.newBlock();
13444         LBasicBlock littleEndianCase = m_out.newBlock();
13445         LBasicBlock continuation = m_out.newBlock();
13446 
13447         m_out.branch(m_out.testIsZero32(isLittleEndian, m_out.constInt32(1)),
13448             unsure(bigEndianCase), unsure(littleEndianCase));
13449 
13450         LBasicBlock lastNext = m_out.appendTo(bigEndianCase, littleEndianCase);
13451         LValue bigEndianValue = emitBigEndianCode();
13452         type = bigEndianValue ? bigEndianValue-&gt;type() : Void;
13453         ValueFromBlock bigEndianResult = bigEndianValue ? m_out.anchor(bigEndianValue) : ValueFromBlock();
13454         m_out.jump(continuation);
13455 
13456         m_out.appendTo(littleEndianCase, continuation);
13457         LValue littleEndianValue = emitLittleEndianCode();
13458         ValueFromBlock littleEndianResult = littleEndianValue ? m_out.anchor(littleEndianValue) : ValueFromBlock();
13459         RELEASE_ASSERT((!littleEndianValue &amp;&amp; !bigEndianValue) || type == littleEndianValue-&gt;type());
13460         m_out.jump(continuation);
13461 
13462         m_out.appendTo(continuation, lastNext);
13463         RELEASE_ASSERT(!!bigEndianResult == !!littleEndianResult);
13464         if (bigEndianResult)
13465             return m_out.phi(type, bigEndianResult, littleEndianResult);
13466         return nullptr;
13467     }
13468 
13469     void compileDataViewGet()
13470     {
13471         LValue dataView = lowDataViewObject(m_node-&gt;child1());
13472         LValue index = lowInt32(m_node-&gt;child2());
13473         LValue isLittleEndian = nullptr;
13474         if (m_node-&gt;child3())
13475             isLittleEndian = lowBoolean(m_node-&gt;child3());
13476 
13477         DataViewData data = m_node-&gt;dataViewData();
13478 
13479         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
13480         LValue indexToCheck = m_out.zeroExtPtr(index);
13481         if (data.byteSize &gt; 1)
13482             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
13483         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
13484 
13485         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);
13486 
13487         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
13488 
13489         if (m_node-&gt;op() == DataViewGetInt) {
13490             switch (data.byteSize) {
13491             case 1:
13492                 if (data.isSigned)
13493                     setInt32(m_out.load8SignExt32(pointer));
13494                 else
13495                     setInt32(m_out.load8ZeroExt32(pointer));
13496                 break;
13497             case 2: {
13498                 auto emitLittleEndianLoad = [&amp;] {
13499                     if (data.isSigned)
13500                         return m_out.load16SignExt32(pointer);
13501                     return m_out.load16ZeroExt32(pointer);
13502                 };
13503 
13504                 auto emitBigEndianLoad = [&amp;] {
13505                     LValue val = m_out.load16ZeroExt32(pointer);
13506 
13507                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
13508                     patchpoint-&gt;appendSomeRegister(val);
13509                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13510                         jit.move(params[1].gpr(), params[0].gpr());
13511                         jit.byteSwap16(params[0].gpr());
13512                         if (data.isSigned)
13513                             jit.signExtend16To32(params[0].gpr(), params[0].gpr());
13514                     });
13515                     patchpoint-&gt;effects = Effects::none();
13516 
13517                     return patchpoint;
13518                 };
13519 
13520                 if (data.isLittleEndian == FalseTriState)
13521                     setInt32(emitBigEndianLoad());
13522                 else if (data.isLittleEndian == TrueTriState)
13523                     setInt32(emitLittleEndianLoad());
13524                 else
13525                     setInt32(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianLoad, emitBigEndianLoad));
13526 
13527                 break;
13528             }
13529             case 4: {
13530                 LValue loadedValue = m_out.load32(pointer);
13531 
13532                 if (data.isLittleEndian == FalseTriState)
13533                     loadedValue = byteSwap32(loadedValue);
13534                 else if (data.isLittleEndian == MixedTriState) {
13535                     auto emitLittleEndianCode = [&amp;] {
13536                         return loadedValue;
13537                     };
13538                     auto emitBigEndianCode = [&amp;] {
13539                         return byteSwap32(loadedValue);
13540                     };
13541 
13542                     loadedValue = emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13543                 }
13544 
13545                 if (data.isSigned)
13546                     setInt32(loadedValue);
13547                 else
13548                     setStrictInt52(m_out.zeroExt(loadedValue, Int64));
13549 
13550                 break;
13551             }
13552             default:
13553                 RELEASE_ASSERT_NOT_REACHED();
13554             }
13555         } else {
13556             switch (data.byteSize) {
13557             case 4: {
13558                 auto emitLittleEndianCode = [&amp;] {
13559                     return m_out.floatToDouble(m_out.loadFloat(pointer));
13560                 };
13561 
13562                 auto emitBigEndianCode = [&amp;] {
13563                     LValue loadedValue = m_out.load32(pointer);
13564                     PatchpointValue* patchpoint = m_out.patchpoint(Double);
13565                     patchpoint-&gt;appendSomeRegister(loadedValue);
13566                     patchpoint-&gt;numGPScratchRegisters = 1;
13567                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13568                         jit.move(params[1].gpr(), params.gpScratch(0));
13569                         jit.byteSwap32(params.gpScratch(0));
13570                         jit.move32ToFloat(params.gpScratch(0), params[0].fpr());
13571                         jit.convertFloatToDouble(params[0].fpr(), params[0].fpr());
13572                     });
13573                     patchpoint-&gt;effects = Effects::none();
13574                     return patchpoint;
13575                 };
13576 
13577                 if (data.isLittleEndian == TrueTriState)
13578                     setDouble(emitLittleEndianCode());
13579                 else if (data.isLittleEndian == FalseTriState)
13580                     setDouble(emitBigEndianCode());
13581                 else
13582                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
13583 
13584                 break;
13585             }
13586             case 8: {
13587                 auto emitLittleEndianCode = [&amp;] {
13588                     return m_out.loadDouble(pointer);
13589                 };
13590 
13591                 auto emitBigEndianCode = [&amp;] {
13592                     LValue loadedValue = m_out.load64(pointer);
13593                     loadedValue = byteSwap64(loadedValue);
13594                     return m_out.bitCast(loadedValue, Double);
13595                 };
13596 
13597                 if (data.isLittleEndian == TrueTriState)
13598                     setDouble(emitLittleEndianCode());
13599                 else if (data.isLittleEndian == FalseTriState)
13600                     setDouble(emitBigEndianCode());
13601                 else
13602                     setDouble(emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode));
13603 
13604                 break;
13605             }
13606             default:
13607                 RELEASE_ASSERT_NOT_REACHED();
13608             }
13609         }
13610     }
13611 
13612     void compileDataViewSet()
13613     {
13614         LValue dataView = lowDataViewObject(m_graph.varArgChild(m_node, 0));
13615         LValue index = lowInt32(m_graph.varArgChild(m_node, 1));
13616         LValue isLittleEndian = nullptr;
13617         if (m_graph.varArgChild(m_node, 3))
13618             isLittleEndian = lowBoolean(m_graph.varArgChild(m_node, 3));
13619 
13620         DataViewData data = m_node-&gt;dataViewData();
13621 
13622         LValue length = m_out.zeroExtPtr(m_out.load32NonNegative(dataView, m_heaps.JSArrayBufferView_length));
13623         LValue indexToCheck = m_out.zeroExtPtr(index);
13624         if (data.byteSize &gt; 1)
13625             indexToCheck = m_out.add(indexToCheck, m_out.constInt64(data.byteSize - 1));
13626         speculate(OutOfBounds, noValue(), nullptr, m_out.aboveOrEqual(indexToCheck, length));
13627 
13628         Edge&amp; valueEdge = m_graph.varArgChild(m_node, 2);
13629         LValue valueToStore;
13630         switch (valueEdge.useKind()) {
13631         case Int32Use:
13632             valueToStore = lowInt32(valueEdge);
13633             break;
13634         case DoubleRepUse:
13635             valueToStore = lowDouble(valueEdge);
13636             break;
13637         case Int52RepUse:
13638             valueToStore = lowStrictInt52(valueEdge);
13639             break;
13640         default:
13641             RELEASE_ASSERT_NOT_REACHED();
13642         }
13643 
13644         LValue vector = caged(Gigacage::Primitive, m_out.loadPtr(dataView, m_heaps.JSArrayBufferView_vector), dataView);
13645         TypedPointer pointer(m_heaps.typedArrayProperties, m_out.add(vector, m_out.zeroExtPtr(index)));
13646 
13647         if (data.isFloatingPoint) {
13648             if (data.byteSize == 4) {
13649                 valueToStore = m_out.doubleToFloat(valueToStore);
13650 
13651                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
13652                     m_out.storeFloat(valueToStore, pointer);
13653                     return nullptr;
13654                 };
13655 
13656                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
13657                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
13658                     patchpoint-&gt;appendSomeRegister(valueToStore);
13659                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13660                         jit.moveFloatTo32(params[1].fpr(), params[0].gpr());
13661                         jit.byteSwap32(params[0].gpr());
13662                     });
13663                     patchpoint-&gt;effects = Effects::none();
13664                     m_out.store32(patchpoint, pointer);
13665                     return nullptr;
13666                 };
13667 
13668                 if (data.isLittleEndian == FalseTriState)
13669                     emitBigEndianCode();
13670                 else if (data.isLittleEndian == TrueTriState)
13671                     emitLittleEndianCode();
13672                 else
13673                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13674 
13675             } else {
13676                 RELEASE_ASSERT(data.byteSize == 8);
13677                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
13678                     m_out.storeDouble(valueToStore, pointer);
13679                     return nullptr;
13680                 };
13681                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
13682                     m_out.store64(byteSwap64(m_out.bitCast(valueToStore, Int64)), pointer);
13683                     return nullptr;
13684                 };
13685 
13686                 if (data.isLittleEndian == FalseTriState)
13687                     emitBigEndianCode();
13688                 else if (data.isLittleEndian == TrueTriState)
13689                     emitLittleEndianCode();
13690                 else
13691                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13692             }
13693         } else {
13694             switch (data.byteSize) {
13695             case 1:
13696                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
13697                 m_out.store32As8(valueToStore, pointer);
13698                 break;
13699             case 2: {
13700                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
13701 
13702                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
13703                     m_out.store32As16(valueToStore, pointer);
13704                     return nullptr;
13705                 };
13706                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
13707                     PatchpointValue* patchpoint = m_out.patchpoint(Int32);
13708                     patchpoint-&gt;appendSomeRegister(valueToStore);
13709                     patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
13710                         jit.move(params[1].gpr(), params[0].gpr());
13711                         jit.byteSwap16(params[0].gpr());
13712                     });
13713                     patchpoint-&gt;effects = Effects::none();
13714 
13715                     m_out.store32As16(patchpoint, pointer);
13716                     return nullptr;
13717                 };
13718 
13719                 if (data.isLittleEndian == FalseTriState)
13720                     emitBigEndianCode();
13721                 else if (data.isLittleEndian == TrueTriState)
13722                     emitLittleEndianCode();
13723                 else
13724                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13725                 break;
13726             }
13727             case 4: {
13728                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
13729 
13730                 if (valueEdge.useKind() == Int52RepUse)
13731                     valueToStore = m_out.castToInt32(valueToStore);
13732 
13733                 auto emitLittleEndianCode = [&amp;] () -&gt; LValue {
13734                     m_out.store32(valueToStore, pointer);
13735                     return nullptr;
13736                 };
13737                 auto emitBigEndianCode = [&amp;] () -&gt; LValue {
13738                     m_out.store32(byteSwap32(valueToStore), pointer);
13739                     return nullptr;
13740                 };
13741 
13742                 if (data.isLittleEndian == FalseTriState)
13743                     emitBigEndianCode();
13744                 else if (data.isLittleEndian == TrueTriState)
13745                     emitLittleEndianCode();
13746                 else
13747                     emitCodeBasedOnEndiannessBranch(isLittleEndian, emitLittleEndianCode, emitBigEndianCode);
13748 
13749                 break;
13750             }
13751             default:
13752                 RELEASE_ASSERT_NOT_REACHED();
13753             }
13754         }
13755     }
13756 
<a name="533" id="anc533"></a><span class="line-added">13757     void compileDateGet()</span>
<span class="line-added">13758     {</span>
<span class="line-added">13759         LValue base = lowDateObject(m_node-&gt;child1());</span>
<span class="line-added">13760 </span>
<span class="line-added">13761         auto emitGetCodeWithCallback = [&amp;] (const AbstractHeap&amp; cachedDoubleOffset, const AbstractHeap&amp; cachedDataOffset, auto* operation, auto callback) {</span>
<span class="line-added">13762             LBasicBlock dataExistsCase = m_out.newBlock();</span>
<span class="line-added">13763             LBasicBlock fastCase = m_out.newBlock();</span>
<span class="line-added">13764             LBasicBlock slowCase = m_out.newBlock();</span>
<span class="line-added">13765             LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">13766 </span>
<span class="line-added">13767             LValue data = m_out.loadPtr(base, m_heaps.DateInstance_data);</span>
<span class="line-added">13768             m_out.branch(m_out.notZero64(data), unsure(dataExistsCase), unsure(slowCase));</span>
<span class="line-added">13769 </span>
<span class="line-added">13770             LBasicBlock lastNext = m_out.appendTo(dataExistsCase, fastCase);</span>
<span class="line-added">13771             LValue milliseconds = m_out.loadDouble(base, m_heaps.DateInstance_internalNumber);</span>
<span class="line-added">13772             LValue cachedMilliseconds = m_out.loadDouble(data, cachedDoubleOffset);</span>
<span class="line-added">13773             m_out.branch(m_out.doubleNotEqualOrUnordered(milliseconds, cachedMilliseconds), unsure(slowCase), unsure(fastCase));</span>
<span class="line-added">13774 </span>
<span class="line-added">13775             m_out.appendTo(fastCase, slowCase);</span>
<span class="line-added">13776             ValueFromBlock fastResult = m_out.anchor(boxInt32(callback(m_out.load32(data, cachedDataOffset))));</span>
<span class="line-added">13777             m_out.jump(continuation);</span>
<span class="line-added">13778 </span>
<span class="line-added">13779             m_out.appendTo(slowCase, continuation);</span>
<span class="line-added">13780             ValueFromBlock slowResult = m_out.anchor(vmCall(Int64, operation, m_vmValue, base));</span>
<span class="line-added">13781             m_out.jump(continuation);</span>
<span class="line-added">13782 </span>
<span class="line-added">13783             m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">13784             setJSValue(m_out.phi(Int64, fastResult, slowResult));</span>
<span class="line-added">13785         };</span>
<span class="line-added">13786 </span>
<span class="line-added">13787         auto emitGetCode = [&amp;] (const AbstractHeap&amp; cachedDoubleOffset, const AbstractHeap&amp; cachedDataOffset, auto* operation) {</span>
<span class="line-added">13788             emitGetCodeWithCallback(cachedDoubleOffset, cachedDataOffset, operation, [] (LValue value) { return value; });</span>
<span class="line-added">13789         };</span>
<span class="line-added">13790 </span>
<span class="line-added">13791         switch (m_node-&gt;intrinsic()) {</span>
<span class="line-added">13792         case DatePrototypeGetTimeIntrinsic:</span>
<span class="line-added">13793             setDouble(m_out.loadDouble(base, m_heaps.DateInstance_internalNumber));</span>
<span class="line-added">13794             break;</span>
<span class="line-added">13795 </span>
<span class="line-added">13796         case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="line-added">13797         case DatePrototypeGetUTCMillisecondsIntrinsic: {</span>
<span class="line-added">13798             LValue milliseconds = m_out.loadDouble(base, m_heaps.DateInstance_internalNumber);</span>
<span class="line-added">13799             LValue msPerSecondConstant = m_out.constDouble(msPerSecond);</span>
<span class="line-added">13800             LValue seconds = m_out.doubleFloor(m_out.doubleDiv(milliseconds, msPerSecondConstant));</span>
<span class="line-added">13801             LValue result = m_out.doubleToInt(m_out.doubleSub(milliseconds, m_out.doubleMul(seconds, msPerSecondConstant)));</span>
<span class="line-added">13802             setJSValue(m_out.select(m_out.doubleNotEqualOrUnordered(milliseconds, milliseconds), m_out.constInt64(JSValue::encode(jsNaN())), boxInt32(result)));</span>
<span class="line-added">13803             break;</span>
<span class="line-added">13804         }</span>
<span class="line-added">13805 </span>
<span class="line-added">13806         case DatePrototypeGetFullYearIntrinsic:</span>
<span class="line-added">13807             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_year, operationDateGetFullYear);</span>
<span class="line-added">13808             break;</span>
<span class="line-added">13809         case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="line-added">13810             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_year, operationDateGetUTCFullYear);</span>
<span class="line-added">13811             break;</span>
<span class="line-added">13812         case DatePrototypeGetMonthIntrinsic:</span>
<span class="line-added">13813             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_month, operationDateGetMonth);</span>
<span class="line-added">13814             break;</span>
<span class="line-added">13815         case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="line-added">13816             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_month, operationDateGetUTCMonth);</span>
<span class="line-added">13817             break;</span>
<span class="line-added">13818         case DatePrototypeGetDateIntrinsic:</span>
<span class="line-added">13819             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_monthDay, operationDateGetDate);</span>
<span class="line-added">13820             break;</span>
<span class="line-added">13821         case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="line-added">13822             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_monthDay, operationDateGetUTCDate);</span>
<span class="line-added">13823             break;</span>
<span class="line-added">13824         case DatePrototypeGetDayIntrinsic:</span>
<span class="line-added">13825             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_weekDay, operationDateGetDay);</span>
<span class="line-added">13826             break;</span>
<span class="line-added">13827         case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="line-added">13828             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_weekDay, operationDateGetUTCDay);</span>
<span class="line-added">13829             break;</span>
<span class="line-added">13830         case DatePrototypeGetHoursIntrinsic:</span>
<span class="line-added">13831             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_hour, operationDateGetHours);</span>
<span class="line-added">13832             break;</span>
<span class="line-added">13833         case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="line-added">13834             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_hour, operationDateGetUTCHours);</span>
<span class="line-added">13835             break;</span>
<span class="line-added">13836         case DatePrototypeGetMinutesIntrinsic:</span>
<span class="line-added">13837             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_minute, operationDateGetMinutes);</span>
<span class="line-added">13838             break;</span>
<span class="line-added">13839         case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="line-added">13840             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_minute, operationDateGetUTCMinutes);</span>
<span class="line-added">13841             break;</span>
<span class="line-added">13842         case DatePrototypeGetSecondsIntrinsic:</span>
<span class="line-added">13843             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_second, operationDateGetSeconds);</span>
<span class="line-added">13844             break;</span>
<span class="line-added">13845         case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="line-added">13846             emitGetCode(m_heaps.DateInstanceData_gregorianDateTimeUTCCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTimeUTC_second, operationDateGetUTCSeconds);</span>
<span class="line-added">13847             break;</span>
<span class="line-added">13848 </span>
<span class="line-added">13849         case DatePrototypeGetTimezoneOffsetIntrinsic:</span>
<span class="line-added">13850             emitGetCodeWithCallback(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_utcOffsetInMinute, operationDateGetTimezoneOffset, [&amp;] (LValue offset) {</span>
<span class="line-added">13851                 return m_out.neg(offset);</span>
<span class="line-added">13852             });</span>
<span class="line-added">13853             break;</span>
<span class="line-added">13854 </span>
<span class="line-added">13855         case DatePrototypeGetYearIntrinsic:</span>
<span class="line-added">13856             emitGetCodeWithCallback(m_heaps.DateInstanceData_gregorianDateTimeCachedForMS, m_heaps.DateInstanceData_cachedGregorianDateTime_year, operationDateGetYear, [&amp;] (LValue year) {</span>
<span class="line-added">13857                 return m_out.sub(year, m_out.constInt32(1900));</span>
<span class="line-added">13858             });</span>
<span class="line-added">13859             break;</span>
<span class="line-added">13860 </span>
<span class="line-added">13861         default:</span>
<span class="line-added">13862             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">13863         }</span>
<span class="line-added">13864     }</span>
<span class="line-added">13865 </span>
13866     void emitSwitchForMultiByOffset(LValue base, bool structuresChecked, Vector&lt;SwitchCase, 2&gt;&amp; cases, LBasicBlock exit)
13867     {
13868         if (cases.isEmpty()) {
13869             m_out.jump(exit);
13870             return;
13871         }
13872 
13873         if (structuresChecked) {
13874             std::sort(
13875                 cases.begin(), cases.end(),
13876                 [&amp;] (const SwitchCase&amp; a, const SwitchCase&amp; b) -&gt; bool {
13877                     return a.value()-&gt;asInt() &lt; b.value()-&gt;asInt();
13878                 });
13879             SwitchCase last = cases.takeLast();
13880             m_out.switchInstruction(
13881                 m_out.load32(base, m_heaps.JSCell_structureID), cases, last.target(), Weight(0));
13882             return;
13883         }
13884 
13885         m_out.switchInstruction(
13886             m_out.load32(base, m_heaps.JSCell_structureID), cases, exit, Weight(0));
13887     }
13888 
13889     void compareEqObjectOrOtherToObject(Edge leftChild, Edge rightChild)
13890     {
13891         LValue rightCell = lowCell(rightChild);
13892         LValue leftValue = lowJSValue(leftChild, ManualOperandSpeculation);
13893 
13894         speculateTruthyObject(rightChild, rightCell, SpecObject);
13895 
13896         LBasicBlock leftCellCase = m_out.newBlock();
13897         LBasicBlock leftNotCellCase = m_out.newBlock();
13898         LBasicBlock continuation = m_out.newBlock();
13899 
13900         m_out.branch(
13901             isCell(leftValue, provenType(leftChild)),
13902             unsure(leftCellCase), unsure(leftNotCellCase));
13903 
13904         LBasicBlock lastNext = m_out.appendTo(leftCellCase, leftNotCellCase);
13905         speculateTruthyObject(leftChild, leftValue, SpecObject | (~SpecCellCheck));
13906         ValueFromBlock cellResult = m_out.anchor(m_out.equal(rightCell, leftValue));
13907         m_out.jump(continuation);
13908 
13909         m_out.appendTo(leftNotCellCase, continuation);
13910         FTL_TYPE_CHECK(
13911             jsValueValue(leftValue), leftChild, SpecOther | SpecCellCheck, isNotOther(leftValue));
13912         ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
13913         m_out.jump(continuation);
13914 
13915         m_out.appendTo(continuation, lastNext);
13916         setBoolean(m_out.phi(Int32, cellResult, notCellResult));
13917     }
13918 
13919     void speculateTruthyObject(Edge edge, LValue cell, SpeculatedType filter)
13920     {
13921         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
13922             FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
13923             return;
13924         }
13925 
13926         FTL_TYPE_CHECK(jsValueValue(cell), edge, filter, isNotObject(cell));
13927         speculate(
13928             BadType, jsValueValue(cell), edge.node(),
13929             m_out.testNonZero32(
13930                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
13931                 m_out.constInt32(MasqueradesAsUndefined)));
13932     }
13933 
13934     template&lt;typename IntFunctor&gt;
<a name="534" id="anc534"></a><span class="line-modified">13935     void nonSpeculativeCompare(const IntFunctor&amp; intFunctor, S_JITOperation_GJJ helperFunction)</span>
13936     {
<a name="535" id="anc535"></a><span class="line-added">13937         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13938         LValue left = lowJSValue(m_node-&gt;child1());
13939         LValue right = lowJSValue(m_node-&gt;child2());
13940 
13941         LBasicBlock leftIsInt = m_out.newBlock();
13942         LBasicBlock fastPath = m_out.newBlock();
13943         LBasicBlock slowPath = m_out.newBlock();
13944         LBasicBlock continuation = m_out.newBlock();
13945 
13946         m_out.branch(isNotInt32(left, provenType(m_node-&gt;child1())), rarely(slowPath), usually(leftIsInt));
13947 
13948         LBasicBlock lastNext = m_out.appendTo(leftIsInt, fastPath);
13949         m_out.branch(isNotInt32(right, provenType(m_node-&gt;child2())), rarely(slowPath), usually(fastPath));
13950 
13951         m_out.appendTo(fastPath, slowPath);
13952         ValueFromBlock fastResult = m_out.anchor(intFunctor(unboxInt32(left), unboxInt32(right)));
13953         m_out.jump(continuation);
13954 
13955         m_out.appendTo(slowPath, continuation);
13956         ValueFromBlock slowResult = m_out.anchor(m_out.notNull(vmCall(
<a name="536" id="anc536"></a><span class="line-modified">13957             pointerType(), helperFunction, weakPointer(globalObject), left, right)));</span>
13958         m_out.jump(continuation);
13959 
13960         m_out.appendTo(continuation, lastNext);
13961         setBoolean(m_out.phi(Int32, fastResult, slowResult));
13962     }
13963 
13964     LValue stringsEqual(LValue leftJSString, LValue rightJSString, Edge leftJSStringEdge = Edge(), Edge rightJSStringEdge = Edge())
13965     {
<a name="537" id="anc537"></a><span class="line-added">13966         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
13967         LBasicBlock notTriviallyUnequalCase = m_out.newBlock();
13968         LBasicBlock notEmptyCase = m_out.newBlock();
13969         LBasicBlock leftReadyCase = m_out.newBlock();
13970         LBasicBlock rightReadyCase = m_out.newBlock();
13971         LBasicBlock left8BitCase = m_out.newBlock();
13972         LBasicBlock right8BitCase = m_out.newBlock();
13973         LBasicBlock loop = m_out.newBlock();
13974         LBasicBlock bytesEqual = m_out.newBlock();
13975         LBasicBlock trueCase = m_out.newBlock();
13976         LBasicBlock falseCase = m_out.newBlock();
13977         LBasicBlock slowCase = m_out.newBlock();
13978         LBasicBlock continuation = m_out.newBlock();
13979 
13980         m_out.branch(isRopeString(leftJSString, leftJSStringEdge), rarely(slowCase), usually(leftReadyCase));
13981 
13982         LBasicBlock lastNext = m_out.appendTo(leftReadyCase, rightReadyCase);
13983         m_out.branch(isRopeString(rightJSString, rightJSStringEdge), rarely(slowCase), usually(rightReadyCase));
13984 
13985         m_out.appendTo(rightReadyCase, notTriviallyUnequalCase);
13986         LValue left = m_out.loadPtr(leftJSString, m_heaps.JSString_value);
13987         LValue right = m_out.loadPtr(rightJSString, m_heaps.JSString_value);
13988         LValue length = m_out.load32(left, m_heaps.StringImpl_length);
13989         m_out.branch(
13990             m_out.notEqual(length, m_out.load32(right, m_heaps.StringImpl_length)),
13991             unsure(falseCase), unsure(notTriviallyUnequalCase));
13992 
13993         m_out.appendTo(notTriviallyUnequalCase, notEmptyCase);
13994         m_out.branch(m_out.isZero32(length), unsure(trueCase), unsure(notEmptyCase));
13995 
13996         m_out.appendTo(notEmptyCase, left8BitCase);
13997         m_out.branch(
13998             m_out.testIsZero32(
13999                 m_out.load32(left, m_heaps.StringImpl_hashAndFlags),
14000                 m_out.constInt32(StringImpl::flagIs8Bit())),
14001             unsure(slowCase), unsure(left8BitCase));
14002 
14003         m_out.appendTo(left8BitCase, right8BitCase);
14004         m_out.branch(
14005             m_out.testIsZero32(
14006                 m_out.load32(right, m_heaps.StringImpl_hashAndFlags),
14007                 m_out.constInt32(StringImpl::flagIs8Bit())),
14008             unsure(slowCase), unsure(right8BitCase));
14009 
14010         m_out.appendTo(right8BitCase, loop);
14011 
14012         LValue leftData = m_out.loadPtr(left, m_heaps.StringImpl_data);
14013         LValue rightData = m_out.loadPtr(right, m_heaps.StringImpl_data);
14014 
14015         ValueFromBlock indexAtStart = m_out.anchor(length);
14016 
14017         m_out.jump(loop);
14018 
14019         m_out.appendTo(loop, bytesEqual);
14020 
14021         LValue indexAtLoopTop = m_out.phi(Int32, indexAtStart);
14022         LValue indexInLoop = m_out.sub(indexAtLoopTop, m_out.int32One);
14023 
14024         LValue leftByte = m_out.load8ZeroExt32(
14025             m_out.baseIndex(m_heaps.characters8, leftData, m_out.zeroExtPtr(indexInLoop)));
14026         LValue rightByte = m_out.load8ZeroExt32(
14027             m_out.baseIndex(m_heaps.characters8, rightData, m_out.zeroExtPtr(indexInLoop)));
14028 
14029         m_out.branch(m_out.notEqual(leftByte, rightByte), unsure(falseCase), unsure(bytesEqual));
14030 
14031         m_out.appendTo(bytesEqual, trueCase);
14032 
14033         ValueFromBlock indexForNextIteration = m_out.anchor(indexInLoop);
14034         m_out.addIncomingToPhi(indexAtLoopTop, indexForNextIteration);
14035         m_out.branch(m_out.notZero32(indexInLoop), unsure(loop), unsure(trueCase));
14036 
14037         m_out.appendTo(trueCase, falseCase);
14038 
14039         ValueFromBlock trueResult = m_out.anchor(m_out.booleanTrue);
14040         m_out.jump(continuation);
14041 
14042         m_out.appendTo(falseCase, slowCase);
14043 
14044         ValueFromBlock falseResult = m_out.anchor(m_out.booleanFalse);
14045         m_out.jump(continuation);
14046 
14047         m_out.appendTo(slowCase, continuation);
14048 
14049         LValue slowResultValue = vmCall(
<a name="538" id="anc538"></a><span class="line-modified">14050             Int64, operationCompareStringEq, weakPointer(globalObject),</span>
14051             leftJSString, rightJSString);
14052         ValueFromBlock slowResult = m_out.anchor(unboxBoolean(slowResultValue));
14053         m_out.jump(continuation);
14054 
14055         m_out.appendTo(continuation, lastNext);
14056         return m_out.phi(Int32, trueResult, falseResult, slowResult);
14057     }
14058 
14059     enum ScratchFPRUsage {
14060         DontNeedScratchFPR,
14061         NeedScratchFPR
14062     };
14063     template&lt;typename BinaryArithOpGenerator, ScratchFPRUsage scratchFPRUsage = DontNeedScratchFPR&gt;
<a name="539" id="anc539"></a><span class="line-modified">14064     void emitBinarySnippet(J_JITOperation_GJJ slowPathFunction)</span>
14065     {
14066         Node* node = m_node;
14067 
14068         LValue left = lowJSValue(node-&gt;child1());
14069         LValue right = lowJSValue(node-&gt;child2());
14070 
14071         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
14072         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
14073 
14074         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
14075         patchpoint-&gt;appendSomeRegister(left);
14076         patchpoint-&gt;appendSomeRegister(right);
<a name="540" id="anc540"></a><span class="line-modified">14077         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">14078         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
14079         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
14080             preparePatchpointForExceptions(patchpoint);
14081         patchpoint-&gt;numGPScratchRegisters = 1;
14082         patchpoint-&gt;numFPScratchRegisters = 2;
14083         if (scratchFPRUsage == NeedScratchFPR)
14084             patchpoint-&gt;numFPScratchRegisters++;
14085         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14086         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
14087         State* state = &amp;m_ftlState;
14088         patchpoint-&gt;setGenerator(
14089             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14090                 AllowMacroScratchRegisterUsage allowScratch(jit);
14091 
14092                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
14093                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
14094 
14095                 auto generator = Box&lt;BinaryArithOpGenerator&gt;::create(
14096                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
14097                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
14098                     params.fpScratch(0), params.fpScratch(1), params.gpScratch(0),
14099                     scratchFPRUsage == NeedScratchFPR ? params.fpScratch(2) : InvalidFPRReg);
14100 
14101                 generator-&gt;generateFastPath(jit);
14102 
14103                 if (generator-&gt;didEmitFastPath()) {
14104                     generator-&gt;endJumpList().link(&amp;jit);
14105                     CCallHelpers::Label done = jit.label();
14106 
14107                     params.addLatePath(
14108                         [=] (CCallHelpers&amp; jit) {
14109                             AllowMacroScratchRegisterUsage allowScratch(jit);
14110 
14111                             generator-&gt;slowPathJumpList().link(&amp;jit);
14112                             callOperation(
14113                                 *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
14114                                 exceptions.get(), slowPathFunction, params[0].gpr(),
<a name="541" id="anc541"></a><span class="line-added">14115                                 jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
14116                                 params[1].gpr(), params[2].gpr());
14117                             jit.jump().linkTo(done, &amp;jit);
14118                         });
14119                 } else {
14120                     callOperation(
14121                         *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
<a name="542" id="anc542"></a><span class="line-modified">14122                         exceptions.get(), slowPathFunction, params[0].gpr(), jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic), params[1].gpr(),</span>
14123                         params[2].gpr());
14124                 }
14125             });
14126 
14127         setJSValue(patchpoint);
14128     }
14129 
14130     template&lt;typename BinaryBitOpGenerator&gt;
<a name="543" id="anc543"></a><span class="line-modified">14131     void emitBinaryBitOpSnippet(J_JITOperation_GJJ slowPathFunction)</span>
14132     {
14133         Node* node = m_node;
14134 
14135         LValue left = lowJSValue(node-&gt;child1());
14136         LValue right = lowJSValue(node-&gt;child2());
14137 
14138         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
14139         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
14140 
14141         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
14142         patchpoint-&gt;appendSomeRegister(left);
14143         patchpoint-&gt;appendSomeRegister(right);
<a name="544" id="anc544"></a><span class="line-modified">14144         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">14145         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
14146         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
14147             preparePatchpointForExceptions(patchpoint);
14148         patchpoint-&gt;numGPScratchRegisters = 1;
14149         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14150         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
14151         State* state = &amp;m_ftlState;
14152         patchpoint-&gt;setGenerator(
14153             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14154                 AllowMacroScratchRegisterUsage allowScratch(jit);
14155 
14156                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
14157                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
14158 
14159                 auto generator = Box&lt;BinaryBitOpGenerator&gt;::create(
14160                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
14161                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()), params.gpScratch(0));
14162 
14163                 generator-&gt;generateFastPath(jit);
14164                 generator-&gt;endJumpList().link(&amp;jit);
14165                 CCallHelpers::Label done = jit.label();
14166 
14167                 params.addLatePath(
14168                     [=] (CCallHelpers&amp; jit) {
14169                         AllowMacroScratchRegisterUsage allowScratch(jit);
14170 
14171                         generator-&gt;slowPathJumpList().link(&amp;jit);
14172                         callOperation(
14173                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
14174                             exceptions.get(), slowPathFunction, params[0].gpr(),
<a name="545" id="anc545"></a><span class="line-added">14175                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
14176                             params[1].gpr(), params[2].gpr());
14177                         jit.jump().linkTo(done, &amp;jit);
14178                     });
14179             });
14180 
14181         setJSValue(patchpoint);
14182     }
14183 
14184     void emitRightShiftSnippet(JITRightShiftGenerator::ShiftType shiftType)
14185     {
14186         Node* node = m_node;
14187 
14188         // FIXME: Make this do exceptions.
14189         // https://bugs.webkit.org/show_bug.cgi?id=151686
14190 
14191         LValue left = lowJSValue(node-&gt;child1());
14192         LValue right = lowJSValue(node-&gt;child2());
14193 
14194         SnippetOperand leftOperand(m_state.forNode(node-&gt;child1()).resultType());
14195         SnippetOperand rightOperand(m_state.forNode(node-&gt;child2()).resultType());
14196 
14197         PatchpointValue* patchpoint = m_out.patchpoint(Int64);
14198         patchpoint-&gt;appendSomeRegister(left);
14199         patchpoint-&gt;appendSomeRegister(right);
<a name="546" id="anc546"></a><span class="line-modified">14200         patchpoint-&gt;append(m_notCellMask, ValueRep::lateReg(GPRInfo::notCellMaskRegister));</span>
<span class="line-modified">14201         patchpoint-&gt;append(m_numberTag, ValueRep::lateReg(GPRInfo::numberTagRegister));</span>
14202         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
14203             preparePatchpointForExceptions(patchpoint);
14204         patchpoint-&gt;numGPScratchRegisters = 1;
14205         patchpoint-&gt;numFPScratchRegisters = 1;
14206         patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14207         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
14208         State* state = &amp;m_ftlState;
14209         patchpoint-&gt;setGenerator(
14210             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14211                 AllowMacroScratchRegisterUsage allowScratch(jit);
14212 
14213                 Box&lt;CCallHelpers::JumpList&gt; exceptions =
14214                     exceptionHandle-&gt;scheduleExitCreation(params)-&gt;jumps(jit);
14215 
14216                 auto generator = Box&lt;JITRightShiftGenerator&gt;::create(
14217                     leftOperand, rightOperand, JSValueRegs(params[0].gpr()),
14218                     JSValueRegs(params[1].gpr()), JSValueRegs(params[2].gpr()),
14219                     params.fpScratch(0), params.gpScratch(0), InvalidFPRReg, shiftType);
14220 
14221                 generator-&gt;generateFastPath(jit);
14222                 generator-&gt;endJumpList().link(&amp;jit);
14223                 CCallHelpers::Label done = jit.label();
14224 
14225                 params.addLatePath(
14226                     [=] (CCallHelpers&amp; jit) {
14227                         AllowMacroScratchRegisterUsage allowScratch(jit);
14228 
14229                         generator-&gt;slowPathJumpList().link(&amp;jit);
14230 
<a name="547" id="anc547"></a><span class="line-modified">14231                         J_JITOperation_GJJ slowPathFunction =</span>
14232                             shiftType == JITRightShiftGenerator::SignedShift
14233                             ? operationValueBitRShift : operationValueBitURShift;
14234 
14235                         callOperation(
14236                             *state, params.unavailableRegisters(), jit, node-&gt;origin.semantic,
14237                             exceptions.get(), slowPathFunction, params[0].gpr(),
<a name="548" id="anc548"></a><span class="line-added">14238                             jit.codeBlock()-&gt;globalObjectFor(node-&gt;origin.semantic),</span>
14239                             params[1].gpr(), params[2].gpr());
14240                         jit.jump().linkTo(done, &amp;jit);
14241                     });
14242             });
14243 
14244         setJSValue(patchpoint);
14245     }
14246 
14247     LValue allocateHeapCell(LValue allocator, LBasicBlock slowPath)
14248     {
14249         JITAllocator actualAllocator;
14250         if (allocator-&gt;hasIntPtr())
14251             actualAllocator = JITAllocator::constant(Allocator(bitwise_cast&lt;LocalAllocator*&gt;(allocator-&gt;asIntPtr())));
14252         else
14253             actualAllocator = JITAllocator::variable();
14254 
14255         if (actualAllocator.isConstant()) {
14256             if (!actualAllocator.allocator()) {
14257                 LBasicBlock haveAllocator = m_out.newBlock();
14258                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
14259                 m_out.jump(slowPath);
14260                 m_out.appendTo(haveAllocator, lastNext);
14261                 return m_out.intPtrZero;
14262             }
14263         } else {
14264             // This means that either we know that the allocator is null or we don&#39;t know what the
14265             // allocator is. In either case, we need the null check.
14266             LBasicBlock haveAllocator = m_out.newBlock();
14267             LBasicBlock lastNext = m_out.insertNewBlocksBefore(haveAllocator);
14268             m_out.branch(
14269                 m_out.notEqual(allocator, m_out.intPtrZero),
14270                 usually(haveAllocator), rarely(slowPath));
14271             m_out.appendTo(haveAllocator, lastNext);
14272         }
14273 
14274         LBasicBlock continuation = m_out.newBlock();
14275 
14276         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
14277 
14278         PatchpointValue* patchpoint = m_out.patchpoint(pointerType());
14279         if (isARM64()) {
14280             // emitAllocateWithNonNullAllocator uses the scratch registers on ARM.
14281             patchpoint-&gt;clobber(RegisterSet::macroScratchRegisters());
14282         }
14283         patchpoint-&gt;effects.terminal = true;
14284         if (actualAllocator.isConstant())
14285             patchpoint-&gt;numGPScratchRegisters++;
14286         else
14287             patchpoint-&gt;appendSomeRegisterWithClobber(allocator);
14288         patchpoint-&gt;numGPScratchRegisters++;
14289         patchpoint-&gt;resultConstraints = { ValueRep::SomeEarlyRegister };
14290 
14291         m_out.appendSuccessor(usually(continuation));
14292         m_out.appendSuccessor(rarely(slowPath));
14293 
14294         patchpoint-&gt;setGenerator(
14295             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
14296                 AllowMacroScratchRegisterUsageIf allowScratchIf(jit, isARM64());
14297                 CCallHelpers::JumpList jumpToSlowPath;
14298 
14299                 GPRReg allocatorGPR;
14300                 if (actualAllocator.isConstant())
14301                     allocatorGPR = params.gpScratch(1);
14302                 else
14303                     allocatorGPR = params[1].gpr();
14304 
14305                 // We use a patchpoint to emit the allocation path because whenever we mess with
14306                 // allocation paths, we already reason about them at the machine code level. We know
14307                 // exactly what instruction sequence we want. We&#39;re confident that no compiler
14308                 // optimization could make this code better. So, it&#39;s best to have the code in
14309                 // AssemblyHelpers::emitAllocate(). That way, the same optimized path is shared by
14310                 // all of the compiler tiers.
14311                 jit.emitAllocateWithNonNullAllocator(
14312                     params[0].gpr(), actualAllocator, allocatorGPR, params.gpScratch(0),
14313                     jumpToSlowPath);
14314 
14315                 CCallHelpers::Jump jumpToSuccess;
14316                 if (!params.fallsThroughToSuccessor(0))
14317                     jumpToSuccess = jit.jump();
14318 
14319                 Vector&lt;Box&lt;CCallHelpers::Label&gt;&gt; labels = params.successorLabels();
14320 
14321                 params.addLatePath(
14322                     [=] (CCallHelpers&amp; jit) {
14323                         jumpToSlowPath.linkTo(*labels[1], &amp;jit);
14324                         if (jumpToSuccess.isSet())
14325                             jumpToSuccess.linkTo(*labels[0], &amp;jit);
14326                     });
14327             });
14328 
14329         m_out.appendTo(continuation, lastNext);
14330         return patchpoint;
14331     }
14332 
14333     void storeStructure(LValue object, Structure* structure)
14334     {
14335         m_out.store32(m_out.constInt32(structure-&gt;id()), object, m_heaps.JSCell_structureID);
14336         m_out.store32(
14337             m_out.constInt32(structure-&gt;objectInitializationBlob()),
14338             object, m_heaps.JSCell_usefulBytes);
14339     }
14340 
14341     void storeStructure(LValue object, LValue structure)
14342     {
14343         if (structure-&gt;hasIntPtr()) {
14344             storeStructure(object, bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr()));
14345             return;
14346         }
14347 
14348         LValue id = m_out.load32(structure, m_heaps.Structure_structureID);
14349         m_out.store32(id, object, m_heaps.JSCell_structureID);
14350 
14351         LValue blob = m_out.load32(structure, m_heaps.Structure_indexingModeIncludingHistory);
14352         m_out.store32(blob, object, m_heaps.JSCell_usefulBytes);
14353     }
14354 
14355     template &lt;typename StructureType&gt;
14356     LValue allocateCell(LValue allocator, StructureType structure, LBasicBlock slowPath)
14357     {
14358         LValue result = allocateHeapCell(allocator, slowPath);
14359         storeStructure(result, structure);
14360         return result;
14361     }
14362 
14363     LValue allocateObject(LValue allocator, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
14364     {
14365         return allocateObject(allocator, weakStructure(structure), butterfly, slowPath);
14366     }
14367 
14368     LValue allocateObject(LValue allocator, LValue structure, LValue butterfly, LBasicBlock slowPath)
14369     {
14370         LValue result = allocateCell(allocator, structure, slowPath);
14371         if (structure-&gt;hasIntPtr()) {
14372             splatWords(
14373                 result,
14374                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
14375                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8 + bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;inlineCapacity()),
14376                 m_out.int64Zero,
14377                 m_heaps.properties.atAnyNumber());
14378         } else {
14379             LValue end = m_out.add(
14380                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
14381                 m_out.load8ZeroExt32(structure, m_heaps.Structure_inlineCapacity));
14382             splatWords(
14383                 result,
14384                 m_out.constInt32(JSFinalObject::offsetOfInlineStorage() / 8),
14385                 end,
14386                 m_out.int64Zero,
14387                 m_heaps.properties.atAnyNumber());
14388         }
14389 
14390         m_out.storePtr(butterfly, result, m_heaps.JSObject_butterfly);
14391         return result;
14392     }
14393 
14394     template&lt;typename ClassType, typename StructureType&gt;
14395     LValue allocateObject(
14396         size_t size, StructureType structure, LValue butterfly, LBasicBlock slowPath)
14397     {
14398         Allocator allocator = allocatorForNonVirtualConcurrently&lt;ClassType&gt;(vm(), size, AllocatorForMode::AllocatorIfExists);
14399         return allocateObject(
14400             m_out.constIntPtr(allocator.localAllocator()), structure, butterfly, slowPath);
14401     }
14402 
14403     template&lt;typename ClassType, typename StructureType&gt;
14404     LValue allocateObject(StructureType structure, LValue butterfly, LBasicBlock slowPath)
14405     {
14406         return allocateObject&lt;ClassType&gt;(
14407             ClassType::allocationSize(0), structure, butterfly, slowPath);
14408     }
14409 
14410     LValue allocatorForSize(LValue subspace, LValue size, LBasicBlock slowPath)
14411     {
14412         static_assert(!(MarkedSpace::sizeStep &amp; (MarkedSpace::sizeStep - 1)), &quot;MarkedSpace::sizeStep must be a power of two.&quot;);
14413 
14414         // Try to do some constant-folding here.
14415         if (subspace-&gt;hasIntPtr() &amp;&amp; size-&gt;hasIntPtr()) {
14416             CompleteSubspace* actualSubspace = bitwise_cast&lt;CompleteSubspace*&gt;(subspace-&gt;asIntPtr());
14417             size_t actualSize = size-&gt;asIntPtr();
14418 
14419             Allocator actualAllocator = actualSubspace-&gt;allocatorForNonVirtual(actualSize, AllocatorForMode::AllocatorIfExists);
14420             if (!actualAllocator) {
14421                 LBasicBlock continuation = m_out.newBlock();
14422                 LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
14423                 m_out.jump(slowPath);
14424                 m_out.appendTo(continuation, lastNext);
14425                 return m_out.intPtrZero;
14426             }
14427 
14428             return m_out.constIntPtr(actualAllocator.localAllocator());
14429         }
14430 
14431         unsigned stepShift = getLSBSet(MarkedSpace::sizeStep);
14432 
14433         LBasicBlock continuation = m_out.newBlock();
14434 
14435         LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
14436 
14437         LValue sizeClassIndex = m_out.lShr(
14438             m_out.add(size, m_out.constIntPtr(MarkedSpace::sizeStep - 1)),
14439             m_out.constInt32(stepShift));
14440 
14441         m_out.branch(
14442             m_out.above(sizeClassIndex, m_out.constIntPtr(MarkedSpace::largeCutoff &gt;&gt; stepShift)),
14443             rarely(slowPath), usually(continuation));
14444 
14445         m_out.appendTo(continuation, lastNext);
14446 
14447         return m_out.loadPtr(
14448             m_out.baseIndex(
14449                 m_heaps.CompleteSubspace_allocatorForSizeStep,
14450                 subspace, sizeClassIndex));
14451     }
14452 
14453     LValue allocatorForSize(CompleteSubspace&amp; subspace, LValue size, LBasicBlock slowPath)
14454     {
14455         return allocatorForSize(m_out.constIntPtr(&amp;subspace), size, slowPath);
14456     }
14457 
14458     template&lt;typename ClassType&gt;
14459     LValue allocateVariableSizedObject(
14460         LValue size, RegisteredStructure structure, LValue butterfly, LBasicBlock slowPath)
14461     {
14462         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
14463         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
14464         LValue allocator = allocatorForSize(*subspace, size, slowPath);
14465         return allocateObject(allocator, structure, butterfly, slowPath);
14466     }
14467 
14468     template&lt;typename ClassType&gt;
14469     LValue allocateVariableSizedCell(
14470         LValue size, Structure* structure, LBasicBlock slowPath)
14471     {
14472         CompleteSubspace* subspace = subspaceForConcurrently&lt;ClassType&gt;(vm());
14473         RELEASE_ASSERT_WITH_MESSAGE(subspace, &quot;CompleteSubspace is always allocated&quot;);
14474         LValue allocator = allocatorForSize(*subspace, size, slowPath);
14475         return allocateCell(allocator, structure, slowPath);
14476     }
14477 
14478     LValue allocateObject(RegisteredStructure structure)
14479     {
14480         size_t allocationSize = JSFinalObject::allocationSize(structure.get()-&gt;inlineCapacity());
14481         Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
14482 
14483         // FIXME: If the allocator is null, we could simply emit a normal C call to the allocator
14484         // instead of putting it on the slow path.
14485         // https://bugs.webkit.org/show_bug.cgi?id=161062
14486 
14487         LBasicBlock slowPath = m_out.newBlock();
14488         LBasicBlock continuation = m_out.newBlock();
14489 
14490         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
14491 
14492         ValueFromBlock fastResult = m_out.anchor(allocateObject(
14493             m_out.constIntPtr(allocator.localAllocator()), structure, m_out.intPtrZero, slowPath));
14494 
14495         m_out.jump(continuation);
14496 
14497         m_out.appendTo(slowPath, continuation);
14498 
14499         VM&amp; vm = this-&gt;vm();
14500         LValue slowResultValue = lazySlowPath(
14501             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14502                 return createLazyCallGenerator(vm,
<a name="549" id="anc549"></a><span class="line-modified">14503                     operationNewObject, locations[0].directGPR(), &amp;vm,</span>
14504                     CCallHelpers::TrustedImmPtr(structure.get()));
14505             });
14506         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
14507         m_out.jump(continuation);
14508 
14509         m_out.appendTo(continuation, lastNext);
14510         return m_out.phi(pointerType(), fastResult, slowResult);
14511     }
14512 
14513     struct ArrayValues {
14514         ArrayValues()
14515             : array(0)
14516             , butterfly(0)
14517         {
14518         }
14519 
14520         ArrayValues(LValue array, LValue butterfly)
14521             : array(array)
14522             , butterfly(butterfly)
14523         {
14524         }
14525 
14526         LValue array;
14527         LValue butterfly;
14528     };
14529 
14530     ArrayValues allocateJSArray(LValue publicLength, LValue vectorLength, LValue structure, LValue indexingType, bool shouldInitializeElements = true, bool shouldLargeArraySizeCreateArrayStorage = true)
14531     {
14532         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
<a name="550" id="anc550"></a>








14533         LBasicBlock fastCase = m_out.newBlock();
14534         LBasicBlock largeCase = m_out.newBlock();
14535         LBasicBlock failCase = m_out.newBlock();
14536         LBasicBlock continuation = m_out.newBlock();
14537         LBasicBlock slowCase = m_out.newBlock();
14538 
14539         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastCase);
14540 
14541         Optional&lt;unsigned&gt; staticVectorLength;
14542         Optional&lt;unsigned&gt; staticVectorLengthFromPublicLength;
14543         if (structure-&gt;hasIntPtr()) {
14544             if (publicLength-&gt;hasInt32()) {
14545                 unsigned publicLengthConst = static_cast&lt;unsigned&gt;(publicLength-&gt;asInt32());
14546                 if (publicLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
14547                     publicLengthConst = Butterfly::optimalContiguousVectorLength(
14548                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), publicLengthConst);
14549                     staticVectorLengthFromPublicLength = publicLengthConst;
14550                 }
14551 
14552             }
14553             if (vectorLength-&gt;hasInt32()) {
14554                 unsigned vectorLengthConst = static_cast&lt;unsigned&gt;(vectorLength-&gt;asInt32());
14555                 if (vectorLengthConst &lt;= MAX_STORAGE_VECTOR_LENGTH) {
14556                     vectorLengthConst = Butterfly::optimalContiguousVectorLength(
14557                         bitwise_cast&lt;Structure*&gt;(structure-&gt;asIntPtr())-&gt;outOfLineCapacity(), vectorLengthConst);
14558                     vectorLength = m_out.constInt32(vectorLengthConst);
14559                     staticVectorLength = vectorLengthConst;
14560                 }
14561             }
14562         } else {
14563             // We don&#39;t compute the optimal vector length for new Array(blah) where blah is not
14564             // statically known, since the compute effort of doing it here is probably not worth it.
14565         }
14566 
14567         ValueFromBlock noButterfly = m_out.anchor(m_out.intPtrZero);
14568 
14569         LValue predicate;
14570         if (shouldLargeArraySizeCreateArrayStorage)
14571             predicate = m_out.aboveOrEqual(publicLength, m_out.constInt32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
14572         else
14573             predicate = m_out.booleanFalse;
14574 
14575         m_out.branch(predicate, rarely(largeCase), usually(fastCase));
14576 
14577         m_out.appendTo(fastCase, largeCase);
14578 
14579         LValue payloadSize =
14580             m_out.shl(m_out.zeroExt(vectorLength, pointerType()), m_out.constIntPtr(3));
14581 
14582         LValue butterflySize = m_out.add(
14583             payloadSize, m_out.constIntPtr(sizeof(IndexingHeader)));
14584 
14585         LValue allocator = allocatorForSize(vm().jsValueGigacageAuxiliarySpace, butterflySize, failCase);
14586         LValue startOfStorage = allocateHeapCell(allocator, failCase);
14587 
14588         LValue butterfly = m_out.add(startOfStorage, m_out.constIntPtr(sizeof(IndexingHeader)));
14589 
14590         m_out.store32(publicLength, butterfly, m_heaps.Butterfly_publicLength);
14591         m_out.store32(vectorLength, butterfly, m_heaps.Butterfly_vectorLength);
14592 
14593         initializeArrayElements(
14594             indexingType,
14595             shouldInitializeElements ? m_out.int32Zero : publicLength, vectorLength,
14596             butterfly);
14597 
14598         ValueFromBlock haveButterfly = m_out.anchor(butterfly);
14599 
14600         LValue object = allocateObject&lt;JSArray&gt;(structure, butterfly, failCase);
14601 
14602         ValueFromBlock fastResult = m_out.anchor(object);
14603         ValueFromBlock fastButterfly = m_out.anchor(butterfly);
14604         m_out.jump(continuation);
14605 
14606         m_out.appendTo(largeCase, failCase);
14607         ValueFromBlock largeStructure = m_out.anchor(
14608             weakStructure(m_graph.registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))));
14609         m_out.jump(slowCase);
14610 
14611         m_out.appendTo(failCase, slowCase);
14612         ValueFromBlock failStructure = m_out.anchor(structure);
14613         m_out.jump(slowCase);
14614 
14615         m_out.appendTo(slowCase, continuation);
14616         LValue structureValue = m_out.phi(pointerType(), largeStructure, failStructure);
14617         LValue butterflyValue = m_out.phi(pointerType(), noButterfly, haveButterfly);
14618 
14619         VM&amp; vm = this-&gt;vm();
14620         LValue slowResultValue = nullptr;
14621         if (vectorLength == publicLength
14622             || (staticVectorLengthFromPublicLength &amp;&amp; staticVectorLength &amp;&amp; staticVectorLength.value() == staticVectorLengthFromPublicLength.value())) {
14623             slowResultValue = lazySlowPath(
14624                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14625                     return createLazyCallGenerator(vm,
<a name="551" id="anc551"></a><span class="line-modified">14626                         operationNewArrayWithSize, locations[0].directGPR(), globalObject,</span>
14627                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR());
14628                 },
14629                 structureValue, publicLength, butterflyValue);
14630         } else {
14631             slowResultValue = lazySlowPath(
14632                 [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
14633                     return createLazyCallGenerator(vm,
<a name="552" id="anc552"></a><span class="line-modified">14634                         operationNewArrayWithSizeAndHint, locations[0].directGPR(), globalObject,</span>
14635                         locations[1].directGPR(), locations[2].directGPR(), locations[3].directGPR(), locations[4].directGPR());
14636                 },
14637                 structureValue, publicLength, vectorLength, butterflyValue);
14638         }
14639 
14640         ValueFromBlock slowResult = m_out.anchor(slowResultValue);
14641         ValueFromBlock slowButterfly = m_out.anchor(
14642             m_out.loadPtr(slowResultValue, m_heaps.JSObject_butterfly));
14643         m_out.jump(continuation);
14644 
14645         m_out.appendTo(continuation, lastNext);
14646         return ArrayValues(
14647             m_out.phi(pointerType(), fastResult, slowResult),
14648             m_out.phi(pointerType(), fastButterfly, slowButterfly));
14649     }
14650 
14651     ArrayValues allocateUninitializedContiguousJSArrayInternal(LValue publicLength, LValue vectorLength, RegisteredStructure structure)
14652     {
14653         bool shouldInitializeElements = false;
14654         bool shouldLargeArraySizeCreateArrayStorage = false;
14655         return allocateJSArray(
14656             publicLength, vectorLength, weakStructure(structure), m_out.constInt32(structure-&gt;indexingType()), shouldInitializeElements,
14657             shouldLargeArraySizeCreateArrayStorage);
14658     }
14659 
14660     ArrayValues allocateUninitializedContiguousJSArray(LValue publicLength, RegisteredStructure structure)
14661     {
14662         return allocateUninitializedContiguousJSArrayInternal(publicLength, publicLength, structure);
14663     }
14664 
14665     ArrayValues allocateUninitializedContiguousJSArray(unsigned publicLength, unsigned vectorLength, RegisteredStructure structure)
14666     {
14667         ASSERT(vectorLength &gt;= publicLength);
14668         return allocateUninitializedContiguousJSArrayInternal(m_out.constInt32(publicLength), m_out.constInt32(vectorLength), structure);
14669     }
14670 
14671     LValue ensureShadowChickenPacket()
14672     {
14673         ShadowChicken* shadowChicken = vm().shadowChicken();
14674         RELEASE_ASSERT(shadowChicken);
14675         LBasicBlock slowCase = m_out.newBlock();
14676         LBasicBlock continuation = m_out.newBlock();
14677 
14678         TypedPointer addressOfLogCursor = m_out.absolute(shadowChicken-&gt;addressOfLogCursor());
14679         LValue logCursor = m_out.loadPtr(addressOfLogCursor);
14680 
14681         ValueFromBlock fastResult = m_out.anchor(logCursor);
14682 
14683         m_out.branch(
14684             m_out.below(logCursor, m_out.constIntPtr(shadowChicken-&gt;logEnd())),
14685             usually(continuation), rarely(slowCase));
14686 
14687         LBasicBlock lastNext = m_out.appendTo(slowCase, continuation);
14688 
<a name="553" id="anc553"></a><span class="line-modified">14689         vmCall(Void, operationProcessShadowChickenLog, m_vmValue);</span>
14690 
14691         ValueFromBlock slowResult = m_out.anchor(m_out.loadPtr(addressOfLogCursor));
14692         m_out.jump(continuation);
14693 
14694         m_out.appendTo(continuation, lastNext);
14695         LValue result = m_out.phi(pointerType(), fastResult, slowResult);
14696 
14697         m_out.storePtr(
14698             m_out.add(result, m_out.constIntPtr(sizeof(ShadowChicken::Packet))),
14699             addressOfLogCursor);
14700 
14701         return result;
14702     }
14703 
14704     LValue boolify(Edge edge)
14705     {
14706         switch (edge.useKind()) {
14707         case BooleanUse:
14708         case KnownBooleanUse:
14709             return lowBoolean(edge);
14710         case Int32Use:
14711             return m_out.notZero32(lowInt32(edge));
14712         case DoubleRepUse:
14713             return m_out.doubleNotEqualAndOrdered(lowDouble(edge), m_out.doubleZero);
14714         case ObjectOrOtherUse:
14715             return m_out.logicalNot(
14716                 equalNullOrUndefined(
14717                     edge, CellCaseSpeculatesObject, SpeculateNullOrUndefined,
14718                     ManualOperandSpeculation));
14719         case StringUse:
14720             return m_out.notEqual(lowString(edge), weakPointer(jsEmptyString(m_graph.m_vm)));
14721         case StringOrOtherUse: {
14722             LValue value = lowJSValue(edge, ManualOperandSpeculation);
14723 
14724             LBasicBlock cellCase = m_out.newBlock();
14725             LBasicBlock notCellCase = m_out.newBlock();
14726             LBasicBlock continuation = m_out.newBlock();
14727 
14728             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
14729 
14730             LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
14731             FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
14732             ValueFromBlock stringResult = m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm))));
14733             m_out.jump(continuation);
14734 
14735             m_out.appendTo(notCellCase, continuation);
14736             FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
14737             ValueFromBlock notCellResult = m_out.anchor(m_out.booleanFalse);
14738             m_out.jump(continuation);
14739 
14740             m_out.appendTo(continuation, lastNext);
14741             return m_out.phi(Int32, stringResult, notCellResult);
14742         }
14743         case UntypedUse: {
14744             LValue value = lowJSValue(edge);
14745 
14746             // Implements the following control flow structure:
14747             // if (value is cell) {
14748             //     if (value is string or value is BigInt)
14749             //         result = !!value-&gt;length
14750             //     else {
14751             //         do evil things for masquerades-as-undefined
14752             //         result = true
14753             //     }
14754             // } else if (value is int32) {
14755             //     result = !!unboxInt32(value)
14756             // } else if (value is number) {
14757             //     result = !!unboxDouble(value)
14758             // } else {
14759             //     result = value == jsTrue
14760             // }
14761 
14762             LBasicBlock cellCase = m_out.newBlock();
14763             LBasicBlock notStringCase = m_out.newBlock();
14764             LBasicBlock stringCase = m_out.newBlock();
14765             LBasicBlock bigIntCase = m_out.newBlock();
14766             LBasicBlock notStringOrBigIntCase = m_out.newBlock();
14767             LBasicBlock notCellCase = m_out.newBlock();
14768             LBasicBlock int32Case = m_out.newBlock();
14769             LBasicBlock notInt32Case = m_out.newBlock();
14770             LBasicBlock doubleCase = m_out.newBlock();
14771             LBasicBlock notDoubleCase = m_out.newBlock();
14772             LBasicBlock continuation = m_out.newBlock();
14773 
14774             Vector&lt;ValueFromBlock&gt; results;
14775 
14776             m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
14777 
14778             LBasicBlock lastNext = m_out.appendTo(cellCase, notStringCase);
14779             m_out.branch(
14780                 isString(value, provenType(edge) &amp; SpecCell),
14781                 unsure(stringCase), unsure(notStringCase));
14782 
14783             m_out.appendTo(notStringCase, stringCase);
14784             m_out.branch(
14785                 isBigInt(value, provenType(edge) &amp; (SpecCell - SpecString)),
14786                 unsure(bigIntCase), unsure(notStringOrBigIntCase));
14787 
14788             m_out.appendTo(stringCase, bigIntCase);
14789             results.append(m_out.anchor(m_out.notEqual(value, weakPointer(jsEmptyString(m_graph.m_vm)))));
14790             m_out.jump(continuation);
14791 
14792             m_out.appendTo(bigIntCase, notStringOrBigIntCase);
14793             LValue nonZeroBigInt = m_out.notZero32(
14794                 m_out.load32NonNegative(value, m_heaps.JSBigInt_length));
14795             results.append(m_out.anchor(nonZeroBigInt));
14796             m_out.jump(continuation);
14797 
14798             m_out.appendTo(notStringOrBigIntCase, notCellCase);
14799             LValue isTruthyObject;
14800             if (masqueradesAsUndefinedWatchpointIsStillValid())
14801                 isTruthyObject = m_out.booleanTrue;
14802             else {
14803                 LBasicBlock masqueradesCase = m_out.newBlock();
14804 
14805                 results.append(m_out.anchor(m_out.booleanTrue));
14806 
14807                 m_out.branch(
14808                     m_out.testIsZero32(
14809                         m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
14810                         m_out.constInt32(MasqueradesAsUndefined)),
14811                     usually(continuation), rarely(masqueradesCase));
14812 
14813                 m_out.appendTo(masqueradesCase);
14814 
14815                 isTruthyObject = m_out.notEqual(
14816                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
14817                     m_out.loadPtr(loadStructure(value), m_heaps.Structure_globalObject));
14818             }
14819             results.append(m_out.anchor(isTruthyObject));
14820             m_out.jump(continuation);
14821 
14822             m_out.appendTo(notCellCase, int32Case);
14823             m_out.branch(
14824                 isInt32(value, provenType(edge) &amp; ~SpecCell),
14825                 unsure(int32Case), unsure(notInt32Case));
14826 
14827             m_out.appendTo(int32Case, notInt32Case);
14828             results.append(m_out.anchor(m_out.notZero32(unboxInt32(value))));
14829             m_out.jump(continuation);
14830 
14831             m_out.appendTo(notInt32Case, doubleCase);
14832             m_out.branch(
14833                 isNumber(value, provenType(edge) &amp; ~SpecCell),
14834                 unsure(doubleCase), unsure(notDoubleCase));
14835 
14836             m_out.appendTo(doubleCase, notDoubleCase);
14837             LValue doubleIsTruthy = m_out.doubleNotEqualAndOrdered(
14838                 unboxDouble(value), m_out.constDouble(0));
14839             results.append(m_out.anchor(doubleIsTruthy));
14840             m_out.jump(continuation);
14841 
14842             m_out.appendTo(notDoubleCase, continuation);
14843             LValue miscIsTruthy = m_out.equal(
14844                 value, m_out.constInt64(JSValue::encode(jsBoolean(true))));
14845             results.append(m_out.anchor(miscIsTruthy));
14846             m_out.jump(continuation);
14847 
14848             m_out.appendTo(continuation, lastNext);
14849             return m_out.phi(Int32, results);
14850         }
14851         default:
14852             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
14853             return 0;
14854         }
14855     }
14856 
14857     enum StringOrObjectMode {
14858         AllCellsAreFalse,
14859         CellCaseSpeculatesObject
14860     };
14861     enum EqualNullOrUndefinedMode {
14862         EqualNull,
14863         EqualUndefined,
14864         EqualNullOrUndefined,
14865         SpeculateNullOrUndefined
14866     };
14867     LValue equalNullOrUndefined(
14868         Edge edge, StringOrObjectMode cellMode, EqualNullOrUndefinedMode primitiveMode,
14869         OperandSpeculationMode operandMode = AutomaticOperandSpeculation)
14870     {
14871         bool validWatchpoint = masqueradesAsUndefinedWatchpointIsStillValid();
14872 
14873         LValue value = lowJSValue(edge, operandMode);
14874 
14875         LBasicBlock cellCase = m_out.newBlock();
14876         LBasicBlock primitiveCase = m_out.newBlock();
14877         LBasicBlock continuation = m_out.newBlock();
14878 
14879         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
14880 
14881         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
14882 
14883         Vector&lt;ValueFromBlock, 3&gt; results;
14884 
14885         switch (cellMode) {
14886         case AllCellsAreFalse:
14887             break;
14888         case CellCaseSpeculatesObject:
14889             FTL_TYPE_CHECK(
14890                 jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
14891             break;
14892         }
14893 
14894         if (validWatchpoint) {
14895             results.append(m_out.anchor(m_out.booleanFalse));
14896             m_out.jump(continuation);
14897         } else {
14898             LBasicBlock masqueradesCase =
14899                 m_out.newBlock();
14900 
14901             results.append(m_out.anchor(m_out.booleanFalse));
14902 
14903             m_out.branch(
14904                 m_out.testNonZero32(
14905                     m_out.load8ZeroExt32(value, m_heaps.JSCell_typeInfoFlags),
14906                     m_out.constInt32(MasqueradesAsUndefined)),
14907                 rarely(masqueradesCase), usually(continuation));
14908 
14909             m_out.appendTo(masqueradesCase, primitiveCase);
14910 
14911             LValue structure = loadStructure(value);
14912 
14913             results.append(m_out.anchor(
14914                 m_out.equal(
14915                     weakPointer(m_graph.globalObjectFor(m_node-&gt;origin.semantic)),
14916                     m_out.loadPtr(structure, m_heaps.Structure_globalObject))));
14917             m_out.jump(continuation);
14918         }
14919 
14920         m_out.appendTo(primitiveCase, continuation);
14921 
14922         LValue primitiveResult;
14923         switch (primitiveMode) {
14924         case EqualNull:
<a name="554" id="anc554"></a><span class="line-modified">14925             primitiveResult = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
14926             break;
14927         case EqualUndefined:
<a name="555" id="anc555"></a><span class="line-modified">14928             primitiveResult = m_out.equal(value, m_out.constInt64(JSValue::ValueUndefined));</span>
14929             break;
14930         case EqualNullOrUndefined:
14931             primitiveResult = isOther(value, provenType(edge));
14932             break;
14933         case SpeculateNullOrUndefined:
14934             FTL_TYPE_CHECK(
14935                 jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
14936             primitiveResult = m_out.booleanTrue;
14937             break;
14938         }
14939         results.append(m_out.anchor(primitiveResult));
14940         m_out.jump(continuation);
14941 
14942         m_out.appendTo(continuation, lastNext);
14943 
14944         return m_out.phi(Int32, results);
14945     }
14946 
14947     template&lt;typename FunctionType&gt;
14948     void contiguousPutByValOutOfBounds(
14949         FunctionType slowPathFunction, LValue base, LValue storage, LValue index, LValue value,
14950         LBasicBlock continuation)
14951     {
<a name="556" id="anc556"></a><span class="line-added">14952         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
14953         if (!m_node-&gt;arrayMode().isInBounds()) {
14954             LBasicBlock notInBoundsCase =
14955                 m_out.newBlock();
14956             LBasicBlock performStore =
14957                 m_out.newBlock();
14958 
14959             LValue isNotInBounds = m_out.aboveOrEqual(
14960                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_publicLength));
14961             m_out.branch(isNotInBounds, unsure(notInBoundsCase), unsure(performStore));
14962 
14963             LBasicBlock lastNext = m_out.appendTo(notInBoundsCase, performStore);
14964 
14965             LValue isOutOfBounds = m_out.aboveOrEqual(
14966                 index, m_out.load32NonNegative(storage, m_heaps.Butterfly_vectorLength));
14967 
14968             if (!m_node-&gt;arrayMode().isOutOfBounds())
14969                 speculate(OutOfBounds, noValue(), 0, isOutOfBounds);
14970             else {
14971                 LBasicBlock outOfBoundsCase =
14972                     m_out.newBlock();
14973                 LBasicBlock holeCase =
14974                     m_out.newBlock();
14975 
14976                 m_out.branch(isOutOfBounds, rarely(outOfBoundsCase), usually(holeCase));
14977 
14978                 LBasicBlock innerLastNext = m_out.appendTo(outOfBoundsCase, holeCase);
14979 
14980                 vmCall(
<a name="557" id="anc557"></a><span class="line-modified">14981                     Void, slowPathFunction,</span>
<span class="line-modified">14982                     weakPointer(globalObject), base, index, value);</span>
14983 
14984                 m_out.jump(continuation);
14985 
14986                 m_out.appendTo(holeCase, innerLastNext);
14987             }
14988 
14989             m_out.store32(
14990                 m_out.add(index, m_out.int32One),
14991                 storage, m_heaps.Butterfly_publicLength);
14992 
14993             m_out.jump(performStore);
14994             m_out.appendTo(performStore, lastNext);
14995         }
14996     }
14997 
14998     LValue untagArrayPtr(LValue ptr, LValue size)
14999     {
15000 #if CPU(ARM64E)
15001         PatchpointValue* authenticate = m_out.patchpoint(pointerType());
15002         authenticate-&gt;appendSomeRegister(ptr);
15003         authenticate-&gt;append(size, B3::ValueRep(B3::ValueRep::SomeLateRegister));
15004         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15005             jit.move(params[1].gpr(), params[0].gpr());
15006             jit.untagArrayPtr(params[2].gpr(), params[0].gpr());
15007         });
15008         return authenticate;
15009 #else
15010         UNUSED_PARAM(size);
15011         return ptr;
15012 #endif
15013     }
15014 
15015     LValue removeArrayPtrTag(LValue ptr)
15016     {
15017 #if CPU(ARM64E)
15018         PatchpointValue* authenticate = m_out.patchpoint(pointerType());
15019         authenticate-&gt;appendSomeRegister(ptr);
15020         authenticate-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15021             jit.move(params[1].gpr(), params[0].gpr());
15022             jit.removeArrayPtrTag(params[0].gpr());
15023         });
15024         return authenticate;
15025 #endif
15026         return ptr;
15027     }
15028 
15029     LValue caged(Gigacage::Kind kind, LValue ptr, LValue base)
15030     {
15031         auto doUntagArrayPtr = [&amp;](LValue taggedPtr) {
15032 #if CPU(ARM64E)
15033             if (kind == Gigacage::Primitive) {
15034                 LValue size = m_out.load32(base, m_heaps.JSArrayBufferView_length);
15035                 return untagArrayPtr(taggedPtr, size);
15036             }
15037             return ptr;
15038 #else
15039             UNUSED_PARAM(taggedPtr);
15040             return ptr;
15041 #endif
15042         };
15043 
15044 #if GIGACAGE_ENABLED
15045         if (!Gigacage::isEnabled(kind))
15046             return doUntagArrayPtr(ptr);
15047 
15048         if (kind == Gigacage::Primitive &amp;&amp; Gigacage::canPrimitiveGigacageBeDisabled()) {
15049             if (vm().primitiveGigacageEnabled().isStillValid())
15050                 m_graph.watchpoints().addLazily(vm().primitiveGigacageEnabled());
15051             else
15052                 return doUntagArrayPtr(ptr);
15053         }
15054 
15055         LValue basePtr = m_out.constIntPtr(Gigacage::basePtr(kind));
15056         LValue mask = m_out.constIntPtr(Gigacage::mask(kind));
15057 
15058         LValue masked = m_out.bitAnd(ptr, mask);
15059         LValue result = m_out.add(masked, basePtr);
15060 
15061 #if CPU(ARM64E)
15062         if (kind == Gigacage::Primitive) {
15063             PatchpointValue* merge = m_out.patchpoint(pointerType());
15064             merge-&gt;append(result, B3::ValueRep(B3::ValueRep::SomeLateRegister));
15065             merge-&gt;appendSomeRegister(ptr);
15066             merge-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15067                 jit.move(params[2].gpr(), params[0].gpr());
15068                 jit.bitFieldInsert64(params[1].gpr(), 0, 64 - MacroAssembler::numberOfPACBits, params[0].gpr());
15069             });
15070 
15071             result = doUntagArrayPtr(merge);
15072         }
15073 #endif // CPU(ARM64E)
15074 
15075         // Make sure that B3 doesn&#39;t try to do smart reassociation of these pointer bits.
15076         // FIXME: In an ideal world, B3 would not do harmful reassociations, and if it did, it would be able
15077         // to undo them during constant hoisting and regalloc. As it stands, if you remove this then Octane
15078         // gets 1.6% slower and Kraken gets 5% slower. It&#39;s all because the basePtr, which is a constant,
15079         // gets reassociated out of the add above and into the address arithmetic. This disables hoisting of
15080         // the basePtr constant. Hoisting that constant is worth a lot more perf than the reassociation. One
15081         // way to make this all work happily is to combine offset legalization with constant hoisting, and
15082         // then teach it reassociation. So, Add(Add(a, b), const) where a is loop-invariant while b isn&#39;t
15083         // will turn into Add(Add(a, const), b) by the constant hoister. We would have to teach B3 to do this
15084         // and possibly other smart things if we want to be able to remove this opaque.
15085         // https://bugs.webkit.org/show_bug.cgi?id=175493
15086         return m_out.opaque(result);
15087 #endif
15088 
15089         UNUSED_PARAM(kind);
15090         UNUSED_PARAM(base);
15091         return doUntagArrayPtr(ptr);
15092     }
15093 
15094     void buildSwitch(SwitchData* data, LType type, LValue switchValue)
15095     {
15096         ASSERT(type == pointerType() || type == Int32);
15097 
15098         Vector&lt;SwitchCase&gt; cases;
15099         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
15100             SwitchCase newCase;
15101 
15102             if (type == pointerType()) {
15103                 newCase = SwitchCase(m_out.constIntPtr(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
15104                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
15105             } else if (type == Int32) {
15106                 newCase = SwitchCase(m_out.constInt32(data-&gt;cases[i].value.switchLookupValue(data-&gt;kind)),
15107                     lowBlock(data-&gt;cases[i].target.block), Weight(data-&gt;cases[i].target.count));
15108             } else
15109                 CRASH();
15110 
15111             cases.append(newCase);
15112         }
15113 
15114         m_out.switchInstruction(
15115             switchValue, cases,
15116             lowBlock(data-&gt;fallThrough.block), Weight(data-&gt;fallThrough.count));
15117     }
15118 
15119     void switchString(SwitchData* data, LValue string, Edge&amp; edge)
15120     {
15121         bool canDoBinarySwitch = true;
15122         unsigned totalLength = 0;
15123 
15124         for (DFG::SwitchCase myCase : data-&gt;cases) {
15125             StringImpl* string = myCase.value.stringImpl();
15126             if (!string-&gt;is8Bit()) {
15127                 canDoBinarySwitch = false;
15128                 break;
15129             }
15130             if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
15131                 canDoBinarySwitch = false;
15132                 break;
15133             }
15134             totalLength += string-&gt;length();
15135         }
15136 
15137         if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
15138             switchStringSlow(data, string);
15139             return;
15140         }
15141 
15142         LBasicBlock hasImplBlock = m_out.newBlock();
15143         LBasicBlock is8BitBlock = m_out.newBlock();
15144         LBasicBlock slowBlock = m_out.newBlock();
15145 
15146         m_out.branch(isRopeString(string, edge), unsure(slowBlock), unsure(hasImplBlock));
15147 
15148         LBasicBlock lastNext = m_out.appendTo(hasImplBlock, is8BitBlock);
15149 
15150         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
15151         LValue length = m_out.load32(stringImpl, m_heaps.StringImpl_length);
15152 
15153         m_out.branch(
15154             m_out.testIsZero32(
15155                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
15156                 m_out.constInt32(StringImpl::flagIs8Bit())),
15157             unsure(slowBlock), unsure(is8BitBlock));
15158 
15159         m_out.appendTo(is8BitBlock, slowBlock);
15160 
15161         LValue buffer = m_out.loadPtr(stringImpl, m_heaps.StringImpl_data);
15162 
15163         // FIXME: We should propagate branch weight data to the cases of this switch.
15164         // https://bugs.webkit.org/show_bug.cgi?id=144368
15165 
15166         Vector&lt;StringSwitchCase&gt; cases;
15167         for (DFG::SwitchCase myCase : data-&gt;cases)
15168             cases.append(StringSwitchCase(myCase.value.stringImpl(), lowBlock(myCase.target.block)));
15169         std::sort(cases.begin(), cases.end());
15170         switchStringRecurse(data, buffer, length, cases, 0, 0, cases.size(), 0, false);
15171 
15172         m_out.appendTo(slowBlock, lastNext);
15173         switchStringSlow(data, string);
15174     }
15175 
15176     // The code for string switching is based closely on the same code in the DFG backend. While it
15177     // would be nice to reduce the amount of similar-looking code, it seems like this is one of
15178     // those algorithms where factoring out the common bits would result in more code than just
15179     // duplicating.
15180 
15181     struct StringSwitchCase {
15182         StringSwitchCase() { }
15183 
15184         StringSwitchCase(StringImpl* string, LBasicBlock target)
15185             : string(string)
15186             , target(target)
15187         {
15188         }
15189 
15190         bool operator&lt;(const StringSwitchCase&amp; other) const
15191         {
15192             return stringLessThan(*string, *other.string);
15193         }
15194 
15195         StringImpl* string;
15196         LBasicBlock target;
15197     };
15198 
15199     struct CharacterCase {
15200         CharacterCase()
15201             : character(0)
15202             , begin(0)
15203             , end(0)
15204         {
15205         }
15206 
15207         CharacterCase(LChar character, unsigned begin, unsigned end)
15208             : character(character)
15209             , begin(begin)
15210             , end(end)
15211         {
15212         }
15213 
15214         bool operator&lt;(const CharacterCase&amp; other) const
15215         {
15216             return character &lt; other.character;
15217         }
15218 
15219         LChar character;
15220         unsigned begin;
15221         unsigned end;
15222     };
15223 
15224     void switchStringRecurse(
15225         SwitchData* data, LValue buffer, LValue length, const Vector&lt;StringSwitchCase&gt;&amp; cases,
15226         unsigned numChecked, unsigned begin, unsigned end, unsigned alreadyCheckedLength,
15227         unsigned checkedExactLength)
15228     {
15229         LBasicBlock fallThrough = lowBlock(data-&gt;fallThrough.block);
15230 
15231         if (begin == end) {
15232             m_out.jump(fallThrough);
15233             return;
15234         }
15235 
15236         unsigned minLength = cases[begin].string-&gt;length();
15237         unsigned commonChars = minLength;
15238         bool allLengthsEqual = true;
15239         for (unsigned i = begin + 1; i &lt; end; ++i) {
15240             unsigned myCommonChars = numChecked;
15241             unsigned limit = std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
15242             for (unsigned j = numChecked; j &lt; limit; ++j) {
15243                 if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j))
15244                     break;
15245                 myCommonChars++;
15246             }
15247             commonChars = std::min(commonChars, myCommonChars);
15248             if (minLength != cases[i].string-&gt;length())
15249                 allLengthsEqual = false;
15250             minLength = std::min(minLength, cases[i].string-&gt;length());
15251         }
15252 
15253         if (checkedExactLength) {
15254             DFG_ASSERT(m_graph, m_node, alreadyCheckedLength == minLength, alreadyCheckedLength, minLength);
15255             DFG_ASSERT(m_graph, m_node, allLengthsEqual);
15256         }
15257 
15258         DFG_ASSERT(m_graph, m_node, minLength &gt;= commonChars, minLength, commonChars);
15259 
15260         if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
15261             m_out.check(m_out.below(length, m_out.constInt32(minLength)), unsure(fallThrough));
15262         if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
15263             m_out.check(m_out.notEqual(length, m_out.constInt32(minLength)), unsure(fallThrough));
15264 
15265         for (unsigned i = numChecked; i &lt; commonChars; ++i) {
15266             m_out.check(
15267                 m_out.notEqual(
15268                     m_out.load8ZeroExt32(buffer, m_heaps.characters8[i]),
15269                     m_out.constInt32(static_cast&lt;uint16_t&gt;(cases[begin].string-&gt;at(i)))),
15270                 unsure(fallThrough));
15271         }
15272 
15273         if (minLength == commonChars) {
15274             // This is the case where one of the cases is a prefix of all of the other cases.
15275             // We&#39;ve already checked that the input string is a prefix of all of the cases,
15276             // so we just check length to jump to that case.
15277 
15278             DFG_ASSERT(m_graph, m_node, cases[begin].string-&gt;length() == commonChars, cases[begin].string-&gt;length(), commonChars);
15279             for (unsigned i = begin + 1; i &lt; end; ++i)
15280                 DFG_ASSERT(m_graph, m_node, cases[i].string-&gt;length() &gt; commonChars, cases[i].string-&gt;length(), commonChars);
15281 
15282             if (allLengthsEqual) {
15283                 DFG_ASSERT(m_graph, m_node, end == begin + 1, end, begin);
15284                 m_out.jump(cases[begin].target);
15285                 return;
15286             }
15287 
15288             m_out.check(
15289                 m_out.equal(length, m_out.constInt32(commonChars)),
15290                 unsure(cases[begin].target));
15291 
15292             // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the length is
15293             // == commonChars. We get to this point if it is &gt;= minLength but not == commonChars.
15294             // Hence we know that it now must be &gt; minLength, i.e. that it&#39;s &gt;= minLength + 1.
15295             switchStringRecurse(
15296                 data, buffer, length, cases, commonChars, begin + 1, end, minLength + 1, false);
15297             return;
15298         }
15299 
15300         // At this point we know that the string is longer than commonChars, and we&#39;ve only verified
15301         // commonChars. Use a binary switch on the next unchecked character, i.e.
15302         // string[commonChars].
15303 
15304         DFG_ASSERT(m_graph, m_node, end &gt;= begin + 2, end, begin);
15305 
15306         LValue uncheckedChar = m_out.load8ZeroExt32(buffer, m_heaps.characters8[commonChars]);
15307 
15308         Vector&lt;CharacterCase&gt; characterCases;
15309         CharacterCase currentCase(cases[begin].string-&gt;at(commonChars), begin, begin + 1);
15310         for (unsigned i = begin + 1; i &lt; end; ++i) {
15311             LChar currentChar = cases[i].string-&gt;at(commonChars);
15312             if (currentChar != currentCase.character) {
15313                 currentCase.end = i;
15314                 characterCases.append(currentCase);
15315                 currentCase = CharacterCase(currentChar, i, i + 1);
15316             } else
15317                 currentCase.end = i + 1;
15318         }
15319         characterCases.append(currentCase);
15320 
15321         Vector&lt;LBasicBlock&gt; characterBlocks;
15322         for (unsigned i = characterCases.size(); i--;)
15323             characterBlocks.append(m_out.newBlock());
15324 
15325         Vector&lt;SwitchCase&gt; switchCases;
15326         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
15327             if (i)
15328                 DFG_ASSERT(m_graph, m_node, characterCases[i - 1].character &lt; characterCases[i].character);
15329             switchCases.append(SwitchCase(
15330                 m_out.constInt32(characterCases[i].character), characterBlocks[i], Weight()));
15331         }
15332         m_out.switchInstruction(uncheckedChar, switchCases, fallThrough, Weight());
15333 
15334         LBasicBlock lastNext = m_out.m_nextBlock;
15335         characterBlocks.append(lastNext); // Makes it convenient to set nextBlock.
15336         for (unsigned i = 0; i &lt; characterCases.size(); ++i) {
15337             m_out.appendTo(characterBlocks[i], characterBlocks[i + 1]);
15338             switchStringRecurse(
15339                 data, buffer, length, cases, commonChars + 1,
15340                 characterCases[i].begin, characterCases[i].end, minLength, allLengthsEqual);
15341         }
15342 
15343         DFG_ASSERT(m_graph, m_node, m_out.m_nextBlock == lastNext);
15344     }
15345 
15346     void switchStringSlow(SwitchData* data, LValue string)
15347     {
15348         // FIXME: We ought to be able to use computed gotos here. We would save the labels of the
15349         // blocks we want to jump to, and then request their addresses after compilation completes.
15350         // https://bugs.webkit.org/show_bug.cgi?id=144369
15351 
<a name="558" id="anc558"></a><span class="line-added">15352         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-added">15353 </span>
15354         LValue branchOffset = vmCall(
<a name="559" id="anc559"></a><span class="line-modified">15355             Int32, operationSwitchStringAndGetBranchOffset,</span>
<span class="line-modified">15356             weakPointer(globalObject), m_out.constIntPtr(data-&gt;switchTableIndex), string);</span>
15357 
15358         StringJumpTable&amp; table = codeBlock()-&gt;stringSwitchJumpTable(data-&gt;switchTableIndex);
15359 
15360         Vector&lt;SwitchCase&gt; cases;
15361         // These may be negative, or zero, or probably other stuff, too. We don&#39;t want to mess with HashSet&#39;s corner cases and we don&#39;t really care about throughput here.
15362         StdUnorderedSet&lt;int32_t&gt; alreadyHandled;
15363         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
15364             // FIXME: The fact that we&#39;re using the bytecode&#39;s switch table means that the
15365             // following DFG IR transformation would be invalid.
15366             //
15367             // Original code:
15368             //     switch (v) {
15369             //     case &quot;foo&quot;:
15370             //     case &quot;bar&quot;:
15371             //         things();
15372             //         break;
15373             //     default:
15374             //         break;
15375             //     }
15376             //
15377             // New code:
15378             //     switch (v) {
15379             //     case &quot;foo&quot;:
15380             //         instrumentFoo();
15381             //         goto _things;
15382             //     case &quot;bar&quot;:
15383             //         instrumentBar();
15384             //     _things:
15385             //         things();
15386             //         break;
15387             //     default:
15388             //         break;
15389             //     }
15390             //
15391             // Luckily, we don&#39;t currently do any such transformation. But it&#39;s kind of silly that
15392             // this is an issue.
15393             // https://bugs.webkit.org/show_bug.cgi?id=144635
15394 
15395             DFG::SwitchCase myCase = data-&gt;cases[i];
15396             StringJumpTable::StringOffsetTable::iterator iter =
15397                 table.offsetTable.find(myCase.value.stringImpl());
15398             DFG_ASSERT(m_graph, m_node, iter != table.offsetTable.end());
15399 
15400             if (!alreadyHandled.insert(iter-&gt;value.branchOffset).second)
15401                 continue;
15402 
15403             cases.append(SwitchCase(
15404                 m_out.constInt32(iter-&gt;value.branchOffset),
15405                 lowBlock(myCase.target.block), Weight(myCase.target.count)));
15406         }
15407 
15408         m_out.switchInstruction(
15409             branchOffset, cases, lowBlock(data-&gt;fallThrough.block),
15410             Weight(data-&gt;fallThrough.count));
15411     }
15412 
15413     // Calls the functor at the point of code generation where we know what the result type is.
15414     // You can emit whatever code you like at that point. Expects you to terminate the basic block.
15415     // When buildTypeOf() returns, it will have terminated all basic blocks that it created. So, if
15416     // you aren&#39;t using this as the terminator of a high-level block, you should create your own
15417     // contination and set it as the nextBlock (m_out.insertNewBlocksBefore(continuation)) before
15418     // calling this. For example:
15419     //
15420     // LBasicBlock continuation = m_out.newBlock();
15421     // LBasicBlock lastNext = m_out.insertNewBlocksBefore(continuation);
15422     // buildTypeOf(
15423     //     child, value,
15424     //     [&amp;] (TypeofType type) {
15425     //          do things;
15426     //          m_out.jump(continuation);
15427     //     });
15428     // m_out.appendTo(continuation, lastNext);
15429     template&lt;typename Functor&gt;
15430     void buildTypeOf(Edge child, LValue value, const Functor&amp; functor)
15431     {
15432         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);
15433 
15434         // Implements the following branching structure:
15435         //
15436         // if (is cell) {
15437         //     if (is object) {
15438         //         if (is function) {
15439         //             return function;
15440         //         } else if (doesn&#39;t have call trap and doesn&#39;t masquerade as undefined) {
15441         //             return object
15442         //         } else {
15443         //             return slowPath();
15444         //         }
15445         //     } else if (is string) {
15446         //         return string
15447         //     } else if (is bigint) {
15448         //         return bigint
15449         //     } else {
15450         //         return symbol
15451         //     }
15452         // } else if (is number) {
15453         //     return number
15454         // } else if (is null) {
15455         //     return object
15456         // } else if (is boolean) {
15457         //     return boolean
15458         // } else {
15459         //     return undefined
15460         // }
15461         //
15462         // FIXME: typeof Symbol should be more frequently seen than BigInt.
15463         // We should change the order of type detection based on this frequency.
15464         // https://bugs.webkit.org/show_bug.cgi?id=192650
15465 
15466         LBasicBlock cellCase = m_out.newBlock();
15467         LBasicBlock objectCase = m_out.newBlock();
15468         LBasicBlock functionCase = m_out.newBlock();
15469         LBasicBlock notFunctionCase = m_out.newBlock();
15470         LBasicBlock reallyObjectCase = m_out.newBlock();
15471         LBasicBlock slowPath = m_out.newBlock();
15472         LBasicBlock unreachable = m_out.newBlock();
15473         LBasicBlock notObjectCase = m_out.newBlock();
15474         LBasicBlock stringCase = m_out.newBlock();
15475         LBasicBlock notStringCase = m_out.newBlock();
15476         LBasicBlock bigIntCase = m_out.newBlock();
15477         LBasicBlock symbolCase = m_out.newBlock();
15478         LBasicBlock notCellCase = m_out.newBlock();
15479         LBasicBlock numberCase = m_out.newBlock();
15480         LBasicBlock notNumberCase = m_out.newBlock();
15481         LBasicBlock notNullCase = m_out.newBlock();
15482         LBasicBlock booleanCase = m_out.newBlock();
15483         LBasicBlock undefinedCase = m_out.newBlock();
15484 
15485         m_out.branch(isCell(value, provenType(child)), unsure(cellCase), unsure(notCellCase));
15486 
15487         LBasicBlock lastNext = m_out.appendTo(cellCase, objectCase);
15488         m_out.branch(isObject(value, provenType(child)), unsure(objectCase), unsure(notObjectCase));
15489 
15490         m_out.appendTo(objectCase, functionCase);
15491         m_out.branch(
15492             isFunction(value, provenType(child) &amp; SpecObject),
15493             unsure(functionCase), unsure(notFunctionCase));
15494 
15495         m_out.appendTo(functionCase, notFunctionCase);
15496         functor(TypeofType::Function);
15497 
15498         m_out.appendTo(notFunctionCase, reallyObjectCase);
15499         m_out.branch(
15500             isExoticForTypeof(value, provenType(child) &amp; (SpecObject - SpecFunction)),
15501             rarely(slowPath), usually(reallyObjectCase));
15502 
15503         m_out.appendTo(reallyObjectCase, slowPath);
15504         functor(TypeofType::Object);
15505 
15506         m_out.appendTo(slowPath, unreachable);
15507         VM&amp; vm = this-&gt;vm();
15508         LValue result = lazySlowPath(
15509             [=, &amp;vm] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
15510                 return createLazyCallGenerator(vm,
15511                     operationTypeOfObjectAsTypeofType, locations[0].directGPR(),
15512                     CCallHelpers::TrustedImmPtr(globalObject), locations[1].directGPR());
15513             }, value);
15514         Vector&lt;SwitchCase, 3&gt; cases;
15515         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Undefined)), undefinedCase));
15516         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Object)), reallyObjectCase));
15517         cases.append(SwitchCase(m_out.constInt32(static_cast&lt;int32_t&gt;(TypeofType::Function)), functionCase));
15518         m_out.switchInstruction(m_out.castToInt32(result), cases, unreachable, Weight());
15519 
15520         m_out.appendTo(unreachable, notObjectCase);
15521         m_out.unreachable();
15522 
15523         m_out.appendTo(notObjectCase, stringCase);
15524         m_out.branch(
15525             isString(value, provenType(child) &amp; (SpecCell - SpecObject)),
15526             unsure(stringCase), unsure(notStringCase));
15527 
15528         m_out.appendTo(stringCase, notStringCase);
15529         functor(TypeofType::String);
15530 
15531         m_out.appendTo(notStringCase, bigIntCase);
15532         m_out.branch(
15533             isBigInt(value, provenType(child) &amp; (SpecCell - SpecObject - SpecString)),
15534             unsure(bigIntCase), unsure(symbolCase));
15535 
15536         m_out.appendTo(bigIntCase, symbolCase);
15537         functor(TypeofType::BigInt);
15538 
15539         m_out.appendTo(symbolCase, notCellCase);
15540         functor(TypeofType::Symbol);
15541 
15542         m_out.appendTo(notCellCase, numberCase);
15543         m_out.branch(
15544             isNumber(value, provenType(child) &amp; ~SpecCell),
15545             unsure(numberCase), unsure(notNumberCase));
15546 
15547         m_out.appendTo(numberCase, notNumberCase);
15548         functor(TypeofType::Number);
15549 
15550         m_out.appendTo(notNumberCase, notNullCase);
15551         LValue isNull;
15552         if (provenType(child) &amp; SpecOther)
<a name="560" id="anc560"></a><span class="line-modified">15553             isNull = m_out.equal(value, m_out.constInt64(JSValue::ValueNull));</span>
15554         else
15555             isNull = m_out.booleanFalse;
15556         m_out.branch(isNull, unsure(reallyObjectCase), unsure(notNullCase));
15557 
15558         m_out.appendTo(notNullCase, booleanCase);
15559         m_out.branch(
15560             isBoolean(value, provenType(child) &amp; ~(SpecCell | SpecFullNumber)),
15561             unsure(booleanCase), unsure(undefinedCase));
15562 
15563         m_out.appendTo(booleanCase, undefinedCase);
15564         functor(TypeofType::Boolean);
15565 
15566         m_out.appendTo(undefinedCase, lastNext);
15567         functor(TypeofType::Undefined);
15568     }
15569 
15570     TypedPointer pointerIntoTypedArray(LValue storage, LValue index, TypedArrayType type)
15571     {
15572         LValue offset = m_out.shl(m_out.zeroExtPtr(index), m_out.constIntPtr(logElementSize(type)));
15573 
15574         return TypedPointer(
15575             m_heaps.typedArrayProperties,
15576             m_out.add(
15577                 storage,
15578                 offset
15579             ));
15580     }
15581 
15582     LValue loadFromIntTypedArray(TypedPointer pointer, TypedArrayType type)
15583     {
15584         switch (elementSize(type)) {
15585         case 1:
15586             return isSigned(type) ? m_out.load8SignExt32(pointer) : m_out.load8ZeroExt32(pointer);
15587         case 2:
15588             return isSigned(type) ? m_out.load16SignExt32(pointer) : m_out.load16ZeroExt32(pointer);
15589         case 4:
15590             return m_out.load32(pointer);
15591         default:
15592             DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
15593         }
15594     }
15595 
15596     Output::StoreType storeType(TypedArrayType type)
15597     {
15598         if (isInt(type)) {
15599             switch (elementSize(type)) {
15600             case 1:
15601                 return Output::Store32As8;
15602             case 2:
15603                 return Output::Store32As16;
15604             case 4:
15605                 return Output::Store32;
15606             default:
15607                 DFG_CRASH(m_graph, m_node, &quot;Bad element size&quot;);
15608                 return Output::Store32;
15609             }
15610         }
15611         switch (type) {
15612         case TypeFloat32:
15613             return Output::StoreFloat;
15614         case TypeFloat64:
15615             return Output::StoreDouble;
15616         default:
15617             DFG_CRASH(m_graph, m_node, &quot;Bad typed array type&quot;);
15618         }
15619     }
15620 
15621     void setIntTypedArrayLoadResult(LValue result, TypedArrayType type, bool canSpeculate = false)
15622     {
15623         if (elementSize(type) &lt; 4 || isSigned(type)) {
15624             setInt32(result);
15625             return;
15626         }
15627 
15628         if (m_node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
15629             speculate(
15630                 Overflow, noValue(), 0, m_out.lessThan(result, m_out.int32Zero));
15631             setInt32(result);
15632             return;
15633         }
15634 
15635         if (m_node-&gt;shouldSpeculateInt52()) {
15636             setStrictInt52(m_out.zeroExt(result, Int64));
15637             return;
15638         }
15639 
15640         setDouble(m_out.unsignedToDouble(result));
15641     }
15642 
15643     LValue getIntTypedArrayStoreOperand(Edge edge, bool isClamped = false)
15644     {
15645         LValue intValue;
15646         switch (edge.useKind()) {
15647         case Int52RepUse:
15648         case Int32Use: {
15649             if (edge.useKind() == Int32Use)
15650                 intValue = lowInt32(edge);
15651             else
15652                 intValue = m_out.castToInt32(lowStrictInt52(edge));
15653 
15654             if (isClamped) {
15655                 LBasicBlock atLeastZero = m_out.newBlock();
15656                 LBasicBlock continuation = m_out.newBlock();
15657 
15658                 Vector&lt;ValueFromBlock, 2&gt; intValues;
15659                 intValues.append(m_out.anchor(m_out.int32Zero));
15660                 m_out.branch(
15661                     m_out.lessThan(intValue, m_out.int32Zero),
15662                     unsure(continuation), unsure(atLeastZero));
15663 
15664                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, continuation);
15665 
15666                 intValues.append(m_out.anchor(m_out.select(
15667                     m_out.greaterThan(intValue, m_out.constInt32(255)),
15668                     m_out.constInt32(255),
15669                     intValue)));
15670                 m_out.jump(continuation);
15671 
15672                 m_out.appendTo(continuation, lastNext);
15673                 intValue = m_out.phi(Int32, intValues);
15674             }
15675             break;
15676         }
15677 
15678         case DoubleRepUse: {
15679             LValue doubleValue = lowDouble(edge);
15680 
15681             if (isClamped) {
15682                 LBasicBlock atLeastZero = m_out.newBlock();
15683                 LBasicBlock withinRange = m_out.newBlock();
15684                 LBasicBlock continuation = m_out.newBlock();
15685 
15686                 Vector&lt;ValueFromBlock, 3&gt; intValues;
15687                 intValues.append(m_out.anchor(m_out.int32Zero));
15688                 m_out.branch(
15689                     m_out.doubleLessThanOrUnordered(doubleValue, m_out.doubleZero),
15690                     unsure(continuation), unsure(atLeastZero));
15691 
15692                 LBasicBlock lastNext = m_out.appendTo(atLeastZero, withinRange);
15693                 intValues.append(m_out.anchor(m_out.constInt32(255)));
15694                 m_out.branch(
15695                     m_out.doubleGreaterThan(doubleValue, m_out.constDouble(255)),
15696                     unsure(continuation), unsure(withinRange));
15697 
15698                 m_out.appendTo(withinRange, continuation);
15699                 intValues.append(m_out.anchor(m_out.doubleToInt(doubleValue)));
15700                 m_out.jump(continuation);
15701 
15702                 m_out.appendTo(continuation, lastNext);
15703                 intValue = m_out.phi(Int32, intValues);
15704             } else
15705                 intValue = doubleToInt32(doubleValue);
15706             break;
15707         }
15708 
15709         default:
15710             DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
15711         }
15712 
15713         return intValue;
15714     }
15715 
15716     LValue doubleToInt32(LValue doubleValue, double low, double high, bool isSigned = true)
15717     {
15718         LBasicBlock greatEnough = m_out.newBlock();
15719         LBasicBlock withinRange = m_out.newBlock();
15720         LBasicBlock slowPath = m_out.newBlock();
15721         LBasicBlock continuation = m_out.newBlock();
15722 
15723         Vector&lt;ValueFromBlock, 2&gt; results;
15724 
15725         m_out.branch(
15726             m_out.doubleGreaterThanOrEqual(doubleValue, m_out.constDouble(low)),
15727             unsure(greatEnough), unsure(slowPath));
15728 
15729         LBasicBlock lastNext = m_out.appendTo(greatEnough, withinRange);
15730         m_out.branch(
15731             m_out.doubleLessThanOrEqual(doubleValue, m_out.constDouble(high)),
15732             unsure(withinRange), unsure(slowPath));
15733 
15734         m_out.appendTo(withinRange, slowPath);
15735         LValue fastResult;
15736         if (isSigned)
15737             fastResult = m_out.doubleToInt(doubleValue);
15738         else
15739             fastResult = m_out.doubleToUInt(doubleValue);
15740         results.append(m_out.anchor(fastResult));
15741         m_out.jump(continuation);
15742 
15743         m_out.appendTo(slowPath, continuation);
<a name="561" id="anc561"></a><span class="line-modified">15744         results.append(m_out.anchor(m_out.callWithoutSideEffects(Int32, operationToInt32, doubleValue)));</span>
15745         m_out.jump(continuation);
15746 
15747         m_out.appendTo(continuation, lastNext);
15748         return m_out.phi(Int32, results);
15749     }
15750 
15751     LValue doubleToInt32(LValue doubleValue)
15752     {
15753 #if CPU(ARM64)
15754         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics()) {
15755             PatchpointValue* patchpoint = m_out.patchpoint(Int32);
15756             patchpoint-&gt;append(ConstrainedValue(doubleValue, B3::ValueRep::SomeRegister));
15757             patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15758                 jit.convertDoubleToInt32UsingJavaScriptSemantics(params[1].fpr(), params[0].gpr());
15759             });
15760             patchpoint-&gt;effects = Effects::none();
15761             return patchpoint;
15762         }
15763 #endif
15764 
15765         if (hasSensibleDoubleToInt())
15766             return sensibleDoubleToInt32(doubleValue);
15767 
15768         double limit = pow(2, 31) - 1;
15769         return doubleToInt32(doubleValue, -limit, limit);
15770     }
15771 
15772     LValue sensibleDoubleToInt32(LValue doubleValue)
15773     {
15774         LBasicBlock slowPath = m_out.newBlock();
15775         LBasicBlock continuation = m_out.newBlock();
15776 
15777         LValue fastResultValue = m_out.doubleToInt(doubleValue);
15778         ValueFromBlock fastResult = m_out.anchor(fastResultValue);
15779         m_out.branch(
15780             m_out.equal(fastResultValue, m_out.constInt32(0x80000000)),
15781             rarely(slowPath), usually(continuation));
15782 
15783         LBasicBlock lastNext = m_out.appendTo(slowPath, continuation);
<a name="562" id="anc562"></a><span class="line-modified">15784         ValueFromBlock slowResult = m_out.anchor(m_out.callWithoutSideEffects(Int32, operationToInt32SensibleSlow, doubleValue));</span>

15785         m_out.jump(continuation);
15786 
15787         m_out.appendTo(continuation, lastNext);
15788         return m_out.phi(Int32, fastResult, slowResult);
15789     }
15790 
15791     // This is a mechanism for creating a code generator that fills in a gap in the code using our
15792     // own MacroAssembler. This is useful for slow paths that involve a lot of code and we don&#39;t want
15793     // to pay the price of B3 optimizing it. A lazy slow path will only be generated if it actually
15794     // executes. On the other hand, a lazy slow path always incurs the cost of two additional jumps.
15795     // Also, the lazy slow path&#39;s register allocation state is slaved to whatever B3 did, so you
15796     // have to use a ScratchRegisterAllocator to try to use some unused registers and you may have
15797     // to spill to top of stack if there aren&#39;t enough registers available.
15798     //
15799     // Lazy slow paths involve three different stages of execution. Each stage has unique
15800     // capabilities and knowledge. The stages are:
15801     //
15802     // 1) DFG-&gt;B3 lowering, i.e. code that runs in this phase. Lowering is the last time you will
15803     //    have access to LValues. If there is an LValue that needs to be fed as input to a lazy slow
15804     //    path, then you must pass it as an argument here (as one of the varargs arguments after the
15805     //    functor). But, lowering doesn&#39;t know which registers will be used for those LValues. Hence
15806     //    you pass a lambda to lazySlowPath() and that lambda will run during stage (2):
15807     //
15808     // 2) FTLCompile.cpp&#39;s fixFunctionBasedOnStackMaps. This code is the only stage at which we know
15809     //    the mapping from arguments passed to this method in (1) and the registers that B3
15810     //    selected for those arguments. You don&#39;t actually want to generate any code here, since then
15811     //    the slow path wouldn&#39;t actually be lazily generated. Instead, you want to save the
15812     //    registers being used for the arguments and defer code generation to stage (3) by creating
15813     //    and returning a LazySlowPath::Generator:
15814     //
15815     // 3) LazySlowPath&#39;s generate() method. This code runs in response to the lazy slow path
15816     //    executing for the first time. It will call the generator you created in stage (2).
15817     //
15818     // Note that each time you invoke stage (1), stage (2) may be invoked zero, one, or many times.
15819     // Stage (2) will usually be invoked once for stage (1). But, B3 may kill the code, in which
15820     // case stage (2) won&#39;t run. B3 may duplicate the code (for example via tail duplication),
15821     // leading to many calls to your stage (2) lambda. Stage (3) may be called zero or once for each
15822     // stage (2). It will be called zero times if the slow path never runs. This is what you hope for
15823     // whenever you use the lazySlowPath() mechanism.
15824     //
15825     // A typical use of lazySlowPath() will look like the example below, which just creates a slow
15826     // path that adds some value to the input and returns it.
15827     //
15828     // // Stage (1) is here. This is your last chance to figure out which LValues to use as inputs.
15829     // // Notice how we pass &quot;input&quot; as an argument to lazySlowPath().
15830     // LValue input = ...;
15831     // int addend = ...;
15832     // LValue output = lazySlowPath(
15833     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
15834     //         // Stage (2) is here. This is your last chance to figure out which registers are used
15835     //         // for which values. Location zero is always the return value. You can ignore it if
15836     //         // you don&#39;t want to return anything. Location 1 is the register for the first
15837     //         // argument to the lazySlowPath(), i.e. &quot;input&quot;. Note that the Location object could
15838     //         // also hold an FPR, if you are passing a double.
15839     //         GPRReg outputGPR = locations[0].directGPR();
15840     //         GPRReg inputGPR = locations[1].directGPR();
15841     //         return LazySlowPath::createGenerator(
15842     //             [=] (CCallHelpers&amp; jit, LazySlowPath::GenerationParams&amp; params) {
15843     //                 // Stage (3) is here. This is when you generate code. You have access to the
15844     //                 // registers you collected in stage (2) because this lambda closes over those
15845     //                 // variables (outputGPR and inputGPR). You also have access to whatever extra
15846     //                 // data you collected in stage (1), such as the addend in this case.
15847     //                 jit.add32(TrustedImm32(addend), inputGPR, outputGPR);
15848     //                 // You have to end by jumping to done. There is nothing to fall through to.
15849     //                 // You can also jump to the exception handler (see LazySlowPath.h for more
15850     //                 // info). Note that currently you cannot OSR exit.
15851     //                 params.doneJumps.append(jit.jump());
15852     //             });
15853     //     },
15854     //     input);
15855     //
15856     // You can basically pass as many inputs as you like, either using this varargs form, or by
15857     // passing a Vector of LValues.
15858     //
15859     // Note that if your slow path is only doing a call, you can use the createLazyCallGenerator()
15860     // helper. For example:
15861     //
15862     // LValue input = ...;
15863     // LValue output = lazySlowPath(
15864     //     [=] (const Vector&lt;Location&gt;&amp; locations) -&gt; RefPtr&lt;LazySlowPath::Generator&gt; {
15865     //         return createLazyCallGenerator(
15866     //             operationDoThings, locations[0].directGPR(), locations[1].directGPR());
15867     //     }, input);
15868     //
15869     // Finally, note that all of the lambdas - both the stage (2) lambda and the stage (3) lambda -
15870     // run after the function that created them returns. Hence, you should not use by-reference
15871     // capture (i.e. [&amp;]) in any of these lambdas.
15872     template&lt;typename Functor, typename... ArgumentTypes&gt;
15873     PatchpointValue* lazySlowPath(const Functor&amp; functor, ArgumentTypes... arguments)
15874     {
15875         return lazySlowPath(functor, Vector&lt;LValue&gt;{ arguments... });
15876     }
15877 
15878     template&lt;typename Functor&gt;
15879     PatchpointValue* lazySlowPath(const Functor&amp; functor, const Vector&lt;LValue&gt;&amp; userArguments)
15880     {
15881         CodeOrigin origin = m_node-&gt;origin.semantic;
15882 
15883         PatchpointValue* result = m_out.patchpoint(B3::Int64);
15884         for (LValue arg : userArguments)
15885             result-&gt;append(ConstrainedValue(arg, B3::ValueRep::SomeRegister));
15886 
15887         RefPtr&lt;PatchpointExceptionHandle&gt; exceptionHandle =
15888             preparePatchpointForExceptions(result);
15889 
15890         result-&gt;clobber(RegisterSet::macroScratchRegisters());
15891         State* state = &amp;m_ftlState;
15892 
15893         result-&gt;setGenerator(
15894             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
15895                 Vector&lt;Location&gt; locations;
15896                 for (const B3::ValueRep&amp; rep : params)
15897                     locations.append(Location::forValueRep(rep));
15898 
15899                 RefPtr&lt;LazySlowPath::Generator&gt; generator = functor(locations);
15900 
15901                 CCallHelpers::PatchableJump patchableJump = jit.patchableJump();
15902                 CCallHelpers::Label done = jit.label();
15903 
15904                 RegisterSet usedRegisters = params.unavailableRegisters();
15905 
15906                 RefPtr&lt;ExceptionTarget&gt; exceptionTarget =
15907                     exceptionHandle-&gt;scheduleExitCreation(params);
15908 
15909                 // FIXME: As part of handling exceptions, we need to create a concrete OSRExit here.
15910                 // Doing so should automagically register late paths that emit exit thunks.
15911 
15912                 params.addLatePath(
15913                     [=] (CCallHelpers&amp; jit) {
15914                         AllowMacroScratchRegisterUsage allowScratch(jit);
15915                         patchableJump.m_jump.link(&amp;jit);
15916                         unsigned index = state-&gt;jitCode-&gt;lazySlowPaths.size();
15917                         state-&gt;jitCode-&gt;lazySlowPaths.append(nullptr);
15918                         jit.pushToSaveImmediateWithoutTouchingRegisters(
15919                             CCallHelpers::TrustedImm32(index));
15920                         CCallHelpers::Jump generatorJump = jit.jump();
15921 
15922                         // Note that so long as we&#39;re here, we don&#39;t really know if our late path
15923                         // runs before or after any other late paths that we might depend on, like
15924                         // the exception thunk.
15925 
15926                         RefPtr&lt;JITCode&gt; jitCode = state-&gt;jitCode;
15927                         VM* vm = &amp;state-&gt;graph.m_vm;
15928 
15929                         jit.addLinkTask(
15930                             [=] (LinkBuffer&amp; linkBuffer) {
15931                                 linkBuffer.link(generatorJump,
15932                                     CodeLocationLabel&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(lazySlowPathGenerationThunkGenerator).code()));
15933 
15934                                 std::unique_ptr&lt;LazySlowPath&gt; lazySlowPath = makeUnique&lt;LazySlowPath&gt;();
15935 
15936                                 auto linkedPatchableJump = CodeLocationJump&lt;JSInternalPtrTag&gt;(linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(patchableJump));
15937 
15938                                 CodeLocationLabel&lt;JSInternalPtrTag&gt; linkedDone = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(done);
15939 
15940                                 CallSiteIndex callSiteIndex =
15941                                     jitCode-&gt;common.addUniqueCallSiteIndex(origin);
15942 
15943                                 lazySlowPath-&gt;initialize(
15944                                         linkedPatchableJump, linkedDone,
15945                                         exceptionTarget-&gt;label(linkBuffer), usedRegisters,
15946                                         callSiteIndex, generator);
15947 
15948                                 jitCode-&gt;lazySlowPaths[index] = WTFMove(lazySlowPath);
15949                             });
15950                     });
15951             });
15952         return result;
15953     }
15954 
15955     void speculate(
15956         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition)
15957     {
15958         appendOSRExit(kind, lowValue, highValue, failCondition, m_origin);
15959     }
15960 
15961     void speculate(
15962         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition)
15963     {
15964         appendOSRExit(kind, lowValue, profile, failCondition, m_origin);
15965     }
15966 
15967     void terminate(ExitKind kind)
15968     {
15969         speculate(kind, noValue(), nullptr, m_out.booleanTrue);
15970         didAlreadyTerminate();
15971     }
15972 
15973     void didAlreadyTerminate()
15974     {
15975         m_state.setIsValid(false);
15976     }
15977 
15978     void simulatedTypeCheck(Edge highValue, SpeculatedType typesPassedThrough)
15979     {
15980         m_interpreter.filter(highValue, typesPassedThrough);
15981     }
15982 
15983     void typeCheck(
15984         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
15985         LValue failCondition, ExitKind exitKind = BadType)
15986     {
15987         appendTypeCheck(lowValue, highValue, typesPassedThrough, failCondition, exitKind);
15988     }
15989 
15990     void appendTypeCheck(
15991         FormattedValue lowValue, Edge highValue, SpeculatedType typesPassedThrough,
15992         LValue failCondition, ExitKind exitKind)
15993     {
15994         if (!m_interpreter.needsTypeCheck(highValue, typesPassedThrough))
15995             return;
15996         ASSERT(mayHaveTypeCheck(highValue.useKind()));
15997         appendOSRExit(exitKind, lowValue, highValue.node(), failCondition, m_origin);
15998         m_interpreter.filter(highValue, typesPassedThrough);
15999     }
16000 
16001     LValue lowInt32(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16002     {
16003         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || (edge.useKind() == Int32Use || edge.useKind() == KnownInt32Use));
16004 
16005         if (edge-&gt;hasConstant()) {
16006             JSValue value = edge-&gt;asJSValue();
16007             simulatedTypeCheck(edge, SpecInt32Only);
16008             if (!value.isInt32()) {
16009                 if (mayHaveTypeCheck(edge.useKind()))
16010                     terminate(Uncountable);
16011                 return m_out.int32Zero;
16012             }
16013             LValue result = m_out.constInt32(value.asInt32());
16014             result-&gt;setOrigin(B3::Origin(edge.node()));
16015             return result;
16016         }
16017 
16018         LoweredNodeValue value = m_int32Values.get(edge.node());
16019         if (isValid(value)) {
16020             simulatedTypeCheck(edge, SpecInt32Only);
16021             return value.value();
16022         }
16023 
16024         value = m_strictInt52Values.get(edge.node());
16025         if (isValid(value))
16026             return strictInt52ToInt32(edge, value.value());
16027 
16028         value = m_int52Values.get(edge.node());
16029         if (isValid(value))
16030             return strictInt52ToInt32(edge, int52ToStrictInt52(value.value()));
16031 
16032         value = m_jsValueValues.get(edge.node());
16033         if (isValid(value)) {
16034             LValue boxedResult = value.value();
16035             FTL_TYPE_CHECK(
16036                 jsValueValue(boxedResult), edge, SpecInt32Only, isNotInt32(boxedResult));
16037             LValue result = unboxInt32(boxedResult);
16038             setInt32(edge.node(), result);
16039             return result;
16040         }
16041 
16042         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecInt32Only), provenType(edge));
16043         if (mayHaveTypeCheck(edge.useKind()))
16044             terminate(Uncountable);
16045         return m_out.int32Zero;
16046     }
16047 
16048     enum Int52Kind { StrictInt52, Int52 };
16049     LValue lowInt52(Edge edge, Int52Kind kind)
16050     {
16051         DFG_ASSERT(m_graph, m_node, edge.useKind() == Int52RepUse, edge.useKind());
16052 
16053         LoweredNodeValue value;
16054 
16055         switch (kind) {
16056         case Int52:
16057             value = m_int52Values.get(edge.node());
16058             if (isValid(value))
16059                 return value.value();
16060 
16061             value = m_strictInt52Values.get(edge.node());
16062             if (isValid(value))
16063                 return strictInt52ToInt52(value.value());
16064             break;
16065 
16066         case StrictInt52:
16067             value = m_strictInt52Values.get(edge.node());
16068             if (isValid(value))
16069                 return value.value();
16070 
16071             value = m_int52Values.get(edge.node());
16072             if (isValid(value))
16073                 return int52ToStrictInt52(value.value());
16074             break;
16075         }
16076 
16077         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
16078         if (mayHaveTypeCheck(edge.useKind()))
16079             terminate(Uncountable);
16080         return m_out.int64Zero;
16081     }
16082 
16083     LValue lowInt52(Edge edge)
16084     {
16085         return lowInt52(edge, Int52);
16086     }
16087 
16088     LValue lowStrictInt52(Edge edge)
16089     {
16090         return lowInt52(edge, StrictInt52);
16091     }
16092 
16093     bool betterUseStrictInt52(Node* node)
16094     {
16095         return !isValid(m_int52Values.get(node));
16096     }
16097     bool betterUseStrictInt52(Edge edge)
16098     {
16099         return betterUseStrictInt52(edge.node());
16100     }
16101     template&lt;typename T&gt;
16102     Int52Kind bestInt52Kind(T node)
16103     {
16104         return betterUseStrictInt52(node) ? StrictInt52 : Int52;
16105     }
16106     Int52Kind opposite(Int52Kind kind)
16107     {
16108         switch (kind) {
16109         case Int52:
16110             return StrictInt52;
16111         case StrictInt52:
16112             return Int52;
16113         }
16114         DFG_CRASH(m_graph, m_node, &quot;Bad use kind&quot;);
16115         return Int52;
16116     }
16117 
16118     LValue lowWhicheverInt52(Edge edge, Int52Kind&amp; kind)
16119     {
16120         kind = bestInt52Kind(edge);
16121         return lowInt52(edge, kind);
16122     }
16123 
16124     LValue lowCell(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16125     {
16126         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || DFG::isCell(edge.useKind()), edge.useKind());
16127 
16128         if (edge-&gt;op() == JSConstant) {
16129             FrozenValue* value = edge-&gt;constant();
16130             simulatedTypeCheck(edge, SpecCellCheck);
16131             if (!value-&gt;value().isCell()) {
16132                 if (mayHaveTypeCheck(edge.useKind()))
16133                     terminate(Uncountable);
16134                 return m_out.intPtrZero;
16135             }
16136             LValue result = frozenPointer(value);
16137             result-&gt;setOrigin(B3::Origin(edge.node()));
16138             return result;
16139         }
16140 
16141         LoweredNodeValue value = m_jsValueValues.get(edge.node());
16142         if (isValid(value)) {
16143             LValue uncheckedValue = value.value();
16144             FTL_TYPE_CHECK(
16145                 jsValueValue(uncheckedValue), edge, SpecCellCheck, isNotCell(uncheckedValue));
16146             return uncheckedValue;
16147         }
16148 
16149         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecCellCheck), provenType(edge));
16150         if (mayHaveTypeCheck(edge.useKind()))
16151             terminate(Uncountable);
16152         return m_out.intPtrZero;
16153     }
16154 
16155     LValue lowObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16156     {
16157         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
16158 
16159         LValue result = lowCell(edge, mode);
16160         speculateObject(edge, result);
16161         return result;
16162     }
16163 
16164     LValue lowRegExpObject(Edge edge)
16165     {
16166         LValue result = lowCell(edge);
16167         speculateRegExpObject(edge, result);
16168         return result;
16169     }
16170 
16171     LValue lowMapObject(Edge edge)
16172     {
16173         LValue result = lowCell(edge);
16174         speculateMapObject(edge, result);
16175         return result;
16176     }
16177 
16178     LValue lowSetObject(Edge edge)
16179     {
16180         LValue result = lowCell(edge);
16181         speculateSetObject(edge, result);
16182         return result;
16183     }
16184 
16185     LValue lowWeakMapObject(Edge edge)
16186     {
16187         LValue result = lowCell(edge);
16188         speculateWeakMapObject(edge, result);
16189         return result;
16190     }
16191 
16192     LValue lowWeakSetObject(Edge edge)
16193     {
16194         LValue result = lowCell(edge);
16195         speculateWeakSetObject(edge, result);
16196         return result;
16197     }
16198 
16199     LValue lowDataViewObject(Edge edge)
16200     {
16201         LValue result = lowCell(edge);
16202         speculateDataViewObject(edge, result);
16203         return result;
16204     }
16205 
<a name="563" id="anc563"></a><span class="line-added">16206     LValue lowDateObject(Edge edge)</span>
<span class="line-added">16207     {</span>
<span class="line-added">16208         LValue result = lowCell(edge);</span>
<span class="line-added">16209         speculateDateObject(edge, result);</span>
<span class="line-added">16210         return result;</span>
<span class="line-added">16211     }</span>
<span class="line-added">16212 </span>
16213     LValue lowString(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16214     {
16215         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringUse || edge.useKind() == KnownStringUse || edge.useKind() == StringIdentUse);
16216 
16217         LValue result = lowCell(edge, mode);
16218         speculateString(edge, result);
16219         return result;
16220     }
16221 
16222     LValue lowStringIdent(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16223     {
16224         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == StringIdentUse);
16225 
16226         LValue string = lowString(edge, mode);
16227         LValue stringImpl = m_out.loadPtr(string, m_heaps.JSString_value);
16228         speculateStringIdent(edge, string, stringImpl);
16229         return stringImpl;
16230     }
16231 
16232     LValue lowSymbol(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16233     {
16234         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == SymbolUse);
16235 
16236         LValue result = lowCell(edge, mode);
16237         speculateSymbol(edge, result);
16238         return result;
16239     }
16240 
16241     LValue lowBigInt(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16242     {
16243         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BigIntUse);
16244 
16245         LValue result = lowCell(edge, mode);
16246         speculateBigInt(edge, result);
16247         return result;
16248     }
16249 
16250     LValue lowNonNullObject(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16251     {
16252         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == ObjectUse);
16253 
16254         LValue result = lowCell(edge, mode);
16255         speculateNonNullObject(edge, result);
16256         return result;
16257     }
16258 
16259     LValue lowBoolean(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16260     {
16261         ASSERT_UNUSED(mode, mode == ManualOperandSpeculation || edge.useKind() == BooleanUse || edge.useKind() == KnownBooleanUse);
16262 
16263         if (edge-&gt;hasConstant()) {
16264             JSValue value = edge-&gt;asJSValue();
16265             simulatedTypeCheck(edge, SpecBoolean);
16266             if (!value.isBoolean()) {
16267                 if (mayHaveTypeCheck(edge.useKind()))
16268                     terminate(Uncountable);
16269                 return m_out.booleanFalse;
16270             }
16271             LValue result = m_out.constBool(value.asBoolean());
16272             result-&gt;setOrigin(B3::Origin(edge.node()));
16273             return result;
16274         }
16275 
16276         LoweredNodeValue value = m_booleanValues.get(edge.node());
16277         if (isValid(value)) {
16278             simulatedTypeCheck(edge, SpecBoolean);
16279             return value.value();
16280         }
16281 
16282         value = m_jsValueValues.get(edge.node());
16283         if (isValid(value)) {
16284             LValue unboxedResult = value.value();
16285             FTL_TYPE_CHECK(
16286                 jsValueValue(unboxedResult), edge, SpecBoolean, isNotBoolean(unboxedResult));
16287             LValue result = unboxBoolean(unboxedResult);
16288             setBoolean(edge.node(), result);
16289             return result;
16290         }
16291 
16292         DFG_ASSERT(m_graph, m_node, !(provenType(edge) &amp; SpecBoolean), provenType(edge));
16293         if (mayHaveTypeCheck(edge.useKind()))
16294             terminate(Uncountable);
16295         return m_out.booleanFalse;
16296     }
16297 
16298     LValue lowDouble(Edge edge)
16299     {
16300         DFG_ASSERT(m_graph, m_node, isDouble(edge.useKind()), edge.useKind());
16301 
16302         LoweredNodeValue value = m_doubleValues.get(edge.node());
16303         if (isValid(value))
16304             return value.value();
16305         DFG_ASSERT(m_graph, m_node, !provenType(edge), provenType(edge));
16306         if (mayHaveTypeCheck(edge.useKind()))
16307             terminate(Uncountable);
16308         return m_out.doubleZero;
16309     }
16310 
16311     LValue lowJSValue(Edge edge, OperandSpeculationMode mode = AutomaticOperandSpeculation)
16312     {
16313         DFG_ASSERT(m_graph, m_node, mode == ManualOperandSpeculation || edge.useKind() == UntypedUse, m_node-&gt;op(), edge.useKind());
16314         DFG_ASSERT(m_graph, m_node, !isDouble(edge.useKind()), m_node-&gt;op(), edge.useKind());
16315         DFG_ASSERT(m_graph, m_node, edge.useKind() != Int52RepUse, m_node-&gt;op(), edge.useKind());
16316 
16317         if (edge-&gt;hasConstant()) {
16318             LValue result = m_out.constInt64(JSValue::encode(edge-&gt;asJSValue()));
16319             result-&gt;setOrigin(B3::Origin(edge.node()));
16320             return result;
16321         }
16322 
16323         LoweredNodeValue value = m_jsValueValues.get(edge.node());
16324         if (isValid(value))
16325             return value.value();
16326 
16327         value = m_int32Values.get(edge.node());
16328         if (isValid(value)) {
16329             LValue result = boxInt32(value.value());
16330             setJSValue(edge.node(), result);
16331             return result;
16332         }
16333 
16334         value = m_booleanValues.get(edge.node());
16335         if (isValid(value)) {
16336             LValue result = boxBoolean(value.value());
16337             setJSValue(edge.node(), result);
16338             return result;
16339         }
16340 
16341         DFG_CRASH(m_graph, m_node, makeString(&quot;Value not defined: &quot;, String::number(edge.node()-&gt;index())).ascii().data());
16342         return 0;
16343     }
16344 
16345     LValue lowNotCell(Edge edge)
16346     {
16347         LValue result = lowJSValue(edge, ManualOperandSpeculation);
16348         FTL_TYPE_CHECK(jsValueValue(result), edge, ~SpecCellCheck, isCell(result));
16349         return result;
16350     }
16351 
16352     LValue lowStorage(Edge edge)
16353     {
16354         LoweredNodeValue value = m_storageValues.get(edge.node());
16355         if (isValid(value))
16356             return value.value();
16357 
16358         LValue result = lowCell(edge);
16359         setStorage(edge.node(), result);
16360         return result;
16361     }
16362 
16363     LValue strictInt52ToInt32(Edge edge, LValue value)
16364     {
16365         LValue result = m_out.castToInt32(value);
16366         FTL_TYPE_CHECK(
16367             noValue(), edge, SpecInt32Only,
16368             m_out.notEqual(m_out.signExt32To64(result), value));
16369         setInt32(edge.node(), result);
16370         return result;
16371     }
16372 
16373     LValue strictInt52ToDouble(LValue value)
16374     {
16375         return m_out.intToDouble(value);
16376     }
16377 
16378     LValue strictInt52ToJSValue(LValue value)
16379     {
16380         LBasicBlock isInt32 = m_out.newBlock();
16381         LBasicBlock isDouble = m_out.newBlock();
16382         LBasicBlock continuation = m_out.newBlock();
16383 
16384         Vector&lt;ValueFromBlock, 2&gt; results;
16385 
16386         LValue int32Value = m_out.castToInt32(value);
16387         m_out.branch(
16388             m_out.equal(m_out.signExt32To64(int32Value), value),
16389             unsure(isInt32), unsure(isDouble));
16390 
16391         LBasicBlock lastNext = m_out.appendTo(isInt32, isDouble);
16392 
16393         results.append(m_out.anchor(boxInt32(int32Value)));
16394         m_out.jump(continuation);
16395 
16396         m_out.appendTo(isDouble, continuation);
16397 
16398         results.append(m_out.anchor(boxDouble(m_out.intToDouble(value))));
16399         m_out.jump(continuation);
16400 
16401         m_out.appendTo(continuation, lastNext);
16402         return m_out.phi(Int64, results);
16403     }
16404 
16405     LValue strictInt52ToInt52(LValue value)
16406     {
16407         return m_out.shl(value, m_out.constInt64(JSValue::int52ShiftAmount));
16408     }
16409 
16410     LValue int52ToStrictInt52(LValue value)
16411     {
16412         return m_out.aShr(value, m_out.constInt64(JSValue::int52ShiftAmount));
16413     }
16414 
16415     LValue isInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
16416     {
16417         if (LValue proven = isProvenValue(type, SpecInt32Only))
16418             return proven;
<a name="564" id="anc564"></a><span class="line-modified">16419         return m_out.aboveOrEqual(jsValue, m_numberTag);</span>
16420     }
16421     LValue isNotInt32(LValue jsValue, SpeculatedType type = SpecFullTop)
16422     {
16423         if (LValue proven = isProvenValue(type, ~SpecInt32Only))
16424             return proven;
<a name="565" id="anc565"></a><span class="line-modified">16425         return m_out.below(jsValue, m_numberTag);</span>
16426     }
16427     LValue unboxInt32(LValue jsValue)
16428     {
16429         return m_out.castToInt32(jsValue);
16430     }
16431     LValue boxInt32(LValue value)
16432     {
<a name="566" id="anc566"></a><span class="line-modified">16433         return m_out.add(m_out.zeroExt(value, Int64), m_numberTag);</span>
16434     }
16435 
16436     LValue isCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
16437     {
16438         if (LValue proven = isProvenValue(type, SpecCellCheck | SpecMisc))
16439             return proven;
<a name="567" id="anc567"></a><span class="line-modified">16440         return m_out.testIsZero64(jsValue, m_numberTag);</span>
16441     }
16442     LValue isNotCellOrMisc(LValue jsValue, SpeculatedType type = SpecFullTop)
16443     {
16444         if (LValue proven = isProvenValue(type, ~(SpecCellCheck | SpecMisc)))
16445             return proven;
<a name="568" id="anc568"></a><span class="line-modified">16446         return m_out.testNonZero64(jsValue, m_numberTag);</span>
16447     }
16448 
16449     LValue unboxDouble(LValue jsValue, LValue* unboxedAsInt = nullptr)
16450     {
<a name="569" id="anc569"></a><span class="line-modified">16451         LValue asInt = m_out.add(jsValue, m_numberTag);</span>
16452         if (unboxedAsInt)
16453             *unboxedAsInt = asInt;
16454         return m_out.bitCast(asInt, Double);
16455     }
16456     LValue boxDouble(LValue doubleValue)
16457     {
<a name="570" id="anc570"></a><span class="line-modified">16458         return m_out.sub(m_out.bitCast(doubleValue, Int64), m_numberTag);</span>
16459     }
16460 
16461     LValue jsValueToStrictInt52(Edge edge, LValue boxedValue)
16462     {
16463         LBasicBlock intCase = m_out.newBlock();
16464         LBasicBlock doubleCase = m_out.newBlock();
16465         LBasicBlock continuation = m_out.newBlock();
16466 
16467         LValue isNotInt32;
16468         if (!m_interpreter.needsTypeCheck(edge, SpecInt32Only))
16469             isNotInt32 = m_out.booleanFalse;
16470         else if (!m_interpreter.needsTypeCheck(edge, ~SpecInt32Only))
16471             isNotInt32 = m_out.booleanTrue;
16472         else
16473             isNotInt32 = this-&gt;isNotInt32(boxedValue);
16474         m_out.branch(isNotInt32, unsure(doubleCase), unsure(intCase));
16475 
16476         LBasicBlock lastNext = m_out.appendTo(intCase, doubleCase);
16477 
16478         ValueFromBlock intToInt52 = m_out.anchor(
16479             m_out.signExt32To64(unboxInt32(boxedValue)));
16480         m_out.jump(continuation);
16481 
16482         m_out.appendTo(doubleCase, continuation);
16483 
<a name="571" id="anc571"></a><span class="line-modified">16484         LValue possibleResult = m_out.callWithoutSideEffects(Int64, operationConvertBoxedDoubleToInt52, boxedValue);</span>

16485         FTL_TYPE_CHECK(
16486             jsValueValue(boxedValue), edge, SpecInt32Only | SpecAnyIntAsDouble,
16487             m_out.equal(possibleResult, m_out.constInt64(JSValue::notInt52)));
16488 
16489         ValueFromBlock doubleToInt52 = m_out.anchor(possibleResult);
16490         m_out.jump(continuation);
16491 
16492         m_out.appendTo(continuation, lastNext);
16493 
16494         return m_out.phi(Int64, intToInt52, doubleToInt52);
16495     }
16496 
16497     LValue doubleToStrictInt52(Edge edge, LValue value)
16498     {
<a name="572" id="anc572"></a><span class="line-modified">16499         LValue integerValue = m_out.doubleToInt64(value);</span>
<span class="line-modified">16500         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);</span>
<span class="line-modified">16501         LValue valueNotConvertibleToInteger = m_out.doubleNotEqualOrUnordered(value, integerValueConvertedToDouble);</span>
<span class="line-modified">16502         speculate(Int52Overflow, doubleValue(value), edge.node(), valueNotConvertibleToInteger);</span>
<span class="line-modified">16503 </span>
<span class="line-added">16504         LBasicBlock valueIsZero = m_out.newBlock();</span>
<span class="line-added">16505         LBasicBlock valueIsNotZero = m_out.newBlock();</span>
<span class="line-added">16506         LBasicBlock continuation = m_out.newBlock();</span>
<span class="line-added">16507         m_out.branch(m_out.isZero64(integerValue), unsure(valueIsZero), unsure(valueIsNotZero));</span>
<span class="line-added">16508 </span>
<span class="line-added">16509         LBasicBlock lastNext = m_out.appendTo(valueIsZero, valueIsNotZero);</span>
<span class="line-added">16510         LValue doubleBitcastToInt64 = m_out.bitCast(value, Int64);</span>
<span class="line-added">16511         LValue signBitSet = m_out.lessThan(doubleBitcastToInt64, m_out.constInt64(0));</span>
<span class="line-added">16512         speculate(Int52Overflow, doubleValue(value), edge.node(), signBitSet);</span>
<span class="line-added">16513         m_out.jump(continuation);</span>
<span class="line-added">16514 </span>
<span class="line-added">16515         m_out.appendTo(valueIsNotZero, continuation);</span>
<span class="line-added">16516         speculate(Int52Overflow, doubleValue(value), edge.node(), m_out.greaterThanOrEqual(integerValue, m_out.constInt64(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1))));</span>
<span class="line-added">16517         speculate(Int52Overflow, doubleValue(value), edge.node(), m_out.lessThan(integerValue, m_out.constInt64(-(static_cast&lt;int64_t&gt;(1) &lt;&lt; (JSValue::numberOfInt52Bits - 1)))));</span>
<span class="line-added">16518         m_out.jump(continuation);</span>
16519 
<a name="573" id="anc573"></a><span class="line-modified">16520         m_out.appendTo(continuation, lastNext);</span>
<span class="line-added">16521         m_interpreter.filter(edge, SpecAnyIntAsDouble);</span>
<span class="line-added">16522         return integerValue;</span>
16523     }
16524 
16525     LValue convertDoubleToInt32(LValue value, bool shouldCheckNegativeZero)
16526     {
16527         LValue integerValue = m_out.doubleToInt(value);
16528         LValue integerValueConvertedToDouble = m_out.intToDouble(integerValue);
16529         LValue valueNotConvertibleToInteger = m_out.doubleNotEqualOrUnordered(value, integerValueConvertedToDouble);
16530         speculate(Overflow, FormattedValue(DataFormatDouble, value), m_node, valueNotConvertibleToInteger);
16531 
16532         if (shouldCheckNegativeZero) {
16533             LBasicBlock valueIsZero = m_out.newBlock();
16534             LBasicBlock continuation = m_out.newBlock();
16535             m_out.branch(m_out.isZero32(integerValue), unsure(valueIsZero), unsure(continuation));
16536 
16537             LBasicBlock lastNext = m_out.appendTo(valueIsZero, continuation);
16538 
16539             LValue doubleBitcastToInt64 = m_out.bitCast(value, Int64);
16540             LValue signBitSet = m_out.lessThan(doubleBitcastToInt64, m_out.constInt64(0));
16541 
16542             speculate(NegativeZero, FormattedValue(DataFormatDouble, value), m_node, signBitSet);
16543             m_out.jump(continuation);
16544             m_out.appendTo(continuation, lastNext);
16545         }
16546         return integerValue;
16547     }
16548 
16549     LValue isNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
16550     {
16551         if (LValue proven = isProvenValue(type, SpecFullNumber))
16552             return proven;
16553         return isNotCellOrMisc(jsValue);
16554     }
16555     LValue isNotNumber(LValue jsValue, SpeculatedType type = SpecFullTop)
16556     {
16557         if (LValue proven = isProvenValue(type, ~SpecFullNumber))
16558             return proven;
16559         return isCellOrMisc(jsValue);
16560     }
16561 
16562     LValue isNotCell(LValue jsValue, SpeculatedType type = SpecFullTop)
16563     {
16564         if (LValue proven = isProvenValue(type, ~SpecCellCheck))
16565             return proven;
<a name="574" id="anc574"></a><span class="line-modified">16566         return m_out.testNonZero64(jsValue, m_notCellMask);</span>
16567     }
16568 
16569     LValue isCell(LValue jsValue, SpeculatedType type = SpecFullTop)
16570     {
16571         if (LValue proven = isProvenValue(type, SpecCellCheck))
16572             return proven;
<a name="575" id="anc575"></a><span class="line-modified">16573         return m_out.testIsZero64(jsValue, m_notCellMask);</span>
16574     }
16575 
16576     LValue isNotMisc(LValue value, SpeculatedType type = SpecFullTop)
16577     {
16578         if (LValue proven = isProvenValue(type, ~SpecMisc))
16579             return proven;
<a name="576" id="anc576"></a><span class="line-modified">16580         return m_out.above(value, m_out.constInt64(JSValue::MiscTag));</span>
16581     }
16582 
16583     LValue isMisc(LValue value, SpeculatedType type = SpecFullTop)
16584     {
16585         if (LValue proven = isProvenValue(type, SpecMisc))
16586             return proven;
16587         return m_out.logicalNot(isNotMisc(value));
16588     }
16589 
16590     LValue isNotBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
16591     {
16592         if (LValue proven = isProvenValue(type, ~SpecBoolean))
16593             return proven;
16594         return m_out.testNonZero64(
<a name="577" id="anc577"></a><span class="line-modified">16595             m_out.bitXor(jsValue, m_out.constInt64(JSValue::ValueFalse)),</span>
16596             m_out.constInt64(~1));
16597     }
16598     LValue isBoolean(LValue jsValue, SpeculatedType type = SpecFullTop)
16599     {
16600         if (LValue proven = isProvenValue(type, SpecBoolean))
16601             return proven;
16602         return m_out.logicalNot(isNotBoolean(jsValue));
16603     }
16604     LValue unboxBoolean(LValue jsValue)
16605     {
16606         // We want to use a cast that guarantees that B3 knows that even the integer
16607         // value is just 0 or 1. But for now we do it the dumb way.
16608         return m_out.notZero64(m_out.bitAnd(jsValue, m_out.constInt64(1)));
16609     }
16610     LValue boxBoolean(LValue value)
16611     {
16612         return m_out.select(
<a name="578" id="anc578"></a><span class="line-modified">16613             value, m_out.constInt64(JSValue::ValueTrue), m_out.constInt64(JSValue::ValueFalse));</span>
16614     }
16615 
16616     LValue isNotOther(LValue value, SpeculatedType type = SpecFullTop)
16617     {
16618         if (LValue proven = isProvenValue(type, ~SpecOther))
16619             return proven;
16620         return m_out.notEqual(
<a name="579" id="anc579"></a><span class="line-modified">16621             m_out.bitAnd(value, m_out.constInt64(~JSValue::UndefinedTag)),</span>
<span class="line-modified">16622             m_out.constInt64(JSValue::ValueNull));</span>
16623     }
16624     LValue isOther(LValue value, SpeculatedType type = SpecFullTop)
16625     {
16626         if (LValue proven = isProvenValue(type, SpecOther))
16627             return proven;
16628         return m_out.equal(
<a name="580" id="anc580"></a><span class="line-modified">16629             m_out.bitAnd(value, m_out.constInt64(~JSValue::UndefinedTag)),</span>
<span class="line-modified">16630             m_out.constInt64(JSValue::ValueNull));</span>
16631     }
16632 
16633     LValue isProvenValue(SpeculatedType provenType, SpeculatedType wantedType)
16634     {
16635         if (!(provenType &amp; ~wantedType))
16636             return m_out.booleanTrue;
16637         if (!(provenType &amp; wantedType))
16638             return m_out.booleanFalse;
16639         return nullptr;
16640     }
16641 
16642     void speculate(Edge edge)
16643     {
16644         switch (edge.useKind()) {
16645         case UntypedUse:
16646             break;
16647         case KnownInt32Use:
16648         case KnownStringUse:
16649         case KnownPrimitiveUse:
16650         case KnownOtherUse:
16651         case DoubleRepUse:
16652         case Int52RepUse:
16653         case KnownCellUse:
16654         case KnownBooleanUse:
16655             ASSERT(!m_interpreter.needsTypeCheck(edge));
16656             break;
16657         case Int32Use:
16658             speculateInt32(edge);
16659             break;
16660         case CellUse:
16661             speculateCell(edge);
16662             break;
16663         case CellOrOtherUse:
16664             speculateCellOrOther(edge);
16665             break;
16666         case AnyIntUse:
16667             speculateAnyInt(edge);
16668             break;
16669         case ObjectUse:
16670             speculateObject(edge);
16671             break;
16672         case ArrayUse:
16673             speculateArray(edge);
16674             break;
16675         case FunctionUse:
16676             speculateFunction(edge);
16677             break;
16678         case ObjectOrOtherUse:
16679             speculateObjectOrOther(edge);
16680             break;
16681         case FinalObjectUse:
16682             speculateFinalObject(edge);
16683             break;
16684         case RegExpObjectUse:
16685             speculateRegExpObject(edge);
16686             break;
<a name="581" id="anc581"></a><span class="line-added">16687         case PromiseObjectUse:</span>
<span class="line-added">16688             speculatePromiseObject(edge);</span>
<span class="line-added">16689             break;</span>
16690         case ProxyObjectUse:
16691             speculateProxyObject(edge);
16692             break;
16693         case DerivedArrayUse:
16694             speculateDerivedArray(edge);
16695             break;
<a name="582" id="anc582"></a><span class="line-added">16696         case DateObjectUse:</span>
<span class="line-added">16697             speculateDateObject(edge);</span>
<span class="line-added">16698             break;</span>
16699         case MapObjectUse:
16700             speculateMapObject(edge);
16701             break;
16702         case SetObjectUse:
16703             speculateSetObject(edge);
16704             break;
16705         case WeakMapObjectUse:
16706             speculateWeakMapObject(edge);
16707             break;
16708         case WeakSetObjectUse:
16709             speculateWeakSetObject(edge);
16710             break;
16711         case DataViewObjectUse:
16712             speculateDataViewObject(edge);
16713             break;
16714         case StringUse:
16715             speculateString(edge);
16716             break;
16717         case StringOrOtherUse:
16718             speculateStringOrOther(edge);
16719             break;
16720         case StringIdentUse:
16721             speculateStringIdent(edge);
16722             break;
16723         case SymbolUse:
16724             speculateSymbol(edge);
16725             break;
16726         case StringObjectUse:
16727             speculateStringObject(edge);
16728             break;
16729         case StringOrStringObjectUse:
16730             speculateStringOrStringObject(edge);
16731             break;
16732         case NumberUse:
16733             speculateNumber(edge);
16734             break;
16735         case RealNumberUse:
16736             speculateRealNumber(edge);
16737             break;
16738         case DoubleRepRealUse:
16739             speculateDoubleRepReal(edge);
16740             break;
16741         case DoubleRepAnyIntUse:
16742             speculateDoubleRepAnyInt(edge);
16743             break;
16744         case BooleanUse:
16745             speculateBoolean(edge);
16746             break;
16747         case BigIntUse:
16748             speculateBigInt(edge);
16749             break;
16750         case NotStringVarUse:
16751             speculateNotStringVar(edge);
16752             break;
16753         case NotSymbolUse:
16754             speculateNotSymbol(edge);
16755             break;
16756         case NotCellUse:
16757             speculateNotCell(edge);
16758             break;
16759         case OtherUse:
16760             speculateOther(edge);
16761             break;
16762         case MiscUse:
16763             speculateMisc(edge);
16764             break;
16765         default:
16766             DFG_CRASH(m_graph, m_node, &quot;Unsupported speculation use kind&quot;);
16767         }
16768     }
16769 
16770     void speculate(Node*, Edge edge)
16771     {
16772         speculate(edge);
16773     }
16774 
16775     void speculateInt32(Edge edge)
16776     {
16777         lowInt32(edge);
16778     }
16779 
16780     void speculateCell(Edge edge)
16781     {
16782         lowCell(edge);
16783     }
16784 
16785     void speculateNotCell(Edge edge)
16786     {
16787         if (!m_interpreter.needsTypeCheck(edge))
16788             return;
16789         lowNotCell(edge);
16790     }
16791 
16792     void speculateCellOrOther(Edge edge)
16793     {
16794         if (shouldNotHaveTypeCheck(edge.useKind()))
16795             return;
16796 
16797         LValue value = lowJSValue(edge, ManualOperandSpeculation);
16798 
16799         LBasicBlock isNotCell = m_out.newBlock();
16800         LBasicBlock continuation = m_out.newBlock();
16801 
16802         m_out.branch(isCell(value, provenType(edge)), unsure(continuation), unsure(isNotCell));
16803 
16804         LBasicBlock lastNext = m_out.appendTo(isNotCell, continuation);
16805         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
16806         m_out.jump(continuation);
16807 
16808         m_out.appendTo(continuation, lastNext);
16809     }
16810 
16811     void speculateAnyInt(Edge edge)
16812     {
16813         if (!m_interpreter.needsTypeCheck(edge))
16814             return;
16815 
16816         jsValueToStrictInt52(edge, lowJSValue(edge, ManualOperandSpeculation));
16817     }
16818 
<a name="583" id="anc583"></a><span class="line-modified">16819     LValue isCellWithType(LValue cell, JSType queriedType, Optional&lt;SpeculatedType&gt; speculatedTypeForQuery, SpeculatedType type = SpecFullTop)</span>
16820     {
<a name="584" id="anc584"></a><span class="line-modified">16821         if (speculatedTypeForQuery) {</span>
<span class="line-modified">16822             if (LValue proven = isProvenValue(type &amp; SpecCell, speculatedTypeForQuery.value()))</span>
<span class="line-added">16823                 return proven;</span>
<span class="line-added">16824         }</span>
16825         return m_out.equal(
16826             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16827             m_out.constInt32(queriedType));
16828     }
16829 
16830     LValue isTypedArrayView(LValue cell, SpeculatedType type = SpecFullTop)
16831     {
16832         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecTypedArrayView))
16833             return proven;
16834         LValue jsType = m_out.sub(
16835             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16836             m_out.constInt32(FirstTypedArrayType));
16837         return m_out.below(
16838             jsType,
16839             m_out.constInt32(NumberOfTypedArrayTypesExcludingDataView));
16840     }
16841 
16842     LValue isObject(LValue cell, SpeculatedType type = SpecFullTop)
16843     {
16844         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecObject))
16845             return proven;
16846         return m_out.aboveOrEqual(
16847             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16848             m_out.constInt32(ObjectType));
16849     }
16850 
16851     LValue isNotObject(LValue cell, SpeculatedType type = SpecFullTop)
16852     {
16853         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecObject))
16854             return proven;
16855         return m_out.below(
16856             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
16857             m_out.constInt32(ObjectType));
16858     }
16859 
16860     LValue isNotString(LValue cell, SpeculatedType type = SpecFullTop)
16861     {
16862         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecString))
16863             return proven;
16864         return m_out.notEqual(
16865             m_out.load32(cell, m_heaps.JSCell_structureID),
16866             m_out.constInt32(vm().stringStructure-&gt;id()));
16867     }
16868 
16869     LValue isString(LValue cell, SpeculatedType type = SpecFullTop)
16870     {
16871         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecString))
16872             return proven;
16873         return m_out.equal(
16874             m_out.load32(cell, m_heaps.JSCell_structureID),
16875             m_out.constInt32(vm().stringStructure-&gt;id()));
16876     }
16877 
16878     LValue isRopeString(LValue string, Edge edge = Edge())
16879     {
16880         if (edge) {
16881             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16882                 return m_out.booleanFalse;
16883             if (JSValue value = provenValue(edge)) {
16884                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16885                     return m_out.booleanFalse;
16886             }
16887             String value = edge-&gt;tryGetString(m_graph);
16888             if (!value.isNull()) {
16889                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.
16890                 return m_out.booleanFalse;
16891             }
16892         }
16893 
16894         return m_out.testNonZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16895     }
16896 
16897     LValue isNotRopeString(LValue string, Edge edge = Edge())
16898     {
16899         if (edge) {
16900             if (!((provenType(edge) &amp; SpecString) &amp; ~SpecStringIdent))
16901                 return m_out.booleanTrue;
16902             if (JSValue value = provenValue(edge)) {
16903                 if (value.isCell() &amp;&amp; value.asCell()-&gt;type() == StringType &amp;&amp; !asString(value)-&gt;isRope())
16904                     return m_out.booleanTrue;
16905             }
16906             String value = edge-&gt;tryGetString(m_graph);
16907             if (!value.isNull()) {
16908                 // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.
16909                 return m_out.booleanTrue;
16910             }
16911         }
16912 
16913         return m_out.testIsZeroPtr(m_out.loadPtr(string, m_heaps.JSString_value), m_out.constIntPtr(JSString::isRopeInPointer));
16914     }
16915 
16916     LValue isNotSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16917     {
16918         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecSymbol))
16919             return proven;
16920         return m_out.notEqual(
16921             m_out.load32(cell, m_heaps.JSCell_structureID),
16922             m_out.constInt32(vm().symbolStructure-&gt;id()));
16923     }
16924 
16925     LValue isSymbol(LValue cell, SpeculatedType type = SpecFullTop)
16926     {
16927         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecSymbol))
16928             return proven;
16929         return m_out.equal(
16930             m_out.load32(cell, m_heaps.JSCell_structureID),
16931             m_out.constInt32(vm().symbolStructure-&gt;id()));
16932     }
16933 
16934     LValue isNotBigInt(LValue cell, SpeculatedType type = SpecFullTop)
16935     {
16936         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecBigInt))
16937             return proven;
16938         return m_out.notEqual(
16939             m_out.load32(cell, m_heaps.JSCell_structureID),
16940             m_out.constInt32(vm().bigIntStructure-&gt;id()));
16941     }
16942 
16943     LValue isBigInt(LValue cell, SpeculatedType type = SpecFullTop)
16944     {
16945         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecBigInt))
16946             return proven;
16947         return m_out.equal(
16948             m_out.load32(cell, m_heaps.JSCell_structureID),
16949             m_out.constInt32(vm().bigIntStructure-&gt;id()));
16950     }
16951 
16952     LValue isArrayTypeForArrayify(LValue cell, ArrayMode arrayMode)
16953     {
16954         switch (arrayMode.type()) {
16955         case Array::Int32:
16956         case Array::Double:
16957         case Array::Contiguous:
16958         case Array::Undecided:
16959         case Array::ArrayStorage: {
16960             IndexingType indexingModeMask = IsArray | IndexingShapeMask;
16961             if (arrayMode.action() == Array::Write)
16962                 indexingModeMask |= CopyOnWrite;
16963 
16964             IndexingType shape = arrayMode.shapeMask();
16965             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
16966 
16967             switch (arrayMode.arrayClass()) {
16968             case Array::OriginalArray:
16969             case Array::OriginalCopyOnWriteArray:
16970                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
16971                 return nullptr;
16972 
16973             case Array::Array:
16974                 return m_out.equal(
16975                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
16976                     m_out.constInt32(IsArray | shape));
16977 
16978             case Array::NonArray:
16979             case Array::OriginalNonArray:
16980                 return m_out.equal(
16981                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask)),
16982                     m_out.constInt32(shape));
16983 
16984             case Array::PossiblyArray:
16985                 return m_out.equal(
16986                     m_out.bitAnd(indexingType, m_out.constInt32(indexingModeMask &amp; ~IsArray)),
16987                     m_out.constInt32(shape));
16988             }
16989             break;
16990         }
16991 
16992         case Array::SlowPutArrayStorage: {
16993             ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
16994             LValue indexingType = m_out.load8ZeroExt32(cell, m_heaps.JSCell_indexingTypeAndMisc);
16995 
16996             LBasicBlock trueCase = m_out.newBlock();
16997             LBasicBlock checkCase = m_out.newBlock();
16998             LBasicBlock continuation = m_out.newBlock();
16999 
17000             ValueFromBlock falseValue = m_out.anchor(m_out.booleanFalse);
17001             LValue isAnArrayStorageShape = m_out.belowOrEqual(
17002                 m_out.sub(
17003                     m_out.bitAnd(indexingType, m_out.constInt32(IndexingShapeMask)),
17004                     m_out.constInt32(ArrayStorageShape)),
17005                 m_out.constInt32(SlowPutArrayStorageShape - ArrayStorageShape));
17006             m_out.branch(isAnArrayStorageShape, unsure(checkCase), unsure(continuation));
17007 
17008             LBasicBlock lastNext = m_out.appendTo(checkCase, trueCase);
17009             switch (arrayMode.arrayClass()) {
17010             case Array::OriginalArray:
17011             case Array::OriginalCopyOnWriteArray:
17012                 DFG_CRASH(m_graph, m_node, &quot;Unexpected original array&quot;);
17013                 return nullptr;
17014 
17015             case Array::Array:
17016                 m_out.branch(
17017                     m_out.testNonZero32(indexingType, m_out.constInt32(IsArray)),
17018                     unsure(trueCase), unsure(continuation));
17019                 break;
17020 
17021             case Array::NonArray:
17022             case Array::OriginalNonArray:
17023                 m_out.branch(
17024                     m_out.testIsZero32(indexingType, m_out.constInt32(IsArray)),
17025                     unsure(trueCase), unsure(continuation));
17026                 break;
17027 
17028             case Array::PossiblyArray:
17029                 m_out.jump(trueCase);
17030                 break;
17031             }
17032 
17033             m_out.appendTo(trueCase, continuation);
17034             ValueFromBlock trueValue = m_out.anchor(m_out.booleanTrue);
17035             m_out.jump(continuation);
17036 
17037             m_out.appendTo(continuation, lastNext);
17038             return m_out.phi(Int32, falseValue, trueValue);
17039         }
17040 
17041         default:
17042             break;
17043         }
17044         DFG_CRASH(m_graph, m_node, &quot;Corrupt array class&quot;);
17045     }
17046 
17047     LValue isArrayTypeForCheckArray(LValue cell, ArrayMode arrayMode)
17048     {
17049         switch (arrayMode.type()) {
17050         case Array::Int32:
17051         case Array::Double:
17052         case Array::Contiguous:
17053         case Array::Undecided:
17054         case Array::ArrayStorage:
17055         case Array::SlowPutArrayStorage:
17056             return isArrayTypeForArrayify(cell, arrayMode);
17057 
17058         case Array::DirectArguments:
17059             return m_out.equal(
17060                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
17061                 m_out.constInt32(DirectArgumentsType));
17062 
17063         case Array::ScopedArguments:
17064             return m_out.equal(
17065                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
17066                 m_out.constInt32(ScopedArgumentsType));
17067 
17068         default:
17069             return m_out.equal(
17070                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
17071                 m_out.constInt32(typeForTypedArrayType(arrayMode.typedArrayType())));
17072         }
17073     }
17074 
17075     LValue isFunction(LValue cell, SpeculatedType type = SpecFullTop)
17076     {
17077         if (LValue proven = isProvenValue(type &amp; SpecCell, SpecFunction))
17078             return proven;
17079         return isType(cell, JSFunctionType);
17080     }
17081     LValue isNotFunction(LValue cell, SpeculatedType type = SpecFullTop)
17082     {
17083         if (LValue proven = isProvenValue(type &amp; SpecCell, ~SpecFunction))
17084             return proven;
17085         return isNotType(cell, JSFunctionType);
17086     }
17087 
17088     LValue isExoticForTypeof(LValue cell, SpeculatedType type = SpecFullTop)
17089     {
17090         if (!(type &amp; SpecObjectOther))
17091             return m_out.booleanFalse;
17092         return m_out.testNonZero32(
17093             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
17094             m_out.constInt32(MasqueradesAsUndefined | OverridesGetCallData));
17095     }
17096 
17097     LValue isType(LValue cell, JSType type)
17098     {
17099         return m_out.equal(
17100             m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType),
17101             m_out.constInt32(type));
17102     }
17103 
17104     LValue isNotType(LValue cell, JSType type)
17105     {
17106         return m_out.logicalNot(isType(cell, type));
17107     }
17108 
17109     void speculateObject(Edge edge, LValue cell)
17110     {
17111         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
17112     }
17113 
17114     void speculateObject(Edge edge)
17115     {
17116         speculateObject(edge, lowCell(edge));
17117     }
17118 
17119     void speculateArray(Edge edge, LValue cell)
17120     {
17121         FTL_TYPE_CHECK(
17122             jsValueValue(cell), edge, SpecArray, isNotType(cell, ArrayType));
17123     }
17124 
17125     void speculateArray(Edge edge)
17126     {
17127         speculateArray(edge, lowCell(edge));
17128     }
17129 
17130     void speculateFunction(Edge edge, LValue cell)
17131     {
17132         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecFunction, isNotFunction(cell));
17133     }
17134 
17135     void speculateFunction(Edge edge)
17136     {
17137         speculateFunction(edge, lowCell(edge));
17138     }
17139 
17140     void speculateObjectOrOther(Edge edge)
17141     {
17142         if (!m_interpreter.needsTypeCheck(edge))
17143             return;
17144 
17145         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17146 
17147         LBasicBlock cellCase = m_out.newBlock();
17148         LBasicBlock primitiveCase = m_out.newBlock();
17149         LBasicBlock continuation = m_out.newBlock();
17150 
17151         m_out.branch(isNotCell(value, provenType(edge)), unsure(primitiveCase), unsure(cellCase));
17152 
17153         LBasicBlock lastNext = m_out.appendTo(cellCase, primitiveCase);
17154 
17155         FTL_TYPE_CHECK(
17156             jsValueValue(value), edge, (~SpecCellCheck) | SpecObject, isNotObject(value));
17157 
17158         m_out.jump(continuation);
17159 
17160         m_out.appendTo(primitiveCase, continuation);
17161 
17162         FTL_TYPE_CHECK(
17163             jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
17164 
17165         m_out.jump(continuation);
17166 
17167         m_out.appendTo(continuation, lastNext);
17168     }
17169 
17170     void speculateFinalObject(Edge edge, LValue cell)
17171     {
17172         FTL_TYPE_CHECK(
17173             jsValueValue(cell), edge, SpecFinalObject, isNotType(cell, FinalObjectType));
17174     }
17175 
17176     void speculateFinalObject(Edge edge)
17177     {
17178         speculateFinalObject(edge, lowCell(edge));
17179     }
17180 
17181     void speculateRegExpObject(Edge edge, LValue cell)
17182     {
17183         FTL_TYPE_CHECK(
17184             jsValueValue(cell), edge, SpecRegExpObject, isNotType(cell, RegExpObjectType));
17185     }
17186 
17187     void speculateRegExpObject(Edge edge)
17188     {
17189         speculateRegExpObject(edge, lowCell(edge));
17190     }
17191 
17192     void speculateProxyObject(Edge edge, LValue cell)
17193     {
17194         FTL_TYPE_CHECK(
17195             jsValueValue(cell), edge, SpecProxyObject, isNotType(cell, ProxyObjectType));
17196     }
17197 
17198     void speculateProxyObject(Edge edge)
17199     {
17200         speculateProxyObject(edge, lowCell(edge));
17201     }
17202 
17203     void speculateDerivedArray(Edge edge, LValue cell)
17204     {
17205         FTL_TYPE_CHECK(
17206             jsValueValue(cell), edge, SpecDerivedArray, isNotType(cell, DerivedArrayType));
17207     }
17208 
17209     void speculateDerivedArray(Edge edge)
17210     {
17211         speculateDerivedArray(edge, lowCell(edge));
17212     }
17213 
<a name="585" id="anc585"></a><span class="line-added">17214     void speculatePromiseObject(Edge edge, LValue cell)</span>
<span class="line-added">17215     {</span>
<span class="line-added">17216         FTL_TYPE_CHECK(</span>
<span class="line-added">17217             jsValueValue(cell), edge, SpecPromiseObject, isNotType(cell, JSPromiseType));</span>
<span class="line-added">17218     }</span>
<span class="line-added">17219 </span>
<span class="line-added">17220     void speculatePromiseObject(Edge edge)</span>
<span class="line-added">17221     {</span>
<span class="line-added">17222         speculatePromiseObject(edge, lowCell(edge));</span>
<span class="line-added">17223     }</span>
<span class="line-added">17224 </span>
<span class="line-added">17225     void speculateDateObject(Edge edge, LValue cell)</span>
<span class="line-added">17226     {</span>
<span class="line-added">17227         FTL_TYPE_CHECK(</span>
<span class="line-added">17228             jsValueValue(cell), edge, SpecDateObject, isNotType(cell, JSDateType));</span>
<span class="line-added">17229     }</span>
<span class="line-added">17230 </span>
<span class="line-added">17231     void speculateDateObject(Edge edge)</span>
<span class="line-added">17232     {</span>
<span class="line-added">17233         speculateDateObject(edge, lowCell(edge));</span>
<span class="line-added">17234     }</span>
<span class="line-added">17235 </span>
17236     void speculateMapObject(Edge edge, LValue cell)
17237     {
17238         FTL_TYPE_CHECK(
17239             jsValueValue(cell), edge, SpecMapObject, isNotType(cell, JSMapType));
17240     }
17241 
17242     void speculateMapObject(Edge edge)
17243     {
17244         speculateMapObject(edge, lowCell(edge));
17245     }
17246 
17247     void speculateSetObject(Edge edge, LValue cell)
17248     {
17249         FTL_TYPE_CHECK(
17250             jsValueValue(cell), edge, SpecSetObject, isNotType(cell, JSSetType));
17251     }
17252 
17253     void speculateSetObject(Edge edge)
17254     {
17255         speculateSetObject(edge, lowCell(edge));
17256     }
17257 
17258     void speculateWeakMapObject(Edge edge, LValue cell)
17259     {
17260         FTL_TYPE_CHECK(
17261             jsValueValue(cell), edge, SpecWeakMapObject, isNotType(cell, JSWeakMapType));
17262     }
17263 
17264     void speculateWeakMapObject(Edge edge)
17265     {
17266         speculateWeakMapObject(edge, lowCell(edge));
17267     }
17268 
17269     void speculateWeakSetObject(Edge edge, LValue cell)
17270     {
17271         FTL_TYPE_CHECK(
17272             jsValueValue(cell), edge, SpecWeakSetObject, isNotType(cell, JSWeakSetType));
17273     }
17274 
17275     void speculateWeakSetObject(Edge edge)
17276     {
17277         speculateWeakSetObject(edge, lowCell(edge));
17278     }
17279 
17280     void speculateDataViewObject(Edge edge, LValue cell)
17281     {
17282         FTL_TYPE_CHECK(
17283             jsValueValue(cell), edge, SpecDataViewObject, isNotType(cell, DataViewType));
17284     }
17285 
17286     void speculateDataViewObject(Edge edge)
17287     {
17288         speculateDataViewObject(edge, lowCell(edge));
17289     }
17290 
17291     void speculateString(Edge edge, LValue cell)
17292     {
17293         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecString, isNotString(cell));
17294     }
17295 
17296     void speculateString(Edge edge)
17297     {
17298         speculateString(edge, lowCell(edge));
17299     }
17300 
17301     void speculateStringOrOther(Edge edge, LValue value)
17302     {
17303         if (!m_interpreter.needsTypeCheck(edge))
17304             return;
17305 
17306         LBasicBlock cellCase = m_out.newBlock();
17307         LBasicBlock notCellCase = m_out.newBlock();
17308         LBasicBlock continuation = m_out.newBlock();
17309 
17310         m_out.branch(isCell(value, provenType(edge)), unsure(cellCase), unsure(notCellCase));
17311 
17312         LBasicBlock lastNext = m_out.appendTo(cellCase, notCellCase);
17313 
17314         FTL_TYPE_CHECK(jsValueValue(value), edge, (~SpecCellCheck) | SpecString, isNotString(value));
17315 
17316         m_out.jump(continuation);
17317         m_out.appendTo(notCellCase, continuation);
17318 
17319         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecCellCheck | SpecOther, isNotOther(value));
17320 
17321         m_out.jump(continuation);
17322         m_out.appendTo(continuation, lastNext);
17323     }
17324 
17325     void speculateStringOrOther(Edge edge)
17326     {
17327         speculateStringOrOther(edge, lowJSValue(edge, ManualOperandSpeculation));
17328     }
17329 
17330     void speculateStringIdent(Edge edge, LValue string, LValue stringImpl)
17331     {
17332         if (!m_interpreter.needsTypeCheck(edge, SpecStringIdent | ~SpecString))
17333             return;
17334 
17335         speculate(BadType, jsValueValue(string), edge.node(), isRopeString(string));
17336         speculate(
17337             BadType, jsValueValue(string), edge.node(),
17338             m_out.testIsZero32(
17339                 m_out.load32(stringImpl, m_heaps.StringImpl_hashAndFlags),
17340                 m_out.constInt32(StringImpl::flagIsAtom())));
17341         m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
17342     }
17343 
17344     void speculateStringIdent(Edge edge)
17345     {
17346         lowStringIdent(edge);
17347     }
17348 
17349     void speculateStringObject(Edge edge)
17350     {
17351         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
17352             return;
17353 
17354         speculateStringObjectForCell(edge, lowCell(edge));
17355     }
17356 
17357     void speculateStringOrStringObject(Edge edge)
17358     {
17359         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
17360             return;
17361 
17362         LValue cellBase = lowCell(edge);
17363         if (!m_interpreter.needsTypeCheck(edge, SpecString | SpecStringObject))
17364             return;
17365 
17366         LBasicBlock notString = m_out.newBlock();
17367         LBasicBlock continuation = m_out.newBlock();
17368 
17369         LValue type = m_out.load8ZeroExt32(cellBase, m_heaps.JSCell_typeInfoType);
17370         m_out.branch(
17371             m_out.equal(type, m_out.constInt32(StringType)),
17372             unsure(continuation), unsure(notString));
17373 
17374         LBasicBlock lastNext = m_out.appendTo(notString, continuation);
17375         speculate(
17376             BadType, jsValueValue(cellBase), edge.node(),
17377             m_out.notEqual(type, m_out.constInt32(StringObjectType)));
17378         m_out.jump(continuation);
17379 
17380         m_out.appendTo(continuation, lastNext);
17381         m_interpreter.filter(edge, SpecString | SpecStringObject);
17382     }
17383 
17384     void speculateStringObjectForCell(Edge edge, LValue cell)
17385     {
17386         if (!m_interpreter.needsTypeCheck(edge, SpecStringObject))
17387             return;
17388 
17389         LValue type = m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoType);
17390         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecStringObject, m_out.notEqual(type, m_out.constInt32(StringObjectType)));
17391     }
17392 
17393     void speculateSymbol(Edge edge, LValue cell)
17394     {
17395         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecSymbol, isNotSymbol(cell));
17396     }
17397 
17398     void speculateSymbol(Edge edge)
17399     {
17400         speculateSymbol(edge, lowCell(edge));
17401     }
17402 
17403     void speculateBigInt(Edge edge, LValue cell)
17404     {
17405         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecBigInt, isNotBigInt(cell));
17406     }
17407 
17408     void speculateBigInt(Edge edge)
17409     {
17410         speculateBigInt(edge, lowCell(edge));
17411     }
17412 
17413     void speculateNonNullObject(Edge edge, LValue cell)
17414     {
17415         FTL_TYPE_CHECK(jsValueValue(cell), edge, SpecObject, isNotObject(cell));
17416         if (masqueradesAsUndefinedWatchpointIsStillValid())
17417             return;
17418 
17419         speculate(
17420             BadType, jsValueValue(cell), edge.node(),
17421             m_out.testNonZero32(
17422                 m_out.load8ZeroExt32(cell, m_heaps.JSCell_typeInfoFlags),
17423                 m_out.constInt32(MasqueradesAsUndefined)));
17424     }
17425 
17426     void speculateNumber(Edge edge)
17427     {
17428         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17429         FTL_TYPE_CHECK(jsValueValue(value), edge, SpecBytecodeNumber, isNotNumber(value));
17430     }
17431 
17432     void speculateRealNumber(Edge edge)
17433     {
17434         // Do an early return here because lowDouble() can create a lot of control flow.
17435         if (!m_interpreter.needsTypeCheck(edge))
17436             return;
17437 
17438         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17439         LValue doubleValue = unboxDouble(value);
17440 
17441         LBasicBlock intCase = m_out.newBlock();
17442         LBasicBlock continuation = m_out.newBlock();
17443 
17444         m_out.branch(
17445             m_out.doubleEqual(doubleValue, doubleValue),
17446             usually(continuation), rarely(intCase));
17447 
17448         LBasicBlock lastNext = m_out.appendTo(intCase, continuation);
17449 
17450         typeCheck(
17451             jsValueValue(value), m_node-&gt;child1(), SpecBytecodeRealNumber,
17452             isNotInt32(value, provenType(m_node-&gt;child1()) &amp; ~SpecFullDouble));
17453         m_out.jump(continuation);
17454 
17455         m_out.appendTo(continuation, lastNext);
17456     }
17457 
17458     void speculateDoubleRepReal(Edge edge)
17459     {
17460         // Do an early return here because lowDouble() can create a lot of control flow.
17461         if (!m_interpreter.needsTypeCheck(edge))
17462             return;
17463 
17464         LValue value = lowDouble(edge);
17465         FTL_TYPE_CHECK(
17466             doubleValue(value), edge, SpecDoubleReal,
17467             m_out.doubleNotEqualOrUnordered(value, value));
17468     }
17469 
17470     void speculateDoubleRepAnyInt(Edge edge)
17471     {
17472         if (!m_interpreter.needsTypeCheck(edge))
17473             return;
17474 
17475         doubleToStrictInt52(edge, lowDouble(edge));
17476     }
17477 
17478     void speculateBoolean(Edge edge)
17479     {
17480         lowBoolean(edge);
17481     }
17482 
17483     void speculateNotStringVar(Edge edge)
17484     {
17485         if (!m_interpreter.needsTypeCheck(edge, ~SpecStringVar))
17486             return;
17487 
17488         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17489 
17490         LBasicBlock isCellCase = m_out.newBlock();
17491         LBasicBlock isStringCase = m_out.newBlock();
17492         LBasicBlock continuation = m_out.newBlock();
17493 
17494         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
17495 
17496         LBasicBlock lastNext = m_out.appendTo(isCellCase, isStringCase);
17497         m_out.branch(isString(value, provenType(edge)), unsure(isStringCase), unsure(continuation));
17498 
17499         m_out.appendTo(isStringCase, continuation);
17500         speculateStringIdent(edge, value, m_out.loadPtr(value, m_heaps.JSString_value));
17501         m_out.jump(continuation);
17502 
17503         m_out.appendTo(continuation, lastNext);
17504     }
17505 
17506     void speculateNotSymbol(Edge edge)
17507     {
17508         if (!m_interpreter.needsTypeCheck(edge, ~SpecSymbol))
17509             return;
17510 
17511         ASSERT(mayHaveTypeCheck(edge.useKind()));
17512         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17513 
17514         LBasicBlock isCellCase = m_out.newBlock();
17515         LBasicBlock continuation = m_out.newBlock();
17516 
17517         m_out.branch(isCell(value, provenType(edge)), unsure(isCellCase), unsure(continuation));
17518 
17519         LBasicBlock lastNext = m_out.appendTo(isCellCase, continuation);
17520         speculate(BadType, jsValueValue(value), edge.node(), isSymbol(value));
17521         m_out.jump(continuation);
17522 
17523         m_out.appendTo(continuation, lastNext);
17524 
17525         m_interpreter.filter(edge, ~SpecSymbol);
17526     }
17527 
17528     void speculateOther(Edge edge)
17529     {
17530         if (!m_interpreter.needsTypeCheck(edge))
17531             return;
17532 
17533         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17534         typeCheck(jsValueValue(value), edge, SpecOther, isNotOther(value));
17535     }
17536 
17537     void speculateMisc(Edge edge)
17538     {
17539         if (!m_interpreter.needsTypeCheck(edge))
17540             return;
17541 
17542         LValue value = lowJSValue(edge, ManualOperandSpeculation);
17543         typeCheck(jsValueValue(value), edge, SpecMisc, isNotMisc(value));
17544     }
17545 
17546     void speculateTypedArrayIsNotNeutered(LValue base)
17547     {
17548         LBasicBlock isWasteful = m_out.newBlock();
17549         LBasicBlock continuation = m_out.newBlock();
17550 
17551         LValue mode = m_out.load32(base, m_heaps.JSArrayBufferView_mode);
17552         m_out.branch(m_out.equal(mode, m_out.constInt32(WastefulTypedArray)),
17553             unsure(isWasteful), unsure(continuation));
17554 
17555         LBasicBlock lastNext = m_out.appendTo(isWasteful, continuation);
17556         LValue vector = m_out.loadPtr(base, m_heaps.JSArrayBufferView_vector);
17557         // FIXME: We could probably make this a mask.
17558         // https://bugs.webkit.org/show_bug.cgi?id=197701
17559         vector = removeArrayPtrTag(vector);
17560         speculate(Uncountable, jsValueValue(vector), m_node, m_out.isZero64(vector));
17561         m_out.jump(continuation);
17562 
17563         m_out.appendTo(continuation, lastNext);
17564     }
17565 
17566     bool masqueradesAsUndefinedWatchpointIsStillValid()
17567     {
17568         return m_graph.masqueradesAsUndefinedWatchpointIsStillValid(m_node-&gt;origin.semantic);
17569     }
17570 
17571     LValue loadCellState(LValue base)
17572     {
17573         return m_out.load8ZeroExt32(base, m_heaps.JSCell_cellState);
17574     }
17575 
17576     void emitStoreBarrier(LValue base, bool isFenced)
17577     {
17578         LBasicBlock recheckPath = nullptr;
17579         if (isFenced)
17580             recheckPath = m_out.newBlock();
17581         LBasicBlock slowPath = m_out.newBlock();
17582         LBasicBlock continuation = m_out.newBlock();
17583 
17584         LBasicBlock lastNext = m_out.insertNewBlocksBefore(isFenced ? recheckPath : slowPath);
17585 
17586         LValue threshold;
17587         if (isFenced)
17588             threshold = m_out.load32(m_out.absolute(vm().heap.addressOfBarrierThreshold()));
17589         else
17590             threshold = m_out.constInt32(blackThreshold);
17591 
17592         m_out.branch(
17593             m_out.above(loadCellState(base), threshold),
17594             usually(continuation), rarely(isFenced ? recheckPath : slowPath));
17595 
17596         if (isFenced) {
17597             m_out.appendTo(recheckPath, slowPath);
17598 
17599             m_out.fence(&amp;m_heaps.root, &amp;m_heaps.JSCell_cellState);
17600 
17601             m_out.branch(
17602                 m_out.above(loadCellState(base), m_out.constInt32(blackThreshold)),
17603                 usually(continuation), rarely(slowPath));
17604         }
17605 
17606         m_out.appendTo(slowPath, continuation);
17607 
<a name="586" id="anc586"></a><span class="line-modified">17608         LValue call = vmCall(Void, operationWriteBarrierSlowPath, m_vmValue, base);</span>
17609         m_heaps.decorateCCallRead(&amp;m_heaps.root, call);
17610         m_heaps.decorateCCallWrite(&amp;m_heaps.JSCell_cellState, call);
17611 
17612         m_out.jump(continuation);
17613 
17614         m_out.appendTo(continuation, lastNext);
17615     }
17616 
17617     void mutatorFence()
17618     {
17619         if (isX86()) {
17620             m_out.fence(&amp;m_heaps.root, nullptr);
17621             return;
17622         }
17623 
17624         LBasicBlock slowPath = m_out.newBlock();
17625         LBasicBlock continuation = m_out.newBlock();
17626 
17627         LBasicBlock lastNext = m_out.insertNewBlocksBefore(slowPath);
17628 
17629         m_out.branch(
17630             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
17631             rarely(slowPath), usually(continuation));
17632 
17633         m_out.appendTo(slowPath, continuation);
17634 
17635         m_out.fence(&amp;m_heaps.root, nullptr);
17636         m_out.jump(continuation);
17637 
17638         m_out.appendTo(continuation, lastNext);
17639     }
17640 
17641     void nukeStructureAndSetButterfly(LValue butterfly, LValue object)
17642     {
17643         if (isX86()) {
17644             m_out.store32(
17645                 m_out.bitOr(
17646                     m_out.load32(object, m_heaps.JSCell_structureID),
17647                     m_out.constInt32(nukedStructureIDBit())),
17648                 object, m_heaps.JSCell_structureID);
17649             m_out.fence(&amp;m_heaps.root, nullptr);
17650             m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
17651             m_out.fence(&amp;m_heaps.root, nullptr);
17652             return;
17653         }
17654 
17655         LBasicBlock fastPath = m_out.newBlock();
17656         LBasicBlock slowPath = m_out.newBlock();
17657         LBasicBlock continuation = m_out.newBlock();
17658 
17659         LBasicBlock lastNext = m_out.insertNewBlocksBefore(fastPath);
17660 
17661         m_out.branch(
17662             m_out.load8ZeroExt32(m_out.absolute(vm().heap.addressOfMutatorShouldBeFenced())),
17663             rarely(slowPath), usually(fastPath));
17664 
17665         m_out.appendTo(fastPath, slowPath);
17666 
17667         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
17668         m_out.jump(continuation);
17669 
17670         m_out.appendTo(slowPath, continuation);
17671 
17672         m_out.store32(
17673             m_out.bitOr(
17674                 m_out.load32(object, m_heaps.JSCell_structureID),
17675                 m_out.constInt32(nukedStructureIDBit())),
17676             object, m_heaps.JSCell_structureID);
17677         m_out.fence(&amp;m_heaps.root, nullptr);
17678         m_out.storePtr(butterfly, object, m_heaps.JSObject_butterfly);
17679         m_out.fence(&amp;m_heaps.root, nullptr);
17680         m_out.jump(continuation);
17681 
17682         m_out.appendTo(continuation, lastNext);
17683     }
17684 
<a name="587" id="anc587"></a><span class="line-modified">17685     template&lt;typename OperationType, typename... Args&gt;</span>
<span class="line-modified">17686     LValue vmCall(LType type, OperationType function, Args&amp;&amp;... args)</span>
















17687     {
<a name="588" id="anc588"></a><span class="line-added">17688         static_assert(!std::is_same&lt;OperationType, LValue&gt;::value);</span>
<span class="line-added">17689         static_assert(FunctionTraits&lt;OperationType&gt;::cCallArity() == sizeof...(Args), &quot;Sanity check&quot;);</span>
17690         callPreflight();
<a name="589" id="anc589"></a><span class="line-modified">17691         LValue result = m_out.call(type, m_out.operation(function), std::forward&lt;Args&gt;(args)...);</span>
17692         if (mayExit(m_graph, m_node))
17693             callCheck();
17694         else {
17695             // We can&#39;t exit due to an exception, so we also can&#39;t throw an exception.
17696 #ifndef NDEBUG
17697             LBasicBlock crash = m_out.newBlock();
17698             LBasicBlock continuation = m_out.newBlock();
17699 
17700             LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
17701             LValue hadException = m_out.notZero64(exception);
17702 
17703             m_out.branch(
17704                 hadException, rarely(crash), usually(continuation));
17705 
17706             LBasicBlock lastNext = m_out.appendTo(crash, continuation);
17707             m_out.unreachable();
17708 
17709             m_out.appendTo(continuation, lastNext);
17710 #endif
17711         }
17712         return result;
17713     }
17714 
17715     void callPreflight(CodeOrigin codeOrigin)
17716     {
17717         CallSiteIndex callSiteIndex = m_ftlState.jitCode-&gt;common.addCodeOrigin(codeOrigin);
17718         m_out.store32(
17719             m_out.constInt32(callSiteIndex.bits()),
<a name="590" id="anc590"></a><span class="line-modified">17720             tagFor(VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));</span>
<span class="line-added">17721 #if !USE(BUILTIN_FRAME_ADDRESS) || ASSERT_ENABLED</span>
<span class="line-added">17722         m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));</span>
<span class="line-added">17723 #endif</span>
17724     }
17725 
17726     void callPreflight()
17727     {
17728         callPreflight(codeOriginDescriptionOfCallSite());
17729     }
17730 
17731     CodeOrigin codeOriginDescriptionOfCallSite() const
17732     {
17733         CodeOrigin codeOrigin = m_node-&gt;origin.semantic;
17734         if (m_node-&gt;op() == TailCallInlinedCaller
17735             || m_node-&gt;op() == TailCallVarargsInlinedCaller
17736             || m_node-&gt;op() == TailCallForwardVarargsInlinedCaller
17737             || m_node-&gt;op() == DirectTailCallInlinedCaller) {
17738             // This case arises when you have a situation like this:
17739             // foo makes a call to bar, bar is inlined in foo. bar makes a call
17740             // to baz and baz is inlined in bar. And then baz makes a tail-call to jaz,
17741             // and jaz is inlined in baz. We want the callframe for jaz to appear to
17742             // have caller be bar.
17743             codeOrigin = *codeOrigin.inlineCallFrame()-&gt;getCallerSkippingTailCalls();
17744         }
17745 
17746         return codeOrigin;
17747     }
17748 
17749     void callCheck()
17750     {
<a name="591" id="anc591"></a><span class="line-modified">17751         JSGlobalObject* globalObject = m_graph.globalObjectFor(m_node-&gt;origin.semantic);</span>
<span class="line-modified">17752         if (Options::useExceptionFuzz()) {</span>
<span class="line-added">17753 #if !USE(BUILTIN_FRAME_ADDRESS) || ASSERT_ENABLED</span>
<span class="line-added">17754             m_out.storePtr(m_callFrame, m_out.absolute(&amp;vm().topCallFrame));</span>
<span class="line-added">17755 #endif</span>
<span class="line-added">17756             m_out.call(Void, m_out.operation(operationExceptionFuzz), weakPointer(globalObject));</span>
<span class="line-added">17757         }</span>
17758 
17759         LValue exception = m_out.load64(m_out.absolute(vm().addressOfException()));
17760         LValue hadException = m_out.notZero64(exception);
17761 
17762         CodeOrigin opCatchOrigin;
17763         HandlerInfo* exceptionHandler;
17764         if (m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler)) {
17765             bool exitOK = true;
17766             bool isExceptionHandler = true;
17767             appendOSRExit(
17768                 ExceptionCheck, noValue(), nullptr, hadException,
17769                 m_origin.withForExitAndExitOK(opCatchOrigin, exitOK), isExceptionHandler);
17770             return;
17771         }
17772 
17773         LBasicBlock continuation = m_out.newBlock();
17774 
17775         m_out.branch(
17776             hadException, rarely(m_handleExceptions), usually(continuation));
17777 
17778         m_out.appendTo(continuation);
17779     }
17780 
17781     RefPtr&lt;PatchpointExceptionHandle&gt; preparePatchpointForExceptions(PatchpointValue* value)
17782     {
17783         CodeOrigin opCatchOrigin;
17784         HandlerInfo* exceptionHandler;
17785         bool willCatchException = m_graph.willCatchExceptionInMachineFrame(m_origin.forExit, opCatchOrigin, exceptionHandler);
17786         if (!willCatchException)
17787             return PatchpointExceptionHandle::defaultHandle(m_ftlState);
17788 
17789         dataLogLnIf(verboseCompilationEnabled(), &quot;    Patchpoint exception OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());
17790 
17791         bool exitOK = true;
17792         NodeOrigin origin = m_origin.withForExitAndExitOK(opCatchOrigin, exitOK);
17793 
17794         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(noValue(), nullptr);
17795 
17796         // Compute the offset into the StackmapGenerationParams where we will find the exit arguments
17797         // we are about to append. We need to account for both the children we&#39;ve already added, and
17798         // for the possibility of a result value if the patchpoint is not void.
17799         unsigned offset = value-&gt;numChildren();
17800         if (value-&gt;type() != Void)
17801             offset++;
17802 
17803         // Use LateColdAny to ensure that the stackmap arguments interfere with the patchpoint&#39;s
17804         // result and with any late-clobbered registers.
17805         value-&gt;appendVectorWithRep(
17806             buildExitArguments(exitDescriptor, opCatchOrigin, noValue()),
17807             ValueRep::LateColdAny);
17808 
17809         return PatchpointExceptionHandle::create(
17810             m_ftlState, exitDescriptor, origin, offset, *exceptionHandler);
17811     }
17812 
17813     LBasicBlock lowBlock(DFG::BasicBlock* block)
17814     {
17815         return m_blocks.get(block);
17816     }
17817 
17818     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, Node* highValue)
17819     {
17820         return appendOSRExitDescriptor(lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue));
17821     }
17822 
17823     OSRExitDescriptor* appendOSRExitDescriptor(FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile)
17824     {
17825         return &amp;m_ftlState.jitCode-&gt;osrExitDescriptors.alloc(
17826             lowValue.format(), profile,
17827             availabilityMap().m_locals.numberOfArguments(),
<a name="592" id="anc592"></a><span class="line-modified">17828             availabilityMap().m_locals.numberOfLocals(),</span>
<span class="line-added">17829             availabilityMap().m_locals.numberOfTmps());</span>
17830     }
17831 
17832     void appendOSRExit(
17833         ExitKind kind, FormattedValue lowValue, Node* highValue, LValue failCondition,
17834         NodeOrigin origin, bool isExceptionHandler = false)
17835     {
17836         return appendOSRExit(kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue),
17837             failCondition, origin, isExceptionHandler);
17838     }
17839 
17840     void appendOSRExit(
17841         ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, LValue failCondition,
17842         NodeOrigin origin, bool isExceptionHandler = false)
17843     {
17844         dataLogLnIf(verboseCompilationEnabled(), &quot;    OSR exit #&quot;, m_ftlState.jitCode-&gt;osrExitDescriptors.size(), &quot; with availability: &quot;, availabilityMap());
17845 
17846         DFG_ASSERT(m_graph, m_node, origin.exitOK);
17847 
17848         if (!isExceptionHandler
17849             &amp;&amp; Options::useOSRExitFuzz()
17850             &amp;&amp; canUseOSRExitFuzzing(m_graph.baselineCodeBlockFor(m_node-&gt;origin.semantic))
17851             &amp;&amp; doOSRExitFuzzing()) {
17852             LValue numberOfFuzzChecks = m_out.add(
17853                 m_out.load32(m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks)),
17854                 m_out.int32One);
17855 
17856             m_out.store32(numberOfFuzzChecks, m_out.absolute(&amp;g_numberOfOSRExitFuzzChecks));
17857 
17858             if (unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter()) {
17859                 failCondition = m_out.bitOr(
17860                     failCondition,
17861                     m_out.aboveOrEqual(numberOfFuzzChecks, m_out.constInt32(atOrAfter)));
17862             }
17863             if (unsigned at = Options::fireOSRExitFuzzAt()) {
17864                 failCondition = m_out.bitOr(
17865                     failCondition,
17866                     m_out.equal(numberOfFuzzChecks, m_out.constInt32(at)));
17867             }
17868         }
17869 
17870         if (failCondition == m_out.booleanFalse)
17871             return;
17872 
17873         blessSpeculation(
17874             m_out.speculate(failCondition), kind, lowValue, profile, origin);
17875     }
17876 
17877     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, Node* highValue, NodeOrigin origin)
17878     {
17879         blessSpeculation(value, kind, lowValue, m_graph.methodOfGettingAValueProfileFor(m_node, highValue), origin);
17880     }
17881 
17882     void blessSpeculation(CheckValue* value, ExitKind kind, FormattedValue lowValue, const MethodOfGettingAValueProfile&amp; profile, NodeOrigin origin)
17883     {
17884         OSRExitDescriptor* exitDescriptor = appendOSRExitDescriptor(lowValue, profile);
17885 
17886         value-&gt;appendColdAnys(buildExitArguments(exitDescriptor, origin.forExit, lowValue));
17887 
17888         State* state = &amp;m_ftlState;
17889         value-&gt;setGenerator(
17890             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
17891                 exitDescriptor-&gt;emitOSRExit(
17892                     *state, kind, origin, jit, params, 0);
17893             });
17894     }
17895 
17896     StackmapArgumentList buildExitArguments(
17897         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, FormattedValue lowValue,
17898         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
17899     {
17900         StackmapArgumentList result;
17901         buildExitArguments(
17902             exitDescriptor, exitOrigin, result, lowValue, offsetOfExitArgumentsInStackmapLocations);
17903         return result;
17904     }
17905 
17906     void buildExitArguments(
17907         OSRExitDescriptor* exitDescriptor, CodeOrigin exitOrigin, StackmapArgumentList&amp; arguments, FormattedValue lowValue,
17908         unsigned offsetOfExitArgumentsInStackmapLocations = 0)
17909     {
17910         if (!!lowValue)
17911             arguments.append(lowValue.value());
17912 
17913         AvailabilityMap availabilityMap = this-&gt;availabilityMap();
17914         availabilityMap.pruneByLiveness(m_graph, exitOrigin);
17915 
17916         HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt; map;
17917         availabilityMap.forEachAvailability(
17918             [&amp;] (Availability availability) {
17919                 if (!availability.shouldUseNode())
17920                     return;
17921 
17922                 Node* node = availability.node();
17923                 if (!node-&gt;isPhantomAllocation())
17924                     return;
17925 
17926                 auto result = map.add(node, nullptr);
17927                 if (result.isNewEntry) {
17928                     result.iterator-&gt;value =
17929                         exitDescriptor-&gt;m_materializations.add(node-&gt;op(), node-&gt;origin.semantic);
17930                 }
17931             });
17932 
17933         for (unsigned i = 0; i &lt; exitDescriptor-&gt;m_values.size(); ++i) {
<a name="593" id="anc593"></a><span class="line-modified">17934             Operand operand = exitDescriptor-&gt;m_values.operandForIndex(i);</span>
17935 
17936             Availability availability = availabilityMap.m_locals[i];
17937 
17938             if (Options::validateFTLOSRExitLiveness()
17939                 &amp;&amp; m_graph.m_plan.mode() != FTLForOSREntryMode) {
17940 
<a name="594" id="anc594"></a><span class="line-modified">17941                 if (availability.isDead() &amp;&amp; m_graph.isLiveInBytecode(operand, exitOrigin))</span>
<span class="line-modified">17942                     DFG_CRASH(m_graph, m_node, toCString(&quot;Live bytecode local not available: operand = &quot;, operand, &quot;, availability = &quot;, availability, &quot;, origin = &quot;, exitOrigin).data());</span>
17943             }
17944             ExitValue exitValue = exitValueForAvailability(arguments, map, availability);
17945             if (exitValue.hasIndexInStackmapLocations())
17946                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
17947             exitDescriptor-&gt;m_values[i] = exitValue;
17948         }
17949 
17950         for (auto heapPair : availabilityMap.m_heap) {
17951             Node* node = heapPair.key.base();
17952             ExitTimeObjectMaterialization* materialization = map.get(node);
17953             if (!materialization)
17954                 DFG_CRASH(m_graph, m_node, toCString(&quot;Could not find materialization for &quot;, node, &quot; in &quot;, availabilityMap).data());
17955             ExitValue exitValue = exitValueForAvailability(arguments, map, heapPair.value);
17956             if (exitValue.hasIndexInStackmapLocations())
17957                 exitValue.adjustStackmapLocationsIndexByOffset(offsetOfExitArgumentsInStackmapLocations);
17958             materialization-&gt;add(
17959                 heapPair.key.descriptor(),
17960                 exitValue);
17961         }
17962 
17963         if (verboseCompilationEnabled()) {
17964             dataLog(&quot;        Exit values: &quot;, exitDescriptor-&gt;m_values, &quot;\n&quot;);
17965             if (!exitDescriptor-&gt;m_materializations.isEmpty()) {
17966                 dataLog(&quot;        Materializations: \n&quot;);
17967                 for (ExitTimeObjectMaterialization* materialization : exitDescriptor-&gt;m_materializations)
17968                     dataLog(&quot;            &quot;, pointerDump(materialization), &quot;\n&quot;);
17969             }
17970         }
17971     }
17972 
17973     ExitValue exitValueForAvailability(
17974         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
17975         Availability availability)
17976     {
17977         FlushedAt flush = availability.flushedAt();
17978         switch (flush.format()) {
17979         case DeadFlush:
17980         case ConflictingFlush:
17981             if (availability.hasNode())
17982                 return exitValueForNode(arguments, map, availability.node());
17983 
17984             // This means that the value is dead. It could be dead in bytecode or it could have
17985             // been killed by our DCE, which can sometimes kill things even if they were live in
17986             // bytecode.
17987             return ExitValue::dead();
17988 
17989         case FlushedJSValue:
17990         case FlushedCell:
17991         case FlushedBoolean:
17992             return ExitValue::inJSStack(flush.virtualRegister());
17993 
17994         case FlushedInt32:
17995             return ExitValue::inJSStackAsInt32(flush.virtualRegister());
17996 
17997         case FlushedInt52:
17998             return ExitValue::inJSStackAsInt52(flush.virtualRegister());
17999 
18000         case FlushedDouble:
18001             return ExitValue::inJSStackAsDouble(flush.virtualRegister());
18002         }
18003 
18004         DFG_CRASH(m_graph, m_node, &quot;Invalid flush format&quot;);
18005         return ExitValue::dead();
18006     }
18007 
18008     ExitValue exitValueForNode(
18009         StackmapArgumentList&amp; arguments, const HashMap&lt;Node*, ExitTimeObjectMaterialization*&gt;&amp; map,
18010         Node* node)
18011     {
18012         // NOTE: In FTL-&gt;B3, we cannot generate code here, because m_output is positioned after the
18013         // stackmap value. Like all values, the stackmap value cannot use a child that is defined after
18014         // it.
18015 
18016         ASSERT(node-&gt;shouldGenerate());
18017         ASSERT(node-&gt;hasResult());
18018 
18019         if (node) {
18020             switch (node-&gt;op()) {
18021             case BottomValue:
18022                 // This might arise in object materializations. I actually doubt that it would,
18023                 // but it seems worthwhile to be conservative.
18024                 return ExitValue::dead();
18025 
18026             case JSConstant:
18027             case Int52Constant:
18028             case DoubleConstant:
18029                 return ExitValue::constant(node-&gt;asJSValue());
18030 
18031             default:
18032                 if (node-&gt;isPhantomAllocation())
18033                     return ExitValue::materializeNewObject(map.get(node));
18034                 break;
18035             }
18036         }
18037 
18038         LoweredNodeValue value = m_int32Values.get(node);
18039         if (isValid(value))
18040             return exitArgument(arguments, DataFormatInt32, value.value());
18041 
18042         value = m_int52Values.get(node);
18043         if (isValid(value))
18044             return exitArgument(arguments, DataFormatInt52, value.value());
18045 
18046         value = m_strictInt52Values.get(node);
18047         if (isValid(value))
18048             return exitArgument(arguments, DataFormatStrictInt52, value.value());
18049 
18050         value = m_booleanValues.get(node);
18051         if (isValid(value))
18052             return exitArgument(arguments, DataFormatBoolean, value.value());
18053 
18054         value = m_jsValueValues.get(node);
18055         if (isValid(value))
18056             return exitArgument(arguments, DataFormatJS, value.value());
18057 
18058         value = m_doubleValues.get(node);
18059         if (isValid(value))
18060             return exitArgument(arguments, DataFormatDouble, value.value());
18061 
18062         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
18063         return ExitValue::dead();
18064     }
18065 
18066     ExitValue exitArgument(StackmapArgumentList&amp; arguments, DataFormat format, LValue value)
18067     {
18068         ExitValue result = ExitValue::exitArgument(ExitArgument(format, arguments.size()));
18069         arguments.append(value);
18070         return result;
18071     }
18072 
18073     ExitValue exitValueForTailCall(StackmapArgumentList&amp; arguments, Node* node)
18074     {
18075         ASSERT(node-&gt;shouldGenerate());
18076         ASSERT(node-&gt;hasResult());
18077 
18078         switch (node-&gt;op()) {
18079         case JSConstant:
18080         case Int52Constant:
18081         case DoubleConstant:
18082             return ExitValue::constant(node-&gt;asJSValue());
18083 
18084         default:
18085             break;
18086         }
18087 
18088         LoweredNodeValue value = m_jsValueValues.get(node);
18089         if (isValid(value))
18090             return exitArgument(arguments, DataFormatJS, value.value());
18091 
18092         value = m_int32Values.get(node);
18093         if (isValid(value))
18094             return exitArgument(arguments, DataFormatJS, boxInt32(value.value()));
18095 
18096         value = m_booleanValues.get(node);
18097         if (isValid(value))
18098             return exitArgument(arguments, DataFormatJS, boxBoolean(value.value()));
18099 
18100         // Doubles and Int52 have been converted by ValueRep()
18101         DFG_CRASH(m_graph, m_node, toCString(&quot;Cannot find value for node: &quot;, node).data());
18102     }
18103 
18104     void setInt32(Node* node, LValue value)
18105     {
18106         m_int32Values.set(node, LoweredNodeValue(value, m_highBlock));
18107     }
18108     void setInt52(Node* node, LValue value)
18109     {
18110         m_int52Values.set(node, LoweredNodeValue(value, m_highBlock));
18111     }
18112     void setStrictInt52(Node* node, LValue value)
18113     {
18114         m_strictInt52Values.set(node, LoweredNodeValue(value, m_highBlock));
18115     }
18116     void setInt52(Node* node, LValue value, Int52Kind kind)
18117     {
18118         switch (kind) {
18119         case Int52:
18120             setInt52(node, value);
18121             return;
18122 
18123         case StrictInt52:
18124             setStrictInt52(node, value);
18125             return;
18126         }
18127 
18128         DFG_CRASH(m_graph, m_node, &quot;Corrupt int52 kind&quot;);
18129     }
18130     void setJSValue(Node* node, LValue value)
18131     {
18132         m_jsValueValues.set(node, LoweredNodeValue(value, m_highBlock));
18133     }
18134     void setBoolean(Node* node, LValue value)
18135     {
18136         m_booleanValues.set(node, LoweredNodeValue(value, m_highBlock));
18137     }
18138     void setStorage(Node* node, LValue value)
18139     {
18140         m_storageValues.set(node, LoweredNodeValue(value, m_highBlock));
18141     }
18142     void setDouble(Node* node, LValue value)
18143     {
18144         m_doubleValues.set(node, LoweredNodeValue(value, m_highBlock));
18145     }
18146 
18147     void setInt32(LValue value)
18148     {
18149         setInt32(m_node, value);
18150     }
18151     void setInt52(LValue value)
18152     {
18153         setInt52(m_node, value);
18154     }
18155     void setStrictInt52(LValue value)
18156     {
18157         setStrictInt52(m_node, value);
18158     }
18159     void setInt52(LValue value, Int52Kind kind)
18160     {
18161         setInt52(m_node, value, kind);
18162     }
18163     void setJSValue(LValue value)
18164     {
18165         setJSValue(m_node, value);
18166     }
18167     void setBoolean(LValue value)
18168     {
18169         setBoolean(m_node, value);
18170     }
18171     void setStorage(LValue value)
18172     {
18173         setStorage(m_node, value);
18174     }
18175     void setDouble(LValue value)
18176     {
18177         setDouble(m_node, value);
18178     }
18179 
18180     bool isValid(const LoweredNodeValue&amp; value)
18181     {
18182         if (!value)
18183             return false;
18184         if (!m_graph.m_ssaDominators-&gt;dominates(value.block(), m_highBlock))
18185             return false;
18186         return true;
18187     }
18188 
18189     void keepAlive(LValue value)
18190     {
18191         PatchpointValue* patchpoint = m_out.patchpoint(Void);
18192         patchpoint-&gt;effects = Effects::none();
18193         patchpoint-&gt;effects.writesLocalState = true;
18194         patchpoint-&gt;effects.reads = HeapRange::top();
18195         patchpoint-&gt;append(value, ValueRep::ColdAny);
18196         patchpoint-&gt;setGenerator([=] (CCallHelpers&amp;, const StackmapGenerationParams&amp;) { });
18197     }
18198 
<a name="595" id="anc595"></a><span class="line-added">18199     LValue toButterfly(LValue immutableButterfly)</span>
<span class="line-added">18200     {</span>
<span class="line-added">18201         return m_out.addPtr(immutableButterfly, JSImmutableButterfly::offsetOfData());</span>
<span class="line-added">18202     }</span>
<span class="line-added">18203 </span>
18204     void addWeakReference(JSCell* target)
18205     {
18206         m_graph.m_plan.weakReferences().addLazily(target);
18207     }
18208 
18209     LValue loadStructure(LValue value)
18210     {
18211         LValue structureID = m_out.load32(value, m_heaps.JSCell_structureID);
18212         LValue tableBase = m_out.loadPtr(m_out.absolute(vm().heap.structureIDTable().base()));
18213         LValue tableIndex = m_out.aShr(structureID, m_out.constInt32(StructureIDTable::s_numberOfEntropyBits));
18214         LValue entropyBits = m_out.shl(m_out.zeroExtPtr(structureID), m_out.constInt32(StructureIDTable::s_entropyBitsShiftForStructurePointer));
18215         TypedPointer address = m_out.baseIndex(m_heaps.structureTable, tableBase, m_out.zeroExtPtr(tableIndex));
18216         LValue encodedStructureBits = m_out.loadPtr(address);
18217         return m_out.bitXor(encodedStructureBits, entropyBits);
18218     }
18219 
18220     LValue weakPointer(JSCell* pointer)
18221     {
18222         addWeakReference(pointer);
<a name="596" id="anc596"></a><span class="line-modified">18223         return m_out.alreadyRegisteredWeakPointer(m_graph, pointer);</span>
18224     }
18225 
18226     LValue frozenPointer(FrozenValue* value)
18227     {
<a name="597" id="anc597"></a><span class="line-modified">18228         return m_out.alreadyRegisteredFrozenPointer(value);</span>
18229     }
18230 
18231     LValue weakStructureID(RegisteredStructure structure)
18232     {
18233         return m_out.constInt32(structure-&gt;id());
18234     }
18235 
18236     LValue weakStructure(RegisteredStructure structure)
18237     {
18238         ASSERT(!!structure.get());
<a name="598" id="anc598"></a><span class="line-modified">18239         return m_out.alreadyRegisteredWeakPointer(m_graph, structure.get());</span>
18240     }
18241 
<a name="599" id="anc599"></a><span class="line-modified">18242     TypedPointer addressFor(LValue base, Operand operand, ptrdiff_t offset = 0)</span>
18243     {
<a name="600" id="anc600"></a><span class="line-modified">18244         return m_out.address(base, m_heaps.variables[operand.virtualRegister().offset()], offset);</span>
18245     }
<a name="601" id="anc601"></a><span class="line-modified">18246     TypedPointer payloadFor(LValue base, Operand operand)</span>
18247     {
18248         return addressFor(base, operand, PayloadOffset);
18249     }
<a name="602" id="anc602"></a><span class="line-modified">18250     TypedPointer tagFor(LValue base, Operand operand)</span>
18251     {
18252         return addressFor(base, operand, TagOffset);
18253     }
<a name="603" id="anc603"></a><span class="line-modified">18254     TypedPointer addressFor(Operand operand, ptrdiff_t offset = 0)</span>
18255     {
<a name="604" id="anc604"></a><span class="line-modified">18256         return addressFor(operand.virtualRegister(), offset);</span>
18257     }
18258     TypedPointer addressFor(VirtualRegister operand, ptrdiff_t offset = 0)
18259     {
18260         if (operand.isLocal())
<a name="605" id="anc605"></a><span class="line-modified">18261             return addressFor(m_captured, operand, offset);</span>
<span class="line-modified">18262         return addressFor(m_callFrame, operand, offset);</span>
18263     }
<a name="606" id="anc606"></a><span class="line-modified">18264     TypedPointer payloadFor(Operand operand)</span>
18265     {
<a name="607" id="anc607"></a><span class="line-modified">18266         return payloadFor(operand.virtualRegister());</span>
18267     }
18268     TypedPointer payloadFor(VirtualRegister operand)
18269     {
18270         return addressFor(operand, PayloadOffset);
18271     }
<a name="608" id="anc608"></a><span class="line-modified">18272     TypedPointer tagFor(Operand operand)</span>
18273     {
<a name="609" id="anc609"></a><span class="line-modified">18274         return tagFor(operand.virtualRegister());</span>
18275     }
18276     TypedPointer tagFor(VirtualRegister operand)
18277     {
18278         return addressFor(operand, TagOffset);
18279     }
18280 
18281     AbstractValue abstractValue(Node* node)
18282     {
18283         return m_state.forNode(node);
18284     }
18285     AbstractValue abstractValue(Edge edge)
18286     {
18287         return abstractValue(edge.node());
18288     }
18289 
18290     SpeculatedType provenType(Node* node)
18291     {
18292         return abstractValue(node).m_type;
18293     }
18294     SpeculatedType provenType(Edge edge)
18295     {
18296         return provenType(edge.node());
18297     }
18298 
18299     JSValue provenValue(Node* node)
18300     {
18301         return abstractValue(node).m_value;
18302     }
18303     JSValue provenValue(Edge edge)
18304     {
18305         return provenValue(edge.node());
18306     }
18307 
18308     StructureAbstractValue abstractStructure(Node* node)
18309     {
18310         return abstractValue(node).m_structure;
18311     }
18312     StructureAbstractValue abstractStructure(Edge edge)
18313     {
18314         return abstractStructure(edge.node());
18315     }
18316 
18317     void crash()
18318     {
18319         crash(m_highBlock, m_node);
18320     }
18321     void crash(DFG::BasicBlock* block, Node* node)
18322     {
18323         BlockIndex blockIndex = block-&gt;index;
18324         unsigned nodeIndex = node ? node-&gt;index() : UINT_MAX;
<a name="610" id="anc610"></a><span class="line-modified">18325 #if !ASSERT_ENABLED</span>
18326         m_out.patchpoint(Void)-&gt;setGenerator(
18327             [=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp;) {
18328                 AllowMacroScratchRegisterUsage allowScratch(jit);
18329 
18330                 jit.move(CCallHelpers::TrustedImm32(blockIndex), GPRInfo::regT0);
18331                 jit.move(CCallHelpers::TrustedImm32(nodeIndex), GPRInfo::regT1);
18332                 if (node)
18333                     jit.move(CCallHelpers::TrustedImm32(node-&gt;op()), GPRInfo::regT2);
18334                 jit.abortWithReason(FTLCrash);
18335             });
<a name="611" id="anc611"></a><span class="line-modified">18336 #else // ASSERT_ENABLED</span>
18337         m_out.call(
18338             Void,
18339             m_out.constIntPtr(ftlUnreachable),
18340             // We don&#39;t want the CodeBlock to have a weak pointer to itself because
18341             // that would cause it to always get collected.
18342             m_out.constIntPtr(bitwise_cast&lt;intptr_t&gt;(codeBlock())), m_out.constInt32(blockIndex),
18343             m_out.constInt32(nodeIndex));
<a name="612" id="anc612"></a><span class="line-modified">18344 #endif // ASSERT_ENABLED</span>
18345         m_out.unreachable();
18346     }
18347 
18348     AvailabilityMap&amp; availabilityMap() { return m_availabilityCalculator.m_availability; }
18349 
18350     VM&amp; vm() { return m_graph.m_vm; }
18351     CodeBlock* codeBlock() { return m_graph.m_codeBlock; }
18352 
18353     Graph&amp; m_graph;
18354     State&amp; m_ftlState;
18355     AbstractHeapRepository m_heaps;
18356     Output m_out;
18357     Procedure&amp; m_proc;
18358 
18359     LBasicBlock m_handleExceptions;
18360     HashMap&lt;DFG::BasicBlock*, LBasicBlock&gt; m_blocks;
18361 
18362     LValue m_callFrame;
<a name="613" id="anc613"></a><span class="line-added">18363     LValue m_vmValue;</span>
18364     LValue m_captured;
<a name="614" id="anc614"></a><span class="line-modified">18365     LValue m_numberTag;</span>
<span class="line-modified">18366     LValue m_notCellMask;</span>
18367 
18368     HashMap&lt;Node*, LoweredNodeValue&gt; m_int32Values;
18369     HashMap&lt;Node*, LoweredNodeValue&gt; m_strictInt52Values;
18370     HashMap&lt;Node*, LoweredNodeValue&gt; m_int52Values;
18371     HashMap&lt;Node*, LoweredNodeValue&gt; m_jsValueValues;
18372     HashMap&lt;Node*, LoweredNodeValue&gt; m_booleanValues;
18373     HashMap&lt;Node*, LoweredNodeValue&gt; m_storageValues;
18374     HashMap&lt;Node*, LoweredNodeValue&gt; m_doubleValues;
18375 
18376     HashMap&lt;Node*, LValue&gt; m_phis;
18377 
18378     LocalOSRAvailabilityCalculator m_availabilityCalculator;
18379 
18380     InPlaceAbstractState m_state;
18381     AbstractInterpreter&lt;InPlaceAbstractState&gt; m_interpreter;
18382     DFG::BasicBlock* m_highBlock;
18383     DFG::BasicBlock* m_nextHighBlock;
18384     LBasicBlock m_nextLowBlock;
18385 
<a name="615" id="anc615"></a>



18386     NodeOrigin m_origin;
18387     unsigned m_nodeIndex;
18388     Node* m_node;
18389 
18390     // These are used for validating AI state.
18391     HashMap&lt;Node*, NodeSet&gt; m_liveInToNode;
18392     HashMap&lt;Node*, AbstractValue&gt; m_aiCheckedNodes;
18393     String m_graphDump;
18394 };
18395 
18396 } // anonymous namespace
18397 
18398 void lowerDFGToB3(State&amp; state)
18399 {
18400     LowerDFGToB3 lowering(state);
18401     lowering.lower();
18402 }
18403 
18404 } } // namespace JSC::FTL
18405 
18406 #endif // ENABLE(FTL_JIT)
18407 
<a name="616" id="anc616"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="616" type="hidden" />
</body>
</html>
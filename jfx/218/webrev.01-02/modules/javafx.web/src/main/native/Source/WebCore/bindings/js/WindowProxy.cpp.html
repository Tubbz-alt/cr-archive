<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WindowProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2006-2019 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;WindowProxy.h&quot;
 23 
 24 #include &quot;CommonVM.h&quot;
 25 #include &quot;Frame.h&quot;
 26 #include &quot;GCController.h&quot;
 27 #include &quot;JSWindowProxy.h&quot;
 28 #include &quot;Page.h&quot;
 29 #include &quot;PageConsoleClient.h&quot;
 30 #include &quot;PageGroup.h&quot;
 31 #include &quot;RemoteFrame.h&quot;
 32 #include &quot;ScriptController.h&quot;
 33 #include &quot;runtime_root.h&quot;
 34 #include &lt;JavaScriptCore/JSLock.h&gt;
 35 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 36 #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;
 37 #include &lt;wtf/MemoryPressureHandler.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 using namespace JSC;
 42 
 43 static void collectGarbageAfterWindowProxyDestruction()
 44 {
 45     // Make sure to GC Extra Soon(tm) during memory pressure conditions
 46     // to soften high peaks of memory usage during navigation.
 47     if (MemoryPressureHandler::singleton().isUnderMemoryPressure()) {
 48         // NOTE: We do the collection on next runloop to ensure that there&#39;s no pointer
 49         //       to the window object on the stack.
 50         GCController::singleton().garbageCollectOnNextRunLoop();
 51     } else
 52         GCController::singleton().garbageCollectSoon();
 53 }
 54 
 55 WindowProxy::WindowProxy(AbstractFrame&amp; frame)
 56     : m_frame(&amp;frame)
 57     , m_jsWindowProxies(makeUniqueRef&lt;ProxyMap&gt;())
 58 {
 59 }
 60 
 61 WindowProxy::~WindowProxy()
 62 {
 63     ASSERT(!m_frame);
 64     ASSERT(m_jsWindowProxies-&gt;isEmpty());
 65 }
 66 
 67 void WindowProxy::detachFromFrame()
 68 {
 69     ASSERT(m_frame);
 70 
 71     m_frame = nullptr;
 72 
 73     // It&#39;s likely that destroying windowProxies will create a lot of garbage.
 74     if (!m_jsWindowProxies-&gt;isEmpty()) {
 75         while (!m_jsWindowProxies-&gt;isEmpty()) {
 76             auto it = m_jsWindowProxies-&gt;begin();
 77             it-&gt;value-&gt;window()-&gt;setConsoleClient(nullptr);
 78             destroyJSWindowProxy(*it-&gt;key);
 79         }
 80         collectGarbageAfterWindowProxyDestruction();
 81     }
 82 }
 83 
 84 void WindowProxy::destroyJSWindowProxy(DOMWrapperWorld&amp; world)
 85 {
 86     ASSERT(m_jsWindowProxies-&gt;contains(&amp;world));
 87     m_jsWindowProxies-&gt;remove(&amp;world);
 88     world.didDestroyWindowProxy(this);
 89 }
 90 
 91 JSWindowProxy&amp; WindowProxy::createJSWindowProxy(DOMWrapperWorld&amp; world)
 92 {
 93     ASSERT(m_frame);
 94 
 95     ASSERT(!m_jsWindowProxies-&gt;contains(&amp;world));
 96     ASSERT(m_frame-&gt;window());
 97 
 98     VM&amp; vm = world.vm();
 99 
100     Strong&lt;JSWindowProxy&gt; jsWindowProxy(vm, &amp;JSWindowProxy::create(vm, *m_frame-&gt;window(), world));
101     Strong&lt;JSWindowProxy&gt; jsWindowProxy2(jsWindowProxy);
102     m_jsWindowProxies-&gt;add(&amp;world, jsWindowProxy);
103     world.didCreateWindowProxy(this);
104     return *jsWindowProxy.get();
105 }
106 
107 Vector&lt;JSC::Strong&lt;JSWindowProxy&gt;&gt; WindowProxy::jsWindowProxiesAsVector() const
108 {
109     return copyToVector(m_jsWindowProxies-&gt;values());
110 }
111 
112 JSDOMGlobalObject* WindowProxy::globalObject(DOMWrapperWorld&amp; world)
113 {
114     if (auto* windowProxy = jsWindowProxy(world))
115         return windowProxy-&gt;window();
116     return nullptr;
117 }
118 
119 JSWindowProxy&amp; WindowProxy::createJSWindowProxyWithInitializedScript(DOMWrapperWorld&amp; world)
120 {
121     ASSERT(m_frame);
122 
123     JSLockHolder lock(world.vm());
124     auto&amp; windowProxy = createJSWindowProxy(world);
125     if (is&lt;Frame&gt;(*m_frame))
126         downcast&lt;Frame&gt;(*m_frame).script().initScriptForWindowProxy(windowProxy);
127     return windowProxy;
128 }
129 
130 void WindowProxy::clearJSWindowProxiesNotMatchingDOMWindow(AbstractDOMWindow* newDOMWindow, bool goingIntoBackForwardCache)
131 {
132     if (m_jsWindowProxies-&gt;isEmpty())
133         return;
134 
135     JSLockHolder lock(commonVM());
136 
137     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
138         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
139             continue;
140 
141         // Clear the debugger and console from the current window before setting the new window.
142         windowProxy-&gt;attachDebugger(nullptr);
143         windowProxy-&gt;window()-&gt;setConsoleClient(nullptr);
144         if (auto* jsDOMWindow = jsDynamicCast&lt;JSDOMWindowBase*&gt;(windowProxy-&gt;vm(), windowProxy-&gt;window()))
145             jsDOMWindow-&gt;willRemoveFromWindowProxy();
146     }
147 
148     // It&#39;s likely that resetting our windows created a lot of garbage, unless
149     // it went in a back/forward cache.
150     if (!goingIntoBackForwardCache)
151         collectGarbageAfterWindowProxyDestruction();
152 }
153 
154 void WindowProxy::setDOMWindow(AbstractDOMWindow* newDOMWindow)
155 {
156     ASSERT(newDOMWindow);
157 
158     if (m_jsWindowProxies-&gt;isEmpty())
159         return;
160 
161     ASSERT(m_frame);
162 
163     JSLockHolder lock(commonVM());
164 
165     for (auto&amp; windowProxy : jsWindowProxiesAsVector()) {
166         if (&amp;windowProxy-&gt;wrapped() == newDOMWindow)
167             continue;
168 
169         windowProxy-&gt;setWindow(*newDOMWindow);
170 
171         ScriptController* scriptController = nullptr;
172         Page* page = nullptr;
173         if (is&lt;Frame&gt;(*m_frame)) {
174             auto&amp; frame = downcast&lt;Frame&gt;(*m_frame);
175             scriptController = &amp;frame.script();
176             page = frame.page();
177         }
178 
179         // ScriptController&#39;s m_cacheableBindingRootObject persists between page navigations
180         // so needs to know about the new JSDOMWindow.
181         if (auto* cacheableBindingRootObject = scriptController ? scriptController-&gt;existingCacheableBindingRootObject() : nullptr)
182             cacheableBindingRootObject-&gt;updateGlobalObject(windowProxy-&gt;window());
183 
184         windowProxy-&gt;attachDebugger(page ? page-&gt;debugger() : nullptr);
185         if (page)
186             windowProxy-&gt;window()-&gt;setProfileGroup(page-&gt;group().identifier());
187         windowProxy-&gt;window()-&gt;setConsoleClient(page ? &amp;page-&gt;console() : nullptr);
188     }
189 }
190 
191 void WindowProxy::attachDebugger(JSC::Debugger* debugger)
192 {
193     for (auto&amp; windowProxy : m_jsWindowProxies-&gt;values())
194         windowProxy-&gt;attachDebugger(debugger);
195 }
196 
197 AbstractDOMWindow* WindowProxy::window() const
198 {
199     return m_frame ? m_frame-&gt;window() : nullptr;
200 }
201 
202 WindowProxy::ProxyMap::ValuesConstIteratorRange WindowProxy::jsWindowProxies() const
203 {
204     return m_jsWindowProxies-&gt;values();
205 }
206 
207 WindowProxy::ProxyMap WindowProxy::releaseJSWindowProxies()
208 {
209     return std::exchange(m_jsWindowProxies, makeUniqueRef&lt;ProxyMap&gt;());
210 }
211 
212 void WindowProxy::setJSWindowProxies(ProxyMap&amp;&amp; windowProxies)
213 {
214     m_jsWindowProxies = makeUniqueRef&lt;ProxyMap&gt;(WTFMove(windowProxies));
215 }
216 
217 } // namespace WebCore
    </pre>
  </body>
</html>
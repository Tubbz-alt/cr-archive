<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/animation/WebAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;WebAnimation.h&quot;
  28 
  29 #include &quot;AnimationEffect.h&quot;
  30 #include &quot;AnimationPlaybackEvent.h&quot;
  31 #include &quot;AnimationTimeline.h&quot;
  32 #include &quot;CSSComputedStyleDeclaration.h&quot;
  33 #include &quot;DOMPromiseProxy.h&quot;
  34 #include &quot;DeclarativeAnimation.h&quot;
  35 #include &quot;Document.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;
  37 #include &quot;EventLoop.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;InspectorInstrumentation.h&quot;
  40 #include &quot;JSWebAnimation.h&quot;
  41 #include &quot;KeyframeEffect.h&quot;
  42 #include &quot;KeyframeEffectStack.h&quot;
  43 #include &quot;Logging.h&quot;
  44 #include &quot;RenderElement.h&quot;
  45 #include &quot;StyledElement.h&quot;
  46 #include &quot;WebAnimationUtilities.h&quot;
  47 #include &lt;wtf/IsoMallocInlines.h&gt;
  48 #include &lt;wtf/Lock.h&gt;
  49 #include &lt;wtf/NeverDestroyed.h&gt;
  50 #include &lt;wtf/Optional.h&gt;
  51 #include &lt;wtf/text/TextStream.h&gt;
  52 #include &lt;wtf/text/WTFString.h&gt;
  53 
  54 namespace WebCore {
  55 
  56 WTF_MAKE_ISO_ALLOCATED_IMPL(WebAnimation);
  57 
  58 HashSet&lt;WebAnimation*&gt;&amp; WebAnimation::instances(const LockHolder&amp;)
  59 {
  60     static NeverDestroyed&lt;HashSet&lt;WebAnimation*&gt;&gt; instances;
  61     return instances;
  62 }
  63 
  64 Lock&amp; WebAnimation::instancesMutex()
  65 {
  66     static LazyNeverDestroyed&lt;Lock&gt; mutex;
  67     static std::once_flag initializeMutex;
  68     std::call_once(initializeMutex, [] {
  69         mutex.construct();
  70     });
  71     return mutex.get();
  72 }
  73 
  74 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect)
  75 {
  76     auto result = adoptRef(*new WebAnimation(document));
  77     result-&gt;setEffect(effect);
  78     result-&gt;setTimeline(&amp;document.timeline());
  79 
  80     InspectorInstrumentation::didCreateWebAnimation(result.get());
  81 
  82     return result;
  83 }
  84 
  85 Ref&lt;WebAnimation&gt; WebAnimation::create(Document&amp; document, AnimationEffect* effect, AnimationTimeline* timeline)
  86 {
  87     auto result = adoptRef(*new WebAnimation(document));
  88     result-&gt;setEffect(effect);
  89     if (timeline)
  90         result-&gt;setTimeline(timeline);
  91 
  92     InspectorInstrumentation::didCreateWebAnimation(result.get());
  93 
  94     return result;
  95 }
  96 
  97 WebAnimation::WebAnimation(Document&amp; document)
  98     : ActiveDOMObject(document)
  99     , m_readyPromise(makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve))
 100     , m_finishedPromise(makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve))
 101 {
 102     m_readyPromise-&gt;resolve(*this);
 103     suspendIfNeeded();
 104 
 105     LockHolder lock(instancesMutex());
 106     instances(lock).add(this);
 107 }
 108 
 109 WebAnimation::~WebAnimation()
 110 {
 111     InspectorInstrumentation::willDestroyWebAnimation(*this);
 112 
 113     if (m_timeline)
 114         m_timeline-&gt;forgetAnimation(this);
 115 
 116     LockHolder lock(instancesMutex());
 117     ASSERT(instances(lock).contains(this));
 118     instances(lock).remove(this);
 119 }
 120 
 121 void WebAnimation::contextDestroyed()
 122 {
 123     InspectorInstrumentation::willDestroyWebAnimation(*this);
 124 
 125     ActiveDOMObject::contextDestroyed();
 126 }
 127 
 128 void WebAnimation::remove()
 129 {
 130     // This object could be deleted after either clearing the effect or timeline relationship.
 131     auto protectedThis = makeRef(*this);
 132     setEffectInternal(nullptr);
 133     setTimelineInternal(nullptr);
 134 }
 135 
 136 void WebAnimation::suspendEffectInvalidation()
 137 {
 138     ++m_suspendCount;
 139 }
 140 
 141 void WebAnimation::unsuspendEffectInvalidation()
 142 {
 143     ASSERT(m_suspendCount &gt; 0);
 144     --m_suspendCount;
 145 }
 146 
 147 void WebAnimation::effectTimingDidChange(Optional&lt;ComputedEffectTiming&gt; previousTiming)
 148 {
 149     timingDidChange(DidSeek::No, SynchronouslyNotify::Yes);
 150 
 151     InspectorInstrumentation::didChangeWebAnimationEffectTiming(*this);
 152 
 153     if (!previousTiming)
 154         return;
 155 
 156     auto* effect = this-&gt;effect();
 157     ASSERT(effect);
 158     if (previousTiming-&gt;progress != effect-&gt;getComputedTiming().progress)
 159         effect-&gt;animationDidSeek();
 160 }
 161 
 162 void WebAnimation::setEffect(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect)
 163 {
 164     // 3.4.3. Setting the target effect of an animation
 165     // https://drafts.csswg.org/web-animations-1/#setting-the-target-effect
 166 
 167     // 1. Let old effect be the current target effect of animation, if any.
 168     auto oldEffect = m_effect;
 169 
 170     // 2. If new effect is the same object as old effect, abort this procedure.
 171     if (newEffect == oldEffect)
 172         return;
 173 
 174     // 3. If animation has a pending pause task, reschedule that task to run as soon as animation is ready.
 175     if (hasPendingPauseTask())
 176         m_timeToRunPendingPauseTask = TimeToRunPendingTask::WhenReady;
 177 
 178     // 4. If animation has a pending play task, reschedule that task to run as soon as animation is ready to play new effect.
 179     if (hasPendingPlayTask())
 180         m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 181 
 182     // 5. If new effect is not null and if new effect is the target effect of another animation, previous animation, run the
 183     // procedure to set the target effect of an animation (this procedure) on previous animation passing null as new effect.
 184     if (newEffect &amp;&amp; newEffect-&gt;animation())
 185         newEffect-&gt;animation()-&gt;setEffect(nullptr);
 186 
 187     // 6. Let the target effect of animation be new effect.
 188     // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 189     // while the effect was set via the API, the element still has a transition or animation set up and we must
 190     // not break the timeline-to-animation relationship.
 191 
 192     invalidateEffect();
 193 
 194     // This object could be deleted after clearing the effect relationship.
 195     auto protectedThis = makeRef(*this);
 196     setEffectInternal(WTFMove(newEffect), isDeclarativeAnimation());
 197 
 198     // 7. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 199     // and the synchronously notify flag set to false.
 200     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 201 
 202     invalidateEffect();
 203 }
 204 
 205 AnimationTimeline* WebAnimation::timeline() const
 206 {
 207     return m_timeline.get();
 208 }
 209 
 210 void WebAnimation::setEffectInternal(RefPtr&lt;AnimationEffect&gt;&amp;&amp; newEffect, bool doNotRemoveFromTimeline)
 211 {
 212     if (m_effect == newEffect)
 213         return;
 214 
 215     auto oldEffect = std::exchange(m_effect, WTFMove(newEffect));
 216 
 217     Element* previousTarget = nullptr;
 218     if (is&lt;KeyframeEffect&gt;(oldEffect))
 219         previousTarget = downcast&lt;KeyframeEffect&gt;(oldEffect.get())-&gt;target();
 220 
 221     Element* newTarget = nullptr;
 222     if (is&lt;KeyframeEffect&gt;(m_effect))
 223         newTarget = downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target();
 224 
 225     // Update the effect-to-animation relationships and the timeline&#39;s animation map.
 226     if (oldEffect) {
 227         oldEffect-&gt;setAnimation(nullptr);
 228         if (!doNotRemoveFromTimeline &amp;&amp; m_timeline &amp;&amp; previousTarget &amp;&amp; previousTarget != newTarget)
 229             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 230         updateRelevance();
 231     }
 232 
 233     if (m_effect) {
 234         m_effect-&gt;setAnimation(this);
 235         if (m_timeline &amp;&amp; newTarget &amp;&amp; previousTarget != newTarget)
 236             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 237     }
 238 
 239     InspectorInstrumentation::didSetWebAnimationEffect(*this);
 240 }
 241 
 242 void WebAnimation::setTimeline(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 243 {
 244     // 3.4.1. Setting the timeline of an animation
 245     // https://drafts.csswg.org/web-animations-1/#setting-the-timeline
 246 
 247     // 2. If new timeline is the same object as old timeline, abort this procedure.
 248     if (timeline == m_timeline.get())
 249         return;
 250 
 251     // 4. If the animation start time of animation is resolved, make animation&#39;s hold time unresolved.
 252     if (m_startTime)
 253         m_holdTime = WTF::nullopt;
 254 
 255     if (is&lt;KeyframeEffect&gt;(m_effect)) {
 256         auto* keyframeEffect = downcast&lt;KeyframeEffect&gt;(m_effect.get());
 257         auto* target = keyframeEffect-&gt;target();
 258         if (target) {
 259             // In the case of a declarative animation, we don&#39;t want to remove the animation from the relevant maps because
 260             // while the timeline was set via the API, the element still has a transition or animation set up and we must
 261             // not break the relationship.
 262             if (m_timeline &amp;&amp; !isDeclarativeAnimation())
 263                 m_timeline-&gt;animationWasRemovedFromElement(*this, *target);
 264             if (timeline)
 265                 timeline-&gt;animationWasAddedToElement(*this, *target);
 266         }
 267     }
 268 
 269     // This object could be deleted after clearing the timeline relationship.
 270     auto protectedThis = makeRef(*this);
 271     setTimelineInternal(WTFMove(timeline));
 272 
 273     setSuspended(is&lt;DocumentTimeline&gt;(m_timeline.get()) &amp;&amp; downcast&lt;DocumentTimeline&gt;(*m_timeline).animationsAreSuspended());
 274 
 275     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false,
 276     // and the synchronously notify flag set to false.
 277     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 278 
 279     invalidateEffect();
 280 }
 281 
 282 void WebAnimation::setTimelineInternal(RefPtr&lt;AnimationTimeline&gt;&amp;&amp; timeline)
 283 {
 284     if (m_timeline.get() == timeline)
 285         return;
 286 
 287     if (m_timeline)
 288         m_timeline-&gt;removeAnimation(*this);
 289 
 290     m_timeline = makeWeakPtr(timeline.get());
 291 
 292     if (m_effect)
 293         m_effect-&gt;animationTimelineDidChange(m_timeline.get());
 294 }
 295 
 296 void WebAnimation::effectTargetDidChange(Element* previousTarget, Element* newTarget)
 297 {
 298     if (m_timeline) {
 299         if (previousTarget)
 300             m_timeline-&gt;animationWasRemovedFromElement(*this, *previousTarget);
 301 
 302         if (newTarget)
 303             m_timeline-&gt;animationWasAddedToElement(*this, *newTarget);
 304 
 305         // This could have changed whether we have replaced animations, so we may need to schedule an update.
 306         m_timeline-&gt;animationTimingDidChange(*this);
 307     }
 308 
 309     InspectorInstrumentation::didChangeWebAnimationEffectTarget(*this);
 310 }
 311 
 312 Optional&lt;double&gt; WebAnimation::startTime() const
 313 {
 314     if (!m_startTime)
 315         return WTF::nullopt;
 316     return secondsToWebAnimationsAPITime(m_startTime.value());
 317 }
 318 
 319 void WebAnimation::setStartTime(Optional&lt;double&gt; startTime)
 320 {
 321     // 3.4.6 The procedure to set the start time of animation, animation, to new start time, is as follows:
 322     // https://drafts.csswg.org/web-animations/#setting-the-start-time-of-an-animation
 323 
 324     Optional&lt;Seconds&gt; newStartTime;
 325     if (!startTime)
 326         newStartTime = WTF::nullopt;
 327     else
 328         newStartTime = Seconds::fromMilliseconds(startTime.value());
 329 
 330     // 1. Let timeline time be the current time value of the timeline that animation is associated with. If
 331     //    there is no timeline associated with animation or the associated timeline is inactive, let the timeline
 332     //    time be unresolved.
 333     auto timelineTime = m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt;
 334 
 335     // 2. If timeline time is unresolved and new start time is resolved, make animation&#39;s hold time unresolved.
 336     if (!timelineTime &amp;&amp; newStartTime)
 337         m_holdTime = WTF::nullopt;
 338 
 339     // 3. Let previous current time be animation&#39;s current time.
 340     auto previousCurrentTime = currentTime();
 341 
 342     // 4. Apply any pending playback rate on animation.
 343     applyPendingPlaybackRate();
 344 
 345     // 5. Set animation&#39;s start time to new start time.
 346     m_startTime = newStartTime;
 347 
 348     // 6. Update animation&#39;s hold time based on the first matching condition from the following,
 349     if (newStartTime) {
 350         // If new start time is resolved,
 351         // If animation&#39;s playback rate is not zero, make animation&#39;s hold time unresolved.
 352         if (m_playbackRate)
 353             m_holdTime = WTF::nullopt;
 354     } else {
 355         // Otherwise (new start time is unresolved),
 356         // Set animation&#39;s hold time to previous current time even if previous current time is unresolved.
 357         m_holdTime = previousCurrentTime;
 358     }
 359 
 360     // 7. If animation has a pending play task or a pending pause task, cancel that task and resolve animation&#39;s current ready promise with animation.
 361     if (pending()) {
 362         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 363         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 364         m_readyPromise-&gt;resolve(*this);
 365     }
 366 
 367     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
 368     timingDidChange(DidSeek::Yes, SynchronouslyNotify::No);
 369 
 370     invalidateEffect();
 371 }
 372 
 373 Optional&lt;double&gt; WebAnimation::bindingsCurrentTime() const
 374 {
 375     auto time = currentTime();
 376     if (!time)
 377         return WTF::nullopt;
 378     return secondsToWebAnimationsAPITime(time.value());
 379 }
 380 
 381 ExceptionOr&lt;void&gt; WebAnimation::setBindingsCurrentTime(Optional&lt;double&gt; currentTime)
 382 {
 383     if (!currentTime)
 384         return setCurrentTime(WTF::nullopt);
 385     return setCurrentTime(Seconds::fromMilliseconds(currentTime.value()));
 386 }
 387 
 388 Optional&lt;Seconds&gt; WebAnimation::currentTime() const
 389 {
 390     return currentTime(RespectHoldTime::Yes);
 391 }
 392 
 393 Optional&lt;Seconds&gt; WebAnimation::currentTime(RespectHoldTime respectHoldTime) const
 394 {
 395     // 3.4.4. The current time of an animation
 396     // https://drafts.csswg.org/web-animations-1/#the-current-time-of-an-animation
 397 
 398     // The current time is calculated from the first matching condition from below:
 399 
 400     // If the animation&#39;s hold time is resolved, the current time is the animation&#39;s hold time.
 401     if (respectHoldTime == RespectHoldTime::Yes &amp;&amp; m_holdTime)
 402         return m_holdTime;
 403 
 404     // If any of the following are true:
 405     //     1. the animation has no associated timeline, or
 406     //     2. the associated timeline is inactive, or
 407     //     3. the animation&#39;s start time is unresolved.
 408     // The current time is an unresolved time value.
 409     if (!m_timeline || !m_timeline-&gt;currentTime() || !m_startTime)
 410         return WTF::nullopt;
 411 
 412     // Otherwise, current time = (timeline time - start time) * playback rate
 413     return (m_timeline-&gt;currentTime().value() - m_startTime.value()) * m_playbackRate;
 414 }
 415 
 416 ExceptionOr&lt;void&gt; WebAnimation::silentlySetCurrentTime(Optional&lt;Seconds&gt; seekTime)
 417 {
 418     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; silentlySetCurrentTime &quot; &lt;&lt; seekTime);
 419 
 420     // 3.4.5. Setting the current time of an animation
 421     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 422 
 423     // 1. If seek time is an unresolved time value, then perform the following steps.
 424     if (!seekTime) {
 425         // 1. If the current time is resolved, then throw a TypeError.
 426         if (currentTime())
 427             return Exception { TypeError };
 428         // 2. Abort these steps.
 429         return { };
 430     }
 431 
 432     // 2. Update either animation&#39;s hold time or start time as follows:
 433     // If any of the following conditions are true:
 434     //     - animation&#39;s hold time is resolved, or
 435     //     - animation&#39;s start time is unresolved, or
 436     //     - animation has no associated timeline or the associated timeline is inactive, or
 437     //     - animation&#39;s playback rate is 0,
 438     // Set animation&#39;s hold time to seek time.
 439     // Otherwise, set animation&#39;s start time to the result of evaluating timeline time - (seek time / playback rate)
 440     // where timeline time is the current time value of timeline associated with animation.
 441     if (m_holdTime || !m_startTime || !m_timeline || !m_timeline-&gt;currentTime() || !m_playbackRate)
 442         m_holdTime = seekTime;
 443     else
 444         m_startTime = m_timeline-&gt;currentTime().value() - (seekTime.value() / m_playbackRate);
 445 
 446     // 3. If animation has no associated timeline or the associated timeline is inactive, make animation&#39;s start time unresolved.
 447     if (!m_timeline || !m_timeline-&gt;currentTime())
 448         m_startTime = WTF::nullopt;
 449 
 450     // 4. Make animation&#39;s previous current time unresolved.
 451     m_previousCurrentTime = WTF::nullopt;
 452 
 453     return { };
 454 }
 455 
 456 ExceptionOr&lt;void&gt; WebAnimation::setCurrentTime(Optional&lt;Seconds&gt; seekTime)
 457 {
 458     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; setCurrentTime &quot; &lt;&lt; seekTime);
 459 
 460     // 3.4.5. Setting the current time of an animation
 461     // https://drafts.csswg.org/web-animations-1/#setting-the-current-time-of-an-animation
 462 
 463     // 1. Run the steps to silently set the current time of animation to seek time.
 464     auto silentResult = silentlySetCurrentTime(seekTime);
 465     if (silentResult.hasException())
 466         return silentResult.releaseException();
 467 
 468     // 2. If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:
 469     if (hasPendingPauseTask()) {
 470         // 1. Set animation&#39;s hold time to seek time.
 471         m_holdTime = seekTime;
 472         // 2. Apply any pending playback rate to animation.
 473         applyPendingPlaybackRate();
 474         // 3. Make animation&#39;s start time unresolved.
 475         m_startTime = WTF::nullopt;
 476         // 4. Cancel the pending pause task.
 477         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 478         // 5. Resolve animation&#39;s current ready promise with animation.
 479         m_readyPromise-&gt;resolve(*this);
 480     }
 481 
 482     // 3. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
 483     timingDidChange(DidSeek::Yes, SynchronouslyNotify::No);
 484 
 485     if (m_effect)
 486         m_effect-&gt;animationDidSeek();
 487 
 488     invalidateEffect();
 489 
 490     return { };
 491 }
 492 
 493 double WebAnimation::effectivePlaybackRate() const
 494 {
 495     // https://drafts.csswg.org/web-animations/#effective-playback-rate
 496     // The effective playback rate of an animation is its pending playback rate, if set, otherwise it is the animation&#39;s playback rate.
 497     return (m_pendingPlaybackRate ? m_pendingPlaybackRate.value() : m_playbackRate);
 498 }
 499 
 500 void WebAnimation::setPlaybackRate(double newPlaybackRate)
 501 {
 502     // 3.4.17.1. Updating the playback rate of an animation
 503     // https://drafts.csswg.org/web-animations-1/#updating-the-playback-rate-of-an-animation
 504 
 505     // 1. Clear any pending playback rate on animation.
 506     m_pendingPlaybackRate = WTF::nullopt;
 507 
 508     // 2. Let previous time be the value of the current time of animation before changing the playback rate.
 509     auto previousTime = currentTime();
 510 
 511     // 3. Set the playback rate to new playback rate.
 512     m_playbackRate = newPlaybackRate;
 513 
 514     // 4. If previous time is resolved, set the current time of animation to previous time.
 515     if (previousTime)
 516         setCurrentTime(previousTime);
 517 }
 518 
 519 void WebAnimation::updatePlaybackRate(double newPlaybackRate)
 520 {
 521     // https://drafts.csswg.org/web-animations/#seamlessly-update-the-playback-rate
 522 
 523     // The procedure to seamlessly update the playback rate an animation, animation, to new playback rate preserving its current time is as follows:
 524 
 525     // 1. Let previous play state be animation&#39;s play state.
 526     //    Note: It is necessary to record the play state before updating animation&#39;s effective playback rate since, in the following logic,
 527     //    we want to immediately apply the pending playback rate of animation if it is currently finished regardless of whether or not it will
 528     //    still be finished after we apply the pending playback rate.
 529     auto previousPlayState = playState();
 530 
 531     // 2. Let animation&#39;s pending playback rate be new playback rate.
 532     m_pendingPlaybackRate = newPlaybackRate;
 533 
 534     // 3. Perform the steps corresponding to the first matching condition from below:
 535     if (pending()) {
 536         // If animation has a pending play task or a pending pause task,
 537         // Abort these steps.
 538         // Note: The different types of pending tasks will apply the pending playback rate when they run so there is no further action required in this case.
 539         return;
 540     }
 541 
 542     if (previousPlayState == PlayState::Idle || previousPlayState == PlayState::Paused) {
 543         // If previous play state is idle or paused,
 544         // Apply any pending playback rate on animation.
 545         applyPendingPlaybackRate();
 546     } else if (previousPlayState == PlayState::Finished) {
 547         // If previous play state is finished,
 548         // 1. Let the unconstrained current time be the result of calculating the current time of animation substituting an unresolved time value for the hold time.
 549         auto unconstrainedCurrentTime = currentTime(RespectHoldTime::No);
 550         // 2. Let animation&#39;s start time be the result of evaluating the following expression:
 551         // timeline time - (unconstrained current time / pending playback rate)
 552         // Where timeline time is the current time value of the timeline associated with animation.
 553         // If pending playback rate is zero, let animation&#39;s start time be timeline time.
 554         auto newStartTime = m_timeline-&gt;currentTime().value();
 555         if (m_pendingPlaybackRate)
 556             newStartTime -= (unconstrainedCurrentTime.value() / m_pendingPlaybackRate.value());
 557         m_startTime = newStartTime;
 558         // 3. Apply any pending playback rate on animation.
 559         applyPendingPlaybackRate();
 560         // 4. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 561         timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 562 
 563         invalidateEffect();
 564     } else {
 565         // Otherwise,
 566         // Run the procedure to play an animation for animation with the auto-rewind flag set to false.
 567         play(AutoRewind::No);
 568     }
 569 }
 570 
 571 void WebAnimation::applyPendingPlaybackRate()
 572 {
 573     // https://drafts.csswg.org/web-animations/#apply-any-pending-playback-rate
 574 
 575     // 1. If animation does not have a pending playback rate, abort these steps.
 576     if (!m_pendingPlaybackRate)
 577         return;
 578 
 579     // 2. Set animation&#39;s playback rate to its pending playback rate.
 580     m_playbackRate = m_pendingPlaybackRate.value();
 581 
 582     // 3. Clear animation&#39;s pending playback rate.
 583     m_pendingPlaybackRate = WTF::nullopt;
 584 }
 585 
 586 auto WebAnimation::playState() const -&gt; PlayState
 587 {
 588     // 3.5.19 Play states
 589     // https://drafts.csswg.org/web-animations/#play-states
 590 
 591     // The play state of animation, animation, at a given moment is the state corresponding to the
 592     // first matching condition from the following:
 593 
 594     // The current time of animation is unresolved, and animation does not have either a pending
 595     // play task or a pending pause task,
 596     // → idle
 597     auto animationCurrentTime = currentTime();
 598     if (!animationCurrentTime &amp;&amp; !pending())
 599         return PlayState::Idle;
 600 
 601     // Animation has a pending pause task, or both the start time of animation is unresolved and it does not
 602     // have a pending play task,
 603     // → paused
 604     if (hasPendingPauseTask() || (!m_startTime &amp;&amp; !hasPendingPlayTask()))
 605         return PlayState::Paused;
 606 
 607     // For animation, current time is resolved and either of the following conditions are true:
 608     // animation&#39;s effective playback rate &gt; 0 and current time ≥ target effect end; or
 609     // animation&#39;s effective playback rate &lt; 0 and current time ≤ 0,
 610     // → finished
 611     if (animationCurrentTime &amp;&amp; ((effectivePlaybackRate() &gt; 0 &amp;&amp; (*animationCurrentTime + timeEpsilon) &gt;= effectEndTime()) || (effectivePlaybackRate() &lt; 0 &amp;&amp; (*animationCurrentTime - timeEpsilon) &lt;= 0_s)))
 612         return PlayState::Finished;
 613 
 614     // Otherwise → running
 615     return PlayState::Running;
 616 }
 617 
 618 Seconds WebAnimation::effectEndTime() const
 619 {
 620     // The target effect end of an animation is equal to the end time of the animation&#39;s target effect.
 621     // If the animation has no target effect, the target effect end is zero.
 622     return m_effect ? m_effect-&gt;endTime() : 0_s;
 623 }
 624 
 625 void WebAnimation::cancel()
 626 {
 627     cancel(Silently::No);
 628     invalidateEffect();
 629 }
 630 
 631 void WebAnimation::cancel(Silently silently)
 632 {
 633     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; cancel(silently &quot; &lt;&lt; (silently == Silently::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
 634 
 635     // 3.4.16. Canceling an animation
 636     // https://drafts.csswg.org/web-animations-1/#canceling-an-animation-section
 637     //
 638     // An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
 639     //
 640     // The procedure to cancel an animation for animation is as follows:
 641     //
 642     // 1. If animation&#39;s play state is not idle, perform the following steps:
 643     if (playState() != PlayState::Idle) {
 644         // 1. Run the procedure to reset an animation&#39;s pending tasks on animation.
 645         resetPendingTasks(silently);
 646 
 647         // 2. Reject the current finished promise with a DOMException named &quot;AbortError&quot;.
 648         if (silently == Silently::No &amp;&amp; !m_finishedPromise-&gt;isFulfilled())
 649             m_finishedPromise-&gt;reject(Exception { AbortError });
 650 
 651         // 3. Let current finished promise be a new (pending) Promise object.
 652         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 653 
 654         // 4. Create an AnimationPlaybackEvent, cancelEvent.
 655         // 5. Set cancelEvent&#39;s type attribute to cancel.
 656         // 6. Set cancelEvent&#39;s currentTime to null.
 657         // 7. Let timeline time be the current time of the timeline with which animation is associated. If animation is not associated with an
 658         //    active timeline, let timeline time be n unresolved time value.
 659         // 8. Set cancelEvent&#39;s timelineTime to timeline time. If timeline time is unresolved, set it to null.
 660         // 9. If animation has a document for timing, then append cancelEvent to its document for timing&#39;s pending animation event queue along
 661         //    with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 662         //    to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 663         //    scheduled event time is an unresolved time value.
 664         // Otherwise, queue a task to dispatch cancelEvent at animation. The task source for this task is the DOM manipulation task source.
 665         if (silently == Silently::No)
 666             enqueueAnimationPlaybackEvent(eventNames().cancelEvent, WTF::nullopt, m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 667     }
 668 
 669     // 2. Make animation&#39;s hold time unresolved.
 670     m_holdTime = WTF::nullopt;
 671 
 672     // 3. Make animation&#39;s start time unresolved.
 673     m_startTime = WTF::nullopt;
 674 
 675     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 676 
 677     invalidateEffect();
 678 
 679     if (m_effect)
 680         m_effect-&gt;animationWasCanceled();
 681 }
 682 
 683 void WebAnimation::willChangeRenderer()
 684 {
 685     if (is&lt;KeyframeEffect&gt;(m_effect))
 686         downcast&lt;KeyframeEffect&gt;(*m_effect).willChangeRenderer();
 687 }
 688 
 689 void WebAnimation::enqueueAnimationPlaybackEvent(const AtomString&amp; type, Optional&lt;Seconds&gt; currentTime, Optional&lt;Seconds&gt; timelineTime)
 690 {
 691     auto event = AnimationPlaybackEvent::create(type, currentTime, timelineTime, this);
 692     event-&gt;setTarget(this);
 693     enqueueAnimationEvent(WTFMove(event));
 694 }
 695 
 696 void WebAnimation::enqueueAnimationEvent(Ref&lt;AnimationEventBase&gt;&amp;&amp; event)
 697 {
 698     if (is&lt;DocumentTimeline&gt;(m_timeline.get())) {
 699         // If animation has a document for timing, then append event to its document for timing&#39;s pending animation event queue along
 700         // with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times
 701         // to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the
 702         // scheduled event time is an unresolved time value.
 703         m_hasScheduledEventsDuringTick = true;
 704         downcast&lt;DocumentTimeline&gt;(*m_timeline).enqueueAnimationEvent(WTFMove(event));
 705     } else {
 706         // Otherwise, queue a task to dispatch event at animation. The task source for this task is the DOM manipulation task source.
 707         queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, WTFMove(event));
 708     }
 709 }
 710 
 711 void WebAnimation::resetPendingTasks(Silently silently)
 712 {
 713     // The procedure to reset an animation&#39;s pending tasks for animation is as follows:
 714     // https://drafts.csswg.org/web-animations-1/#reset-an-animations-pending-tasks
 715     //
 716     // 1. If animation does not have a pending play task or a pending pause task, abort this procedure.
 717     if (!pending())
 718         return;
 719 
 720     // 2. If animation has a pending play task, cancel that task.
 721     if (hasPendingPlayTask())
 722         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 723 
 724     // 3. If animation has a pending pause task, cancel that task.
 725     if (hasPendingPauseTask())
 726         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 727 
 728     // 4. Apply any pending playback rate on animation.
 729     applyPendingPlaybackRate();
 730 
 731     // 5. Reject animation&#39;s current ready promise with a DOMException named &quot;AbortError&quot;.
 732     if (silently == Silently::No)
 733         m_readyPromise-&gt;reject(Exception { AbortError });
 734 
 735     // 6. Let animation&#39;s current ready promise be the result of creating a new resolved Promise object.
 736     m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 737     m_readyPromise-&gt;resolve(*this);
 738 }
 739 
 740 ExceptionOr&lt;void&gt; WebAnimation::finish()
 741 {
 742     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; finish (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
 743 
 744     // 3.4.15. Finishing an animation
 745     // https://drafts.csswg.org/web-animations-1/#finishing-an-animation-section
 746 
 747     // An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
 748     //
 749     // 1. If animation&#39;s effective playback rate is zero, or if animation&#39;s effective playback rate &gt; 0 and target effect end is infinity, throw an InvalidStateError and abort these steps.
 750     if (!effectivePlaybackRate() || (effectivePlaybackRate() &gt; 0 &amp;&amp; effectEndTime() == Seconds::infinity()))
 751         return Exception { InvalidStateError };
 752 
 753     // 2. Apply any pending playback rate to animation.
 754     applyPendingPlaybackRate();
 755 
 756     // 3. Set limit as follows:
 757     // If animation playback rate &gt; 0, let limit be target effect end.
 758     // Otherwise, let limit be zero.
 759     auto limit = m_playbackRate &gt; 0 ? effectEndTime() : 0_s;
 760 
 761     // 4. Silently set the current time to limit.
 762     silentlySetCurrentTime(limit);
 763 
 764     // 5. If animation&#39;s start time is unresolved and animation has an associated active timeline, let the start time be the result of
 765     //    evaluating timeline time - (limit / playback rate) where timeline time is the current time value of the associated timeline.
 766     if (!m_startTime &amp;&amp; m_timeline &amp;&amp; m_timeline-&gt;currentTime())
 767         m_startTime = m_timeline-&gt;currentTime().value() - (limit / m_playbackRate);
 768 
 769     // 6. If there is a pending pause task and start time is resolved,
 770     if (hasPendingPauseTask() &amp;&amp; m_startTime) {
 771         // 1. Let the hold time be unresolved.
 772         m_holdTime = WTF::nullopt;
 773         // 2. Cancel the pending pause task.
 774         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 775         // 3. Resolve the current ready promise of animation with animation.
 776         m_readyPromise-&gt;resolve(*this);
 777     }
 778 
 779     // 7. If there is a pending play task and start time is resolved, cancel that task and resolve the current ready promise of animation with animation.
 780     if (hasPendingPlayTask() &amp;&amp; m_startTime) {
 781         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 782         m_readyPromise-&gt;resolve(*this);
 783     }
 784 
 785     // 8. Run the procedure to update an animation&#39;s finished state animation with the did seek flag set to true, and the synchronously notify flag set to true.
 786     timingDidChange(DidSeek::Yes, SynchronouslyNotify::Yes);
 787 
 788     invalidateEffect();
 789 
 790     return { };
 791 }
 792 
 793 void WebAnimation::timingDidChange(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify, Silently silently)
 794 {
 795     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
 796     updateFinishedState(didSeek, synchronouslyNotify);
 797 
 798     if (is&lt;KeyframeEffect&gt;(m_effect)) {
 799         updateRelevance();
 800         downcast&lt;KeyframeEffect&gt;(*m_effect).animationTimingDidChange();
 801     }
 802 
 803     if (silently == Silently::No &amp;&amp; m_timeline)
 804         m_timeline-&gt;animationTimingDidChange(*this);
 805 };
 806 
 807 void WebAnimation::invalidateEffect()
 808 {
 809     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)
 810         m_effect-&gt;invalidate();
 811 }
 812 
 813 void WebAnimation::updateFinishedState(DidSeek didSeek, SynchronouslyNotify synchronouslyNotify)
 814 {
 815     // 3.4.14. Updating the finished state
 816     // https://drafts.csswg.org/web-animations-1/#updating-the-finished-state
 817 
 818     // 1. Let the unconstrained current time be the result of calculating the current time substituting an unresolved time value
 819     // for the hold time if did seek is false. If did seek is true, the unconstrained current time is equal to the current time.
 820     auto unconstrainedCurrentTime = currentTime(didSeek == DidSeek::Yes ? RespectHoldTime::Yes : RespectHoldTime::No);
 821     auto endTime = effectEndTime();
 822 
 823     // 2. If all three of the following conditions are true,
 824     //    - the unconstrained current time is resolved, and
 825     //    - animation&#39;s start time is resolved, and
 826     //    - animation does not have a pending play task or a pending pause task,
 827     if (unconstrainedCurrentTime &amp;&amp; m_startTime &amp;&amp; !pending()) {
 828         // then update animation&#39;s hold time based on the first matching condition for animation from below, if any:
 829         if (m_playbackRate &gt; 0 &amp;&amp; unconstrainedCurrentTime &gt;= endTime) {
 830             // If animation playback rate &gt; 0 and unconstrained current time is greater than or equal to target effect end,
 831             // If did seek is true, let the hold time be the value of unconstrained current time.
 832             if (didSeek == DidSeek::Yes)
 833                 m_holdTime = unconstrainedCurrentTime;
 834             // If did seek is false, let the hold time be the maximum value of previous current time and target effect end. If the previous current time is unresolved, let the hold time be target effect end.
 835             else if (!m_previousCurrentTime)
 836                 m_holdTime = endTime;
 837             else
 838                 m_holdTime = std::max(m_previousCurrentTime.value(), endTime);
 839         } else if (m_playbackRate &lt; 0 &amp;&amp; unconstrainedCurrentTime &lt;= 0_s) {
 840             // If animation playback rate &lt; 0 and unconstrained current time is less than or equal to 0,
 841             // If did seek is true, let the hold time be the value of unconstrained current time.
 842             if (didSeek == DidSeek::Yes)
 843                 m_holdTime = unconstrainedCurrentTime;
 844             // If did seek is false, let the hold time be the minimum value of previous current time and zero. If the previous current time is unresolved, let the hold time be zero.
 845             else if (!m_previousCurrentTime)
 846                 m_holdTime = 0_s;
 847             else
 848                 m_holdTime = std::min(m_previousCurrentTime.value(), 0_s);
 849         } else if (m_playbackRate &amp;&amp; m_timeline &amp;&amp; m_timeline-&gt;currentTime()) {
 850             // If animation playback rate ≠ 0, and animation is associated with an active timeline,
 851             // Perform the following steps:
 852             // 1. If did seek is true and the hold time is resolved, let animation&#39;s start time be equal to the result of evaluating timeline time - (hold time / playback rate)
 853             //    where timeline time is the current time value of timeline associated with animation.
 854             if (didSeek == DidSeek::Yes &amp;&amp; m_holdTime)
 855                 m_startTime = m_timeline-&gt;currentTime().value() - (m_holdTime.value() / m_playbackRate);
 856             // 2. Let the hold time be unresolved.
 857             m_holdTime = WTF::nullopt;
 858         }
 859     }
 860 
 861     // 3. Set the previous current time of animation be the result of calculating its current time.
 862     m_previousCurrentTime = currentTime();
 863 
 864     // 4. Let current finished state be true if the play state of animation is finished. Otherwise, let it be false.
 865     auto currentFinishedState = playState() == PlayState::Finished;
 866 
 867     // 5. If current finished state is true and the current finished promise is not yet resolved, perform the following steps:
 868     if (currentFinishedState &amp;&amp; !m_finishedPromise-&gt;isFulfilled()) {
 869         if (synchronouslyNotify == SynchronouslyNotify::Yes) {
 870             // If synchronously notify is true, cancel any queued microtask to run the finish notification steps for this animation,
 871             // and run the finish notification steps immediately.
 872             m_finishNotificationStepsMicrotaskPending = false;
 873             finishNotificationSteps();
 874         } else if (!m_finishNotificationStepsMicrotaskPending) {
 875             // Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there
 876             // is already a microtask queued to run those steps for animation.
 877             m_finishNotificationStepsMicrotaskPending = true;
 878             if (auto* context = scriptExecutionContext()) {
 879                 context-&gt;eventLoop().queueMicrotask([this, protectedThis = makeRef(*this)] {
 880                     if (m_finishNotificationStepsMicrotaskPending) {
 881                         m_finishNotificationStepsMicrotaskPending = false;
 882                         finishNotificationSteps();
 883                     }
 884                 });
 885             }
 886         }
 887     }
 888 
 889     // 6. If current finished state is false and animation&#39;s current finished promise is already resolved, set animation&#39;s current
 890     // finished promise to a new (pending) Promise object.
 891     if (!currentFinishedState &amp;&amp; m_finishedPromise-&gt;isFulfilled())
 892         m_finishedPromise = makeUniqueRef&lt;FinishedPromise&gt;(*this, &amp;WebAnimation::finishedPromiseResolve);
 893 
 894     updateRelevance();
 895 }
 896 
 897 void WebAnimation::finishNotificationSteps()
 898 {
 899     // 3.4.14. Updating the finished state
 900     // https://drafts.csswg.org/web-animations-1/#finish-notification-steps
 901 
 902     // Let finish notification steps refer to the following procedure:
 903     // 1. If animation&#39;s play state is not equal to finished, abort these steps.
 904     if (playState() != PlayState::Finished)
 905         return;
 906 
 907     // 2. Resolve animation&#39;s current finished promise object with animation.
 908     m_finishedPromise-&gt;resolve(*this);
 909 
 910     // 3. Create an AnimationPlaybackEvent, finishEvent.
 911     // 4. Set finishEvent&#39;s type attribute to finish.
 912     // 5. Set finishEvent&#39;s currentTime attribute to the current time of animation.
 913     // 6. Set finishEvent&#39;s timelineTime attribute to the current time of the timeline with which animation is associated.
 914     //    If animation is not associated with a timeline, or the timeline is inactive, let timelineTime be null.
 915     // 7. If animation has a document for timing, then append finishEvent to its document for timing&#39;s pending animation event
 916     //    queue along with its target, animation. For the scheduled event time, use the result of converting animation&#39;s target
 917     //    effect end to an origin-relative time.
 918     //    Otherwise, queue a task to dispatch finishEvent at animation. The task source for this task is the DOM manipulation task source.
 919     enqueueAnimationPlaybackEvent(eventNames().finishEvent, currentTime(), m_timeline ? m_timeline-&gt;currentTime() : WTF::nullopt);
 920 }
 921 
 922 ExceptionOr&lt;void&gt; WebAnimation::play()
 923 {
 924     return play(AutoRewind::Yes);
 925 }
 926 
 927 ExceptionOr&lt;void&gt; WebAnimation::play(AutoRewind autoRewind)
 928 {
 929     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; play(autoRewind &quot; &lt;&lt; (autoRewind == AutoRewind::Yes) &lt;&lt; &quot;) (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
 930 
 931     // 3.4.10. Playing an animation
 932     // https://drafts.csswg.org/web-animations-1/#play-an-animation
 933 
 934     auto localTime = currentTime();
 935     auto endTime = effectEndTime();
 936 
 937     // 1. Let aborted pause be a boolean flag that is true if animation has a pending pause task, and false otherwise.
 938     bool abortedPause = hasPendingPauseTask();
 939 
 940     // 2. Let has pending ready promise be a boolean flag that is initially false.
 941     bool hasPendingReadyPromise = false;
 942 
 943     // 3. Perform the steps corresponding to the first matching condition from the following, if any:
 944     if (effectivePlaybackRate() &gt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt; 0_s || localTime.value() &gt;= endTime)) {
 945         // If animation&#39;s effective playback rate &gt; 0, the auto-rewind flag is true and either animation&#39;s:
 946         //     - current time is unresolved, or
 947         //     - current time &lt; zero, or
 948         //     - current time ≥ target effect end,
 949         // Set animation&#39;s hold time to zero.
 950         m_holdTime = 0_s;
 951     } else if (effectivePlaybackRate() &lt; 0 &amp;&amp; autoRewind == AutoRewind::Yes &amp;&amp; (!localTime || localTime.value() &lt;= 0_s || localTime.value() &gt; endTime)) {
 952         // If animation&#39;s effective playback rate &lt; 0, the auto-rewind flag is true and either animation&#39;s:
 953         //     - current time is unresolved, or
 954         //     - current time ≤ zero, or
 955         //     - current time &gt; target effect end
 956         // If target effect end is positive infinity, throw an InvalidStateError and abort these steps.
 957         if (endTime == Seconds::infinity())
 958             return Exception { InvalidStateError };
 959         m_holdTime = endTime;
 960     } else if (!effectivePlaybackRate() &amp;&amp; !localTime) {
 961         // If animation&#39;s effective playback rate = 0 and animation&#39;s current time is unresolved,
 962         // Set animation&#39;s hold time to zero.
 963         m_holdTime = 0_s;
 964     }
 965 
 966     // 4. If animation has a pending play task or a pending pause task,
 967     if (pending()) {
 968         // 1. Cancel that task.
 969         m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
 970         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
 971         // 2. Set has pending ready promise to true.
 972         hasPendingReadyPromise = true;
 973     }
 974 
 975     // 5. If the following three conditions are all satisfied:
 976     //    - animation&#39;s hold time is unresolved, and
 977     //    - aborted pause is false, and
 978     //    - animation does not have a pending playback rate,
 979     // abort this procedure.
 980     if (!m_holdTime &amp;&amp; !abortedPause &amp;&amp; !m_pendingPlaybackRate)
 981         return { };
 982 
 983     // 6. If animation&#39;s hold time is resolved, let its start time be unresolved.
 984     if (m_holdTime)
 985         m_startTime = WTF::nullopt;
 986 
 987     // 7. If has pending ready promise is false, let animation&#39;s current ready promise be a new (pending) Promise object.
 988     if (!hasPendingReadyPromise)
 989         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
 990 
 991     // 8. Schedule a task to run as soon as animation is ready.
 992     m_timeToRunPendingPlayTask = TimeToRunPendingTask::WhenReady;
 993 
 994     // 9. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
 995     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
 996 
 997     invalidateEffect();
 998 
 999     if (m_effect)
1000         m_effect-&gt;animationDidPlay();
1001 
1002     return { };
1003 }
1004 
1005 void WebAnimation::runPendingPlayTask()
1006 {
1007     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPlayTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
1008 
1009     // 3.4.10. Playing an animation, step 8.
1010     // https://drafts.csswg.org/web-animations-1/#play-an-animation
1011 
1012     m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
1013 
1014     // 1. Assert that at least one of animation&#39;s start time or hold time is resolved.
1015     ASSERT(m_startTime || m_holdTime);
1016 
1017     // 2. Let ready time be the time value of the timeline associated with animation at the moment when animation became ready.
1018     auto readyTime = m_timeline-&gt;currentTime();
1019 
1020     // 3. Perform the steps corresponding to the first matching condition below, if any:
1021     if (m_holdTime) {
1022         // If animation&#39;s hold time is resolved,
1023         // 1. Apply any pending playback rate on animation.
1024         applyPendingPlaybackRate();
1025         // 2. Let new start time be the result of evaluating ready time - hold time / animation playback rate for animation.
1026         // If the animation playback rate is zero, let new start time be simply ready time.
1027         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1028         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
1029         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
1030         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
1031         auto newStartTime = readyTime.valueOr(0_s);
1032         if (m_playbackRate)
1033             newStartTime -= m_holdTime.value() / m_playbackRate;
1034         // 3. Set the start time of animation to new start time.
1035         m_startTime = newStartTime;
1036         // 4. If animation&#39;s playback rate is not 0, make animation&#39;s hold time unresolved.
1037         if (m_playbackRate)
1038             m_holdTime = WTF::nullopt;
1039     } else if (m_startTime &amp;&amp; m_pendingPlaybackRate) {
1040         // If animation&#39;s start time is resolved and animation has a pending playback rate,
1041         // 1. Let current time to match be the result of evaluating (ready time - start time) × playback rate for animation.
1042         auto currentTimeToMatch = (readyTime.valueOr(0_s) - m_startTime.value()) * m_playbackRate;
1043         // 2. Apply any pending playback rate on animation.
1044         applyPendingPlaybackRate();
1045         // 3. If animation&#39;s playback rate is zero, let animation&#39;s hold time be current time to match.
1046         if (m_playbackRate)
1047             m_holdTime = currentTimeToMatch;
1048         // 4. Let new start time be the result of evaluating ready time - current time to match / playback rate for animation.
1049         // If the playback rate is zero, let new start time be simply ready time.
1050         auto newStartTime = readyTime.valueOr(0_s);
1051         if (m_playbackRate)
1052             newStartTime -= currentTimeToMatch / m_playbackRate;
1053         // 5. Set the start time of animation to new start time.
1054         m_startTime = newStartTime;
1055     }
1056 
1057     // 4. Resolve animation&#39;s current ready promise with animation.
1058     if (!m_readyPromise-&gt;isFulfilled())
1059         m_readyPromise-&gt;resolve(*this);
1060 
1061     // 5. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
1062     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);
1063 
1064     invalidateEffect();
1065 }
1066 
1067 ExceptionOr&lt;void&gt; WebAnimation::pause()
1068 {
1069     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; pause (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
1070 
1071     // 3.4.11. Pausing an animation
1072     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1073 
1074     // 1. If animation has a pending pause task, abort these steps.
1075     if (hasPendingPauseTask())
1076         return { };
1077 
1078     // 2. If the play state of animation is paused, abort these steps.
1079     if (playState() == PlayState::Paused)
1080         return { };
1081 
1082     auto localTime = currentTime();
1083 
1084     // 3. If the animation&#39;s current time is unresolved, perform the steps according to the first matching condition from below:
1085     if (!localTime) {
1086         if (m_playbackRate &gt;= 0) {
1087             // If animation&#39;s playback rate is ≥ 0, let animation&#39;s hold time be zero.
1088             m_holdTime = 0_s;
1089         } else if (effectEndTime() == Seconds::infinity()) {
1090             // Otherwise, if target effect end for animation is positive infinity, throw an InvalidStateError and abort these steps.
1091             return Exception { InvalidStateError };
1092         } else {
1093             // Otherwise, let animation&#39;s hold time be target effect end.
1094             m_holdTime = effectEndTime();
1095         }
1096     }
1097 
1098     // 4. Let has pending ready promise be a boolean flag that is initially false.
1099     bool hasPendingReadyPromise = false;
1100 
1101     // 5. If animation has a pending play task, cancel that task and let has pending ready promise be true.
1102     if (hasPendingPlayTask()) {
1103         m_timeToRunPendingPlayTask = TimeToRunPendingTask::NotScheduled;
1104         hasPendingReadyPromise = true;
1105     }
1106 
1107     // 6. If has pending ready promise is false, set animation&#39;s current ready promise to a new (pending) Promise object.
1108     if (!hasPendingReadyPromise)
1109         m_readyPromise = makeUniqueRef&lt;ReadyPromise&gt;(*this, &amp;WebAnimation::readyPromiseResolve);
1110 
1111     // 7. Schedule a task to be executed at the first possible moment after the user agent has performed any processing necessary
1112     //    to suspend the playback of animation&#39;s target effect, if any.
1113     m_timeToRunPendingPauseTask = TimeToRunPendingTask::ASAP;
1114 
1115     // 8. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
1116     timingDidChange(DidSeek::No, SynchronouslyNotify::No);
1117 
1118     invalidateEffect();
1119 
1120     return { };
1121 }
1122 
1123 ExceptionOr&lt;void&gt; WebAnimation::reverse()
1124 {
1125     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; reverse (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
1126 
1127     // 3.4.18. Reversing an animation
1128     // https://drafts.csswg.org/web-animations-1/#reverse-an-animation
1129 
1130     // The procedure to reverse an animation of animation animation is as follows:
1131 
1132     // 1. If there is no timeline associated with animation, or the associated timeline is inactive
1133     //    throw an InvalidStateError and abort these steps.
1134     if (!m_timeline || !m_timeline-&gt;currentTime())
1135         return Exception { InvalidStateError };
1136 
1137     // 2. Let original pending playback rate be animation&#39;s pending playback rate.
1138     auto originalPendingPlaybackRate = m_pendingPlaybackRate;
1139 
1140     // 3. Let animation&#39;s pending playback rate be the additive inverse of its effective playback rate (i.e. -effective playback rate).
1141     m_pendingPlaybackRate = -effectivePlaybackRate();
1142 
1143     // 4. Run the steps to play an animation for animation with the auto-rewind flag set to true.
1144     auto playResult = play(AutoRewind::Yes);
1145 
1146     // If the steps to play an animation throw an exception, set animation&#39;s pending playback rate to original
1147     // pending playback rate and propagate the exception.
1148     if (playResult.hasException()) {
1149         m_pendingPlaybackRate = originalPendingPlaybackRate;
1150         return playResult.releaseException();
1151     }
1152 
1153     return { };
1154 }
1155 
1156 void WebAnimation::runPendingPauseTask()
1157 {
1158     LOG_WITH_STREAM(Animations, stream &lt;&lt; &quot;WebAnimation &quot; &lt;&lt; this &lt;&lt; &quot; runPendingPauseTask (current time is &quot; &lt;&lt; currentTime() &lt;&lt; &quot;)&quot;);
1159 
1160     // 3.4.11. Pausing an animation, step 7.
1161     // https://drafts.csswg.org/web-animations-1/#pause-an-animation
1162 
1163     m_timeToRunPendingPauseTask = TimeToRunPendingTask::NotScheduled;
1164 
1165     // 1. Let ready time be the time value of the timeline associated with animation at the moment when the user agent
1166     //    completed processing necessary to suspend playback of animation&#39;s target effect.
1167     auto readyTime = m_timeline-&gt;currentTime();
1168     auto animationStartTime = m_startTime;
1169 
1170     // 2. If animation&#39;s start time is resolved and its hold time is not resolved, let animation&#39;s hold time be the result of
1171     //    evaluating (ready time - start time) × playback rate.
1172     //    Note: The hold time might be already set if the animation is finished, or if the animation is pending, waiting to begin
1173     //    playback. In either case we want to preserve the hold time as we enter the paused state.
1174     if (animationStartTime &amp;&amp; !m_holdTime) {
1175         // FIXME: Implementation cannot guarantee an active timeline at the point of this async dispatch.
1176         // Subsequently, the resulting readyTime value can be null. Unify behavior between C++17 and
1177         // C++14 builds (the latter using WTF&#39;s Optional) and avoid null Optional dereferencing
1178         // by defaulting to a Seconds(0) value. See https://bugs.webkit.org/show_bug.cgi?id=186189.
1179         m_holdTime = (readyTime.valueOr(0_s) - animationStartTime.value()) * m_playbackRate;
1180     }
1181 
1182     // 3. Apply any pending playback rate on animation.
1183     applyPendingPlaybackRate();
1184 
1185     // 4. Make animation&#39;s start time unresolved.
1186     m_startTime = WTF::nullopt;
1187 
1188     // 5. Resolve animation&#39;s current ready promise with animation.
1189     if (!m_readyPromise-&gt;isFulfilled())
1190         m_readyPromise-&gt;resolve(*this);
1191 
1192     // 6. Run the procedure to update an animation&#39;s finished state for animation with the did seek flag set to false, and the
1193     //    synchronously notify flag set to false.
1194     timingDidChange(DidSeek::No, SynchronouslyNotify::No, Silently::Yes);
1195 
1196     invalidateEffect();
1197 }
1198 
1199 bool WebAnimation::isRunningAccelerated() const
1200 {
1201     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isRunningAccelerated();
1202 }
1203 
1204 bool WebAnimation::isCompletelyAccelerated() const
1205 {
1206     return is&lt;KeyframeEffect&gt;(m_effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(*m_effect).isCompletelyAccelerated();
1207 }
1208 
1209 bool WebAnimation::needsTick() const
1210 {
1211     return pending() || playState() == PlayState::Running || m_hasScheduledEventsDuringTick;
1212 }
1213 
1214 void WebAnimation::tick()
1215 {
1216     m_hasScheduledEventsDuringTick = false;
1217     updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1218     m_shouldSkipUpdatingFinishedStateWhenResolving = true;
1219 
1220     // Run pending tasks, if any.
1221     if (hasPendingPauseTask())
1222         runPendingPauseTask();
1223     if (hasPendingPlayTask())
1224         runPendingPlayTask();
1225 
1226     if (!isEffectInvalidationSuspended() &amp;&amp; m_effect)
1227         m_effect-&gt;animationDidTick();
1228 }
1229 
1230 void WebAnimation::resolve(RenderStyle&amp; targetStyle)
1231 {
1232     if (!m_shouldSkipUpdatingFinishedStateWhenResolving)
1233         updateFinishedState(DidSeek::No, SynchronouslyNotify::Yes);
1234     m_shouldSkipUpdatingFinishedStateWhenResolving = false;
1235 
1236     if (m_effect)
1237         m_effect-&gt;apply(targetStyle);
1238 }
1239 
1240 void WebAnimation::setSuspended(bool isSuspended)
1241 {
1242     if (m_isSuspended == isSuspended)
1243         return;
1244 
1245     m_isSuspended = isSuspended;
1246 
1247     if (m_effect &amp;&amp; playState() == PlayState::Running)
1248         m_effect-&gt;animationSuspensionStateDidChange(isSuspended);
1249 }
1250 
1251 void WebAnimation::acceleratedStateDidChange()
1252 {
1253     if (is&lt;DocumentTimeline&gt;(m_timeline.get()))
1254         downcast&lt;DocumentTimeline&gt;(*m_timeline).animationAcceleratedRunningStateDidChange(*this);
1255 }
1256 
1257 void WebAnimation::applyPendingAcceleratedActions()
1258 {
1259     if (is&lt;KeyframeEffect&gt;(m_effect))
1260         downcast&lt;KeyframeEffect&gt;(*m_effect).applyPendingAcceleratedActions();
1261 }
1262 
1263 WebAnimation&amp; WebAnimation::readyPromiseResolve()
1264 {
1265     return *this;
1266 }
1267 
1268 WebAnimation&amp; WebAnimation::finishedPromiseResolve()
1269 {
1270     return *this;
1271 }
1272 
1273 const char* WebAnimation::activeDOMObjectName() const
1274 {
1275     return &quot;Animation&quot;;
1276 }
1277 
1278 void WebAnimation::suspend(ReasonForSuspension)
1279 {
1280     setSuspended(true);
1281 }
1282 
1283 void WebAnimation::resume()
1284 {
1285     setSuspended(false);
1286 }
1287 
1288 void WebAnimation::stop()
1289 {
1290     ActiveDOMObject::stop();
1291     removeAllEventListeners();
1292 }
1293 
1294 bool WebAnimation::hasPendingActivity() const
1295 {
1296     // Keep the JS wrapper alive if the animation is considered relevant or could become relevant again by virtue of having a timeline.
1297     return m_timeline || m_isRelevant || ActiveDOMObject::hasPendingActivity();
1298 }
1299 
1300 void WebAnimation::updateRelevance()
1301 {
1302     m_isRelevant = computeRelevance();
1303 }
1304 
1305 bool WebAnimation::computeRelevance()
1306 {
1307     // To be listed in getAnimations() an animation needs a target effect which is current or in effect.
1308     if (!m_effect)
1309         return false;
1310 
1311     if (m_replaceState == ReplaceState::Removed)
1312         return false;
1313 
1314     auto timing = m_effect-&gt;getBasicTiming();
1315 
1316     // An animation effect is in effect if its active time is not unresolved.
1317     if (timing.activeTime)
1318         return true;
1319 
1320     // An animation effect is current if either of the following conditions is true:
1321     // - the animation effect is in the before phase, or
1322     // - the animation effect is in play.
1323 
1324     // An animation effect is in play if all of the following conditions are met:
1325     // - the animation effect is in the active phase, and
1326     // - the animation effect is associated with an animation that is not finished.
1327     return timing.phase == AnimationEffectPhase::Before || (timing.phase == AnimationEffectPhase::Active &amp;&amp; playState() != PlayState::Finished);
1328 }
1329 
1330 bool WebAnimation::isReplaceable() const
1331 {
1332     // An animation is replaceable if all of the following conditions are true:
1333     // https://drafts.csswg.org/web-animations/#removing-replaced-animations
1334 
1335     // The existence of the animation is not prescribed by markup. That is, it is not a CSS animation with an owning element,
1336     // nor a CSS transition with an owning element.
1337     if (isDeclarativeAnimation() &amp;&amp; downcast&lt;DeclarativeAnimation&gt;(this)-&gt;owningElement())
1338         return false;
1339 
1340     // The animation&#39;s play state is finished.
1341     if (playState() != PlayState::Finished)
1342         return false;
1343 
1344     // The animation&#39;s replace state is not removed.
1345     if (m_replaceState == ReplaceState::Removed)
1346         return false;
1347 
1348     // The animation is associated with a monotonically increasing timeline.
1349     if (!m_timeline)
1350         return false;
1351 
1352     // The animation has an associated target effect.
1353     if (!m_effect)
1354         return false;
1355 
1356     // The target effect associated with the animation is in effect.
1357     if (!m_effect-&gt;getBasicTiming().activeTime)
1358         return false;
1359 
1360     // The target effect has an associated target element.
1361     if (!is&lt;KeyframeEffect&gt;(m_effect) || !downcast&lt;KeyframeEffect&gt;(m_effect.get())-&gt;target())
1362         return false;
1363 
1364     return true;
1365 }
1366 
1367 void WebAnimation::persist()
1368 {
1369     auto previousReplaceState = std::exchange(m_replaceState, ReplaceState::Persisted);
1370 
1371     if (previousReplaceState == ReplaceState::Removed &amp;&amp; m_timeline) {
1372         if (is&lt;KeyframeEffect&gt;(m_effect)) {
1373             auto&amp; keyframeEffect = downcast&lt;KeyframeEffect&gt;(*m_effect);
1374             auto&amp; target = *keyframeEffect.target();
1375             m_timeline-&gt;animationWasAddedToElement(*this, target);
1376             target.ensureKeyframeEffectStack().addEffect(keyframeEffect);
1377         }
1378     }
1379 }
1380 
1381 ExceptionOr&lt;void&gt; WebAnimation::commitStyles()
1382 {
1383     // https://drafts.csswg.org/web-animations-1/#commit-computed-styles
1384 
1385     // 1. Let targets be the set of all effect targets for animation effects associated with animation.
1386     auto* effect = is&lt;KeyframeEffect&gt;(m_effect) ? downcast&lt;KeyframeEffect&gt;(m_effect.get()) : nullptr;
1387     auto* target = effect ? effect-&gt;target() : nullptr;
1388 
1389     // 2. For each target in targets:
1390     //
1391     // 2.1 If target is not an element capable of having a style attribute (for example, it is a pseudo-element or is an element in a
1392     // document format for which style attributes are not defined) throw a &quot;NoModificationAllowedError&quot; DOMException and abort these steps.
1393     if (!is&lt;StyledElement&gt;(target))
1394         return Exception { NoModificationAllowedError };
1395 
1396     auto&amp; styledElement = downcast&lt;StyledElement&gt;(*target);
1397 
1398     // 2.2 If, after applying any pending style changes, target is not being rendered, throw an &quot;InvalidStateError&quot; DOMException and abort these steps.
1399     styledElement.document().updateStyleIfNeeded();
1400     auto* renderer = styledElement.renderer();
1401     if (!renderer)
1402         return Exception { InvalidStateError };
1403 
1404     // 2.3 Let inline style be the result of getting the CSS declaration block corresponding to target’s style attribute. If target does not have a style
1405     // attribute, let inline style be a new empty CSS declaration block with the readonly flag unset and owner node set to target.
1406 
1407     // 2.4 Let targeted properties be the set of physical longhand properties that are a target property for at least one animation effect associated with
1408     // animation whose effect target is target.
1409 
1410     auto&amp; style = renderer-&gt;style();
1411     auto computedStyleExtractor = ComputedStyleExtractor(&amp;styledElement);
1412     auto inlineStyle = styledElement.document().createCSSStyleDeclaration();
1413     inlineStyle-&gt;setCssText(styledElement.getAttribute(&quot;style&quot;));
1414 
1415     auto&amp; keyframeStack = styledElement.ensureKeyframeEffectStack();
1416     auto* cssAnimationList = keyframeStack.cssAnimationList();
1417 
1418     // 2.5 For each property, property, in targeted properties:
1419     for (auto property : effect-&gt;animatedProperties()) {
1420         // 1. Let partialEffectStack be a copy of the effect stack for property on target.
1421         // 2. If animation&#39;s replace state is removed, add all animation effects associated with animation whose effect target is target and which include
1422         // property as a target property to partialEffectStack.
1423         // 3. Remove from partialEffectStack any animation effects whose associated animation has a higher composite order than animation.
1424         // 4. Let effect value be the result of calculating the result of partialEffectStack for property using target&#39;s computed style (see § 5.4.3 Calculating
1425         // the result of an effect stack).
1426         // 5. Set a CSS declaration property for effect value in inline style.
1427         // 6. Update style attribute for inline style.
1428 
1429         // We actually perform those steps in a different way: instead of building a copy of the effect stack and then removing stuff, we iterate through the
1430         // effect stack and stop when we&#39;ve found this animation&#39;s effect or when we&#39;ve found an effect associated with an animation with a higher composite order.
1431         auto animatedStyle = RenderStyle::clonePtr(style);
1432         for (const auto&amp; effectInStack : keyframeStack.sortedEffects()) {
1433             if (effectInStack-&gt;animation() != this &amp;&amp; !compareAnimationsByCompositeOrder(*effectInStack-&gt;animation(), *this, cssAnimationList))
1434                 break;
1435             if (effectInStack-&gt;animatedProperties().contains(property))
1436                 effectInStack-&gt;animation()-&gt;resolve(*animatedStyle);
1437             if (effectInStack-&gt;animation() == this)
1438                 break;
1439         }
1440         if (m_replaceState == ReplaceState::Removed)
1441             effect-&gt;animation()-&gt;resolve(*animatedStyle);
1442         if (auto cssValue = computedStyleExtractor.valueForPropertyInStyle(*animatedStyle, property, renderer))
1443             inlineStyle-&gt;setPropertyInternal(property, cssValue-&gt;cssText(), false);
1444     }
1445 
1446     styledElement.setAttribute(&quot;style&quot;, inlineStyle-&gt;cssText());
1447 
1448     return { };
1449 }
1450 
1451 Seconds WebAnimation::timeToNextTick() const
1452 {
1453     ASSERT(effect());
1454 
1455     if (pending())
1456         return 0_s;
1457 
1458     // If we&#39;re not running, or time is not advancing for this animation, there&#39;s no telling when we&#39;ll end.
1459     auto playbackRate = effectivePlaybackRate();
1460     if (playState() != PlayState::Running || !playbackRate)
1461         return Seconds::infinity();
1462 
1463     auto&amp; effect = *this-&gt;effect();
1464     auto timing = effect.getBasicTiming();
1465     switch (timing.phase) {
1466     case AnimationEffectPhase::Before:
1467         // The animation is in its &quot;before&quot; phase, in this case we can wait until it enters its &quot;active&quot; phase.
1468         return (effect.delay() - timing.localTime.value()) / playbackRate;
1469     case AnimationEffectPhase::Active:
1470         if (isCompletelyAccelerated() &amp;&amp; isRunningAccelerated()) {
1471             // Fully-accelerated running CSS Animations need to trigger &quot;animationiteration&quot; events, in this case we must wait until the next iteration.
1472             if (isCSSAnimation()) {
1473                 if (auto iterationProgress = effect.getComputedTiming().simpleIterationProgress)
1474                     return effect.iterationDuration() * (1 - *iterationProgress);
1475             }
1476             // Fully-accelerated running animations in the &quot;active&quot; phase can wait until they ended.
1477             return (effect.endTime() - timing.localTime.value()) / playbackRate;
1478         }
1479         // Other animations in the &quot;active&quot; phase will need to update their animated value at the immediate next opportunity.
1480         return 0_s;
1481     case AnimationEffectPhase::After:
1482         // The animation is in its after phase, which means it will no longer update its value, so it doens&#39;t need a tick.
1483         return Seconds::infinity();
1484     case AnimationEffectPhase::Idle:
1485         ASSERT_NOT_REACHED();
1486         return Seconds::infinity();
1487     }
1488 
1489     ASSERT_NOT_REACHED();
1490     return Seconds::infinity();
1491 }
1492 
1493 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARM64Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../Sources.txt.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARM64Registers.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARM64Assembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1492,12 +1492,15 @@</span>
      ALWAYS_INLINE void nop()
      {
          insn(nopPseudo());
      }
  
<span class="udiff-line-modified-removed">-     template &lt;typename CopyFunction&gt;</span>
<span class="udiff-line-modified-removed">-     static void fillNops(void* base, size_t size, CopyFunction copy)</span>
<span class="udiff-line-modified-added">+     enum BranchTargetType { DirectBranch, IndirectBranch  };</span>
<span class="udiff-line-modified-added">+     using CopyFunction = void*(&amp;)(void*, const void*, size_t);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     template &lt;CopyFunction copy&gt;</span>
<span class="udiff-line-added">+     static void fillNops(void* base, size_t size)</span>
      {
          RELEASE_ASSERT(!(size % sizeof(int32_t)));
          size_t n = size / sizeof(int32_t);
          for (int32_t* ptr = static_cast&lt;int32_t*&gt;(base); n--;) {
              int insn = nopPseudo();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2550,17 +2553,17 @@</span>
      }
  
      static void linkJump(void* code, AssemblerLabel from, void* to)
      {
          ASSERT(from.isSet());
<span class="udiff-line-modified-removed">-         relinkJumpOrCall&lt;false&gt;(addressOf(code, from), addressOf(code, from), to);</span>
<span class="udiff-line-modified-added">+         relinkJumpOrCall&lt;BranchType_JMP&gt;(addressOf(code, from), addressOf(code, from), to);</span>
      }
  
      static void linkCall(void* code, AssemblerLabel from, void* to)
      {
          ASSERT(from.isSet());
<span class="udiff-line-modified-removed">-         linkJumpOrCall&lt;true&gt;(addressOf(code, from) - 1, addressOf(code, from) - 1, to);</span>
<span class="udiff-line-modified-added">+         linkJumpOrCall&lt;BranchType_CALL&gt;(addressOf(code, from) - 1, addressOf(code, from) - 1, to);</span>
      }
  
      static void linkPointer(void* code, AssemblerLabel where, void* valuePtr)
      {
          linkPointer(addressOf(code, where), valuePtr);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2613,11 +2616,11 @@</span>
              int insn = loadStoreRegisterUnsignedImmediate(MemOpSize_64, false, MemOp_LOAD, encodePositiveImmediate&lt;64&gt;(imm12), rn, rd);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(where) == where);
              performJITMemcpy(where, &amp;insn, sizeof(int));
              cacheFlush(where, sizeof(int));
          }
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
          else {
              MemOpSize size;
              bool V;
              MemOp opc;
              int imm12;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2627,11 +2630,11 @@</span>
              ASSERT(size == MemOpSize_64);
              ASSERT(!V);
              ASSERT(opc == MemOp_LOAD);
              ASSERT(!(imm12 &amp; ~0x1ff));
          }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
      }
  
      static void replaceWithAddressComputation(void* where)
      {
          MemOpSize size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2648,11 +2651,11 @@</span>
              int insn = addSubtractImmediate(Datasize_64, AddOp_ADD, DontSetFlags, 0, imm12 * sizeof(void*), rn, rt);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(where) == where);
              performJITMemcpy(where, &amp;insn, sizeof(int));
              cacheFlush(where, sizeof(int));
          }
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
          else {
              Datasize sf;
              AddOp op;
              SetFlags S;
              int shift;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2664,11 +2667,11 @@</span>
              ASSERT(op == AddOp_ADD);
              ASSERT(!S);
              ASSERT(!shift);
              ASSERT(!(imm12 &amp; ~0xff8));
          }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
      }
  
      static void repatchPointer(void* where, void* valuePtr)
      {
          linkPointer(static_cast&lt;int*&gt;(where), valuePtr, true);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2752,22 +2755,22 @@</span>
      // and jump patching as they&#39;re modifying existing (linked) code,
      // so the address being provided is correct for relative address
      // computation.
      static void relinkJump(void* from, void* to)
      {
<span class="udiff-line-modified-removed">-         relinkJumpOrCall&lt;false&gt;(reinterpret_cast&lt;int*&gt;(from), reinterpret_cast&lt;const int*&gt;(from), to);</span>
<span class="udiff-line-modified-added">+         relinkJumpOrCall&lt;BranchType_JMP&gt;(reinterpret_cast&lt;int*&gt;(from), reinterpret_cast&lt;const int*&gt;(from), to);</span>
          cacheFlush(from, sizeof(int));
      }
  
      static void relinkJumpToNop(void* from)
      {
          relinkJump(from, static_cast&lt;char*&gt;(from) + 4);
      }
  
      static void relinkCall(void* from, void* to)
      {
<span class="udiff-line-modified-removed">-         relinkJumpOrCall&lt;true&gt;(reinterpret_cast&lt;int*&gt;(from) - 1, reinterpret_cast&lt;const int*&gt;(from) - 1, to);</span>
<span class="udiff-line-modified-added">+         relinkJumpOrCall&lt;BranchType_CALL&gt;(reinterpret_cast&lt;int*&gt;(from) - 1, reinterpret_cast&lt;const int*&gt;(from) - 1, to);</span>
          cacheFlush(reinterpret_cast&lt;int*&gt;(from) - 1, sizeof(int));
      }
  
      static void repatchCompact(void* where, int32_t value)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2802,11 +2805,11 @@</span>
      }
  #endif
  
      static void cacheFlush(void* code, size_t size)
      {
<span class="udiff-line-modified-removed">- #if OS(IOS_FAMILY)</span>
<span class="udiff-line-modified-added">+ #if OS(DARWIN)</span>
          sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
  #elif OS(FUCHSIA)
          zx_cache_flush(code, size, ZX_CACHE_FLUSH_INSN);
  #elif OS(LINUX)
          size_t page = pageSize();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2908,56 +2911,35 @@</span>
      {
          std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
          return m_jumpsToLink;
      }
  
<span class="udiff-line-modified-removed">- #if CPU(ARM64E)</span>
<span class="udiff-line-modified-removed">-     class CopyFunction {</span>
<span class="udiff-line-removed">-         typedef void* (*Func)(void*, const void*, size_t);</span>
<span class="udiff-line-removed">-     public:</span>
<span class="udiff-line-removed">-         CopyFunction(Func func)</span>
<span class="udiff-line-removed">-             : m_func(func)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             assertIsNullOrTaggedWith(func, CopyFunctionPtrTag);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         void* operator()(void* dst, const void* src, size_t size)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-             return ptrauth_auth_function(m_func, ptrauth_key_process_dependent_code, CopyFunctionPtrTag)(dst, src, size);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private:</span>
<span class="udiff-line-removed">-         Func m_func;</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     typedef void* (*CopyFunction)(void*, const void*, size_t);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy&gt;</span>
<span class="udiff-line-modified-added">+     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to)</span>
      {
          const int* fromInstruction = reinterpret_cast&lt;const int*&gt;(fromInstruction8);
          switch (record.linkType()) {
          case LinkJumpNoCondition:
<span class="udiff-line-modified-removed">-             linkJumpOrCall&lt;false&gt;(reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpOrCall&lt;BranchType_JMP, copy&gt;(reinterpret_cast&lt;int*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpConditionDirect:
<span class="udiff-line-modified-removed">-             linkConditionalBranch&lt;true&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkConditionalBranch&lt;DirectBranch, copy&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpCondition:
<span class="udiff-line-modified-removed">-             linkConditionalBranch&lt;false&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkConditionalBranch&lt;IndirectBranch, copy&gt;(record.condition(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to);</span>
              break;
          case LinkJumpCompareAndBranchDirect:
<span class="udiff-line-modified-removed">-             linkCompareAndBranch&lt;true&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkCompareAndBranch&lt;DirectBranch, copy&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpCompareAndBranch:
<span class="udiff-line-modified-removed">-             linkCompareAndBranch&lt;false&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkCompareAndBranch&lt;IndirectBranch, copy&gt;(record.condition(), record.is64Bit(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to);</span>
              break;
          case LinkJumpTestBitDirect:
<span class="udiff-line-modified-removed">-             linkTestAndBranch&lt;true&gt;(record.condition(), record.bitNumber(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkTestAndBranch&lt;DirectBranch, copy&gt;(record.condition(), record.bitNumber(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpTestBit:
<span class="udiff-line-modified-removed">-             linkTestAndBranch&lt;false&gt;(record.condition(), record.bitNumber(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkTestAndBranch&lt;IndirectBranch, copy&gt;(record.condition(), record.bitNumber(), record.compareRegister(), reinterpret_cast&lt;int*&gt;(from) - 1, fromInstruction - 1, to);</span>
              break;
          default:
              ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2994,18 +2976,21 @@</span>
          ASSERT(checkMovk&lt;Datasize_64&gt;(address[2], 2, rd));
  
          setPointer(address, valuePtr, rd, flush);
      }
  
<span class="udiff-line-modified-removed">-     template&lt;bool isCall&gt;</span>
<span class="udiff-line-modified-removed">-     static void linkJumpOrCall(int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
<span class="udiff-line-modified-added">+     template&lt;BranchType type, CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-modified-added">+     static void linkJumpOrCall(int* from, const int* fromInstruction, void* to)</span>
      {
<span class="udiff-line-added">+         static_assert(type == BranchType_JMP || type == BranchType_CALL, &quot;&quot;);</span>
<span class="udiff-line-added">+ </span>
          bool link;
          int imm26;
          bool isUnconditionalBranchImmediateOrNop = disassembleUnconditionalBranchImmediate(from, link, imm26) || disassembleNop(from);
  
          ASSERT_UNUSED(isUnconditionalBranchImmediateOrNop, isUnconditionalBranchImmediateOrNop);
<span class="udiff-line-added">+         constexpr bool isCall = (type == BranchType_CALL);</span>
          ASSERT_UNUSED(isCall, (link == isCall) || disassembleNop(from));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
          assertIsNotTagged(to);
          assertIsNotTagged(fromInstruction);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3015,112 +3000,113 @@</span>
          int insn = unconditionalBranchImmediate(isCall, static_cast&lt;int&gt;(offset));
          RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
          copy(from, &amp;insn, sizeof(int));
      }
  
<span class="udiff-line-modified-removed">-     template&lt;bool isDirect&gt;</span>
<span class="udiff-line-modified-removed">-     static void linkCompareAndBranch(Condition condition, bool is64Bit, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
<span class="udiff-line-modified-added">+     template&lt;BranchTargetType type, CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-modified-added">+     static void linkCompareAndBranch(Condition condition, bool is64Bit, RegisterID rt, int* from, const int* fromInstruction, void* to)</span>
      {
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
          intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
          ASSERT(isInt&lt;26&gt;(offset));
  
          bool useDirect = isInt&lt;19&gt;(offset);
<span class="udiff-line-modified-removed">-         ASSERT(!isDirect || useDirect);</span>
<span class="udiff-line-modified-added">+         ASSERT(type == IndirectBranch || useDirect);</span>
  
<span class="udiff-line-modified-removed">-         if (useDirect || isDirect) {</span>
<span class="udiff-line-modified-added">+         if (useDirect || type == DirectBranch) {</span>
              int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, condition == ConditionNE, static_cast&lt;int&gt;(offset), rt);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             if (!isDirect) {</span>
<span class="udiff-line-modified-added">+             if (type == IndirectBranch) {</span>
                  insn = nopPseudo();
                  RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
                  copy(from + 1, &amp;insn, sizeof(int));
              }
          } else {
              int insn = compareAndBranchImmediate(is64Bit ? Datasize_64 : Datasize_32, invert(condition) == ConditionNE, 2, rt);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpOrCall&lt;BranchType_JMP, copy&gt;(from + 1, fromInstruction + 1, to);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     template&lt;bool isDirect&gt;</span>
<span class="udiff-line-modified-removed">-     static void linkConditionalBranch(Condition condition, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
<span class="udiff-line-modified-added">+     template&lt;BranchTargetType type, CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-modified-added">+     static void linkConditionalBranch(Condition condition, int* from, const int* fromInstruction, void* to)</span>
      {
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
          intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
          ASSERT(isInt&lt;26&gt;(offset));
  
          bool useDirect = isInt&lt;19&gt;(offset);
<span class="udiff-line-modified-removed">-         ASSERT(!isDirect || useDirect);</span>
<span class="udiff-line-modified-added">+         ASSERT(type == IndirectBranch || useDirect);</span>
  
<span class="udiff-line-modified-removed">-         if (useDirect || isDirect) {</span>
<span class="udiff-line-modified-added">+         if (useDirect || type == DirectBranch) {</span>
              int insn = conditionalBranchImmediate(static_cast&lt;int&gt;(offset), condition);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             if (!isDirect) {</span>
<span class="udiff-line-modified-added">+             if (type == IndirectBranch) {</span>
                  insn = nopPseudo();
                  RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
                  copy(from + 1, &amp;insn, sizeof(int));
              }
          } else {
              int insn = conditionalBranchImmediate(2, invert(condition));
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpOrCall&lt;BranchType_JMP, copy&gt;(from + 1, fromInstruction + 1, to);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     template&lt;bool isDirect&gt;</span>
<span class="udiff-line-modified-removed">-     static void linkTestAndBranch(Condition condition, unsigned bitNumber, RegisterID rt, int* from, const int* fromInstruction, void* to, CopyFunction copy = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy))</span>
<span class="udiff-line-modified-added">+     template&lt;BranchTargetType type, CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-modified-added">+     static void linkTestAndBranch(Condition condition, unsigned bitNumber, RegisterID rt, int* from, const int* fromInstruction, void* to)</span>
      {
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(from) &amp; 3));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(to) &amp; 3));
          intptr_t offset = (reinterpret_cast&lt;intptr_t&gt;(to) - reinterpret_cast&lt;intptr_t&gt;(fromInstruction)) &gt;&gt; 2;
          ASSERT(static_cast&lt;int&gt;(offset) == offset);
          ASSERT(isInt&lt;26&gt;(offset));
  
          bool useDirect = isInt&lt;14&gt;(offset);
<span class="udiff-line-modified-removed">-         ASSERT(!isDirect || useDirect);</span>
<span class="udiff-line-modified-added">+         ASSERT(type == IndirectBranch || useDirect);</span>
  
<span class="udiff-line-modified-removed">-         if (useDirect || isDirect) {</span>
<span class="udiff-line-modified-added">+         if (useDirect || type == DirectBranch) {</span>
              int insn = testAndBranchImmediate(condition == ConditionNE, static_cast&lt;int&gt;(bitNumber), static_cast&lt;int&gt;(offset), rt);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             if (!isDirect) {</span>
<span class="udiff-line-modified-added">+             if (type == IndirectBranch) {</span>
                  insn = nopPseudo();
                  RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from + 1) == (from + 1));
                  copy(from + 1, &amp;insn, sizeof(int));
              }
          } else {
              int insn = testAndBranchImmediate(invert(condition) == ConditionNE, static_cast&lt;int&gt;(bitNumber), 2, rt);
              RELEASE_ASSERT(roundUpToMultipleOf&lt;instructionSize&gt;(from) == from);
              copy(from, &amp;insn, sizeof(int));
<span class="udiff-line-modified-removed">-             linkJumpOrCall&lt;false&gt;(from + 1, fromInstruction + 1, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpOrCall&lt;BranchType_JMP, copy&gt;(from + 1, fromInstruction + 1, to);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     template&lt;bool isCall&gt;</span>
<span class="udiff-line-modified-added">+     template&lt;BranchType type&gt;</span>
      static void relinkJumpOrCall(int* from, const int* fromInstruction, void* to)
      {
<span class="udiff-line-modified-removed">-         if (!isCall &amp;&amp; disassembleNop(from)) {</span>
<span class="udiff-line-modified-added">+         static_assert(type == BranchType_JMP || type == BranchType_CALL, &quot;&quot;);</span>
<span class="udiff-line-added">+         if ((type == BranchType_JMP) &amp;&amp; disassembleNop(from)) {</span>
              unsigned op01;
              int imm19;
              Condition condition;
              bool isConditionalBranchImmediate = disassembleConditionalBranchImmediate(from - 1, op01, imm19, condition);
  
              if (isConditionalBranchImmediate) {
                  ASSERT_UNUSED(op01, !op01);
<span class="udiff-line-modified-removed">-                 ASSERT_UNUSED(isCall, !isCall);</span>
<span class="udiff-line-modified-added">+                 ASSERT(type == BranchType_JMP);</span>
  
                  if (imm19 == 8)
                      condition = invert(condition);
  
<span class="udiff-line-modified-removed">-                 linkConditionalBranch&lt;false&gt;(condition, from - 1, fromInstruction - 1, to);</span>
<span class="udiff-line-modified-added">+                 linkConditionalBranch&lt;IndirectBranch&gt;(condition, from - 1, fromInstruction - 1, to);</span>
                  return;
              }
  
              Datasize opSize;
              bool op;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3129,11 +3115,11 @@</span>
  
              if (isCompareAndBranchImmediate) {
                  if (imm19 == 8)
                      op = !op;
  
<span class="udiff-line-modified-removed">-                 linkCompareAndBranch&lt;false&gt;(op ? ConditionNE : ConditionEQ, opSize == Datasize_64, rt, from - 1, fromInstruction - 1, to);</span>
<span class="udiff-line-modified-added">+                 linkCompareAndBranch&lt;IndirectBranch&gt;(op ? ConditionNE : ConditionEQ, opSize == Datasize_64, rt, from - 1, fromInstruction - 1, to);</span>
                  return;
              }
  
              int imm14;
              unsigned bitNumber;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3141,16 +3127,16 @@</span>
  
              if (isTestAndBranchImmediate) {
                  if (imm14 == 8)
                      op = !op;
  
<span class="udiff-line-modified-removed">-                 linkTestAndBranch&lt;false&gt;(op ? ConditionNE : ConditionEQ, bitNumber, rt, from - 1, fromInstruction - 1, to);</span>
<span class="udiff-line-modified-added">+                 linkTestAndBranch&lt;IndirectBranch&gt;(op ? ConditionNE : ConditionEQ, bitNumber, rt, from - 1, fromInstruction - 1, to);</span>
                  return;
              }
          }
  
<span class="udiff-line-modified-removed">-         linkJumpOrCall&lt;isCall&gt;(from, fromInstruction, to);</span>
<span class="udiff-line-modified-added">+         linkJumpOrCall&lt;type&gt;(from, fromInstruction, to);</span>
      }
  
      static int* addressOf(void* code, AssemblerLabel label)
      {
          return reinterpret_cast&lt;int*&gt;(static_cast&lt;char*&gt;(code) + label.m_offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3242,17 +3228,17 @@</span>
      }
  
      static int xOrSp(RegisterID reg)
      {
          ASSERT(!isZr(reg));
<span class="udiff-line-modified-removed">-         ASSERT(!isIOS() || reg != ARM64Registers::x18);</span>
<span class="udiff-line-modified-added">+         ASSERT(!isDarwin() || reg != ARM64Registers::x18);</span>
          return reg;
      }
      static int xOrZr(RegisterID reg)
      {
          ASSERT(!isSp(reg));
<span class="udiff-line-modified-removed">-         ASSERT(!isIOS() || reg != ARM64Registers::x18);</span>
<span class="udiff-line-modified-added">+         ASSERT(!isDarwin() || reg != ARM64Registers::x18);</span>
          return reg &amp; 31;
      }
      static FPRegisterID xOrZrAsFPR(RegisterID reg) { return static_cast&lt;FPRegisterID&gt;(xOrZr(reg)); }
      static int xOrZrOrSp(bool useZr, RegisterID reg) { return useZr ? xOrZr(reg) : xOrSp(reg); }
  
</pre>
<center><a href="../Sources.txt.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARM64Registers.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
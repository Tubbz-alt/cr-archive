diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp
@@ -1,8 +1,8 @@
 /*
  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
- * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
+ * Copyright (C) 2016-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -84,25 +84,20 @@
 {
     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 }
 
 IntlDateTimeFormat::IntlDateTimeFormat(VM& vm, Structure* structure)
-    : JSDestructibleObject(vm, structure)
+    : Base(vm, structure)
 {
 }
 
 void IntlDateTimeFormat::finishCreation(VM& vm)
 {
     Base::finishCreation(vm);
     ASSERT(inherits(vm, info()));
 }
 
-void IntlDateTimeFormat::destroy(JSCell* cell)
-{
-    static_cast<IntlDateTimeFormat*>(cell)->IntlDateTimeFormat::~IntlDateTimeFormat();
-}
-
 void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor& visitor)
 {
     IntlDateTimeFormat* thisObject = jsCast<IntlDateTimeFormat*>(cell);
     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 
@@ -236,26 +231,26 @@
         ASSERT_NOT_REACHED();
     }
     return keyLocaleData;
 }
 
-static JSObject* toDateTimeOptionsAnyDate(ExecState& exec, JSValue originalOptions)
+static JSObject* toDateTimeOptionsAnyDate(JSGlobalObject* globalObject, JSValue originalOptions)
 {
     // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 1. If options is undefined, then let options be null, else let options be ToObject(options).
     // 2. ReturnIfAbrupt(options).
     // 3. Let options be ObjectCreate(options).
     JSObject* options;
     if (originalOptions.isUndefined())
-        options = constructEmptyObject(&exec, exec.lexicalGlobalObject()->nullPrototypeObjectStructure());
+        options = constructEmptyObject(vm, globalObject->nullPrototypeObjectStructure());
     else {
-        JSObject* originalToObject = originalOptions.toObject(&exec);
+        JSObject* originalToObject = originalOptions.toObject(globalObject);
         RETURN_IF_EXCEPTION(scope, nullptr);
-        options = constructEmptyObject(&exec, originalToObject);
+        options = constructEmptyObject(globalObject, originalToObject);
     }
 
     // 4. Let needDefaults be true.
     bool needDefaults = true;
 
@@ -265,26 +260,26 @@
     // a. For each of the property names "weekday", "year", "month", "day":
     // i. Let prop be the property name.
     // ii. Let value be Get(options, prop).
     // iii. ReturnIfAbrupt(value).
     // iv. If value is not undefined, then let needDefaults be false.
-    JSValue weekday = options->get(&exec, vm.propertyNames->weekday);
+    JSValue weekday = options->get(globalObject, vm.propertyNames->weekday);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!weekday.isUndefined())
         needDefaults = false;
 
-    JSValue year = options->get(&exec, vm.propertyNames->year);
+    JSValue year = options->get(globalObject, vm.propertyNames->year);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!year.isUndefined())
         needDefaults = false;
 
-    JSValue month = options->get(&exec, vm.propertyNames->month);
+    JSValue month = options->get(globalObject, vm.propertyNames->month);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!month.isUndefined())
         needDefaults = false;
 
-    JSValue day = options->get(&exec, vm.propertyNames->day);
+    JSValue day = options->get(globalObject, vm.propertyNames->day);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!day.isUndefined())
         needDefaults = false;
 
     // 6. If required is "time" or "any",
@@ -293,21 +288,21 @@
     // a. For each of the property names "hour", "minute", "second":
     // i. Let prop be the property name.
     // ii. Let value be Get(options, prop).
     // iii. ReturnIfAbrupt(value).
     // iv. If value is not undefined, then let needDefaults be false.
-    JSValue hour = options->get(&exec, vm.propertyNames->hour);
+    JSValue hour = options->get(globalObject, vm.propertyNames->hour);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!hour.isUndefined())
         needDefaults = false;
 
-    JSValue minute = options->get(&exec, vm.propertyNames->minute);
+    JSValue minute = options->get(globalObject, vm.propertyNames->minute);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!minute.isUndefined())
         needDefaults = false;
 
-    JSValue second = options->get(&exec, vm.propertyNames->second);
+    JSValue second = options->get(globalObject, vm.propertyNames->second);
     RETURN_IF_EXCEPTION(scope, nullptr);
     if (!second.isUndefined())
         needDefaults = false;
 
     // 7. If needDefaults is true and defaults is either "date" or "all", then
@@ -439,50 +434,50 @@
             break;
         }
     }
 }
 
-void IntlDateTimeFormat::initializeDateTimeFormat(ExecState& exec, JSValue locales, JSValue originalOptions)
+void IntlDateTimeFormat::initializeDateTimeFormat(JSGlobalObject* globalObject, JSValue locales, JSValue originalOptions)
 {
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
     // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
 
-    Vector<String> requestedLocales = canonicalizeLocaleList(exec, locales);
+    Vector<String> requestedLocales = canonicalizeLocaleList(globalObject, locales);
     RETURN_IF_EXCEPTION(scope, void());
 
-    JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(exec, originalOptions);
+    JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(globalObject, originalOptions);
     RETURN_IF_EXCEPTION(scope, void());
 
     HashMap<String, String> opt;
 
-    String localeMatcher = intlStringOption(exec, options, vm.propertyNames->localeMatcher, { "lookup", "best fit" }, "localeMatcher must be either \"lookup\" or \"best fit\"", "best fit");
+    String localeMatcher = intlStringOption(globalObject, options, vm.propertyNames->localeMatcher, { "lookup", "best fit" }, "localeMatcher must be either \"lookup\" or \"best fit\"", "best fit");
     RETURN_IF_EXCEPTION(scope, void());
     opt.add(vm.propertyNames->localeMatcher.string(), localeMatcher);
 
     bool isHour12Undefined;
-    bool hour12 = intlBooleanOption(exec, options, vm.propertyNames->hour12, isHour12Undefined);
+    bool hour12 = intlBooleanOption(globalObject, options, vm.propertyNames->hour12, isHour12Undefined);
     RETURN_IF_EXCEPTION(scope, void());
 
-    String hourCycle = intlStringOption(exec, options, vm.propertyNames->hourCycle, { "h11", "h12", "h23", "h24" }, "hourCycle must be \"h11\", \"h12\", \"h23\", or \"h24\"", nullptr);
+    String hourCycle = intlStringOption(globalObject, options, vm.propertyNames->hourCycle, { "h11", "h12", "h23", "h24" }, "hourCycle must be \"h11\", \"h12\", \"h23\", or \"h24\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (isHour12Undefined) {
         // Set hour12 here to simplify hour logic later.
         hour12 = (hourCycle == "h11" || hourCycle == "h12");
         if (!hourCycle.isNull())
             opt.add("hc"_s, hourCycle);
     } else
         opt.add("hc"_s, String());
 
-    const HashSet<String> availableLocales = exec.jsCallee()->globalObject(vm)->intlDateTimeFormatAvailableLocales();
-    HashMap<String, String> resolved = resolveLocale(exec, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);
+    const HashSet<String>& availableLocales = intlDateTimeFormatAvailableLocales();
+    HashMap<String, String> resolved = resolveLocale(globalObject, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);
 
     m_locale = resolved.get(vm.propertyNames->locale.string());
     if (m_locale.isEmpty()) {
-        throwTypeError(&exec, scope, "failed to initialize DateTimeFormat due to invalid locale"_s);
+        throwTypeError(globalObject, scope, "failed to initialize DateTimeFormat due to invalid locale"_s);
         return;
     }
 
     m_calendar = resolved.get("ca"_s);
     if (m_calendar == "gregorian")
@@ -494,19 +489,19 @@
 
     m_hourCycle = resolved.get("hc"_s);
     m_numberingSystem = resolved.get("nu"_s);
     String dataLocale = resolved.get("dataLocale"_s);
 
-    JSValue tzValue = options->get(&exec, vm.propertyNames->timeZone);
+    JSValue tzValue = options->get(globalObject, vm.propertyNames->timeZone);
     RETURN_IF_EXCEPTION(scope, void());
     String tz;
     if (!tzValue.isUndefined()) {
-        String originalTz = tzValue.toWTFString(&exec);
+        String originalTz = tzValue.toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, void());
         tz = canonicalizeTimeZoneName(originalTz);
         if (tz.isNull()) {
-            throwRangeError(&exec, scope, "invalid time zone: " + originalTz);
+            throwRangeError(globalObject, scope, "invalid time zone: " + originalTz);
             return;
         }
     } else
         tz = defaultTimeZone();
     m_timeZone = tz;
@@ -515,42 +510,42 @@
     auto narrowShortLong = { "narrow", "short", "long" };
     auto twoDigitNumeric = { "2-digit", "numeric" };
     auto twoDigitNumericNarrowShortLong = { "2-digit", "numeric", "narrow", "short", "long" };
     auto shortLong = { "short", "long" };
 
-    String weekday = intlStringOption(exec, options, vm.propertyNames->weekday, narrowShortLong, "weekday must be \"narrow\", \"short\", or \"long\"", nullptr);
+    String weekday = intlStringOption(globalObject, options, vm.propertyNames->weekday, narrowShortLong, "weekday must be \"narrow\", \"short\", or \"long\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!weekday.isNull()) {
         if (weekday == "narrow")
             skeletonBuilder.appendLiteral("EEEEE");
         else if (weekday == "short")
             skeletonBuilder.appendLiteral("EEE");
         else if (weekday == "long")
             skeletonBuilder.appendLiteral("EEEE");
     }
 
-    String era = intlStringOption(exec, options, vm.propertyNames->era, narrowShortLong, "era must be \"narrow\", \"short\", or \"long\"", nullptr);
+    String era = intlStringOption(globalObject, options, vm.propertyNames->era, narrowShortLong, "era must be \"narrow\", \"short\", or \"long\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!era.isNull()) {
         if (era == "narrow")
             skeletonBuilder.appendLiteral("GGGGG");
         else if (era == "short")
             skeletonBuilder.appendLiteral("GGG");
         else if (era == "long")
             skeletonBuilder.appendLiteral("GGGG");
     }
 
-    String year = intlStringOption(exec, options, vm.propertyNames->year, twoDigitNumeric, "year must be \"2-digit\" or \"numeric\"", nullptr);
+    String year = intlStringOption(globalObject, options, vm.propertyNames->year, twoDigitNumeric, "year must be \"2-digit\" or \"numeric\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!year.isNull()) {
         if (year == "2-digit")
             skeletonBuilder.appendLiteral("yy");
         else if (year == "numeric")
             skeletonBuilder.append('y');
     }
 
-    String month = intlStringOption(exec, options, vm.propertyNames->month, twoDigitNumericNarrowShortLong, "month must be \"2-digit\", \"numeric\", \"narrow\", \"short\", or \"long\"", nullptr);
+    String month = intlStringOption(globalObject, options, vm.propertyNames->month, twoDigitNumericNarrowShortLong, "month must be \"2-digit\", \"numeric\", \"narrow\", \"short\", or \"long\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!month.isNull()) {
         if (month == "2-digit")
             skeletonBuilder.appendLiteral("MM");
         else if (month == "numeric")
@@ -561,20 +556,20 @@
             skeletonBuilder.appendLiteral("MMM");
         else if (month == "long")
             skeletonBuilder.appendLiteral("MMMM");
     }
 
-    String day = intlStringOption(exec, options, vm.propertyNames->day, twoDigitNumeric, "day must be \"2-digit\" or \"numeric\"", nullptr);
+    String day = intlStringOption(globalObject, options, vm.propertyNames->day, twoDigitNumeric, "day must be \"2-digit\" or \"numeric\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!day.isNull()) {
         if (day == "2-digit")
             skeletonBuilder.appendLiteral("dd");
         else if (day == "numeric")
             skeletonBuilder.append('d');
     }
 
-    String hour = intlStringOption(exec, options, vm.propertyNames->hour, twoDigitNumeric, "hour must be \"2-digit\" or \"numeric\"", nullptr);
+    String hour = intlStringOption(globalObject, options, vm.propertyNames->hour, twoDigitNumeric, "hour must be \"2-digit\" or \"numeric\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (hour == "2-digit") {
         if (isHour12Undefined && m_hourCycle.isNull())
             skeletonBuilder.appendLiteral("jj");
         else if (hour12)
@@ -589,45 +584,45 @@
         else
             skeletonBuilder.append('H');
     } else
         m_hourCycle = String();
 
-    String minute = intlStringOption(exec, options, vm.propertyNames->minute, twoDigitNumeric, "minute must be \"2-digit\" or \"numeric\"", nullptr);
+    String minute = intlStringOption(globalObject, options, vm.propertyNames->minute, twoDigitNumeric, "minute must be \"2-digit\" or \"numeric\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!minute.isNull()) {
         if (minute == "2-digit")
             skeletonBuilder.appendLiteral("mm");
         else if (minute == "numeric")
             skeletonBuilder.append('m');
     }
 
-    String second = intlStringOption(exec, options, vm.propertyNames->second, twoDigitNumeric, "second must be \"2-digit\" or \"numeric\"", nullptr);
+    String second = intlStringOption(globalObject, options, vm.propertyNames->second, twoDigitNumeric, "second must be \"2-digit\" or \"numeric\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!second.isNull()) {
         if (second == "2-digit")
             skeletonBuilder.appendLiteral("ss");
         else if (second == "numeric")
             skeletonBuilder.append('s');
     }
 
-    String timeZoneName = intlStringOption(exec, options, vm.propertyNames->timeZoneName, shortLong, "timeZoneName must be \"short\" or \"long\"", nullptr);
+    String timeZoneName = intlStringOption(globalObject, options, vm.propertyNames->timeZoneName, shortLong, "timeZoneName must be \"short\" or \"long\"", nullptr);
     RETURN_IF_EXCEPTION(scope, void());
     if (!timeZoneName.isNull()) {
         if (timeZoneName == "short")
             skeletonBuilder.append('z');
         else if (timeZoneName == "long")
             skeletonBuilder.appendLiteral("zzzz");
     }
 
-    intlStringOption(exec, options, vm.propertyNames->formatMatcher, { "basic", "best fit" }, "formatMatcher must be either \"basic\" or \"best fit\"", "best fit");
+    intlStringOption(globalObject, options, vm.propertyNames->formatMatcher, { "basic", "best fit" }, "formatMatcher must be either \"basic\" or \"best fit\"", "best fit");
     RETURN_IF_EXCEPTION(scope, void());
 
     // Always use ICU date format generator, rather than our own pattern list and matcher.
     UErrorCode status = U_ZERO_ERROR;
     UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &status);
     if (U_FAILURE(status)) {
-        throwTypeError(&exec, scope, "failed to initialize DateTimeFormat"_s);
+        throwTypeError(globalObject, scope, "failed to initialize DateTimeFormat"_s);
         return;
     }
 
     String skeleton = skeletonBuilder.toString();
     StringView skeletonView(skeleton);
@@ -639,11 +634,11 @@
         patternBuffer.grow(patternLength);
         udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &status);
     }
     udatpg_close(generator);
     if (U_FAILURE(status)) {
-        throwTypeError(&exec, scope, "failed to initialize DateTimeFormat"_s);
+        throwTypeError(globalObject, scope, "failed to initialize DateTimeFormat"_s);
         return;
     }
 
     // Enforce our hourCycle, replacing hour characters in pattern.
     if (!m_hourCycle.isNull()) {
@@ -675,11 +670,11 @@
 
     status = U_ZERO_ERROR;
     StringView timeZoneView(m_timeZone);
     m_dateFormat = std::unique_ptr<UDateFormat, UDateFormatDeleter>(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &status));
     if (U_FAILURE(status)) {
-        throwTypeError(&exec, scope, "failed to initialize DateTimeFormat"_s);
+        throwTypeError(globalObject, scope, "failed to initialize DateTimeFormat"_s);
         return;
     }
 
     // Gregorian calendar should be used from the beginning of ECMAScript time.
     // Failure here means unsupported calendar, and can safely be ignored.
@@ -832,29 +827,34 @@
     }
     ASSERT_NOT_REACHED();
     return ASCIILiteral::null();
 }
 
-JSObject* IntlDateTimeFormat::resolvedOptions(ExecState& exec)
+JSObject* IntlDateTimeFormat::resolvedOptions(JSGlobalObject* globalObject)
 {
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
     // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
     // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
     if (!m_initializedDateTimeFormat) {
-        initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());
+        initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());
         scope.assertNoException();
     }
 
-    JSObject* options = constructEmptyObject(&exec);
+    JSObject* options = constructEmptyObject(globalObject);
     options->putDirect(vm, vm.propertyNames->locale, jsNontrivialString(vm, m_locale));
     options->putDirect(vm, vm.propertyNames->calendar, jsNontrivialString(vm, m_calendar));
     options->putDirect(vm, vm.propertyNames->numberingSystem, jsNontrivialString(vm, m_numberingSystem));
     options->putDirect(vm, vm.propertyNames->timeZone, jsNontrivialString(vm, m_timeZone));
 
+    if (!m_hourCycle.isNull()) {
+        options->putDirect(vm, vm.propertyNames->hourCycle, jsNontrivialString(vm, m_hourCycle));
+        options->putDirect(vm, vm.propertyNames->hour12, jsBoolean(m_hourCycle == "h11" || m_hourCycle == "h12"));
+    }
+
     if (m_weekday != Weekday::None)
         options->putDirect(vm, vm.propertyNames->weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
 
     if (m_era != Era::None)
         options->putDirect(vm, vm.propertyNames->era, jsNontrivialString(vm, eraString(m_era)));
@@ -869,15 +869,10 @@
         options->putDirect(vm, vm.propertyNames->day, jsNontrivialString(vm, dayString(m_day)));
 
     if (m_hour != Hour::None)
         options->putDirect(vm, vm.propertyNames->hour, jsNontrivialString(vm, hourString(m_hour)));
 
-    if (!m_hourCycle.isNull()) {
-        options->putDirect(vm, vm.propertyNames->hourCycle, jsNontrivialString(vm, m_hourCycle));
-        options->putDirect(vm, vm.propertyNames->hour12, jsBoolean(m_hourCycle == "h11" || m_hourCycle == "h12"));
-    }
-
     if (m_minute != Minute::None)
         options->putDirect(vm, vm.propertyNames->minute, jsNontrivialString(vm, minuteString(m_minute)));
 
     if (m_second != Second::None)
         options->putDirect(vm, vm.propertyNames->second, jsNontrivialString(vm, secondString(m_second)));
@@ -886,24 +881,24 @@
         options->putDirect(vm, vm.propertyNames->timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
 
     return options;
 }
 
-JSValue IntlDateTimeFormat::format(ExecState& exec, double value)
+JSValue IntlDateTimeFormat::format(JSGlobalObject* globalObject, double value)
 {
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
     if (!m_initializedDateTimeFormat) {
-        initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());
+        initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());
         scope.assertNoException();
     }
 
     // 1. If x is not a finite Number, then throw a RangeError exception.
     if (!std::isfinite(value))
-        return throwRangeError(&exec, scope, "date value is not finite in DateTimeFormat format()"_s);
+        return throwRangeError(globalObject, scope, "date value is not finite in DateTimeFormat format()"_s);
 
     // Delegate remaining steps to ICU.
     UErrorCode status = U_ZERO_ERROR;
     Vector<UChar, 32> result(32);
     auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &status);
@@ -911,11 +906,11 @@
         status = U_ZERO_ERROR;
         result.grow(resultLength);
         udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &status);
     }
     if (U_FAILURE(status))
-        return throwTypeError(&exec, scope, "failed to format date value"_s);
+        return throwTypeError(globalObject, scope, "failed to format date value"_s);
 
     return jsString(vm, String(result.data(), resultLength));
 }
 
 #if JSC_ICU_HAS_UFIELDPOSITER
@@ -983,45 +978,44 @@
     }
     return "unknown"_s;
 }
 
 
-JSValue IntlDateTimeFormat::formatToParts(ExecState& exec, double value)
+JSValue IntlDateTimeFormat::formatToParts(JSGlobalObject* globalObject, double value)
 {
-    VM& vm = exec.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
     // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
 
     if (!std::isfinite(value))
-        return throwRangeError(&exec, scope, "date value is not finite in DateTimeFormat formatToParts()"_s);
+        return throwRangeError(globalObject, scope, "date value is not finite in DateTimeFormat formatToParts()"_s);
 
     UErrorCode status = U_ZERO_ERROR;
     auto fields = std::unique_ptr<UFieldPositionIterator, UFieldPositionIteratorDeleter>(ufieldpositer_open(&status));
     if (U_FAILURE(status))
-        return throwTypeError(&exec, scope, "failed to open field position iterator"_s);
+        return throwTypeError(globalObject, scope, "failed to open field position iterator"_s);
 
     status = U_ZERO_ERROR;
     Vector<UChar, 32> result(32);
     auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &status);
     if (status == U_BUFFER_OVERFLOW_ERROR) {
         status = U_ZERO_ERROR;
         result.grow(resultLength);
         udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &status);
     }
     if (U_FAILURE(status))
-        return throwTypeError(&exec, scope, "failed to format date value"_s);
+        return throwTypeError(globalObject, scope, "failed to format date value"_s);
 
-    JSGlobalObject* globalObject = exec.jsCallee()->globalObject(vm);
     JSArray* parts = JSArray::tryCreate(vm, globalObject->arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
     if (!parts)
-        return throwOutOfMemoryError(&exec, scope);
+        return throwOutOfMemoryError(globalObject, scope);
 
     auto resultString = String(result.data(), resultLength);
     auto typePropertyName = Identifier::fromString(vm, "type");
-    auto literalString = jsString(vm, "literal"_s);
+    auto literalString = jsNontrivialString(vm, "literal"_s);
 
     int32_t previousEndIndex = 0;
     int32_t beginIndex = 0;
     int32_t endIndex = 0;
     while (previousEndIndex < resultLength) {
@@ -1029,25 +1023,25 @@
         if (fieldType < 0)
             beginIndex = endIndex = resultLength;
 
         if (previousEndIndex < beginIndex) {
             auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
-            JSObject* part = constructEmptyObject(&exec);
+            JSObject* part = constructEmptyObject(globalObject);
             part->putDirect(vm, typePropertyName, literalString);
             part->putDirect(vm, vm.propertyNames->value, value);
-            parts->push(&exec, part);
+            parts->push(globalObject, part);
             RETURN_IF_EXCEPTION(scope, { });
         }
         previousEndIndex = endIndex;
 
         if (fieldType >= 0) {
             auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
             auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
-            JSObject* part = constructEmptyObject(&exec);
+            JSObject* part = constructEmptyObject(globalObject);
             part->putDirect(vm, typePropertyName, type);
             part->putDirect(vm, vm.propertyNames->value, value);
-            parts->push(&exec, part);
+            parts->push(globalObject, part);
             RETURN_IF_EXCEPTION(scope, { });
         }
     }
 
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssemblerARMv7.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerMIPS.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerCodeRef.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
222 #if COMPILER_SUPPORTS(BUILTIN_IS_TRIVIALLY_COPYABLE)
223 static_assert(__is_trivially_copyable(FunctionPtr&lt;CFunctionPtrTag&gt;), &quot;&quot;);
224 #endif
225 
226 // ReturnAddressPtr:
227 //
228 // ReturnAddressPtr should be used to wrap return addresses generated by processor
229 // &#39;call&#39; instructions exectued in JIT code.  We use return addresses to look up
230 // exception and optimization information, and to repatch the call instruction
231 // that is the source of the return address.
232 class ReturnAddressPtr {
233 public:
234     ReturnAddressPtr() { }
235 
236     explicit ReturnAddressPtr(const void* value)
237         : m_value(value)
238     {
239         ASSERT_VALID_CODE_POINTER(m_value);
240     }
241 
<span class="line-removed">242     template&lt;PtrTag tag&gt;</span>
<span class="line-removed">243     explicit ReturnAddressPtr(FunctionPtr&lt;tag&gt; function)</span>
<span class="line-removed">244         : m_value(untagCodePtr&lt;tag&gt;(function.executableAddress()))</span>
<span class="line-removed">245     {</span>
<span class="line-removed">246         ASSERT_VALID_CODE_POINTER(m_value);</span>
<span class="line-removed">247     }</span>
<span class="line-removed">248 </span>
249     const void* value() const
250     {
251         return m_value;
252     }
253 
254     void dump(PrintStream&amp; out) const
255     {
256         out.print(RawPointer(m_value));
257     }
258 
259 private:
260     const void* m_value { nullptr };
261 };
262 
263 // MacroAssemblerCodePtr:
264 //
265 // MacroAssemblerCodePtr should be used to wrap pointers to JIT generated code.
266 class MacroAssemblerCodePtrBase {
267 protected:
268     static void dumpWithName(void* executableAddress, void* dataLocation, const char* name, PrintStream&amp; out);
</pre>
<hr />
<pre>
391     bool isDeletedValue() const { return m_value == deletedValue(); }
392 
393     unsigned hash() const { return PtrHash&lt;const void*&gt;::hash(m_value); }
394 
395     static void initialize();
396 
397 private:
398     static const void* emptyValue() { return bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1)); }
399     static const void* deletedValue() { return bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(2)); }
400 
401     const void* m_value { nullptr };
402 };
403 
404 template&lt;PtrTag tag&gt;
405 struct MacroAssemblerCodePtrHash {
406     static unsigned hash(const MacroAssemblerCodePtr&lt;tag&gt;&amp; ptr) { return ptr.hash(); }
407     static bool equal(const MacroAssemblerCodePtr&lt;tag&gt;&amp; a, const MacroAssemblerCodePtr&lt;tag&gt;&amp; b)
408     {
409         return a == b;
410     }
<span class="line-modified">411     static const bool safeToCompareToEmptyOrDeleted = true;</span>
412 };
413 
414 // MacroAssemblerCodeRef:
415 //
416 // A reference to a section of JIT generated code.  A CodeRef consists of a
417 // pointer to the code, and a ref pointer to the pool from within which it
418 // was allocated.
419 class MacroAssemblerCodeRefBase {
420 protected:
421     static bool tryToDisassemble(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t, const char* prefix, PrintStream&amp; out);
422     static bool tryToDisassemble(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t, const char* prefix);
423     JS_EXPORT_PRIVATE static CString disassembly(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t);
424 };
425 
426 template&lt;PtrTag tag&gt;
427 class MacroAssemblerCodeRef : private MacroAssemblerCodeRefBase {
428 private:
429     // This is private because it&#39;s dangerous enough that we want uses of it
430     // to be easy to find - hence the static create method below.
431     explicit MacroAssemblerCodeRef(MacroAssemblerCodePtr&lt;tag&gt; codePtr)
</pre>
</td>
<td>
<hr />
<pre>
222 #if COMPILER_SUPPORTS(BUILTIN_IS_TRIVIALLY_COPYABLE)
223 static_assert(__is_trivially_copyable(FunctionPtr&lt;CFunctionPtrTag&gt;), &quot;&quot;);
224 #endif
225 
226 // ReturnAddressPtr:
227 //
228 // ReturnAddressPtr should be used to wrap return addresses generated by processor
229 // &#39;call&#39; instructions exectued in JIT code.  We use return addresses to look up
230 // exception and optimization information, and to repatch the call instruction
231 // that is the source of the return address.
232 class ReturnAddressPtr {
233 public:
234     ReturnAddressPtr() { }
235 
236     explicit ReturnAddressPtr(const void* value)
237         : m_value(value)
238     {
239         ASSERT_VALID_CODE_POINTER(m_value);
240     }
241 







242     const void* value() const
243     {
244         return m_value;
245     }
246 
247     void dump(PrintStream&amp; out) const
248     {
249         out.print(RawPointer(m_value));
250     }
251 
252 private:
253     const void* m_value { nullptr };
254 };
255 
256 // MacroAssemblerCodePtr:
257 //
258 // MacroAssemblerCodePtr should be used to wrap pointers to JIT generated code.
259 class MacroAssemblerCodePtrBase {
260 protected:
261     static void dumpWithName(void* executableAddress, void* dataLocation, const char* name, PrintStream&amp; out);
</pre>
<hr />
<pre>
384     bool isDeletedValue() const { return m_value == deletedValue(); }
385 
386     unsigned hash() const { return PtrHash&lt;const void*&gt;::hash(m_value); }
387 
388     static void initialize();
389 
390 private:
391     static const void* emptyValue() { return bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(1)); }
392     static const void* deletedValue() { return bitwise_cast&lt;void*&gt;(static_cast&lt;intptr_t&gt;(2)); }
393 
394     const void* m_value { nullptr };
395 };
396 
397 template&lt;PtrTag tag&gt;
398 struct MacroAssemblerCodePtrHash {
399     static unsigned hash(const MacroAssemblerCodePtr&lt;tag&gt;&amp; ptr) { return ptr.hash(); }
400     static bool equal(const MacroAssemblerCodePtr&lt;tag&gt;&amp; a, const MacroAssemblerCodePtr&lt;tag&gt;&amp; b)
401     {
402         return a == b;
403     }
<span class="line-modified">404     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
405 };
406 
407 // MacroAssemblerCodeRef:
408 //
409 // A reference to a section of JIT generated code.  A CodeRef consists of a
410 // pointer to the code, and a ref pointer to the pool from within which it
411 // was allocated.
412 class MacroAssemblerCodeRefBase {
413 protected:
414     static bool tryToDisassemble(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t, const char* prefix, PrintStream&amp; out);
415     static bool tryToDisassemble(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t, const char* prefix);
416     JS_EXPORT_PRIVATE static CString disassembly(MacroAssemblerCodePtr&lt;DisassemblyPtrTag&gt;, size_t);
417 };
418 
419 template&lt;PtrTag tag&gt;
420 class MacroAssemblerCodeRef : private MacroAssemblerCodeRefBase {
421 private:
422     // This is private because it&#39;s dangerous enough that we want uses of it
423     // to be easy to find - hence the static create method below.
424     explicit MacroAssemblerCodeRef(MacroAssemblerCodePtr&lt;tag&gt; codePtr)
</pre>
</td>
</tr>
</table>
<center><a href="MacroAssemblerARMv7.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerMIPS.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
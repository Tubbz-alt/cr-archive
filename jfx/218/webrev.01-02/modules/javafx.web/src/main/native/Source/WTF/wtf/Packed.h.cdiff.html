<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="OptionSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageBlock.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,13 ---</span>
   */
  
  #pragma once
  
  #include &lt;array&gt;
<span class="line-added">+ #include &lt;wtf/Forward.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/GetPtr.h&gt;</span>
<span class="line-added">+ #include &lt;wtf/HashFunctions.h&gt;</span>
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UnalignedAccess.h&gt;
  
  namespace WTF {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,19 ***</span>
  };
  
  // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
  // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
  // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
<span class="line-modified">! template&lt;typename T, size_t alignment = alignof(T)&gt;</span>
  class PackedAlignedPtr {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static_assert(hasOneBitSet(alignment), &quot;Alignment needs to be power-of-two&quot;);</span>
      static constexpr bool isPackedType = true;
      static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
<span class="line-modified">!     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8&gt;(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) / 8;</span>
<span class="line-modified">!     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8&gt;(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH - alignmentShiftSizeIfProfitable) / 8;</span>
      static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
      static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
      static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
  
      constexpr PackedAlignedPtr()
<span class="line-new-header">--- 101,20 ---</span>
  };
  
  // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
  // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
  // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
<span class="line-modified">! template&lt;typename T, size_t passedAlignment&gt;</span>
  class PackedAlignedPtr {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     static_assert(hasOneBitSet(passedAlignment), &quot;Alignment needs to be power-of-two&quot;);</span>
<span class="line-added">+     static constexpr size_t alignment = passedAlignment;</span>
      static constexpr bool isPackedType = true;
      static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
<span class="line-modified">!     static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) / 8;</span>
<span class="line-modified">!     static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf&lt;8&gt;(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH) - alignmentShiftSizeIfProfitable) / 8;</span>
      static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift &gt; storageSizeWithAlignmentShift;
      static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
      static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
  
      constexpr PackedAlignedPtr()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 161,22 ***</span>
      }
  
      T* operator-&gt;() const { return get(); }
      T&amp; operator*() const { return *get(); }
      bool operator!() const { return !get(); }
      explicit operator bool() const { return get(); }
  
      PackedAlignedPtr&amp; operator=(T* value)
      {
          set(value);
          return *this;
      }
  
      template&lt;class U&gt;
<span class="line-modified">!     T exchange(U&amp;&amp; newValue)</span>
      {
<span class="line-modified">!         T oldValue = get();</span>
          set(std::forward&lt;U&gt;(newValue));
          return oldValue;
      }
  
      void swap(std::nullptr_t) { clear(); }
<span class="line-new-header">--- 165,26 ---</span>
      }
  
      T* operator-&gt;() const { return get(); }
      T&amp; operator*() const { return *get(); }
      bool operator!() const { return !get(); }
<span class="line-added">+ </span>
<span class="line-added">+     // This conversion operator allows implicit conversion to bool but not to other integer types.</span>
<span class="line-added">+     typedef T* (PackedAlignedPtr::*UnspecifiedBoolType);</span>
<span class="line-added">+     operator UnspecifiedBoolType() const { return get() ? &amp;PackedAlignedPtr::m_storage : nullptr; }</span>
      explicit operator bool() const { return get(); }
  
      PackedAlignedPtr&amp; operator=(T* value)
      {
          set(value);
          return *this;
      }
  
      template&lt;class U&gt;
<span class="line-modified">!     T* exchange(U&amp;&amp; newValue)</span>
      {
<span class="line-modified">!         T* oldValue = get();</span>
          set(std::forward&lt;U&gt;(newValue));
          return oldValue;
      }
  
      void swap(std::nullptr_t) { clear(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,19 ***</span>
      }
  
      template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
      void swap(Other&amp; other)
      {
<span class="line-modified">!         T t1 = get();</span>
<span class="line-modified">!         T t2 = other.get();</span>
          set(t2);
          other.set(t1);
      }
  
<span class="line-modified">!     void swap(T&amp; t2)</span>
      {
<span class="line-modified">!         T t1 = get();</span>
          std::swap(t1, t2);
          set(t1);
      }
  
  private:
<span class="line-new-header">--- 195,19 ---</span>
      }
  
      template&lt;typename Other, typename = std::enable_if_t&lt;Other::isPackedType&gt;&gt;
      void swap(Other&amp; other)
      {
<span class="line-modified">!         T* t1 = get();</span>
<span class="line-modified">!         T* t2 = other.get();</span>
          set(t2);
          other.set(t1);
      }
  
<span class="line-modified">!     void swap(T* t2)</span>
      {
<span class="line-modified">!         T* t1 = get();</span>
          std::swap(t1, t2);
          set(t1);
      }
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,15 ***</span>
<span class="line-new-header">--- 217,30 ---</span>
  template&lt;typename T&gt;
  class Packed&lt;T*&gt; : public PackedAlignedPtr&lt;T, 1&gt; {
  public:
      using Base = PackedAlignedPtr&lt;T, 1&gt;;
      using Base::Base;
<span class="line-added">+ </span>
<span class="line-added">+     // Hash table deleted values, which are only constructed and never copied or destroyed.</span>
<span class="line-added">+     Packed(HashTableDeletedValueType) : Base(bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment))) { }</span>
<span class="line-added">+     bool isHashTableDeletedValue() const { return Base::get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(Base::alignment)); }</span>
  };
  
  template&lt;typename T&gt;
  using PackedPtr = Packed&lt;T*&gt;;
  
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ struct GetPtrHelper&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">+     using PtrType = T*;</span>
<span class="line-added">+     static T* getPtr(const PackedPtr&lt;T&gt;&amp; p) { return const_cast&lt;T*&gt;(p.get()); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ struct IsSmartPtr&lt;PackedPtr&lt;T&gt;&gt; {</span>
<span class="line-added">+     static constexpr bool value = true;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  template&lt;typename T&gt;
  struct PackedPtrTraits {
      template&lt;typename U&gt; using RebindTraits = PackedPtrTraits&lt;U&gt;;
  
      using StorageType = PackedPtr&lt;T&gt;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,12 ***</span>
<span class="line-new-header">--- 248,20 ---</span>
      template&lt;class U&gt; static ALWAYS_INLINE T* exchange(StorageType&amp; ptr, U&amp;&amp; newValue) { return ptr.exchange(newValue); }
  
      template&lt;typename Other&gt; static ALWAYS_INLINE void swap(PackedPtr&lt;T&gt;&amp; a, Other&amp; b) { a.swap(b); }
  
      static ALWAYS_INLINE T* unwrap(const StorageType&amp; ptr) { return ptr.get(); }
<span class="line-added">+ </span>
<span class="line-added">+     // We assume that,</span>
<span class="line-added">+     // 1. The alignment is &lt; 4KB. (It is tested by HashTraits).</span>
<span class="line-added">+     // 2. The first page (including nullptr) is never mapped.</span>
<span class="line-added">+     static StorageType hashTableDeletedValue() { return StorageType { bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)) }; }</span>
<span class="line-added">+     static ALWAYS_INLINE bool isHashTableDeletedValue(const StorageType&amp; ptr) { return ptr.get() == bitwise_cast&lt;T*&gt;(static_cast&lt;uintptr_t&gt;(StorageType::alignment)); }</span>
  };
  
<span class="line-added">+ template&lt;typename P&gt; struct DefaultHash&lt;PackedPtr&lt;P&gt;&gt; { using Hash = PtrHash&lt;PackedPtr&lt;P&gt;&gt;; };</span>
<span class="line-added">+ </span>
  } // namespace WTF
  
  using WTF::Packed;
  using WTF::PackedAlignedPtr;
  using WTF::PackedPtr;
</pre>
<center><a href="OptionSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageBlock.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayConventions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayIteratorPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayConventions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 37 // as an unsigned integer, or where the value is greater than  MAX_ARRAY_INDEX
 38 // (specifically, this is only one property - the value 0xFFFFFFFFU as an unsigned 32-bit
 39 // integer) are not considered array indices and will be stored in the JSObject property map.
 40 //
 41 // All properties with a numeric identifier, representable as an unsigned integer i,
 42 // where (i &lt;= MAX_ARRAY_INDEX), are an array index and will be stored in either the
 43 // storage vector or the sparse map. An array index i will be handled in the following
 44 // fashion:
 45 //
 46 //   * Where (i &lt; MIN_SPARSE_ARRAY_INDEX) the value will be stored in the storage vector,
 47 //     unless the array is in SparseMode in which case all properties go into the map.
 48 //   * Where (MIN_SPARSE_ARRAY_INDEX &lt;= i &lt;= MAX_STORAGE_VECTOR_INDEX) the value will either
 49 //     be stored in the storage vector or in the sparse array, depending on the density of
 50 //     data that would be stored in the vector (a vector being used where at least
 51 //     (1 / minDensityMultiplier) of the entries would be populated).
 52 //   * Where (MAX_STORAGE_VECTOR_INDEX &lt; i &lt;= MAX_ARRAY_INDEX) the value will always be stored
 53 //     in the sparse array.
 54 
 55 // Define the maximum storage vector length to be 2^32 / sizeof(JSValue) / 2 to ensure that
 56 // there is no risk of overflow.
<span class="line-modified"> 57 #define MAX_STORAGE_VECTOR_LENGTH (static_cast&lt;unsigned&gt;(IndexingHeader::maximumLength))</span>
 58 
 59 // These values have to be macros to be used in max() and min() without introducing
 60 // a PIC branch in Mach-O binaries, see &lt;rdar://problem/5971391&gt;.
 61 
 62 // If you grow an ArrayStorage array by more than this, then the array will go sparse. Note that we
 63 // could probably make this smaller (it&#39;s large because it used to be conflated with
 64 // MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH).
 65 #define MIN_SPARSE_ARRAY_INDEX 100000U
 66 // If you try to allocate a contiguous array larger than this, then we will allocate an ArrayStorage
 67 // array instead. We allow for an array that occupies 1GB of VM.
 68 #define MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH (1024 * 1024 * 1024 / 8)
 69 #define MAX_STORAGE_VECTOR_INDEX (MAX_STORAGE_VECTOR_LENGTH - 1)
 70 // 0xFFFFFFFF is a bit weird -- is not an array index even though it&#39;s an integer.
 71 #define MAX_ARRAY_INDEX 0xFFFFFFFEU
 72 
 73 static_assert(MIN_SPARSE_ARRAY_INDEX &lt;= MAX_STORAGE_VECTOR_INDEX, &quot;MIN_SPARSE_ARRAY_INDEX must be less than or equal to MAX_STORAGE_VECTOR_INDEX&quot;);
 74 static_assert(MAX_STORAGE_VECTOR_INDEX &lt;= MAX_ARRAY_INDEX, &quot;MAX_STORAGE_VECTOR_INDEX must be less than or equal to MAX_ARRAY_INDEX&quot;);
 75 
 76 // The value BASE_XXX_VECTOR_LEN is the maximum number of vector elements we&#39;ll allocate
 77 // for an array that was created with a sepcified length (e.g. a = new Array(123))
 78 #define BASE_CONTIGUOUS_VECTOR_LEN 3U
 79 #define BASE_CONTIGUOUS_VECTOR_LEN_EMPTY 5U
 80 #define BASE_CONTIGUOUS_VECTOR_LEN_MIN 3U
 81 #define BASE_CONTIGUOUS_VECTOR_LEN_MAX 25U
 82 #define BASE_ARRAY_STORAGE_VECTOR_LEN 4U
 83 
 84 // The upper bound to the size we&#39;ll grow a zero length array when the first element
 85 // is added.
 86 #define FIRST_ARRAY_STORAGE_VECTOR_GROW 4U
 87 
 88 #define MIN_BEYOND_LENGTH_SPARSE_INDEX 1000
 89 
 90 // Our policy for when to use a vector and when to use a sparse map.
 91 // For all array indices under MIN_SPARSE_ARRAY_INDEX, we always use a vector.
 92 // When indices greater than MIN_SPARSE_ARRAY_INDEX are involved, we use a vector
 93 // as long as it is 1/8 full. If more sparse than that, we use a map.
<span class="line-modified"> 94 static const unsigned minDensityMultiplier = 8;</span>
 95 
 96 inline bool isDenseEnoughForVector(unsigned length, unsigned numValues)
 97 {
 98     return length / minDensityMultiplier &lt;= numValues;
 99 }
100 
101 inline bool indexIsSufficientlyBeyondLengthForSparseMap(unsigned i, unsigned length)
102 {
103     return i &gt;= MIN_BEYOND_LENGTH_SPARSE_INDEX &amp;&amp; i &gt; length;
104 }
105 
106 inline IndexingHeader indexingHeaderForArrayStorage(unsigned length, unsigned vectorLength)
107 {
108     IndexingHeader result;
109     result.setPublicLength(length);
110     result.setVectorLength(vectorLength);
111     return result;
112 }
113 
114 inline IndexingHeader baseIndexingHeaderForArrayStorage(unsigned length)
</pre>
</td>
<td>
<hr />
<pre>
 37 // as an unsigned integer, or where the value is greater than  MAX_ARRAY_INDEX
 38 // (specifically, this is only one property - the value 0xFFFFFFFFU as an unsigned 32-bit
 39 // integer) are not considered array indices and will be stored in the JSObject property map.
 40 //
 41 // All properties with a numeric identifier, representable as an unsigned integer i,
 42 // where (i &lt;= MAX_ARRAY_INDEX), are an array index and will be stored in either the
 43 // storage vector or the sparse map. An array index i will be handled in the following
 44 // fashion:
 45 //
 46 //   * Where (i &lt; MIN_SPARSE_ARRAY_INDEX) the value will be stored in the storage vector,
 47 //     unless the array is in SparseMode in which case all properties go into the map.
 48 //   * Where (MIN_SPARSE_ARRAY_INDEX &lt;= i &lt;= MAX_STORAGE_VECTOR_INDEX) the value will either
 49 //     be stored in the storage vector or in the sparse array, depending on the density of
 50 //     data that would be stored in the vector (a vector being used where at least
 51 //     (1 / minDensityMultiplier) of the entries would be populated).
 52 //   * Where (MAX_STORAGE_VECTOR_INDEX &lt; i &lt;= MAX_ARRAY_INDEX) the value will always be stored
 53 //     in the sparse array.
 54 
 55 // Define the maximum storage vector length to be 2^32 / sizeof(JSValue) / 2 to ensure that
 56 // there is no risk of overflow.
<span class="line-modified"> 57 #define MAX_STORAGE_VECTOR_LENGTH IndexingHeader::maximumLength</span>
 58 
 59 // These values have to be macros to be used in max() and min() without introducing
 60 // a PIC branch in Mach-O binaries, see &lt;rdar://problem/5971391&gt;.
 61 
 62 // If you grow an ArrayStorage array by more than this, then the array will go sparse. Note that we
 63 // could probably make this smaller (it&#39;s large because it used to be conflated with
 64 // MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH).
 65 #define MIN_SPARSE_ARRAY_INDEX 100000U
 66 // If you try to allocate a contiguous array larger than this, then we will allocate an ArrayStorage
 67 // array instead. We allow for an array that occupies 1GB of VM.
 68 #define MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH (1024 * 1024 * 1024 / 8)
 69 #define MAX_STORAGE_VECTOR_INDEX (MAX_STORAGE_VECTOR_LENGTH - 1)
 70 // 0xFFFFFFFF is a bit weird -- is not an array index even though it&#39;s an integer.
 71 #define MAX_ARRAY_INDEX 0xFFFFFFFEU
 72 
 73 static_assert(MIN_SPARSE_ARRAY_INDEX &lt;= MAX_STORAGE_VECTOR_INDEX, &quot;MIN_SPARSE_ARRAY_INDEX must be less than or equal to MAX_STORAGE_VECTOR_INDEX&quot;);
 74 static_assert(MAX_STORAGE_VECTOR_INDEX &lt;= MAX_ARRAY_INDEX, &quot;MAX_STORAGE_VECTOR_INDEX must be less than or equal to MAX_ARRAY_INDEX&quot;);
 75 
 76 // The value BASE_XXX_VECTOR_LEN is the maximum number of vector elements we&#39;ll allocate
 77 // for an array that was created with a sepcified length (e.g. a = new Array(123))
 78 #define BASE_CONTIGUOUS_VECTOR_LEN 3U
 79 #define BASE_CONTIGUOUS_VECTOR_LEN_EMPTY 5U
 80 #define BASE_CONTIGUOUS_VECTOR_LEN_MIN 3U
 81 #define BASE_CONTIGUOUS_VECTOR_LEN_MAX 25U
 82 #define BASE_ARRAY_STORAGE_VECTOR_LEN 4U
 83 
 84 // The upper bound to the size we&#39;ll grow a zero length array when the first element
 85 // is added.
 86 #define FIRST_ARRAY_STORAGE_VECTOR_GROW 4U
 87 
 88 #define MIN_BEYOND_LENGTH_SPARSE_INDEX 1000
 89 
 90 // Our policy for when to use a vector and when to use a sparse map.
 91 // For all array indices under MIN_SPARSE_ARRAY_INDEX, we always use a vector.
 92 // When indices greater than MIN_SPARSE_ARRAY_INDEX are involved, we use a vector
 93 // as long as it is 1/8 full. If more sparse than that, we use a map.
<span class="line-modified"> 94 static constexpr unsigned minDensityMultiplier = 8;</span>
 95 
 96 inline bool isDenseEnoughForVector(unsigned length, unsigned numValues)
 97 {
 98     return length / minDensityMultiplier &lt;= numValues;
 99 }
100 
101 inline bool indexIsSufficientlyBeyondLengthForSparseMap(unsigned i, unsigned length)
102 {
103     return i &gt;= MIN_BEYOND_LENGTH_SPARSE_INDEX &amp;&amp; i &gt; length;
104 }
105 
106 inline IndexingHeader indexingHeaderForArrayStorage(unsigned length, unsigned vectorLength)
107 {
108     IndexingHeader result;
109     result.setPublicLength(length);
110     result.setVectorLength(vectorLength);
111     return result;
112 }
113 
114 inline IndexingHeader baseIndexingHeaderForArrayStorage(unsigned length)
</pre>
</td>
</tr>
</table>
<center><a href="ArrayConventions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayIteratorPrototype.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2018 Apple Inc. All rights reserved.
  6  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;HTMLTextFormControlElement.h&quot;
 27 
 28 #include &quot;AXObjectCache.h&quot;
 29 #include &quot;CSSPrimitiveValueMappings.h&quot;
 30 #include &quot;ChromeClient.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Editing.h&quot;
 33 #include &quot;Event.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameSelection.h&quot;
 37 #include &quot;HTMLBRElement.h&quot;
 38 #include &quot;HTMLFormElement.h&quot;
 39 #include &quot;HTMLInputElement.h&quot;
 40 #include &quot;HTMLNames.h&quot;
 41 #include &quot;HTMLParserIdioms.h&quot;
 42 #include &quot;LayoutDisallowedScope.h&quot;
 43 #include &quot;Logging.h&quot;
 44 #include &quot;NodeTraversal.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;RenderTextControlSingleLine.h&quot;
 47 #include &quot;RenderTheme.h&quot;
 48 #include &quot;ScriptDisallowedScope.h&quot;
 49 #include &quot;ShadowRoot.h&quot;
 50 #include &quot;Text.h&quot;
 51 #include &quot;TextControlInnerElements.h&quot;
 52 #include &lt;wtf/IsoMallocInlines.h&gt;
 53 #include &lt;wtf/text/StringBuilder.h&gt;
 54 
 55 namespace WebCore {
 56 
 57 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLTextFormControlElement);
 58 
 59 using namespace HTMLNames;
 60 
 61 static Position positionForIndex(TextControlInnerTextElement*, unsigned);
 62 
 63 HTMLTextFormControlElement::HTMLTextFormControlElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 64     : HTMLFormControlElementWithState(tagName, document, form)
 65     , m_cachedSelectionDirection(SelectionHasNoDirection)
 66     , m_lastChangeWasUserEdit(false)
 67     , m_isPlaceholderVisible(false)
<a name="1" id="anc1"></a><span class="line-added"> 68     , m_canShowPlaceholder(true)</span>
 69     , m_cachedSelectionStart(-1)
 70     , m_cachedSelectionEnd(-1)
 71 {
 72 }
 73 
 74 HTMLTextFormControlElement::~HTMLTextFormControlElement() = default;
 75 
 76 bool HTMLTextFormControlElement::childShouldCreateRenderer(const Node&amp; child) const
 77 {
 78     // FIXME: We shouldn&#39;t force the pseudo elements down into the shadow, but
 79     // this perserves the current behavior of WebKit.
 80     if (child.isPseudoElement())
 81         return HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 82     return hasShadowRootParent(child) &amp;&amp; HTMLFormControlElementWithState::childShouldCreateRenderer(child);
 83 }
 84 
 85 Node::InsertedIntoAncestorResult HTMLTextFormControlElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 86 {
 87     InsertedIntoAncestorResult InsertedIntoAncestorResult = HTMLFormControlElementWithState::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 88     if (insertionType.connectedToDocument) {
 89         String initialValue = value();
 90         setTextAsOfLastFormControlChangeEvent(initialValue.isNull() ? emptyString() : initialValue);
 91     }
 92     return InsertedIntoAncestorResult;
 93 }
 94 
 95 void HTMLTextFormControlElement::dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection direction)
 96 {
 97     if (supportsPlaceholder())
 98         updatePlaceholderVisibility();
 99     handleFocusEvent(oldFocusedElement.get(), direction);
100     HTMLFormControlElementWithState::dispatchFocusEvent(WTFMove(oldFocusedElement), direction);
101 }
102 
103 void HTMLTextFormControlElement::dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement)
104 {
105     if (supportsPlaceholder())
106         updatePlaceholderVisibility();
107     // Match the order in Document::setFocusedElement.
108     handleBlurEvent();
109     HTMLFormControlElementWithState::dispatchBlurEvent(WTFMove(newFocusedElement));
110 }
111 
112 void HTMLTextFormControlElement::didEditInnerTextValue()
113 {
114     if (!renderer() || !isTextField())
115         return;
116 
117     LOG(Editing, &quot;HTMLTextFormControlElement %p didEditInnerTextValue&quot;, this);
118 
119     m_lastChangeWasUserEdit = true;
120     subtreeHasChanged();
121 }
122 
123 void HTMLTextFormControlElement::forwardEvent(Event&amp; event)
124 {
125     if (event.type() == eventNames().blurEvent || event.type() == eventNames().focusEvent)
126         return;
127     innerTextElement()-&gt;defaultEventHandler(event);
128 }
129 
130 String HTMLTextFormControlElement::strippedPlaceholder() const
131 {
132     // According to the HTML5 specification, we need to remove CR and LF from
133     // the attribute value.
134     const AtomString&amp; attributeValue = attributeWithoutSynchronization(placeholderAttr);
135     if (!attributeValue.contains(newlineCharacter) &amp;&amp; !attributeValue.contains(carriageReturn))
136         return attributeValue;
137 
138     StringBuilder stripped;
139     unsigned length = attributeValue.length();
140     stripped.reserveCapacity(length);
141     for (unsigned i = 0; i &lt; length; ++i) {
142         UChar character = attributeValue[i];
143         if (character == newlineCharacter || character == carriageReturn)
144             continue;
145         stripped.append(character);
146     }
147     return stripped.toString();
148 }
149 
150 static bool isNotLineBreak(UChar ch) { return ch != newlineCharacter &amp;&amp; ch != carriageReturn; }
151 
152 bool HTMLTextFormControlElement::isPlaceholderEmpty() const
153 {
154     const AtomString&amp; attributeValue = attributeWithoutSynchronization(placeholderAttr);
155     return attributeValue.string().find(isNotLineBreak) == notFound;
156 }
157 
158 bool HTMLTextFormControlElement::placeholderShouldBeVisible() const
159 {
160     // This function is used by the style resolver to match the :placeholder-shown pseudo class.
161     // Since it is used for styling, it must not use any value depending on the style.
<a name="2" id="anc2"></a><span class="line-modified">162     return supportsPlaceholder() &amp;&amp; isEmptyValue() &amp;&amp; !isPlaceholderEmpty() &amp;&amp; m_canShowPlaceholder;</span>
163 }
164 
165 void HTMLTextFormControlElement::updatePlaceholderVisibility()
166 {
167     bool placeHolderWasVisible = m_isPlaceholderVisible;
168     m_isPlaceholderVisible = placeholderShouldBeVisible();
169 
170     if (placeHolderWasVisible == m_isPlaceholderVisible)
171         return;
172 
173     invalidateStyleForSubtree();
174 }
175 
<a name="3" id="anc3"></a><span class="line-added">176 void HTMLTextFormControlElement::setCanShowPlaceholder(bool canShowPlaceholder)</span>
<span class="line-added">177 {</span>
<span class="line-added">178     m_canShowPlaceholder = canShowPlaceholder;</span>
<span class="line-added">179     updatePlaceholderVisibility();</span>
<span class="line-added">180 }</span>
<span class="line-added">181 </span>
182 void HTMLTextFormControlElement::setSelectionStart(int start)
183 {
184     setSelectionRange(start, std::max(start, selectionEnd()), selectionDirection());
185 }
186 
187 void HTMLTextFormControlElement::setSelectionEnd(int end)
188 {
189     setSelectionRange(std::min(end, selectionStart()), end, selectionDirection());
190 }
191 
192 void HTMLTextFormControlElement::setSelectionDirection(const String&amp; direction)
193 {
194     setSelectionRange(selectionStart(), selectionEnd(), direction);
195 }
196 
197 void HTMLTextFormControlElement::select(SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
198 {
199     setSelectionRange(0, std::numeric_limits&lt;int&gt;::max(), SelectionHasNoDirection, revealMode, intent);
200 }
201 
202 String HTMLTextFormControlElement::selectedText() const
203 {
204     if (!isTextField())
205         return String();
206     return value().substring(selectionStart(), selectionEnd() - selectionStart());
207 }
208 
209 void HTMLTextFormControlElement::dispatchFormControlChangeEvent()
210 {
211     if (m_textAsOfLastFormControlChangeEvent != value()) {
212         dispatchChangeEvent();
213         setTextAsOfLastFormControlChangeEvent(value());
214     }
215     setChangedSinceLastFormControlChangeEvent(false);
216 }
217 
218 ExceptionOr&lt;void&gt; HTMLTextFormControlElement::setRangeText(const String&amp; replacement)
219 {
220     return setRangeText(replacement, selectionStart(), selectionEnd(), String());
221 }
222 
223 ExceptionOr&lt;void&gt; HTMLTextFormControlElement::setRangeText(const String&amp; replacement, unsigned start, unsigned end, const String&amp; selectionMode)
224 {
225     if (start &gt; end)
226         return Exception { IndexSizeError };
227 
228     String text = innerTextValue();
229     unsigned textLength = text.length();
230     unsigned replacementLength = replacement.length();
231     unsigned newSelectionStart = selectionStart();
232     unsigned newSelectionEnd = selectionEnd();
233 
234     start = std::min(start, textLength);
235     end = std::min(end, textLength);
236 
237     if (start &lt; end)
238         text.replace(start, end - start, replacement);
239     else
240         text.insert(replacement, start);
241 
242     setInnerTextValue(text);
243 
244     // FIXME: What should happen to the value (as in value()) if there&#39;s no renderer?
245     if (!renderer())
246         return { };
247 
248     subtreeHasChanged();
249 
250     if (equalLettersIgnoringASCIICase(selectionMode, &quot;select&quot;)) {
251         newSelectionStart = start;
252         newSelectionEnd = start + replacementLength;
253     } else if (equalLettersIgnoringASCIICase(selectionMode, &quot;start&quot;))
254         newSelectionStart = newSelectionEnd = start;
255     else if (equalLettersIgnoringASCIICase(selectionMode, &quot;end&quot;))
256         newSelectionStart = newSelectionEnd = start + replacementLength;
257     else {
258         // Default is &quot;preserve&quot;.
259         long delta = replacementLength - (end - start);
260 
261         if (newSelectionStart &gt; end)
262             newSelectionStart += delta;
263         else if (newSelectionStart &gt; start)
264             newSelectionStart = start;
265 
266         if (newSelectionEnd &gt; end)
267             newSelectionEnd += delta;
268         else if (newSelectionEnd &gt; start)
269             newSelectionEnd = start + replacementLength;
270     }
271 
272     setSelectionRange(newSelectionStart, newSelectionEnd, SelectionHasNoDirection);
273 
274     return { };
275 }
276 
277 void HTMLTextFormControlElement::setSelectionRange(int start, int end, const String&amp; directionString, const AXTextStateChangeIntent&amp; intent)
278 {
279     TextFieldSelectionDirection direction = SelectionHasNoDirection;
280     if (directionString == &quot;forward&quot;)
281         direction = SelectionHasForwardDirection;
282     else if (directionString == &quot;backward&quot;)
283         direction = SelectionHasBackwardDirection;
284 
285     return setSelectionRange(start, end, direction, SelectionRevealMode::DoNotReveal, intent);
286 }
287 
288 void HTMLTextFormControlElement::setSelectionRange(int start, int end, TextFieldSelectionDirection direction, SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
289 {
290     if (!isTextField())
291         return;
292 
293     end = std::max(end, 0);
294     start = std::min(std::max(start, 0), end);
295 
296     auto innerText = innerTextElement();
297     bool hasFocus = document().focusedElement() == this;
298     if (!hasFocus &amp;&amp; innerText) {
<a name="4" id="anc4"></a><span class="line-added">299         if (!isConnected()) {</span>
<span class="line-added">300             cacheSelection(start, end, direction);</span>
<span class="line-added">301             return;</span>
<span class="line-added">302         }</span>
<span class="line-added">303 </span>
304         // FIXME: Removing this synchronous layout requires fixing setSelectionWithoutUpdatingAppearance not needing up-to-date style.
305         document().updateLayoutIgnorePendingStylesheets();
306 
<a name="5" id="anc5"></a><span class="line-added">307         if (!isTextField())</span>
<span class="line-added">308             return;</span>
<span class="line-added">309 </span>
310         // Double-check the state of innerTextElement after the layout.
311         innerText = innerTextElement();
312         auto* rendererTextControl = renderer();
313 
314         if (innerText &amp;&amp; rendererTextControl) {
315             if (rendererTextControl-&gt;style().visibility() == Visibility::Hidden || !innerText-&gt;renderBox() || !innerText-&gt;renderBox()-&gt;height()) {
316                 cacheSelection(start, end, direction);
317                 return;
318             }
319         }
320     }
321 
322     Position startPosition = positionForIndex(innerText.get(), start);
323     Position endPosition;
324     if (start == end)
325         endPosition = startPosition;
326     else {
327         if (direction == SelectionHasBackwardDirection) {
328             endPosition = startPosition;
329             startPosition = positionForIndex(innerText.get(), end);
330         } else
331             endPosition = positionForIndex(innerText.get(), end);
332     }
333 
334     if (RefPtr&lt;Frame&gt; frame = document().frame())
335         frame-&gt;selection().moveWithoutValidationTo(startPosition, endPosition, direction != SelectionHasNoDirection, !hasFocus, revealMode, intent);
336 }
337 
338 int HTMLTextFormControlElement::indexForVisiblePosition(const VisiblePosition&amp; position) const
339 {
340     auto innerText = innerTextElement();
341     if (!innerText || !innerText-&gt;contains(position.deepEquivalent().anchorNode()))
342         return 0;
343     unsigned index = indexForPosition(position.deepEquivalent());
344     ASSERT(VisiblePosition(positionForIndex(innerTextElement().get(), index)) == position);
345     return index;
346 }
347 
348 VisiblePosition HTMLTextFormControlElement::visiblePositionForIndex(int index) const
349 {
350     VisiblePosition position = positionForIndex(innerTextElement().get(), index);
351     ASSERT(indexForVisiblePosition(position) == index);
352     return position;
353 }
354 
355 int HTMLTextFormControlElement::selectionStart() const
356 {
357     if (!isTextField())
358         return 0;
359     if (document().focusedElement() != this &amp;&amp; hasCachedSelection())
360         return m_cachedSelectionStart;
361 
362     return computeSelectionStart();
363 }
364 
365 int HTMLTextFormControlElement::computeSelectionStart() const
366 {
367     ASSERT(isTextField());
368     RefPtr&lt;Frame&gt; frame = document().frame();
369     if (!frame)
370         return 0;
371 
372     return indexForPosition(frame-&gt;selection().selection().start());
373 }
374 
375 int HTMLTextFormControlElement::selectionEnd() const
376 {
377     if (!isTextField())
378         return 0;
379     if (document().focusedElement() != this &amp;&amp; hasCachedSelection())
380         return m_cachedSelectionEnd;
381     return computeSelectionEnd();
382 }
383 
384 int HTMLTextFormControlElement::computeSelectionEnd() const
385 {
386     ASSERT(isTextField());
387     RefPtr&lt;Frame&gt; frame = document().frame();
388     if (!frame)
389         return 0;
390 
391     return indexForPosition(frame-&gt;selection().selection().end());
392 }
393 
394 static const AtomString&amp; directionString(TextFieldSelectionDirection direction)
395 {
396     static NeverDestroyed&lt;const AtomString&gt; none(&quot;none&quot;, AtomString::ConstructFromLiteral);
397     static NeverDestroyed&lt;const AtomString&gt; forward(&quot;forward&quot;, AtomString::ConstructFromLiteral);
398     static NeverDestroyed&lt;const AtomString&gt; backward(&quot;backward&quot;, AtomString::ConstructFromLiteral);
399 
400     switch (direction) {
401     case SelectionHasNoDirection:
402         return none;
403     case SelectionHasForwardDirection:
404         return forward;
405     case SelectionHasBackwardDirection:
406         return backward;
407     }
408 
409     ASSERT_NOT_REACHED();
410     return none;
411 }
412 
413 const AtomString&amp; HTMLTextFormControlElement::selectionDirection() const
414 {
415     if (!isTextField())
416         return directionString(SelectionHasNoDirection);
417     if (document().focusedElement() != this &amp;&amp; hasCachedSelection())
418         return directionString(cachedSelectionDirection());
419 
420     return directionString(computeSelectionDirection());
421 }
422 
423 TextFieldSelectionDirection HTMLTextFormControlElement::computeSelectionDirection() const
424 {
425     ASSERT(isTextField());
426     RefPtr&lt;Frame&gt; frame = document().frame();
427     if (!frame)
428         return SelectionHasNoDirection;
429 
430     const VisibleSelection&amp; selection = frame-&gt;selection().selection();
431     return selection.isDirectional() ? (selection.isBaseFirst() ? SelectionHasForwardDirection : SelectionHasBackwardDirection) : SelectionHasNoDirection;
432 }
433 
434 static inline void setContainerAndOffsetForRange(Node* node, int offset, Node*&amp; containerNode, int&amp; offsetInContainer)
435 {
436     if (node-&gt;isTextNode()) {
437         containerNode = node;
438         offsetInContainer = offset;
439     } else {
440         containerNode = node-&gt;parentNode();
441         offsetInContainer = node-&gt;computeNodeIndex() + offset;
442     }
443 }
444 
445 RefPtr&lt;Range&gt; HTMLTextFormControlElement::selection() const
446 {
447     if (!renderer() || !isTextField() || !hasCachedSelection())
448         return nullptr;
449 
450     int start = m_cachedSelectionStart;
451     int end = m_cachedSelectionEnd;
452 
453     ASSERT(start &lt;= end);
454     auto innerText = innerTextElement();
455     if (!innerText)
456         return nullptr;
457 
458     if (!innerText-&gt;firstChild())
459         return Range::create(document(), innerText, 0, innerText, 0);
460 
461     int offset = 0;
462     Node* startNode = nullptr;
463     Node* endNode = nullptr;
464     for (RefPtr&lt;Node&gt; node = innerText-&gt;firstChild(); node; node = NodeTraversal::next(*node, innerText.get())) {
465         ASSERT(!node-&gt;firstChild());
466         ASSERT(node-&gt;isTextNode() || node-&gt;hasTagName(brTag));
467         int length = node-&gt;isTextNode() ? lastOffsetInNode(node.get()) : 1;
468 
469         if (offset &lt;= start &amp;&amp; start &lt;= offset + length)
470             setContainerAndOffsetForRange(node.get(), start - offset, startNode, start);
471 
472         if (offset &lt;= end &amp;&amp; end &lt;= offset + length) {
473             setContainerAndOffsetForRange(node.get(), end - offset, endNode, end);
474             break;
475         }
476 
477         offset += length;
478     }
479 
480     if (!startNode || !endNode)
481         return nullptr;
482 
483     return Range::create(document(), startNode, start, endNode, end);
484 }
485 
486 void HTMLTextFormControlElement::restoreCachedSelection(SelectionRevealMode revealMode, const AXTextStateChangeIntent&amp; intent)
487 {
488     setSelectionRange(m_cachedSelectionStart, m_cachedSelectionEnd, cachedSelectionDirection(), revealMode, intent);
489 }
490 
491 void HTMLTextFormControlElement::selectionChanged(bool shouldFireSelectEvent)
492 {
493     if (!isTextField())
494         return;
495 
496     // FIXME: Don&#39;t re-compute selection start and end if this function was called inside setSelectionRange.
497     // selectionStart() or selectionEnd() will return cached selection when this node doesn&#39;t have focus
498     cacheSelection(computeSelectionStart(), computeSelectionEnd(), computeSelectionDirection());
499 
500     if (shouldFireSelectEvent &amp;&amp; m_cachedSelectionStart != m_cachedSelectionEnd)
501         dispatchEvent(Event::create(eventNames().selectEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
502 }
503 
504 void HTMLTextFormControlElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
505 {
506     if (name == placeholderAttr) {
507         updatePlaceholderText();
508         updatePlaceholderVisibility();
509     } else
510         HTMLFormControlElementWithState::parseAttribute(name, value);
511 }
512 
513 void HTMLTextFormControlElement::disabledStateChanged()
514 {
515     HTMLFormControlElementWithState::disabledStateChanged();
516     updateInnerTextElementEditability();
517 }
518 
519 void HTMLTextFormControlElement::readOnlyStateChanged()
520 {
521     HTMLFormControlElementWithState::readOnlyStateChanged();
522     updateInnerTextElementEditability();
523 }
524 
525 bool HTMLTextFormControlElement::isInnerTextElementEditable() const
526 {
527     return !isDisabledOrReadOnly();
528 }
529 
530 void HTMLTextFormControlElement::updateInnerTextElementEditability()
531 {
532     if (auto innerText = innerTextElement()) {
533         auto value = isInnerTextElementEditable() ? AtomString { &quot;plaintext-only&quot;, AtomString::ConstructFromLiteral } : AtomString { &quot;false&quot;, AtomString::ConstructFromLiteral };
534         innerText-&gt;setAttributeWithoutSynchronization(contenteditableAttr, value);
535     }
536 }
537 
538 bool HTMLTextFormControlElement::lastChangeWasUserEdit() const
539 {
540     if (!isTextField())
541         return false;
542     return m_lastChangeWasUserEdit;
543 }
544 
545 static void stripTrailingNewline(StringBuilder&amp; result)
546 {
547     // Remove one trailing newline; there&#39;s always one that&#39;s collapsed out by rendering.
548     size_t size = result.length();
549     if (size &amp;&amp; result[size - 1] == newlineCharacter)
550         result.resize(size - 1);
551 }
552 
553 static String innerTextValueFrom(TextControlInnerTextElement&amp; innerText)
554 {
555     StringBuilder result;
556     for (RefPtr&lt;Node&gt; node = innerText.firstChild(); node; node = NodeTraversal::next(*node, &amp;innerText)) {
557         if (is&lt;HTMLBRElement&gt;(*node))
558             result.append(newlineCharacter);
559         else if (is&lt;Text&gt;(*node))
560             result.append(downcast&lt;Text&gt;(*node).data());
561     }
562     stripTrailingNewline(result);
563     return result.toString();
564 }
565 
566 void HTMLTextFormControlElement::setInnerTextValue(const String&amp; value)
567 {
568     LayoutDisallowedScope layoutDisallowedScope(LayoutDisallowedScope::Reason::PerformanceOptimization);
569     auto innerText = innerTextElement();
570     if (!innerText)
571         return;
572 
573     ASSERT(isTextField());
574     String previousValue = innerTextValueFrom(*innerText);
575     bool textIsChanged = value != previousValue;
576     if (textIsChanged || !innerText-&gt;hasChildNodes()) {
577 #if ENABLE(ACCESSIBILITY) &amp;&amp; !PLATFORM(COCOA)
578         if (textIsChanged &amp;&amp; renderer()) {
579             if (AXObjectCache* cache = document().existingAXObjectCache())
580                 cache-&gt;postNotification(this, AXObjectCache::AXValueChanged, TargetObservableParent);
581         }
582 #endif
583 
584         {
585             // Events dispatched on the inner text element cannot execute arbitrary author scripts.
586             ScriptDisallowedScope::EventAllowedScope allowedScope(*userAgentShadowRoot());
587 
588             innerText-&gt;setInnerText(value);
589 
590             if (value.endsWith(&#39;\n&#39;) || value.endsWith(&#39;\r&#39;))
591                 innerText-&gt;appendChild(HTMLBRElement::create(document()));
592         }
593 
594 #if ENABLE(ACCESSIBILITY) &amp;&amp; PLATFORM(COCOA)
595         if (textIsChanged &amp;&amp; renderer()) {
596             if (AXObjectCache* cache = document().existingAXObjectCache())
597                 cache-&gt;deferTextReplacementNotificationForTextControl(*this, previousValue);
598         }
599 #endif
600     }
601 
602     setFormControlValueMatchesRenderer(true);
603 }
604 
605 String HTMLTextFormControlElement::innerTextValue() const
606 {
607     auto innerText = innerTextElement();
608     return innerText ? innerTextValueFrom(*innerText) : emptyString();
609 }
610 
611 static Position positionForIndex(TextControlInnerTextElement* innerText, unsigned index)
612 {
613     unsigned remainingCharactersToMoveForward = index;
614     RefPtr&lt;Node&gt; lastBrOrText = innerText;
615     for (RefPtr&lt;Node&gt; node = innerText; node; node = NodeTraversal::next(*node, innerText)) {
616         if (node-&gt;hasTagName(brTag)) {
617             if (!remainingCharactersToMoveForward)
618                 return positionBeforeNode(node.get());
619             remainingCharactersToMoveForward--;
620             lastBrOrText = node;
621         } else if (is&lt;Text&gt;(*node)) {
622             Text&amp; text = downcast&lt;Text&gt;(*node);
623             if (remainingCharactersToMoveForward &lt; text.length())
624                 return Position(&amp;text, remainingCharactersToMoveForward);
625             remainingCharactersToMoveForward -= text.length();
626             lastBrOrText = node;
627         }
628     }
629     return lastPositionInOrAfterNode(lastBrOrText.get());
630 }
631 
632 unsigned HTMLTextFormControlElement::indexForPosition(const Position&amp; passedPosition) const
633 {
634     auto innerText = innerTextElement();
635     if (!innerText || !innerText-&gt;contains(passedPosition.anchorNode()) || passedPosition.isNull())
636         return 0;
637 
638     if (positionBeforeNode(innerText.get()) == passedPosition)
639         return 0;
640 
641     unsigned index = 0;
642     RefPtr&lt;Node&gt; startNode = passedPosition.computeNodeBeforePosition();
643     if (!startNode)
644         startNode = passedPosition.containerNode();
645     ASSERT(startNode);
646     ASSERT(innerText-&gt;contains(startNode.get()));
647 
648     for (RefPtr&lt;Node&gt; node = startNode; node; node = NodeTraversal::previous(*node, innerText.get())) {
649         if (is&lt;Text&gt;(*node)) {
650             unsigned length = downcast&lt;Text&gt;(*node).length();
651             if (node == passedPosition.containerNode())
652                 index += std::min&lt;unsigned&gt;(length, passedPosition.offsetInContainerNode());
653             else
654                 index += length;
655         } else if (is&lt;HTMLBRElement&gt;(*node))
656             ++index;
657     }
658 
659     unsigned length = innerTextValue().length();
660     index = std::min(index, length); // FIXME: We shouldn&#39;t have to call innerTextValue() just to ignore the last LF. See finishText.
<a name="6" id="anc6"></a><span class="line-modified">661 #if 0</span>
<span class="line-added">662     // FIXME: This assertion code was never built, has bit rotted, and needs to be fixed before it can be enabled:</span>
<span class="line-added">663     // https://bugs.webkit.org/show_bug.cgi?id=205706.</span>
<span class="line-added">664 #if ASSERT_ENABLED</span>
665     VisiblePosition visiblePosition = passedPosition;
666     unsigned indexComputedByVisiblePosition = 0;
667     if (visiblePosition.isNotNull())
668         indexComputedByVisiblePosition = WebCore::indexForVisiblePosition(innerText, visiblePosition, false /* forSelectionPreservation */);
669     ASSERT(index == indexComputedByVisiblePosition);
<a name="7" id="anc7"></a><span class="line-added">670 #endif</span>
671 #endif
672     return index;
673 }
674 
675 #if PLATFORM(IOS_FAMILY)
676 void HTMLTextFormControlElement::hidePlaceholder()
677 {
678     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
679         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueHidden, true);
680 }
681 
682 void HTMLTextFormControlElement::showPlaceholderIfNecessary()
683 {
684     if (RefPtr&lt;HTMLElement&gt; placeholder = placeholderElement())
685         placeholder-&gt;setInlineStyleProperty(CSSPropertyVisibility, CSSValueVisible, true);
686 }
687 #endif
688 
689 static void getNextSoftBreak(RootInlineBox*&amp; line, Node*&amp; breakNode, unsigned&amp; breakOffset)
690 {
691     RootInlineBox* next;
692     for (; line; line = next) {
693         next = line-&gt;nextRootBox();
694         if (next &amp;&amp; !line-&gt;endsWithBreak()) {
695             ASSERT(line-&gt;lineBreakObj());
696             breakNode = line-&gt;lineBreakObj()-&gt;node();
697             breakOffset = line-&gt;lineBreakPos();
698             line = next;
699             return;
700         }
701     }
702     breakNode = 0;
703     breakOffset = 0;
704 }
705 
706 String HTMLTextFormControlElement::valueWithHardLineBreaks() const
707 {
708     // FIXME: It&#39;s not acceptable to ignore the HardWrap setting when there is no renderer.
709     // While we have no evidence this has ever been a practical problem, it would be best to fix it some day.
710     if (!isTextField())
711         return value();
712 
713     auto innerText = innerTextElement();
714     if (!innerText)
715         return value();
716 
717     RenderTextControlInnerBlock* renderer = innerText-&gt;renderer();
718     if (!renderer)
719         return value();
720 
721     Node* breakNode;
722     unsigned breakOffset;
723     RootInlineBox* line = renderer-&gt;firstRootBox();
724     if (!line)
725         return value();
726 
727     getNextSoftBreak(line, breakNode, breakOffset);
728 
729     StringBuilder result;
730     for (RefPtr&lt;Node&gt; node = innerText-&gt;firstChild(); node; node = NodeTraversal::next(*node, innerText.get())) {
731         if (is&lt;HTMLBRElement&gt;(*node))
732             result.append(newlineCharacter);
733         else if (is&lt;Text&gt;(*node)) {
734             String data = downcast&lt;Text&gt;(*node).data();
735             unsigned length = data.length();
736             unsigned position = 0;
737             while (breakNode == node &amp;&amp; breakOffset &lt;= length) {
738                 if (breakOffset &gt; position) {
739                     result.appendSubstring(data, position, breakOffset - position);
740                     position = breakOffset;
741                     result.append(newlineCharacter);
742                 }
743                 getNextSoftBreak(line, breakNode, breakOffset);
744             }
745             result.appendSubstring(data, position, length - position);
746         }
747         while (breakNode == node)
748             getNextSoftBreak(line, breakNode, breakOffset);
749     }
750     stripTrailingNewline(result);
751     return result.toString();
752 }
753 
754 HTMLTextFormControlElement* enclosingTextFormControl(const Position&amp; position)
755 {
756     ASSERT(position.isNull() || position.anchorType() == Position::PositionIsOffsetInAnchor
757         || position.containerNode() || !position.anchorNode()-&gt;shadowHost()
758         || hasShadowRootParent(*position.anchorNode()));
759 
760     RefPtr&lt;Node&gt; container = position.containerNode();
761     if (!container)
762         return nullptr;
763     RefPtr&lt;Element&gt; ancestor = container-&gt;shadowHost();
764     return ancestor &amp;&amp; ancestor-&gt;isTextField() ? downcast&lt;HTMLTextFormControlElement&gt;(ancestor.get()) : nullptr;
765 }
766 
767 static const Element* parentHTMLElement(const Element* element)
768 {
769     while (element) {
770         element = element-&gt;parentElement();
771         if (element &amp;&amp; element-&gt;isHTMLElement())
772             return element;
773     }
774     return 0;
775 }
776 
777 String HTMLTextFormControlElement::directionForFormData() const
778 {
779     for (const Element* element = this; element; element = parentHTMLElement(element)) {
780         const AtomString&amp; dirAttributeValue = element-&gt;attributeWithoutSynchronization(dirAttr);
781         if (dirAttributeValue.isNull())
782             continue;
783 
784         if (equalLettersIgnoringASCIICase(dirAttributeValue, &quot;rtl&quot;) || equalLettersIgnoringASCIICase(dirAttributeValue, &quot;ltr&quot;))
785             return dirAttributeValue;
786 
787         if (equalLettersIgnoringASCIICase(dirAttributeValue, &quot;auto&quot;)) {
788             bool isAuto;
789             TextDirection textDirection = static_cast&lt;const HTMLElement*&gt;(element)-&gt;directionalityIfhasDirAutoAttribute(isAuto);
790             return textDirection == TextDirection::RTL ? &quot;rtl&quot; : &quot;ltr&quot;;
791         }
792     }
793 
794     return &quot;ltr&quot;;
795 }
796 
797 ExceptionOr&lt;void&gt; HTMLTextFormControlElement::setMaxLength(int maxLength)
798 {
799     if (maxLength &lt; 0 || (m_minLength &gt;= 0 &amp;&amp; maxLength &lt; m_minLength))
800         return Exception { IndexSizeError };
801     setIntegralAttribute(maxlengthAttr, maxLength);
802     return { };
803 }
804 
805 ExceptionOr&lt;void&gt; HTMLTextFormControlElement::setMinLength(int minLength)
806 {
807     if (minLength &lt; 0 || (m_maxLength &gt;= 0 &amp;&amp; minLength &gt; m_maxLength))
808         return Exception { IndexSizeError };
809     setIntegralAttribute(minlengthAttr, minLength);
810     return { };
811 }
812 
813 void HTMLTextFormControlElement::adjustInnerTextStyle(const RenderStyle&amp; parentStyle, RenderStyle&amp; textBlockStyle) const
814 {
815     // The inner block, if present, always has its direction set to LTR,
816     // so we need to inherit the direction and unicode-bidi style from the element.
817     textBlockStyle.setDirection(parentStyle.direction());
818     textBlockStyle.setUnicodeBidi(parentStyle.unicodeBidi());
819 
820     if (auto innerText = innerTextElement()) {
821         if (const StyleProperties* properties = innerText-&gt;presentationAttributeStyle()) {
822             RefPtr&lt;CSSValue&gt; value = properties-&gt;getPropertyCSSValue(CSSPropertyWebkitUserModify);
823             if (is&lt;CSSPrimitiveValue&gt;(value))
824                 textBlockStyle.setUserModify(downcast&lt;CSSPrimitiveValue&gt;(*value));
825         }
826     }
827 
828     if (isDisabledFormControl())
829         textBlockStyle.setColor(RenderTheme::singleton().disabledTextColor(textBlockStyle.visitedDependentColorWithColorFilter(CSSPropertyColor), parentStyle.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor)));
830 #if PLATFORM(IOS_FAMILY)
831     if (textBlockStyle.textSecurity() != TextSecurity::None &amp;&amp; !textBlockStyle.isLeftToRightDirection()) {
832         // Preserve the alignment but force the direction to LTR so that the last-typed, unmasked character
833         // (which cannot have RTL directionality) will appear to the right of the masked characters. See &lt;rdar://problem/7024375&gt;.
834 
835         switch (textBlockStyle.textAlign()) {
836         case TextAlignMode::Start:
837         case TextAlignMode::Justify:
838             textBlockStyle.setTextAlign(TextAlignMode::Right);
839             break;
840         case TextAlignMode::End:
841             textBlockStyle.setTextAlign(TextAlignMode::Left);
842             break;
843         case TextAlignMode::Left:
844         case TextAlignMode::Right:
845         case TextAlignMode::Center:
846         case TextAlignMode::WebKitLeft:
847         case TextAlignMode::WebKitRight:
848         case TextAlignMode::WebKitCenter:
849             break;
850         }
851 
852         textBlockStyle.setDirection(TextDirection::LTR);
853     }
854 #endif
855 }
856 
857 } // namespace Webcore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
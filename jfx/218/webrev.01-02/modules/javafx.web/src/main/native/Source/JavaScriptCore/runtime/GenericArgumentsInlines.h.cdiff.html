<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GenericArguments.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericOffset.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/GenericArgumentsInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,14 ***</span>
      if (thisObject-&gt;m_modifiedArgumentsDescriptor)
          visitor.markAuxiliary(thisObject-&gt;m_modifiedArgumentsDescriptor.getUnsafe());
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName ident, PropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (!thisObject-&gt;overrodeThings()) {
          if (ident == vm.propertyNames-&gt;length) {
              slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), jsNumber(thisObject-&gt;internalLength()));
              return true;
<span class="line-new-header">--- 40,14 ---</span>
      if (thisObject-&gt;m_modifiedArgumentsDescriptor)
          visitor.markAuxiliary(thisObject-&gt;m_modifiedArgumentsDescriptor.getUnsafe());
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName ident, PropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      if (!thisObject-&gt;overrodeThings()) {
          if (ident == vm.propertyNames-&gt;length) {
              slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), jsNumber(thisObject-&gt;internalLength()));
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,26 ***</span>
              return true;
          }
      }
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!         return GenericArguments&lt;Type&gt;::getOwnPropertySlotByIndex(thisObject, exec, *index, slot);</span>
  
<span class="line-modified">!     return Base::getOwnPropertySlot(thisObject, exec, ident, slot);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
  
      if (!thisObject-&gt;isModifiedArgumentDescriptor(index) &amp;&amp; thisObject-&gt;isMappedArgument(index)) {
          slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), thisObject-&gt;getIndexQuickly(index));
          return true;
      }
  
<span class="line-modified">!     bool result = Base::getOwnPropertySlotByIndex(object, exec, index, slot);</span>
  
      if (thisObject-&gt;isMappedArgument(index)) {
          ASSERT(result);
          slot.setValue(thisObject, slot.attributes(), thisObject-&gt;getIndexQuickly(index));
          return true;
<span class="line-new-header">--- 61,26 ---</span>
              return true;
          }
      }
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!         return GenericArguments&lt;Type&gt;::getOwnPropertySlotByIndex(thisObject, globalObject, *index, slot);</span>
  
<span class="line-modified">!     return Base::getOwnPropertySlot(thisObject, globalObject, ident, slot);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned index, PropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
  
      if (!thisObject-&gt;isModifiedArgumentDescriptor(index) &amp;&amp; thisObject-&gt;isMappedArgument(index)) {
          slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), thisObject-&gt;getIndexQuickly(index));
          return true;
      }
  
<span class="line-modified">!     bool result = Base::getOwnPropertySlotByIndex(object, globalObject, index, slot);</span>
  
      if (thisObject-&gt;isMappedArgument(index)) {
          ASSERT(result);
          slot.setValue(thisObject, slot.attributes(), thisObject-&gt;getIndexQuickly(index));
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,13 ***</span>
  
      return result;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; array, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      Type* thisObject = jsCast&lt;Type*&gt;(object);
  
      if (array.includeStringProperties()) {
          for (unsigned i = 0; i &lt; thisObject-&gt;internalLength(); ++i) {
              if (!thisObject-&gt;isMappedArgument(i))
<span class="line-new-header">--- 88,13 ---</span>
  
      return result;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::getOwnPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; array, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      Type* thisObject = jsCast&lt;Type*&gt;(object);
  
      if (array.includeStringProperties()) {
          for (unsigned i = 0; i &lt; thisObject-&gt;internalLength(); ++i) {
              if (!thisObject-&gt;isMappedArgument(i))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,109 ***</span>
          array.add(vm.propertyNames-&gt;length);
          array.add(vm.propertyNames-&gt;callee);
          if (array.includeSymbolProperties())
              array.add(vm.propertyNames-&gt;iteratorSymbol);
      }
<span class="line-modified">!     Base::getOwnPropertyNames(thisObject, exec, array, mode);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::put(JSCell* cell, ExecState* exec, PropertyName ident, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (!thisObject-&gt;overrodeThings()
          &amp;&amp; (ident == vm.propertyNames-&gt;length
              || ident == vm.propertyNames-&gt;callee
              || ident == vm.propertyNames-&gt;iteratorSymbol)) {
<span class="line-modified">!         thisObject-&gt;overrideThings(vm);</span>
          PutPropertySlot dummy = slot; // This put is not cacheable, so we shadow the slot that was given to us.
<span class="line-modified">!         return Base::put(thisObject, exec, ident, value, dummy);</span>
      }
  
      // https://tc39.github.io/ecma262/#sec-arguments-exotic-objects-set-p-v-receiver
      // Fall back to the OrdinarySet when the receiver is altered from the thisObject.
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         return ordinarySetSlow(exec, thisObject, ident, value, slot.thisValue(), slot.isStrictMode());</span>
  
      Optional&lt;uint32_t&gt; index = parseIndex(ident);
      if (index &amp;&amp; thisObject-&gt;isMappedArgument(index.value())) {
          thisObject-&gt;setIndexQuickly(vm, index.value(), value);
          return true;
      }
  
<span class="line-modified">!     return Base::put(thisObject, exec, ident, value, slot);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::putByIndex(JSCell* cell, ExecState* exec, unsigned index, JSValue value, bool shouldThrow)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (thisObject-&gt;isMappedArgument(index)) {
          thisObject-&gt;setIndexQuickly(vm, index, value);
          return true;
      }
  
<span class="line-modified">!     return Base::putByIndex(cell, exec, index, value, shouldThrow);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::deleteProperty(JSCell* cell, ExecState* exec, PropertyName ident)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      if (!thisObject-&gt;overrodeThings()
          &amp;&amp; (ident == vm.propertyNames-&gt;length
              || ident == vm.propertyNames-&gt;callee
<span class="line-modified">!             || ident == vm.propertyNames-&gt;iteratorSymbol))</span>
<span class="line-modified">!         thisObject-&gt;overrideThings(vm);</span>
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!         return GenericArguments&lt;Type&gt;::deletePropertyByIndex(thisObject, exec, *index);</span>
  
<span class="line-modified">!     return Base::deleteProperty(thisObject, exec, ident);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned index)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
  
      bool propertyMightBeInJSObjectStorage = thisObject-&gt;isModifiedArgumentDescriptor(index) || !thisObject-&gt;isMappedArgument(index);
      bool deletedProperty = true;
<span class="line-modified">!     if (propertyMightBeInJSObjectStorage)</span>
<span class="line-modified">!         deletedProperty = Base::deletePropertyByIndex(cell, exec, index);</span>
  
      if (deletedProperty) {
          // Deleting an indexed property unconditionally unmaps it.
          if (thisObject-&gt;isMappedArgument(index)) {
              // We need to check that the property was mapped so we don&#39;t write to random memory.
<span class="line-modified">!             thisObject-&gt;unmapArgument(vm, index);</span>
          }
<span class="line-modified">!         thisObject-&gt;setModifiedArgumentDescriptor(vm, index);</span>
      }
  
      return deletedProperty;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName ident, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (ident == vm.propertyNames-&gt;length
          || ident == vm.propertyNames-&gt;callee
<span class="line-modified">!         || ident == vm.propertyNames-&gt;iteratorSymbol)</span>
<span class="line-modified">!         thisObject-&gt;overrideThingsIfNecessary(vm);</span>
<span class="line-modified">!     else {</span>
          Optional&lt;uint32_t&gt; optionalIndex = parseIndex(ident);
          if (optionalIndex) {
              uint32_t index = optionalIndex.value();
              if (!descriptor.isAccessorDescriptor() &amp;&amp; thisObject-&gt;isMappedArgument(optionalIndex.value())) {
                  // If the property is not deleted and we are using a non-accessor descriptor, then
<span class="line-new-header">--- 107,121 ---</span>
          array.add(vm.propertyNames-&gt;length);
          array.add(vm.propertyNames-&gt;callee);
          if (array.includeSymbolProperties())
              array.add(vm.propertyNames-&gt;iteratorSymbol);
      }
<span class="line-modified">!     Base::getOwnPropertyNames(thisObject, globalObject, array, mode);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName ident, JSValue value, PutPropertySlot&amp; slot)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      if (!thisObject-&gt;overrodeThings()
          &amp;&amp; (ident == vm.propertyNames-&gt;length
              || ident == vm.propertyNames-&gt;callee
              || ident == vm.propertyNames-&gt;iteratorSymbol)) {
<span class="line-modified">!         thisObject-&gt;overrideThings(globalObject);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
          PutPropertySlot dummy = slot; // This put is not cacheable, so we shadow the slot that was given to us.
<span class="line-modified">!         RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, ident, value, dummy));</span>
      }
  
      // https://tc39.github.io/ecma262/#sec-arguments-exotic-objects-set-p-v-receiver
      // Fall back to the OrdinarySet when the receiver is altered from the thisObject.
      if (UNLIKELY(isThisValueAltered(slot, thisObject)))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, ordinarySetSlow(globalObject, thisObject, ident, value, slot.thisValue(), slot.isStrictMode()));</span>
  
      Optional&lt;uint32_t&gt; index = parseIndex(ident);
      if (index &amp;&amp; thisObject-&gt;isMappedArgument(index.value())) {
          thisObject-&gt;setIndexQuickly(vm, index.value(), value);
          return true;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, ident, value, slot));</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned index, JSValue value, bool shouldThrow)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
      if (thisObject-&gt;isMappedArgument(index)) {
          thisObject-&gt;setIndexQuickly(vm, index, value);
          return true;
      }
  
<span class="line-modified">!     return Base::putByIndex(cell, globalObject, index, value, shouldThrow);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName ident)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
  
      if (!thisObject-&gt;overrodeThings()
          &amp;&amp; (ident == vm.propertyNames-&gt;length
              || ident == vm.propertyNames-&gt;callee
<span class="line-modified">!             || ident == vm.propertyNames-&gt;iteratorSymbol)) {</span>
<span class="line-modified">!         thisObject-&gt;overrideThings(globalObject);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+     }</span>
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(ident))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, GenericArguments&lt;Type&gt;::deletePropertyByIndex(thisObject, globalObject, *index));</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::deleteProperty(thisObject, globalObject, ident));</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned index)</span>
  {
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      Type* thisObject = jsCast&lt;Type*&gt;(cell);
  
      bool propertyMightBeInJSObjectStorage = thisObject-&gt;isModifiedArgumentDescriptor(index) || !thisObject-&gt;isMappedArgument(index);
      bool deletedProperty = true;
<span class="line-modified">!     if (propertyMightBeInJSObjectStorage) {</span>
<span class="line-modified">!         deletedProperty = Base::deletePropertyByIndex(cell, globalObject, index);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, true);</span>
<span class="line-added">+     }</span>
  
      if (deletedProperty) {
          // Deleting an indexed property unconditionally unmaps it.
          if (thisObject-&gt;isMappedArgument(index)) {
              // We need to check that the property was mapped so we don&#39;t write to random memory.
<span class="line-modified">!             thisObject-&gt;unmapArgument(globalObject, index);</span>
<span class="line-added">+             RETURN_IF_EXCEPTION(scope, true);</span>
          }
<span class="line-modified">!         thisObject-&gt;setModifiedArgumentDescriptor(globalObject, index);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, true);</span>
      }
  
      return deletedProperty;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! bool GenericArguments&lt;Type&gt;::defineOwnProperty(JSObject* object, JSGlobalObject* globalObject, PropertyName ident, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
  {
      Type* thisObject = jsCast&lt;Type*&gt;(object);
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (ident == vm.propertyNames-&gt;length
          || ident == vm.propertyNames-&gt;callee
<span class="line-modified">!         || ident == vm.propertyNames-&gt;iteratorSymbol) {</span>
<span class="line-modified">!         thisObject-&gt;overrideThingsIfNecessary(globalObject);</span>
<span class="line-modified">!         RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+     } else {</span>
          Optional&lt;uint32_t&gt; optionalIndex = parseIndex(ident);
          if (optionalIndex) {
              uint32_t index = optionalIndex.value();
              if (!descriptor.isAccessorDescriptor() &amp;&amp; thisObject-&gt;isMappedArgument(optionalIndex.value())) {
                  // If the property is not deleted and we are using a non-accessor descriptor, then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,14 ***</span>
  
                  if (!thisObject-&gt;isModifiedArgumentDescriptor(index)) {
                      // If it is a new entry, we need to put direct to initialize argument[i] descriptor properly
                      JSValue value = thisObject-&gt;getIndexQuickly(index);
                      ASSERT(value);
<span class="line-modified">!                     object-&gt;putDirectMayBeIndex(exec, ident, value);</span>
                      scope.assertNoException();
  
<span class="line-modified">!                     thisObject-&gt;setModifiedArgumentDescriptor(vm, index);</span>
                  }
              }
  
              if (thisObject-&gt;isMappedArgument(index)) {
                  // Just unmap arguments if its descriptor contains {writable: false}.
<span class="line-new-header">--- 237,15 ---</span>
  
                  if (!thisObject-&gt;isModifiedArgumentDescriptor(index)) {
                      // If it is a new entry, we need to put direct to initialize argument[i] descriptor properly
                      JSValue value = thisObject-&gt;getIndexQuickly(index);
                      ASSERT(value);
<span class="line-modified">!                     object-&gt;putDirectMayBeIndex(globalObject, ident, value);</span>
                      scope.assertNoException();
  
<span class="line-modified">!                     thisObject-&gt;setModifiedArgumentDescriptor(globalObject, index);</span>
<span class="line-added">+                     RETURN_IF_EXCEPTION(scope, false);</span>
                  }
              }
  
              if (thisObject-&gt;isMappedArgument(index)) {
                  // Just unmap arguments if its descriptor contains {writable: false}.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,49 ***</span>
                  // property from arguments object are {writable: true, configurable: true, enumerable: true} by default
                  if ((descriptor.writablePresent() &amp;&amp; !descriptor.writable()) || descriptor.isAccessorDescriptor()) {
                      if (!descriptor.isAccessorDescriptor()) {
                          JSValue value = thisObject-&gt;getIndexQuickly(index);
                          ASSERT(value);
<span class="line-modified">!                         object-&gt;putDirectMayBeIndex(exec, ident, value);</span>
                          scope.assertNoException();
                      }
<span class="line-modified">!                     thisObject-&gt;unmapArgument(vm, index);</span>
<span class="line-modified">!                     thisObject-&gt;setModifiedArgumentDescriptor(vm, index);</span>
                  }
              }
          }
      }
  
      // Now just let the normal object machinery do its thing.
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, exec, ident, descriptor, shouldThrow));</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::initModifiedArgumentsDescriptor(VM&amp; vm, unsigned argsLength)</span>
  {
      RELEASE_ASSERT(!m_modifiedArgumentsDescriptor);
  
      if (argsLength) {
<span class="line-modified">!         void* backingStore = vm.gigacageAuxiliarySpace(m_modifiedArgumentsDescriptor.kind).allocateNonVirtual(vm, WTF::roundUpToMultipleOf&lt;8&gt;(argsLength), nullptr, AllocationFailureMode::Assert);</span>
          bool* modifiedArguments = static_cast&lt;bool*&gt;(backingStore);
          m_modifiedArgumentsDescriptor.set(vm, this, modifiedArguments, argsLength);
          for (unsigned i = argsLength; i--;)
              modifiedArguments[i] = false;
      }
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::initModifiedArgumentsDescriptorIfNecessary(VM&amp; vm, unsigned argsLength)</span>
  {
      if (!m_modifiedArgumentsDescriptor)
<span class="line-modified">!         initModifiedArgumentsDescriptor(vm, argsLength);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::setModifiedArgumentDescriptor(VM&amp; vm, unsigned index, unsigned length)</span>
  {
<span class="line-modified">!     initModifiedArgumentsDescriptorIfNecessary(vm, length);</span>
      if (index &lt; length)
          m_modifiedArgumentsDescriptor.at(index, length) = true;
  }
  
  template&lt;typename Type&gt;
<span class="line-new-header">--- 254,62 ---</span>
                  // property from arguments object are {writable: true, configurable: true, enumerable: true} by default
                  if ((descriptor.writablePresent() &amp;&amp; !descriptor.writable()) || descriptor.isAccessorDescriptor()) {
                      if (!descriptor.isAccessorDescriptor()) {
                          JSValue value = thisObject-&gt;getIndexQuickly(index);
                          ASSERT(value);
<span class="line-modified">!                         object-&gt;putDirectMayBeIndex(globalObject, ident, value);</span>
                          scope.assertNoException();
                      }
<span class="line-modified">!                     thisObject-&gt;unmapArgument(globalObject, index);</span>
<span class="line-modified">!                     RETURN_IF_EXCEPTION(scope, false);</span>
<span class="line-added">+                     thisObject-&gt;setModifiedArgumentDescriptor(globalObject, index);</span>
<span class="line-added">+                     RETURN_IF_EXCEPTION(scope, false);</span>
                  }
              }
          }
      }
  
      // Now just let the normal object machinery do its thing.
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(object, globalObject, ident, descriptor, shouldThrow));</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::initModifiedArgumentsDescriptor(JSGlobalObject* globalObject, unsigned argsLength)</span>
  {
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
      RELEASE_ASSERT(!m_modifiedArgumentsDescriptor);
  
      if (argsLength) {
<span class="line-modified">!         void* backingStore = vm.gigacageAuxiliarySpace(m_modifiedArgumentsDescriptor.kind).allocateNonVirtual(vm, WTF::roundUpToMultipleOf&lt;8&gt;(argsLength), nullptr, AllocationFailureMode::ReturnNull);</span>
<span class="line-added">+         if (UNLIKELY(!backingStore)) {</span>
<span class="line-added">+             throwOutOfMemoryError(globalObject, scope);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
          bool* modifiedArguments = static_cast&lt;bool*&gt;(backingStore);
          m_modifiedArgumentsDescriptor.set(vm, this, modifiedArguments, argsLength);
          for (unsigned i = argsLength; i--;)
              modifiedArguments[i] = false;
      }
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::initModifiedArgumentsDescriptorIfNecessary(JSGlobalObject* globalObject, unsigned argsLength)</span>
  {
      if (!m_modifiedArgumentsDescriptor)
<span class="line-modified">!         initModifiedArgumentsDescriptor(globalObject, argsLength);</span>
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::setModifiedArgumentDescriptor(JSGlobalObject* globalObject, unsigned index, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     initModifiedArgumentsDescriptorIfNecessary(globalObject, length);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
      if (index &lt; length)
          m_modifiedArgumentsDescriptor.at(index, length) = true;
  }
  
  template&lt;typename Type&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,21 ***</span>
          return m_modifiedArgumentsDescriptor.at(index, length);
      return false;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::copyToArguments(ExecState* exec, VirtualRegister firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Type* thisObject = static_cast&lt;Type*&gt;(this);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (thisObject-&gt;isMappedArgument(i + offset))
<span class="line-modified">!             exec-&gt;r(firstElementDest + i) = thisObject-&gt;getIndexQuickly(i + offset);</span>
          else {
<span class="line-modified">!             exec-&gt;r(firstElementDest + i) = get(exec, i + offset);</span>
              RETURN_IF_EXCEPTION(scope, void());
          }
      }
  }
  
<span class="line-new-header">--- 321,21 ---</span>
          return m_modifiedArgumentsDescriptor.at(index, length);
      return false;
  }
  
  template&lt;typename Type&gt;
<span class="line-modified">! void GenericArguments&lt;Type&gt;::copyToArguments(JSGlobalObject* globalObject, JSValue* firstElementDest, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      Type* thisObject = static_cast&lt;Type*&gt;(this);
      for (unsigned i = 0; i &lt; length; ++i) {
          if (thisObject-&gt;isMappedArgument(i + offset))
<span class="line-modified">!             firstElementDest[i] = thisObject-&gt;getIndexQuickly(i + offset);</span>
          else {
<span class="line-modified">!             firstElementDest[i] = get(globalObject, i + offset);</span>
              RETURN_IF_EXCEPTION(scope, void());
          }
      }
  }
  
</pre>
<center><a href="GenericArguments.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GenericOffset.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
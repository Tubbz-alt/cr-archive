<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertRecord.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMConvertPromise.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertScheduledAction.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertRecord.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,95 +25,108 @@</span>
  
  #pragma once
  
  #include &quot;IDLTypes.h&quot;
  #include &quot;JSDOMConvertStrings.h&quot;
<span class="udiff-line-added">+ #include &quot;JSDOMGlobalObject.h&quot;</span>
  #include &lt;JavaScriptCore/ObjectConstructor.h&gt;
  
  namespace WebCore {
  
  namespace Detail {
  
  template&lt;typename IDLStringType&gt;
  struct IdentifierConverter;
  
  template&lt;&gt; struct IdentifierConverter&lt;IDLDOMString&gt; {
<span class="udiff-line-modified-removed">-     static String convert(JSC::ExecState&amp;, const JSC::Identifier&amp; identifier)</span>
<span class="udiff-line-modified-added">+     static String convert(JSC::JSGlobalObject&amp;, const JSC::Identifier&amp; identifier)</span>
      {
          return identifier.string();
      }
  };
  
  template&lt;&gt; struct IdentifierConverter&lt;IDLByteString&gt; {
<span class="udiff-line-modified-removed">-     static String convert(JSC::ExecState&amp; state, const JSC::Identifier&amp; identifier)</span>
<span class="udiff-line-modified-added">+     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)</span>
      {
<span class="udiff-line-modified-removed">-         return identifierToByteString(state, identifier);</span>
<span class="udiff-line-modified-added">+         return identifierToByteString(lexicalGlobalObject, identifier);</span>
      }
  };
  
  template&lt;&gt; struct IdentifierConverter&lt;IDLUSVString&gt; {
<span class="udiff-line-modified-removed">-     static String convert(JSC::ExecState&amp; state, const JSC::Identifier&amp; identifier)</span>
<span class="udiff-line-modified-added">+     static String convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, const JSC::Identifier&amp; identifier)</span>
      {
<span class="udiff-line-modified-removed">-         return identifierToUSVString(state, identifier);</span>
<span class="udiff-line-modified-added">+         return identifierToUSVString(lexicalGlobalObject, identifier);</span>
      }
  };
  
  }
  
  template&lt;typename K, typename V&gt; struct Converter&lt;IDLRecord&lt;K, V&gt;&gt; : DefaultConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
      using ReturnType = typename IDLRecord&lt;K, V&gt;::ImplementationType;
      using KeyType = typename K::ImplementationType;
      using ValueType = typename V::ImplementationType;
  
<span class="udiff-line-modified-removed">-     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)</span>
<span class="udiff-line-modified-added">+     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, JSDOMGlobalObject&amp; globalObject)</span>
      {
<span class="udiff-line-modified-removed">-         auto&amp; vm = state.vm();</span>
<span class="udiff-line-modified-added">+         return convertRecord&lt;JSDOMGlobalObject&amp;&gt;(lexicalGlobalObject, value, globalObject);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         return convertRecord(lexicalGlobalObject, value);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+     template&lt;class...Args&gt;</span>
<span class="udiff-line-added">+     static ReturnType convertRecord(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, Args ... args)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          // 1. Let result be a new empty instance of record&lt;K, V&gt;.
          // 2. If Type(O) is Undefined or Null, return result.
          if (value.isUndefinedOrNull())
              return { };
  
          // 3. If Type(O) is not Object, throw a TypeError.
          if (!value.isObject()) {
<span class="udiff-line-modified-removed">-             throwTypeError(&amp;state, scope);</span>
<span class="udiff-line-modified-added">+             throwTypeError(&amp;lexicalGlobalObject, scope);</span>
              return { };
          }
  
          JSC::JSObject* object = JSC::asObject(value);
  
          ReturnType result;
  
          // 4. Let keys be ? O.[[OwnPropertyKeys]]().
          JSC::PropertyNameArray keys(vm, JSC::PropertyNameMode::Strings, JSC::PrivateSymbolMode::Exclude);
<span class="udiff-line-modified-removed">-         object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, &amp;state, keys, JSC::EnumerationMode(JSC::DontEnumPropertiesMode::Include));</span>
<span class="udiff-line-modified-added">+         object-&gt;methodTable(vm)-&gt;getOwnPropertyNames(object, &amp;lexicalGlobalObject, keys, JSC::EnumerationMode(JSC::DontEnumPropertiesMode::Include));</span>
  
          RETURN_IF_EXCEPTION(scope, { });
  
          // 5. Repeat, for each element key of keys in List order:
          for (auto&amp; key : keys) {
              // 1. Let desc be ? O.[[GetOwnProperty]](key).
              JSC::PropertyDescriptor descriptor;
<span class="udiff-line-modified-removed">-             bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(&amp;state, key, descriptor);</span>
<span class="udiff-line-modified-added">+             bool didGetDescriptor = object-&gt;getOwnPropertyDescriptor(&amp;lexicalGlobalObject, key, descriptor);</span>
              RETURN_IF_EXCEPTION(scope, { });
  
              // 2. If desc is not undefined and desc.[[Enumerable]] is true:
  
              // It&#39;s necessary to filter enumerable here rather than using the default EnumerationMode,
              // to prevent an observable extra [[GetOwnProperty]] operation in the case of ProxyObject records.
              if (didGetDescriptor &amp;&amp; descriptor.enumerable()) {
                  // 1. Let typedKey be key converted to an IDL value of type K.
<span class="udiff-line-modified-removed">-                 auto typedKey = Detail::IdentifierConverter&lt;K&gt;::convert(state, key);</span>
<span class="udiff-line-modified-added">+                 auto typedKey = Detail::IdentifierConverter&lt;K&gt;::convert(lexicalGlobalObject, key);</span>
                  RETURN_IF_EXCEPTION(scope, { });
  
                  // 2. Let value be ? Get(O, key).
<span class="udiff-line-modified-removed">-                 auto subValue = object-&gt;get(&amp;state, key);</span>
<span class="udiff-line-modified-added">+                 auto subValue = object-&gt;get(&amp;lexicalGlobalObject, key);</span>
                  RETURN_IF_EXCEPTION(scope, { });
  
                  // 3. Let typedValue be value converted to an IDL value of type V.
<span class="udiff-line-modified-removed">-                 auto typedValue = Converter&lt;V&gt;::convert(state, subValue);</span>
<span class="udiff-line-modified-added">+                 auto typedValue = Converter&lt;V&gt;::convert(lexicalGlobalObject, subValue, args...);</span>
                  RETURN_IF_EXCEPTION(scope, { });
  
                  // 4. If typedKey is already a key in result, set its value to typedValue.
                  // Note: This can happen when O is a proxy object.
                  // FIXME: Handle this case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -131,25 +144,25 @@</span>
  template&lt;typename K, typename V&gt; struct JSConverter&lt;IDLRecord&lt;K, V&gt;&gt; {
      static constexpr bool needsState = true;
      static constexpr bool needsGlobalObject = true;
  
      template&lt;typename MapType&gt;
<span class="udiff-line-modified-removed">-     static JSC::JSValue convert(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const MapType&amp; map)</span>
<span class="udiff-line-modified-added">+     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const MapType&amp; map)</span>
      {
<span class="udiff-line-modified-removed">-         auto&amp; vm = state.vm();</span>
<span class="udiff-line-modified-added">+         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
  
          // 1. Let result be ! ObjectCreate(%ObjectPrototype%).
<span class="udiff-line-modified-removed">-         auto result = constructEmptyObject(&amp;state, globalObject.objectPrototype());</span>
<span class="udiff-line-modified-added">+         auto result = constructEmptyObject(&amp;lexicalGlobalObject, globalObject.objectPrototype());</span>
  
          // 2. Repeat, for each mapping (key, value) in D:
          for (const auto&amp; keyValuePair : map) {
              // 1. Let esKey be key converted to an ECMAScript value.
              // Note, this step is not required, as we need the key to be
              // an Identifier, not a JSValue.
  
              // 2. Let esValue be value converted to an ECMAScript value.
<span class="udiff-line-modified-removed">-             auto esValue = toJS&lt;V&gt;(state, globalObject, keyValuePair.value);</span>
<span class="udiff-line-modified-added">+             auto esValue = toJS&lt;V&gt;(lexicalGlobalObject, globalObject, keyValuePair.value);</span>
  
              // 3. Let created be ! CreateDataProperty(result, esKey, esValue).
              bool created = result-&gt;putDirect(vm, JSC::Identifier::fromString(vm, keyValuePair.key), esValue);
  
              // 4. Assert: created is true.
</pre>
<center><a href="JSDOMConvertPromise.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMConvertScheduledAction.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
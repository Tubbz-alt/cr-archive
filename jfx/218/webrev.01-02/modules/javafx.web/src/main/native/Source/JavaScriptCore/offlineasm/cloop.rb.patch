diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb
@@ -86,13 +86,13 @@
         when "t5"
             "t5"
         when "csr0"
             "pcBase"
         when "csr1"
-            "tagTypeNumber"
+            "numberTag"
         when "csr2"
-            "tagMask"
+            "notCellMask"
         when "csr3"
             "metadataTable"
         when "cfr"
             "cfr"
         when "lr"
@@ -158,10 +158,11 @@
 
         valueStr = (value < 0) ? "#{value}" : "0x#{value.to_s(16)}"
 
         case type
         when :int8;    "int8_t(#{valueStr})"
+        when :int16;   "int16_t(#{valueStr})"
         when :int32;   "int32_t(#{valueStr})"
         when :int64;   "int64_t(#{valueStr})"
         when :intptr;  "intptr_t(#{valueStr})"
         when :uint8;   "uint8_t(#{valueStr})"
         when :uint32;  "uint32_t(#{valueStr})"
@@ -181,10 +182,11 @@
         clValue(type)
     end
     def clValue(type=:intptr)
         case type
         when :int8;         int8MemRef
+        when :int16;        int16MemRef
         when :int32;        int32MemRef
         when :int64;        int64MemRef
         when :intptr;       intptrMemRef
         when :uint8;        uint8MemRef
         when :uint32;       uint32MemRef
@@ -384,11 +386,11 @@
 end
 
 
 def cloopEmitOperation(operands, type, operator)
     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \
-        type == :int64 || type == :uint64 || type == :double
+        type == :int64 || type == :uint64 || type == :double || type == :int16
     if operands.size == 3
         op1 = operands[0]
         op2 = operands[1]
         dst = operands[2]
     else
@@ -399,10 +401,13 @@
     end
     raise unless not dst.is_a? Immediate
     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
         truncationHeader = "(uint32_t)("
         truncationFooter = ")"
+    elsif dst.is_a? RegisterID and (type == :int16)
+        truncationHeader = "(uint16_t)("
+        truncationFooter = ")"
     else
         truncationHeader = ""
         truncationFooter = ""
     end
     $asm.putc "#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};"
@@ -583,10 +588,12 @@
             cloopEmitOperation(operands, :int32, "|")
         when "orq"
             cloopEmitOperation(operands, :int64, "|")
         when "orp"
             cloopEmitOperation(operands, :intptr, "|")
+        when "orh"
+            cloopEmitOperation(operands, :int16, "|")
 
         when "xori"
             cloopEmitOperation(operands, :int32, "^")
         when "xorq"
             cloopEmitOperation(operands, :int64, "^")
@@ -683,12 +690,12 @@
             cloopEmitOperation(operands, :double, "-")
         when "muld"
             cloopEmitOperation(operands, :double, "*")
 
         # Convert an int value to its double equivalent, and store it in a double register.
-        when "ci2d"
-            $asm.putc "#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d"
+        when "ci2ds"
+            $asm.putc "#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2ds"
 
         when "bdeq"
             cloopEmitCompareAndBranch(operands, :double, "==")
         when "bdneq"
             cloopEmitCompareAndBranch(operands, :double, "!=")
@@ -1124,15 +1131,15 @@
             $asm.putc "DISPATCH_OPCODE();"
             $asm.putsLabel("llint_cloop_did_return_from_js_#{uid}", false)
 
         # We can't do generic function calls with an arbitrary set of args, but
         # fortunately we don't have to here. All native function calls always
-        # have a fixed prototype of 1 args: the passed ExecState.
+        # have a fixed prototype of 2 args: the passed JSGlobalObject* and CallFrame*.
         when "cloopCallNative"
             $asm.putc "cloopStack.setCurrentStackPointer(sp.vp());"
             $asm.putc "nativeFunc = #{operands[0].clValue(:nativeFunc)};"
-            $asm.putc "functionReturnValue = JSValue::decode(nativeFunc(t0.execState()));"
+            $asm.putc "functionReturnValue = JSValue::decode(nativeFunc(jsCast<JSGlobalObject*>(t0.cell()), t1.callFrame()));"
             $asm.putc "#if USE(JSVALUE32_64)"
             $asm.putc "    t1 = functionReturnValue.tag();"
             $asm.putc "    t0 = functionReturnValue.payload();"
             $asm.putc "#else // USE_JSVALUE64)"
             $asm.putc "    t0 = JSValue::encode(functionReturnValue);"

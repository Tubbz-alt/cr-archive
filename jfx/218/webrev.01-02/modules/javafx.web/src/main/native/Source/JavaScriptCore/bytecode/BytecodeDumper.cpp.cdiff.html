<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeBasicBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeDumper.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,173 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;BytecodeDumper.h&quot;
  
  #include &quot;ArithProfile.h&quot;
  #include &quot;BytecodeStructs.h&quot;
  #include &quot;CallLinkStatus.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;HeapInlines.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;PolymorphicAccess.h&quot;
  #include &quot;PutByIdFlags.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;ToThisStatus.h&quot;
<span class="line-modified">! #include &quot;UnlinkedCodeBlock.h&quot;</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! template&lt;class Block&gt;</span>
<span class="line-removed">- VM&amp; BytecodeDumper&lt;Block&gt;::vm() const</span>
  {
<span class="line-modified">!     return block()-&gt;vm();</span>
  }
  
<span class="line-modified">! template&lt;class Block&gt;</span>
<span class="line-removed">- const Identifier&amp; BytecodeDumper&lt;Block&gt;::identifier(int index) const</span>
  {
<span class="line-modified">!     return block()-&gt;identifier(index);</span>
  }
  
<span class="line-modified">! static ALWAYS_INLINE bool isConstantRegisterIndex(int index)</span>
  {
<span class="line-modified">!     return index &gt;= FirstConstantRegisterIndex;</span>
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! CString BytecodeDumper&lt;Block&gt;::registerName(int r) const</span>
  {
<span class="line-modified">!     if (isConstantRegisterIndex(r))</span>
          return constantName(r);
  
<span class="line-modified">!     return toCString(VirtualRegister(r));</span>
  }
  
<span class="line-modified">! template&lt;class Block&gt;</span>
<span class="line-modified">! CString BytecodeDumper&lt;Block&gt;::constantName(int index) const</span>
  {
<span class="line-modified">!     JSValue value = block()-&gt;getConstant(index);</span>
<span class="line-removed">-     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);</span>
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::printLocationAndOp(InstructionStream::Offset location, const char* op)</span>
  {
<span class="line-modified">!     m_currentLocation = location;</span>
<span class="line-modified">!     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);</span>
  }
  
  template&lt;class Block&gt;
  void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
  {
      ::JSC::dumpBytecode(this, it.offset(), it.ptr());
<span class="line-modified">!     m_out.print(&quot;\n&quot;);</span>
  }
  
  template&lt;class Block&gt;
  void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
  {
      BytecodeDumper dumper(block, out);
      dumper.dumpBytecode(it, statusMap);
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpIdentifiers()</span>
  {
<span class="line-modified">!     if (size_t count = block()-&gt;numberOfIdentifiers()) {</span>
<span class="line-modified">!         m_out.printf(&quot;\nIdentifiers:\n&quot;);</span>
          size_t i = 0;
          do {
<span class="line-modified">!             m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);</span>
              ++i;
          } while (i != count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpConstants()</span>
  {
<span class="line-modified">!     if (!block()-&gt;constantRegisters().isEmpty()) {</span>
<span class="line-modified">!         m_out.printf(&quot;\nConstants:\n&quot;);</span>
          size_t i = 0;
<span class="line-modified">!         for (const auto&amp; constant : block()-&gt;constantRegisters()) {</span>
              const char* sourceCodeRepresentationDescription = nullptr;
<span class="line-modified">!             switch (block()-&gt;constantsSourceCodeRepresentation()[i]) {</span>
              case SourceCodeRepresentation::Double:
                  sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
                  break;
              case SourceCodeRepresentation::Integer:
                  sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
                  break;
              case SourceCodeRepresentation::Other:
                  sourceCodeRepresentationDescription = &quot;&quot;;
                  break;
              }
<span class="line-modified">!             m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);</span>
              ++i;
          }
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()</span>
  {
<span class="line-modified">!     if (unsigned count = block()-&gt;numberOfExceptionHandlers()) {</span>
<span class="line-modified">!         m_out.printf(&quot;\nException Handlers:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             const auto&amp; handler = block()-&gt;exceptionHandler(i);</span>
<span class="line-modified">!             m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()</span>
  {
<span class="line-modified">!     if (unsigned count = block()-&gt;numberOfSwitchJumpTables()) {</span>
<span class="line-modified">!         m_out.printf(&quot;Switch Jump Tables:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">!             const auto&amp; switchJumpTable = block()-&gt;switchJumpTable(i);</span>
              int entry = 0;
              auto end = switchJumpTable.branchOffsets.end();
              for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
                  if (!*iter)
                      continue;
<span class="line-modified">!                 m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);</span>
              }
<span class="line-modified">!             m_out.printf(&quot;      }\n&quot;);</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()</span>
  {
<span class="line-modified">!     if (unsigned count = block()-&gt;numberOfStringSwitchJumpTables()) {</span>
<span class="line-modified">!         m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">!             const auto&amp; stringSwitchJumpTable = block()-&gt;stringSwitchJumpTable(i);</span>
              auto end = stringSwitchJumpTable.offsetTable.end();
              for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
<span class="line-modified">!                 m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);</span>
<span class="line-modified">!             m_out.printf(&quot;      }\n&quot;);</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void BytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)</span>
  {
      size_t instructionCount = 0;
      size_t wide16InstructionCount = 0;
      size_t wide32InstructionCount = 0;
      size_t instructionWithMetadataCount = 0;
<span class="line-new-header">--- 26,209 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;BytecodeDumper.h&quot;
  
  #include &quot;ArithProfile.h&quot;
<span class="line-added">+ #include &quot;B3Type.h&quot;</span>
<span class="line-added">+ #include &quot;BytecodeGenerator.h&quot;</span>
  #include &quot;BytecodeStructs.h&quot;
  #include &quot;CallLinkStatus.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;HeapInlines.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;PolymorphicAccess.h&quot;
  #include &quot;PutByIdFlags.h&quot;
  #include &quot;StructureInlines.h&quot;
  #include &quot;ToThisStatus.h&quot;
<span class="line-modified">! #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
<span class="line-added">+ #include &quot;WasmFunctionCodeBlock.h&quot;</span>
<span class="line-added">+ #include &quot;WasmGeneratorTraits.h&quot;</span>
<span class="line-added">+ #include &quot;WasmModuleInformation.h&quot;</span>
<span class="line-added">+ #include &quot;WasmOps.h&quot;</span>
<span class="line-added">+ #include &quot;WasmSignatureInlines.h&quot;</span>
  
  namespace JSC {
  
<span class="line-modified">! static ALWAYS_INLINE bool isConstantRegisterIndex(int index)</span>
  {
<span class="line-modified">!     return index &gt;= FirstConstantRegisterIndex;</span>
  }
  
<span class="line-modified">! void BytecodeDumperBase::printLocationAndOp(InstructionStream::Offset location, const char* op)</span>
  {
<span class="line-modified">!     m_currentLocation = location;</span>
<span class="line-added">+     m_out.printf(&quot;[%4u] %-18s &quot;, location, op);</span>
  }
  
<span class="line-modified">! void BytecodeDumperBase::dumpValue(VirtualRegister reg)</span>
  {
<span class="line-modified">!     m_out.printf(&quot;%s&quot;, registerName(reg).data());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename Traits&gt;</span>
<span class="line-added">+ void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Traits&gt; label)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     int target = label.target();</span>
<span class="line-added">+     if (!target)</span>
<span class="line-added">+         target = outOfLineJumpOffset(m_currentLocation);</span>
<span class="line-added">+     InstructionStream::Offset targetOffset = target + m_currentLocation;</span>
<span class="line-added">+     m_out.print(target, &quot;(-&gt;&quot;, targetOffset, &quot;)&quot;);</span>
  }
  
<span class="line-added">+ template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;JSGeneratorTraits&gt;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ template void BytecodeDumperBase::dumpValue(GenericBoundLabel&lt;Wasm::GeneratorTraits&gt;);</span>
<span class="line-added">+ #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ </span>
  template&lt;class Block&gt;
<span class="line-modified">! CString BytecodeDumper&lt;Block&gt;::registerName(VirtualRegister r) const</span>
  {
<span class="line-modified">!     if (r.isConstant())</span>
          return constantName(r);
  
<span class="line-modified">!     return toCString(r);</span>
  }
  
<span class="line-modified">! template &lt;class Block&gt;</span>
<span class="line-modified">! int BytecodeDumper&lt;Block&gt;::outOfLineJumpOffset(InstructionStream::Offset offset) const</span>
  {
<span class="line-modified">!     return m_block-&gt;outOfLineJumpOffset(offset);</span>
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! CString BytecodeDumper&lt;Block&gt;::constantName(VirtualRegister reg) const</span>
  {
<span class="line-modified">!     auto value = block()-&gt;getConstant(reg);</span>
<span class="line-modified">!     return toCString(value, &quot;(&quot;, reg, &quot;)&quot;);</span>
  }
  
  template&lt;class Block&gt;
  void BytecodeDumper&lt;Block&gt;::dumpBytecode(const InstructionStream::Ref&amp; it, const ICStatusMap&amp;)
  {
      ::JSC::dumpBytecode(this, it.offset(), it.ptr());
<span class="line-modified">!     this-&gt;m_out.print(&quot;\n&quot;);</span>
  }
  
  template&lt;class Block&gt;
  void BytecodeDumper&lt;Block&gt;::dumpBytecode(Block* block, PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
  {
      BytecodeDumper dumper(block, out);
      dumper.dumpBytecode(it, statusMap);
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! VM&amp; CodeBlockBytecodeDumper&lt;Block&gt;::vm() const</span>
  {
<span class="line-modified">!     return this-&gt;block()-&gt;vm();</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Block&gt;</span>
<span class="line-added">+ const Identifier&amp; CodeBlockBytecodeDumper&lt;Block&gt;::identifier(int index) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return this-&gt;block()-&gt;identifier(index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;class Block&gt;</span>
<span class="line-added">+ void CodeBlockBytecodeDumper&lt;Block&gt;::dumpIdentifiers()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (size_t count = this-&gt;block()-&gt;numberOfIdentifiers()) {</span>
<span class="line-added">+         this-&gt;m_out.printf(&quot;\nIdentifiers:\n&quot;);</span>
          size_t i = 0;
          do {
<span class="line-modified">!             this-&gt;m_out.print(&quot;  id&quot;, static_cast&lt;unsigned&gt;(i), &quot; = &quot;, identifier(i), &quot;\n&quot;);</span>
              ++i;
          } while (i != count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void CodeBlockBytecodeDumper&lt;Block&gt;::dumpConstants()</span>
  {
<span class="line-modified">!     if (!this-&gt;block()-&gt;constantRegisters().isEmpty()) {</span>
<span class="line-modified">!         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
          size_t i = 0;
<span class="line-modified">!         for (const auto&amp; constant : this-&gt;block()-&gt;constantRegisters()) {</span>
              const char* sourceCodeRepresentationDescription = nullptr;
<span class="line-modified">!             switch (this-&gt;block()-&gt;constantsSourceCodeRepresentation()[i]) {</span>
              case SourceCodeRepresentation::Double:
                  sourceCodeRepresentationDescription = &quot;: in source as double&quot;;
                  break;
              case SourceCodeRepresentation::Integer:
                  sourceCodeRepresentationDescription = &quot;: in source as integer&quot;;
                  break;
              case SourceCodeRepresentation::Other:
                  sourceCodeRepresentationDescription = &quot;&quot;;
                  break;
<span class="line-added">+             case SourceCodeRepresentation::LinkTimeConstant:</span>
<span class="line-added">+                 sourceCodeRepresentationDescription = &quot;: in source as linke-time-constant&quot;;</span>
<span class="line-added">+                 break;</span>
              }
<span class="line-modified">!             this-&gt;m_out.printf(&quot;   k%u = %s%s\n&quot;, static_cast&lt;unsigned&gt;(i), toCString(constant.get()).data(), sourceCodeRepresentationDescription);</span>
              ++i;
          }
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void CodeBlockBytecodeDumper&lt;Block&gt;::dumpExceptionHandlers()</span>
  {
<span class="line-modified">!     if (unsigned count = this-&gt;block()-&gt;numberOfExceptionHandlers()) {</span>
<span class="line-modified">!         this-&gt;m_out.printf(&quot;\nException Handlers:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             const auto&amp; handler = this-&gt;block()-&gt;exceptionHandler(i);</span>
<span class="line-modified">!             this-&gt;m_out.printf(&quot;\t %d: { start: [%4d] end: [%4d] target: [%4d] } %s\n&quot;, i + 1, handler.start, handler.end, handler.target, handler.typeName());</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void CodeBlockBytecodeDumper&lt;Block&gt;::dumpSwitchJumpTables()</span>
  {
<span class="line-modified">!     if (unsigned count = this-&gt;block()-&gt;numberOfSwitchJumpTables()) {</span>
<span class="line-modified">!         this-&gt;m_out.printf(&quot;Switch Jump Tables:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">!             const auto&amp; switchJumpTable = this-&gt;block()-&gt;switchJumpTable(i);</span>
              int entry = 0;
              auto end = switchJumpTable.branchOffsets.end();
              for (auto iter = switchJumpTable.branchOffsets.begin(); iter != end; ++iter, ++entry) {
                  if (!*iter)
                      continue;
<span class="line-modified">!                 this-&gt;m_out.printf(&quot;\t\t%4d =&gt; %04d\n&quot;, entry + switchJumpTable.min, *iter);</span>
              }
<span class="line-modified">!             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void CodeBlockBytecodeDumper&lt;Block&gt;::dumpStringSwitchJumpTables()</span>
  {
<span class="line-modified">!     if (unsigned count = this-&gt;block()-&gt;numberOfStringSwitchJumpTables()) {</span>
<span class="line-modified">!         this-&gt;m_out.printf(&quot;\nString Switch Jump Tables:\n&quot;);</span>
          unsigned i = 0;
          do {
<span class="line-modified">!             this-&gt;m_out.printf(&quot;  %1d = {\n&quot;, i);</span>
<span class="line-modified">!             const auto&amp; stringSwitchJumpTable = this-&gt;block()-&gt;stringSwitchJumpTable(i);</span>
              auto end = stringSwitchJumpTable.offsetTable.end();
              for (auto iter = stringSwitchJumpTable.offsetTable.begin(); iter != end; ++iter)
<span class="line-modified">!                 this-&gt;m_out.printf(&quot;\t\t\&quot;%s\&quot; =&gt; %04d\n&quot;, iter-&gt;key-&gt;utf8().data(), iter-&gt;value.branchOffset);</span>
<span class="line-modified">!             this-&gt;m_out.printf(&quot;      }\n&quot;);</span>
              ++i;
          } while (i &lt; count);
      }
  }
  
  template&lt;class Block&gt;
<span class="line-modified">! void CodeBlockBytecodeDumper&lt;Block&gt;::dumpBlock(Block* block, const InstructionStream&amp; instructions, PrintStream&amp; out, const ICStatusMap&amp; statusMap)</span>
  {
      size_t instructionCount = 0;
      size_t wide16InstructionCount = 0;
      size_t wide32InstructionCount = 0;
      size_t instructionWithMetadataCount = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,11 ***</span>
          static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
          block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
      out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
      out.printf(&quot;\n&quot;);
  
<span class="line-modified">!     BytecodeDumper&lt;Block&gt; dumper(block, out);</span>
      for (const auto&amp; it : instructions)
          dumper.dumpBytecode(it, statusMap);
  
      dumper.dumpIdentifiers();
      dumper.dumpConstants();
<span class="line-new-header">--- 254,11 ---</span>
          static_cast&lt;unsigned long&gt;(block-&gt;metadataSizeInBytes()),
          block-&gt;numParameters(), block-&gt;numCalleeLocals(), block-&gt;numVars());
      out.print(&quot;; scope at &quot;, block-&gt;scopeRegister());
      out.printf(&quot;\n&quot;);
  
<span class="line-modified">!     CodeBlockBytecodeDumper&lt;Block&gt; dumper(block, out);</span>
      for (const auto&amp; it : instructions)
          dumper.dumpBytecode(it, statusMap);
  
      dumper.dumpIdentifiers();
      dumper.dumpConstants();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 231,9 ***</span>
      dumper.dumpStringSwitchJumpTables();
  
      out.printf(&quot;\n&quot;);
  }
  
<span class="line-removed">- template class BytecodeDumper&lt;UnlinkedCodeBlock&gt;;</span>
  template class BytecodeDumper&lt;CodeBlock&gt;;
  
  }
<span class="line-new-header">--- 267,106 ---</span>
      dumper.dumpStringSwitchJumpTables();
  
      out.printf(&quot;\n&quot;);
  }
  
  template class BytecodeDumper&lt;CodeBlock&gt;;
<span class="line-added">+ template class CodeBlockBytecodeDumper&lt;UnlinkedCodeBlockGenerator&gt;;</span>
<span class="line-added">+ template class CodeBlockBytecodeDumper&lt;CodeBlock&gt;;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">+ </span>
<span class="line-added">+ namespace Wasm {</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeDumper::dumpBlock(FunctionCodeBlock* block, const ModuleInformation&amp; moduleInformation, PrintStream&amp; out)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t instructionCount = 0;</span>
<span class="line-added">+     size_t wide16InstructionCount = 0;</span>
<span class="line-added">+     size_t wide32InstructionCount = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">+         if (it-&gt;isWide16())</span>
<span class="line-added">+             ++wide16InstructionCount;</span>
<span class="line-added">+         else if (it-&gt;isWide32())</span>
<span class="line-added">+             ++wide32InstructionCount;</span>
<span class="line-added">+         ++instructionCount;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     size_t functionIndexSpace = moduleInformation.importFunctionCount() + block-&gt;functionIndex();</span>
<span class="line-added">+     out.print(makeString(IndexOrName(functionIndexSpace, moduleInformation.nameSection-&gt;get(functionIndexSpace))));</span>
<span class="line-added">+ </span>
<span class="line-added">+     const auto&amp; function = moduleInformation.functions[block-&gt;functionIndex()];</span>
<span class="line-added">+     SignatureIndex signatureIndex = moduleInformation.internalFunctionSignatureIndices[block-&gt;functionIndex()];</span>
<span class="line-added">+     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">+     out.print(&quot; : &quot;, signature, &quot;\n&quot;);</span>
<span class="line-added">+     out.print(&quot;wasm size: &quot;, function.data.size(), &quot; bytes\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     out.printf(</span>
<span class="line-added">+         &quot;bytecode: %lu instructions (%lu 16-bit instructions, %lu 32-bit instructions); %lu bytes; %d parameter(s); %d local(s); %d callee register(s)\n&quot;,</span>
<span class="line-added">+         static_cast&lt;unsigned long&gt;(instructionCount),</span>
<span class="line-added">+         static_cast&lt;unsigned long&gt;(wide16InstructionCount),</span>
<span class="line-added">+         static_cast&lt;unsigned long&gt;(wide32InstructionCount),</span>
<span class="line-added">+         static_cast&lt;unsigned long&gt;(block-&gt;instructions().sizeInBytes()),</span>
<span class="line-added">+         block-&gt;numArguments(),</span>
<span class="line-added">+         block-&gt;numVars(),</span>
<span class="line-added">+         block-&gt;numCalleeLocals());</span>
<span class="line-added">+ </span>
<span class="line-added">+     BytecodeDumper dumper(block, out);</span>
<span class="line-added">+     for (auto it = block-&gt;instructions().begin(); it != block-&gt;instructions().end(); it += it-&gt;size&lt;WasmOpcodeTraits&gt;()) {</span>
<span class="line-added">+         dumpWasm(&amp;dumper, it.offset(), it.ptr());</span>
<span class="line-added">+         out.print(&quot;\n&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     dumper.dumpConstants();</span>
<span class="line-added">+ </span>
<span class="line-added">+     out.printf(&quot;\n&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void BytecodeDumper::dumpConstants()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">+     if (!block-&gt;constants().isEmpty()) {</span>
<span class="line-added">+         this-&gt;m_out.printf(&quot;\nConstants:\n&quot;);</span>
<span class="line-added">+         unsigned i = 0;</span>
<span class="line-added">+         for (const auto&amp; constant : block-&gt;constants()) {</span>
<span class="line-added">+             Type type = block-&gt;constantTypes()[i];</span>
<span class="line-added">+             this-&gt;m_out.print(&quot;   const&quot;, i, &quot; : &quot;, type, &quot; = &quot;, formatConstant(type, constant), &quot;\n&quot;);</span>
<span class="line-added">+             ++i;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CString BytecodeDumper::constantName(VirtualRegister index) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     FunctionCodeBlock* block = this-&gt;block();</span>
<span class="line-added">+     auto value = formatConstant(block-&gt;getConstantType(index), block-&gt;getConstant(index));</span>
<span class="line-added">+     return toCString(value, &quot;(&quot;, VirtualRegister(index), &quot;)&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CString BytecodeDumper::formatConstant(Type type, uint64_t constant) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (type) {</span>
<span class="line-added">+     case Type::I32:</span>
<span class="line-added">+         return toCString(static_cast&lt;int32_t&gt;(constant));</span>
<span class="line-added">+     case Type::I64:</span>
<span class="line-added">+         return toCString(constant);</span>
<span class="line-added">+     case Type::F32:</span>
<span class="line-added">+         return toCString(bitwise_cast&lt;float&gt;(static_cast&lt;int32_t&gt;(constant)));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Type::F64:</span>
<span class="line-added">+         return toCString(bitwise_cast&lt;double&gt;(constant));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Type::Anyref:</span>
<span class="line-added">+     case Type::Funcref:</span>
<span class="line-added">+         if (JSValue::decode(constant) == jsNull())</span>
<span class="line-added">+             return &quot;null&quot;;</span>
<span class="line-added">+         return toCString(RawPointer(bitwise_cast&lt;void*&gt;(constant)));</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return &quot;&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ } // namespace Wasm</span>
  
<span class="line-added">+ #endif // ENABLE(WEBASSEMBLY)</span>
  }
</pre>
<center><a href="BytecodeBasicBlock.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeDumper.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2007 Alp Toker &lt;alp@atoker.com&gt;
  4  * Copyright (C) 2010 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;HTMLCanvasElement.h&quot;
 30 
 31 #include &quot;Blob.h&quot;
 32 #include &quot;BlobCallback.h&quot;
 33 #include &quot;CanvasGradient.h&quot;
 34 #include &quot;CanvasPattern.h&quot;
 35 #include &quot;CanvasRenderingContext2D.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameLoaderClient.h&quot;
 39 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
 40 #include &quot;GeometryUtilities.h&quot;
 41 #include &quot;GraphicsContext.h&quot;
 42 #include &quot;HTMLNames.h&quot;
 43 #include &quot;HTMLParserIdioms.h&quot;
 44 #include &quot;ImageBitmapRenderingContext.h&quot;
 45 #include &quot;ImageBuffer.h&quot;
 46 #include &quot;ImageData.h&quot;
 47 #include &quot;InspectorInstrumentation.h&quot;
 48 #include &quot;JSDOMConvertDictionary.h&quot;
 49 #include &quot;MIMETypeRegistry.h&quot;
 50 #include &quot;RenderElement.h&quot;
 51 #include &quot;RenderHTMLCanvas.h&quot;
 52 #include &quot;ResourceLoadObserver.h&quot;
 53 #include &quot;RuntimeEnabledFeatures.h&quot;
 54 #include &quot;ScriptController.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;StringAdaptors.h&quot;
 57 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 58 #include &lt;math.h&gt;
 59 #include &lt;wtf/IsoMallocInlines.h&gt;
 60 #include &lt;wtf/RAMSize.h&gt;
 61 #include &lt;wtf/text/StringBuilder.h&gt;
 62 
 63 #if ENABLE(MEDIA_STREAM)
 64 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
 65 #include &quot;MediaStream.h&quot;
 66 #endif
 67 
 68 #if ENABLE(WEBGL)
 69 #include &quot;WebGLContextAttributes.h&quot;
 70 #include &quot;WebGLRenderingContext.h&quot;
 71 #endif
 72 
 73 #if ENABLE(WEBGL2)
 74 #include &quot;WebGL2RenderingContext.h&quot;
 75 #endif
 76 
 77 #if ENABLE(WEBGPU)
 78 #include &quot;GPUCanvasContext.h&quot;
 79 #endif
 80 
 81 #if PLATFORM(COCOA)
 82 #include &quot;MediaSampleAVFObjC.h&quot;
 83 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
 84 #endif
 85 
 86 #if USE(CG)
 87 #include &quot;ImageBufferUtilitiesCG.h&quot;
 88 #endif
 89 
 90 namespace WebCore {
 91 
 92 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
 93 
 94 using namespace PAL;
 95 using namespace HTMLNames;
 96 
 97 // These values come from the WhatWG/W3C HTML spec.
 98 const int defaultWidth = 300;
 99 const int defaultHeight = 150;
100 
101 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
102 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
103 // in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.
104 #if PLATFORM(IOS_FAMILY)
105 const unsigned maxCanvasArea = 4096 * 4096;
106 #else
107 const unsigned maxCanvasArea = 16384 * 16384;
108 #endif
109 
110 static size_t maxActivePixelMemoryForTesting = 0;
111 
112 HTMLCanvasElement::HTMLCanvasElement(const QualifiedName&amp; tagName, Document&amp; document)
113     : HTMLElement(tagName, document)
114     , CanvasBase(IntSize(defaultWidth, defaultHeight))
115 {
116     ASSERT(hasTagName(canvasTag));
117 }
118 
119 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(Document&amp; document)
120 {
121     return adoptRef(*new HTMLCanvasElement(canvasTag, document));
122 }
123 
124 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(const QualifiedName&amp; tagName, Document&amp; document)
125 {
126     return adoptRef(*new HTMLCanvasElement(tagName, document));
127 }
128 
129 HTMLCanvasElement::~HTMLCanvasElement()
130 {
131     // FIXME: This has to be called here because CSSCanvasValue::CanvasObserverProxy::canvasDestroyed()
132     // downcasts the CanvasBase object to HTMLCanvasElement. That invokes virtual methods, which should be
133     // avoided in destructors, but works as long as it&#39;s done before HTMLCanvasElement destructs completely.
134     notifyObserversCanvasDestroyed();
135 
136     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
137     setImageBuffer(nullptr);
138 }
139 
140 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
141 {
142     if (name == widthAttr || name == heightAttr)
143         reset();
144     HTMLElement::parseAttribute(name, value);
145 }
146 
147 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
148 {
149     RefPtr&lt;Frame&gt; frame = document().frame();
150     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
151         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
152     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
153 }
154 
155 bool HTMLCanvasElement::canContainRangeEndPoint() const
156 {
157     return false;
158 }
159 
160 bool HTMLCanvasElement::canStartSelection() const
161 {
162     return false;
163 }
164 
165 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
166 {
167     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
168         return Exception { InvalidStateError };
169     setAttributeWithoutSynchronization(heightAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));
170     return { };
171 }
172 
173 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
174 {
175     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
176         return Exception { InvalidStateError };
177     setAttributeWithoutSynchronization(widthAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));
178     return { };
179 }
180 
181 void HTMLCanvasElement::setSize(const IntSize&amp; newSize)
182 {
183     if (newSize == size())
184         return;
185 
186     m_ignoreReset = true;
187     setWidth(newSize.width());
188     setHeight(newSize.height());
189     m_ignoreReset = false;
190     reset();
191 }
192 
193 static inline size_t maxActivePixelMemory()
194 {
195     if (maxActivePixelMemoryForTesting)
196         return maxActivePixelMemoryForTesting;
197 
198     static size_t maxPixelMemory;
199     static std::once_flag onceFlag;
200     std::call_once(onceFlag, [] {
201 #if PLATFORM(IOS_FAMILY)
202         maxPixelMemory = ramSize() / 4;
203 #else
204         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
205 #endif
206     });
207 
208     return maxPixelMemory;
209 }
210 
211 void HTMLCanvasElement::setMaxPixelMemoryForTesting(size_t size)
212 {
213     maxActivePixelMemoryForTesting = size;
214 }
215 
216 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::JSGlobalObject&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)
217 {
218     if (m_context) {
219         if (m_context-&gt;isPlaceholder())
220             return Exception { InvalidStateError };
221 
222         if (m_context-&gt;is2d()) {
223             if (!is2dType(contextId))
224                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
225             return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*m_context) } };
226         }
227 
228         if (m_context-&gt;isBitmapRenderer()) {
229             if (!isBitmapRendererType(contextId))
230                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
231             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
232         }
233 
234 #if ENABLE(WEBGL)
235         if (m_context-&gt;isWebGL()) {
236             if (!isWebGLType(contextId))
237                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
238             if (is&lt;WebGLRenderingContext&gt;(*m_context))
239                 return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
240 #if ENABLE(WEBGL2)
241             ASSERT(is&lt;WebGL2RenderingContext&gt;(*m_context));
242             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*m_context) } };
243 #endif
244         }
245 #endif
246 
247 #if ENABLE(WEBGPU)
248         if (m_context-&gt;isWebGPU()) {
249             if (!isWebGPUType(contextId))
250                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
251             return Optional&lt;RenderingContext&gt; { RefPtr&lt;GPUCanvasContext&gt; { &amp;downcast&lt;GPUCanvasContext&gt;(*m_context) } };
252         }
253 #endif
254 
255         ASSERT_NOT_REACHED();
256         return Optional&lt;RenderingContext&gt; { WTF::nullopt };
257     }
258 
259     if (is2dType(contextId)) {
260         auto context = createContext2d(contextId);
261         if (!context)
262             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
263         return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { context } };
264     }
265 
266     if (isBitmapRendererType(contextId)) {
267         auto scope = DECLARE_THROW_SCOPE(state.vm());
268         auto attributes = convert&lt;IDLDictionary&lt;ImageBitmapRenderingContextSettings&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
269         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
270 
271         auto context = createContextBitmapRenderer(contextId, WTFMove(attributes));
272         if (!context)
273             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
274         return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { context } };
275     }
276 
277 #if ENABLE(WEBGL)
278     if (isWebGLType(contextId)) {
279         auto scope = DECLARE_THROW_SCOPE(state.vm());
280         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
281         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
282 
283         auto context = createContextWebGL(contextId, WTFMove(attributes));
284         if (!context)
285             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
286 
287         if (is&lt;WebGLRenderingContext&gt;(*context))
288             return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*context) } };
289 #if ENABLE(WEBGL2)
290         ASSERT(is&lt;WebGL2RenderingContext&gt;(*context));
291         return Optional&lt;RenderingContext&gt; { RefPtr&lt;WebGL2RenderingContext&gt; { &amp;downcast&lt;WebGL2RenderingContext&gt;(*context) } };
292 #endif
293     }
294 #endif
295 
296 #if ENABLE(WEBGPU)
297     if (isWebGPUType(contextId)) {
298         auto context = createContextWebGPU(contextId);
299         if (!context)
300             return Optional&lt;RenderingContext&gt; { WTF::nullopt };
301         return Optional&lt;RenderingContext&gt; { RefPtr&lt;GPUCanvasContext&gt; { context } };
302     }
303 #endif
304 
305     return Optional&lt;RenderingContext&gt; { WTF::nullopt };
306 }
307 
308 CanvasRenderingContext* HTMLCanvasElement::getContext(const String&amp; type)
309 {
310     if (HTMLCanvasElement::is2dType(type))
311         return getContext2d(type);
312 
313     if (HTMLCanvasElement::isBitmapRendererType(type))
314         return getContextBitmapRenderer(type);
315 
316 #if ENABLE(WEBGL)
317     if (HTMLCanvasElement::isWebGLType(type))
318         return getContextWebGL(type);
319 #endif
320 
321 #if ENABLE(WEBGPU)
322     if (HTMLCanvasElement::isWebGPUType(type))
323         return getContextWebGPU(type);
324 #endif
325 
326     return nullptr;
327 }
328 
329 bool HTMLCanvasElement::is2dType(const String&amp; type)
330 {
331     return type == &quot;2d&quot;;
332 }
333 
334 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
335 {
336     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
337     ASSERT(!m_context);
338 
339     // Make sure we don&#39;t use more pixel memory than the system can support.
340     size_t requestedPixelMemory = 4 * width() * height();
341     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {
342         StringBuilder stringBuilder;
343         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
344         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
345         stringBuilder.appendLiteral(&quot; MB).&quot;);
346         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
347         return nullptr;
348     }
349 
350     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode());
351 
352     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
353     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
354 
355 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
356     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
357     invalidateStyleAndLayerComposition();
358 #endif
359 
360     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
361 }
362 
363 CanvasRenderingContext2D* HTMLCanvasElement::getContext2d(const String&amp; type)
364 {
365     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
366 
367     if (m_context &amp;&amp; !m_context-&gt;is2d())
368         return nullptr;
369 
370     if (!m_context)
371         return createContext2d(type);
372     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
373 }
374 
375 #if ENABLE(WEBGL)
376 
377 static bool requiresAcceleratedCompositingForWebGL()
378 {
379 #if PLATFORM(GTK) || PLATFORM(WIN_CAIRO)
380     return false;
381 #else
382     return true;
383 #endif
384 
385 }
386 static bool shouldEnableWebGL(const Settings&amp; settings)
387 {
388     if (!settings.webGLEnabled())
389         return false;
390 
391     if (!requiresAcceleratedCompositingForWebGL())
392         return true;
393 
394     return settings.acceleratedCompositingEnabled();
395 }
396 
397 bool HTMLCanvasElement::isWebGLType(const String&amp; type)
398 {
399     // Retain support for the legacy &quot;webkit-3d&quot; name.
400     return type == &quot;webgl&quot; || type == &quot;experimental-webgl&quot;
401 #if ENABLE(WEBGL2)
402         || type == &quot;webgl2&quot;
403 #endif
404         || type == &quot;webkit-3d&quot;;
405 }
406 
407 WebGLRenderingContextBase* HTMLCanvasElement::createContextWebGL(const String&amp; type, WebGLContextAttributes&amp;&amp; attrs)
408 {
409     ASSERT(HTMLCanvasElement::isWebGLType(type));
410     ASSERT(!m_context);
411 
412     if (!shouldEnableWebGL(document().settings()))
413         return nullptr;
414 
415     m_context = WebGLRenderingContextBase::create(*this, attrs, type);
416     if (m_context) {
417         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
418         invalidateStyleAndLayerComposition();
419     }
420 
421     return downcast&lt;WebGLRenderingContextBase&gt;(m_context.get());
422 }
423 
424 WebGLRenderingContextBase* HTMLCanvasElement::getContextWebGL(const String&amp; type, WebGLContextAttributes&amp;&amp; attrs)
425 {
426     ASSERT(HTMLCanvasElement::isWebGLType(type));
427 
428     if (!shouldEnableWebGL(document().settings()))
429         return nullptr;
430 
431     if (m_context &amp;&amp; !m_context-&gt;isWebGL())
432         return nullptr;
433 
434     if (!m_context)
435         return createContextWebGL(type, WTFMove(attrs));
436     return &amp;downcast&lt;WebGLRenderingContextBase&gt;(*m_context);
437 }
438 
439 #endif // ENABLE(WEBGL)
440 
441 #if ENABLE(WEBGPU)
442 
443 bool HTMLCanvasElement::isWebGPUType(const String&amp; type)
444 {
445     return type == &quot;gpu&quot;;
446 }
447 
448 GPUCanvasContext* HTMLCanvasElement::createContextWebGPU(const String&amp; type)
449 {
450     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
451     ASSERT(!m_context);
452 
453     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
454         return nullptr;
455 
456     m_context = GPUCanvasContext::create(*this);
457     if (m_context) {
458         // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
459         invalidateStyleAndLayerComposition();
460     }
461 
462     return static_cast&lt;GPUCanvasContext*&gt;(m_context.get());
463 }
464 
465 GPUCanvasContext* HTMLCanvasElement::getContextWebGPU(const String&amp; type)
466 {
467     ASSERT_UNUSED(type, HTMLCanvasElement::isWebGPUType(type));
468 
469     if (!RuntimeEnabledFeatures::sharedFeatures().webGPUEnabled())
470         return nullptr;
471 
472     if (m_context &amp;&amp; !m_context-&gt;isWebGPU())
473         return nullptr;
474 
475     if (!m_context)
476         return createContextWebGPU(type);
477     return static_cast&lt;GPUCanvasContext*&gt;(m_context.get());
478 }
479 
480 #endif // ENABLE(WEBGPU)
481 
482 bool HTMLCanvasElement::isBitmapRendererType(const String&amp; type)
483 {
484     return type == &quot;bitmaprenderer&quot;;
485 }
486 
487 ImageBitmapRenderingContext* HTMLCanvasElement::createContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
488 {
489     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
490     ASSERT(!m_context);
491 
492     m_context = ImageBitmapRenderingContext::create(*this, WTFMove(settings));
493 
494 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
495     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
496     invalidateStyleAndLayerComposition();
497 #endif
498 
499     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
500 }
501 
502 ImageBitmapRenderingContext* HTMLCanvasElement::getContextBitmapRenderer(const String&amp; type, ImageBitmapRenderingContextSettings&amp;&amp; settings)
503 {
504     ASSERT_UNUSED(type, HTMLCanvasElement::isBitmapRendererType(type));
505     if (!m_context)
506         return createContextBitmapRenderer(type, WTFMove(settings));
507     return static_cast&lt;ImageBitmapRenderingContext*&gt;(m_context.get());
508 }
509 
510 void HTMLCanvasElement::didDraw(const FloatRect&amp; rect)
511 {
512     clearCopiedImage();
513 
514     FloatRect dirtyRect = rect;
515     if (auto* renderer = renderBox()) {
516         FloatRect destRect;
517         if (is&lt;RenderReplaced&gt;(renderer))
518             destRect = downcast&lt;RenderReplaced&gt;(renderer)-&gt;replacedContentRect();
519         else
520             destRect = renderer-&gt;contentBoxRect();
521 
522         // Inflate dirty rect to cover antialiasing on image buffers.
523         if (drawingContext() &amp;&amp; drawingContext()-&gt;shouldAntialias())
524             dirtyRect.inflate(1);
525 
526         FloatRect r = mapRect(dirtyRect, FloatRect(0, 0, size().width(), size().height()), destRect);
527         r.intersect(destRect);
528 
529         if (!r.isEmpty() &amp;&amp; !m_dirtyRect.contains(r)) {
530             m_dirtyRect.unite(r);
531             renderer-&gt;repaintRectangle(enclosingIntRect(m_dirtyRect));
532         }
533     }
534     notifyObserversCanvasChanged(dirtyRect);
535 }
536 
537 void HTMLCanvasElement::reset()
538 {
539     if (m_ignoreReset)
540         return;
541 
542     bool hadImageBuffer = hasCreatedImageBuffer();
543 
544     int w = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(widthAttr), defaultWidth);
545     int h = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(heightAttr), defaultHeight);
546 
547     resetGraphicsContextState();
548     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
549         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).reset();
550 
551     IntSize oldSize = size();
552     IntSize newSize(w, h);
553     // If the size of an existing buffer matches, we can just clear it instead of reallocating.
554     // This optimization is only done for 2D canvases for now.
555     if (m_hasCreatedImageBuffer &amp;&amp; oldSize == newSize &amp;&amp; m_context &amp;&amp; m_context-&gt;is2d()) {
556         if (!m_didClearImageBuffer)
557             clearImageBuffer();
558         return;
559     }
560 
561     setSurfaceSize(newSize);
562 
563     if (isGPUBased() &amp;&amp; oldSize != size())
564         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).reshape(width(), height());
565 
566     auto renderer = this-&gt;renderer();
567     if (is&lt;RenderHTMLCanvas&gt;(renderer)) {
568         auto&amp; canvasRenderer = downcast&lt;RenderHTMLCanvas&gt;(*renderer);
569         if (oldSize != size()) {
570             canvasRenderer.canvasSizeChanged();
571             if (canvasRenderer.hasAcceleratedCompositing())
572                 canvasRenderer.contentChanged(CanvasChanged);
573         }
574         if (hadImageBuffer)
575             canvasRenderer.repaint();
576     }
577 
578     notifyObserversCanvasResized();
579 }
580 
581 bool HTMLCanvasElement::paintsIntoCanvasBuffer() const
582 {
583     ASSERT(m_context);
584 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
585     if (m_context-&gt;is2d() || m_context-&gt;isBitmapRenderer())
586         return true;
587 #endif
588 
589     if (!m_context-&gt;isAccelerated())
590         return true;
591 
592     if (renderBox() &amp;&amp; renderBox()-&gt;hasAcceleratedCompositing())
593         return false;
594 
595     return true;
596 }
597 
598 
599 void HTMLCanvasElement::paint(GraphicsContext&amp; context, const LayoutRect&amp; r)
600 {
601     // Clear the dirty rect
602     m_dirtyRect = FloatRect();
603 
604     if (!context.paintingDisabled()) {
605         bool shouldPaint = true;
606 
607         if (m_context) {
608             shouldPaint = paintsIntoCanvasBuffer() || document().printing();
609             if (shouldPaint)
610                 m_context-&gt;paintRenderingResultsToCanvas();
611         }
612 
613         if (shouldPaint) {
614             if (hasCreatedImageBuffer()) {
615                 if (m_presentedImage)
616                     context.drawImage(*m_presentedImage, snappedIntRect(r), renderer()-&gt;imageOrientation());
617                 else if (ImageBuffer* imageBuffer = buffer())
618                     context.drawImageBuffer(*imageBuffer, snappedIntRect(r));
619             }
620 
621             if (isGPUBased())
622                 downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();
623         }
624     }
625 
626     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))
627         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);
628 }
629 
630 bool HTMLCanvasElement::isGPUBased() const
631 {
632     return m_context &amp;&amp; m_context-&gt;isGPUBased();
633 }
634 
635 void HTMLCanvasElement::makePresentationCopy()
636 {
637     if (!m_presentedImage) {
638         // The buffer contains the last presented data, so save a copy of it.
639         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
640     }
641 }
642 
643 void HTMLCanvasElement::clearPresentationCopy()
644 {
645     m_presentedImage = nullptr;
646 }
647 
648 void HTMLCanvasElement::setSurfaceSize(const IntSize&amp; size)
649 {
650     CanvasBase::setSize(size);
651     m_hasCreatedImageBuffer = false;
652     setImageBuffer(nullptr);
653     clearCopiedImage();
654 }
655 
656 static String toEncodingMimeType(const String&amp; mimeType)
657 {
658     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
659         return &quot;image/png&quot;_s;
660     return mimeType.convertToASCIILowercase();
661 }
662 
663 // https://html.spec.whatwg.org/multipage/canvas.html#a-serialisation-of-the-bitmap-as-a-file
664 static Optional&lt;double&gt; qualityFromJSValue(JSC::JSValue qualityValue)
665 {
666     if (!qualityValue.isNumber())
667         return WTF::nullopt;
668 
669     double qualityNumber = qualityValue.asNumber();
670     if (qualityNumber &lt; 0 || qualityNumber &gt; 1)
671         return WTF::nullopt;
672 
673     return qualityNumber;
674 }
675 
676 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType, JSC::JSValue qualityValue)
677 {
678     if (!originClean())
679         return Exception { SecurityError };
680 
681     if (size().isEmpty() || !buffer())
682         return UncachedString { &quot;data:,&quot;_s };
683     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
684         ResourceLoadObserver::shared().logCanvasRead(document());
685 
686     auto encodingMIMEType = toEncodingMimeType(mimeType);
687     auto quality = qualityFromJSValue(qualityValue);
688 
689 #if USE(CG)
690     // Try to get ImageData first, as that may avoid lossy conversions.
691     if (auto imageData = getImageData())
692         return UncachedString { dataURL(*imageData, encodingMIMEType, quality) };
693 #endif
694 
695     makeRenderingResultsAvailable();
696 
697     return UncachedString { buffer()-&gt;toDataURL(encodingMIMEType, quality) };
698 }
699 
700 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType)
701 {
702     return toDataURL(mimeType, { });
703 }
704 
705 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
706 {
707     if (!originClean())
708         return Exception { SecurityError };
709 
710     if (size().isEmpty() || !buffer()) {
711         callback-&gt;scheduleCallback(context, nullptr);
712         return { };
713     }
714     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
715         ResourceLoadObserver::shared().logCanvasRead(document());
716 
717     auto encodingMIMEType = toEncodingMimeType(mimeType);
718     auto quality = qualityFromJSValue(qualityValue);
719 
720 #if USE(CG)
721     if (auto imageData = getImageData()) {
722         RefPtr&lt;Blob&gt; blob;
723         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
724         if (!blobData.isEmpty())
725             blob = Blob::create(WTFMove(blobData), encodingMIMEType);
726         callback-&gt;scheduleCallback(context, WTFMove(blob));
727         return { };
728     }
729 #endif
730 
731     makeRenderingResultsAvailable();
732 
733     RefPtr&lt;Blob&gt; blob;
734     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
735     if (!blobData.isEmpty())
736         blob = Blob::create(WTFMove(blobData), encodingMIMEType);
737     callback-&gt;scheduleCallback(context, WTFMove(blob));
738     return { };
739 }
740 
741 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
742 {
743 #if ENABLE(WEBGL)
744     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
745         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
746             ResourceLoadObserver::shared().logCanvasRead(document());
747         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
748     }
749 #endif
750     return nullptr;
751 }
752 
753 #if ENABLE(MEDIA_STREAM)
754 
755 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
756 {
757     auto* imageBuffer = buffer();
758     if (!imageBuffer)
759         return nullptr;
760     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
761         ResourceLoadObserver::shared().logCanvasRead(document());
762 
763 #if PLATFORM(COCOA)
764     makeRenderingResultsAvailable();
765     return MediaSampleAVFObjC::createImageSample(imageBuffer-&gt;toBGRAData(), width(), height());
766 #else
767     return nullptr;
768 #endif
769 }
770 
771 ExceptionOr&lt;Ref&lt;MediaStream&gt;&gt; HTMLCanvasElement::captureStream(Document&amp; document, Optional&lt;double&gt;&amp;&amp; frameRequestRate)
772 {
773     if (!originClean())
774         return Exception(SecurityError, &quot;Canvas is tainted&quot;_s);
775     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
776         ResourceLoadObserver::shared().logCanvasRead(this-&gt;document());
777 
778     if (frameRequestRate &amp;&amp; frameRequestRate.value() &lt; 0)
779         return Exception(NotSupportedError, &quot;frameRequestRate is negative&quot;_s);
780 
781     auto track = CanvasCaptureMediaStreamTrack::create(document, *this, WTFMove(frameRequestRate));
782     auto stream =  MediaStream::create(document);
783     stream-&gt;addTrack(track);
784     return stream;
785 }
786 #endif
787 
788 SecurityOrigin* HTMLCanvasElement::securityOrigin() const
789 {
790     return &amp;document().securityOrigin();
791 }
792 
793 bool HTMLCanvasElement::shouldAccelerate(const IntSize&amp; size) const
794 {
795     auto&amp; settings = document().settings();
796 
797     auto area = size.area&lt;RecordOverflow&gt;();
798     if (area.hasOverflowed())
799         return false;
800 
801     if (area &gt; settings.maximumAccelerated2dCanvasSize())
802         return false;
803 
804 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
805     return settings.canvasUsesAcceleratedDrawing();
806 #elif ENABLE(ACCELERATED_2D_CANVAS)
807     if (m_context &amp;&amp; !m_context-&gt;is2d())
808         return false;
809 
810     if (!settings.accelerated2dCanvasEnabled())
811         return false;
812 
813     if (area &lt; settings.minimumAccelerated2dCanvasSize())
814         return false;
815 
816     return true;
817 #else
818     UNUSED_PARAM(size);
819     return false;
820 #endif
821 }
822 
823 void HTMLCanvasElement::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
824 {
825     if (usesDisplayListDrawing == m_usesDisplayListDrawing)
826         return;
827 
828     m_usesDisplayListDrawing = usesDisplayListDrawing;
829 
830     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
831         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
832 }
833 
834 void HTMLCanvasElement::setTracksDisplayListReplay(bool tracksDisplayListReplay)
835 {
836     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
837         return;
838 
839     m_tracksDisplayListReplay = tracksDisplayListReplay;
840 
841     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
842         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
843 }
844 
845 String HTMLCanvasElement::displayListAsText(DisplayList::AsTextFlags flags) const
846 {
847     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
848         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).displayListAsText(flags);
849 
850     return String();
851 }
852 
853 String HTMLCanvasElement::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
854 {
855     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
856         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).replayDisplayListAsText(flags);
857 
858     return String();
859 }
860 
861 void HTMLCanvasElement::createImageBuffer() const
862 {
863     ASSERT(!hasCreatedImageBuffer());
864 
865     m_hasCreatedImageBuffer = true;
866     m_didClearImageBuffer = true;
867 
868     // Perform multiplication as floating point to avoid overflow
869     if (float(width()) * height() &gt; maxCanvasArea) {
870         StringBuilder stringBuilder;
871         stringBuilder.appendLiteral(&quot;Canvas area exceeds the maximum limit (width * height &gt; &quot;);
872         stringBuilder.appendNumber(maxCanvasArea);
873         stringBuilder.appendLiteral(&quot;).&quot;);
874         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
875         return;
876     }
877 
878     // Make sure we don&#39;t use more pixel memory than the system can support.
879     size_t requestedPixelMemory = 4 * width() * height();
880     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {
881         StringBuilder stringBuilder;
882         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
883         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
884         stringBuilder.appendLiteral(&quot; MB).&quot;);
885         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
886         return;
887     }
888 
889     if (!width() || !height())
890         return;
891 
892     RenderingMode renderingMode = shouldAccelerate(size()) ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;
893 
894     auto hostWindow = (document().view() &amp;&amp; document().view()-&gt;root()) ? document().view()-&gt;root()-&gt;hostWindow() : nullptr;
895     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpace::SRGB, hostWindow));
896 
897 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
898     if (m_context &amp;&amp; m_context-&gt;is2d()) {
899         // Recalculate compositing requirements if acceleration state changed.
900         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
901     }
902 #endif
903 }
904 
905 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
906 {
907     m_hasCreatedImageBuffer = true;
908     setImageBuffer(WTFMove(buffer));
909     didDraw(FloatRect(FloatPoint(), size()));
910 }
911 
912 Image* HTMLCanvasElement::copiedImage() const
913 {
914     if (!m_copiedImage &amp;&amp; buffer()) {
915         if (m_context)
916             m_context-&gt;paintRenderingResultsToCanvas();
917         m_copiedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
918     }
919     return m_copiedImage.get();
920 }
921 
922 void HTMLCanvasElement::clearImageBuffer() const
923 {
924     ASSERT(m_hasCreatedImageBuffer);
925     ASSERT(!m_didClearImageBuffer);
926     ASSERT(m_context);
927 
928     m_didClearImageBuffer = true;
929 
930     if (is&lt;CanvasRenderingContext2D&gt;(*m_context)) {
931         // No need to undo transforms/clip/etc. because we are called right after the context is reset.
932         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).clearRect(0, 0, width(), height());
933     }
934 }
935 
936 void HTMLCanvasElement::clearCopiedImage()
937 {
938     m_copiedImage = nullptr;
939     m_didClearImageBuffer = false;
940 }
941 
942 }
    </pre>
  </body>
</html>
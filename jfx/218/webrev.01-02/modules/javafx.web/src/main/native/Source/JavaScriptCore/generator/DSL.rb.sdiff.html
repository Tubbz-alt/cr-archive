<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/DSL.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Argument.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GeneratedFile.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/DSL.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Assertion&#39;

 25 require_relative &#39;Section&#39;
 26 require_relative &#39;Template&#39;
 27 require_relative &#39;Type&#39;
<span class="line-modified"> 28 require_relative &#39;GeneratedFile&#39;</span>
 29 
 30 module DSL
 31     @sections = []

 32     @current_section = nil
 33     @context = binding()
 34     @namespaces = []
 35 
 36     def self.begin_section(name, config={})
 37         assert(&quot;must call `end_section` before beginning a new section&quot;) { @current_section.nil? }
 38         @current_section = Section.new name, config
 39     end
 40 
 41     def self.end_section(name)
 42         assert(&quot;current section&#39;s name is `#{@current_section.name}`, but end_section was called with `#{name}`&quot;) { @current_section.name == name }
 43         @current_section.sort!
 44         @sections &lt;&lt; @current_section




 45         @current_section = nil
 46     end
 47 
 48     def self.op(name, config = {})
 49         assert(&quot;`op` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 50         @current_section.add_opcode(name, config)
 51     end
 52 
 53     def self.op_group(desc, ops, config)
 54         assert(&quot;`op_group` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 55         @current_section.add_opcode_group(desc, ops, config)
 56     end
 57 
 58     def self.types(types)
 59         types.map do |type|
 60             type = (@namespaces + [type]).join &quot;::&quot;
 61             @context.eval(&quot;#{type} = Type.new &#39;#{type}&#39;&quot;)
 62         end
 63     end
 64 
</pre>
<hr />
<pre>
 68             @context.eval(&quot;#{type} = Template.new &#39;#{type}&#39;&quot;)
 69         end
 70     end
 71 
 72     def self.namespace(name)
 73         @namespaces &lt;&lt; name.to_s
 74         ctx = @context
 75         @context = @context.eval(&quot;
 76             module #{name}
 77               def self.get_binding
 78                 binding()
 79               end
 80             end
 81             #{name}.get_binding
 82          &quot;)
 83         yield
 84         @context = ctx
 85         @namespaces.pop
 86     end
 87 






 88     def self.run(options)
<span class="line-modified"> 89         bytecodeListPath = options[:bytecodeList]</span>
<span class="line-modified"> 90         bytecodeList = File.open(bytecodeListPath)</span>
<span class="line-modified"> 91         @context.eval(bytecodeList.read, bytecodeListPath)</span>



 92         assert(&quot;must end last section&quot;) { @current_section.nil? }
 93 
<span class="line-modified"> 94         write_bytecodes(bytecodeList, options[:bytecodesFilename])</span>
<span class="line-modified"> 95         write_bytecode_structs(bytecodeList, options[:bytecodeStructsFilename])</span>
<span class="line-modified"> 96         write_init_asm(bytecodeList, options[:initAsmFilename])</span>
<span class="line-modified"> 97         write_indices(bytecodeList, options[:bytecodeIndicesFilename])</span>



 98     end
 99 
100     def self.write_bytecodes(bytecode_list, bytecodes_filename)
101         GeneratedFile::create(bytecodes_filename, bytecode_list) do |template|
102             template.prefix = &quot;#pragma once\n&quot;
103             num_opcodes = @sections.map(&amp;:opcodes).flatten.size
<span class="line-modified">104             template.body = &lt;&lt;-EOF</span>
<span class="line-modified">105 #{@sections.map { |s| s.header_helpers(num_opcodes) }.join(&quot;\n&quot;)}</span>
<span class="line-modified">106 #define FOR_EACH_BYTECODE_STRUCT(macro) \\</span>
<span class="line-modified">107 #{opcodes_for(:emit_in_structs_file).map { |op| &quot;    macro(#{op.capitalized_name}) \\&quot; }.join(&quot;\n&quot;)}</span>
<span class="line-removed">108             EOF</span>
109         end
110     end
111 
112     def self.write_bytecode_structs(bytecode_list, bytecode_structs_filename)
113         GeneratedFile::create(bytecode_structs_filename, bytecode_list) do |template|
<span class="line-removed">114             opcodes = opcodes_for(:emit_in_structs_file)</span>
<span class="line-removed">115 </span>
116             template.prefix = &lt;&lt;-EOF
117 #pragma once
118 
119 #include &quot;ArithProfile.h&quot;
120 #include &quot;BytecodeDumper.h&quot;
<span class="line-removed">121 #include &quot;BytecodeGenerator.h&quot;</span>
122 #include &quot;Fits.h&quot;
123 #include &quot;GetByIdMetadata.h&quot;

124 #include &quot;Instruction.h&quot;
125 #include &quot;Opcode.h&quot;
126 #include &quot;PutByIdStatus.h&quot;
127 #include &quot;PutByIdFlags.h&quot;
128 #include &quot;ToThisStatus.h&quot;
129 
130 namespace JSC {







131 EOF
132 
133             template.body = &lt;&lt;-EOF
<span class="line-modified">134 #{opcodes.map(&amp;:struct).join(&quot;\n&quot;)}</span>
<span class="line-modified">135 #{Opcode.dump_bytecode(opcodes)}</span>



136 EOF
137             template.suffix = &quot;} // namespace JSC&quot;
138         end
139     end
140 
<span class="line-modified">141     def self.write_init_asm(bytecode_list, init_asm_filename)</span>
<span class="line-modified">142         opcodes = opcodes_for(:emit_in_asm_file)</span>











143 
<span class="line-modified">144         GeneratedFile::create(init_asm_filename, bytecode_list) do |template|</span>









145             template.multiline_comment = nil
146             template.line_comment = &quot;#&quot;
147             template.body = (opcodes.map.with_index(&amp;:set_entry_address) + opcodes.map.with_index(&amp;:set_entry_address_wide16) + opcodes.map.with_index(&amp;:set_entry_address_wide32)) .join(&quot;\n&quot;)
148         end
149     end
150 














151     def self.write_indices(bytecode_list, indices_filename)
152         opcodes = opcodes_for(:emit_in_structs_file)
153 
154         GeneratedFile::create(indices_filename, bytecode_list) do |template|
155             template.prefix = &quot;namespace JSC {\n&quot;
156             template.body = opcodes.map(&amp;:struct_indices).join(&quot;\n&quot;)
157             template.suffix = &quot;\n} // namespace JSC&quot;
158         end
159     end
160 
161     def self.opcodes_for(file)
162         sections = @sections.select { |s| s.config[file] }
163         sections.map(&amp;:opcodes).flatten
164     end





165 end
</pre>
</td>
<td>
<hr />
<pre>
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Assertion&#39;
<span class="line-added"> 25 require_relative &#39;GeneratedFile&#39;</span>
 26 require_relative &#39;Section&#39;
 27 require_relative &#39;Template&#39;
 28 require_relative &#39;Type&#39;
<span class="line-modified"> 29 require_relative &#39;Wasm&#39;</span>
 30 
 31 module DSL
 32     @sections = []
<span class="line-added"> 33     @wasm_section = nil</span>
 34     @current_section = nil
 35     @context = binding()
 36     @namespaces = []
 37 
 38     def self.begin_section(name, config={})
 39         assert(&quot;must call `end_section` before beginning a new section&quot;) { @current_section.nil? }
 40         @current_section = Section.new name, config
 41     end
 42 
 43     def self.end_section(name)
 44         assert(&quot;current section&#39;s name is `#{@current_section.name}`, but end_section was called with `#{name}`&quot;) { @current_section.name == name }
 45         @current_section.sort!
 46         @sections &lt;&lt; @current_section
<span class="line-added"> 47         if @current_section.is_wasm?</span>
<span class="line-added"> 48           assert(&quot;Cannot have 2 wasm sections&quot;) { @wasm_section.nil? }</span>
<span class="line-added"> 49           @wasm_section = @current_section</span>
<span class="line-added"> 50         end</span>
 51         @current_section = nil
 52     end
 53 
 54     def self.op(name, config = {})
 55         assert(&quot;`op` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 56         @current_section.add_opcode(name, config)
 57     end
 58 
 59     def self.op_group(desc, ops, config)
 60         assert(&quot;`op_group` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }
 61         @current_section.add_opcode_group(desc, ops, config)
 62     end
 63 
 64     def self.types(types)
 65         types.map do |type|
 66             type = (@namespaces + [type]).join &quot;::&quot;
 67             @context.eval(&quot;#{type} = Type.new &#39;#{type}&#39;&quot;)
 68         end
 69     end
 70 
</pre>
<hr />
<pre>
 74             @context.eval(&quot;#{type} = Template.new &#39;#{type}&#39;&quot;)
 75         end
 76     end
 77 
 78     def self.namespace(name)
 79         @namespaces &lt;&lt; name.to_s
 80         ctx = @context
 81         @context = @context.eval(&quot;
 82             module #{name}
 83               def self.get_binding
 84                 binding()
 85               end
 86             end
 87             #{name}.get_binding
 88          &quot;)
 89         yield
 90         @context = ctx
 91         @namespaces.pop
 92     end
 93 
<span class="line-added"> 94     def self.autogenerate_wasm_opcodes()</span>
<span class="line-added"> 95         assert(&quot;`autogenerate_wasm_opcodes` can only be called in between `begin_section` and `end_section`&quot;) { not @current_section.nil? }</span>
<span class="line-added"> 96         assert(&quot;`autogenerate_wasm_opcodes` can only be called from the `Wasm` section&quot;) { @current_section.name == :Wasm }</span>
<span class="line-added"> 97         Wasm::autogenerate_opcodes(@context, @wasm_json)</span>
<span class="line-added"> 98     end</span>
<span class="line-added"> 99 </span>
100     def self.run(options)
<span class="line-modified">101         bytecode_list_path = options[:bytecode_list]</span>
<span class="line-modified">102         bytecode_list = File.open(bytecode_list_path).read</span>
<span class="line-modified">103 </span>
<span class="line-added">104         @wasm_json = File.open(options[:wasm_json_filename]).read</span>
<span class="line-added">105 </span>
<span class="line-added">106         @context.eval(bytecode_list, bytecode_list_path)</span>
107         assert(&quot;must end last section&quot;) { @current_section.nil? }
108 
<span class="line-modified">109         write_bytecodes(bytecode_list, options[:bytecodes_filename])</span>
<span class="line-modified">110         write_bytecode_structs(bytecode_list, options[:bytecode_structs_filename])</span>
<span class="line-modified">111         write_bytecode_dumper(bytecode_list, options[:bytecode_dumper_filename])</span>
<span class="line-modified">112         write_bytecodes_init(options[:init_asm_filename], bytecode_list)</span>
<span class="line-added">113         write_indices(bytecode_list, options[:bytecode_indices_filename])</span>
<span class="line-added">114         write_llint_generator(options[:wasm_llint_generator_filename], bytecode_list, @wasm_json)</span>
<span class="line-added">115         write_wasm_init(options[:wasm_init_filename], bytecode_list, @wasm_json)</span>
116     end
117 
118     def self.write_bytecodes(bytecode_list, bytecodes_filename)
119         GeneratedFile::create(bytecodes_filename, bytecode_list) do |template|
120             template.prefix = &quot;#pragma once\n&quot;
121             num_opcodes = @sections.map(&amp;:opcodes).flatten.size
<span class="line-modified">122             template.body = [</span>
<span class="line-modified">123                 @sections.map { |s| s.header_helpers(num_opcodes) },</span>
<span class="line-modified">124                 @sections.select { |s| s.config[:emit_in_structs_file] }.map(&amp;:for_each_struct)</span>
<span class="line-modified">125             ].flatten.join(&quot;\n&quot;)</span>

126         end
127     end
128 
129     def self.write_bytecode_structs(bytecode_list, bytecode_structs_filename)
130         GeneratedFile::create(bytecode_structs_filename, bytecode_list) do |template|


131             template.prefix = &lt;&lt;-EOF
132 #pragma once
133 
134 #include &quot;ArithProfile.h&quot;
135 #include &quot;BytecodeDumper.h&quot;

136 #include &quot;Fits.h&quot;
137 #include &quot;GetByIdMetadata.h&quot;
<span class="line-added">138 #include &quot;GetByValHistory.h&quot;</span>
139 #include &quot;Instruction.h&quot;
140 #include &quot;Opcode.h&quot;
141 #include &quot;PutByIdStatus.h&quot;
142 #include &quot;PutByIdFlags.h&quot;
143 #include &quot;ToThisStatus.h&quot;
144 
145 namespace JSC {
<span class="line-added">146 </span>
<span class="line-added">147 void dumpBytecode(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);</span>
<span class="line-added">148 </span>
<span class="line-added">149 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">150 void dumpWasm(BytecodeDumperBase* dumper, InstructionStream::Offset, const Instruction*);</span>
<span class="line-added">151 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">152 </span>
153 EOF
154 
155             template.body = &lt;&lt;-EOF
<span class="line-modified">156 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}</span>
<span class="line-modified">157 </span>
<span class="line-added">158 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">159 #{opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; s.is_wasm? }.map(&amp;:struct).join(&quot;\n&quot;)}</span>
<span class="line-added">160 #endif // ENABLE(WEBASSEMBLY)</span>
161 EOF
162             template.suffix = &quot;} // namespace JSC&quot;
163         end
164     end
165 
<span class="line-modified">166     def self.write_bytecode_dumper(bytecode_list, bytecode_dumper_filename)</span>
<span class="line-modified">167         GeneratedFile::create(bytecode_dumper_filename, bytecode_list) do |template|</span>
<span class="line-added">168             template.prefix = &lt;&lt;-EOF</span>
<span class="line-added">169 #include &quot;config.h&quot;</span>
<span class="line-added">170 #include &quot;BytecodeDumper.h&quot;</span>
<span class="line-added">171 </span>
<span class="line-added">172 #include &quot;BytecodeStructs.h&quot;</span>
<span class="line-added">173 </span>
<span class="line-added">174 namespace JSC {</span>
<span class="line-added">175 EOF</span>
<span class="line-added">176 </span>
<span class="line-added">177             template.body = &lt;&lt;-EOF</span>
<span class="line-added">178 #{Opcode.dump_bytecode(:Bytecode, :JSOpcodeTraits, opcodes_filter { |s| s.config[:emit_in_structs_file] &amp;&amp; !s.is_wasm? })}</span>
179 
<span class="line-modified">180 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">181 #{Opcode.dump_bytecode(:Wasm, :WasmOpcodeTraits, opcodes_filter { |s| s.is_wasm? })}</span>
<span class="line-added">182 #endif // ENABLE(WEBASSEMBLY)</span>
<span class="line-added">183 EOF</span>
<span class="line-added">184             template.suffix = &quot;} // namespace JSC&quot;</span>
<span class="line-added">185         end</span>
<span class="line-added">186     end</span>
<span class="line-added">187 </span>
<span class="line-added">188     def self.write_init_asm(opcodes, filename, *dependencies)</span>
<span class="line-added">189         GeneratedFile::create(filename, *dependencies) do |template|</span>
190             template.multiline_comment = nil
191             template.line_comment = &quot;#&quot;
192             template.body = (opcodes.map.with_index(&amp;:set_entry_address) + opcodes.map.with_index(&amp;:set_entry_address_wide16) + opcodes.map.with_index(&amp;:set_entry_address_wide32)) .join(&quot;\n&quot;)
193         end
194     end
195 
<span class="line-added">196     def self.write_bytecodes_init(bytecodes_init_filename, *dependencies)</span>
<span class="line-added">197         write_init_asm(opcodes_for(:emit_in_asm_file), bytecodes_init_filename, *dependencies)</span>
<span class="line-added">198     end</span>
<span class="line-added">199 </span>
<span class="line-added">200     def self.write_wasm_init(wasm_init_filename, *dependencies)</span>
<span class="line-added">201         write_init_asm(@wasm_section.opcodes, wasm_init_filename, *dependencies)</span>
<span class="line-added">202     end</span>
<span class="line-added">203 </span>
<span class="line-added">204     def self.write_llint_generator(generator_filename, *dependencies)</span>
<span class="line-added">205         GeneratedFile::create(generator_filename, *dependencies) do |template|</span>
<span class="line-added">206             template.body = Wasm::generate_llint_generator(@wasm_section)</span>
<span class="line-added">207         end</span>
<span class="line-added">208     end</span>
<span class="line-added">209 </span>
210     def self.write_indices(bytecode_list, indices_filename)
211         opcodes = opcodes_for(:emit_in_structs_file)
212 
213         GeneratedFile::create(indices_filename, bytecode_list) do |template|
214             template.prefix = &quot;namespace JSC {\n&quot;
215             template.body = opcodes.map(&amp;:struct_indices).join(&quot;\n&quot;)
216             template.suffix = &quot;\n} // namespace JSC&quot;
217         end
218     end
219 
220     def self.opcodes_for(file)
221         sections = @sections.select { |s| s.config[file] }
222         sections.map(&amp;:opcodes).flatten
223     end
<span class="line-added">224 </span>
<span class="line-added">225     def self.opcodes_filter</span>
<span class="line-added">226         sections = @sections.select { |s| yield s }</span>
<span class="line-added">227         sections.map(&amp;:opcodes).flatten</span>
<span class="line-added">228     end</span>
229 end
</pre>
</td>
</tr>
</table>
<center><a href="Argument.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GeneratedFile.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 // A red-black tree, which is a form of a balanced binary tree. It
 27 // supports efficient insertion, deletion and queries of comparable
 28 // elements. The same element may be inserted multiple times. The
 29 // algorithmic complexity of common operations is:
 30 //
 31 //   Insertion: O(lg(n))
 32 //   Deletion:  O(lg(n))
 33 //   Querying:  O(lg(n))
 34 //
<a name="2" id="anc2"></a><span class="line-removed"> 35 // The data type T that is stored in this red-black tree must be only</span>
<span class="line-removed"> 36 // Plain Old Data (POD), or bottom out into POD. It must _not_ rely on</span>
<span class="line-removed"> 37 // having its destructor called. This implementation internally</span>
<span class="line-removed"> 38 // allocates storage in large chunks and does not call the destructor</span>
<span class="line-removed"> 39 // on each object.</span>
<span class="line-removed"> 40 //</span>
 41 // Type T must supply a default constructor, a copy constructor, and
 42 // the &quot;&lt;&quot; and &quot;==&quot; operators.
 43 //
 44 // In debug mode, printing of the data contained in the tree is
<a name="3" id="anc3"></a><span class="line-modified"> 45 // enabled. This requires the template specialization to be available:</span>
<span class="line-removed"> 46 //</span>
<span class="line-removed"> 47 //   template&lt;&gt; struct WebCore::ValueToString&lt;T&gt; {</span>
<span class="line-removed"> 48 //       static String string(const T&amp; t);</span>
<span class="line-removed"> 49 //   };</span>
<span class="line-removed"> 50 //</span>
<span class="line-removed"> 51 // Note that when complex types are stored in this red/black tree, it</span>
<span class="line-removed"> 52 // is possible that single invocations of the &quot;&lt;&quot; and &quot;==&quot; operators</span>
<span class="line-removed"> 53 // will be insufficient to describe the ordering of elements in the</span>
<span class="line-removed"> 54 // tree during queries. As a concrete example, consider the case where</span>
<span class="line-removed"> 55 // intervals are stored in the tree sorted by low endpoint. The &quot;&lt;&quot;</span>
<span class="line-removed"> 56 // operator on the Interval class only compares the low endpoint, but</span>
<span class="line-removed"> 57 // the &quot;==&quot; operator takes into account the high endpoint as well.</span>
<span class="line-removed"> 58 // This makes the necessary logic for querying and deletion somewhat</span>
<span class="line-removed"> 59 // more complex. In order to properly handle such situations, the</span>
<span class="line-removed"> 60 // property &quot;needsFullOrderingComparisons&quot; must be set to true on</span>
<span class="line-removed"> 61 // the tree.</span>
 62 //
 63 // This red-black tree is designed to be _augmented_; subclasses can
 64 // add additional and summary information to each node to efficiently
 65 // store and index more complex data structures. A concrete example is
 66 // the IntervalTree, which extends each node with a summary statistic
 67 // to efficiently store one-dimensional intervals.
 68 //
 69 // The design of this red-black tree comes from Cormen, Leiserson,
 70 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 71 
<a name="4" id="anc4"></a><span class="line-modified"> 72 #ifndef PODRedBlackTree_h</span>
<span class="line-removed"> 73 #define PODRedBlackTree_h</span>
 74 
 75 #include &lt;wtf/Assertions.h&gt;
 76 #include &lt;wtf/Noncopyable.h&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 77 #include &lt;wtf/text/ValueToString.h&gt;</span>
 78 #ifndef NDEBUG
 79 #include &lt;wtf/text/StringBuilder.h&gt;
<a name="6" id="anc6"></a><span class="line-modified"> 80 #include &lt;wtf/text/WTFString.h&gt;</span>
 81 #endif
 82 
<a name="7" id="anc7"></a>


 83 namespace WebCore {
 84 
<a name="8" id="anc8"></a><span class="line-modified"> 85 template&lt;class T&gt;</span>
<span class="line-modified"> 86 class PODRedBlackTree {</span>
<span class="line-removed"> 87     WTF_MAKE_FAST_ALLOCATED;</span>
 88 public:
<a name="9" id="anc9"></a><span class="line-modified"> 89     class Node;</span>
 90 
<a name="10" id="anc10"></a><span class="line-modified"> 91     // Visitor interface for walking all of the tree&#39;s elements.</span>
<span class="line-removed"> 92     class Visitor {</span>
<span class="line-removed"> 93     public:</span>
<span class="line-removed"> 94         virtual void visit(const T&amp; data) = 0;</span>
<span class="line-removed"> 95     protected:</span>
<span class="line-removed"> 96         virtual ~Visitor() = default;</span>
<span class="line-removed"> 97     };</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99     PODRedBlackTree()</span>
<span class="line-removed">100         : m_root(0)</span>
<span class="line-removed">101         , m_needsFullOrderingComparisons(false)</span>
<span class="line-removed">102 #ifndef NDEBUG</span>
<span class="line-removed">103         , m_verboseDebugging(false)</span>
<span class="line-removed">104 #endif</span>
<span class="line-removed">105     {</span>
<span class="line-removed">106     }</span>
<span class="line-removed">107 </span>
<span class="line-removed">108     virtual ~PODRedBlackTree()</span>
109     {
110         clear();
111     }
112 
<a name="11" id="anc11"></a><span class="line-removed">113     // Clearing will delete the contents of the tree. After this call</span>
<span class="line-removed">114     // isInitialized will return false.</span>
115     void clear()
116     {
<a name="12" id="anc12"></a><span class="line-modified">117         markFree(m_root);</span>
<span class="line-modified">118         m_root = 0;</span>






119     }
120 
121     void add(const T&amp; data)
122     {
<a name="13" id="anc13"></a><span class="line-modified">123         Node* node = new Node(data);</span>
<span class="line-modified">124         insertNode(node);</span>




125     }
126 
127     // Returns true if the datum was found in the tree.
128     bool remove(const T&amp; data)
129     {
130         Node* node = treeSearch(data);
131         if (node) {
132             deleteNode(node);
133             return true;
134         }
135         return false;
136     }
137 
138     bool contains(const T&amp; data) const
139     {
140         return treeSearch(data);
141     }
142 
<a name="14" id="anc14"></a><span class="line-modified">143     void visitInorder(Visitor* visitor) const</span>
144     {
<a name="15" id="anc15"></a><span class="line-modified">145         if (!m_root)</span>
<span class="line-removed">146             return;</span>
<span class="line-removed">147         visitInorderImpl(m_root, visitor);</span>
<span class="line-removed">148     }</span>
<span class="line-removed">149 </span>
<span class="line-removed">150     int size() const</span>
<span class="line-removed">151     {</span>
<span class="line-removed">152         Counter counter;</span>
<span class="line-removed">153         visitInorder(&amp;counter);</span>
<span class="line-removed">154         return counter.count();</span>
155     }
156 
<a name="16" id="anc16"></a><span class="line-modified">157     // See the class documentation for an explanation of this property.</span>
<span class="line-removed">158     void setNeedsFullOrderingComparisons(bool needsFullOrderingComparisons)</span>
<span class="line-removed">159     {</span>
<span class="line-removed">160         m_needsFullOrderingComparisons = needsFullOrderingComparisons;</span>
<span class="line-removed">161     }</span>
162 
<a name="17" id="anc17"></a><span class="line-modified">163     virtual bool checkInvariants() const</span>
164     {
165         int blackCount;
<a name="18" id="anc18"></a><span class="line-modified">166         return checkInvariantsFromNode(m_root, &amp;blackCount);</span>
167     }
168 
<a name="19" id="anc19"></a><span class="line-modified">169 #ifndef NDEBUG</span>
<span class="line-removed">170     // Dumps the tree&#39;s contents to the logging info stream for</span>
<span class="line-removed">171     // debugging purposes.</span>
172     void dump() const
173     {
<a name="20" id="anc20"></a><span class="line-modified">174         dumpFromNode(m_root, 0);</span>
175     }
176 
177     // Turns on or off verbose debugging of the tree, causing many
178     // messages to be logged during insertion and other operations in
179     // debug mode.
180     void setVerboseDebugging(bool verboseDebugging)
181     {
182         m_verboseDebugging = verboseDebugging;
183     }
<a name="21" id="anc21"></a>
184 #endif
185 
<a name="22" id="anc22"></a><span class="line-modified">186     enum Color {</span>
<span class="line-modified">187         Red = 1,</span>
<span class="line-removed">188         Black</span>
<span class="line-removed">189     };</span>
190 
<a name="23" id="anc23"></a><span class="line-removed">191     // The base Node class which is stored in the tree. Nodes are only</span>
<span class="line-removed">192     // an internal concept; users of the tree deal only with the data</span>
<span class="line-removed">193     // they store in it.</span>
194     class Node {
195         WTF_MAKE_FAST_ALLOCATED;
196         WTF_MAKE_NONCOPYABLE(Node);
197     public:
<a name="24" id="anc24"></a><span class="line-modified">198         // Constructor. Newly-created nodes are colored red.</span>
<span class="line-modified">199         explicit Node(const T&amp; data)</span>
<span class="line-removed">200             : m_left(0)</span>
<span class="line-removed">201             , m_right(0)</span>
<span class="line-removed">202             , m_parent(0)</span>
<span class="line-removed">203             , m_color(Red)</span>
<span class="line-removed">204             , m_data(data)</span>
205         {
206         }
207 
<a name="25" id="anc25"></a><span class="line-removed">208         virtual ~Node() = default;</span>
<span class="line-removed">209 </span>
210         Color color() const { return m_color; }
211         void setColor(Color color) { m_color = color; }
212 
<a name="26" id="anc26"></a><span class="line-removed">213         // Fetches the user data.</span>
214         T&amp; data() { return m_data; }
215 
<a name="27" id="anc27"></a><span class="line-modified">216         // Copies all user-level fields from the source node, but not</span>
<span class="line-removed">217         // internal fields. For example, the base implementation of this</span>
<span class="line-removed">218         // method copies the &quot;m_data&quot; field, but not the child or parent</span>
<span class="line-removed">219         // fields. Any augmentation information also does not need to be</span>
<span class="line-removed">220         // copied, as it will be recomputed. Subclasses must call the</span>
<span class="line-removed">221         // superclass implementation.</span>
<span class="line-removed">222         virtual void copyFrom(Node* src) { m_data = src-&gt;data(); }</span>
223 
224         Node* left() const { return m_left; }
225         void setLeft(Node* node) { m_left = node; }
226 
227         Node* right() const { return m_right; }
228         void setRight(Node* node) { m_right = node; }
229 
230         Node* parent() const { return m_parent; }
231         void setParent(Node* node) { m_parent = node; }
232 
233     private:
<a name="28" id="anc28"></a><span class="line-modified">234         Node* m_left;</span>
<span class="line-modified">235         Node* m_right;</span>
<span class="line-modified">236         Node* m_parent;</span>
<span class="line-modified">237         Color m_color;</span>
238         T m_data;
239     };
240 
<a name="29" id="anc29"></a><span class="line-removed">241 protected:</span>
242     // Returns the root of the tree, which is needed by some subclasses.
243     Node* root() const { return m_root; }
244 
245 private:
<a name="30" id="anc30"></a><span class="line-modified">246     // This virtual method is the hook that subclasses should use when</span>
247     // augmenting the red-black tree with additional per-node summary
248     // information. For example, in the case of an interval tree, this
249     // is used to compute the maximum endpoint of the subtree below the
250     // given node based on the values in the left and right children. It
251     // is guaranteed that this will be called in the correct order to
252     // properly update such summary information based only on the values
<a name="31" id="anc31"></a><span class="line-modified">253     // in the left and right children. This method should return true if</span>
254     // the node&#39;s summary information changed.
<a name="32" id="anc32"></a><span class="line-modified">255     virtual bool updateNode(Node*) { return false; }</span>
<span class="line-removed">256 </span>
<span class="line-removed">257     //----------------------------------------------------------------------</span>
<span class="line-removed">258     // Generic binary search tree operations</span>
<span class="line-removed">259     //</span>
<span class="line-removed">260 </span>
<span class="line-removed">261     // Searches the tree for the given datum.</span>
<span class="line-removed">262     Node* treeSearch(const T&amp; data) const</span>
263     {
<a name="33" id="anc33"></a><span class="line-modified">264         if (m_needsFullOrderingComparisons)</span>
<span class="line-removed">265             return treeSearchFullComparisons(m_root, data);</span>
<span class="line-removed">266 </span>
<span class="line-removed">267         return treeSearchNormal(m_root, data);</span>
268     }
269 
<a name="34" id="anc34"></a><span class="line-modified">270     // Searches the tree using the normal comparison operations,</span>
<span class="line-removed">271     // suitable for simple data types such as numbers.</span>
<span class="line-removed">272     Node* treeSearchNormal(Node* current, const T&amp; data) const</span>
273     {
<a name="35" id="anc35"></a><span class="line-modified">274         while (current) {</span>
275             if (current-&gt;data() == data)
276                 return current;
277             if (data &lt; current-&gt;data())
278                 current = current-&gt;left();
279             else
280                 current = current-&gt;right();
281         }
<a name="36" id="anc36"></a><span class="line-modified">282         return 0;</span>
<span class="line-removed">283     }</span>
<span class="line-removed">284 </span>
<span class="line-removed">285     // Searches the tree using multiple comparison operations, required</span>
<span class="line-removed">286     // for data types with more complex behavior such as intervals.</span>
<span class="line-removed">287     Node* treeSearchFullComparisons(Node* current, const T&amp; data) const</span>
<span class="line-removed">288     {</span>
<span class="line-removed">289         if (!current)</span>
<span class="line-removed">290             return 0;</span>
<span class="line-removed">291         if (data &lt; current-&gt;data())</span>
<span class="line-removed">292             return treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">293         if (current-&gt;data() &lt; data)</span>
<span class="line-removed">294             return treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">295         if (data == current-&gt;data())</span>
<span class="line-removed">296             return current;</span>
<span class="line-removed">297 </span>
<span class="line-removed">298         // We may need to traverse both the left and right subtrees.</span>
<span class="line-removed">299         Node* result = treeSearchFullComparisons(current-&gt;left(), data);</span>
<span class="line-removed">300         if (!result)</span>
<span class="line-removed">301             result = treeSearchFullComparisons(current-&gt;right(), data);</span>
<span class="line-removed">302         return result;</span>
303     }
304 
305     void treeInsert(Node* z)
306     {
<a name="37" id="anc37"></a><span class="line-modified">307         Node* y = 0;</span>
308         Node* x = m_root;
309         while (x) {
310             y = x;
311             if (z-&gt;data() &lt; x-&gt;data())
312                 x = x-&gt;left();
313             else
314                 x = x-&gt;right();
315         }
316         z-&gt;setParent(y);
317         if (!y)
318             m_root = z;
319         else {
320             if (z-&gt;data() &lt; y-&gt;data())
321                 y-&gt;setLeft(z);
322             else
323                 y-&gt;setRight(z);
324         }
325     }
326 
327     // Finds the node following the given one in sequential ordering of
328     // their data, or null if none exists.
<a name="38" id="anc38"></a><span class="line-modified">329     Node* treeSuccessor(Node* x)</span>
330     {
331         if (x-&gt;right())
332             return treeMinimum(x-&gt;right());
333         Node* y = x-&gt;parent();
334         while (y &amp;&amp; x == y-&gt;right()) {
335             x = y;
336             y = y-&gt;parent();
337         }
338         return y;
339     }
340 
<a name="39" id="anc39"></a><span class="line-modified">341     // Finds the minimum element in the sub-tree rooted at the given</span>
<span class="line-modified">342     // node.</span>
<span class="line-removed">343     Node* treeMinimum(Node* x)</span>
344     {
345         while (x-&gt;left())
346             x = x-&gt;left();
347         return x;
348     }
349 
<a name="40" id="anc40"></a><span class="line-modified">350     // Helper for maintaining the augmented red-black tree.</span>
<span class="line-removed">351     void propagateUpdates(Node* start)</span>
352     {
<a name="41" id="anc41"></a><span class="line-modified">353         bool shouldContinue = true;</span>
<span class="line-modified">354         while (start &amp;&amp; shouldContinue) {</span>
<span class="line-modified">355             shouldContinue = updateNode(start);</span>
<span class="line-modified">356             start = start-&gt;parent();</span>
<span class="line-removed">357         }</span>
358     }
359 
360     //----------------------------------------------------------------------
361     // Red-Black tree operations
362     //
363 
364     // Left-rotates the subtree rooted at x.
365     // Returns the new root of the subtree (x&#39;s right child).
366     Node* leftRotate(Node* x)
367     {
368         // Set y.
369         Node* y = x-&gt;right();
370 
371         // Turn y&#39;s left subtree into x&#39;s right subtree.
372         x-&gt;setRight(y-&gt;left());
373         if (y-&gt;left())
374             y-&gt;left()-&gt;setParent(x);
375 
376         // Link x&#39;s parent to y.
377         y-&gt;setParent(x-&gt;parent());
378         if (!x-&gt;parent())
379             m_root = y;
380         else {
381             if (x == x-&gt;parent()-&gt;left())
382                 x-&gt;parent()-&gt;setLeft(y);
383             else
384                 x-&gt;parent()-&gt;setRight(y);
385         }
386 
387         // Put x on y&#39;s left.
388         y-&gt;setLeft(x);
389         x-&gt;setParent(y);
390 
391         // Update nodes lowest to highest.
<a name="42" id="anc42"></a><span class="line-modified">392         updateNode(x);</span>
<span class="line-modified">393         updateNode(y);</span>
394         return y;
395     }
396 
<a name="43" id="anc43"></a>





397     // Right-rotates the subtree rooted at y.
398     // Returns the new root of the subtree (y&#39;s left child).
399     Node* rightRotate(Node* y)
400     {
401         // Set x.
402         Node* x = y-&gt;left();
403 
404         // Turn x&#39;s right subtree into y&#39;s left subtree.
405         y-&gt;setLeft(x-&gt;right());
406         if (x-&gt;right())
407             x-&gt;right()-&gt;setParent(y);
408 
409         // Link y&#39;s parent to x.
410         x-&gt;setParent(y-&gt;parent());
411         if (!y-&gt;parent())
412             m_root = x;
413         else {
414             if (y == y-&gt;parent()-&gt;left())
415                 y-&gt;parent()-&gt;setLeft(x);
416             else
417                 y-&gt;parent()-&gt;setRight(x);
418         }
419 
420         // Put y on x&#39;s right.
421         x-&gt;setRight(y);
422         y-&gt;setParent(x);
423 
424         // Update nodes lowest to highest.
<a name="44" id="anc44"></a><span class="line-modified">425         updateNode(y);</span>
<span class="line-modified">426         updateNode(x);</span>
427         return x;
428     }
429 
430     // Inserts the given node into the tree.
431     void insertNode(Node* x)
432     {
433         treeInsert(x);
434         x-&gt;setColor(Red);
<a name="45" id="anc45"></a><span class="line-modified">435         updateNode(x);</span>
436 
437         logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
438 
439         // The node from which to start propagating updates upwards.
440         Node* updateStart = x-&gt;parent();
441 
442         while (x != m_root &amp;&amp; x-&gt;parent()-&gt;color() == Red) {
443             if (x-&gt;parent() == x-&gt;parent()-&gt;parent()-&gt;left()) {
444                 Node* y = x-&gt;parent()-&gt;parent()-&gt;right();
445                 if (y &amp;&amp; y-&gt;color() == Red) {
446                     // Case 1
447                     logIfVerbose(&quot;  Case 1/1&quot;);
448                     x-&gt;parent()-&gt;setColor(Black);
449                     y-&gt;setColor(Black);
450                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<a name="46" id="anc46"></a><span class="line-modified">451                     updateNode(x-&gt;parent());</span>
452                     x = x-&gt;parent()-&gt;parent();
<a name="47" id="anc47"></a><span class="line-modified">453                     updateNode(x);</span>
454                     updateStart = x-&gt;parent();
455                 } else {
456                     if (x == x-&gt;parent()-&gt;right()) {
457                         logIfVerbose(&quot;  Case 1/2&quot;);
458                         // Case 2
459                         x = x-&gt;parent();
460                         leftRotate(x);
461                     }
462                     // Case 3
463                     logIfVerbose(&quot;  Case 1/3&quot;);
464                     x-&gt;parent()-&gt;setColor(Black);
465                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
466                     Node* newSubTreeRoot = rightRotate(x-&gt;parent()-&gt;parent());
467                     updateStart = newSubTreeRoot-&gt;parent();
468                 }
469             } else {
470                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot; exchanged.
471                 Node* y = x-&gt;parent()-&gt;parent()-&gt;left();
472                 if (y &amp;&amp; y-&gt;color() == Red) {
473                     // Case 1
474                     logIfVerbose(&quot;  Case 2/1&quot;);
475                     x-&gt;parent()-&gt;setColor(Black);
476                     y-&gt;setColor(Black);
477                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<a name="48" id="anc48"></a><span class="line-modified">478                     updateNode(x-&gt;parent());</span>
479                     x = x-&gt;parent()-&gt;parent();
<a name="49" id="anc49"></a><span class="line-modified">480                     updateNode(x);</span>
481                     updateStart = x-&gt;parent();
482                 } else {
483                     if (x == x-&gt;parent()-&gt;left()) {
484                         // Case 2
485                         logIfVerbose(&quot;  Case 2/2&quot;);
486                         x = x-&gt;parent();
487                         rightRotate(x);
488                     }
489                     // Case 3
490                     logIfVerbose(&quot;  Case 2/3&quot;);
491                     x-&gt;parent()-&gt;setColor(Black);
492                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
493                     Node* newSubTreeRoot = leftRotate(x-&gt;parent()-&gt;parent());
494                     updateStart = newSubTreeRoot-&gt;parent();
495                 }
496             }
497         }
498 
499         propagateUpdates(updateStart);
500 
501         m_root-&gt;setColor(Black);
502     }
503 
504     // Restores the red-black property to the tree after splicing out
<a name="50" id="anc50"></a><span class="line-modified">505     // a node. Note that x may be null, which is why xParent must be</span>
<span class="line-removed">506     // supplied.</span>
507     void deleteFixup(Node* x, Node* xParent)
508     {
509         while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
510             if (x == xParent-&gt;left()) {
511                 // Note: the text points out that w can not be null.
512                 // The reason is not obvious from simply looking at
513                 // the code; it comes about from the properties of the
514                 // red-black tree.
515                 Node* w = xParent-&gt;right();
516                 ASSERT(w); // x&#39;s sibling should not be null.
517                 if (w-&gt;color() == Red) {
518                     // Case 1
519                     w-&gt;setColor(Black);
520                     xParent-&gt;setColor(Red);
521                     leftRotate(xParent);
522                     w = xParent-&gt;right();
523                 }
524                 if ((!w-&gt;left() || w-&gt;left()-&gt;color() == Black)
525                     &amp;&amp; (!w-&gt;right() || w-&gt;right()-&gt;color() == Black)) {
526                     // Case 2
527                     w-&gt;setColor(Red);
528                     x = xParent;
529                     xParent = x-&gt;parent();
530                 } else {
531                     if (!w-&gt;right() || w-&gt;right()-&gt;color() == Black) {
532                         // Case 3
533                         w-&gt;left()-&gt;setColor(Black);
534                         w-&gt;setColor(Red);
535                         rightRotate(w);
536                         w = xParent-&gt;right();
537                     }
538                     // Case 4
539                     w-&gt;setColor(xParent-&gt;color());
540                     xParent-&gt;setColor(Black);
541                     if (w-&gt;right())
542                         w-&gt;right()-&gt;setColor(Black);
543                     leftRotate(xParent);
544                     x = m_root;
545                     xParent = x-&gt;parent();
546                 }
547             } else {
548                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot;
549                 // exchanged.
550 
551                 // Note: the text points out that w can not be null.
552                 // The reason is not obvious from simply looking at
553                 // the code; it comes about from the properties of the
554                 // red-black tree.
555                 Node* w = xParent-&gt;left();
556                 ASSERT(w); // x&#39;s sibling should not be null.
557                 if (w-&gt;color() == Red) {
558                     // Case 1
559                     w-&gt;setColor(Black);
560                     xParent-&gt;setColor(Red);
561                     rightRotate(xParent);
562                     w = xParent-&gt;left();
563                 }
564                 if ((!w-&gt;right() || w-&gt;right()-&gt;color() == Black)
565                     &amp;&amp; (!w-&gt;left() || w-&gt;left()-&gt;color() == Black)) {
566                     // Case 2
567                     w-&gt;setColor(Red);
568                     x = xParent;
569                     xParent = x-&gt;parent();
570                 } else {
571                     if (!w-&gt;left() || w-&gt;left()-&gt;color() == Black) {
572                         // Case 3
573                         w-&gt;right()-&gt;setColor(Black);
574                         w-&gt;setColor(Red);
575                         leftRotate(w);
576                         w = xParent-&gt;left();
577                     }
578                     // Case 4
579                     w-&gt;setColor(xParent-&gt;color());
580                     xParent-&gt;setColor(Black);
581                     if (w-&gt;left())
582                         w-&gt;left()-&gt;setColor(Black);
583                     rightRotate(xParent);
584                     x = m_root;
585                     xParent = x-&gt;parent();
586                 }
587             }
588         }
589         if (x)
590             x-&gt;setColor(Black);
591     }
592 
593     // Deletes the given node from the tree. Note that this
594     // particular node may not actually be removed from the tree;
595     // instead, another node might be removed and its contents
596     // copied into z.
597     void deleteNode(Node* z)
598     {
599         // Y is the node to be unlinked from the tree.
600         Node* y;
601         if (!z-&gt;left() || !z-&gt;right())
602             y = z;
603         else
604             y = treeSuccessor(z);
605 
606         // Y is guaranteed to be non-null at this point.
607         Node* x;
608         if (y-&gt;left())
609             x = y-&gt;left();
610         else
611             x = y-&gt;right();
612 
613         // X is the child of y which might potentially replace y in
614         // the tree. X might be null at this point.
615         Node* xParent;
616         if (x) {
617             x-&gt;setParent(y-&gt;parent());
618             xParent = x-&gt;parent();
619         } else
620             xParent = y-&gt;parent();
621         if (!y-&gt;parent())
622             m_root = x;
623         else {
624             if (y == y-&gt;parent()-&gt;left())
625                 y-&gt;parent()-&gt;setLeft(x);
626             else
627                 y-&gt;parent()-&gt;setRight(x);
628         }
629         if (y != z) {
<a name="51" id="anc51"></a><span class="line-modified">630             z-&gt;copyFrom(y);</span>
631             // This node has changed location in the tree and must be updated.
<a name="52" id="anc52"></a><span class="line-modified">632             updateNode(z);</span>
633             // The parent and its parents may now be out of date.
634             propagateUpdates(z-&gt;parent());
635         }
636 
637         // If we haven&#39;t already updated starting from xParent, do so now.
638         if (xParent &amp;&amp; xParent != y &amp;&amp; xParent != z)
639             propagateUpdates(xParent);
640         if (y-&gt;color() == Black)
641             deleteFixup(x, xParent);
642 
643         delete y;
644     }
645 
<a name="53" id="anc53"></a><span class="line-removed">646     // Visits the subtree rooted at the given node in order.</span>
<span class="line-removed">647     void visitInorderImpl(Node* node, Visitor* visitor) const</span>
<span class="line-removed">648     {</span>
<span class="line-removed">649         if (node-&gt;left())</span>
<span class="line-removed">650             visitInorderImpl(node-&gt;left(), visitor);</span>
<span class="line-removed">651         visitor-&gt;visit(node-&gt;data());</span>
<span class="line-removed">652         if (node-&gt;right())</span>
<span class="line-removed">653             visitInorderImpl(node-&gt;right(), visitor);</span>
<span class="line-removed">654     }</span>
<span class="line-removed">655 </span>
<span class="line-removed">656     void markFree(Node *node)</span>
<span class="line-removed">657     {</span>
<span class="line-removed">658         if (!node)</span>
<span class="line-removed">659             return;</span>
<span class="line-removed">660 </span>
<span class="line-removed">661         if (node-&gt;left())</span>
<span class="line-removed">662             markFree(node-&gt;left());</span>
<span class="line-removed">663         if (node-&gt;right())</span>
<span class="line-removed">664             markFree(node-&gt;right());</span>
<span class="line-removed">665         delete node;</span>
<span class="line-removed">666     }</span>
<span class="line-removed">667 </span>
<span class="line-removed">668     //----------------------------------------------------------------------</span>
<span class="line-removed">669     // Helper class for size()</span>
<span class="line-removed">670 </span>
<span class="line-removed">671     // A Visitor which simply counts the number of visited elements.</span>
<span class="line-removed">672     class Counter : public Visitor {</span>
<span class="line-removed">673         WTF_MAKE_NONCOPYABLE(Counter);</span>
<span class="line-removed">674     public:</span>
<span class="line-removed">675         Counter()</span>
<span class="line-removed">676             : m_count(0) { }</span>
<span class="line-removed">677 </span>
<span class="line-removed">678         void visit(const T&amp;) override { ++m_count; }</span>
<span class="line-removed">679         int count() const { return m_count; }</span>
<span class="line-removed">680 </span>
<span class="line-removed">681     private:</span>
<span class="line-removed">682         int m_count;</span>
<span class="line-removed">683     };</span>
<span class="line-removed">684 </span>
685     //----------------------------------------------------------------------
686     // Verification and debugging routines
687     //
688 
<a name="54" id="anc54"></a>

689     // Returns in the &quot;blackCount&quot; parameter the number of black
690     // children along all paths to all leaves of the given node.
<a name="55" id="anc55"></a><span class="line-modified">691     bool checkInvariantsFromNode(Node* node, int* blackCount) const</span>
692     {
693         // Base case is a leaf node.
694         if (!node) {
<a name="56" id="anc56"></a><span class="line-modified">695             *blackCount = 1;</span>
696             return true;
697         }
698 
699         // Each node is either red or black.
700         if (!(node-&gt;color() == Red || node-&gt;color() == Black))
701             return false;
702 
703         // Every leaf (or null) is black.
704 
705         if (node-&gt;color() == Red) {
706             // Both of its children are black.
707             if (!((!node-&gt;left() || node-&gt;left()-&gt;color() == Black)))
708                 return false;
709             if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
710                 return false;
711         }
712 
<a name="57" id="anc57"></a><span class="line-modified">713         // Every simple path to a leaf node contains the same number of</span>
<span class="line-removed">714         // black nodes.</span>
715         int leftCount = 0, rightCount = 0;
<a name="58" id="anc58"></a><span class="line-modified">716         bool leftValid = checkInvariantsFromNode(node-&gt;left(), &amp;leftCount);</span>
<span class="line-modified">717         bool rightValid = checkInvariantsFromNode(node-&gt;right(), &amp;rightCount);</span>
718         if (!leftValid || !rightValid)
719             return false;
<a name="59" id="anc59"></a><span class="line-modified">720         *blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
721         return leftCount == rightCount;
722     }
723 
<a name="60" id="anc60"></a>

724 #ifdef NDEBUG
725     void logIfVerbose(const char*) const { }
726 #else
727     void logIfVerbose(const char* output) const
728     {
729         if (m_verboseDebugging)
730             LOG_ERROR(&quot;%s&quot;, output);
731     }
732 #endif
733 
734 #ifndef NDEBUG
<a name="61" id="anc61"></a><span class="line-modified">735     // Dumps the subtree rooted at the given node.</span>
<span class="line-modified">736     void dumpFromNode(Node* node, int indentation) const</span>
737     {
738         StringBuilder builder;
739         for (int i = 0; i &lt; indentation; i++)
740             builder.append(&#39; &#39;);
741         builder.append(&#39;-&#39;);
742         if (node) {
743             builder.append(&#39; &#39;);
<a name="62" id="anc62"></a><span class="line-modified">744             builder.append(ValueToString&lt;T&gt;::string(node-&gt;data()));</span>


745             builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
746         }
<a name="63" id="anc63"></a><span class="line-modified">747         LOG_ERROR(&quot;%s&quot;, builder.toString().ascii().data());</span>
748         if (node) {
<a name="64" id="anc64"></a><span class="line-modified">749             dumpFromNode(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">750             dumpFromNode(node-&gt;right(), indentation + 2);</span>
751         }
752     }
<a name="65" id="anc65"></a><span class="line-removed">753 #endif</span>
754 
<a name="66" id="anc66"></a><span class="line-modified">755     //----------------------------------------------------------------------</span>
<span class="line-removed">756     // Data members</span>
757 
<a name="67" id="anc67"></a><span class="line-modified">758     Node* m_root;</span>
<span class="line-removed">759     bool m_needsFullOrderingComparisons;</span>
760 #ifndef NDEBUG
<a name="68" id="anc68"></a><span class="line-modified">761     bool m_verboseDebugging;</span>
762 #endif
763 };
764 
765 } // namespace WebCore
<a name="69" id="anc69"></a><span class="line-removed">766 </span>
<span class="line-removed">767 #endif // PODRedBlackTree_h</span>
<a name="70" id="anc70"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="70" type="hidden" />
</body>
</html>
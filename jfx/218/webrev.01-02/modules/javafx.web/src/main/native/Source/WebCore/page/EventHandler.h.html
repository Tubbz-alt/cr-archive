<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Cursor.h&quot;
 29 #include &quot;DragActions.h&quot;
 30 #include &quot;FocusDirection.h&quot;
 31 #include &quot;HitTestRequest.h&quot;
 32 #include &quot;LayoutPoint.h&quot;
 33 #include &quot;PlatformMouseEvent.h&quot;
 34 #include &quot;RenderObject.h&quot;
 35 #include &quot;ScrollTypes.h&quot;
 36 #include &quot;TextEventInputType.h&quot;
 37 #include &quot;TextGranularity.h&quot;
 38 #include &quot;Timer.h&quot;
 39 #include &lt;memory&gt;
 40 #include &lt;wtf/Forward.h&gt;
 41 #include &lt;wtf/HashMap.h&gt;
 42 #include &lt;wtf/HashSet.h&gt;
 43 #include &lt;wtf/RefPtr.h&gt;
 44 #include &lt;wtf/WeakPtr.h&gt;
 45 
 46 #if PLATFORM(COCOA)
 47 OBJC_CLASS NSView;
 48 #endif
 49 
 50 #if PLATFORM(IOS_FAMILY)
 51 OBJC_CLASS WebEvent;
 52 #endif
 53 
 54 #if PLATFORM(MAC)
 55 OBJC_CLASS NSEvent;
 56 #endif
 57 
 58 #if PLATFORM(IOS_FAMILY) &amp;&amp; defined(__OBJC__)
 59 #include &quot;WAKAppKitStubs.h&quot;
 60 #endif
 61 
 62 namespace WebCore {
 63 
 64 class AutoscrollController;
 65 class ContainerNode;
 66 class DataTransfer;
 67 class Document;
 68 class Element;
 69 class Event;
 70 class EventTarget;
 71 class FloatQuad;
 72 class Frame;
 73 class FrameView;
 74 class HTMLFrameSetElement;
 75 class HitTestResult;
 76 class KeyboardEvent;
 77 class MouseEventWithHitTestResults;
 78 class Node;
 79 class Pasteboard;
 80 class PlatformGestureEvent;
 81 class PlatformKeyboardEvent;
 82 class PlatformTouchEvent;
 83 class PlatformWheelEvent;
 84 class RenderBox;
 85 class RenderElement;
 86 class RenderLayer;
 87 class RenderWidget;
 88 class ScrollableArea;
 89 class Scrollbar;
 90 class TextEvent;
 91 class Touch;
 92 class TouchEvent;
 93 class VisibleSelection;
 94 class WheelEvent;
 95 class Widget;
 96 
 97 struct DragState;
 98 
 99 #if ENABLE(DRAG_SUPPORT)
100 extern const int LinkDragHysteresis;
101 extern const int ImageDragHysteresis;
102 extern const int TextDragHysteresis;
103 extern const int ColorDragHystersis;
104 extern const int GeneralDragHysteresis;
105 #endif
106 
107 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
108 extern const float GestureUnknown;
109 extern const unsigned InvalidTouchIdentifier;
110 #endif
111 
112 enum AppendTrailingWhitespace { ShouldAppendTrailingWhitespace, DontAppendTrailingWhitespace };
113 enum CheckDragHysteresis { ShouldCheckDragHysteresis, DontCheckDragHysteresis };
114 
115 enum class ImmediateActionStage {
116     None,
117     PerformedHitTest,
118     ActionUpdated,
119     ActionCancelledWithoutUpdate,
120     ActionCancelledAfterUpdate,
121     ActionCompleted
122 };
123 
124 class EventHandler {
125     WTF_MAKE_FAST_ALLOCATED;
126 public:
127     explicit EventHandler(Frame&amp;);
128     ~EventHandler();
129 
130     void clear();
131     void nodeWillBeRemoved(Node&amp;);
132 
133     WEBCORE_EXPORT VisiblePosition selectionExtentRespectingEditingBoundary(const VisibleSelection&amp;, const LayoutPoint&amp;, Node*);
134 
135 #if ENABLE(DRAG_SUPPORT)
136     void updateSelectionForMouseDrag();
137 #endif
138 
139 #if ENABLE(PAN_SCROLLING)
140     void didPanScrollStart();
141     void didPanScrollStop();
142     void startPanScrolling(RenderElement&amp;);
143 #endif
144 
145     void stopAutoscrollTimer(bool rendererIsBeingDestroyed = false);
146     RenderBox* autoscrollRenderer() const;
147     void updateAutoscrollRenderer();
148     bool autoscrollInProgress() const;
149     bool mouseDownWasInSubframe() const { return m_mouseDownWasInSubframe; }
150     bool panScrollInProgress() const;
151 
152     WEBCORE_EXPORT void dispatchFakeMouseMoveEventSoon();
153     void dispatchFakeMouseMoveEventSoonInQuad(const FloatQuad&amp;);
154 
155     WEBCORE_EXPORT HitTestResult hitTestResultAtPoint(const LayoutPoint&amp;, HitTestRequest::HitTestRequestType, const LayoutSize&amp; padding = LayoutSize()) const;
156 
157     bool mousePressed() const { return m_mousePressed; }
158     Node* mousePressNode() const { return m_mousePressNode.get(); }
159 
160     WEBCORE_EXPORT void setCapturingMouseEventsElement(Element*);
161 #if ENABLE(POINTER_EVENTS)
162     void pointerCaptureElementDidChange(Element*);
163 #endif
164 
165 #if ENABLE(DRAG_SUPPORT)
166     struct DragTargetResponse {
167         bool accept { false };
168         Optional&lt;DragOperation&gt; operation;
169     };
170     DragTargetResponse updateDragAndDrop(const PlatformMouseEvent&amp;, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp;, DragOperation sourceOperation, bool draggingFiles);
171     void cancelDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
172     bool performDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
173     void updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement);
174     RefPtr&lt;Element&gt; draggedElement() const;
175 #endif
176 
177     void scheduleHoverStateUpdate();
178     void scheduleCursorUpdate();
179 
180     void setResizingFrameSet(HTMLFrameSetElement*);
181 
182     void resizeLayerDestroyed();
183 
184     IntPoint lastKnownMousePosition() const;
185     IntPoint lastKnownMouseGlobalPosition() const { return m_lastKnownMouseGlobalPosition; }
186     Cursor currentMouseCursor() const { return m_currentMouseCursor; }
187 
188     IntPoint targetPositionInWindowForSelectionAutoscroll() const;
189     bool shouldUpdateAutoscroll();
190 
191     static Frame* subframeForTargetNode(Node*);
192     static Frame* subframeForHitTestResult(const MouseEventWithHitTestResults&amp;);
193 
194     WEBCORE_EXPORT bool scrollOverflow(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
195     WEBCORE_EXPORT bool scrollRecursively(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
196     WEBCORE_EXPORT bool logicalScrollRecursively(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
197 
198     bool tabsToLinks(KeyboardEvent*) const;
199     bool tabsToAllFormControls(KeyboardEvent*) const;
200 
201     WEBCORE_EXPORT bool mouseMoved(const PlatformMouseEvent&amp;);
202     WEBCORE_EXPORT bool passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp;);
203 
204     void lostMouseCapture();
205 
206     WEBCORE_EXPORT bool handleMousePressEvent(const PlatformMouseEvent&amp;);
207     bool handleMouseMoveEvent(const PlatformMouseEvent&amp;, HitTestResult* hoveredNode = nullptr, bool onlyUpdateScrollbars = false);
208     WEBCORE_EXPORT bool handleMouseReleaseEvent(const PlatformMouseEvent&amp;);
209     bool handleMouseForceEvent(const PlatformMouseEvent&amp;);
210     WEBCORE_EXPORT bool handleWheelEvent(const PlatformWheelEvent&amp;);
211     void defaultWheelEventHandler(Node*, WheelEvent&amp;);
212     bool handlePasteGlobalSelection(const PlatformMouseEvent&amp;);
213 
214     void platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp; eventTarget, RefPtr&lt;ContainerNode&gt;&amp; scrollableContainer, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp; isOverWidget);
215     void platformRecordWheelEvent(const PlatformWheelEvent&amp;);
216     bool platformCompleteWheelEvent(const PlatformWheelEvent&amp;, ContainerNode* scrollableContainer, const WeakPtr&lt;ScrollableArea&gt;&amp;);
217     bool platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode* scrollableContainer);
218     void platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;);
219 
220 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
221     using TouchArray = Vector&lt;RefPtr&lt;Touch&gt;&gt;;
222     using EventTargetTouchMap = HashMap&lt;EventTarget*, TouchArray*&gt;;
223     using EventTargetTouchArrayMap = HashMap&lt;Ref&lt;EventTarget&gt;, std::unique_ptr&lt;TouchArray&gt;&gt;;
224 #endif
225 
226 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
227     using EventTargetSet = HashSet&lt;RefPtr&lt;EventTarget&gt;&gt;;
228 #endif
229 
230 #if ENABLE(IOS_TOUCH_EVENTS)
231     bool dispatchTouchEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetTouchMap&amp;, float, float);
232     bool dispatchTouchEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetTouchArrayMap&amp;, float, float);
233     bool dispatchSimulatedTouchEvent(IntPoint location);
234     Frame* touchEventTargetSubframe() const { return m_touchEventTargetSubframe.get(); }
235     const TouchArray&amp; touches() const { return m_touches; }
236 #endif
237 
238 #if ENABLE(IOS_GESTURE_EVENTS)
239     bool dispatchGestureEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
240 #elif ENABLE(MAC_GESTURE_EVENTS)
241     bool dispatchGestureEvent(const PlatformGestureEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
242     WEBCORE_EXPORT bool handleGestureEvent(const PlatformGestureEvent&amp;);
243 #endif
244 
245 #if PLATFORM(IOS_FAMILY)
246     void defaultTouchEventHandler(Node&amp;, TouchEvent&amp;);
247     WEBCORE_EXPORT void dispatchSyntheticMouseOut(const PlatformMouseEvent&amp;);
248     WEBCORE_EXPORT void dispatchSyntheticMouseMove(const PlatformMouseEvent&amp;);
249 #endif
250 
251 #if ENABLE(CONTEXT_MENU_EVENT)
252     WEBCORE_EXPORT bool sendContextMenuEvent(const PlatformMouseEvent&amp;);
253     WEBCORE_EXPORT bool sendContextMenuEventForKey();
254 #endif
255 
256     void setMouseDownMayStartAutoscroll() { m_mouseDownMayStartAutoscroll = true; }
257 
258     bool needsKeyboardEventDisambiguationQuirks() const;
259 
260     WEBCORE_EXPORT static OptionSet&lt;PlatformEvent::Modifier&gt; accessKeyModifiers();
261     WEBCORE_EXPORT bool handleAccessKey(const PlatformKeyboardEvent&amp;);
262     WEBCORE_EXPORT bool keyEvent(const PlatformKeyboardEvent&amp;);
263     void defaultKeyboardEventHandler(KeyboardEvent&amp;);
264     WEBCORE_EXPORT void capsLockStateMayHaveChanged() const;
265 
266     bool accessibilityPreventsEventPropagation(KeyboardEvent&amp;);
267     WEBCORE_EXPORT void handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp;);
268 
269     bool handleTextInputEvent(const String&amp; text, Event* underlyingEvent = nullptr, TextEventInputType = TextEventInputKeyboard);
270     void defaultTextInputEventHandler(TextEvent&amp;);
271 
272 #if ENABLE(DRAG_SUPPORT)
273     WEBCORE_EXPORT bool eventMayStartDrag(const PlatformMouseEvent&amp;) const;
274 
275     WEBCORE_EXPORT void didStartDrag();
276     WEBCORE_EXPORT void dragCancelled();
277     WEBCORE_EXPORT void dragSourceEndedAt(const PlatformMouseEvent&amp;, DragOperation, MayExtendDragSession = MayExtendDragSession::No);
278 #endif
279 
280     void focusDocumentView();
281 
282     WEBCORE_EXPORT void sendScrollEvent();
283 
284 #if PLATFORM(MAC)
285     WEBCORE_EXPORT void mouseDown(NSEvent *, NSEvent *correspondingPressureEvent);
286     WEBCORE_EXPORT void mouseDragged(NSEvent *, NSEvent *correspondingPressureEvent);
287     WEBCORE_EXPORT void mouseUp(NSEvent *, NSEvent *correspondingPressureEvent);
288     WEBCORE_EXPORT void mouseMoved(NSEvent *, NSEvent *correspondingPressureEvent);
289     WEBCORE_EXPORT void pressureChange(NSEvent *, NSEvent* correspondingPressureEvent);
290     WEBCORE_EXPORT bool keyEvent(NSEvent *);
291     WEBCORE_EXPORT bool wheelEvent(NSEvent *);
292 #endif
293 
294 #if PLATFORM(IOS_FAMILY)
295     WEBCORE_EXPORT void mouseDown(WebEvent *);
296     WEBCORE_EXPORT void mouseUp(WebEvent *);
297     WEBCORE_EXPORT void mouseMoved(WebEvent *);
298     WEBCORE_EXPORT bool keyEvent(WebEvent *);
299     WEBCORE_EXPORT bool wheelEvent(WebEvent *);
300 #endif
301 
302 #if ENABLE(IOS_TOUCH_EVENTS)
303     WEBCORE_EXPORT void touchEvent(WebEvent *);
304 #endif
305 
306 #if PLATFORM(MAC)
307     WEBCORE_EXPORT void passMouseMovedEventToScrollbars(NSEvent *, NSEvent* correspondingPressureEvent);
308 
309     WEBCORE_EXPORT void sendFakeEventsAfterWidgetTracking(NSEvent *initiatingEvent);
310 
311     void setActivationEventNumber(int num) { m_activationEventNumber = num; }
312 
313     WEBCORE_EXPORT static NSEvent *currentNSEvent();
314     static NSEvent *correspondingPressureEvent();
315 #endif
316 
317 #if PLATFORM(IOS_FAMILY)
318     static WebEvent *currentEvent();
319 
320     void invalidateClick();
321 #endif
322 
323 #if ENABLE(TOUCH_EVENTS)
324     WEBCORE_EXPORT bool handleTouchEvent(const PlatformTouchEvent&amp;);
325 #endif
326 
327     bool useHandCursor(Node*, bool isOverLink, bool shiftKey);
328     void updateCursor();
329 
330     bool isHandlingWheelEvent() const { return m_isHandlingWheelEvent; }
331 
332     WEBCORE_EXPORT void setImmediateActionStage(ImmediateActionStage stage);
333     ImmediateActionStage immediateActionStage() const { return m_immediateActionStage; }
334 
335     static Widget* widgetForEventTarget(Element* eventTarget);
336 
337 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DRAG_SUPPORT)
338     WEBCORE_EXPORT bool tryToBeginDragAtPoint(const IntPoint&amp; clientPosition, const IntPoint&amp; globalPosition);
339 #endif
340 
341 #if PLATFORM(IOS_FAMILY)
342     WEBCORE_EXPORT void startSelectionAutoscroll(RenderObject* renderer, const FloatPoint&amp; positionInWindow);
343     WEBCORE_EXPORT void cancelSelectionAutoscroll();
344 #endif
345 
346     WEBCORE_EXPORT Optional&lt;Cursor&gt; selectCursor(const HitTestResult&amp;, bool shiftKey);
347 
348 private:
349 #if ENABLE(DRAG_SUPPORT)
350     static DragState&amp; dragState();
351     static const Seconds TextDragDelay;
352 #endif
353 
354     bool eventActivatedView(const PlatformMouseEvent&amp;) const;
355     bool updateSelectionForMouseDownDispatchingSelectStart(Node*, const VisibleSelection&amp;, TextGranularity);
356     void selectClosestWordFromHitTestResult(const HitTestResult&amp;, AppendTrailingWhitespace);
357     VisibleSelection selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;);
358     void selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
359     void selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
360     void selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp;);
361 
362     bool handleMouseDoubleClickEvent(const PlatformMouseEvent&amp;);
363 
364     WEBCORE_EXPORT bool handleMousePressEvent(const MouseEventWithHitTestResults&amp;);
365     bool handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp;);
366     bool handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp;);
367     bool handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp;);
368 
369 #if ENABLE(DRAG_SUPPORT)
370     bool handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis = ShouldCheckDragHysteresis);
371     bool shouldAllowMouseDownToStartDrag() const;
372 #endif
373 
374     WEBCORE_EXPORT bool handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp;);
375 
376     bool internalKeyEvent(const PlatformKeyboardEvent&amp;);
377 
378     void updateCursor(FrameView&amp;, const HitTestResult&amp;, bool shiftKey);
379 
380     void hoverTimerFired();
381     void cursorUpdateTimerFired();
382 
383     bool logicalScrollOverflow(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
384 
385     bool shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const;
386 
387     bool mouseDownMayStartSelect() const { return m_mouseDownMayStartSelect; }
388 
389     static bool isKeyboardOptionTab(KeyboardEvent&amp;);
390     static bool eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp;);
391 
392 #if !ENABLE(IOS_TOUCH_EVENTS)
393     void fakeMouseMoveEventTimerFired();
394     void cancelFakeMouseMoveEvent();
395 #endif
396 
397     bool isInsideScrollbar(const IntPoint&amp;) const;
398 
399 #if ENABLE(TOUCH_EVENTS)
400     bool dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp;);
401 #endif
402 
403 #if !PLATFORM(IOS_FAMILY)
404     void invalidateClick();
405 #endif
406 
407     Node* nodeUnderMouse() const;
408 
409     enum class FireMouseOverOut { No, Yes };
410     void updateMouseEventTargetNode(Node*, const PlatformMouseEvent&amp;, FireMouseOverOut);
411 
412     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const PlatformMouseEvent&amp;);
413 
414     bool dispatchMouseEvent(const AtomString&amp; eventType, Node* target, bool cancelable, int clickCount, const PlatformMouseEvent&amp;, bool setUnder);
415 
416 #if ENABLE(DRAG_SUPPORT)
417     bool dispatchDragEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, DataTransfer&amp;);
418     DragTargetResponse dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; , DragOperation, bool draggingFiles);
419     void invalidateDataTransfer();
420 
421     bool handleDrag(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis);
422 #endif
423 
424     bool handleMouseUp(const MouseEventWithHitTestResults&amp;);
425 
426 #if ENABLE(DRAG_SUPPORT)
427     void clearDragState();
428 
429     static bool shouldDispatchEventsToDragSourceElement();
430     void dispatchEventToDragSourceElement(const AtomString&amp; eventType, const PlatformMouseEvent&amp;);
431     bool dispatchDragStartEventOnSourceElement(DataTransfer&amp;);
432 
433     bool dragHysteresisExceeded(const FloatPoint&amp;) const;
434     bool dragHysteresisExceeded(const IntPoint&amp;) const;
435 #endif
436 
437     bool mouseMovementExceedsThreshold(const FloatPoint&amp;, int pointsThreshold) const;
438 
439     bool passMousePressEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
440     bool passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
441     bool passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
442 
443     bool passSubframeEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
444 
445     bool passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp;, Scrollbar*);
446 
447     bool passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp;);
448     bool passWidgetMouseDownEventToWidget(RenderWidget*);
449 
450     bool passMouseDownEventToWidget(Widget*);
451     bool widgetDidHandleWheelEvent(const PlatformWheelEvent&amp;, Widget&amp;);
452     bool completeWidgetWheelEvent(const PlatformWheelEvent&amp;, const WeakPtr&lt;Widget&gt;&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;, ContainerNode*);
453 
454     void defaultSpaceEventHandler(KeyboardEvent&amp;);
455     void defaultBackspaceEventHandler(KeyboardEvent&amp;);
456     void defaultTabEventHandler(KeyboardEvent&amp;);
457     void defaultArrowEventHandler(FocusDirection, KeyboardEvent&amp;);
458 
459 #if ENABLE(DRAG_SUPPORT)
460     DragSourceAction updateDragSourceActionsAllowed() const;
461     bool supportsSelectionUpdatesOnMouseDrag() const;
462 #endif
463 
464     // The following are called at the beginning of handleMouseUp and handleDrag.
465     // If they return true it indicates that they have consumed the event.
466     bool eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;);
467 
468 #if ENABLE(DRAG_SUPPORT)
469     bool eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;);
470     void updateSelectionForMouseDrag(const HitTestResult&amp;);
471 #endif
472 
473     enum class SetOrClearLastScrollbar { Clear, Set };
474     void updateLastScrollbarUnderMouse(Scrollbar*, SetOrClearLastScrollbar);
475 
476     void setFrameWasScrolledByUser();
477 
478     bool capturesDragging() const { return m_capturesDragging; }
479 
480 #if PLATFORM(COCOA) &amp;&amp; defined(__OBJC__)
481     NSView *mouseDownViewIfStillGood();
482 
483     PlatformMouseEvent currentPlatformMouseEvent() const;
484 #endif
485 
486 #if ENABLE(FULLSCREEN_API)
487     bool isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp;) const;
488 #endif
489 
490     void setLastKnownMousePosition(const PlatformMouseEvent&amp;);
491 
492 #if ENABLE(CURSOR_VISIBILITY)
493     void startAutoHideCursorTimer();
494     void cancelAutoHideCursorTimer();
495     void autoHideCursorTimerFired();
496 #endif
497 
498     void clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;);
499     void clearLatchedState();
500 
501     bool shouldSendMouseEventsToInactiveWindows() const;
502 
503     bool canMouseDownStartSelect(const MouseEventWithHitTestResults&amp;);
504 
505     Frame&amp; m_frame;
506 
507     bool m_mousePressed { false };
508     bool m_capturesDragging { false };
509     RefPtr&lt;Node&gt; m_mousePressNode;
510 
511     bool m_mouseDownMayStartSelect { false };
512 
513 #if ENABLE(DRAG_SUPPORT)
514     bool m_mouseDownMayStartDrag { false };
515     bool m_dragMayStartSelectionInstead { false };
516 #endif
517 
518     bool m_mouseDownWasSingleClickInSelection { false };
519     enum SelectionInitiationState { HaveNotStartedSelection, PlacedCaret, ExtendedSelection };
520     SelectionInitiationState m_selectionInitiationState { HaveNotStartedSelection };
521 
522 #if ENABLE(DRAG_SUPPORT)
523     LayoutPoint m_dragStartPosition;
524 #endif
525 
526     Timer m_hoverTimer;
527     Timer m_cursorUpdateTimer;
528 
529 #if PLATFORM(MAC)
530     Timer m_pendingMomentumWheelEventsTimer;
531 #endif
532 
533     std::unique_ptr&lt;AutoscrollController&gt; m_autoscrollController;
534     bool m_mouseDownMayStartAutoscroll { false };
535     bool m_mouseDownWasInSubframe { false };
536 
537 #if !ENABLE(IOS_TOUCH_EVENTS)
538     Timer m_fakeMouseMoveEventTimer;
539 #endif
540 
541     bool m_svgPan { false };
542 
543     RenderLayer* m_resizeLayer { nullptr };
544 
545     RefPtr&lt;Element&gt; m_capturingMouseEventsElement;
546     bool m_eventHandlerWillResetCapturingMouseEventsElement { false };
547 
548     RefPtr&lt;Element&gt; m_elementUnderMouse;
549     RefPtr&lt;Element&gt; m_lastElementUnderMouse;
550     RefPtr&lt;Frame&gt; m_lastMouseMoveEventSubframe;
551     WeakPtr&lt;Scrollbar&gt; m_lastScrollbarUnderMouse;
552     Cursor m_currentMouseCursor;
553 
554     int m_clickCount { 0 };
555     RefPtr&lt;Node&gt; m_clickNode;
556 
557 #if ENABLE(IOS_GESTURE_EVENTS)
558     float m_gestureInitialDiameter { GestureUnknown };
559     float m_gestureInitialRotation { GestureUnknown };
560 #endif
561 
562 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
563     float m_gestureLastDiameter { GestureUnknown };
564     float m_gestureLastRotation { GestureUnknown };
565     EventTargetSet m_gestureTargets;
566 #endif
567 
568 #if ENABLE(MAC_GESTURE_EVENTS)
569     bool m_hasActiveGesture { false };
570 #endif
571 
572 #if ENABLE(IOS_TOUCH_EVENTS)
573     unsigned m_firstTouchID { InvalidTouchIdentifier };
574 
575     TouchArray m_touches;
576     RefPtr&lt;Frame&gt; m_touchEventTargetSubframe;
577 #endif
578 
579 #if ENABLE(DRAG_SUPPORT)
580     RefPtr&lt;Element&gt; m_dragTarget;
581     bool m_shouldOnlyFireDragOverEvent { false };
582 #endif
583 
584     RefPtr&lt;HTMLFrameSetElement&gt; m_frameSetBeingResized;
585 
586     LayoutSize m_offsetFromResizeCorner; // In the coords of m_resizeLayer.
587 
588     bool m_mousePositionIsUnknown { true };
589     IntPoint m_lastKnownMousePosition;
590     IntPoint m_lastKnownMouseGlobalPosition;
591     IntPoint m_mouseDownPos; // In our view&#39;s coords.
592     WallTime m_mouseDownTimestamp;
593     PlatformMouseEvent m_mouseDown;
594 #if ENABLE(POINTER_EVENTS)
595     PlatformMouseEvent m_lastPlatformMouseEvent;
596 #endif
597 
598 #if PLATFORM(COCOA)
599     NSView *m_mouseDownView { nullptr };
600     bool m_sendingEventToSubview { false };
601 #endif
602 
603 #if PLATFORM(MAC)
604     int m_activationEventNumber { -1 };
605 #endif
606 
607 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
608     using TouchTargetMap = HashMap&lt;int, RefPtr&lt;EventTarget&gt;&gt;;
609     TouchTargetMap m_originatingTouchPointTargets;
610     RefPtr&lt;Document&gt; m_originatingTouchPointDocument;
611     unsigned m_originatingTouchPointTargetKey { 0 };
612     bool m_touchPressed { false };
613 #endif
614 
615 #if ENABLE(IOS_TOUCH_EVENTS)
616     unsigned touchIdentifierForMouseEvents { 0 };
617 #endif
618 
619 #if ENABLE(POINTER_EVENTS) &amp;&amp; ENABLE(IOS_TOUCH_EVENTS)
620     unsigned m_touchIdentifierForPrimaryTouch { 0 };
621 #endif
622 
623     double m_maxMouseMovedDuration { 0 };
624     bool m_didStartDrag { false };
625     bool m_isHandlingWheelEvent { false };
626 
627 #if PLATFORM(IOS_FAMILY)
628     bool m_shouldAllowMouseDownToStartDrag { false };
629     IntPoint m_targetAutoscrollPositionInWindow;
630     bool m_isAutoscrolling { false };
631 #endif
632 
633 #if ENABLE(CURSOR_VISIBILITY)
634     Timer m_autoHideCursorTimer;
635 #endif
636 
637     ImmediateActionStage m_immediateActionStage { ImmediateActionStage::None };
638 };
639 
640 } // namespace WebCore
    </pre>
  </body>
</html>
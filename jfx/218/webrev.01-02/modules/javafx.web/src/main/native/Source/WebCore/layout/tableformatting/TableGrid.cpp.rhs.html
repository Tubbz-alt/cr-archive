<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableGrid.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableGrid.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &lt;wtf/IsoMallocInlines.h&gt;
 32 
 33 namespace WebCore {
 34 namespace Layout {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(TableGrid);
 37 
<a name="1" id="anc1"></a><span class="line-added"> 38 TableGrid::Column::Column(const Box* columnBox)</span>
<span class="line-added"> 39     : m_columnBox(makeWeakPtr(columnBox))</span>
<span class="line-added"> 40 {</span>
<span class="line-added"> 41 }</span>
<span class="line-added"> 42 </span>
 43 void TableGrid::Column::setWidthConstraints(FormattingContext::IntrinsicWidthConstraints widthConstraints)
 44 {
<a name="2" id="anc2"></a><span class="line-modified"> 45 #if ASSERT_ENABLED</span>
 46     m_hasWidthConstraints = true;
 47 #endif
 48     m_widthConstraints = widthConstraints;
 49 }
 50 
 51 FormattingContext::IntrinsicWidthConstraints TableGrid::Column::widthConstraints() const
 52 {
 53     ASSERT(m_hasWidthConstraints);
 54     return m_widthConstraints;
 55 }
 56 
 57 void TableGrid::Column::setLogicalWidth(LayoutUnit computedLogicalWidth)
 58 {
<a name="3" id="anc3"></a><span class="line-modified"> 59 #if ASSERT_ENABLED</span>
 60     m_hasComputedWidth = true;
 61 #endif
 62     m_computedLogicalWidth = computedLogicalWidth;
 63 }
 64 
 65 LayoutUnit TableGrid::Column::logicalWidth() const
 66 {
 67     ASSERT(m_hasComputedWidth);
 68     return m_computedLogicalWidth;
 69 }
 70 
 71 void TableGrid::Column::setLogicalLeft(LayoutUnit computedLogicalLeft)
 72 {
<a name="4" id="anc4"></a><span class="line-modified"> 73 #if ASSERT_ENABLED</span>
 74     m_hasComputedLeft = true;
 75 #endif
 76     m_computedLogicalLeft = computedLogicalLeft;
 77 }
 78 
 79 LayoutUnit TableGrid::Column::logicalLeft() const
 80 {
 81     ASSERT(m_hasComputedLeft);
 82     return m_computedLogicalLeft;
 83 }
 84 
<a name="5" id="anc5"></a><span class="line-modified"> 85 bool TableGrid::Column::hasFixedWidth() const</span>
 86 {
<a name="6" id="anc6"></a><span class="line-modified"> 87     // FIXME: This only covers the &lt;col&gt; attribute case.</span>
<span class="line-added"> 88     return columnBox() &amp;&amp; columnBox()-&gt;columnWidth();</span>
 89 }
 90 
<a name="7" id="anc7"></a><span class="line-modified"> 91 void TableGrid::ColumnsContext::addColumn(const Box* columnBox)</span>
<span class="line-added"> 92 {</span>
<span class="line-added"> 93     m_columns.append({ columnBox });</span>
<span class="line-added"> 94 }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96 TableGrid::Row::Row(const Box&amp; rowBox)</span>
<span class="line-added"> 97     : m_layoutBox(rowBox)</span>
 98 {
<a name="8" id="anc8"></a>

 99 }
100 
101 TableGrid::CellInfo::CellInfo(const Box&amp; tableCellBox, SlotPosition position, CellSize size)
102     : tableCellBox(tableCellBox)
103     , position(position)
104     , size(size)
105 {
106 }
107 
108 TableGrid::SlotInfo::SlotInfo(CellInfo&amp; cell)
109     : cell(makeWeakPtr(cell))
110 {
111 }
112 
113 TableGrid::TableGrid()
114 {
115 }
116 
117 TableGrid::SlotInfo* TableGrid::slot(SlotPosition position)
118 {
119     return m_slotMap.get(position);
120 }
121 
122 void TableGrid::appendCell(const Box&amp; tableCellBox)
123 {
124     int rowSpan = tableCellBox.rowSpan();
125     int columnSpan = tableCellBox.columnSpan();
126     auto isInNewRow = !tableCellBox.previousSibling();
127     auto initialSlotPosition = SlotPosition { };
128 
129     if (!m_cellList.isEmpty()) {
130         auto&amp; lastCell = m_cellList.last();
131         auto lastSlotPosition = lastCell-&gt;position;
132         // First table cell in this row?
133         if (isInNewRow)
134             initialSlotPosition = SlotPosition { 0, lastSlotPosition.y() + 1 };
135         else
136             initialSlotPosition = SlotPosition { lastSlotPosition.x() + 1, lastSlotPosition.y() };
137 
138         // Pick the next available slot by avoiding row and column spanners.
139         while (true) {
140             if (!m_slotMap.contains(initialSlotPosition))
141                 break;
142             initialSlotPosition.move(1, 0);
143         }
144     }
145     auto cellInfo = makeUnique&lt;CellInfo&gt;(tableCellBox, initialSlotPosition, CellSize { rowSpan, columnSpan });
146     // Row and column spanners create additional slots.
147     for (int row = 1; row &lt;= rowSpan; ++row) {
148         for (int column = 1; column &lt;= columnSpan; ++column) {
149             auto position = SlotPosition { initialSlotPosition.x() + row - 1, initialSlotPosition.y() + column - 1 };
150             ASSERT(!m_slotMap.contains(position));
151             m_slotMap.add(position, makeUnique&lt;SlotInfo&gt;(*cellInfo));
152         }
153     }
154     // Initialize columns/rows if needed.
<a name="9" id="anc9"></a><span class="line-modified">155     auto missingNumberOfColumns = std::max&lt;int&gt;(0, initialSlotPosition.x() + columnSpan - m_columnsContext.columns().size());</span>
<span class="line-modified">156     for (auto column = 0; column &lt; missingNumberOfColumns; ++column)</span>
157         m_columnsContext.addColumn();
158 
159     if (isInNewRow)
<a name="10" id="anc10"></a><span class="line-modified">160         m_rows.append({ *tableCellBox.parent() });</span>
161 
162     m_cellList.add(WTFMove(cellInfo));
163 }
164 
165 void TableGrid::insertCell(const Box&amp; tableCellBox, const Box&amp; before)
166 {
167     UNUSED_PARAM(tableCellBox);
168     UNUSED_PARAM(before);
169 }
170 
171 void TableGrid::removeCell(const Box&amp; tableCellBox)
172 {
173     UNUSED_PARAM(tableCellBox);
174 }
175 
<a name="11" id="anc11"></a><span class="line-modified">176 FormattingContext::IntrinsicWidthConstraints TableGrid::widthConstraints()</span>
177 {
<a name="12" id="anc12"></a><span class="line-modified">178     // FIXME: Add constraint invalidation for incremental layouts.</span>
<span class="line-modified">179     if (m_intrinsicWidthConstraints)</span>
<span class="line-added">180         return *m_intrinsicWidthConstraints;</span>
<span class="line-added">181 </span>
<span class="line-added">182     m_intrinsicWidthConstraints = FormattingContext::IntrinsicWidthConstraints { };</span>
183     for (auto&amp; column : m_columnsContext.columns())
<a name="13" id="anc13"></a><span class="line-modified">184         *m_intrinsicWidthConstraints += column.widthConstraints();</span>
<span class="line-modified">185     m_intrinsicWidthConstraints-&gt;expand(totalHorizontalSpacing());</span>
<span class="line-added">186     return *m_intrinsicWidthConstraints;</span>
187 }
188 
189 }
190 }
191 #endif
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
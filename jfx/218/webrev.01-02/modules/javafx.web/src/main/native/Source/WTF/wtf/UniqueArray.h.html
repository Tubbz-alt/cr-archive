<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/UniqueArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/CheckedArithmetic.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace WTF {
 33 
 34 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(UniqueArray);
 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(UniqueArrayElement);
 36 
 37 template&lt;bool isTriviallyDestructible, typename T&gt; struct UniqueArrayMaker;
 38 
 39 template&lt;typename T&gt;
 40 struct UniqueArrayFree {
 41     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 42 
 43     void operator()(T* pointer) const
 44     {
 45         UniqueArrayMalloc::free(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));
 46     }
 47 };
 48 
 49 template&lt;typename T&gt;
 50 struct UniqueArrayFree&lt;T[]&gt; {
 51     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 52 
 53     void operator()(T* pointer) const
 54     {
 55         UniqueArrayMalloc::free(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));
 56     }
 57 };
 58 
 59 
 60 template&lt;typename T&gt;
 61 struct UniqueArrayMaker&lt;true, T&gt; {
 62     using ResultType = typename std::unique_ptr&lt;T[], UniqueArrayFree&lt;T[]&gt;&gt;;
 63 
 64     static ResultType make(size_t size)
 65     {
 66         // C++ `new T[N]` stores its `N` to somewhere. Otherwise, `delete []` cannot destroy
 67         // these N elements. But we do not want to increase the size of allocated memory.
 68         // If it is acceptable, we can just use Vector&lt;T&gt; instead. So this UniqueArray&lt;T&gt; only
 69         // accepts the type T which has a trivial destructor. This allows us to skip calling
 70         // destructors for N elements. And this allows UniqueArray&lt;T&gt; not to store its N size.
 71         static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 72 
 73         // Do not use placement new like `new (storage) T[size]()`. `new T[size]()` requires
 74         // larger storage than the `sizeof(T) * size` storage since it want to store `size`
 75         // to somewhere.
 76         T* storage = static_cast&lt;T*&gt;(UniqueArrayMalloc::malloc((Checked&lt;size_t&gt;(sizeof(T)) * size).unsafeGet()));
 77         VectorTypeOperations&lt;T&gt;::initialize(storage, storage + size);
 78         return ResultType(storage);
 79     }
 80 };
 81 
 82 template&lt;typename T&gt;
 83 struct UniqueArrayMaker&lt;false, T&gt; {
 84     // Since we do not know how to store/retrieve N size to/from allocated memory when calling new [] and delete [],
 85     // we use new [] and delete [] operators simply. We create UniqueArrayElement container for the type T.
 86     // UniqueArrayElement has new [] and delete [] operators for FastMalloc. We allocate UniqueArrayElement[] and cast
 87     // it to T[]. When deleting, the custom deleter casts T[] to UniqueArrayElement[] and deletes it.
 88     class UniqueArrayElement {
 89         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(UniqueArrayElement);
 90     public:
 91         struct Deleter {
 92             void operator()(T* pointer)
 93             {
 94                 delete [] bitwise_cast&lt;UniqueArrayElement*&gt;(pointer);
 95             };
 96         };
 97 
 98         UniqueArrayElement() = default;
 99 
100         T value { };
101     };
102     static_assert(sizeof(T) == sizeof(UniqueArrayElement), &quot;&quot;);
103 
104     using ResultType = typename std::unique_ptr&lt;T[], typename UniqueArrayElement::Deleter&gt;;
105 
106     static ResultType make(size_t size)
107     {
108         return ResultType(bitwise_cast&lt;T*&gt;(new UniqueArrayElement[size]()));
109     }
110 };
111 
112 template&lt;typename T&gt;
113 using UniqueArray = typename UniqueArrayMaker&lt;std::is_trivially_destructible&lt;T&gt;::value, T&gt;::ResultType;
114 
115 template&lt;typename T&gt;
116 UniqueArray&lt;T&gt; makeUniqueArray(size_t size)
117 {
118     static_assert(std::is_same&lt;typename std::remove_extent&lt;T&gt;::type, T&gt;::value, &quot;&quot;);
119     return UniqueArrayMaker&lt;std::is_trivially_destructible&lt;T&gt;::value, T&gt;::make(size);
120 }
121 
122 } // namespace WTF
123 
124 using WTF::UniqueArray;
125 using WTF::makeUniqueArray;
    </pre>
  </body>
</html>
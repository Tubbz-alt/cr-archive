<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/SVGUseElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) Research In Motion Limited 2009-2010. All rights reserved.
  5  * Copyright (C) 2011 Torch Mobile (Beijing) Co. Ltd. All rights reserved.
  6  * Copyright (C) 2012 University of Szeged
  7  * Copyright (C) 2012 Renata Hodovan &lt;reni@webkit.org&gt;
  8  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  9  *
 10  * This library is free software; you can redistribute it and/or
 11  * modify it under the terms of the GNU Library General Public
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SVGUseElement.h&quot;
 28 
 29 #include &quot;CachedResourceLoader.h&quot;
 30 #include &quot;CachedSVGDocument.h&quot;
 31 #include &quot;ElementIterator.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;RenderSVGResource.h&quot;
 35 #include &quot;RenderSVGTransformableContainer.h&quot;
 36 #include &quot;SVGDocumentExtensions.h&quot;
 37 #include &quot;SVGGElement.h&quot;
 38 #include &quot;SVGSVGElement.h&quot;
 39 #include &quot;SVGSymbolElement.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;ShadowRoot.h&quot;
 42 #include &quot;XLinkNames.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(SVGUseElement);
 48 
 49 inline SVGUseElement::SVGUseElement(const QualifiedName&amp; tagName, Document&amp; document)
 50     : SVGGraphicsElement(tagName, document)
<a name="1" id="anc1"></a>
 51     , SVGURIReference(this)
<a name="2" id="anc2"></a><span class="line-modified"> 52     , m_loadEventTimer(*this, &amp;SVGElement::loadEventTimerFired)</span>
 53 {
 54     ASSERT(hasCustomStyleResolveCallbacks());
 55     ASSERT(hasTagName(SVGNames::useTag));
 56 
 57     static std::once_flag onceFlag;
 58     std::call_once(onceFlag, [] {
 59         PropertyRegistry::registerProperty&lt;SVGNames::xAttr, &amp;SVGUseElement::m_x&gt;();
 60         PropertyRegistry::registerProperty&lt;SVGNames::yAttr, &amp;SVGUseElement::m_y&gt;();
 61         PropertyRegistry::registerProperty&lt;SVGNames::widthAttr, &amp;SVGUseElement::m_width&gt;();
 62         PropertyRegistry::registerProperty&lt;SVGNames::heightAttr, &amp;SVGUseElement::m_height&gt;();
 63     });
 64 }
 65 
 66 Ref&lt;SVGUseElement&gt; SVGUseElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 67 {
 68     return adoptRef(*new SVGUseElement(tagName, document));
 69 }
 70 
 71 SVGUseElement::~SVGUseElement()
 72 {
 73     if (m_externalDocument)
 74         m_externalDocument-&gt;removeClient(*this);
 75 }
 76 
 77 void SVGUseElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 78 {
 79     SVGParsingError parseError = NoError;
 80 
 81     if (name == SVGNames::xAttr)
<a name="3" id="anc3"></a><span class="line-modified"> 82         m_x-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError));</span>
 83     else if (name == SVGNames::yAttr)
<a name="4" id="anc4"></a><span class="line-modified"> 84         m_y-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError));</span>
 85     else if (name == SVGNames::widthAttr)
<a name="5" id="anc5"></a><span class="line-modified"> 86         m_width-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Width, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
 87     else if (name == SVGNames::heightAttr)
<a name="6" id="anc6"></a><span class="line-modified"> 88         m_height-&gt;setBaseValInternal(SVGLengthValue::construct(SVGLengthMode::Height, value, parseError, SVGLengthNegativeValuesMode::Forbid));</span>
 89 
 90     reportAttributeParsingError(parseError, name, value);
 91 
<a name="7" id="anc7"></a>
 92     SVGGraphicsElement::parseAttribute(name, value);
 93     SVGURIReference::parseAttribute(name, value);
 94 }
 95 
 96 Node::InsertedIntoAncestorResult SVGUseElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 97 {
 98     SVGGraphicsElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 99     if (insertionType.connectedToDocument) {
100         if (m_shadowTreeNeedsUpdate)
101             document().addSVGUseElement(*this);
<a name="8" id="anc8"></a>
102         invalidateShadowTree();
103         // FIXME: Move back the call to updateExternalDocument() here once notifyFinished is made always async.
104         return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
105     }
106     return InsertedIntoAncestorResult::Done;
107 }
108 
109 void SVGUseElement::didFinishInsertingNode()
110 {
111     updateExternalDocument();
112 }
113 
114 void SVGUseElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
115 {
116     // Check m_shadowTreeNeedsUpdate before calling SVGElement::removedFromAncestor which calls SVGElement::invalidateInstances
117     // and SVGUseElement::updateExternalDocument which calls invalidateShadowTree().
118     if (removalType.disconnectedFromDocument) {
119         if (m_shadowTreeNeedsUpdate)
120             document().removeSVGUseElement(*this);
121     }
122     SVGGraphicsElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
123     if (removalType.disconnectedFromDocument) {
124         clearShadowTree();
125         updateExternalDocument();
126     }
127 }
128 
129 inline Document* SVGUseElement::externalDocument() const
130 {
131     return m_externalDocument ? m_externalDocument-&gt;document() : nullptr;
132 }
133 
134 void SVGUseElement::transferSizeAttributesToTargetClone(SVGElement&amp; shadowElement) const
135 {
136     // FIXME: The check for valueInSpecifiedUnits being non-zero below is a workaround for the fact
137     // that we currently have no good way to tell whether a particular animatable attribute is a value
138     // indicating it was unspecified, or specified but could not be parsed. Would be nice to fix that some day.
139     if (is&lt;SVGSymbolElement&gt;(shadowElement)) {
140         // Spec (&lt;use&gt; on &lt;symbol&gt;): This generated &#39;svg&#39; will always have explicit values for attributes width and height.
141         // If attributes width and/or height are provided on the &#39;use&#39; element, then these attributes
142         // will be transferred to the generated &#39;svg&#39;. If attributes width and/or height are not specified,
143         // the generated &#39;svg&#39; element will use values of 100% for these attributes.
144         shadowElement.setAttribute(SVGNames::widthAttr, width().valueInSpecifiedUnits() ? AtomString(width().valueAsString()) : &quot;100%&quot;);
145         shadowElement.setAttribute(SVGNames::heightAttr, height().valueInSpecifiedUnits() ? AtomString(height().valueAsString()) : &quot;100%&quot;);
146     } else if (is&lt;SVGSVGElement&gt;(shadowElement)) {
147         // Spec (&lt;use&gt; on &lt;svg&gt;): If attributes width and/or height are provided on the &#39;use&#39; element, then these
148         // values will override the corresponding attributes on the &#39;svg&#39; in the generated tree.
149         auto correspondingElement = makeRefPtr(shadowElement.correspondingElement());
150         shadowElement.setAttribute(SVGNames::widthAttr, width().valueInSpecifiedUnits() ? AtomString(width().valueAsString()) : (correspondingElement ? correspondingElement-&gt;getAttribute(SVGNames::widthAttr) : nullAtom()));
151         shadowElement.setAttribute(SVGNames::heightAttr, height().valueInSpecifiedUnits() ? AtomString(height().valueAsString()) : (correspondingElement ? correspondingElement-&gt;getAttribute(SVGNames::heightAttr) : nullAtom()));
152     }
153 }
154 
155 void SVGUseElement::svgAttributeChanged(const QualifiedName&amp; attrName)
156 {
157     InstanceInvalidationGuard guard(*this);
158 
159     if (PropertyRegistry::isKnownAttribute(attrName)) {
160         updateRelativeLengthsInformation();
161         if (attrName == SVGNames::widthAttr || attrName == SVGNames::heightAttr) {
162             // FIXME: It&#39;s unnecessarily inefficient to update both width and height each time either is changed.
163             if (auto targetClone = this-&gt;targetClone())
164                 transferSizeAttributesToTargetClone(*targetClone);
165         }
166         if (auto* renderer = this-&gt;renderer())
167             RenderSVGResource::markForLayoutAndParentResourceInvalidation(*renderer);
168         return;
169     }
170 
171     if (SVGURIReference::isKnownAttribute(attrName)) {
172         updateExternalDocument();
173         invalidateShadowTree();
174         return;
175     }
176 
<a name="9" id="anc9"></a>


177     SVGGraphicsElement::svgAttributeChanged(attrName);
<a name="10" id="anc10"></a>
178 }
179 
180 static HashSet&lt;AtomString&gt; createAllowedElementSet()
181 {
182     // Spec: &quot;Any &#39;svg&#39;, &#39;symbol&#39;, &#39;g&#39;, graphics element or other &#39;use&#39; is potentially a template object that can be re-used
183     // (i.e., &quot;instanced&quot;) in the SVG document via a &#39;use&#39; element.&quot;
184     // &quot;Graphics Element&quot; is defined as &#39;circle&#39;, &#39;ellipse&#39;, &#39;image&#39;, &#39;line&#39;, &#39;path&#39;, &#39;polygon&#39;, &#39;polyline&#39;, &#39;rect&#39;, &#39;text&#39;
185     // Excluded are anything that is used by reference or that only make sense to appear once in a document.
186     using namespace SVGNames;
187     HashSet&lt;AtomString&gt; set;
188     for (auto&amp; tag : { aTag.get(), circleTag.get(), descTag.get(), ellipseTag.get(), gTag.get(), imageTag.get(), lineTag.get(), metadataTag.get(), pathTag.get(), polygonTag.get(), polylineTag.get(), rectTag.get(), svgTag.get(), switchTag.get(), symbolTag.get(), textTag.get(), textPathTag.get(), titleTag.get(), trefTag.get(), tspanTag.get(), useTag.get() })
189         set.add(tag.localName());
190     return set;
191 }
192 
193 static inline bool isDisallowedElement(const SVGElement&amp; element)
194 {
195     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; set = createAllowedElementSet();
196     return !set.get().contains(element.localName());
197 }
198 
199 static inline bool isDisallowedElement(const Element&amp; element)
200 {
201     return !element.isSVGElement() || isDisallowedElement(downcast&lt;SVGElement&gt;(element));
202 }
203 
204 void SVGUseElement::clearShadowTree()
205 {
206     if (auto root = userAgentShadowRoot()) {
207         // Safe because SVG use element&#39;s shadow tree is never used to fire synchronous events during layout or DOM mutations.
208         ScriptDisallowedScope::EventAllowedScope scope(*root);
209         root-&gt;removeChildren();
210     }
211 }
212 
213 void SVGUseElement::buildPendingResource()
214 {
215     invalidateShadowTree();
216 }
217 
218 void SVGUseElement::updateShadowTree()
219 {
220     m_shadowTreeNeedsUpdate = false;
221 
222     // FIXME: It&#39;s expensive to re-clone the entire tree every time. We should find a more efficient way to handle this.
223     clearShadowTree();
224 
225     if (!isConnected())
226         return;
227     document().removeSVGUseElement(*this);
228 
229     String targetID;
230     auto* target = findTarget(&amp;targetID);
231     if (!target) {
232         document().accessSVGExtensions().addPendingResource(targetID, *this);
233         return;
234     }
235 
236     RELEASE_ASSERT(!isDescendantOf(target));
237     {
238         auto&amp; shadowRoot = ensureUserAgentShadowRoot();
239         cloneTarget(shadowRoot, *target);
240         expandUseElementsInShadowTree();
241         expandSymbolElementsInShadowTree();
242         updateRelativeLengthsInformation();
243     }
244 
245     transferEventListenersToShadowTree();
246 
247     // When we invalidate the other shadow trees, it&#39;s important that we don&#39;t
248     // follow any cycles and invalidate ourselves. To avoid that, we temporarily
249     // set m_shadowTreeNeedsUpdate to true so invalidateShadowTree will
250     // quickly return and do nothing.
251     ASSERT(!m_shadowTreeNeedsUpdate);
252     m_shadowTreeNeedsUpdate = true;
253     invalidateDependentShadowTrees();
254     m_shadowTreeNeedsUpdate = false;
255 }
256 
257 RefPtr&lt;SVGElement&gt; SVGUseElement::targetClone() const
258 {
259     auto root = userAgentShadowRoot();
260     if (!root)
261         return nullptr;
262     return childrenOfType&lt;SVGElement&gt;(*root).first();
263 }
264 
265 RenderPtr&lt;RenderElement&gt; SVGUseElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
266 {
267     return createRenderer&lt;RenderSVGTransformableContainer&gt;(*this, WTFMove(style));
268 }
269 
270 static bool isDirectReference(const SVGElement&amp; element)
271 {
272     using namespace SVGNames;
273     return element.hasTagName(circleTag)
274         || element.hasTagName(ellipseTag)
275         || element.hasTagName(pathTag)
276         || element.hasTagName(polygonTag)
277         || element.hasTagName(polylineTag)
278         || element.hasTagName(rectTag)
279         || element.hasTagName(textTag);
280 }
281 
282 Path SVGUseElement::toClipPath()
283 {
284     auto targetClone = this-&gt;targetClone();
285     if (!is&lt;SVGGraphicsElement&gt;(targetClone))
286         return { };
287 
288     if (!isDirectReference(*targetClone)) {
289         // Spec: Indirect references are an error (14.3.5)
290         document().accessSVGExtensions().reportError(&quot;Not allowed to use indirect reference in &lt;clip-path&gt;&quot;_s);
291         return { };
292     }
293 
294     Path path = downcast&lt;SVGGraphicsElement&gt;(*targetClone).toClipPath();
295     SVGLengthContext lengthContext(this);
296     // FIXME: Find a way to do this without manual resolution of x/y here. It&#39;s potentially incorrect.
297     path.translate(FloatSize(x().value(lengthContext), y().value(lengthContext)));
298     path.transform(animatedLocalTransform());
299     return path;
300 }
301 
302 RenderElement* SVGUseElement::rendererClipChild() const
303 {
304     auto targetClone = this-&gt;targetClone();
305     if (!targetClone)
306         return nullptr;
307     if (!isDirectReference(*targetClone))
308         return nullptr;
309     return targetClone-&gt;renderer();
310 }
311 
312 static inline void disassociateAndRemoveClones(const Vector&lt;Element*&gt;&amp; clones)
313 {
314     for (auto&amp; clone : clones) {
315         for (auto&amp; descendant : descendantsOfType&lt;SVGElement&gt;(*clone))
316             descendant.setCorrespondingElement(nullptr);
317         if (is&lt;SVGElement&gt;(clone))
318             downcast&lt;SVGElement&gt;(*clone).setCorrespondingElement(nullptr);
319         clone-&gt;parentNode()-&gt;removeChild(*clone);
320     }
321 }
322 
323 static void removeDisallowedElementsFromSubtree(SVGElement&amp; subtree)
324 {
325     // Remove disallowed elements after the fact rather than not cloning them in the first place.
326     // This optimizes for the normal case where none of those elements are present.
327 
328     // This function is used only on elements in subtrees that are not yet in documents, so
329     // mutation events are not a factor; there are no event listeners to handle those events.
330     // Assert that it&#39;s not in a document to make sure callers are still using it this way.
331     ASSERT(!subtree.isConnected());
332 
333     Vector&lt;Element*&gt; disallowedElements;
334     auto descendants = descendantsOfType&lt;Element&gt;(subtree);
335     for (auto it = descendants.begin(), end = descendants.end(); it != end; ) {
336         if (isDisallowedElement(*it)) {
337             disallowedElements.append(&amp;*it);
338             it.traverseNextSkippingChildren();
339             continue;
340         }
341         ++it;
342     }
343 
344     disassociateAndRemoveClones(disallowedElements);
345 }
346 
347 static void removeSymbolElementsFromSubtree(SVGElement&amp; subtree)
348 {
349     // Symbol elements inside the subtree should not be cloned for two reasons: 1) They are invisible and
350     // don&#39;t need to be cloned to get correct rendering. 2) expandSymbolElementsInShadowTree will turn them
351     // into &lt;svg&gt; elements, which is correct for symbol elements directly referenced by use elements,
352     // but incorrect for ones that just happen to be in a subtree.
353     Vector&lt;Element*&gt; symbolElements;
354     for (auto&amp; descendant : descendantsOfType&lt;SVGSymbolElement&gt;(subtree))
355         symbolElements.append(&amp;descendant);
356     disassociateAndRemoveClones(symbolElements);
357 }
358 
359 static void associateClonesWithOriginals(SVGElement&amp; clone, SVGElement&amp; original)
360 {
361     // This assertion checks that we don&#39;t call this with the arguments backwards.
362     // The clone is new and so it&#39;s not installed in a parent yet.
363     ASSERT(!clone.parentNode());
364 
365     // The loop below works because we are associating these clones immediately, before
366     // doing transformations like removing disallowed elements or expanding elements.
367     clone.setCorrespondingElement(&amp;original);
368     for (auto pair : descendantsOfType&lt;SVGElement&gt;(clone, original))
369         pair.first.setCorrespondingElement(&amp;pair.second);
370 }
371 
372 static void associateReplacementCloneWithOriginal(SVGElement&amp; replacementClone, SVGElement&amp; originalClone)
373 {
374     auto* correspondingElement = originalClone.correspondingElement();
375     ASSERT(correspondingElement);
376     originalClone.setCorrespondingElement(nullptr);
377     replacementClone.setCorrespondingElement(correspondingElement);
378 }
379 
380 static void associateReplacementClonesWithOriginals(SVGElement&amp; replacementClone, SVGElement&amp; originalClone)
381 {
382     // This assertion checks that we don&#39;t call this with the arguments backwards.
383     // The replacement clone is new and so it&#39;s not installed in a parent yet.
384     ASSERT(!replacementClone.parentNode());
385 
386     // The loop below works because we are associating these clones immediately, before
387     // doing transformations like removing disallowed elements or expanding elements.
388     associateReplacementCloneWithOriginal(replacementClone, originalClone);
389     for (auto pair : descendantsOfType&lt;SVGElement&gt;(replacementClone, originalClone))
390         associateReplacementCloneWithOriginal(pair.first, pair.second);
391 }
392 
393 SVGElement* SVGUseElement::findTarget(String* targetID) const
394 {
395     auto* correspondingElement = this-&gt;correspondingElement();
396     auto&amp; original = correspondingElement ? downcast&lt;SVGUseElement&gt;(*correspondingElement) : *this;
397 
398     auto targetResult = targetElementFromIRIString(original.href(), original.treeScope(), original.externalDocument());
399     if (targetID) {
400         *targetID = WTFMove(targetResult.identifier);
401         // If the reference is external, don&#39;t return the target ID to the caller.
402         // The caller would use the target ID to wait for a pending resource on the wrong document.
403         // If we ever want the change that and let the caller to wait on the external document,
404         // we should change this function so it returns the appropriate document to go with the ID.
405         if (!targetID-&gt;isNull() &amp;&amp; isExternalURIReference(original.href(), original.document()))
406             *targetID = String { };
407     }
408     if (!is&lt;SVGElement&gt;(targetResult.element))
409         return nullptr;
410     auto&amp; target = downcast&lt;SVGElement&gt;(*targetResult.element);
411 
412     if (!target.isConnected() || isDisallowedElement(target))
413         return nullptr;
414 
415     if (correspondingElement) {
416         for (auto&amp; ancestor : lineageOfType&lt;SVGElement&gt;(*this)) {
417             if (ancestor.correspondingElement() == &amp;target)
418                 return nullptr;
419         }
420     } else {
421         if (target.contains(this))
422             return nullptr;
423         // Target should only refer to a node in the same tree or a node in another document.
424         ASSERT(!isDescendantOrShadowDescendantOf(&amp;target));
425     }
426 
427     return &amp;target;
428 }
429 
430 void SVGUseElement::cloneTarget(ContainerNode&amp; container, SVGElement&amp; target) const
431 {
432     Ref&lt;SVGElement&gt; targetClone = static_cast&lt;SVGElement&amp;&gt;(target.cloneElementWithChildren(document()).get());
433     associateClonesWithOriginals(targetClone.get(), target);
434     removeDisallowedElementsFromSubtree(targetClone.get());
435     removeSymbolElementsFromSubtree(targetClone.get());
436     transferSizeAttributesToTargetClone(targetClone.get());
437     container.appendChild(targetClone);
438 }
439 
440 static void cloneDataAndChildren(SVGElement&amp; replacementClone, SVGElement&amp; originalClone)
441 {
442     // This assertion checks that we don&#39;t call this with the arguments backwards.
443     // The replacement clone is new and so it&#39;s not installed in a parent yet.
444     ASSERT(!replacementClone.parentNode());
445 
446     replacementClone.cloneDataFromElement(originalClone);
447     originalClone.cloneChildNodes(replacementClone);
448     associateReplacementClonesWithOriginals(replacementClone, originalClone);
449     removeDisallowedElementsFromSubtree(replacementClone);
450 }
451 
452 void SVGUseElement::expandUseElementsInShadowTree() const
453 {
454     auto descendants = descendantsOfType&lt;SVGUseElement&gt;(*userAgentShadowRoot());
455     for (auto it = descendants.begin(), end = descendants.end(); it != end; ) {
456         SVGUseElement&amp; originalClone = *it;
457         it = end; // Efficiently quiets assertions due to the outstanding iterator.
458 
459         auto* target = originalClone.findTarget();
460 
461         // Spec: In the generated content, the &#39;use&#39; will be replaced by &#39;g&#39;, where all attributes from the
462         // &#39;use&#39; element except for x, y, width, height and xlink:href are transferred to the generated &#39;g&#39; element.
463 
464         auto replacementClone = SVGGElement::create(document());
465 
466         cloneDataAndChildren(replacementClone.get(), originalClone);
467 
468         replacementClone-&gt;removeAttribute(SVGNames::xAttr);
469         replacementClone-&gt;removeAttribute(SVGNames::yAttr);
470         replacementClone-&gt;removeAttribute(SVGNames::widthAttr);
471         replacementClone-&gt;removeAttribute(SVGNames::heightAttr);
472         replacementClone-&gt;removeAttribute(SVGNames::hrefAttr);
473         replacementClone-&gt;removeAttribute(XLinkNames::hrefAttr);
474 
475         if (target)
476             originalClone.cloneTarget(replacementClone.get(), *target);
477 
478         originalClone.parentNode()-&gt;replaceChild(replacementClone, originalClone);
479 
480         // Resume iterating, starting just inside the replacement clone.
481         it = descendants.from(replacementClone.get());
482     }
483 }
484 
485 void SVGUseElement::expandSymbolElementsInShadowTree() const
486 {
487     auto descendants = descendantsOfType&lt;SVGSymbolElement&gt;(*userAgentShadowRoot());
488     for (auto it = descendants.begin(), end = descendants.end(); it != end; ) {
489         SVGSymbolElement&amp; originalClone = *it;
490         it = end; // Efficiently quiets assertions due to the outstanding iterator.
491 
492         // Spec: The referenced &#39;symbol&#39; and its contents are deep-cloned into the generated tree,
493         // with the exception that the &#39;symbol&#39; is replaced by an &#39;svg&#39;. This generated &#39;svg&#39; will
494         // always have explicit values for attributes width and height. If attributes width and/or
495         // height are provided on the &#39;use&#39; element, then these attributes will be transferred to
496         // the generated &#39;svg&#39;. If attributes width and/or height are not specified, the generated
497         // &#39;svg&#39; element will use values of 100% for these attributes.
498 
499         auto replacementClone = SVGSVGElement::create(document());
500         cloneDataAndChildren(replacementClone.get(), originalClone);
501 
502         originalClone.parentNode()-&gt;replaceChild(replacementClone, originalClone);
503 
504         // Resume iterating, starting just inside the replacement clone.
505         it = descendants.from(replacementClone.get());
506     }
507 }
508 
509 void SVGUseElement::transferEventListenersToShadowTree() const
510 {
511     // FIXME: Don&#39;t directly add event listeners on each descendant. Copy event listeners on the use element instead.
512     for (auto&amp; descendant : descendantsOfType&lt;SVGElement&gt;(*userAgentShadowRoot())) {
513         if (EventTargetData* data = descendant.correspondingElement()-&gt;eventTargetData())
514             data-&gt;eventListenerMap.copyEventListenersNotCreatedFromMarkupToTarget(&amp;descendant);
515     }
516 }
517 
518 void SVGUseElement::invalidateShadowTree()
519 {
520     if (m_shadowTreeNeedsUpdate)
521         return;
522     m_shadowTreeNeedsUpdate = true;
523     invalidateStyleAndRenderersForSubtree();
524     invalidateDependentShadowTrees();
525     if (isConnected())
526         document().addSVGUseElement(*this);
527 }
528 
529 void SVGUseElement::invalidateDependentShadowTrees()
530 {
531     for (auto* instance : instances()) {
532         if (auto element = instance-&gt;correspondingUseElement())
533             element-&gt;invalidateShadowTree();
534     }
535 }
536 
537 bool SVGUseElement::selfHasRelativeLengths() const
538 {
539     if (x().isRelative() || y().isRelative() || width().isRelative() || height().isRelative())
540         return true;
541 
542     auto targetClone = this-&gt;targetClone();
543     return targetClone &amp;&amp; targetClone-&gt;hasRelativeLengths();
544 }
545 
546 void SVGUseElement::notifyFinished(CachedResource&amp; resource)
547 {
548     ASSERT(ScriptDisallowedScope::InMainThread::isScriptAllowed());
549     invalidateShadowTree();
<a name="11" id="anc11"></a><span class="line-modified">550     if (resource.errorOccurred()) {</span>
<span class="line-added">551         setErrorOccurred(true);</span>
552         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
<a name="12" id="anc12"></a><span class="line-modified">553     } else if (!resource.wasCanceled())</span>
<span class="line-modified">554         SVGURIReference::dispatchLoadEvent();</span>






555 }
556 
557 void SVGUseElement::updateExternalDocument()
558 {
559     URL externalDocumentURL;
560     if (isConnected() &amp;&amp; isExternalURIReference(href(), document())) {
561         externalDocumentURL = document().completeURL(href());
562         if (!externalDocumentURL.hasFragmentIdentifier())
563             externalDocumentURL = URL();
564     }
565 
566     if (externalDocumentURL == (m_externalDocument ? m_externalDocument-&gt;url() : URL()))
567         return;
568 
569     if (m_externalDocument)
570         m_externalDocument-&gt;removeClient(*this);
571 
572     if (externalDocumentURL.isNull())
573         m_externalDocument = nullptr;
574     else {
575         ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
576         options.contentSecurityPolicyImposition = isInUserAgentShadowTree() ? ContentSecurityPolicyImposition::SkipPolicyCheck : ContentSecurityPolicyImposition::DoPolicyCheck;
577         options.mode = FetchOptions::Mode::SameOrigin;
578         CachedResourceRequest request { ResourceRequest { externalDocumentURL }, options };
579         request.setInitiator(*this);
580         m_externalDocument = document().cachedResourceLoader().requestSVGDocument(WTFMove(request)).value_or(nullptr);
581         if (m_externalDocument)
582             m_externalDocument-&gt;addClient(*this);
583     }
584 
585     invalidateShadowTree();
586 }
587 
<a name="13" id="anc13"></a>
























588 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
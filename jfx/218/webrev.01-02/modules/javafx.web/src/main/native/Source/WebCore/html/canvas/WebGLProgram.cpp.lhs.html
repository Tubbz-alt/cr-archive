<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLProgram.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<a name="1" id="anc1"></a>

 31 #include &quot;WebGLContextGroup.h&quot;
 32 #include &quot;WebGLRenderingContextBase.h&quot;
 33 #include &quot;WebGLShader.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 34 #include &lt;wtf/HashMap.h&gt;</span>
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/NeverDestroyed.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&amp; WebGLProgram::instances(const LockHolder&amp;)
 41 {
 42     static NeverDestroyed&lt;HashMap&lt;WebGLProgram*, WebGLRenderingContextBase*&gt;&gt; instances;
 43     return instances;
 44 }
 45 
 46 Lock&amp; WebGLProgram::instancesMutex()
 47 {
 48     static LazyNeverDestroyed&lt;Lock&gt; mutex;
 49     static std::once_flag initializeMutex;
 50     std::call_once(initializeMutex, [] {
 51         mutex.construct();
 52     });
 53     return mutex.get();
 54 }
 55 
 56 Ref&lt;WebGLProgram&gt; WebGLProgram::create(WebGLRenderingContextBase&amp; ctx)
 57 {
 58     return adoptRef(*new WebGLProgram(ctx));
 59 }
 60 
 61 WebGLProgram::WebGLProgram(WebGLRenderingContextBase&amp; ctx)
 62     : WebGLSharedObject(ctx)
<a name="3" id="anc3"></a>
 63 {
<a name="4" id="anc4"></a>

 64     {
 65         LockHolder lock(instancesMutex());
 66         instances(lock).add(this, &amp;ctx);
 67     }
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69     setObject(ctx.graphicsContext3D()-&gt;createProgram());</span>
 70 }
 71 
 72 WebGLProgram::~WebGLProgram()
 73 {
<a name="6" id="anc6"></a>

 74     deleteObject(0);
 75 
 76     {
 77         LockHolder lock(instancesMutex());
 78         ASSERT(instances(lock).contains(this));
 79         instances(lock).remove(this);
 80     }
 81 }
 82 
<a name="7" id="anc7"></a><span class="line-modified"> 83 void WebGLProgram::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject obj)</span>







 84 {
 85     context3d-&gt;deleteProgram(obj);
 86     if (m_vertexShader) {
 87         m_vertexShader-&gt;onDetached(context3d);
 88         m_vertexShader = nullptr;
 89     }
 90     if (m_fragmentShader) {
 91         m_fragmentShader-&gt;onDetached(context3d);
 92         m_fragmentShader = nullptr;
 93     }
 94 }
 95 
 96 unsigned WebGLProgram::numActiveAttribLocations()
 97 {
 98     cacheInfoIfNeeded();
 99     return m_activeAttribLocations.size();
100 }
101 
<a name="8" id="anc8"></a><span class="line-modified">102 GC3Dint WebGLProgram::getActiveAttribLocation(GC3Duint index)</span>
103 {
104     cacheInfoIfNeeded();
105     if (index &gt;= numActiveAttribLocations())
106         return -1;
107     return m_activeAttribLocations[index];
108 }
109 
110 bool WebGLProgram::isUsingVertexAttrib0()
111 {
112     cacheInfoIfNeeded();
113     for (unsigned ii = 0; ii &lt; numActiveAttribLocations(); ++ii) {
114         if (!getActiveAttribLocation(ii))
115             return true;
116     }
117     return false;
118 }
119 
120 bool WebGLProgram::getLinkStatus()
121 {
122     cacheInfoIfNeeded();
123     return m_linkStatus;
124 }
125 
126 void WebGLProgram::setLinkStatus(bool status)
127 {
128     cacheInfoIfNeeded();
129     m_linkStatus = status;
130 }
131 
132 void WebGLProgram::increaseLinkCount()
133 {
134     ++m_linkCount;
135     m_infoValid = false;
136 }
137 
<a name="9" id="anc9"></a><span class="line-modified">138 WebGLShader* WebGLProgram::getAttachedShader(GC3Denum type)</span>
139 {
140     switch (type) {
<a name="10" id="anc10"></a><span class="line-modified">141     case GraphicsContext3D::VERTEX_SHADER:</span>
142         return m_vertexShader.get();
<a name="11" id="anc11"></a><span class="line-modified">143     case GraphicsContext3D::FRAGMENT_SHADER:</span>
144         return m_fragmentShader.get();
145     default:
146         return 0;
147     }
148 }
149 
150 bool WebGLProgram::attachShader(WebGLShader* shader)
151 {
152     if (!shader || !shader-&gt;object())
153         return false;
154     switch (shader-&gt;getType()) {
<a name="12" id="anc12"></a><span class="line-modified">155     case GraphicsContext3D::VERTEX_SHADER:</span>
156         if (m_vertexShader)
157             return false;
158         m_vertexShader = shader;
159         return true;
<a name="13" id="anc13"></a><span class="line-modified">160     case GraphicsContext3D::FRAGMENT_SHADER:</span>
161         if (m_fragmentShader)
162             return false;
163         m_fragmentShader = shader;
164         return true;
165     default:
166         return false;
167     }
168 }
169 
170 bool WebGLProgram::detachShader(WebGLShader* shader)
171 {
172     if (!shader || !shader-&gt;object())
173         return false;
174     switch (shader-&gt;getType()) {
<a name="14" id="anc14"></a><span class="line-modified">175     case GraphicsContext3D::VERTEX_SHADER:</span>
176         if (m_vertexShader != shader)
177             return false;
178         m_vertexShader = nullptr;
179         return true;
<a name="15" id="anc15"></a><span class="line-modified">180     case GraphicsContext3D::FRAGMENT_SHADER:</span>
181         if (m_fragmentShader != shader)
182             return false;
183         m_fragmentShader = nullptr;
184         return true;
185     default:
186         return false;
187     }
188 }
189 
<a name="16" id="anc16"></a><span class="line-modified">190 void WebGLProgram::cacheActiveAttribLocations(GraphicsContext3D* context3d)</span>
191 {
192     m_activeAttribLocations.clear();
193 
<a name="17" id="anc17"></a><span class="line-modified">194     GC3Dint numAttribs = 0;</span>
<span class="line-modified">195     context3d-&gt;getProgramiv(object(), GraphicsContext3D::ACTIVE_ATTRIBUTES, &amp;numAttribs);</span>
196     m_activeAttribLocations.resize(static_cast&lt;size_t&gt;(numAttribs));
197     for (int i = 0; i &lt; numAttribs; ++i) {
<a name="18" id="anc18"></a><span class="line-modified">198         ActiveInfo info;</span>
199         context3d-&gt;getActiveAttribImpl(object(), i, info);
200         m_activeAttribLocations[i] = context3d-&gt;getAttribLocation(object(), info.name);
201     }
202 }
203 
204 void WebGLProgram::cacheInfoIfNeeded()
205 {
206     if (m_infoValid)
207         return;
208 
209     if (!object())
210         return;
211 
<a name="19" id="anc19"></a><span class="line-modified">212     GraphicsContext3D* context = getAGraphicsContext3D();</span>
213     if (!context)
214         return;
<a name="20" id="anc20"></a><span class="line-modified">215     GC3Dint linkStatus = 0;</span>
<span class="line-modified">216     context-&gt;getProgramiv(object(), GraphicsContext3D::LINK_STATUS, &amp;linkStatus);</span>
217     m_linkStatus = linkStatus;
218     if (m_linkStatus)
219         cacheActiveAttribLocations(context);
220     m_infoValid = true;
221 }
222 
223 }
224 
225 #endif // ENABLE(WEBGL)
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
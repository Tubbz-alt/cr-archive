<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/BitmapImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  3  * Copyright (C) 2004, 2005, 2006, 2008, 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;BitmapImage.h&quot;
 29 
 30 #include &quot;FloatRect.h&quot;
 31 #include &quot;GraphicsContext.h&quot;
 32 #include &quot;ImageBuffer.h&quot;
 33 #include &quot;ImageObserver.h&quot;
 34 #include &quot;IntRect.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;Settings.h&quot;
 37 #include &quot;Timer.h&quot;
 38 #include &lt;wtf/Vector.h&gt;
 39 #include &lt;wtf/text/TextStream.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 #if USE(CG)
 43 #include &lt;pal/spi/cg/CoreGraphicsSPI.h&gt;
 44 #endif
 45 
 46 namespace WebCore {
 47 
 48 BitmapImage::BitmapImage(ImageObserver* observer)
 49     : Image(observer)
 50     , m_source(ImageSource::create(this))
 51 {
 52 }
 53 
 54 BitmapImage::BitmapImage(NativeImagePtr&amp;&amp; image, ImageObserver* observer)
 55     : Image(observer)
 56     , m_source(ImageSource::create(WTFMove(image)))
 57 {
 58 }
 59 
 60 BitmapImage::~BitmapImage()
 61 {
 62     invalidatePlatformData();
 63     clearTimer();
 64     m_source-&gt;clearImage();
 65     m_source-&gt;stopAsyncDecodingQueue();
 66 }
 67 
 68 void BitmapImage::updateFromSettings(const Settings&amp; settings)
 69 {
 70     m_allowSubsampling = settings.imageSubsamplingEnabled();
 71     m_allowAnimatedImageAsyncDecoding = settings.animatedImageAsyncDecodingEnabled();
 72     m_showDebugBackground = settings.showDebugBorders();
 73 }
 74 
 75 void BitmapImage::destroyDecodedData(bool destroyAll)
 76 {
 77     LOG(Images, &quot;BitmapImage::%s - %p - url: %s&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
 78 
 79     if (!destroyAll)
 80         m_source-&gt;destroyDecodedDataBeforeFrame(m_currentFrame);
 81     else if (!canDestroyDecodedData())
 82         m_source-&gt;destroyAllDecodedDataExcludeFrame(m_currentFrame);
 83     else {
 84         m_source-&gt;destroyAllDecodedData();
 85         m_currentFrameDecodingStatus = DecodingStatus::Invalid;
 86     }
 87 
 88     // There&#39;s no need to throw away the decoder unless we&#39;re explicitly asked
 89     // to destroy all of the frames.
 90     if (!destroyAll || m_source-&gt;hasAsyncDecodingQueue())
 91         m_source-&gt;clearFrameBufferCache(m_currentFrame);
 92     else
 93         m_source-&gt;resetData(data());
 94 
 95     invalidatePlatformData();
 96 }
 97 
 98 void BitmapImage::destroyDecodedDataIfNecessary(bool destroyAll)
 99 {
100     // If we have decoded frames but there is no encoded data, we shouldn&#39;t destroy
101     // the decoded image since we won&#39;t be able to reconstruct it later.
102     if (!data() &amp;&amp; frameCount())
103         return;
104 
105     if (m_source-&gt;decodedSize() &lt; LargeAnimationCutoff)
106         return;
107 
108     destroyDecodedData(destroyAll);
109 }
110 
111 EncodedDataStatus BitmapImage::dataChanged(bool allDataReceived)
112 {
113     if (m_source-&gt;decodedSize() &amp;&amp; !canUseAsyncDecodingForLargeImages())
114         m_source-&gt;destroyIncompleteDecodedData();
115 
116     m_currentFrameDecodingStatus = DecodingStatus::Invalid;
117     return m_source-&gt;dataChanged(data(), allDataReceived);
118 }
119 
120 void BitmapImage::setCurrentFrameDecodingStatusIfNecessary(DecodingStatus decodingStatus)
121 {
122     // When new data is received, m_currentFrameDecodingStatus is set to DecodingStatus::Invalid
123     // to force decoding the frame when it&#39;s drawn. m_currentFrameDecodingStatus should not be
124     // changed in this case till draw() is called and sets its value to DecodingStatus::Decoding.
125     if (m_currentFrameDecodingStatus != DecodingStatus::Decoding)
126         return;
127     m_currentFrameDecodingStatus = decodingStatus;
128 }
129 
130 NativeImagePtr BitmapImage::frameImageAtIndexCacheIfNeeded(size_t index, SubsamplingLevel subsamplingLevel, const GraphicsContext* targetContext)
131 {
132     if (!frameHasFullSizeNativeImageAtIndex(index, subsamplingLevel)) {
133         LOG(Images, &quot;BitmapImage::%s - %p - url: %s [subsamplingLevel was %d, resampling]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), static_cast&lt;int&gt;(frameSubsamplingLevelAtIndex(index)));
134         invalidatePlatformData();
135     }
136 #if USE(DIRECT2D)
137     m_source-&gt;setTargetContext(targetContext);
138 #else
139     UNUSED_PARAM(targetContext);
140 #endif
141     return m_source-&gt;frameImageAtIndexCacheIfNeeded(index, subsamplingLevel);
142 }
143 
144 NativeImagePtr BitmapImage::nativeImage(const GraphicsContext* targetContext)
145 {
146     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
147 }
148 
149 NativeImagePtr BitmapImage::nativeImageForCurrentFrame(const GraphicsContext* targetContext)
150 {
151     return frameImageAtIndexCacheIfNeeded(m_currentFrame, SubsamplingLevel::Default, targetContext);
152 }
153 
154 NativeImagePtr BitmapImage::nativeImageForCurrentFrameRespectingOrientation(const GraphicsContext* targetContext)
155 {
156     auto image = nativeImageForCurrentFrame(targetContext);
157 
158     ImageOrientation orientation = orientationForCurrentFrame();
159     if (orientation == ImageOrientation::None)
160         return image;
161 
162     FloatRect rect = { FloatPoint(), size() };
163     auto buffer = ImageBuffer::create(rect.size(), RenderingMode::Unaccelerated);
164     if (!buffer)
165         return image;
166 
167 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
168     buffer-&gt;context().drawNativeImage(image, rect.size(), rect, rect, { orientation });
169 #endif
170 
171 #if USE(CG) || USE(DIRECT2D)
172     return ImageBuffer::sinkIntoNativeImage(WTFMove(buffer));
173 #elif USE(CAIRO)
174     return buffer-&gt;nativeImage();
175 #endif
176 
177     return nullptr;
178 }
179 
180 #if USE(CG)
181 NativeImagePtr BitmapImage::nativeImageOfSize(const IntSize&amp; size, const GraphicsContext* targetContext)
182 {
183     size_t count = frameCount();
184 
185     for (size_t i = 0; i &lt; count; ++i) {
186         auto image = frameImageAtIndexCacheIfNeeded(i, SubsamplingLevel::Default, targetContext);
187         if (image &amp;&amp; nativeImageSize(image) == size)
188             return image;
189     }
190 
191     // Fallback to the first frame image if we can&#39;t find the right size
192     return frameImageAtIndexCacheIfNeeded(0, SubsamplingLevel::Default, targetContext);
193 }
194 
195 Vector&lt;NativeImagePtr&gt; BitmapImage::framesNativeImages()
196 {
197     Vector&lt;NativeImagePtr&gt; images;
198     size_t count = frameCount();
199 
200     for (size_t i = 0; i &lt; count; ++i) {
201         if (auto image = frameImageAtIndexCacheIfNeeded(i))
202             images.append(image);
203     }
204 
205     return images;
206 }
207 #endif
208 
209 #if ASSERT_ENABLED
210 bool BitmapImage::notSolidColor()
211 {
212     return size().width() != 1 || size().height() != 1 || frameCount() &gt; 1;
213 }
214 #endif // ASSERT_ENABLED
215 
216 ImageDrawResult BitmapImage::draw(GraphicsContext&amp; context, const FloatRect&amp; destRect, const FloatRect&amp; srcRect, const ImagePaintingOptions&amp; options)
217 {
218     if (destRect.isEmpty() || srcRect.isEmpty())
219         return ImageDrawResult::DidNothing;
220 
221     FloatSize scaleFactorForDrawing = context.scaleFactorForDrawing(destRect, srcRect);
222     IntSize sizeForDrawing = expandedIntSize(size() * scaleFactorForDrawing);
223     ImageDrawResult result = ImageDrawResult::DidDraw;
224 
225     m_currentSubsamplingLevel = m_allowSubsampling ? subsamplingLevelForScaleFactor(context, scaleFactorForDrawing) : SubsamplingLevel::Default;
226     LOG(Images, &quot;BitmapImage::%s - %p - url: %s [subsamplingLevel = %d scaleFactorForDrawing = (%.4f, %.4f)]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), static_cast&lt;int&gt;(m_currentSubsamplingLevel), scaleFactorForDrawing.width(), scaleFactorForDrawing.height());
227 
228     NativeImagePtr image;
229     if (options.decodingMode() == DecodingMode::Asynchronous) {
230         ASSERT(!canAnimate());
231         ASSERT(!m_currentFrame || m_animationFinished);
232 
233         bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, DecodingOptions(sizeForDrawing));
234         bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, DecodingOptions(sizeForDrawing));
235 
236         // If the current frame is incomplete, a new request for decoding this frame has to be made even if
237         // it is currently being decoded. New data may have been received since the previous request was made.
238         if ((!frameIsCompatible &amp;&amp; !frameIsBeingDecoded) || m_currentFrameDecodingStatus == DecodingStatus::Invalid) {
239             LOG(Images, &quot;BitmapImage::%s - %p - url: %s [requesting large async decoding]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
240             m_source-&gt;requestFrameAsyncDecodingAtIndex(m_currentFrame, m_currentSubsamplingLevel, sizeForDrawing);
241             m_currentFrameDecodingStatus = DecodingStatus::Decoding;
242         }
243 
244         if (m_currentFrameDecodingStatus == DecodingStatus::Decoding)
245             result = ImageDrawResult::DidRequestDecoding;
246 
247         if (!frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, DecodingOptions(DecodingMode::Asynchronous))) {
248             if (m_showDebugBackground)
249                 fillWithSolidColor(context, destRect, Color(Color::yellow).colorWithAlpha(0.5), options.compositeOperator());
250             return result;
251         }
252 
253         image = frameImageAtIndex(m_currentFrame);
254         LOG(Images, &quot;BitmapImage::%s - %p - url: %s [a decoded frame will be used for asynchronous drawing]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
255     } else {
256         StartAnimationStatus status = internalStartAnimation();
257         ASSERT_IMPLIES(status == StartAnimationStatus::DecodingActive, (!m_currentFrame &amp;&amp; !m_repetitionsComplete) || frameHasFullSizeNativeImageAtIndex(m_currentFrame, m_currentSubsamplingLevel));
258 
259         if (status == StartAnimationStatus::DecodingActive &amp;&amp; m_showDebugBackground) {
260             fillWithSolidColor(context, destRect, Color(Color::yellow).colorWithAlpha(0.5), options.compositeOperator());
261             return result;
262         }
263 
264         // If the decodingMode changes from asynchronous to synchronous and new data is received,
265         // the current incomplete decoded frame has to be destroyed.
266         if (m_currentFrameDecodingStatus == DecodingStatus::Invalid)
267             m_source-&gt;destroyIncompleteDecodedData();
268 
269         bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, DecodingOptions(sizeForDrawing));
270         bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, DecodingOptions(DecodingMode::Asynchronous));
271 
272         if (frameIsCompatible) {
273             image = frameImageAtIndex(m_currentFrame);
274             LOG(Images, &quot;BitmapImage::%s - %p - url: %s [a decoded frame will reused for synchronous drawing]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
275         } else if (frameIsBeingDecoded) {
276             // FIXME: instead of showing the yellow rectangle and returning we need to wait for this frame to finish decoding.
277             if (m_showDebugBackground) {
278                 fillWithSolidColor(context, destRect, Color(Color::yellow).colorWithAlpha(0.5), options.compositeOperator());
279                 LOG(Images, &quot;BitmapImage::%s - %p - url: %s [waiting for async decoding to finish]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
280             }
281             return ImageDrawResult::DidRequestDecoding;
282         } else {
283             image = frameImageAtIndexCacheIfNeeded(m_currentFrame, m_currentSubsamplingLevel, &amp;context);
284             LOG(Images, &quot;BitmapImage::%s - %p - url: %s [an image frame will be decoded synchronously]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
285         }
286 
287         if (!image) // If it&#39;s too early we won&#39;t have an image yet.
288             return ImageDrawResult::DidNothing;
289 
290         if (m_currentFrameDecodingStatus != DecodingStatus::Complete)
291             ++m_decodeCountForTesting;
292     }
293 
294     ASSERT(image);
295     Color color = singlePixelSolidColor();
296     if (color.isValid()) {
297         fillWithSolidColor(context, destRect, color, options.compositeOperator());
298         return result;
299     }
300 
301     if (options.orientation() == ImageOrientation::FromImage)
302         drawNativeImage(image, context, destRect, srcRect, IntSize(size()), { options, frameOrientationAtIndex(m_currentFrame) });
303     else
304         drawNativeImage(image, context, destRect, srcRect, IntSize(size()), options);
305 
306     m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
307 
308     if (imageObserver())
309         imageObserver()-&gt;didDraw(*this);
310 
311     return result;
312 }
313 
314 void BitmapImage::drawPattern(GraphicsContext&amp; ctxt, const FloatRect&amp; destRect, const FloatRect&amp; tileRect, const AffineTransform&amp; transform, const FloatPoint&amp; phase, const FloatSize&amp; spacing, const ImagePaintingOptions&amp; options)
315 {
316     if (tileRect.isEmpty())
317         return;
318 
319     if (!ctxt.drawLuminanceMask()) {
320         // If new data is received, the current incomplete decoded frame has to be destroyed.
321         if (m_currentFrameDecodingStatus == DecodingStatus::Invalid)
322             m_source-&gt;destroyIncompleteDecodedData();
323 
324         Image::drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, { options, ImageOrientation::FromImage });
325         m_currentFrameDecodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
326         return;
327     }
328 
329     if (!m_cachedImage) {
330         auto buffer = ImageBuffer::createCompatibleBuffer(expandedIntSize(tileRect.size()), ColorSpace::SRGB, ctxt);
331         if (!buffer)
332             return;
333 
334         ImageObserver* observer = imageObserver();
335 
336         // Temporarily reset image observer, we don&#39;t want to receive any changeInRect() calls due to this relayout.
337         setImageObserver(nullptr);
338 
339         draw(buffer-&gt;context(), tileRect, tileRect, { options, DecodingMode::Synchronous, ImageOrientation::FromImage });
340 
341         setImageObserver(observer);
342         buffer-&gt;convertToLuminanceMask();
343 
344         m_cachedImage = ImageBuffer::sinkIntoImage(WTFMove(buffer), PreserveResolution::Yes);
345         if (!m_cachedImage)
346             return;
347     }
348 
349     ctxt.setDrawLuminanceMask(false);
350     m_cachedImage-&gt;drawPattern(ctxt, destRect, tileRect, transform, phase, spacing, { options, ImageOrientation::FromImage });
351 }
352 
353 bool BitmapImage::shouldAnimate() const
354 {
355     return repetitionCount() &amp;&amp; !m_animationFinished &amp;&amp; imageObserver();
356 }
357 
358 bool BitmapImage::canAnimate() const
359 {
360     return shouldAnimate() &amp;&amp; frameCount() &gt; 1;
361 }
362 
363 bool BitmapImage::canUseAsyncDecodingForLargeImages() const
364 {
365     return !canAnimate() &amp;&amp; m_source-&gt;canUseAsyncDecoding();
366 }
367 
368 bool BitmapImage::shouldUseAsyncDecodingForAnimatedImages() const
369 {
370     return canAnimate() &amp;&amp; m_allowAnimatedImageAsyncDecoding &amp;&amp; (shouldUseAsyncDecodingForTesting() || m_source-&gt;canUseAsyncDecoding());
371 }
372 
373 void BitmapImage::clearTimer()
374 {
375     m_frameTimer = nullptr;
376 }
377 
378 void BitmapImage::startTimer(Seconds delay)
379 {
380     ASSERT(!m_frameTimer);
381     m_frameTimer = makeUnique&lt;Timer&gt;(*this, &amp;BitmapImage::advanceAnimation);
382     m_frameTimer-&gt;startOneShot(delay);
383 }
384 
385 SubsamplingLevel BitmapImage::subsamplingLevelForScaleFactor(GraphicsContext&amp; context, const FloatSize&amp; scaleFactor)
386 {
387 #if USE(CG)
388     // Never use subsampled images for drawing into PDF contexts.
389     if (CGContextGetType(context.platformContext()) == kCGContextTypePDF)
390         return SubsamplingLevel::Default;
391 
392     float scale = std::min(float(1), std::max(scaleFactor.width(), scaleFactor.height()));
393     if (!(scale &gt; 0 &amp;&amp; scale &lt;= 1))
394         return SubsamplingLevel::Default;
395 
396     int result = std::ceil(std::log2(1 / scale));
397     return static_cast&lt;SubsamplingLevel&gt;(std::min(result, static_cast&lt;int&gt;(m_source-&gt;maximumSubsamplingLevel())));
398 #else
399     UNUSED_PARAM(context);
400     UNUSED_PARAM(scaleFactor);
401     return SubsamplingLevel::Default;
402 #endif
403 }
404 
405 bool BitmapImage::canDestroyDecodedData()
406 {
407     // Animated images should preserve the current frame till the next one finishes decoding.
408     if (m_source-&gt;hasAsyncDecodingQueue())
409         return false;
410 
411     // Small image should be decoded synchronously. Deleting its decoded frame is fine.
412     if (!canUseAsyncDecodingForLargeImages())
413         return true;
414 
415     return !imageObserver() || imageObserver()-&gt;canDestroyDecodedData(*this);
416 }
417 
418 BitmapImage::StartAnimationStatus BitmapImage::internalStartAnimation()
419 {
420     LOG_WITH_STREAM(Images, stream &lt;&lt; &quot;BitmapImage &quot; &lt;&lt; this &lt;&lt; &quot; internalStartAnimation&quot;);
421 
422     if (!canAnimate())
423         return StartAnimationStatus::CannotStart;
424 
425     if (m_frameTimer)
426         return StartAnimationStatus::TimerActive;
427 
428     // Don&#39;t start a new animation until we draw the frame that is currently being decoded.
429     size_t nextFrame = (m_currentFrame + 1) % frameCount();
430     if (frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(nextFrame, DecodingOptions(DecodingMode::Asynchronous))) {
431         LOG(Images, &quot;BitmapImage::%s - %p - url: %s [nextFrame = %ld is being decoded]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), nextFrame);
432         return StartAnimationStatus::DecodingActive;
433     }
434 
435     if (m_currentFrame &gt;= frameCount() - 1) {
436         // Don&#39;t advance past the last frame if we haven&#39;t decoded the whole image
437         // yet and our repetition count is potentially unset. The repetition count
438         // in a GIF can potentially come after all the rest of the image data, so
439         // wait on it.
440         if (!m_source-&gt;isAllDataReceived() &amp;&amp; repetitionCount() == RepetitionCountOnce)
441             return StartAnimationStatus::IncompleteData;
442 
443         ++m_repetitionsComplete;
444 
445         // Check for the end of animation.
446         if (repetitionCount() != RepetitionCountInfinite &amp;&amp; m_repetitionsComplete &gt;= repetitionCount()) {
447             m_animationFinished = true;
448             destroyDecodedDataIfNecessary(false);
449             return StartAnimationStatus::CannotStart;
450         }
451 
452         destroyDecodedDataIfNecessary(true);
453     }
454 
455     // Don&#39;t advance the animation to an incomplete frame.
456     if (!m_source-&gt;isAllDataReceived() &amp;&amp; !frameIsCompleteAtIndex(nextFrame))
457         return StartAnimationStatus::IncompleteData;
458 
459     MonotonicTime time = MonotonicTime::now();
460 
461     // Handle initial state.
462     if (!m_desiredFrameStartTime)
463         m_desiredFrameStartTime = time;
464 
465     // Setting &#39;m_desiredFrameStartTime&#39; to &#39;time&#39; means we are late; otherwise we are early.
466     m_desiredFrameStartTime = std::max(time, m_desiredFrameStartTime + Seconds { frameDurationAtIndex(m_currentFrame) });
467 
468     // Request async decoding for nextFrame only if this is required. If nextFrame is not in the frameCache,
469     // it will be decoded on a separate work queue. When decoding nextFrame finishes, we will be notified
470     // through the callback newFrameNativeImageAvailableAtIndex(). Otherwise, advanceAnimation() will be called
471     // when the timer fires and m_currentFrame will be advanced to nextFrame since it is not being decoded.
472     if (shouldUseAsyncDecodingForAnimatedImages()) {
473         if (frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(nextFrame, m_currentSubsamplingLevel, DecodingOptions(Optional&lt;IntSize&gt;())))
474             LOG(Images, &quot;BitmapImage::%s - %p - url: %s [cachedFrameCount = %ld nextFrame = %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), ++m_cachedFrameCount, nextFrame);
475         else {
476             m_source-&gt;requestFrameAsyncDecodingAtIndex(nextFrame, m_currentSubsamplingLevel);
477             m_currentFrameDecodingStatus = DecodingStatus::Decoding;
478             LOG(Images, &quot;BitmapImage::%s - %p - url: %s [requesting async decoding for nextFrame = %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), nextFrame);
479         }
480 
481         if (m_clearDecoderAfterAsyncFrameRequestForTesting)
482             m_source-&gt;resetData(data());
483     }
484 
485     ASSERT(!m_frameTimer);
486     startTimer(m_desiredFrameStartTime - time);
487     return StartAnimationStatus::Started;
488 }
489 
490 void BitmapImage::advanceAnimation()
491 {
492     clearTimer();
493 
494     // Don&#39;t advance to nextFrame unless its decoding has finished or was not required.
495     size_t nextFrame = (m_currentFrame + 1) % frameCount();
496     if (!frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(nextFrame, DecodingOptions(DecodingMode::Asynchronous)))
497         internalAdvanceAnimation();
498     else {
499         // Force repaint if showDebugBackground() is on.
500         if (m_showDebugBackground)
501             imageObserver()-&gt;changedInRect(*this);
502         LOG(Images, &quot;BitmapImage::%s - %p - url: %s [lateFrameCount = %ld nextFrame = %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), ++m_lateFrameCount, nextFrame);
503     }
504 }
505 
506 void BitmapImage::internalAdvanceAnimation()
507 {
508     m_currentFrame = (m_currentFrame + 1) % frameCount();
509     ASSERT(!frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, DecodingOptions(DecodingMode::Asynchronous)));
510 
511     destroyDecodedDataIfNecessary(false);
512 
513     DecodingStatus decodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
514     setCurrentFrameDecodingStatusIfNecessary(decodingStatus);
515 
516     callDecodingCallbacks();
517 
518     if (imageObserver())
519         imageObserver()-&gt;imageFrameAvailable(*this, ImageAnimatingState::Yes, nullptr, decodingStatus);
520 
521     LOG(Images, &quot;BitmapImage::%s - %p - url: %s [m_currentFrame = %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), m_currentFrame);
522 }
523 
524 bool BitmapImage::isAnimating() const
525 {
526     return !!m_frameTimer;
527 }
528 
529 void BitmapImage::stopAnimation()
530 {
531     // This timer is used to animate all occurrences of this image. Don&#39;t invalidate
532     // the timer unless all renderers have stopped drawing.
533     clearTimer();
534     if (canAnimate())
535         m_source-&gt;stopAsyncDecodingQueue();
536 }
537 
538 void BitmapImage::resetAnimation()
539 {
540     stopAnimation();
541     m_currentFrame = 0;
542     m_repetitionsComplete = RepetitionCountNone;
543     m_desiredFrameStartTime = { };
544     m_animationFinished = false;
545 
546     // For extremely large animations, when the animation is reset, we just throw everything away.
547     destroyDecodedDataIfNecessary(true);
548 }
549 
550 void BitmapImage::decode(WTF::Function&lt;void()&gt;&amp;&amp; callback)
551 {
552     if (!m_decodingCallbacks)
553         m_decodingCallbacks = makeUnique&lt;Vector&lt;Function&lt;void()&gt;, 1&gt;&gt;();
554 
555     m_decodingCallbacks-&gt;append(WTFMove(callback));
556 
557     if (canAnimate())  {
558         if (m_desiredFrameStartTime) {
559             internalStartAnimation();
560             return;
561         }
562 
563         // The animated image has not been displayed. In this case, either the first frame has not been decoded yet or the animation has not started yet.
564         bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, Optional&lt;IntSize&gt;());
565         bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, Optional&lt;IntSize&gt;());
566 
567         if (frameIsCompatible)
568             internalStartAnimation();
569         else if (!frameIsBeingDecoded) {
570             m_source-&gt;requestFrameAsyncDecodingAtIndex(m_currentFrame, m_currentSubsamplingLevel, Optional&lt;IntSize&gt;());
571             m_currentFrameDecodingStatus = DecodingStatus::Decoding;
572         }
573         return;
574     }
575 
576     bool frameIsCompatible = frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, Optional&lt;IntSize&gt;());
577     bool frameIsBeingDecoded = frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(m_currentFrame, Optional&lt;IntSize&gt;());
578 
579     if (frameIsCompatible)
580         callDecodingCallbacks();
581     else if (!frameIsBeingDecoded) {
582         m_source-&gt;requestFrameAsyncDecodingAtIndex(m_currentFrame, m_currentSubsamplingLevel, Optional&lt;IntSize&gt;());
583         m_currentFrameDecodingStatus = DecodingStatus::Decoding;
584     }
585 }
586 
587 void BitmapImage::callDecodingCallbacks()
588 {
589     if (!m_decodingCallbacks)
590         return;
591     for (auto&amp; decodingCallback : *m_decodingCallbacks)
592         decodingCallback();
593     m_decodingCallbacks = nullptr;
594 }
595 
596 void BitmapImage::imageFrameAvailableAtIndex(size_t index)
597 {
598     LOG(Images, &quot;BitmapImage::%s - %p - url: %s [requested frame %ld is now available]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), index);
599 
600     if (canAnimate()) {
601         if (index == (m_currentFrame + 1) % frameCount()) {
602             // Don&#39;t advance to nextFrame unless the timer was fired before its decoding finishes.
603             if (!m_frameTimer)
604                 internalAdvanceAnimation();
605             else
606                 LOG(Images, &quot;BitmapImage::%s - %p - url: %s [earlyFrameCount = %ld nextFrame = %ld]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), ++m_earlyFrameCount, index);
607             return;
608         }
609 
610         // Because of image partial loading, an image may start decoding as a large static image. But
611         // when more data is received, frameCount() changes to be &gt; 1 so the image starts animating.
612         // The animation may even start before finishing the decoding of the first frame.
613         ASSERT(!m_repetitionsComplete);
614         LOG(Images, &quot;BitmapImage::%s - %p - url: %s [More data makes frameCount() &gt; 1]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data());
615     }
616 
617     ASSERT(index == m_currentFrame &amp;&amp; !m_currentFrame);
618     if (m_source-&gt;isAsyncDecodingQueueIdle())
619         m_source-&gt;stopAsyncDecodingQueue();
620 
621     DecodingStatus decodingStatus = frameDecodingStatusAtIndex(m_currentFrame);
622     setCurrentFrameDecodingStatusIfNecessary(decodingStatus);
623 
624     if (m_currentFrameDecodingStatus == DecodingStatus::Complete)
625         ++m_decodeCountForTesting;
626 
627     // Call m_decodingCallbacks only if the image frame was decoded with the native size.
628     if (frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(m_currentFrame, m_currentSubsamplingLevel, Optional&lt;IntSize&gt;()))
629         callDecodingCallbacks();
630 
631     if (imageObserver())
632         imageObserver()-&gt;imageFrameAvailable(*this, ImageAnimatingState::No, nullptr, decodingStatus);
633 }
634 
635 unsigned BitmapImage::decodeCountForTesting() const
636 {
637     return m_decodeCountForTesting;
638 }
639 
640 void BitmapImage::dump(TextStream&amp; ts) const
641 {
642     Image::dump(ts);
643 
644     if (isAnimated())
645         ts.dumpProperty(&quot;current-frame&quot;, m_currentFrame);
646 
647     m_source-&gt;dump(ts);
648 }
649 
650 }
    </pre>
  </body>
</html>
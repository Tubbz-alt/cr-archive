<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSCallbackObjectFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCallbackObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSCallbackObjectFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 


 27 #include &quot;APICast.h&quot;
 28 #include &quot;Error.h&quot;
 29 #include &quot;ExceptionHelpers.h&quot;
 30 #include &quot;JSCallbackFunction.h&quot;
 31 #include &quot;JSClassRef.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGlobalObject.h&quot;
 34 #include &quot;JSLock.h&quot;
 35 #include &quot;JSObjectRef.h&quot;
 36 #include &quot;JSString.h&quot;
 37 #include &quot;OpaqueJSString.h&quot;
 38 #include &quot;PropertyNameArray.h&quot;
 39 #include &lt;wtf/Vector.h&gt;
 40 
 41 namespace JSC {
 42 
 43 template &lt;class Parent&gt;
 44 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(JSValue value)
 45 {
 46     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 47     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 48 }
 49 
 50 template &lt;class Parent&gt;
 51 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(EncodedJSValue encodedValue)
 52 {
 53     JSValue value = JSValue::decode(encodedValue);
 54     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 55     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 56 }
 57 
 58 template &lt;class Parent&gt;
<span class="line-modified"> 59 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(ExecState* exec, Structure* structure, JSClassRef jsClass, void* data)</span>
<span class="line-modified"> 60     : Parent(exec-&gt;vm(), structure)</span>
 61     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(data, jsClass))
 62 {
 63 }
 64 
 65 // Global object constructor.
 66 // FIXME: Move this into a separate JSGlobalCallbackObject class derived from this one.
 67 template &lt;class Parent&gt;
 68 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(VM&amp; vm, JSClassRef jsClass, Structure* structure)
 69     : Parent(vm, structure)
 70     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(nullptr, jsClass))
 71 {
 72 }
 73 
 74 template &lt;class Parent&gt;
 75 JSCallbackObject&lt;Parent&gt;::~JSCallbackObject()
 76 {
 77     VM&amp; vm = this-&gt;HeapCell::vm();
 78     vm.currentlyDestructingCallbackObject = this;
 79     ASSERT(m_classInfo);
 80     vm.currentlyDestructingCallbackObjectClassInfo = m_classInfo;
 81     JSObjectRef thisRef = toRef(static_cast&lt;JSObject*&gt;(this));
 82     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
 83         if (JSObjectFinalizeCallback finalize = jsClass-&gt;finalize)
 84             finalize(thisRef);
 85     }
 86     vm.currentlyDestructingCallbackObject = nullptr;
 87     vm.currentlyDestructingCallbackObjectClassInfo = nullptr;
 88 }
 89 
 90 template &lt;class Parent&gt;
<span class="line-modified"> 91 void JSCallbackObject&lt;Parent&gt;::finishCreation(ExecState* exec)</span>
 92 {
<span class="line-modified"> 93     VM&amp; vm = exec-&gt;vm();</span>
 94     Base::finishCreation(vm);
 95     ASSERT(Parent::inherits(vm, info()));
<span class="line-modified"> 96     init(exec);</span>
 97 }
 98 
 99 // This is just for Global object, so we can assume that Base::finishCreation is JSGlobalObject::finishCreation.
100 template &lt;class Parent&gt;
101 void JSCallbackObject&lt;Parent&gt;::finishCreation(VM&amp; vm)
102 {
103     ASSERT(Parent::inherits(vm, info()));
104     ASSERT(Parent::isGlobalObject());
105     Base::finishCreation(vm);
<span class="line-modified">106     init(jsCast&lt;JSGlobalObject*&gt;(this)-&gt;globalExec());</span>
107 }
108 
109 template &lt;class Parent&gt;
<span class="line-modified">110 void JSCallbackObject&lt;Parent&gt;::init(ExecState* exec)</span>
111 {
<span class="line-modified">112     ASSERT(exec);</span>
113 
114     Vector&lt;JSObjectInitializeCallback, 16&gt; initRoutines;
115     JSClassRef jsClass = classRef();
116     do {
117         if (JSObjectInitializeCallback initialize = jsClass-&gt;initialize)
118             initRoutines.append(initialize);
119     } while ((jsClass = jsClass-&gt;parentClass));
120 
121     // initialize from base to derived
122     for (int i = static_cast&lt;int&gt;(initRoutines.size()) - 1; i &gt;= 0; i--) {
<span class="line-modified">123         JSLock::DropAllLocks dropAllLocks(exec);</span>
124         JSObjectInitializeCallback initialize = initRoutines[i];
<span class="line-modified">125         initialize(toRef(exec), toRef(this));</span>
126     }
127 
<span class="line-modified">128     m_classInfo = this-&gt;classInfo();</span>
129 }
130 
131 template &lt;class Parent&gt;
132 String JSCallbackObject&lt;Parent&gt;::className(const JSObject* object, VM&amp; vm)
133 {
134     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
135     String thisClassName = thisObject-&gt;classRef()-&gt;className();
136     if (!thisClassName.isEmpty())
137         return thisClassName;
138 
139     return Parent::className(object, vm);
140 }
141 
142 template &lt;class Parent&gt;
<span class="line-modified">143 String JSCallbackObject&lt;Parent&gt;::toStringName(const JSObject* object, ExecState* exec)</span>
144 {
<span class="line-modified">145     VM&amp; vm = exec-&gt;vm();</span>
146     const ClassInfo* info = object-&gt;classInfo(vm);
147     ASSERT(info);
148     return info-&gt;methodTable.className(object, vm);
149 }
150 
151 template &lt;class Parent&gt;
<span class="line-modified">152 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
153 {
<span class="line-modified">154     VM&amp; vm = exec-&gt;vm();</span>
155     auto scope = DECLARE_THROW_SCOPE(vm);
156 
157     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">158     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">159     JSObjectRef thisRef = toRef(thisObject);</span>
160     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
161 
162     if (StringImpl* name = propertyName.uid()) {
163         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
164             // optional optimization to bypass getProperty in cases when we only need to know if the property exists
165             if (JSObjectHasPropertyCallback hasProperty = jsClass-&gt;hasProperty) {
166                 if (!propertyNameRef)
167                     propertyNameRef = OpaqueJSString::tryCreate(name);
<span class="line-modified">168                 JSLock::DropAllLocks dropAllLocks(exec);</span>
169                 if (hasProperty(ctx, thisRef, propertyNameRef.get())) {
170                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, callbackGetter);
171                     return true;
172                 }
173             } else if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
174                 if (!propertyNameRef)
175                     propertyNameRef = OpaqueJSString::tryCreate(name);
176                 JSValueRef exception = 0;
177                 JSValueRef value;
178                 {
<span class="line-modified">179                     JSLock::DropAllLocks dropAllLocks(exec);</span>
180                     value = getProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
181                 }
182                 if (exception) {
<span class="line-modified">183                     throwException(exec, scope, toJS(exec, exception));</span>
184                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, jsUndefined());
185                     return true;
186                 }
187                 if (value) {
<span class="line-modified">188                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, toJS(exec, value));</span>
189                     return true;
190                 }
191             }
192 
<span class="line-modified">193             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
194                 if (staticValues-&gt;contains(name)) {
<span class="line-modified">195                     JSValue value = thisObject-&gt;getStaticValue(exec, propertyName);</span>
196                     if (value) {
197                         slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, value);
198                         return true;
199                     }
200                 }
201             }
202 
<span class="line-modified">203             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
204                 if (staticFunctions-&gt;contains(name)) {
205                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, staticFunctionGetter);
206                     return true;
207                 }
208             }
209         }
210     }
211 
<span class="line-modified">212     return Parent::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
213 }
214 
215 template &lt;class Parent&gt;
<span class="line-modified">216 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
217 {
<span class="line-modified">218     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">219     return object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, exec, Identifier::from(vm, propertyName), slot);</span>
220 }
221 
222 template &lt;class Parent&gt;
<span class="line-modified">223 JSValue JSCallbackObject&lt;Parent&gt;::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)</span>
224 {
<span class="line-modified">225     VM&amp; vm = exec-&gt;vm();</span>
226     auto scope = DECLARE_THROW_SCOPE(vm);
227 
228     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
<span class="line-modified">229     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">230     JSObjectRef thisRef = toRef(thisObject);</span>
231     ::JSType jsHint = hint == PreferString ? kJSTypeString : kJSTypeNumber;
232 
233     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
234         if (JSObjectConvertToTypeCallback convertToType = jsClass-&gt;convertToType) {
235             JSValueRef exception = 0;
236             JSValueRef result = convertToType(ctx, thisRef, jsHint, &amp;exception);
237             if (exception) {
<span class="line-modified">238                 throwException(exec, scope, toJS(exec, exception));</span>
239                 return jsUndefined();
240             }
241             if (result)
<span class="line-modified">242                 return toJS(exec, result);</span>
243         }
244     }
245 
<span class="line-modified">246     return Parent::defaultValue(object, exec, hint);</span>
247 }
248 
249 template &lt;class Parent&gt;
<span class="line-modified">250 bool JSCallbackObject&lt;Parent&gt;::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
251 {
<span class="line-modified">252     VM&amp; vm = exec-&gt;vm();</span>
253     auto scope = DECLARE_THROW_SCOPE(vm);
254 
255     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">256     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">257     JSObjectRef thisRef = toRef(thisObject);</span>
258     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">259     JSValueRef valueRef = toRef(exec, value);</span>
260 
261     if (StringImpl* name = propertyName.uid()) {
262         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
263             if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
264                 if (!propertyNameRef)
265                     propertyNameRef = OpaqueJSString::tryCreate(name);
266                 JSValueRef exception = 0;
267                 bool result;
268                 {
<span class="line-modified">269                     JSLock::DropAllLocks dropAllLocks(exec);</span>
270                     result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
271                 }
272                 if (exception)
<span class="line-modified">273                     throwException(exec, scope, toJS(exec, exception));</span>
274                 if (result || exception)
275                     return result;
276             }
277 
<span class="line-modified">278             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
279                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
280                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
281                         return false;
282                     if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
283                         JSValueRef exception = 0;
284                         bool result;
285                         {
<span class="line-modified">286                             JSLock::DropAllLocks dropAllLocks(exec);</span>
287                             result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
288                         }
289                         if (exception)
<span class="line-modified">290                             throwException(exec, scope, toJS(exec, exception));</span>
291                         if (result || exception)
292                             return result;
293                     }
294                 }
295             }
296 
<span class="line-modified">297             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
298                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
299                     PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">300                     if (Parent::getOwnPropertySlot(thisObject, exec, propertyName, getSlot))</span>
<span class="line-modified">301                         return Parent::put(thisObject, exec, propertyName, value, slot);</span>
302                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
303                         return false;
304                     return thisObject-&gt;JSCallbackObject&lt;Parent&gt;::putDirect(vm, propertyName, value); // put as override property
305                 }
306             }
307         }
308     }
309 
<span class="line-modified">310     return Parent::put(thisObject, exec, propertyName, value, slot);</span>
311 }
312 
313 template &lt;class Parent&gt;
<span class="line-modified">314 bool JSCallbackObject&lt;Parent&gt;::putByIndex(JSCell* cell, ExecState* exec, unsigned propertyIndex, JSValue value, bool shouldThrow)</span>
315 {
<span class="line-modified">316     VM&amp; vm = exec-&gt;vm();</span>
317     auto scope = DECLARE_THROW_SCOPE(vm);
318 
319     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">320     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">321     JSObjectRef thisRef = toRef(thisObject);</span>
322     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">323     JSValueRef valueRef = toRef(exec, value);</span>
324     Identifier propertyName = Identifier::from(vm, propertyIndex);
325 
326     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
327         if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
328             if (!propertyNameRef)
329                 propertyNameRef = OpaqueJSString::tryCreate(propertyName.impl());
330             JSValueRef exception = 0;
331             bool result;
332             {
<span class="line-modified">333                 JSLock::DropAllLocks dropAllLocks(exec);</span>
334                 result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
335             }
336             if (exception)
<span class="line-modified">337                 throwException(exec, scope, toJS(exec, exception));</span>
338             if (result || exception)
339                 return result;
340         }
341 
<span class="line-modified">342         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
343             if (StaticValueEntry* entry = staticValues-&gt;get(propertyName.impl())) {
344                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
345                     return false;
346                 if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
347                     JSValueRef exception = 0;
348                     bool result;
349                     {
<span class="line-modified">350                         JSLock::DropAllLocks dropAllLocks(exec);</span>
351                         result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
352                     }
353                     if (exception)
<span class="line-modified">354                         throwException(exec, scope, toJS(exec, exception));</span>
355                     if (result || exception)
356                         return result;
357                 }
358             }
359         }
360 
<span class="line-modified">361         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
362             if (StaticFunctionEntry* entry = staticFunctions-&gt;get(propertyName.impl())) {
363                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
364                     return false;
365                 break;
366             }
367         }
368     }
369 
<span class="line-modified">370     return Parent::putByIndex(thisObject, exec, propertyIndex, value, shouldThrow);</span>
371 }
372 
373 template &lt;class Parent&gt;
<span class="line-modified">374 bool JSCallbackObject&lt;Parent&gt;::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
375 {
<span class="line-modified">376     VM&amp; vm = exec-&gt;vm();</span>
377     auto scope = DECLARE_THROW_SCOPE(vm);
378 
379     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">380     JSContextRef ctx = toRef(exec);</span>
<span class="line-modified">381     JSObjectRef thisRef = toRef(thisObject);</span>
382     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
383 
384     if (StringImpl* name = propertyName.uid()) {
385         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
386             if (JSObjectDeletePropertyCallback deleteProperty = jsClass-&gt;deleteProperty) {
387                 if (!propertyNameRef)
388                     propertyNameRef = OpaqueJSString::tryCreate(name);
389                 JSValueRef exception = 0;
390                 bool result;
391                 {
<span class="line-modified">392                     JSLock::DropAllLocks dropAllLocks(exec);</span>
393                     result = deleteProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
394                 }
395                 if (exception)
<span class="line-modified">396                     throwException(exec, scope, toJS(exec, exception));</span>
397                 if (result || exception)
398                     return true;
399             }
400 
<span class="line-modified">401             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
402                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
403                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
404                         return false;
405                     return true;
406                 }
407             }
408 
<span class="line-modified">409             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
410                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
411                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
412                         return false;
413                     return true;
414                 }
415             }
416         }
417     }
418 
<span class="line-modified">419     return Parent::deleteProperty(thisObject, exec, propertyName);</span>
420 }
421 
422 template &lt;class Parent&gt;
<span class="line-modified">423 bool JSCallbackObject&lt;Parent&gt;::deletePropertyByIndex(JSCell* cell, ExecState* exec, unsigned propertyName)</span>
424 {
<span class="line-modified">425     VM&amp; vm = exec-&gt;vm();</span>
426     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">427     return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, exec, Identifier::from(vm, propertyName));</span>
428 }
429 
430 template &lt;class Parent&gt;
431 ConstructType JSCallbackObject&lt;Parent&gt;::getConstructData(JSCell* cell, ConstructData&amp; constructData)
432 {
433     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
434     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
435         if (jsClass-&gt;callAsConstructor) {
436             constructData.native.function = construct;
437             return ConstructType::Host;
438         }
439     }
440     return ConstructType::None;
441 }
442 
443 template &lt;class Parent&gt;
<span class="line-modified">444 EncodedJSValue JSCallbackObject&lt;Parent&gt;::construct(ExecState* exec)</span>
445 {
<span class="line-modified">446     VM&amp; vm = exec-&gt;vm();</span>
447     auto scope = DECLARE_THROW_SCOPE(vm);
448 
<span class="line-modified">449     JSObject* constructor = exec-&gt;jsCallee();</span>
<span class="line-modified">450     JSContextRef execRef = toRef(exec);</span>
451     JSObjectRef constructorRef = toRef(constructor);
452 
453     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(constructor)-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
454         if (JSObjectCallAsConstructorCallback callAsConstructor = jsClass-&gt;callAsConstructor) {
<span class="line-modified">455             size_t argumentCount = exec-&gt;argumentCount();</span>
456             Vector&lt;JSValueRef, 16&gt; arguments;
457             arguments.reserveInitialCapacity(argumentCount);
458             for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">459                 arguments.uncheckedAppend(toRef(exec, exec-&gt;uncheckedArgument(i)));</span>
460             JSValueRef exception = 0;
461             JSObject* result;
462             {
<span class="line-modified">463                 JSLock::DropAllLocks dropAllLocks(exec);</span>
464                 result = toJS(callAsConstructor(execRef, constructorRef, argumentCount, arguments.data(), &amp;exception));
465             }
466             if (exception)
<span class="line-modified">467                 throwException(exec, scope, toJS(exec, exception));</span>
468             return JSValue::encode(result);
469         }
470     }
471 
472     RELEASE_ASSERT_NOT_REACHED(); // getConstructData should prevent us from reaching here
473     return JSValue::encode(JSValue());
474 }
475 
476 template &lt;class Parent&gt;
<span class="line-modified">477 bool JSCallbackObject&lt;Parent&gt;::customHasInstance(JSObject* object, ExecState* exec, JSValue value)</span>
478 {
<span class="line-modified">479     VM&amp; vm = exec-&gt;vm();</span>
480     auto scope = DECLARE_THROW_SCOPE(vm);
481 
482     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">483     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">484     JSObjectRef thisRef = toRef(thisObject);</span>
485 
486     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
487         if (JSObjectHasInstanceCallback hasInstance = jsClass-&gt;hasInstance) {
<span class="line-modified">488             JSValueRef valueRef = toRef(exec, value);</span>
489             JSValueRef exception = 0;
490             bool result;
491             {
<span class="line-modified">492                 JSLock::DropAllLocks dropAllLocks(exec);</span>
493                 result = hasInstance(execRef, thisRef, valueRef, &amp;exception);
494             }
495             if (exception)
<span class="line-modified">496                 throwException(exec, scope, toJS(exec, exception));</span>
497             return result;
498         }
499     }
500     return false;
501 }
502 
503 template &lt;class Parent&gt;
504 CallType JSCallbackObject&lt;Parent&gt;::getCallData(JSCell* cell, CallData&amp; callData)
505 {
506     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
507     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
508         if (jsClass-&gt;callAsFunction) {
509             callData.native.function = call;
510             return CallType::Host;
511         }
512     }
513     return CallType::None;
514 }
515 
516 template &lt;class Parent&gt;
<span class="line-modified">517 EncodedJSValue JSCallbackObject&lt;Parent&gt;::call(ExecState* exec)</span>
518 {
<span class="line-modified">519     VM&amp; vm = exec-&gt;vm();</span>
520     auto scope = DECLARE_THROW_SCOPE(vm);
521 
<span class="line-modified">522     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">523     JSObjectRef functionRef = toRef(exec-&gt;jsCallee());</span>
<span class="line-modified">524     JSObjectRef thisObjRef = toRef(jsCast&lt;JSObject*&gt;(exec-&gt;thisValue().toThis(exec, NotStrictMode)));</span>
525 
526     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(toJS(functionRef))-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
527         if (JSObjectCallAsFunctionCallback callAsFunction = jsClass-&gt;callAsFunction) {
<span class="line-modified">528             size_t argumentCount = exec-&gt;argumentCount();</span>
529             Vector&lt;JSValueRef, 16&gt; arguments;
530             arguments.reserveInitialCapacity(argumentCount);
531             for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">532                 arguments.uncheckedAppend(toRef(exec, exec-&gt;uncheckedArgument(i)));</span>
533             JSValueRef exception = 0;
534             JSValue result;
535             {
<span class="line-modified">536                 JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">537                 result = toJS(exec, callAsFunction(execRef, functionRef, thisObjRef, argumentCount, arguments.data(), &amp;exception));</span>
538             }
539             if (exception)
<span class="line-modified">540                 throwException(exec, scope, toJS(exec, exception));</span>
541             return JSValue::encode(result);
542         }
543     }
544 
545     RELEASE_ASSERT_NOT_REACHED(); // getCallData should prevent us from reaching here
546     return JSValue::encode(JSValue());
547 }
548 
549 template &lt;class Parent&gt;
<span class="line-modified">550 void JSCallbackObject&lt;Parent&gt;::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
551 {
<span class="line-modified">552     VM&amp; vm = exec-&gt;vm();</span>
553     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">554     JSContextRef execRef = toRef(exec);</span>
<span class="line-modified">555     JSObjectRef thisRef = toRef(thisObject);</span>
556 
557     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
558         if (JSObjectGetPropertyNamesCallback getPropertyNames = jsClass-&gt;getPropertyNames) {
<span class="line-modified">559             JSLock::DropAllLocks dropAllLocks(exec);</span>
560             getPropertyNames(execRef, thisRef, toRef(&amp;propertyNames));
561         }
562 
<span class="line-modified">563         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
564             typedef OpaqueJSClassStaticValuesTable::const_iterator iterator;
565             iterator end = staticValues-&gt;end();
566             for (iterator it = staticValues-&gt;begin(); it != end; ++it) {
567                 StringImpl* name = it-&gt;key.get();
568                 StaticValueEntry* entry = it-&gt;value.get();
569                 if (entry-&gt;getProperty &amp;&amp; (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties())) {
570                     ASSERT(!name-&gt;isSymbol());
571                     propertyNames.add(Identifier::fromString(vm, String(name)));
572                 }
573             }
574         }
575 
<span class="line-modified">576         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
577             typedef OpaqueJSClassStaticFunctionsTable::const_iterator iterator;
578             iterator end = staticFunctions-&gt;end();
579             for (iterator it = staticFunctions-&gt;begin(); it != end; ++it) {
580                 StringImpl* name = it-&gt;key.get();
581                 StaticFunctionEntry* entry = it-&gt;value.get();
582                 if (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties()) {
583                     ASSERT(!name-&gt;isSymbol());
584                     propertyNames.add(Identifier::fromString(vm, String(name)));
585                 }
586             }
587         }
588     }
589 
<span class="line-modified">590     Parent::getOwnNonIndexPropertyNames(thisObject, exec, propertyNames, mode);</span>
591 }
592 
593 template &lt;class Parent&gt;
594 void JSCallbackObject&lt;Parent&gt;::setPrivate(void* data)
595 {
596     m_callbackObjectData-&gt;privateData = data;
597 }
598 
599 template &lt;class Parent&gt;
600 void* JSCallbackObject&lt;Parent&gt;::getPrivate()
601 {
602     return m_callbackObjectData-&gt;privateData;
603 }
604 
605 template &lt;class Parent&gt;
606 bool JSCallbackObject&lt;Parent&gt;::inherits(JSClassRef c) const
607 {
608     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
609         if (jsClass == c)
610             return true;
611     }
612     return false;
613 }
614 
615 template &lt;class Parent&gt;
<span class="line-modified">616 JSValue JSCallbackObject&lt;Parent&gt;::getStaticValue(ExecState* exec, PropertyName propertyName)</span>
617 {
<span class="line-modified">618     VM&amp; vm = exec-&gt;vm();</span>
619     auto scope = DECLARE_THROW_SCOPE(vm);
620 
<span class="line-modified">621     JSObjectRef thisRef = toRef(this);</span>
622 
623     if (StringImpl* name = propertyName.uid()) {
624         for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">625             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(exec)) {</span>
626                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
627                     if (JSObjectGetPropertyCallback getProperty = entry-&gt;getProperty) {
628                         JSValueRef exception = 0;
629                         JSValueRef value;
630                         {
<span class="line-modified">631                             JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">632                             value = getProperty(toRef(exec), thisRef, entry-&gt;propertyNameRef.get(), &amp;exception);</span>
633                         }
634                         if (exception) {
<span class="line-modified">635                             throwException(exec, scope, toJS(exec, exception));</span>
636                             return jsUndefined();
637                         }
638                         if (value)
<span class="line-modified">639                             return toJS(exec, value);</span>
640                     }
641                 }
642             }
643         }
644     }
645 
646     return JSValue();
647 }
648 
649 template &lt;class Parent&gt;
<span class="line-modified">650 EncodedJSValue JSCallbackObject&lt;Parent&gt;::staticFunctionGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
651 {
<span class="line-modified">652     VM&amp; vm = exec-&gt;vm();</span>
653     auto scope = DECLARE_THROW_SCOPE(vm);
654 
655     JSCallbackObject* thisObj = asCallbackObject(thisValue);
656 
657     // Check for cached or override property.
658     PropertySlot slot2(thisObj, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">659     if (Parent::getOwnPropertySlot(thisObj, exec, propertyName, slot2))</span>
<span class="line-modified">660         return JSValue::encode(slot2.getValue(exec, propertyName));</span>
661 
662     if (StringImpl* name = propertyName.uid()) {
663         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">664             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(exec)) {</span>
665                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
666                     if (JSObjectCallAsFunctionCallback callAsFunction = entry-&gt;callAsFunction) {
667                         JSObject* o = JSCallbackFunction::create(vm, thisObj-&gt;globalObject(vm), callAsFunction, name);
668                         thisObj-&gt;putDirect(vm, propertyName, o, entry-&gt;attributes);
669                         return JSValue::encode(o);
670                     }
671                 }
672             }
673         }
674     }
675 
<span class="line-modified">676     return JSValue::encode(throwException(exec, scope, createReferenceError(exec, &quot;Static function property defined with NULL callAsFunction callback.&quot;_s)));</span>
677 }
678 
679 template &lt;class Parent&gt;
<span class="line-modified">680 EncodedJSValue JSCallbackObject&lt;Parent&gt;::callbackGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
681 {
<span class="line-modified">682     VM&amp; vm = exec-&gt;vm();</span>
683     auto scope = DECLARE_THROW_SCOPE(vm);
684 
685     JSCallbackObject* thisObj = asCallbackObject(thisValue);
686 
<span class="line-modified">687     JSObjectRef thisRef = toRef(thisObj);</span>
688     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
689 
690     if (StringImpl* name = propertyName.uid()) {
691         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
692             if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
693                 if (!propertyNameRef)
694                     propertyNameRef = OpaqueJSString::tryCreate(name);
695                 JSValueRef exception = 0;
696                 JSValueRef value;
697                 {
<span class="line-modified">698                     JSLock::DropAllLocks dropAllLocks(exec);</span>
<span class="line-modified">699                     value = getProperty(toRef(exec), thisRef, propertyNameRef.get(), &amp;exception);</span>
700                 }
701                 if (exception) {
<span class="line-modified">702                     throwException(exec, scope, toJS(exec, exception));</span>
703                     return JSValue::encode(jsUndefined());
704                 }
705                 if (value)
<span class="line-modified">706                     return JSValue::encode(toJS(exec, value));</span>
707             }
708         }
709     }
710 
<span class="line-modified">711     return JSValue::encode(throwException(exec, scope, createReferenceError(exec, &quot;hasProperty callback returned true for a property that doesn&#39;t exist.&quot;_s)));</span>
712 }
713 
714 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
<span class="line-added"> 27 #pragma once</span>
<span class="line-added"> 28 </span>
 29 #include &quot;APICast.h&quot;
 30 #include &quot;Error.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;JSCallbackFunction.h&quot;
 33 #include &quot;JSClassRef.h&quot;
 34 #include &quot;JSFunction.h&quot;
 35 #include &quot;JSGlobalObject.h&quot;
 36 #include &quot;JSLock.h&quot;
 37 #include &quot;JSObjectRef.h&quot;
 38 #include &quot;JSString.h&quot;
 39 #include &quot;OpaqueJSString.h&quot;
 40 #include &quot;PropertyNameArray.h&quot;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 namespace JSC {
 44 
 45 template &lt;class Parent&gt;
 46 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(JSValue value)
 47 {
 48     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 49     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 50 }
 51 
 52 template &lt;class Parent&gt;
 53 inline JSCallbackObject&lt;Parent&gt;* JSCallbackObject&lt;Parent&gt;::asCallbackObject(EncodedJSValue encodedValue)
 54 {
 55     JSValue value = JSValue::decode(encodedValue);
 56     ASSERT(asObject(value)-&gt;inherits(value.getObject()-&gt;vm(), info()));
 57     return jsCast&lt;JSCallbackObject*&gt;(asObject(value));
 58 }
 59 
 60 template &lt;class Parent&gt;
<span class="line-modified"> 61 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(JSGlobalObject* globalObject, Structure* structure, JSClassRef jsClass, void* data)</span>
<span class="line-modified"> 62     : Parent(getVM(globalObject), structure)</span>
 63     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(data, jsClass))
 64 {
 65 }
 66 
 67 // Global object constructor.
 68 // FIXME: Move this into a separate JSGlobalCallbackObject class derived from this one.
 69 template &lt;class Parent&gt;
 70 JSCallbackObject&lt;Parent&gt;::JSCallbackObject(VM&amp; vm, JSClassRef jsClass, Structure* structure)
 71     : Parent(vm, structure)
 72     , m_callbackObjectData(makeUnique&lt;JSCallbackObjectData&gt;(nullptr, jsClass))
 73 {
 74 }
 75 
 76 template &lt;class Parent&gt;
 77 JSCallbackObject&lt;Parent&gt;::~JSCallbackObject()
 78 {
 79     VM&amp; vm = this-&gt;HeapCell::vm();
 80     vm.currentlyDestructingCallbackObject = this;
 81     ASSERT(m_classInfo);
 82     vm.currentlyDestructingCallbackObjectClassInfo = m_classInfo;
 83     JSObjectRef thisRef = toRef(static_cast&lt;JSObject*&gt;(this));
 84     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
 85         if (JSObjectFinalizeCallback finalize = jsClass-&gt;finalize)
 86             finalize(thisRef);
 87     }
 88     vm.currentlyDestructingCallbackObject = nullptr;
 89     vm.currentlyDestructingCallbackObjectClassInfo = nullptr;
 90 }
 91 
 92 template &lt;class Parent&gt;
<span class="line-modified"> 93 void JSCallbackObject&lt;Parent&gt;::finishCreation(JSGlobalObject* globalObject)</span>
 94 {
<span class="line-modified"> 95     VM&amp; vm = getVM(globalObject);</span>
 96     Base::finishCreation(vm);
 97     ASSERT(Parent::inherits(vm, info()));
<span class="line-modified"> 98     init(globalObject);</span>
 99 }
100 
101 // This is just for Global object, so we can assume that Base::finishCreation is JSGlobalObject::finishCreation.
102 template &lt;class Parent&gt;
103 void JSCallbackObject&lt;Parent&gt;::finishCreation(VM&amp; vm)
104 {
105     ASSERT(Parent::inherits(vm, info()));
106     ASSERT(Parent::isGlobalObject());
107     Base::finishCreation(vm);
<span class="line-modified">108     init(jsCast&lt;JSGlobalObject*&gt;(this));</span>
109 }
110 
111 template &lt;class Parent&gt;
<span class="line-modified">112 void JSCallbackObject&lt;Parent&gt;::init(JSGlobalObject* globalObject)</span>
113 {
<span class="line-modified">114     ASSERT(globalObject);</span>
115 
116     Vector&lt;JSObjectInitializeCallback, 16&gt; initRoutines;
117     JSClassRef jsClass = classRef();
118     do {
119         if (JSObjectInitializeCallback initialize = jsClass-&gt;initialize)
120             initRoutines.append(initialize);
121     } while ((jsClass = jsClass-&gt;parentClass));
122 
123     // initialize from base to derived
124     for (int i = static_cast&lt;int&gt;(initRoutines.size()) - 1; i &gt;= 0; i--) {
<span class="line-modified">125         JSLock::DropAllLocks dropAllLocks(globalObject);</span>
126         JSObjectInitializeCallback initialize = initRoutines[i];
<span class="line-modified">127         initialize(toRef(globalObject), toRef(jsCast&lt;JSObject*&gt;(this)));</span>
128     }
129 
<span class="line-modified">130     m_classInfo = this-&gt;classInfo(getVM(globalObject));</span>
131 }
132 
133 template &lt;class Parent&gt;
134 String JSCallbackObject&lt;Parent&gt;::className(const JSObject* object, VM&amp; vm)
135 {
136     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
137     String thisClassName = thisObject-&gt;classRef()-&gt;className();
138     if (!thisClassName.isEmpty())
139         return thisClassName;
140 
141     return Parent::className(object, vm);
142 }
143 
144 template &lt;class Parent&gt;
<span class="line-modified">145 String JSCallbackObject&lt;Parent&gt;::toStringName(const JSObject* object, JSGlobalObject* globalObject)</span>
146 {
<span class="line-modified">147     VM&amp; vm = getVM(globalObject);</span>
148     const ClassInfo* info = object-&gt;classInfo(vm);
149     ASSERT(info);
150     return info-&gt;methodTable.className(object, vm);
151 }
152 
153 template &lt;class Parent&gt;
<span class="line-modified">154 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
155 {
<span class="line-modified">156     VM&amp; vm = getVM(globalObject);</span>
157     auto scope = DECLARE_THROW_SCOPE(vm);
158 
159     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">160     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">161     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
162     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
163 
164     if (StringImpl* name = propertyName.uid()) {
165         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
166             // optional optimization to bypass getProperty in cases when we only need to know if the property exists
167             if (JSObjectHasPropertyCallback hasProperty = jsClass-&gt;hasProperty) {
168                 if (!propertyNameRef)
169                     propertyNameRef = OpaqueJSString::tryCreate(name);
<span class="line-modified">170                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
171                 if (hasProperty(ctx, thisRef, propertyNameRef.get())) {
172                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, callbackGetter);
173                     return true;
174                 }
175             } else if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
176                 if (!propertyNameRef)
177                     propertyNameRef = OpaqueJSString::tryCreate(name);
178                 JSValueRef exception = 0;
179                 JSValueRef value;
180                 {
<span class="line-modified">181                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
182                     value = getProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
183                 }
184                 if (exception) {
<span class="line-modified">185                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
186                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, jsUndefined());
187                     return true;
188                 }
189                 if (value) {
<span class="line-modified">190                     slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, toJS(globalObject, value));</span>
191                     return true;
192                 }
193             }
194 
<span class="line-modified">195             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
196                 if (staticValues-&gt;contains(name)) {
<span class="line-modified">197                     JSValue value = thisObject-&gt;getStaticValue(globalObject, propertyName);</span>
198                     if (value) {
199                         slot.setValue(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, value);
200                         return true;
201                     }
202                 }
203             }
204 
<span class="line-modified">205             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
206                 if (staticFunctions-&gt;contains(name)) {
207                     slot.setCustom(thisObject, PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, staticFunctionGetter);
208                     return true;
209                 }
210             }
211         }
212     }
213 
<span class="line-modified">214     return Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
215 }
216 
217 template &lt;class Parent&gt;
<span class="line-modified">218 bool JSCallbackObject&lt;Parent&gt;::getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
219 {
<span class="line-modified">220     VM&amp; vm = getVM(globalObject);</span>
<span class="line-modified">221     return object-&gt;methodTable(vm)-&gt;getOwnPropertySlot(object, globalObject, Identifier::from(vm, propertyName), slot);</span>
222 }
223 
224 template &lt;class Parent&gt;
<span class="line-modified">225 JSValue JSCallbackObject&lt;Parent&gt;::defaultValue(const JSObject* object, JSGlobalObject* globalObject, PreferredPrimitiveType hint)</span>
226 {
<span class="line-modified">227     VM&amp; vm = getVM(globalObject);</span>
228     auto scope = DECLARE_THROW_SCOPE(vm);
229 
230     const JSCallbackObject* thisObject = jsCast&lt;const JSCallbackObject*&gt;(object);
<span class="line-modified">231     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">232     JSObjectRef thisRef = toRef(jsCast&lt;const JSObject*&gt;(thisObject));</span>
233     ::JSType jsHint = hint == PreferString ? kJSTypeString : kJSTypeNumber;
234 
235     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
236         if (JSObjectConvertToTypeCallback convertToType = jsClass-&gt;convertToType) {
237             JSValueRef exception = 0;
238             JSValueRef result = convertToType(ctx, thisRef, jsHint, &amp;exception);
239             if (exception) {
<span class="line-modified">240                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
241                 return jsUndefined();
242             }
243             if (result)
<span class="line-modified">244                 return toJS(globalObject, result);</span>
245         }
246     }
247 
<span class="line-modified">248     return Parent::defaultValue(object, globalObject, hint);</span>
249 }
250 
251 template &lt;class Parent&gt;
<span class="line-modified">252 bool JSCallbackObject&lt;Parent&gt;::put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
253 {
<span class="line-modified">254     VM&amp; vm = getVM(globalObject);</span>
255     auto scope = DECLARE_THROW_SCOPE(vm);
256 
257     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">258     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">259     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
260     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">261     JSValueRef valueRef = toRef(globalObject, value);</span>
262 
263     if (StringImpl* name = propertyName.uid()) {
264         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
265             if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
266                 if (!propertyNameRef)
267                     propertyNameRef = OpaqueJSString::tryCreate(name);
268                 JSValueRef exception = 0;
269                 bool result;
270                 {
<span class="line-modified">271                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
272                     result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
273                 }
274                 if (exception)
<span class="line-modified">275                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
276                 if (result || exception)
277                     return result;
278             }
279 
<span class="line-modified">280             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
281                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
282                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
283                         return false;
284                     if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
285                         JSValueRef exception = 0;
286                         bool result;
287                         {
<span class="line-modified">288                             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
289                             result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
290                         }
291                         if (exception)
<span class="line-modified">292                             throwException(globalObject, scope, toJS(globalObject, exception));</span>
293                         if (result || exception)
294                             return result;
295                     }
296                 }
297             }
298 
<span class="line-modified">299             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
300                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
301                     PropertySlot getSlot(thisObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">302                     if (Parent::getOwnPropertySlot(thisObject, globalObject, propertyName, getSlot))</span>
<span class="line-modified">303                         return Parent::put(thisObject, globalObject, propertyName, value, slot);</span>
304                     if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
305                         return false;
306                     return thisObject-&gt;JSCallbackObject&lt;Parent&gt;::putDirect(vm, propertyName, value); // put as override property
307                 }
308             }
309         }
310     }
311 
<span class="line-modified">312     return Parent::put(thisObject, globalObject, propertyName, value, slot);</span>
313 }
314 
315 template &lt;class Parent&gt;
<span class="line-modified">316 bool JSCallbackObject&lt;Parent&gt;::putByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyIndex, JSValue value, bool shouldThrow)</span>
317 {
<span class="line-modified">318     VM&amp; vm = getVM(globalObject);</span>
319     auto scope = DECLARE_THROW_SCOPE(vm);
320 
321     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">322     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">323     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
324     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
<span class="line-modified">325     JSValueRef valueRef = toRef(globalObject, value);</span>
326     Identifier propertyName = Identifier::from(vm, propertyIndex);
327 
328     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
329         if (JSObjectSetPropertyCallback setProperty = jsClass-&gt;setProperty) {
330             if (!propertyNameRef)
331                 propertyNameRef = OpaqueJSString::tryCreate(propertyName.impl());
332             JSValueRef exception = 0;
333             bool result;
334             {
<span class="line-modified">335                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
336                 result = setProperty(ctx, thisRef, propertyNameRef.get(), valueRef, &amp;exception);
337             }
338             if (exception)
<span class="line-modified">339                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
340             if (result || exception)
341                 return result;
342         }
343 
<span class="line-modified">344         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
345             if (StaticValueEntry* entry = staticValues-&gt;get(propertyName.impl())) {
346                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
347                     return false;
348                 if (JSObjectSetPropertyCallback setProperty = entry-&gt;setProperty) {
349                     JSValueRef exception = 0;
350                     bool result;
351                     {
<span class="line-modified">352                         JSLock::DropAllLocks dropAllLocks(globalObject);</span>
353                         result = setProperty(ctx, thisRef, entry-&gt;propertyNameRef.get(), valueRef, &amp;exception);
354                     }
355                     if (exception)
<span class="line-modified">356                         throwException(globalObject, scope, toJS(globalObject, exception));</span>
357                     if (result || exception)
358                         return result;
359                 }
360             }
361         }
362 
<span class="line-modified">363         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
364             if (StaticFunctionEntry* entry = staticFunctions-&gt;get(propertyName.impl())) {
365                 if (entry-&gt;attributes &amp; kJSPropertyAttributeReadOnly)
366                     return false;
367                 break;
368             }
369         }
370     }
371 
<span class="line-modified">372     return Parent::putByIndex(thisObject, globalObject, propertyIndex, value, shouldThrow);</span>
373 }
374 
375 template &lt;class Parent&gt;
<span class="line-modified">376 bool JSCallbackObject&lt;Parent&gt;::deleteProperty(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
377 {
<span class="line-modified">378     VM&amp; vm = getVM(globalObject);</span>
379     auto scope = DECLARE_THROW_SCOPE(vm);
380 
381     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">382     JSContextRef ctx = toRef(globalObject);</span>
<span class="line-modified">383     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
384     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
385 
386     if (StringImpl* name = propertyName.uid()) {
387         for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
388             if (JSObjectDeletePropertyCallback deleteProperty = jsClass-&gt;deleteProperty) {
389                 if (!propertyNameRef)
390                     propertyNameRef = OpaqueJSString::tryCreate(name);
391                 JSValueRef exception = 0;
392                 bool result;
393                 {
<span class="line-modified">394                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
395                     result = deleteProperty(ctx, thisRef, propertyNameRef.get(), &amp;exception);
396                 }
397                 if (exception)
<span class="line-modified">398                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
399                 if (result || exception)
400                     return true;
401             }
402 
<span class="line-modified">403             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
404                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
405                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
406                         return false;
407                     return true;
408                 }
409             }
410 
<span class="line-modified">411             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
412                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
413                     if (entry-&gt;attributes &amp; kJSPropertyAttributeDontDelete)
414                         return false;
415                     return true;
416                 }
417             }
418         }
419     }
420 
<span class="line-modified">421     return Parent::deleteProperty(thisObject, globalObject, propertyName);</span>
422 }
423 
424 template &lt;class Parent&gt;
<span class="line-modified">425 bool JSCallbackObject&lt;Parent&gt;::deletePropertyByIndex(JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
426 {
<span class="line-modified">427     VM&amp; vm = getVM(globalObject);</span>
428     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
<span class="line-modified">429     return thisObject-&gt;methodTable(vm)-&gt;deleteProperty(thisObject, globalObject, Identifier::from(vm, propertyName));</span>
430 }
431 
432 template &lt;class Parent&gt;
433 ConstructType JSCallbackObject&lt;Parent&gt;::getConstructData(JSCell* cell, ConstructData&amp; constructData)
434 {
435     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
436     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
437         if (jsClass-&gt;callAsConstructor) {
438             constructData.native.function = construct;
439             return ConstructType::Host;
440         }
441     }
442     return ConstructType::None;
443 }
444 
445 template &lt;class Parent&gt;
<span class="line-modified">446 EncodedJSValue JSCallbackObject&lt;Parent&gt;::construct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
447 {
<span class="line-modified">448     VM&amp; vm = getVM(globalObject);</span>
449     auto scope = DECLARE_THROW_SCOPE(vm);
450 
<span class="line-modified">451     JSObject* constructor = callFrame-&gt;jsCallee();</span>
<span class="line-modified">452     JSContextRef execRef = toRef(globalObject);</span>
453     JSObjectRef constructorRef = toRef(constructor);
454 
455     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(constructor)-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
456         if (JSObjectCallAsConstructorCallback callAsConstructor = jsClass-&gt;callAsConstructor) {
<span class="line-modified">457             size_t argumentCount = callFrame-&gt;argumentCount();</span>
458             Vector&lt;JSValueRef, 16&gt; arguments;
459             arguments.reserveInitialCapacity(argumentCount);
460             for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">461                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));</span>
462             JSValueRef exception = 0;
463             JSObject* result;
464             {
<span class="line-modified">465                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
466                 result = toJS(callAsConstructor(execRef, constructorRef, argumentCount, arguments.data(), &amp;exception));
467             }
468             if (exception)
<span class="line-modified">469                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
470             return JSValue::encode(result);
471         }
472     }
473 
474     RELEASE_ASSERT_NOT_REACHED(); // getConstructData should prevent us from reaching here
475     return JSValue::encode(JSValue());
476 }
477 
478 template &lt;class Parent&gt;
<span class="line-modified">479 bool JSCallbackObject&lt;Parent&gt;::customHasInstance(JSObject* object, JSGlobalObject* globalObject, JSValue value)</span>
480 {
<span class="line-modified">481     VM&amp; vm = getVM(globalObject);</span>
482     auto scope = DECLARE_THROW_SCOPE(vm);
483 
484     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">485     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">486     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
487 
488     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
489         if (JSObjectHasInstanceCallback hasInstance = jsClass-&gt;hasInstance) {
<span class="line-modified">490             JSValueRef valueRef = toRef(globalObject, value);</span>
491             JSValueRef exception = 0;
492             bool result;
493             {
<span class="line-modified">494                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
495                 result = hasInstance(execRef, thisRef, valueRef, &amp;exception);
496             }
497             if (exception)
<span class="line-modified">498                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
499             return result;
500         }
501     }
502     return false;
503 }
504 
505 template &lt;class Parent&gt;
506 CallType JSCallbackObject&lt;Parent&gt;::getCallData(JSCell* cell, CallData&amp; callData)
507 {
508     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(cell);
509     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
510         if (jsClass-&gt;callAsFunction) {
511             callData.native.function = call;
512             return CallType::Host;
513         }
514     }
515     return CallType::None;
516 }
517 
518 template &lt;class Parent&gt;
<span class="line-modified">519 EncodedJSValue JSCallbackObject&lt;Parent&gt;::call(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
520 {
<span class="line-modified">521     VM&amp; vm = getVM(globalObject);</span>
522     auto scope = DECLARE_THROW_SCOPE(vm);
523 
<span class="line-modified">524     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">525     JSObjectRef functionRef = toRef(callFrame-&gt;jsCallee());</span>
<span class="line-modified">526     JSObjectRef thisObjRef = toRef(jsCast&lt;JSObject*&gt;(callFrame-&gt;thisValue().toThis(globalObject, NotStrictMode)));</span>
527 
528     for (JSClassRef jsClass = jsCast&lt;JSCallbackObject&lt;Parent&gt;*&gt;(toJS(functionRef))-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
529         if (JSObjectCallAsFunctionCallback callAsFunction = jsClass-&gt;callAsFunction) {
<span class="line-modified">530             size_t argumentCount = callFrame-&gt;argumentCount();</span>
531             Vector&lt;JSValueRef, 16&gt; arguments;
532             arguments.reserveInitialCapacity(argumentCount);
533             for (size_t i = 0; i &lt; argumentCount; ++i)
<span class="line-modified">534                 arguments.uncheckedAppend(toRef(globalObject, callFrame-&gt;uncheckedArgument(i)));</span>
535             JSValueRef exception = 0;
536             JSValue result;
537             {
<span class="line-modified">538                 JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">539                 result = toJS(globalObject, callAsFunction(execRef, functionRef, thisObjRef, argumentCount, arguments.data(), &amp;exception));</span>
540             }
541             if (exception)
<span class="line-modified">542                 throwException(globalObject, scope, toJS(globalObject, exception));</span>
543             return JSValue::encode(result);
544         }
545     }
546 
547     RELEASE_ASSERT_NOT_REACHED(); // getCallData should prevent us from reaching here
548     return JSValue::encode(JSValue());
549 }
550 
551 template &lt;class Parent&gt;
<span class="line-modified">552 void JSCallbackObject&lt;Parent&gt;::getOwnNonIndexPropertyNames(JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; propertyNames, EnumerationMode mode)</span>
553 {
<span class="line-modified">554     VM&amp; vm = getVM(globalObject);</span>
555     JSCallbackObject* thisObject = jsCast&lt;JSCallbackObject*&gt;(object);
<span class="line-modified">556     JSContextRef execRef = toRef(globalObject);</span>
<span class="line-modified">557     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObject));</span>
558 
559     for (JSClassRef jsClass = thisObject-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
560         if (JSObjectGetPropertyNamesCallback getPropertyNames = jsClass-&gt;getPropertyNames) {
<span class="line-modified">561             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
562             getPropertyNames(execRef, thisRef, toRef(&amp;propertyNames));
563         }
564 
<span class="line-modified">565         if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
566             typedef OpaqueJSClassStaticValuesTable::const_iterator iterator;
567             iterator end = staticValues-&gt;end();
568             for (iterator it = staticValues-&gt;begin(); it != end; ++it) {
569                 StringImpl* name = it-&gt;key.get();
570                 StaticValueEntry* entry = it-&gt;value.get();
571                 if (entry-&gt;getProperty &amp;&amp; (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties())) {
572                     ASSERT(!name-&gt;isSymbol());
573                     propertyNames.add(Identifier::fromString(vm, String(name)));
574                 }
575             }
576         }
577 
<span class="line-modified">578         if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
579             typedef OpaqueJSClassStaticFunctionsTable::const_iterator iterator;
580             iterator end = staticFunctions-&gt;end();
581             for (iterator it = staticFunctions-&gt;begin(); it != end; ++it) {
582                 StringImpl* name = it-&gt;key.get();
583                 StaticFunctionEntry* entry = it-&gt;value.get();
584                 if (!(entry-&gt;attributes &amp; kJSPropertyAttributeDontEnum) || mode.includeDontEnumProperties()) {
585                     ASSERT(!name-&gt;isSymbol());
586                     propertyNames.add(Identifier::fromString(vm, String(name)));
587                 }
588             }
589         }
590     }
591 
<span class="line-modified">592     Parent::getOwnNonIndexPropertyNames(thisObject, globalObject, propertyNames, mode);</span>
593 }
594 
595 template &lt;class Parent&gt;
596 void JSCallbackObject&lt;Parent&gt;::setPrivate(void* data)
597 {
598     m_callbackObjectData-&gt;privateData = data;
599 }
600 
601 template &lt;class Parent&gt;
602 void* JSCallbackObject&lt;Parent&gt;::getPrivate()
603 {
604     return m_callbackObjectData-&gt;privateData;
605 }
606 
607 template &lt;class Parent&gt;
608 bool JSCallbackObject&lt;Parent&gt;::inherits(JSClassRef c) const
609 {
610     for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
611         if (jsClass == c)
612             return true;
613     }
614     return false;
615 }
616 
617 template &lt;class Parent&gt;
<span class="line-modified">618 JSValue JSCallbackObject&lt;Parent&gt;::getStaticValue(JSGlobalObject* globalObject, PropertyName propertyName)</span>
619 {
<span class="line-modified">620     VM&amp; vm = getVM(globalObject);</span>
621     auto scope = DECLARE_THROW_SCOPE(vm);
622 
<span class="line-modified">623     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(this));</span>
624 
625     if (StringImpl* name = propertyName.uid()) {
626         for (JSClassRef jsClass = classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">627             if (OpaqueJSClassStaticValuesTable* staticValues = jsClass-&gt;staticValues(globalObject)) {</span>
628                 if (StaticValueEntry* entry = staticValues-&gt;get(name)) {
629                     if (JSObjectGetPropertyCallback getProperty = entry-&gt;getProperty) {
630                         JSValueRef exception = 0;
631                         JSValueRef value;
632                         {
<span class="line-modified">633                             JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">634                             value = getProperty(toRef(globalObject), thisRef, entry-&gt;propertyNameRef.get(), &amp;exception);</span>
635                         }
636                         if (exception) {
<span class="line-modified">637                             throwException(globalObject, scope, toJS(globalObject, exception));</span>
638                             return jsUndefined();
639                         }
640                         if (value)
<span class="line-modified">641                             return toJS(globalObject, value);</span>
642                     }
643                 }
644             }
645         }
646     }
647 
648     return JSValue();
649 }
650 
651 template &lt;class Parent&gt;
<span class="line-modified">652 EncodedJSValue JSCallbackObject&lt;Parent&gt;::staticFunctionGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
653 {
<span class="line-modified">654     VM&amp; vm = getVM(globalObject);</span>
655     auto scope = DECLARE_THROW_SCOPE(vm);
656 
657     JSCallbackObject* thisObj = asCallbackObject(thisValue);
658 
659     // Check for cached or override property.
660     PropertySlot slot2(thisObj, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">661     if (Parent::getOwnPropertySlot(thisObj, globalObject, propertyName, slot2))</span>
<span class="line-modified">662         return JSValue::encode(slot2.getValue(globalObject, propertyName));</span>
663 
664     if (StringImpl* name = propertyName.uid()) {
665         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
<span class="line-modified">666             if (OpaqueJSClassStaticFunctionsTable* staticFunctions = jsClass-&gt;staticFunctions(globalObject)) {</span>
667                 if (StaticFunctionEntry* entry = staticFunctions-&gt;get(name)) {
668                     if (JSObjectCallAsFunctionCallback callAsFunction = entry-&gt;callAsFunction) {
669                         JSObject* o = JSCallbackFunction::create(vm, thisObj-&gt;globalObject(vm), callAsFunction, name);
670                         thisObj-&gt;putDirect(vm, propertyName, o, entry-&gt;attributes);
671                         return JSValue::encode(o);
672                     }
673                 }
674             }
675         }
676     }
677 
<span class="line-modified">678     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;Static function property defined with NULL callAsFunction callback.&quot;_s)));</span>
679 }
680 
681 template &lt;class Parent&gt;
<span class="line-modified">682 EncodedJSValue JSCallbackObject&lt;Parent&gt;::callbackGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
683 {
<span class="line-modified">684     VM&amp; vm = getVM(globalObject);</span>
685     auto scope = DECLARE_THROW_SCOPE(vm);
686 
687     JSCallbackObject* thisObj = asCallbackObject(thisValue);
688 
<span class="line-modified">689     JSObjectRef thisRef = toRef(jsCast&lt;JSObject*&gt;(thisObj));</span>
690     RefPtr&lt;OpaqueJSString&gt; propertyNameRef;
691 
692     if (StringImpl* name = propertyName.uid()) {
693         for (JSClassRef jsClass = thisObj-&gt;classRef(); jsClass; jsClass = jsClass-&gt;parentClass) {
694             if (JSObjectGetPropertyCallback getProperty = jsClass-&gt;getProperty) {
695                 if (!propertyNameRef)
696                     propertyNameRef = OpaqueJSString::tryCreate(name);
697                 JSValueRef exception = 0;
698                 JSValueRef value;
699                 {
<span class="line-modified">700                     JSLock::DropAllLocks dropAllLocks(globalObject);</span>
<span class="line-modified">701                     value = getProperty(toRef(globalObject), thisRef, propertyNameRef.get(), &amp;exception);</span>
702                 }
703                 if (exception) {
<span class="line-modified">704                     throwException(globalObject, scope, toJS(globalObject, exception));</span>
705                     return JSValue::encode(jsUndefined());
706                 }
707                 if (value)
<span class="line-modified">708                     return JSValue::encode(toJS(globalObject, value));</span>
709             }
710         }
711     }
712 
<span class="line-modified">713     return JSValue::encode(throwException(globalObject, scope, createReferenceError(globalObject, &quot;hasProperty callback returned true for a property that doesn&#39;t exist.&quot;_s)));</span>
714 }
715 
716 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSCallbackObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSClassRef.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/UniqueArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnalignedAccess.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ValueCheck.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/UniqueArray.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/CheckedArithmetic.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace WTF {
 33 



 34 template&lt;bool isTriviallyDestructible, typename T&gt; struct UniqueArrayMaker;
 35 





















 36 template&lt;typename T&gt;
 37 struct UniqueArrayMaker&lt;true, T&gt; {
<span class="line-modified"> 38     using ResultType = typename std::unique_ptr&lt;T[], FastFree&lt;T[]&gt;&gt;;</span>
 39 
 40     static ResultType make(size_t size)
 41     {
 42         // C++ `new T[N]` stores its `N` to somewhere. Otherwise, `delete []` cannot destroy
 43         // these N elements. But we do not want to increase the size of allocated memory.
 44         // If it is acceptable, we can just use Vector&lt;T&gt; instead. So this UniqueArray&lt;T&gt; only
 45         // accepts the type T which has a trivial destructor. This allows us to skip calling
 46         // destructors for N elements. And this allows UniqueArray&lt;T&gt; not to store its N size.
 47         static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 48 
 49         // Do not use placement new like `new (storage) T[size]()`. `new T[size]()` requires
 50         // larger storage than the `sizeof(T) * size` storage since it want to store `size`
 51         // to somewhere.
<span class="line-modified"> 52         T* storage = static_cast&lt;T*&gt;(fastMalloc((Checked&lt;size_t&gt;(sizeof(T)) * size).unsafeGet()));</span>
 53         VectorTypeOperations&lt;T&gt;::initialize(storage, storage + size);
 54         return ResultType(storage);
 55     }
 56 };
 57 
 58 template&lt;typename T&gt;
 59 struct UniqueArrayMaker&lt;false, T&gt; {
 60     // Since we do not know how to store/retrieve N size to/from allocated memory when calling new [] and delete [],
 61     // we use new [] and delete [] operators simply. We create UniqueArrayElement container for the type T.
 62     // UniqueArrayElement has new [] and delete [] operators for FastMalloc. We allocate UniqueArrayElement[] and cast
 63     // it to T[]. When deleting, the custom deleter casts T[] to UniqueArrayElement[] and deletes it.
 64     class UniqueArrayElement {
<span class="line-modified"> 65         WTF_MAKE_FAST_ALLOCATED;</span>
 66     public:
 67         struct Deleter {
 68             void operator()(T* pointer)
 69             {
 70                 delete [] bitwise_cast&lt;UniqueArrayElement*&gt;(pointer);
 71             };
 72         };
 73 
 74         UniqueArrayElement() = default;
 75 
 76         T value { };
 77     };
 78     static_assert(sizeof(T) == sizeof(UniqueArrayElement), &quot;&quot;);
 79 
 80     using ResultType = typename std::unique_ptr&lt;T[], typename UniqueArrayElement::Deleter&gt;;
 81 
 82     static ResultType make(size_t size)
 83     {
 84         return ResultType(bitwise_cast&lt;T*&gt;(new UniqueArrayElement[size]()));
 85     }
</pre>
</td>
<td>
<hr />
<pre>
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/CheckedArithmetic.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace WTF {
 33 
<span class="line-added"> 34 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(UniqueArray);</span>
<span class="line-added"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(UniqueArrayElement);</span>
<span class="line-added"> 36 </span>
 37 template&lt;bool isTriviallyDestructible, typename T&gt; struct UniqueArrayMaker;
 38 
<span class="line-added"> 39 template&lt;typename T&gt;</span>
<span class="line-added"> 40 struct UniqueArrayFree {</span>
<span class="line-added"> 41     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43     void operator()(T* pointer) const</span>
<span class="line-added"> 44     {</span>
<span class="line-added"> 45         UniqueArrayMalloc::free(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));</span>
<span class="line-added"> 46     }</span>
<span class="line-added"> 47 };</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49 template&lt;typename T&gt;</span>
<span class="line-added"> 50 struct UniqueArrayFree&lt;T[]&gt; {</span>
<span class="line-added"> 51     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53     void operator()(T* pointer) const</span>
<span class="line-added"> 54     {</span>
<span class="line-added"> 55         UniqueArrayMalloc::free(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));</span>
<span class="line-added"> 56     }</span>
<span class="line-added"> 57 };</span>
<span class="line-added"> 58 </span>
<span class="line-added"> 59 </span>
 60 template&lt;typename T&gt;
 61 struct UniqueArrayMaker&lt;true, T&gt; {
<span class="line-modified"> 62     using ResultType = typename std::unique_ptr&lt;T[], UniqueArrayFree&lt;T[]&gt;&gt;;</span>
 63 
 64     static ResultType make(size_t size)
 65     {
 66         // C++ `new T[N]` stores its `N` to somewhere. Otherwise, `delete []` cannot destroy
 67         // these N elements. But we do not want to increase the size of allocated memory.
 68         // If it is acceptable, we can just use Vector&lt;T&gt; instead. So this UniqueArray&lt;T&gt; only
 69         // accepts the type T which has a trivial destructor. This allows us to skip calling
 70         // destructors for N elements. And this allows UniqueArray&lt;T&gt; not to store its N size.
 71         static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 72 
 73         // Do not use placement new like `new (storage) T[size]()`. `new T[size]()` requires
 74         // larger storage than the `sizeof(T) * size` storage since it want to store `size`
 75         // to somewhere.
<span class="line-modified"> 76         T* storage = static_cast&lt;T*&gt;(UniqueArrayMalloc::malloc((Checked&lt;size_t&gt;(sizeof(T)) * size).unsafeGet()));</span>
 77         VectorTypeOperations&lt;T&gt;::initialize(storage, storage + size);
 78         return ResultType(storage);
 79     }
 80 };
 81 
 82 template&lt;typename T&gt;
 83 struct UniqueArrayMaker&lt;false, T&gt; {
 84     // Since we do not know how to store/retrieve N size to/from allocated memory when calling new [] and delete [],
 85     // we use new [] and delete [] operators simply. We create UniqueArrayElement container for the type T.
 86     // UniqueArrayElement has new [] and delete [] operators for FastMalloc. We allocate UniqueArrayElement[] and cast
 87     // it to T[]. When deleting, the custom deleter casts T[] to UniqueArrayElement[] and deletes it.
 88     class UniqueArrayElement {
<span class="line-modified"> 89         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(UniqueArrayElement);</span>
 90     public:
 91         struct Deleter {
 92             void operator()(T* pointer)
 93             {
 94                 delete [] bitwise_cast&lt;UniqueArrayElement*&gt;(pointer);
 95             };
 96         };
 97 
 98         UniqueArrayElement() = default;
 99 
100         T value { };
101     };
102     static_assert(sizeof(T) == sizeof(UniqueArrayElement), &quot;&quot;);
103 
104     using ResultType = typename std::unique_ptr&lt;T[], typename UniqueArrayElement::Deleter&gt;;
105 
106     static ResultType make(size_t size)
107     {
108         return ResultType(bitwise_cast&lt;T*&gt;(new UniqueArrayElement[size]()));
109     }
</pre>
</td>
</tr>
</table>
<center><a href="UnalignedAccess.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ValueCheck.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
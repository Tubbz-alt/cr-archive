<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/ViewportConfiguration.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2005-2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ViewportConfiguration.h&quot;
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &lt;wtf/Assertions.h&gt;
 31 #include &lt;wtf/MathExtras.h&gt;
 32 #include &lt;wtf/text/CString.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 #if PLATFORM(IOS_FAMILY)
 36 #include &quot;PlatformScreen.h&quot;
 37 #endif
 38 
 39 namespace WebCore {
 40 
 41 #if ASSERT_ENABLED
 42 static bool constraintsAreAllRelative(const ViewportConfiguration::Parameters&amp; configuration)
 43 {
 44     return !configuration.widthIsSet &amp;&amp; !configuration.heightIsSet &amp;&amp; !configuration.initialScaleIsSet;
 45 }
 46 #endif // ASSERT_ENABLED
 47 
 48 static float platformDeviceWidthOverride()
 49 {
 50 #if PLATFORM(WATCHOS)
 51     return 320;
 52 #else
 53     return 0;
 54 #endif
 55 }
 56 
 57 static bool shouldOverrideShrinkToFitArgument()
 58 {
 59 #if PLATFORM(WATCHOS)
 60     return true;
 61 #else
 62     return false;
 63 #endif
 64 }
 65 
 66 static bool needsUpdateAfterChangingDisabledAdaptations(const OptionSet&lt;DisabledAdaptations&gt;&amp; oldDisabledAdaptations, const OptionSet&lt;DisabledAdaptations&gt;&amp; newDisabledAdaptations)
 67 {
 68     if (oldDisabledAdaptations == newDisabledAdaptations)
 69         return false;
 70 
 71 #if PLATFORM(WATCHOS)
 72     if (oldDisabledAdaptations.contains(DisabledAdaptations::Watch) != newDisabledAdaptations.contains(DisabledAdaptations::Watch))
 73         return true;
 74 #endif
 75 
 76     return false;
 77 }
 78 
 79 ViewportConfiguration::ViewportConfiguration()
 80     : m_minimumLayoutSize(1024, 768)
 81     , m_viewLayoutSize(1024, 768)
 82     , m_canIgnoreScalingConstraints(false)
 83     , m_forceAlwaysUserScalable(false)
 84 {
 85     // Setup a reasonable default configuration to avoid computing infinite scale/sizes.
 86     // Those are the original iPhone configuration.
 87     m_defaultConfiguration = ViewportConfiguration::webpageParameters();
 88     updateConfiguration();
 89 }
 90 
 91 void ViewportConfiguration::setDefaultConfiguration(const ViewportConfiguration::Parameters&amp; defaultConfiguration)
 92 {
 93     ASSERT(!constraintsAreAllRelative(m_configuration));
 94     ASSERT(!defaultConfiguration.initialScaleIsSet || defaultConfiguration.initialScale &gt; 0);
 95     ASSERT(defaultConfiguration.minimumScale &gt; 0);
 96     ASSERT(defaultConfiguration.maximumScale &gt;= defaultConfiguration.minimumScale);
 97 
 98     if (m_defaultConfiguration == defaultConfiguration)
 99         return;
100 
101     m_defaultConfiguration = defaultConfiguration;
102     updateConfiguration();
103 }
104 
105 bool ViewportConfiguration::setContentsSize(const IntSize&amp; contentSize)
106 {
107     if (m_contentSize == contentSize)
108         return false;
109 
110     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;ViewportConfiguration::setContentsSize &quot; &lt;&lt; contentSize &lt;&lt; &quot; (was &quot; &lt;&lt; m_contentSize &lt;&lt; &quot;)&quot;);
111 
112     m_contentSize = contentSize;
113     updateConfiguration();
114     return true;
115 }
116 
117 bool ViewportConfiguration::setViewLayoutSize(const FloatSize&amp; viewLayoutSize, Optional&lt;double&gt;&amp;&amp; scaleFactor, Optional&lt;double&gt;&amp;&amp; minimumEffectiveDeviceWidth)
118 {
119     double newScaleFactor = scaleFactor.valueOr(m_layoutSizeScaleFactor);
120     double newEffectiveWidth = minimumEffectiveDeviceWidth.valueOr(m_minimumEffectiveDeviceWidth);
121     if (m_viewLayoutSize == viewLayoutSize &amp;&amp; m_layoutSizeScaleFactor == newScaleFactor &amp;&amp; newEffectiveWidth == m_minimumEffectiveDeviceWidth)
122         return false;
123 
124     m_layoutSizeScaleFactor = newScaleFactor;
125     m_viewLayoutSize = viewLayoutSize;
126     m_minimumEffectiveDeviceWidth = newEffectiveWidth;
127 
128     updateMinimumLayoutSize();
129     updateConfiguration();
130     return true;
131 }
132 
133 bool ViewportConfiguration::setDisabledAdaptations(const OptionSet&lt;DisabledAdaptations&gt;&amp; disabledAdaptations)
134 {
135     auto previousDisabledAdaptations = m_disabledAdaptations;
136     m_disabledAdaptations = disabledAdaptations;
137 
138     if (!needsUpdateAfterChangingDisabledAdaptations(previousDisabledAdaptations, disabledAdaptations))
139         return false;
140 
141     updateMinimumLayoutSize();
142     updateConfiguration();
143     return true;
144 }
145 
146 bool ViewportConfiguration::canOverrideConfigurationParameters() const
147 {
148     return m_defaultConfiguration == ViewportConfiguration::nativeWebpageParametersWithoutShrinkToFit() || m_defaultConfiguration == ViewportConfiguration::nativeWebpageParametersWithShrinkToFit();
149 }
150 
151 void ViewportConfiguration::updateDefaultConfiguration()
152 {
153     if (!canOverrideConfigurationParameters())
154         return;
155 
156     m_defaultConfiguration = nativeWebpageParameters();
157 }
158 
159 bool ViewportConfiguration::setViewportArguments(const ViewportArguments&amp; viewportArguments)
160 {
161     if (m_viewportArguments == viewportArguments)
162         return false;
163 
164     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;ViewportConfiguration::setViewportArguments &quot; &lt;&lt; viewportArguments);
165     m_viewportArguments = viewportArguments;
166 
167     updateDefaultConfiguration();
168     updateMinimumLayoutSize();
169     updateConfiguration();
170     return true;
171 }
172 
173 bool ViewportConfiguration::setCanIgnoreScalingConstraints(bool canIgnoreScalingConstraints)
174 {
175     if (canIgnoreScalingConstraints == m_canIgnoreScalingConstraints)
176         return false;
177 
178     m_canIgnoreScalingConstraints = canIgnoreScalingConstraints;
179     updateDefaultConfiguration();
180     updateMinimumLayoutSize();
181     updateConfiguration();
182     return true;
183 }
184 
185 IntSize ViewportConfiguration::layoutSize() const
186 {
187     return IntSize(layoutWidth(), layoutHeight());
188 }
189 
190 bool ViewportConfiguration::shouldOverrideDeviceWidthAndShrinkToFit() const
191 {
192     if (m_disabledAdaptations.contains(DisabledAdaptations::Watch))
193         return false;
194 
195     auto viewWidth = m_viewLayoutSize.width();
196     return 0 &lt; viewWidth &amp;&amp; viewWidth &lt; platformDeviceWidthOverride();
197 }
198 
199 bool ViewportConfiguration::shouldIgnoreHorizontalScalingConstraints() const
200 {
201     if (!m_canIgnoreScalingConstraints)
202         return false;
203 
204     if (shouldOverrideDeviceWidthAndShrinkToFit())
205         return true;
206 
207     if (!m_configuration.allowsShrinkToFit)
208         return false;
209 
210     bool laidOutWiderThanViewport = m_contentSize.width() &gt; layoutWidth();
211     if (m_viewportArguments.width == ViewportArguments::ValueDeviceWidth)
212         return laidOutWiderThanViewport;
213 
214     if (m_configuration.initialScaleIsSet &amp;&amp; m_configuration.initialScaleIgnoringLayoutScaleFactor == 1)
215         return laidOutWiderThanViewport;
216 
217     return false;
218 }
219 
220 bool ViewportConfiguration::shouldIgnoreVerticalScalingConstraints() const
221 {
222     if (!m_canIgnoreScalingConstraints)
223         return false;
224 
225     if (!m_configuration.allowsShrinkToFit)
226         return false;
227 
228     bool laidOutTallerThanViewport = m_contentSize.height() &gt; layoutHeight();
229     if (m_viewportArguments.height == ViewportArguments::ValueDeviceHeight &amp;&amp; m_viewportArguments.width == ViewportArguments::ValueAuto)
230         return laidOutTallerThanViewport;
231 
232     return false;
233 }
234 
235 bool ViewportConfiguration::shouldIgnoreScalingConstraints() const
236 {
237     return shouldIgnoreHorizontalScalingConstraints() || shouldIgnoreVerticalScalingConstraints();
238 }
239 
240 bool ViewportConfiguration::shouldIgnoreScalingConstraintsRegardlessOfContentSize() const
241 {
242     return m_canIgnoreScalingConstraints &amp;&amp; shouldOverrideDeviceWidthAndShrinkToFit();
243 }
244 
245 double ViewportConfiguration::initialScaleFromSize(double width, double height, bool shouldIgnoreScalingConstraints) const
246 {
247     ASSERT(!constraintsAreAllRelative(m_configuration));
248 
249     auto clampToMinimumAndMaximumScales = [&amp;] (double initialScale) {
250         return clampTo&lt;double&gt;(initialScale, shouldIgnoreScalingConstraints ? m_defaultConfiguration.minimumScale : m_configuration.minimumScale, m_configuration.maximumScale);
251     };
252 
253     if (layoutSizeIsExplicitlyScaled()) {
254         if (m_configuration.initialScaleIsSet)
255             return clampToMinimumAndMaximumScales(m_configuration.initialScale);
256 
257         if (m_configuration.width &gt; 0)
258             return clampToMinimumAndMaximumScales(m_viewLayoutSize.width() / m_configuration.width);
259     }
260 
261     // If the document has specified its own initial scale, use it regardless.
262     // This is guaranteed to be sanity checked already, so no need for MIN/MAX.
263     if (m_configuration.initialScaleIsSet &amp;&amp; !shouldIgnoreScalingConstraints)
264         return m_configuration.initialScale;
265 
266     // If not, it is up to us to determine the initial scale.
267     // We want a scale small enough to fit the document width-wise.
268     double initialScale = 0;
269     if (!shouldIgnoreVerticalScalingConstraints()) {
270         static const double maximumContentWidthBeforePreferringExplicitWidthToAvoidExcessiveScaling = 1920;
271         if (width &gt; maximumContentWidthBeforePreferringExplicitWidthToAvoidExcessiveScaling &amp;&amp; m_configuration.widthIsSet &amp;&amp; 0 &lt; m_configuration.width &amp;&amp; m_configuration.width &lt; width)
272             initialScale = m_viewLayoutSize.width() / m_configuration.width;
273         else if (width &gt; 0)
274             initialScale = m_viewLayoutSize.width() / width;
275     }
276 
277     // Prevent the initial scale from shrinking to a height smaller than our view&#39;s minimum height.
278     if (height &gt; 0 &amp;&amp; height * initialScale &lt; m_viewLayoutSize.height() &amp;&amp; !shouldIgnoreHorizontalScalingConstraints())
279         initialScale = m_viewLayoutSize.height() / height;
280 
281     return clampToMinimumAndMaximumScales(initialScale);
282 }
283 
284 double ViewportConfiguration::initialScale() const
285 {
286     return initialScaleFromSize(m_contentSize.width() &gt; 0 ? m_contentSize.width() : layoutWidth(), m_contentSize.height() &gt; 0 ? m_contentSize.height() : layoutHeight(), shouldIgnoreScalingConstraints());
287 }
288 
289 double ViewportConfiguration::initialScaleIgnoringContentSize() const
290 {
291     return initialScaleFromSize(layoutWidth(), layoutHeight(), shouldIgnoreScalingConstraintsRegardlessOfContentSize());
292 }
293 
294 double ViewportConfiguration::minimumScale() const
295 {
296     // If we scale to fit, then this is our minimum scale as well.
297     if (!m_configuration.initialScaleIsSet || shouldIgnoreScalingConstraints())
298         return initialScale();
299 
300     // If not, we still need to sanity check our value.
301     double minimumScale = m_configuration.minimumScale;
302 
303     if (m_forceAlwaysUserScalable)
304         minimumScale = std::min(minimumScale, forceAlwaysUserScalableMinimumScale());
305 
306     auto scaleForFittingContentIsApproximatelyEqualToMinimumScale = [] (double viewLength, double contentLength, double minimumScale) {
307         if (contentLength &lt;= 1 || viewLength &lt;= 1)
308             return false;
309 
310         if (minimumScale &lt; (viewLength - 0.5) / (contentLength + 0.5))
311             return false;
312 
313         if (minimumScale &gt; (viewLength + 0.5) / (contentLength - 0.5))
314             return false;
315 
316         return true;
317     };
318 
319     double contentWidth = m_contentSize.width();
320     if (contentWidth &gt; 0 &amp;&amp; contentWidth * minimumScale &lt; m_viewLayoutSize.width() &amp;&amp; !shouldIgnoreVerticalScalingConstraints()) {
321         if (!scaleForFittingContentIsApproximatelyEqualToMinimumScale(m_viewLayoutSize.width(), contentWidth, minimumScale))
322             minimumScale = m_viewLayoutSize.width() / contentWidth;
323     }
324 
325     double contentHeight = m_contentSize.height();
326     if (contentHeight &gt; 0 &amp;&amp; contentHeight * minimumScale &lt; m_viewLayoutSize.height() &amp;&amp; !shouldIgnoreHorizontalScalingConstraints()) {
327         if (!scaleForFittingContentIsApproximatelyEqualToMinimumScale(m_viewLayoutSize.height(), contentHeight, minimumScale))
328             minimumScale = m_viewLayoutSize.height() / contentHeight;
329     }
330 
331     minimumScale = std::min(std::max(minimumScale, m_configuration.minimumScale), m_configuration.maximumScale);
332 
333     return minimumScale;
334 }
335 
336 bool ViewportConfiguration::allowsUserScaling() const
337 {
338     return m_forceAlwaysUserScalable || allowsUserScalingIgnoringAlwaysScalable();
339 }
340 
341 bool ViewportConfiguration::allowsUserScalingIgnoringAlwaysScalable() const
342 {
343     return shouldIgnoreScalingConstraints() || m_configuration.allowsUserScaling;
344 }
345 
346 ViewportConfiguration::Parameters ViewportConfiguration::nativeWebpageParameters()
347 {
348     if (m_canIgnoreScalingConstraints || !shouldIgnoreMinimumEffectiveDeviceWidth())
349         return ViewportConfiguration::nativeWebpageParametersWithShrinkToFit();
350 
351     return ViewportConfiguration::nativeWebpageParametersWithoutShrinkToFit();
352 }
353 
354 ViewportConfiguration::Parameters ViewportConfiguration::nativeWebpageParametersWithoutShrinkToFit()
355 {
356     Parameters parameters;
357     parameters.width = ViewportArguments::ValueDeviceWidth;
358     parameters.widthIsSet = true;
359     parameters.allowsUserScaling = true;
360     parameters.allowsShrinkToFit = false;
361     parameters.minimumScale = 1;
362     parameters.maximumScale = 5;
363     parameters.initialScale = 1;
364     parameters.initialScaleIgnoringLayoutScaleFactor = 1;
365     parameters.initialScaleIsSet = true;
366     return parameters;
367 }
368 
369 ViewportConfiguration::Parameters ViewportConfiguration::nativeWebpageParametersWithShrinkToFit()
370 {
371     Parameters parameters = ViewportConfiguration::nativeWebpageParametersWithoutShrinkToFit();
372     parameters.allowsShrinkToFit = true;
373     parameters.minimumScale = 0.25;
374     parameters.initialScaleIsSet = false;
375     return parameters;
376 }
377 
378 ViewportConfiguration::Parameters ViewportConfiguration::webpageParameters()
379 {
380     Parameters parameters;
381     parameters.width = 980;
382     parameters.widthIsSet = true;
383     parameters.allowsUserScaling = true;
384     parameters.allowsShrinkToFit = true;
385     parameters.minimumScale = 0.25;
386     parameters.maximumScale = 5;
387     return parameters;
388 }
389 
390 ViewportConfiguration::Parameters ViewportConfiguration::textDocumentParameters()
391 {
392     Parameters parameters;
393 
394 #if PLATFORM(IOS_FAMILY)
395     parameters.width = static_cast&lt;int&gt;(screenSize().width());
396 #else
397     // FIXME: this needs to be unified with ViewportArguments on all ports.
398     parameters.width = 320;
399 #endif
400 
401     parameters.widthIsSet = true;
402     parameters.allowsUserScaling = true;
403     parameters.allowsShrinkToFit = false;
404     parameters.minimumScale = 0.25;
405     parameters.maximumScale = 5;
406     return parameters;
407 }
408 
409 ViewportConfiguration::Parameters ViewportConfiguration::imageDocumentParameters()
410 {
411     Parameters parameters;
412     parameters.width = 980;
413     parameters.widthIsSet = true;
414     parameters.allowsUserScaling = true;
415     parameters.allowsShrinkToFit = false;
416     parameters.minimumScale = 0.01;
417     parameters.maximumScale = 5;
418     return parameters;
419 }
420 
421 ViewportConfiguration::Parameters ViewportConfiguration::xhtmlMobileParameters()
422 {
423     Parameters parameters = webpageParameters();
424     parameters.width = 320;
425     return parameters;
426 }
427 
428 ViewportConfiguration::Parameters ViewportConfiguration::testingParameters()
429 {
430     Parameters parameters;
431     parameters.initialScale = 1;
432     parameters.initialScaleIgnoringLayoutScaleFactor = 1;
433     parameters.initialScaleIsSet = true;
434     parameters.allowsShrinkToFit = true;
435     parameters.minimumScale = 1;
436     parameters.maximumScale = 5;
437     return parameters;
438 }
439 
440 static inline bool viewportArgumentValueIsValid(float value)
441 {
442     return value &gt; 0;
443 }
444 
445 template&lt;typename ValueType, typename ViewportArgumentsType&gt;
446 static inline void applyViewportArgument(ValueType&amp; value, ViewportArgumentsType viewportArgumentValue, ValueType minimum, ValueType maximum)
447 {
448     if (viewportArgumentValueIsValid(viewportArgumentValue))
449         value = std::min(maximum, std::max(minimum, static_cast&lt;ValueType&gt;(viewportArgumentValue)));
450 }
451 
452 template&lt;typename ValueType, typename ViewportArgumentsType&gt;
453 static inline void applyViewportArgument(ValueType&amp; value, bool&amp; valueIsSet, ViewportArgumentsType viewportArgumentValue, ValueType minimum, ValueType maximum)
454 {
455     if (viewportArgumentValueIsValid(viewportArgumentValue)) {
456         value = std::min(maximum, std::max(minimum, static_cast&lt;ValueType&gt;(viewportArgumentValue)));
457         valueIsSet = true;
458     } else
459         valueIsSet = false;
460 }
461 
462 static inline bool booleanViewportArgumentIsSet(float value)
463 {
464     return !value || value == 1;
465 }
466 
467 void ViewportConfiguration::updateConfiguration()
468 {
469     m_configuration = m_defaultConfiguration;
470 
471     const double minimumViewportArgumentsScaleFactor = 0.1;
472     const double maximumViewportArgumentsScaleFactor = 10.0;
473 
474     bool viewportArgumentsOverridesInitialScale;
475     bool viewportArgumentsOverridesWidth;
476     bool viewportArgumentsOverridesHeight;
477 
478     auto effectiveLayoutScale = effectiveLayoutSizeScaleFactor();
479 
480     if (layoutSizeIsExplicitlyScaled())
481         m_configuration.width /= effectiveLayoutScale;
482 
483     applyViewportArgument(m_configuration.minimumScale, m_viewportArguments.minZoom, minimumViewportArgumentsScaleFactor, maximumViewportArgumentsScaleFactor);
484     applyViewportArgument(m_configuration.maximumScale, m_viewportArguments.maxZoom, m_configuration.minimumScale, maximumViewportArgumentsScaleFactor);
485     applyViewportArgument(m_configuration.initialScale, viewportArgumentsOverridesInitialScale, m_viewportArguments.zoom, m_configuration.minimumScale, m_configuration.maximumScale);
486 
487     double minimumViewportArgumentsDimension = 10;
488     double maximumViewportArgumentsDimension = 10000;
489     applyViewportArgument(m_configuration.width, viewportArgumentsOverridesWidth, viewportArgumentsLength(m_viewportArguments.width), minimumViewportArgumentsDimension, maximumViewportArgumentsDimension);
490     applyViewportArgument(m_configuration.height, viewportArgumentsOverridesHeight, viewportArgumentsLength(m_viewportArguments.height), minimumViewportArgumentsDimension, maximumViewportArgumentsDimension);
491 
492     if (viewportArgumentsOverridesInitialScale || viewportArgumentsOverridesWidth || viewportArgumentsOverridesHeight) {
493         m_configuration.initialScaleIsSet = viewportArgumentsOverridesInitialScale;
494         m_configuration.widthIsSet = viewportArgumentsOverridesWidth;
495         m_configuration.heightIsSet = viewportArgumentsOverridesHeight;
496     }
497 
498     if (booleanViewportArgumentIsSet(m_viewportArguments.userZoom))
499         m_configuration.allowsUserScaling = m_viewportArguments.userZoom != 0.;
500 
501     if (shouldOverrideShrinkToFitArgument())
502         m_configuration.allowsShrinkToFit = shouldOverrideDeviceWidthAndShrinkToFit();
503     else if (booleanViewportArgumentIsSet(m_viewportArguments.shrinkToFit))
504         m_configuration.allowsShrinkToFit = m_viewportArguments.shrinkToFit != 0.;
505 
506     if (canOverrideConfigurationParameters() &amp;&amp; !viewportArgumentsOverridesWidth)
507         m_configuration.width = m_minimumLayoutSize.width();
508 
509     m_configuration.avoidsUnsafeArea = m_viewportArguments.viewportFit != ViewportFit::Cover;
510     m_configuration.initialScaleIgnoringLayoutScaleFactor = m_configuration.initialScale;
511     m_configuration.initialScale *= effectiveLayoutScale;
512     m_configuration.minimumScale *= effectiveLayoutScale;
513     m_configuration.maximumScale *= effectiveLayoutScale;
514 
515     LOG_WITH_STREAM(Viewports, stream &lt;&lt; &quot;ViewportConfiguration &quot; &lt;&lt; this &lt;&lt; &quot; updateConfiguration &quot; &lt;&lt; *this &lt;&lt; &quot; gives initial scale &quot; &lt;&lt; initialScale() &lt;&lt; &quot; based on contentSize &quot; &lt;&lt; m_contentSize &lt;&lt; &quot; and layout size &quot; &lt;&lt; layoutWidth() &lt;&lt; &quot;x&quot; &lt;&lt; layoutHeight());
516 }
517 
518 void ViewportConfiguration::updateMinimumLayoutSize()
519 {
520     m_minimumLayoutSize = m_viewLayoutSize / effectiveLayoutSizeScaleFactor();
521 
522     if (!shouldOverrideDeviceWidthAndShrinkToFit())
523         return;
524 
525     float minDeviceWidth = platformDeviceWidthOverride();
526     m_minimumLayoutSize = FloatSize(minDeviceWidth, std::roundf(m_minimumLayoutSize.height() * (minDeviceWidth / m_minimumLayoutSize.width())));
527 }
528 
529 double ViewportConfiguration::viewportArgumentsLength(double length) const
530 {
531     if (length == ViewportArguments::ValueDeviceWidth)
532         return m_minimumLayoutSize.width();
533     if (length == ViewportArguments::ValueDeviceHeight)
534         return m_minimumLayoutSize.height();
535     return length;
536 }
537 
538 int ViewportConfiguration::layoutWidth() const
539 {
540     ASSERT(!constraintsAreAllRelative(m_configuration));
541 
542     const FloatSize&amp; minimumLayoutSize = m_minimumLayoutSize;
543     if (m_configuration.widthIsSet) {
544         // If we scale to fit, then accept the viewport width with sanity checking.
545         if (!m_configuration.initialScaleIsSet) {
546             double maximumScale = this-&gt;maximumScale();
547             double maximumContentWidthInViewportCoordinate = maximumScale * m_configuration.width;
548             if (maximumContentWidthInViewportCoordinate &lt; minimumLayoutSize.width()) {
549                 // The content zoomed to maxScale does not fit the view. Return the minimum width
550                 // satisfying the constraint maximumScale.
551                 return std::round(minimumLayoutSize.width() / maximumScale);
552             }
553             return std::round(m_configuration.width);
554         }
555 
556         // If not, make sure the viewport width and initial scale can co-exist.
557         double initialContentWidthInViewportCoordinate = m_configuration.width * m_configuration.initialScaleIgnoringLayoutScaleFactor;
558         if (initialContentWidthInViewportCoordinate &lt; minimumLayoutSize.width()) {
559             // The specified width does not fit in viewport. Return the minimum width that satisfy the initialScale constraint.
560             return std::round(minimumLayoutSize.width() / m_configuration.initialScaleIgnoringLayoutScaleFactor);
561         }
562         return std::round(m_configuration.width);
563     }
564 
565     // If the page has a real scale, then just return the minimum size over the initial scale.
566     if (m_configuration.initialScaleIsSet &amp;&amp; !m_configuration.heightIsSet)
567         return std::round(minimumLayoutSize.width() / m_configuration.initialScaleIgnoringLayoutScaleFactor);
568 
569     if (minimumLayoutSize.height() &gt; 0)
570         return std::round(minimumLayoutSize.width() * layoutHeight() / minimumLayoutSize.height());
571     return minimumLayoutSize.width();
572 }
573 
574 int ViewportConfiguration::layoutHeight() const
575 {
576     ASSERT(!constraintsAreAllRelative(m_configuration));
577 
578     const FloatSize&amp; minimumLayoutSize = m_minimumLayoutSize;
579     if (m_configuration.heightIsSet) {
580         // If we scale to fit, then accept the viewport height with sanity checking.
581         if (!m_configuration.initialScaleIsSet) {
582             double maximumScale = this-&gt;maximumScale();
583             double maximumContentHeightInViewportCoordinate = maximumScale * m_configuration.height;
584             if (maximumContentHeightInViewportCoordinate &lt; minimumLayoutSize.height()) {
585                 // The content zoomed to maxScale does not fit the view. Return the minimum height that
586                 // satisfy the constraint maximumScale.
587                 return std::round(minimumLayoutSize.height() / maximumScale);
588             }
589             return std::round(m_configuration.height);
590         }
591 
592         // If not, make sure the viewport width and initial scale can co-exist.
593         double initialContentHeightInViewportCoordinate = m_configuration.height * m_configuration.initialScaleIgnoringLayoutScaleFactor;
594         if (initialContentHeightInViewportCoordinate &lt; minimumLayoutSize.height()) {
595             // The specified width does not fit in viewport. Return the minimum height that satisfy the initialScale constraint.
596             return std::round(minimumLayoutSize.height() / m_configuration.initialScaleIgnoringLayoutScaleFactor);
597         }
598         return std::round(m_configuration.height);
599     }
600 
601     // If the page has a real scale, then just return the minimum size over the initial scale.
602     if (m_configuration.initialScaleIsSet &amp;&amp; !m_configuration.widthIsSet)
603         return std::round(minimumLayoutSize.height() / m_configuration.initialScaleIgnoringLayoutScaleFactor);
604 
605     if (minimumLayoutSize.width() &gt; 0)
606         return std::round(minimumLayoutSize.height() * layoutWidth() / minimumLayoutSize.width());
607     return minimumLayoutSize.height();
608 }
609 
610 bool ViewportConfiguration::setMinimumEffectiveDeviceWidth(double width)
611 {
612     if (WTF::areEssentiallyEqual(m_minimumEffectiveDeviceWidth, width))
613         return false;
614 
615     m_minimumEffectiveDeviceWidth = width;
616 
617     if (shouldIgnoreMinimumEffectiveDeviceWidth())
618         return false;
619 
620     updateMinimumLayoutSize();
621     updateConfiguration();
622     return true;
623 }
624 
625 bool ViewportConfiguration::setIsKnownToLayOutWiderThanViewport(bool value)
626 {
627     if (m_isKnownToLayOutWiderThanViewport == value)
628         return false;
629 
630     m_isKnownToLayOutWiderThanViewport = value;
631     updateMinimumLayoutSize();
632     updateConfiguration();
633     return true;
634 }
635 
636 #if !LOG_DISABLED
637 
638 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ViewportConfiguration::Parameters&amp; parameters)
639 {
640     ts.startGroup();
641     ts &lt;&lt; &quot;width &quot; &lt;&lt; parameters.width &lt;&lt; &quot;, set: &quot; &lt;&lt; (parameters.widthIsSet ? &quot;true&quot; : &quot;false&quot;);
642     ts.endGroup();
643 
644     ts.startGroup();
645     ts &lt;&lt; &quot;height &quot; &lt;&lt; parameters.height &lt;&lt; &quot;, set: &quot; &lt;&lt; (parameters.heightIsSet ? &quot;true&quot; : &quot;false&quot;);
646     ts.endGroup();
647 
648     ts.startGroup();
649     ts &lt;&lt; &quot;initialScale &quot; &lt;&lt; parameters.initialScale &lt;&lt; &quot;, set: &quot; &lt;&lt; (parameters.initialScaleIsSet ? &quot;true&quot; : &quot;false&quot;);
650     ts.endGroup();
651 
652     ts.dumpProperty(&quot;initialScaleIgnoringLayoutScaleFactor&quot;, parameters.initialScaleIgnoringLayoutScaleFactor);
653     ts.dumpProperty(&quot;minimumScale&quot;, parameters.minimumScale);
654     ts.dumpProperty(&quot;maximumScale&quot;, parameters.maximumScale);
655     ts.dumpProperty(&quot;allowsUserScaling&quot;, parameters.allowsUserScaling);
656     ts.dumpProperty(&quot;allowsShrinkToFit&quot;, parameters.allowsShrinkToFit);
657     ts.dumpProperty(&quot;avoidsUnsafeArea&quot;, parameters.avoidsUnsafeArea);
658 
659     return ts;
660 }
661 
662 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const ViewportConfiguration&amp; config)
663 {
664     return ts &lt;&lt; config.description();
665 }
666 
667 String ViewportConfiguration::description() const
668 {
669     TextStream ts;
670 
671     ts.startGroup();
672     ts &lt;&lt; &quot;viewport-configuration &quot; &lt;&lt; (void*)this;
673     {
674         TextStream::GroupScope scope(ts);
675         ts &lt;&lt; &quot;viewport arguments&quot;;
676         ts &lt;&lt; m_viewportArguments;
677     }
678     {
679         TextStream::GroupScope scope(ts);
680         ts &lt;&lt; &quot;configuration&quot;;
681         ts &lt;&lt; m_configuration;
682     }
683     {
684         TextStream::GroupScope scope(ts);
685         ts &lt;&lt; &quot;default configuration&quot;;
686         ts &lt;&lt; m_defaultConfiguration;
687     }
688 
689     ts.dumpProperty(&quot;contentSize&quot;, m_contentSize);
690     ts.dumpProperty(&quot;minimumLayoutSize&quot;, m_minimumLayoutSize);
691     ts.dumpProperty(&quot;layoutSizeScaleFactor&quot;, m_layoutSizeScaleFactor);
692     ts.dumpProperty(&quot;computed initial scale&quot;, initialScale());
693     ts.dumpProperty(&quot;computed minimum scale&quot;, minimumScale());
694     ts.dumpProperty(&quot;computed layout size&quot;, layoutSize());
695     ts.dumpProperty(&quot;ignoring horizontal scaling constraints&quot;, shouldIgnoreHorizontalScalingConstraints() ? &quot;true&quot; : &quot;false&quot;);
696     ts.dumpProperty(&quot;ignoring vertical scaling constraints&quot;, shouldIgnoreVerticalScalingConstraints() ? &quot;true&quot; : &quot;false&quot;);
697     ts.dumpProperty(&quot;avoids unsafe area&quot;, avoidsUnsafeArea() ? &quot;true&quot; : &quot;false&quot;);
698     ts.dumpProperty(&quot;minimum effective device width&quot;, m_minimumEffectiveDeviceWidth);
699     ts.dumpProperty(&quot;known to lay out wider than viewport&quot;, m_isKnownToLayOutWiderThanViewport ? &quot;true&quot; : &quot;false&quot;);
700 
701     ts.endGroup();
702 
703     return ts.release();
704 }
705 
706 void ViewportConfiguration::dump() const
707 {
708     WTFLogAlways(&quot;%s&quot;, description().utf8().data());
709 }
710 
711 #endif
712 
713 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateScrollingNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingStateScrollingNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateScrollingNode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 
 30 #include &quot;ScrollSnapOffsetsInfo.h&quot;
 31 #include &quot;ScrollTypes.h&quot;
 32 #include &quot;ScrollingCoordinator.h&quot;
 33 #include &quot;ScrollingStateNode.h&quot;
 34 
 35 #if PLATFORM(COCOA)
 36 OBJC_CLASS NSScrollerImp;
 37 #endif
 38 
 39 namespace WebCore {
 40 













 41 class ScrollingStateScrollingNode : public ScrollingStateNode {
 42 public:
 43     virtual ~ScrollingStateScrollingNode();
 44 
 45     enum ChangedProperty {
 46         ScrollableAreaSize = NumStateNodeBits,
 47         TotalContentsSize,
 48         ReachableContentsSize,
 49         ParentRelativeScrollableRect,
 50         ScrollPosition,
 51         ScrollOrigin,
 52         ScrollableAreaParams,
 53         RequestedScrollPosition,
 54 #if ENABLE(CSS_SCROLL_SNAP)
 55         HorizontalSnapOffsets,
 56         VerticalSnapOffsets,
 57         HorizontalSnapOffsetRanges,
 58         VerticalSnapOffsetRanges,
 59         CurrentHorizontalSnapOffsetIndex,
 60         CurrentVerticalSnapOffsetIndex,
 61 #endif
<span class="line-modified"> 62         ExpectsWheelEventTestTrigger,</span>
 63         ScrollContainerLayer,
 64         ScrolledContentsLayer,
 65         HorizontalScrollbarLayer,
 66         VerticalScrollbarLayer,
 67         PainterForScrollbar,
 68         NumScrollingStateNodeBits // This must remain at the last position.
 69     };
 70 
 71     const FloatSize&amp; scrollableAreaSize() const { return m_scrollableAreaSize; }
 72     WEBCORE_EXPORT void setScrollableAreaSize(const FloatSize&amp;);
 73 
 74     const FloatSize&amp; totalContentsSize() const { return m_totalContentsSize; }
 75     WEBCORE_EXPORT void setTotalContentsSize(const FloatSize&amp;);
 76 
 77     const FloatSize&amp; reachableContentsSize() const { return m_reachableContentsSize; }
 78     WEBCORE_EXPORT void setReachableContentsSize(const FloatSize&amp;);
 79 
 80     const LayoutRect&amp; parentRelativeScrollableRect() const { return m_parentRelativeScrollableRect; }
 81     WEBCORE_EXPORT void setParentRelativeScrollableRect(const LayoutRect&amp;);
 82 
</pre>
<hr />
<pre>
 92 
 93     const Vector&lt;float&gt;&amp; verticalSnapOffsets() const { return m_snapOffsetsInfo.verticalSnapOffsets; }
 94     WEBCORE_EXPORT void setVerticalSnapOffsets(const Vector&lt;float&gt;&amp;);
 95 
 96     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; horizontalSnapOffsetRanges() const { return m_snapOffsetsInfo.horizontalSnapOffsetRanges; }
 97     WEBCORE_EXPORT void setHorizontalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
 98 
 99     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; verticalSnapOffsetRanges() const { return m_snapOffsetsInfo.verticalSnapOffsetRanges; }
100     WEBCORE_EXPORT void setVerticalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
101 
102     unsigned currentHorizontalSnapPointIndex() const { return m_currentHorizontalSnapPointIndex; }
103     WEBCORE_EXPORT void setCurrentHorizontalSnapPointIndex(unsigned);
104 
105     unsigned currentVerticalSnapPointIndex() const { return m_currentVerticalSnapPointIndex; }
106     WEBCORE_EXPORT void setCurrentVerticalSnapPointIndex(unsigned);
107 #endif
108 
109     const ScrollableAreaParameters&amp; scrollableAreaParameters() const { return m_scrollableAreaParameters; }
110     WEBCORE_EXPORT void setScrollableAreaParameters(const ScrollableAreaParameters&amp; params);
111 
<span class="line-modified">112     const FloatPoint&amp; requestedScrollPosition() const { return m_requestedScrollPosition; }</span>
<span class="line-modified">113     bool requestedScrollPositionRepresentsProgrammaticScroll() const { return m_requestedScrollPositionRepresentsProgrammaticScroll; }</span>
<span class="line-removed">114     WEBCORE_EXPORT void setRequestedScrollPosition(const FloatPoint&amp;, bool representsProgrammaticScroll);</span>
115 
<span class="line-modified">116     bool expectsWheelEventTestTrigger() const { return m_expectsWheelEventTestTrigger; }</span>
<span class="line-modified">117     WEBCORE_EXPORT void setExpectsWheelEventTestTrigger(bool);</span>
118 
119     const LayerRepresentation&amp; scrollContainerLayer() const { return m_scrollContainerLayer; }
120     WEBCORE_EXPORT void setScrollContainerLayer(const LayerRepresentation&amp;);
121 
122     // This is a layer with the contents that move.
123     const LayerRepresentation&amp; scrolledContentsLayer() const { return m_scrolledContentsLayer; }
124     WEBCORE_EXPORT void setScrolledContentsLayer(const LayerRepresentation&amp;);
125 
126     const LayerRepresentation&amp; horizontalScrollbarLayer() const { return m_horizontalScrollbarLayer; }
127     WEBCORE_EXPORT void setHorizontalScrollbarLayer(const LayerRepresentation&amp;);
128 
129     const LayerRepresentation&amp; verticalScrollbarLayer() const { return m_verticalScrollbarLayer; }
130     WEBCORE_EXPORT void setVerticalScrollbarLayer(const LayerRepresentation&amp;);
131 
132 #if PLATFORM(MAC)
133     NSScrollerImp *verticalScrollerImp() const { return m_verticalScrollerImp.get(); }
134     NSScrollerImp *horizontalScrollerImp() const { return m_horizontalScrollerImp.get(); }
135 #endif
136     void setScrollerImpsFromScrollbars(Scrollbar* verticalScrollbar, Scrollbar* horizontalScrollbar);
137 
138 protected:
139     ScrollingStateScrollingNode(ScrollingStateTree&amp;, ScrollingNodeType, ScrollingNodeID);
140     ScrollingStateScrollingNode(const ScrollingStateScrollingNode&amp;, ScrollingStateTree&amp;);
141 
142     void setPropertyChangedBitsAfterReattach() override;
143 
144     void dumpProperties(WTF::TextStream&amp;, ScrollingStateTreeAsTextBehavior) const override;
145 
146 private:
147     FloatSize m_scrollableAreaSize;
148     FloatSize m_totalContentsSize;
149     FloatSize m_reachableContentsSize;
150     LayoutRect m_parentRelativeScrollableRect;
151     FloatPoint m_scrollPosition;
<span class="line-removed">152     FloatPoint m_requestedScrollPosition;</span>
153     IntPoint m_scrollOrigin;
154 
155 #if ENABLE(CSS_SCROLL_SNAP)
156     ScrollSnapOffsetsInfo&lt;float&gt; m_snapOffsetsInfo;
157     unsigned m_currentHorizontalSnapPointIndex { 0 };
158     unsigned m_currentVerticalSnapPointIndex { 0 };
159 #endif
160 
161     LayerRepresentation m_scrollContainerLayer;
162     LayerRepresentation m_scrolledContentsLayer;
163     LayerRepresentation m_horizontalScrollbarLayer;
164     LayerRepresentation m_verticalScrollbarLayer;
165 
166 #if PLATFORM(MAC)
167     RetainPtr&lt;NSScrollerImp&gt; m_verticalScrollerImp;
168     RetainPtr&lt;NSScrollerImp&gt; m_horizontalScrollerImp;
169 #endif
170 
171     ScrollableAreaParameters m_scrollableAreaParameters;

172 
<span class="line-modified">173     bool m_requestedScrollPositionRepresentsProgrammaticScroll { false };</span>
<span class="line-removed">174     bool m_expectsWheelEventTestTrigger { false };</span>
175 };
176 
177 } // namespace WebCore
178 
179 SPECIALIZE_TYPE_TRAITS_SCROLLING_STATE_NODE(ScrollingStateScrollingNode, isScrollingNode())
180 
181 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 
 30 #include &quot;ScrollSnapOffsetsInfo.h&quot;
 31 #include &quot;ScrollTypes.h&quot;
 32 #include &quot;ScrollingCoordinator.h&quot;
 33 #include &quot;ScrollingStateNode.h&quot;
 34 
 35 #if PLATFORM(COCOA)
 36 OBJC_CLASS NSScrollerImp;
 37 #endif
 38 
 39 namespace WebCore {
 40 
<span class="line-added"> 41 struct RequestedScrollData {</span>
<span class="line-added"> 42     FloatPoint scrollPosition;</span>
<span class="line-added"> 43     ScrollType scrollType { ScrollType::User };</span>
<span class="line-added"> 44     ScrollClamping clamping { ScrollClamping::Clamped };</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46     bool operator==(const RequestedScrollData&amp; other) const</span>
<span class="line-added"> 47     {</span>
<span class="line-added"> 48         return scrollPosition == other.scrollPosition</span>
<span class="line-added"> 49             &amp;&amp; scrollType == other.scrollType</span>
<span class="line-added"> 50             &amp;&amp; clamping == other.clamping;</span>
<span class="line-added"> 51     }</span>
<span class="line-added"> 52 };</span>
<span class="line-added"> 53 </span>
 54 class ScrollingStateScrollingNode : public ScrollingStateNode {
 55 public:
 56     virtual ~ScrollingStateScrollingNode();
 57 
 58     enum ChangedProperty {
 59         ScrollableAreaSize = NumStateNodeBits,
 60         TotalContentsSize,
 61         ReachableContentsSize,
 62         ParentRelativeScrollableRect,
 63         ScrollPosition,
 64         ScrollOrigin,
 65         ScrollableAreaParams,
 66         RequestedScrollPosition,
 67 #if ENABLE(CSS_SCROLL_SNAP)
 68         HorizontalSnapOffsets,
 69         VerticalSnapOffsets,
 70         HorizontalSnapOffsetRanges,
 71         VerticalSnapOffsetRanges,
 72         CurrentHorizontalSnapOffsetIndex,
 73         CurrentVerticalSnapOffsetIndex,
 74 #endif
<span class="line-modified"> 75         IsMonitoringWheelEvents,</span>
 76         ScrollContainerLayer,
 77         ScrolledContentsLayer,
 78         HorizontalScrollbarLayer,
 79         VerticalScrollbarLayer,
 80         PainterForScrollbar,
 81         NumScrollingStateNodeBits // This must remain at the last position.
 82     };
 83 
 84     const FloatSize&amp; scrollableAreaSize() const { return m_scrollableAreaSize; }
 85     WEBCORE_EXPORT void setScrollableAreaSize(const FloatSize&amp;);
 86 
 87     const FloatSize&amp; totalContentsSize() const { return m_totalContentsSize; }
 88     WEBCORE_EXPORT void setTotalContentsSize(const FloatSize&amp;);
 89 
 90     const FloatSize&amp; reachableContentsSize() const { return m_reachableContentsSize; }
 91     WEBCORE_EXPORT void setReachableContentsSize(const FloatSize&amp;);
 92 
 93     const LayoutRect&amp; parentRelativeScrollableRect() const { return m_parentRelativeScrollableRect; }
 94     WEBCORE_EXPORT void setParentRelativeScrollableRect(const LayoutRect&amp;);
 95 
</pre>
<hr />
<pre>
105 
106     const Vector&lt;float&gt;&amp; verticalSnapOffsets() const { return m_snapOffsetsInfo.verticalSnapOffsets; }
107     WEBCORE_EXPORT void setVerticalSnapOffsets(const Vector&lt;float&gt;&amp;);
108 
109     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; horizontalSnapOffsetRanges() const { return m_snapOffsetsInfo.horizontalSnapOffsetRanges; }
110     WEBCORE_EXPORT void setHorizontalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
111 
112     const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; verticalSnapOffsetRanges() const { return m_snapOffsetsInfo.verticalSnapOffsetRanges; }
113     WEBCORE_EXPORT void setVerticalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp;);
114 
115     unsigned currentHorizontalSnapPointIndex() const { return m_currentHorizontalSnapPointIndex; }
116     WEBCORE_EXPORT void setCurrentHorizontalSnapPointIndex(unsigned);
117 
118     unsigned currentVerticalSnapPointIndex() const { return m_currentVerticalSnapPointIndex; }
119     WEBCORE_EXPORT void setCurrentVerticalSnapPointIndex(unsigned);
120 #endif
121 
122     const ScrollableAreaParameters&amp; scrollableAreaParameters() const { return m_scrollableAreaParameters; }
123     WEBCORE_EXPORT void setScrollableAreaParameters(const ScrollableAreaParameters&amp; params);
124 
<span class="line-modified">125     const RequestedScrollData&amp; requestedScrollData() const { return m_requestedScrollData; }</span>
<span class="line-modified">126     WEBCORE_EXPORT void setRequestedScrollData(const RequestedScrollData&amp;);</span>

127 
<span class="line-modified">128     bool isMonitoringWheelEvents() const { return m_isMonitoringWheelEvents; }</span>
<span class="line-modified">129     WEBCORE_EXPORT void setIsMonitoringWheelEvents(bool);</span>
130 
131     const LayerRepresentation&amp; scrollContainerLayer() const { return m_scrollContainerLayer; }
132     WEBCORE_EXPORT void setScrollContainerLayer(const LayerRepresentation&amp;);
133 
134     // This is a layer with the contents that move.
135     const LayerRepresentation&amp; scrolledContentsLayer() const { return m_scrolledContentsLayer; }
136     WEBCORE_EXPORT void setScrolledContentsLayer(const LayerRepresentation&amp;);
137 
138     const LayerRepresentation&amp; horizontalScrollbarLayer() const { return m_horizontalScrollbarLayer; }
139     WEBCORE_EXPORT void setHorizontalScrollbarLayer(const LayerRepresentation&amp;);
140 
141     const LayerRepresentation&amp; verticalScrollbarLayer() const { return m_verticalScrollbarLayer; }
142     WEBCORE_EXPORT void setVerticalScrollbarLayer(const LayerRepresentation&amp;);
143 
144 #if PLATFORM(MAC)
145     NSScrollerImp *verticalScrollerImp() const { return m_verticalScrollerImp.get(); }
146     NSScrollerImp *horizontalScrollerImp() const { return m_horizontalScrollerImp.get(); }
147 #endif
148     void setScrollerImpsFromScrollbars(Scrollbar* verticalScrollbar, Scrollbar* horizontalScrollbar);
149 
150 protected:
151     ScrollingStateScrollingNode(ScrollingStateTree&amp;, ScrollingNodeType, ScrollingNodeID);
152     ScrollingStateScrollingNode(const ScrollingStateScrollingNode&amp;, ScrollingStateTree&amp;);
153 
154     void setPropertyChangedBitsAfterReattach() override;
155 
156     void dumpProperties(WTF::TextStream&amp;, ScrollingStateTreeAsTextBehavior) const override;
157 
158 private:
159     FloatSize m_scrollableAreaSize;
160     FloatSize m_totalContentsSize;
161     FloatSize m_reachableContentsSize;
162     LayoutRect m_parentRelativeScrollableRect;
163     FloatPoint m_scrollPosition;

164     IntPoint m_scrollOrigin;
165 
166 #if ENABLE(CSS_SCROLL_SNAP)
167     ScrollSnapOffsetsInfo&lt;float&gt; m_snapOffsetsInfo;
168     unsigned m_currentHorizontalSnapPointIndex { 0 };
169     unsigned m_currentVerticalSnapPointIndex { 0 };
170 #endif
171 
172     LayerRepresentation m_scrollContainerLayer;
173     LayerRepresentation m_scrolledContentsLayer;
174     LayerRepresentation m_horizontalScrollbarLayer;
175     LayerRepresentation m_verticalScrollbarLayer;
176 
177 #if PLATFORM(MAC)
178     RetainPtr&lt;NSScrollerImp&gt; m_verticalScrollerImp;
179     RetainPtr&lt;NSScrollerImp&gt; m_horizontalScrollerImp;
180 #endif
181 
182     ScrollableAreaParameters m_scrollableAreaParameters;
<span class="line-added">183     RequestedScrollData m_requestedScrollData;</span>
184 
<span class="line-modified">185     bool m_isMonitoringWheelEvents { false };</span>

186 };
187 
188 } // namespace WebCore
189 
190 SPECIALIZE_TYPE_TRAITS_SCROLLING_STATE_NODE(ScrollingStateScrollingNode, isScrollingNode())
191 
192 #endif // ENABLE(ASYNC_SCROLLING)
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingStateScrollingNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTree.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
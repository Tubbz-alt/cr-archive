<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBuilder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;DisplayRun.h&quot;
 31 #include &quot;InlineItem.h&quot;
 32 #include &quot;InlineLineBoxBuilder.h&quot;
 33 #include &quot;InlineTextItem.h&quot;
 34 
 35 namespace WebCore {
 36 namespace Layout {
 37 
 38 struct HangingContent;
 39 class InlineFormattingContext;
 40 class InlineSoftLineBreakItem;
 41 
 42 class LineBuilder {
 43     struct ContinuousContent;
 44 
 45 public:
 46     struct Constraints {
 47         InlineLayoutPoint logicalTopLeft;
 48         InlineLayoutUnit availableLogicalWidth { 0 };
 49         bool lineIsConstrainedByFloat { false };
 50         struct HeightAndBaseline {
 51             InlineLayoutUnit height { 0 };
 52             InlineLayoutUnit baselineOffset { 0 };
 53             Optional&lt;LineBoxBuilder::Baseline&gt; strut;
 54         };
 55         Optional&lt;HeightAndBaseline&gt; heightAndBaseline;
 56     };
 57 
 58     enum class IntrinsicSizing { No, Yes };
 59     LineBuilder(const InlineFormattingContext&amp;, Optional&lt;TextAlignMode&gt;, IntrinsicSizing);
 60     ~LineBuilder();
 61 
 62     void initialize(const Constraints&amp;);
 63     void append(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
 64     void resetContent();
 65     bool isVisuallyEmpty() const { return m_lineBox.isConsideredEmpty(); }
 66     bool hasIntrusiveFloat() const { return m_hasIntrusiveFloat; }
 67     InlineLayoutUnit availableWidth() const { return logicalWidth() - contentLogicalWidth(); }
 68 
 69     InlineLayoutUnit trimmableTrailingWidth() const { return m_trimmableTrailingContent.width(); }
 70     bool isTrailingRunFullyTrimmable() const { return m_trimmableTrailingContent.isTrailingRunFullyTrimmable(); }
 71 
 72     const LineBoxBuilder&amp; lineBox() const { return m_lineBox; }
 73     void moveLogicalLeft(InlineLayoutUnit);
 74     void moveLogicalRight(InlineLayoutUnit);
 75     void setHasIntrusiveFloat() { m_hasIntrusiveFloat = true; }
 76 
 77     struct Run {
 78         bool isText() const { return m_type == InlineItem::Type::Text; }
 79         bool isBox() const { return m_type == InlineItem::Type::Box; }
 80         bool isLineBreak() const { return m_type == InlineItem::Type::HardLineBreak || m_type == InlineItem::Type::SoftLineBreak; }
 81         bool isContainerStart() const { return m_type == InlineItem::Type::ContainerStart; }
 82         bool isContainerEnd() const { return m_type == InlineItem::Type::ContainerEnd; }
 83 
 84         const Box&amp; layoutBox() const { return *m_layoutBox; }
 85         const RenderStyle&amp; style() const { return m_layoutBox-&gt;style(); }
 86         const Display::InlineRect&amp; logicalRect() const { return m_logicalRect; }
 87         const Optional&lt;Display::Run::TextContext&gt;&amp; textContext() const { return m_textContext; }
 88 
 89         Run(Run&amp;&amp;) = default;
 90         Run&amp; operator=(Run&amp;&amp; other) = default;
 91 
 92     private:
 93         friend class LineBuilder;
 94 
 95         Run(const InlineTextItem&amp;, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth);
 96         Run(const InlineSoftLineBreakItem&amp;, InlineLayoutUnit logicalLeft);
 97         Run(const InlineItem&amp;, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth);
 98 
 99         void expand(const InlineTextItem&amp;, InlineLayoutUnit logicalWidth);
100 
101         InlineLayoutUnit logicalWidth() const { return m_logicalRect.width(); }
102 
103         void moveHorizontally(InlineLayoutUnit offset) { m_logicalRect.moveHorizontally(offset); }
104         void shrinkHorizontally(InlineLayoutUnit width) { m_logicalRect.expandHorizontally(-width); }
105 
106         void adjustLogicalTop(InlineLayoutUnit logicalTop) { m_logicalRect.setTop(logicalTop); }
107         void moveVertically(InlineLayoutUnit offset) { m_logicalRect.moveVertically(offset); }
108         void setLogicalHeight(InlineLayoutUnit logicalHeight) { m_logicalRect.setHeight(logicalHeight); }
109 
110         bool hasExpansionOpportunity() const { return m_expansionOpportunityCount; }
111         Optional&lt;ExpansionBehavior&gt; expansionBehavior() const;
112         unsigned expansionOpportunityCount() const { return m_expansionOpportunityCount; }
113         void setComputedHorizontalExpansion(InlineLayoutUnit logicalExpansion);
114         void adjustExpansionBehavior(ExpansionBehavior);
115 
116         enum class TrailingWhitespace {
117             None,
118             NotCollapsible,
119             Collapsible,
120             Collapsed
121         };
122         bool hasTrailingWhitespace() const { return m_trailingWhitespaceType != TrailingWhitespace::None; }
123         bool hasCollapsibleTrailingWhitespace() const { return m_trailingWhitespaceType == TrailingWhitespace::Collapsible || hasCollapsedTrailingWhitespace(); }
124         bool hasCollapsedTrailingWhitespace() const { return m_trailingWhitespaceType == TrailingWhitespace::Collapsed; }
125         InlineLayoutUnit trailingWhitespaceWidth() const { return m_trailingWhitespaceWidth; }
126         TrailingWhitespace trailingWhitespaceType(const InlineTextItem&amp;) const;
127         void removeTrailingWhitespace();
128         void visuallyCollapseTrailingWhitespace();
129 
130         bool hasTrailingLetterSpacing() const;
131         InlineLayoutUnit trailingLetterSpacing() const;
132         void removeTrailingLetterSpacing();
133 
134         InlineItem::Type m_type { InlineItem::Type::Text };
135         const Box* m_layoutBox { nullptr };
136         Display::InlineRect m_logicalRect;
137         TrailingWhitespace m_trailingWhitespaceType { TrailingWhitespace::None };
138         InlineLayoutUnit m_trailingWhitespaceWidth { 0 };
139         Optional&lt;Display::Run::TextContext&gt; m_textContext;
140         unsigned m_expansionOpportunityCount { 0 };
141     };
142     using RunList = Vector&lt;Run, 10&gt;;
143     enum class IsLastLineWithInlineContent { No, Yes };
144     RunList close(IsLastLineWithInlineContent = IsLastLineWithInlineContent::No);
145 
146     static LineBoxBuilder::Baseline halfLeadingMetrics(const FontMetrics&amp;, InlineLayoutUnit lineLogicalHeight);
147 
148 private:
149     InlineLayoutUnit logicalTop() const { return m_lineBox.logicalTop(); }
150     InlineLayoutUnit logicalBottom() const { return m_lineBox.logicalBottom(); }
151 
152     InlineLayoutUnit logicalLeft() const { return m_lineBox.logicalLeft(); }
153     InlineLayoutUnit logicalRight() const { return logicalLeft() + logicalWidth(); }
154 
155     InlineLayoutUnit logicalWidth() const { return m_lineLogicalWidth; }
156     InlineLayoutUnit logicalHeight() const { return m_lineBox.logicalHeight(); }
157 
158     InlineLayoutUnit contentLogicalWidth() const { return m_lineBox.logicalWidth(); }
159     InlineLayoutUnit contentLogicalRight() const { return m_lineBox.logicalRight(); }
160     InlineLayoutUnit baselineOffset() const { return m_lineBox.baselineOffset(); }
161 
162     void appendNonBreakableSpace(const InlineItem&amp;, InlineLayoutUnit logicalLeft, InlineLayoutUnit logicalWidth);
163     void appendTextContent(const InlineTextItem&amp;, InlineLayoutUnit logicalWidth);
164     void appendNonReplacedInlineBox(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
165     void appendReplacedInlineBox(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
166     void appendInlineContainerStart(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
167     void appendInlineContainerEnd(const InlineItem&amp;, InlineLayoutUnit logicalWidth);
168     void appendLineBreak(const InlineItem&amp;);
169 
170     void removeTrailingTrimmableContent();
171     void visuallyCollapsePreWrapOverflowContent();
172     HangingContent collectHangingContent(IsLastLineWithInlineContent);
173     void alignHorizontally(const HangingContent&amp;, IsLastLineWithInlineContent);
174     void alignContentVertically();
175 
176     void adjustBaselineAndLineHeight(const Run&amp;);
177     InlineLayoutUnit runContentHeight(const Run&amp;) const;
178 
179     bool isTextAlignJustify() const { return m_horizontalAlignment == TextAlignMode::Justify; };
180     bool isTextAlignRight() const { return m_horizontalAlignment == TextAlignMode::Right || m_horizontalAlignment == TextAlignMode::WebKitRight || m_horizontalAlignment == TextAlignMode::End; }
181     void justifyRuns(InlineLayoutUnit availableWidth);
182 
183     bool isVisuallyNonEmpty(const Run&amp;) const;
184 
185     LayoutState&amp; layoutState() const;
186     const InlineFormattingContext&amp; formattingContext() const;
187 
188     struct TrimmableTrailingContent {
189         TrimmableTrailingContent(RunList&amp;);
190 
191         void addFullyTrimmableContent(size_t runIndex, InlineLayoutUnit trimmableWidth);
192         void addPartiallyTrimmableContent(size_t runIndex, InlineLayoutUnit trimmableWidth);
193         InlineLayoutUnit remove();
194         InlineLayoutUnit removePartiallyTrimmableContent();
195 
196         InlineLayoutUnit width() const { return m_fullyTrimmableWidth + m_partiallyTrimmableWidth; }
197         bool isEmpty() const { return !m_firstRunIndex.hasValue(); }
198         bool isTrailingRunFullyTrimmable() const { return m_hasFullyTrimmableContent; }
199         bool isTrailingRunPartiallyTrimmable() const { return m_partiallyTrimmableWidth; }
200 
201         void reset();
202 
203     private:
204         RunList&amp; m_runs;
205         Optional&lt;size_t&gt; m_firstRunIndex;
206         bool m_hasFullyTrimmableContent { false };
207         InlineLayoutUnit m_fullyTrimmableWidth { 0 };
208         InlineLayoutUnit m_partiallyTrimmableWidth { 0 };
209     };
210 
211     const InlineFormattingContext&amp; m_inlineFormattingContext;
212     RunList m_runs;
213     TrimmableTrailingContent m_trimmableTrailingContent;
214     Optional&lt;LineBoxBuilder::Baseline&gt; m_initialStrut;
215     InlineLayoutUnit m_lineLogicalWidth { 0 };
216     Optional&lt;TextAlignMode&gt; m_horizontalAlignment;
217     bool m_isIntrinsicSizing { false };
218     bool m_hasIntrusiveFloat { false };
219     LineBoxBuilder m_lineBox;
220     Optional&lt;bool&gt; m_lineIsVisuallyEmptyBeforeTrimmableTrailingContent;
221     bool m_shouldIgnoreTrailingLetterSpacing { false };
222 };
223 
224 inline void LineBuilder::TrimmableTrailingContent::reset()
225 {
226     m_hasFullyTrimmableContent = false;
227     m_firstRunIndex = { };
228     m_fullyTrimmableWidth = { };
229     m_partiallyTrimmableWidth = { };
230 }
231 
232 inline LineBuilder::Run::TrailingWhitespace LineBuilder::Run::trailingWhitespaceType(const InlineTextItem&amp; inlineTextItem) const
233 {
234     if (!inlineTextItem.isWhitespace())
235         return TrailingWhitespace::None;
236     if (!inlineTextItem.isCollapsible())
237         return TrailingWhitespace::NotCollapsible;
238     if (inlineTextItem.length() == 1)
239         return TrailingWhitespace::Collapsible;
240     return TrailingWhitespace::Collapsed;
241 }
242 
243 }
244 }
245 #endif
    </pre>
  </body>
</html>
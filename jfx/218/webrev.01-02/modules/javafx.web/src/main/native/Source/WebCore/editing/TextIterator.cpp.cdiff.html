<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SpellingCorrectionCommand.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/TextIterator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 472,12 ***</span>
          return;
      }
  
      if (!m_textBox &amp;&amp; m_remainingTextBox) {
          m_textBox = m_remainingTextBox;
<span class="line-modified">!         m_remainingTextBox = nullptr;</span>
<span class="line-modified">!         m_firstLetterText = nullptr;</span>
          m_offset = 0;
      }
      // handle remembered text box
      if (m_textBox) {
          handleTextBox();
<span class="line-new-header">--- 472,12 ---</span>
          return;
      }
  
      if (!m_textBox &amp;&amp; m_remainingTextBox) {
          m_textBox = m_remainingTextBox;
<span class="line-modified">!         m_remainingTextBox = { };</span>
<span class="line-modified">!         m_firstLetterText = { };</span>
          m_offset = 0;
      }
      // handle remembered text box
      if (m_textBox) {
          handleTextBox();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 572,29 ***</span>
          }
      }
      return false;
  }
  
<span class="line-removed">- static unsigned textNodeOffsetInFlow(const Text&amp; firstTextNodeInRange)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Calculate the text offset for simple lines.</span>
<span class="line-removed">-     RenderObject* renderer = firstTextNodeInRange.renderer();</span>
<span class="line-removed">-     if (!renderer)</span>
<span class="line-removed">-         return 0;</span>
<span class="line-removed">-     unsigned textOffset = 0;</span>
<span class="line-removed">-     for (renderer = renderer-&gt;previousSibling(); renderer; renderer = renderer-&gt;previousSibling()) {</span>
<span class="line-removed">-         if (is&lt;RenderText&gt;(renderer))</span>
<span class="line-removed">-             textOffset += downcast&lt;RenderText&gt;(renderer)-&gt;text().length();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return textOffset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static bool isNewLineOrTabCharacter(UChar character)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return character == &#39;\n&#39; || character == &#39;\t&#39;;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool TextIterator::handleTextNode()
  {
      Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
  
      if (m_fullyClippedStack.top() &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
<span class="line-new-header">--- 572,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 615,11 ***</span>
              handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
              if (m_firstLetterText) {
                  String firstLetter = m_firstLetterText-&gt;text();
                  emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
                  m_firstLetterText = nullptr;
<span class="line-modified">!                 m_textBox = nullptr;</span>
                  return false;
              }
          }
          if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return false;
<span class="line-new-header">--- 596,11 ---</span>
              handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
              if (m_firstLetterText) {
                  String firstLetter = m_firstLetterText-&gt;text();
                  emitText(textNode, *m_firstLetterText, m_offset, m_offset + firstLetter.length());
                  m_firstLetterText = nullptr;
<span class="line-modified">!                 m_textBox = { };</span>
                  return false;
              }
          }
          if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 632,145 ***</span>
  
          emitText(textNode, renderer, runStart, runEnd);
          return true;
      }
  
<span class="line-modified">!     if (const auto* layout = renderer.simpleLineLayout()) {</span>
<span class="line-removed">-         if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         ASSERT(renderer.parent());</span>
<span class="line-removed">-         ASSERT(is&lt;RenderBlockFlow&gt;(*renderer.parent()));</span>
<span class="line-removed">-         const auto&amp; blockFlow = downcast&lt;RenderBlockFlow&gt;(*renderer.parent());</span>
<span class="line-removed">-         // Use the simple layout runs to iterate over the text content.</span>
<span class="line-removed">-         bool isNewTextNode = m_previousSimpleTextNodeInFlow &amp;&amp; m_previousSimpleTextNodeInFlow != &amp;textNode;</span>
<span class="line-removed">-         // Simple line layout run positions are all absolute to the parent flow.</span>
<span class="line-removed">-         // Offsetting is required when multiple renderers are present.</span>
<span class="line-removed">-         m_accumulatedSimpleTextLengthInFlow += isNewTextNode ? m_previousSimpleTextNodeInFlow-&gt;renderer()-&gt;text().length() : 0;</span>
<span class="line-removed">-         m_previousSimpleTextNodeInFlow = &amp;textNode;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         unsigned endPosition = (m_node == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : rendererText.length();</span>
<span class="line-removed">-         if (!m_flowRunResolverCache || &amp;m_flowRunResolverCache-&gt;flow() != &amp;blockFlow) {</span>
<span class="line-removed">-             m_accumulatedSimpleTextLengthInFlow = m_flowRunResolverCache ? 0 : textNodeOffsetInFlow(textNode);</span>
<span class="line-removed">-             m_flowRunResolverCache = makeUnique&lt;SimpleLineLayout::RunResolver&gt;(blockFlow, *layout);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // Skip to m_offset position.</span>
<span class="line-removed">-         auto range = m_flowRunResolverCache-&gt;rangeForRenderer(renderer);</span>
<span class="line-removed">-         auto it = range.begin();</span>
<span class="line-removed">-         auto end = range.end();</span>
<span class="line-removed">-         auto startPosition = static_cast&lt;unsigned&gt;(m_offset) + m_accumulatedSimpleTextLengthInFlow;</span>
<span class="line-removed">-         while (it != end &amp;&amp; (*it).end() &lt;= startPosition)</span>
<span class="line-removed">-             ++it;</span>
<span class="line-removed">-         if (m_nextRunNeedsWhitespace &amp;&amp; rendererText[m_offset - 1] == &#39;\n&#39;) {</span>
<span class="line-removed">-             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed">-             return it == end;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (it == end) {</span>
<span class="line-removed">-             // Collapsed trailing whitespace.</span>
<span class="line-removed">-             m_offset = endPosition;</span>
<span class="line-removed">-             m_lastTextNodeEndedWithCollapsedSpace = true;</span>
<span class="line-removed">-             return true;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (m_nextRunNeedsWhitespace) {</span>
<span class="line-removed">-             emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // If the position we are looking for is to the left of the renderer&#39;s first run, it could mean that</span>
<span class="line-removed">-         // the runs and the renderers are out of sync (e.g. we skipped a renderer in between).</span>
<span class="line-removed">-         // Better bail out at this point.</span>
<span class="line-removed">-         auto run = *it;</span>
<span class="line-removed">-         if (run.start() &gt; startPosition) {</span>
<span class="line-removed">-             ASSERT(m_flowRunResolverCache);</span>
<span class="line-removed">-             if (&amp;(rendererForPosition(m_flowRunResolverCache-&gt;flowContents(), startPosition)) != &amp;renderer) {</span>
<span class="line-removed">-                 ASSERT_NOT_REACHED();</span>
<span class="line-removed">-                 return true;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         ASSERT(run.end() - run.start() &lt;= rendererText.length());</span>
<span class="line-removed">-         // contentStart skips leading whitespace.</span>
<span class="line-removed">-         unsigned contentStart = std::max&lt;unsigned&gt;(m_offset, run.start() - m_accumulatedSimpleTextLengthInFlow);</span>
<span class="line-removed">-         unsigned contentEnd = std::min(endPosition, run.end() - m_accumulatedSimpleTextLengthInFlow);</span>
<span class="line-removed">-         ASSERT_WITH_SECURITY_IMPLICATION(contentStart &lt;= contentEnd);</span>
<span class="line-removed">-         // Check if whitespace adjustment is needed when crossing renderer boundary.</span>
<span class="line-removed">-         if (isNewTextNode) {</span>
<span class="line-removed">-             bool lastCharacterIsNotWhitespace = m_lastCharacter &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter);</span>
<span class="line-removed">-             bool addTrailingWhitespaceForPrevious = m_lastTextNodeEndedWithCollapsedSpace &amp;&amp; lastCharacterIsNotWhitespace;</span>
<span class="line-removed">-             bool leadingWhitespaceIsNeededForCurrent = contentStart &gt; static_cast&lt;unsigned&gt;(m_offset) &amp;&amp; lastCharacterIsNotWhitespace;</span>
<span class="line-removed">-             if (addTrailingWhitespaceForPrevious || leadingWhitespaceIsNeededForCurrent) {</span>
<span class="line-removed">-                 emitCharacter(&#39; &#39;, textNode, nullptr, m_offset, m_offset + 1);</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // \n \t single whitespace characters need replacing so that the new line/tab characters don&#39;t show up.</span>
<span class="line-removed">-         unsigned stopPosition = contentStart;</span>
<span class="line-removed">-         while (stopPosition &lt; contentEnd &amp;&amp; !isNewLineOrTabCharacter(rendererText[stopPosition]))</span>
<span class="line-removed">-             ++stopPosition;</span>
<span class="line-removed">-         // Emit the text up to the new line/tab character.</span>
<span class="line-removed">-         if (stopPosition &lt; contentEnd) {</span>
<span class="line-removed">-             if (stopPosition == contentStart) {</span>
<span class="line-removed">-                 emitCharacter(&#39; &#39;, textNode, nullptr, contentStart, contentStart + 1);</span>
<span class="line-removed">-                 m_offset = contentStart + 1;</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             emitText(textNode, renderer, contentStart, stopPosition);</span>
<span class="line-removed">-             m_offset = stopPosition + 1;</span>
<span class="line-removed">-             m_nextRunNeedsWhitespace = true;</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         emitText(textNode, renderer, contentStart, contentEnd);</span>
<span class="line-removed">-         // When line ending with collapsed whitespace is present, we need to carry over one whitespace: foo(end of line)bar -&gt; foo bar (otherwise we would end up with foobar).</span>
<span class="line-removed">-         m_nextRunNeedsWhitespace = run.isEndOfLine() &amp;&amp; contentEnd &lt; endPosition &amp;&amp; renderer.style().isCollapsibleWhiteSpace(rendererText[contentEnd]);</span>
<span class="line-removed">-         m_offset = contentEnd;</span>
<span class="line-removed">-         return static_cast&lt;unsigned&gt;(m_offset) == endPosition;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (renderer.firstTextBox())</span>
<span class="line-removed">-         m_textBox = renderer.firstTextBox();</span>
  
      bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
      if (shouldHandleFirstLetter)
          handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
  
<span class="line-modified">!     if (!renderer.firstTextBox() &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {</span>
          if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return false;
          m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
          return true;
      }
  
<span class="line-removed">-     // Used when text boxes are out of order (Hebrew/Arabic w/ embeded LTR text)</span>
<span class="line-removed">-     auto&amp; boxesRenderer = m_firstLetterText ? *m_firstLetterText : renderer;</span>
<span class="line-removed">-     if (boxesRenderer.containsReversedText()) {</span>
<span class="line-removed">-         m_sortedTextBoxes.clear();</span>
<span class="line-removed">-         for (InlineTextBox* textBox = boxesRenderer.firstTextBox(); textBox; textBox = textBox-&gt;nextTextBox())</span>
<span class="line-removed">-             m_sortedTextBoxes.append(textBox);</span>
<span class="line-removed">-         std::sort(m_sortedTextBoxes.begin(), m_sortedTextBoxes.end(), InlineTextBox::compareByStart);</span>
<span class="line-removed">-         m_sortedTextBoxesPosition = 0;</span>
<span class="line-removed">-         m_textBox = m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      handleTextBox();
      return true;
  }
  
  void TextIterator::handleTextBox()
  {
      Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
  
      auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
      if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
<span class="line-modified">!         m_textBox = nullptr;</span>
          return;
      }
      String rendererText = renderer.text();
      unsigned start = m_offset;
      unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
      while (m_textBox) {
<span class="line-modified">!         unsigned textBoxStart = m_textBox-&gt;start();</span>
          unsigned runStart = std::max(textBoxStart, start);
  
          // Check for collapsed space at the start of this run.
<span class="line-removed">-         InlineTextBox* firstTextBox = renderer.containsReversedText() ? (m_sortedTextBoxes.isEmpty() ? nullptr : m_sortedTextBoxes[0]) : renderer.firstTextBox();</span>
          bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
          if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
              if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
                  unsigned spaceRunStart = runStart - 1;
                  while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
<span class="line-new-header">--- 613,47 ---</span>
  
          emitText(textNode, renderer, runStart, runEnd);
          return true;
      }
  
<span class="line-modified">!     m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>
  
      bool shouldHandleFirstLetter = !m_handledFirstLetter &amp;&amp; is&lt;RenderTextFragment&gt;(renderer) &amp;&amp; !m_offset;
      if (shouldHandleFirstLetter)
          handleTextNodeFirstLetter(downcast&lt;RenderTextFragment&gt;(renderer));
  
<span class="line-modified">!     if (!m_textBox &amp;&amp; rendererText.length() &amp;&amp; !shouldHandleFirstLetter) {</span>
          if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return false;
          m_lastTextNodeEndedWithCollapsedSpace = true; // entire block is collapsed space
          return true;
      }
  
      handleTextBox();
      return true;
  }
  
  void TextIterator::handleTextBox()
  {
      Text&amp; textNode = downcast&lt;Text&gt;(*m_node);
  
      auto&amp; renderer = m_firstLetterText ? *m_firstLetterText : *textNode.renderer();
      if (renderer.style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility)) {
<span class="line-modified">!         m_textBox = { };</span>
          return;
      }
<span class="line-added">+ </span>
<span class="line-added">+     auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(renderer);</span>
<span class="line-added">+ </span>
      String rendererText = renderer.text();
      unsigned start = m_offset;
      unsigned end = (&amp;textNode == m_endContainer) ? static_cast&lt;unsigned&gt;(m_endOffset) : UINT_MAX;
      while (m_textBox) {
<span class="line-modified">!         unsigned textBoxStart = m_textBox-&gt;localStartOffset();</span>
          unsigned runStart = std::max(textBoxStart, start);
  
          // Check for collapsed space at the start of this run.
          bool needSpace = m_lastTextNodeEndedWithCollapsedSpace || (m_textBox == firstTextBox &amp;&amp; textBoxStart == runStart &amp;&amp; runStart);
          if (needSpace &amp;&amp; !renderer.style().isCollapsibleWhiteSpace(m_lastCharacter) &amp;&amp; m_lastCharacter) {
              if (m_lastTextNode == &amp;textNode &amp;&amp; runStart &amp;&amp; rendererText[runStart - 1] == &#39; &#39;) {
                  unsigned spaceRunStart = runStart - 1;
                  while (spaceRunStart &amp;&amp; rendererText[spaceRunStart - 1] == &#39; &#39;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 778,34 ***</span>
                  emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
              } else
                  emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
              return;
          }
<span class="line-modified">!         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;len();</span>
          unsigned runEnd = std::min(textBoxEnd, end);
  
          // Determine what the next text box will be, but don&#39;t advance yet
<span class="line-modified">!         InlineTextBox* nextTextBox = nullptr;</span>
<span class="line-modified">!         if (renderer.containsReversedText()) {</span>
<span class="line-removed">-             if (m_sortedTextBoxesPosition + 1 &lt; m_sortedTextBoxes.size())</span>
<span class="line-removed">-                 nextTextBox = m_sortedTextBoxes[m_sortedTextBoxesPosition + 1];</span>
<span class="line-removed">-         } else</span>
<span class="line-removed">-             nextTextBox = m_textBox-&gt;nextTextBox();</span>
<span class="line-removed">-         ASSERT(!nextTextBox || &amp;nextTextBox-&gt;renderer() == &amp;renderer);</span>
  
          if (runStart &lt; runEnd) {
<span class="line-modified">!             // Handle either a single newline character (which becomes a space),</span>
<span class="line-modified">!             // or a run of characters that does not include a newline.</span>
<span class="line-modified">!             // This effectively translates newlines to spaces without copying the text.</span>
<span class="line-modified">!             if (rendererText[runStart] == &#39;\n&#39;) {</span>
                  emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
                  m_offset = runStart + 1;
              } else {
<span class="line-modified">!                 size_t subrunEnd = rendererText.find(&#39;\n&#39;, runStart);</span>
<span class="line-modified">!                 if (subrunEnd == notFound || subrunEnd &gt; runEnd) {</span>
<span class="line-modified">!                     subrunEnd = runEnd;</span>
<span class="line-modified">!                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing) &amp;&amp; rendererText.length() &gt; runEnd;</span>
                      if (lastSpaceCollapsedByNextNonTextBox)
                          ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
                  }
                  m_offset = subrunEnd;
                  emitText(textNode, renderer, runStart, subrunEnd);
<span class="line-new-header">--- 661,35 ---</span>
                  emitText(textNode, renderer, spaceRunStart, spaceRunStart + 1);
              } else
                  emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart);
              return;
          }
<span class="line-modified">!         unsigned textBoxEnd = textBoxStart + m_textBox-&gt;length();</span>
          unsigned runEnd = std::min(textBoxEnd, end);
  
          // Determine what the next text box will be, but don&#39;t advance yet
<span class="line-modified">!         auto nextTextBox = m_textBox;</span>
<span class="line-modified">!         nextTextBox.traverseNextInTextOrder();</span>
  
          if (runStart &lt; runEnd) {
<span class="line-modified">!             auto isNewlineOrTab = [&amp;](UChar character) {</span>
<span class="line-modified">!                 return character == &#39;\n&#39; || character == &#39;\t&#39;;</span>
<span class="line-modified">!             };</span>
<span class="line-modified">!             // Handle either a single newline or tab character (which becomes a space),</span>
<span class="line-added">+             // or a run of characters that does not include newlines or tabs.</span>
<span class="line-added">+             // This effectively translates newlines and tabs to spaces without copying the text.</span>
<span class="line-added">+             if (isNewlineOrTab(rendererText[runStart])) {</span>
                  emitCharacter(&#39; &#39;, textNode, nullptr, runStart, runStart + 1);
                  m_offset = runStart + 1;
              } else {
<span class="line-modified">!                 auto subrunEnd = runStart + 1;</span>
<span class="line-modified">!                 for (; subrunEnd &lt; runEnd; ++subrunEnd) {</span>
<span class="line-modified">!                     if (isNewlineOrTab(rendererText[subrunEnd]))</span>
<span class="line-modified">!                         break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+                 if (subrunEnd == runEnd &amp;&amp; (m_behavior &amp; TextIteratorBehavesAsIfNodesFollowing)) {</span>
<span class="line-added">+                     bool lastSpaceCollapsedByNextNonTextBox = !nextTextBox &amp;&amp; rendererText.length() &gt; subrunEnd &amp;&amp; rendererText[subrunEnd] == &#39; &#39;;</span>
                      if (lastSpaceCollapsedByNextNonTextBox)
                          ++subrunEnd; // runEnd stopped before last space. Increment by one to restore the space.
                  }
                  m_offset = subrunEnd;
                  emitText(textNode, renderer, runStart, subrunEnd);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,27 ***</span>
              // come back again to finish handling this text box; don&#39;t advance to the next one.
              if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
                  return;
  
              // Advance and return
<span class="line-modified">!             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;start() : rendererText.length();</span>
              if (nextRunStart &gt; runEnd)
                  m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
              m_textBox = nextTextBox;
<span class="line-removed">-             if (renderer.containsReversedText())</span>
<span class="line-removed">-                 ++m_sortedTextBoxesPosition;</span>
              return;
          }
          // Advance and continue
          m_textBox = nextTextBox;
<span class="line-removed">-         if (renderer.containsReversedText())</span>
<span class="line-removed">-             ++m_sortedTextBoxesPosition;</span>
      }
      if (!m_textBox &amp;&amp; m_remainingTextBox) {
          m_textBox = m_remainingTextBox;
<span class="line-modified">!         m_remainingTextBox = nullptr;</span>
<span class="line-modified">!         m_firstLetterText = nullptr;</span>
          m_offset = 0;
          handleTextBox();
      }
  }
  
<span class="line-new-header">--- 699,23 ---</span>
              // come back again to finish handling this text box; don&#39;t advance to the next one.
              if (static_cast&lt;unsigned&gt;(m_positionEndOffset) &lt; textBoxEnd)
                  return;
  
              // Advance and return
<span class="line-modified">!             unsigned nextRunStart = nextTextBox ? nextTextBox-&gt;localStartOffset() : rendererText.length();</span>
              if (nextRunStart &gt; runEnd)
                  m_lastTextNodeEndedWithCollapsedSpace = true; // collapsed space between runs or at the end
              m_textBox = nextTextBox;
              return;
          }
          // Advance and continue
          m_textBox = nextTextBox;
      }
      if (!m_textBox &amp;&amp; m_remainingTextBox) {
          m_textBox = m_remainingTextBox;
<span class="line-modified">!         m_remainingTextBox = { };</span>
<span class="line-modified">!         m_firstLetterText = { };</span>
          m_offset = 0;
          handleTextBox();
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 854,12 ***</span>
          if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return;
          if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
              m_handledFirstLetter = true;
              m_remainingTextBox = m_textBox;
<span class="line-modified">!             m_textBox = firstLetterText-&gt;firstTextBox();</span>
<span class="line-removed">-             m_sortedTextBoxes.clear();</span>
              m_firstLetterText = firstLetterText;
          }
      }
      m_handledFirstLetter = true;
  }
<span class="line-new-header">--- 734,11 ---</span>
          if (firstLetter-&gt;style().visibility() != Visibility::Visible &amp;&amp; !(m_behavior &amp; TextIteratorIgnoresStyleVisibility))
              return;
          if (auto* firstLetterText = firstRenderTextInFirstLetter(firstLetter)) {
              m_handledFirstLetter = true;
              m_remainingTextBox = m_textBox;
<span class="line-modified">!             m_textBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(*firstLetterText);</span>
              m_firstLetterText = firstLetterText;
          }
      }
      m_handledFirstLetter = true;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1220,11 ***</span>
  
      m_copyableText.set(character);
      m_text = m_copyableText.text();
      m_lastCharacter = character;
      m_lastTextNodeEndedWithCollapsedSpace = false;
<span class="line-removed">-     m_nextRunNeedsWhitespace = false;</span>
  }
  
  void TextIterator::emitText(Text&amp; textNode, RenderText&amp; renderer, int textStartOffset, int textEndOffset)
  {
      ASSERT(textStartOffset &gt;= 0);
<span class="line-new-header">--- 1099,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1245,11 ***</span>
      m_lastCharacter = string[textEndOffset - 1];
      m_copyableText.set(WTFMove(string), textStartOffset, textEndOffset - textStartOffset);
      m_text = m_copyableText.text();
  
      m_lastTextNodeEndedWithCollapsedSpace = false;
<span class="line-removed">-     m_nextRunNeedsWhitespace = false;</span>
      m_hasEmitted = true;
  }
  
  Ref&lt;Range&gt; TextIterator::range() const
  {
<span class="line-new-header">--- 1123,10 ---</span>
</pre>
<center><a href="SpellingCorrectionCommand.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextIterator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderEmbeddedObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFlexibleBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;RenderFlexibleBox.h&quot;
  33 
  34 #include &quot;FlexibleBoxAlgorithm.h&quot;
  35 #include &quot;LayoutRepainter.h&quot;
  36 #include &quot;RenderChildIterator.h&quot;
  37 #include &quot;RenderLayer.h&quot;
  38 #include &quot;RenderLayoutState.h&quot;
  39 #include &quot;RenderView.h&quot;
<span class="line-removed">  40 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  41 #include &lt;limits&gt;
  42 #include &lt;wtf/IsoMallocInlines.h&gt;
  43 #include &lt;wtf/MathExtras.h&gt;

  44 
  45 namespace WebCore {
  46 
  47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFlexibleBox);
  48 
  49 struct RenderFlexibleBox::LineContext {
  50     LineContext(LayoutUnit crossAxisOffset, LayoutUnit crossAxisExtent, LayoutUnit maxAscent, Vector&lt;FlexItem&gt;&amp;&amp; flexItems)
  51         : crossAxisOffset(crossAxisOffset)
  52         , crossAxisExtent(crossAxisExtent)
  53         , maxAscent(maxAscent)
  54         , flexItems(flexItems)
  55     {
  56     }
  57 
  58     LayoutUnit crossAxisOffset;
  59     LayoutUnit crossAxisExtent;
  60     LayoutUnit maxAscent;
  61     Vector&lt;FlexItem&gt; flexItems;
  62 };
  63 
</pre>
<hr />
<pre>
 246         // can compute new available cross axis space. This is only necessary for
 247         // stretching since other alignment values don&#39;t change the size of the
 248         // box.
 249         for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
 250             ItemPosition previousAlignment = child.style().resolvedAlignSelf(oldStyle, selfAlignmentNormalBehavior()).position();
 251             if (previousAlignment == ItemPosition::Stretch &amp;&amp; previousAlignment != child.style().resolvedAlignSelf(&amp;style(), selfAlignmentNormalBehavior()).position())
 252                 child.setChildNeedsLayout(MarkOnlyThis);
 253         }
 254     }
 255 }
 256 
 257 void RenderFlexibleBox::layoutBlock(bool relayoutChildren, LayoutUnit)
 258 {
 259     ASSERT(needsLayout());
 260 
 261     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 262         return;
 263 
 264     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 265 

 266     m_relaidOutChildren.clear();
 267 
 268     bool oldInLayout = m_inLayout;
 269     m_inLayout = true;
 270 
 271     if (recomputeLogicalWidth())
 272         relayoutChildren = true;
 273 
 274     LayoutUnit previousHeight = logicalHeight();
 275     setLogicalHeight(borderAndPaddingLogicalHeight() + scrollbarLogicalHeight());
 276     {
 277         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 278 
 279         preparePaginationBeforeBlockLayout(relayoutChildren);
 280 
 281         m_numberOfInFlowChildrenOnFirstLine = -1;
 282 
 283         beginUpdateScrollInfoAfterLayoutTransaction();
 284 
 285         prepareOrderIteratorAndMargins();
</pre>
<hr />
<pre>
1517         if (childFlexBasis.isIntrinsic() || childMinSize.isIntrinsicOrAuto() || childMaxSize.isIntrinsic())
1518             result = true;
1519     }
1520     return result;
1521 }
1522 
1523 Overflow RenderFlexibleBox::mainAxisOverflowForChild(const RenderBox&amp; child) const
1524 {
1525     if (isHorizontalFlow())
1526         return child.style().overflowX();
1527     return child.style().overflowY();
1528 }
1529 
1530 Overflow RenderFlexibleBox::crossAxisOverflowForChild(const RenderBox&amp; child) const
1531 {
1532     if (isHorizontalFlow())
1533         return child.style().overflowY();
1534     return child.style().overflowX();
1535 }
1536 



























1537 void RenderFlexibleBox::layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp; lineContexts)
1538 {
1539     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehavior());
1540     ContentDistribution distribution = style().resolvedJustifyContentDistribution(contentAlignmentNormalBehavior());
1541 
1542     LayoutUnit autoMarginOffset = autoMarginOffsetInMainAxis(children, availableFreeSpace);
1543     LayoutUnit mainAxisOffset = flowAwareBorderStart() + flowAwarePaddingStart();
1544     mainAxisOffset += initialJustifyContentOffset(availableFreeSpace, position, distribution, children.size());
1545     if (style().flexDirection() == FlexDirection::RowReverse)
1546         mainAxisOffset += isHorizontalFlow() ? verticalScrollbarWidth() : horizontalScrollbarHeight();
1547 
1548     LayoutUnit totalMainExtent = mainAxisExtent();
1549     LayoutUnit maxAscent, maxDescent; // Used when align-items: baseline.
1550     LayoutUnit maxChildCrossAxisExtent;
1551     bool shouldFlipMainAxis = !isColumnFlow() &amp;&amp; !isLeftToRightFlow();
1552     for (size_t i = 0; i &lt; children.size(); ++i) {
1553         const auto&amp; flexItem = children[i];
1554         auto&amp; child = flexItem.box;
1555         bool childHadLayout = child.everHadLayout();
1556 
1557         ASSERT(!flexItem.box.isOutOfFlowPositioned());
1558 
1559         setOverrideMainAxisContentSizeForChild(child, flexItem.flexedContentSize);
1560         // The flexed content size and the override size include the scrollbar
1561         // width, so we need to compare to the size including the scrollbar.
1562         // TODO(cbiesinger): Should it include the scrollbar?
1563         if (flexItem.flexedContentSize != mainAxisContentExtentForChildIncludingScrollbar(child))
1564             child.setChildNeedsLayout(MarkOnlyThis);
1565         else {
1566             // To avoid double applying margin changes in
1567             // updateAutoMarginsInCrossAxis, we reset the margins here.
1568             resetAutoMarginsAndLogicalTopInCrossAxis(child);
1569         }
1570         // We may have already forced relayout for orthogonal flowing children in
1571         // computeInnerFlexBaseSizeForChild.
1572         bool forceChildRelayout = relayoutChildren &amp;&amp; !m_relaidOutChildren.contains(&amp;child);
<span class="line-modified">1573         if (child.isRenderBlock() &amp;&amp; downcast&lt;RenderBlock&gt;(child).hasPercentHeightDescendants()) {</span>
1574             // Have to force another relayout even though the child is sized
1575             // correctly, because its descendants are not sized correctly yet. Our
1576             // previous layout of the child was done without an override height set.
1577             // So, redo it here.
1578             forceChildRelayout = true;
1579         }
1580         updateBlockChildDirtyBitsBeforeLayout(forceChildRelayout, child);
1581         if (!child.needsLayout())
1582             child.markForPaginationRelayoutIfNeeded();
1583         if (child.needsLayout())
1584             m_relaidOutChildren.add(&amp;child);
1585         child.layoutIfNeeded();
1586         if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) {
1587             child.repaint();
1588             child.repaintOverhangingFloats(true);
1589         }
1590 
1591         updateAutoMarginsInMainAxis(child, autoMarginOffset);
1592 
1593         LayoutUnit childCrossAxisMarginBoxExtent;
</pre>
<hr />
<pre>
1796 void RenderFlexibleBox::applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent)
1797 {
1798     if (!hasOrthogonalFlow(child) &amp;&amp; child.style().logicalHeight().isAuto()) {
1799         LayoutUnit stretchedLogicalHeight = std::max(child.borderAndPaddingLogicalHeight(),
1800         lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1801         ASSERT(!child.needsLayout());
1802         LayoutUnit desiredLogicalHeight = child.constrainLogicalHeightByMinMax(stretchedLogicalHeight, cachedChildIntrinsicContentLogicalHeight(child));
1803 
1804         // FIXME: Can avoid laying out here in some cases. See https://webkit.org/b/87905.
1805         bool childNeedsRelayout = desiredLogicalHeight != child.logicalHeight();
1806         if (child.isRenderBlock() &amp;&amp; downcast&lt;RenderBlock&gt;(child).hasPercentHeightDescendants() &amp;&amp; m_relaidOutChildren.contains(&amp;child)) {
1807             // Have to force another relayout even though the child is sized
1808             // correctly, because its descendants are not sized correctly yet. Our
1809             // previous layout of the child was done without an override height set.
1810             // So, redo it here.
1811             childNeedsRelayout = true;
1812         }
1813         if (childNeedsRelayout || !child.hasOverrideContentLogicalHeight())
1814             child.setOverrideContentLogicalHeight(desiredLogicalHeight - child.borderAndPaddingLogicalHeight());
1815         if (childNeedsRelayout) {
<span class="line-modified">1816             child.setLogicalHeight(0_lu);</span>
1817             // We cache the child&#39;s intrinsic content logical height to avoid it being
1818             // reset to the stretched height.
<span class="line-modified">1819             // FIXME: This is fragile. RendertBoxes should be smart enough to</span>
1820             // determine their intrinsic content logical height correctly even when
1821             // there&#39;s an overrideHeight.
1822             LayoutUnit childIntrinsicContentLogicalHeight = cachedChildIntrinsicContentLogicalHeight(child);
1823             child.setChildNeedsLayout(MarkOnlyThis);
1824 
1825             // Don&#39;t use layoutChildIfNeeded to avoid setting cross axis cached size twice.
1826             child.layoutIfNeeded();
1827 
1828             setCachedChildIntrinsicContentLogicalHeight(child, childIntrinsicContentLogicalHeight);
1829         }
1830     } else if (hasOrthogonalFlow(child) &amp;&amp; child.style().logicalWidth().isAuto()) {
1831         LayoutUnit childWidth = std::max(0_lu, lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1832         childWidth = child.constrainLogicalWidthInFragmentByMinMax(childWidth, crossAxisContentExtent(), *this, nullptr);
1833 
1834         if (childWidth != child.logicalWidth()) {
1835             child.setOverrideContentLogicalWidth(childWidth - child.borderAndPaddingLogicalWidth());
1836             child.setChildNeedsLayout(MarkOnlyThis);
1837             child.layoutIfNeeded();
1838         }
1839     }
</pre>
</td>
<td>
<hr />
<pre>
  20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;RenderFlexibleBox.h&quot;
  33 
  34 #include &quot;FlexibleBoxAlgorithm.h&quot;
  35 #include &quot;LayoutRepainter.h&quot;
  36 #include &quot;RenderChildIterator.h&quot;
  37 #include &quot;RenderLayer.h&quot;
  38 #include &quot;RenderLayoutState.h&quot;
  39 #include &quot;RenderView.h&quot;

  40 #include &lt;limits&gt;
  41 #include &lt;wtf/IsoMallocInlines.h&gt;
  42 #include &lt;wtf/MathExtras.h&gt;
<span class="line-added">  43 #include &lt;wtf/SetForScope.h&gt;</span>
  44 
  45 namespace WebCore {
  46 
  47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFlexibleBox);
  48 
  49 struct RenderFlexibleBox::LineContext {
  50     LineContext(LayoutUnit crossAxisOffset, LayoutUnit crossAxisExtent, LayoutUnit maxAscent, Vector&lt;FlexItem&gt;&amp;&amp; flexItems)
  51         : crossAxisOffset(crossAxisOffset)
  52         , crossAxisExtent(crossAxisExtent)
  53         , maxAscent(maxAscent)
  54         , flexItems(flexItems)
  55     {
  56     }
  57 
  58     LayoutUnit crossAxisOffset;
  59     LayoutUnit crossAxisExtent;
  60     LayoutUnit maxAscent;
  61     Vector&lt;FlexItem&gt; flexItems;
  62 };
  63 
</pre>
<hr />
<pre>
 246         // can compute new available cross axis space. This is only necessary for
 247         // stretching since other alignment values don&#39;t change the size of the
 248         // box.
 249         for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
 250             ItemPosition previousAlignment = child.style().resolvedAlignSelf(oldStyle, selfAlignmentNormalBehavior()).position();
 251             if (previousAlignment == ItemPosition::Stretch &amp;&amp; previousAlignment != child.style().resolvedAlignSelf(&amp;style(), selfAlignmentNormalBehavior()).position())
 252                 child.setChildNeedsLayout(MarkOnlyThis);
 253         }
 254     }
 255 }
 256 
 257 void RenderFlexibleBox::layoutBlock(bool relayoutChildren, LayoutUnit)
 258 {
 259     ASSERT(needsLayout());
 260 
 261     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 262         return;
 263 
 264     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 265 
<span class="line-added"> 266     resetLogicalHeightBeforeLayoutIfNeeded();</span>
 267     m_relaidOutChildren.clear();
 268 
 269     bool oldInLayout = m_inLayout;
 270     m_inLayout = true;
 271 
 272     if (recomputeLogicalWidth())
 273         relayoutChildren = true;
 274 
 275     LayoutUnit previousHeight = logicalHeight();
 276     setLogicalHeight(borderAndPaddingLogicalHeight() + scrollbarLogicalHeight());
 277     {
 278         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 279 
 280         preparePaginationBeforeBlockLayout(relayoutChildren);
 281 
 282         m_numberOfInFlowChildrenOnFirstLine = -1;
 283 
 284         beginUpdateScrollInfoAfterLayoutTransaction();
 285 
 286         prepareOrderIteratorAndMargins();
</pre>
<hr />
<pre>
1518         if (childFlexBasis.isIntrinsic() || childMinSize.isIntrinsicOrAuto() || childMaxSize.isIntrinsic())
1519             result = true;
1520     }
1521     return result;
1522 }
1523 
1524 Overflow RenderFlexibleBox::mainAxisOverflowForChild(const RenderBox&amp; child) const
1525 {
1526     if (isHorizontalFlow())
1527         return child.style().overflowX();
1528     return child.style().overflowY();
1529 }
1530 
1531 Overflow RenderFlexibleBox::crossAxisOverflowForChild(const RenderBox&amp; child) const
1532 {
1533     if (isHorizontalFlow())
1534         return child.style().overflowY();
1535     return child.style().overflowX();
1536 }
1537 
<span class="line-added">1538 bool RenderFlexibleBox::hasPercentHeightDescendants(const RenderBox&amp; renderer) const</span>
<span class="line-added">1539 {</span>
<span class="line-added">1540     // FIXME: This function can be removed soon after webkit.org/b/204318 is fixed.</span>
<span class="line-added">1541     if (!is&lt;RenderBlock&gt;(renderer))</span>
<span class="line-added">1542         return false;</span>
<span class="line-added">1543     auto&amp; renderBlock = downcast&lt;RenderBlock&gt;(renderer);</span>
<span class="line-added">1544     if (!renderBlock.hasPercentHeightDescendants())</span>
<span class="line-added">1545         return false;</span>
<span class="line-added">1546 </span>
<span class="line-added">1547     auto* percentHeightDescendants = renderBlock.percentHeightDescendants();</span>
<span class="line-added">1548     if (!percentHeightDescendants)</span>
<span class="line-added">1549         return false;</span>
<span class="line-added">1550 </span>
<span class="line-added">1551     for (auto it = percentHeightDescendants-&gt;begin(), end = percentHeightDescendants-&gt;end(); it != end; ++it) {</span>
<span class="line-added">1552         bool hasOutOfFlowAncestor = false;</span>
<span class="line-added">1553         for (auto* ancestor = (*it)-&gt;containingBlock(); ancestor &amp;&amp; ancestor != &amp;renderBlock; ancestor = ancestor-&gt;containingBlock()) {</span>
<span class="line-added">1554             if (ancestor-&gt;isOutOfFlowPositioned()) {</span>
<span class="line-added">1555                 hasOutOfFlowAncestor = true;</span>
<span class="line-added">1556                 break;</span>
<span class="line-added">1557             }</span>
<span class="line-added">1558         }</span>
<span class="line-added">1559         if (!hasOutOfFlowAncestor)</span>
<span class="line-added">1560             return true;</span>
<span class="line-added">1561     }</span>
<span class="line-added">1562     return false;</span>
<span class="line-added">1563 }</span>
<span class="line-added">1564 </span>
1565 void RenderFlexibleBox::layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp; lineContexts)
1566 {
1567     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehavior());
1568     ContentDistribution distribution = style().resolvedJustifyContentDistribution(contentAlignmentNormalBehavior());
1569 
1570     LayoutUnit autoMarginOffset = autoMarginOffsetInMainAxis(children, availableFreeSpace);
1571     LayoutUnit mainAxisOffset = flowAwareBorderStart() + flowAwarePaddingStart();
1572     mainAxisOffset += initialJustifyContentOffset(availableFreeSpace, position, distribution, children.size());
1573     if (style().flexDirection() == FlexDirection::RowReverse)
1574         mainAxisOffset += isHorizontalFlow() ? verticalScrollbarWidth() : horizontalScrollbarHeight();
1575 
1576     LayoutUnit totalMainExtent = mainAxisExtent();
1577     LayoutUnit maxAscent, maxDescent; // Used when align-items: baseline.
1578     LayoutUnit maxChildCrossAxisExtent;
1579     bool shouldFlipMainAxis = !isColumnFlow() &amp;&amp; !isLeftToRightFlow();
1580     for (size_t i = 0; i &lt; children.size(); ++i) {
1581         const auto&amp; flexItem = children[i];
1582         auto&amp; child = flexItem.box;
1583         bool childHadLayout = child.everHadLayout();
1584 
1585         ASSERT(!flexItem.box.isOutOfFlowPositioned());
1586 
1587         setOverrideMainAxisContentSizeForChild(child, flexItem.flexedContentSize);
1588         // The flexed content size and the override size include the scrollbar
1589         // width, so we need to compare to the size including the scrollbar.
1590         // TODO(cbiesinger): Should it include the scrollbar?
1591         if (flexItem.flexedContentSize != mainAxisContentExtentForChildIncludingScrollbar(child))
1592             child.setChildNeedsLayout(MarkOnlyThis);
1593         else {
1594             // To avoid double applying margin changes in
1595             // updateAutoMarginsInCrossAxis, we reset the margins here.
1596             resetAutoMarginsAndLogicalTopInCrossAxis(child);
1597         }
1598         // We may have already forced relayout for orthogonal flowing children in
1599         // computeInnerFlexBaseSizeForChild.
1600         bool forceChildRelayout = relayoutChildren &amp;&amp; !m_relaidOutChildren.contains(&amp;child);
<span class="line-modified">1601         if (!forceChildRelayout &amp;&amp; hasPercentHeightDescendants(child)) {</span>
1602             // Have to force another relayout even though the child is sized
1603             // correctly, because its descendants are not sized correctly yet. Our
1604             // previous layout of the child was done without an override height set.
1605             // So, redo it here.
1606             forceChildRelayout = true;
1607         }
1608         updateBlockChildDirtyBitsBeforeLayout(forceChildRelayout, child);
1609         if (!child.needsLayout())
1610             child.markForPaginationRelayoutIfNeeded();
1611         if (child.needsLayout())
1612             m_relaidOutChildren.add(&amp;child);
1613         child.layoutIfNeeded();
1614         if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) {
1615             child.repaint();
1616             child.repaintOverhangingFloats(true);
1617         }
1618 
1619         updateAutoMarginsInMainAxis(child, autoMarginOffset);
1620 
1621         LayoutUnit childCrossAxisMarginBoxExtent;
</pre>
<hr />
<pre>
1824 void RenderFlexibleBox::applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent)
1825 {
1826     if (!hasOrthogonalFlow(child) &amp;&amp; child.style().logicalHeight().isAuto()) {
1827         LayoutUnit stretchedLogicalHeight = std::max(child.borderAndPaddingLogicalHeight(),
1828         lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1829         ASSERT(!child.needsLayout());
1830         LayoutUnit desiredLogicalHeight = child.constrainLogicalHeightByMinMax(stretchedLogicalHeight, cachedChildIntrinsicContentLogicalHeight(child));
1831 
1832         // FIXME: Can avoid laying out here in some cases. See https://webkit.org/b/87905.
1833         bool childNeedsRelayout = desiredLogicalHeight != child.logicalHeight();
1834         if (child.isRenderBlock() &amp;&amp; downcast&lt;RenderBlock&gt;(child).hasPercentHeightDescendants() &amp;&amp; m_relaidOutChildren.contains(&amp;child)) {
1835             // Have to force another relayout even though the child is sized
1836             // correctly, because its descendants are not sized correctly yet. Our
1837             // previous layout of the child was done without an override height set.
1838             // So, redo it here.
1839             childNeedsRelayout = true;
1840         }
1841         if (childNeedsRelayout || !child.hasOverrideContentLogicalHeight())
1842             child.setOverrideContentLogicalHeight(desiredLogicalHeight - child.borderAndPaddingLogicalHeight());
1843         if (childNeedsRelayout) {
<span class="line-modified">1844             SetForScope&lt;bool&gt; resetChildLogicalHeight(m_shouldResetChildLogicalHeightBeforeLayout, true);</span>
1845             // We cache the child&#39;s intrinsic content logical height to avoid it being
1846             // reset to the stretched height.
<span class="line-modified">1847             // FIXME: This is fragile. RenderBoxes should be smart enough to</span>
1848             // determine their intrinsic content logical height correctly even when
1849             // there&#39;s an overrideHeight.
1850             LayoutUnit childIntrinsicContentLogicalHeight = cachedChildIntrinsicContentLogicalHeight(child);
1851             child.setChildNeedsLayout(MarkOnlyThis);
1852 
1853             // Don&#39;t use layoutChildIfNeeded to avoid setting cross axis cached size twice.
1854             child.layoutIfNeeded();
1855 
1856             setCachedChildIntrinsicContentLogicalHeight(child, childIntrinsicContentLogicalHeight);
1857         }
1858     } else if (hasOrthogonalFlow(child) &amp;&amp; child.style().logicalWidth().isAuto()) {
1859         LayoutUnit childWidth = std::max(0_lu, lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1860         childWidth = child.constrainLogicalWidthInFragmentByMinMax(childWidth, crossAxisContentExtent(), *this, nullptr);
1861 
1862         if (childWidth != child.logicalWidth()) {
1863             child.setOverrideContentLogicalWidth(childWidth - child.borderAndPaddingLogicalWidth());
1864             child.setChildNeedsLayout(MarkOnlyThis);
1865             child.layoutIfNeeded();
1866         }
1867     }
</pre>
</td>
</tr>
</table>
<center><a href="RenderEmbeddedObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFlexibleBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
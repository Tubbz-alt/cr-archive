<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/xml/XPathFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005 Frerich Raabe &lt;raabe@kde.org&gt;
  3  * Copyright (C) 2006, 2009, 2013 Apple Inc. All rights reserved.
  4  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1. Redistributions of source code must retain the above copyright
 11  *    notice, this list of conditions and the following disclaimer.
 12  * 2. Redistributions in binary form must reproduce the above copyright
 13  *    notice, this list of conditions and the following disclaimer in the
 14  *    documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR
 17  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 18  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 19  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 20  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 21  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 25  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;XPathFunctions.h&quot;
 30 
 31 #include &quot;Element.h&quot;
 32 #include &quot;ProcessingInstruction.h&quot;
 33 #include &quot;TreeScope.h&quot;
 34 #include &quot;XMLNames.h&quot;
 35 #include &quot;XPathUtil.h&quot;
 36 #include &lt;wtf/MathExtras.h&gt;
 37 #include &lt;wtf/NeverDestroyed.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 namespace XPath {
 42 
 43 static inline bool isWhitespace(UChar c)
 44 {
 45     return c == &#39; &#39; || c == &#39;\n&#39; || c == &#39;\r&#39; || c == &#39;\t&#39;;
 46 }
 47 
 48 #define DEFINE_FUNCTION_CREATOR(Suffix) static std::unique_ptr&lt;Function&gt; createFunction##Suffix() { return makeUnique&lt;Fun##Suffix&gt;(); }
 49 
 50 class Interval {
 51 public:
 52     static const int Inf = -1;
 53 
 54     Interval();
 55     Interval(int value);
 56     Interval(int min, int max);
 57 
 58     bool contains(int value) const;
 59 
 60 private:
 61     int m_min;
 62     int m_max;
 63 };
 64 
 65 class FunLast final : public Function {
 66     Value evaluate() const override;
 67     Value::Type resultType() const override { return Value::NumberValue; }
 68 public:
 69     FunLast() { setIsContextSizeSensitive(true); }
 70 };
 71 
 72 class FunPosition final : public Function {
 73     Value evaluate() const override;
 74     Value::Type resultType() const override { return Value::NumberValue; }
 75 public:
 76     FunPosition() { setIsContextPositionSensitive(true); }
 77 };
 78 
 79 class FunCount final : public Function {
 80     Value evaluate() const override;
 81     Value::Type resultType() const override { return Value::NumberValue; }
 82 };
 83 
 84 class FunId final : public Function {
 85     Value evaluate() const override;
 86     Value::Type resultType() const override { return Value::NodeSetValue; }
 87 };
 88 
 89 class FunLocalName final : public Function {
 90     Value evaluate() const override;
 91     Value::Type resultType() const override { return Value::StringValue; }
 92 public:
 93     FunLocalName() { setIsContextNodeSensitive(true); } // local-name() with no arguments uses context node.
 94 };
 95 
 96 class FunNamespaceURI final : public Function {
 97     Value evaluate() const override;
 98     Value::Type resultType() const override { return Value::StringValue; }
 99 public:
100     FunNamespaceURI() { setIsContextNodeSensitive(true); } // namespace-uri() with no arguments uses context node.
101 };
102 
103 class FunName final : public Function {
104     Value evaluate() const override;
105     Value::Type resultType() const override { return Value::StringValue; }
106 public:
107     FunName() { setIsContextNodeSensitive(true); } // name() with no arguments uses context node.
108 };
109 
110 class FunString final : public Function {
111     Value evaluate() const override;
112     Value::Type resultType() const override { return Value::StringValue; }
113 public:
114     FunString() { setIsContextNodeSensitive(true); } // string() with no arguments uses context node.
115 };
116 
117 class FunConcat final : public Function {
118     Value evaluate() const override;
119     Value::Type resultType() const override { return Value::StringValue; }
120 };
121 
122 class FunStartsWith final : public Function {
123     Value evaluate() const override;
124     Value::Type resultType() const override { return Value::BooleanValue; }
125 };
126 
127 class FunContains final : public Function {
128     Value evaluate() const override;
129     Value::Type resultType() const override { return Value::BooleanValue; }
130 };
131 
132 class FunSubstringBefore final : public Function {
133     Value evaluate() const override;
134     Value::Type resultType() const override { return Value::StringValue; }
135 };
136 
137 class FunSubstringAfter final : public Function {
138     Value evaluate() const override;
139     Value::Type resultType() const override { return Value::StringValue; }
140 };
141 
142 class FunSubstring final : public Function {
143     Value evaluate() const override;
144     Value::Type resultType() const override { return Value::StringValue; }
145 };
146 
147 class FunStringLength final : public Function {
148     Value evaluate() const override;
149     Value::Type resultType() const override { return Value::NumberValue; }
150 public:
151     FunStringLength() { setIsContextNodeSensitive(true); } // string-length() with no arguments uses context node.
152 };
153 
154 class FunNormalizeSpace final : public Function {
155     Value evaluate() const override;
156     Value::Type resultType() const override { return Value::StringValue; }
157 public:
158     FunNormalizeSpace() { setIsContextNodeSensitive(true); } // normalize-space() with no arguments uses context node.
159 };
160 
161 class FunTranslate final : public Function {
162     Value evaluate() const override;
163     Value::Type resultType() const override { return Value::StringValue; }
164 };
165 
166 class FunBoolean final : public Function {
167     Value evaluate() const override;
168     Value::Type resultType() const override { return Value::BooleanValue; }
169 };
170 
171 class FunNot : public Function {
172     Value evaluate() const override;
173     Value::Type resultType() const override { return Value::BooleanValue; }
174 };
175 
176 class FunTrue final : public Function {
177     Value evaluate() const override;
178     Value::Type resultType() const override { return Value::BooleanValue; }
179 };
180 
181 class FunFalse final : public Function {
182     Value evaluate() const override;
183     Value::Type resultType() const override { return Value::BooleanValue; }
184 };
185 
186 class FunLang final : public Function {
187     Value evaluate() const override;
188     Value::Type resultType() const override { return Value::BooleanValue; }
189 public:
190     FunLang() { setIsContextNodeSensitive(true); } // lang() always works on context node.
191 };
192 
193 class FunNumber final : public Function {
194     Value evaluate() const override;
195     Value::Type resultType() const override { return Value::NumberValue; }
196 public:
197     FunNumber() { setIsContextNodeSensitive(true); } // number() with no arguments uses context node.
198 };
199 
200 class FunSum final : public Function {
201     Value evaluate() const override;
202     Value::Type resultType() const override { return Value::NumberValue; }
203 };
204 
205 class FunFloor final : public Function {
206     Value evaluate() const override;
207     Value::Type resultType() const override { return Value::NumberValue; }
208 };
209 
210 class FunCeiling final : public Function {
211     Value evaluate() const override;
212     Value::Type resultType() const override { return Value::NumberValue; }
213 };
214 
215 class FunRound final : public Function {
216     Value evaluate() const override;
217     Value::Type resultType() const override { return Value::NumberValue; }
218 public:
219     static double round(double);
220 };
221 
222 DEFINE_FUNCTION_CREATOR(Last)
223 DEFINE_FUNCTION_CREATOR(Position)
224 DEFINE_FUNCTION_CREATOR(Count)
225 DEFINE_FUNCTION_CREATOR(Id)
226 DEFINE_FUNCTION_CREATOR(LocalName)
227 DEFINE_FUNCTION_CREATOR(NamespaceURI)
228 DEFINE_FUNCTION_CREATOR(Name)
229 
230 DEFINE_FUNCTION_CREATOR(String)
231 DEFINE_FUNCTION_CREATOR(Concat)
232 DEFINE_FUNCTION_CREATOR(StartsWith)
233 DEFINE_FUNCTION_CREATOR(Contains)
234 DEFINE_FUNCTION_CREATOR(SubstringBefore)
235 DEFINE_FUNCTION_CREATOR(SubstringAfter)
236 DEFINE_FUNCTION_CREATOR(Substring)
237 DEFINE_FUNCTION_CREATOR(StringLength)
238 DEFINE_FUNCTION_CREATOR(NormalizeSpace)
239 DEFINE_FUNCTION_CREATOR(Translate)
240 
241 DEFINE_FUNCTION_CREATOR(Boolean)
242 DEFINE_FUNCTION_CREATOR(Not)
243 DEFINE_FUNCTION_CREATOR(True)
244 DEFINE_FUNCTION_CREATOR(False)
245 DEFINE_FUNCTION_CREATOR(Lang)
246 
247 DEFINE_FUNCTION_CREATOR(Number)
248 DEFINE_FUNCTION_CREATOR(Sum)
249 DEFINE_FUNCTION_CREATOR(Floor)
250 DEFINE_FUNCTION_CREATOR(Ceiling)
251 DEFINE_FUNCTION_CREATOR(Round)
252 
253 #undef DEFINE_FUNCTION_CREATOR
254 
255 inline Interval::Interval()
256     : m_min(Inf), m_max(Inf)
257 {
258 }
259 
260 inline Interval::Interval(int value)
261     : m_min(value), m_max(value)
262 {
263 }
264 
265 inline Interval::Interval(int min, int max)
266     : m_min(min), m_max(max)
267 {
268 }
269 
270 inline bool Interval::contains(int value) const
271 {
272     if (m_min == Inf &amp;&amp; m_max == Inf)
273         return true;
274 
275     if (m_min == Inf)
276         return value &lt;= m_max;
277 
278     if (m_max == Inf)
279         return value &gt;= m_min;
280 
281     return value &gt;= m_min &amp;&amp; value &lt;= m_max;
282 }
283 
284 void Function::setArguments(const String&amp; name, Vector&lt;std::unique_ptr&lt;Expression&gt;&gt; arguments)
285 {
286     ASSERT(!subexpressionCount());
287 
288     // Functions that use the context node as an implicit argument are context node sensitive when they
289     // have no arguments, but when explicit arguments are added, they are no longer context node sensitive.
290     // As of this writing, the only exception to this is the &quot;lang&quot; function.
291     if (name != &quot;lang&quot; &amp;&amp; !arguments.isEmpty())
292         setIsContextNodeSensitive(false);
293 
294     setSubexpressions(WTFMove(arguments));
295 }
296 
297 Value FunLast::evaluate() const
298 {
299     return Expression::evaluationContext().size;
300 }
301 
302 Value FunPosition::evaluate() const
303 {
304     return Expression::evaluationContext().position;
305 }
306 
<a name="1" id="anc1"></a><span class="line-modified">307 // FIXME: Should StringBuilder offer this as a member function?</span>
<span class="line-added">308 static StringView toStringView(StringBuilder&amp; builder)</span>
309 {
<a name="2" id="anc2"></a>

310     if (builder.is8Bit())
<a name="3" id="anc3"></a><span class="line-modified">311         return { builder.characters8(), builder.length() };</span>
<span class="line-modified">312     return { builder.characters16(), builder.length() };</span>
313 }
314 
315 Value FunId::evaluate() const
316 {
317     Value a = argument(0).evaluate();
318     StringBuilder idList; // A whitespace-separated list of IDs
319 
320     if (!a.isNodeSet())
321         idList.append(a.toString());
322     else {
323         for (auto&amp; node : a.toNodeSet()) {
324             idList.append(stringValue(node.get()));
325             idList.append(&#39; &#39;);
326         }
327     }
328 
329     TreeScope&amp; contextScope = evaluationContext().node-&gt;treeScope();
330     NodeSet result;
331     HashSet&lt;Node*&gt; resultSet;
332 
333     unsigned startPos = 0;
334     unsigned length = idList.length();
335     while (true) {
336         while (startPos &lt; length &amp;&amp; isWhitespace(idList[startPos]))
337             ++startPos;
338 
339         if (startPos == length)
340             break;
341 
342         size_t endPos = startPos;
343         while (endPos &lt; length &amp;&amp; !isWhitespace(idList[endPos]))
344             ++endPos;
345 
346         // If there are several nodes with the same id, id() should return the first one.
347         // In WebKit, getElementById behaves so, too, although its behavior in this case is formally undefined.
<a name="4" id="anc4"></a><span class="line-modified">348         Node* node = contextScope.getElementById(toStringView(idList).substring(startPos, endPos - startPos));</span>
349         if (node &amp;&amp; resultSet.add(node).isNewEntry)
350             result.append(node);
351 
352         startPos = endPos;
353     }
354 
355     result.markSorted(false);
356 
357     return Value(WTFMove(result));
358 }
359 
360 static inline String expandedNameLocalPart(Node* node)
361 {
362     if (is&lt;ProcessingInstruction&gt;(*node))
363         return downcast&lt;ProcessingInstruction&gt;(*node).target();
364     return node-&gt;localName().string();
365 }
366 
367 static inline String expandedName(Node* node)
368 {
369     const AtomString&amp; prefix = node-&gt;prefix();
370     return prefix.isEmpty() ? expandedNameLocalPart(node) : prefix + &quot;:&quot; + expandedNameLocalPart(node);
371 }
372 
373 Value FunLocalName::evaluate() const
374 {
375     if (argumentCount() &gt; 0) {
376         Value a = argument(0).evaluate();
377         if (!a.isNodeSet())
378             return emptyString();
379 
380         Node* node = a.toNodeSet().firstNode();
381         return node ? expandedNameLocalPart(node) : emptyString();
382     }
383 
384     return expandedNameLocalPart(evaluationContext().node.get());
385 }
386 
387 Value FunNamespaceURI::evaluate() const
388 {
389     if (argumentCount() &gt; 0) {
390         Value a = argument(0).evaluate();
391         if (!a.isNodeSet())
392             return emptyString();
393 
394         Node* node = a.toNodeSet().firstNode();
395         return node ? node-&gt;namespaceURI().string() : emptyString();
396     }
397 
398     return evaluationContext().node-&gt;namespaceURI().string();
399 }
400 
401 Value FunName::evaluate() const
402 {
403     if (argumentCount() &gt; 0) {
404         Value a = argument(0).evaluate();
405         if (!a.isNodeSet())
406             return emptyString();
407 
408         Node* node = a.toNodeSet().firstNode();
409         return node ? expandedName(node) : emptyString();
410     }
411 
412     return expandedName(evaluationContext().node.get());
413 }
414 
415 Value FunCount::evaluate() const
416 {
417     Value a = argument(0).evaluate();
418 
419     return double(a.toNodeSet().size());
420 }
421 
422 Value FunString::evaluate() const
423 {
424     if (!argumentCount())
425         return Value(Expression::evaluationContext().node.get()).toString();
426     return argument(0).evaluate().toString();
427 }
428 
429 Value FunConcat::evaluate() const
430 {
431     StringBuilder result;
432     result.reserveCapacity(1024);
433 
434     for (unsigned i = 0, count = argumentCount(); i &lt; count; ++i) {
435         String str(argument(i).evaluate().toString());
436         result.append(str);
437     }
438 
439     return result.toString();
440 }
441 
442 Value FunStartsWith::evaluate() const
443 {
444     String s1 = argument(0).evaluate().toString();
445     String s2 = argument(1).evaluate().toString();
446 
447     if (s2.isEmpty())
448         return true;
449 
450     return s1.startsWith(s2);
451 }
452 
453 Value FunContains::evaluate() const
454 {
455     String s1 = argument(0).evaluate().toString();
456     String s2 = argument(1).evaluate().toString();
457 
458     if (s2.isEmpty())
459         return true;
460 
461     return s1.contains(s2) != 0;
462 }
463 
464 Value FunSubstringBefore::evaluate() const
465 {
466     String s1 = argument(0).evaluate().toString();
467     String s2 = argument(1).evaluate().toString();
468 
469     if (s2.isEmpty())
470         return emptyString();
471 
472     size_t i = s1.find(s2);
473 
474     if (i == notFound)
475         return emptyString();
476 
477     return s1.left(i);
478 }
479 
480 Value FunSubstringAfter::evaluate() const
481 {
482     String s1 = argument(0).evaluate().toString();
483     String s2 = argument(1).evaluate().toString();
484 
485     size_t i = s1.find(s2);
486     if (i == notFound)
487         return emptyString();
488 
489     return s1.substring(i + s2.length());
490 }
491 
492 Value FunSubstring::evaluate() const
493 {
494     String s = argument(0).evaluate().toString();
495     double doublePos = argument(1).evaluate().toNumber();
496     if (std::isnan(doublePos))
497         return emptyString();
498     long pos = static_cast&lt;long&gt;(FunRound::round(doublePos));
499     bool haveLength = argumentCount() == 3;
500     long len = -1;
501     if (haveLength) {
502         double doubleLen = argument(2).evaluate().toNumber();
503         if (std::isnan(doubleLen))
504             return emptyString();
505         len = static_cast&lt;long&gt;(FunRound::round(doubleLen));
506     }
507 
508     if (pos &gt; long(s.length()))
509         return emptyString();
510 
511     if (pos &lt; 1) {
512         if (haveLength) {
513             len -= 1 - pos;
514             if (len &lt; 1)
515                 return emptyString();
516         }
517         pos = 1;
518     }
519 
520     return s.substring(pos - 1, len);
521 }
522 
523 Value FunStringLength::evaluate() const
524 {
525     if (!argumentCount())
526         return Value(Expression::evaluationContext().node.get()).toString().length();
527     return argument(0).evaluate().toString().length();
528 }
529 
530 Value FunNormalizeSpace::evaluate() const
531 {
532     if (!argumentCount()) {
533         String s = Value(Expression::evaluationContext().node.get()).toString();
534         return s.simplifyWhiteSpace();
535     }
536 
537     String s = argument(0).evaluate().toString();
538     return s.simplifyWhiteSpace();
539 }
540 
541 Value FunTranslate::evaluate() const
542 {
543     String s1 = argument(0).evaluate().toString();
544     String s2 = argument(1).evaluate().toString();
545     String s3 = argument(2).evaluate().toString();
546     StringBuilder result;
547 
548     for (unsigned i1 = 0; i1 &lt; s1.length(); ++i1) {
549         UChar ch = s1[i1];
550         size_t i2 = s2.find(ch);
551 
552         if (i2 == notFound)
553             result.append(ch);
554         else if (i2 &lt; s3.length())
555             result.append(s3[i2]);
556     }
557 
558     return result.toString();
559 }
560 
561 Value FunBoolean::evaluate() const
562 {
563     return argument(0).evaluate().toBoolean();
564 }
565 
566 Value FunNot::evaluate() const
567 {
568     return !argument(0).evaluate().toBoolean();
569 }
570 
571 Value FunTrue::evaluate() const
572 {
573     return true;
574 }
575 
576 Value FunLang::evaluate() const
577 {
578     String lang = argument(0).evaluate().toString();
579 
580     const Attribute* languageAttribute = nullptr;
581     Node* node = evaluationContext().node.get();
582     while (node) {
583         if (is&lt;Element&gt;(*node)) {
584             Element&amp; element = downcast&lt;Element&gt;(*node);
585             if (element.hasAttributes())
586                 languageAttribute = element.findAttributeByName(XMLNames::langAttr);
587         }
588         if (languageAttribute)
589             break;
590         node = node-&gt;parentNode();
591     }
592 
593     if (!languageAttribute)
594         return false;
595 
596     String langValue = languageAttribute-&gt;value();
597     while (true) {
598         if (equalIgnoringASCIICase(langValue, lang))
599             return true;
600 
601         // Remove suffixes one by one.
602         size_t index = langValue.reverseFind(&#39;-&#39;);
603         if (index == notFound)
604             break;
605         langValue = langValue.left(index);
606     }
607 
608     return false;
609 }
610 
611 Value FunFalse::evaluate() const
612 {
613     return false;
614 }
615 
616 Value FunNumber::evaluate() const
617 {
618     if (!argumentCount())
619         return Value(Expression::evaluationContext().node.get()).toNumber();
620     return argument(0).evaluate().toNumber();
621 }
622 
623 Value FunSum::evaluate() const
624 {
625     Value a = argument(0).evaluate();
626     if (!a.isNodeSet())
627         return 0.0;
628 
629     double sum = 0.0;
630     const NodeSet&amp; nodes = a.toNodeSet();
631     // To be really compliant, we should sort the node-set, as floating point addition is not associative.
632     // However, this is unlikely to ever become a practical issue, and sorting is slow.
633 
634     for (auto&amp; node : nodes)
635         sum += Value(stringValue(node.get())).toNumber();
636 
637     return sum;
638 }
639 
640 Value FunFloor::evaluate() const
641 {
642     return floor(argument(0).evaluate().toNumber());
643 }
644 
645 Value FunCeiling::evaluate() const
646 {
647     return ceil(argument(0).evaluate().toNumber());
648 }
649 
650 double FunRound::round(double val)
651 {
652     if (!std::isnan(val) &amp;&amp; !std::isinf(val)) {
653         if (std::signbit(val) &amp;&amp; val &gt;= -0.5)
654             val *= 0; // negative zero
655         else
656             val = floor(val + 0.5);
657     }
658     return val;
659 }
660 
661 Value FunRound::evaluate() const
662 {
663     return round(argument(0).evaluate().toNumber());
664 }
665 
666 struct FunctionMapValue {
667     std::unique_ptr&lt;Function&gt; (*creationFunction)();
668     Interval argumentCountInterval;
669 };
670 
671 static HashMap&lt;String, FunctionMapValue&gt; createFunctionMap()
672 {
673     struct FunctionMapping {
674         const char* name;
675         FunctionMapValue function;
676     };
677 
678     static const FunctionMapping functions[] = {
679         { &quot;boolean&quot;, { createFunctionBoolean, 1 } },
680         { &quot;ceiling&quot;, { createFunctionCeiling, 1 } },
681         { &quot;concat&quot;, { createFunctionConcat, Interval(2, Interval::Inf) } },
682         { &quot;contains&quot;, { createFunctionContains, 2 } },
683         { &quot;count&quot;, { createFunctionCount, 1 } },
684         { &quot;false&quot;, { createFunctionFalse, 0 } },
685         { &quot;floor&quot;, { createFunctionFloor, 1 } },
686         { &quot;id&quot;, { createFunctionId, 1 } },
687         { &quot;lang&quot;, { createFunctionLang, 1 } },
688         { &quot;last&quot;, { createFunctionLast, 0 } },
689         { &quot;local-name&quot;, { createFunctionLocalName, Interval(0, 1) } },
690         { &quot;name&quot;, { createFunctionName, Interval(0, 1) } },
691         { &quot;namespace-uri&quot;, { createFunctionNamespaceURI, Interval(0, 1) } },
692         { &quot;normalize-space&quot;, { createFunctionNormalizeSpace, Interval(0, 1) } },
693         { &quot;not&quot;, { createFunctionNot, 1 } },
694         { &quot;number&quot;, { createFunctionNumber, Interval(0, 1) } },
695         { &quot;position&quot;, { createFunctionPosition, 0 } },
696         { &quot;round&quot;, { createFunctionRound, 1 } },
697         { &quot;starts-with&quot;, { createFunctionStartsWith, 2 } },
698         { &quot;string&quot;, { createFunctionString, Interval(0, 1) } },
699         { &quot;string-length&quot;, { createFunctionStringLength, Interval(0, 1) } },
700         { &quot;substring&quot;, { createFunctionSubstring, Interval(2, 3) } },
701         { &quot;substring-after&quot;, { createFunctionSubstringAfter, 2 } },
702         { &quot;substring-before&quot;, { createFunctionSubstringBefore, 2 } },
703         { &quot;sum&quot;, { createFunctionSum, 1 } },
704         { &quot;translate&quot;, { createFunctionTranslate, 3 } },
705         { &quot;true&quot;, { createFunctionTrue, 0 } },
706     };
707 
708     HashMap&lt;String, FunctionMapValue&gt; map;
709     for (auto&amp; function : functions)
710         map.add(function.name, function.function);
711     return map;
712 }
713 
714 std::unique_ptr&lt;Function&gt; Function::create(const String&amp; name, unsigned numArguments)
715 {
716     static const auto functionMap = makeNeverDestroyed(createFunctionMap());
717 
718     auto it = functionMap.get().find(name);
719     if (it == functionMap.get().end())
720         return nullptr;
721 
722     if (!it-&gt;value.argumentCountInterval.contains(numArguments))
723         return nullptr;
724 
725     return it-&gt;value.creationFunction();
726 }
727 
728 std::unique_ptr&lt;Function&gt; Function::create(const String&amp; name)
729 {
730     return create(name, 0);
731 }
732 
733 std::unique_ptr&lt;Function&gt; Function::create(const String&amp; name, Vector&lt;std::unique_ptr&lt;Expression&gt;&gt; arguments)
734 {
735     auto function = create(name, arguments.size());
736     if (function)
737         function-&gt;setArguments(name, WTFMove(arguments));
738     return function;
739 }
740 
741 }
742 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
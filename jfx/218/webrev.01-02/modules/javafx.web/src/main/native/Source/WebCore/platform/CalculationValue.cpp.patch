diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/CalculationValue.cpp
@@ -53,11 +53,11 @@
     ts << TextStream::FormatNumberRespectingIntegers(m_value);
 }
 
 bool CalcExpressionNumber::operator==(const CalcExpressionNode& other) const
 {
-    return other.type() == CalcExpressionNodeType::Number && *this == toCalcExpressionNumber(other);
+    return is<CalcExpressionNumber>(other) && *this == downcast<CalcExpressionNumber>(other);
 }
 
 float CalculationValue::evaluate(float maxValue) const
 {
     float result = m_expression->evaluate(maxValue);
@@ -66,32 +66,78 @@
     if (std::isnan(result))
         return 0;
     return m_shouldClampToNonNegative && result < 0 ? 0 : result;
 }
 
+float CalcExpressionNegation::evaluate(float maxValue) const
+{
+    return -m_child->evaluate(maxValue);
+}
+
+bool CalcExpressionNegation::operator==(const CalcExpressionNode& other) const
+{
+    return is<CalcExpressionNegation>(other) && *this == downcast<CalcExpressionNegation>(other);
+}
+
+void CalcExpressionNegation::dump(TextStream& ts) const
+{
+    ts << "-(";
+    ts << *m_child;
+    ts << ")";
+}
+
+bool operator==(const CalcExpressionNegation& a, const CalcExpressionNegation& b)
+{
+    return *a.child() == *b.child();
+}
+
+float CalcExpressionInversion::evaluate(float maxValue) const
+{
+    return 1.0f / m_child->evaluate(maxValue);
+}
+
+void CalcExpressionInversion::dump(TextStream& ts) const
+{
+    ts << "1.0 / " << "(";
+    ts << *m_child;
+    ts << ")";
+}
+
+bool CalcExpressionInversion::operator==(const CalcExpressionNode& other) const
+{
+    return is<CalcExpressionInversion>(other) && *this == downcast<CalcExpressionInversion>(other);
+}
+
+bool operator==(const CalcExpressionInversion& a, const CalcExpressionInversion& b)
+{
+    return *a.child() == *b.child();
+}
+
 float CalcExpressionOperation::evaluate(float maxValue) const
 {
     switch (m_operator) {
     case CalcOperator::Add: {
-        ASSERT(m_children.size() == 2);
-        float left = m_children[0]->evaluate(maxValue);
-        float right = m_children[1]->evaluate(maxValue);
-        return left + right;
+        float sum = 0;
+        for (auto& child : m_children)
+            sum += child->evaluate(maxValue);
+        return sum;
     }
     case CalcOperator::Subtract: {
+        // FIXME
         ASSERT(m_children.size() == 2);
         float left = m_children[0]->evaluate(maxValue);
         float right = m_children[1]->evaluate(maxValue);
         return left - right;
     }
     case CalcOperator::Multiply: {
-        ASSERT(m_children.size() == 2);
-        float left = m_children[0]->evaluate(maxValue);
-        float right = m_children[1]->evaluate(maxValue);
-        return left * right;
+        float product = 1;
+        for (auto& child : m_children)
+            product *= child->evaluate(maxValue);
+        return product;
     }
     case CalcOperator::Divide: {
+        // FIXME
         ASSERT(m_children.size() == 1 || m_children.size() == 2);
         if (m_children.size() == 1)
             return std::numeric_limits<float>::quiet_NaN();
         float left = m_children[0]->evaluate(maxValue);
         float right = m_children[1]->evaluate(maxValue);
@@ -111,18 +157,27 @@
         float maximum = m_children[0]->evaluate(maxValue);
         for (auto& child : m_children)
             maximum = std::max(maximum, child->evaluate(maxValue));
         return maximum;
     }
+    case CalcOperator::Clamp: {
+        if (m_children.size() != 3)
+            return std::numeric_limits<float>::quiet_NaN();
+
+        float min = m_children[0]->evaluate(maxValue);
+        float value = m_children[1]->evaluate(maxValue);
+        float max = m_children[2]->evaluate(maxValue);
+        return std::max(min, std::min(value, max));
+    }
     }
     ASSERT_NOT_REACHED();
     return std::numeric_limits<float>::quiet_NaN();
 }
 
 bool CalcExpressionOperation::operator==(const CalcExpressionNode& other) const
 {
-    return other.type() == CalcExpressionNodeType::Operation && *this == toCalcExpressionOperation(other);
+    return is<CalcExpressionOperation>(other) && *this == downcast<CalcExpressionOperation>(other);
 }
 
 bool operator==(const CalcExpressionOperation& a, const CalcExpressionOperation& b)
 {
     if (a.getOperator() != b.getOperator())
@@ -157,11 +212,11 @@
     return floatValueForLength(m_length, maxValue);
 }
 
 bool CalcExpressionLength::operator==(const CalcExpressionNode& other) const
 {
-    return other.type() == CalcExpressionNodeType::Length && *this == toCalcExpressionLength(other);
+    return is<CalcExpressionLength>(other) && *this == downcast<CalcExpressionLength>(other);
 }
 
 void CalcExpressionLength::dump(TextStream& ts) const
 {
     ts << m_length;
@@ -174,23 +229,23 @@
     , m_progress(progress)
 {
     // Flatten nesting of CalcExpressionBlendLength as a speculative fix for rdar://problem/30533005.
     // CalcExpressionBlendLength is only used as a result of animation and they don't nest in normal cases.
     if (m_from.isCalculated() && m_from.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
-        m_from = toCalcExpressionBlendLength(m_from.calculationValue().expression()).from();
+        m_from = downcast<CalcExpressionBlendLength>(m_from.calculationValue().expression()).from();
     if (m_to.isCalculated() && m_to.calculationValue().expression().type() == CalcExpressionNodeType::BlendLength)
-        m_to = toCalcExpressionBlendLength(m_to.calculationValue().expression()).to();
+        m_to = downcast<CalcExpressionBlendLength>(m_to.calculationValue().expression()).to();
 }
 
 float CalcExpressionBlendLength::evaluate(float maxValue) const
 {
     return (1.0f - m_progress) * floatValueForLength(m_from, maxValue) + m_progress * floatValueForLength(m_to, maxValue);
 }
 
 bool CalcExpressionBlendLength::operator==(const CalcExpressionNode& other) const
 {
-    return other.type() == CalcExpressionNodeType::BlendLength && *this == toCalcExpressionBlendLength(other);
+    return is<CalcExpressionBlendLength>(other) && *this == downcast<CalcExpressionBlendLength>(other);
 }
 
 void CalcExpressionBlendLength::dump(TextStream& ts) const
 {
     ts << "blend(" << m_from << ", " << m_to << ", " << m_progress << ")";
@@ -201,12 +256,13 @@
     switch (op) {
     case CalcOperator::Add: ts << "+"; break;
     case CalcOperator::Subtract: ts << "-"; break;
     case CalcOperator::Multiply: ts << "*"; break;
     case CalcOperator::Divide: ts << "/"; break;
-    case CalcOperator::Min: ts << "max"; break;
-    case CalcOperator::Max: ts << "min"; break;
+    case CalcOperator::Min: ts << "min"; break;
+    case CalcOperator::Max: ts << "max"; break;
+    case CalcOperator::Clamp: ts << "clamp"; break;
     }
     return ts;
 }
 
 TextStream& operator<<(TextStream& ts, const CalculationValue& value)

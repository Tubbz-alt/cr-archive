<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ContainerNode.h&quot;
 25 #include &quot;LoadableScript.h&quot;
 26 #include &quot;ReferrerPolicy.h&quot;
 27 #include &quot;UserGestureIndicator.h&quot;
 28 #include &lt;wtf/MonotonicTime.h&gt;
 29 #include &lt;wtf/text/TextPosition.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class CachedScript;
 34 class ContainerNode;
 35 class Element;
 36 class LoadableModuleScript;
 37 class PendingScript;
 38 class ScriptSourceCode;
 39 
 40 class ScriptElement {
 41 public:
 42     virtual ~ScriptElement() = default;
 43 
 44     Element&amp; element() { return m_element; }
 45     const Element&amp; element() const { return m_element; }
 46 
 47     enum LegacyTypeSupport { DisallowLegacyTypeInTypeAttribute, AllowLegacyTypeInTypeAttribute };
 48     bool prepareScript(const TextPosition&amp; scriptStartPosition = TextPosition(), LegacyTypeSupport = DisallowLegacyTypeInTypeAttribute);
 49 
 50     String scriptCharset() const { return m_characterEncoding; }
 51     WEBCORE_EXPORT String scriptContent() const;
 52     void executeClassicScript(const ScriptSourceCode&amp;);
 53     void executeModuleScript(LoadableModuleScript&amp;);
 54 
 55     void executePendingScript(PendingScript&amp;);
 56 
 57     // XML parser calls these
 58     virtual void dispatchLoadEvent() = 0;
 59     virtual void dispatchErrorEvent();
 60 
 61     bool haveFiredLoadEvent() const { return m_haveFiredLoad; }
 62     bool errorOccurred() const { return m_errorOccurred; }
 63     bool willBeParserExecuted() const { return m_willBeParserExecuted; }
 64     bool readyToBeParserExecuted() const { return m_readyToBeParserExecuted; }
 65     bool willExecuteWhenDocumentFinishedParsing() const { return m_willExecuteWhenDocumentFinishedParsing; }
 66     bool willExecuteInOrder() const { return m_willExecuteInOrder; }
 67     LoadableScript* loadableScript() { return m_loadableScript.get(); }
 68 
 69     // https://html.spec.whatwg.org/multipage/scripting.html#concept-script-type
 70     enum class ScriptType { Classic, Module };
 71     ScriptType scriptType() const { return m_isModuleScript ? ScriptType::Module : ScriptType::Classic; }
 72 
 73     void ref();
 74     void deref();
 75 
 76 protected:
 77     ScriptElement(Element&amp;, bool createdByParser, bool isEvaluated);
 78 
 79     void setHaveFiredLoadEvent(bool haveFiredLoad) { m_haveFiredLoad = haveFiredLoad; }
 80     void setErrorOccurred(bool errorOccurred) { m_errorOccurred = errorOccurred; }
 81     bool isParserInserted() const { return m_parserInserted; }
 82     bool alreadyStarted() const { return m_alreadyStarted; }
 83     bool forceAsync() const { return m_forceAsync; }
 84 
 85     // Helper functions used by our parent classes.
 86     Node::InsertedIntoAncestorResult insertedIntoAncestor(Node::InsertionType insertionType, ContainerNode&amp;) const
 87     {
 88         if (insertionType.connectedToDocument &amp;&amp; !m_parserInserted)
 89             return Node::InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 90         return Node::InsertedIntoAncestorResult::Done;
 91     }
 92 
 93     void didFinishInsertingNode();
 94     void childrenChanged(const ContainerNode::ChildChange&amp;);
 95     void handleSourceAttribute(const String&amp; sourceURL);
 96     void handleAsyncAttribute();
 97 
 98 private:
 99     void executeScriptAndDispatchEvent(LoadableScript&amp;);
100 
101     Optional&lt;ScriptType&gt; determineScriptType(LegacyTypeSupport) const;
102     bool ignoresLoadRequest() const;
103     bool isScriptForEventSupported() const;
104     void dispatchLoadEventRespectingUserGestureIndicator();
105 
106     bool requestClassicScript(const String&amp; sourceURL);
107     bool requestModuleScript(const TextPosition&amp; scriptStartPosition);
108 
109     virtual String sourceAttributeValue() const = 0;
110     virtual String charsetAttributeValue() const = 0;
111     virtual String typeAttributeValue() const = 0;
112     virtual String languageAttributeValue() const = 0;
113     virtual String forAttributeValue() const = 0;
114     virtual String eventAttributeValue() const = 0;
115     virtual bool hasAsyncAttribute() const = 0;
116     virtual bool hasDeferAttribute() const = 0;
117     virtual bool hasSourceAttribute() const = 0;
118     virtual bool hasNoModuleAttribute() const = 0;
119     virtual ReferrerPolicy referrerPolicy() const = 0;
120 
121     Element&amp; m_element;
122     WTF::OrdinalNumber m_startLineNumber;
123     bool m_parserInserted : 1;
124     bool m_isExternalScript : 1;
125     bool m_alreadyStarted : 1;
126     bool m_haveFiredLoad : 1;
127     bool m_errorOccurred : 1;
128     bool m_willBeParserExecuted : 1; // Same as &quot;The parser will handle executing the script.&quot;
129     bool m_readyToBeParserExecuted : 1;
130     bool m_willExecuteWhenDocumentFinishedParsing : 1;
131     bool m_forceAsync : 1;
132     bool m_willExecuteInOrder : 1;
133     bool m_isModuleScript : 1;
134     String m_characterEncoding;
135     String m_fallbackCharacterEncoding;
136     RefPtr&lt;LoadableScript&gt; m_loadableScript;
137 
138     MonotonicTime m_creationTime;
139     RefPtr&lt;UserGestureToken&gt; m_userGestureToken;
140 };
141 
142 // FIXME: replace with is/downcast&lt;ScriptElement&gt;.
143 bool isScriptElement(Element&amp;);
144 ScriptElement&amp; downcastScriptElement(Element&amp;);
145 
146 }
    </pre>
  </body>
</html>
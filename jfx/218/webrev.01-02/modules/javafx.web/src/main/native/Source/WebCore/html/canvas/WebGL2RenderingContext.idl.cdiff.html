<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.idl</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGL2RenderingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLActiveInfo.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGL2RenderingContext.idl</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,17 ***</span>
<span class="line-new-header">--- 49,24 ---</span>
  #else
  typedef (ImageBitmap or ImageData or HTMLImageElement or HTMLCanvasElement) TexImageSource;
  #endif
  
  [
<span class="line-added">+     ActiveDOMObject,</span>
      Conditional=WEBGL2,
      EnabledAtRuntime=WebGL2,
      JSCustomMarkFunction,
      JSGenerateToJSObject,
      DoNotCheckConstants,
      CallTracingCallback=recordCanvasAction,
  ] interface WebGL2RenderingContext {
<span class="line-added">+ </span>
<span class="line-added">+     // The specification splits the API surface into a WebGL2RenderingContextBase</span>
<span class="line-added">+     // and a WebGL2RenderingContext, but we merge both into one class.</span>
<span class="line-added">+ </span>
<span class="line-added">+     // WebGLRenderingContextBase contents.</span>
<span class="line-added">+ </span>
      const GLenum READ_BUFFER                                   = 0x0C02;
      const GLenum UNPACK_ROW_LENGTH                             = 0x0CF2;
      const GLenum UNPACK_SKIP_ROWS                              = 0x0CF3;
      const GLenum UNPACK_SKIP_PIXELS                            = 0x0CF4;
      const GLenum PACK_ROW_LENGTH                               = 0x0D02;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,77 ***</span>
      const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
      const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;
  
      const GLint64 TIMEOUT_IGNORED                              = -1;
  
<span class="line-modified">!     /* WebGL-specific enums */</span>
      const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;
  
<span class="line-modified">!     /* Buffer objects */</span>
      void bufferData(GLenum target, ArrayBufferView data, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
      void bufferSubData(GLenum target, GLintptr dstByteOffset, ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
  
      void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
<span class="line-removed">-     // MapBufferRange, in particular its read-only and write-only modes,</span>
<span class="line-removed">-     // can not be exposed safely to JavaScript. GetBufferSubData</span>
<span class="line-removed">-     // replaces it for the purpose of fetching data back from the GPU.</span>
      void getBufferSubData(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstData, optional GLuint dstOffset = 0, optional GLuint length = 0);
  
<span class="line-modified">!     /* Framebuffer objects */</span>
      void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
      void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer);
      void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
      void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
      void readBuffer(GLenum src);
  
<span class="line-modified">!     /* Renderbuffer objects */</span>
      [OverrideIDLType=IDLWebGLAny] any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
      void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
  
<span class="line-modified">!     /* Texture objects */</span>
      void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
      void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
  
<span class="line-removed">-     // WebGL1 legacy entrypoints:</span>
<span class="line-removed">-     void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);</span>
<span class="line-removed">-     [MayThrowException] void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, TexImageSource? source);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView? pixels);</span>
<span class="line-removed">-     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLenum format, GLenum type, TexImageSource? source);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // WebGL2 entrypoints:</span>
<span class="line-removed">-     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-removed">-     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-removed">-     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-removed">- </span>
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexImageSource source);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
  
<span class="line-removed">-     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-removed">-     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-removed">-     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-removed">- </span>
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr pboOffset);
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexImageSource source);
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? srcData, optional GLuint srcOffset = 0);
  
      void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  
<span class="line-removed">-     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);</span>
<span class="line-removed">-     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);</span>
<span class="line-removed">- </span>
      void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
      void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
      void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset);
      void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
  
<span class="line-modified">!     /* Programs and shaders */</span>
      GLint getFragDataLocation(WebGLProgram program, DOMString name);
  
<span class="line-modified">!     /* Uniforms and attributes */</span>
      void uniform1ui(WebGLUniformLocation? location, GLuint v0);
      void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
      void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
      void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
      void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
<span class="line-new-header">--- 329,55 ---</span>
      const GLenum MAX_ELEMENT_INDEX                             = 0x8D6B;
      const GLenum TEXTURE_IMMUTABLE_LEVELS                      = 0x82DF;
  
      const GLint64 TIMEOUT_IGNORED                              = -1;
  
<span class="line-modified">!     // WebGL-specific enums/</span>
      const GLenum MAX_CLIENT_WAIT_TIMEOUT_WEBGL                 = 0x9247;
  
<span class="line-modified">!     // Buffer objects.</span>
      void bufferData(GLenum target, ArrayBufferView data, GLenum usage, GLuint srcOffset, optional GLuint length = 0);
      void bufferSubData(GLenum target, GLintptr dstByteOffset, ArrayBufferView srcData, GLuint srcOffset, optional GLuint length = 0);
  
      void copyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
      void getBufferSubData(GLenum target, GLintptr srcByteOffset, ArrayBufferView dstData, optional GLuint dstOffset = 0, optional GLuint length = 0);
  
<span class="line-modified">!     // Framebuffer objects.</span>
      void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
      void framebufferTextureLayer(GLenum target, GLenum attachment, WebGLTexture? texture, GLint level, GLint layer);
      void invalidateFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments);
      void invalidateSubFramebuffer(GLenum target, sequence&lt;GLenum&gt; attachments, GLint x, GLint y, GLsizei width, GLsizei height);
      void readBuffer(GLenum src);
  
<span class="line-modified">!     // Renderbuffer objects.</span>
      [OverrideIDLType=IDLWebGLAny] any getInternalformatParameter(GLenum target, GLenum internalformat, GLenum pname);
      void renderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
  
<span class="line-modified">!     // Texture objects.</span>
      void texStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
      void texStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
  
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, GLintptr pboOffset);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, TexImageSource source);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);
      void texImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);
  
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLintptr pboOffset);
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, TexImageSource source);
      void texSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, ArrayBufferView? srcData, optional GLuint srcOffset = 0);
  
      void copyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
  
      void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, GLintptr offset);
      void compressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
      void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, GLintptr offset);
      void compressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, ArrayBufferView srcData, optional GLuint srcOffset = 0, optional GLuint srcLengthOverride = 0);
  
<span class="line-modified">!     // Programs and shaders/</span>
      GLint getFragDataLocation(WebGLProgram program, DOMString name);
  
<span class="line-modified">!     // Uniforms and attributes.</span>
      void uniform1ui(WebGLUniformLocation? location, GLuint v0);
      void uniform2ui(WebGLUniformLocation? location, GLuint v0, GLuint v1);
      void uniform3ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2);
      void uniform4ui(WebGLUniformLocation? location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
      void uniform1uiv(WebGLUniformLocation? location, Uint32List data, optional GLuint srcOffset = 0, optional GLuint srcLength = 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 409,50 ***</span>
      void vertexAttribI4iv(GLuint index, Int32List values);
      void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
      void vertexAttribI4uiv(GLuint index, Uint32List values);
      void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
  
<span class="line-modified">!     /* Writing to the drawing buffer */</span>
      void vertexAttribDivisor(GLuint index, GLuint divisor);
      void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
      void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
      void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);
  
<span class="line-modified">!     /* Multiple Render Targets */</span>
      void drawBuffers(sequence&lt;GLenum&gt; buffers);
      void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values, optional GLuint srcOffset = 0);
      void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values, optional GLuint srcOffset = 0);
      void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values, optional GLuint srcOffset = 0);
      void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
  
<span class="line-modified">!     /* Query Objects */</span>
      WebGLQuery? createQuery();
      void deleteQuery(WebGLQuery? query);
      GLboolean isQuery(WebGLQuery? query);
      void beginQuery(GLenum target, WebGLQuery query);
      void endQuery(GLenum target);
      WebGLQuery? getQuery(GLenum target, GLenum pname);
      [OverrideIDLType=IDLWebGLAny] any getQueryParameter(WebGLQuery query, GLenum pname);
  
<span class="line-modified">!     /* Sampler Objects */</span>
      WebGLSampler? createSampler();
      void deleteSampler(WebGLSampler? sampler);
      GLboolean isSampler(WebGLSampler? sampler);
      void bindSampler(GLuint unit, WebGLSampler? sampler);
      void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
      void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
      [OverrideIDLType=IDLWebGLAny] any getSamplerParameter(WebGLSampler sampler, GLenum pname);
  
<span class="line-modified">!     /* Sync objects */</span>
      WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
      GLboolean isSync(WebGLSync? sync);
      void deleteSync(WebGLSync? sync);
      GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
      void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
      [OverrideIDLType=IDLWebGLAny] any getSyncParameter(WebGLSync sync, GLenum pname);
  
<span class="line-modified">!     /* Transform Feedback */</span>
      WebGLTransformFeedback? createTransformFeedback();
      void deleteTransformFeedback(WebGLTransformFeedback? id);
      GLboolean isTransformFeedback(WebGLTransformFeedback? id);
      void bindTransformFeedback(GLenum target, WebGLTransformFeedback? id);
      void beginTransformFeedback(GLenum primitiveMode);
<span class="line-new-header">--- 394,50 ---</span>
      void vertexAttribI4iv(GLuint index, Int32List values);
      void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
      void vertexAttribI4uiv(GLuint index, Uint32List values);
      void vertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
  
<span class="line-modified">!     // Writing to the drawing buffer.</span>
      void vertexAttribDivisor(GLuint index, GLuint divisor);
      void drawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instanceCount);
      void drawElementsInstanced(GLenum mode, GLsizei count, GLenum type, GLintptr offset, GLsizei instanceCount);
      void drawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLintptr offset);
  
<span class="line-modified">!     // Multiple Render Targets.</span>
      void drawBuffers(sequence&lt;GLenum&gt; buffers);
      void clearBufferiv(GLenum buffer, GLint drawbuffer, Int32List values, optional GLuint srcOffset = 0);
      void clearBufferuiv(GLenum buffer, GLint drawbuffer, Uint32List values, optional GLuint srcOffset = 0);
      void clearBufferfv(GLenum buffer, GLint drawbuffer, Float32List values, optional GLuint srcOffset = 0);
      void clearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
  
<span class="line-modified">!     // Query Objects.</span>
      WebGLQuery? createQuery();
      void deleteQuery(WebGLQuery? query);
      GLboolean isQuery(WebGLQuery? query);
      void beginQuery(GLenum target, WebGLQuery query);
      void endQuery(GLenum target);
      WebGLQuery? getQuery(GLenum target, GLenum pname);
      [OverrideIDLType=IDLWebGLAny] any getQueryParameter(WebGLQuery query, GLenum pname);
  
<span class="line-modified">!     // Sampler Objects.</span>
      WebGLSampler? createSampler();
      void deleteSampler(WebGLSampler? sampler);
      GLboolean isSampler(WebGLSampler? sampler);
      void bindSampler(GLuint unit, WebGLSampler? sampler);
      void samplerParameteri(WebGLSampler sampler, GLenum pname, GLint param);
      void samplerParameterf(WebGLSampler sampler, GLenum pname, GLfloat param);
      [OverrideIDLType=IDLWebGLAny] any getSamplerParameter(WebGLSampler sampler, GLenum pname);
  
<span class="line-modified">!     // Sync objects.</span>
      WebGLSync? fenceSync(GLenum condition, GLbitfield flags);
      GLboolean isSync(WebGLSync? sync);
      void deleteSync(WebGLSync? sync);
      GLenum clientWaitSync(WebGLSync sync, GLbitfield flags, GLuint64 timeout);
      void waitSync(WebGLSync sync, GLbitfield flags, GLint64 timeout);
      [OverrideIDLType=IDLWebGLAny] any getSyncParameter(WebGLSync sync, GLenum pname);
  
<span class="line-modified">!     // Transform Feedback.</span>
      WebGLTransformFeedback? createTransformFeedback();
      void deleteTransformFeedback(WebGLTransformFeedback? id);
      GLboolean isTransformFeedback(WebGLTransformFeedback? id);
      void bindTransformFeedback(GLenum target, WebGLTransformFeedback? id);
      void beginTransformFeedback(GLenum primitiveMode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,24 ***</span>
      void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
      WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
      void pauseTransformFeedback();
      void resumeTransformFeedback();
  
<span class="line-modified">!     /* Uniform Buffer Objects and Transform Feedback Buffers */</span>
      void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
      void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
      [OverrideIDLType=IDLWebGLAny] any getIndexedParameter(GLenum target, GLuint index);
      sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
      [OverrideIDLType=IDLWebGLAny] any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
      GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
      [OverrideIDLType=IDLWebGLAny] any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
      [OverrideIDLType=IDLWebGLAny] DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
      void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
  
<span class="line-modified">!     /* Vertex Array Objects */</span>
      WebGLVertexArrayObject? createVertexArray();
      void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
      GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
      void bindVertexArray(WebGLVertexArrayObject? vertexArray);
  };
  
  WebGL2RenderingContext implements WebGLRenderingContextBase;
<span class="line-new-header">--- 445,57 ---</span>
      void transformFeedbackVaryings(WebGLProgram program, sequence&lt;DOMString&gt; varyings, GLenum bufferMode);
      WebGLActiveInfo? getTransformFeedbackVarying(WebGLProgram program, GLuint index);
      void pauseTransformFeedback();
      void resumeTransformFeedback();
  
<span class="line-modified">!     // Uniform Buffer Objects and Transform Feedback Buffers.</span>
      void bindBufferBase(GLenum target, GLuint index, WebGLBuffer? buffer);
      void bindBufferRange(GLenum target, GLuint index, WebGLBuffer? buffer, GLintptr offset, GLsizeiptr size);
      [OverrideIDLType=IDLWebGLAny] any getIndexedParameter(GLenum target, GLuint index);
      sequence&lt;GLuint&gt;? getUniformIndices(WebGLProgram program, sequence&lt;DOMString&gt; uniformNames);
      [OverrideIDLType=IDLWebGLAny] any getActiveUniforms(WebGLProgram program, sequence&lt;GLuint&gt; uniformIndices, GLenum pname);
      GLuint getUniformBlockIndex(WebGLProgram program, DOMString uniformBlockName);
      [OverrideIDLType=IDLWebGLAny] any getActiveUniformBlockParameter(WebGLProgram program, GLuint uniformBlockIndex, GLenum pname);
      [OverrideIDLType=IDLWebGLAny] DOMString? getActiveUniformBlockName(WebGLProgram program, GLuint uniformBlockIndex);
      void uniformBlockBinding(WebGLProgram program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
  
<span class="line-modified">!     // Vertex Array Objects.</span>
      WebGLVertexArrayObject? createVertexArray();
      void deleteVertexArray(WebGLVertexArrayObject? vertexArray);
      GLboolean isVertexArray(WebGLVertexArrayObject? vertexArray);
      void bindVertexArray(WebGLVertexArrayObject? vertexArray);
<span class="line-added">+ </span>
<span class="line-added">+     // WebGL2RenderingContext API.</span>
<span class="line-added">+ </span>
<span class="line-added">+     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-added">+     [MayThrowException] void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-added">+     void texImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr pboOffset);</span>
<span class="line-added">+     [MayThrowException] void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, TexImageSource source);</span>
<span class="line-added">+     void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView srcData, GLuint srcOffset);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, GLintptr offset);</span>
<span class="line-added">+     void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, ArrayBufferView srcData, GLuint srcOffset, optional GLuint srcLengthOverride = 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, GLintptr offset);</span>
<span class="line-added">+     void compressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView srcData, GLuint srcOffset, optional GLuint srcLengthOverride = 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void uniform1fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform2fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform3fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform4fv(WebGLUniformLocation? location, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void uniform1iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform2iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform3iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniform4iv(WebGLUniformLocation? location, Int32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+     void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose, Float32List data, GLuint srcOffset, optional GLuint srcLength = 0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLintptr offset);</span>
<span class="line-added">+     void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, ArrayBufferView dstData, GLuint dstOffset);</span>
  };
  
  WebGL2RenderingContext implements WebGLRenderingContextBase;
</pre>
<center><a href="WebGL2RenderingContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLActiveInfo.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
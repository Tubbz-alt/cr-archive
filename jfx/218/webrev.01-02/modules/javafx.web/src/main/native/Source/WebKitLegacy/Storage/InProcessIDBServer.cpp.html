<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebKitLegacy/Storage/InProcessIDBServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;InProcessIDBServer.h&quot;
 27 
 28 #if ENABLE(INDEXED_DATABASE)
 29 
 30 #include &quot;StorageThread.h&quot;
 31 #include &lt;WebCore/ClientOrigin.h&gt;
 32 #include &lt;WebCore/IDBConnectionToClient.h&gt;
 33 #include &lt;WebCore/IDBConnectionToServer.h&gt;
 34 #include &lt;WebCore/IDBCursorInfo.h&gt;
 35 #include &lt;WebCore/IDBGetRecordData.h&gt;
 36 #include &lt;WebCore/IDBIterateCursorData.h&gt;
 37 #include &lt;WebCore/IDBKeyRangeData.h&gt;
 38 #include &lt;WebCore/IDBOpenDBRequest.h&gt;
 39 #include &lt;WebCore/IDBRequestData.h&gt;
 40 #include &lt;WebCore/IDBResultData.h&gt;
 41 #include &lt;WebCore/IDBTransactionInfo.h&gt;
 42 #include &lt;WebCore/IDBValue.h&gt;
 43 #include &lt;WebCore/StorageQuotaManager.h&gt;
 44 #include &lt;wtf/threads/BinarySemaphore.h&gt;
 45 
 46 using namespace WebCore;
 47 
 48 Ref&lt;InProcessIDBServer&gt; InProcessIDBServer::create(PAL::SessionID sessionID)
 49 {
 50     ASSERT(sessionID.isEphemeral());
 51 
 52     return adoptRef(*new InProcessIDBServer(sessionID));
 53 }
 54 
 55 Ref&lt;InProcessIDBServer&gt; InProcessIDBServer::create(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath)
 56 {
 57     ASSERT(!sessionID.isEphemeral());
 58 
 59     return adoptRef(*new InProcessIDBServer(sessionID, databaseDirectoryPath));
 60 }
 61 
 62 InProcessIDBServer::~InProcessIDBServer()
 63 {
 64     BinarySemaphore semaphore;
 65     dispatchTask([this, &amp;semaphore] {
 66         m_server = nullptr;
 67         m_connectionToClient = nullptr;
 68         semaphore.signal();
 69     });
 70     semaphore.wait();
 71     m_thread-&gt;terminate();
 72 }
 73 
 74 StorageQuotaManager* InProcessIDBServer::quotaManager(const ClientOrigin&amp; origin)
 75 {
 76     return m_quotaManagers.ensure(origin, [] {
 77         return StorageQuotaManager::create(StorageQuotaManager::defaultQuota(), [] {
 78             return 0;
 79         }, [](uint64_t quota, uint64_t currentSpace, uint64_t spaceIncrease, auto callback) {
 80             callback(quota + currentSpace + spaceIncrease);
 81         });
 82     }).iterator-&gt;value.get();
 83 }
 84 
 85 static inline IDBServer::IDBServer::StorageQuotaManagerSpaceRequester storageQuotaManagerSpaceRequester(InProcessIDBServer&amp; server)
 86 {
 87     return [server = &amp;server, weakServer = makeWeakPtr(server)](const ClientOrigin&amp; origin, uint64_t spaceRequested) mutable {
 88         auto* storageQuotaManager = weakServer ? server-&gt;quotaManager(origin) : nullptr;
 89         return storageQuotaManager ? storageQuotaManager-&gt;requestSpaceOnBackgroundThread(spaceRequested) : StorageQuotaManager::Decision::Deny;
 90     };
 91 }
 92 
 93 InProcessIDBServer::InProcessIDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath)
 94     : m_thread(makeUnique&lt;StorageThread&gt;(StorageThread::Type::IndexedDB))
 95 {
 96     ASSERT(isMainThread());
 97     m_connectionToServer = IDBClient::IDBConnectionToServer::create(*this);
 98     m_thread-&gt;start();
 99     dispatchTask([this, protectedThis = makeRef(*this), sessionID, directory = databaseDirectoryPath.isolatedCopy(), spaceRequester = storageQuotaManagerSpaceRequester(*this)] () mutable {
100         m_connectionToClient = IDBServer::IDBConnectionToClient::create(*this);
101         m_server = makeUnique&lt;IDBServer::IDBServer&gt;(sessionID, directory, WTFMove(spaceRequester));
102 
103         LockHolder locker(m_server-&gt;lock());
104         m_server-&gt;registerConnection(*m_connectionToClient);
105     });
106 }
107 
108 IDBConnectionIdentifier InProcessIDBServer::identifier() const
109 {
110     // An instance of InProcessIDBServer always has a 1:1 relationship with its instance of IDBServer.
111     // Therefore the connection identifier between the two can always be &quot;1&quot;.
112     return Process::identifier();
113 }
114 
115 IDBClient::IDBConnectionToServer&amp; InProcessIDBServer::connectionToServer() const
116 {
117     return *m_connectionToServer;
118 }
119 
120 IDBServer::IDBConnectionToClient&amp; InProcessIDBServer::connectionToClient() const
121 {
122     return *m_connectionToClient;
123 }
124 
125 void InProcessIDBServer::deleteDatabase(const WebCore::IDBRequestData&amp; requestData)
126 {
127     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy()] {
128         LockHolder locker(m_server-&gt;lock());
129         m_server-&gt;deleteDatabase(requestData);
130     });
131 }
132 
133 void InProcessIDBServer::didDeleteDatabase(const IDBResultData&amp; resultData)
134 {
135     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
136         m_connectionToServer-&gt;didDeleteDatabase(resultData);
137     });
138 }
139 
140 void InProcessIDBServer::openDatabase(const WebCore::IDBRequestData&amp; requestData)
141 {
142     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy()] {
143         LockHolder locker(m_server-&gt;lock());
144         m_server-&gt;openDatabase(requestData);
145     });
146 }
147 
148 void InProcessIDBServer::didOpenDatabase(const IDBResultData&amp; resultData)
149 {
150     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
151         m_connectionToServer-&gt;didOpenDatabase(resultData);
152     });
153 }
154 
155 void InProcessIDBServer::didAbortTransaction(const WebCore::IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
156 {
157     dispatchTaskReply([this, protectedThis = makeRef(*this), transactionIdentifier = transactionIdentifier.isolatedCopy(), error = error.isolatedCopy()] {
158         m_connectionToServer-&gt;didAbortTransaction(transactionIdentifier, error);
159     });
160 }
161 
162 void InProcessIDBServer::didCommitTransaction(const WebCore::IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
163 {
164     dispatchTaskReply([this, protectedThis = makeRef(*this), transactionIdentifier = transactionIdentifier.isolatedCopy(), error = error.isolatedCopy()] {
165         m_connectionToServer-&gt;didCommitTransaction(transactionIdentifier, error);
166     });
167 }
168 
169 void InProcessIDBServer::didCreateObjectStore(const IDBResultData&amp; resultData)
170 {
171     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
172         m_connectionToServer-&gt;didCreateObjectStore(resultData);
173     });
174 }
175 
176 void InProcessIDBServer::didDeleteObjectStore(const IDBResultData&amp; resultData)
177 {
178     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
179         m_connectionToServer-&gt;didDeleteObjectStore(resultData);
180     });
181 }
182 
183 void InProcessIDBServer::didRenameObjectStore(const IDBResultData&amp; resultData)
184 {
185     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
186         m_connectionToServer-&gt;didRenameObjectStore(resultData);
187     });
188 }
189 
190 void InProcessIDBServer::didClearObjectStore(const IDBResultData&amp; resultData)
191 {
192     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
193         m_connectionToServer-&gt;didClearObjectStore(resultData);
194     });
195 }
196 
197 void InProcessIDBServer::didCreateIndex(const IDBResultData&amp; resultData)
198 {
199     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
200         m_connectionToServer-&gt;didCreateIndex(resultData);
201     });
202 }
203 
204 void InProcessIDBServer::didDeleteIndex(const IDBResultData&amp; resultData)
205 {
206     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
207         m_connectionToServer-&gt;didDeleteIndex(resultData);
208     });
209 }
210 
211 void InProcessIDBServer::didRenameIndex(const IDBResultData&amp; resultData)
212 {
213     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
214         m_connectionToServer-&gt;didRenameIndex(resultData);
215     });
216 }
217 
218 void InProcessIDBServer::didPutOrAdd(const IDBResultData&amp; resultData)
219 {
220     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
221         m_connectionToServer-&gt;didPutOrAdd(resultData);
222     });
223 }
224 
225 void InProcessIDBServer::didGetRecord(const IDBResultData&amp; resultData)
226 {
227     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
228         m_connectionToServer-&gt;didGetRecord(resultData);
229     });
230 }
231 
232 void InProcessIDBServer::didGetAllRecords(const IDBResultData&amp; resultData)
233 {
234     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
235         m_connectionToServer-&gt;didGetAllRecords(resultData);
236     });
237 }
238 
239 void InProcessIDBServer::didGetCount(const IDBResultData&amp; resultData)
240 {
241     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
242         m_connectionToServer-&gt;didGetCount(resultData);
243     });
244 }
245 
246 void InProcessIDBServer::didDeleteRecord(const IDBResultData&amp; resultData)
247 {
248     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
249         m_connectionToServer-&gt;didDeleteRecord(resultData);
250     });
251 }
252 
253 void InProcessIDBServer::didOpenCursor(const IDBResultData&amp; resultData)
254 {
255     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
256         m_connectionToServer-&gt;didOpenCursor(resultData);
257     });
258 }
259 
260 void InProcessIDBServer::didIterateCursor(const IDBResultData&amp; resultData)
261 {
262     dispatchTaskReply([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy()] {
263         m_connectionToServer-&gt;didIterateCursor(resultData);
264     });
265 }
266 
267 void InProcessIDBServer::abortTransaction(const WebCore::IDBResourceIdentifier&amp; resourceIdentifier)
268 {
269     dispatchTask([this, protectedThis = makeRef(*this), resourceIdentifier = resourceIdentifier.isolatedCopy()] {
270         LockHolder locker(m_server-&gt;lock());
271         m_server-&gt;abortTransaction(resourceIdentifier);
272     });
273 }
274 
275 void InProcessIDBServer::commitTransaction(const WebCore::IDBResourceIdentifier&amp; resourceIdentifier)
276 {
277     dispatchTask([this, protectedThis = makeRef(*this), resourceIdentifier = resourceIdentifier.isolatedCopy()] {
278         LockHolder locker(m_server-&gt;lock());
279         m_server-&gt;commitTransaction(resourceIdentifier);
280     });
281 }
282 
283 void InProcessIDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const WebCore::IDBResourceIdentifier&amp; transactionIdentifier)
284 {
285     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier, transactionIdentifier = transactionIdentifier.isolatedCopy()] {
286         LockHolder locker(m_server-&gt;lock());
287         m_server-&gt;didFinishHandlingVersionChangeTransaction(databaseConnectionIdentifier, transactionIdentifier);
288     });
289 }
290 
291 void InProcessIDBServer::createObjectStore(const WebCore::IDBRequestData&amp; resultData, const IDBObjectStoreInfo&amp; info)
292 {
293     dispatchTask([this, protectedThis = makeRef(*this), resultData = resultData.isolatedCopy(), info = info.isolatedCopy()] {
294         LockHolder locker(m_server-&gt;lock());
295         m_server-&gt;createObjectStore(resultData, info);
296     });
297 }
298 
299 void InProcessIDBServer::deleteObjectStore(const WebCore::IDBRequestData&amp; requestData, const String&amp; objectStoreName)
300 {
301     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), objectStoreName = objectStoreName.isolatedCopy()] () mutable {
302         LockHolder locker(m_server-&gt;lock());
303         m_server-&gt;deleteObjectStore(requestData, objectStoreName);
304     });
305 }
306 
307 void InProcessIDBServer::renameObjectStore(const WebCore::IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
308 {
309     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), objectStoreIdentifier, newName = newName.isolatedCopy()] () mutable {
310         LockHolder locker(m_server-&gt;lock());
311         m_server-&gt;renameObjectStore(requestData, objectStoreIdentifier, newName);
312     });
313 }
314 
315 void InProcessIDBServer::clearObjectStore(const WebCore::IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
316 {
317     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), objectStoreIdentifier] {
318         LockHolder locker(m_server-&gt;lock());
319         m_server-&gt;clearObjectStore(requestData, objectStoreIdentifier);
320     });
321 }
322 
323 void InProcessIDBServer::createIndex(const WebCore::IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
324 {
325     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), info = info.isolatedCopy()] {
326         LockHolder locker(m_server-&gt;lock());
327         m_server-&gt;createIndex(requestData, info);
328     });
329 }
330 
331 void InProcessIDBServer::deleteIndex(const WebCore::IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
332 {
333     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), objectStoreIdentifier, indexName = indexName.isolatedCopy()] {
334         LockHolder locker(m_server-&gt;lock());
335         m_server-&gt;deleteIndex(requestData, objectStoreIdentifier, indexName);
336     });
337 }
338 
339 void InProcessIDBServer::renameIndex(const WebCore::IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
340 {
341     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] {
342         LockHolder locker(m_server-&gt;lock());
343         m_server-&gt;renameIndex(requestData, objectStoreIdentifier, indexIdentifier, newName);
344     });
345 }
346 
347 void InProcessIDBServer::putOrAdd(const WebCore::IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, const IndexedDB::ObjectStoreOverwriteMode overwriteMode)
348 {
349     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), keyData = keyData.isolatedCopy(), value = value.isolatedCopy(), overwriteMode] {
350         LockHolder locker(m_server-&gt;lock());
351         m_server-&gt;putOrAdd(requestData, keyData, value, overwriteMode);
352     });
353 }
354 
355 void InProcessIDBServer::getRecord(const WebCore::IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
356 {
357     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), getRecordData = getRecordData.isolatedCopy()] {
358         LockHolder locker(m_server-&gt;lock());
359         m_server-&gt;getRecord(requestData, getRecordData);
360     });
361 }
362 
363 void InProcessIDBServer::getAllRecords(const WebCore::IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
364 {
365     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), getAllRecordsData = getAllRecordsData.isolatedCopy()] {
366         LockHolder locker(m_server-&gt;lock());
367         m_server-&gt;getAllRecords(requestData, getAllRecordsData);
368     });
369 }
370 
371 void InProcessIDBServer::getCount(const WebCore::IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
372 {
373     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), keyRangeData = keyRangeData.isolatedCopy()] {
374         LockHolder locker(m_server-&gt;lock());
375         m_server-&gt;getCount(requestData, keyRangeData);
376     });
377 }
378 
379 void InProcessIDBServer::deleteRecord(const WebCore::IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
380 {
381     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), keyRangeData = keyRangeData.isolatedCopy()] {
382         LockHolder locker(m_server-&gt;lock());
383         m_server-&gt;deleteRecord(requestData, keyRangeData);
384     });
385 }
386 
387 void InProcessIDBServer::openCursor(const WebCore::IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
388 {
389     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), info = info.isolatedCopy()] () mutable {
390         LockHolder locker(m_server-&gt;lock());
391         m_server-&gt;openCursor(requestData, info);
392     });
393 }
394 
395 void InProcessIDBServer::iterateCursor(const WebCore::IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
396 {
397     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy(), data = data.isolatedCopy()] {
398         LockHolder locker(m_server-&gt;lock());
399         m_server-&gt;iterateCursor(requestData, data);
400     });
401 }
402 
403 void InProcessIDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo&amp; info)
404 {
405     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier, info = info.isolatedCopy()] {
406         LockHolder locker(m_server-&gt;lock());
407         m_server-&gt;establishTransaction(databaseConnectionIdentifier, info);
408     });
409 }
410 
411 void InProcessIDBServer::fireVersionChangeEvent(IDBServer::UniqueIDBDatabaseConnection&amp; connection, const WebCore::IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
412 {
413     dispatchTaskReply([this, protectedThis = makeRef(*this), databaseConnectionIdentifier = connection.identifier(), requestIdentifier = requestIdentifier.isolatedCopy(), requestedVersion] {
414         m_connectionToServer-&gt;fireVersionChangeEvent(databaseConnectionIdentifier, requestIdentifier, requestedVersion);
415     });
416 }
417 
418 void InProcessIDBServer::didStartTransaction(const WebCore::IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
419 {
420     dispatchTaskReply([this, protectedThis = makeRef(*this), transactionIdentifier = transactionIdentifier.isolatedCopy(), error = error.isolatedCopy()] {
421         m_connectionToServer-&gt;didStartTransaction(transactionIdentifier, error);
422     });
423 }
424 
425 void InProcessIDBServer::didCloseFromServer(IDBServer::UniqueIDBDatabaseConnection&amp; connection, const IDBError&amp; error)
426 {
427     dispatchTaskReply([this, protectedThis = makeRef(*this), databaseConnectionIdentifier = connection.identifier(), error = error.isolatedCopy()] {
428         m_connectionToServer-&gt;didCloseFromServer(databaseConnectionIdentifier, error);
429     });
430 }
431 
432 void InProcessIDBServer::notifyOpenDBRequestBlocked(const WebCore::IDBResourceIdentifier&amp; requestIdentifier, uint64_t oldVersion, uint64_t newVersion)
433 {
434     dispatchTaskReply([this, protectedThis = makeRef(*this), requestIdentifier = requestIdentifier.isolatedCopy(), oldVersion, newVersion] {
435         m_connectionToServer-&gt;notifyOpenDBRequestBlocked(requestIdentifier, oldVersion, newVersion);
436     });
437 }
438 
439 void InProcessIDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
440 {
441     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier] {
442         LockHolder locker(m_server-&gt;lock());
443         m_server-&gt;databaseConnectionPendingClose(databaseConnectionIdentifier);
444     });
445 }
446 
447 void InProcessIDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
448 {
449     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier] {
450         LockHolder locker(m_server-&gt;lock());
451         m_server-&gt;databaseConnectionClosed(databaseConnectionIdentifier);
452     });
453 }
454 
455 void InProcessIDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const WebCore::IDBResourceIdentifier&amp; transactionIdentifier)
456 {
457     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier, transactionIdentifier = transactionIdentifier.isolatedCopy()] {
458         LockHolder locker(m_server-&gt;lock());
459         m_server-&gt;abortOpenAndUpgradeNeeded(databaseConnectionIdentifier, transactionIdentifier);
460     });
461 }
462 
463 void InProcessIDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const WebCore::IDBResourceIdentifier&amp; requestIdentifier, const IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)
464 {
465     dispatchTask([this, protectedThis = makeRef(*this), databaseConnectionIdentifier, requestIdentifier = requestIdentifier.isolatedCopy(), connectionClosed] {
466         LockHolder locker(m_server-&gt;lock());
467         m_server-&gt;didFireVersionChangeEvent(databaseConnectionIdentifier, requestIdentifier, connectionClosed);
468     });
469 }
470 
471 void InProcessIDBServer::openDBRequestCancelled(const WebCore::IDBRequestData&amp; requestData)
472 {
473     dispatchTask([this, protectedThis = makeRef(*this), requestData = requestData.isolatedCopy()] {
474         LockHolder locker(m_server-&gt;lock());
475         m_server-&gt;openDBRequestCancelled(requestData);
476     });
477 }
478 
479 void InProcessIDBServer::getAllDatabaseNames(const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)
480 {
481     dispatchTask([this, protectedThis = makeRef(*this), identifier = m_connectionToServer-&gt;identifier(), mainFrameOrigin = mainFrameOrigin.isolatedCopy(), openingOrigin = openingOrigin.isolatedCopy(), callbackID] {
482         LockHolder locker(m_server-&gt;lock());
483         m_server-&gt;getAllDatabaseNames(identifier, mainFrameOrigin, openingOrigin, callbackID);
484     });
485 }
486 
487 void InProcessIDBServer::didGetAllDatabaseNames(uint64_t callbackID, const Vector&lt;String&gt;&amp; databaseNames)
488 {
489     dispatchTaskReply([this, protectedThis = makeRef(*this), callbackID, databaseNames = databaseNames.isolatedCopy()] {
490         m_connectionToServer-&gt;didGetAllDatabaseNames(callbackID, databaseNames);
491     });
492 }
493 
494 void InProcessIDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime)
495 {
496     dispatchTask([this, protectedThis = makeRef(*this), modificationTime] {
497         LockHolder locker(m_server-&gt;lock());
498         m_server-&gt;closeAndDeleteDatabasesModifiedSince(modificationTime);
499     });
500 }
501 
502 void InProcessIDBServer::dispatchTask(Function&lt;void()&gt;&amp;&amp; function)
503 {
504     ASSERT(isMainThread());
505     m_thread-&gt;dispatch(WTFMove(function));
506 }
507 
508 void InProcessIDBServer::dispatchTaskReply(Function&lt;void()&gt;&amp;&amp; function)
509 {
510     ASSERT(!isMainThread());
511     callOnMainThread(WTFMove(function));
512 }
513 
514 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2010, 2011 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #include &quot;RenderLayerBacking.h&quot;
  29 
  30 #include &quot;BitmapImage.h&quot;
  31 #include &quot;CSSAnimationController.h&quot;
  32 #include &quot;CanvasRenderingContext.h&quot;
  33 #include &quot;CSSPropertyNames.h&quot;
  34 #include &quot;CachedImage.h&quot;
  35 #include &quot;Chrome.h&quot;
  36 #include &quot;DocumentTimeline.h&quot;
  37 #include &quot;EventRegion.h&quot;
  38 #include &quot;Frame.h&quot;
  39 #include &quot;FrameView.h&quot;
  40 #include &quot;GraphicsContext.h&quot;
  41 #include &quot;GraphicsLayer.h&quot;
  42 #include &quot;HTMLBodyElement.h&quot;
  43 #include &quot;HTMLCanvasElement.h&quot;
  44 #include &quot;HTMLIFrameElement.h&quot;
  45 #include &quot;HTMLMediaElement.h&quot;
  46 #include &quot;HTMLNames.h&quot;
  47 #include &quot;HTMLPlugInElement.h&quot;
  48 #include &quot;InspectorInstrumentation.h&quot;
  49 #include &quot;KeyframeList.h&quot;
  50 #include &quot;LayerAncestorClippingStack.h&quot;
  51 #include &quot;Logging.h&quot;
  52 #include &quot;Page.h&quot;
  53 #include &quot;PerformanceLoggingClient.h&quot;
  54 #include &quot;PluginViewBase.h&quot;
  55 #include &quot;ProgressTracker.h&quot;
  56 #include &quot;RenderFragmentContainer.h&quot;
  57 #include &quot;RenderFragmentedFlow.h&quot;
  58 #include &quot;RenderHTMLCanvas.h&quot;
  59 #include &quot;RenderIFrame.h&quot;
  60 #include &quot;RenderImage.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderEmbeddedObject.h&quot;
  63 #include &quot;RenderMedia.h&quot;
  64 #include &quot;RenderVideo.h&quot;
  65 #include &quot;RenderView.h&quot;
  66 #include &quot;RuntimeEnabledFeatures.h&quot;
  67 #include &quot;ScrollingCoordinator.h&quot;
  68 #include &quot;Settings.h&quot;
  69 #include &quot;StyleResolver.h&quot;
  70 #include &quot;TiledBacking.h&quot;
  71 #include &lt;wtf/text/TextStream.h&gt;
  72 
  73 #if PLATFORM(IOS_FAMILY)
  74 #include &quot;RuntimeApplicationChecks.h&quot;
  75 #endif
  76 
  77 #if PLATFORM(MAC)
  78 #include &quot;LocalDefaultSystemAppearance.h&quot;
  79 #endif
  80 
  81 namespace WebCore {
  82 
  83 using namespace HTMLNames;
  84 
  85 CanvasCompositingStrategy canvasCompositingStrategy(const RenderObject&amp; renderer)
  86 {
  87     ASSERT(renderer.isCanvas());
  88 
  89     const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer.node());
  90     auto* context = canvas-&gt;renderingContext();
  91     if (!context || !context-&gt;isAccelerated())
  92         return UnacceleratedCanvas;
  93 
  94     if (context-&gt;isGPUBased())
  95         return CanvasAsLayerContents;
  96 
  97 #if ENABLE(ACCELERATED_2D_CANVAS)
  98     return CanvasAsLayerContents;
  99 #else
 100     return CanvasPaintedToLayer; // On Mac and iOS we paint accelerated canvases into their layers.
 101 #endif
 102 }
 103 
 104 // This acts as a cache of what we know about what is painting into this RenderLayerBacking.
 105 class PaintedContentsInfo {
 106 public:
 107     enum class ContentsTypeDetermination {
 108         Unknown,
 109         SimpleContainer,
 110         DirectlyCompositedImage,
 111         Painted
 112     };
 113 
 114     PaintedContentsInfo(RenderLayerBacking&amp; inBacking)
 115         : m_backing(inBacking)
 116     {
 117     }
 118 
 119     void setWantsSubpixelAntialiasedTextState(bool wantsSubpixelAntialiasedTextState)
 120     {
 121         m_subpixelAntialiasedText = wantsSubpixelAntialiasedTextState ? RequestState::Unknown : RequestState::DontCare;
 122     }
 123 
 124     RequestState paintsBoxDecorationsDetermination();
 125     bool paintsBoxDecorations()
 126     {
 127         RequestState state = paintsBoxDecorationsDetermination();
 128         return state == RequestState::True || state == RequestState::Undetermined;
 129     }
 130 
 131     RequestState paintsContentDetermination();
 132     bool paintsContent()
 133     {
 134         RequestState state = paintsContentDetermination();
 135         return state == RequestState::True || state == RequestState::Undetermined;
 136     }
 137 
 138     RequestState paintsSubpixelAntialiasedTextDetermination();
 139     bool paintsSubpixelAntialiasedText()
 140     {
 141         RequestState state = paintsSubpixelAntialiasedTextDetermination();
 142         return state == RequestState::True || state == RequestState::Undetermined;
 143     }
 144 
 145     ContentsTypeDetermination contentsTypeDetermination();
 146     bool isSimpleContainer()
 147     {
 148         return contentsTypeDetermination() == ContentsTypeDetermination::SimpleContainer;
 149     }
 150 
 151     bool isDirectlyCompositedImage()
 152     {
 153         return contentsTypeDetermination() == ContentsTypeDetermination::DirectlyCompositedImage;
 154     }
 155 
 156     RenderLayerBacking&amp; m_backing;
 157     RequestState m_boxDecorations { RequestState::Unknown };
 158     RequestState m_content { RequestState::Unknown };
 159     RequestState m_subpixelAntialiasedText { RequestState::DontCare };
 160 
 161     ContentsTypeDetermination m_contentsType { ContentsTypeDetermination::Unknown };
 162 };
 163 
 164 RequestState PaintedContentsInfo::paintsBoxDecorationsDetermination()
 165 {
 166     if (m_boxDecorations != RequestState::Unknown)
 167         return m_boxDecorations;
 168 
 169     m_boxDecorations = m_backing.paintsBoxDecorations() ? RequestState::True : RequestState::False;
 170     return m_boxDecorations;
 171 }
 172 
 173 RequestState PaintedContentsInfo::paintsContentDetermination()
 174 {
 175     if (m_content != RequestState::Unknown &amp;&amp; m_subpixelAntialiasedText != RequestState::Unknown)
 176         return m_content;
 177 
 178     RenderLayer::PaintedContentRequest contentRequest;
 179     if (m_subpixelAntialiasedText == RequestState::Unknown)
 180         contentRequest.hasSubpixelAntialiasedText = RequestState::Unknown;
 181 
 182     m_content = m_backing.paintsContent(contentRequest) ? RequestState::True : RequestState::False;
 183 
 184     if (m_subpixelAntialiasedText == RequestState::Unknown)
 185         m_subpixelAntialiasedText = contentRequest.hasSubpixelAntialiasedText;
 186 
 187     return m_content;
 188 }
 189 
 190 RequestState PaintedContentsInfo::paintsSubpixelAntialiasedTextDetermination()
 191 {
 192     if (m_subpixelAntialiasedText != RequestState::Unknown)
 193         return m_subpixelAntialiasedText;
 194 
 195     paintsContentDetermination();
 196 
 197     return m_subpixelAntialiasedText;
 198 }
 199 
 200 PaintedContentsInfo::ContentsTypeDetermination PaintedContentsInfo::contentsTypeDetermination()
 201 {
 202     if (m_contentsType != ContentsTypeDetermination::Unknown)
 203         return m_contentsType;
 204 
 205     if (m_backing.isSimpleContainerCompositingLayer(*this))
 206         m_contentsType = ContentsTypeDetermination::SimpleContainer;
 207     else if (m_backing.isDirectlyCompositedImage())
 208         m_contentsType = ContentsTypeDetermination::DirectlyCompositedImage;
 209     else
 210         m_contentsType = ContentsTypeDetermination::Painted;
 211 
 212     return m_contentsType;
 213 }
 214 
 215 
 216 RenderLayerBacking::RenderLayerBacking(RenderLayer&amp; layer)
 217     : m_owningLayer(layer)
 218 {
 219     if (layer.isRenderViewLayer()) {
 220         m_isMainFrameRenderViewLayer = renderer().frame().isMainFrame();
 221         m_isFrameLayerWithTiledBacking = renderer().page().chrome().client().shouldUseTiledBackingForFrameView(renderer().view().frameView());
 222     }
 223 
 224     createPrimaryGraphicsLayer();
 225 #if ENABLE(FULLSCREEN_API)
 226     setRequiresBackgroundLayer(layer.renderer().isRenderFullScreen());
 227 #endif
 228 
 229     if (auto* tiledBacking = this-&gt;tiledBacking()) {
 230         tiledBacking-&gt;setIsInWindow(renderer().page().isInWindow());
 231 
 232         if (m_isFrameLayerWithTiledBacking) {
 233             tiledBacking-&gt;setScrollingPerformanceLoggingEnabled(renderer().settings().scrollingPerformanceLoggingEnabled());
 234             adjustTiledBackingCoverage();
 235         }
 236     }
 237 }
 238 
 239 RenderLayerBacking::~RenderLayerBacking()
 240 {
 241 #if USE(OWNING_LAYER_BEAR_TRAP)
 242     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;~RenderLayerBacking: m_owningLayerBearTrap caught the bear (55699292)&quot;);
 243     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;~RenderLayerBacking: m_owningLayer is null (55699292)&quot;);
 244 #endif
 245     // Note that m_owningLayer-&gt;backing() is null here.
 246     updateAncestorClipping(false, nullptr);
 247     updateChildClippingStrategy(false);
 248     updateDescendantClippingLayer(false);
 249     updateOverflowControlsLayers(false, false, false);
 250     updateForegroundLayer(false);
 251     updateBackgroundLayer(false);
 252     updateMaskingLayer(false, false);
 253     updateScrollingLayers(false);
 254 
 255     ASSERT(!m_viewportConstrainedNodeID);
 256     ASSERT(!m_scrollingNodeID);
 257     ASSERT(!m_frameHostingNodeID);
 258     ASSERT(!m_positioningNodeID);
 259 
 260     destroyGraphicsLayers();
 261 }
 262 
 263 void RenderLayerBacking::willBeDestroyed()
 264 {
 265 #if USE(OWNING_LAYER_BEAR_TRAP)
 266     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
 267     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::willBeDestroyed(): m_owningLayer is null (55699292)&quot;);
 268 #endif
 269 
 270     ASSERT(m_owningLayer.backing() == this);
 271     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
 272 
 273     clearBackingSharingLayers();
 274 }
 275 
 276 void RenderLayerBacking::willDestroyLayer(const GraphicsLayer* layer)
 277 {
 278     if (layer &amp;&amp; layer-&gt;type() == GraphicsLayer::Type::Normal &amp;&amp; layer-&gt;tiledBacking())
 279         compositor().layerTiledBackingUsageChanged(layer, false);
 280 }
 281 
 282 static void clearBackingSharingLayerProviders(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; sharingLayers, const RenderLayer&amp; providerLayer)
 283 {
 284     for (auto&amp; layerWeakPtr : sharingLayers) {
 285         if (!layerWeakPtr)
 286             continue;
 287         if (layerWeakPtr-&gt;backingProviderLayer() == &amp;providerLayer)
 288             layerWeakPtr-&gt;setBackingProviderLayer(nullptr);
 289     }
 290 }
 291 
 292 void RenderLayerBacking::setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp; sharingLayers)
 293 {
 294     bool sharingLayersChanged = m_backingSharingLayers != sharingLayers;
 295     if (sharingLayersChanged) {
 296         // For layers that used to share and no longer do, and are not composited, recompute repaint rects.
 297         for (auto&amp; oldSharingLayer : m_backingSharingLayers) {
 298             // Layers that go from shared to composited have their repaint rects recomputed in RenderLayerCompositor::updateBacking().
 299             // FIXME: Two O(n^2) traversals in this funtion. Probably OK because sharing lists are usually small, but still.
 300             if (!sharingLayers.contains(oldSharingLayer) &amp;&amp; !oldSharingLayer-&gt;isComposited())
 301                 oldSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 302         }
 303     }
 304 
 305     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);
 306 
 307     if (sharingLayers != m_backingSharingLayers) {
 308         if (sharingLayers.size())
 309             setRequiresOwnBackingStore(true);
 310         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.
 311     }
 312 
 313     auto oldSharingLayers = WTFMove(m_backingSharingLayers);
 314     m_backingSharingLayers = WTFMove(sharingLayers);
 315 
 316     for (auto&amp; layerWeakPtr : m_backingSharingLayers)
 317         layerWeakPtr-&gt;setBackingProviderLayer(&amp;m_owningLayer);
 318 
 319     if (sharingLayersChanged) {
 320         // For layers that are newly sharing, recompute repaint rects.
 321         for (auto&amp; currentSharingLayer : m_backingSharingLayers) {
 322             if (!oldSharingLayers.contains(currentSharingLayer))
 323                 currentSharingLayer-&gt;computeRepaintRectsIncludingDescendants();
 324         }
 325     }
 326 }
 327 
 328 void RenderLayerBacking::removeBackingSharingLayer(RenderLayer&amp; layer)
 329 {
 330     layer.setBackingProviderLayer(nullptr);
 331     m_backingSharingLayers.removeAll(&amp;layer);
 332 }
 333 
 334 void RenderLayerBacking::clearBackingSharingLayers()
 335 {
 336     clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);
 337     m_backingSharingLayers.clear();
 338 }
 339 
 340 Ref&lt;GraphicsLayer&gt; RenderLayerBacking::createGraphicsLayer(const String&amp; name, GraphicsLayer::Type layerType)
 341 {
 342     auto* graphicsLayerFactory = renderer().page().chrome().client().graphicsLayerFactory();
 343 
 344     auto graphicsLayer = GraphicsLayer::create(graphicsLayerFactory, *this, layerType);
 345 
 346     graphicsLayer-&gt;setName(name);
 347 
 348 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 349     graphicsLayer-&gt;setAcceleratesDrawing(compositor().acceleratedDrawingEnabled());
 350     graphicsLayer-&gt;setUsesDisplayListDrawing(compositor().displayListDrawingEnabled());
 351 #endif
 352 
 353     return graphicsLayer;
 354 }
 355 
 356 void RenderLayerBacking::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 357 {
 358     // Note that this only affects the primary layer.
 359     if (usesDisplayListDrawing == m_graphicsLayer-&gt;usesDisplayListDrawing())
 360         return;
 361 
 362     m_graphicsLayer-&gt;setUsesDisplayListDrawing(usesDisplayListDrawing);
 363     if (m_graphicsLayer-&gt;drawsContent())
 364         m_graphicsLayer-&gt;setNeedsDisplay();
 365 }
 366 
 367 String RenderLayerBacking::displayListAsText(DisplayList::AsTextFlags flags) const
 368 {
 369     return m_graphicsLayer-&gt;displayListAsText(flags);
 370 }
 371 
 372 void RenderLayerBacking::setIsTrackingDisplayListReplay(bool isTrackingReplay)
 373 {
 374     m_graphicsLayer-&gt;setIsTrackingDisplayListReplay(isTrackingReplay);
 375 }
 376 
 377 String RenderLayerBacking::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 378 {
 379     return m_graphicsLayer-&gt;replayDisplayListAsText(flags);
 380 }
 381 
 382 void RenderLayerBacking::tiledBackingUsageChanged(const GraphicsLayer* layer, bool usingTiledBacking)
 383 {
 384     compositor().layerTiledBackingUsageChanged(layer, usingTiledBacking);
 385 }
 386 
 387 TiledBacking* RenderLayerBacking::tiledBacking() const
 388 {
 389     return m_graphicsLayer-&gt;tiledBacking();
 390 }
 391 
 392 static TiledBacking::TileCoverage computePageTiledBackingCoverage(const RenderLayer&amp; layer)
 393 {
 394     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
 395     if (!layer.page().isVisible())
 396         return TiledBacking::CoverageForVisibleArea;
 397 
 398     auto&amp; frameView = layer.renderer().view().frameView();
 399 
 400     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
 401     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
 402     if (frameView.speculativeTilingEnabled() &amp;&amp; !useMinimalTilesDuringLiveResize) {
 403         bool clipsToExposedRect = static_cast&lt;bool&gt;(frameView.viewExposedRect());
 404         if (frameView.horizontalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 405             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;
 406 
 407         if (frameView.verticalScrollbarMode() != ScrollbarAlwaysOff || clipsToExposedRect)
 408             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
 409     }
 410     return tileCoverage;
 411 }
 412 
 413 static TiledBacking::TileCoverage computeOverflowTiledBackingCoverage(const RenderLayer&amp; layer)
 414 {
 415     // If the page is non-visible, don&#39;t incur the cost of keeping extra tiles for scrolling.
 416     if (!layer.page().isVisible())
 417         return TiledBacking::CoverageForVisibleArea;
 418 
 419     auto&amp; frameView = layer.renderer().view().frameView();
 420 
 421     TiledBacking::TileCoverage tileCoverage = TiledBacking::CoverageForVisibleArea;
 422     bool useMinimalTilesDuringLiveResize = frameView.inLiveResize();
 423     if (!useMinimalTilesDuringLiveResize) {
 424         if (layer.hasScrollableHorizontalOverflow())
 425             tileCoverage |= TiledBacking::CoverageForHorizontalScrolling;
 426 
 427         if (layer.hasScrollableVerticalOverflow())
 428             tileCoverage |= TiledBacking::CoverageForVerticalScrolling;
 429     }
 430     return tileCoverage;
 431 }
 432 
 433 void RenderLayerBacking::adjustTiledBackingCoverage()
 434 {
 435     if (m_isFrameLayerWithTiledBacking) {
 436         auto tileCoverage = computePageTiledBackingCoverage(m_owningLayer);
 437         if (auto* tiledBacking = this-&gt;tiledBacking())
 438             tiledBacking-&gt;setTileCoverage(tileCoverage);
 439     }
 440 
 441     if (m_owningLayer.hasCompositedScrollableOverflow() &amp;&amp; m_scrolledContentsLayer) {
 442         if (auto* tiledBacking = m_scrolledContentsLayer-&gt;tiledBacking()) {
 443             auto tileCoverage = computeOverflowTiledBackingCoverage(m_owningLayer);
 444             tiledBacking-&gt;setTileCoverage(tileCoverage);
 445         }
 446     }
 447 }
 448 
 449 void RenderLayerBacking::setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom)
 450 {
 451     if (!m_isFrameLayerWithTiledBacking)
 452         return;
 453 
 454     tiledBacking()-&gt;setHasMargins(hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnTopAndBottom, hasExtendedBackgroundOnLeftAndRight, hasExtendedBackgroundOnLeftAndRight);
 455 }
 456 
 457 void RenderLayerBacking::updateDebugIndicators(bool showBorder, bool showRepaintCounter)
 458 {
 459     m_graphicsLayer-&gt;setShowDebugBorder(showBorder);
 460     m_graphicsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 461 
 462     if (m_ancestorClippingStack) {
 463         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())
 464             entry.clippingLayer-&gt;setShowDebugBorder(showBorder);
 465     }
 466 
 467     if (m_foregroundLayer) {
 468         m_foregroundLayer-&gt;setShowDebugBorder(showBorder);
 469         m_foregroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 470     }
 471 
 472     if (m_contentsContainmentLayer)
 473         m_contentsContainmentLayer-&gt;setShowDebugBorder(showBorder);
 474 
 475     if (m_backgroundLayer) {
 476         m_backgroundLayer-&gt;setShowDebugBorder(showBorder);
 477         m_backgroundLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 478     }
 479 
 480     if (m_maskLayer) {
 481         m_maskLayer-&gt;setShowDebugBorder(showBorder);
 482         m_maskLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 483     }
 484 
 485     if (m_layerForHorizontalScrollbar)
 486         m_layerForHorizontalScrollbar-&gt;setShowDebugBorder(showBorder);
 487 
 488     if (m_layerForVerticalScrollbar)
 489         m_layerForVerticalScrollbar-&gt;setShowDebugBorder(showBorder);
 490 
 491     if (m_layerForScrollCorner)
 492         m_layerForScrollCorner-&gt;setShowDebugBorder(showBorder);
 493 
 494     if (m_scrollContainerLayer)
 495         m_scrollContainerLayer-&gt;setShowDebugBorder(showBorder);
 496 
 497     if (m_scrolledContentsLayer) {
 498         m_scrolledContentsLayer-&gt;setShowDebugBorder(showBorder);
 499         m_scrolledContentsLayer-&gt;setShowRepaintCounter(showRepaintCounter);
 500     }
 501 }
 502 
 503 void RenderLayerBacking::createPrimaryGraphicsLayer()
 504 {
 505     String layerName = m_owningLayer.name();
 506     const unsigned maxLayerNameLength = 100;
 507     if (layerName.length() &gt; maxLayerNameLength) {
 508         layerName.truncate(maxLayerNameLength);
 509         layerName.append(&quot;...&quot;);
 510     }
 511     m_graphicsLayer = createGraphicsLayer(layerName, m_isFrameLayerWithTiledBacking ? GraphicsLayer::Type::PageTiledBacking : GraphicsLayer::Type::Normal);
 512 
 513     if (m_isFrameLayerWithTiledBacking) {
 514         m_childContainmentLayer = createGraphicsLayer(&quot;Page TiledBacking containment&quot;);
 515         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
 516     }
 517 
 518 #if !PLATFORM(IOS_FAMILY)
 519     if (m_isMainFrameRenderViewLayer) {
 520         // Page scale is applied above the RenderView on iOS.
 521         m_graphicsLayer-&gt;setContentsOpaque(!compositor().viewHasTransparentBackground());
 522         m_graphicsLayer-&gt;setAppliesPageScale();
 523     }
 524 #endif
 525 
 526 #if PLATFORM(COCOA) &amp;&amp; USE(CA)
 527     if (!compositor().acceleratedDrawingEnabled() &amp;&amp; renderer().isCanvas()) {
 528         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 529         if (canvas-&gt;shouldAccelerate(canvas-&gt;size()))
 530             m_graphicsLayer-&gt;setAcceleratesDrawing(true);
 531     }
 532 #endif
 533 
 534     updateOpacity(renderer().style());
 535     updateTransform(renderer().style());
 536     updateFilters(renderer().style());
 537 #if ENABLE(FILTERS_LEVEL_2)
 538     updateBackdropFilters(renderer().style());
 539 #endif
 540 #if ENABLE(CSS_COMPOSITING)
 541     updateBlendMode(renderer().style());
 542 #endif
 543     updateCustomAppearance(renderer().style());
 544 }
 545 
 546 #if PLATFORM(IOS_FAMILY)
 547 void RenderLayerBacking::layerWillBeDestroyed()
 548 {
 549     auto&amp; renderer = this-&gt;renderer();
 550     if (is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing()) {
 551         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer).widget());
 552         if (pluginViewBase &amp;&amp; m_graphicsLayer-&gt;contentsLayerForMedia())
 553             pluginViewBase-&gt;detachPluginLayer();
 554     }
 555 }
 556 
 557 bool RenderLayerBacking::needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(const GraphicsLayer&amp; layer) const
 558 {
 559     if (m_isMainFrameRenderViewLayer &amp;&amp; IOSApplication::isDumpRenderTree()) {
 560         // In iOS WebKit1 the main frame&#39;s RenderView layer is always transparent. We lie that it is opaque so that
 561         // internals.layerTreeAsText() tests succeed.
 562         ASSERT_UNUSED(layer, !layer.contentsOpaque());
 563         return true;
 564     }
 565     return false;
 566 }
 567 #endif
 568 
 569 void RenderLayerBacking::destroyGraphicsLayers()
 570 {
 571     if (m_graphicsLayer) {
 572         m_graphicsLayer-&gt;setMaskLayer(nullptr);
 573         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 574         willDestroyLayer(m_graphicsLayer.get());
 575     }
 576 
 577     GraphicsLayer::clear(m_maskLayer);
 578 
 579     if (m_ancestorClippingStack) {
 580         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())
 581             GraphicsLayer::unparentAndClear(entry.clippingLayer);
 582     }
 583 
 584     GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
 585     GraphicsLayer::unparentAndClear(m_foregroundLayer);
 586     GraphicsLayer::unparentAndClear(m_backgroundLayer);
 587     GraphicsLayer::unparentAndClear(m_childContainmentLayer);
 588     GraphicsLayer::unparentAndClear(m_childClippingMaskLayer);
 589     GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
 590     GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
 591     GraphicsLayer::unparentAndClear(m_graphicsLayer);
 592 }
 593 
 594 void RenderLayerBacking::updateOpacity(const RenderStyle&amp; style)
 595 {
 596     m_graphicsLayer-&gt;setOpacity(compositingOpacity(style.opacity()));
 597 }
 598 
 599 void RenderLayerBacking::updateTransform(const RenderStyle&amp; style)
 600 {
 601     // FIXME: This could use m_owningLayer.transform(), but that currently has transform-origin
 602     // baked into it, and we don&#39;t want that.
 603     TransformationMatrix t;
 604     if (m_owningLayer.hasTransform()) {
 605         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 606         style.applyTransform(t, snapRectToDevicePixels(renderBox.borderBoxRect(), deviceScaleFactor()), RenderStyle::ExcludeTransformOrigin);
 607         makeMatrixRenderable(t, compositor().canRender3DTransforms());
 608     }
 609 
 610     if (m_contentsContainmentLayer) {
 611         m_contentsContainmentLayer-&gt;setTransform(t);
 612         m_graphicsLayer-&gt;setTransform({ });
 613     } else
 614         m_graphicsLayer-&gt;setTransform(t);
 615 }
 616 
 617 void RenderLayerBacking::updateFilters(const RenderStyle&amp; style)
 618 {
 619     m_canCompositeFilters = m_graphicsLayer-&gt;setFilters(style.filter());
 620 }
 621 
 622 #if ENABLE(FILTERS_LEVEL_2)
 623 void RenderLayerBacking::updateBackdropFilters(const RenderStyle&amp; style)
 624 {
 625     m_canCompositeBackdropFilters = m_graphicsLayer-&gt;setBackdropFilters(style.backdropFilter());
 626 }
 627 
 628 void RenderLayerBacking::updateBackdropFiltersGeometry()
 629 {
 630     if (!m_canCompositeBackdropFilters)
 631         return;
 632 
 633     if (!is&lt;RenderBox&gt;(renderer()))
 634         return;
 635 
 636     auto&amp; renderer = downcast&lt;RenderBox&gt;(this-&gt;renderer());
 637     LayoutRect boxRect = renderer.borderBoxRect();
 638     if (renderer.hasClip())
 639         boxRect.intersect(renderer.clipRect(LayoutPoint(), nullptr));
 640     boxRect.move(contentOffsetInCompositingLayer());
 641 
 642     FloatRoundedRect backdropFiltersRect;
 643     if (renderer.style().hasBorderRadius() &amp;&amp; !renderer.hasClip())
 644         backdropFiltersRect = renderer.style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 645     else
 646         backdropFiltersRect = FloatRoundedRect(snapRectToDevicePixels(boxRect, deviceScaleFactor()));
 647 
 648     m_graphicsLayer-&gt;setBackdropFiltersRect(backdropFiltersRect);
 649 }
 650 #endif
 651 
 652 #if ENABLE(CSS_COMPOSITING)
 653 void RenderLayerBacking::updateBlendMode(const RenderStyle&amp; style)
 654 {
 655     // FIXME: where is the blend mode updated when m_ancestorClippingStacks come and go?
 656     if (m_ancestorClippingStack) {
 657         m_ancestorClippingStack-&gt;stack().first().clippingLayer-&gt;setBlendMode(style.blendMode());
 658         m_graphicsLayer-&gt;setBlendMode(BlendMode::Normal);
 659     } else
 660         m_graphicsLayer-&gt;setBlendMode(style.blendMode());
 661 }
 662 #endif
 663 
 664 void RenderLayerBacking::updateCustomAppearance(const RenderStyle&amp; style)
 665 {
 666     ControlPart appearance = style.appearance();
 667     if (appearance == MediaControlsLightBarBackgroundPart)
 668         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::LightBackdrop);
 669     else if (appearance == MediaControlsDarkBarBackgroundPart)
 670         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::DarkBackdrop);
 671     else
 672         m_graphicsLayer-&gt;setCustomAppearance(GraphicsLayer::CustomAppearance::None);
 673 }
 674 
 675 static bool layerOrAncestorIsTransformedOrUsingCompositedScrolling(RenderLayer&amp; layer)
 676 {
 677     for (auto* curr = &amp;layer; curr; curr = curr-&gt;parent()) {
 678         if (curr-&gt;hasTransform() || curr-&gt;hasCompositedScrollableOverflow())
 679             return true;
 680     }
 681 
 682     return false;
 683 }
 684 
 685 bool RenderLayerBacking::shouldClipCompositedBounds() const
 686 {
 687 #if !PLATFORM(IOS_FAMILY)
 688     // Scrollbar layers use this layer for relative positioning, so don&#39;t clip.
 689     if (layerForHorizontalScrollbar() || layerForVerticalScrollbar())
 690         return false;
 691 #endif
 692 
 693     if (m_isFrameLayerWithTiledBacking)
 694         return false;
 695 
 696     if (layerOrAncestorIsTransformedOrUsingCompositedScrolling(m_owningLayer))
 697         return false;
 698 
 699     return true;
 700 }
 701 
 702 static bool hasNonZeroTransformOrigin(const RenderObject&amp; renderer)
 703 {
 704     const RenderStyle&amp; style = renderer.style();
 705     return (style.transformOriginX().type() == Fixed &amp;&amp; style.transformOriginX().value())
 706         || (style.transformOriginY().type() == Fixed &amp;&amp; style.transformOriginY().value());
 707 }
 708 
 709 bool RenderLayerBacking::updateCompositedBounds()
 710 {
 711 #if USE(OWNING_LAYER_BEAR_TRAP)
 712     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
 713     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateCompositedBounds(): m_owningLayer is null (55699292)&quot;);
 714 #endif
 715 
 716     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&amp;m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
 717     // Clip to the size of the document or enclosing overflow-scroll layer.
 718     // If this or an ancestor is transformed, we can&#39;t currently compute the correct rect to intersect with.
 719     // We&#39;d need RenderObject::convertContainerToLocalQuad(), which doesn&#39;t yet exist.
 720     if (shouldClipCompositedBounds()) {
 721         auto&amp; view = renderer().view();
 722         auto* rootLayer = view.layer();
 723 
 724         LayoutRect clippingBounds;
 725         if (renderer().isFixedPositioned() &amp;&amp; renderer().container() == &amp;view)
 726             clippingBounds = view.frameView().rectForFixedPositionLayout();
 727         else
 728             clippingBounds = view.unscaledDocumentRect();
 729 
 730         if (&amp;m_owningLayer != rootLayer)
 731             clippingBounds.intersect(m_owningLayer.backgroundClipRect(RenderLayer::ClipRectsContext(rootLayer, AbsoluteClipRects)).rect()); // FIXME: Incorrect for CSS regions.
 732 
 733         LayoutPoint delta = m_owningLayer.convertToLayerCoords(rootLayer, LayoutPoint(), RenderLayer::AdjustForColumns);
 734         clippingBounds.move(-delta.x(), -delta.y());
 735 
 736         layerBounds.intersect(clippingBounds);
 737     }
 738 
 739     // If the backing provider has overflow:clip, we know all sharing layers are affected by the clip because they are containing-block descendants.
 740     if (!renderer().hasOverflowClip()) {
 741         for (auto&amp; layerWeakPtr : m_backingSharingLayers) {
 742             auto* boundsRootLayer = &amp;m_owningLayer;
 743             ASSERT(layerWeakPtr-&gt;isDescendantOf(m_owningLayer));
 744             auto offset = layerWeakPtr-&gt;offsetFromAncestor(&amp;m_owningLayer);
 745             auto bounds = layerWeakPtr-&gt;calculateLayerBounds(boundsRootLayer, offset, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
 746             layerBounds.unite(bounds);
 747         }
 748     }
 749 
 750     // If the element has a transform-origin that has fixed lengths, and the renderer has zero size,
 751     // then we need to ensure that the compositing layer has non-zero size so that we can apply
 752     // the transform-origin via the GraphicsLayer anchorPoint (which is expressed as a fractional value).
 753     if (layerBounds.isEmpty() &amp;&amp; (hasNonZeroTransformOrigin(renderer()) || renderer().style().hasPerspective())) {
 754         layerBounds.setWidth(1);
 755         layerBounds.setHeight(1);
 756         m_artificiallyInflatedBounds = true;
 757     } else
 758         m_artificiallyInflatedBounds = false;
 759 
 760     return setCompositedBounds(layerBounds);
 761 }
 762 
 763 void RenderLayerBacking::updateAllowsBackingStoreDetaching(const LayoutRect&amp; absoluteBounds)
 764 {
 765     auto setAllowsBackingStoreDetaching = [&amp;](bool allowDetaching) {
 766         m_graphicsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);
 767         if (m_foregroundLayer)
 768             m_foregroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);
 769         if (m_backgroundLayer)
 770             m_backgroundLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);
 771         if (m_scrolledContentsLayer)
 772             m_scrolledContentsLayer-&gt;setAllowsBackingStoreDetaching(allowDetaching);
 773     };
 774 
 775     if (!m_owningLayer.behavesAsFixed()) {
 776         setAllowsBackingStoreDetaching(true);
 777         return;
 778     }
 779 
 780     // We&#39;ll allow detaching if the layer is outside the layout viewport. Fixed layers inside
 781     // the layout viewport can be revealed by async scrolling, so we want to pin their backing store.
 782     FrameView&amp; frameView = renderer().view().frameView();
 783     LayoutRect fixedLayoutRect;
 784     if (frameView.useFixedLayout())
 785         fixedLayoutRect = renderer().view().unscaledDocumentRect();
 786     else
 787         fixedLayoutRect = frameView.rectForFixedPositionLayout();
 788 
 789     bool allowDetaching = !fixedLayoutRect.intersects(absoluteBounds);
 790     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;RenderLayerBacking (layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot;) updateAllowsBackingStoreDetaching - absoluteBounds &quot; &lt;&lt; absoluteBounds &lt;&lt; &quot; layoutViewportRect &quot; &lt;&lt; fixedLayoutRect &lt;&lt; &quot;, allowDetaching &quot; &lt;&lt; allowDetaching);
 791     setAllowsBackingStoreDetaching(allowDetaching);
 792 }
 793 
 794 void RenderLayerBacking::updateAfterWidgetResize()
 795 {
 796     if (!is&lt;RenderWidget&gt;(renderer()))
 797         return;
 798 
 799     if (auto* innerCompositor = RenderLayerCompositor::frameContentsCompositor(downcast&lt;RenderWidget&gt;(renderer()))) {
 800         innerCompositor-&gt;frameViewDidChangeSize();
 801         innerCompositor-&gt;frameViewDidChangeLocation(flooredIntPoint(contentsBox().location()));
 802     }
 803 }
 804 
 805 void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)
 806 {
 807 #if USE(OWNING_LAYER_BEAR_TRAP)
 808     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
 809     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterLayout(): m_owningLayer is null (55699292)&quot;);
 810 #endif
 811 
 812     LOG(Compositing, &quot;RenderLayerBacking %p updateAfterLayout (layer %p)&quot;, this, &amp;m_owningLayer);
 813 
 814     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
 815     // when we know the final compositing hierarchy. We can&#39;t just set dirty bits from RenderLayer::setSize() because that doesn&#39;t
 816     // take overflow into account.
 817     if (updateCompositedBounds()) {
 818         m_owningLayer.setNeedsCompositingGeometryUpdate();
 819         // This layer&#39;s geometry affects those of its children.
 820         m_owningLayer.setChildrenNeedCompositingGeometryUpdate();
 821     } else if (needsClippingUpdate) {
 822         m_owningLayer.setNeedsCompositingConfigurationUpdate();
 823         m_owningLayer.setNeedsCompositingGeometryUpdate();
 824     }
 825 
 826     if (needsFullRepaint &amp;&amp; canIssueSetNeedsDisplay())
 827         setContentsNeedDisplay();
 828 }
 829 
 830 // This can only update things that don&#39;t require up-to-date layout.
 831 void RenderLayerBacking::updateConfigurationAfterStyleChange()
 832 {
 833     updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath());
 834 
 835     if (m_owningLayer.hasReflection()) {
 836         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 837             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 838             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 839         }
 840     } else
 841         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 842 
 843     // FIXME: do we care if opacity is animating?
 844     auto&amp; style = renderer().style();
 845     updateOpacity(style);
 846     updateFilters(style);
 847 
 848 #if ENABLE(FILTERS_LEVEL_2)
 849     updateBackdropFilters(style);
 850 #endif
 851 #if ENABLE(CSS_COMPOSITING)
 852     updateBlendMode(style);
 853 #endif
 854     updateCustomAppearance(style);
 855 }
 856 
 857 bool RenderLayerBacking::updateConfiguration(const RenderLayer* compositingAncestor)
 858 {
 859     ASSERT(!m_owningLayer.normalFlowListDirty());
 860     ASSERT(!m_owningLayer.zOrderListsDirty());
 861     ASSERT(!renderer().view().needsLayout());
 862 
 863     bool layerConfigChanged = false;
 864     auto&amp; compositor = this-&gt;compositor();
 865 
 866     setBackgroundLayerPaintsFixedRootBackground(compositor.needsFixedRootBackgroundLayer(m_owningLayer));
 867 
 868     if (updateBackgroundLayer(m_backgroundLayerPaintsFixedRootBackground || m_requiresBackgroundLayer))
 869         layerConfigChanged = true;
 870 
 871     if (updateForegroundLayer(compositor.needsContentsCompositingLayer(m_owningLayer)))
 872         layerConfigChanged = true;
 873 
 874     bool needsDescendantsClippingLayer = false;
 875     bool usesCompositedScrolling = m_owningLayer.hasCompositedScrollableOverflow();
 876 
 877     if (usesCompositedScrolling) {
 878         // If it&#39;s scrollable, it has to be a box.
 879         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
 880         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(renderBox.borderBoxRect()).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
 881         needsDescendantsClippingLayer = contentsClippingRect.isRounded();
 882     } else
 883         needsDescendantsClippingLayer = RenderLayerCompositor::clipsCompositingDescendants(m_owningLayer);
 884 
 885     if (updateScrollingLayers(usesCompositedScrolling))
 886         layerConfigChanged = true;
 887 
 888     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
 889         layerConfigChanged = true;
 890 
 891     ASSERT(compositingAncestor == m_owningLayer.ancestorCompositingLayer());
 892     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
 893         layerConfigChanged = true;
 894 
 895     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
 896         layerConfigChanged = true;
 897 
 898     if (layerConfigChanged)
 899         updateInternalHierarchy();
 900 
 901     if (auto* flatteningLayer = tileCacheFlatteningLayer()) {
 902         if (layerConfigChanged || flatteningLayer-&gt;parent() != m_graphicsLayer.get())
 903             m_graphicsLayer-&gt;addChild(*flatteningLayer);
 904     }
 905 
 906     if (updateMaskingLayer(renderer().hasMask(), renderer().hasClipPath()))
 907         layerConfigChanged = true;
 908 
 909     updateChildClippingStrategy(needsDescendantsClippingLayer);
 910 
 911     if (m_owningLayer.hasReflection()) {
 912         if (m_owningLayer.reflectionLayer()-&gt;backing()) {
 913             auto* reflectionLayer = m_owningLayer.reflectionLayer()-&gt;backing()-&gt;graphicsLayer();
 914             m_graphicsLayer-&gt;setReplicatedByLayer(reflectionLayer);
 915         }
 916     } else
 917         m_graphicsLayer-&gt;setReplicatedByLayer(nullptr);
 918 
 919     PaintedContentsInfo contentsInfo(*this);
 920 
 921     // Requires layout.
 922     if (!m_owningLayer.isRenderViewLayer()) {
 923         bool didUpdateContentsRect = false;
 924         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
 925     } else
 926         updateRootLayerConfiguration();
 927 
 928     // Requires layout.
 929     if (contentsInfo.isDirectlyCompositedImage())
 930         updateImageContents(contentsInfo);
 931 
 932     if (is&lt;RenderEmbeddedObject&gt;(renderer()) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer()).allowsAcceleratedCompositing()) {
 933         auto* pluginViewBase = downcast&lt;PluginViewBase&gt;(downcast&lt;RenderWidget&gt;(renderer()).widget());
 934 #if PLATFORM(IOS_FAMILY)
 935         if (pluginViewBase &amp;&amp; !m_graphicsLayer-&gt;contentsLayerForMedia()) {
 936             pluginViewBase-&gt;detachPluginLayer();
 937             pluginViewBase-&gt;attachPluginLayer();
 938         }
 939 #else
 940         if (!pluginViewBase-&gt;shouldNotAddLayer())
 941             m_graphicsLayer-&gt;setContentsToPlatformLayer(pluginViewBase-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Plugin);
 942 #endif
 943     }
 944 #if ENABLE(VIDEO)
 945     else if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo()) {
 946         auto* mediaElement = downcast&lt;HTMLMediaElement&gt;(renderer().element());
 947         m_graphicsLayer-&gt;setContentsToPlatformLayer(mediaElement-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Media);
 948         // Requires layout.
 949         resetContentsRect();
 950     }
 951 #endif
 952 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)
 953     else if (renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
 954         const HTMLCanvasElement* canvas = downcast&lt;HTMLCanvasElement&gt;(renderer().element());
 955         if (auto* context = canvas-&gt;renderingContext())
 956             m_graphicsLayer-&gt;setContentsToPlatformLayer(context-&gt;platformLayer(), GraphicsLayer::ContentsLayerPurpose::Canvas);
 957 
 958         layerConfigChanged = true;
 959     }
 960 #endif
 961     if (is&lt;RenderWidget&gt;(renderer()) &amp;&amp; compositor.parentFrameContentLayers(downcast&lt;RenderWidget&gt;(renderer()))) {
 962         m_owningLayer.setNeedsCompositingGeometryUpdate();
 963         layerConfigChanged = true;
 964     }
 965 
 966     if (is&lt;RenderImage&gt;(renderer()) &amp;&amp; downcast&lt;RenderImage&gt;(renderer()).isEditableImage()) {
 967         auto element = renderer().element();
 968         if (is&lt;HTMLImageElement&gt;(element)) {
 969             m_graphicsLayer-&gt;setContentsToEmbeddedView(GraphicsLayer::ContentsLayerEmbeddedViewType::EditableImage, downcast&lt;HTMLImageElement&gt;(element)-&gt;editableImageViewID());
 970             layerConfigChanged = true;
 971         }
 972     }
 973 
 974     if (layerConfigChanged)
 975         updatePaintingPhases();
 976 
 977 #if USE(OWNING_LAYER_BEAR_TRAP)
 978     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
 979     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateConfiguration(): m_owningLayer is null (55699292)&quot;);
 980 #endif
 981 
 982     return layerConfigChanged;
 983 }
 984 
 985 static LayoutRect clipBox(RenderBox&amp; renderer)
 986 {
 987     LayoutRect result = LayoutRect::infiniteRect();
 988     if (renderer.hasOverflowClip())
 989         result = renderer.overflowClipRect(LayoutPoint(), 0); // FIXME: Incorrect for CSS regions.
 990 
 991     if (renderer.hasClip())
 992         result.intersect(renderer.clipRect(LayoutPoint(), 0)); // FIXME: Incorrect for CSS regions.
 993 
 994     return result;
 995 }
 996 
 997 static bool subpixelOffsetFromRendererChanged(const LayoutSize&amp; oldSubpixelOffsetFromRenderer, const LayoutSize&amp; newSubpixelOffsetFromRenderer, float deviceScaleFactor)
 998 {
 999     FloatSize previous = snapSizeToDevicePixel(oldSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
1000     FloatSize current = snapSizeToDevicePixel(newSubpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor);
1001     return previous != current;
1002 }
1003 
1004 static FloatSize subpixelForLayerPainting(const LayoutPoint&amp; point, float pixelSnappingFactor)
1005 {
1006     LayoutUnit x = point.x();
1007     LayoutUnit y = point.y();
1008     x = x &gt;= 0 ? floorToDevicePixel(x, pixelSnappingFactor) : ceilToDevicePixel(x, pixelSnappingFactor);
1009     y = y &gt;= 0 ? floorToDevicePixel(y, pixelSnappingFactor) : ceilToDevicePixel(y, pixelSnappingFactor);
1010     return point - LayoutPoint(x, y);
1011 }
1012 
1013 struct OffsetFromRenderer {
1014     // 1.2px - &gt; { m_devicePixelOffset = 1px m_subpixelOffset = 0.2px }
1015     LayoutSize m_devicePixelOffset;
1016     LayoutSize m_subpixelOffset;
1017 };
1018 
1019 static OffsetFromRenderer computeOffsetFromRenderer(const LayoutSize&amp; offset, float deviceScaleFactor)
1020 {
1021     OffsetFromRenderer offsetFromRenderer;
1022     offsetFromRenderer.m_subpixelOffset = LayoutSize(subpixelForLayerPainting(toLayoutPoint(offset), deviceScaleFactor));
1023     offsetFromRenderer.m_devicePixelOffset = offset - offsetFromRenderer.m_subpixelOffset;
1024     return offsetFromRenderer;
1025 }
1026 
1027 struct SnappedRectInfo {
1028     LayoutRect m_snappedRect;
1029     LayoutSize m_snapDelta;
1030 };
1031 
1032 static SnappedRectInfo snappedGraphicsLayer(const LayoutSize&amp; offset, const LayoutSize&amp; size, float deviceScaleFactor)
1033 {
1034     SnappedRectInfo snappedGraphicsLayer;
1035     LayoutRect graphicsLayerRect = LayoutRect(toLayoutPoint(offset), size);
1036     snappedGraphicsLayer.m_snappedRect = LayoutRect(snapRectToDevicePixels(graphicsLayerRect, deviceScaleFactor));
1037     snappedGraphicsLayer.m_snapDelta = snappedGraphicsLayer.m_snappedRect.location() - toLayoutPoint(offset);
1038     return snappedGraphicsLayer;
1039 }
1040 
1041 static LayoutSize computeOffsetFromAncestorGraphicsLayer(const RenderLayer* compositedAncestor, const LayoutPoint&amp; location, float deviceScaleFactor)
1042 {
1043     if (!compositedAncestor)
1044         return toLayoutSize(location);
1045 
1046     // FIXME: This is a workaround until after webkit.org/162634 gets fixed. ancestorSubpixelOffsetFromRenderer
1047     // could be stale when a dynamic composited state change triggers a pre-order updateGeometry() traversal.
1048     LayoutSize ancestorSubpixelOffsetFromRenderer = compositedAncestor-&gt;backing()-&gt;subpixelOffsetFromRenderer();
1049     LayoutRect ancestorCompositedBounds = compositedAncestor-&gt;backing()-&gt;compositedBounds();
1050     LayoutSize floored = toLayoutSize(LayoutPoint(floorPointToDevicePixels(ancestorCompositedBounds.location() - ancestorSubpixelOffsetFromRenderer, deviceScaleFactor)));
1051     LayoutSize ancestorRendererOffsetFromAncestorGraphicsLayer = -(floored + ancestorSubpixelOffsetFromRenderer);
1052     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
1053 }
1054 
1055 class ComputedOffsets {
1056 public:
1057     ComputedOffsets(const RenderLayer&amp; renderLayer, const RenderLayer* compositingAncestor, const LayoutRect&amp; localRect, const LayoutRect&amp; parentGraphicsLayerRect, const LayoutRect&amp; primaryGraphicsLayerRect)
1058         : m_renderLayer(renderLayer)
1059         , m_compositingAncestor(compositingAncestor)
1060         , m_location(localRect.location())
1061         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
1062         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
1063         , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
1064     {
1065     }
1066 
1067     LayoutSize fromParentGraphicsLayer()
1068     {
1069         if (!m_fromParentGraphicsLayer)
1070             m_fromParentGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset;
1071         return m_fromParentGraphicsLayer.value();
1072     }
1073 
1074     LayoutSize fromPrimaryGraphicsLayer()
1075     {
1076         if (!m_fromPrimaryGraphicsLayer)
1077             m_fromPrimaryGraphicsLayer = fromAncestorGraphicsLayer() - m_parentGraphicsLayerOffset - m_primaryGraphicsLayerOffset;
1078         return m_fromPrimaryGraphicsLayer.value();
1079     }
1080 
1081 private:
1082     LayoutSize fromAncestorGraphicsLayer()
1083     {
1084         if (!m_fromAncestorGraphicsLayer) {
1085             LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(m_compositingAncestor, m_location, RenderLayer::AdjustForColumns);
1086             m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(m_compositingAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
1087         }
1088         return m_fromAncestorGraphicsLayer.value();
1089     }
1090 
1091     Optional&lt;LayoutSize&gt; m_fromAncestorGraphicsLayer;
1092     Optional&lt;LayoutSize&gt; m_fromParentGraphicsLayer;
1093     Optional&lt;LayoutSize&gt; m_fromPrimaryGraphicsLayer;
1094 
1095     const RenderLayer&amp; m_renderLayer;
1096     const RenderLayer* m_compositingAncestor;
1097     // Location is relative to the renderer.
1098     const LayoutPoint m_location;
1099     const LayoutSize m_parentGraphicsLayerOffset;
1100     const LayoutSize m_primaryGraphicsLayerOffset;
1101     float m_deviceScaleFactor;
1102 };
1103 
1104 LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect&amp; parentGraphicsLayerRect) const
1105 {
1106     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, { });
1107     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
1108         deviceScaleFactor()));
1109 }
1110 
1111 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
1112 LayoutRect RenderLayerBacking::computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const
1113 {
1114     if (!compositedAncestor || !compositedAncestor-&gt;backing())
1115         return renderer().view().documentRect();
1116 
1117     auto* ancestorBackingLayer = compositedAncestor-&gt;backing();
1118     LayoutRect parentGraphicsLayerRect;
1119     if (m_owningLayer.isInsideFragmentedFlow()) {
1120         // FIXME: flows/columns need work.
1121         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1122         ancestorCompositedBounds.setLocation(LayoutPoint());
1123         parentGraphicsLayerRect = ancestorCompositedBounds;
1124     }
1125 
1126     if (ancestorBackingLayer-&gt;hasClippingLayer()) {
1127         // If the compositing ancestor has a layer to clip children, we parent in that, and therefore position relative to it.
1128         LayoutRect clippingBox = clipBox(downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer()));
1129         LayoutSize clippingBoxOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clippingBox.location(), deviceScaleFactor());
1130         parentGraphicsLayerRect = snappedGraphicsLayer(clippingBoxOffset, clippingBox.size(), deviceScaleFactor()).m_snappedRect;
1131     }
1132 
1133     if (compositedAncestor-&gt;hasCompositedScrollableOverflow()) {
1134         LayoutRect ancestorCompositedBounds = ancestorBackingLayer-&gt;compositedBounds();
1135         auto&amp; renderBox = downcast&lt;RenderBox&gt;(compositedAncestor-&gt;renderer());
1136         LayoutRect paddingBoxIncludingScrollbar = renderBox.paddingBoxRectIncludingScrollbar();
1137         ScrollOffset scrollOffset = compositedAncestor-&gt;scrollOffset();
1138         parentGraphicsLayerRect = LayoutRect((paddingBoxIncludingScrollbar.location() - toLayoutSize(ancestorCompositedBounds.location()) - toLayoutSize(scrollOffset)), paddingBoxIncludingScrollbar.size());
1139     }
1140 
1141     return parentGraphicsLayerRect;
1142 }
1143 
1144 void RenderLayerBacking::updateGeometry(const RenderLayer* compositedAncestor)
1145 {
1146     ASSERT(!m_owningLayer.normalFlowListDirty());
1147     ASSERT(!m_owningLayer.zOrderListsDirty());
1148     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
1149     ASSERT(!renderer().view().needsLayout());
1150 
1151     const RenderStyle&amp; style = renderer().style();
1152 
1153     bool isRunningAcceleratedTransformAnimation = false;
1154     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1155         if (auto* timeline = renderer().documentTimeline())
1156             isRunningAcceleratedTransformAnimation = timeline-&gt;isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1157     } else
1158         isRunningAcceleratedTransformAnimation = renderer().animation().isRunningAcceleratedAnimationOnRenderer(renderer(), CSSPropertyTransform);
1159 
1160     updateTransform(style);
1161     updateOpacity(style);
1162     updateFilters(style);
1163 #if ENABLE(FILTERS_LEVEL_2)
1164     updateBackdropFilters(style);
1165 #endif
1166 #if ENABLE(CSS_COMPOSITING)
1167     updateBlendMode(style);
1168 #endif
1169 
1170     ASSERT(compositedAncestor == m_owningLayer.ancestorCompositingLayer());
1171     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
1172 
1173     if (m_ancestorClippingStack) {
1174         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
1175         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
1176         LayoutRect lastClipLayerRect = parentGraphicsLayerRect;
1177 
1178         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {
1179             auto clipRect = entry.clipData.clipRect;
1180             LayoutSize clippingOffset = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, clipRect.location() + offsetFromCompositedAncestor, deviceScaleFactor());
1181             LayoutRect snappedClippingLayerRect = snappedGraphicsLayer(clippingOffset, clipRect.size(), deviceScaleFactor()).m_snappedRect;
1182 
1183             entry.clippingLayer-&gt;setPosition(toLayoutPoint(snappedClippingLayerRect.location() - lastClipLayerRect.location()));
1184             lastClipLayerRect = snappedClippingLayerRect;
1185 
1186             entry.clippingLayer-&gt;setSize(snappedClippingLayerRect.size());
1187 
1188             if (entry.clipData.isOverflowScroll) {
1189                 ScrollOffset scrollOffset = entry.clipData.clippingLayer-&gt;scrollOffset();
1190 
1191                 entry.clippingLayer-&gt;setBoundsOrigin(scrollOffset);
1192                 lastClipLayerRect.moveBy(-scrollOffset);
1193             } else
1194                 entry.clippingLayer-&gt;setBoundsOrigin({ });
1195         }
1196 
1197         parentGraphicsLayerRect = lastClipLayerRect;
1198     }
1199 
1200     LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(compositedAncestor, parentGraphicsLayerRect);
1201 
1202     ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
1203     ComputedOffsets rendererOffset(m_owningLayer, compositedAncestor, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);
1204 
1205     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
1206 
1207     auto primaryLayerPosition = primaryGraphicsLayerRect.location();
1208 
1209     // FIXME: reflections should force transform-style to be flat in the style: https://bugs.webkit.org/show_bug.cgi?id=106959
1210     bool preserves3D = style.transformStyle3D() == TransformStyle3D::Preserve3D &amp;&amp; !renderer().hasReflection();
1211     if (m_contentsContainmentLayer) {
1212         m_contentsContainmentLayer-&gt;setPreserves3D(preserves3D);
1213         m_contentsContainmentLayer-&gt;setPosition(primaryLayerPosition);
1214         primaryLayerPosition = { };
1215         // Use the same size as m_graphicsLayer so transforms behave correctly.
1216         m_contentsContainmentLayer-&gt;setSize(primaryGraphicsLayerRect.size());
1217     }
1218 
1219     auto computeAnimationExtent = [&amp;] () -&gt; Optional&lt;FloatRect&gt; {
1220         LayoutRect animatedBounds;
1221         if (isRunningAcceleratedTransformAnimation &amp;&amp; m_owningLayer.getOverlapBoundsIncludingChildrenAccountingForTransformAnimations(animatedBounds, RenderLayer::IncludeCompositedDescendants))
1222             return FloatRect(animatedBounds);
1223         return { };
1224     };
1225     m_graphicsLayer-&gt;setAnimationExtent(computeAnimationExtent());
1226     m_graphicsLayer-&gt;setPreserves3D(preserves3D);
1227     m_graphicsLayer-&gt;setBackfaceVisibility(style.backfaceVisibility() == BackfaceVisibility::Visible);
1228 
1229     m_graphicsLayer-&gt;setPosition(primaryLayerPosition);
1230     m_graphicsLayer-&gt;setSize(primaryGraphicsLayerRect.size());
1231 
1232     // Compute renderer offset from primary graphics layer. Note that primaryGraphicsLayerRect is in parentGraphicsLayer&#39;s coordinate system which is not necessarily
1233     // the same as the ancestor graphics layer.
1234     OffsetFromRenderer primaryGraphicsLayerOffsetFromRenderer;
1235     LayoutSize oldSubpixelOffsetFromRenderer = m_subpixelOffsetFromRenderer;
1236     primaryGraphicsLayerOffsetFromRenderer = computeOffsetFromRenderer(-rendererOffset.fromPrimaryGraphicsLayer(), deviceScaleFactor());
1237     m_subpixelOffsetFromRenderer = primaryGraphicsLayerOffsetFromRenderer.m_subpixelOffset;
1238     m_hasSubpixelRounding = !m_subpixelOffsetFromRenderer.isZero() || compositedBounds().size() != primaryGraphicsLayerRect.size();
1239 
1240     if (primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset != m_graphicsLayer-&gt;offsetFromRenderer()) {
1241         m_graphicsLayer-&gt;setOffsetFromRenderer(primaryGraphicsLayerOffsetFromRenderer.m_devicePixelOffset);
1242         positionOverflowControlsLayers();
1243     }
1244 
1245     // If we have a layer that clips children, position it.
1246     LayoutRect clippingBox;
1247     if (auto* clipLayer = clippingLayer()) {
1248         // clipLayer is the m_childContainmentLayer.
1249         clippingBox = clipBox(downcast&lt;RenderBox&gt;(renderer()));
1250         // Clipping layer is parented in the primary graphics layer.
1251         LayoutSize clipBoxOffsetFromGraphicsLayer = toLayoutSize(clippingBox.location()) + rendererOffset.fromPrimaryGraphicsLayer();
1252         SnappedRectInfo snappedClippingGraphicsLayer = snappedGraphicsLayer(clipBoxOffsetFromGraphicsLayer, clippingBox.size(), deviceScaleFactor());
1253         clipLayer-&gt;setPosition(snappedClippingGraphicsLayer.m_snappedRect.location());
1254         clipLayer-&gt;setSize(snappedClippingGraphicsLayer.m_snappedRect.size());
1255         clipLayer-&gt;setOffsetFromRenderer(toLayoutSize(clippingBox.location() - snappedClippingGraphicsLayer.m_snapDelta));
1256 
1257         if ((renderer().style().clipPath() || renderer().style().hasBorderRadius()) &amp;&amp; !m_childClippingMaskLayer) {
1258             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
1259             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1260             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));
1261             clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect);
1262         }
1263 
1264         if (m_childClippingMaskLayer &amp;&amp; !m_scrollContainerLayer) {
1265             m_childClippingMaskLayer-&gt;setSize(clipLayer-&gt;size());
1266             m_childClippingMaskLayer-&gt;setPosition(FloatPoint());
1267             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(clipLayer-&gt;offsetFromRenderer());
1268         }
1269     }
1270 
1271     if (m_maskLayer)
1272         updateMaskingLayerGeometry();
1273 
1274     if (renderer().hasTransformRelatedProperty()) {
1275         // Update properties that depend on layer dimensions.
1276         FloatPoint3D transformOrigin = computeTransformOriginForPainting(downcast&lt;RenderBox&gt;(renderer()).borderBoxRect());
1277         FloatPoint layerOffset = roundPointToDevicePixels(toLayoutPoint(rendererOffset.fromParentGraphicsLayer()), deviceScaleFactor());
1278         // Compute the anchor point, which is in the center of the renderer box unless transform-origin is set.
1279         FloatPoint3D anchor(
1280             primaryGraphicsLayerRect.width() ? ((layerOffset.x() - primaryGraphicsLayerRect.x()) + transformOrigin.x()) / primaryGraphicsLayerRect.width() : 0.5,
1281             primaryGraphicsLayerRect.height() ? ((layerOffset.y() - primaryGraphicsLayerRect.y())+ transformOrigin.y()) / primaryGraphicsLayerRect.height() : 0.5,
1282             transformOrigin.z());
1283 
1284         if (m_contentsContainmentLayer)
1285             m_contentsContainmentLayer-&gt;setAnchorPoint(anchor);
1286         else
1287             m_graphicsLayer-&gt;setAnchorPoint(anchor);
1288 
1289         auto* clipLayer = clippingLayer();
1290         if (style.hasPerspective()) {
1291             TransformationMatrix t = owningLayer().perspectiveTransform();
1292 
1293             if (clipLayer) {
1294                 clipLayer-&gt;setChildrenTransform(t);
1295                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1296             }
1297             else
1298                 m_graphicsLayer-&gt;setChildrenTransform(t);
1299         } else {
1300             if (clipLayer)
1301                 clipLayer-&gt;setChildrenTransform(TransformationMatrix());
1302             else
1303                 m_graphicsLayer-&gt;setChildrenTransform(TransformationMatrix());
1304         }
1305     } else {
1306         m_graphicsLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1307         if (m_contentsContainmentLayer)
1308             m_contentsContainmentLayer-&gt;setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
1309     }
1310 
1311     if (m_owningLayer.reflectionLayer() &amp;&amp; m_owningLayer.reflectionLayer()-&gt;isComposited()) {
1312         auto* reflectionBacking = m_owningLayer.reflectionLayer()-&gt;backing();
1313         reflectionBacking-&gt;updateGeometry(&amp;m_owningLayer);
1314 
1315         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
1316         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
1317         FloatRect layerBounds = this-&gt;compositedBounds();
1318         FloatRect reflectionLayerBounds = reflectionBacking-&gt;compositedBounds();
1319         reflectionBacking-&gt;graphicsLayer()-&gt;setReplicatedLayerPosition(FloatPoint(layerBounds.location() - reflectionLayerBounds.location()));
1320     }
1321 
1322     if (m_scrollContainerLayer) {
1323         ASSERT(m_scrolledContentsLayer);
1324         auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
1325         LayoutRect paddingBox = renderBox.paddingBoxRect();
1326         LayoutRect parentLayerBounds = clippingLayer() ? clippingBox : compositedBounds();
1327 
1328         // FIXME: need to do some pixel snapping here.
1329         m_scrollContainerLayer-&gt;setPosition(FloatPoint(paddingBox.location() - parentLayerBounds.location()));
1330         m_scrollContainerLayer-&gt;setSize(roundedIntSize(LayoutSize(renderBox.paddingBoxWidth(), renderBox.paddingBoxHeight())));
1331 
1332         ScrollOffset scrollOffset = m_owningLayer.scrollOffset();
1333         updateScrollOffset(scrollOffset);
1334 
1335         FloatSize oldScrollingLayerOffset = m_scrollContainerLayer-&gt;offsetFromRenderer();
1336         m_scrollContainerLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));
1337 
1338         if (m_childClippingMaskLayer) {
1339             m_childClippingMaskLayer-&gt;setPosition(m_scrollContainerLayer-&gt;position());
1340             m_childClippingMaskLayer-&gt;setSize(m_scrollContainerLayer-&gt;size());
1341             m_childClippingMaskLayer-&gt;setOffsetFromRenderer(toFloatSize(paddingBox.location()));
1342         }
1343 
1344         bool paddingBoxOffsetChanged = oldScrollingLayerOffset != m_scrollContainerLayer-&gt;offsetFromRenderer();
1345 
1346         IntSize scrollSize(m_owningLayer.scrollWidth(), m_owningLayer.scrollHeight());
1347         if (scrollSize != m_scrolledContentsLayer-&gt;size() || paddingBoxOffsetChanged)
1348             m_scrolledContentsLayer-&gt;setNeedsDisplay();
1349 
1350         m_scrolledContentsLayer-&gt;setSize(scrollSize);
1351         m_scrolledContentsLayer-&gt;setScrollOffset(scrollOffset, GraphicsLayer::DontSetNeedsDisplay);
1352         m_scrolledContentsLayer-&gt;setOffsetFromRenderer(toLayoutSize(paddingBox.location()), GraphicsLayer::DontSetNeedsDisplay);
1353 
1354         adjustTiledBackingCoverage();
1355     }
1356 
1357     if (m_foregroundLayer) {
1358         FloatSize foregroundSize;
1359         FloatSize foregroundOffset;
1360         GraphicsLayer::ShouldSetNeedsDisplay needsDisplayOnOffsetChange = GraphicsLayer::SetNeedsDisplay;
1361         if (m_scrolledContentsLayer) {
1362             foregroundSize = m_scrolledContentsLayer-&gt;size();
1363             foregroundOffset = m_scrolledContentsLayer-&gt;offsetFromRenderer() - toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset());
1364             needsDisplayOnOffsetChange = GraphicsLayer::DontSetNeedsDisplay;
1365         } else if (hasClippingLayer()) {
1366             // If we have a clipping layer (which clips descendants), then the foreground layer is a child of it,
1367             // so that it gets correctly sorted with children. In that case, position relative to the clipping layer.
1368             foregroundSize = FloatSize(clippingBox.size());
1369             foregroundOffset = toFloatSize(clippingBox.location());
1370         } else {
1371             foregroundSize = primaryGraphicsLayerRect.size();
1372             foregroundOffset = m_graphicsLayer-&gt;offsetFromRenderer();
1373         }
1374 
1375         m_foregroundLayer-&gt;setPosition({ });
1376         m_foregroundLayer-&gt;setSize(foregroundSize);
1377         m_foregroundLayer-&gt;setOffsetFromRenderer(foregroundOffset, needsDisplayOnOffsetChange);
1378     }
1379 
1380     if (m_backgroundLayer) {
1381         FloatPoint backgroundPosition;
1382         FloatSize backgroundSize = primaryGraphicsLayerRect.size();
1383         if (backgroundLayerPaintsFixedRootBackground()) {
1384             const FrameView&amp; frameView = renderer().view().frameView();
1385             backgroundPosition = frameView.scrollPositionForFixedPosition();
1386             backgroundSize = frameView.layoutSize();
1387         } else {
1388             auto boundingBox = renderer().objectBoundingBox();
1389             backgroundPosition = boundingBox.location();
1390             backgroundSize = boundingBox.size();
1391         }
1392         m_backgroundLayer-&gt;setPosition(backgroundPosition);
1393         m_backgroundLayer-&gt;setSize(backgroundSize);
1394         m_backgroundLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1395     }
1396 
1397     // If this layer was created just for clipping or to apply perspective, it doesn&#39;t need its own backing store.
1398     LayoutRect ancestorCompositedBounds = compositedAncestor ? compositedAncestor-&gt;backing()-&gt;compositedBounds() : LayoutRect();
1399     setRequiresOwnBackingStore(compositor().requiresOwnBackingStore(m_owningLayer, compositedAncestor,
1400         LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()), ancestorCompositedBounds));
1401 #if ENABLE(FILTERS_LEVEL_2)
1402     updateBackdropFiltersGeometry();
1403 #endif
1404     updateAfterWidgetResize();
1405 
1406     if (subpixelOffsetFromRendererChanged(oldSubpixelOffsetFromRenderer, m_subpixelOffsetFromRenderer, deviceScaleFactor()) &amp;&amp; canIssueSetNeedsDisplay())
1407         setContentsNeedDisplay();
1408 }
1409 
1410 void RenderLayerBacking::setLocationOfScrolledContents(ScrollOffset scrollOffset, ScrollingLayerPositionAction setOrSync)
1411 {
1412     if (setOrSync == ScrollingLayerPositionAction::Sync)
1413         m_scrollContainerLayer-&gt;syncBoundsOrigin(scrollOffset);
1414     else
1415         m_scrollContainerLayer-&gt;setBoundsOrigin(scrollOffset);
1416 }
1417 
1418 void RenderLayerBacking::updateScrollOffset(ScrollOffset scrollOffset)
1419 {
1420     if (m_owningLayer.currentScrollType() == ScrollType::User) {
1421         // If scrolling is happening externally, we don&#39;t want to touch the layer bounds origin here because that will cause jitter.
1422         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Sync);
1423         m_owningLayer.setRequiresScrollPositionReconciliation(true);
1424     } else {
1425         // Note that we implement the contents offset via the bounds origin on this layer, rather than a position on the sublayer.
1426         setLocationOfScrolledContents(scrollOffset, ScrollingLayerPositionAction::Set);
1427         m_owningLayer.setRequiresScrollPositionReconciliation(false);
1428     }
1429 
1430     ASSERT(m_scrolledContentsLayer-&gt;position().isZero());
1431 }
1432 
1433 void RenderLayerBacking::updateAfterDescendants()
1434 {
1435     // FIXME: this potentially duplicates work we did in updateConfiguration().
1436     PaintedContentsInfo contentsInfo(*this);
1437     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText() &amp;&amp; FontCascade::isSubpixelAntialiasingAvailable());
1438 
1439     if (!m_owningLayer.isRenderViewLayer()) {
1440         bool didUpdateContentsRect = false;
1441         updateDirectlyCompositedBoxDecorations(contentsInfo, didUpdateContentsRect);
1442         if (!didUpdateContentsRect &amp;&amp; m_graphicsLayer-&gt;usesContentsLayer())
1443             resetContentsRect();
1444     }
1445 
1446     updateDrawsContent(contentsInfo);
1447 
1448     if (!m_isMainFrameRenderViewLayer &amp;&amp; !m_isFrameLayerWithTiledBacking &amp;&amp; !m_requiresBackgroundLayer) {
1449         // For non-root layers, background is always painted by the primary graphics layer.
1450         ASSERT(!m_backgroundLayer);
1451         m_graphicsLayer-&gt;setContentsOpaque(!m_hasSubpixelRounding &amp;&amp; m_owningLayer.backgroundIsKnownToBeOpaqueInRect(compositedBounds()));
1452     }
1453 
1454     m_graphicsLayer-&gt;setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
1455     if (m_scrollContainerLayer) {
1456         m_scrollContainerLayer-&gt;setContentsVisible(renderer().style().visibility() == Visibility::Visible);
1457         m_scrollContainerLayer-&gt;setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
1458     }
1459 
1460 #if USE(OWNING_LAYER_BEAR_TRAP)
1461     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
1462     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::updateAfterDescendants(): m_owningLayer is null (55699292)&quot;);
1463 #endif
1464 }
1465 
1466 // FIXME: Avoid repaints when clip path changes.
1467 void RenderLayerBacking::updateMaskingLayerGeometry()
1468 {
1469     m_maskLayer-&gt;setSize(m_graphicsLayer-&gt;size());
1470     m_maskLayer-&gt;setPosition(FloatPoint());
1471     m_maskLayer-&gt;setOffsetFromRenderer(m_graphicsLayer-&gt;offsetFromRenderer());
1472 
1473     if (!m_maskLayer-&gt;drawsContent()) {
1474         if (renderer().hasClipPath()) {
1475             ASSERT(renderer().style().clipPath()-&gt;type() != ClipPathOperation::Reference);
1476 
1477             WindRule windRule;
1478             // FIXME: Use correct reference box for inlines: https://bugs.webkit.org/show_bug.cgi?id=129047
1479             LayoutRect boundingBox = m_owningLayer.boundingBox(&amp;m_owningLayer);
1480             LayoutRect referenceBoxForClippedInline = LayoutRect(snapRectToDevicePixels(boundingBox, deviceScaleFactor()));
1481             LayoutSize offset = LayoutSize(snapSizeToDevicePixel(-m_subpixelOffsetFromRenderer, LayoutPoint(), deviceScaleFactor()));
1482             Path clipPath = m_owningLayer.computeClipPath(offset, referenceBoxForClippedInline, windRule);
1483 
1484             FloatSize pathOffset = m_maskLayer-&gt;offsetFromRenderer();
1485             if (!pathOffset.isZero())
1486                 clipPath.translate(-pathOffset);
1487 
1488             m_maskLayer-&gt;setShapeLayerPath(clipPath);
1489             m_maskLayer-&gt;setShapeLayerWindRule(windRule);
1490         }
1491     }
1492 }
1493 
1494 void RenderLayerBacking::updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
1495 {
1496     if (!m_owningLayer.hasVisibleContent())
1497         return;
1498 
1499     // The order of operations here matters, since the last valid type of contents needs
1500     // to also update the contentsRect.
1501     updateDirectlyCompositedBackgroundColor(contentsInfo, didUpdateContentsRect);
1502     updateDirectlyCompositedBackgroundImage(contentsInfo, didUpdateContentsRect);
1503 }
1504 
1505 void RenderLayerBacking::updateInternalHierarchy()
1506 {
1507     // m_foregroundLayer has to be inserted in the correct order with child layers,
1508     // so it&#39;s not inserted here.
1509     GraphicsLayer* lastClippingLayer = nullptr;
1510     if (m_ancestorClippingStack) {
1511         auto&amp; clippingStack = m_ancestorClippingStack-&gt;stack();
1512         for (unsigned i = 0; i &lt; clippingStack.size() - 1; ++i) {
1513             auto&amp; entry = clippingStack.at(i);
1514             Vector&lt;Ref&lt;GraphicsLayer&gt;&gt; children;
1515             children.append(*clippingStack.at(i + 1).clippingLayer);
1516             entry.clippingLayer-&gt;setChildren(WTFMove(children));
1517         }
1518 
1519         lastClippingLayer = clippingStack.last().clippingLayer.get();
1520         lastClippingLayer-&gt;removeAllChildren();
1521     }
1522 
1523     if (m_contentsContainmentLayer) {
1524         m_contentsContainmentLayer-&gt;removeAllChildren();
1525         if (lastClippingLayer)
1526             lastClippingLayer-&gt;addChild(*m_contentsContainmentLayer);
1527     }
1528 
1529     if (m_backgroundLayer)
1530         m_contentsContainmentLayer-&gt;addChild(*m_backgroundLayer);
1531 
1532     if (m_contentsContainmentLayer)
1533         m_contentsContainmentLayer-&gt;addChild(*m_graphicsLayer);
1534     else if (lastClippingLayer)
1535         lastClippingLayer-&gt;addChild(*m_graphicsLayer);
1536 
1537     if (m_childContainmentLayer)
1538         m_graphicsLayer-&gt;addChild(*m_childContainmentLayer);
1539 
1540     if (m_scrollContainerLayer) {
1541         auto* superlayer = m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
1542         superlayer-&gt;addChild(*m_scrollContainerLayer);
1543     }
1544 
1545     // The clip for child layers does not include space for overflow controls, so they exist as
1546     // siblings of the clipping layer if we have one. Normal children of this layer are set as
1547     // children of the clipping layer.
1548     if (m_layerForHorizontalScrollbar)
1549         m_graphicsLayer-&gt;addChild(*m_layerForHorizontalScrollbar);
1550 
1551     if (m_layerForVerticalScrollbar)
1552         m_graphicsLayer-&gt;addChild(*m_layerForVerticalScrollbar);
1553 
1554     if (m_layerForScrollCorner)
1555         m_graphicsLayer-&gt;addChild(*m_layerForScrollCorner);
1556 }
1557 
1558 void RenderLayerBacking::resetContentsRect()
1559 {
1560     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
1561 
1562     if (is&lt;RenderBox&gt;(renderer())) {
1563         LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
1564         boxRect.move(contentOffsetInCompositingLayer());
1565         FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1566         m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
1567     }
1568 
1569     m_graphicsLayer-&gt;setContentsTileSize(IntSize());
1570     m_graphicsLayer-&gt;setContentsTilePhase(IntSize());
1571 }
1572 
1573 void RenderLayerBacking::updateDrawsContent()
1574 {
1575     PaintedContentsInfo contentsInfo(*this);
1576     contentsInfo.setWantsSubpixelAntialiasedTextState(GraphicsLayer::supportsSubpixelAntialiasedLayerText());
1577 
1578     updateDrawsContent(contentsInfo);
1579 }
1580 
1581 void RenderLayerBacking::updateDrawsContent(PaintedContentsInfo&amp; contentsInfo)
1582 {
1583     if (m_scrollContainerLayer) {
1584         // We don&#39;t have to consider overflow controls, because we know that the scrollbars are drawn elsewhere.
1585         // m_graphicsLayer only needs backing store if the non-scrolling parts (background, outlines, borders, shadows etc) need to paint.
1586         // m_scrollContainerLayer never has backing store.
1587         // m_scrolledContentsLayer only needs backing store if the scrolled contents need to paint.
1588         bool hasNonScrollingPaintedContent = m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasVisibleBoxDecorationsOrBackground();
1589         m_graphicsLayer-&gt;setDrawsContent(hasNonScrollingPaintedContent);
1590 
1591         bool hasScrollingPaintedContent = hasBackingSharingLayers() || (m_owningLayer.hasVisibleContent() &amp;&amp; (renderer().hasBackground() || contentsInfo.paintsContent()));
1592         m_scrolledContentsLayer-&gt;setDrawsContent(hasScrollingPaintedContent);
1593         return;
1594     }
1595 
1596     bool hasPaintedContent = containsPaintedContent(contentsInfo);
1597 
1598     m_paintsSubpixelAntialiasedText = renderer().settings().subpixelAntialiasedLayerTextEnabled() &amp;&amp; contentsInfo.paintsSubpixelAntialiasedText();
1599 
1600     // FIXME: we could refine this to only allocate backing for one of these layers if possible.
1601     m_graphicsLayer-&gt;setDrawsContent(hasPaintedContent);
1602     if (m_foregroundLayer) {
1603         m_foregroundLayer-&gt;setDrawsContent(hasPaintedContent);
1604         m_foregroundLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1605         // The text content is painted into the foreground layer.
1606         // FIXME: this ignores SVG background images which may contain text.
1607         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(false);
1608     } else
1609         m_graphicsLayer-&gt;setSupportsSubpixelAntialiasedText(m_paintsSubpixelAntialiasedText);
1610 
1611     if (m_backgroundLayer)
1612         m_backgroundLayer-&gt;setDrawsContent(m_backgroundLayerPaintsFixedRootBackground ? hasPaintedContent : contentsInfo.paintsBoxDecorations());
1613 }
1614 
1615 void RenderLayerBacking::updateEventRegion()
1616 {
1617 #if PLATFORM(IOS_FAMILY)
1618     if (paintsIntoCompositedAncestor())
1619         return;
1620 
1621     bool hasTouchActionElements = false;
1622 #if ENABLE(POINTER_EVENTS)
1623     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
1624 #endif
1625     if (m_owningLayer.isRenderViewLayer() &amp;&amp; !hasTouchActionElements)
1626         return;
1627 
1628     auto updateEventRegionForLayer = [&amp;](GraphicsLayer&amp; graphicsLayer) {
1629         GraphicsContext nullContext(nullptr);
1630         EventRegion eventRegion;
1631         auto eventRegionContext = eventRegion.makeContext();
1632         auto layerOffset = graphicsLayer.scrollOffset() - roundedIntSize(graphicsLayer.offsetFromRenderer());
1633 
1634         if (&amp;graphicsLayer == m_scrolledContentsLayer &amp;&amp; renderer().visibleToHitTesting()) {
1635             // Initialize scrolled contents layer with layer-sized event region as it can all used for scrolling.
1636             // This avoids generating unnecessarily complex event regions. We still need to to do the paint to capture touch-action regions.
1637             eventRegionContext.unite(enclosingIntRect(FloatRect(-layerOffset, graphicsLayer.size())), RenderStyle::defaultStyle());
1638         }
1639 
1640         auto dirtyRect = enclosingIntRect(FloatRect(FloatPoint(graphicsLayer.offsetFromRenderer()), graphicsLayer.size()));
1641         paintIntoLayer(&amp;graphicsLayer, nullContext, dirtyRect, { }, &amp;eventRegionContext);
1642 
1643         eventRegion.translate(toIntSize(layerOffset));
1644 
1645         graphicsLayer.setEventRegion(WTFMove(eventRegion));
1646     };
1647 
1648     updateEventRegionForLayer(*m_graphicsLayer);
1649 
1650     if (m_scrolledContentsLayer)
1651         updateEventRegionForLayer(*m_scrolledContentsLayer);
1652 #endif
1653 }
1654 
1655 bool RenderLayerBacking::updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp; clippingData)
1656 {
1657     if (!m_ancestorClippingStack &amp;&amp; clippingData.isEmpty())
1658         return false;
1659 
1660     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
1661 
1662     if (m_ancestorClippingStack &amp;&amp; clippingData.isEmpty()) {
1663         m_ancestorClippingStack-&gt;clear(scrollingCoordinator);
1664         m_ancestorClippingStack = nullptr;
1665         return true;
1666     }
1667 
1668     if (!m_ancestorClippingStack) {
1669         m_ancestorClippingStack = makeUnique&lt;LayerAncestorClippingStack&gt;(WTFMove(clippingData));
1670         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);
1671         return true;
1672     }
1673 
1674     if (m_ancestorClippingStack-&gt;equalToClipData(clippingData)) {
1675         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);
1676         return false;
1677     }
1678 
1679     m_ancestorClippingStack-&gt;updateWithClipData(scrollingCoordinator, WTFMove(clippingData));
1680     LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;layer &quot; &lt;&lt; &amp;m_owningLayer &lt;&lt; &quot; ancestorClippingStack &quot; &lt;&lt; *m_ancestorClippingStack);
1681     return true;
1682 }
1683 
1684 // Return true if the layer changed.
1685 bool RenderLayerBacking::updateAncestorClipping(bool needsAncestorClip, const RenderLayer* compositingAncestor)
1686 {
1687     bool layersChanged = false;
1688 
1689     if (needsAncestorClip) {
1690         if (compositor().updateAncestorClippingStack(m_owningLayer, compositingAncestor)) {
1691             // Make any layers we don&#39;t have.
1692             if (m_ancestorClippingStack) {
1693                 for (auto&amp; entry : m_ancestorClippingStack-&gt;stack()) {
1694                     if (!entry.clippingLayer) {
1695                         entry.clippingLayer = createGraphicsLayer(entry.clipData.isOverflowScroll ? &quot;clip for scroller&quot; : &quot;ancestor clipping&quot;);
1696                         entry.clippingLayer-&gt;setMasksToBounds(true);
1697                         entry.clippingLayer-&gt;setPaintingPhase({ });
1698                     }
1699                 }
1700             }
1701 
1702             layersChanged = true;
1703         }
1704     } else if (m_ancestorClippingStack) {
1705         for (auto&amp; entry : m_ancestorClippingStack-&gt;stack())
1706             GraphicsLayer::unparentAndClear(entry.clippingLayer);
1707 
1708         m_ancestorClippingStack = nullptr;
1709         layersChanged = true;
1710     }
1711 
1712     return layersChanged;
1713 }
1714 
1715 // Return true if the layer changed.
1716 bool RenderLayerBacking::updateDescendantClippingLayer(bool needsDescendantClip)
1717 {
1718     bool layersChanged = false;
1719 
1720     if (needsDescendantClip) {
1721         if (!m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking) {
1722             m_childContainmentLayer = createGraphicsLayer(&quot;child clipping&quot;);
1723             m_childContainmentLayer-&gt;setMasksToBounds(true);
1724             layersChanged = true;
1725         }
1726     } else if (hasClippingLayer()) {
1727         willDestroyLayer(m_childContainmentLayer.get());
1728         GraphicsLayer::unparentAndClear(m_childContainmentLayer);
1729         layersChanged = true;
1730     }
1731 
1732     return layersChanged;
1733 }
1734 
1735 void RenderLayerBacking::setBackgroundLayerPaintsFixedRootBackground(bool backgroundLayerPaintsFixedRootBackground)
1736 {
1737     if (backgroundLayerPaintsFixedRootBackground == m_backgroundLayerPaintsFixedRootBackground)
1738         return;
1739 
1740     m_backgroundLayerPaintsFixedRootBackground = backgroundLayerPaintsFixedRootBackground;
1741 
1742     if (m_backgroundLayerPaintsFixedRootBackground) {
1743         ASSERT(m_isFrameLayerWithTiledBacking);
1744         renderer().view().frameView().removeSlowRepaintObject(*renderer().view().rendererForRootBackground());
1745     }
1746 }
1747 
1748 void RenderLayerBacking::setRequiresBackgroundLayer(bool requiresBackgroundLayer)
1749 {
1750     if (requiresBackgroundLayer == m_requiresBackgroundLayer)
1751         return;
1752 
1753     m_requiresBackgroundLayer = requiresBackgroundLayer;
1754     m_owningLayer.setNeedsCompositingConfigurationUpdate();
1755 }
1756 
1757 bool RenderLayerBacking::requiresHorizontalScrollbarLayer() const
1758 {
1759     if (!m_owningLayer.hasOverlayScrollbars())
1760         return false;
1761     return m_owningLayer.horizontalScrollbar();
1762 }
1763 
1764 bool RenderLayerBacking::requiresVerticalScrollbarLayer() const
1765 {
1766     if (!m_owningLayer.hasOverlayScrollbars())
1767         return false;
1768     return m_owningLayer.verticalScrollbar();
1769 }
1770 
1771 bool RenderLayerBacking::requiresScrollCornerLayer() const
1772 {
1773     if (!m_owningLayer.hasOverlayScrollbars())
1774         return false;
1775     return !m_owningLayer.scrollCornerAndResizerRect().isEmpty();
1776 }
1777 
1778 bool RenderLayerBacking::updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer)
1779 {
1780     bool horizontalScrollbarLayerChanged = false;
1781     if (needsHorizontalScrollbarLayer) {
1782         if (!m_layerForHorizontalScrollbar) {
1783             m_layerForHorizontalScrollbar = createGraphicsLayer(&quot;horizontal scrollbar&quot;);
1784             m_layerForHorizontalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
1785             horizontalScrollbarLayerChanged = true;
1786         }
1787     } else if (m_layerForHorizontalScrollbar) {
1788         willDestroyLayer(m_layerForHorizontalScrollbar.get());
1789         GraphicsLayer::unparentAndClear(m_layerForHorizontalScrollbar);
1790         horizontalScrollbarLayerChanged = true;
1791     }
1792 
1793     bool verticalScrollbarLayerChanged = false;
1794     if (needsVerticalScrollbarLayer) {
1795         if (!m_layerForVerticalScrollbar) {
1796             m_layerForVerticalScrollbar = createGraphicsLayer(&quot;vertical scrollbar&quot;);
1797             m_layerForVerticalScrollbar-&gt;setAllowsBackingStoreDetaching(false);
1798             verticalScrollbarLayerChanged = true;
1799         }
1800     } else if (m_layerForVerticalScrollbar) {
1801         willDestroyLayer(m_layerForVerticalScrollbar.get());
1802         GraphicsLayer::unparentAndClear(m_layerForVerticalScrollbar);
1803         verticalScrollbarLayerChanged = true;
1804     }
1805 
1806     bool scrollCornerLayerChanged = false;
1807     if (needsScrollCornerLayer) {
1808         if (!m_layerForScrollCorner) {
1809             m_layerForScrollCorner = createGraphicsLayer(&quot;scroll corner&quot;);
1810             m_layerForScrollCorner-&gt;setAllowsBackingStoreDetaching(false);
1811             scrollCornerLayerChanged = true;
1812         }
1813     } else if (m_layerForScrollCorner) {
1814         willDestroyLayer(m_layerForScrollCorner.get());
1815         GraphicsLayer::unparentAndClear(m_layerForScrollCorner);
1816         scrollCornerLayerChanged = true;
1817     }
1818 
1819     if (auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator()) {
1820         if (horizontalScrollbarLayerChanged)
1821             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, HorizontalScrollbar);
1822         if (verticalScrollbarLayerChanged)
1823             scrollingCoordinator-&gt;scrollableAreaScrollbarLayerDidChange(m_owningLayer, VerticalScrollbar);
1824     }
1825 
1826     return horizontalScrollbarLayerChanged || verticalScrollbarLayerChanged || scrollCornerLayerChanged;
1827 }
1828 
1829 void RenderLayerBacking::positionOverflowControlsLayers()
1830 {
1831     if (!m_owningLayer.hasScrollbars())
1832         return;
1833 
1834     const IntRect borderBox = snappedIntRect(renderBox()-&gt;borderBoxRect());
1835 
1836     FloatSize offsetFromRenderer = m_graphicsLayer-&gt;offsetFromRenderer();
1837     if (auto* layer = layerForHorizontalScrollbar()) {
1838         IntRect hBarRect = m_owningLayer.rectForHorizontalScrollbar(borderBox);
1839         layer-&gt;setPosition(hBarRect.location() - offsetFromRenderer);
1840         layer-&gt;setSize(hBarRect.size());
1841         if (layer-&gt;usesContentsLayer()) {
1842             IntRect barRect = IntRect(IntPoint(), hBarRect.size());
1843             layer-&gt;setContentsRect(barRect);
1844             layer-&gt;setContentsClippingRect(FloatRoundedRect(barRect));
1845         }
1846         layer-&gt;setDrawsContent(m_owningLayer.horizontalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1847     }
1848 
1849     if (auto* layer = layerForVerticalScrollbar()) {
1850         IntRect vBarRect = m_owningLayer.rectForVerticalScrollbar(borderBox);
1851         layer-&gt;setPosition(vBarRect.location() - offsetFromRenderer);
1852         layer-&gt;setSize(vBarRect.size());
1853         if (layer-&gt;usesContentsLayer()) {
1854             IntRect barRect = IntRect(IntPoint(), vBarRect.size());
1855             layer-&gt;setContentsRect(barRect);
1856             layer-&gt;setContentsClippingRect(FloatRoundedRect(barRect));
1857         }
1858         layer-&gt;setDrawsContent(m_owningLayer.verticalScrollbar() &amp;&amp; !layer-&gt;usesContentsLayer());
1859     }
1860 
1861     if (auto* layer = layerForScrollCorner()) {
1862         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
1863         layer-&gt;setPosition(scrollCornerAndResizer.location() - offsetFromRenderer);
1864         layer-&gt;setSize(scrollCornerAndResizer.size());
1865         layer-&gt;setDrawsContent(!scrollCornerAndResizer.isEmpty());
1866     }
1867 }
1868 
1869 bool RenderLayerBacking::updateForegroundLayer(bool needsForegroundLayer)
1870 {
1871     bool layerChanged = false;
1872     if (needsForegroundLayer) {
1873         if (!m_foregroundLayer) {
1874             String layerName = m_owningLayer.name() + &quot; (foreground)&quot;;
1875             m_foregroundLayer = createGraphicsLayer(layerName);
1876             m_foregroundLayer-&gt;setDrawsContent(true);
1877             layerChanged = true;
1878         }
1879     } else if (m_foregroundLayer) {
1880         willDestroyLayer(m_foregroundLayer.get());
1881         GraphicsLayer::unparentAndClear(m_foregroundLayer);
1882         layerChanged = true;
1883     }
1884 
1885     return layerChanged;
1886 }
1887 
1888 bool RenderLayerBacking::updateBackgroundLayer(bool needsBackgroundLayer)
1889 {
1890     bool layerChanged = false;
1891     if (needsBackgroundLayer) {
1892         if (!m_backgroundLayer) {
1893             String layerName = m_owningLayer.name() + &quot; (background)&quot;;
1894             m_backgroundLayer = createGraphicsLayer(layerName);
1895             m_backgroundLayer-&gt;setDrawsContent(true);
1896             m_backgroundLayer-&gt;setAnchorPoint(FloatPoint3D());
1897             layerChanged = true;
1898         }
1899 
1900         if (!m_contentsContainmentLayer) {
1901             String layerName = m_owningLayer.name() + &quot; (contents containment)&quot;;
1902             m_contentsContainmentLayer = createGraphicsLayer(layerName);
1903             m_contentsContainmentLayer-&gt;setAppliesPageScale(true);
1904             m_graphicsLayer-&gt;setAppliesPageScale(false);
1905             layerChanged = true;
1906         }
1907     } else {
1908         if (m_backgroundLayer) {
1909             willDestroyLayer(m_backgroundLayer.get());
1910             GraphicsLayer::unparentAndClear(m_backgroundLayer);
1911             layerChanged = true;
1912         }
1913         if (m_contentsContainmentLayer) {
1914             willDestroyLayer(m_contentsContainmentLayer.get());
1915             GraphicsLayer::unparentAndClear(m_contentsContainmentLayer);
1916             layerChanged = true;
1917             m_graphicsLayer-&gt;setAppliesPageScale(true);
1918         }
1919     }
1920 
1921     return layerChanged;
1922 }
1923 
1924 // Masking layer is used for masks or clip-path.
1925 bool RenderLayerBacking::updateMaskingLayer(bool hasMask, bool hasClipPath)
1926 {
1927     bool layerChanged = false;
1928     if (hasMask || hasClipPath) {
1929         OptionSet&lt;GraphicsLayerPaintingPhase&gt; maskPhases;
1930         if (hasMask)
1931             maskPhases = GraphicsLayerPaintingPhase::Mask;
1932 
1933         if (hasClipPath) {
1934             // If we have a mask, we need to paint the combined clip-path and mask into the mask layer.
1935             if (hasMask || renderer().style().clipPath()-&gt;type() == ClipPathOperation::Reference || !GraphicsLayer::supportsLayerType(GraphicsLayer::Type::Shape))
1936                 maskPhases.add(GraphicsLayerPaintingPhase::ClipPath);
1937         }
1938 
1939         bool paintsContent = !maskPhases.isEmpty();
1940         GraphicsLayer::Type requiredLayerType = paintsContent ? GraphicsLayer::Type::Normal : GraphicsLayer::Type::Shape;
1941         if (m_maskLayer &amp;&amp; m_maskLayer-&gt;type() != requiredLayerType) {
1942             m_graphicsLayer-&gt;setMaskLayer(nullptr);
1943             willDestroyLayer(m_maskLayer.get());
1944             GraphicsLayer::clear(m_maskLayer);
1945         }
1946 
1947         if (!m_maskLayer) {
1948             m_maskLayer = createGraphicsLayer(&quot;mask&quot;, requiredLayerType);
1949             m_maskLayer-&gt;setDrawsContent(paintsContent);
1950             m_maskLayer-&gt;setPaintingPhase(maskPhases);
1951             layerChanged = true;
1952             m_graphicsLayer-&gt;setMaskLayer(m_maskLayer.copyRef());
1953             // We need a geometry update to size the new mask layer.
1954             m_owningLayer.setNeedsCompositingGeometryUpdate();
1955         }
1956     } else if (m_maskLayer) {
1957         m_graphicsLayer-&gt;setMaskLayer(nullptr);
1958         willDestroyLayer(m_maskLayer.get());
1959         GraphicsLayer::clear(m_maskLayer);
1960         layerChanged = true;
1961     }
1962 
1963     return layerChanged;
1964 }
1965 
1966 void RenderLayerBacking::updateChildClippingStrategy(bool needsDescendantsClippingLayer)
1967 {
1968     if (hasClippingLayer() &amp;&amp; needsDescendantsClippingLayer) {
1969         if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
1970             auto* clipLayer = clippingLayer();
1971             LayoutRect boxRect(LayoutPoint(), downcast&lt;RenderBox&gt;(renderer()).size());
1972             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
1973             contentsClippingRect.move(LayoutSize(-clipLayer-&gt;offsetFromRenderer()));
1974             // Note that we have to set this rounded rect again during the geometry update (clipLayer-&gt;offsetFromRenderer() may be stale here).
1975             if (clipLayer-&gt;setMasksToBoundsRect(contentsClippingRect)) {
1976                 clipLayer-&gt;setMaskLayer(nullptr);
1977                 GraphicsLayer::clear(m_childClippingMaskLayer);
1978                 return;
1979             }
1980 
1981             if (!m_childClippingMaskLayer) {
1982                 m_childClippingMaskLayer = createGraphicsLayer(&quot;child clipping mask&quot;);
1983                 m_childClippingMaskLayer-&gt;setDrawsContent(true);
1984                 m_childClippingMaskLayer-&gt;setPaintingPhase({ GraphicsLayerPaintingPhase::ChildClippingMask });
1985                 clippingLayer()-&gt;setMaskLayer(m_childClippingMaskLayer.copyRef());
1986             }
1987         }
1988     } else {
1989         if (m_childClippingMaskLayer) {
1990             if (hasClippingLayer())
1991                 clippingLayer()-&gt;setMaskLayer(nullptr);
1992             GraphicsLayer::clear(m_childClippingMaskLayer);
1993         } else
1994             if (hasClippingLayer())
1995                 clippingLayer()-&gt;setMasksToBoundsRect(FloatRoundedRect(FloatRect({ }, clippingLayer()-&gt;size())));
1996     }
1997 }
1998 
1999 bool RenderLayerBacking::updateScrollingLayers(bool needsScrollingLayers)
2000 {
2001     if (needsScrollingLayers == !!m_scrollContainerLayer)
2002         return false;
2003 
2004     if (!m_scrollContainerLayer) {
2005         // Outer layer which corresponds with the scroll view. This never paints content.
2006         m_scrollContainerLayer = createGraphicsLayer(&quot;scroll container&quot;, GraphicsLayer::Type::ScrollContainer);
2007         m_scrollContainerLayer-&gt;setPaintingPhase({ });
2008         m_scrollContainerLayer-&gt;setDrawsContent(false);
2009         m_scrollContainerLayer-&gt;setMasksToBounds(true);
2010 
2011         // Inner layer which renders the content that scrolls.
2012         m_scrolledContentsLayer = createGraphicsLayer(&quot;scrolled contents&quot;, GraphicsLayer::Type::ScrolledContents);
2013         m_scrolledContentsLayer-&gt;setDrawsContent(true);
2014         m_scrolledContentsLayer-&gt;setAnchorPoint({ });
2015         m_scrollContainerLayer-&gt;addChild(*m_scrolledContentsLayer);
2016     } else {
2017         compositor().willRemoveScrollingLayerWithBacking(m_owningLayer, *this);
2018 
2019         willDestroyLayer(m_scrollContainerLayer.get());
2020         willDestroyLayer(m_scrolledContentsLayer.get());
2021 
2022         GraphicsLayer::unparentAndClear(m_scrollContainerLayer);
2023         GraphicsLayer::unparentAndClear(m_scrolledContentsLayer);
2024     }
2025 
2026     if (m_scrollContainerLayer)
2027         compositor().didAddScrollingLayer(m_owningLayer);
2028 
2029     return true;
2030 }
2031 
2032 void RenderLayerBacking::detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt; roles)
2033 {
2034     if (!m_scrollingNodeID &amp;&amp; !m_ancestorClippingStack &amp;&amp; !m_frameHostingNodeID &amp;&amp; !m_viewportConstrainedNodeID &amp;&amp; !m_positioningNodeID)
2035         return;
2036 
2037     auto* scrollingCoordinator = m_owningLayer.page().scrollingCoordinator();
2038     if (!scrollingCoordinator)
2039         return;
2040 
2041     if (roles.contains(ScrollCoordinationRole::Scrolling) &amp;&amp; m_scrollingNodeID) {
2042         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Scrolling node &quot; &lt;&lt; m_scrollingNodeID);
2043         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_scrollingNodeID);
2044         m_scrollingNodeID = 0;
2045     }
2046 
2047     if (roles.contains(ScrollCoordinationRole::ScrollingProxy) &amp;&amp; m_ancestorClippingStack) {
2048         m_ancestorClippingStack-&gt;detachFromScrollingCoordinator(*scrollingCoordinator);
2049         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching nodes in ancestor clipping stack&quot;);
2050     }
2051 
2052     if (roles.contains(ScrollCoordinationRole::FrameHosting) &amp;&amp; m_frameHostingNodeID) {
2053         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching FrameHosting node &quot; &lt;&lt; m_frameHostingNodeID);
2054         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_frameHostingNodeID);
2055         m_frameHostingNodeID = 0;
2056     }
2057 
2058     if (roles.contains(ScrollCoordinationRole::ViewportConstrained) &amp;&amp; m_viewportConstrainedNodeID) {
2059         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching ViewportConstrained node &quot; &lt;&lt; m_viewportConstrainedNodeID);
2060         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_viewportConstrainedNodeID);
2061         m_viewportConstrainedNodeID = 0;
2062     }
2063 
2064     if (roles.contains(ScrollCoordinationRole::Positioning) &amp;&amp; m_positioningNodeID) {
2065         LOG_WITH_STREAM(Compositing, stream &lt;&lt; &quot;Detaching Positioned node &quot; &lt;&lt; m_positioningNodeID);
2066         scrollingCoordinator-&gt;unparentChildrenAndDestroyNode(m_positioningNodeID);
2067         m_positioningNodeID = 0;
2068     }
2069 }
2070 
2071 ScrollingNodeID RenderLayerBacking::scrollingNodeIDForChildren() const
2072 {
2073     if (m_frameHostingNodeID)
2074         return m_frameHostingNodeID;
2075 
2076     if (m_scrollingNodeID)
2077         return m_scrollingNodeID;
2078 
2079     if (m_viewportConstrainedNodeID)
2080         return m_viewportConstrainedNodeID;
2081 
2082     if (m_ancestorClippingStack) {
2083         if (auto lastOverflowScrollProxyNode = m_ancestorClippingStack-&gt;lastOverflowScrollProxyNodeID())
2084             return lastOverflowScrollProxyNode;
2085     }
2086 
2087     return m_positioningNodeID;
2088 }
2089 
2090 float RenderLayerBacking::compositingOpacity(float rendererOpacity) const
2091 {
2092     float finalOpacity = rendererOpacity;
2093 
2094     for (auto* curr = m_owningLayer.parent(); curr; curr = curr-&gt;parent()) {
2095         // We only care about parents that are stacking contexts.
2096         // Recall that opacity creates stacking context.
2097         if (!curr-&gt;isCSSStackingContext())
2098             continue;
2099 
2100         // If we found a compositing layer, we want to compute opacity
2101         // relative to it. So we can break here.
2102         if (curr-&gt;isComposited())
2103             break;
2104 
2105         finalOpacity *= curr-&gt;renderer().opacity();
2106     }
2107 
2108     return finalOpacity;
2109 }
2110 
2111 // FIXME: Code is duplicated in RenderLayer. Also, we should probably not consider filters a box decoration here.
2112 static inline bool hasVisibleBoxDecorations(const RenderStyle&amp; style)
2113 {
2114     return style.hasVisibleBorder() || style.hasBorderRadius() || style.hasOutline() || style.hasAppearance() || style.boxShadow() || style.hasFilter();
2115 }
2116 
2117 static bool canDirectlyCompositeBackgroundBackgroundImage(const RenderStyle&amp; style)
2118 {
2119     if (!GraphicsLayer::supportsContentsTiling())
2120         return false;
2121 
2122     auto&amp; fillLayer = style.backgroundLayers();
2123     if (fillLayer.next())
2124         return false;
2125 
2126     if (!fillLayer.imagesAreLoaded())
2127         return false;
2128 
2129     if (fillLayer.attachment() != FillAttachment::ScrollBackground)
2130         return false;
2131 
2132     // FIXME: Allow color+image compositing when it makes sense.
2133     // For now bailing out.
2134     if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
2135         return false;
2136 
2137     // FIXME: support gradients with isGeneratedImage.
2138     auto* styleImage = fillLayer.image();
2139     if (!styleImage-&gt;hasCachedImage())
2140         return false;
2141 
2142     auto* image = styleImage-&gt;cachedImage()-&gt;image();
2143     if (!image-&gt;isBitmapImage())
2144         return false;
2145 
2146     return true;
2147 }
2148 
2149 static bool hasPaintedBoxDecorationsOrBackgroundImage(const RenderStyle&amp; style)
2150 {
2151     if (hasVisibleBoxDecorations(style))
2152         return true;
2153 
2154     if (!style.hasBackgroundImage())
2155         return false;
2156 
2157     return !canDirectlyCompositeBackgroundBackgroundImage(style);
2158 }
2159 
2160 static inline bool hasPerspectiveOrPreserves3D(const RenderStyle&amp; style)
2161 {
2162     return style.hasPerspective() || style.preserves3D();
2163 }
2164 
2165 Color RenderLayerBacking::rendererBackgroundColor() const
2166 {
2167     RenderElement* backgroundRenderer = nullptr;
2168     if (renderer().isDocumentElementRenderer())
2169         backgroundRenderer = renderer().view().rendererForRootBackground();
2170 
2171     if (!backgroundRenderer)
2172         backgroundRenderer = &amp;renderer();
2173 
2174     return backgroundRenderer-&gt;style().visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor);
2175 }
2176 
2177 void RenderLayerBacking::updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
2178 {
2179     if (m_backgroundLayer &amp;&amp; !m_backgroundLayerPaintsFixedRootBackground &amp;&amp; !contentsInfo.paintsBoxDecorations()) {
2180         m_graphicsLayer-&gt;setContentsToSolidColor(Color());
2181         m_backgroundLayer-&gt;setContentsToSolidColor(rendererBackgroundColor());
2182 
2183         FloatRect contentsRect = backgroundBoxForSimpleContainerPainting();
2184         // NOTE: This is currently only used by RenderFullScreen, which we want to be
2185         // big enough to hide overflow areas of the root.
2186         contentsRect.inflate(contentsRect.size());
2187         m_backgroundLayer-&gt;setContentsRect(contentsRect);
2188         m_backgroundLayer-&gt;setContentsClippingRect(FloatRoundedRect(contentsRect));
2189         return;
2190     }
2191 
2192     if (!contentsInfo.isSimpleContainer() || (is&lt;RenderBox&gt;(renderer()) &amp;&amp; !downcast&lt;RenderBox&gt;(renderer()).paintsOwnBackground())) {
2193         m_graphicsLayer-&gt;setContentsToSolidColor(Color());
2194         return;
2195     }
2196 
2197     Color backgroundColor = rendererBackgroundColor();
2198 
2199     // An unset (invalid) color will remove the solid color.
2200     m_graphicsLayer-&gt;setContentsToSolidColor(backgroundColor);
2201     FloatRect contentsRect = backgroundBoxForSimpleContainerPainting();
2202     m_graphicsLayer-&gt;setContentsRect(contentsRect);
2203     m_graphicsLayer-&gt;setContentsClippingRect(FloatRoundedRect(contentsRect));
2204     didUpdateContentsRect = true;
2205 }
2206 
2207 void RenderLayerBacking::updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp; contentsInfo, bool&amp; didUpdateContentsRect)
2208 {
2209     if (!GraphicsLayer::supportsContentsTiling())
2210         return;
2211 
2212     if (contentsInfo.isDirectlyCompositedImage())
2213         return;
2214 
2215     auto&amp; style = renderer().style();
2216     if (!contentsInfo.isSimpleContainer() || !style.hasBackgroundImage()) {
2217         m_graphicsLayer-&gt;setContentsToImage(0);
2218         return;
2219     }
2220 
2221     auto destRect = backgroundBoxForSimpleContainerPainting();
2222     FloatSize phase;
2223     FloatSize tileSize;
2224     // FIXME: Absolute paint location is required here.
2225     downcast&lt;RenderBox&gt;(renderer()).getGeometryForBackgroundImage(&amp;renderer(), LayoutPoint(), destRect, phase, tileSize);
2226 
2227     m_graphicsLayer-&gt;setContentsTileSize(tileSize);
2228     m_graphicsLayer-&gt;setContentsTilePhase(phase);
2229     m_graphicsLayer-&gt;setContentsRect(destRect);
2230     m_graphicsLayer-&gt;setContentsClippingRect(FloatRoundedRect(destRect));
2231     m_graphicsLayer-&gt;setContentsToImage(style.backgroundLayers().image()-&gt;cachedImage()-&gt;image());
2232 
2233     didUpdateContentsRect = true;
2234 }
2235 
2236 void RenderLayerBacking::updateRootLayerConfiguration()
2237 {
2238     if (!m_isFrameLayerWithTiledBacking)
2239         return;
2240 
2241     Color backgroundColor;
2242     bool viewIsTransparent = compositor().viewHasTransparentBackground(&amp;backgroundColor);
2243 
2244     if (m_backgroundLayerPaintsFixedRootBackground &amp;&amp; m_backgroundLayer) {
2245         if (m_isMainFrameRenderViewLayer) {
2246             m_backgroundLayer-&gt;setBackgroundColor(backgroundColor);
2247             m_backgroundLayer-&gt;setContentsOpaque(!viewIsTransparent);
2248         }
2249 
2250         m_graphicsLayer-&gt;setBackgroundColor(Color());
2251         m_graphicsLayer-&gt;setContentsOpaque(false);
2252     } else if (m_isMainFrameRenderViewLayer) {
2253         m_graphicsLayer-&gt;setBackgroundColor(backgroundColor);
2254         m_graphicsLayer-&gt;setContentsOpaque(!viewIsTransparent);
2255     }
2256 }
2257 
2258 void RenderLayerBacking::updatePaintingPhases()
2259 {
2260     // Phases for m_childClippingMaskLayer and m_maskLayer are set elsewhere.
2261     OptionSet&lt;GraphicsLayerPaintingPhase&gt; primaryLayerPhases = { GraphicsLayerPaintingPhase::Background, GraphicsLayerPaintingPhase::Foreground };
2262 
2263     if (m_foregroundLayer) {
2264         OptionSet&lt;GraphicsLayerPaintingPhase&gt; foregroundLayerPhases { GraphicsLayerPaintingPhase::Foreground };
2265 
2266         if (m_scrolledContentsLayer)
2267             foregroundLayerPhases.add(GraphicsLayerPaintingPhase::OverflowContents);
2268 
2269         m_foregroundLayer-&gt;setPaintingPhase(foregroundLayerPhases);
2270         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);
2271     }
2272 
2273     if (m_backgroundLayer) {
2274         m_backgroundLayer-&gt;setPaintingPhase(GraphicsLayerPaintingPhase::Background);
2275         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Background);
2276     }
2277 
2278     if (m_scrolledContentsLayer) {
2279         OptionSet&lt;GraphicsLayerPaintingPhase&gt; scrolledContentLayerPhases = { GraphicsLayerPaintingPhase::OverflowContents, GraphicsLayerPaintingPhase::CompositedScroll };
2280         if (!m_foregroundLayer)
2281             scrolledContentLayerPhases.add(GraphicsLayerPaintingPhase::Foreground);
2282         m_scrolledContentsLayer-&gt;setPaintingPhase(scrolledContentLayerPhases);
2283 
2284         primaryLayerPhases.remove(GraphicsLayerPaintingPhase::Foreground);
2285         primaryLayerPhases.add(GraphicsLayerPaintingPhase::CompositedScroll);
2286     }
2287 
2288     m_graphicsLayer-&gt;setPaintingPhase(primaryLayerPhases);
2289 }
2290 
2291 static bool supportsDirectlyCompositedBoxDecorations(const RenderLayerModelObject&amp; renderer)
2292 {
2293     if (!GraphicsLayer::supportsBackgroundColorContent())
2294         return false;
2295 
2296     const RenderStyle&amp; style = renderer.style();
2297     if (renderer.hasClip())
2298         return false;
2299 
2300     if (hasPaintedBoxDecorationsOrBackgroundImage(style))
2301         return false;
2302 
2303     // FIXME: We can&#39;t create a directly composited background if this
2304     // layer will have children that intersect with the background layer.
2305     // A better solution might be to introduce a flattening layer if
2306     // we do direct box decoration composition.
2307     // https://bugs.webkit.org/show_bug.cgi?id=119461
2308     if (hasPerspectiveOrPreserves3D(style))
2309         return false;
2310 
2311     // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
2312     if (style.backgroundComposite() != CompositeOperator::SourceOver)
2313         return false;
2314 
2315     return true;
2316 }
2317 
2318 bool RenderLayerBacking::paintsBoxDecorations() const
2319 {
2320     if (!m_owningLayer.hasVisibleBoxDecorations())
2321         return false;
2322 
2323     return !supportsDirectlyCompositedBoxDecorations(renderer());
2324 }
2325 
2326 bool RenderLayerBacking::paintsContent(RenderLayer::PaintedContentRequest&amp; request) const
2327 {
2328     m_owningLayer.updateDescendantDependentFlags();
2329 
2330     bool paintsContent = false;
2331 
2332     if (m_owningLayer.hasVisibleContent() &amp;&amp; m_owningLayer.hasNonEmptyChildRenderers(request))
2333         paintsContent = true;
2334 
2335     if (request.isSatisfied())
2336         return paintsContent;
2337 
2338     if (isPaintDestinationForDescendantLayers(request))
2339         paintsContent = true;
2340 
2341     if (request.isSatisfied())
2342         return paintsContent;
2343 
2344     if (request.hasPaintedContent == RequestState::Unknown)
2345         request.hasPaintedContent = RequestState::False;
2346 
2347     if (request.hasSubpixelAntialiasedText == RequestState::Unknown)
2348         request.hasSubpixelAntialiasedText = RequestState::False;
2349 
2350     return paintsContent;
2351 }
2352 
2353 static bool isRestartedPlugin(RenderObject&amp; renderer)
2354 {
2355     if (!is&lt;RenderEmbeddedObject&gt;(renderer))
2356         return false;
2357 
2358     auto&amp; element = downcast&lt;RenderEmbeddedObject&gt;(renderer).frameOwnerElement();
2359     if (!is&lt;HTMLPlugInElement&gt;(element))
2360         return false;
2361 
2362     return downcast&lt;HTMLPlugInElement&gt;(element).isRestartedPlugin();
2363 }
2364 
2365 static bool isCompositedPlugin(RenderObject&amp; renderer)
2366 {
2367     return is&lt;RenderEmbeddedObject&gt;(renderer) &amp;&amp; downcast&lt;RenderEmbeddedObject&gt;(renderer).allowsAcceleratedCompositing();
2368 }
2369 
2370 // A &quot;simple container layer&quot; is a RenderLayer which has no visible content to render.
2371 // It may have no children, or all its children may be themselves composited.
2372 // This is a useful optimization, because it allows us to avoid allocating backing store.
2373 bool RenderLayerBacking::isSimpleContainerCompositingLayer(PaintedContentsInfo&amp; contentsInfo) const
2374 {
2375     if (m_owningLayer.isRenderViewLayer())
2376         return false;
2377 
2378     if (hasBackingSharingLayers())
2379         return false;
2380 
2381     if (renderer().isRenderReplaced() &amp;&amp; (!isCompositedPlugin(renderer()) || isRestartedPlugin(renderer())))
2382         return false;
2383 
2384     if (renderer().isTextControl())
2385         return false;
2386 
2387     if (contentsInfo.paintsBoxDecorations() || contentsInfo.paintsContent())
2388         return false;
2389 
2390     if (renderer().style().backgroundClip() == FillBox::Text)
2391         return false;
2392 
2393     if (renderer().isDocumentElementRenderer() &amp;&amp; m_owningLayer.isolatesCompositedBlending())
2394         return false;
2395 
2396     return true;
2397 }
2398 
2399 // Returning true stops the traversal.
2400 enum class LayerTraversal { Continue, Stop };
2401 
2402 static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer&amp; parent, const WTF::Function&lt;LayerTraversal (const RenderLayer&amp;)&gt;&amp; layerFunc)
2403 {
2404     // FIXME: We shouldn&#39;t be called with a stale z-order lists. See bug 85512.
2405     parent.updateLayerListsIfNeeded();
2406 
2407 #if ASSERT_ENABLED
2408     LayerListMutationDetector mutationChecker(parent);
2409 #endif
2410 
2411     for (auto* childLayer : parent.normalFlowLayers()) {
2412         if (compositedWithOwnBackingStore(*childLayer))
2413             continue;
2414 
2415         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2416             return LayerTraversal::Stop;
2417 
2418         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2419             return LayerTraversal::Stop;
2420     }
2421 
2422     if (parent.isStackingContext() &amp;&amp; !parent.hasVisibleDescendant())
2423         return LayerTraversal::Continue;
2424 
2425     // Use the m_hasCompositingDescendant bit to optimize?
2426     for (auto* childLayer : parent.negativeZOrderLayers()) {
2427         if (compositedWithOwnBackingStore(*childLayer))
2428             continue;
2429 
2430         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2431             return LayerTraversal::Stop;
2432 
2433         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2434             return LayerTraversal::Stop;
2435     }
2436 
2437     for (auto* childLayer : parent.positiveZOrderLayers()) {
2438         if (compositedWithOwnBackingStore(*childLayer))
2439             continue;
2440 
2441         if (layerFunc(*childLayer) == LayerTraversal::Stop)
2442             return LayerTraversal::Stop;
2443 
2444         if (traverseVisibleNonCompositedDescendantLayers(*childLayer, layerFunc) == LayerTraversal::Stop)
2445             return LayerTraversal::Stop;
2446     }
2447 
2448     return LayerTraversal::Continue;
2449 }
2450 
2451 // Conservative test for having no rendered children.
2452 bool RenderLayerBacking::isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp; request) const
2453 {
2454     bool hasPaintingDescendant = false;
2455     traverseVisibleNonCompositedDescendantLayers(m_owningLayer, [&amp;hasPaintingDescendant, &amp;request](const RenderLayer&amp; layer) {
2456         hasPaintingDescendant |= layer.isVisuallyNonEmpty(&amp;request);
2457         return (hasPaintingDescendant &amp;&amp; request.isSatisfied()) ? LayerTraversal::Stop : LayerTraversal::Continue;
2458     });
2459 
2460     return hasPaintingDescendant;
2461 }
2462 
2463 bool RenderLayerBacking::hasVisibleNonCompositedDescendants() const
2464 {
2465     bool hasVisibleDescendant = false;
2466     traverseVisibleNonCompositedDescendantLayers(m_owningLayer, [&amp;hasVisibleDescendant](const RenderLayer&amp; layer) {
2467         hasVisibleDescendant |= layer.hasVisibleContent();
2468         return hasVisibleDescendant ? LayerTraversal::Stop : LayerTraversal::Continue;
2469     });
2470 
2471     return hasVisibleDescendant;
2472 }
2473 
2474 bool RenderLayerBacking::containsPaintedContent(PaintedContentsInfo&amp; contentsInfo) const
2475 {
2476     if (contentsInfo.isSimpleContainer() || paintsIntoWindow() || paintsIntoCompositedAncestor() || m_artificiallyInflatedBounds || m_owningLayer.isReflection())
2477         return false;
2478 
2479     if (contentsInfo.isDirectlyCompositedImage())
2480         return false;
2481 
2482     // FIXME: we could optimize cases where the image, video or canvas is known to fill the border box entirely,
2483     // and set background color on the layer in that case, instead of allocating backing store and painting.
2484 #if ENABLE(VIDEO)
2485     if (is&lt;RenderVideo&gt;(renderer()) &amp;&amp; downcast&lt;RenderVideo&gt;(renderer()).shouldDisplayVideo())
2486         return m_owningLayer.hasVisibleBoxDecorationsOrBackground() || (!(downcast&lt;RenderVideo&gt;(renderer()).supportsAcceleratedRendering()) &amp;&amp; m_requiresOwnBackingStore);
2487 #endif
2488 
2489 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS)
2490     if (is&lt;RenderHTMLCanvas&gt;(renderer()) &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents)
2491         return m_owningLayer.hasVisibleBoxDecorationsOrBackground();
2492 #endif
2493 
2494     return true;
2495 }
2496 
2497 // An image can be directly compositing if it&#39;s the sole content of the layer, and has no box decorations
2498 // that require painting. Direct compositing saves backing store.
2499 bool RenderLayerBacking::isDirectlyCompositedImage() const
2500 {
2501     if (!is&lt;RenderImage&gt;(renderer()) || m_owningLayer.hasVisibleBoxDecorationsOrBackground() || m_owningLayer.paintsWithFilters() || renderer().hasClip())
2502         return false;
2503 
2504 #if ENABLE(VIDEO)
2505     if (is&lt;RenderMedia&gt;(renderer()))
2506         return false;
2507 #endif
2508 
2509     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2510     if (auto* cachedImage = imageRenderer.cachedImage()) {
2511         if (!cachedImage-&gt;hasImage())
2512             return false;
2513 
2514         auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2515         if (!is&lt;BitmapImage&gt;(image))
2516             return false;
2517 
2518         if (downcast&lt;BitmapImage&gt;(*image).orientationForCurrentFrame() != ImageOrientation::None)
2519             return false;
2520 
2521 #if (PLATFORM(GTK) || PLATFORM(WPE))
2522         // GTK and WPE ports don&#39;t support rounded rect clipping at TextureMapper level, so they cannot
2523         // directly composite images that have border-radius propery. Draw them as non directly composited
2524         // content instead. See https://bugs.webkit.org/show_bug.cgi?id=174157.
2525         if (imageRenderer.style().hasBorderRadius())
2526             return false;
2527 #endif
2528 
2529         return m_graphicsLayer-&gt;shouldDirectlyCompositeImage(image);
2530     }
2531 
2532     return false;
2533 }
2534 
2535 void RenderLayerBacking::contentChanged(ContentChangeType changeType)
2536 {
2537     PaintedContentsInfo contentsInfo(*this);
2538     if ((changeType == ImageChanged) &amp;&amp; contentsInfo.isDirectlyCompositedImage()) {
2539         updateImageContents(contentsInfo);
2540         return;
2541     }
2542 
2543     if (changeType == VideoChanged) {
2544         compositor().scheduleCompositingLayerUpdate();
2545         return;
2546     }
2547 
2548     if ((changeType == BackgroundImageChanged) &amp;&amp; canDirectlyCompositeBackgroundBackgroundImage(renderer().style()))
2549         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2550 
2551     if ((changeType == MaskImageChanged) &amp;&amp; m_maskLayer)
2552         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2553 
2554 #if ENABLE(WEBGL) || ENABLE(ACCELERATED_2D_CANVAS) || ENABLE(WEBGPU)
2555     if ((changeType == CanvasChanged || changeType == CanvasPixelsChanged) &amp;&amp; renderer().isCanvas() &amp;&amp; canvasCompositingStrategy(renderer()) == CanvasAsLayerContents) {
2556         if (changeType == CanvasChanged)
2557             compositor().scheduleCompositingLayerUpdate();
2558 
2559         m_graphicsLayer-&gt;setContentsNeedsDisplay();
2560         return;
2561     }
2562 #endif
2563 }
2564 
2565 void RenderLayerBacking::updateImageContents(PaintedContentsInfo&amp; contentsInfo)
2566 {
2567     auto&amp; imageRenderer = downcast&lt;RenderImage&gt;(renderer());
2568 
2569     auto* cachedImage = imageRenderer.cachedImage();
2570     if (!cachedImage)
2571         return;
2572 
2573     auto* image = cachedImage-&gt;imageForRenderer(&amp;imageRenderer);
2574     if (!image)
2575         return;
2576 
2577     // We have to wait until the image is fully loaded before setting it on the layer.
2578     if (!cachedImage-&gt;isLoaded())
2579         return;
2580 
2581     // This is a no-op if the layer doesn&#39;t have an inner layer for the image.
2582     m_graphicsLayer-&gt;setContentsRect(snapRectToDevicePixels(contentsBox(), deviceScaleFactor()));
2583 
2584     LayoutRect boxRect(LayoutPoint(), imageRenderer.size());
2585     boxRect.move(contentOffsetInCompositingLayer());
2586     FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
2587     m_graphicsLayer-&gt;setContentsClippingRect(contentsClippingRect);
2588 
2589     m_graphicsLayer-&gt;setContentsToImage(image);
2590 
2591     updateDrawsContent(contentsInfo);
2592 
2593     // Image animation is &quot;lazy&quot;, in that it automatically stops unless someone is drawing
2594     // the image. So we have to kick the animation each time; this has the downside that the
2595     // image will keep animating, even if its layer is not visible.
2596     image-&gt;startAnimation();
2597 }
2598 
2599 FloatPoint3D RenderLayerBacking::computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const
2600 {
2601     const RenderStyle&amp; style = renderer().style();
2602     float deviceScaleFactor = this-&gt;deviceScaleFactor();
2603 
2604     FloatPoint3D origin;
2605     origin.setX(roundToDevicePixel(floatValueForLength(style.transformOriginX(), borderBox.width()), deviceScaleFactor));
2606     origin.setY(roundToDevicePixel(floatValueForLength(style.transformOriginY(), borderBox.height()), deviceScaleFactor));
2607     origin.setZ(style.transformOriginZ());
2608 
2609     return origin;
2610 }
2611 
2612 // Return the offset from the top-left of this compositing layer at which the renderer&#39;s contents are painted.
2613 LayoutSize RenderLayerBacking::contentOffsetInCompositingLayer() const
2614 {
2615     return LayoutSize(-m_compositedBounds.x() + m_compositedBoundsOffsetFromGraphicsLayer.width(), -m_compositedBounds.y() + m_compositedBoundsOffsetFromGraphicsLayer.height());
2616 }
2617 
2618 LayoutRect RenderLayerBacking::contentsBox() const
2619 {
2620     if (!is&lt;RenderBox&gt;(renderer()))
2621         return LayoutRect();
2622 
2623     auto&amp; renderBox = downcast&lt;RenderBox&gt;(renderer());
2624     LayoutRect contentsRect;
2625 #if ENABLE(VIDEO)
2626     if (is&lt;RenderVideo&gt;(renderBox))
2627         contentsRect = downcast&lt;RenderVideo&gt;(renderBox).videoBox();
2628     else
2629 #endif
2630     if (is&lt;RenderReplaced&gt;(renderBox)) {
2631         RenderReplaced&amp; renderReplaced = downcast&lt;RenderReplaced&gt;(renderBox);
2632         contentsRect = renderReplaced.replacedContentRect();
2633     } else
2634         contentsRect = renderBox.contentBoxRect();
2635 
2636     contentsRect.move(contentOffsetInCompositingLayer());
2637     return contentsRect;
2638 }
2639 
2640 static LayoutRect backgroundRectForBox(const RenderBox&amp; box)
2641 {
2642     switch (box.style().backgroundClip()) {
2643     case FillBox::Border:
2644         return box.borderBoxRect();
2645     case FillBox::Padding:
2646         return box.paddingBoxRect();
2647     case FillBox::Content:
2648         return box.contentBoxRect();
2649     default:
2650         break;
2651     }
2652 
2653     ASSERT_NOT_REACHED();
2654     return LayoutRect();
2655 }
2656 
2657 FloatRect RenderLayerBacking::backgroundBoxForSimpleContainerPainting() const
2658 {
2659     if (!is&lt;RenderBox&gt;(renderer()))
2660         return FloatRect();
2661 
2662     LayoutRect backgroundBox = backgroundRectForBox(downcast&lt;RenderBox&gt;(renderer()));
2663     backgroundBox.move(contentOffsetInCompositingLayer());
2664     return snapRectToDevicePixels(backgroundBox, deviceScaleFactor());
2665 }
2666 
2667 GraphicsLayer* RenderLayerBacking::parentForSublayers() const
2668 {
2669     if (m_scrolledContentsLayer)
2670         return m_scrolledContentsLayer.get();
2671 
2672     return m_childContainmentLayer ? m_childContainmentLayer.get() : m_graphicsLayer.get();
2673 }
2674 
2675 GraphicsLayer* RenderLayerBacking::childForSuperlayers() const
2676 {
2677     if (m_ancestorClippingStack)
2678         return m_ancestorClippingStack-&gt;firstClippingLayer();
2679 
2680     if (m_contentsContainmentLayer)
2681         return m_contentsContainmentLayer.get();
2682 
2683     return m_graphicsLayer.get();
2684 }
2685 
2686 bool RenderLayerBacking::paintsIntoWindow() const
2687 {
2688 #if USE(COORDINATED_GRAPHICS)
2689         return false;
2690 #endif
2691 
2692     if (m_isFrameLayerWithTiledBacking)
2693         return false;
2694 
2695     if (m_owningLayer.isRenderViewLayer()) {
2696 #if PLATFORM(IOS_FAMILY) || USE(COORDINATED_GRAPHICS)
2697         if (compositor().inForcedCompositingMode())
2698             return false;
2699 #endif
2700 
2701         return compositor().rootLayerAttachment() != RenderLayerCompositor::RootLayerAttachedViaEnclosingFrame;
2702     }
2703 
2704     return false;
2705 }
2706 
2707 void RenderLayerBacking::setRequiresOwnBackingStore(bool requiresOwnBacking)
2708 {
2709     if (requiresOwnBacking == m_requiresOwnBackingStore)
2710         return;
2711 
2712     m_requiresOwnBackingStore = requiresOwnBacking;
2713 
2714     // This affects the answer to paintsIntoCompositedAncestor(), which in turn affects
2715     // cached clip rects, so when it changes we have to clear clip rects on descendants.
2716     m_owningLayer.clearClipRectsIncludingDescendants(PaintingClipRects);
2717     m_owningLayer.computeRepaintRectsIncludingDescendants();
2718 
2719     compositor().repaintInCompositedAncestor(m_owningLayer, compositedBounds());
2720 }
2721 
2722 void RenderLayerBacking::setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer shouldClip)
2723 {
2724     ASSERT(!paintsIntoCompositedAncestor());
2725 
2726     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2727     if (!m_owningLayer.isRenderViewLayer())
2728         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2729 
2730     m_owningLayer.invalidateEventRegion();
2731 
2732     auto&amp; frameView = renderer().view().frameView();
2733     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2734         frameView.addTrackedRepaintRect(owningLayer().absoluteBoundingBoxForPainting());
2735 
2736     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2737         // By default, setNeedsDisplay will clip to the size of the GraphicsLayer, which does not include margin tiles.
2738         // So if the TiledBacking has a margin that needs to be invalidated, we need to send in a rect to setNeedsDisplayInRect
2739         // that is large enough to include the margin. TiledBacking::bounds() includes the margin.
2740         auto* tiledBacking = this-&gt;tiledBacking();
2741         FloatRect rectToRepaint = tiledBacking ? tiledBacking-&gt;bounds() : FloatRect(FloatPoint(0, 0), m_graphicsLayer-&gt;size());
2742         m_graphicsLayer-&gt;setNeedsDisplayInRect(rectToRepaint, shouldClip);
2743     }
2744 
2745     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent())
2746         m_foregroundLayer-&gt;setNeedsDisplay();
2747 
2748     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent())
2749         m_backgroundLayer-&gt;setNeedsDisplay();
2750 
2751     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent())
2752         m_maskLayer-&gt;setNeedsDisplay();
2753 
2754     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent())
2755         m_childClippingMaskLayer-&gt;setNeedsDisplay();
2756 
2757     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent())
2758         m_scrolledContentsLayer-&gt;setNeedsDisplay();
2759 }
2760 
2761 // r is in the coordinate space of the layer&#39;s render object
2762 void RenderLayerBacking::setContentsNeedDisplayInRect(const LayoutRect&amp; r, GraphicsLayer::ShouldClipToLayer shouldClip)
2763 {
2764     ASSERT(!paintsIntoCompositedAncestor());
2765 
2766     // Use the repaint as a trigger to re-evaluate direct compositing (which is never used on the root layer).
2767     if (!m_owningLayer.isRenderViewLayer())
2768         m_owningLayer.setNeedsCompositingConfigurationUpdate();
2769 
2770     m_owningLayer.invalidateEventRegion();
2771 
2772     FloatRect pixelSnappedRectForPainting = snapRectToDevicePixels(r, deviceScaleFactor());
2773     auto&amp; frameView = renderer().view().frameView();
2774     if (m_isMainFrameRenderViewLayer &amp;&amp; frameView.isTrackingRepaints())
2775         frameView.addTrackedRepaintRect(pixelSnappedRectForPainting);
2776 
2777     if (m_graphicsLayer &amp;&amp; m_graphicsLayer-&gt;drawsContent()) {
2778         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2779         layerDirtyRect.move(-m_graphicsLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2780         m_graphicsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2781     }
2782 
2783     if (m_foregroundLayer &amp;&amp; m_foregroundLayer-&gt;drawsContent()) {
2784         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2785         layerDirtyRect.move(-m_foregroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2786         m_foregroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2787     }
2788 
2789     // FIXME: need to split out repaints for the background.
2790     if (m_backgroundLayer &amp;&amp; m_backgroundLayer-&gt;drawsContent()) {
2791         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2792         layerDirtyRect.move(-m_backgroundLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2793         m_backgroundLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2794     }
2795 
2796     if (m_maskLayer &amp;&amp; m_maskLayer-&gt;drawsContent()) {
2797         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2798         layerDirtyRect.move(-m_maskLayer-&gt;offsetFromRenderer() - m_subpixelOffsetFromRenderer);
2799         m_maskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2800     }
2801 
2802     if (m_childClippingMaskLayer &amp;&amp; m_childClippingMaskLayer-&gt;drawsContent()) {
2803         FloatRect layerDirtyRect = r;
2804         layerDirtyRect.move(-m_childClippingMaskLayer-&gt;offsetFromRenderer());
2805         m_childClippingMaskLayer-&gt;setNeedsDisplayInRect(layerDirtyRect);
2806     }
2807 
2808     if (m_scrolledContentsLayer &amp;&amp; m_scrolledContentsLayer-&gt;drawsContent()) {
2809         FloatRect layerDirtyRect = pixelSnappedRectForPainting;
2810         layerDirtyRect.move(-m_scrolledContentsLayer-&gt;offsetFromRenderer() + toLayoutSize(m_scrolledContentsLayer-&gt;scrollOffset()) - m_subpixelOffsetFromRenderer);
2811         m_scrolledContentsLayer-&gt;setNeedsDisplayInRect(layerDirtyRect, shouldClip);
2812     }
2813 }
2814 
2815 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context,
2816     const IntRect&amp; paintDirtyRect, // In the coords of rootLayer.
2817     OptionSet&lt;PaintBehavior&gt; paintBehavior, EventRegionContext* eventRegionContext)
2818 {
2819 #if USE(OWNING_LAYER_BEAR_TRAP)
2820     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayerBearTrap caught the bear (55699292)&quot;);
2821     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer(): m_owningLayer is null (55699292)&quot;);
2822 #endif
2823 
2824     if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) &amp;&amp; graphicsLayer-&gt;paintingPhase() != OptionSet&lt;GraphicsLayerPaintingPhase&gt;(GraphicsLayerPaintingPhase::ChildClippingMask)) {
2825 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !OS(WINDOWS)
2826         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
2827         // when pages are restored from the BackForwardCache.
2828         // &lt;rdar://problem/8712587&gt; ASSERT: When Going Back to Page with Plugins in BackForwardCache
2829         ASSERT_NOT_REACHED();
2830 #endif
2831         return;
2832     }
2833 
2834     auto paintFlags = paintFlagsForLayer(*graphicsLayer);
2835 
2836     if (eventRegionContext)
2837         paintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);
2838 
2839 #ifndef NDEBUG
2840     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&amp;renderer());
2841 #endif
2842 
2843     auto paintOneLayer = [&amp;](RenderLayer&amp; layer, OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags) {
2844         FrameView::PaintingState paintingState;
2845         if (!eventRegionContext) {
2846             InspectorInstrumentation::willPaint(layer.renderer());
2847 
2848             if (layer.isRenderViewLayer())
2849                 renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);
2850         }
2851 
2852         RenderLayer::LayerPaintingInfo paintingInfo(&amp;m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);
2853         paintingInfo.eventRegionContext = eventRegionContext;
2854 
2855         if (&amp;layer == &amp;m_owningLayer) {
2856             layer.paintLayerContents(context, paintingInfo, paintFlags);
2857 
2858             if (layer.containsDirtyOverlayScrollbars() &amp;&amp; !eventRegionContext)
2859                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
2860         } else
2861             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
2862 
2863         if (!eventRegionContext) {
2864             if (layer.isRenderViewLayer())
2865                 renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);
2866 
2867             InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);
2868         }
2869 
2870         ASSERT(!m_owningLayer.m_usedTransparency);
2871     };
2872 
2873     paintOneLayer(m_owningLayer, paintFlags);
2874 
2875     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
2876     GraphicsLayer* destinationForSharingLayers = m_scrolledContentsLayer ? m_scrolledContentsLayer.get() : m_graphicsLayer.get();
2877 
2878     if (graphicsLayer == destinationForSharingLayers) {
2879         OptionSet&lt;RenderLayer::PaintLayerFlag&gt; sharingLayerPaintFlags = {
2880             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
2881             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
2882 
2883         if (graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))
2884             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
2885         if (eventRegionContext)
2886             sharingLayerPaintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);
2887 
2888         for (auto&amp; layerWeakPtr : m_backingSharingLayers)
2889             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
2890     }
2891 
2892     if (!eventRegionContext)
2893         compositor().didPaintBacking(this);
2894 
2895 #if USE(OWNING_LAYER_BEAR_TRAP)
2896     RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayerBearTrap caught the bear (55699292)&quot;);
2897     RELEASE_ASSERT_WITH_MESSAGE(&amp;m_owningLayer, &quot;RenderLayerBacking::paintIntoLayer() end: m_owningLayer is null (55699292)&quot;);
2898 #endif
2899 }
2900 
2901 OptionSet&lt;RenderLayer::PaintLayerFlag&gt; RenderLayerBacking::paintFlagsForLayer(const GraphicsLayer&amp; graphicsLayer) const
2902 {
2903     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlags;
2904 
2905     auto paintingPhase = graphicsLayer.paintingPhase();
2906     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))
2907         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
2908     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))
2909         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
2910     if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))
2911         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
2912     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))
2913         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
2914     if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))
2915         paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
2916     if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))
2917         paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
2918     if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))
2919         paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
2920 
2921     if (&amp;graphicsLayer == m_backgroundLayer.get() &amp;&amp; m_backgroundLayerPaintsFixedRootBackground)
2922         paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
2923     else if (compositor().fixedRootBackgroundLayer())
2924         paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
2925 
2926     return paintFlags;
2927 }
2928 
2929 #if ENABLE(POINTER_EVENTS)
2930 static RefPtr&lt;Pattern&gt; patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext&amp; destContext)
2931 {
2932     auto toIndex = [](TouchAction touchAction) -&gt; unsigned {
2933         switch (touchAction) {
2934         case TouchAction::None:
2935             return 1;
2936         case TouchAction::Manipulation:
2937             return 2;
2938         case TouchAction::PanX:
2939             return 3;
2940         case TouchAction::PanY:
2941             return 4;
2942         case TouchAction::PinchZoom:
2943             return 5;
2944         case TouchAction::Auto:
2945             break;
2946         }
2947         return 0;
2948     };
2949 
2950     struct TouchActionAndRGB {
2951         TouchAction action;
2952         ASCIILiteral name;
2953         FloatSize phase;
2954     };
2955     static const TouchActionAndRGB actionsAndColors[] = {
2956         { TouchAction::Auto, &quot;auto&quot;_s, { } },
2957         { TouchAction::None, &quot;none&quot;_s, { } },
2958         { TouchAction::Manipulation, &quot;manip&quot;_s, { } },
2959         { TouchAction::PanX, &quot;pan-x&quot;_s, { } },
2960         { TouchAction::PanY, &quot;pan-y&quot;_s, { 0, 9 } },
2961         { TouchAction::PinchZoom, &quot;p-z&quot;_s, { 16, 4.5 } },
2962     };
2963 
2964     auto actionIndex = toIndex(touchAction);
2965     if (!actionIndex || actionIndex &gt;= ARRAY_SIZE(actionsAndColors))
2966         return nullptr;
2967 
2968     const FloatSize tileSize { 32, 18 };
2969 
2970     auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpace::SRGB, destContext);
2971     if (!imageBuffer)
2972         return nullptr;
2973 
2974     const auto&amp; touchActionData = actionsAndColors[actionIndex];
2975     {
2976         GraphicsContext&amp; imageContext = imageBuffer-&gt;context();
2977 
2978         FontCascadeDescription fontDescription;
2979         fontDescription.setOneFamily(&quot;Helvetica&quot;);
2980         fontDescription.setSpecifiedSize(10);
2981         fontDescription.setComputedSize(10);
2982         fontDescription.setWeight(FontSelectionValue(500));
2983         FontCascade font(WTFMove(fontDescription), 0, 0);
2984         font.update(nullptr);
2985 
2986         TextRun textRun = TextRun(touchActionData.name);
2987         imageContext.setFillColor(Color(0, 0, 0, 128));
2988 
2989         constexpr float textGap = 4;
2990         constexpr float yOffset = 12;
2991         imageContext.drawText(font, textRun, { textGap, yOffset }, 0);
2992     }
2993 
2994     auto tileImage = ImageBuffer::sinkIntoImage(WTFMove(imageBuffer));
2995     auto fillPattern = Pattern::create(tileImage.releaseNonNull(), true, true);
2996     AffineTransform patternOffsetTransform;
2997     patternOffsetTransform.translate(contentOffset + touchActionData.phase);
2998     patternOffsetTransform.scale(1 / destContext.scaleFactor());
2999     fillPattern-&gt;setPatternSpaceTransform(patternOffsetTransform);
3000 
3001     return fillPattern;
3002 }
3003 #endif // ENABLE(POINTER_EVENTS)
3004 
3005 void RenderLayerBacking::paintDebugOverlays(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context)
3006 {
3007     if (graphicsLayer-&gt;eventRegion().isEmpty())
3008         return;
3009 
3010     GraphicsContextStateSaver stateSaver(context);
3011 
3012     // The region is offset by contentOffsetInCompositingLayer() so undo that.
3013     auto contentOffset = roundedIntSize(contentOffsetInCompositingLayer());
3014     context.translate(-contentOffset);
3015 
3016     // The interactive part.
3017     auto&amp; eventRegion = graphicsLayer-&gt;eventRegion();
3018     Color regionColor(0, 0, 0, 5);
3019     context.setFillColor(regionColor);
3020     for (auto rect : eventRegion.region().rects())
3021         context.fillRect(rect);
3022 
3023 #if ENABLE(POINTER_EVENTS)
3024     const TouchAction touchActionList[] = {
3025         TouchAction::None,
3026         TouchAction::Manipulation,
3027         TouchAction::PanX,
3028         TouchAction::PanY,
3029         TouchAction::PinchZoom,
3030     };
3031 
3032     for (auto action : touchActionList) {
3033         auto* actionRegion = graphicsLayer-&gt;eventRegion().regionForTouchAction(action);
3034         if (!actionRegion)
3035             continue;
3036 
3037         auto fillPattern = patternForTouchAction(action, contentOffsetInCompositingLayer(), context);
3038         if (!fillPattern)
3039             continue;
3040 
3041         context.setFillPattern(fillPattern.releaseNonNull());
3042         for (auto rect : actionRegion-&gt;rects())
3043             context.fillRect(rect);
3044     }
3045 #endif // ENABLE(POINTER_EVENTS)
3046 }
3047 
3048 // Up-call from compositing layer drawing callback.
3049 void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext&amp; context, const FloatRect&amp; clip, GraphicsLayerPaintBehavior layerPaintBehavior)
3050 {
3051 #ifndef NDEBUG
3052     renderer().page().setIsPainting(true);
3053 #endif
3054 
3055 #if PLATFORM(MAC)
3056     LocalDefaultSystemAppearance localAppearance(renderer().useDarkAppearance());
3057 #endif
3058 
3059     // The dirtyRect is in the coords of the painting root.
3060     FloatRect adjustedClipRect = clip;
3061     adjustedClipRect.move(m_subpixelOffsetFromRenderer);
3062     IntRect dirtyRect = enclosingIntRect(adjustedClipRect);
3063 
3064     if (!graphicsLayer-&gt;repaintCount())
3065         layerPaintBehavior |= GraphicsLayerPaintFirstTilePaint;
3066 
3067     if (graphicsLayer == m_graphicsLayer.get()
3068         || graphicsLayer == m_foregroundLayer.get()
3069         || graphicsLayer == m_backgroundLayer.get()
3070         || graphicsLayer == m_maskLayer.get()
3071         || graphicsLayer == m_childClippingMaskLayer.get()
3072         || graphicsLayer == m_scrolledContentsLayer.get()) {
3073 
3074         if (!graphicsLayer-&gt;paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))
3075             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
3076 
3077         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
3078         OptionSet&lt;PaintBehavior&gt; behavior = PaintBehavior::Normal;
3079         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
3080             behavior.add(PaintBehavior::Snapshotting);
3081 
3082         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
3083             behavior.add(PaintBehavior::TileFirstPaint);
3084 
3085         paintIntoLayer(graphicsLayer, context, dirtyRect, behavior);
3086 
3087         if (renderer().settings().visibleDebugOverlayRegions() &amp; NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
3088             paintDebugOverlays(graphicsLayer, context);
3089 
3090     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
3091         paintScrollbar(m_owningLayer.horizontalScrollbar(), context, dirtyRect);
3092     } else if (graphicsLayer == layerForVerticalScrollbar()) {
3093         paintScrollbar(m_owningLayer.verticalScrollbar(), context, dirtyRect);
3094     } else if (graphicsLayer == layerForScrollCorner()) {
3095         const LayoutRect&amp; scrollCornerAndResizer = m_owningLayer.scrollCornerAndResizerRect();
3096         GraphicsContextStateSaver stateSaver(context);
3097         context.translate(-scrollCornerAndResizer.location());
3098         LayoutRect transformedClip = LayoutRect(clip);
3099         transformedClip.moveBy(scrollCornerAndResizer.location());
3100         m_owningLayer.paintScrollCorner(context, IntPoint(), snappedIntRect(transformedClip));
3101         m_owningLayer.paintResizer(context, IntPoint(), transformedClip);
3102     }
3103 #ifndef NDEBUG
3104     renderer().page().setIsPainting(false);
3105 #endif
3106 }
3107 
3108 float RenderLayerBacking::pageScaleFactor() const
3109 {
3110     return compositor().pageScaleFactor();
3111 }
3112 
3113 float RenderLayerBacking::zoomedOutPageScaleFactor() const
3114 {
3115     return compositor().zoomedOutPageScaleFactor();
3116 }
3117 
3118 float RenderLayerBacking::deviceScaleFactor() const
3119 {
3120     return compositor().deviceScaleFactor();
3121 }
3122 
3123 float RenderLayerBacking::contentsScaleMultiplierForNewTiles(const GraphicsLayer* layer) const
3124 {
3125     return compositor().contentsScaleMultiplierForNewTiles(layer);
3126 }
3127 
3128 bool RenderLayerBacking::paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const
3129 {
3130     return m_isMainFrameRenderViewLayer;
3131 }
3132 
3133 void RenderLayerBacking::didChangePlatformLayerForLayer(const GraphicsLayer* layer)
3134 {
3135     compositor().didChangePlatformLayerForLayer(m_owningLayer, layer);
3136 }
3137 
3138 bool RenderLayerBacking::getCurrentTransform(const GraphicsLayer* graphicsLayer, TransformationMatrix&amp; transform) const
3139 {
3140     auto* transformedLayer = m_contentsContainmentLayer.get() ? m_contentsContainmentLayer.get() : m_graphicsLayer.get();
3141     if (graphicsLayer != transformedLayer)
3142         return false;
3143 
3144     if (m_owningLayer.hasTransform()) {
3145         transform = m_owningLayer.currentTransform(RenderStyle::ExcludeTransformOrigin);
3146         return true;
3147     }
3148     return false;
3149 }
3150 
3151 bool RenderLayerBacking::isTrackingRepaints() const
3152 {
3153     return static_cast&lt;GraphicsLayerClient&amp;&gt;(compositor()).isTrackingRepaints();
3154 }
3155 
3156 bool RenderLayerBacking::shouldSkipLayerInDump(const GraphicsLayer* layer, LayerTreeAsTextBehavior behavior) const
3157 {
3158     if (behavior &amp; LayerTreeAsTextDebug)
3159         return false;
3160 
3161     // Skip the root tile cache&#39;s flattening layer.
3162     return m_isMainFrameRenderViewLayer &amp;&amp; layer &amp;&amp; layer == m_childContainmentLayer.get();
3163 }
3164 
3165 bool RenderLayerBacking::shouldDumpPropertyForLayer(const GraphicsLayer* layer, const char* propertyName, LayerTreeAsTextBehavior flags) const
3166 {
3167     // For backwards compatibility with WebKit1 and other platforms,
3168     // skip some properties on the root tile cache.
3169     if (m_isMainFrameRenderViewLayer &amp;&amp; layer == m_graphicsLayer.get() &amp;&amp; !(flags &amp; LayerTreeAsTextIncludeRootLayerProperties)) {
3170         if (!strcmp(propertyName, &quot;drawsContent&quot;))
3171             return false;
3172 
3173         // Background color could be of interest to tests or other dumpers if it&#39;s non-white.
3174         if (!strcmp(propertyName, &quot;backgroundColor&quot;) &amp;&amp; Color::isWhiteColor(layer-&gt;backgroundColor()))
3175             return false;
3176 
3177         // The root tile cache&#39;s repaints will show up at the top with FrameView&#39;s,
3178         // so don&#39;t dump them twice.
3179         if (!strcmp(propertyName, &quot;repaintRects&quot;))
3180             return false;
3181     }
3182 
3183     return true;
3184 }
3185 
3186 bool RenderLayerBacking::shouldAggressivelyRetainTiles(const GraphicsLayer*) const
3187 {
3188     // Only the main frame TileController has enough information about in-window state to
3189     // correctly implement aggressive tile retention.
3190     if (!m_isMainFrameRenderViewLayer)
3191         return false;
3192 
3193     return renderer().settings().aggressiveTileRetentionEnabled();
3194 }
3195 
3196 bool RenderLayerBacking::shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const
3197 {
3198     return renderer().settings().temporaryTileCohortRetentionEnabled();
3199 }
3200 
3201 bool RenderLayerBacking::useGiantTiles() const
3202 {
3203     return renderer().settings().useGiantTiles();
3204 }
3205 
3206 void RenderLayerBacking::logFilledVisibleFreshTile(unsigned blankPixelCount)
3207 {
3208     if (auto* loggingClient = renderer().page().performanceLoggingClient())
3209         loggingClient-&gt;logScrollingEvent(PerformanceLoggingClient::ScrollingEvent::FilledTile, MonotonicTime::now(), blankPixelCount);
3210 }
3211 
3212 #ifndef NDEBUG
3213 void RenderLayerBacking::verifyNotPainting()
3214 {
3215     ASSERT(!renderer().page().isPainting());
3216 }
3217 #endif
3218 
3219 bool RenderLayerBacking::startAnimation(double timeOffset, const Animation&amp; animation, const KeyframeList&amp; keyframes)
3220 {
3221     bool hasOpacity = keyframes.containsProperty(CSSPropertyOpacity);
3222     bool hasTransform = renderer().isBox() &amp;&amp; keyframes.containsProperty(CSSPropertyTransform);
3223     bool hasFilter = keyframes.containsProperty(CSSPropertyFilter);
3224 
3225     bool hasBackdropFilter = false;
3226 #if ENABLE(FILTERS_LEVEL_2)
3227     hasBackdropFilter = keyframes.containsProperty(CSSPropertyWebkitBackdropFilter);
3228 #endif
3229 
3230     if (!hasOpacity &amp;&amp; !hasTransform &amp;&amp; !hasFilter &amp;&amp; !hasBackdropFilter)
3231         return false;
3232 
3233     KeyframeValueList transformVector(AnimatedPropertyTransform);
3234     KeyframeValueList opacityVector(AnimatedPropertyOpacity);
3235     KeyframeValueList filterVector(AnimatedPropertyFilter);
3236 #if ENABLE(FILTERS_LEVEL_2)
3237     KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
3238 #endif
3239 
3240     size_t numKeyframes = keyframes.size();
3241     for (size_t i = 0; i &lt; numKeyframes; ++i) {
3242         const KeyframeValue&amp; currentKeyframe = keyframes[i];
3243         const RenderStyle* keyframeStyle = currentKeyframe.style();
3244         double key = currentKeyframe.key();
3245 
3246         if (!keyframeStyle)
3247             continue;
3248 
3249         auto* tf = currentKeyframe.timingFunction();
3250 
3251         bool isFirstOrLastKeyframe = key == 0 || key == 1;
3252         if ((hasTransform &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyTransform))
3253             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(key, keyframeStyle-&gt;transform(), tf));
3254 
3255         if ((hasOpacity &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyOpacity))
3256             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(key, keyframeStyle-&gt;opacity(), tf));
3257 
3258         if ((hasFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyFilter))
3259             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;filter(), tf));
3260 
3261 #if ENABLE(FILTERS_LEVEL_2)
3262         if ((hasBackdropFilter &amp;&amp; isFirstOrLastKeyframe) || currentKeyframe.containsProperty(CSSPropertyWebkitBackdropFilter))
3263             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(key, keyframeStyle-&gt;backdropFilter(), tf));
3264 #endif
3265     }
3266 
3267     if (!renderer().settings().acceleratedCompositedAnimationsEnabled())
3268         return false;
3269 
3270     bool didAnimate = false;
3271 
3272     if (hasTransform &amp;&amp; m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), &amp;animation, keyframes.animationName(), timeOffset))
3273         didAnimate = true;
3274 
3275     if (hasOpacity &amp;&amp; m_graphicsLayer-&gt;addAnimation(opacityVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3276         didAnimate = true;
3277 
3278     if (hasFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(filterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3279         didAnimate = true;
3280 
3281 #if ENABLE(FILTERS_LEVEL_2)
3282     if (hasBackdropFilter &amp;&amp; m_graphicsLayer-&gt;addAnimation(backdropFilterVector, IntSize { }, &amp;animation, keyframes.animationName(), timeOffset))
3283         didAnimate = true;
3284 #endif
3285 
3286     if (didAnimate) {
3287         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3288         m_owningLayer.setNeedsCompositingGeometryUpdate();
3289     }
3290 
3291     return didAnimate;
3292 }
3293 
3294 void RenderLayerBacking::animationPaused(double timeOffset, const String&amp; animationName)
3295 {
3296     m_graphicsLayer-&gt;pauseAnimation(animationName, timeOffset);
3297 }
3298 
3299 void RenderLayerBacking::animationSeeked(double timeOffset, const String&amp; animationName)
3300 {
3301     m_graphicsLayer-&gt;seekAnimation(animationName, timeOffset);
3302 }
3303 
3304 void RenderLayerBacking::animationFinished(const String&amp; animationName)
3305 {
3306     m_graphicsLayer-&gt;removeAnimation(animationName);
3307     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3308     m_owningLayer.setNeedsCompositingGeometryUpdate();
3309 }
3310 
3311 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
3312 {
3313     bool didAnimate = false;
3314 
3315     ASSERT(property != CSSPropertyInvalid);
3316 
3317     if (property == CSSPropertyOpacity) {
3318         const Animation* opacityAnim = toStyle-&gt;transitionForProperty(CSSPropertyOpacity);
3319         if (opacityAnim &amp;&amp; !opacityAnim-&gt;isEmptyOrZeroDuration()) {
3320             KeyframeValueList opacityVector(AnimatedPropertyOpacity);
3321             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(0, compositingOpacity(fromStyle-&gt;opacity())));
3322             opacityVector.insert(makeUnique&lt;FloatAnimationValue&gt;(1, compositingOpacity(toStyle-&gt;opacity())));
3323             // The boxSize param is only used for transform animations (which can only run on RenderBoxes), so we pass an empty size here.
3324             if (m_graphicsLayer-&gt;addAnimation(opacityVector, FloatSize(), opacityAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyOpacity), timeOffset)) {
3325                 // To ensure that the correct opacity is visible when the animation ends, also set the final opacity.
3326                 updateOpacity(*toStyle);
3327                 didAnimate = true;
3328             }
3329         }
3330     }
3331 
3332     if (property == CSSPropertyTransform &amp;&amp; m_owningLayer.hasTransform()) {
3333         const Animation* transformAnim = toStyle-&gt;transitionForProperty(CSSPropertyTransform);
3334         if (transformAnim &amp;&amp; !transformAnim-&gt;isEmptyOrZeroDuration()) {
3335             KeyframeValueList transformVector(AnimatedPropertyTransform);
3336             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(0, fromStyle-&gt;transform()));
3337             transformVector.insert(makeUnique&lt;TransformAnimationValue&gt;(1, toStyle-&gt;transform()));
3338             if (m_graphicsLayer-&gt;addAnimation(transformVector, snappedIntRect(renderBox()-&gt;borderBoxRect()).size(), transformAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyTransform), timeOffset)) {
3339                 // To ensure that the correct transform is visible when the animation ends, also set the final transform.
3340                 updateTransform(*toStyle);
3341                 didAnimate = true;
3342             }
3343         }
3344     }
3345 
3346     if (property == CSSPropertyFilter &amp;&amp; m_owningLayer.hasFilter()) {
3347         const Animation* filterAnim = toStyle-&gt;transitionForProperty(CSSPropertyFilter);
3348         if (filterAnim &amp;&amp; !filterAnim-&gt;isEmptyOrZeroDuration()) {
3349             KeyframeValueList filterVector(AnimatedPropertyFilter);
3350             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;filter()));
3351             filterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;filter()));
3352             if (m_graphicsLayer-&gt;addAnimation(filterVector, FloatSize(), filterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyFilter), timeOffset)) {
3353                 // To ensure that the correct filter is visible when the animation ends, also set the final filter.
3354                 updateFilters(*toStyle);
3355                 didAnimate = true;
3356             }
3357         }
3358     }
3359 
3360 #if ENABLE(FILTERS_LEVEL_2)
3361     if (property == CSSPropertyWebkitBackdropFilter &amp;&amp; m_owningLayer.hasBackdropFilter()) {
3362         const Animation* backdropFilterAnim = toStyle-&gt;transitionForProperty(CSSPropertyWebkitBackdropFilter);
3363         if (backdropFilterAnim &amp;&amp; !backdropFilterAnim-&gt;isEmptyOrZeroDuration()) {
3364             KeyframeValueList backdropFilterVector(AnimatedPropertyWebkitBackdropFilter);
3365             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(0, fromStyle-&gt;backdropFilter()));
3366             backdropFilterVector.insert(makeUnique&lt;FilterAnimationValue&gt;(1, toStyle-&gt;backdropFilter()));
3367             if (m_graphicsLayer-&gt;addAnimation(backdropFilterVector, FloatSize(), backdropFilterAnim, GraphicsLayer::animationNameForTransition(AnimatedPropertyWebkitBackdropFilter), timeOffset)) {
3368                 // To ensure that the correct backdrop filter is visible when the animation ends, also set the final backdrop filter.
3369                 updateBackdropFilters(*toStyle);
3370                 didAnimate = true;
3371             }
3372         }
3373     }
3374 #endif
3375 
3376     if (didAnimate)
3377         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3378 
3379     return didAnimate;
3380 }
3381 
3382 void RenderLayerBacking::transitionPaused(double timeOffset, CSSPropertyID property)
3383 {
3384     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3385     if (animatedProperty != AnimatedPropertyInvalid)
3386         m_graphicsLayer-&gt;pauseAnimation(GraphicsLayer::animationNameForTransition(animatedProperty), timeOffset);
3387 }
3388 
3389 void RenderLayerBacking::transitionFinished(CSSPropertyID property)
3390 {
3391     AnimatedPropertyID animatedProperty = cssToGraphicsLayerProperty(property);
3392     if (animatedProperty != AnimatedPropertyInvalid) {
3393         m_graphicsLayer-&gt;removeAnimation(GraphicsLayer::animationNameForTransition(animatedProperty));
3394         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
3395     }
3396 }
3397 
3398 void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&amp;, MonotonicTime time)
3399 {
3400     if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
3401         renderer().animation().notifyAnimationStarted(renderer(), time);
3402 }
3403 
3404 void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
3405 {
3406     if (renderer().renderTreeBeingDestroyed())
3407         return;
3408     compositor().scheduleLayerFlush(layer-&gt;canThrottleLayerFlush());
3409 }
3410 
3411 void RenderLayerBacking::notifyFlushBeforeDisplayRefresh(const GraphicsLayer* layer)
3412 {
3413     compositor().notifyFlushBeforeDisplayRefresh(layer);
3414 }
3415 
3416 // This is used for the &#39;freeze&#39; API, for testing only.
3417 void RenderLayerBacking::suspendAnimations(MonotonicTime time)
3418 {
3419     m_graphicsLayer-&gt;suspendAnimations(time);
3420 }
3421 
3422 void RenderLayerBacking::resumeAnimations()
3423 {
3424     m_graphicsLayer-&gt;resumeAnimations();
3425 }
3426 
3427 LayoutRect RenderLayerBacking::compositedBounds() const
3428 {
3429     return m_compositedBounds;
3430 }
3431 
3432 bool RenderLayerBacking::setCompositedBounds(const LayoutRect&amp; bounds)
3433 {
3434     if (bounds == m_compositedBounds)
3435         return false;
3436 
3437     m_compositedBounds = bounds;
3438     return true;
3439 }
3440 
3441 LayoutRect RenderLayerBacking::compositedBoundsIncludingMargin() const
3442 {
3443     auto* tiledBacking = this-&gt;tiledBacking();
3444     if (!tiledBacking || !tiledBacking-&gt;hasMargins())
3445         return compositedBounds();
3446 
3447     LayoutRect boundsIncludingMargin = compositedBounds();
3448     LayoutUnit leftMarginWidth = tiledBacking-&gt;leftMarginWidth();
3449     LayoutUnit topMarginHeight = tiledBacking-&gt;topMarginHeight();
3450 
3451     boundsIncludingMargin.moveBy(LayoutPoint(-leftMarginWidth, -topMarginHeight));
3452     boundsIncludingMargin.expand(leftMarginWidth + tiledBacking-&gt;rightMarginWidth(), topMarginHeight + tiledBacking-&gt;bottomMarginHeight());
3453 
3454     return boundsIncludingMargin;
3455 }
3456 
3457 CSSPropertyID RenderLayerBacking::graphicsLayerToCSSProperty(AnimatedPropertyID property)
3458 {
3459     CSSPropertyID cssProperty = CSSPropertyInvalid;
3460     switch (property) {
3461     case AnimatedPropertyTransform:
3462         cssProperty = CSSPropertyTransform;
3463         break;
3464     case AnimatedPropertyOpacity:
3465         cssProperty = CSSPropertyOpacity;
3466         break;
3467     case AnimatedPropertyBackgroundColor:
3468         cssProperty = CSSPropertyBackgroundColor;
3469         break;
3470     case AnimatedPropertyFilter:
3471         cssProperty = CSSPropertyFilter;
3472         break;
3473 #if ENABLE(FILTERS_LEVEL_2)
3474     case AnimatedPropertyWebkitBackdropFilter:
3475         cssProperty = CSSPropertyWebkitBackdropFilter;
3476         break;
3477 #endif
3478     case AnimatedPropertyInvalid:
3479         ASSERT_NOT_REACHED();
3480     }
3481     return cssProperty;
3482 }
3483 
3484 AnimatedPropertyID RenderLayerBacking::cssToGraphicsLayerProperty(CSSPropertyID cssProperty)
3485 {
3486     switch (cssProperty) {
3487     case CSSPropertyTransform:
3488         return AnimatedPropertyTransform;
3489     case CSSPropertyOpacity:
3490         return AnimatedPropertyOpacity;
3491     case CSSPropertyBackgroundColor:
3492         return AnimatedPropertyBackgroundColor;
3493     case CSSPropertyFilter:
3494         return AnimatedPropertyFilter;
3495 #if ENABLE(FILTERS_LEVEL_2)
3496     case CSSPropertyWebkitBackdropFilter:
3497         return AnimatedPropertyWebkitBackdropFilter;
3498 #endif
3499     default:
3500         // It&#39;s fine if we see other css properties here; they are just not accelerated.
3501         break;
3502     }
3503     return AnimatedPropertyInvalid;
3504 }
3505 
3506 CompositingLayerType RenderLayerBacking::compositingLayerType() const
3507 {
3508     if (m_graphicsLayer-&gt;usesContentsLayer())
3509         return MediaCompositingLayer;
3510 
3511     if (m_graphicsLayer-&gt;drawsContent())
3512         return m_graphicsLayer-&gt;tiledBacking() ? TiledCompositingLayer : NormalCompositingLayer;
3513 
3514     return ContainerCompositingLayer;
3515 }
3516 
3517 double RenderLayerBacking::backingStoreMemoryEstimate() const
3518 {
3519     double backingMemory;
3520 
3521     // Layers in m_ancestorClippingStack, m_contentsContainmentLayer and m_childContainmentLayer are just used for masking or containment, so have no backing.
3522     backingMemory = m_graphicsLayer-&gt;backingStoreMemoryEstimate();
3523     if (m_foregroundLayer)
3524         backingMemory += m_foregroundLayer-&gt;backingStoreMemoryEstimate();
3525     if (m_backgroundLayer)
3526         backingMemory += m_backgroundLayer-&gt;backingStoreMemoryEstimate();
3527     if (m_maskLayer)
3528         backingMemory += m_maskLayer-&gt;backingStoreMemoryEstimate();
3529     if (m_childClippingMaskLayer)
3530         backingMemory += m_childClippingMaskLayer-&gt;backingStoreMemoryEstimate();
3531 
3532     if (m_scrolledContentsLayer)
3533         backingMemory += m_scrolledContentsLayer-&gt;backingStoreMemoryEstimate();
3534 
3535     if (m_layerForHorizontalScrollbar)
3536         backingMemory += m_layerForHorizontalScrollbar-&gt;backingStoreMemoryEstimate();
3537 
3538     if (m_layerForVerticalScrollbar)
3539         backingMemory += m_layerForVerticalScrollbar-&gt;backingStoreMemoryEstimate();
3540 
3541     if (m_layerForScrollCorner)
3542         backingMemory += m_layerForScrollCorner-&gt;backingStoreMemoryEstimate();
3543 
3544     return backingMemory;
3545 }
3546 
3547 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const RenderLayerBacking&amp; backing)
3548 {
3549     ts &lt;&lt; &quot;RenderLayerBacking &quot; &lt;&lt; &amp;backing &lt;&lt; &quot; bounds &quot; &lt;&lt; backing.compositedBounds();
3550 
3551     if (backing.isFrameLayerWithTiledBacking())
3552         ts &lt;&lt; &quot; frame layer tiled backing&quot;;
3553     if (backing.paintsIntoWindow())
3554         ts &lt;&lt; &quot; paintsIntoWindow&quot;;
3555     if (backing.paintsIntoCompositedAncestor())
3556         ts &lt;&lt; &quot; paintsIntoCompositedAncestor&quot;;
3557 
3558     ts &lt;&lt; &quot; primary layer ID &quot; &lt;&lt; backing.graphicsLayer()-&gt;primaryLayerID();
3559     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::ViewportConstrained))
3560         ts &lt;&lt; &quot; viewport constrained scrolling node &quot; &lt;&lt; nodeID;
3561     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Scrolling))
3562         ts &lt;&lt; &quot; scrolling node &quot; &lt;&lt; nodeID;
3563 
3564     if (backing.ancestorClippingStack())
3565         ts &lt;&lt; &quot; ancestor clip stack &quot; &lt;&lt; *backing.ancestorClippingStack();
3566 
3567     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::FrameHosting))
3568         ts &lt;&lt; &quot; frame hosting node &quot; &lt;&lt; nodeID;
3569     if (auto nodeID = backing.scrollingNodeIDForRole(ScrollCoordinationRole::Positioning))
3570         ts &lt;&lt; &quot; positioning node &quot; &lt;&lt; nodeID;
3571     return ts;
3572 }
3573 
3574 } // namespace WebCore
    </pre>
  </body>
</html>
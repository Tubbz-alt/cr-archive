<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBGetResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBIndex.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 
 31 #include &quot;IDBBindingUtilities.h&quot;
 32 #include &quot;IDBCursor.h&quot;
 33 #include &quot;IDBDatabase.h&quot;
 34 #include &quot;IDBKeyRangeData.h&quot;
 35 #include &quot;IDBObjectStore.h&quot;
 36 #include &quot;IDBRequest.h&quot;
 37 #include &quot;IDBTransaction.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 40 
 41 namespace WebCore {
 42 using namespace JSC;
 43 
 44 IDBIndex::IDBIndex(ScriptExecutionContext&amp; context, const IDBIndexInfo&amp; info, IDBObjectStore&amp; objectStore)
 45     : ActiveDOMObject(&amp;context)
 46     , m_info(info)
 47     , m_originalInfo(info)
 48     , m_objectStore(objectStore)
 49 {
<span class="line-modified"> 50     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
 51 
 52     suspendIfNeeded();
 53 }
 54 
 55 IDBIndex::~IDBIndex()
 56 {
<span class="line-modified"> 57     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
 58 }
 59 
 60 const char* IDBIndex::activeDOMObjectName() const
 61 {
 62     return &quot;IDBIndex&quot;;
 63 }
 64 
<span class="line-removed"> 65 bool IDBIndex::canSuspendForDocumentSuspension() const</span>
<span class="line-removed"> 66 {</span>
<span class="line-removed"> 67     return false;</span>
<span class="line-removed"> 68 }</span>
<span class="line-removed"> 69 </span>
 70 bool IDBIndex::hasPendingActivity() const
 71 {
<span class="line-modified"> 72     return m_objectStore.transaction().hasPendingActivity();</span>
 73 }
 74 
 75 const String&amp; IDBIndex::name() const
 76 {
<span class="line-modified"> 77     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
 78     return m_info.name();
 79 }
 80 
 81 ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
 82 {
<span class="line-modified"> 83     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
 84 
 85     if (m_deleted)
 86         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
 87 
 88     if (m_objectStore.isDeleted())
 89         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s object store has been deleted.&quot;_s };
 90 
 91     if (!m_objectStore.transaction().isVersionChange())
 92         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not a version change transaction.&quot;_s };
 93 
 94     if (!m_objectStore.transaction().isActive())
 95         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not active.&quot;_s };
 96 
 97     if (m_info.name() == name)
 98         return { };
 99 
100     if (m_objectStore.info().hasIndex(name))
101         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The owning object store already has an index named &#39;&quot;, name, &quot;&#39;.&quot;) };
102 
103     m_objectStore.transaction().database().renameIndex(*this, name);
104     m_info.rename(name);
105 
106     return { };
107 }
108 
109 IDBObjectStore&amp; IDBIndex::objectStore()
110 {
<span class="line-modified">111     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
112     return m_objectStore;
113 }
114 
115 const IDBKeyPath&amp; IDBIndex::keyPath() const
116 {
<span class="line-modified">117     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
118     return m_info.keyPath();
119 }
120 
121 bool IDBIndex::unique() const
122 {
<span class="line-modified">123     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
124     return m_info.unique();
125 }
126 
127 bool IDBIndex::multiEntry() const
128 {
<span class="line-modified">129     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
130     return m_info.multiEntry();
131 }
132 
133 void IDBIndex::rollbackInfoForVersionChangeAbort()
134 {
<span class="line-modified">135     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
136 
137     // Only rollback to the original info if this index still exists in the rolled-back database info.
138     auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
139     if (!objectStoreInfo)
140         return;
141 
142     if (!objectStoreInfo-&gt;hasIndex(m_info.identifier())) {
143         m_deleted = true;
144         return;
145     }
146 
147     m_info = m_originalInfo;
148     m_deleted = false;
149 }
150 
<span class="line-modified">151 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
152 {
153     LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
<span class="line-modified">154     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
155 
156     if (m_deleted || m_objectStore.isDeleted())
157         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
158 
159     if (!m_objectStore.transaction().isActive())
160         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
161 
162     auto keyRange = function();
163     if (keyRange.hasException())
164         return keyRange.releaseException();
165 
166     IDBKeyRangeData rangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
167     if (rangeData.lowerKey.isNull())
168         rangeData.lowerKey = IDBKeyData::minimum();
169     if (rangeData.upperKey.isNull())
170         rangeData.upperKey = IDBKeyData::maximum();
171 
172     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
173     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
174 }
175 
<span class="line-modified">176 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
177 {
178     return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
179         return range;
180     });
181 }
182 
<span class="line-modified">183 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
184 {
185     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
186         auto onlyResult = IDBKeyRange::only(*state, key);
187         if (onlyResult.hasException())
188             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
189 
190         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
191     });
192 }
193 
<span class="line-modified">194 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(ExecState&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
195 {
196     LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
<span class="line-modified">197     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
198 
199     if (m_deleted || m_objectStore.isDeleted())
200         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
201 
202     if (!m_objectStore.transaction().isActive())
203         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
204 
205     auto keyRange = function();
206     if (keyRange.hasException())
207         return keyRange.releaseException();
208 
209     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
210     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
211     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
212 }
213 
<span class="line-modified">214 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
215 {
216     return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
217         return range;
218     });
219 }
220 
<span class="line-modified">221 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(ExecState&amp; execState, JSValue key, IDBCursorDirection direction)</span>
222 {
223     return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
224         auto onlyResult = IDBKeyRange::only(*state, key);
225         if (onlyResult.hasException())
226             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
227 
228         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
229     });
230 }
231 
<span class="line-modified">232 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, IDBKeyRange* range)</span>
233 {
234     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
235 
236     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
237 }
238 
<span class="line-modified">239 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(ExecState&amp; execState, JSValue key)</span>
240 {
241     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
242 
243     auto idbKey = scriptValueToIDBKey(execState, key);
244     auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
245 
246     return doCount(execState, IDBKeyRangeData(idbKeyPointer));
247 }
248 
<span class="line-modified">249 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(ExecState&amp; execState, const IDBKeyRangeData&amp; range)</span>
250 {
<span class="line-modified">251     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
252 
253     if (m_deleted || m_objectStore.isDeleted())
254         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
255 
256     auto&amp; transaction = m_objectStore.transaction();
257     if (!transaction.isActive())
258         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
259 
260     if (!range.isValid())
261         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
262 
263     return transaction.requestCount(execState, *this, range);
264 }
265 
<span class="line-modified">266 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, IDBKeyRange* range)</span>
267 {
268     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
269 
270     return doGet(execState, IDBKeyRangeData(range));
271 }
272 
<span class="line-modified">273 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(ExecState&amp; execState, JSValue key)</span>
274 {
275     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
276 
277     auto idbKey = scriptValueToIDBKey(execState, key);
278     if (!idbKey-&gt;isValid())
279         return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
280 
281     return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
282 }
283 
<span class="line-modified">284 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
285 {
<span class="line-modified">286     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
287 
288     if (m_deleted || m_objectStore.isDeleted())
289         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
290 
291     auto&amp; transaction = m_objectStore.transaction();
292     if (!transaction.isActive())
293         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
294 
295     if (range.hasException())
296         return range.releaseException();
297     auto keyRange = range.releaseReturnValue();
298 
299     if (keyRange.isNull)
300         return Exception { DataError };
301 
302     return transaction.requestGetValue(execState, *this, keyRange);
303 }
304 
<span class="line-modified">305 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, IDBKeyRange* range)</span>
306 {
307     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
308 
309     return doGetKey(execState, IDBKeyRangeData(range));
310 }
311 
<span class="line-modified">312 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(ExecState&amp; execState, JSValue key)</span>
313 {
314     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
315 
316     auto idbKey = scriptValueToIDBKey(execState, key);
317     if (!idbKey-&gt;isValid())
318         return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
319 
320     return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
321 }
322 
<span class="line-modified">323 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(ExecState&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
324 {
<span class="line-modified">325     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
326 
327     if (m_deleted || m_objectStore.isDeleted())
328         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
329 
330     auto&amp; transaction = m_objectStore.transaction();
331     if (!transaction.isActive())
332         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
333 
334     if (range.hasException())
335         return range.releaseException();
336     auto keyRange = range.releaseReturnValue();
337 
338     if (keyRange.isNull)
339         return Exception { DataError };
340 
341     return transaction.requestGetKey(execState, *this, keyRange);
342 }
343 
<span class="line-modified">344 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
345 {
346     LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
<span class="line-modified">347     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
348 
349     if (m_deleted || m_objectStore.isDeleted())
350         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
351 
352     if (!m_objectStore.transaction().isActive())
353         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
354 
355     auto keyRange = function();
356     if (keyRange.hasException())
357         return keyRange.releaseException();
358 
359     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
360     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
361 }
362 
<span class="line-modified">363 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
364 {
365     return doGetAll(execState, count, [range = WTFMove(range)]() {
366         return range;
367     });
368 }
369 
<span class="line-modified">370 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
371 {
372     return doGetAll(execState, count, [state=&amp;execState, key]() {
373         auto onlyResult = IDBKeyRange::only(*state, key);
374         if (onlyResult.hasException())
375             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
376 
377         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
378     });
379 }
380 
<span class="line-modified">381 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(ExecState&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
382 {
383     LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
<span class="line-modified">384     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
385 
386     if (m_deleted || m_objectStore.isDeleted())
387         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
388 
389     if (!m_objectStore.transaction().isActive())
390         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
391 
392     auto keyRange = function();
393     if (keyRange.hasException())
394         return keyRange.releaseException();
395 
396     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
397     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
398 }
399 
<span class="line-modified">400 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
401 {
402     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
403         return range;
404     });
405 }
406 
<span class="line-modified">407 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(ExecState&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
408 {
409     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
410         auto onlyResult = IDBKeyRange::only(*state, key);
411         if (onlyResult.hasException())
412             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
413 
414         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
415     });
416 }
417 
418 void IDBIndex::markAsDeleted()
419 {
<span class="line-modified">420     ASSERT(&amp;m_objectStore.transaction().database().originThread() == &amp;Thread::current());</span>
421 
422     ASSERT(!m_deleted);
423     m_deleted = true;
424 }
425 
426 void IDBIndex::ref()
427 {
428     m_objectStore.ref();
429 }
430 
431 void IDBIndex::deref()
432 {
433     m_objectStore.deref();
434 }
435 
436 } // namespace WebCore
437 
438 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 30 
 31 #include &quot;IDBBindingUtilities.h&quot;
 32 #include &quot;IDBCursor.h&quot;
 33 #include &quot;IDBDatabase.h&quot;
 34 #include &quot;IDBKeyRangeData.h&quot;
 35 #include &quot;IDBObjectStore.h&quot;
 36 #include &quot;IDBRequest.h&quot;
 37 #include &quot;IDBTransaction.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &lt;JavaScriptCore/HeapInlines.h&gt;
 40 
 41 namespace WebCore {
 42 using namespace JSC;
 43 
 44 IDBIndex::IDBIndex(ScriptExecutionContext&amp; context, const IDBIndexInfo&amp; info, IDBObjectStore&amp; objectStore)
 45     : ActiveDOMObject(&amp;context)
 46     , m_info(info)
 47     , m_originalInfo(info)
 48     , m_objectStore(objectStore)
 49 {
<span class="line-modified"> 50     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
 51 
 52     suspendIfNeeded();
 53 }
 54 
 55 IDBIndex::~IDBIndex()
 56 {
<span class="line-modified"> 57     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
 58 }
 59 
 60 const char* IDBIndex::activeDOMObjectName() const
 61 {
 62     return &quot;IDBIndex&quot;;
 63 }
 64 





 65 bool IDBIndex::hasPendingActivity() const
 66 {
<span class="line-modified"> 67     return m_objectStore.hasPendingActivity();</span>
 68 }
 69 
 70 const String&amp; IDBIndex::name() const
 71 {
<span class="line-modified"> 72     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
 73     return m_info.name();
 74 }
 75 
 76 ExceptionOr&lt;void&gt; IDBIndex::setName(const String&amp; name)
 77 {
<span class="line-modified"> 78     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
 79 
 80     if (m_deleted)
 81         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index has been deleted.&quot;_s };
 82 
 83     if (m_objectStore.isDeleted())
 84         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s object store has been deleted.&quot;_s };
 85 
 86     if (!m_objectStore.transaction().isVersionChange())
 87         return Exception { InvalidStateError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not a version change transaction.&quot;_s };
 88 
 89     if (!m_objectStore.transaction().isActive())
 90         return Exception { TransactionInactiveError, &quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The index&#39;s transaction is not active.&quot;_s };
 91 
 92     if (m_info.name() == name)
 93         return { };
 94 
 95     if (m_objectStore.info().hasIndex(name))
 96         return Exception { ConstraintError, makeString(&quot;Failed set property &#39;name&#39; on &#39;IDBIndex&#39;: The owning object store already has an index named &#39;&quot;, name, &quot;&#39;.&quot;) };
 97 
 98     m_objectStore.transaction().database().renameIndex(*this, name);
 99     m_info.rename(name);
100 
101     return { };
102 }
103 
104 IDBObjectStore&amp; IDBIndex::objectStore()
105 {
<span class="line-modified">106     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
107     return m_objectStore;
108 }
109 
110 const IDBKeyPath&amp; IDBIndex::keyPath() const
111 {
<span class="line-modified">112     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
113     return m_info.keyPath();
114 }
115 
116 bool IDBIndex::unique() const
117 {
<span class="line-modified">118     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
119     return m_info.unique();
120 }
121 
122 bool IDBIndex::multiEntry() const
123 {
<span class="line-modified">124     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
125     return m_info.multiEntry();
126 }
127 
128 void IDBIndex::rollbackInfoForVersionChangeAbort()
129 {
<span class="line-modified">130     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
131 
132     // Only rollback to the original info if this index still exists in the rolled-back database info.
133     auto* objectStoreInfo = m_objectStore.transaction().database().info().infoForExistingObjectStore(m_objectStore.info().identifier());
134     if (!objectStoreInfo)
135         return;
136 
137     if (!objectStoreInfo-&gt;hasIndex(m_info.identifier())) {
138         m_deleted = true;
139         return;
140     }
141 
142     m_info = m_originalInfo;
143     m_deleted = false;
144 }
145 
<span class="line-modified">146 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
147 {
148     LOG(IndexedDB, &quot;IDBIndex::openCursor&quot;);
<span class="line-modified">149     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
150 
151     if (m_deleted || m_objectStore.isDeleted())
152         return Exception { InvalidStateError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
153 
154     if (!m_objectStore.transaction().isActive())
155         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
156 
157     auto keyRange = function();
158     if (keyRange.hasException())
159         return keyRange.releaseException();
160 
161     IDBKeyRangeData rangeData = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
162     if (rangeData.lowerKey.isNull())
163         rangeData.lowerKey = IDBKeyData::minimum();
164     if (rangeData.upperKey.isNull())
165         rangeData.upperKey = IDBKeyData::maximum();
166 
167     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), rangeData, direction, IndexedDB::CursorType::KeyAndValue);
168     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
169 }
170 
<span class="line-modified">171 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
172 {
173     return doOpenCursor(execState, direction, [range=WTFMove(range)]() {
174         return range;
175     });
176 }
177 
<span class="line-modified">178 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
179 {
180     return doOpenCursor(execState, direction, [state=&amp;execState, key]() {
181         auto onlyResult = IDBKeyRange::only(*state, key);
182         if (onlyResult.hasException())
183             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
184 
185         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
186     });
187 }
188 
<span class="line-modified">189 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doOpenKeyCursor(JSGlobalObject&amp; execState, IDBCursorDirection direction, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
190 {
191     LOG(IndexedDB, &quot;IDBIndex::openKeyCursor&quot;);
<span class="line-modified">192     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
193 
194     if (m_deleted || m_objectStore.isDeleted())
195         return Exception { InvalidStateError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
196 
197     if (!m_objectStore.transaction().isActive())
198         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
199 
200     auto keyRange = function();
201     if (keyRange.hasException())
202         return keyRange.releaseException();
203 
204     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
205     auto info = IDBCursorInfo::indexCursor(m_objectStore.transaction(), m_objectStore.info().identifier(), m_info.identifier(), keyRangePointer, direction, IndexedDB::CursorType::KeyOnly);
206     return m_objectStore.transaction().requestOpenCursor(execState, *this, info);
207 }
208 
<span class="line-modified">209 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, IDBCursorDirection direction)</span>
210 {
211     return doOpenKeyCursor(execState, direction, [range=WTFMove(range)]() {
212         return range;
213     });
214 }
215 
<span class="line-modified">216 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::openKeyCursor(JSGlobalObject&amp; execState, JSValue key, IDBCursorDirection direction)</span>
217 {
218     return doOpenKeyCursor(execState, direction, [state=&amp;execState, key]() {
219         auto onlyResult = IDBKeyRange::only(*state, key);
220         if (onlyResult.hasException())
221             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;openKeyCursor&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
222 
223         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
224     });
225 }
226 
<span class="line-modified">227 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
228 {
229     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
230 
231     return doCount(execState, range ? IDBKeyRangeData(range) : IDBKeyRangeData::allKeys());
232 }
233 
<span class="line-modified">234 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::count(JSGlobalObject&amp; execState, JSValue key)</span>
235 {
236     LOG(IndexedDB, &quot;IDBIndex::count&quot;);
237 
238     auto idbKey = scriptValueToIDBKey(execState, key);
239     auto* idbKeyPointer = idbKey-&gt;isValid() ? idbKey.ptr() : nullptr;
240 
241     return doCount(execState, IDBKeyRangeData(idbKeyPointer));
242 }
243 
<span class="line-modified">244 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doCount(JSGlobalObject&amp; execState, const IDBKeyRangeData&amp; range)</span>
245 {
<span class="line-modified">246     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
247 
248     if (m_deleted || m_objectStore.isDeleted())
249         return Exception { InvalidStateError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
250 
251     auto&amp; transaction = m_objectStore.transaction();
252     if (!transaction.isActive())
253         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
254 
255     if (!range.isValid())
256         return Exception { DataError, &quot;Failed to execute &#39;count&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s };
257 
258     return transaction.requestCount(execState, *this, range);
259 }
260 
<span class="line-modified">261 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
262 {
263     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
264 
265     return doGet(execState, IDBKeyRangeData(range));
266 }
267 
<span class="line-modified">268 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::get(JSGlobalObject&amp; execState, JSValue key)</span>
269 {
270     LOG(IndexedDB, &quot;IDBIndex::get&quot;);
271 
272     auto idbKey = scriptValueToIDBKey(execState, key);
273     if (!idbKey-&gt;isValid())
274         return doGet(execState, Exception(DataError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
275 
276     return doGet(execState, IDBKeyRangeData(idbKey.ptr()));
277 }
278 
<span class="line-modified">279 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGet(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
280 {
<span class="line-modified">281     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
282 
283     if (m_deleted || m_objectStore.isDeleted())
284         return Exception { InvalidStateError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
285 
286     auto&amp; transaction = m_objectStore.transaction();
287     if (!transaction.isActive())
288         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;get&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
289 
290     if (range.hasException())
291         return range.releaseException();
292     auto keyRange = range.releaseReturnValue();
293 
294     if (keyRange.isNull)
295         return Exception { DataError };
296 
297     return transaction.requestGetValue(execState, *this, keyRange);
298 }
299 
<span class="line-modified">300 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, IDBKeyRange* range)</span>
301 {
302     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
303 
304     return doGetKey(execState, IDBKeyRangeData(range));
305 }
306 
<span class="line-modified">307 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getKey(JSGlobalObject&amp; execState, JSValue key)</span>
308 {
309     LOG(IndexedDB, &quot;IDBIndex::getKey&quot;);
310 
311     auto idbKey = scriptValueToIDBKey(execState, key);
312     if (!idbKey-&gt;isValid())
313         return doGetKey(execState, Exception(DataError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s));
314 
315     return doGetKey(execState, IDBKeyRangeData(idbKey.ptr()));
316 }
317 
<span class="line-modified">318 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetKey(JSGlobalObject&amp; execState, ExceptionOr&lt;IDBKeyRangeData&gt; range)</span>
319 {
<span class="line-modified">320     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
321 
322     if (m_deleted || m_objectStore.isDeleted())
323         return Exception { InvalidStateError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
324 
325     auto&amp; transaction = m_objectStore.transaction();
326     if (!transaction.isActive())
327         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getKey&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
328 
329     if (range.hasException())
330         return range.releaseException();
331     auto keyRange = range.releaseReturnValue();
332 
333     if (keyRange.isNull)
334         return Exception { DataError };
335 
336     return transaction.requestGetKey(execState, *this, keyRange);
337 }
338 
<span class="line-modified">339 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAll(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
340 {
341     LOG(IndexedDB, &quot;IDBIndex::getAll&quot;);
<span class="line-modified">342     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
343 
344     if (m_deleted || m_objectStore.isDeleted())
345         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
346 
347     if (!m_objectStore.transaction().isActive())
348         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
349 
350     auto keyRange = function();
351     if (keyRange.hasException())
352         return keyRange.releaseException();
353 
354     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
355     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Values, count);
356 }
357 
<span class="line-modified">358 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
359 {
360     return doGetAll(execState, count, [range = WTFMove(range)]() {
361         return range;
362     });
363 }
364 
<span class="line-modified">365 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAll(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
366 {
367     return doGetAll(execState, count, [state=&amp;execState, key]() {
368         auto onlyResult = IDBKeyRange::only(*state, key);
369         if (onlyResult.hasException())
370             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAll&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
371 
372         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
373     });
374 }
375 
<span class="line-modified">376 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::doGetAllKeys(JSGlobalObject&amp; execState, Optional&lt;uint32_t&gt; count, WTF::Function&lt;ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;()&gt;&amp;&amp; function)</span>
377 {
378     LOG(IndexedDB, &quot;IDBIndex::getAllKeys&quot;);
<span class="line-modified">379     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
380 
381     if (m_deleted || m_objectStore.isDeleted())
382         return Exception { InvalidStateError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The index or its object store has been deleted.&quot;_s };
383 
384     if (!m_objectStore.transaction().isActive())
385         return Exception { TransactionInactiveError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The transaction is inactive or finished.&quot;_s };
386 
387     auto keyRange = function();
388     if (keyRange.hasException())
389         return keyRange.releaseException();
390 
391     auto* keyRangePointer = keyRange.returnValue() ? keyRange.releaseReturnValue().get() : nullptr;
392     return m_objectStore.transaction().requestGetAllIndexRecords(execState, *this, keyRangePointer, IndexedDB::GetAllType::Keys, count);
393 }
394 
<span class="line-modified">395 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, RefPtr&lt;IDBKeyRange&gt;&amp;&amp; range, Optional&lt;uint32_t&gt; count)</span>
396 {
397     return doGetAllKeys(execState, count, [range = WTFMove(range)]() {
398         return range;
399     });
400 }
401 
<span class="line-modified">402 ExceptionOr&lt;Ref&lt;IDBRequest&gt;&gt; IDBIndex::getAllKeys(JSGlobalObject&amp; execState, JSValue key, Optional&lt;uint32_t&gt; count)</span>
403 {
404     return doGetAllKeys(execState, count, [state=&amp;execState, key]() {
405         auto onlyResult = IDBKeyRange::only(*state, key);
406         if (onlyResult.hasException())
407             return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt;{ Exception(DataError, &quot;Failed to execute &#39;getAllKeys&#39; on &#39;IDBIndex&#39;: The parameter is not a valid key.&quot;_s) };
408 
409         return ExceptionOr&lt;RefPtr&lt;IDBKeyRange&gt;&gt; { onlyResult.releaseReturnValue() };
410     });
411 }
412 
413 void IDBIndex::markAsDeleted()
414 {
<span class="line-modified">415     ASSERT(canCurrentThreadAccessThreadLocalData(m_objectStore.transaction().database().originThread()));</span>
416 
417     ASSERT(!m_deleted);
418     m_deleted = true;
419 }
420 
421 void IDBIndex::ref()
422 {
423     m_objectStore.ref();
424 }
425 
426 void IDBIndex::deref()
427 {
428     m_objectStore.deref();
429 }
430 
431 } // namespace WebCore
432 
433 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBGetResult.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBIndex.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
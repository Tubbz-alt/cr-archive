<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/SegmentedVector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #pragma once
 30 
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace WTF {
 35 
 36     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SegmentedVector);
 37 
 38     // An iterator for SegmentedVector. It supports only the pre ++ operator
 39     template &lt;typename T, size_t SegmentSize = 8&gt; class SegmentedVector;
 40     template &lt;typename T, size_t SegmentSize = 8&gt; class SegmentedVectorIterator {
 41         WTF_MAKE_FAST_ALLOCATED;
 42     private:
 43         friend class SegmentedVector&lt;T, SegmentSize&gt;;
 44     public:
 45         typedef SegmentedVectorIterator&lt;T, SegmentSize&gt; Iterator;
 46 
 47         ~SegmentedVectorIterator() { }
 48 
 49         T&amp; operator*() const { return m_vector.at(m_index); }
 50         T* operator-&gt;() const { return &amp;m_vector.at(m_index); }
 51 
 52         // Only prefix ++ operator supported
 53         Iterator&amp; operator++()
 54         {
 55             m_index++;
 56             return *this;
 57         }
 58 
 59         bool operator==(const Iterator&amp; other) const
 60         {
 61             return m_index == other.m_index &amp;&amp; &amp;m_vector == &amp;other.m_vector;
 62         }
 63 
 64         bool operator!=(const Iterator&amp; other) const
 65         {
 66             return m_index != other.m_index || &amp;m_vector != &amp;other.m_vector;
 67         }
 68 
 69         SegmentedVectorIterator&amp; operator=(const SegmentedVectorIterator&lt;T, SegmentSize&gt;&amp; other)
 70         {
 71             m_vector = other.m_vector;
 72             m_index = other.m_index;
 73             return *this;
 74         }
 75 
 76     private:
 77         SegmentedVectorIterator(SegmentedVector&lt;T, SegmentSize&gt;&amp; vector, size_t index)
 78             : m_vector(vector)
 79             , m_index(index)
 80         {
 81         }
 82 
 83         SegmentedVector&lt;T, SegmentSize&gt;&amp; m_vector;
 84         size_t m_index;
 85     };
 86 
 87     // SegmentedVector is just like Vector, but it doesn&#39;t move the values
 88     // stored in its buffer when it grows. Therefore, it is safe to keep
 89     // pointers into a SegmentedVector. The default tuning values are
 90     // optimized for segmented vectors that get large; you may want to use
 91     // SegmentedVector&lt;thingy, 1&gt; if you don&#39;t expect a lot of entries.
 92     template &lt;typename T, size_t SegmentSize&gt;
 93     class SegmentedVector final {
 94         friend class SegmentedVectorIterator&lt;T, SegmentSize&gt;;
 95         WTF_MAKE_NONCOPYABLE(SegmentedVector);
 96         WTF_MAKE_FAST_ALLOCATED;
 97 
 98     public:
 99         typedef SegmentedVectorIterator&lt;T, SegmentSize&gt; Iterator;
100 
101         SegmentedVector() = default;
102 
103         ~SegmentedVector()
104         {
105             deleteAllSegments();
106         }
107 
108         size_t size() const { return m_size; }
109         bool isEmpty() const { return !size(); }
110 
111         T&amp; at(size_t index)
112         {
113             ASSERT_WITH_SECURITY_IMPLICATION(index &lt; m_size);
114             return segmentFor(index)-&gt;entries[subscriptFor(index)];
115         }
116 
117         const T&amp; at(size_t index) const
118         {
119             return const_cast&lt;SegmentedVector&lt;T, SegmentSize&gt;*&gt;(this)-&gt;at(index);
120         }
121 
122         T&amp; operator[](size_t index)
123         {
124             return at(index);
125         }
126 
127         const T&amp; operator[](size_t index) const
128         {
129             return at(index);
130         }
131 
132         T&amp; first()
133         {
134             ASSERT_WITH_SECURITY_IMPLICATION(!isEmpty());
135             return at(0);
136         }
137         const T&amp; first() const
138         {
139             ASSERT_WITH_SECURITY_IMPLICATION(!isEmpty());
140             return at(0);
141         }
142         T&amp; last()
143         {
144             ASSERT_WITH_SECURITY_IMPLICATION(!isEmpty());
145             return at(size() - 1);
146         }
147         const T&amp; last() const
148         {
149             ASSERT_WITH_SECURITY_IMPLICATION(!isEmpty());
150             return at(size() - 1);
151         }
152 
153         T takeLast()
154         {
155             ASSERT_WITH_SECURITY_IMPLICATION(!isEmpty());
156             T result = WTFMove(last());
157             --m_size;
158             return result;
159         }
160 
161         template&lt;typename... Args&gt;
162         void append(Args&amp;&amp;... args)
163         {
164             ++m_size;
165             if (!segmentExistsFor(m_size - 1))
166                 allocateSegment();
167             new (NotNull, &amp;last()) T(std::forward&lt;Args&gt;(args)...);
168         }
169 
170         template&lt;typename... Args&gt;
171         T&amp; alloc(Args&amp;&amp;... args)
172         {
173             append(std::forward&lt;Args&gt;(args)...);
174             return last();
175         }
176 
177         void removeLast()
178         {
179             last().~T();
180             --m_size;
181         }
182 
183         void grow(size_t size)
184         {
185             ASSERT(size &gt; m_size);
186             ensureSegmentsFor(size);
187             size_t oldSize = m_size;
188             m_size = size;
189             for (size_t i = oldSize; i &lt; m_size; ++i)
190                 new (NotNull, &amp;at(i)) T();
191         }
192 
193         void clear()
194         {
195             deleteAllSegments();
196             m_segments.clear();
197             m_size = 0;
198         }
199 
200         Iterator begin()
201         {
202             return Iterator(*this, 0);
203         }
204 
205         Iterator end()
206         {
207             return Iterator(*this, m_size);
208         }
209 
210         void shrinkToFit()
211         {
212             m_segments.shrinkToFit();
213         }
214 
215     private:
216         struct Segment {
217 #if COMPILER(MSVC)
218 #pragma warning(push)
219 #pragma warning(disable: 4200)
220 #endif
221             T entries[0];
222 #if COMPILER(MSVC)
223 #pragma warning(pop)
224 #endif
225         };
226 
227         void deleteAllSegments()
228         {
229             for (size_t i = 0; i &lt; m_size; ++i)
230                 at(i).~T();
231             for (size_t i = 0; i &lt; m_segments.size(); ++i)
232                 SegmentedVectorMalloc::free(m_segments[i]);
233         }
234 
235         bool segmentExistsFor(size_t index)
236         {
237             return index / SegmentSize &lt; m_segments.size();
238         }
239 
240         Segment* segmentFor(size_t index)
241         {
242             return m_segments[index / SegmentSize];
243         }
244 
245         size_t subscriptFor(size_t index)
246         {
247             return index % SegmentSize;
248         }
249 
250         void ensureSegmentsFor(size_t size)
251         {
252             size_t segmentCount = (m_size + SegmentSize - 1) / SegmentSize;
253             size_t neededSegmentCount = (size + SegmentSize - 1) / SegmentSize;
254 
255             for (size_t i = segmentCount ? segmentCount - 1 : 0; i &lt; neededSegmentCount; ++i)
256                 ensureSegment(i);
257         }
258 
259         void ensureSegment(size_t segmentIndex)
260         {
261             ASSERT_WITH_SECURITY_IMPLICATION(segmentIndex &lt;= m_segments.size());
262             if (segmentIndex == m_segments.size())
263                 allocateSegment();
264         }
265 
266         void allocateSegment()
267         {
268             m_segments.append(static_cast&lt;Segment*&gt;(SegmentedVectorMalloc::malloc(sizeof(T) * SegmentSize)));
269         }
270 
271         size_t m_size { 0 };
272         Vector&lt;Segment*&gt; m_segments;
273     };
274 
275 } // namespace WTF
276 
277 using WTF::SegmentedVector;
    </pre>
  </body>
</html>
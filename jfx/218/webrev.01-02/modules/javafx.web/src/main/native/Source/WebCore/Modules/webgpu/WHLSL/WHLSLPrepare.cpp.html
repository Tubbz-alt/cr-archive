<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLPrepare.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLPrepare.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLASTDumper.h&quot;
 32 #include &quot;WHLSLCheckDuplicateFunctions.h&quot;
 33 #include &quot;WHLSLCheckReferenceTypes.h&quot;
 34 #include &quot;WHLSLCheckTextureReferences.h&quot;
 35 #include &quot;WHLSLChecker.h&quot;
 36 #include &quot;WHLSLComputeDimensions.h&quot;
 37 #include &quot;WHLSLFunctionStageChecker.h&quot;
 38 #include &quot;WHLSLHighZombieFinder.h&quot;
 39 #include &quot;WHLSLLiteralTypeChecker.h&quot;
 40 #include &quot;WHLSLMetalCodeGenerator.h&quot;
 41 #include &quot;WHLSLNameResolver.h&quot;
 42 #include &quot;WHLSLNameSpace.h&quot;
 43 #include &quot;WHLSLParser.h&quot;
 44 #include &quot;WHLSLPreserveVariableLifetimes.h&quot;
 45 #include &quot;WHLSLProgram.h&quot;
 46 #include &quot;WHLSLPropertyResolver.h&quot;
 47 #include &quot;WHLSLPruneUnreachableStandardLibraryFunctions.h&quot;
 48 #include &quot;WHLSLRecursionChecker.h&quot;
 49 #include &quot;WHLSLRecursiveTypeChecker.h&quot;
 50 #include &quot;WHLSLSemanticMatcher.h&quot;
 51 #include &quot;WHLSLStandardLibraryUtilities.h&quot;
 52 #include &quot;WHLSLStatementBehaviorChecker.h&quot;
 53 #include &quot;WHLSLSynthesizeConstructors.h&quot;
 54 #include &quot;WHLSLSynthesizeEnumerationFunctions.h&quot;
 55 #include &lt;wtf/MonotonicTime.h&gt;
 56 #include &lt;wtf/Optional.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 namespace WHLSL {
 61 
 62 struct ShaderModule {
 63     WTF_MAKE_FAST_ALLOCATED;
 64 public:
 65 
 66     ShaderModule(const String&amp; whlslSource)
 67         : whlslSource(whlslSource)
 68     {
 69     }
 70 
 71     String whlslSource;
 72 };
 73 
 74 }
 75 
 76 }
 77 
 78 namespace std {
 79 
 80 void default_delete&lt;WebCore::WHLSL::ShaderModule&gt;::operator()(WebCore::WHLSL::ShaderModule* shaderModule) const
 81 {
 82     delete shaderModule;
 83 }
 84 
 85 }
 86 
 87 namespace WebCore {
 88 
 89 namespace WHLSL {
 90 
 91 static constexpr bool dumpASTBeforeEachPass = false;
 92 static constexpr bool dumpASTAfterParsing = false;
 93 static constexpr bool dumpASTAtEnd = false;
 94 static constexpr bool alwaysDumpPassFailures = false;
 95 static constexpr bool dumpPassFailure = dumpASTBeforeEachPass || dumpASTAfterParsing || dumpASTAtEnd || alwaysDumpPassFailures;
 96 static constexpr bool dumpPhaseTimes = false;
 97 
 98 static constexpr bool parseFullStandardLibrary = false;
 99 
100 static bool dumpASTIfNeeded(bool shouldDump, Program&amp; program, const char* message)
101 {
102     if (shouldDump) {
103         dataLogLn(message);
104         dumpAST(program);
105         return true;
106     }
107 
108     return false;
109 }
110 
111 static bool dumpASTAfterParsingIfNeeded(Program&amp; program)
112 {
113     return dumpASTIfNeeded(dumpASTAfterParsing, program, &quot;AST after parsing&quot;);
114 }
115 
116 static bool dumpASTBetweenEachPassIfNeeded(Program&amp; program, const char* message)
117 {
118     return dumpASTIfNeeded(dumpASTBeforeEachPass, program, message);
119 }
120 
121 static bool dumpASTAtEndIfNeeded(Program&amp; program)
122 {
123     return dumpASTIfNeeded(dumpASTAtEnd, program, &quot;AST at end&quot;);
124 }
125 
126 using PhaseTimes = Vector&lt;std::pair&lt;String, Seconds&gt;&gt;;
127 
128 static void logPhaseTimes(PhaseTimes&amp; phaseTimes)
129 {
130     if (!dumpPhaseTimes)
131         return;
132 
133     for (auto&amp; entry : phaseTimes)
134         dataLogLn(entry.first, &quot;: &quot;, entry.second.milliseconds(), &quot; ms&quot;);
135 }
136 
137 class PhaseTimer {
138 public:
139     PhaseTimer(const char* phaseName, PhaseTimes&amp; phaseTimes)
140         : m_phaseTimes(phaseTimes)
141     {
142         if (dumpPhaseTimes) {
143             m_phaseName = phaseName;
144             m_start = MonotonicTime::now();
145         }
146     }
147 
148     ~PhaseTimer()
149     {
150         if (dumpPhaseTimes) {
151             auto totalTime = MonotonicTime::now() - m_start;
152             m_phaseTimes.append({ m_phaseName, totalTime });
153         }
154     }
155 
156 private:
157     String m_phaseName;
158     PhaseTimes&amp; m_phaseTimes;
159     MonotonicTime m_start;
160 };
161 
162 UniqueRef&lt;ShaderModule&gt; createShaderModule(const String&amp; whlslSource)
163 {
164     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200872 We should consider moving as much work from prepare() into here as possible.
165     return makeUniqueRef&lt;ShaderModule&gt;(whlslSource);
166 }
167 
168 #define CHECK_PASS(pass, ...) \
169     do { \
170         dumpASTBetweenEachPassIfNeeded(program, &quot;AST before &quot; # pass); \
171         PhaseTimer phaseTimer(#pass, phaseTimes); \
172         auto result = pass(__VA_ARGS__); \
173         if (!result) { \
174             if (dumpPassFailure) \
175                 dataLogLn(&quot;failed pass: &quot; # pass, Lexer::errorString(result.error(), whlslSource1, whlslSource2)); \
176             return makeUnexpected(Lexer::errorString(result.error(), whlslSource1, whlslSource2)); \
177         } \
178     } while (0)
179 
180 #define RUN_PASS(pass, ...) \
181     do { \
182         PhaseTimer phaseTimer(#pass, phaseTimes); \
183         dumpASTBetweenEachPassIfNeeded(program, &quot;AST before &quot; # pass); \
184         pass(__VA_ARGS__); \
185     } while (0)
186 
187 static Expected&lt;Program, String&gt; prepareShared(PhaseTimes&amp; phaseTimes, const String&amp; whlslSource1, const String* whlslSource2 = nullptr)
188 {
189     Program program;
190     Parser parser;
191 
192     {
193         program.nameContext().setCurrentNameSpace(AST::NameSpace::NameSpace1);
194 
195         PhaseTimer phaseTimer(&quot;parse&quot;, phaseTimes);
196         auto parseResult = parser.parse(program, whlslSource1, ParsingMode::User, AST::NameSpace::NameSpace1);
197         if (!parseResult) {
198             if (dumpPassFailure)
199                 dataLogLn(&quot;failed to parse the program: &quot;, Lexer::errorString(parseResult.error(), whlslSource1, whlslSource2));
200             return makeUnexpected(Lexer::errorString(parseResult.error(), whlslSource1, whlslSource2));
201         }
202         if (whlslSource2) {
203             program.nameContext().setCurrentNameSpace(AST::NameSpace::NameSpace2);
204             auto parseResult = parser.parse(program, *whlslSource2, ParsingMode::User, AST::NameSpace::NameSpace2);
205             if (!parseResult) {
206                 if (dumpPassFailure)
207                     dataLogLn(&quot;failed to parse the program: &quot;, Lexer::errorString(parseResult.error(), whlslSource1, whlslSource2));
208                 return makeUnexpected(Lexer::errorString(parseResult.error(), whlslSource1, whlslSource2));
209             }
210         }
211         program.nameContext().setCurrentNameSpace(AST::NameSpace::StandardLibrary);
212     }
213 
214     {
215         PhaseTimer phaseTimer(&quot;includeStandardLibrary&quot;, phaseTimes);
216         includeStandardLibrary(program, parser, parseFullStandardLibrary);
217     }
218 
219     if (!dumpASTBetweenEachPassIfNeeded(program, &quot;AST after parsing&quot;))
220         dumpASTAfterParsingIfNeeded(program);
221 
222     NameResolver nameResolver(program.nameContext());
223     CHECK_PASS(resolveNamesInTypes, program, nameResolver);
224     CHECK_PASS(checkRecursiveTypes, program);
225     CHECK_PASS(synthesizeEnumerationFunctions, program);
226     CHECK_PASS(resolveTypeNamesInFunctions, program, nameResolver);
227     CHECK_PASS(synthesizeConstructors, program);
228     CHECK_PASS(checkDuplicateFunctions, program);
229 
230     CHECK_PASS(check, program);
231     RUN_PASS(pruneUnreachableStandardLibraryFunctions, program);
232 
233     RUN_PASS(checkLiteralTypes, program);
234     CHECK_PASS(checkTextureReferences, program);
235     CHECK_PASS(checkReferenceTypes, program);
236     RUN_PASS(resolveProperties, program);
237     RUN_PASS(findHighZombies, program);
238     CHECK_PASS(checkStatementBehavior, program);
239     CHECK_PASS(checkRecursion, program);
240     CHECK_PASS(checkFunctionStages, program);
241     RUN_PASS(preserveVariableLifetimes, program);
242 
243     dumpASTAtEndIfNeeded(program);
244 
245     return program;
246 }
247 
248 Expected&lt;RenderPrepareResult, String&gt; prepare(const ShaderModule&amp; vertexShaderModule, const ShaderModule* fragmentShaderModule, RenderPipelineDescriptor&amp; renderPipelineDescriptor)
249 {
250     PhaseTimes phaseTimes;
251     Metal::RenderMetalCode generatedCode;
252 
253     {
254         PhaseTimer phaseTimer(&quot;prepare total&quot;, phaseTimes);
255         const String* secondShader = nullptr;
256         bool distinctFragmentShader = false;
257         if (fragmentShaderModule &amp;&amp; fragmentShaderModule != &amp;vertexShaderModule) {
258             secondShader = &amp;fragmentShaderModule-&gt;whlslSource;
259             distinctFragmentShader = true;
260         }
261         auto program = prepareShared(phaseTimes, vertexShaderModule.whlslSource, secondShader);
262         if (!program)
263             return makeUnexpected(program.error());
264 
265         Optional&lt;MatchedRenderSemantics&gt; matchedSemantics;
266         {
267             PhaseTimer phaseTimer(&quot;matchSemantics&quot;, phaseTimes);
268             matchedSemantics = matchSemantics(*program, renderPipelineDescriptor, distinctFragmentShader, fragmentShaderModule);
269             if (!matchedSemantics)
270                 return makeUnexpected(Lexer::errorString(Error(&quot;Could not match semantics&quot;_str), vertexShaderModule.whlslSource, secondShader));
271         }
272 
273         {
274             PhaseTimer phaseTimer(&quot;generateMetalCode&quot;, phaseTimes);
275             generatedCode = Metal::generateMetalCode(*program, WTFMove(*matchedSemantics), renderPipelineDescriptor.layout);
276         }
277     }
278 
279     logPhaseTimes(phaseTimes);
280 
281     RenderPrepareResult result;
282     result.metalSource = WTFMove(generatedCode.metalSource);
283     result.mangledVertexEntryPointName = WTFMove(generatedCode.mangledVertexEntryPointName);
284     result.mangledFragmentEntryPointName = WTFMove(generatedCode.mangledFragmentEntryPointName);
285     return result;
286 }
287 
288 Expected&lt;ComputePrepareResult, String&gt; prepare(const ShaderModule&amp; shaderModule, ComputePipelineDescriptor&amp; computePipelineDescriptor)
289 {
290     PhaseTimes phaseTimes;
291     Metal::ComputeMetalCode generatedCode;
292     Optional&lt;ComputeDimensions&gt; computeDimensions;
293 
294     {
295         PhaseTimer phaseTimer(&quot;prepare total&quot;, phaseTimes);
296         auto program = prepareShared(phaseTimes, shaderModule.whlslSource);
297         if (!program)
298             return makeUnexpected(program.error());
299 
300         Optional&lt;MatchedComputeSemantics&gt; matchedSemantics;
301         {
302             PhaseTimer phaseTimer(&quot;matchSemantics&quot;, phaseTimes);
303             matchedSemantics = matchSemantics(*program, computePipelineDescriptor);
304             if (!matchedSemantics)
305                 return makeUnexpected(Lexer::errorString(Error(&quot;Could not match semantics&quot;_str), shaderModule.whlslSource));
306         }
307 
308         {
309             PhaseTimer phaseTimer(&quot;computeDimensions&quot;, phaseTimes);
310             computeDimensions = WHLSL::computeDimensions(*program, *matchedSemantics-&gt;shader);
311             if (!computeDimensions)
312                 return makeUnexpected(Lexer::errorString(Error(&quot;Could not match compute dimensions&quot;_str), shaderModule.whlslSource));
313         }
314 
315         {
316             PhaseTimer phaseTimer(&quot;generateMetalCode&quot;, phaseTimes);
317             generatedCode = Metal::generateMetalCode(*program, WTFMove(*matchedSemantics), computePipelineDescriptor.layout);
318         }
319     }
320 
321     logPhaseTimes(phaseTimes);
322 
323     ComputePrepareResult result;
324     result.metalSource = WTFMove(generatedCode.metalSource);
325     result.mangledEntryPointName = WTFMove(generatedCode.mangledEntryPointName);
326     result.computeDimensions = WTFMove(*computeDimensions);
327     return result;
328 }
329 
330 } // namespace WHLSL
331 
332 } // namespace WebCore
333 
334 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
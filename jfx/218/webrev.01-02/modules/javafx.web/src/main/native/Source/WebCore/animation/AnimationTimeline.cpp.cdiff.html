<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AnimationPlaybackEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationTimeline.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/AnimationTimeline.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,11 ---</span>
  #include &quot;CSSPropertyAnimation.h&quot;
  #include &quot;CSSTransition.h&quot;
  #include &quot;DocumentTimeline.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;KeyframeEffect.h&quot;
<span class="line-added">+ #include &quot;KeyframeEffectStack.h&quot;</span>
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderView.h&quot;
  #include &quot;StylePropertyShorthand.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;WebAnimationUtilities.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,25 ***</span>
      m_allAnimations.removeFirst(animation);
  }
  
  void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
  {
      if (m_animations.add(&amp;animation)) {
          m_allAnimations.append(makeWeakPtr(&amp;animation));
          auto* timeline = animation.timeline();
          if (timeline &amp;&amp; timeline != this)
              timeline-&gt;removeAnimation(animation);
      }
  }
  
  void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
  {
      ASSERT(!animation.timeline() || animation.timeline() == this);
      m_animations.remove(&amp;animation);
      if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<span class="line-modified">!         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target())</span>
              animationWasRemovedFromElement(animation, *target);
      }
  }
  
  Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
  {
<span class="line-new-header">--- 60,36 ---</span>
      m_allAnimations.removeFirst(animation);
  }
  
  void AnimationTimeline::animationTimingDidChange(WebAnimation&amp; animation)
  {
<span class="line-added">+     updateGlobalPosition(animation);</span>
<span class="line-added">+ </span>
      if (m_animations.add(&amp;animation)) {
          m_allAnimations.append(makeWeakPtr(&amp;animation));
          auto* timeline = animation.timeline();
          if (timeline &amp;&amp; timeline != this)
              timeline-&gt;removeAnimation(animation);
      }
  }
  
<span class="line-added">+ void AnimationTimeline::updateGlobalPosition(WebAnimation&amp; animation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static uint64_t s_globalPosition = 0;</span>
<span class="line-added">+     if (!animation.globalPosition() &amp;&amp; animation.canHaveGlobalPosition())</span>
<span class="line-added">+         animation.setGlobalPosition(++s_globalPosition);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void AnimationTimeline::removeAnimation(WebAnimation&amp; animation)
  {
      ASSERT(!animation.timeline() || animation.timeline() == this);
      m_animations.remove(&amp;animation);
      if (is&lt;KeyframeEffect&gt;(animation.effect())) {
<span class="line-modified">!         if (auto* target = downcast&lt;KeyframeEffect&gt;(animation.effect())-&gt;target()) {</span>
              animationWasRemovedFromElement(animation, *target);
<span class="line-added">+             target-&gt;ensureKeyframeEffectStack().removeEffect(*downcast&lt;KeyframeEffect&gt;(animation.effect()));</span>
<span class="line-added">+         }</span>
      }
  }
  
  Optional&lt;double&gt; AnimationTimeline::bindingsCurrentTime()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,11 ***</span>
              return m_elementToCSSTransitionsMap;
          if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
              return m_elementToCSSAnimationsMap;
          return m_elementToAnimationsMap;
      }().ensure(&amp;element, [] {
<span class="line-modified">!         return ListHashSet&lt;RefPtr&lt;WebAnimation&gt;&gt; { };</span>
      }).iterator-&gt;value.add(&amp;animation);
  }
  
  static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
  {
<span class="line-new-header">--- 106,11 ---</span>
              return m_elementToCSSTransitionsMap;
          if (is&lt;CSSAnimation&gt;(animation) &amp;&amp; downcast&lt;CSSAnimation&gt;(animation).owningElement())
              return m_elementToCSSAnimationsMap;
          return m_elementToAnimationsMap;
      }().ensure(&amp;element, [] {
<span class="line-modified">!         return AnimationCollection { };</span>
      }).iterator-&gt;value.add(&amp;animation);
  }
  
  static inline bool removeCSSTransitionFromMap(CSSTransition&amp; transition, Element&amp; element, HashMap&lt;Element*, AnimationTimeline::PropertyToTransitionMap&gt;&amp; map)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,86 ***</span>
  {
      removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
      removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
      removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
  
<span class="line-modified">!     // Now, if we&#39;re dealing with a declarative animation, we remove it from either the m_elementToCSSAnimationByName</span>
<span class="line-modified">!     // or the m_elementToRunningCSSTransitionByCSSPropertyID map, whichever is relevant to this type of animation.</span>
<span class="line-modified">!     if (is&lt;DeclarativeAnimation&gt;(animation))</span>
          removeDeclarativeAnimationFromListsForOwningElement(animation, element);
  }
  
  void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
  {
      ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
  
<span class="line-modified">!     if (is&lt;CSSAnimation&gt;(animation)) {</span>
<span class="line-removed">-         auto iterator = m_elementToCSSAnimationByName.find(&amp;element);</span>
<span class="line-removed">-         if (iterator != m_elementToCSSAnimationByName.end()) {</span>
<span class="line-removed">-             auto&amp; cssAnimationsByName = iterator-&gt;value;</span>
<span class="line-removed">-             auto&amp; name = downcast&lt;CSSAnimation&gt;(animation).animationName();</span>
<span class="line-removed">-             cssAnimationsByName.remove(name);</span>
<span class="line-removed">-             if (cssAnimationsByName.isEmpty())</span>
<span class="line-removed">-                 m_elementToCSSAnimationByName.remove(&amp;element);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else if (is&lt;CSSTransition&gt;(animation)) {</span>
          auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
          if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
              removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
      }
  }
  
  Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
  {
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<span class="line-modified">!     if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">!         const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>
<span class="line-modified">!         if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">!             Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; sortedCSSTransitions;</span>
<span class="line-modified">!             sortedCSSTransitions.appendRange(cssTransitions.begin(), cssTransitions.end());</span>
<span class="line-modified">!             std::sort(sortedCSSTransitions.begin(), sortedCSSTransitions.end(), [](auto&amp; lhs, auto&amp; rhs) {</span>
<span class="line-modified">!                 // Sort transitions first by their generation time, and then by transition-property.</span>
<span class="line-modified">!                 // https://drafts.csswg.org/css-transitions-2/#animation-composite-order</span>
<span class="line-modified">!                 auto* lhsTransition = downcast&lt;CSSTransition&gt;(lhs.get());</span>
<span class="line-removed">-                 auto* rhsTransition = downcast&lt;CSSTransition&gt;(rhs.get());</span>
<span class="line-removed">-                 if (lhsTransition-&gt;generationTime() != rhsTransition-&gt;generationTime())</span>
<span class="line-removed">-                     return lhsTransition-&gt;generationTime() &lt; rhsTransition-&gt;generationTime();</span>
<span class="line-removed">-                 return lhsTransition-&gt;transitionProperty().utf8() &lt; rhsTransition-&gt;transitionProperty().utf8();</span>
<span class="line-removed">-             });</span>
<span class="line-removed">-             animations.appendVector(sortedCSSTransitions);</span>
<span class="line-removed">-         } else</span>
              animations.appendRange(cssTransitions.begin(), cssTransitions.end());
      }
<span class="line-modified">!     if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">!         const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-modified">!         animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>
      }
<span class="line-modified">!     if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-modified">!         const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-modified">!         animations.appendRange(webAnimations.begin(), webAnimations.end());</span>
      }
<span class="line-removed">-     return animations;</span>
  }
  
  void AnimationTimeline::elementWasRemoved(Element&amp; element)
  {
<span class="line-modified">!     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-modified">!         animation-&gt;cancel(WebAnimation::Silently::Yes);</span>
  }
  
  void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
  {
      for (auto&amp; animation : animationsForElement(element))
          animation-&gt;remove();
  }
  
  void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
  {
      for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
          cssTransition-&gt;cancel();
<span class="line-modified">!     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element))</span>
          cssAnimation-&gt;cancel();
  }
  
  static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
  {
      if (!animation.isValidAnimation())
<span class="line-new-header">--- 147,129 ---</span>
  {
      removeAnimationFromMapForElement(animation, m_elementToCSSTransitionsMap, element);
      removeAnimationFromMapForElement(animation, m_elementToCSSAnimationsMap, element);
      removeAnimationFromMapForElement(animation, m_elementToAnimationsMap, element);
  
<span class="line-modified">!     // Now, if we&#39;re dealing with a CSS Transition, we remove it from the m_elementToRunningCSSTransitionByCSSPropertyID map.</span>
<span class="line-modified">!     // We don&#39;t need to do this for CSS Animations because their timing can be set via CSS to end, which would cause this</span>
<span class="line-modified">!     // function to be called, but they should remain associated with their owning element until this is changed via a call</span>
<span class="line-added">+     // to the JS API or changing the target element&#39;s animation-name property.</span>
<span class="line-added">+     if (is&lt;CSSTransition&gt;(animation))</span>
          removeDeclarativeAnimationFromListsForOwningElement(animation, element);
  }
  
  void AnimationTimeline::removeDeclarativeAnimationFromListsForOwningElement(WebAnimation&amp; animation, Element&amp; element)
  {
      ASSERT(is&lt;DeclarativeAnimation&gt;(animation));
  
<span class="line-modified">!     if (is&lt;CSSTransition&gt;(animation)) {</span>
          auto&amp; transition = downcast&lt;CSSTransition&gt;(animation);
          if (!removeCSSTransitionFromMap(transition, element, m_elementToRunningCSSTransitionByCSSPropertyID))
              removeCSSTransitionFromMap(transition, element, m_elementToCompletedCSSTransitionByCSSPropertyID);
      }
  }
  
  Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; AnimationTimeline::animationsForElement(Element&amp; element, Ordering ordering) const
  {
      Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; animations;
<span class="line-modified">! </span>
<span class="line-modified">!     if (ordering == Ordering::Sorted) {</span>
<span class="line-modified">!         if (element.hasKeyframeEffects()) {</span>
<span class="line-modified">!             for (auto&amp; effect : element.ensureKeyframeEffectStack().sortedEffects())</span>
<span class="line-modified">!                 animations.append(effect-&gt;animation());</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     } else {</span>
<span class="line-modified">!         if (m_elementToCSSTransitionsMap.contains(&amp;element)) {</span>
<span class="line-modified">!             const auto&amp; cssTransitions = m_elementToCSSTransitionsMap.get(&amp;element);</span>
              animations.appendRange(cssTransitions.begin(), cssTransitions.end());
<span class="line-added">+         }</span>
<span class="line-added">+         if (m_elementToCSSAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">+             const auto&amp; cssAnimations = m_elementToCSSAnimationsMap.get(&amp;element);</span>
<span class="line-added">+             animations.appendRange(cssAnimations.begin(), cssAnimations.end());</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (m_elementToAnimationsMap.contains(&amp;element)) {</span>
<span class="line-added">+             const auto&amp; webAnimations = m_elementToAnimationsMap.get(&amp;element);</span>
<span class="line-added">+             animations.appendRange(webAnimations.begin(), webAnimations.end());</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     return animations;</span>
<span class="line-modified">! }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AnimationTimeline::removeCSSAnimationCreatedByMarkup(Element&amp; element, CSSAnimation&amp; cssAnimation)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-added">+     if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-added">+         auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">+         cssAnimations.remove(&amp;cssAnimation);</span>
<span class="line-added">+         if (!cssAnimations.size())</span>
<span class="line-added">+             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
      }
<span class="line-modified">! </span>
<span class="line-modified">!     if (!element.hasKeyframeEffects())</span>
<span class="line-modified">!         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">+     auto* cssAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">+     if (!cssAnimationList || cssAnimationList-&gt;isEmpty())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; backingAnimation = cssAnimation.backingAnimation();</span>
<span class="line-added">+     for (size_t i = 0; i &lt; cssAnimationList-&gt;size(); ++i) {</span>
<span class="line-added">+         if (cssAnimationList-&gt;animation(i) == backingAnimation) {</span>
<span class="line-added">+             auto newAnimationList = cssAnimationList-&gt;copy();</span>
<span class="line-added">+             newAnimationList-&gt;remove(i);</span>
<span class="line-added">+             keyframeEffectStack.setCSSAnimationList(WTFMove(newAnimationList));</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void AnimationTimeline::willDestroyRendererForElement(Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))</span>
<span class="line-added">+         cssTransition-&gt;cancel(WebAnimation::Silently::Yes);</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">+         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">+             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
<span class="line-added">+         cssAnimation-&gt;cancel(WebAnimation::Silently::Yes);</span>
      }
  }
  
  void AnimationTimeline::elementWasRemoved(Element&amp; element)
  {
<span class="line-modified">!     willDestroyRendererForElement(element);</span>
<span class="line-modified">! </span>
<span class="line-added">+     m_elementToAnimationsMap.remove(&amp;element);</span>
<span class="line-added">+     m_elementToCSSAnimationsMap.remove(&amp;element);</span>
<span class="line-added">+     m_elementToCSSTransitionsMap.remove(&amp;element);</span>
<span class="line-added">+     m_elementToRunningCSSTransitionByCSSPropertyID.remove(&amp;element);</span>
<span class="line-added">+     m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
  }
  
  void AnimationTimeline::removeAnimationsForElement(Element&amp; element)
  {
      for (auto&amp; animation : animationsForElement(element))
          animation-&gt;remove();
  }
  
<span class="line-added">+ void AnimationTimeline::willChangeRendererForElement(Element&amp; element)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (auto&amp; animation : animationsForElement(element))</span>
<span class="line-added">+         animation-&gt;willChangeRenderer();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void AnimationTimeline::cancelDeclarativeAnimationsForElement(Element&amp; element)
  {
      for (auto&amp; cssTransition : m_elementToCSSTransitionsMap.get(&amp;element))
          cssTransition-&gt;cancel();
<span class="line-modified">!     for (auto&amp; cssAnimation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-added">+         if (is&lt;CSSAnimation&gt;(cssAnimation))</span>
<span class="line-added">+             removeCSSAnimationCreatedByMarkup(element, downcast&lt;CSSAnimation&gt;(*cssAnimation));</span>
          cssAnimation-&gt;cancel();
<span class="line-added">+     }</span>
  }
  
  static bool shouldConsiderAnimation(Element&amp; element, const Animation&amp; animation)
  {
      if (!animation.isValidAnimation())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 232,74 ***</span>
      return false;
  }
  
  void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
  {
      // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<span class="line-modified">!     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">!         if (m_elementToCSSAnimationByName.contains(&amp;element)) {</span>
<span class="line-modified">!             for (const auto&amp; cssAnimationsByNameMapItem : m_elementToCSSAnimationByName.take(&amp;element))</span>
<span class="line-modified">!                 cancelDeclarativeAnimation(*cssAnimationsByNameMapItem.value);</span>
          }
          return;
      }
  
<span class="line-modified">!     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(currentStyle-&gt;animations()) == *(afterChangeStyle.animations()))</span>
          return;
  
<span class="line-modified">!     // First, compile the list of animation names that were applied to this element up to this point.</span>
<span class="line-modified">!     HashSet&lt;String&gt; namesOfPreviousAnimations;</span>
<span class="line-modified">!     if (currentStyle &amp;&amp; currentStyle-&gt;hasAnimations()) {</span>
<span class="line-removed">-         auto* previousAnimations = currentStyle-&gt;animations();</span>
<span class="line-removed">-         for (size_t i = 0; i &lt; previousAnimations-&gt;size(); ++i) {</span>
<span class="line-removed">-             auto&amp; previousAnimation = previousAnimations-&gt;animation(i);</span>
<span class="line-removed">-             if (shouldConsiderAnimation(element, previousAnimation))</span>
<span class="line-removed">-                 namesOfPreviousAnimations.add(previousAnimation.name());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Create or get the CSSAnimations by animation name map for this element.</span>
<span class="line-removed">-     auto&amp; cssAnimationsByName = m_elementToCSSAnimationByName.ensure(&amp;element, [] {</span>
<span class="line-removed">-         return HashMap&lt;String, RefPtr&lt;CSSAnimation&gt;&gt; { };</span>
      }).iterator-&gt;value;
  
<span class="line-modified">!     if (auto* currentAnimations = afterChangeStyle.animations()) {</span>
<span class="line-modified">!         for (size_t i = 0; i &lt; currentAnimations-&gt;size(); ++i) {</span>
<span class="line-modified">!             auto&amp; currentAnimation = currentAnimations-&gt;animation(i);</span>
<span class="line-modified">!             auto&amp; name = currentAnimation.name();</span>
<span class="line-modified">!             if (namesOfPreviousAnimations.contains(name)) {</span>
<span class="line-modified">!                 // We&#39;ve found the name of this animation in our list of previous animations, this means we&#39;ve already</span>
<span class="line-modified">!                 // created a CSSAnimation object for it and need to ensure that this CSSAnimation is backed by the current</span>
<span class="line-modified">!                 // animation object for this animation name.</span>
<span class="line-modified">!                 if (auto cssAnimation = cssAnimationsByName.get(name))</span>
<span class="line-modified">!                     cssAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-modified">!             } else if (shouldConsiderAnimation(element, currentAnimation)) {</span>
<span class="line-modified">!                 // Otherwise we are dealing with a new animation name and must create a CSSAnimation for it.</span>
<span class="line-modified">!                 cssAnimationsByName.set(name, CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>
              }
<span class="line-modified">!             // Remove the name of this animation from our list since it&#39;s now known to be current.</span>
<span class="line-modified">!             namesOfPreviousAnimations.remove(name);</span>
          }
      }
  
<span class="line-modified">!     // The animations names left in namesOfPreviousAnimations are now known to no longer apply so we need to</span>
<span class="line-modified">!     // remove the CSSAnimation object created for them.</span>
<span class="line-modified">!     for (const auto&amp; nameOfAnimationToRemove : namesOfPreviousAnimations) {</span>
<span class="line-modified">!         if (auto animation = cssAnimationsByName.take(nameOfAnimationToRemove))</span>
<span class="line-modified">!             cancelDeclarativeAnimation(*animation);</span>
      }
  }
  
<span class="line-modified">! RefPtr&lt;WebAnimation&gt; AnimationTimeline::cssAnimationForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
  {
<span class="line-modified">!     RefPtr&lt;WebAnimation&gt; matchingAnimation;</span>
<span class="line-modified">!     for (const auto&amp; animation : m_elementToCSSAnimationsMap.get(&amp;element)) {</span>
<span class="line-modified">!         auto* effect = animation-&gt;effect();</span>
<span class="line-modified">!         if (is&lt;KeyframeEffect&gt;(effect) &amp;&amp; downcast&lt;KeyframeEffect&gt;(effect)-&gt;animatedProperties().contains(property))</span>
<span class="line-modified">!             matchingAnimation = animation;</span>
      }
<span class="line-modified">!     return matchingAnimation;</span>
  }
  
  static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
  {
      if (auto* transition = transitions.get(property)) {
<span class="line-new-header">--- 287,96 ---</span>
      return false;
  }
  
  void AnimationTimeline::updateCSSAnimationsForElement(Element&amp; element, const RenderStyle* currentStyle, const RenderStyle&amp; afterChangeStyle)
  {
<span class="line-added">+     auto&amp; keyframeEffectStack = element.ensureKeyframeEffectStack();</span>
<span class="line-added">+ </span>
      // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its animations and disregard new ones.
<span class="line-modified">!     if (currentStyle &amp;&amp; currentStyle-&gt;display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">!         auto iterator = m_elementToCSSAnimationsCreatedByMarkupMap.find(&amp;element);</span>
<span class="line-modified">!         if (iterator != m_elementToCSSAnimationsCreatedByMarkupMap.end()) {</span>
<span class="line-modified">!             auto&amp; cssAnimations = iterator-&gt;value;</span>
<span class="line-added">+             for (auto&amp; cssAnimation : cssAnimations)</span>
<span class="line-added">+                 cssAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">+             m_elementToCSSAnimationsCreatedByMarkupMap.remove(iterator);</span>
          }
<span class="line-added">+         keyframeEffectStack.setCSSAnimationList(nullptr);</span>
          return;
      }
  
<span class="line-modified">!     auto* currentAnimationList = afterChangeStyle.animations();</span>
<span class="line-added">+     auto* previousAnimationList = keyframeEffectStack.cssAnimationList();</span>
<span class="line-added">+     if (previousAnimationList &amp;&amp; !previousAnimationList-&gt;isEmpty() &amp;&amp; afterChangeStyle.hasAnimations() &amp;&amp; *(previousAnimationList) == *(afterChangeStyle.animations()))</span>
          return;
  
<span class="line-modified">!     CSSAnimationCollection newAnimations;</span>
<span class="line-modified">!     auto&amp; previousAnimations = m_elementToCSSAnimationsCreatedByMarkupMap.ensure(&amp;element, [] {</span>
<span class="line-modified">!         return CSSAnimationCollection { };</span>
      }).iterator-&gt;value;
  
<span class="line-modified">!     // https://www.w3.org/TR/css-animations-1/#animations</span>
<span class="line-modified">!     // The same @keyframes rule name may be repeated within an animation-name. Changes to the animation-name update existing</span>
<span class="line-modified">!     // animations by iterating over the new list of animations from last to first, and, for each animation, finding the last</span>
<span class="line-modified">!     // matching animation in the list of existing animations. If a match is found, the existing animation is updated using the</span>
<span class="line-modified">!     // animation properties corresponding to its position in the new list of animations, whilst maintaining its current playback</span>
<span class="line-modified">!     // time as described above. The matching animation is removed from the existing list of animations such that it will not match</span>
<span class="line-modified">!     // twice. If a match is not found, a new animation is created. As a result, updating animation-name from ‘a’ to ‘a, a’ will</span>
<span class="line-modified">!     // cause the existing animation for ‘a’ to become the second animation in the list and a new animation will be created for the</span>
<span class="line-modified">!     // first item in the list.</span>
<span class="line-modified">!     if (currentAnimationList) {</span>
<span class="line-modified">!         for (size_t i = currentAnimationList-&gt;size(); i &gt; 0; --i) {</span>
<span class="line-modified">!             auto&amp; currentAnimation = currentAnimationList-&gt;animation(i - 1);</span>
<span class="line-modified">!             if (!shouldConsiderAnimation(element, currentAnimation))</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+             bool foundMatchingAnimation = false;</span>
<span class="line-added">+             for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-added">+                 if (previousAnimation-&gt;animationName() == currentAnimation.name()) {</span>
<span class="line-added">+                     // Timing properties or play state may have changed so we need to update the backing animation with</span>
<span class="line-added">+                     // the Animation found in the current style.</span>
<span class="line-added">+                     previousAnimation-&gt;setBackingAnimation(currentAnimation);</span>
<span class="line-added">+                     newAnimations.add(previousAnimation);</span>
<span class="line-added">+                     // Remove the matched animation from the list of previous animations so we may not match it again.</span>
<span class="line-added">+                     previousAnimations.remove(previousAnimation);</span>
<span class="line-added">+                     foundMatchingAnimation = true;</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
              }
<span class="line-modified">! </span>
<span class="line-modified">!             if (!foundMatchingAnimation)</span>
<span class="line-added">+                 newAnimations.add(CSSAnimation::create(element, currentAnimation, currentStyle, afterChangeStyle));</span>
          }
      }
  
<span class="line-modified">!     // Any animation found in previousAnimations but not found in newAnimations is not longer current and should be canceled.</span>
<span class="line-modified">!     for (auto&amp; previousAnimation : previousAnimations) {</span>
<span class="line-modified">!         if (!newAnimations.contains(previousAnimation)) {</span>
<span class="line-modified">!             if (previousAnimation-&gt;owningElement())</span>
<span class="line-modified">!                 previousAnimation-&gt;cancelFromStyle();</span>
<span class="line-added">+         }</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+     if (newAnimations.isEmpty())</span>
<span class="line-added">+         m_elementToCSSAnimationsCreatedByMarkupMap.remove(&amp;element);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         m_elementToCSSAnimationsCreatedByMarkupMap.set(&amp;element, WTFMove(newAnimations));</span>
<span class="line-added">+ </span>
<span class="line-added">+     keyframeEffectStack.setCSSAnimationList(currentAnimationList);</span>
  }
  
<span class="line-modified">! static KeyframeEffect* keyframeEffectForElementAndProperty(Element&amp; element, CSSPropertyID property)</span>
  {
<span class="line-modified">!     if (auto* keyframeEffectStack = element.keyframeEffectStack()) {</span>
<span class="line-modified">!         auto effects = keyframeEffectStack-&gt;sortedEffects();</span>
<span class="line-modified">!         for (const auto&amp; effect : makeReversedRange(effects)) {</span>
<span class="line-modified">!             if (effect-&gt;animatesProperty(property))</span>
<span class="line-modified">!                 return effect.get();</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     return nullptr;</span>
  }
  
  static bool propertyInStyleMatchesValueForTransitionInMap(CSSPropertyID property, const RenderStyle&amp; style, AnimationTimeline::PropertyToTransitionMap&amp; transitions)
  {
      if (auto* transition = transitions.get(property)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,161 ***</span>
      return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
          return PropertyToTransitionMap { };
      }).iterator-&gt;value;
  }
  
<span class="line-modified">! void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
  {
<span class="line-modified">!     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-removed">-     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-removed">-         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-removed">-             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-removed">-                 cancelDeclarativeAnimation(*cssTransitionsByCSSPropertyIDMapItem.value);</span>
<span class="line-removed">-         }</span>
          return;
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-removed">-     // https://drafts.csswg.org/css-transitions-1/#starting</span>
  
<span class="line-modified">!     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>
  
<span class="line-modified">!     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">!         return PropertyToTransitionMap { };</span>
<span class="line-modified">!     }).iterator-&gt;value;</span>
  
<span class="line-modified">!     auto generationTime = MonotonicTime::now();</span>
  
<span class="line-modified">!     auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">!     for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">!         Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">!         auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">!         if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">!             continue;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-modified">!         if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-modified">!             for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">!                 auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-modified">!                 if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-modified">!                     matchingBackingAnimation = &amp;backingAnimation;</span>
              }
          }
  
<span class="line-modified">!         // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">!         // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">!         // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">!         auto existingAnimation = cssAnimationForElementAndProperty(element, property);</span>
<span class="line-modified">!         const auto&amp; beforeChangeStyle = existingAnimation ? downcast&lt;CSSAnimation&gt;(existingAnimation.get())-&gt;unanimatedStyle() : currentStyle;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (!runningTransitionsByProperty.contains(property)</span>
<span class="line-modified">!             &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">!             &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-modified">!             &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-modified">!             &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-modified">!             // 1. If all of the following are true:</span>
<span class="line-modified">!             //   - the element does not have a running transition for the property,</span>
<span class="line-modified">!             //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-modified">!             //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-modified">!             //   - there is a matching transition-property value, and</span>
<span class="line-modified">!             //   - the combined duration is greater than 0s,</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // then implementations must remove the completed transition (if present) from the set of completed transitions</span>
              completedTransitionsByProperty.remove(property);
  
<span class="line-modified">!             // and start a transition whose:</span>
              //   - start time is the time of the style change event plus the matching transition delay,
              //   - end time is the start time plus the matching transition duration,
<span class="line-modified">!             //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-modified">!             //   - end value is the value of the transitioning property in the after-change style,</span>
              //   - reversing-adjusted start value is the same as the start value, and
              //   - reversing shortening factor is 1.
              auto delay = Seconds(matchingBackingAnimation-&gt;delay());
              auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<span class="line-modified">!             auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
              auto reversingShorteningFactor = 1;
<span class="line-modified">!             runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">-         } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-removed">-             // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-removed">-             //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-removed">-             completedTransitionsByProperty.remove(property);</span>
          }
  
<span class="line-modified">!         bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">!         if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-modified">!             // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-modified">!             //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-modified">!             if (hasRunningTransition)</span>
<span class="line-modified">!                 runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-modified">!             else</span>
<span class="line-removed">-                 completedTransitionsByProperty.remove(property);</span>
          }
  
<span class="line-modified">!         if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-modified">!             auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-modified">!             auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-modified">!             // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-modified">!             //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-modified">!             if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">!                 // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-modified">!                 //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-modified">!                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">!             } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-modified">!                 // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-modified">!                 //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-modified">!                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">!             } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-modified">!                 // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-modified">!                 //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-modified">!                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 // and start a new transition whose:</span>
<span class="line-modified">!                 //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-modified">!                 //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-modified">!                 //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-modified">!                 //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-modified">!                 //   - start time is the time of the style change event plus:</span>
<span class="line-modified">!                 //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-removed">-                 //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-removed">-                 //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-removed">-                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">-                 //   - end value is the value of the property in the after-change style</span>
<span class="line-removed">-                 auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-removed">-                 double transformedProgress = 1;</span>
<span class="line-removed">-                 if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-removed">-                     if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-removed">-                         transformedProgress = *computedTimingProgress;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-                 auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-removed">-                 auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">-                 auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">-             } else {</span>
<span class="line-removed">-                 // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-removed">-                 cancelDeclarativeAnimation(*previouslyRunningTransition);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // and start a new transition whose:</span>
<span class="line-removed">-                 //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-removed">-                 //   - end time is the start time plus the matching transition duration,</span>
<span class="line-removed">-                 //   - start value is the current value of the property in the running transition,</span>
<span class="line-removed">-                 //   - end value is the value of the property in the after-change style,</span>
<span class="line-removed">-                 //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-removed">-                 //   - reversing shortening factor is 1.</span>
<span class="line-removed">-                 auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-removed">-                 auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-removed">-                 auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
<span class="line-removed">-                 auto reversingShorteningFactor = 1;</span>
<span class="line-removed">-                 ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-removed">-             }</span>
          }
      }
<span class="line-removed">- }</span>
  
<span class="line-modified">! void AnimationTimeline::cancelDeclarativeAnimation(DeclarativeAnimation&amp; animation)</span>
<span class="line-modified">! {</span>
<span class="line-removed">-     animation.cancelFromStyle();</span>
<span class="line-removed">-     removeAnimation(animation);</span>
<span class="line-removed">-     m_allAnimations.removeFirst(&amp;animation);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 415,228 ---</span>
      return m_elementToRunningCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {
          return PropertyToTransitionMap { };
      }).iterator-&gt;value;
  }
  
<span class="line-modified">! static void compileTransitionPropertiesInStyle(const RenderStyle&amp; style, HashSet&lt;CSSPropertyID&gt;&amp; transitionProperties, bool&amp; transitionPropertiesContainAll)</span>
  {
<span class="line-modified">!     if (transitionPropertiesContainAll)</span>
          return;
  
<span class="line-modified">!     auto* transitions = style.transitions();</span>
<span class="line-added">+     if (!transitions)</span>
<span class="line-added">+         return;</span>
  
<span class="line-modified">!     for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-modified">!         const auto&amp; animation = transitions-&gt;animation(i);</span>
<span class="line-modified">!         auto mode = animation.animationMode();</span>
<span class="line-added">+         if (mode == Animation::AnimateSingleProperty) {</span>
<span class="line-added">+             auto property = animation.property();</span>
<span class="line-added">+             if (isShorthandCSSProperty(property)) {</span>
<span class="line-added">+                 auto shorthand = shorthandForProperty(property);</span>
<span class="line-added">+                 for (size_t j = 0; j &lt; shorthand.length(); ++j)</span>
<span class="line-added">+                     transitionProperties.add(shorthand.properties()[j]);</span>
<span class="line-added">+             } else if (property != CSSPropertyInvalid)</span>
<span class="line-added">+                 transitionProperties.add(property);</span>
<span class="line-added">+         } else if (mode == Animation::AnimateAll) {</span>
<span class="line-added">+             transitionPropertiesContainAll = true;</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void AnimationTimeline::updateCSSTransitionsForElementAndProperty(Element&amp; element, CSSPropertyID property, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle, AnimationTimeline::PropertyToTransitionMap&amp; runningTransitionsByProperty, PropertyToTransitionMap&amp; completedTransitionsByProperty, const MonotonicTime generationTime)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     const Animation* matchingBackingAnimation = nullptr;</span>
<span class="line-added">+     if (auto* transitions = afterChangeStyle.transitions()) {</span>
<span class="line-added">+         for (size_t i = 0; i &lt; transitions-&gt;size(); ++i) {</span>
<span class="line-added">+             auto&amp; backingAnimation = transitions-&gt;animation(i);</span>
<span class="line-added">+             if (transitionMatchesProperty(backingAnimation, property))</span>
<span class="line-added">+                 matchingBackingAnimation = &amp;backingAnimation;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     // https://drafts.csswg.org/css-transitions-1/#before-change-style</span>
<span class="line-modified">!     // Define the before-change style as the computed values of all properties on the element as of the previous style change event, except with</span>
<span class="line-modified">!     // any styles derived from declarative animations such as CSS Transitions, CSS Animations, and SMIL Animations updated to the current time.</span>
<span class="line-modified">!     bool hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-modified">!     auto beforeChangeStyle = [&amp;]() {</span>
<span class="line-modified">!         if (hasRunningTransition &amp;&amp; CSSPropertyAnimation::animationOfPropertyIsAccelerated(property)) {</span>
<span class="line-modified">!             // In case we have an accelerated transition running for this element, we need to get its computed style as the before-change style</span>
<span class="line-modified">!             // since otherwise the animated value for that property won&#39;t be visible.</span>
<span class="line-modified">!             auto* runningTransition = runningTransitionsByProperty.get(property);</span>
<span class="line-modified">!             if (is&lt;KeyframeEffect&gt;(runningTransition-&gt;effect())) {</span>
<span class="line-modified">!                 auto&amp; keyframeEffect = *downcast&lt;KeyframeEffect&gt;(runningTransition-&gt;effect());</span>
<span class="line-modified">!                 if (keyframeEffect.isRunningAccelerated()) {</span>
<span class="line-modified">!                     auto animatedStyle = RenderStyle::clone(currentStyle);</span>
<span class="line-added">+                     runningTransition-&gt;resolve(animatedStyle);</span>
<span class="line-added">+                     return animatedStyle;</span>
<span class="line-added">+                 }</span>
              }
          }
  
<span class="line-modified">!         if (auto* keyframeEffect = keyframeEffectForElementAndProperty(element, property)) {</span>
<span class="line-modified">!             // If we already have a keyframe effect targeting this property, we should use its unanimated style to determine what the potential</span>
<span class="line-modified">!             // start value of the transition shoud be to make sure that we don&#39;t account for animated values that would have been blended onto</span>
<span class="line-modified">!             // the style applied during the last style resolution.</span>
<span class="line-modified">!             if (auto* unanimatedStyle = keyframeEffect-&gt;unanimatedStyle())</span>
<span class="line-modified">!                 return RenderStyle::clone(*unanimatedStyle);</span>
<span class="line-modified">! </span>
<span class="line-modified">!             // If we have a keyframe effect targeting this property, but it doesn&#39;t yet have an unanimated style, this is because it has not</span>
<span class="line-modified">!             // had a chance to apply itself with a non-null progress. In this case, the before-change and after-change styles should be the</span>
<span class="line-modified">!             // same in order to prevent a transition from being triggered as the unanimated style for this keyframe effect will most likely</span>
<span class="line-modified">!             // be this after-change style, or any future style change that may happen before the keyframe effect starts blending animated values.</span>
<span class="line-modified">!             return RenderStyle::clone(afterChangeStyle);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // In any other scenario, the before-change style should be the previously resolved style for this element.</span>
<span class="line-modified">!         return RenderStyle::clone(currentStyle);</span>
<span class="line-modified">!     }();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!hasRunningTransition</span>
<span class="line-added">+         &amp;&amp; !CSSPropertyAnimation::propertiesEqual(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">+         &amp;&amp; CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;beforeChangeStyle, &amp;afterChangeStyle)</span>
<span class="line-added">+         &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)</span>
<span class="line-added">+         &amp;&amp; matchingBackingAnimation &amp;&amp; transitionCombinedDuration(matchingBackingAnimation) &gt; 0) {</span>
<span class="line-added">+         // 1. If all of the following are true:</span>
<span class="line-added">+         //   - the element does not have a running transition for the property,</span>
<span class="line-added">+         //   - the before-change style is different from and can be interpolated with the after-change style for that property,</span>
<span class="line-added">+         //   - the element does not have a completed transition for the property or the end value of the completed transition is different from the after-change style for the property,</span>
<span class="line-added">+         //   - there is a matching transition-property value, and</span>
<span class="line-added">+         //   - the combined duration is greater than 0s,</span>
<span class="line-added">+ </span>
<span class="line-added">+         // then implementations must remove the completed transition (if present) from the set of completed transitions</span>
<span class="line-added">+         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // and start a transition whose:</span>
<span class="line-added">+         //   - start time is the time of the style change event plus the matching transition delay,</span>
<span class="line-added">+         //   - end time is the start time plus the matching transition duration,</span>
<span class="line-added">+         //   - start value is the value of the transitioning property in the before-change style,</span>
<span class="line-added">+         //   - end value is the value of the transitioning property in the after-change style,</span>
<span class="line-added">+         //   - reversing-adjusted start value is the same as the start value, and</span>
<span class="line-added">+         //   - reversing shortening factor is 1.</span>
<span class="line-added">+         auto delay = Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">+         auto duration = Seconds(matchingBackingAnimation-&gt;duration());</span>
<span class="line-added">+         auto&amp; reversingAdjustedStartStyle = beforeChangeStyle;</span>
<span class="line-added">+         auto reversingShorteningFactor = 1;</span>
<span class="line-added">+         runningTransitionsByProperty.set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;beforeChangeStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">+     } else if (completedTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, completedTransitionsByProperty)) {</span>
<span class="line-added">+         // 2. Otherwise, if the element has a completed transition for the property and the end value of the completed transition is different from</span>
<span class="line-added">+         //    the after-change style for the property, then implementations must remove the completed transition from the set of completed transitions.</span>
<span class="line-added">+         completedTransitionsByProperty.remove(property);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     hasRunningTransition = runningTransitionsByProperty.contains(property);</span>
<span class="line-added">+     if ((hasRunningTransition || completedTransitionsByProperty.contains(property)) &amp;&amp; !matchingBackingAnimation) {</span>
<span class="line-added">+         // 3. If the element has a running transition or completed transition for the property, and there is not a matching transition-property</span>
<span class="line-added">+         //    value, then implementations must cancel the running transition or remove the completed transition from the set of completed transitions.</span>
<span class="line-added">+         if (hasRunningTransition)</span>
<span class="line-added">+             runningTransitionsByProperty.take(property)-&gt;cancel();</span>
<span class="line-added">+         else</span>
              completedTransitionsByProperty.remove(property);
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (matchingBackingAnimation &amp;&amp; runningTransitionsByProperty.contains(property) &amp;&amp; !propertyInStyleMatchesValueForTransitionInMap(property, afterChangeStyle, runningTransitionsByProperty)) {</span>
<span class="line-added">+         auto previouslyRunningTransition = runningTransitionsByProperty.take(property);</span>
<span class="line-added">+         auto&amp; previouslyRunningTransitionCurrentStyle = previouslyRunningTransition-&gt;currentStyle();</span>
<span class="line-added">+         // 4. If the element has a running transition for the property, there is a matching transition-property value, and the end value of the running</span>
<span class="line-added">+         //    transition is not equal to the value of the property in the after-change style, then:</span>
<span class="line-added">+         if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle) || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;currentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">+             // 1. If the current value of the property in the running transition is equal to the value of the property in the after-change style,</span>
<span class="line-added">+             //    or if these two values cannot be interpolated, then implementations must cancel the running transition.</span>
<span class="line-added">+             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">+         } else if (transitionCombinedDuration(matchingBackingAnimation) &lt;= 0.0 || !CSSPropertyAnimation::canPropertyBeInterpolated(property, &amp;previouslyRunningTransitionCurrentStyle, &amp;afterChangeStyle)) {</span>
<span class="line-added">+             // 2. Otherwise, if the combined duration is less than or equal to 0s, or if the current value of the property in the running transition</span>
<span class="line-added">+             //    cannot be interpolated with the value of the property in the after-change style, then implementations must cancel the running transition.</span>
<span class="line-added">+             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">+         } else if (CSSPropertyAnimation::propertiesEqual(property, &amp;previouslyRunningTransition-&gt;reversingAdjustedStartStyle(), &amp;afterChangeStyle)) {</span>
<span class="line-added">+             // 3. Otherwise, if the reversing-adjusted start value of the running transition is the same as the value of the property in the after-change</span>
<span class="line-added">+             //    style (see the section on reversing of transitions for why these case exists), implementations must cancel the running transition</span>
<span class="line-added">+             previouslyRunningTransition-&gt;cancelFromStyle();</span>
<span class="line-added">+ </span>
<span class="line-added">+             // and start a new transition whose:</span>
<span class="line-added">+             //   - reversing-adjusted start value is the end value of the running transition,</span>
<span class="line-added">+             //   - reversing shortening factor is the absolute value, clamped to the range [0, 1], of the sum of:</span>
<span class="line-added">+             //       1. the output of the timing function of the old transition at the time of the style change event, times the reversing shortening factor of the old transition</span>
<span class="line-added">+             //       2. 1 minus the reversing shortening factor of the old transition.</span>
<span class="line-added">+             //   - start time is the time of the style change event plus:</span>
<span class="line-added">+             //       1. if the matching transition delay is nonnegative, the matching transition delay, or</span>
<span class="line-added">+             //       2. if the matching transition delay is negative, the product of the new transition’s reversing shortening factor and the matching transition delay,</span>
<span class="line-added">+             //   - end time is the start time plus the product of the matching transition duration and the new transition’s reversing shortening factor,</span>
<span class="line-added">+             //   - start value is the current value of the property in the running transition,</span>
<span class="line-added">+             //   - end value is the value of the property in the after-change style</span>
<span class="line-added">+             auto&amp; reversingAdjustedStartStyle = previouslyRunningTransition-&gt;targetStyle();</span>
<span class="line-added">+             double transformedProgress = 1;</span>
<span class="line-added">+             if (auto* effect = previouslyRunningTransition-&gt;effect()) {</span>
<span class="line-added">+                 if (auto computedTimingProgress = effect-&gt;getComputedTiming().progress)</span>
<span class="line-added">+                     transformedProgress = *computedTimingProgress;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             auto reversingShorteningFactor = std::max(std::min(((transformedProgress * previouslyRunningTransition-&gt;reversingShorteningFactor()) + (1 - previouslyRunningTransition-&gt;reversingShorteningFactor())), 1.0), 0.0);</span>
<span class="line-added">+             auto delay = matchingBackingAnimation-&gt;delay() &lt; 0 ? Seconds(matchingBackingAnimation-&gt;delay()) * reversingShorteningFactor : Seconds(matchingBackingAnimation-&gt;delay());</span>
<span class="line-added">+             auto duration = Seconds(matchingBackingAnimation-&gt;duration()) * reversingShorteningFactor;</span>
<span class="line-added">+ </span>
<span class="line-added">+             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             // 4. Otherwise, implementations must cancel the running transition</span>
<span class="line-added">+             previouslyRunningTransition-&gt;cancelFromStyle();</span>
  
<span class="line-modified">!             // and start a new transition whose:</span>
              //   - start time is the time of the style change event plus the matching transition delay,
              //   - end time is the start time plus the matching transition duration,
<span class="line-modified">!             //   - start value is the current value of the property in the running transition,</span>
<span class="line-modified">!             //   - end value is the value of the property in the after-change style,</span>
              //   - reversing-adjusted start value is the same as the start value, and
              //   - reversing shortening factor is 1.
              auto delay = Seconds(matchingBackingAnimation-&gt;delay());
              auto duration = Seconds(matchingBackingAnimation-&gt;duration());
<span class="line-modified">!             auto&amp; reversingAdjustedStartStyle = currentStyle;</span>
              auto reversingShorteningFactor = 1;
<span class="line-modified">!             ensureRunningTransitionsByProperty(element).set(property, CSSTransition::create(element, property, generationTime, *matchingBackingAnimation, &amp;previouslyRunningTransitionCurrentStyle, afterChangeStyle, delay, duration, reversingAdjustedStartStyle, reversingShorteningFactor));</span>
          }
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void AnimationTimeline::updateCSSTransitionsForElement(Element&amp; element, const RenderStyle&amp; currentStyle, const RenderStyle&amp; afterChangeStyle)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     // In case this element is newly getting a &quot;display: none&quot; we need to cancel all of its transitions and disregard new ones.</span>
<span class="line-modified">!     if (currentStyle.hasTransitions() &amp;&amp; currentStyle.display() != DisplayType::None &amp;&amp; afterChangeStyle.display() == DisplayType::None) {</span>
<span class="line-modified">!         if (m_elementToRunningCSSTransitionByCSSPropertyID.contains(&amp;element)) {</span>
<span class="line-modified">!             for (const auto&amp; cssTransitionsByCSSPropertyIDMapItem : m_elementToRunningCSSTransitionByCSSPropertyID.take(&amp;element))</span>
<span class="line-modified">!                 cssTransitionsByCSSPropertyIDMapItem.value-&gt;cancelFromStyle();</span>
          }
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     // Section 3 &quot;Starting of transitions&quot; from the CSS Transitions Level 1 specification.</span>
<span class="line-modified">!     // https://drafts.csswg.org/css-transitions-1/#starting</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto&amp; runningTransitionsByProperty = ensureRunningTransitionsByProperty(element);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto&amp; completedTransitionsByProperty = m_elementToCompletedCSSTransitionByCSSPropertyID.ensure(&amp;element, [] {</span>
<span class="line-modified">!         return PropertyToTransitionMap { };</span>
<span class="line-modified">!     }).iterator-&gt;value;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     auto generationTime = MonotonicTime::now();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     // First, let&#39;s compile the list of all CSS properties found in the current style and the after-change style.</span>
<span class="line-modified">!     bool transitionPropertiesContainAll = false;</span>
<span class="line-modified">!     HashSet&lt;CSSPropertyID&gt; transitionProperties;</span>
<span class="line-modified">!     compileTransitionPropertiesInStyle(currentStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">!     compileTransitionPropertiesInStyle(afterChangeStyle, transitionProperties, transitionPropertiesContainAll);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (transitionPropertiesContainAll) {</span>
<span class="line-modified">!         auto numberOfProperties = CSSPropertyAnimation::getNumProperties();</span>
<span class="line-modified">!         for (int propertyIndex = 0; propertyIndex &lt; numberOfProperties; ++propertyIndex) {</span>
<span class="line-modified">!             Optional&lt;bool&gt; isShorthand;</span>
<span class="line-modified">!             auto property = CSSPropertyAnimation::getPropertyAtIndex(propertyIndex, isShorthand);</span>
<span class="line-modified">!             if (isShorthand &amp;&amp; *isShorthand)</span>
<span class="line-modified">!                 continue;</span>
<span class="line-modified">!             updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>
          }
<span class="line-added">+         return;</span>
      }
  
<span class="line-modified">!     for (auto property : transitionProperties)</span>
<span class="line-modified">!         updateCSSTransitionsForElementAndProperty(element, property, currentStyle, afterChangeStyle, runningTransitionsByProperty, completedTransitionsByProperty, generationTime);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="AnimationPlaybackEvent.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AnimationTimeline.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
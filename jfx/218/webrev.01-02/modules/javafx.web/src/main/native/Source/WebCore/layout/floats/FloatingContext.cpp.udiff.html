<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FloatBox.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/floats/FloatingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -32,11 +32,10 @@</span>
  #include &quot;FloatAvoider.h&quot;
  #include &quot;FloatBox.h&quot;
  #include &quot;FormattingContext.h&quot;
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
<span class="udiff-line-removed">- #include &quot;LayoutState.h&quot;</span>
  #include &lt;wtf/IsoMallocInlines.h&gt;
  
  namespace WebCore {
  namespace Layout {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -116,11 +115,11 @@</span>
  static Iterator end(const FloatingState::FloatList&amp; floats)
  {
      return Iterator(floats, { });
  }
  
<span class="udiff-line-modified-removed">- #ifndef NDEBUG</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  static bool areFloatsHorizontallySorted(const FloatingState&amp; floatingState)
  {
      auto&amp; floats = floatingState.floats();
      auto rightEdgeOfLeftFloats = LayoutUnit::min();
      auto leftEdgeOfRightFloats = LayoutUnit::max();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,39 +147,52 @@</span>
      }
      return true;
  }
  #endif
  
<span class="udiff-line-modified-removed">- FloatingContext::FloatingContext(FloatingState&amp; floatingState)</span>
<span class="udiff-line-modified-removed">-     : m_floatingState(floatingState)</span>
<span class="udiff-line-modified-added">+ struct FloatingContext::AbsoluteCoordinateValuesForFloatAvoider {</span>
<span class="udiff-line-modified-added">+     Display::Box displayBox;</span>
<span class="udiff-line-added">+     LayoutPoint containingBlockTopLeft;</span>
<span class="udiff-line-added">+     HorizontalEdges containingBlockContentBox;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ FloatingContext::FloatingContext(const Container&amp; floatingContextRoot, const FormattingContext&amp; formattingContext, FloatingState&amp; floatingState)</span>
<span class="udiff-line-added">+     : m_root(makeWeakPtr(floatingContextRoot))</span>
<span class="udiff-line-added">+     , m_formattingContext(formattingContext)</span>
<span class="udiff-line-added">+     , m_floatingState(floatingState)</span>
  {
  }
  
  Point FloatingContext::positionForFloat(const Box&amp; layoutBox) const
  {
      ASSERT(layoutBox.isFloatingPositioned());
      ASSERT(areFloatsHorizontallySorted(m_floatingState));
  
<span class="udiff-line-modified-removed">-     if (m_floatingState.isEmpty()) {</span>
<span class="udiff-line-modified-removed">-         auto&amp; displayBox = layoutState().displayBoxForLayoutBox(layoutBox);</span>
<span class="udiff-line-modified-added">+     if (isEmpty()) {</span>
<span class="udiff-line-modified-added">+         auto&amp; boxGeometry = formattingContext().geometryForBox(layoutBox);</span>
  
          auto alignWithContainingBlock = [&amp;]() -&gt; Position {
              // If there is no floating to align with, push the box to the left/right edge of its containing block&#39;s content box.
<span class="udiff-line-modified-removed">-             auto&amp; containingBlockDisplayBox = layoutState().displayBoxForLayoutBox(*layoutBox.containingBlock());</span>
<span class="udiff-line-modified-added">+             auto&amp; containingBlockGeometry = formattingContext().geometryForBox(*layoutBox.containingBlock());</span>
  
              if (layoutBox.isLeftFloatingPositioned())
<span class="udiff-line-modified-removed">-                 return Position { containingBlockDisplayBox.contentBoxLeft() + displayBox.marginStart() };</span>
<span class="udiff-line-modified-added">+                 return Position { containingBlockGeometry.contentBoxLeft() + boxGeometry.marginStart() };</span>
  
<span class="udiff-line-modified-removed">-             return Position { containingBlockDisplayBox.contentBoxRight() - displayBox.marginEnd() - displayBox.width() };</span>
<span class="udiff-line-modified-added">+             return Position { containingBlockGeometry.contentBoxRight() - boxGeometry.marginEnd() - boxGeometry.width() };</span>
          };
  
          // No float box on the context yet -&gt; align it with the containing block&#39;s left/right edge.
<span class="udiff-line-modified-removed">-         return { alignWithContainingBlock(), displayBox.top() };</span>
<span class="udiff-line-modified-added">+         return { alignWithContainingBlock(), boxGeometry.top() };</span>
      }
  
      // Find the top most position where the float box fits.
<span class="udiff-line-modified-removed">-     FloatBox floatBox = { layoutBox, m_floatingState, layoutState() };</span>
<span class="udiff-line-modified-added">+     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Optional&lt;LayoutUnit&gt; previousFloatAbsoluteTop;</span>
<span class="udiff-line-added">+     if (!isEmpty())</span>
<span class="udiff-line-added">+         previousFloatAbsoluteTop = floatingState().floats().last().rectWithMargin().top();</span>
<span class="udiff-line-added">+     auto floatBox = FloatBox { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox, previousFloatAbsoluteTop };</span>
      findPositionForFloatBox(floatBox);
      return floatBox.rectInContainingBlock().topLeft();
  }
  
  Optional&lt;Point&gt; FloatingContext::positionForFormattingContextRoot(const Box&amp; layoutBox) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -188,25 +200,26 @@</span>
      ASSERT(layoutBox.establishesBlockFormattingContext());
      ASSERT(!layoutBox.isFloatingPositioned());
      ASSERT(!layoutBox.hasFloatClear());
      ASSERT(areFloatsHorizontallySorted(m_floatingState));
  
<span class="udiff-line-modified-removed">-     if (m_floatingState.isEmpty())</span>
<span class="udiff-line-modified-added">+     if (isEmpty())</span>
          return { };
  
<span class="udiff-line-modified-removed">-     FloatAvoider floatAvoider = { layoutBox, m_floatingState, layoutState() };</span>
<span class="udiff-line-modified-added">+     auto absoluteDisplayBoxCoordinates = this-&gt;absoluteDisplayBoxCoordinates(layoutBox);</span>
<span class="udiff-line-added">+     auto floatAvoider = FloatAvoider { layoutBox, absoluteDisplayBoxCoordinates.displayBox, absoluteDisplayBoxCoordinates.containingBlockTopLeft, absoluteDisplayBoxCoordinates.containingBlockContentBox };</span>
      findPositionForFormattingContextRoot(floatAvoider);
      return { floatAvoider.rectInContainingBlock().topLeft() };
  }
  
  FloatingContext::ClearancePosition FloatingContext::verticalPositionWithClearance(const Box&amp; layoutBox) const
  {
      ASSERT(layoutBox.hasFloatClear());
      ASSERT(layoutBox.isBlockLevelBox());
      ASSERT(areFloatsHorizontallySorted(m_floatingState));
  
<span class="udiff-line-modified-removed">-     if (m_floatingState.isEmpty())</span>
<span class="udiff-line-modified-added">+     if (isEmpty())</span>
          return { };
  
      auto bottom = [&amp;](Optional&lt;PositionInContextRoot&gt; floatBottom) -&gt; ClearancePosition {
          // &#39;bottom&#39; is in the formatting root&#39;s coordinate system.
          if (!floatBottom)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,22 +228,21 @@</span>
          // 9.5.2 Controlling flow next to floats: the &#39;clear&#39; property
          // Then the amount of clearance is set to the greater of:
          //
          // 1. The amount necessary to place the border edge of the block even with the bottom outer edge of the lowest float that is to be cleared.
          // 2. The amount necessary to place the top border edge of the block at its hypothetical position.
<span class="udiff-line-modified-removed">-         auto&amp; layoutState = this-&gt;layoutState();</span>
<span class="udiff-line-removed">-         auto rootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, layoutBox, downcast&lt;Container&gt;(m_floatingState.root()));</span>
<span class="udiff-line-modified-added">+         auto rootRelativeTop = mapTopToFloatingStateRoot(layoutBox);</span>
          auto clearance = *floatBottom - rootRelativeTop;
          if (clearance &lt;= 0)
              return { };
  
          // Clearance inhibits margin collapsing.
          if (auto* previousInFlowSibling = layoutBox.previousInFlowSibling()) {
              // Does this box with clearance actually collapse its margin before with the previous inflow box&#39;s margin after?
<span class="udiff-line-modified-removed">-             auto verticalMargin = layoutState.displayBoxForLayoutBox(layoutBox).verticalMargin();</span>
<span class="udiff-line-modified-added">+             auto verticalMargin = formattingContext().geometryForBox(layoutBox).verticalMargin();</span>
              if (verticalMargin.hasCollapsedValues() &amp;&amp; verticalMargin.collapsedValues().before) {
<span class="udiff-line-modified-removed">-                 auto previousVerticalMargin = layoutState.displayBoxForLayoutBox(*previousInFlowSibling).verticalMargin();</span>
<span class="udiff-line-modified-added">+                 auto previousVerticalMargin = formattingContext().geometryForBox(*previousInFlowSibling).verticalMargin();</span>
                  auto collapsedMargin = *verticalMargin.collapsedValues().before;
                  auto nonCollapsedMargin = previousVerticalMargin.after() + verticalMargin.before();
                  auto marginDifference = nonCollapsedMargin - collapsedMargin;
                  // Move the box to the position where it would be with non-collapsed margins.
                  rootRelativeTop += marginDifference;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -244,30 +256,85 @@</span>
  
          // The return vertical position is in the containing block&#39;s coordinate system. Convert it to the formatting root&#39;s coordinate system if needed.
          if (layoutBox.containingBlock() == &amp;m_floatingState.root())
              return { Position { rootRelativeTop }, clearance };
  
<span class="udiff-line-modified-removed">-         auto containingBlockRootRelativeTop = FormattingContext::mapTopToAncestor(layoutState, *layoutBox.containingBlock(), downcast&lt;Container&gt;(m_floatingState.root()));</span>
<span class="udiff-line-modified-added">+         auto containingBlockRootRelativeTop = mapTopToFloatingStateRoot(*layoutBox.containingBlock());</span>
          return { Position { rootRelativeTop - containingBlockRootRelativeTop }, clearance };
      };
  
      auto clear = layoutBox.style().clear();
<span class="udiff-line-removed">-     auto&amp; formattingContextRoot = layoutBox.formattingContextRoot();</span>
<span class="udiff-line-removed">- </span>
      if (clear == Clear::Left)
<span class="udiff-line-modified-removed">-         return bottom(m_floatingState.leftBottom(formattingContextRoot));</span>
<span class="udiff-line-modified-added">+         return bottom(m_floatingState.leftBottom(root()));</span>
  
      if (clear == Clear::Right)
<span class="udiff-line-modified-removed">-         return bottom(m_floatingState.rightBottom(formattingContextRoot));</span>
<span class="udiff-line-modified-added">+         return bottom(m_floatingState.rightBottom(root()));</span>
  
      if (clear == Clear::Both)
<span class="udiff-line-modified-removed">-         return bottom(m_floatingState.bottom(formattingContextRoot));</span>
<span class="udiff-line-modified-added">+         return bottom(m_floatingState.bottom(root()));</span>
  
      ASSERT_NOT_REACHED();
      return { };
  }
  
<span class="udiff-line-added">+ FloatingContext::Constraints FloatingContext::constraints(LayoutUnit logicalTop, LayoutUnit logicalBottom) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (isEmpty())</span>
<span class="udiff-line-added">+         return { };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // 1. Convert vertical position if this floating context is inherited.</span>
<span class="udiff-line-added">+     // 2. Find the inner left/right floats at logicalTop/logicalBottom.</span>
<span class="udiff-line-added">+     // 3. Convert left/right positions back to formattingContextRoot&#39;s cooridnate system.</span>
<span class="udiff-line-added">+     auto coordinateMappingIsRequired = &amp;floatingState().root() != &amp;root();</span>
<span class="udiff-line-added">+     auto adjustedLogicalTop = logicalTop;</span>
<span class="udiff-line-added">+     LayoutSize adjustingDelta;</span>
<span class="udiff-line-added">+     if (coordinateMappingIsRequired) {</span>
<span class="udiff-line-added">+         auto adjustedPosition = mapPointFromFormattingContextRootToFloatingStateRoot({ 0, logicalTop });</span>
<span class="udiff-line-added">+         adjustedLogicalTop = adjustedPosition.y;</span>
<span class="udiff-line-added">+         adjustingDelta = { adjustedPosition.x, adjustedLogicalTop - logicalTop };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     auto adjustedLogicalBottom = adjustedLogicalTop + (logicalBottom - logicalTop);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Constraints constraints;</span>
<span class="udiff-line-added">+     auto&amp; floats = floatingState().floats();</span>
<span class="udiff-line-added">+     for (auto index = floats.size(); index--;) {</span>
<span class="udiff-line-added">+         auto&amp; floatItem = floats[index];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (constraints.left &amp;&amp; floatItem.isLeftPositioned())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (constraints.right &amp;&amp; !floatItem.isLeftPositioned())</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto rect = floatItem.rectWithMargin();</span>
<span class="udiff-line-added">+         if (rect.top() &gt;= adjustedLogicalBottom || rect.bottom() &lt;= adjustedLogicalTop)</span>
<span class="udiff-line-added">+             continue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (floatItem.isLeftPositioned())</span>
<span class="udiff-line-added">+             constraints.left = PointInContextRoot { rect.right(), rect.bottom() };</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             constraints.right = PointInContextRoot { rect.left(), rect.bottom() };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (constraints.left &amp;&amp; constraints.right)</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (coordinateMappingIsRequired) {</span>
<span class="udiff-line-added">+         if (constraints.left)</span>
<span class="udiff-line-added">+             constraints.left-&gt;move(-adjustingDelta);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (constraints.right)</span>
<span class="udiff-line-added">+             constraints.right-&gt;move(-adjustingDelta);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return constraints;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void FloatingContext::append(const Box&amp; floatBox)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     floatingState().append(FloatingState::FloatItem { floatBox, mapToFloatingStateRoot(floatBox) });</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static FloatPair::LeftRightIndex findAvailablePosition(FloatAvoider&amp; floatAvoider, const FloatingState::FloatList&amp; floats)
  {
      Optional&lt;PositionInContextRoot&gt; bottomMost;
      Optional&lt;FloatPair::LeftRightIndex&gt; innerMostLeftAndRight;
      auto end = Layout::end(floats);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -346,10 +413,58 @@</span>
              return;
          floatAvoider.setVerticalConstraint({ intersectedFloatBox-&gt;rectWithMargin().top() });
      }
  }
  
<span class="udiff-line-added">+ FloatingContext::AbsoluteCoordinateValuesForFloatAvoider FloatingContext::absoluteDisplayBoxCoordinates(const Box&amp; floatAvoider) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; containingBlock = *floatAvoider.containingBlock();</span>
<span class="udiff-line-added">+     auto displayBox = mapToFloatingStateRoot(floatAvoider);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (&amp;containingBlock == &amp;floatingState().root()) {</span>
<span class="udiff-line-added">+         auto containingBlockGeometry = formattingContext().geometryForBox(containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);</span>
<span class="udiff-line-added">+         return { displayBox, { }, {  containingBlockGeometry.contentBoxLeft(), containingBlockGeometry.contentBoxRight() } };</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     auto containingBlockAbsoluteDisplayBox = mapToFloatingStateRoot(containingBlock);</span>
<span class="udiff-line-added">+     auto containingBlockLeft = containingBlockAbsoluteDisplayBox.left();</span>
<span class="udiff-line-added">+     return { displayBox, containingBlockAbsoluteDisplayBox.topLeft(), { containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxLeft(), containingBlockLeft + containingBlockAbsoluteDisplayBox.contentBoxRight() } };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Display::Box FloatingContext::mapToFloatingStateRoot(const Box&amp; floatBox) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; floatingStateRoot = floatingState().root();</span>
<span class="udiff-line-added">+     auto&amp; boxGeometry = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates);</span>
<span class="udiff-line-added">+     auto topLeft = boxGeometry.topLeft();</span>
<span class="udiff-line-added">+     for (auto* containingBlock = floatBox.containingBlock(); containingBlock &amp;&amp; containingBlock != &amp;floatingStateRoot; containingBlock = containingBlock-&gt;containingBlock())</span>
<span class="udiff-line-added">+         topLeft.moveBy(formattingContext().geometryForBox(*containingBlock, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto mappedDisplayBox = Display::Box(boxGeometry);</span>
<span class="udiff-line-added">+     mappedDisplayBox.setTopLeft(topLeft);</span>
<span class="udiff-line-added">+     return mappedDisplayBox;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ LayoutUnit FloatingContext::mapTopToFloatingStateRoot(const Box&amp; floatBox) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; floatingStateRoot = floatingState().root();</span>
<span class="udiff-line-added">+     auto top = formattingContext().geometryForBox(floatBox, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();</span>
<span class="udiff-line-added">+     for (auto* container = floatBox.containingBlock(); container &amp;&amp; container != &amp;floatingStateRoot; container = container-&gt;containingBlock())</span>
<span class="udiff-line-added">+         top += formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).top();</span>
<span class="udiff-line-added">+     return top;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ Point FloatingContext::mapPointFromFormattingContextRootToFloatingStateRoot(Point position) const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto&amp; from = root();</span>
<span class="udiff-line-added">+     auto&amp; to = floatingState().root();</span>
<span class="udiff-line-added">+     if (&amp;from == &amp;to)</span>
<span class="udiff-line-added">+         return position;</span>
<span class="udiff-line-added">+     auto mappedPosition = position;</span>
<span class="udiff-line-added">+     for (auto* container = &amp;from; container &amp;&amp; container != &amp;to; container = container-&gt;containingBlock())</span>
<span class="udiff-line-added">+         mappedPosition.moveBy(formattingContext().geometryForBox(*container, FormattingContext::EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates).topLeft());</span>
<span class="udiff-line-added">+     return mappedPosition;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  FloatPair::FloatPair(const FloatingState::FloatList&amp; floats)
      : m_floats(floats)
  {
  }
  
</pre>
<center><a href="FloatBox.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FloatingContext.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
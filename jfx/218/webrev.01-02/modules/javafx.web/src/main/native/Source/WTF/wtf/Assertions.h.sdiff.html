<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Assertions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Assertions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AutomaticThread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Assertions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47 #include &lt;stdlib.h&gt;
 48 #include &lt;wtf/ExportMacros.h&gt;
 49 
 50 #if USE(OS_LOG)
 51 #include &lt;os/log.h&gt;
 52 #endif
 53 
 54 #ifdef __cplusplus
 55 #include &lt;cstdlib&gt;
 56 #include &lt;type_traits&gt;
 57 
 58 #if OS(WINDOWS)
 59 #if !COMPILER(GCC_COMPATIBLE)
 60 extern &quot;C&quot; void _ReadWriteBarrier(void);
 61 #pragma intrinsic(_ReadWriteBarrier)
 62 #endif
 63 #include &lt;intrin.h&gt;
 64 #endif
 65 #endif
 66 
<span class="line-modified"> 67 #ifdef NDEBUG</span>
<span class="line-removed"> 68 /* Disable ASSERT* macros in release mode. */</span>
<span class="line-removed"> 69 #define ASSERTIONS_DISABLED_DEFAULT 1</span>
<span class="line-removed"> 70 #else</span>
<span class="line-removed"> 71 #define ASSERTIONS_DISABLED_DEFAULT 0</span>
<span class="line-removed"> 72 #endif</span>
 73 
 74 #ifndef BACKTRACE_DISABLED
<span class="line-modified"> 75 #define BACKTRACE_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
<span class="line-removed"> 76 #endif</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 #ifndef ASSERT_DISABLED</span>
<span class="line-removed"> 79 #define ASSERT_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
 80 #endif
 81 
 82 #ifndef ASSERT_MSG_DISABLED
<span class="line-modified"> 83 #define ASSERT_MSG_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
 84 #endif
 85 
 86 #ifndef ASSERT_ARG_DISABLED
<span class="line-modified"> 87 #define ASSERT_ARG_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
 88 #endif
 89 
 90 #ifndef FATAL_DISABLED
<span class="line-modified"> 91 #define FATAL_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
 92 #endif
 93 
 94 #ifndef ERROR_DISABLED
<span class="line-modified"> 95 #define ERROR_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
 96 #endif
 97 
 98 #ifndef LOG_DISABLED
<span class="line-modified"> 99 #define LOG_DISABLED ASSERTIONS_DISABLED_DEFAULT</span>
100 #endif
101 
102 #ifndef RELEASE_LOG_DISABLED
103 #define RELEASE_LOG_DISABLED !(USE(OS_LOG))
104 #endif
105 
106 #if COMPILER(GCC_COMPATIBLE)
107 #define WTF_PRETTY_FUNCTION __PRETTY_FUNCTION__
108 #else
109 #define WTF_PRETTY_FUNCTION __FUNCTION__
110 #endif
111 
112 #if COMPILER(MINGW)
113 /* By default MinGW emits warnings when C99 format attributes are used, even if __USE_MINGW_ANSI_STDIO is defined */
114 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(gnu_printf, formatStringArgument, extraArguments)))
115 #elif COMPILER(GCC_COMPATIBLE) &amp;&amp; !defined(__OBJC__)
116 /* WTF logging functions can process %@ in the format string to log a NSObject* but the printf format attribute
117    emits a warning when %@ is used in the format string.  Until &lt;rdar://problem/5195437&gt; is resolved we can&#39;t include
118    the attribute when being used from Objective-C code in case it decides to use %@. */
119 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(printf, formatStringArgument, extraArguments)))
</pre>
<hr />
<pre>
285 
286 #else
287 
288 #define BACKTRACE() do { \
289     WTFReportBacktrace(); \
290 } while(false)
291 
292 #endif
293 
294 /* ASSERT, ASSERT_NOT_REACHED, ASSERT_UNUSED
295 
296   These macros are compiled out of release builds.
297   Expressions inside them are evaluated in debug builds only.
298 */
299 
300 #if OS(WINDOWS)
301 /* FIXME: Change to use something other than ASSERT to avoid this conflict with the underlying platform */
302 #undef ASSERT
303 #endif
304 
<span class="line-modified">305 #if ASSERT_DISABLED</span>
306 
307 #define ASSERT(assertion, ...) ((void)0)
308 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ((void)0)
309 #define ASSERT_AT(assertion, file, line, function) ((void)0)
310 #define ASSERT_NOT_REACHED(...) ((void)0)
311 #define ASSERT_NOT_IMPLEMENTED_YET() ((void)0)
312 #define ASSERT_IMPLIES(condition, assertion) ((void)0)
313 #define NO_RETURN_DUE_TO_ASSERT
314 
315 #define ASSERT_UNUSED(variable, assertion, ...) ((void)variable)
316 
317 #if ENABLE(SECURITY_ASSERTIONS)
318 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
319     (!(assertion) ? \
320         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
321          CRASH_WITH_SECURITY_IMPLICATION()) : \
322         (void)0)
323 
324 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
<span class="line-modified">325 #else</span>
326 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) ((void)0)
327 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 1
<span class="line-modified">328 #endif</span>
329 
<span class="line-modified">330 #else</span>
331 
332 #define ASSERT(assertion, ...) do { \
333     if (!(assertion)) { \
334         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
335         CRASH_WITH_INFO(__VA_ARGS__); \
336     } \
337 } while (0)
338 
339 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
340     if (!(assertion)) { \
341         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
342         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
343     } \
344 } while (0)
345 
346 #define ASSERT_AT(assertion, file, line, function) do { \
347     if (!(assertion)) { \
348         WTFReportAssertionFailure(file, line, function, #assertion); \
349         CRASH(); \
350     } \
</pre>
<hr />
<pre>
368 } while (0)
369 
370 #define ASSERT_UNUSED(variable, assertion, ...) ASSERT(assertion, __VA_ARGS__)
371 
372 #define NO_RETURN_DUE_TO_ASSERT NO_RETURN_DUE_TO_CRASH
373 
374 /* ASSERT_WITH_SECURITY_IMPLICATION
375 
376    Failure of this assertion indicates a possible security vulnerability.
377    Class of vulnerabilities that it tests include bad casts, out of bounds
378    accesses, use-after-frees, etc. Please file a bug using the security
379    template - https://bugs.webkit.org/enter_bug.cgi?product=Security.
380 
381 */
382 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
383     (!(assertion) ? \
384         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
385          CRASH_WITH_SECURITY_IMPLICATION()) : \
386         (void)0)
387 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
<span class="line-modified">388 #endif</span>

389 
390 /* ASSERT_WITH_MESSAGE */
391 
392 #if ASSERT_MSG_DISABLED
393 #define ASSERT_WITH_MESSAGE(assertion, ...) ((void)0)
394 #else
395 #define ASSERT_WITH_MESSAGE(assertion, ...) do { \
396     if (!(assertion)) { \
397         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
398         CRASH(); \
399     } \
400 } while (0)
401 #endif
402 





403 /* ASSERT_WITH_MESSAGE_UNUSED */
404 
405 #if ASSERT_MSG_DISABLED
406 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) ((void)variable)
407 #else
408 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) do { \
409     if (!(assertion)) { \
410         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
411         CRASH(); \
412     } \
413 } while (0)
414 #endif
415 
416 
417 /* ASSERT_ARG */
418 
419 #if ASSERT_ARG_DISABLED
420 
421 #define ASSERT_ARG(argName, assertion) ((void)0)
422 
</pre>
<hr />
<pre>
509 #define RELEASE_LOG_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG(      channel, __VA_ARGS__); } while (0)
510 #define RELEASE_LOG_ERROR_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_ERROR(channel, __VA_ARGS__); } while (0)
511 #define RELEASE_LOG_INFO_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_INFO(channel, __VA_ARGS__); } while (0)
512 
513 #define RELEASE_LOG_WITH_LEVEL(channel, logLevel, ...) do { \
514     if (LOG_CHANNEL(channel).level &gt;= (logLevel)) \
515         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
516 } while (0)
517 
518 #define RELEASE_LOG_WITH_LEVEL_IF(isAllowed, channel, logLevel, ...) do { \
519     if ((isAllowed) &amp;&amp; LOG_CHANNEL(channel).level &gt;= (logLevel)) \
520         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
521 } while (0)
522 
523 #define RELEASE_LOG_STACKTRACE(channel) WTFReleaseLogStackTrace(&amp;LOG_CHANNEL(channel))
524 #endif
525 
526 
527 /* RELEASE_ASSERT */
528 
<span class="line-modified">529 #if ASSERT_DISABLED</span>

530 #define RELEASE_ASSERT(assertion, ...) do { \
531     if (UNLIKELY(!(assertion))) \
532         CRASH_WITH_INFO(__VA_ARGS__); \
533 } while (0)
534 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) RELEASE_ASSERT(assertion)
535 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) RELEASE_ASSERT(assertion)
536 #define RELEASE_ASSERT_NOT_REACHED(...) CRASH_WITH_INFO(__VA_ARGS__)
537 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
538     if (UNLIKELY(!(assertion))) { \
539         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
540     } \
541 } while (0)
<span class="line-modified">542 #else</span>


543 #define RELEASE_ASSERT(assertion, ...) ASSERT(assertion, __VA_ARGS__)
544 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) ASSERT_WITH_MESSAGE(assertion, __VA_ARGS__)
545 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) ASSERT_WITH_SECURITY_IMPLICATION(assertion)
546 #define RELEASE_ASSERT_NOT_REACHED() ASSERT_NOT_REACHED()
547 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion)
<span class="line-modified">548 #endif</span>

549 
550 #ifdef __cplusplus

551 
552 // The combination of line, file, function, and counter should be a unique number per call to this crash. This tricks the compiler into not coalescing calls to WTFCrashWithInfo.
553 // The easiest way to fill these values per translation unit is to pass __LINE__, __FILE__, WTF_PRETTY_FUNCTION, and __COUNTER__.
554 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5, uint64_t misc6);
555 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5);
556 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4);
557 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3);
558 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2);
559 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1);
560 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason);
561 NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfo(int line, const char* file, const char* function, int counter);
562 
563 template&lt;typename T&gt;
564 ALWAYS_INLINE uint64_t wtfCrashArg(T* arg) { return reinterpret_cast&lt;uintptr_t&gt;(arg); }
565 
566 template&lt;typename T&gt;
567 ALWAYS_INLINE uint64_t wtfCrashArg(T arg) { return arg; }
568 
569 template&lt;typename T&gt;
570 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason)
</pre>
</td>
<td>
<hr />
<pre>
 47 #include &lt;stdlib.h&gt;
 48 #include &lt;wtf/ExportMacros.h&gt;
 49 
 50 #if USE(OS_LOG)
 51 #include &lt;os/log.h&gt;
 52 #endif
 53 
 54 #ifdef __cplusplus
 55 #include &lt;cstdlib&gt;
 56 #include &lt;type_traits&gt;
 57 
 58 #if OS(WINDOWS)
 59 #if !COMPILER(GCC_COMPATIBLE)
 60 extern &quot;C&quot; void _ReadWriteBarrier(void);
 61 #pragma intrinsic(_ReadWriteBarrier)
 62 #endif
 63 #include &lt;intrin.h&gt;
 64 #endif
 65 #endif
 66 
<span class="line-modified"> 67 /* ASSERT_ENABLED is defined in Platform.h. */</span>





 68 
 69 #ifndef BACKTRACE_DISABLED
<span class="line-modified"> 70 #define BACKTRACE_DISABLED !ASSERT_ENABLED</span>




 71 #endif
 72 
 73 #ifndef ASSERT_MSG_DISABLED
<span class="line-modified"> 74 #define ASSERT_MSG_DISABLED !ASSERT_ENABLED</span>
 75 #endif
 76 
 77 #ifndef ASSERT_ARG_DISABLED
<span class="line-modified"> 78 #define ASSERT_ARG_DISABLED !ASSERT_ENABLED</span>
 79 #endif
 80 
 81 #ifndef FATAL_DISABLED
<span class="line-modified"> 82 #define FATAL_DISABLED !ASSERT_ENABLED</span>
 83 #endif
 84 
 85 #ifndef ERROR_DISABLED
<span class="line-modified"> 86 #define ERROR_DISABLED !ASSERT_ENABLED</span>
 87 #endif
 88 
 89 #ifndef LOG_DISABLED
<span class="line-modified"> 90 #define LOG_DISABLED !ASSERT_ENABLED</span>
 91 #endif
 92 
 93 #ifndef RELEASE_LOG_DISABLED
 94 #define RELEASE_LOG_DISABLED !(USE(OS_LOG))
 95 #endif
 96 
 97 #if COMPILER(GCC_COMPATIBLE)
 98 #define WTF_PRETTY_FUNCTION __PRETTY_FUNCTION__
 99 #else
100 #define WTF_PRETTY_FUNCTION __FUNCTION__
101 #endif
102 
103 #if COMPILER(MINGW)
104 /* By default MinGW emits warnings when C99 format attributes are used, even if __USE_MINGW_ANSI_STDIO is defined */
105 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(gnu_printf, formatStringArgument, extraArguments)))
106 #elif COMPILER(GCC_COMPATIBLE) &amp;&amp; !defined(__OBJC__)
107 /* WTF logging functions can process %@ in the format string to log a NSObject* but the printf format attribute
108    emits a warning when %@ is used in the format string.  Until &lt;rdar://problem/5195437&gt; is resolved we can&#39;t include
109    the attribute when being used from Objective-C code in case it decides to use %@. */
110 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(printf, formatStringArgument, extraArguments)))
</pre>
<hr />
<pre>
276 
277 #else
278 
279 #define BACKTRACE() do { \
280     WTFReportBacktrace(); \
281 } while(false)
282 
283 #endif
284 
285 /* ASSERT, ASSERT_NOT_REACHED, ASSERT_UNUSED
286 
287   These macros are compiled out of release builds.
288   Expressions inside them are evaluated in debug builds only.
289 */
290 
291 #if OS(WINDOWS)
292 /* FIXME: Change to use something other than ASSERT to avoid this conflict with the underlying platform */
293 #undef ASSERT
294 #endif
295 
<span class="line-modified">296 #if !ASSERT_ENABLED</span>
297 
298 #define ASSERT(assertion, ...) ((void)0)
299 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ((void)0)
300 #define ASSERT_AT(assertion, file, line, function) ((void)0)
301 #define ASSERT_NOT_REACHED(...) ((void)0)
302 #define ASSERT_NOT_IMPLEMENTED_YET() ((void)0)
303 #define ASSERT_IMPLIES(condition, assertion) ((void)0)
304 #define NO_RETURN_DUE_TO_ASSERT
305 
306 #define ASSERT_UNUSED(variable, assertion, ...) ((void)variable)
307 
308 #if ENABLE(SECURITY_ASSERTIONS)
309 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
310     (!(assertion) ? \
311         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
312          CRASH_WITH_SECURITY_IMPLICATION()) : \
313         (void)0)
314 
315 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
<span class="line-modified">316 #else /* not ENABLE(SECURITY_ASSERTIONS) */</span>
317 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) ((void)0)
318 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 1
<span class="line-modified">319 #endif /* ENABLE(SECURITY_ASSERTIONS) */</span>
320 
<span class="line-modified">321 #else /* ASSERT_ENABLED */</span>
322 
323 #define ASSERT(assertion, ...) do { \
324     if (!(assertion)) { \
325         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
326         CRASH_WITH_INFO(__VA_ARGS__); \
327     } \
328 } while (0)
329 
330 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
331     if (!(assertion)) { \
332         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
333         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
334     } \
335 } while (0)
336 
337 #define ASSERT_AT(assertion, file, line, function) do { \
338     if (!(assertion)) { \
339         WTFReportAssertionFailure(file, line, function, #assertion); \
340         CRASH(); \
341     } \
</pre>
<hr />
<pre>
359 } while (0)
360 
361 #define ASSERT_UNUSED(variable, assertion, ...) ASSERT(assertion, __VA_ARGS__)
362 
363 #define NO_RETURN_DUE_TO_ASSERT NO_RETURN_DUE_TO_CRASH
364 
365 /* ASSERT_WITH_SECURITY_IMPLICATION
366 
367    Failure of this assertion indicates a possible security vulnerability.
368    Class of vulnerabilities that it tests include bad casts, out of bounds
369    accesses, use-after-frees, etc. Please file a bug using the security
370    template - https://bugs.webkit.org/enter_bug.cgi?product=Security.
371 
372 */
373 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
374     (!(assertion) ? \
375         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
376          CRASH_WITH_SECURITY_IMPLICATION()) : \
377         (void)0)
378 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
<span class="line-modified">379 </span>
<span class="line-added">380 #endif /* ASSERT_ENABLED */</span>
381 
382 /* ASSERT_WITH_MESSAGE */
383 
384 #if ASSERT_MSG_DISABLED
385 #define ASSERT_WITH_MESSAGE(assertion, ...) ((void)0)
386 #else
387 #define ASSERT_WITH_MESSAGE(assertion, ...) do { \
388     if (!(assertion)) { \
389         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
390         CRASH(); \
391     } \
392 } while (0)
393 #endif
394 
<span class="line-added">395 #ifdef __cplusplus</span>
<span class="line-added">396 constexpr bool assertionFailureDueToUnreachableCode = false;</span>
<span class="line-added">397 #define ASSERT_NOT_REACHED_WITH_MESSAGE(...) ASSERT_WITH_MESSAGE(assertionFailureDueToUnreachableCode, __VA_ARGS__)</span>
<span class="line-added">398 #endif</span>
<span class="line-added">399 </span>
400 /* ASSERT_WITH_MESSAGE_UNUSED */
401 
402 #if ASSERT_MSG_DISABLED
403 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) ((void)variable)
404 #else
405 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) do { \
406     if (!(assertion)) { \
407         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
408         CRASH(); \
409     } \
410 } while (0)
411 #endif
412 
413 
414 /* ASSERT_ARG */
415 
416 #if ASSERT_ARG_DISABLED
417 
418 #define ASSERT_ARG(argName, assertion) ((void)0)
419 
</pre>
<hr />
<pre>
506 #define RELEASE_LOG_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG(      channel, __VA_ARGS__); } while (0)
507 #define RELEASE_LOG_ERROR_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_ERROR(channel, __VA_ARGS__); } while (0)
508 #define RELEASE_LOG_INFO_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_INFO(channel, __VA_ARGS__); } while (0)
509 
510 #define RELEASE_LOG_WITH_LEVEL(channel, logLevel, ...) do { \
511     if (LOG_CHANNEL(channel).level &gt;= (logLevel)) \
512         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
513 } while (0)
514 
515 #define RELEASE_LOG_WITH_LEVEL_IF(isAllowed, channel, logLevel, ...) do { \
516     if ((isAllowed) &amp;&amp; LOG_CHANNEL(channel).level &gt;= (logLevel)) \
517         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
518 } while (0)
519 
520 #define RELEASE_LOG_STACKTRACE(channel) WTFReleaseLogStackTrace(&amp;LOG_CHANNEL(channel))
521 #endif
522 
523 
524 /* RELEASE_ASSERT */
525 
<span class="line-modified">526 #if !ASSERT_ENABLED</span>
<span class="line-added">527 </span>
528 #define RELEASE_ASSERT(assertion, ...) do { \
529     if (UNLIKELY(!(assertion))) \
530         CRASH_WITH_INFO(__VA_ARGS__); \
531 } while (0)
532 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) RELEASE_ASSERT(assertion)
533 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) RELEASE_ASSERT(assertion)
534 #define RELEASE_ASSERT_NOT_REACHED(...) CRASH_WITH_INFO(__VA_ARGS__)
535 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
536     if (UNLIKELY(!(assertion))) { \
537         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
538     } \
539 } while (0)
<span class="line-modified">540 </span>
<span class="line-added">541 #else /* ASSERT_ENABLED */</span>
<span class="line-added">542 </span>
543 #define RELEASE_ASSERT(assertion, ...) ASSERT(assertion, __VA_ARGS__)
544 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) ASSERT_WITH_MESSAGE(assertion, __VA_ARGS__)
545 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) ASSERT_WITH_SECURITY_IMPLICATION(assertion)
546 #define RELEASE_ASSERT_NOT_REACHED() ASSERT_NOT_REACHED()
547 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion)
<span class="line-modified">548 </span>
<span class="line-added">549 #endif /* ASSERT_ENABLED */</span>
550 
551 #ifdef __cplusplus
<span class="line-added">552 #define RELEASE_ASSERT_NOT_REACHED_WITH_MESSAGE(...) RELEASE_ASSERT_WITH_MESSAGE(assertionFailureDueToUnreachableCode, __VA_ARGS__)</span>
553 
554 // The combination of line, file, function, and counter should be a unique number per call to this crash. This tricks the compiler into not coalescing calls to WTFCrashWithInfo.
555 // The easiest way to fill these values per translation unit is to pass __LINE__, __FILE__, WTF_PRETTY_FUNCTION, and __COUNTER__.
556 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5, uint64_t misc6);
557 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5);
558 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4);
559 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3);
560 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2);
561 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1);
562 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason);
563 NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfo(int line, const char* file, const char* function, int counter);
564 
565 template&lt;typename T&gt;
566 ALWAYS_INLINE uint64_t wtfCrashArg(T* arg) { return reinterpret_cast&lt;uintptr_t&gt;(arg); }
567 
568 template&lt;typename T&gt;
569 ALWAYS_INLINE uint64_t wtfCrashArg(T arg) { return arg; }
570 
571 template&lt;typename T&gt;
572 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason)
</pre>
</td>
</tr>
</table>
<center><a href="Assertions.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AutomaticThread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
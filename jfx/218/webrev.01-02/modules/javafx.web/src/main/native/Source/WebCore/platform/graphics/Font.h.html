<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Font.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * This file is part of the internal font implementation.
  3  *
  4  * Copyright (C) 2006, 2008, 2010, 2015-2016 Apple Inc. All rights reserved.
  5  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  *
 22  */
 23 
 24 #ifndef Font_h
 25 #define Font_h
 26 
 27 #include &quot;FloatRect.h&quot;
 28 #include &quot;FontMetrics.h&quot;
 29 #include &quot;FontPlatformData.h&quot;
 30 #include &quot;GlyphBuffer.h&quot;
 31 #include &quot;GlyphMetricsMap.h&quot;
 32 #include &quot;GlyphPage.h&quot;
 33 #include &quot;OpenTypeMathData.h&quot;
 34 #if ENABLE(OPENTYPE_VERTICAL)
 35 #include &quot;OpenTypeVerticalData.h&quot;
 36 #endif
 37 #include &lt;wtf/BitVector.h&gt;
 38 #include &lt;wtf/Hasher.h&gt;
 39 #include &lt;wtf/Optional.h&gt;
 40 #include &lt;wtf/text/StringHash.h&gt;
 41 
 42 #if PLATFORM(COCOA)
 43 #include &lt;CoreFoundation/CoreFoundation.h&gt;
 44 #include &lt;wtf/RetainPtr.h&gt;
 45 #endif
 46 
 47 #if PLATFORM(WIN)
 48 #include &lt;usp10.h&gt;
 49 #endif
 50 
 51 #if USE(DIRECT2D)
 52 interface IDWriteFactory5;
 53 interface IDWriteGdiInterop;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 class GlyphPage;
 59 class FontDescription;
 60 class SharedBuffer;
 61 struct GlyphData;
 62 struct WidthIterator;
 63 
 64 enum FontVariant { AutoVariant, NormalVariant, SmallCapsVariant, EmphasisMarkVariant, BrokenIdeographVariant };
 65 enum Pitch { UnknownPitch, FixedPitch, VariablePitch };
 66 enum class IsForPlatformFont : uint8_t { No, Yes };
 67 
 68 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Font);
 69 class Font : public RefCounted&lt;Font&gt; {
 70     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(Font);
 71 public:
 72     // Used to create platform fonts.
 73     enum class Origin : uint8_t {
 74         Remote,
 75         Local
 76     };
 77     enum class Interstitial : uint8_t {
 78         Yes,
 79         No
 80     };
 81     enum class Visibility : uint8_t {
 82         Visible,
 83         Invisible
 84     };
 85     enum class OrientationFallback : uint8_t {
 86         Yes,
 87         No
 88     };
 89     static Ref&lt;Font&gt; create(const FontPlatformData&amp; platformData, Origin origin = Origin::Local, Interstitial interstitial = Interstitial::No, Visibility visibility = Visibility::Visible, OrientationFallback orientationFallback = OrientationFallback::No)
 90     {
 91         return adoptRef(*new Font(platformData, origin, interstitial, visibility, orientationFallback));
 92     }
 93 
 94     WEBCORE_EXPORT ~Font();
 95 
 96     static const Font* systemFallback() { return reinterpret_cast&lt;const Font*&gt;(-1); }
 97 
 98     const FontPlatformData&amp; platformData() const { return m_platformData; }
 99     const OpenTypeMathData* mathData() const;
100 #if ENABLE(OPENTYPE_VERTICAL)
101     const OpenTypeVerticalData* verticalData() const { return m_verticalData.get(); }
102 #endif
103 
104     const Font* smallCapsFont(const FontDescription&amp;) const;
105     const Font&amp; noSynthesizableFeaturesFont() const;
106     const Font* emphasisMarkFont(const FontDescription&amp;) const;
107     const Font&amp; brokenIdeographFont() const;
108 
109     const Font* variantFont(const FontDescription&amp; description, FontVariant variant) const
110     {
111 #if PLATFORM(COCOA)
112         ASSERT(variant != SmallCapsVariant);
113 #endif
114         switch (variant) {
115         case SmallCapsVariant:
116             return smallCapsFont(description);
117         case EmphasisMarkVariant:
118             return emphasisMarkFont(description);
119         case BrokenIdeographVariant:
120             return &amp;brokenIdeographFont();
121         case AutoVariant:
122         case NormalVariant:
123             break;
124         }
125         ASSERT_NOT_REACHED();
126         return const_cast&lt;Font*&gt;(this);
127     }
128 
129     bool variantCapsSupportsCharacterForSynthesis(FontVariantCaps, UChar32) const;
130 
131     const Font&amp; verticalRightOrientationFont() const;
132     const Font&amp; uprightOrientationFont() const;
133     const Font&amp; invisibleFont() const;
134 
135     bool hasVerticalGlyphs() const { return m_hasVerticalGlyphs; }
136     bool isTextOrientationFallback() const { return m_isTextOrientationFallback; }
137 
138     FontMetrics&amp; fontMetrics() { return m_fontMetrics; }
139     const FontMetrics&amp; fontMetrics() const { return m_fontMetrics; }
140     float sizePerUnit() const { return platformData().size() / (fontMetrics().unitsPerEm() ? fontMetrics().unitsPerEm() : 1); }
141 
142     float maxCharWidth() const { return m_maxCharWidth; }
143     void setMaxCharWidth(float maxCharWidth) { m_maxCharWidth = maxCharWidth; }
144 
145     float avgCharWidth() const { return m_avgCharWidth; }
146     void setAvgCharWidth(float avgCharWidth) { m_avgCharWidth = avgCharWidth; }
147 
148     FloatRect boundsForGlyph(Glyph) const;
149     float widthForGlyph(Glyph) const;
150     const Path&amp; pathForGlyph(Glyph) const; // Don&#39;t store the result of this! The hash map is free to rehash at any point, leaving this reference dangling.
151     FloatRect platformBoundsForGlyph(Glyph) const;
152     float platformWidthForGlyph(Glyph) const;
153     Path platformPathForGlyph(Glyph) const;
154 
155     float spaceWidth() const { return m_spaceWidth; }
156     float adjustedSpaceWidth() const { return m_adjustedSpaceWidth; }
157     void setSpaceWidths(float spaceWidth)
158     {
159         m_spaceWidth = spaceWidth;
160         m_adjustedSpaceWidth = spaceWidth;
161     }
162 
163 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO) || PLATFORM(JAVA)
164     float syntheticBoldOffset() const { return m_syntheticBoldOffset; }
165 #endif
166 
167     Glyph spaceGlyph() const { return m_spaceGlyph; }
168     void setSpaceGlyph(Glyph spaceGlyph) { m_spaceGlyph = spaceGlyph; }
169     Glyph zeroWidthSpaceGlyph() const { return m_zeroWidthSpaceGlyph; }
170     void setZeroWidthSpaceGlyph(Glyph spaceGlyph) { m_zeroWidthSpaceGlyph = spaceGlyph; }
171     bool isZeroWidthSpaceGlyph(Glyph glyph) const { return glyph == m_zeroWidthSpaceGlyph &amp;&amp; glyph; }
172     Glyph zeroGlyph() const { return m_zeroGlyph; }
173     void setZeroGlyph(Glyph zeroGlyph) { m_zeroGlyph = zeroGlyph; }
174 
175     GlyphData glyphDataForCharacter(UChar32) const;
176     Glyph glyphForCharacter(UChar32) const;
177     bool supportsCodePoint(UChar32) const;
178     bool platformSupportsCodePoint(UChar32, Optional&lt;UChar32&gt; variation = WTF::nullopt) const;
179 
180     RefPtr&lt;Font&gt; systemFallbackFontForCharacter(UChar32, const FontDescription&amp;, IsForPlatformFont) const;
181 
182     const GlyphPage* glyphPage(unsigned pageNumber) const;
183 
184     void determinePitch();
185     Pitch pitch() const { return m_treatAsFixedPitch ? FixedPitch : VariablePitch; }
186 
187     Origin origin() const { return m_origin; }
188     bool isInterstitial() const { return m_isInterstitial; }
189     Visibility visibility() const { return m_visibility; }
190     bool allowsAntialiasing() const { return m_allowsAntialiasing; }
191 
192 #if !LOG_DISABLED
193     String description() const;
194 #endif
195 
196 #if PLATFORM(IOS_FAMILY)
197     bool shouldNotBeUsedForArabic() const { return m_shouldNotBeUsedForArabic; };
198 #endif
199 #if PLATFORM(COCOA)
200     CTFontRef getCTFont() const { return m_platformData.font(); }
201     RetainPtr&lt;CFDictionaryRef&gt; getCFStringAttributes(bool enableKerning, FontOrientation, const AtomString&amp; locale) const;
202     const BitVector&amp; glyphsSupportedBySmallCaps() const;
203     const BitVector&amp; glyphsSupportedByAllSmallCaps() const;
204     const BitVector&amp; glyphsSupportedByPetiteCaps() const;
205     const BitVector&amp; glyphsSupportedByAllPetiteCaps() const;
206 #endif
207 
208 #if HAVE(DISALLOWABLE_USER_INSTALLED_FONTS)
209     bool isUserInstalledFont() const;
210 #endif
211 
212     bool canRenderCombiningCharacterSequence(const UChar*, size_t) const;
213     void applyTransforms(GlyphBuffer&amp;, unsigned beginningIndex, bool enableKerning, bool requiresShaping, const AtomString&amp; locale) const;
214 
215 #if PLATFORM(WIN)
216     SCRIPT_FONTPROPERTIES* scriptFontProperties() const;
217     SCRIPT_CACHE* scriptCache() const { return &amp;m_scriptCache; }
218     static void setShouldApplyMacAscentHack(bool);
219     static bool shouldApplyMacAscentHack();
220     static float ascentConsideringMacAscentHack(const WCHAR*, float ascent, float descent);
221 #endif
222 
223     SharedBuffer* fontFaceData() const { return m_fontFaceData.get(); }
224     void setFontFaceData(RefPtr&lt;SharedBuffer&gt;&amp;&amp;);
225 
226 private:
227     WEBCORE_EXPORT Font(const FontPlatformData&amp;, Origin, Interstitial, Visibility, OrientationFallback);
228 
229     void platformInit();
230     void platformGlyphInit();
231     void platformCharWidthInit();
232     void platformDestroy();
233 
234     void initCharWidths();
235 
236     RefPtr&lt;Font&gt; createFontWithoutSynthesizableFeatures() const;
237     RefPtr&lt;Font&gt; createScaledFont(const FontDescription&amp;, float scaleFactor) const;
238     RefPtr&lt;Font&gt; platformCreateScaledFont(const FontDescription&amp;, float scaleFactor) const;
239 
240     void removeFromSystemFallbackCache();
241 
242     struct DerivedFonts;
243     DerivedFonts&amp; ensureDerivedFontData() const;
244 
245 #if PLATFORM(WIN)
246     void initGDIFont();
247     void platformCommonDestroy();
248     FloatRect boundsForGDIGlyph(Glyph) const;
249     float widthForGDIGlyph(Glyph) const;
250 #endif
251 
252     FontMetrics m_fontMetrics;
253     float m_maxCharWidth { -1 };
254     float m_avgCharWidth { -1 };
255 
256     const FontPlatformData m_platformData;
257 
258     mutable RefPtr&lt;GlyphPage&gt; m_glyphPageZero;
259     mutable HashMap&lt;unsigned, RefPtr&lt;GlyphPage&gt;&gt; m_glyphPages;
260     mutable std::unique_ptr&lt;GlyphMetricsMap&lt;FloatRect&gt;&gt; m_glyphToBoundsMap;
261     mutable GlyphMetricsMap&lt;float&gt; m_glyphToWidthMap;
262     mutable GlyphMetricsMap&lt;Optional&lt;Path&gt;&gt; m_glyphPathMap;
263     mutable BitVector m_codePointSupport;
264 
265     mutable RefPtr&lt;OpenTypeMathData&gt; m_mathData;
266 #if ENABLE(OPENTYPE_VERTICAL)
267     RefPtr&lt;OpenTypeVerticalData&gt; m_verticalData;
268 #endif
269 
270     struct DerivedFonts {
271         WTF_MAKE_STRUCT_FAST_ALLOCATED;
272     public:
273 
274         RefPtr&lt;Font&gt; smallCapsFont;
275         RefPtr&lt;Font&gt; noSynthesizableFeaturesFont;
276         RefPtr&lt;Font&gt; emphasisMarkFont;
277         RefPtr&lt;Font&gt; brokenIdeographFont;
278         RefPtr&lt;Font&gt; verticalRightOrientationFont;
279         RefPtr&lt;Font&gt; uprightOrientationFont;
280         RefPtr&lt;Font&gt; invisibleFont;
281     };
282 
283     mutable std::unique_ptr&lt;DerivedFonts&gt; m_derivedFontData;
284 
285 #if PLATFORM(COCOA)
286     mutable Optional&lt;BitVector&gt; m_glyphsSupportedBySmallCaps;
287     mutable Optional&lt;BitVector&gt; m_glyphsSupportedByAllSmallCaps;
288     mutable Optional&lt;BitVector&gt; m_glyphsSupportedByPetiteCaps;
289     mutable Optional&lt;BitVector&gt; m_glyphsSupportedByAllPetiteCaps;
290 #endif
291 
292 #if PLATFORM(WIN)
293     mutable SCRIPT_CACHE m_scriptCache;
294     mutable SCRIPT_FONTPROPERTIES* m_scriptFontProperties;
295 #endif
296 
297     RefPtr&lt;SharedBuffer&gt; m_fontFaceData;
298 
299     Glyph m_spaceGlyph { 0 };
300     Glyph m_zeroGlyph { 0 };
301     Glyph m_zeroWidthSpaceGlyph { 0 };
302 
303     Origin m_origin; // Whether or not we are custom font loaded via @font-face
304     Visibility m_visibility; // @font-face&#39;s internal timer can cause us to show fonts even when a font is being downloaded.
305 
306     float m_spaceWidth { 0 };
307     float m_adjustedSpaceWidth { 0 };
308 
309 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO) || PLATFORM(JAVA)
310     float m_syntheticBoldOffset { 0 };
311 #endif
312 
313     unsigned m_treatAsFixedPitch : 1;
314     unsigned m_isInterstitial : 1; // Whether or not this custom font is the last resort placeholder for a loading font
315 
316     unsigned m_isTextOrientationFallback : 1;
317     unsigned m_isBrokenIdeographFallback : 1;
318     unsigned m_hasVerticalGlyphs : 1;
319 
320     unsigned m_isUsedInSystemFallbackCache : 1;
321 
322     unsigned m_allowsAntialiasing : 1;
323 
324 #if PLATFORM(IOS_FAMILY)
325     unsigned m_shouldNotBeUsedForArabic : 1;
326 #endif
327 };
328 
329 class FontHandle {
330 public:
331     FontHandle() = default;
332     WEBCORE_EXPORT FontHandle(Ref&lt;SharedBuffer&gt;&amp;&amp; fontFaceData, Font::Origin, float fontSize, bool syntheticBold, bool syntheticItalic);
333 
334     RefPtr&lt;Font&gt; font;
335 };
336 
337 #if PLATFORM(IOS_FAMILY)
338 bool fontFamilyShouldNotBeUsedForArabic(CFStringRef);
339 #endif
340 
341 ALWAYS_INLINE FloatRect Font::boundsForGlyph(Glyph glyph) const
342 {
343     if (isZeroWidthSpaceGlyph(glyph))
344         return FloatRect();
345 
346     FloatRect bounds;
347     if (m_glyphToBoundsMap) {
348         bounds = m_glyphToBoundsMap-&gt;metricsForGlyph(glyph);
349         if (bounds.width() != cGlyphSizeUnknown)
350             return bounds;
351     }
352 
353     bounds = platformBoundsForGlyph(glyph);
354     if (!m_glyphToBoundsMap)
355         m_glyphToBoundsMap = makeUnique&lt;GlyphMetricsMap&lt;FloatRect&gt;&gt;();
356     m_glyphToBoundsMap-&gt;setMetricsForGlyph(glyph, bounds);
357     return bounds;
358 }
359 
360 ALWAYS_INLINE float Font::widthForGlyph(Glyph glyph) const
361 {
362     // The optimization of returning 0 for the zero-width-space glyph is incorrect for the LastResort font,
363     // used in place of the actual font when isLoading() is true on both macOS and iOS.
364     // The zero-width-space glyph in that font does not have a width of zero and, further, that glyph is used
365     // for many other characters and must not be zero width when used for them.
366     if (isZeroWidthSpaceGlyph(glyph) &amp;&amp; !isInterstitial())
367         return 0;
368 
369     float width = m_glyphToWidthMap.metricsForGlyph(glyph);
370     if (width != cGlyphSizeUnknown)
371         return width;
372 
373 #if ENABLE(OPENTYPE_VERTICAL)
374     if (m_verticalData) {
375 #if USE(CG) || USE(DIRECT2D) || USE(CAIRO)
376         width = m_verticalData-&gt;advanceHeight(this, glyph) + m_syntheticBoldOffset;
377 #else
378         width = m_verticalData-&gt;advanceHeight(this, glyph);
379 #endif
380     } else
381 #endif
382         width = platformWidthForGlyph(glyph);
383 
384     m_glyphToWidthMap.setMetricsForGlyph(glyph, width);
385     return width;
386 }
387 
388 } // namespace WebCore
389 
390 #endif // Font_h
    </pre>
  </body>
</html>
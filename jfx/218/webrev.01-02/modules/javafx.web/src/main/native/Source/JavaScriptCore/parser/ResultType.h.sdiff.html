<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ResultType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ParserTokens.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SourceCodeKey.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ResultType.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 


 30     struct ResultType {
 31     private:
 32         friend struct OperandTypes;
 33 
 34         using Type = uint8_t;
 35         static constexpr Type TypeInt32       = 0x1 &lt;&lt; 0;
 36         static constexpr Type TypeMaybeNumber = 0x1 &lt;&lt; 1;
 37         static constexpr Type TypeMaybeString = 0x1 &lt;&lt; 2;
 38         static constexpr Type TypeMaybeBigInt = 0x1 &lt;&lt; 3;
 39         static constexpr Type TypeMaybeNull   = 0x1 &lt;&lt; 4;
 40         static constexpr Type TypeMaybeBool   = 0x1 &lt;&lt; 5;
 41         static constexpr Type TypeMaybeOther  = 0x1 &lt;&lt; 6;
 42 
 43         static constexpr Type TypeBits = TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt | TypeMaybeNull | TypeMaybeBool | TypeMaybeOther;
 44 
 45     public:
 46         static constexpr int numBitsNeeded = 7;
 47         static_assert((TypeBits &amp; ((1 &lt;&lt; numBitsNeeded) - 1)) == TypeBits, &quot;This is necessary for correctness.&quot;);
 48 




 49         constexpr explicit ResultType(Type type)
 50             : m_bits(type)
 51         {
 52         }
 53 
 54         constexpr bool isInt32() const
 55         {
 56             return m_bits &amp; TypeInt32;
 57         }
 58 
 59         constexpr bool definitelyIsNumber() const
 60         {
 61             return (m_bits &amp; TypeBits) == TypeMaybeNumber;
 62         }
 63 
 64         constexpr bool definitelyIsString() const
 65         {
 66             return (m_bits &amp; TypeBits) == TypeMaybeString;
 67         }
 68 
</pre>
<hr />
<pre>
131             return ResultType(TypeMaybeNumber | TypeMaybeString);
132         }
133 
134         static constexpr ResultType addResultType()
135         {
136             return ResultType(TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt);
137         }
138 
139         static constexpr ResultType stringType()
140         {
141             return ResultType(TypeMaybeString);
142         }
143 
144         static constexpr ResultType bigIntType()
145         {
146             return ResultType(TypeMaybeBigInt);
147         }
148 
149         static constexpr ResultType bigIntOrInt32Type()
150         {
<span class="line-modified">151             return ResultType(TypeMaybeBigInt | TypeInt32);</span>





152         }
153 
154         static constexpr ResultType unknownType()
155         {
156             return ResultType(TypeBits);
157         }
158 
159         static constexpr ResultType forAdd(ResultType op1, ResultType op2)
160         {
161             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
162                 return numberType();
163             if (op1.definitelyIsString() || op2.definitelyIsString())
164                 return stringType();
165             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
166                 return bigIntType();
167             return addResultType();
168         }
169 


















170         // Unlike in C, a logical op produces the value of the
171         // last expression evaluated (and not true or false).
172         static constexpr ResultType forLogicalOp(ResultType op1, ResultType op2)
173         {
174             if (op1.definitelyIsBoolean() &amp;&amp; op2.definitelyIsBoolean())
175                 return booleanType();
176             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
177                 return numberType();
178             if (op1.definitelyIsString() &amp;&amp; op2.definitelyIsString())
179                 return stringType();
180             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
181                 return bigIntType();
182             return unknownType();
183         }
184 
185         static constexpr ResultType forCoalesce(ResultType op1, ResultType op2)
186         {
187             if (op1.definitelyIsNull())
188                 return op2;
189             if (!op1.mightBeUndefinedOrNull())
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 
<span class="line-added"> 30     // FIXME: Consider whether this is actually necessary. Is LLInt and Baseline&#39;s profiling information enough?</span>
<span class="line-added"> 31     // https://bugs.webkit.org/show_bug.cgi?id=201659</span>
 32     struct ResultType {
 33     private:
 34         friend struct OperandTypes;
 35 
 36         using Type = uint8_t;
 37         static constexpr Type TypeInt32       = 0x1 &lt;&lt; 0;
 38         static constexpr Type TypeMaybeNumber = 0x1 &lt;&lt; 1;
 39         static constexpr Type TypeMaybeString = 0x1 &lt;&lt; 2;
 40         static constexpr Type TypeMaybeBigInt = 0x1 &lt;&lt; 3;
 41         static constexpr Type TypeMaybeNull   = 0x1 &lt;&lt; 4;
 42         static constexpr Type TypeMaybeBool   = 0x1 &lt;&lt; 5;
 43         static constexpr Type TypeMaybeOther  = 0x1 &lt;&lt; 6;
 44 
 45         static constexpr Type TypeBits = TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt | TypeMaybeNull | TypeMaybeBool | TypeMaybeOther;
 46 
 47     public:
 48         static constexpr int numBitsNeeded = 7;
 49         static_assert((TypeBits &amp; ((1 &lt;&lt; numBitsNeeded) - 1)) == TypeBits, &quot;This is necessary for correctness.&quot;);
 50 
<span class="line-added"> 51         constexpr explicit ResultType()</span>
<span class="line-added"> 52             : ResultType(unknownType())</span>
<span class="line-added"> 53         {</span>
<span class="line-added"> 54         }</span>
 55         constexpr explicit ResultType(Type type)
 56             : m_bits(type)
 57         {
 58         }
 59 
 60         constexpr bool isInt32() const
 61         {
 62             return m_bits &amp; TypeInt32;
 63         }
 64 
 65         constexpr bool definitelyIsNumber() const
 66         {
 67             return (m_bits &amp; TypeBits) == TypeMaybeNumber;
 68         }
 69 
 70         constexpr bool definitelyIsString() const
 71         {
 72             return (m_bits &amp; TypeBits) == TypeMaybeString;
 73         }
 74 
</pre>
<hr />
<pre>
137             return ResultType(TypeMaybeNumber | TypeMaybeString);
138         }
139 
140         static constexpr ResultType addResultType()
141         {
142             return ResultType(TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt);
143         }
144 
145         static constexpr ResultType stringType()
146         {
147             return ResultType(TypeMaybeString);
148         }
149 
150         static constexpr ResultType bigIntType()
151         {
152             return ResultType(TypeMaybeBigInt);
153         }
154 
155         static constexpr ResultType bigIntOrInt32Type()
156         {
<span class="line-modified">157             return ResultType(TypeMaybeBigInt | TypeInt32 | TypeMaybeNumber);</span>
<span class="line-added">158         }</span>
<span class="line-added">159 </span>
<span class="line-added">160         static constexpr ResultType bigIntOrNumberType()</span>
<span class="line-added">161         {</span>
<span class="line-added">162             return ResultType(TypeMaybeBigInt | TypeMaybeNumber);</span>
163         }
164 
165         static constexpr ResultType unknownType()
166         {
167             return ResultType(TypeBits);
168         }
169 
170         static constexpr ResultType forAdd(ResultType op1, ResultType op2)
171         {
172             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
173                 return numberType();
174             if (op1.definitelyIsString() || op2.definitelyIsString())
175                 return stringType();
176             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
177                 return bigIntType();
178             return addResultType();
179         }
180 
<span class="line-added">181         static constexpr ResultType forNonAddArith(ResultType op1, ResultType op2)</span>
<span class="line-added">182         {</span>
<span class="line-added">183             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())</span>
<span class="line-added">184                 return numberType();</span>
<span class="line-added">185             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())</span>
<span class="line-added">186                 return bigIntType();</span>
<span class="line-added">187             return bigIntOrNumberType();</span>
<span class="line-added">188         }</span>
<span class="line-added">189 </span>
<span class="line-added">190         static constexpr ResultType forUnaryArith(ResultType op)</span>
<span class="line-added">191         {</span>
<span class="line-added">192             if (op.definitelyIsNumber())</span>
<span class="line-added">193                 return numberType();</span>
<span class="line-added">194             if (op.definitelyIsBigInt())</span>
<span class="line-added">195                 return bigIntType();</span>
<span class="line-added">196             return bigIntOrNumberType();</span>
<span class="line-added">197         }</span>
<span class="line-added">198 </span>
199         // Unlike in C, a logical op produces the value of the
200         // last expression evaluated (and not true or false).
201         static constexpr ResultType forLogicalOp(ResultType op1, ResultType op2)
202         {
203             if (op1.definitelyIsBoolean() &amp;&amp; op2.definitelyIsBoolean())
204                 return booleanType();
205             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
206                 return numberType();
207             if (op1.definitelyIsString() &amp;&amp; op2.definitelyIsString())
208                 return stringType();
209             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
210                 return bigIntType();
211             return unknownType();
212         }
213 
214         static constexpr ResultType forCoalesce(ResultType op1, ResultType op2)
215         {
216             if (op1.definitelyIsNull())
217                 return op2;
218             if (!op1.mightBeUndefinedOrNull())
</pre>
</td>
</tr>
</table>
<center><a href="ParserTokens.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SourceCodeKey.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmMemory.h&quot;
 28 #include &quot;WasmInstance.h&quot;
 29 
 30 #if ENABLE(WEBASSEMBLY)
 31 
 32 #include &quot;Options.h&quot;
 33 #include &lt;wtf/DataLog.h&gt;
 34 #include &lt;wtf/Gigacage.h&gt;
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/OSAllocator.h&gt;
 37 #include &lt;wtf/PageBlock.h&gt;
 38 #include &lt;wtf/Platform.h&gt;
 39 #include &lt;wtf/PrintStream.h&gt;
 40 #include &lt;wtf/RAMSize.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 
 43 #include &lt;cstring&gt;
 44 #include &lt;mutex&gt;
 45 
 46 namespace JSC { namespace Wasm {
 47 
 48 // FIXME: We could be smarter about memset / mmap / madvise. https://bugs.webkit.org/show_bug.cgi?id=170343
 49 // FIXME: Give up some of the cached fast memories if the GC determines it&#39;s easy to get them back, and they haven&#39;t been used in a while. https://bugs.webkit.org/show_bug.cgi?id=170773
 50 // FIXME: Limit slow memory size. https://bugs.webkit.org/show_bug.cgi?id=170825
 51 
 52 namespace {
 53 
 54 constexpr bool verbose = false;
 55 
 56 NEVER_INLINE NO_RETURN_DUE_TO_CRASH void webAssemblyCouldntGetFastMemory() { CRASH(); }
 57 
 58 struct MemoryResult {
 59     enum Kind {
 60         Success,
 61         SuccessAndNotifyMemoryPressure,
 62         SyncTryToReclaimMemory
 63     };
 64 
 65     static const char* toString(Kind kind)
 66     {
 67         switch (kind) {
 68         case Success:
 69             return &quot;Success&quot;;
 70         case SuccessAndNotifyMemoryPressure:
 71             return &quot;SuccessAndNotifyMemoryPressure&quot;;
 72         case SyncTryToReclaimMemory:
 73             return &quot;SyncTryToReclaimMemory&quot;;
 74         }
 75         RELEASE_ASSERT_NOT_REACHED();
 76         return nullptr;
 77     }
 78 
 79     MemoryResult() { }
 80 
 81     MemoryResult(void* basePtr, Kind kind)
 82         : basePtr(basePtr)
 83         , kind(kind)
 84     {
 85     }
 86 
 87     void dump(PrintStream&amp; out) const
 88     {
 89         out.print(&quot;{basePtr = &quot;, RawPointer(basePtr), &quot;, kind = &quot;, toString(kind), &quot;}&quot;);
 90     }
 91 
 92     void* basePtr;
 93     Kind kind;
 94 };
 95 
 96 class MemoryManager {
 97     WTF_MAKE_FAST_ALLOCATED;
 98     WTF_MAKE_NONCOPYABLE(MemoryManager);
 99 public:
100     MemoryManager()
101         : m_maxFastMemoryCount(Options::maxNumWebAssemblyFastMemories())
102     {
103     }
104 
105     MemoryResult tryAllocateFastMemory()
106     {
107         MemoryResult result = [&amp;] {
108             auto holder = holdLock(m_lock);
109             if (m_fastMemories.size() &gt;= m_maxFastMemoryCount)
110                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
111 
112             void* result = Gigacage::tryAllocateZeroedVirtualPages(Gigacage::Primitive, Memory::fastMappedBytes());
113             if (!result)
114                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
115 
116             m_fastMemories.append(result);
117 
118             return MemoryResult(
119                 result,
120                 m_fastMemories.size() &gt;= m_maxFastMemoryCount / 2 ? MemoryResult::SuccessAndNotifyMemoryPressure : MemoryResult::Success);
121         }();
122 
123         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Allocated virtual: &quot;, result, &quot;; state: &quot;, *this);
124 
125         return result;
126     }
127 
128     void freeFastMemory(void* basePtr)
129     {
130         {
131             auto holder = holdLock(m_lock);
132             Gigacage::freeVirtualPages(Gigacage::Primitive, basePtr, Memory::fastMappedBytes());
133             m_fastMemories.removeFirst(basePtr);
134         }
135 
136         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Freed virtual; state: &quot;, *this);
137     }
138 
139     bool isAddressInFastMemory(void* address)
140     {
141         // NOTE: This can be called from a signal handler, but only after we proved that we&#39;re in JIT code.
142         auto holder = holdLock(m_lock);
143         for (void* memory : m_fastMemories) {
144             char* start = static_cast&lt;char*&gt;(memory);
145             if (start &lt;= address &amp;&amp; address &lt;= start + Memory::fastMappedBytes())
146                 return true;
147         }
148         return false;
149     }
150 
151     // We allow people to &quot;commit&quot; more wasm memory than there is on the system since most of the time
152     // people don&#39;t actually write to most of that memory. There is some chance that this gets us
153     // JetSammed but that&#39;s possible anyway.
154     inline size_t memoryLimit() const { return ramSize() * 3; }
155 
156     // FIXME: Ideally, bmalloc would have this kind of mechanism. Then, we would just forward to that
157     // mechanism here.
158     MemoryResult::Kind tryAllocatePhysicalBytes(size_t bytes)
159     {
160         MemoryResult::Kind result = [&amp;] {
161             auto holder = holdLock(m_lock);
162             if (m_physicalBytes + bytes &gt; memoryLimit())
163                 return MemoryResult::SyncTryToReclaimMemory;
164 
165             m_physicalBytes += bytes;
166 
167             if (m_physicalBytes &gt;= memoryLimit() / 2)
168                 return MemoryResult::SuccessAndNotifyMemoryPressure;
169 
170             return MemoryResult::Success;
171         }();
172 
173         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Allocated physical: &quot;, bytes, &quot;, &quot;, MemoryResult::toString(result), &quot;; state: &quot;, *this);
174 
175         return result;
176     }
177 
178     void freePhysicalBytes(size_t bytes)
179     {
180         {
181             auto holder = holdLock(m_lock);
182             m_physicalBytes -= bytes;
183         }
184 
185         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Freed physical: &quot;, bytes, &quot;; state: &quot;, *this);
186     }
187 
188     void dump(PrintStream&amp; out) const
189     {
190         out.print(&quot;fast memories =  &quot;, m_fastMemories.size(), &quot;/&quot;, m_maxFastMemoryCount, &quot;, bytes = &quot;, m_physicalBytes, &quot;/&quot;, memoryLimit());
191     }
192 
193 private:
194     Lock m_lock;
195     unsigned m_maxFastMemoryCount { 0 };
196     Vector&lt;void*&gt; m_fastMemories;
197     size_t m_physicalBytes { 0 };
198 };
199 
200 static MemoryManager&amp; memoryManager()
201 {
202     static std::once_flag onceFlag;
203     static MemoryManager* manager;
204     std::call_once(
205         onceFlag,
206         [] {
207             manager = new MemoryManager();
208         });
209     return *manager;
210 }
211 
212 template&lt;typename Func&gt;
213 bool tryAllocate(const Func&amp; allocate, const WTF::Function&lt;void(Memory::NotifyPressure)&gt;&amp; notifyMemoryPressure, const WTF::Function&lt;void(Memory::SyncTryToReclaim)&gt;&amp; syncTryToReclaimMemory)
214 {
215     unsigned numTries = 2;
216     bool done = false;
217     for (unsigned i = 0; i &lt; numTries &amp;&amp; !done; ++i) {
218         switch (allocate()) {
219         case MemoryResult::Success:
220             done = true;
221             break;
222         case MemoryResult::SuccessAndNotifyMemoryPressure:
223             if (notifyMemoryPressure)
224                 notifyMemoryPressure(Memory::NotifyPressureTag);
225             done = true;
226             break;
227         case MemoryResult::SyncTryToReclaimMemory:
228             if (i + 1 == numTries)
229                 break;
230             if (syncTryToReclaimMemory)
231                 syncTryToReclaimMemory(Memory::SyncTryToReclaimTag);
232             break;
233         }
234     }
235     return done;
236 }
237 
238 } // anonymous namespace
239 
240 Memory::Memory()
241 {
242 }
243 
244 Memory::Memory(PageCount initial, PageCount maximum, Function&lt;void(NotifyPressure)&gt;&amp;&amp; notifyMemoryPressure, Function&lt;void(SyncTryToReclaim)&gt;&amp;&amp; syncTryToReclaimMemory, WTF::Function&lt;void(GrowSuccess, PageCount, PageCount)&gt;&amp;&amp; growSuccessCallback)
245     : m_initial(initial)
246     , m_maximum(maximum)
247     , m_notifyMemoryPressure(WTFMove(notifyMemoryPressure))
248     , m_syncTryToReclaimMemory(WTFMove(syncTryToReclaimMemory))
249     , m_growSuccessCallback(WTFMove(growSuccessCallback))
250 {
251     ASSERT(!initial.bytes());
252     ASSERT(m_mode == MemoryMode::BoundsChecking);
253     dataLogLnIf(verbose, &quot;Memory::Memory allocating &quot;, *this);
254     ASSERT(!memory());
255 }
256 
257 Memory::Memory(void* memory, PageCount initial, PageCount maximum, size_t mappedCapacity, MemoryMode mode, Function&lt;void(NotifyPressure)&gt;&amp;&amp; notifyMemoryPressure, Function&lt;void(SyncTryToReclaim)&gt;&amp;&amp; syncTryToReclaimMemory, WTF::Function&lt;void(GrowSuccess, PageCount, PageCount)&gt;&amp;&amp; growSuccessCallback)
258     : m_memory(memory, initial.bytes())
259     , m_size(initial.bytes())
260     , m_initial(initial)
261     , m_maximum(maximum)
262     , m_mappedCapacity(mappedCapacity)
263     , m_mode(mode)
264     , m_notifyMemoryPressure(WTFMove(notifyMemoryPressure))
265     , m_syncTryToReclaimMemory(WTFMove(syncTryToReclaimMemory))
266     , m_growSuccessCallback(WTFMove(growSuccessCallback))
267 {
268     dataLogLnIf(verbose, &quot;Memory::Memory allocating &quot;, *this);
269 }
270 
271 Ref&lt;Memory&gt; Memory::create()
272 {
273     return adoptRef(*new Memory());
274 }
275 
276 RefPtr&lt;Memory&gt; Memory::tryCreate(PageCount initial, PageCount maximum, WTF::Function&lt;void(NotifyPressure)&gt;&amp;&amp; notifyMemoryPressure, WTF::Function&lt;void(SyncTryToReclaim)&gt;&amp;&amp; syncTryToReclaimMemory, WTF::Function&lt;void(GrowSuccess, PageCount, PageCount)&gt;&amp;&amp; growSuccessCallback)
277 {
278     ASSERT(initial);
279     RELEASE_ASSERT(!maximum || maximum &gt;= initial); // This should be guaranteed by our caller.
280 
281     const size_t initialBytes = initial.bytes();
282     const size_t maximumBytes = maximum ? maximum.bytes() : 0;
283 
284     if (initialBytes &gt; MAX_ARRAY_BUFFER_SIZE)
285         return nullptr; // Client will throw OOMError.
286 
287     if (maximum &amp;&amp; !maximumBytes) {
288         // User specified a zero maximum, initial size must also be zero.
289         RELEASE_ASSERT(!initialBytes);
290         return adoptRef(new Memory(initial, maximum, WTFMove(notifyMemoryPressure), WTFMove(syncTryToReclaimMemory), WTFMove(growSuccessCallback)));
291     }
292 
293     bool done = tryAllocate(
294         [&amp;] () -&gt; MemoryResult::Kind {
295             return memoryManager().tryAllocatePhysicalBytes(initialBytes);
296         }, notifyMemoryPressure, syncTryToReclaimMemory);
297     if (!done)
298         return nullptr;
299 
300     char* fastMemory = nullptr;
301     if (Options::useWebAssemblyFastMemory()) {
302         tryAllocate(
303             [&amp;] () -&gt; MemoryResult::Kind {
304                 auto result = memoryManager().tryAllocateFastMemory();
305                 fastMemory = bitwise_cast&lt;char*&gt;(result.basePtr);
306                 return result.kind;
307             }, notifyMemoryPressure, syncTryToReclaimMemory);
308     }
309 
310     if (fastMemory) {
311 
312         if (mprotect(fastMemory + initialBytes, Memory::fastMappedBytes() - initialBytes, PROT_NONE)) {
313             dataLog(&quot;mprotect failed: &quot;, strerror(errno), &quot;\n&quot;);
314             RELEASE_ASSERT_NOT_REACHED();
315         }
316 
317         return adoptRef(new Memory(fastMemory, initial, maximum, Memory::fastMappedBytes(), MemoryMode::Signaling, WTFMove(notifyMemoryPressure), WTFMove(syncTryToReclaimMemory), WTFMove(growSuccessCallback)));
318     }
319 
320     if (UNLIKELY(Options::crashIfWebAssemblyCantFastMemory()))
321         webAssemblyCouldntGetFastMemory();
322 
323     if (!initialBytes)
324         return adoptRef(new Memory(initial, maximum, WTFMove(notifyMemoryPressure), WTFMove(syncTryToReclaimMemory), WTFMove(growSuccessCallback)));
325 
326     void* slowMemory = Gigacage::tryAllocateZeroedVirtualPages(Gigacage::Primitive, initialBytes);
327     if (!slowMemory) {
328         memoryManager().freePhysicalBytes(initialBytes);
329         return nullptr;
330     }
331     return adoptRef(new Memory(slowMemory, initial, maximum, initialBytes, MemoryMode::BoundsChecking, WTFMove(notifyMemoryPressure), WTFMove(syncTryToReclaimMemory), WTFMove(growSuccessCallback)));
332 }
333 
334 Memory::~Memory()
335 {
336     if (m_memory) {
337         memoryManager().freePhysicalBytes(m_size);
338         switch (m_mode) {
339         case MemoryMode::Signaling:
340             if (mprotect(memory(), Memory::fastMappedBytes(), PROT_READ | PROT_WRITE)) {
341                 dataLog(&quot;mprotect failed: &quot;, strerror(errno), &quot;\n&quot;);
342                 RELEASE_ASSERT_NOT_REACHED();
343             }
344             memoryManager().freeFastMemory(memory());
345             break;
346         case MemoryMode::BoundsChecking:
347             Gigacage::freeVirtualPages(Gigacage::Primitive, memory(), m_size);
348             break;
349         }
350     }
351 }
352 
353 size_t Memory::fastMappedRedzoneBytes()
354 {
355     return static_cast&lt;size_t&gt;(PageCount::pageSize) * Options::webAssemblyFastMemoryRedzonePages();
356 }
357 
358 size_t Memory::fastMappedBytes()
359 {
360     static_assert(sizeof(uint64_t) == sizeof(size_t), &quot;We rely on allowing the maximum size of Memory we map to be 2^32 + redzone which is larger than fits in a 32-bit integer that we&#39;d pass to mprotect if this didn&#39;t hold.&quot;);
361     return static_cast&lt;size_t&gt;(std::numeric_limits&lt;uint32_t&gt;::max()) + fastMappedRedzoneBytes();
362 }
363 
364 bool Memory::addressIsInActiveFastMemory(void* address)
365 {
366     return memoryManager().isAddressInFastMemory(address);
367 }
368 
369 Expected&lt;PageCount, Memory::GrowFailReason&gt; Memory::grow(PageCount delta)
370 {
371     const Wasm::PageCount oldPageCount = sizeInPages();
372 
373     if (!delta.isValid())
374         return makeUnexpected(GrowFailReason::InvalidDelta);
375 
376     const Wasm::PageCount newPageCount = oldPageCount + delta;
377     if (!newPageCount || !newPageCount.isValid())
378         return makeUnexpected(GrowFailReason::InvalidGrowSize);
379     if (newPageCount.bytes() &gt; MAX_ARRAY_BUFFER_SIZE)
380         return makeUnexpected(GrowFailReason::OutOfMemory);
381 
382     auto success = [&amp;] () {
383         m_growSuccessCallback(GrowSuccessTag, oldPageCount, newPageCount);
384         // Update cache for instance
385         for (auto&amp; instance : m_instances) {
386             if (instance.get() != nullptr)
387                 instance.get()-&gt;updateCachedMemory();
388         }
389         return oldPageCount;
390     };
391 
392     if (delta.pageCount() == 0)
393         return success();
394 
395     dataLogLnIf(verbose, &quot;Memory::grow(&quot;, delta, &quot;) to &quot;, newPageCount, &quot; from &quot;, *this);
396     RELEASE_ASSERT(newPageCount &gt; PageCount::fromBytes(m_size));
397 
398     if (maximum() &amp;&amp; newPageCount &gt; maximum())
399         return makeUnexpected(GrowFailReason::WouldExceedMaximum);
400 
401     size_t desiredSize = newPageCount.bytes();
402     RELEASE_ASSERT(desiredSize &lt;= MAX_ARRAY_BUFFER_SIZE);
403     RELEASE_ASSERT(desiredSize &gt; m_size);
404     size_t extraBytes = desiredSize - m_size;
405     RELEASE_ASSERT(extraBytes);
406     bool allocationSuccess = tryAllocate(
407         [&amp;] () -&gt; MemoryResult::Kind {
408             return memoryManager().tryAllocatePhysicalBytes(extraBytes);
409         }, m_notifyMemoryPressure, m_syncTryToReclaimMemory);
410     if (!allocationSuccess)
411         return makeUnexpected(GrowFailReason::OutOfMemory);
412 
413     switch (mode()) {
414     case MemoryMode::BoundsChecking: {
415         RELEASE_ASSERT(maximum().bytes() != 0);
416 
417         void* newMemory = Gigacage::tryAllocateZeroedVirtualPages(Gigacage::Primitive, desiredSize);
418         if (!newMemory)
419             return makeUnexpected(GrowFailReason::OutOfMemory);
420 
421         memcpy(newMemory, memory(), m_size);
422         if (m_memory)
423             Gigacage::freeVirtualPages(Gigacage::Primitive, memory(), m_size);
424         m_memory = CagedMemory(newMemory, desiredSize);
425         m_mappedCapacity = desiredSize;
426         m_size = desiredSize;
427         ASSERT(memory() == newMemory);
428         return success();
429     }
430     case MemoryMode::Signaling: {
431         RELEASE_ASSERT(memory());
432         // Signaling memory must have been pre-allocated virtually.
433         uint8_t* startAddress = static_cast&lt;uint8_t*&gt;(memory()) + m_size;
434 
435         dataLogLnIf(verbose, &quot;Marking WebAssembly memory&#39;s &quot;, RawPointer(memory()), &quot; as read+write in range [&quot;, RawPointer(startAddress), &quot;, &quot;, RawPointer(startAddress + extraBytes), &quot;)&quot;);
436         if (mprotect(startAddress, extraBytes, PROT_READ | PROT_WRITE)) {
437             dataLog(&quot;mprotect failed: &quot;, strerror(errno), &quot;\n&quot;);
438             RELEASE_ASSERT_NOT_REACHED();
439         }
440         m_memory.recage(m_size, desiredSize);
441         m_size = desiredSize;
442         return success();
443     }
444     }
445 
446     RELEASE_ASSERT_NOT_REACHED();
447     return oldPageCount;
448 }
449 
450 void Memory::registerInstance(Instance* instance)
451 {
452     size_t count = m_instances.size();
453     for (size_t index = 0; index &lt; count; index++) {
454         if (m_instances.at(index).get() == nullptr) {
455             m_instances.at(index) = makeWeakPtr(*instance);
456             return;
457         }
458     }
459     m_instances.append(makeWeakPtr(*instance));
460 }
461 
462 void Memory::dump(PrintStream&amp; out) const
463 {
464     out.print(&quot;Memory at &quot;, RawPointer(memory()), &quot;, size &quot;, m_size, &quot;B capacity &quot;, m_mappedCapacity, &quot;B, initial &quot;, m_initial, &quot; maximum &quot;, m_maximum, &quot; mode &quot;, makeString(m_mode));
465 }
466 
467 } // namespace JSC
468 
469 } // namespace Wasm
470 
471 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Lexer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;Lookup.h&quot;
 26 #include &quot;ParserArena.h&quot;
 27 #include &quot;ParserModes.h&quot;
 28 #include &quot;ParserTokens.h&quot;
 29 #include &quot;SourceCode.h&quot;
 30 #include &lt;wtf/ASCIICType.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace JSC {
 34 
<span class="line-modified"> 35 enum LexerFlags {</span>
<span class="line-modified"> 36     LexerFlagsIgnoreReservedWords = 1,</span>
<span class="line-modified"> 37     LexerFlagsDontBuildStrings = 2,</span>
<span class="line-modified"> 38     LexexFlagsDontBuildKeywords = 4</span>
 39 };
 40 
 41 enum class LexerEscapeParseMode { Template, String };
 42 
 43 struct ParsedUnicodeEscapeValue;
 44 
 45 bool isLexerKeyword(const Identifier&amp;);
 46 
 47 template &lt;typename T&gt;
 48 class Lexer {
 49     WTF_MAKE_NONCOPYABLE(Lexer);
 50     WTF_MAKE_FAST_ALLOCATED;
 51 
 52 public:
 53     Lexer(VM&amp;, JSParserBuiltinMode, JSParserScriptMode);
 54     ~Lexer();
 55 
 56     // Character manipulation functions.
 57     static bool isWhiteSpace(T character);
 58     static bool isLineTerminator(T character);
 59     static unsigned char convertHex(int c1, int c2);
 60     static UChar convertUnicode(int c1, int c2, int c3, int c4);
 61 
 62     // Functions to set up parsing.
 63     void setCode(const SourceCode&amp;, ParserArena*);
 64     void setIsReparsingFunction() { m_isReparsingFunction = true; }
 65     bool isReparsingFunction() const { return m_isReparsingFunction; }
 66 
<span class="line-modified"> 67     JSTokenType lex(JSToken*, unsigned, bool strictMode);</span>
<span class="line-modified"> 68     JSTokenType lexWithoutClearingLineTerminator(JSToken*, unsigned, bool strictMode);</span>
 69     bool nextTokenIsColon();
 70     int lineNumber() const { return m_lineNumber; }
 71     ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
 72     ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
 73     ALWAYS_INLINE JSTextPosition currentPosition() const
 74     {
 75         return JSTextPosition(m_lineNumber, currentOffset(), currentLineStartOffset());
 76     }
 77     JSTextPosition positionBeforeLastNewline() const { return m_positionBeforeLastNewline; }
 78     JSTokenLocation lastTokenLocation() const { return m_lastTokenLocation; }
 79     void setLastLineNumber(int lastLineNumber) { m_lastLineNumber = lastLineNumber; }
 80     int lastLineNumber() const { return m_lastLineNumber; }
 81     bool hasLineTerminatorBeforeToken() const { return m_hasLineTerminatorBeforeToken; }
 82     JSTokenType scanRegExp(JSToken*, UChar patternPrefix = 0);
 83     enum class RawStringsBuildMode { BuildRawStrings, DontBuildRawStrings };
 84     JSTokenType scanTemplateString(JSToken*, RawStringsBuildMode);
 85 
 86     // Functions for use after parsing.
 87     bool sawError() const { return m_error; }
 88     void setSawError(bool sawError) { m_error = sawError; }
</pre>
<hr />
<pre>
 92     String sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }
 93     void clear();
 94     void setOffset(int offset, int lineStartOffset)
 95     {
 96         m_error = 0;
 97         m_lexErrorMessage = String();
 98 
 99         m_code = sourcePtrFromOffset(offset);
100         m_lineStart = sourcePtrFromOffset(lineStartOffset);
101         ASSERT(currentOffset() &gt;= currentLineStartOffset());
102 
103         m_buffer8.shrink(0);
104         m_buffer16.shrink(0);
105         if (LIKELY(m_code &lt; m_codeEnd))
106             m_current = *m_code;
107         else
108             m_current = 0;
109     }
110     void setLineNumber(int line)
111     {

112         m_lineNumber = line;
113     }
114     void setHasLineTerminatorBeforeToken(bool terminator)
115     {
116         m_hasLineTerminatorBeforeToken = terminator;
117     }
118 
<span class="line-modified">119     JSTokenType lexExpectIdentifier(JSToken*, unsigned, bool strictMode);</span>
120 
121     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
122     {
123         SourceProvider* sourceProvider = m_source-&gt;provider();
124         ASSERT_WITH_MESSAGE(token.m_location.startOffset &lt;= token.m_location.endOffset, &quot;Calling this function with the baked token.&quot;);
125         return sourceProvider-&gt;getRange(token.m_location.startOffset, token.m_location.endOffset);
126     }
127 
128 private:
129     void record8(int);
130     void append8(const T*, size_t);
131     void record16(int);
132     void record16(T);
133     void recordUnicodeCodePoint(UChar32);
134     void append16(const LChar*, size_t);
135     void append16(const UChar* characters, size_t length) { m_buffer16.append(characters, length); }
136 
137     ALWAYS_INLINE void shift();
138     ALWAYS_INLINE bool atEnd() const;
139     ALWAYS_INLINE T peek(int offset) const;
</pre>
<hr />
<pre>
147     String invalidCharacterMessage() const;
148     ALWAYS_INLINE const T* currentSourcePtr() const;
149     ALWAYS_INLINE void setOffsetFromSourcePtr(const T* sourcePtr, unsigned lineStartOffset) { setOffset(offsetFromSourcePtr(sourcePtr), lineStartOffset); }
150 
151     ALWAYS_INLINE void setCodeStart(const StringView&amp;);
152 
153     ALWAYS_INLINE const Identifier* makeIdentifier(const LChar* characters, size_t length);
154     ALWAYS_INLINE const Identifier* makeIdentifier(const UChar* characters, size_t length);
155     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const LChar* characters, size_t length);
156     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const UChar* characters, size_t length);
157     ALWAYS_INLINE const Identifier* makeRightSizedIdentifier(const UChar* characters, size_t length, UChar orAllChars);
158     ALWAYS_INLINE const Identifier* makeIdentifierLCharFromUChar(const UChar* characters, size_t length);
159     ALWAYS_INLINE const Identifier* makeEmptyIdentifier();
160 
161     ALWAYS_INLINE bool lastTokenWasRestrKeyword() const;
162 
163     ALWAYS_INLINE void skipWhitespace();
164 
165     template &lt;int shiftAmount&gt; void internalShift();
166     template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
<span class="line-modified">167     template &lt;bool shouldBuildIdentifiers&gt; ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, unsigned lexerFlags, bool strictMode);</span>
<span class="line-modified">168     template &lt;bool shouldBuildIdentifiers&gt; NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, unsigned lexerFlags, bool strictMode);</span>
169     enum StringParseResult {
170         StringParsedSuccessfully,
171         StringUnterminated,
172         StringCannotBeParsed
173     };
174     template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE StringParseResult parseString(JSTokenData*, bool strictMode);
175     template &lt;bool shouldBuildStrings&gt; NEVER_INLINE StringParseResult parseStringSlowCase(JSTokenData*, bool strictMode);
176 
177 
178     template &lt;bool shouldBuildStrings, LexerEscapeParseMode escapeParseMode&gt; ALWAYS_INLINE StringParseResult parseComplexEscape(bool strictMode, T stringQuoteCharacter);
179     ALWAYS_INLINE StringParseResult parseTemplateLiteral(JSTokenData*, RawStringsBuildMode);
180 
181     using NumberParseResult = Variant&lt;double, const Identifier*&gt;;
182     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseHex();
183     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseBinary();
184     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseOctal();
185     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseDecimal();
186     ALWAYS_INLINE bool parseNumberAfterDecimalPoint();
187     ALWAYS_INLINE bool parseNumberAfterExponentIndicator();
188     ALWAYS_INLINE bool parseMultilineComment();
189 
190     ALWAYS_INLINE void parseCommentDirective();
191     ALWAYS_INLINE String parseCommentDirectiveValue();
192 
193     template &lt;unsigned length&gt;
194     ALWAYS_INLINE bool consume(const char (&amp;input)[length]);
195 
196     void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
197 
<span class="line-modified">198     static const size_t initialReadBufferCapacity = 32;</span>
199 
200     int m_lineNumber;
201     int m_lastLineNumber;
202 
203     Vector&lt;LChar&gt; m_buffer8;
204     Vector&lt;UChar&gt; m_buffer16;
205     Vector&lt;UChar&gt; m_bufferForRawTemplateString16;
206     bool m_hasLineTerminatorBeforeToken;
207     int m_lastToken;
208 
209     const SourceCode* m_source;
210     unsigned m_sourceOffset;
211     const T* m_code;
212     const T* m_codeStart;
213     const T* m_codeEnd;
214     const T* m_codeStartPlusOffset;
215     const T* m_lineStart;
216     JSTextPosition m_positionBeforeLastNewline;
217     JSTokenLocation m_lastTokenLocation;
218     bool m_isReparsingFunction;
</pre>
<hr />
<pre>
316 }
317 
318 template &lt;typename T&gt;
319 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeIdentifierLCharFromUChar(const UChar* characters, size_t length)
320 {
321     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
322 }
323 
324 template &lt;typename T&gt;
325 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const LChar* characters, size_t length)
326 {
327     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
328 }
329 
330 template &lt;typename T&gt;
331 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const UChar* characters, size_t length)
332 {
333     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
334 }
335 
<span class="line-modified">336 #if ASSERT_DISABLED</span>
<span class="line-removed">337 ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*) { return true; }</span>
<span class="line-removed">338 #else</span>
339 bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*);
<span class="line-modified">340 #endif</span>


341 
342 template &lt;typename T&gt;
<span class="line-modified">343 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lexExpectIdentifier(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)</span>
344 {
345     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
346     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
<span class="line-modified">347     ASSERT((lexerFlags &amp; LexerFlagsIgnoreReservedWords));</span>
348     const T* start = m_code;
349     const T* ptr = start;
350     const T* end = m_codeEnd;
351     JSTextPosition startPosition = currentPosition();
352     if (ptr &gt;= end) {
353         ASSERT(ptr == end);
354         goto slowCase;
355     }
356     if (!WTF::isASCIIAlpha(*ptr))
357         goto slowCase;
358     ++ptr;
359     while (ptr &lt; end) {
360         if (!WTF::isASCIIAlphanumeric(*ptr))
361             break;
362         ++ptr;
363     }
364 
365     // Here&#39;s the shift
366     if (ptr &lt; end) {
367         if ((!WTF::isASCII(*ptr)) || (*ptr == &#39;\\&#39;) || (*ptr == &#39;_&#39;) || (*ptr == &#39;$&#39;))
368             goto slowCase;
369         m_current = *ptr;
370     } else
371         m_current = 0;
372 
373     m_code = ptr;
374     ASSERT(currentOffset() &gt;= currentLineStartOffset());
375 
376     // Create the identifier if needed
<span class="line-modified">377     if (lexerFlags &amp; LexexFlagsDontBuildKeywords</span>
<span class="line-modified">378 #if !ASSERT_DISABLED</span>
379         &amp;&amp; !m_parsingBuiltinFunction
380 #endif
381         )
382         tokenData-&gt;ident = 0;
383     else
384         tokenData-&gt;ident = makeLCharIdentifier(start, ptr - start);
385 
386     tokenLocation-&gt;line = m_lineNumber;
387     tokenLocation-&gt;lineStartOffset = currentLineStartOffset();
388     tokenLocation-&gt;startOffset = offsetFromSourcePtr(start);
389     tokenLocation-&gt;endOffset = currentOffset();
390     ASSERT(tokenLocation-&gt;startOffset &gt;= tokenLocation-&gt;lineStartOffset);
391     tokenRecord-&gt;m_startPosition = startPosition;
392     tokenRecord-&gt;m_endPosition = currentPosition();
<span class="line-modified">393 #if !ASSERT_DISABLED</span>
394     if (m_parsingBuiltinFunction) {
395         if (!isSafeBuiltinIdentifier(m_vm, tokenData-&gt;ident))
396             return ERRORTOK;
397     }
398 #endif
399 
400     m_lastToken = IDENT;
401     return IDENT;
402 
403 slowCase:
404     return lex(tokenRecord, lexerFlags, strictMode);
405 }
406 
407 template &lt;typename T&gt;
<span class="line-modified">408 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lex(JSToken* tokenRecord, unsigned lexerFlags, bool strictMode)</span>
409 {
410     m_hasLineTerminatorBeforeToken = false;
411     return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
412 }
413 
414 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;Lookup.h&quot;
 26 #include &quot;ParserArena.h&quot;
 27 #include &quot;ParserModes.h&quot;
 28 #include &quot;ParserTokens.h&quot;
 29 #include &quot;SourceCode.h&quot;
 30 #include &lt;wtf/ASCIICType.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace JSC {
 34 
<span class="line-modified"> 35 enum class LexerFlags : uint8_t {</span>
<span class="line-modified"> 36     IgnoreReservedWords = 1 &lt;&lt; 0,</span>
<span class="line-modified"> 37     DontBuildStrings = 1 &lt;&lt; 1,</span>
<span class="line-modified"> 38     DontBuildKeywords = 1 &lt;&lt; 2</span>
 39 };
 40 
 41 enum class LexerEscapeParseMode { Template, String };
 42 
 43 struct ParsedUnicodeEscapeValue;
 44 
 45 bool isLexerKeyword(const Identifier&amp;);
 46 
 47 template &lt;typename T&gt;
 48 class Lexer {
 49     WTF_MAKE_NONCOPYABLE(Lexer);
 50     WTF_MAKE_FAST_ALLOCATED;
 51 
 52 public:
 53     Lexer(VM&amp;, JSParserBuiltinMode, JSParserScriptMode);
 54     ~Lexer();
 55 
 56     // Character manipulation functions.
 57     static bool isWhiteSpace(T character);
 58     static bool isLineTerminator(T character);
 59     static unsigned char convertHex(int c1, int c2);
 60     static UChar convertUnicode(int c1, int c2, int c3, int c4);
 61 
 62     // Functions to set up parsing.
 63     void setCode(const SourceCode&amp;, ParserArena*);
 64     void setIsReparsingFunction() { m_isReparsingFunction = true; }
 65     bool isReparsingFunction() const { return m_isReparsingFunction; }
 66 
<span class="line-modified"> 67     JSTokenType lex(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified"> 68     JSTokenType lexWithoutClearingLineTerminator(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
 69     bool nextTokenIsColon();
 70     int lineNumber() const { return m_lineNumber; }
 71     ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
 72     ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
 73     ALWAYS_INLINE JSTextPosition currentPosition() const
 74     {
 75         return JSTextPosition(m_lineNumber, currentOffset(), currentLineStartOffset());
 76     }
 77     JSTextPosition positionBeforeLastNewline() const { return m_positionBeforeLastNewline; }
 78     JSTokenLocation lastTokenLocation() const { return m_lastTokenLocation; }
 79     void setLastLineNumber(int lastLineNumber) { m_lastLineNumber = lastLineNumber; }
 80     int lastLineNumber() const { return m_lastLineNumber; }
 81     bool hasLineTerminatorBeforeToken() const { return m_hasLineTerminatorBeforeToken; }
 82     JSTokenType scanRegExp(JSToken*, UChar patternPrefix = 0);
 83     enum class RawStringsBuildMode { BuildRawStrings, DontBuildRawStrings };
 84     JSTokenType scanTemplateString(JSToken*, RawStringsBuildMode);
 85 
 86     // Functions for use after parsing.
 87     bool sawError() const { return m_error; }
 88     void setSawError(bool sawError) { m_error = sawError; }
</pre>
<hr />
<pre>
 92     String sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }
 93     void clear();
 94     void setOffset(int offset, int lineStartOffset)
 95     {
 96         m_error = 0;
 97         m_lexErrorMessage = String();
 98 
 99         m_code = sourcePtrFromOffset(offset);
100         m_lineStart = sourcePtrFromOffset(lineStartOffset);
101         ASSERT(currentOffset() &gt;= currentLineStartOffset());
102 
103         m_buffer8.shrink(0);
104         m_buffer16.shrink(0);
105         if (LIKELY(m_code &lt; m_codeEnd))
106             m_current = *m_code;
107         else
108             m_current = 0;
109     }
110     void setLineNumber(int line)
111     {
<span class="line-added">112         ASSERT(line &gt;= 0);</span>
113         m_lineNumber = line;
114     }
115     void setHasLineTerminatorBeforeToken(bool terminator)
116     {
117         m_hasLineTerminatorBeforeToken = terminator;
118     }
119 
<span class="line-modified">120     JSTokenType lexExpectIdentifier(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
121 
122     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
123     {
124         SourceProvider* sourceProvider = m_source-&gt;provider();
125         ASSERT_WITH_MESSAGE(token.m_location.startOffset &lt;= token.m_location.endOffset, &quot;Calling this function with the baked token.&quot;);
126         return sourceProvider-&gt;getRange(token.m_location.startOffset, token.m_location.endOffset);
127     }
128 
129 private:
130     void record8(int);
131     void append8(const T*, size_t);
132     void record16(int);
133     void record16(T);
134     void recordUnicodeCodePoint(UChar32);
135     void append16(const LChar*, size_t);
136     void append16(const UChar* characters, size_t length) { m_buffer16.append(characters, length); }
137 
138     ALWAYS_INLINE void shift();
139     ALWAYS_INLINE bool atEnd() const;
140     ALWAYS_INLINE T peek(int offset) const;
</pre>
<hr />
<pre>
148     String invalidCharacterMessage() const;
149     ALWAYS_INLINE const T* currentSourcePtr() const;
150     ALWAYS_INLINE void setOffsetFromSourcePtr(const T* sourcePtr, unsigned lineStartOffset) { setOffset(offsetFromSourcePtr(sourcePtr), lineStartOffset); }
151 
152     ALWAYS_INLINE void setCodeStart(const StringView&amp;);
153 
154     ALWAYS_INLINE const Identifier* makeIdentifier(const LChar* characters, size_t length);
155     ALWAYS_INLINE const Identifier* makeIdentifier(const UChar* characters, size_t length);
156     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const LChar* characters, size_t length);
157     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const UChar* characters, size_t length);
158     ALWAYS_INLINE const Identifier* makeRightSizedIdentifier(const UChar* characters, size_t length, UChar orAllChars);
159     ALWAYS_INLINE const Identifier* makeIdentifierLCharFromUChar(const UChar* characters, size_t length);
160     ALWAYS_INLINE const Identifier* makeEmptyIdentifier();
161 
162     ALWAYS_INLINE bool lastTokenWasRestrKeyword() const;
163 
164     ALWAYS_INLINE void skipWhitespace();
165 
166     template &lt;int shiftAmount&gt; void internalShift();
167     template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
<span class="line-modified">168     template &lt;bool shouldBuildIdentifiers&gt; ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified">169     template &lt;bool shouldBuildIdentifiers&gt; NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
170     enum StringParseResult {
171         StringParsedSuccessfully,
172         StringUnterminated,
173         StringCannotBeParsed
174     };
175     template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE StringParseResult parseString(JSTokenData*, bool strictMode);
176     template &lt;bool shouldBuildStrings&gt; NEVER_INLINE StringParseResult parseStringSlowCase(JSTokenData*, bool strictMode);
177 
178 
179     template &lt;bool shouldBuildStrings, LexerEscapeParseMode escapeParseMode&gt; ALWAYS_INLINE StringParseResult parseComplexEscape(bool strictMode, T stringQuoteCharacter);
180     ALWAYS_INLINE StringParseResult parseTemplateLiteral(JSTokenData*, RawStringsBuildMode);
181 
182     using NumberParseResult = Variant&lt;double, const Identifier*&gt;;
183     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseHex();
184     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseBinary();
185     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseOctal();
186     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseDecimal();
187     ALWAYS_INLINE bool parseNumberAfterDecimalPoint();
188     ALWAYS_INLINE bool parseNumberAfterExponentIndicator();
189     ALWAYS_INLINE bool parseMultilineComment();
190 
191     ALWAYS_INLINE void parseCommentDirective();
192     ALWAYS_INLINE String parseCommentDirectiveValue();
193 
194     template &lt;unsigned length&gt;
195     ALWAYS_INLINE bool consume(const char (&amp;input)[length]);
196 
197     void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
198 
<span class="line-modified">199     static constexpr size_t initialReadBufferCapacity = 32;</span>
200 
201     int m_lineNumber;
202     int m_lastLineNumber;
203 
204     Vector&lt;LChar&gt; m_buffer8;
205     Vector&lt;UChar&gt; m_buffer16;
206     Vector&lt;UChar&gt; m_bufferForRawTemplateString16;
207     bool m_hasLineTerminatorBeforeToken;
208     int m_lastToken;
209 
210     const SourceCode* m_source;
211     unsigned m_sourceOffset;
212     const T* m_code;
213     const T* m_codeStart;
214     const T* m_codeEnd;
215     const T* m_codeStartPlusOffset;
216     const T* m_lineStart;
217     JSTextPosition m_positionBeforeLastNewline;
218     JSTokenLocation m_lastTokenLocation;
219     bool m_isReparsingFunction;
</pre>
<hr />
<pre>
317 }
318 
319 template &lt;typename T&gt;
320 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeIdentifierLCharFromUChar(const UChar* characters, size_t length)
321 {
322     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
323 }
324 
325 template &lt;typename T&gt;
326 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const LChar* characters, size_t length)
327 {
328     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
329 }
330 
331 template &lt;typename T&gt;
332 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const UChar* characters, size_t length)
333 {
334     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
335 }
336 
<span class="line-modified">337 #if ASSERT_ENABLED</span>


338 bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*);
<span class="line-modified">339 #else</span>
<span class="line-added">340 ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*) { return true; }</span>
<span class="line-added">341 #endif // ASSERT_ENABLED</span>
342 
343 template &lt;typename T&gt;
<span class="line-modified">344 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lexExpectIdentifier(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
345 {
346     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
347     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
<span class="line-modified">348     ASSERT(lexerFlags.contains(LexerFlags::IgnoreReservedWords));</span>
349     const T* start = m_code;
350     const T* ptr = start;
351     const T* end = m_codeEnd;
352     JSTextPosition startPosition = currentPosition();
353     if (ptr &gt;= end) {
354         ASSERT(ptr == end);
355         goto slowCase;
356     }
357     if (!WTF::isASCIIAlpha(*ptr))
358         goto slowCase;
359     ++ptr;
360     while (ptr &lt; end) {
361         if (!WTF::isASCIIAlphanumeric(*ptr))
362             break;
363         ++ptr;
364     }
365 
366     // Here&#39;s the shift
367     if (ptr &lt; end) {
368         if ((!WTF::isASCII(*ptr)) || (*ptr == &#39;\\&#39;) || (*ptr == &#39;_&#39;) || (*ptr == &#39;$&#39;))
369             goto slowCase;
370         m_current = *ptr;
371     } else
372         m_current = 0;
373 
374     m_code = ptr;
375     ASSERT(currentOffset() &gt;= currentLineStartOffset());
376 
377     // Create the identifier if needed
<span class="line-modified">378     if (lexerFlags.contains(LexerFlags::DontBuildKeywords)</span>
<span class="line-modified">379 #if ASSERT_ENABLED</span>
380         &amp;&amp; !m_parsingBuiltinFunction
381 #endif
382         )
383         tokenData-&gt;ident = 0;
384     else
385         tokenData-&gt;ident = makeLCharIdentifier(start, ptr - start);
386 
387     tokenLocation-&gt;line = m_lineNumber;
388     tokenLocation-&gt;lineStartOffset = currentLineStartOffset();
389     tokenLocation-&gt;startOffset = offsetFromSourcePtr(start);
390     tokenLocation-&gt;endOffset = currentOffset();
391     ASSERT(tokenLocation-&gt;startOffset &gt;= tokenLocation-&gt;lineStartOffset);
392     tokenRecord-&gt;m_startPosition = startPosition;
393     tokenRecord-&gt;m_endPosition = currentPosition();
<span class="line-modified">394 #if ASSERT_ENABLED</span>
395     if (m_parsingBuiltinFunction) {
396         if (!isSafeBuiltinIdentifier(m_vm, tokenData-&gt;ident))
397             return ERRORTOK;
398     }
399 #endif
400 
401     m_lastToken = IDENT;
402     return IDENT;
403 
404 slowCase:
405     return lex(tokenRecord, lexerFlags, strictMode);
406 }
407 
408 template &lt;typename T&gt;
<span class="line-modified">409 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lex(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
410 {
411     m_hasLineTerminatorBeforeToken = false;
412     return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
413 }
414 
415 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Lexer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ModuleAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
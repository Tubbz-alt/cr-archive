<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLCompressedTextureASTC.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLBuffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #pragma once
  
  #if ENABLE(WEBGL)
  
  #include &quot;WebGLSharedObject.h&quot;
<span class="line-modified">! #include &lt;wtf/Forward.h&gt;</span>
  
  namespace JSC {
  class ArrayBuffer;
  class ArrayBufferView;
  }
<span class="line-new-header">--- 26,11 ---</span>
  #pragma once
  
  #if ENABLE(WEBGL)
  
  #include &quot;WebGLSharedObject.h&quot;
<span class="line-modified">! #include &lt;wtf/RefPtr.h&gt;</span>
  
  namespace JSC {
  class ArrayBuffer;
  class ArrayBufferView;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,52 ***</span>
  class WebGLBuffer final : public WebGLSharedObject {
  public:
      static Ref&lt;WebGLBuffer&gt; create(WebGLRenderingContextBase&amp;);
      virtual ~WebGLBuffer();
  
<span class="line-modified">!     bool associateBufferData(GC3Dsizeiptr size);</span>
      bool associateBufferData(JSC::ArrayBuffer*);
      bool associateBufferData(JSC::ArrayBufferView*);
<span class="line-modified">!     bool associateBufferSubData(GC3Dintptr offset, JSC::ArrayBuffer*);</span>
<span class="line-modified">!     bool associateBufferSubData(GC3Dintptr offset, JSC::ArrayBufferView*);</span>
<span class="line-modified">!     bool associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GC3Dintptr readOffset, GC3Dintptr writeOffset, GC3Dsizeiptr);</span>
  
      void disassociateBufferData();
  
<span class="line-modified">!     GC3Dsizeiptr byteLength() const;</span>
      const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer() const { return m_elementArrayBuffer; }
  
      // Gets the cached max index for the given type if one has been set.
<span class="line-modified">!     Optional&lt;unsigned&gt; getCachedMaxIndex(GC3Denum type);</span>
      // Sets the cached max index for the given type.
<span class="line-modified">!     void setCachedMaxIndex(GC3Denum type, unsigned value);</span>
  
<span class="line-modified">!     GC3Denum getTarget() const { return m_target; }</span>
<span class="line-modified">!     void setTarget(GC3Denum, bool forWebGL2);</span>
  
      bool hasEverBeenBound() const { return object() &amp;&amp; m_target; }
  
  protected:
      WebGLBuffer(WebGLRenderingContextBase&amp;);
  
<span class="line-modified">!     void deleteObjectImpl(GraphicsContext3D*, Platform3DObject) override;</span>
  
  private:
<span class="line-modified">!     GC3Denum m_target { 0 };</span>
  
      RefPtr&lt;JSC::ArrayBuffer&gt; m_elementArrayBuffer;
<span class="line-modified">!     GC3Dsizeiptr m_byteLength { 0 };</span>
  
      // Optimization for index validation. For each type of index
      // (i.e., UNSIGNED_SHORT), cache the maximum index in the
      // entire buffer.
      //
      // This is sufficient to eliminate a lot of work upon each
      // draw call as long as all bound array buffers are at least
      // that size.
      struct MaxIndexCacheEntry {
<span class="line-modified">!         GC3Denum type;</span>
          unsigned maxIndex;
      };
      // OpenGL ES 2.0 only has two valid index types (UNSIGNED_BYTE
      // and UNSIGNED_SHORT) plus one extension (UNSIGNED_INT).
      MaxIndexCacheEntry m_maxIndexCache[4];
<span class="line-new-header">--- 40,56 ---</span>
  class WebGLBuffer final : public WebGLSharedObject {
  public:
      static Ref&lt;WebGLBuffer&gt; create(WebGLRenderingContextBase&amp;);
      virtual ~WebGLBuffer();
  
<span class="line-modified">!     bool associateBufferData(GCGLsizeiptr size);</span>
      bool associateBufferData(JSC::ArrayBuffer*);
      bool associateBufferData(JSC::ArrayBufferView*);
<span class="line-modified">!     bool associateBufferSubData(GCGLintptr offset, JSC::ArrayBuffer*);</span>
<span class="line-modified">!     bool associateBufferSubData(GCGLintptr offset, JSC::ArrayBufferView*);</span>
<span class="line-modified">!     bool associateCopyBufferSubData(const WebGLBuffer&amp; readBuffer, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr);</span>
  
      void disassociateBufferData();
  
<span class="line-modified">!     GCGLsizeiptr byteLength() const;</span>
      const RefPtr&lt;JSC::ArrayBuffer&gt; elementArrayBuffer() const { return m_elementArrayBuffer; }
  
      // Gets the cached max index for the given type if one has been set.
<span class="line-modified">!     Optional&lt;unsigned&gt; getCachedMaxIndex(GCGLenum type);</span>
      // Sets the cached max index for the given type.
<span class="line-modified">!     void setCachedMaxIndex(GCGLenum type, unsigned value);</span>
  
<span class="line-modified">!     GCGLenum getTarget() const { return m_target; }</span>
<span class="line-modified">!     void setTarget(GCGLenum);</span>
<span class="line-added">+ </span>
<span class="line-added">+     GCGLenum arrayBufferOrElementArrayBuffer() const { return m_arrayBufferOrElementArrayBuffer; }</span>
  
      bool hasEverBeenBound() const { return object() &amp;&amp; m_target; }
  
  protected:
      WebGLBuffer(WebGLRenderingContextBase&amp;);
  
<span class="line-modified">!     void deleteObjectImpl(GraphicsContextGLOpenGL*, PlatformGLObject) override;</span>
  
  private:
<span class="line-modified">!     GCGLenum m_target { 0 };</span>
  
      RefPtr&lt;JSC::ArrayBuffer&gt; m_elementArrayBuffer;
<span class="line-modified">!     GCGLsizeiptr m_byteLength { 0 };</span>
<span class="line-added">+ </span>
<span class="line-added">+     GCGLenum m_arrayBufferOrElementArrayBuffer { 0 };</span>
  
      // Optimization for index validation. For each type of index
      // (i.e., UNSIGNED_SHORT), cache the maximum index in the
      // entire buffer.
      //
      // This is sufficient to eliminate a lot of work upon each
      // draw call as long as all bound array buffers are at least
      // that size.
      struct MaxIndexCacheEntry {
<span class="line-modified">!         GCGLenum type;</span>
          unsigned maxIndex;
      };
      // OpenGL ES 2.0 only has two valid index types (UNSIGNED_BYTE
      // and UNSIGNED_SHORT) plus one extension (UNSIGNED_INT).
      MaxIndexCacheEntry m_maxIndexCache[4];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,13 ***</span>
  
      // Clears all of the cached max indices.
      void clearCachedMaxIndices();
  
      // Helper function called by the three associateBufferData().
<span class="line-modified">!     bool associateBufferDataImpl(const void* data, GC3Dsizeiptr byteLength);</span>
      // Helper function called by the two associateBufferSubData().
<span class="line-modified">!     bool associateBufferSubDataImpl(GC3Dintptr offset, const void* data, GC3Dsizeiptr byteLength);</span>
  };
  
  } // namespace WebCore
  
  #endif
<span class="line-new-header">--- 97,13 ---</span>
  
      // Clears all of the cached max indices.
      void clearCachedMaxIndices();
  
      // Helper function called by the three associateBufferData().
<span class="line-modified">!     bool associateBufferDataImpl(const void* data, GCGLsizeiptr byteLength);</span>
      // Helper function called by the two associateBufferSubData().
<span class="line-modified">!     bool associateBufferSubDataImpl(GCGLintptr offset, const void* data, GCGLsizeiptr byteLength);</span>
  };
  
  } // namespace WebCore
  
  #endif
</pre>
<center><a href="WebGLBuffer.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLCompressedTextureASTC.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
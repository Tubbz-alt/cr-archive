diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.cpp
@@ -31,10 +31,12 @@
 #include "ModuleScopeData.h"
 #include <wtf/Assertions.h>
 
 namespace JSC {
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);
+
 // ------------------------------ StatementNode --------------------------------
 
 void StatementNode::setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
 {
     m_lastLine = lastLine;
@@ -196,10 +198,11 @@
     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
         : Node(endLocation)
         , m_isInStrictContext(isInStrictContext)
         , m_superBinding(static_cast<unsigned>(superBinding))
         , m_constructorKind(static_cast<unsigned>(constructorKind))
+        , m_needsClassFieldInitializer(static_cast<unsigned>(NeedsClassFieldInitializer::No))
         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
         , m_parseMode(mode)
         , m_startColumn(startColumn)
         , m_endColumn(endColumn)
         , m_functionKeywordStart(functionKeywordStart)
@@ -219,10 +222,11 @@
     ConstructorKind constructorKind, SuperBinding superBinding, unsigned parameterCount, SourceParseMode mode, bool isArrowFunctionBodyExpression)
         : Node(endLocation)
         , m_isInStrictContext(isInStrictContext)
         , m_superBinding(static_cast<unsigned>(superBinding))
         , m_constructorKind(static_cast<unsigned>(constructorKind))
+        , m_needsClassFieldInitializer(static_cast<unsigned>(NeedsClassFieldInitializer::No))
         , m_isArrowFunctionBodyExpression(isArrowFunctionBodyExpression)
         , m_parseMode(mode)
         , m_startColumn(startColumn)
         , m_endColumn(endColumn)
         , m_functionKeywordStart(functionKeywordStart)
@@ -248,28 +252,28 @@
     m_endColumn = position.offset - position.lineStartOffset;
 }
 
 bool FunctionMetadataNode::operator==(const FunctionMetadataNode& other) const
 {
-    return m_parseMode== other.m_parseMode
+    return m_parseMode == other.m_parseMode
         && m_isInStrictContext == other.m_isInStrictContext
         && m_superBinding == other.m_superBinding
         && m_constructorKind == other.m_constructorKind
         && m_isArrowFunctionBodyExpression == other.m_isArrowFunctionBodyExpression
         && m_ident == other.m_ident
         && m_ecmaName == other.m_ecmaName
-        && m_functionMode== other.m_functionMode
-        && m_startColumn== other.m_startColumn
-        && m_endColumn== other.m_endColumn
-        && m_functionKeywordStart== other.m_functionKeywordStart
-        && m_functionNameStart== other.m_functionNameStart
-        && m_parametersStart== other.m_parametersStart
-        && m_source== other.m_source
-        && m_classSource== other.m_classSource
-        && m_startStartOffset== other.m_startStartOffset
-        && m_parameterCount== other.m_parameterCount
-        && m_lastLine== other.m_lastLine
+        && m_functionMode == other.m_functionMode
+        && m_startColumn == other.m_startColumn
+        && m_endColumn == other.m_endColumn
+        && m_functionKeywordStart == other.m_functionKeywordStart
+        && m_functionNameStart == other.m_functionNameStart
+        && m_parametersStart == other.m_parametersStart
+        && m_source == other.m_source
+        && m_classSource == other.m_classSource
+        && m_startStartOffset == other.m_startStartOffset
+        && m_parameterCount == other.m_parameterCount
+        && m_lastLine == other.m_lastLine
         && m_position == other.m_position;
 }
 
 void FunctionMetadataNode::dump(PrintStream& stream) const
 {
@@ -324,10 +328,35 @@
         list = list->m_next;
     }
     return false;
 }
 
+// FIXME: calculate this feature once when parsing the property list.
+// https://bugs.webkit.org/show_bug.cgi?id=206174
+bool PropertyListNode::shouldCreateLexicalScopeForClass(PropertyListNode* list)
+{
+    while (list) {
+        if (list->m_node->isComputedClassField())
+            return true;
+        list = list->m_next;
+    }
+    return false;
+}
+
+// ------------------------------ ClassExprNode -----------------------------
+
+// FIXME: calculate this feature once when parsing the property list.
+// https://bugs.webkit.org/show_bug.cgi?id=206174
+bool PropertyListNode::hasInstanceFields() const
+{
+    for (auto list = this; list; list = list->m_next) {
+        if (list->m_node->isInstanceClassField())
+            return true;
+    }
+    return false;
+}
+
 VariableEnvironmentNode::VariableEnvironmentNode(VariableEnvironment& lexicalVariables)
 {
     m_lexicalVariables.swap(lexicalVariables);
 }
 

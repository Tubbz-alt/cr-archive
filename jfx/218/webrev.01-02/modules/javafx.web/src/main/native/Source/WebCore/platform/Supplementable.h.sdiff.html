<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/Supplementable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StaticPasteboard.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapper.cmake.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/Supplementable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Supplementable_h
 27 #define Supplementable_h
 28 
 29 #include &lt;wtf/Assertions.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/MainThread.h&gt;
 32 
<span class="line-modified"> 33 #if !ASSERT_DISABLED</span>
 34 #include &lt;wtf/Threading.h&gt;
 35 #endif
 36 
 37 namespace WebCore {
 38 
 39 // What you should know about Supplementable and Supplement
 40 // ========================================================
 41 // Supplementable and Supplement instances are meant to be thread local. They
 42 // should only be accessed from within the thread that created them. The
 43 // 2 classes are not designed for safe access from another thread. Violating
 44 // this design assumption can result in memory corruption and unpredictable
 45 // behavior.
 46 //
 47 // What you should know about the Supplement keys
 48 // ==============================================
 49 // The Supplement is expected to use the same const char* string instance
 50 // as its key. The Supplementable&#39;s SupplementMap will use the address of the
 51 // string as the key and not the characters themselves. Hence, 2 strings with
 52 // the same characters will be treated as 2 different keys.
 53 //
</pre>
<hr />
<pre>
 61 //
 62 //     const char* MyClass::supplementName()
 63 //     {
 64 //         return &quot;MyClass&quot;;
 65 //     }
 66 //
 67 // An example of the using the key:
 68 //
 69 //     MyClass* MyClass::from(MySupplementable* host)
 70 //     {
 71 //         return reinterpret_cast&lt;MyClass*&gt;(Supplement&lt;MySupplementable&gt;::from(host, supplementName()));
 72 //     }
 73 
 74 template&lt;typename T&gt;
 75 class Supplementable;
 76 
 77 template&lt;typename T&gt;
 78 class Supplement {
 79 public:
 80     virtual ~Supplement() = default;
<span class="line-modified"> 81 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 82     virtual bool isRefCountedWrapper() const { return false; }
 83 #endif
 84 
 85     static void provideTo(Supplementable&lt;T&gt;* host, const char* key, std::unique_ptr&lt;Supplement&lt;T&gt;&gt; supplement)
 86     {
 87         host-&gt;provideSupplement(key, WTFMove(supplement));
 88     }
 89 
 90     static Supplement&lt;T&gt;* from(Supplementable&lt;T&gt;* host, const char* key)
 91     {
 92         return host ? host-&gt;requireSupplement(key) : 0;
 93     }
 94 };
 95 
 96 template&lt;typename T&gt;
 97 class Supplementable {
 98 public:
 99     void provideSupplement(const char* key, std::unique_ptr&lt;Supplement&lt;T&gt;&gt; supplement)
100     {
<span class="line-modified">101         ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
102         ASSERT(!m_supplements.get(key));
103         m_supplements.set(key, WTFMove(supplement));
104     }
105 
106     void removeSupplement(const char* key)
107     {
<span class="line-modified">108         ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
109         m_supplements.remove(key);
110     }
111 
112     Supplement&lt;T&gt;* requireSupplement(const char* key)
113     {
<span class="line-modified">114         ASSERT(canAccessThreadLocalDataForThread(m_thread.get()));</span>
115         return m_supplements.get(key);
116     }
117 
<span class="line-modified">118 #if !ASSERT_DISABLED</span>
119 protected:
120     Supplementable() = default;
121 #endif
122 
123 private:
124     typedef HashMap&lt;const char*, std::unique_ptr&lt;Supplement&lt;T&gt;&gt;, PtrHash&lt;const char*&gt;&gt; SupplementMap;
125     SupplementMap m_supplements;
<span class="line-modified">126 #if !ASSERT_DISABLED</span>
127     Ref&lt;Thread&gt; m_thread { Thread::current() };
128 #endif
129 };
130 
131 } // namespace WebCore
132 
133 #endif // Supplementable_h
134 
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef Supplementable_h
 27 #define Supplementable_h
 28 
 29 #include &lt;wtf/Assertions.h&gt;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/MainThread.h&gt;
 32 
<span class="line-modified"> 33 #if ASSERT_ENABLED</span>
 34 #include &lt;wtf/Threading.h&gt;
 35 #endif
 36 
 37 namespace WebCore {
 38 
 39 // What you should know about Supplementable and Supplement
 40 // ========================================================
 41 // Supplementable and Supplement instances are meant to be thread local. They
 42 // should only be accessed from within the thread that created them. The
 43 // 2 classes are not designed for safe access from another thread. Violating
 44 // this design assumption can result in memory corruption and unpredictable
 45 // behavior.
 46 //
 47 // What you should know about the Supplement keys
 48 // ==============================================
 49 // The Supplement is expected to use the same const char* string instance
 50 // as its key. The Supplementable&#39;s SupplementMap will use the address of the
 51 // string as the key and not the characters themselves. Hence, 2 strings with
 52 // the same characters will be treated as 2 different keys.
 53 //
</pre>
<hr />
<pre>
 61 //
 62 //     const char* MyClass::supplementName()
 63 //     {
 64 //         return &quot;MyClass&quot;;
 65 //     }
 66 //
 67 // An example of the using the key:
 68 //
 69 //     MyClass* MyClass::from(MySupplementable* host)
 70 //     {
 71 //         return reinterpret_cast&lt;MyClass*&gt;(Supplement&lt;MySupplementable&gt;::from(host, supplementName()));
 72 //     }
 73 
 74 template&lt;typename T&gt;
 75 class Supplementable;
 76 
 77 template&lt;typename T&gt;
 78 class Supplement {
 79 public:
 80     virtual ~Supplement() = default;
<span class="line-modified"> 81 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 82     virtual bool isRefCountedWrapper() const { return false; }
 83 #endif
 84 
 85     static void provideTo(Supplementable&lt;T&gt;* host, const char* key, std::unique_ptr&lt;Supplement&lt;T&gt;&gt; supplement)
 86     {
 87         host-&gt;provideSupplement(key, WTFMove(supplement));
 88     }
 89 
 90     static Supplement&lt;T&gt;* from(Supplementable&lt;T&gt;* host, const char* key)
 91     {
 92         return host ? host-&gt;requireSupplement(key) : 0;
 93     }
 94 };
 95 
 96 template&lt;typename T&gt;
 97 class Supplementable {
 98 public:
 99     void provideSupplement(const char* key, std::unique_ptr&lt;Supplement&lt;T&gt;&gt; supplement)
100     {
<span class="line-modified">101         ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
102         ASSERT(!m_supplements.get(key));
103         m_supplements.set(key, WTFMove(supplement));
104     }
105 
106     void removeSupplement(const char* key)
107     {
<span class="line-modified">108         ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
109         m_supplements.remove(key);
110     }
111 
112     Supplement&lt;T&gt;* requireSupplement(const char* key)
113     {
<span class="line-modified">114         ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));</span>
115         return m_supplements.get(key);
116     }
117 
<span class="line-modified">118 #if ASSERT_ENABLED</span>
119 protected:
120     Supplementable() = default;
121 #endif
122 
123 private:
124     typedef HashMap&lt;const char*, std::unique_ptr&lt;Supplement&lt;T&gt;&gt;, PtrHash&lt;const char*&gt;&gt; SupplementMap;
125     SupplementMap m_supplements;
<span class="line-modified">126 #if ASSERT_ENABLED</span>
127     Ref&lt;Thread&gt; m_thread { Thread::current() };
128 #endif
129 };
130 
131 } // namespace WebCore
132 
133 #endif // Supplementable_h
134 
</pre>
</td>
</tr>
</table>
<center><a href="StaticPasteboard.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TextureMapper.cmake.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLDocumentParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google, Inc. All Rights Reserved.
  3  * Copyright (C) 2015 Apple Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;HTMLInputStream.h&quot;
 30 #include &quot;HTMLScriptRunnerHost.h&quot;
 31 #include &quot;HTMLSourceTracker.h&quot;
 32 #include &quot;HTMLTokenizer.h&quot;
 33 #include &quot;PendingScriptClient.h&quot;
 34 #include &quot;ScriptableDocumentParser.h&quot;
 35 #include &quot;XSSAuditor.h&quot;
 36 #include &quot;XSSAuditorDelegate.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 class DocumentFragment;
 41 class Element;
 42 class HTMLDocument;
 43 class HTMLParserScheduler;
 44 class HTMLPreloadScanner;
 45 class HTMLScriptRunner;
 46 class HTMLTreeBuilder;
 47 class HTMLResourcePreloader;
 48 class PumpSession;
 49 
<a name="1" id="anc1"></a><span class="line-added"> 50 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(HTMLDocumentParser);</span>
 51 class HTMLDocumentParser : public ScriptableDocumentParser, private HTMLScriptRunnerHost, private PendingScriptClient {
<a name="2" id="anc2"></a><span class="line-modified"> 52     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(HTMLDocumentParser);</span>
 53 public:
 54     static Ref&lt;HTMLDocumentParser&gt; create(HTMLDocument&amp;);
 55     virtual ~HTMLDocumentParser();
 56 
 57     static void parseDocumentFragment(const String&amp;, DocumentFragment&amp;, Element&amp; contextElement, ParserContentPolicy = AllowScriptingContent);
 58 
 59     // For HTMLParserScheduler.
 60     void resumeParsingAfterYield();
 61 
 62     // For HTMLTreeBuilder.
 63     HTMLTokenizer&amp; tokenizer();
 64     TextPosition textPosition() const final;
 65 
 66 protected:
 67     explicit HTMLDocumentParser(HTMLDocument&amp;);
 68 
 69     void insert(SegmentedString&amp;&amp;) final;
 70     void append(RefPtr&lt;StringImpl&gt;&amp;&amp;) override;
 71     void finish() override;
 72 
 73     HTMLTreeBuilder&amp; treeBuilder();
 74 
 75 private:
 76     HTMLDocumentParser(DocumentFragment&amp;, Element&amp; contextElement, ParserContentPolicy);
 77     static Ref&lt;HTMLDocumentParser&gt; create(DocumentFragment&amp;, Element&amp; contextElement, ParserContentPolicy);
 78 
 79     // DocumentParser
 80     void detach() final;
 81     bool hasInsertionPoint() final;
 82     bool processingData() const final;
 83     void prepareToStopParsing() final;
 84     void stopParsing() final;
 85     bool isWaitingForScripts() const override;
 86     bool isExecutingScript() const final;
 87     bool hasScriptsWaitingForStylesheets() const final;
 88     void executeScriptsWaitingForStylesheets() final;
 89     void suspendScheduledTasks() final;
 90     void resumeScheduledTasks() final;
 91 
 92     bool shouldAssociateConsoleMessagesWithTextPosition() const final;
 93 
 94     // HTMLScriptRunnerHost
 95     void watchForLoad(PendingScript&amp;) final;
 96     void stopWatchingForLoad(PendingScript&amp;) final;
 97     HTMLInputStream&amp; inputStream() final;
 98     bool hasPreloadScanner() const final;
 99     void appendCurrentInputStreamToPreloadScannerAndScan() final;
100 
101     // PendingScriptClient
102     void notifyFinished(PendingScript&amp;) final;
103 
104     Document* contextForParsingSession();
105 
106     enum SynchronousMode { AllowYield, ForceSynchronous };
107     void pumpTokenizer(SynchronousMode);
108     bool pumpTokenizerLoop(SynchronousMode, bool parsingFragment, PumpSession&amp;);
109     void pumpTokenizerIfPossible(SynchronousMode);
110     void constructTreeFromHTMLToken(HTMLTokenizer::TokenPtr&amp;);
111 
112     void runScriptsForPausedTreeBuilder();
113     void resumeParsingAfterScriptExecution();
114 
115     void attemptToEnd();
116     void endIfDelayed();
117     void attemptToRunDeferredScriptsAndEnd();
118     void end();
119 
120     bool isParsingFragment() const;
121     bool isScheduledForResume() const;
122     bool inPumpSession() const;
123     bool shouldDelayEnd() const;
124 
125     void didBeginYieldingParser() final;
126     void didEndYieldingParser() final;
127 
128     HTMLParserOptions m_options;
129     HTMLInputStream m_input;
130 
131     HTMLTokenizer m_tokenizer;
132     std::unique_ptr&lt;HTMLScriptRunner&gt; m_scriptRunner;
133     std::unique_ptr&lt;HTMLTreeBuilder&gt; m_treeBuilder;
134     std::unique_ptr&lt;HTMLPreloadScanner&gt; m_preloadScanner;
135     std::unique_ptr&lt;HTMLPreloadScanner&gt; m_insertionPreloadScanner;
136     std::unique_ptr&lt;HTMLParserScheduler&gt; m_parserScheduler;
137     HTMLSourceTracker m_sourceTracker;
138     TextPosition m_textPosition;
139     XSSAuditor m_xssAuditor;
140     XSSAuditorDelegate m_xssAuditorDelegate;
141 
142     std::unique_ptr&lt;HTMLResourcePreloader&gt; m_preloader;
143 
144     bool m_endWasDelayed { false };
145     unsigned m_pumpSessionNestingLevel { 0 };
146 };
147 
148 inline HTMLTokenizer&amp; HTMLDocumentParser::tokenizer()
149 {
150     return m_tokenizer;
151 }
152 
153 inline HTMLInputStream&amp; HTMLDocumentParser::inputStream()
154 {
155     return m_input;
156 }
157 
158 inline bool HTMLDocumentParser::hasPreloadScanner() const
159 {
160     return m_preloadScanner.get();
161 }
162 
163 inline HTMLTreeBuilder&amp; HTMLDocumentParser::treeBuilder()
164 {
165     ASSERT(m_treeBuilder);
166     return *m_treeBuilder;
167 }
168 
169 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
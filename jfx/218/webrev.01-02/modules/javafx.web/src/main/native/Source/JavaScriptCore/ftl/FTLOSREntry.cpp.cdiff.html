<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSREntry.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLLowerDFGToB3.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOSREntry.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,52 ***</span>
  
  namespace JSC { namespace FTL {
  
  SUPPRESS_ASAN
  void* prepareOSREntry(
<span class="line-modified">!     ExecState* exec, CodeBlock* dfgCodeBlock, CodeBlock* entryCodeBlock,</span>
<span class="line-modified">!     unsigned bytecodeIndex, unsigned streamIndex)</span>
  {
<span class="line-removed">-     VM&amp; vm = exec-&gt;vm();</span>
      CodeBlock* baseline = dfgCodeBlock-&gt;baselineVersion();
      ExecutableBase* executable = dfgCodeBlock-&gt;ownerExecutable();
      DFG::JITCode* dfgCode = dfgCodeBlock-&gt;jitCode()-&gt;dfg();
      ForOSREntryJITCode* entryCode = entryCodeBlock-&gt;jitCode()-&gt;ftlForOSREntry();
  
      if (!entryCode-&gt;dfgCommon()-&gt;isStillValid) {
          dfgCode-&gt;clearOSREntryBlockAndResetThresholds(dfgCodeBlock);
          return 0;
      }
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-modified">!             &quot;FTL OSR from &quot;, *dfgCodeBlock, &quot; to &quot;, *entryCodeBlock, &quot; at bc#&quot;,</span>
<span class="line-removed">-             bytecodeIndex, &quot;.\n&quot;);</span>
<span class="line-removed">-     }</span>
  
      if (bytecodeIndex)
          jsCast&lt;ScriptExecutable*&gt;(executable)-&gt;setDidTryToEnterInLoop(true);
  
      if (bytecodeIndex != entryCode-&gt;bytecodeIndex()) {
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;    OSR failed because we don&#39;t have an entrypoint for bc#&quot;, bytecodeIndex, &quot;; ours is for bc#&quot;, entryCode-&gt;bytecodeIndex(), &quot;\n&quot;);</span>
          return 0;
      }
  
      Operands&lt;Optional&lt;JSValue&gt;&gt; values;
<span class="line-modified">!     dfgCode-&gt;reconstruct(</span>
<span class="line-removed">-         exec, dfgCodeBlock, CodeOrigin(bytecodeIndex), streamIndex, values);</span>
  
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(&quot;    Values at entry: &quot;, values, &quot;\n&quot;);</span>
  
      for (int argument = values.numberOfArguments(); argument--;) {
<span class="line-modified">!         JSValue valueOnStack = exec-&gt;r(virtualRegisterForArgument(argument).offset()).asanUnsafeJSValue();</span>
          Optional&lt;JSValue&gt; reconstructedValue = values.argument(argument);
          if ((reconstructedValue &amp;&amp; valueOnStack == reconstructedValue.value()) || !argument)
              continue;
<span class="line-modified">!         dataLog(&quot;Mismatch between reconstructed values and the value on the stack for argument arg&quot;, argument, &quot; for &quot;, *entryCodeBlock, &quot; at bc#&quot;, bytecodeIndex, &quot;:\n&quot;);</span>
          dataLog(&quot;    Value on stack: &quot;, valueOnStack, &quot;\n&quot;);
          dataLog(&quot;    Reconstructed value: &quot;, reconstructedValue, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
<span class="line-new-header">--- 38,46 ---</span>
  
  namespace JSC { namespace FTL {
  
  SUPPRESS_ASAN
  void* prepareOSREntry(
<span class="line-modified">!     VM&amp; vm, CallFrame* callFrame, CodeBlock* dfgCodeBlock, CodeBlock* entryCodeBlock,</span>
<span class="line-modified">!     BytecodeIndex bytecodeIndex, unsigned streamIndex)</span>
  {
      CodeBlock* baseline = dfgCodeBlock-&gt;baselineVersion();
      ExecutableBase* executable = dfgCodeBlock-&gt;ownerExecutable();
      DFG::JITCode* dfgCode = dfgCodeBlock-&gt;jitCode()-&gt;dfg();
      ForOSREntryJITCode* entryCode = entryCodeBlock-&gt;jitCode()-&gt;ftlForOSREntry();
  
      if (!entryCode-&gt;dfgCommon()-&gt;isStillValid) {
          dfgCode-&gt;clearOSREntryBlockAndResetThresholds(dfgCodeBlock);
          return 0;
      }
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         &quot;FTL OSR from &quot;, *dfgCodeBlock, &quot; to &quot;, *entryCodeBlock, &quot; at &quot;,</span>
<span class="line-modified">!         bytecodeIndex);</span>
  
      if (bytecodeIndex)
          jsCast&lt;ScriptExecutable*&gt;(executable)-&gt;setDidTryToEnterInLoop(true);
  
      if (bytecodeIndex != entryCode-&gt;bytecodeIndex()) {
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because we don&#39;t have an entrypoint for &quot;, bytecodeIndex, &quot;; ours is for &quot;, entryCode-&gt;bytecodeIndex());</span>
          return 0;
      }
  
      Operands&lt;Optional&lt;JSValue&gt;&gt; values;
<span class="line-modified">!     dfgCode-&gt;reconstruct(callFrame, dfgCodeBlock, CodeOrigin(bytecodeIndex), streamIndex, values);</span>
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;    Values at entry: &quot;, values);</span>
  
      for (int argument = values.numberOfArguments(); argument--;) {
<span class="line-modified">!         JSValue valueOnStack = callFrame-&gt;r(virtualRegisterForArgumentIncludingThis(argument)).asanUnsafeJSValue();</span>
          Optional&lt;JSValue&gt; reconstructedValue = values.argument(argument);
          if ((reconstructedValue &amp;&amp; valueOnStack == reconstructedValue.value()) || !argument)
              continue;
<span class="line-modified">!         dataLog(&quot;Mismatch between reconstructed values and the value on the stack for argument arg&quot;, argument, &quot; for &quot;, *entryCodeBlock, &quot; at &quot;, bytecodeIndex, &quot;:\n&quot;);</span>
          dataLog(&quot;    Value on stack: &quot;, valueOnStack, &quot;\n&quot;);
          dataLog(&quot;    Reconstructed value: &quot;, reconstructedValue, &quot;\n&quot;);
          RELEASE_ASSERT_NOT_REACHED();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,21 ***</span>
          else
              scratch[local] = JSValue::encode(JSValue());
      }
  
      int stackFrameSize = entryCode-&gt;common.requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;exec-&gt;registers()[virtualRegisterForLocal(stackFrameSize - 1).offset()]))) {</span>
<span class="line-modified">!         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLog(&quot;    OSR failed because stack growth failed.\n&quot;);</span>
          return 0;
      }
  
<span class="line-modified">!     exec-&gt;setCodeBlock(entryCodeBlock);</span>
  
      void* result = entryCode-&gt;addressForCall(ArityCheckNotRequired).executableAddress();
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(&quot;    Entry will succeed, going to address &quot;, RawPointer(result), &quot;\n&quot;);</span>
  
      return result;
  }
  
  } } // namespace JSC::FTL
<span class="line-new-header">--- 94,19 ---</span>
          else
              scratch[local] = JSValue::encode(JSValue());
      }
  
      int stackFrameSize = entryCode-&gt;common.requiredRegisterCountForExecutionAndExit();
<span class="line-modified">!     if (UNLIKELY(!vm.ensureStackCapacityFor(&amp;callFrame-&gt;registers()[virtualRegisterForLocal(stackFrameSize - 1).offset()]))) {</span>
<span class="line-modified">!         dataLogLnIf(Options::verboseOSR(), &quot;    OSR failed because stack growth failed.&quot;);</span>
          return 0;
      }
  
<span class="line-modified">!     callFrame-&gt;setCodeBlock(entryCodeBlock);</span>
  
      void* result = entryCode-&gt;addressForCall(ArityCheckNotRequired).executableAddress();
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;    Entry will succeed, going to address &quot;, RawPointer(result));</span>
  
      return result;
  }
  
  } } // namespace JSC::FTL
</pre>
<center><a href="FTLLowerDFGToB3.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOSREntry.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
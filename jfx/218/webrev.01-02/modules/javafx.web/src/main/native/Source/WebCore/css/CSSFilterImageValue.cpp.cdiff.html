<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSFilterImageValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSCustomPropertyValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFilterImageValue.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSFilterImageValue.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,12 ***</span>
  #include &quot;CachedImage.h&quot;
  #include &quot;CachedResourceLoader.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;ImageBuffer.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;StyleCachedImage.h&quot;
<span class="line-removed">- #include &quot;StyleResolver.h&quot;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  CSSFilterImageValue::~CSSFilterImageValue()
<span class="line-new-header">--- 31,12 ---</span>
  #include &quot;CachedImage.h&quot;
  #include &quot;CachedResourceLoader.h&quot;
  #include &quot;GraphicsContext.h&quot;
  #include &quot;ImageBuffer.h&quot;
  #include &quot;RenderElement.h&quot;
<span class="line-added">+ #include &quot;StyleBuilderState.h&quot;</span>
  #include &quot;StyleCachedImage.h&quot;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  
  CSSFilterImageValue::~CSSFilterImageValue()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 48,23 ***</span>
  String CSSFilterImageValue::customCSSText() const
  {
      return makeString(&quot;filter(&quot;, m_imageValue-&gt;cssText(), &quot;, &quot;, m_filterValue-&gt;cssText(), &#39;)&#39;);
  }
  
<span class="line-modified">! FloatSize CSSFilterImageValue::fixedSize(const RenderElement* renderer)</span>
  {
      // FIXME: Skip Content Security Policy check when filter is applied to an element in a user agent shadow tree.
      // See &lt;https://bugs.webkit.org/show_bug.cgi?id=146663&gt;.
      ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
  
<span class="line-modified">!     CachedResourceLoader&amp; cachedResourceLoader = renderer-&gt;document().cachedResourceLoader();</span>
      CachedImage* cachedImage = cachedImageForCSSValue(m_imageValue, cachedResourceLoader, options);
  
      if (!cachedImage)
          return FloatSize();
  
<span class="line-modified">!     return cachedImage-&gt;imageForRenderer(renderer)-&gt;size();</span>
  }
  
  bool CSSFilterImageValue::isPending() const
  {
      return CSSImageGeneratorValue::subimageIsPending(m_imageValue);
<span class="line-new-header">--- 48,23 ---</span>
  String CSSFilterImageValue::customCSSText() const
  {
      return makeString(&quot;filter(&quot;, m_imageValue-&gt;cssText(), &quot;, &quot;, m_filterValue-&gt;cssText(), &#39;)&#39;);
  }
  
<span class="line-modified">! FloatSize CSSFilterImageValue::fixedSize(const RenderElement&amp; renderer)</span>
  {
      // FIXME: Skip Content Security Policy check when filter is applied to an element in a user agent shadow tree.
      // See &lt;https://bugs.webkit.org/show_bug.cgi?id=146663&gt;.
      ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
  
<span class="line-modified">!     CachedResourceLoader&amp; cachedResourceLoader = renderer.document().cachedResourceLoader();</span>
      CachedImage* cachedImage = cachedImageForCSSValue(m_imageValue, cachedResourceLoader, options);
  
      if (!cachedImage)
          return FloatSize();
  
<span class="line-modified">!     return cachedImage-&gt;imageForRenderer(&amp;renderer)-&gt;size();</span>
  }
  
  bool CSSFilterImageValue::isPending() const
  {
      return CSSImageGeneratorValue::subimageIsPending(m_imageValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,42 ***</span>
      }
  
      m_filterSubimageObserver.setReady(true);
  }
  
<span class="line-modified">! RefPtr&lt;Image&gt; CSSFilterImageValue::image(RenderElement* renderer, const FloatSize&amp; size)</span>
  {
<span class="line-removed">-     ASSERT(renderer);</span>
<span class="line-removed">- </span>
      if (size.isEmpty())
          return nullptr;
  
      // FIXME: Skip Content Security Policy check when filter is applied to an element in a user agent shadow tree.
      // See &lt;https://bugs.webkit.org/show_bug.cgi?id=146663&gt;.
      ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
<span class="line-modified">!     auto* cachedImage = cachedImageForCSSValue(m_imageValue, renderer-&gt;document().cachedResourceLoader(), options);</span>
      if (!cachedImage)
          return &amp;Image::nullImage();
  
<span class="line-modified">!     auto* image = cachedImage-&gt;imageForRenderer(renderer);</span>
      if (!image)
          return &amp;Image::nullImage();
  
      // Transform Image into ImageBuffer.
      // FIXME (149424): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">!     auto texture = ImageBuffer::create(size, Unaccelerated);</span>
      if (!texture)
          return &amp;Image::nullImage();
  
      auto imageRect = FloatRect { { }, size };
      texture-&gt;context().drawImage(*image, imageRect);
  
      auto cssFilter = CSSFilter::create();
      cssFilter-&gt;setSourceImage(WTFMove(texture));
      cssFilter-&gt;setSourceImageRect(imageRect);
      cssFilter-&gt;setFilterRegion(imageRect);
<span class="line-modified">!     if (!cssFilter-&gt;build(*renderer, m_filterOperations, FilterConsumer::FilterFunction))</span>
          return &amp;Image::nullImage();
      cssFilter-&gt;apply();
  
      return cssFilter-&gt;output()-&gt;copyImage();
  }
<span class="line-new-header">--- 96,40 ---</span>
      }
  
      m_filterSubimageObserver.setReady(true);
  }
  
<span class="line-modified">! RefPtr&lt;Image&gt; CSSFilterImageValue::image(RenderElement&amp; renderer, const FloatSize&amp; size)</span>
  {
      if (size.isEmpty())
          return nullptr;
  
      // FIXME: Skip Content Security Policy check when filter is applied to an element in a user agent shadow tree.
      // See &lt;https://bugs.webkit.org/show_bug.cgi?id=146663&gt;.
      ResourceLoaderOptions options = CachedResourceLoader::defaultCachedResourceOptions();
<span class="line-modified">!     auto* cachedImage = cachedImageForCSSValue(m_imageValue, renderer.document().cachedResourceLoader(), options);</span>
      if (!cachedImage)
          return &amp;Image::nullImage();
  
<span class="line-modified">!     auto* image = cachedImage-&gt;imageForRenderer(&amp;renderer);</span>
      if (!image)
          return &amp;Image::nullImage();
  
      // Transform Image into ImageBuffer.
      // FIXME (149424): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">!     auto texture = ImageBuffer::create(size, RenderingMode::Unaccelerated);</span>
      if (!texture)
          return &amp;Image::nullImage();
  
      auto imageRect = FloatRect { { }, size };
      texture-&gt;context().drawImage(*image, imageRect);
  
      auto cssFilter = CSSFilter::create();
      cssFilter-&gt;setSourceImage(WTFMove(texture));
      cssFilter-&gt;setSourceImageRect(imageRect);
      cssFilter-&gt;setFilterRegion(imageRect);
<span class="line-modified">!     if (!cssFilter-&gt;build(renderer, m_filterOperations, FilterConsumer::FilterFunction))</span>
          return &amp;Image::nullImage();
      cssFilter-&gt;apply();
  
      return cssFilter-&gt;output()-&gt;copyImage();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,14 ***</span>
  {
      for (auto&amp; client : clients())
          client.key-&gt;imageChanged(static_cast&lt;WrappedImagePtr&gt;(this));
  }
  
<span class="line-modified">! void CSSFilterImageValue::createFilterOperations(StyleResolver* resolver)</span>
  {
      m_filterOperations.clear();
<span class="line-modified">!     resolver-&gt;createFilterOperations(m_filterValue, m_filterOperations);</span>
  }
  
  void CSSFilterImageValue::FilterSubimageObserverProxy::imageChanged(CachedImage*, const IntRect* rect)
  {
      if (m_ready)
<span class="line-new-header">--- 138,14 ---</span>
  {
      for (auto&amp; client : clients())
          client.key-&gt;imageChanged(static_cast&lt;WrappedImagePtr&gt;(this));
  }
  
<span class="line-modified">! void CSSFilterImageValue::createFilterOperations(Style::BuilderState&amp; builderState)</span>
  {
      m_filterOperations.clear();
<span class="line-modified">!     builderState.createFilterOperations(m_filterValue, m_filterOperations);</span>
  }
  
  void CSSFilterImageValue::FilterSubimageObserverProxy::imageChanged(CachedImage*, const IntRect* rect)
  {
      if (m_ready)
</pre>
<center><a href="CSSCustomPropertyValue.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFilterImageValue.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLDocumentParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google, Inc. All Rights Reserved.
  3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;HTMLDocumentParser.h&quot;
 29 
 30 #include &quot;CustomHeaderFields.h&quot;
 31 #include &quot;CustomElementReactionQueue.h&quot;
 32 #include &quot;DocumentFragment.h&quot;
 33 #include &quot;DocumentLoader.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 34 #include &quot;EventLoop.h&quot;</span>
 35 #include &quot;Frame.h&quot;
 36 #include &quot;HTMLDocument.h&quot;
 37 #include &quot;HTMLParserScheduler.h&quot;
 38 #include &quot;HTMLPreloadScanner.h&quot;
 39 #include &quot;HTMLScriptRunner.h&quot;
 40 #include &quot;HTMLTreeBuilder.h&quot;
 41 #include &quot;HTMLUnknownElement.h&quot;
 42 #include &quot;JSCustomElementInterface.h&quot;
 43 #include &quot;LinkLoader.h&quot;
<a name="2" id="anc2"></a>
 44 #include &quot;NavigationScheduler.h&quot;
 45 #include &quot;ScriptElement.h&quot;
 46 #include &quot;ThrowOnDynamicMarkupInsertionCountIncrementer.h&quot;
 47 
 48 namespace WebCore {
 49 
 50 using namespace HTMLNames;
 51 
<a name="3" id="anc3"></a><span class="line-added"> 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(HTMLDocumentParser);</span>
<span class="line-added"> 53 </span>
 54 HTMLDocumentParser::HTMLDocumentParser(HTMLDocument&amp; document)
 55     : ScriptableDocumentParser(document)
 56     , m_options(document)
 57     , m_tokenizer(m_options)
 58     , m_scriptRunner(makeUnique&lt;HTMLScriptRunner&gt;(document, static_cast&lt;HTMLScriptRunnerHost&amp;&gt;(*this)))
 59     , m_treeBuilder(makeUnique&lt;HTMLTreeBuilder&gt;(*this, document, parserContentPolicy(), m_options))
 60     , m_parserScheduler(makeUnique&lt;HTMLParserScheduler&gt;(*this))
 61     , m_xssAuditorDelegate(document)
 62     , m_preloader(makeUnique&lt;HTMLResourcePreloader&gt;(document))
 63 {
 64 }
 65 
 66 Ref&lt;HTMLDocumentParser&gt; HTMLDocumentParser::create(HTMLDocument&amp; document)
 67 {
 68     return adoptRef(*new HTMLDocumentParser(document));
 69 }
 70 
 71 inline HTMLDocumentParser::HTMLDocumentParser(DocumentFragment&amp; fragment, Element&amp; contextElement, ParserContentPolicy rawPolicy)
 72     : ScriptableDocumentParser(fragment.document(), rawPolicy)
 73     , m_options(fragment.document())
 74     , m_tokenizer(m_options)
 75     , m_treeBuilder(makeUnique&lt;HTMLTreeBuilder&gt;(*this, fragment, contextElement, parserContentPolicy(), m_options))
 76     , m_xssAuditorDelegate(fragment.document())
 77 {
 78     // https://html.spec.whatwg.org/multipage/syntax.html#parsing-html-fragments
 79     if (contextElement.isHTMLElement())
 80         m_tokenizer.updateStateFor(contextElement.tagQName().localName());
 81     m_xssAuditor.initForFragment();
 82 }
 83 
 84 inline Ref&lt;HTMLDocumentParser&gt; HTMLDocumentParser::create(DocumentFragment&amp; fragment, Element&amp; contextElement, ParserContentPolicy parserContentPolicy)
 85 {
 86     return adoptRef(*new HTMLDocumentParser(fragment, contextElement, parserContentPolicy));
 87 }
 88 
 89 HTMLDocumentParser::~HTMLDocumentParser()
 90 {
 91     ASSERT(!m_parserScheduler);
 92     ASSERT(!m_pumpSessionNestingLevel);
 93     ASSERT(!m_preloadScanner);
 94     ASSERT(!m_insertionPreloadScanner);
 95 }
 96 
 97 void HTMLDocumentParser::detach()
 98 {
 99     ScriptableDocumentParser::detach();
100 
101     if (m_scriptRunner)
102         m_scriptRunner-&gt;detach();
103     // FIXME: It seems wrong that we would have a preload scanner here.
104     // Yet during fast/dom/HTMLScriptElement/script-load-events.html we do.
105     m_preloadScanner = nullptr;
106     m_insertionPreloadScanner = nullptr;
107     m_parserScheduler = nullptr; // Deleting the scheduler will clear any timers.
108 }
109 
110 void HTMLDocumentParser::stopParsing()
111 {
112     DocumentParser::stopParsing();
113     m_parserScheduler = nullptr; // Deleting the scheduler will clear any timers.
114 }
115 
116 // This kicks off &quot;Once the user agent stops parsing&quot; as described by:
117 // https://html.spec.whatwg.org/multipage/syntax.html#the-end
118 void HTMLDocumentParser::prepareToStopParsing()
119 {
120     ASSERT(!hasInsertionPoint());
121 
122     // pumpTokenizer can cause this parser to be detached from the Document,
123     // but we need to ensure it isn&#39;t deleted yet.
124     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
125 
126     // NOTE: This pump should only ever emit buffered character tokens,
127     // so ForceSynchronous vs. AllowYield should be meaningless.
128     pumpTokenizerIfPossible(ForceSynchronous);
129 
130     if (isStopped())
131         return;
132 
133     DocumentParser::prepareToStopParsing();
134 
135     // We will not have a scriptRunner when parsing a DocumentFragment.
136     if (m_scriptRunner)
137         document()-&gt;setReadyState(Document::Interactive);
138 
139     // Setting the ready state above can fire mutation event and detach us
140     // from underneath. In that case, just bail out.
141     if (isDetached())
142         return;
143 
144     attemptToRunDeferredScriptsAndEnd();
145 }
146 
147 inline bool HTMLDocumentParser::inPumpSession() const
148 {
149     return m_pumpSessionNestingLevel &gt; 0;
150 }
151 
152 inline bool HTMLDocumentParser::shouldDelayEnd() const
153 {
154     return inPumpSession() || isWaitingForScripts() || isScheduledForResume() || isExecutingScript();
155 }
156 
157 void HTMLDocumentParser::didBeginYieldingParser()
158 {
159     m_parserScheduler-&gt;didBeginYieldingParser();
160 }
161 
162 void HTMLDocumentParser::didEndYieldingParser()
163 {
164     m_parserScheduler-&gt;didEndYieldingParser();
165 }
166 
167 bool HTMLDocumentParser::isParsingFragment() const
168 {
169     return m_treeBuilder-&gt;isParsingFragment();
170 }
171 
172 bool HTMLDocumentParser::processingData() const
173 {
174     return isScheduledForResume() || inPumpSession();
175 }
176 
177 void HTMLDocumentParser::pumpTokenizerIfPossible(SynchronousMode mode)
178 {
179     if (isStopped() || isWaitingForScripts())
180         return;
181 
182     // Once a resume is scheduled, HTMLParserScheduler controls when we next pump.
183     if (isScheduledForResume()) {
184         ASSERT(mode == AllowYield);
185         return;
186     }
187 
188     pumpTokenizer(mode);
189 }
190 
191 bool HTMLDocumentParser::isScheduledForResume() const
192 {
193     return m_parserScheduler &amp;&amp; m_parserScheduler-&gt;isScheduledForResume();
194 }
195 
196 // Used by HTMLParserScheduler
197 void HTMLDocumentParser::resumeParsingAfterYield()
198 {
199     // pumpTokenizer can cause this parser to be detached from the Document,
200     // but we need to ensure it isn&#39;t deleted yet.
201     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
202 
203     // We should never be here unless we can pump immediately.
204     // Call pumpTokenizer() directly so that ASSERTS will fire if we&#39;re wrong.
205     pumpTokenizer(AllowYield);
206     endIfDelayed();
207 }
208 
209 void HTMLDocumentParser::runScriptsForPausedTreeBuilder()
210 {
211     ASSERT(scriptingContentIsAllowed(parserContentPolicy()));
212 
213     if (std::unique_ptr&lt;CustomElementConstructionData&gt; constructionData = m_treeBuilder-&gt;takeCustomElementConstructionData()) {
214         ASSERT(!m_treeBuilder-&gt;hasParserBlockingScriptWork());
215 
216         // https://html.spec.whatwg.org/#create-an-element-for-the-token
217         {
218             // Prevent document.open/write during reactions by allocating the incrementer before the reactions stack.
219             ThrowOnDynamicMarkupInsertionCountIncrementer incrementer(*document());
220 
<a name="4" id="anc4"></a><span class="line-modified">221             document()-&gt;eventLoop().performMicrotaskCheckpoint();</span>
222 
223             CustomElementReactionStack reactionStack(document()-&gt;execState());
224             auto&amp; elementInterface = constructionData-&gt;elementInterface.get();
225             auto newElement = elementInterface.constructElementWithFallback(*document(), constructionData-&gt;name);
226             m_treeBuilder-&gt;didCreateCustomOrFallbackElement(WTFMove(newElement), *constructionData);
227         }
228         return;
229     }
230 
231     TextPosition scriptStartPosition = TextPosition::belowRangePosition();
232     if (auto scriptElement = m_treeBuilder-&gt;takeScriptToProcess(scriptStartPosition)) {
233         ASSERT(!m_treeBuilder-&gt;hasParserBlockingScriptWork());
234         // We will not have a scriptRunner when parsing a DocumentFragment.
235         if (m_scriptRunner)
236             m_scriptRunner-&gt;execute(scriptElement.releaseNonNull(), scriptStartPosition);
237     }
238 }
239 
240 Document* HTMLDocumentParser::contextForParsingSession()
241 {
242     // The parsing session should interact with the document only when parsing
243     // non-fragments. Otherwise, we might delay the load event mistakenly.
244     if (isParsingFragment())
245         return nullptr;
246     return document();
247 }
248 
249 bool HTMLDocumentParser::pumpTokenizerLoop(SynchronousMode mode, bool parsingFragment, PumpSession&amp; session)
250 {
251     do {
252         if (UNLIKELY(isWaitingForScripts())) {
253             if (mode == AllowYield &amp;&amp; m_parserScheduler-&gt;shouldYieldBeforeExecutingScript(session))
254                 return true;
255             runScriptsForPausedTreeBuilder();
256             // If we&#39;re paused waiting for a script, we try to execute scripts before continuing.
257             if (isWaitingForScripts() || isStopped())
258                 return false;
259         }
260 
261         // FIXME: It&#39;s wrong for the HTMLDocumentParser to reach back to the Frame, but this approach is
262         // how the parser has always handled stopping when the page assigns window.location. What should
263         // happen instead is that assigning window.location causes the parser to stop parsing cleanly.
264         // The problem is we&#39;re not prepared to do that at every point where we run JavaScript.
265         if (UNLIKELY(!parsingFragment &amp;&amp; document()-&gt;frame() &amp;&amp; document()-&gt;frame()-&gt;navigationScheduler().locationChangePending()))
266             return false;
267 
268         if (UNLIKELY(mode == AllowYield &amp;&amp; m_parserScheduler-&gt;shouldYieldBeforeToken(session)))
269             return true;
270 
271         if (!parsingFragment)
272             m_sourceTracker.startToken(m_input.current(), m_tokenizer);
273 
274         auto token = m_tokenizer.nextToken(m_input.current());
275         if (!token)
276             return false;
277 
278         if (!parsingFragment) {
279             m_sourceTracker.endToken(m_input.current(), m_tokenizer);
280 
281             // We do not XSS filter innerHTML, which means we (intentionally) fail
282             // http/tests/security/xssAuditor/dom-write-innerHTML.html
283             if (auto xssInfo = m_xssAuditor.filterToken(FilterTokenRequest(*token, m_sourceTracker, m_tokenizer.shouldAllowCDATA())))
284                 m_xssAuditorDelegate.didBlockScript(*xssInfo);
285         }
286 
287         constructTreeFromHTMLToken(token);
288     } while (!isStopped());
289 
290     return false;
291 }
292 
293 void HTMLDocumentParser::pumpTokenizer(SynchronousMode mode)
294 {
295     ASSERT(!isStopped());
296     ASSERT(!isScheduledForResume());
297 
298     // This is an attempt to check that this object is both attached to the Document and protected by something.
299     ASSERT(refCount() &gt;= 2);
300 
301     PumpSession session(m_pumpSessionNestingLevel, contextForParsingSession());
302 
303     m_xssAuditor.init(document(), &amp;m_xssAuditorDelegate);
304 
305     bool shouldResume = pumpTokenizerLoop(mode, isParsingFragment(), session);
306 
307     // Ensure we haven&#39;t been totally deref&#39;ed after pumping. Any caller of this
308     // function should be holding a RefPtr to this to ensure we weren&#39;t deleted.
309     ASSERT(refCount() &gt;= 1);
310 
311     if (isStopped())
312         return;
313 
314     if (shouldResume)
315         m_parserScheduler-&gt;scheduleForResume();
316 
317     if (isWaitingForScripts()) {
318         ASSERT(m_tokenizer.isInDataState());
319         if (!m_preloadScanner) {
320             m_preloadScanner = makeUnique&lt;HTMLPreloadScanner&gt;(m_options, document()-&gt;url(), document()-&gt;deviceScaleFactor());
321             m_preloadScanner-&gt;appendToEnd(m_input.current());
322         }
323         m_preloadScanner-&gt;scan(*m_preloader, *document());
324     }
325     // The viewport definition is known here, so we can load link preloads with media attributes.
326     if (document()-&gt;loader())
327         LinkLoader::loadLinksFromHeader(document()-&gt;loader()-&gt;response().httpHeaderField(HTTPHeaderName::Link), document()-&gt;url(), *document(), LinkLoader::MediaAttributeCheck::MediaAttributeNotEmpty);
328 }
329 
330 void HTMLDocumentParser::constructTreeFromHTMLToken(HTMLTokenizer::TokenPtr&amp; rawToken)
331 {
332     AtomicHTMLToken token(*rawToken);
333 
<a name="5" id="anc5"></a><span class="line-modified">334     // We clear the rawToken in case constructTree</span>
335     // synchronously re-enters the parser. We don&#39;t clear the token immedately
336     // for Character tokens because the AtomicHTMLToken avoids copying the
337     // characters by keeping a pointer to the underlying buffer in the
338     // HTMLToken. Fortunately, Character tokens can&#39;t cause us to re-enter
339     // the parser.
340     //
341     // FIXME: Stop clearing the rawToken once we start running the parser off
342     // the main thread or once we stop allowing synchronous JavaScript
343     // execution from parseAttribute.
344     if (rawToken-&gt;type() != HTMLToken::Character) {
345         // Clearing the TokenPtr makes sure we don&#39;t clear the HTMLToken a second time
346         // later when the TokenPtr is destroyed.
347         rawToken.clear();
348     }
349 
350     m_treeBuilder-&gt;constructTree(WTFMove(token));
351 }
352 
353 bool HTMLDocumentParser::hasInsertionPoint()
354 {
355     // FIXME: The wasCreatedByScript() branch here might not be fully correct.
356     // Our model of the EOF character differs slightly from the one in the spec
357     // because our treatment is uniform between network-sourced and script-sourced
358     // input streams whereas the spec treats them differently.
359     return m_input.hasInsertionPoint() || (wasCreatedByScript() &amp;&amp; !m_input.haveSeenEndOfFile());
360 }
361 
362 void HTMLDocumentParser::insert(SegmentedString&amp;&amp; source)
363 {
364     if (isStopped())
365         return;
366 
367     // pumpTokenizer can cause this parser to be detached from the Document,
368     // but we need to ensure it isn&#39;t deleted yet.
369     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
370 
371     source.setExcludeLineNumbers();
372     m_input.insertAtCurrentInsertionPoint(WTFMove(source));
373     pumpTokenizerIfPossible(ForceSynchronous);
374 
375     if (isWaitingForScripts()) {
376         // Check the document.write() output with a separate preload scanner as
377         // the main scanner can&#39;t deal with insertions.
378         if (!m_insertionPreloadScanner)
379             m_insertionPreloadScanner = makeUnique&lt;HTMLPreloadScanner&gt;(m_options, document()-&gt;url(), document()-&gt;deviceScaleFactor());
380         m_insertionPreloadScanner-&gt;appendToEnd(source);
381         m_insertionPreloadScanner-&gt;scan(*m_preloader, *document());
382     }
383 
384     endIfDelayed();
385 }
386 
387 void HTMLDocumentParser::append(RefPtr&lt;StringImpl&gt;&amp;&amp; inputSource)
388 {
389     if (isStopped())
390         return;
391 
392     // pumpTokenizer can cause this parser to be detached from the Document,
393     // but we need to ensure it isn&#39;t deleted yet.
394     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
395 
396     String source { WTFMove(inputSource) };
397 
398     if (m_preloadScanner) {
399         if (m_input.current().isEmpty() &amp;&amp; !isWaitingForScripts()) {
400             // We have parsed until the end of the current input and so are now moving ahead of the preload scanner.
401             // Clear the scanner so we know to scan starting from the current input point if we block again.
402             m_preloadScanner = nullptr;
403         } else {
404             m_preloadScanner-&gt;appendToEnd(source);
405             if (isWaitingForScripts())
406                 m_preloadScanner-&gt;scan(*m_preloader, *document());
407         }
408     }
409 
410     m_input.appendToEnd(source);
411 
412     if (inPumpSession()) {
413         // We&#39;ve gotten data off the network in a nested write.
414         // We don&#39;t want to consume any more of the input stream now.  Do
415         // not worry.  We&#39;ll consume this data in a less-nested write().
416         return;
417     }
418 
419     pumpTokenizerIfPossible(AllowYield);
420 
421     endIfDelayed();
422 }
423 
424 void HTMLDocumentParser::end()
425 {
426     ASSERT(!isDetached());
427     ASSERT(!isScheduledForResume());
428 
429     // Informs the rest of WebCore that parsing is really finished (and deletes this).
430     m_treeBuilder-&gt;finished();
431 }
432 
433 void HTMLDocumentParser::attemptToRunDeferredScriptsAndEnd()
434 {
435     ASSERT(isStopping());
436     ASSERT(!hasInsertionPoint());
437     if (m_scriptRunner &amp;&amp; !m_scriptRunner-&gt;executeScriptsWaitingForParsing())
438         return;
439     end();
440 }
441 
442 void HTMLDocumentParser::attemptToEnd()
443 {
444     // finish() indicates we will not receive any more data. If we are waiting on
445     // an external script to load, we can&#39;t finish parsing quite yet.
446 
447     if (shouldDelayEnd()) {
448         m_endWasDelayed = true;
449         return;
450     }
451     prepareToStopParsing();
452 }
453 
454 void HTMLDocumentParser::endIfDelayed()
455 {
456     // If we&#39;ve already been detached, don&#39;t bother ending.
457     if (isDetached())
458         return;
459 
460     if (!m_endWasDelayed || shouldDelayEnd())
461         return;
462 
463     m_endWasDelayed = false;
464     prepareToStopParsing();
465 }
466 
467 void HTMLDocumentParser::finish()
468 {
469     // FIXME: We should ASSERT(!m_parserStopped) here, since it does not
470     // makes sense to call any methods on DocumentParser once it&#39;s been stopped.
471     // However, FrameLoader::stop calls DocumentParser::finish unconditionally.
472 
473     // We&#39;re not going to get any more data off the network, so we tell the
474     // input stream we&#39;ve reached the end of file. finish() can be called more
475     // than once, if the first time does not call end().
476     if (!m_input.haveSeenEndOfFile())
477         m_input.markEndOfFile();
478 
479     attemptToEnd();
480 }
481 
482 bool HTMLDocumentParser::isExecutingScript() const
483 {
484     return m_scriptRunner &amp;&amp; m_scriptRunner-&gt;isExecutingScript();
485 }
486 
487 TextPosition HTMLDocumentParser::textPosition() const
488 {
489     auto&amp; currentString = m_input.current();
490     return TextPosition(currentString.currentLine(), currentString.currentColumn());
491 }
492 
493 bool HTMLDocumentParser::shouldAssociateConsoleMessagesWithTextPosition() const
494 {
495     return inPumpSession() &amp;&amp; !isExecutingScript();
496 }
497 
498 bool HTMLDocumentParser::isWaitingForScripts() const
499 {
500     // When the TreeBuilder encounters a &lt;/script&gt; tag, it returns to the HTMLDocumentParser
501     // where the script is transfered from the treebuilder to the script runner.
502     // The script runner will hold the script until its loaded and run. During
503     // any of this time, we want to count ourselves as &quot;waiting for a script&quot; and thus
504     // run the preload scanner, as well as delay completion of parsing.
505     bool treeBuilderHasBlockingScript = m_treeBuilder-&gt;hasParserBlockingScriptWork();
506     bool scriptRunnerHasBlockingScript = m_scriptRunner &amp;&amp; m_scriptRunner-&gt;hasParserBlockingScript();
507     // Since the parser is paused while a script runner has a blocking script, it should
508     // never be possible to end up with both objects holding a blocking script.
509     ASSERT(!(treeBuilderHasBlockingScript &amp;&amp; scriptRunnerHasBlockingScript));
510     // If either object has a blocking script, the parser should be paused.
511     return treeBuilderHasBlockingScript || scriptRunnerHasBlockingScript;
512 }
513 
514 void HTMLDocumentParser::resumeParsingAfterScriptExecution()
515 {
516     ASSERT(!isExecutingScript());
517     ASSERT(!isWaitingForScripts());
518 
519     // pumpTokenizer can cause this parser to be detached from the Document,
520     // but we need to ensure it isn&#39;t deleted yet.
521     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
522 
523     m_insertionPreloadScanner = nullptr;
524     pumpTokenizerIfPossible(AllowYield);
525     endIfDelayed();
526 }
527 
528 void HTMLDocumentParser::watchForLoad(PendingScript&amp; pendingScript)
529 {
530     ASSERT(!pendingScript.isLoaded());
531     // setClient would call notifyFinished if the load were complete.
532     // Callers do not expect to be re-entered from this call, so they should
533     // not an already-loaded PendingScript.
534     pendingScript.setClient(*this);
535 }
536 
537 void HTMLDocumentParser::stopWatchingForLoad(PendingScript&amp; pendingScript)
538 {
539     pendingScript.clearClient();
540 }
541 
542 void HTMLDocumentParser::appendCurrentInputStreamToPreloadScannerAndScan()
543 {
544     ASSERT(m_preloadScanner);
545     m_preloadScanner-&gt;appendToEnd(m_input.current());
546     m_preloadScanner-&gt;scan(*m_preloader, *document());
547 }
548 
549 void HTMLDocumentParser::notifyFinished(PendingScript&amp; pendingScript)
550 {
551     // pumpTokenizer can cause this parser to be detached from the Document,
552     // but we need to ensure it isn&#39;t deleted yet.
553     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
554 
555     // After Document parser is stopped or detached, the parser-inserted deferred script execution should be ignored.
556     if (isStopped())
557         return;
558 
559     ASSERT(m_scriptRunner);
560     ASSERT(!isExecutingScript());
561     if (isStopping()) {
562         attemptToRunDeferredScriptsAndEnd();
563         return;
564     }
565 
566     m_scriptRunner-&gt;executeScriptsWaitingForLoad(pendingScript);
567     if (!isWaitingForScripts())
568         resumeParsingAfterScriptExecution();
569 }
570 
571 bool HTMLDocumentParser::hasScriptsWaitingForStylesheets() const
572 {
573     return m_scriptRunner &amp;&amp; m_scriptRunner-&gt;hasScriptsWaitingForStylesheets();
574 }
575 
576 void HTMLDocumentParser::executeScriptsWaitingForStylesheets()
577 {
578     // Document only calls this when the Document owns the DocumentParser
579     // so this will not be called in the DocumentFragment case.
580     ASSERT(m_scriptRunner);
581     // Ignore calls unless we have a script blocking the parser waiting on a
582     // stylesheet load.  Otherwise we are currently parsing and this
583     // is a re-entrant call from encountering a &lt;/ style&gt; tag.
584     if (!m_scriptRunner-&gt;hasScriptsWaitingForStylesheets())
585         return;
586 
587     // pumpTokenizer can cause this parser to be detached from the Document,
588     // but we need to ensure it isn&#39;t deleted yet.
589     Ref&lt;HTMLDocumentParser&gt; protectedThis(*this);
590     m_scriptRunner-&gt;executeScriptsWaitingForStylesheets();
591     if (!isWaitingForScripts())
592         resumeParsingAfterScriptExecution();
593 }
594 
595 void HTMLDocumentParser::parseDocumentFragment(const String&amp; source, DocumentFragment&amp; fragment, Element&amp; contextElement, ParserContentPolicy parserContentPolicy)
596 {
597     auto parser = create(fragment, contextElement, parserContentPolicy);
598     parser-&gt;insert(source); // Use insert() so that the parser will not yield.
599     parser-&gt;finish();
600     ASSERT(!parser-&gt;processingData());
601     parser-&gt;detach();
602 }
603 
604 void HTMLDocumentParser::suspendScheduledTasks()
605 {
606     if (m_parserScheduler)
607         m_parserScheduler-&gt;suspend();
608 }
609 
610 void HTMLDocumentParser::resumeScheduledTasks()
611 {
612     if (m_parserScheduler)
613         m_parserScheduler-&gt;resume();
614 }
615 
616 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
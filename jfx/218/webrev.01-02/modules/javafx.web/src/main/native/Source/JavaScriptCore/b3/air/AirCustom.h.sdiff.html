<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AirCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirDisassembler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AirGenerationContext.h&quot;
 32 #include &quot;AirInst.h&quot;
 33 #include &quot;AirSpecial.h&quot;
 34 #include &quot;B3ValueInlines.h&quot;
 35 #include &quot;B3WasmBoundsCheckValue.h&quot;

 36 
 37 namespace JSC { namespace B3 { namespace Air {
 38 
 39 // This defines the behavior of custom instructions - i.e. those whose behavior cannot be
 40 // described using AirOpcode.opcodes. If you define an opcode as &quot;custom Foo&quot; in that file, then
 41 // you will need to create a &quot;struct FooCustom&quot; here that implements the custom behavior
 42 // methods.
 43 //
 44 // The customizability granted by the custom instruction mechanism is strictly less than what
 45 // you get using the Patch instruction and implementing a Special. However, that path requires
 46 // allocating a Special object and ensuring that it&#39;s the first operand. For many instructions,
 47 // that is not as convenient as using Custom, which makes the instruction look like any other
 48 // instruction. Note that both of those extra powers of the Patch instruction happen because we
 49 // special-case that instruction in many phases and analyses. Non-special-cased behaviors of
 50 // Patch are implemented using the custom instruction mechanism.
 51 //
 52 // Specials are still more flexible if you need to list extra clobbered registers and you&#39;d like
 53 // that to be expressed as a bitvector rather than an arglist. They are also more flexible if
 54 // you need to carry extra state around with the instruction. Also, Specials mean that you
 55 // always have access to Code&amp; even in methods that don&#39;t take a GenerationContext.
</pre>
<hr />
<pre>
 91     static Optional&lt;unsigned&gt; shouldTryAliasingDef(Inst&amp; inst)
 92     {
 93         return inst.args[0].special()-&gt;shouldTryAliasingDef(inst);
 94     }
 95 
 96     static bool isTerminal(Inst&amp; inst)
 97     {
 98         return inst.args[0].special()-&gt;isTerminal(inst);
 99     }
100 
101     static bool hasNonArgEffects(Inst&amp; inst)
102     {
103         return inst.args[0].special()-&gt;hasNonArgEffects(inst);
104     }
105 
106     static bool hasNonArgNonControlEffects(Inst&amp; inst)
107     {
108         return inst.args[0].special()-&gt;hasNonArgNonControlEffects(inst);
109     }
110 
<span class="line-modified">111     static CCallHelpers::Jump generate(</span>
112         Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)
113     {
114         return inst.args[0].special()-&gt;generate(inst, jit, context);
115     }
116 };
117 
118 template&lt;typename Subtype&gt;
119 struct CommonCustomBase {
120     static bool hasNonArgEffects(Inst&amp; inst)
121     {
122         return Subtype::isTerminal(inst) || Subtype::hasNonArgNonControlEffects(inst);
123     }
124 };
125 
126 // Definition of CCall instruction. CCall is used for hot path C function calls. It&#39;s lowered to a
127 // Patch with an Air CCallSpecial along with code to marshal instructions. The lowering happens
128 // before register allocation, so that the register allocator sees the clobbers.
129 struct CCallCustom : public CommonCustomBase&lt;CCallCustom&gt; {
130     template&lt;typename Functor&gt;
131     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
</pre>
<hr />
<pre>
164     {
165         return true;
166     }
167 
168     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
169     {
170         return false;
171     }
172 
173     static bool isTerminal(Inst&amp;)
174     {
175         return false;
176     }
177 
178     static bool hasNonArgNonControlEffects(Inst&amp;)
179     {
180         return true;
181     }
182 
183     // This just crashes, since we expect C calls to be lowered before generation.
<span class="line-modified">184     static CCallHelpers::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);</span>
185 };
186 
187 struct ColdCCallCustom : CCallCustom {
188     template&lt;typename Functor&gt;
189     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
190     {
191         // This is just like a call, but uses become cold.
192         CCallCustom::forEachArg(
193             inst,
194             [&amp;] (Arg&amp; arg, Arg::Role role, Bank bank, Width width) {
195                 functor(arg, Arg::cooled(role), bank, width);
196             });
197     }
198 };
199 
200 struct ShuffleCustom : public CommonCustomBase&lt;ShuffleCustom&gt; {
201     template&lt;typename Functor&gt;
202     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
203     {
204         unsigned limit = inst.args.size() / 3 * 3;
</pre>
<hr />
<pre>
231         default:
232             return false;
233         }
234     }
235 
236     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
237     {
238         return false;
239     }
240 
241     static bool isTerminal(Inst&amp;)
242     {
243         return false;
244     }
245 
246     static bool hasNonArgNonControlEffects(Inst&amp;)
247     {
248         return false;
249     }
250 
<span class="line-modified">251     static CCallHelpers::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);</span>
252 };
253 
254 struct EntrySwitchCustom : public CommonCustomBase&lt;EntrySwitchCustom&gt; {
255     template&lt;typename Func&gt;
256     static void forEachArg(Inst&amp;, const Func&amp;)
257     {
258     }
259 
260     template&lt;typename... Arguments&gt;
261     static bool isValidFormStatic(Arguments...)
262     {
263         return !sizeof...(Arguments);
264     }
265 
266     static bool isValidForm(Inst&amp; inst)
267     {
268         return inst.args.isEmpty();
269     }
270 
271     static bool admitsStack(Inst&amp;, unsigned)
272     {
273         return false;
274     }
275 
276     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
277     {
278         return false;
279     }
280 
281     static bool isTerminal(Inst&amp;)
282     {
283         return true;
284     }
285 
286     static bool hasNonArgNonControlEffects(Inst&amp;)
287     {
288         return false;
289     }
290 
<span class="line-modified">291     static CCallHelpers::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;)</span>
292     {
293         // This should never be reached because we should have lowered EntrySwitch before
294         // generation.
295         UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">296         return CCallHelpers::Jump();</span>
297     }
298 };
299 
300 struct WasmBoundsCheckCustom : public CommonCustomBase&lt;WasmBoundsCheckCustom&gt; {
301     template&lt;typename Func&gt;
302     static void forEachArg(Inst&amp; inst, const Func&amp; functor)
303     {
304         functor(inst.args[0], Arg::Use, GP, Width64);
305         functor(inst.args[1], Arg::Use, GP, Width64);
306     }
307 
308     template&lt;typename... Arguments&gt;
309     static bool isValidFormStatic(Arguments...)
310     {
311         return false;
312     }
313 
314     static bool isValidForm(Inst&amp;);
315 
316     static bool admitsStack(Inst&amp;, unsigned)
317     {
318         return false;
319     }
320 
321     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
322     {
323         return false;
324     }
325 
326     static bool isTerminal(Inst&amp;)
327     {
328         return false;
329     }
330 
331     static bool hasNonArgNonControlEffects(Inst&amp;)
332     {
333         return true;
334     }
335 
<span class="line-modified">336     static CCallHelpers::Jump generate(Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)</span>
<span class="line-removed">337     {</span>
<span class="line-removed">338         WasmBoundsCheckValue* value = inst.origin-&gt;as&lt;WasmBoundsCheckValue&gt;();</span>
<span class="line-removed">339         CCallHelpers::Jump outOfBounds = Inst(Air::Branch64, value, Arg::relCond(CCallHelpers::AboveOrEqual), inst.args[0], inst.args[1]).generate(jit, context);</span>
<span class="line-removed">340 </span>
<span class="line-removed">341         context.latePaths.append(createSharedTask&lt;GenerationContext::LatePathFunction&gt;(</span>
<span class="line-removed">342             [outOfBounds, value] (CCallHelpers&amp; jit, Air::GenerationContext&amp; context) {</span>
<span class="line-removed">343                 outOfBounds.link(&amp;jit);</span>
<span class="line-removed">344                 switch (value-&gt;boundsType()) {</span>
<span class="line-removed">345                 case WasmBoundsCheckValue::Type::Pinned:</span>
<span class="line-removed">346                     context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, value-&gt;bounds().pinnedSize);</span>
<span class="line-removed">347                     break;</span>
<span class="line-removed">348 </span>
<span class="line-removed">349                 case WasmBoundsCheckValue::Type::Maximum:</span>
<span class="line-removed">350                     context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, InvalidGPRReg);</span>
<span class="line-removed">351                     break;</span>
<span class="line-removed">352                 }</span>
<span class="line-removed">353             }));</span>
<span class="line-removed">354 </span>
<span class="line-removed">355         // We said we were not a terminal.</span>
<span class="line-removed">356         return CCallHelpers::Jump();</span>
<span class="line-removed">357     }</span>
358 };
359 
360 } } } // namespace JSC::B3::Air
361 
362 #endif // ENABLE(B3_JIT)
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(B3_JIT)
 29 
 30 #include &quot;AirCode.h&quot;
 31 #include &quot;AirGenerationContext.h&quot;
 32 #include &quot;AirInst.h&quot;
 33 #include &quot;AirSpecial.h&quot;
 34 #include &quot;B3ValueInlines.h&quot;
 35 #include &quot;B3WasmBoundsCheckValue.h&quot;
<span class="line-added"> 36 #include &quot;MacroAssembler.h&quot;</span>
 37 
 38 namespace JSC { namespace B3 { namespace Air {
 39 
 40 // This defines the behavior of custom instructions - i.e. those whose behavior cannot be
 41 // described using AirOpcode.opcodes. If you define an opcode as &quot;custom Foo&quot; in that file, then
 42 // you will need to create a &quot;struct FooCustom&quot; here that implements the custom behavior
 43 // methods.
 44 //
 45 // The customizability granted by the custom instruction mechanism is strictly less than what
 46 // you get using the Patch instruction and implementing a Special. However, that path requires
 47 // allocating a Special object and ensuring that it&#39;s the first operand. For many instructions,
 48 // that is not as convenient as using Custom, which makes the instruction look like any other
 49 // instruction. Note that both of those extra powers of the Patch instruction happen because we
 50 // special-case that instruction in many phases and analyses. Non-special-cased behaviors of
 51 // Patch are implemented using the custom instruction mechanism.
 52 //
 53 // Specials are still more flexible if you need to list extra clobbered registers and you&#39;d like
 54 // that to be expressed as a bitvector rather than an arglist. They are also more flexible if
 55 // you need to carry extra state around with the instruction. Also, Specials mean that you
 56 // always have access to Code&amp; even in methods that don&#39;t take a GenerationContext.
</pre>
<hr />
<pre>
 92     static Optional&lt;unsigned&gt; shouldTryAliasingDef(Inst&amp; inst)
 93     {
 94         return inst.args[0].special()-&gt;shouldTryAliasingDef(inst);
 95     }
 96 
 97     static bool isTerminal(Inst&amp; inst)
 98     {
 99         return inst.args[0].special()-&gt;isTerminal(inst);
100     }
101 
102     static bool hasNonArgEffects(Inst&amp; inst)
103     {
104         return inst.args[0].special()-&gt;hasNonArgEffects(inst);
105     }
106 
107     static bool hasNonArgNonControlEffects(Inst&amp; inst)
108     {
109         return inst.args[0].special()-&gt;hasNonArgNonControlEffects(inst);
110     }
111 
<span class="line-modified">112     static MacroAssembler::Jump generate(</span>
113         Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)
114     {
115         return inst.args[0].special()-&gt;generate(inst, jit, context);
116     }
117 };
118 
119 template&lt;typename Subtype&gt;
120 struct CommonCustomBase {
121     static bool hasNonArgEffects(Inst&amp; inst)
122     {
123         return Subtype::isTerminal(inst) || Subtype::hasNonArgNonControlEffects(inst);
124     }
125 };
126 
127 // Definition of CCall instruction. CCall is used for hot path C function calls. It&#39;s lowered to a
128 // Patch with an Air CCallSpecial along with code to marshal instructions. The lowering happens
129 // before register allocation, so that the register allocator sees the clobbers.
130 struct CCallCustom : public CommonCustomBase&lt;CCallCustom&gt; {
131     template&lt;typename Functor&gt;
132     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
</pre>
<hr />
<pre>
165     {
166         return true;
167     }
168 
169     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
170     {
171         return false;
172     }
173 
174     static bool isTerminal(Inst&amp;)
175     {
176         return false;
177     }
178 
179     static bool hasNonArgNonControlEffects(Inst&amp;)
180     {
181         return true;
182     }
183 
184     // This just crashes, since we expect C calls to be lowered before generation.
<span class="line-modified">185     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);</span>
186 };
187 
188 struct ColdCCallCustom : CCallCustom {
189     template&lt;typename Functor&gt;
190     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
191     {
192         // This is just like a call, but uses become cold.
193         CCallCustom::forEachArg(
194             inst,
195             [&amp;] (Arg&amp; arg, Arg::Role role, Bank bank, Width width) {
196                 functor(arg, Arg::cooled(role), bank, width);
197             });
198     }
199 };
200 
201 struct ShuffleCustom : public CommonCustomBase&lt;ShuffleCustom&gt; {
202     template&lt;typename Functor&gt;
203     static void forEachArg(Inst&amp; inst, const Functor&amp; functor)
204     {
205         unsigned limit = inst.args.size() / 3 * 3;
</pre>
<hr />
<pre>
232         default:
233             return false;
234         }
235     }
236 
237     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
238     {
239         return false;
240     }
241 
242     static bool isTerminal(Inst&amp;)
243     {
244         return false;
245     }
246 
247     static bool hasNonArgNonControlEffects(Inst&amp;)
248     {
249         return false;
250     }
251 
<span class="line-modified">252     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);</span>
253 };
254 
255 struct EntrySwitchCustom : public CommonCustomBase&lt;EntrySwitchCustom&gt; {
256     template&lt;typename Func&gt;
257     static void forEachArg(Inst&amp;, const Func&amp;)
258     {
259     }
260 
261     template&lt;typename... Arguments&gt;
262     static bool isValidFormStatic(Arguments...)
263     {
264         return !sizeof...(Arguments);
265     }
266 
267     static bool isValidForm(Inst&amp; inst)
268     {
269         return inst.args.isEmpty();
270     }
271 
272     static bool admitsStack(Inst&amp;, unsigned)
273     {
274         return false;
275     }
276 
277     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
278     {
279         return false;
280     }
281 
282     static bool isTerminal(Inst&amp;)
283     {
284         return true;
285     }
286 
287     static bool hasNonArgNonControlEffects(Inst&amp;)
288     {
289         return false;
290     }
291 
<span class="line-modified">292     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;)</span>
293     {
294         // This should never be reached because we should have lowered EntrySwitch before
295         // generation.
296         UNREACHABLE_FOR_PLATFORM();
<span class="line-modified">297         return MacroAssembler::Jump();</span>
298     }
299 };
300 
301 struct WasmBoundsCheckCustom : public CommonCustomBase&lt;WasmBoundsCheckCustom&gt; {
302     template&lt;typename Func&gt;
303     static void forEachArg(Inst&amp; inst, const Func&amp; functor)
304     {
305         functor(inst.args[0], Arg::Use, GP, Width64);
306         functor(inst.args[1], Arg::Use, GP, Width64);
307     }
308 
309     template&lt;typename... Arguments&gt;
310     static bool isValidFormStatic(Arguments...)
311     {
312         return false;
313     }
314 
315     static bool isValidForm(Inst&amp;);
316 
317     static bool admitsStack(Inst&amp;, unsigned)
318     {
319         return false;
320     }
321 
322     static bool admitsExtendedOffsetAddr(Inst&amp;, unsigned)
323     {
324         return false;
325     }
326 
327     static bool isTerminal(Inst&amp;)
328     {
329         return false;
330     }
331 
332     static bool hasNonArgNonControlEffects(Inst&amp;)
333     {
334         return true;
335     }
336 
<span class="line-modified">337     static MacroAssembler::Jump generate(Inst&amp;, CCallHelpers&amp;, GenerationContext&amp;);</span>





















338 };
339 
340 } } } // namespace JSC::B3::Air
341 
342 #endif // ENABLE(B3_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="AirCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirDisassembler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
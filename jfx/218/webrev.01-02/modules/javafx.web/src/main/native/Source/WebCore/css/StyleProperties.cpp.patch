diff a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleProperties.cpp
@@ -47,23 +47,27 @@
 #include <wtf/text/CString.h>
 #endif
 
 namespace WebCore {
 
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleProperties);
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ImmutableStyleProperties);
+DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MutableStyleProperties);
+
 static size_t sizeForImmutableStylePropertiesWithPropertyCount(unsigned count)
 {
-    return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(CSSValue*) * count + sizeof(StylePropertyMetadata) * count;
+    return sizeof(ImmutableStyleProperties) - sizeof(void*) + sizeof(StylePropertyMetadata) * count + sizeof(PackedPtr<const CSSValue>) * count;
 }
 
 static bool isInitialOrInherit(const String& value)
 {
     return value.length() == 7 && (value == "initial" || value == "inherit");
 }
 
 Ref<ImmutableStyleProperties> ImmutableStyleProperties::create(const CSSProperty* properties, unsigned count, CSSParserMode cssParserMode)
 {
-    void* slot = WTF::fastMalloc(sizeForImmutableStylePropertiesWithPropertyCount(count));
+    void* slot = ImmutableStylePropertiesMalloc::malloc(sizeForImmutableStylePropertiesWithPropertyCount(count));
     return adoptRef(*new (NotNull, slot) ImmutableStyleProperties(properties, count, cssParserMode));
 }
 
 Ref<ImmutableStyleProperties> StyleProperties::immutableCopyIfNeeded() const
 {
@@ -76,35 +80,34 @@
 MutableStyleProperties::MutableStyleProperties(CSSParserMode cssParserMode)
     : StyleProperties(cssParserMode, MutablePropertiesType)
 {
 }
 
-MutableStyleProperties::MutableStyleProperties(const CSSProperty* properties, unsigned length)
+MutableStyleProperties::MutableStyleProperties(Vector<CSSProperty>&& properties)
     : StyleProperties(HTMLStandardMode, MutablePropertiesType)
+    , m_propertyVector(WTFMove(properties))
 {
-    m_propertyVector.reserveInitialCapacity(length);
-    for (unsigned i = 0; i < length; ++i)
-        m_propertyVector.uncheckedAppend(properties[i]);
 }
 
 MutableStyleProperties::~MutableStyleProperties() = default;
 
 ImmutableStyleProperties::ImmutableStyleProperties(const CSSProperty* properties, unsigned length, CSSParserMode cssParserMode)
     : StyleProperties(cssParserMode, length)
 {
     StylePropertyMetadata* metadataArray = const_cast<StylePropertyMetadata*>(this->metadataArray());
-    CSSValue** valueArray = const_cast<CSSValue**>(this->valueArray());
+    PackedPtr<CSSValue>* valueArray = bitwise_cast<PackedPtr<CSSValue>*>(this->valueArray());
     for (unsigned i = 0; i < length; ++i) {
         metadataArray[i] = properties[i].metadata();
-        valueArray[i] = properties[i].value();
-        valueArray[i]->ref();
+        auto* value = properties[i].value();
+        valueArray[i] = value;
+        value->ref();
     }
 }
 
 ImmutableStyleProperties::~ImmutableStyleProperties()
 {
-    CSSValue** valueArray = const_cast<CSSValue**>(this->valueArray());
+    PackedPtr<CSSValue>* valueArray = bitwise_cast<PackedPtr<CSSValue>*>(this->valueArray());
     for (unsigned i = 0; i < m_arraySize; ++i)
         valueArray[i]->deref();
 }
 
 MutableStyleProperties::MutableStyleProperties(const StyleProperties& other)
@@ -123,12 +126,27 @@
 }
 
 String StyleProperties::getPropertyValue(CSSPropertyID propertyID) const
 {
     RefPtr<CSSValue> value = getPropertyCSSValue(propertyID);
-    if (value)
-        return value->cssText();
+    if (value) {
+        switch (propertyID) {
+        case CSSPropertyFillOpacity:
+        case CSSPropertyFloodOpacity:
+        case CSSPropertyOpacity:
+        case CSSPropertyStopOpacity:
+        case CSSPropertyStrokeOpacity:
+            // Opacity values always serializes as a number.
+            if (value->isPrimitiveValue() && downcast<CSSPrimitiveValue>(value.get())->isPercentage()) {
+                auto doubleValue = downcast<CSSPrimitiveValue>(value.get())->doubleValue();
+                return makeString(doubleValue / 100.0);
+            }
+            FALLTHROUGH;
+        default:
+            return value->cssText();
+        }
+    }
 
     const StylePropertyShorthand& shorthand = shorthandForProperty(propertyID);
     if (shorthand.length()) {
         RefPtr<CSSValue> value = getPropertyCSSValueInternal(shorthand.properties()[0]);
         if (!value || value->isPendingSubstitutionValue())
@@ -203,19 +221,19 @@
     case CSSPropertyFlex:
         return getShorthandValue(flexShorthand());
     case CSSPropertyFlexFlow:
         return getShorthandValue(flexFlowShorthand());
     case CSSPropertyGridArea:
-        return getShorthandValue(gridAreaShorthand());
+        return getGridShorthandValue(gridAreaShorthand());
     case CSSPropertyGridTemplate:
-        return getShorthandValue(gridTemplateShorthand());
+        return getGridShorthandValue(gridTemplateShorthand());
     case CSSPropertyGrid:
-        return getShorthandValue(gridShorthand());
+        return getGridShorthandValue(gridShorthand());
     case CSSPropertyGridColumn:
-        return getShorthandValue(gridColumnShorthand());
+        return getGridShorthandValue(gridColumnShorthand());
     case CSSPropertyGridRow:
-        return getShorthandValue(gridRowShorthand());
+        return getGridShorthandValue(gridRowShorthand());
     case CSSPropertyPageBreakAfter:
         return pageBreakPropertyValue(pageBreakAfterShorthand());
     case CSSPropertyPageBreakBefore:
         return pageBreakPropertyValue(pageBreakBeforeShorthand());
     case CSSPropertyPageBreakInside:
@@ -241,23 +259,21 @@
     case CSSPropertyMarginInline:
         return get2Values(marginInlineShorthand());
     case CSSPropertyWebkitMarginCollapse:
         return getShorthandValue(webkitMarginCollapseShorthand());
     case CSSPropertyOverflow:
-        return getCommonValue(overflowShorthand());
+        return get2Values(overflowShorthand());
     case CSSPropertyPadding:
         return get4Values(paddingShorthand());
     case CSSPropertyPaddingBlock:
         return get2Values(paddingBlockShorthand());
     case CSSPropertyPaddingInline:
         return get2Values(paddingInlineShorthand());
     case CSSPropertyTransition:
         return getLayeredShorthandValue(transitionShorthand());
     case CSSPropertyListStyle:
         return getShorthandValue(listStyleShorthand());
-    case CSSPropertyWebkitMarquee:
-        return getShorthandValue(webkitMarqueeShorthand());
     case CSSPropertyWebkitMaskPosition:
         return getLayeredShorthandValue(webkitMaskPositionShorthand());
     case CSSPropertyWebkitMaskRepeat:
         return getLayeredShorthandValue(webkitMaskRepeatShorthand());
     case CSSPropertyWebkitMask:
@@ -635,11 +651,16 @@
     if (result.isEmpty())
         return String();
     return result.toString();
 }
 
-String StyleProperties::getShorthandValue(const StylePropertyShorthand& shorthand) const
+String StyleProperties::getGridShorthandValue(const StylePropertyShorthand& shorthand) const
+{
+    return getShorthandValue(shorthand, " / ");
+}
+
+String StyleProperties::getShorthandValue(const StylePropertyShorthand& shorthand, const char* separator) const
 {
     String commonValue;
     StringBuilder result;
     for (unsigned i = 0; i < shorthand.length(); ++i) {
         if (!isPropertyImplicit(shorthand.properties()[i])) {
@@ -652,11 +673,11 @@
             else if (!commonValue.isNull() && commonValue != valueText)
                 commonValue = String();
             if (value->isInitialValue())
                 continue;
             if (!result.isEmpty())
-                result.append(' ');
+                result.append(separator);
             result.append(valueText);
         } else
             commonValue = String();
     }
     if (isInitialOrInherit(commonValue))
@@ -1268,11 +1289,11 @@
     }
 
     // FIXME: This is a not-so-nice way to turn x/y positions into single background-position in output.
     // It is required because background-position-x/y are non-standard properties and WebKit generated output
     // would not work in Firefox (<rdar://problem/5143183>)
-    // It would be a better solution if background-position was CSS_PAIR.
+    // It would be a better solution if background-position was CSSUnitType::CSS_PAIR.
     if (positionXPropertyIndex != -1 && positionYPropertyIndex != -1 && propertyAt(positionXPropertyIndex).isImportant() == propertyAt(positionYPropertyIndex).isImportant()) {
         PropertyReference positionXProperty = propertyAt(positionXPropertyIndex);
         PropertyReference positionYProperty = propertyAt(positionYPropertyIndex);
 
         if (numDecls++)
@@ -1449,13 +1470,14 @@
     // Convert the propertyID into an uint16_t to compare it with the metadata's m_propertyID to avoid
     // the compiler converting it to an int multiple times in the loop.
     for (int n = m_arraySize - 1 ; n >= 0; --n) {
         if (metadataArray()[n].m_propertyID == CSSPropertyCustom) {
             // We found a custom property. See if the name matches.
-            if (!valueArray()[n])
+            auto* value = valueArray()[n].get();
+            if (!value)
                 continue;
-            if (downcast<CSSCustomPropertyValue>(*valueArray()[n]).name() == propertyName)
+            if (downcast<CSSCustomPropertyValue>(*value).name() == propertyName)
                 return n;
         }
     }
 
     return -1;
@@ -1507,17 +1529,17 @@
     return adoptRef(*new MutableStyleProperties(*this));
 }
 
 Ref<MutableStyleProperties> StyleProperties::copyPropertiesInSet(const CSSPropertyID* set, unsigned length) const
 {
-    Vector<CSSProperty, 256> list;
+    Vector<CSSProperty> list;
     list.reserveInitialCapacity(length);
     for (unsigned i = 0; i < length; ++i) {
         if (auto value = getPropertyCSSValueInternal(set[i]))
             list.uncheckedAppend(CSSProperty(set[i], WTFMove(value), false));
     }
-    return MutableStyleProperties::create(list.data(), list.size());
+    return MutableStyleProperties::create(WTFMove(list));
 }
 
 PropertySetCSSStyleDeclaration* MutableStyleProperties::cssStyleDeclaration()
 {
     return m_cssomWrapper.get();
@@ -1566,13 +1588,13 @@
 Ref<MutableStyleProperties> MutableStyleProperties::create(CSSParserMode cssParserMode)
 {
     return adoptRef(*new MutableStyleProperties(cssParserMode));
 }
 
-Ref<MutableStyleProperties> MutableStyleProperties::create(const CSSProperty* properties, unsigned count)
+Ref<MutableStyleProperties> MutableStyleProperties::create(Vector<CSSProperty>&& properties)
 {
-    return adoptRef(*new MutableStyleProperties(properties, count));
+    return adoptRef(*new MutableStyleProperties(WTFMove(properties)));
 }
 
 String StyleProperties::PropertyReference::cssName() const
 {
     if (id() == CSSPropertyCustom)

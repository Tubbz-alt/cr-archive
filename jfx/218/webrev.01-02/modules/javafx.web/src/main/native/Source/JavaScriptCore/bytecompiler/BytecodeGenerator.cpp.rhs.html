<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/BytecodeGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  * Copyright (C) 2012 Igalia, S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  *
  10  * 1.  Redistributions of source code must retain the above copyright
  11  *     notice, this list of conditions and the following disclaimer.
  12  * 2.  Redistributions in binary form must reproduce the above copyright
  13  *     notice, this list of conditions and the following disclaimer in the
  14  *     documentation and/or other materials provided with the distribution.
  15  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  16  *     its contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;BytecodeGenerator.h&quot;
  33 
  34 #include &quot;ArithProfile.h&quot;
  35 #include &quot;BuiltinExecutables.h&quot;
  36 #include &quot;BuiltinNames.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  37 #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  38 #include &quot;BytecodeGeneratorification.h&quot;
  39 #include &quot;BytecodeLivenessAnalysis.h&quot;
<a name="2" id="anc2"></a>
  40 #include &quot;BytecodeUseDef.h&quot;
  41 #include &quot;CatchScope.h&quot;
  42 #include &quot;DefinePropertyAttributes.h&quot;
  43 #include &quot;Interpreter.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  44 #include &quot;JSAsyncGenerator.h&quot;</span>
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
<a name="4" id="anc4"></a>
  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSGeneratorFunction.h&quot;
  49 #include &quot;JSImmutableButterfly.h&quot;
  50 #include &quot;JSLexicalEnvironment.h&quot;
  51 #include &quot;JSTemplateObjectDescriptor.h&quot;
<a name="5" id="anc5"></a><span class="line-added">  52 #include &quot;LinkTimeConstant.h&quot;</span>
  53 #include &quot;LowLevelInterpreter.h&quot;
  54 #include &quot;Options.h&quot;
  55 #include &quot;PreciseJumpTargetsInlines.h&quot;
  56 #include &quot;StackAlignment.h&quot;
  57 #include &quot;StrongInlines.h&quot;
  58 #include &quot;SuperSamplerBytecodeScope.h&quot;
  59 #include &quot;UnlinkedCodeBlock.h&quot;
  60 #include &quot;UnlinkedEvalCodeBlock.h&quot;
  61 #include &quot;UnlinkedFunctionCodeBlock.h&quot;
  62 #include &quot;UnlinkedMetadataTableInlines.h&quot;
  63 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
  64 #include &quot;UnlinkedProgramCodeBlock.h&quot;
  65 #include &lt;wtf/BitVector.h&gt;
  66 #include &lt;wtf/CommaPrinter.h&gt;
  67 #include &lt;wtf/Optional.h&gt;
  68 #include &lt;wtf/SmallPtrSet.h&gt;
  69 #include &lt;wtf/StdLibExtras.h&gt;
  70 #include &lt;wtf/text/WTFString.h&gt;
  71 
  72 namespace JSC {
  73 
  74 template&lt;typename CallOp, typename = std::true_type&gt;
  75 struct VarArgsOp;
  76 
  77 template&lt;typename CallOp&gt;
  78 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  79     using type = OpTailCallVarargs;
  80 };
  81 
  82 
  83 template&lt;typename CallOp&gt;
  84 struct VarArgsOp&lt;CallOp, std::enable_if_t&lt;!std::is_same&lt;CallOp, OpTailCall&gt;::value, std::true_type&gt;&gt; {
  85     using type = OpCallVarargs;
  86 };
  87 
<a name="6" id="anc6"></a><span class="line-modified">  88 template&lt;&gt;</span>
<span class="line-modified">  89 void GenericLabel&lt;JSGeneratorTraits&gt;::setLocation(BytecodeGenerator&amp; generator, unsigned location)</span>







  90 {
  91     m_location = location;
  92 
  93     for (auto offset : m_unresolvedJumps) {
  94         auto instruction = generator.m_writer.ref(offset);
  95         int target = m_location - offset;
  96 
  97 #define CASE(__op) \
  98     case __op::opcodeID:  \
  99         instruction-&gt;cast&lt;__op&gt;()-&gt;setTargetLabel(BoundLabel(target), [&amp;]() { \
 100             generator.m_codeBlock-&gt;addOutOfLineJumpTarget(instruction.offset(), target); \
 101             return BoundLabel(); \
 102         }); \
 103         break;
 104 
 105         switch (instruction-&gt;opcodeID()) {
 106         CASE(OpJmp)
 107         CASE(OpJtrue)
 108         CASE(OpJfalse)
 109         CASE(OpJeqNull)
 110         CASE(OpJneqNull)
 111         CASE(OpJundefinedOrNull)
 112         CASE(OpJnundefinedOrNull)
 113         CASE(OpJeq)
 114         CASE(OpJstricteq)
 115         CASE(OpJneq)
 116         CASE(OpJneqPtr)
 117         CASE(OpJnstricteq)
 118         CASE(OpJless)
 119         CASE(OpJlesseq)
 120         CASE(OpJgreater)
 121         CASE(OpJgreatereq)
 122         CASE(OpJnless)
 123         CASE(OpJnlesseq)
 124         CASE(OpJngreater)
 125         CASE(OpJngreatereq)
 126         CASE(OpJbelow)
 127         CASE(OpJbeloweq)
 128         default:
 129             ASSERT_NOT_REACHED();
 130         }
 131 #undef CASE
 132     }
 133 }
 134 
<a name="7" id="anc7"></a>


































 135 void Variable::dump(PrintStream&amp; out) const
 136 {
 137     out.print(
 138         &quot;{ident = &quot;, m_ident,
 139         &quot;, offset = &quot;, m_offset,
 140         &quot;, local = &quot;, RawPointer(m_local),
 141         &quot;, attributes = &quot;, m_attributes,
 142         &quot;, kind = &quot;, m_kind,
 143         &quot;, symbolTableConstantIndex = &quot;, m_symbolTableConstantIndex,
 144         &quot;, isLexicallyScoped = &quot;, m_isLexicallyScoped, &quot;}&quot;);
 145 }
 146 
 147 FinallyContext::FinallyContext(BytecodeGenerator&amp; generator, Label&amp; finallyLabel)
 148     : m_outerContext(generator.m_currentFinallyContext)
 149     , m_finallyLabel(&amp;finallyLabel)
 150 {
 151     ASSERT(m_jumps.isEmpty());
 152     m_completionRecord.typeRegister = generator.newTemporary();
 153     m_completionRecord.valueRegister = generator.newTemporary();
 154     generator.emitLoad(completionTypeRegister(), CompletionType::Normal);
 155     generator.moveEmptyValue(completionValueRegister());
 156 }
 157 
 158 ParserError BytecodeGenerator::generate()
 159 {
 160     m_codeBlock-&gt;setThisRegister(m_thisRegister.virtualRegister());
 161 
 162     emitLogShadowChickenPrologueIfNecessary();
 163 
 164     // If we have declared a variable named &quot;arguments&quot; and we are using arguments then we should
 165     // perform that assignment now.
 166     if (m_needToInitializeArguments)
 167         initializeVariable(variable(propertyNames().arguments), m_argumentsRegister);
 168 
 169     if (m_restParameter)
 170         m_restParameter-&gt;emit(*this);
 171 
 172     {
 173         RefPtr&lt;RegisterID&gt; temp = newTemporary();
 174         RefPtr&lt;RegisterID&gt; tolLevelScope;
 175         for (auto functionPair : m_functionsToInitialize) {
 176             FunctionMetadataNode* metadata = functionPair.first;
 177             FunctionVariableType functionType = functionPair.second;
 178             emitNewFunction(temp.get(), metadata);
 179             if (functionType == NormalFunctionVariable)
 180                 initializeVariable(variable(metadata-&gt;ident()), temp.get());
 181             else if (functionType == TopLevelFunctionVariable) {
 182                 if (!tolLevelScope) {
 183                     // We know this will resolve to the top level scope or global object because our parser/global initialization code
 184                     // doesn&#39;t allow let/const/class variables to have the same names as functions.
 185                     // This is a top level function, and it&#39;s an error to ever create a top level function
 186                     // name that would resolve to a lexical variable. E.g:
 187                     // ```
 188                     //     function f() {
 189                     //         {
 190                     //             let x;
 191                     //             {
 192                     //             //// error thrown here
 193                     //                  eval(&quot;function x(){}&quot;);
 194                     //             }
 195                     //         }
 196                     //     }
 197                     // ```
 198                     // Therefore, we&#39;re guaranteed to have this resolve to a top level variable.
 199                     RefPtr&lt;RegisterID&gt; tolLevelObjectScope = emitResolveScope(nullptr, Variable(metadata-&gt;ident()));
 200                     tolLevelScope = newBlockScopeVariable();
 201                     move(tolLevelScope.get(), tolLevelObjectScope.get());
 202                 }
 203                 emitPutToScope(tolLevelScope.get(), Variable(metadata-&gt;ident()), temp.get(), ThrowIfNotFound, InitializationMode::NotInitialization);
 204             } else
 205                 RELEASE_ASSERT_NOT_REACHED();
 206         }
 207     }
 208 
<a name="8" id="anc8"></a><span class="line-modified"> 209     bool callingClassConstructor = false;</span>
<span class="line-added"> 210     switch (constructorKind()) {</span>
<span class="line-added"> 211     case ConstructorKind::None:</span>
<span class="line-added"> 212     case ConstructorKind::Naked:</span>
<span class="line-added"> 213         break;</span>
<span class="line-added"> 214     case ConstructorKind::Base:</span>
<span class="line-added"> 215     case ConstructorKind::Extends:</span>
<span class="line-added"> 216         callingClassConstructor = !isConstructor();</span>
<span class="line-added"> 217         break;</span>
<span class="line-added"> 218     }</span>
 219     if (!callingClassConstructor)
 220         m_scopeNode-&gt;emitBytecode(*this);
 221     else {
 222         // At this point we would have emitted an unconditional throw followed by some nonsense that&#39;s
 223         // just an artifact of how this generator is structured. That code never runs, but it confuses
 224         // bytecode analyses because it constitutes an unterminated basic block. So, we terminate the
 225         // basic block the strongest way possible.
 226         emitUnreachable();
 227     }
 228 
 229     for (auto&amp; handler : m_exceptionHandlersToEmit) {
 230         Ref&lt;Label&gt; realCatchTarget = newLabel();
 231         TryData* tryData = handler.tryData;
 232 
 233         OpCatch::emit(this, handler.exceptionRegister, handler.thrownValueRegister);
 234         realCatchTarget-&gt;setLocation(*this, m_lastInstruction.offset());
 235         if (handler.completionTypeRegister.isValid()) {
 236             RegisterID completionTypeRegister { handler.completionTypeRegister };
 237             CompletionType completionType =
 238                 tryData-&gt;handlerType == HandlerType::Finally || tryData-&gt;handlerType == HandlerType::SynthesizedFinally
 239                 ? CompletionType::Throw
 240                 : CompletionType::Normal;
 241             emitLoad(&amp;completionTypeRegister, completionType);
 242         }
 243         m_codeBlock-&gt;addJumpTarget(m_lastInstruction.offset());
 244 
 245 
 246         emitJump(tryData-&gt;target.get());
 247         tryData-&gt;target = WTFMove(realCatchTarget);
 248     }
 249 
 250     m_staticPropertyAnalyzer.kill();
 251 
 252     for (auto&amp; range : m_tryRanges) {
 253         int start = range.start-&gt;bind();
 254         int end = range.end-&gt;bind();
 255 
 256         // This will happen for empty try blocks and for some cases of finally blocks:
 257         //
 258         // try {
 259         //    try {
 260         //    } finally {
 261         //        return 42;
 262         //        // *HERE*
 263         //    }
 264         // } finally {
 265         //    print(&quot;things&quot;);
 266         // }
 267         //
 268         // The return will pop scopes to execute the outer finally block. But this includes
 269         // popping the try context for the inner try. The try context is live in the fall-through
 270         // part of the finally block not because we will emit a handler that overlaps the finally,
 271         // but because we haven&#39;t yet had a chance to plant the catch target. Then when we finish
 272         // emitting code for the outer finally block, we repush the try contex, this time with a
 273         // new start index. But that means that the start index for the try range corresponding
 274         // to the inner-finally-following-the-return (marked as &quot;*HERE*&quot; above) will be greater
 275         // than the end index of the try block. This is harmless since end &lt; start handlers will
 276         // never get matched in our logic, but we do the runtime a favor and choose to not emit
 277         // such handlers at all.
 278         if (end &lt;= start)
 279             continue;
 280 
 281         UnlinkedHandlerInfo info(static_cast&lt;uint32_t&gt;(start), static_cast&lt;uint32_t&gt;(end),
 282             static_cast&lt;uint32_t&gt;(range.tryData-&gt;target-&gt;bind()), range.tryData-&gt;handlerType);
 283         m_codeBlock-&gt;addExceptionHandler(info);
 284     }
 285 
 286 
 287     if (isGeneratorOrAsyncFunctionBodyParseMode(m_codeBlock-&gt;parseMode()))
 288         performGeneratorification(*this, m_codeBlock.get(), m_writer, m_generatorFrameSymbolTable.get(), m_generatorFrameSymbolTableIndex);
 289 
 290     RELEASE_ASSERT(static_cast&lt;unsigned&gt;(m_codeBlock-&gt;numCalleeLocals()) &lt; static_cast&lt;unsigned&gt;(FirstConstantRegisterIndex));
<a name="9" id="anc9"></a><span class="line-modified"> 291     m_codeBlock-&gt;finalize(m_writer.finalize());</span>



 292     if (m_expressionTooDeep)
 293         return ParserError(ParserError::OutOfMemory);
 294     return ParserError(ParserError::ErrorNone);
 295 }
 296 
 297 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ProgramNode* programNode, UnlinkedProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<a name="10" id="anc10"></a><span class="line-modified"> 298     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 299     , m_codeGenerationMode(codeGenerationMode)</span>
 300     , m_scopeNode(programNode)
<a name="11" id="anc11"></a>
 301     , m_thisRegister(CallFrame::thisArgumentOffset())
 302     , m_codeType(GlobalCode)
 303     , m_vm(vm)
 304     , m_needsToUpdateArrowFunctionContext(programNode-&gt;usesArrowFunction() || programNode-&gt;usesEval())
 305 {
 306     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 307 
<a name="12" id="anc12"></a>




 308     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 309 
 310     emitEnter();
 311 
 312     allocateAndEmitScope();
 313 
<a name="13" id="anc13"></a><span class="line-added"> 314     emitCheckTraps();</span>
<span class="line-added"> 315 </span>
 316     const FunctionStack&amp; functionStack = programNode-&gt;functionStack();
 317 
 318     for (auto* function : functionStack)
 319         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 320 
 321     if (Options::validateBytecode()) {
 322         for (auto&amp; entry : programNode-&gt;varDeclarations())
 323             RELEASE_ASSERT(entry.value.isVar());
 324     }
 325     codeBlock-&gt;setVariableDeclarations(programNode-&gt;varDeclarations());
 326     codeBlock-&gt;setLexicalDeclarations(programNode-&gt;lexicalVariables());
 327     // Even though this program may have lexical variables that go under TDZ, when linking the get_from_scope/put_to_scope
 328     // operations we emit we will have ResolveTypes that implictly do TDZ checks. Therefore, we don&#39;t need
 329     // additional TDZ checks on top of those. This is why we can omit pushing programNode-&gt;lexicalVariables()
 330     // to the TDZ stack.
 331 
 332     if (needsToUpdateArrowFunctionContext()) {
 333         initializeArrowFunctionContextScopeIfNeeded();
 334         emitPutThisToArrowFunctionContextScope();
 335     }
 336 }
 337 
 338 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, FunctionNode* functionNode, UnlinkedFunctionCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<a name="14" id="anc14"></a><span class="line-modified"> 339     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 340     , m_codeGenerationMode(codeGenerationMode)</span>
 341     , m_scopeNode(functionNode)
<a name="15" id="anc15"></a>
 342     , m_codeType(FunctionCode)
 343     , m_vm(vm)
 344     , m_isBuiltinFunction(codeBlock-&gt;isBuiltinFunction())
 345     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 346     // FIXME: We should be able to have tail call elimination with the profiler
 347     // enabled. This is currently not possible because the profiler expects
 348     // op_will_call / op_did_call pairs before and after a call, which are not
 349     // compatible with tail calls (we have no way of emitting op_did_call).
 350     // https://bugs.webkit.org/show_bug.cgi?id=148819
<a name="16" id="anc16"></a><span class="line-added"> 351     //</span>
<span class="line-added"> 352     // Note that we intentionally enable tail call for naked constructors since it does not have special code for &quot;return&quot;.</span>
 353     , m_inTailPosition(Options::useTailCalls() &amp;&amp; !isConstructor() &amp;&amp; constructorKind() == ConstructorKind::None &amp;&amp; isStrictMode())
 354     , m_needsToUpdateArrowFunctionContext(functionNode-&gt;usesArrowFunction() || functionNode-&gt;usesEval())
 355     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 356 {
<a name="17" id="anc17"></a>




 357     SymbolTable* functionSymbolTable = SymbolTable::create(m_vm);
 358     functionSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 359     int symbolTableConstantIndex = 0;
 360 
 361     FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 362     // http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
 363     // This implements IsSimpleParameterList in the Ecma 2015 spec.
 364     // If IsSimpleParameterList is false, we will create a strict-mode like arguments object.
 365     // IsSimpleParameterList is false if the argument list contains any default parameter values,
 366     // a rest parameter, or any destructuring patterns.
 367     // If we do have default parameters, destructuring parameters, or a rest parameter, our parameters will be allocated in a different scope.
 368     bool isSimpleParameterList = parameters.isSimpleParameterList();
 369 
 370     SourceParseMode parseMode = codeBlock-&gt;parseMode();
 371 
 372     bool containsArrowOrEvalButNotInArrowBlock = ((functionNode-&gt;usesArrowFunction() &amp;&amp; functionNode-&gt;doAnyInnerArrowFunctionsUseAnyFeature()) || functionNode-&gt;usesEval()) &amp;&amp; !m_codeBlock-&gt;isArrowFunction();
 373     bool shouldCaptureSomeOfTheThings = shouldEmitDebugHooks() || functionNode-&gt;needsActivation() || containsArrowOrEvalButNotInArrowBlock;
 374 
 375     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
<a name="18" id="anc18"></a><span class="line-modified"> 376     bool needsArguments = ((functionNode-&gt;usesArguments() &amp;&amp; !codeBlock-&gt;isArrowFunction()) || codeBlock-&gt;usesEval() || (functionNode-&gt;usesArrowFunction() &amp;&amp; !codeBlock-&gt;isArrowFunction() &amp;&amp; isArgumentsUsedInInnerArrowFunction())) &amp;&amp; parseMode != SourceParseMode::InstanceFieldInitializerMode;</span>
 377 
 378     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 379         // Generator and AsyncFunction never provides &quot;arguments&quot;. &quot;arguments&quot; reference will be resolved in an upper generator function scope.
 380         needsArguments = false;
 381     }
 382 
 383     if (isGeneratorOrAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; needsArguments) {
 384         // Generator does not provide &quot;arguments&quot;. Instead, wrapping GeneratorFunction provides &quot;arguments&quot;.
 385         // This is because arguments of a generator should be evaluated before starting it.
 386         // To workaround it, we evaluate these arguments as arguments of a wrapping generator function, and reference it from a generator.
 387         //
 388         //    function *gen(a, b = hello())
 389         //    {
 390         //        return {
 391         //            @generatorNext: function (@generator, @generatorState, @generatorValue, @generatorResumeMode, @generatorFrame)
 392         //            {
 393         //                arguments;  // This `arguments` should reference to the gen&#39;s arguments.
 394         //                ...
 395         //            }
 396         //        }
 397         //    }
 398         shouldCaptureSomeOfTheThings = true;
 399     }
 400 
 401     if (shouldCaptureAllOfTheThings)
 402         functionNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 403 
 404     auto captures = scopedLambda&lt;bool (UniquedStringImpl*)&gt;([&amp;] (UniquedStringImpl* uid) -&gt; bool {
 405         if (!shouldCaptureSomeOfTheThings)
 406             return false;
 407         if (needsArguments &amp;&amp; uid == propertyNames().arguments.impl()) {
 408             // Actually, we only need to capture the arguments object when we &quot;need full activation&quot;
 409             // because of name scopes. But historically we did it this way, so for now we just preserve
 410             // the old behavior.
 411             // FIXME: https://bugs.webkit.org/show_bug.cgi?id=143072
 412             return true;
 413         }
 414         return functionNode-&gt;captures(uid);
 415     });
 416     auto varKind = [&amp;] (UniquedStringImpl* uid) -&gt; VarKind {
 417         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 418     };
 419 
 420     m_calleeRegister.setIndex(CallFrameSlot::callee);
 421 
 422     initializeParameters(parameters);
 423     ASSERT(!(isSimpleParameterList &amp;&amp; m_restParameter));
 424 
 425     emitEnter();
 426 
 427     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode))
 428         m_generatorRegister = &amp;m_parameters[1];
 429 
 430     allocateAndEmitScope();
 431 
<a name="19" id="anc19"></a><span class="line-added"> 432     emitCheckTraps();</span>
<span class="line-added"> 433 </span>
 434     if (functionNameIsInScope(functionNode-&gt;ident(), functionNode-&gt;functionMode())) {
 435         ASSERT(parseMode != SourceParseMode::GeneratorBodyMode);
 436         ASSERT(!isAsyncFunctionBodyParseMode(parseMode));
 437         bool isDynamicScope = functionNameScopeIsDynamic(codeBlock-&gt;usesEval(), codeBlock-&gt;isStrictMode());
 438         bool isFunctionNameCaptured = captures(functionNode-&gt;ident().impl());
 439         bool markAsCaptured = isDynamicScope || isFunctionNameCaptured;
 440         emitPushFunctionNameScope(functionNode-&gt;ident(), &amp;m_calleeRegister, markAsCaptured);
 441     }
 442 
 443     if (shouldCaptureSomeOfTheThings)
 444         m_lexicalEnvironmentRegister = addVar();
 445 
 446     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode) || shouldCaptureSomeOfTheThings || shouldEmitTypeProfilerHooks())
 447         symbolTableConstantIndex = addConstantValue(functionSymbolTable)-&gt;index();
 448 
 449     // We can allocate the &quot;var&quot; environment if we don&#39;t have default parameter expressions. If we have
 450     // default parameter expressions, we have to hold off on allocating the &quot;var&quot; environment because
 451     // the parent scope of the &quot;var&quot; environment is the parameter environment.
 452     if (isSimpleParameterList)
 453         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, shouldCaptureSomeOfTheThings);
 454 
 455     // Figure out some interesting facts about our arguments.
 456     bool capturesAnyArgumentByName = false;
 457     if (functionNode-&gt;hasCapturedVariables()) {
 458         FunctionParameters&amp; parameters = *functionNode-&gt;parameters();
 459         for (size_t i = 0; i &lt; parameters.size(); ++i) {
 460             auto pattern = parameters.at(i).first;
 461             if (!pattern-&gt;isBindingNode())
 462                 continue;
 463             const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
 464             capturesAnyArgumentByName |= captures(ident.impl());
 465         }
 466     }
 467 
 468     if (capturesAnyArgumentByName)
 469         ASSERT(m_lexicalEnvironmentRegister);
 470 
 471     // Need to know what our functions are called. Parameters have some goofy behaviors when it
 472     // comes to functions of the same name.
 473     for (FunctionMetadataNode* function : functionNode-&gt;functionStack())
 474         m_functions.add(function-&gt;ident().impl());
 475 
 476     if (needsArguments) {
 477         // Create the arguments object now. We may put the arguments object into the activation if
 478         // it is captured. Either way, we create two arguments object variables: one is our
 479         // private variable that is immutable, and another that is the user-visible variable. The
 480         // immutable one is only used here, or during formal parameter resolutions if we opt for
 481         // DirectArguments.
 482 
 483         m_argumentsRegister = addVar();
 484         m_argumentsRegister-&gt;ref();
 485     }
 486 
 487     if (needsArguments &amp;&amp; !codeBlock-&gt;isStrictMode() &amp;&amp; isSimpleParameterList) {
 488         // If we captured any formal parameter by name, then we use ScopedArguments. Otherwise we
 489         // use DirectArguments. With ScopedArguments, we lift all of our arguments into the
 490         // activation.
 491 
 492         if (capturesAnyArgumentByName) {
 493             functionSymbolTable-&gt;setArgumentsLength(vm, parameters.size());
 494 
 495             // For each parameter, we have two possibilities:
 496             // Either it&#39;s a binding node with no function overlap, in which case it gets a name
 497             // in the symbol table - or it just gets space reserved in the symbol table. Either
 498             // way we lift the value into the scope.
 499             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 500                 ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 501                 functionSymbolTable-&gt;setArgumentOffset(vm, i, offset);
 502                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first)) {
 503                     VarOffset varOffset(offset);
 504                     SymbolTableEntry entry(varOffset);
 505                     // Stores to these variables via the ScopedArguments object will not do
 506                     // notifyWrite(), since that would be cumbersome. Also, watching formal
 507                     // parameters when &quot;arguments&quot; is in play is unlikely to be super profitable.
 508                     // So, we just disable it.
 509                     entry.disableWatching(m_vm);
 510                     functionSymbolTable-&gt;set(NoLockingNecessary, name, entry);
 511                 }
<a name="20" id="anc20"></a><span class="line-modified"> 512                 OpPutToScope::emit(this, m_lexicalEnvironmentRegister, UINT_MAX, virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 513             }
 514 
 515             // This creates a scoped arguments object and copies the overflow arguments into the
 516             // scope. It&#39;s the equivalent of calling ScopedArguments::createByCopying().
 517             OpCreateScopedArguments::emit(this, m_argumentsRegister, m_lexicalEnvironmentRegister);
 518         } else {
 519             // We&#39;re going to put all parameters into the DirectArguments object. First ensure
 520             // that the symbol table knows that this is happening.
 521             for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 522                 if (UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first))
 523                     functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(DirectArgumentsOffset(i))));
 524             }
 525 
 526             OpCreateDirectArguments::emit(this, m_argumentsRegister);
 527         }
 528     } else if (isSimpleParameterList) {
 529         // Create the formal parameters the normal way. Any of them could be captured, or not. If
 530         // captured, lift them into the scope. We cannot do this if we have default parameter expressions
 531         // because when default parameter expressions exist, they belong in their own lexical environment
 532         // separate from the &quot;var&quot; lexical environment.
 533         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 534             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 535             if (!name)
 536                 continue;
 537 
 538             if (!captures(name)) {
 539                 // This is the easy case - just tell the symbol table about the argument. It will
 540                 // be accessed directly.
<a name="21" id="anc21"></a><span class="line-modified"> 541                 functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(virtualRegisterForArgumentIncludingThis(1 + i))));</span>
 542                 continue;
 543             }
 544 
 545             ScopeOffset offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
 546             const Identifier&amp; ident =
 547                 static_cast&lt;const BindingNode*&gt;(parameters.at(i).first)-&gt;boundProperty();
 548             functionSymbolTable-&gt;set(NoLockingNecessary, name, SymbolTableEntry(VarOffset(offset)));
 549 
<a name="22" id="anc22"></a><span class="line-modified"> 550             OpPutToScope::emit(this, m_lexicalEnvironmentRegister, addConstant(ident), virtualRegisterForArgumentIncludingThis(1 + i), GetPutInfo(ThrowIfNotFound, LocalClosureVar, InitializationMode::NotInitialization), SymbolTableOrScopeDepth::symbolTable(VirtualRegister { symbolTableConstantIndex }), offset.offset());</span>
 551         }
 552     }
 553 
 554     if (needsArguments &amp;&amp; (codeBlock-&gt;isStrictMode() || !isSimpleParameterList)) {
 555         // Allocate a cloned arguments object.
 556         OpCreateClonedArguments::emit(this, m_argumentsRegister);
 557     }
 558 
 559     // There are some variables that need to be preinitialized to something other than Undefined:
 560     //
 561     // - &quot;arguments&quot;: unless it&#39;s used as a function or parameter, this should refer to the
 562     //   arguments object.
 563     //
 564     // - functions: these always override everything else.
 565     //
 566     // The most logical way to do all of this is to initialize none of the variables until now,
 567     // and then initialize them in BytecodeGenerator::generate() in such an order that the rules
 568     // for how these things override each other end up holding. We would initialize &quot;arguments&quot; first,
 569     // then all arguments, then the functions.
 570     //
 571     // But some arguments are already initialized by default, since if they aren&#39;t captured and we
 572     // don&#39;t have &quot;arguments&quot; then we just point the symbol table at the stack slot of those
 573     // arguments. We end up initializing the rest of the arguments that have an uncomplicated
 574     // binding (i.e. don&#39;t involve destructuring) above when figuring out how to lay them out,
 575     // because that&#39;s just the simplest thing. This means that when we initialize them, we have to
 576     // watch out for the things that override arguments (namely, functions).
 577 
 578     // This is our final act of weirdness. &quot;arguments&quot; is overridden by everything except the
 579     // callee. We add it to the symbol table if it&#39;s not already there and it&#39;s not an argument.
 580     bool shouldCreateArgumentsVariableInParameterScope = false;
 581     if (needsArguments) {
 582         // If &quot;arguments&quot; is overridden by a function or destructuring parameter name, then it&#39;s
 583         // OK for us to call createVariable() because it won&#39;t change anything. It&#39;s also OK for
 584         // us to them tell BytecodeGenerator::generate() to write to it because it will do so
 585         // before it initializes functions and destructuring parameters. But if &quot;arguments&quot; is
 586         // overridden by a &quot;simple&quot; function parameter, then we have to bail: createVariable()
 587         // would assert and BytecodeGenerator::generate() would write the &quot;arguments&quot; after the
 588         // argument value had already been properly initialized.
 589 
 590         bool haveParameterNamedArguments = false;
 591         for (unsigned i = 0; i &lt; parameters.size(); ++i) {
 592             UniquedStringImpl* name = visibleNameForParameter(parameters.at(i).first);
 593             if (name == propertyNames().arguments.impl()) {
 594                 haveParameterNamedArguments = true;
 595                 break;
 596             }
 597         }
 598 
 599         bool shouldCreateArgumensVariable = !haveParameterNamedArguments
<a name="23" id="anc23"></a><span class="line-modified"> 600             &amp;&amp; !SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode, SourceParseMode::InstanceFieldInitializerMode).contains(m_codeBlock-&gt;parseMode());</span>
 601         shouldCreateArgumentsVariableInParameterScope = shouldCreateArgumensVariable &amp;&amp; !isSimpleParameterList;
 602         // Do not create arguments variable in case of Arrow function. Value will be loaded from parent scope
 603         if (shouldCreateArgumensVariable &amp;&amp; !shouldCreateArgumentsVariableInParameterScope) {
 604             createVariable(
 605                 propertyNames().arguments, varKind(propertyNames().arguments.impl()), functionSymbolTable);
 606 
 607             m_needToInitializeArguments = true;
 608         }
 609     }
 610 
 611     for (FunctionMetadataNode* function : functionNode-&gt;functionStack()) {
 612         const Identifier&amp; ident = function-&gt;ident();
 613         createVariable(ident, varKind(ident.impl()), functionSymbolTable);
 614         m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
 615     }
 616     for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
 617         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 618         if (!entry.value.isVar()) // This is either a parameter or callee.
 619             continue;
 620         if (shouldCreateArgumentsVariableInParameterScope &amp;&amp; entry.key.get() == propertyNames().arguments.impl())
 621             continue;
 622         createVariable(Identifier::fromUid(m_vm, entry.key.get()), varKind(entry.key.get()), functionSymbolTable, IgnoreExisting);
 623     }
 624 
 625 
 626     if (functionNode-&gt;needsNewTargetRegisterForThisScope() || isNewTargetUsedInInnerArrowFunction() || codeBlock-&gt;usesEval())
 627         m_newTargetRegister = addVar();
 628 
 629     switch (parseMode) {
 630     case SourceParseMode::GeneratorWrapperFunctionMode:
<a name="24" id="anc24"></a><span class="line-modified"> 631     case SourceParseMode::GeneratorWrapperMethodMode: {</span>
<span class="line-added"> 632         m_generatorRegister = addVar();</span>
<span class="line-added"> 633 </span>
<span class="line-added"> 634         // FIXME: Emit to_this only when Generator uses it.</span>
<span class="line-added"> 635         // https://bugs.webkit.org/show_bug.cgi?id=151586</span>
<span class="line-added"> 636         emitToThis();</span>
<span class="line-added"> 637 </span>
<span class="line-added"> 638         emitCreateGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>
<span class="line-added"> 639         break;</span>
<span class="line-added"> 640     }</span>
<span class="line-added"> 641 </span>
 642     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 643     case SourceParseMode::AsyncGeneratorWrapperFunctionMode: {
 644         m_generatorRegister = addVar();
 645 
 646         // FIXME: Emit to_this only when Generator uses it.
 647         // https://bugs.webkit.org/show_bug.cgi?id=151586
 648         emitToThis();
 649 
<a name="25" id="anc25"></a><span class="line-modified"> 650         emitCreateAsyncGenerator(m_generatorRegister, &amp;m_calleeRegister);</span>

 651         break;
 652     }
 653 
 654     case SourceParseMode::AsyncArrowFunctionMode:
 655     case SourceParseMode::AsyncMethodMode:
 656     case SourceParseMode::AsyncFunctionMode: {
 657         ASSERT(!isConstructor());
 658         ASSERT(constructorKind() == ConstructorKind::None);
 659         m_generatorRegister = addVar();
<a name="26" id="anc26"></a><span class="line-modified"> 660         m_promiseRegister = addVar();</span>
 661 
 662         if (parseMode != SourceParseMode::AsyncArrowFunctionMode) {
 663             // FIXME: Emit to_this only when AsyncFunctionBody uses it.
 664             // https://bugs.webkit.org/show_bug.cgi?id=151586
 665             emitToThis();
 666         }
 667 
<a name="27" id="anc27"></a><span class="line-modified"> 668         emitNewGenerator(m_generatorRegister);</span>
<span class="line-modified"> 669         emitNewPromise(promiseRegister(), m_isBuiltinFunction);</span>

















 670         break;
 671     }
 672 
 673     case SourceParseMode::AsyncGeneratorBodyMode:
 674     case SourceParseMode::AsyncFunctionBodyMode:
 675     case SourceParseMode::AsyncArrowFunctionBodyMode:
 676     case SourceParseMode::GeneratorBodyMode: {
 677         // |this| is already filled correctly before here.
 678         if (m_newTargetRegister)
 679             emitLoad(m_newTargetRegister, jsUndefined());
 680         break;
 681     }
 682 
 683     default: {
 684         if (SourceParseMode::ArrowFunctionMode != parseMode) {
 685             if (isConstructor()) {
 686                 if (m_newTargetRegister)
 687                     move(m_newTargetRegister, &amp;m_thisRegister);
<a name="28" id="anc28"></a><span class="line-modified"> 688                 switch (constructorKind()) {</span>
<span class="line-modified"> 689                 case ConstructorKind::Naked:</span>
<span class="line-modified"> 690                     // Naked constructor not create |this| automatically.</span>
<span class="line-added"> 691                     break;</span>
<span class="line-added"> 692                 case ConstructorKind::None:</span>
<span class="line-added"> 693                 case ConstructorKind::Base:</span>
 694                     emitCreateThis(&amp;m_thisRegister);
<a name="29" id="anc29"></a><span class="line-modified"> 695                     if (Options::useClassFields())</span>
<span class="line-modified"> 696                         emitInstanceFieldInitializationIfNeeded(&amp;m_thisRegister, &amp;m_calleeRegister, m_scopeNode-&gt;position(), m_scopeNode-&gt;position(), m_scopeNode-&gt;position());</span>
<span class="line-modified"> 697                     break;</span>
<span class="line-modified"> 698                 case ConstructorKind::Extends:</span>
<span class="line-modified"> 699                     moveEmptyValue(&amp;m_thisRegister);</span>
<span class="line-modified"> 700                     break;</span>
<span class="line-modified"> 701                 }</span>
<span class="line-modified"> 702             } else {</span>
<span class="line-modified"> 703                 switch (constructorKind()) {</span>
<span class="line-modified"> 704                 case ConstructorKind::None: {</span>
<span class="line-modified"> 705                     bool shouldEmitToThis = false;</span>
<span class="line-modified"> 706                     if (functionNode-&gt;usesThis() || codeBlock-&gt;usesEval() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval())</span>
<span class="line-modified"> 707                         shouldEmitToThis = true;</span>
<span class="line-modified"> 708                     else if ((functionNode-&gt;usesSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty()) &amp;&amp; !codeBlock-&gt;isStrictMode()) {</span>
<span class="line-modified"> 709                         // We must emit to_this when we&#39;re not in strict mode because we</span>
<span class="line-modified"> 710                         // will convert |this| to an object, and that object may be passed</span>
<span class="line-modified"> 711                         // to a strict function as |this|. This is observable because that</span>
<span class="line-modified"> 712                         // strict function&#39;s to_this will just return the object.</span>
<span class="line-modified"> 713                         //</span>
<span class="line-added"> 714                         // We don&#39;t need to emit this for strict-mode code because</span>
<span class="line-added"> 715                         // strict-mode code may call another strict function, which will</span>
<span class="line-added"> 716                         // to_this if it directly uses this; this is OK, because we defer</span>
<span class="line-added"> 717                         // to_this until |this| is used directly. Strict-mode code might</span>
<span class="line-added"> 718                         // also call a sloppy mode function, and that will to_this, which</span>
<span class="line-added"> 719                         // will defer the conversion, again, until necessary.</span>
<span class="line-added"> 720                         shouldEmitToThis = true;</span>
<span class="line-added"> 721                     }</span>
<span class="line-added"> 722 </span>
<span class="line-added"> 723                     if (shouldEmitToThis)</span>
<span class="line-added"> 724                         emitToThis();</span>
<span class="line-added"> 725                     break;</span>
<span class="line-added"> 726                 }</span>
<span class="line-added"> 727                 case ConstructorKind::Naked:</span>
<span class="line-added"> 728                     emitThrowTypeError(&quot;Cannot call a constructor without |new|&quot;);</span>
<span class="line-added"> 729                     break;</span>
<span class="line-added"> 730                 case ConstructorKind::Base:</span>
<span class="line-added"> 731                 case ConstructorKind::Extends:</span>
<span class="line-added"> 732                     emitThrowTypeError(&quot;Cannot call a class constructor without |new|&quot;);</span>
<span class="line-added"> 733                     break;</span>
 734                 }
<a name="30" id="anc30"></a>


 735             }
 736         }
 737         break;
 738     }
 739     }
 740 
 741     // We need load |super| &amp; |this| for arrow function before initializeDefaultParameterValuesAndSetupFunctionScopeStack
 742     // if we have default parameter expression. Because |super| &amp; |this| values can be used there
 743     if ((SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; !isSimpleParameterList) || parseMode == SourceParseMode::AsyncArrowFunctionBodyMode) {
 744         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 745             emitLoadThisFromArrowFunctionLexicalEnvironment();
 746 
 747         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 748             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 749     }
 750 
 751     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunction()) {
 752         bool canReuseLexicalEnvironment = isSimpleParameterList;
 753         initializeArrowFunctionContextScopeIfNeeded(functionSymbolTable, canReuseLexicalEnvironment);
 754         emitPutThisToArrowFunctionContextScope();
 755         emitPutNewTargetToArrowFunctionContextScope();
 756         emitPutDerivedConstructorToArrowFunctionContextScope();
 757     }
 758 
 759     // All &quot;addVar()&quot;s needs to happen before &quot;initializeDefaultParameterValuesAndSetupFunctionScopeStack()&quot; is called
 760     // because a function&#39;s default parameter ExpressionNodes will use temporary registers.
 761     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 762 
 763     Ref&lt;Label&gt; catchLabel = newLabel();
 764     TryData* tryFormalParametersData = nullptr;
 765     bool needTryCatch = isAsyncFunctionWrapperParseMode(parseMode) &amp;&amp; !isSimpleParameterList;
 766     if (needTryCatch) {
 767         Ref&lt;Label&gt; tryFormalParametersStart = newEmittedLabel();
 768         tryFormalParametersData = pushTry(tryFormalParametersStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
 769     }
 770 
 771     initializeDefaultParameterValuesAndSetupFunctionScopeStack(parameters, isSimpleParameterList, functionNode, functionSymbolTable, symbolTableConstantIndex, captures, shouldCreateArgumentsVariableInParameterScope);
 772 
 773     if (needTryCatch) {
 774         Ref&lt;Label&gt; didNotThrow = newLabel();
 775         emitJump(didNotThrow.get());
 776         emitLabel(catchLabel.get());
 777         popTry(tryFormalParametersData, catchLabel.get());
 778 
 779         RefPtr&lt;RegisterID&gt; thrownValue = newTemporary();
 780         emitOutOfLineCatchHandler(thrownValue.get(), nullptr, tryFormalParametersData);
 781 
<a name="31" id="anc31"></a><span class="line-modified"> 782         // @rejectPromiseWithFirstResolvingFunctionCallCheck(@promise, thrownValue);</span>
<span class="line-modified"> 783         // return @promise;</span>
<span class="line-modified"> 784         RefPtr&lt;RegisterID&gt; rejectPromise = moveLinkTimeConstant(nullptr, LinkTimeConstant::rejectPromiseWithFirstResolvingFunctionCallCheck);</span>
<span class="line-modified"> 785         CallArguments args(*this, nullptr, 2);</span>
 786         emitLoad(args.thisRegister(), jsUndefined());
<a name="32" id="anc32"></a><span class="line-modified"> 787         move(args.argumentRegister(0), promiseRegister());</span>
<span class="line-modified"> 788         move(args.argumentRegister(1), thrownValue.get());</span>
 789         JSTextPosition divot(functionNode-&gt;firstLine(), functionNode-&gt;startOffset(), functionNode-&gt;lineStartOffset());
<a name="33" id="anc33"></a><span class="line-added"> 790         emitCall(newTemporary(), rejectPromise.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);</span>
 791 
<a name="34" id="anc34"></a><span class="line-modified"> 792         emitReturn(promiseRegister());</span>


 793         emitLabel(didNotThrow.get());
 794     }
 795 
 796     // If we don&#39;t have  default parameter expression, then loading |this| inside an arrow function must be done
 797     // after initializeDefaultParameterValuesAndSetupFunctionScopeStack() because that function sets up the
 798     // SymbolTable stack and emitLoadThisFromArrowFunctionLexicalEnvironment() consults the SymbolTable stack
 799     if (SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(parseMode) &amp;&amp; isSimpleParameterList) {
 800         if (functionNode-&gt;usesThis() || functionNode-&gt;usesSuperProperty())
 801             emitLoadThisFromArrowFunctionLexicalEnvironment();
 802 
 803         if (m_scopeNode-&gt;needsNewTargetRegisterForThisScope())
 804             emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 805     }
 806 
 807     // Set up the lexical environment scope as the generator frame. We store the saved and resumed generator registers into this scope with the symbol keys.
 808     // Since they are symbol keyed, these variables cannot be reached from the usual code.
 809     if (isGeneratorOrAsyncFunctionBodyParseMode(parseMode)) {
 810         m_generatorFrameSymbolTable.set(m_vm, functionSymbolTable);
 811         m_generatorFrameSymbolTableIndex = symbolTableConstantIndex;
 812         if (m_lexicalEnvironmentRegister)
 813             move(generatorFrameRegister(), m_lexicalEnvironmentRegister);
 814         else {
 815             // It would be possible that generator does not need to suspend and resume any registers.
 816             // In this case, we would like to avoid creating a lexical environment as much as possible.
 817             // op_create_generator_frame_environment is a marker, which is similar to op_yield.
 818             // Generatorification inserts lexical environment creation if necessary. Otherwise, we convert it to op_mov frame, `undefined`.
 819             OpCreateGeneratorFrameEnvironment::emit(this, generatorFrameRegister(), scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
 820         }
<a name="35" id="anc35"></a><span class="line-modified"> 821         static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Frame));</span>
<span class="line-added"> 822         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::Frame), generatorFrameRegister());</span>
 823     }
 824 
 825     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 826     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 827 }
 828 
 829 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, EvalNode* evalNode, UnlinkedEvalCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<a name="36" id="anc36"></a><span class="line-modified"> 830     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 831     , m_codeGenerationMode(codeGenerationMode)</span>
 832     , m_scopeNode(evalNode)
<a name="37" id="anc37"></a>
 833     , m_thisRegister(CallFrame::thisArgumentOffset())
 834     , m_codeType(EvalCode)
 835     , m_vm(vm)
 836     , m_usesNonStrictEval(codeBlock-&gt;usesEval() &amp;&amp; !codeBlock-&gt;isStrictMode())
 837     , m_needsToUpdateArrowFunctionContext(evalNode-&gt;usesArrowFunction() || evalNode-&gt;usesEval())
 838     , m_derivedContextType(codeBlock-&gt;derivedContextType())
 839 {
<a name="38" id="anc38"></a>




 840     m_codeBlock-&gt;setNumParameters(1);
 841 
 842     pushTDZVariables(*parentScopeTDZVariables, TDZCheckOptimization::DoNotOptimize, TDZRequirement::UnderTDZ);
 843 
 844     emitEnter();
 845 
 846     allocateAndEmitScope();
 847 
<a name="39" id="anc39"></a><span class="line-added"> 848     emitCheckTraps();</span>
<span class="line-added"> 849 </span>
 850     for (FunctionMetadataNode* function : evalNode-&gt;functionStack()) {
 851         m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
 852         m_functionsToInitialize.append(std::make_pair(function, TopLevelFunctionVariable));
 853     }
 854 
 855     const VariableEnvironment&amp; varDeclarations = evalNode-&gt;varDeclarations();
 856     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; variables;
 857     Vector&lt;Identifier, 0, UnsafeVectorOverflow&gt; hoistedFunctions;
 858     for (auto&amp; entry : varDeclarations) {
 859         ASSERT(entry.value.isVar());
 860         ASSERT(entry.key-&gt;isAtom() || entry.key-&gt;isSymbol());
 861         if (entry.value.isSloppyModeHoistingCandidate())
 862             hoistedFunctions.append(Identifier::fromUid(m_vm, entry.key.get()));
 863         else
 864             variables.append(Identifier::fromUid(m_vm, entry.key.get()));
 865     }
 866     codeBlock-&gt;adoptVariables(variables);
 867     codeBlock-&gt;adoptFunctionHoistingCandidates(WTFMove(hoistedFunctions));
 868 
 869     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 870         m_newTargetRegister = addVar();
 871 
 872     if (codeBlock-&gt;isArrowFunctionContext() &amp;&amp; (evalNode-&gt;usesThis() || evalNode-&gt;usesSuperProperty()))
 873         emitLoadThisFromArrowFunctionLexicalEnvironment();
 874 
 875     if (evalNode-&gt;needsNewTargetRegisterForThisScope())
 876         emitLoadNewTargetFromArrowFunctionLexicalEnvironment();
 877 
 878     if (needsToUpdateArrowFunctionContext() &amp;&amp; !codeBlock-&gt;isArrowFunctionContext() &amp;&amp; !isDerivedConstructorContext()) {
 879         initializeArrowFunctionContextScopeIfNeeded();
 880         emitPutThisToArrowFunctionContextScope();
 881     }
 882 
 883     bool shouldInitializeBlockScopedFunctions = false; // We generate top-level function declarations in ::generate().
 884     pushLexicalScope(m_scopeNode, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, shouldInitializeBlockScopedFunctions);
 885 }
 886 
 887 BytecodeGenerator::BytecodeGenerator(VM&amp; vm, ModuleProgramNode* moduleProgramNode, UnlinkedModuleProgramCodeBlock* codeBlock, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode, const VariableEnvironment* parentScopeTDZVariables)
<a name="40" id="anc40"></a><span class="line-modified"> 888     : BytecodeGeneratorBase(makeUnique&lt;UnlinkedCodeBlockGenerator&gt;(vm, codeBlock), CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters())</span>
<span class="line-added"> 889     , m_codeGenerationMode(codeGenerationMode)</span>
 890     , m_scopeNode(moduleProgramNode)
<a name="41" id="anc41"></a>
 891     , m_thisRegister(CallFrame::thisArgumentOffset())
 892     , m_codeType(ModuleCode)
 893     , m_vm(vm)
 894     , m_usesNonStrictEval(false)
 895     , m_needsToUpdateArrowFunctionContext(moduleProgramNode-&gt;usesArrowFunction() || moduleProgramNode-&gt;usesEval())
 896 {
 897     ASSERT_UNUSED(parentScopeTDZVariables, !parentScopeTDZVariables-&gt;size());
 898 
<a name="42" id="anc42"></a>




 899     SymbolTable* moduleEnvironmentSymbolTable = SymbolTable::create(m_vm);
 900     moduleEnvironmentSymbolTable-&gt;setUsesNonStrictEval(m_usesNonStrictEval);
 901     moduleEnvironmentSymbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
 902 
 903     bool shouldCaptureAllOfTheThings = shouldEmitDebugHooks() || codeBlock-&gt;usesEval();
 904     if (shouldCaptureAllOfTheThings)
 905         moduleProgramNode-&gt;varDeclarations().markAllVariablesAsCaptured();
 906 
 907     auto captures = [&amp;] (UniquedStringImpl* uid) -&gt; bool {
 908         return moduleProgramNode-&gt;captures(uid);
 909     };
 910     auto lookUpVarKind = [&amp;] (UniquedStringImpl* uid, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
 911         // Allocate the exported variables in the module environment.
 912         if (entry.isExported())
 913             return VarKind::Scope;
 914 
 915         // Allocate the namespace variables in the module environment to instantiate
 916         // it from the outside of the module code.
 917         if (entry.isImportedNamespace())
 918             return VarKind::Scope;
 919 
 920         if (entry.isCaptured())
 921             return VarKind::Scope;
 922         return captures(uid) ? VarKind::Scope : VarKind::Stack;
 923     };
 924 
 925     emitEnter();
 926 
 927     allocateAndEmitScope();
 928 
<a name="43" id="anc43"></a><span class="line-added"> 929     emitCheckTraps();</span>
<span class="line-added"> 930 </span>
 931     m_calleeRegister.setIndex(CallFrameSlot::callee);
 932 
 933     m_codeBlock-&gt;setNumParameters(1); // Allocate space for &quot;this&quot;
 934 
 935     // Now declare all variables.
 936 
 937     createVariable(m_vm.propertyNames-&gt;builtinNames().metaPrivateName(), VarKind::Scope, moduleEnvironmentSymbolTable, VerifyExisting);
 938 
 939     for (auto&amp; entry : moduleProgramNode-&gt;varDeclarations()) {
 940         ASSERT(!entry.value.isLet() &amp;&amp; !entry.value.isConst());
 941         if (!entry.value.isVar()) // This is either a parameter or callee.
 942             continue;
 943         // Imported bindings are not allocated in the module environment as usual variables&#39; way.
 944         // These references remain the &quot;Dynamic&quot; in the unlinked code block. Later, when linking
 945         // the code block, we resolve the reference to the &quot;ModuleVar&quot;.
 946         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
 947             continue;
 948         createVariable(Identifier::fromUid(m_vm, entry.key.get()), lookUpVarKind(entry.key.get(), entry.value), moduleEnvironmentSymbolTable, IgnoreExisting);
 949     }
 950 
 951     VariableEnvironment&amp; lexicalVariables = moduleProgramNode-&gt;lexicalVariables();
 952     instantiateLexicalVariables(lexicalVariables, moduleEnvironmentSymbolTable, ScopeRegisterType::Block, lookUpVarKind);
 953 
 954     // We keep the symbol table in the constant pool.
 955     RegisterID* constantSymbolTable = nullptr;
 956     if (shouldEmitTypeProfilerHooks())
 957         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable);
 958     else
 959         constantSymbolTable = addConstantValue(moduleEnvironmentSymbolTable-&gt;cloneScopePart(m_vm));
 960 
 961     pushTDZVariables(lexicalVariables, TDZCheckOptimization::Optimize, TDZRequirement::UnderTDZ);
 962     bool isWithScope = false;
 963     m_lexicalScopeStack.append({ moduleEnvironmentSymbolTable, m_topMostScope, isWithScope, constantSymbolTable-&gt;index() });
 964     emitPrefillStackTDZVariables(lexicalVariables, moduleEnvironmentSymbolTable);
 965 
 966     // makeFunction assumes that there&#39;s correct TDZ stack entries.
 967     // So it should be called after putting our lexical environment to the TDZ stack correctly.
 968 
 969     for (FunctionMetadataNode* function : moduleProgramNode-&gt;functionStack()) {
 970         const auto&amp; iterator = moduleProgramNode-&gt;varDeclarations().find(function-&gt;ident().impl());
 971         RELEASE_ASSERT(iterator != moduleProgramNode-&gt;varDeclarations().end());
 972         RELEASE_ASSERT(!iterator-&gt;value.isImported());
 973 
 974         VarKind varKind = lookUpVarKind(iterator-&gt;key.get(), iterator-&gt;value);
 975         if (varKind == VarKind::Scope) {
 976             // http://www.ecma-international.org/ecma-262/6.0/#sec-moduledeclarationinstantiation
 977             // Section 15.2.1.16.4, step 16-a-iv-1.
 978             // All heap allocated function declarations should be instantiated when the module environment
 979             // is created. They include the exported function declarations and not-exported-but-heap-allocated
 980             // function declarations. This is required because exported function should be instantiated before
 981             // executing the any module in the dependency graph. This enables the modules to link the imported
 982             // bindings before executing the any module code.
 983             //
 984             // And since function declarations are instantiated before executing the module body code, the spec
 985             // allows the functions inside the module to be executed before its module body is executed under
 986             // the circular dependencies. The following is the example.
 987             //
 988             // Module A (executed first):
 989             //    import { b } from &quot;B&quot;;
 990             //    // Here, the module &quot;B&quot; is not executed yet, but the function declaration is already instantiated.
 991             //    // So we can call the function exported from &quot;B&quot;.
 992             //    b();
 993             //
 994             //    export function a() {
 995             //    }
 996             //
 997             // Module B (executed second):
 998             //    import { a } from &quot;A&quot;;
 999             //
1000             //    export function b() {
1001             //        c();
1002             //    }
1003             //
1004             //    // c is not exported, but since it is referenced from the b, we should instantiate it before
1005             //    // executing the &quot;B&quot; module code.
1006             //    function c() {
1007             //        a();
1008             //    }
1009             //
1010             // Module EntryPoint (executed last):
1011             //    import &quot;B&quot;;
1012             //    import &quot;A&quot;;
1013             //
1014             m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
1015         } else {
1016             // Stack allocated functions can be allocated when executing the module&#39;s body.
1017             m_functionsToInitialize.append(std::make_pair(function, NormalFunctionVariable));
1018         }
1019     }
1020 
1021     // Remember the constant register offset to the top-most symbol table. This symbol table will be
1022     // cloned in the code block linking. After that, to create the module environment, we retrieve
1023     // the cloned symbol table from the linked code block by using this offset.
1024     codeBlock-&gt;setModuleEnvironmentSymbolTableConstantRegisterOffset(constantSymbolTable-&gt;index());
1025 }
1026 
1027 BytecodeGenerator::~BytecodeGenerator()
1028 {
1029 }
1030 
1031 void BytecodeGenerator::initializeDefaultParameterValuesAndSetupFunctionScopeStack(
1032     FunctionParameters&amp; parameters, bool isSimpleParameterList, FunctionNode* functionNode, SymbolTable* functionSymbolTable,
1033     int symbolTableConstantIndex, const ScopedLambda&lt;bool (UniquedStringImpl*)&gt;&amp; captures, bool shouldCreateArgumentsVariableInParameterScope)
1034 {
1035     Vector&lt;std::pair&lt;Identifier, RefPtr&lt;RegisterID&gt;&gt;&gt; valuesToMoveIntoVars;
1036     ASSERT(!(isSimpleParameterList &amp;&amp; shouldCreateArgumentsVariableInParameterScope));
1037     if (!isSimpleParameterList) {
1038         // Refer to the ES6 spec section 9.2.12: http://www.ecma-international.org/ecma-262/6.0/index.html#sec-functiondeclarationinstantiation
1039         // This implements step 21.
1040         VariableEnvironment environment;
1041         Vector&lt;Identifier&gt; allParameterNames;
1042         for (unsigned i = 0; i &lt; parameters.size(); i++)
1043             parameters.at(i).first-&gt;collectBoundIdentifiers(allParameterNames);
1044         if (shouldCreateArgumentsVariableInParameterScope)
1045             allParameterNames.append(propertyNames().arguments);
1046         IdentifierSet parameterSet;
1047         for (auto&amp; ident : allParameterNames) {
1048             parameterSet.add(ident.impl());
1049             auto addResult = environment.add(ident);
1050             addResult.iterator-&gt;value.setIsLet(); // When we have default parameter expressions, parameters act like &quot;let&quot; variables.
1051             if (captures(ident.impl()))
1052                 addResult.iterator-&gt;value.setIsCaptured();
1053         }
1054         // This implements step 25 of section 9.2.12.
1055         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1056 
1057         if (shouldCreateArgumentsVariableInParameterScope) {
1058             Variable argumentsVariable = variable(propertyNames().arguments);
1059             initializeVariable(argumentsVariable, m_argumentsRegister);
1060             liftTDZCheckIfPossible(argumentsVariable);
1061         }
1062 
1063         RefPtr&lt;RegisterID&gt; temp = newTemporary();
1064         for (unsigned i = 0; i &lt; parameters.size(); i++) {
1065             std::pair&lt;DestructuringPatternNode*, ExpressionNode*&gt; parameter = parameters.at(i);
1066             if (parameter.first-&gt;isRestParameter())
1067                 continue;
1068             if ((i + 1) &lt; m_parameters.size())
1069                 move(temp.get(), &amp;m_parameters[i + 1]);
1070             else
1071                 emitGetArgument(temp.get(), i);
1072             if (parameter.second) {
1073                 RefPtr&lt;RegisterID&gt; condition = emitIsUndefined(newTemporary(), temp.get());
1074                 Ref&lt;Label&gt; skipDefaultParameterBecauseNotUndefined = newLabel();
1075                 emitJumpIfFalse(condition.get(), skipDefaultParameterBecauseNotUndefined.get());
1076                 emitNode(temp.get(), parameter.second);
1077                 emitLabel(skipDefaultParameterBecauseNotUndefined.get());
1078             }
1079 
1080             parameter.first-&gt;bindValue(*this, temp.get());
1081         }
1082 
1083         // Final act of weirdness for default parameters. If a &quot;var&quot; also
1084         // has the same name as a parameter, it should start out as the
1085         // value of that parameter. Note, though, that they will be distinct
1086         // bindings.
1087         // This is step 28 of section 9.2.12.
1088         for (auto&amp; entry : functionNode-&gt;varDeclarations()) {
1089             if (!entry.value.isVar()) // This is either a parameter or callee.
1090                 continue;
1091 
1092             if (parameterSet.contains(entry.key)) {
1093                 Identifier ident = Identifier::fromUid(m_vm, entry.key.get());
1094                 Variable var = variable(ident);
1095                 RegisterID* scope = emitResolveScope(nullptr, var);
1096                 RefPtr&lt;RegisterID&gt; value = emitGetFromScope(newTemporary(), scope, var, DoNotThrowIfNotFound);
1097                 valuesToMoveIntoVars.append(std::make_pair(ident, value));
1098             }
1099         }
1100 
1101         // Functions with default parameter expressions must have a separate environment
1102         // record for parameters and &quot;var&quot;s. The &quot;var&quot; environment record must have the
1103         // parameter environment record as its parent.
1104         // See step 28 of section 9.2.12.
1105         bool hasCapturedVariables = !!m_lexicalEnvironmentRegister;
1106         initializeVarLexicalEnvironment(symbolTableConstantIndex, functionSymbolTable, hasCapturedVariables);
1107     }
1108 
1109     // This completes step 28 of section 9.2.12.
1110     for (unsigned i = 0; i &lt; valuesToMoveIntoVars.size(); i++) {
1111         ASSERT(!isSimpleParameterList);
1112         Variable var = variable(valuesToMoveIntoVars[i].first);
1113         RegisterID* scope = emitResolveScope(nullptr, var);
1114         emitPutToScope(scope, var, valuesToMoveIntoVars[i].second.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
1115     }
1116 }
1117 
1118 bool BytecodeGenerator::needsDerivedConstructorInArrowFunctionLexicalEnvironment()
1119 {
1120     ASSERT(m_codeBlock-&gt;isClassContext() || !(isConstructor() &amp;&amp; constructorKind() == ConstructorKind::Extends));
1121     return m_codeBlock-&gt;isClassContext() &amp;&amp; isSuperUsedInInnerArrowFunction();
1122 }
1123 
1124 void BytecodeGenerator::initializeArrowFunctionContextScopeIfNeeded(SymbolTable* functionSymbolTable, bool canReuseLexicalEnvironment)
1125 {
1126     ASSERT(!m_arrowFunctionContextLexicalEnvironmentRegister);
1127 
1128     if (canReuseLexicalEnvironment &amp;&amp; m_lexicalEnvironmentRegister) {
1129         RELEASE_ASSERT(!m_codeBlock-&gt;isArrowFunction());
1130         RELEASE_ASSERT(functionSymbolTable);
1131 
1132         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalEnvironmentRegister;
1133 
1134         ScopeOffset offset;
1135 
1136         if (isThisUsedInInnerArrowFunction()) {
1137             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1138             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().thisIdentifier.impl(), SymbolTableEntry(VarOffset(offset)));
1139         }
1140 
1141         if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1142             offset = functionSymbolTable-&gt;takeNextScopeOffset();
1143             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().newTargetLocalPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1144         }
1145 
1146         if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1147             offset = functionSymbolTable-&gt;takeNextScopeOffset(NoLockingNecessary);
1148             functionSymbolTable-&gt;set(NoLockingNecessary, propertyNames().builtinNames().derivedConstructorPrivateName().impl(), SymbolTableEntry(VarOffset(offset)));
1149         }
1150 
1151         return;
1152     }
1153 
1154     VariableEnvironment environment;
1155 
1156     if (isThisUsedInInnerArrowFunction()) {
1157         auto addResult = environment.add(propertyNames().thisIdentifier);
1158         addResult.iterator-&gt;value.setIsCaptured();
1159         addResult.iterator-&gt;value.setIsLet();
1160     }
1161 
1162     if (m_codeType == FunctionCode &amp;&amp; isNewTargetUsedInInnerArrowFunction()) {
1163         auto addTarget = environment.add(propertyNames().builtinNames().newTargetLocalPrivateName());
1164         addTarget.iterator-&gt;value.setIsCaptured();
1165         addTarget.iterator-&gt;value.setIsLet();
1166     }
1167 
1168     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
1169         auto derivedConstructor = environment.add(propertyNames().builtinNames().derivedConstructorPrivateName());
1170         derivedConstructor.iterator-&gt;value.setIsCaptured();
1171         derivedConstructor.iterator-&gt;value.setIsLet();
1172     }
1173 
1174     if (environment.size() &gt; 0) {
1175         size_t size = m_lexicalScopeStack.size();
1176         pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1177 
1178         ASSERT_UNUSED(size, m_lexicalScopeStack.size() == size + 1);
1179 
1180         m_arrowFunctionContextLexicalEnvironmentRegister = m_lexicalScopeStack.last().m_scope;
1181     }
1182 }
1183 
1184 RegisterID* BytecodeGenerator::initializeNextParameter()
1185 {
<a name="44" id="anc44"></a><span class="line-modified">1186     VirtualRegister reg = virtualRegisterForArgumentIncludingThis(m_codeBlock-&gt;numParameters());</span>
1187     m_parameters.grow(m_parameters.size() + 1);
1188     auto&amp; parameter = registerFor(reg);
<a name="45" id="anc45"></a><span class="line-modified">1189     parameter.setIndex(reg);</span>
<span class="line-modified">1190     m_codeBlock-&gt;setNumParameters(m_codeBlock-&gt;numParameters() + 1);</span>
1191     return &amp;parameter;
1192 }
1193 
1194 void BytecodeGenerator::initializeParameters(FunctionParameters&amp; parameters)
1195 {
1196     // Make sure the code block knows about all of our parameters, and make sure that parameters
1197     // needing destructuring are noted.
<a name="46" id="anc46"></a><span class="line-modified">1198     m_thisRegister.setIndex(VirtualRegister(initializeNextParameter()-&gt;index())); // this</span>
1199 
1200     bool nonSimpleArguments = false;
1201     for (unsigned i = 0; i &lt; parameters.size(); ++i) {
1202         auto parameter = parameters.at(i);
1203         auto pattern = parameter.first;
1204         if (pattern-&gt;isRestParameter()) {
1205             RELEASE_ASSERT(!m_restParameter);
1206             m_restParameter = static_cast&lt;RestParameterNode*&gt;(pattern);
1207             nonSimpleArguments = true;
1208             continue;
1209         }
1210         if (parameter.second) {
1211             nonSimpleArguments = true;
1212             continue;
1213         }
1214         if (!nonSimpleArguments)
1215             initializeNextParameter();
1216     }
1217 }
1218 
1219 void BytecodeGenerator::initializeVarLexicalEnvironment(int symbolTableConstantIndex, SymbolTable* functionSymbolTable, bool hasCapturedVariables)
1220 {
1221     if (hasCapturedVariables) {
1222         RELEASE_ASSERT(m_lexicalEnvironmentRegister);
1223         OpCreateLexicalEnvironment::emit(this, m_lexicalEnvironmentRegister, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(jsUndefined()));
1224 
1225         OpMov::emit(this, scopeRegister(), m_lexicalEnvironmentRegister);
1226 
1227         pushLocalControlFlowScope();
1228     }
1229     bool isWithScope = false;
1230     m_lexicalScopeStack.append({ functionSymbolTable, m_lexicalEnvironmentRegister, isWithScope, symbolTableConstantIndex });
1231     m_varScopeLexicalScopeStackIndex = m_lexicalScopeStack.size() - 1;
1232 }
1233 
1234 UniquedStringImpl* BytecodeGenerator::visibleNameForParameter(DestructuringPatternNode* pattern)
1235 {
1236     if (pattern-&gt;isBindingNode()) {
1237         const Identifier&amp; ident = static_cast&lt;const BindingNode*&gt;(pattern)-&gt;boundProperty();
1238         if (!m_functions.contains(ident.impl()))
1239             return ident.impl();
1240     }
1241     return nullptr;
1242 }
1243 
<a name="47" id="anc47"></a>













1244 RegisterID* BytecodeGenerator::newBlockScopeVariable()
1245 {
1246     reclaimFreeRegisters();
1247 
1248     return newRegister();
1249 }
1250 
<a name="48" id="anc48"></a>








1251 Ref&lt;LabelScope&gt; BytecodeGenerator::newLabelScope(LabelScope::Type type, const Identifier* name)
1252 {
1253     shrinkToFit(m_labelScopes);
1254 
1255     // Allocate new label scope.
1256     m_labelScopes.append(type, name, labelScopeDepth(), newLabel(), type == LabelScope::Loop ? RefPtr&lt;Label&gt;(newLabel()) : RefPtr&lt;Label&gt;()); // Only loops have continue targets.
1257     return m_labelScopes.last();
1258 }
1259 
<a name="49" id="anc49"></a>


























































1260 void BytecodeGenerator::emitEnter()
1261 {
1262     OpEnter::emit(this);
1263 
1264     if (LIKELY(Options::optimizeRecursiveTailCalls())) {
1265         // We must add the end of op_enter as a potential jump target, because the bytecode parser may decide to split its basic block
1266         // to have somewhere to jump to if there is a recursive tail-call that points to this function.
1267         m_codeBlock-&gt;addJumpTarget(instructions().size());
1268         // This disables peephole optimizations when an instruction is a jump target
1269         m_lastOpcodeID = op_end;
1270     }
1271 }
1272 
1273 void BytecodeGenerator::emitLoopHint()
1274 {
1275     OpLoopHint::emit(this);
<a name="50" id="anc50"></a><span class="line-added">1276     emitCheckTraps();</span>
1277 }
1278 
1279 void BytecodeGenerator::emitJump(Label&amp; target)
1280 {
1281     OpJmp::emit(this, target.bind(this));
1282 }
1283 
<a name="51" id="anc51"></a><span class="line-added">1284 void BytecodeGenerator::emitCheckTraps()</span>
<span class="line-added">1285 {</span>
<span class="line-added">1286     OpCheckTraps::emit(this);</span>
<span class="line-added">1287 }</span>
<span class="line-added">1288 </span>
1289 void ALWAYS_INLINE BytecodeGenerator::rewind()
1290 {
1291     ASSERT(m_lastInstruction.isValid());
1292     m_lastOpcodeID = op_end;
1293     m_writer.rewind(m_lastInstruction);
1294 }
1295 
1296 template&lt;typename BinOp, typename JmpOp&gt;
1297 bool BytecodeGenerator::fuseCompareAndJump(RegisterID* cond, Label&amp; target, bool swapOperands)
1298 {
1299     ASSERT(canDoPeepholeOptimization());
1300     auto binop = m_lastInstruction-&gt;as&lt;BinOp&gt;();
1301     if (cond-&gt;index() == binop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1302         rewind();
1303 
1304         if (swapOperands)
1305             std::swap(binop.m_lhs, binop.m_rhs);
1306 
1307         JmpOp::emit(this, binop.m_lhs, binop.m_rhs, target.bind(this));
1308         return true;
1309     }
1310     return false;
1311 }
1312 
1313 template&lt;typename UnaryOp, typename JmpOp&gt;
1314 bool BytecodeGenerator::fuseTestAndJmp(RegisterID* cond, Label&amp; target)
1315 {
1316     ASSERT(canDoPeepholeOptimization());
1317     auto unop = m_lastInstruction-&gt;as&lt;UnaryOp&gt;();
1318     if (cond-&gt;index() == unop.m_dst.offset() &amp;&amp; cond-&gt;isTemporary() &amp;&amp; !cond-&gt;refCount()) {
1319         rewind();
1320 
1321         JmpOp::emit(this, unop.m_operand, target.bind(this));
1322         return true;
1323     }
1324     return false;
1325 }
1326 
1327 void BytecodeGenerator::emitJumpIfTrue(RegisterID* cond, Label&amp; target)
1328 {
1329     if (canDoPeepholeOptimization()) {
1330         if (m_lastOpcodeID == op_less) {
1331             if (fuseCompareAndJump&lt;OpLess, OpJless&gt;(cond, target))
1332                 return;
1333         } else if (m_lastOpcodeID == op_lesseq) {
1334             if (fuseCompareAndJump&lt;OpLesseq, OpJlesseq&gt;(cond, target))
1335                 return;
1336         } else if (m_lastOpcodeID == op_greater) {
1337             if (fuseCompareAndJump&lt;OpGreater, OpJgreater&gt;(cond, target))
1338                 return;
1339         } else if (m_lastOpcodeID == op_greatereq) {
1340             if (fuseCompareAndJump&lt;OpGreatereq, OpJgreatereq&gt;(cond, target))
1341                 return;
1342         } else if (m_lastOpcodeID == op_eq) {
1343             if (fuseCompareAndJump&lt;OpEq, OpJeq&gt;(cond, target))
1344                 return;
1345         } else if (m_lastOpcodeID == op_stricteq) {
1346             if (fuseCompareAndJump&lt;OpStricteq, OpJstricteq&gt;(cond, target))
1347                 return;
1348         } else if (m_lastOpcodeID == op_neq) {
1349             if (fuseCompareAndJump&lt;OpNeq, OpJneq&gt;(cond, target))
1350                 return;
1351         } else if (m_lastOpcodeID == op_nstricteq) {
1352             if (fuseCompareAndJump&lt;OpNstricteq, OpJnstricteq&gt;(cond, target))
1353                 return;
1354         } else if (m_lastOpcodeID == op_below) {
1355             if (fuseCompareAndJump&lt;OpBelow, OpJbelow&gt;(cond, target))
1356                 return;
1357         } else if (m_lastOpcodeID == op_beloweq) {
1358             if (fuseCompareAndJump&lt;OpBeloweq, OpJbeloweq&gt;(cond, target))
1359                 return;
1360         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1361             if (fuseTestAndJmp&lt;OpEqNull, OpJeqNull&gt;(cond, target))
1362                 return;
1363         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1364             if (fuseTestAndJmp&lt;OpNeqNull, OpJneqNull&gt;(cond, target))
1365                 return;
1366         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1367             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJundefinedOrNull&gt;(cond, target))
1368                 return;
1369         }
1370     }
1371 
1372     OpJtrue::emit(this, cond, target.bind(this));
1373 }
1374 
1375 void BytecodeGenerator::emitJumpIfFalse(RegisterID* cond, Label&amp; target)
1376 {
1377     if (canDoPeepholeOptimization()) {
1378         if (m_lastOpcodeID == op_less &amp;&amp; target.isForward()) {
1379             if (fuseCompareAndJump&lt;OpLess, OpJnless&gt;(cond, target))
1380                 return;
1381         } else if (m_lastOpcodeID == op_lesseq &amp;&amp; target.isForward()) {
1382             if (fuseCompareAndJump&lt;OpLesseq, OpJnlesseq&gt;(cond, target))
1383                 return;
1384         } else if (m_lastOpcodeID == op_greater &amp;&amp; target.isForward()) {
1385             if (fuseCompareAndJump&lt;OpGreater, OpJngreater&gt;(cond, target))
1386                 return;
1387         } else if (m_lastOpcodeID == op_greatereq &amp;&amp; target.isForward()) {
1388             if (fuseCompareAndJump&lt;OpGreatereq, OpJngreatereq&gt;(cond, target))
1389                 return;
1390         } else if (m_lastOpcodeID == op_eq &amp;&amp; target.isForward()) {
1391             if (fuseCompareAndJump&lt;OpEq, OpJneq&gt;(cond, target))
1392                 return;
1393         } else if (m_lastOpcodeID == op_stricteq &amp;&amp; target.isForward()) {
1394             if (fuseCompareAndJump&lt;OpStricteq, OpJnstricteq&gt;(cond, target))
1395                 return;
1396         } else if (m_lastOpcodeID == op_neq &amp;&amp; target.isForward()) {
1397             if (fuseCompareAndJump&lt;OpNeq, OpJeq&gt;(cond, target))
1398                 return;
1399         } else if (m_lastOpcodeID == op_nstricteq &amp;&amp; target.isForward()) {
1400             if (fuseCompareAndJump&lt;OpNstricteq, OpJstricteq&gt;(cond, target))
1401                 return;
1402         } else if (m_lastOpcodeID == op_below &amp;&amp; target.isForward()) {
1403             if (fuseCompareAndJump&lt;OpBelow, OpJbeloweq&gt;(cond, target, true))
1404                 return;
1405         } else if (m_lastOpcodeID == op_beloweq &amp;&amp; target.isForward()) {
1406             if (fuseCompareAndJump&lt;OpBeloweq, OpJbelow&gt;(cond, target, true))
1407                 return;
1408         } else if (m_lastOpcodeID == op_not) {
1409             if (fuseTestAndJmp&lt;OpNot, OpJtrue&gt;(cond, target))
1410                 return;
1411         } else if (m_lastOpcodeID == op_eq_null &amp;&amp; target.isForward()) {
1412             if (fuseTestAndJmp&lt;OpEqNull, OpJneqNull&gt;(cond, target))
1413                 return;
1414         } else if (m_lastOpcodeID == op_neq_null &amp;&amp; target.isForward()) {
1415             if (fuseTestAndJmp&lt;OpNeqNull, OpJeqNull&gt;(cond, target))
1416                 return;
1417         } else if (m_lastOpcodeID == op_is_undefined_or_null &amp;&amp; target.isForward()) {
1418             if (fuseTestAndJmp&lt;OpIsUndefinedOrNull, OpJnundefinedOrNull&gt;(cond, target))
1419                 return;
1420         }
1421     }
1422 
1423     OpJfalse::emit(this, cond, target.bind(this));
1424 }
1425 
1426 void BytecodeGenerator::emitJumpIfNotFunctionCall(RegisterID* cond, Label&amp; target)
1427 {
<a name="52" id="anc52"></a><span class="line-modified">1428     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::callFunction), target.bind(this));</span>
1429 }
1430 
1431 void BytecodeGenerator::emitJumpIfNotFunctionApply(RegisterID* cond, Label&amp; target)
1432 {
<a name="53" id="anc53"></a><span class="line-modified">1433     OpJneqPtr::emit(this, cond, moveLinkTimeConstant(nullptr, LinkTimeConstant::applyFunction), target.bind(this));</span>
1434 }
1435 
1436 bool BytecodeGenerator::hasConstant(const Identifier&amp; ident) const
1437 {
1438     UniquedStringImpl* rep = ident.impl();
1439     return m_identifierMap.contains(rep);
1440 }
1441 
1442 unsigned BytecodeGenerator::addConstant(const Identifier&amp; ident)
1443 {
1444     UniquedStringImpl* rep = ident.impl();
1445     IdentifierMap::AddResult result = m_identifierMap.add(rep, m_codeBlock-&gt;numberOfIdentifiers());
1446     if (result.isNewEntry)
1447         m_codeBlock-&gt;addIdentifier(ident);
1448 
1449     return result.iterator-&gt;value;
1450 }
1451 
1452 // We can&#39;t hash JSValue(), so we use a dedicated data member to cache it.
1453 RegisterID* BytecodeGenerator::addConstantEmptyValue()
1454 {
1455     if (!m_emptyValueRegister) {
1456         int index = addConstantIndex();
1457         m_codeBlock-&gt;addConstant(JSValue());
1458         m_emptyValueRegister = &amp;m_constantPoolRegisters[index];
1459     }
1460 
1461     return m_emptyValueRegister;
1462 }
1463 
1464 RegisterID* BytecodeGenerator::addConstantValue(JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1465 {
1466     if (!v)
1467         return addConstantEmptyValue();
1468 
1469     int index = m_nextConstantOffset;
1470 
1471     if (sourceCodeRepresentation == SourceCodeRepresentation::Double &amp;&amp; v.isInt32())
1472         v = jsDoubleNumber(v.asNumber());
1473     EncodedJSValueWithRepresentation valueMapKey { JSValue::encode(v), sourceCodeRepresentation };
1474     JSValueMap::AddResult result = m_jsValueMap.add(valueMapKey, m_nextConstantOffset);
1475     if (result.isNewEntry) {
1476         addConstantIndex();
1477         m_codeBlock-&gt;addConstant(v, sourceCodeRepresentation);
1478     } else
1479         index = result.iterator-&gt;value;
1480     return &amp;m_constantPoolRegisters[index];
1481 }
1482 
1483 RegisterID* BytecodeGenerator::moveLinkTimeConstant(RegisterID* dst, LinkTimeConstant type)
1484 {
<a name="54" id="anc54"></a><span class="line-modified">1485     RegisterID* constant = m_linkTimeConstantRegisters.ensure(type, [&amp;] {</span>

1486         int index = addConstantIndex();
1487         m_codeBlock-&gt;addConstant(type);
<a name="55" id="anc55"></a><span class="line-modified">1488         return &amp;m_constantPoolRegisters[index];</span>
<span class="line-modified">1489     }).iterator-&gt;value;</span>

1490     if (!dst)
<a name="56" id="anc56"></a><span class="line-modified">1491         return constant;</span>
1492 
<a name="57" id="anc57"></a><span class="line-modified">1493     OpMov::emit(this, dst, constant);</span>
1494 
1495     return dst;
1496 }
1497 
1498 RegisterID* BytecodeGenerator::moveEmptyValue(RegisterID* dst)
1499 {
1500     RefPtr&lt;RegisterID&gt; emptyValue = addConstantEmptyValue();
1501 
1502     OpMov::emit(this, dst, emptyValue.get());
1503 
1504     return dst;
1505 }
1506 
1507 RegisterID* BytecodeGenerator::emitMove(RegisterID* dst, RegisterID* src)
1508 {
1509     ASSERT(src != m_emptyValueRegister);
1510 
1511     m_staticPropertyAnalyzer.mov(dst, src);
1512     OpMov::emit(this, dst, src);
1513 
1514     return dst;
1515 }
1516 
<a name="58" id="anc58"></a><span class="line-modified">1517 RegisterID* BytecodeGenerator::emitUnaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src, ResultType type)</span>
1518 {
1519     switch (opcodeID) {
1520     case op_not:
1521         emitUnaryOp&lt;OpNot&gt;(dst, src);
1522         break;
1523     case op_negate:
<a name="59" id="anc59"></a><span class="line-modified">1524         OpNegate::emit(this, dst, src, type);</span>
1525         break;
1526     case op_bitnot:
1527         emitUnaryOp&lt;OpBitnot&gt;(dst, src);
1528         break;
1529     case op_to_number:
1530         emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1531         break;
<a name="60" id="anc60"></a><span class="line-added">1532     case op_to_numeric:</span>
<span class="line-added">1533         emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">1534         break;</span>
1535     default:
1536         ASSERT_NOT_REACHED();
1537     }
1538     return dst;
1539 }
1540 
1541 RegisterID* BytecodeGenerator::emitBinaryOp(OpcodeID opcodeID, RegisterID* dst, RegisterID* src1, RegisterID* src2, OperandTypes types)
1542 {
1543     switch (opcodeID) {
1544     case op_eq:
1545         return emitBinaryOp&lt;OpEq&gt;(dst, src1, src2, types);
1546     case op_neq:
1547         return emitBinaryOp&lt;OpNeq&gt;(dst, src1, src2, types);
1548     case op_stricteq:
1549         return emitBinaryOp&lt;OpStricteq&gt;(dst, src1, src2, types);
1550     case op_nstricteq:
1551         return emitBinaryOp&lt;OpNstricteq&gt;(dst, src1, src2, types);
1552     case op_less:
1553         return emitBinaryOp&lt;OpLess&gt;(dst, src1, src2, types);
1554     case op_lesseq:
1555         return emitBinaryOp&lt;OpLesseq&gt;(dst, src1, src2, types);
1556     case op_greater:
1557         return emitBinaryOp&lt;OpGreater&gt;(dst, src1, src2, types);
1558     case op_greatereq:
1559         return emitBinaryOp&lt;OpGreatereq&gt;(dst, src1, src2, types);
1560     case op_below:
1561         return emitBinaryOp&lt;OpBelow&gt;(dst, src1, src2, types);
1562     case op_beloweq:
1563         return emitBinaryOp&lt;OpBeloweq&gt;(dst, src1, src2, types);
1564     case op_mod:
1565         return emitBinaryOp&lt;OpMod&gt;(dst, src1, src2, types);
1566     case op_pow:
1567         return emitBinaryOp&lt;OpPow&gt;(dst, src1, src2, types);
1568     case op_lshift:
1569         return emitBinaryOp&lt;OpLshift&gt;(dst, src1, src2, types);
1570     case op_rshift:
1571         return emitBinaryOp&lt;OpRshift&gt;(dst, src1, src2, types);
1572     case op_urshift:
1573         return emitBinaryOp&lt;OpUrshift&gt;(dst, src1, src2, types);
1574     case op_add:
1575         return emitBinaryOp&lt;OpAdd&gt;(dst, src1, src2, types);
1576     case op_mul:
1577         return emitBinaryOp&lt;OpMul&gt;(dst, src1, src2, types);
1578     case op_div:
1579         return emitBinaryOp&lt;OpDiv&gt;(dst, src1, src2, types);
1580     case op_sub:
1581         return emitBinaryOp&lt;OpSub&gt;(dst, src1, src2, types);
1582     case op_bitand:
1583         return emitBinaryOp&lt;OpBitand&gt;(dst, src1, src2, types);
1584     case op_bitxor:
1585         return emitBinaryOp&lt;OpBitxor&gt;(dst, src1, src2, types);
1586     case op_bitor:
1587         return emitBinaryOp&lt;OpBitor&gt;(dst, src1, src2, types);
1588     default:
1589         ASSERT_NOT_REACHED();
1590         return nullptr;
1591     }
1592 }
1593 
1594 RegisterID* BytecodeGenerator::emitToObject(RegisterID* dst, RegisterID* src, const Identifier&amp; message)
1595 {
1596     OpToObject::emit(this, dst, src, addConstant(message));
1597     return dst;
1598 }
1599 
1600 RegisterID* BytecodeGenerator::emitToNumber(RegisterID* dst, RegisterID* src)
1601 {
1602     return emitUnaryOp&lt;OpToNumber&gt;(dst, src);
1603 }
1604 
<a name="61" id="anc61"></a><span class="line-added">1605 RegisterID* BytecodeGenerator::emitToNumeric(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">1606 {</span>
<span class="line-added">1607     return emitUnaryOp&lt;OpToNumeric&gt;(dst, src);</span>
<span class="line-added">1608 }</span>
<span class="line-added">1609 </span>
1610 RegisterID* BytecodeGenerator::emitToString(RegisterID* dst, RegisterID* src)
1611 {
1612     return emitUnaryOp&lt;OpToString&gt;(dst, src);
1613 }
1614 
1615 RegisterID* BytecodeGenerator::emitTypeOf(RegisterID* dst, RegisterID* src)
1616 {
1617     return emitUnaryOp&lt;OpTypeof&gt;(dst, src);
1618 }
1619 
1620 RegisterID* BytecodeGenerator::emitInc(RegisterID* srcDst)
1621 {
1622     OpInc::emit(this, srcDst);
1623     return srcDst;
1624 }
1625 
1626 RegisterID* BytecodeGenerator::emitDec(RegisterID* srcDst)
1627 {
1628     OpDec::emit(this, srcDst);
1629     return srcDst;
1630 }
1631 
1632 bool BytecodeGenerator::emitEqualityOpImpl(RegisterID* dst, RegisterID* src1, RegisterID* src2)
1633 {
1634     if (!canDoPeepholeOptimization())
1635         return false;
1636 
1637     if (m_lastInstruction-&gt;is&lt;OpTypeof&gt;()) {
1638         auto op = m_lastInstruction-&gt;as&lt;OpTypeof&gt;();
<a name="62" id="anc62"></a><span class="line-modified">1639         if (src1-&gt;virtualRegister() == op.m_dst</span>
1640             &amp;&amp; src1-&gt;isTemporary()
<a name="63" id="anc63"></a><span class="line-modified">1641             &amp;&amp; src2-&gt;virtualRegister().isConstant()</span>
<span class="line-modified">1642             &amp;&amp; m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get().isString()) {</span>
<span class="line-modified">1643             const String&amp; value = asString(m_codeBlock-&gt;constantRegister(src2-&gt;virtualRegister()).get())-&gt;tryGetValue();</span>
1644             if (value == &quot;undefined&quot;) {
1645                 rewind();
1646                 OpIsUndefined::emit(this, dst, op.m_value);
1647                 return true;
1648             }
1649             if (value == &quot;boolean&quot;) {
1650                 rewind();
1651                 OpIsBoolean::emit(this, dst, op.m_value);
1652                 return true;
1653             }
1654             if (value == &quot;number&quot;) {
1655                 rewind();
1656                 OpIsNumber::emit(this, dst, op.m_value);
1657                 return true;
1658             }
1659             if (value == &quot;string&quot;) {
1660                 rewind();
1661                 OpIsCellWithType::emit(this, dst, op.m_value, StringType);
1662                 return true;
1663             }
1664             if (value == &quot;symbol&quot;) {
1665                 rewind();
1666                 OpIsCellWithType::emit(this, dst, op.m_value, SymbolType);
1667                 return true;
1668             }
1669             if (Options::useBigInt() &amp;&amp; value == &quot;bigint&quot;) {
1670                 rewind();
1671                 OpIsCellWithType::emit(this, dst, op.m_value, BigIntType);
1672                 return true;
1673             }
1674             if (value == &quot;object&quot;) {
1675                 rewind();
1676                 OpIsObjectOrNull::emit(this, dst, op.m_value);
1677                 return true;
1678             }
1679             if (value == &quot;function&quot;) {
1680                 rewind();
1681                 OpIsFunction::emit(this, dst, op.m_value);
1682                 return true;
1683             }
1684         }
1685     }
1686 
1687     return false;
1688 }
1689 
1690 void BytecodeGenerator::emitTypeProfilerExpressionInfo(const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1691 {
1692     ASSERT(shouldEmitTypeProfilerHooks());
1693 
1694     unsigned start = startDivot.offset; // Ranges are inclusive of their endpoints, AND 0 indexed.
1695     unsigned end = endDivot.offset - 1; // End Ranges already go one past the inclusive range, so subtract 1.
1696     unsigned instructionOffset = instructions().size() - 1;
1697     m_codeBlock-&gt;addTypeProfilerExpressionInfo(instructionOffset, start, end);
1698 }
1699 
1700 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag)
1701 {
1702     if (!shouldEmitTypeProfilerHooks())
1703         return;
1704 
1705     if (!registerToProfile)
1706         return;
1707 
1708     OpProfileType::emit(this, registerToProfile, { }, flag, { }, resolveType());
1709 
1710     // Don&#39;t emit expression info for this version of profile type. This generally means
1711     // we&#39;re profiling information for something that isn&#39;t in the actual text of a JavaScript
1712     // program. For example, implicit return undefined from a function call.
1713 }
1714 
1715 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1716 {
1717     emitProfileType(registerToProfile, ProfileTypeBytecodeDoesNotHaveGlobalID, startDivot, endDivot);
1718 }
1719 
1720 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, ProfileTypeBytecodeFlag flag, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1721 {
1722     if (!shouldEmitTypeProfilerHooks())
1723         return;
1724 
1725     if (!registerToProfile)
1726         return;
1727 
1728     OpProfileType::emit(this, registerToProfile, { },  flag, { }, resolveType());
1729     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1730 }
1731 
1732 void BytecodeGenerator::emitProfileType(RegisterID* registerToProfile, const Variable&amp; var, const JSTextPosition&amp; startDivot, const JSTextPosition&amp; endDivot)
1733 {
1734     if (!shouldEmitTypeProfilerHooks())
1735         return;
1736 
1737     if (!registerToProfile)
1738         return;
1739 
1740     ProfileTypeBytecodeFlag flag;
1741     SymbolTableOrScopeDepth symbolTableOrScopeDepth;
1742     if (var.local() || var.offset().isScope()) {
1743         flag = ProfileTypeBytecodeLocallyResolved;
1744         ASSERT(var.symbolTableConstantIndex());
1745         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { var.symbolTableConstantIndex() });
1746     } else {
1747         flag = ProfileTypeBytecodeClosureVar;
1748         symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
1749     }
1750 
1751     OpProfileType::emit(this, registerToProfile, symbolTableOrScopeDepth, flag, addConstant(var.ident()), resolveType());
1752     emitTypeProfilerExpressionInfo(startDivot, endDivot);
1753 }
1754 
1755 void BytecodeGenerator::emitProfileControlFlow(int textOffset)
1756 {
1757     if (shouldEmitControlFlowProfilerHooks()) {
1758         RELEASE_ASSERT(textOffset &gt;= 0);
1759 
1760         OpProfileControlFlow::emit(this, textOffset);
1761         m_codeBlock-&gt;addOpProfileControlFlowBytecodeOffset(m_lastInstruction.offset());
1762     }
1763 }
1764 
1765 unsigned BytecodeGenerator::addConstantIndex()
1766 {
1767     unsigned index = m_nextConstantOffset;
1768     m_constantPoolRegisters.append(FirstConstantRegisterIndex + m_nextConstantOffset);
1769     ++m_nextConstantOffset;
1770     return index;
1771 }
1772 
1773 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, bool b)
1774 {
1775     return emitLoad(dst, jsBoolean(b));
1776 }
1777 
1778 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, const Identifier&amp; identifier)
1779 {
1780     ASSERT(!identifier.isSymbol());
1781     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
1782     if (!stringInMap)
1783         stringInMap = jsOwnedString(vm(), identifier.string());
1784 
1785     return emitLoad(dst, JSValue(stringInMap));
1786 }
1787 
1788 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, JSValue v, SourceCodeRepresentation sourceCodeRepresentation)
1789 {
1790     RegisterID* constantID = addConstantValue(v, sourceCodeRepresentation);
1791     if (dst)
1792         return move(dst, constantID);
1793     return constantID;
1794 }
1795 
1796 RegisterID* BytecodeGenerator::emitLoad(RegisterID* dst, IdentifierSet&amp; set)
1797 {
1798     if (m_codeBlock-&gt;numberOfConstantIdentifierSets()) {
1799         for (const auto&amp; entry : m_codeBlock-&gt;constantIdentifierSets()) {
1800             if (entry.first != set)
1801                 continue;
1802 
1803             return &amp;m_constantPoolRegisters[entry.second];
1804         }
1805     }
1806 
1807     unsigned index = addConstantIndex();
1808     m_codeBlock-&gt;addSetConstant(set);
1809     RegisterID* m_setRegister = &amp;m_constantPoolRegisters[index];
1810 
1811     if (dst)
1812         return move(dst, m_setRegister);
1813 
1814     return m_setRegister;
1815 }
1816 
1817 template&lt;typename LookUpVarKindFunctor&gt;
1818 bool BytecodeGenerator::instantiateLexicalVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable, ScopeRegisterType scopeRegisterType, LookUpVarKindFunctor lookUpVarKind)
1819 {
1820     bool hasCapturedVariables = false;
1821     {
1822         for (auto&amp; entry : lexicalVariables) {
1823             ASSERT(entry.value.isLet() || entry.value.isConst() || entry.value.isFunction());
1824             ASSERT(!entry.value.isVar());
1825             SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1826             ASSERT(symbolTableEntry.isNull());
1827 
1828             // Imported bindings which are not the namespace bindings are not allocated
1829             // in the module environment as usual variables&#39; way.
1830             // And since these types of the variables only seen in the module environment,
1831             // other lexical environment need not to take care this.
1832             if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1833                 continue;
1834 
1835             VarKind varKind = lookUpVarKind(entry.key.get(), entry.value);
1836             VarOffset varOffset;
1837             if (varKind == VarKind::Scope) {
1838                 varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
1839                 hasCapturedVariables = true;
1840             } else {
1841                 ASSERT(varKind == VarKind::Stack);
1842                 RegisterID* local;
1843                 if (scopeRegisterType == ScopeRegisterType::Block) {
1844                     local = newBlockScopeVariable();
1845                     local-&gt;ref();
1846                 } else
1847                     local = addVar();
1848                 varOffset = VarOffset(local-&gt;virtualRegister());
1849             }
1850 
1851             SymbolTableEntry newEntry(varOffset, static_cast&lt;unsigned&gt;(entry.value.isConst() ? PropertyAttribute::ReadOnly : PropertyAttribute::None));
1852             symbolTable-&gt;add(NoLockingNecessary, entry.key.get(), newEntry);
1853         }
1854     }
1855     return hasCapturedVariables;
1856 }
1857 
1858 void BytecodeGenerator::emitPrefillStackTDZVariables(const VariableEnvironment&amp; lexicalVariables, SymbolTable* symbolTable)
1859 {
1860     // Prefill stack variables with the TDZ empty value.
1861     // Scope variables will be initialized to the TDZ empty value when JSLexicalEnvironment is allocated.
1862     for (auto&amp; entry : lexicalVariables) {
1863         // Imported bindings which are not the namespace bindings are not allocated
1864         // in the module environment as usual variables&#39; way.
1865         // And since these types of the variables only seen in the module environment,
1866         // other lexical environment need not to take care this.
1867         if (entry.value.isImported() &amp;&amp; !entry.value.isImportedNamespace())
1868             continue;
1869 
1870         if (entry.value.isFunction())
1871             continue;
1872 
1873         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
1874         ASSERT(!symbolTableEntry.isNull());
1875         VarOffset offset = symbolTableEntry.varOffset();
1876         if (offset.isScope())
1877             continue;
1878 
1879         ASSERT(offset.isStack());
1880         moveEmptyValue(&amp;registerFor(offset.stackOffset()));
1881     }
1882 }
1883 
1884 void BytecodeGenerator::pushLexicalScope(VariableEnvironmentNode* node, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType, RegisterID** constantSymbolTableResult, bool shouldInitializeBlockScopedFunctions)
1885 {
1886     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
1887     RegisterID* constantSymbolTableResultTemp = nullptr;
1888     pushLexicalScopeInternal(environment, tdzCheckOptimization, nestedScopeType, &amp;constantSymbolTableResultTemp, TDZRequirement::UnderTDZ, ScopeType::LetConstScope, ScopeRegisterType::Block);
1889 
1890     if (shouldInitializeBlockScopedFunctions)
1891         initializeBlockScopedFunctions(environment, node-&gt;functionStack(), constantSymbolTableResultTemp);
1892 
1893     if (constantSymbolTableResult &amp;&amp; constantSymbolTableResultTemp)
1894         *constantSymbolTableResult = constantSymbolTableResultTemp;
1895 }
1896 
1897 void BytecodeGenerator::pushLexicalScopeInternal(VariableEnvironment&amp; environment, TDZCheckOptimization tdzCheckOptimization, NestedScopeType nestedScopeType,
1898     RegisterID** constantSymbolTableResult, TDZRequirement tdzRequirement, ScopeType scopeType, ScopeRegisterType scopeRegisterType)
1899 {
1900     if (!environment.size())
1901         return;
1902 
1903     if (shouldEmitDebugHooks())
1904         environment.markAllVariablesAsCaptured();
1905 
1906     SymbolTable* symbolTable = SymbolTable::create(m_vm);
1907     switch (scopeType) {
1908     case ScopeType::CatchScope:
1909         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::CatchScope);
1910         break;
1911     case ScopeType::LetConstScope:
1912         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::LexicalScope);
1913         break;
1914     case ScopeType::FunctionNameScope:
1915         symbolTable-&gt;setScopeType(SymbolTable::ScopeType::FunctionNameScope);
1916         break;
1917     }
1918 
1919     if (nestedScopeType == NestedScopeType::IsNested)
1920         symbolTable-&gt;markIsNestedLexicalScope();
1921 
1922     auto lookUpVarKind = [] (UniquedStringImpl*, const VariableEnvironmentEntry&amp; entry) -&gt; VarKind {
1923         return entry.isCaptured() ? VarKind::Scope : VarKind::Stack;
1924     };
1925 
1926     bool hasCapturedVariables = instantiateLexicalVariables(environment, symbolTable, scopeRegisterType, lookUpVarKind);
1927 
1928     RegisterID* newScope = nullptr;
1929     RegisterID* constantSymbolTable = nullptr;
1930     int symbolTableConstantIndex = 0;
1931     if (shouldEmitTypeProfilerHooks()) {
1932         constantSymbolTable = addConstantValue(symbolTable);
1933         symbolTableConstantIndex = constantSymbolTable-&gt;index();
1934     }
1935     if (hasCapturedVariables) {
1936         if (scopeRegisterType == ScopeRegisterType::Block) {
1937             newScope = newBlockScopeVariable();
1938             newScope-&gt;ref();
1939         } else
1940             newScope = addVar();
1941         if (!constantSymbolTable) {
1942             ASSERT(!shouldEmitTypeProfilerHooks());
1943             constantSymbolTable = addConstantValue(symbolTable-&gt;cloneScopePart(m_vm));
1944             symbolTableConstantIndex = constantSymbolTable-&gt;index();
1945         }
1946         if (constantSymbolTableResult)
1947             *constantSymbolTableResult = constantSymbolTable;
1948 
1949         OpCreateLexicalEnvironment::emit(this, newScope, scopeRegister(), VirtualRegister { symbolTableConstantIndex }, addConstantValue(tdzRequirement == TDZRequirement::UnderTDZ ? jsTDZValue() : jsUndefined()));
1950 
1951         move(scopeRegister(), newScope);
1952 
1953         pushLocalControlFlowScope();
1954     }
1955 
1956     bool isWithScope = false;
1957     m_lexicalScopeStack.append({ symbolTable, newScope, isWithScope, symbolTableConstantIndex });
1958     pushTDZVariables(environment, tdzCheckOptimization, tdzRequirement);
1959 
1960     if (tdzRequirement == TDZRequirement::UnderTDZ)
1961         emitPrefillStackTDZVariables(environment, symbolTable);
1962 }
1963 
1964 void BytecodeGenerator::initializeBlockScopedFunctions(VariableEnvironment&amp; environment, FunctionStack&amp; functionStack, RegisterID* constantSymbolTable)
1965 {
1966     /*
1967      * We must transform block scoped function declarations in strict mode like so:
1968      *
1969      * function foo() {
1970      *     if (c) {
1971      *           function foo() { ... }
1972      *           if (bar) { ... }
1973      *           else { ... }
1974      *           function baz() { ... }
1975      *     }
1976      * }
1977      *
1978      * to:
1979      *
1980      * function foo() {
1981      *     if (c) {
1982      *         let foo = function foo() { ... }
1983      *         let baz = function baz() { ... }
1984      *         if (bar) { ... }
1985      *         else { ... }
1986      *     }
1987      * }
1988      *
1989      * But without the TDZ checks.
1990     */
1991 
1992     if (!environment.size()) {
1993         RELEASE_ASSERT(!functionStack.size());
1994         return;
1995     }
1996 
1997     if (!functionStack.size())
1998         return;
1999 
2000     SymbolTable* symbolTable = m_lexicalScopeStack.last().m_symbolTable;
2001     RegisterID* scope = m_lexicalScopeStack.last().m_scope;
2002     RefPtr&lt;RegisterID&gt; temp = newTemporary();
2003     int symbolTableIndex = constantSymbolTable ? constantSymbolTable-&gt;index() : 0;
2004     for (FunctionMetadataNode* function : functionStack) {
2005         const Identifier&amp; name = function-&gt;ident();
2006         auto iter = environment.find(name.impl());
2007         RELEASE_ASSERT(iter != environment.end());
2008         RELEASE_ASSERT(iter-&gt;value.isFunction());
2009         // We purposefully don&#39;t hold the symbol table lock around this loop because emitNewFunctionExpressionCommon may GC.
2010         SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, name.impl());
2011         RELEASE_ASSERT(!entry.isNull());
2012         emitNewFunctionExpressionCommon(temp.get(), function);
2013         bool isLexicallyScoped = true;
2014         emitPutToScope(scope, variableForLocalEntry(name, entry, symbolTableIndex, isLexicallyScoped), temp.get(), DoNotThrowIfNotFound, InitializationMode::Initialization);
2015     }
2016 }
2017 
2018 void BytecodeGenerator::hoistSloppyModeFunctionIfNecessary(const Identifier&amp; functionName)
2019 {
2020     if (m_scopeNode-&gt;hasSloppyModeHoistedFunction(functionName.impl())) {
2021         if (codeType() != EvalCode) {
2022             Variable currentFunctionVariable = variable(functionName);
2023             RefPtr&lt;RegisterID&gt; currentValue;
2024             if (RegisterID* local = currentFunctionVariable.local())
2025                 currentValue = local;
2026             else {
2027                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2028                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2029             }
2030 
2031             ASSERT(m_varScopeLexicalScopeStackIndex);
2032             ASSERT(*m_varScopeLexicalScopeStackIndex &lt; m_lexicalScopeStack.size());
2033             LexicalScopeStackEntry varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex];
2034             SymbolTable* varSymbolTable = varScope.m_symbolTable;
2035             ASSERT(varSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope);
2036             SymbolTableEntry entry = varSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2037             if (functionName == propertyNames().arguments &amp;&amp; entry.isNull()) {
2038                 // &quot;arguments&quot; might be put in the parameter scope when we have a non-simple
2039                 // parameter list since &quot;arguments&quot; is visible to expressions inside the
2040                 // parameter evaluation list.
2041                 // e.g:
2042                 // function foo(x = arguments) { { function arguments() { } } }
2043                 RELEASE_ASSERT(*m_varScopeLexicalScopeStackIndex &gt; 0);
2044                 varScope = m_lexicalScopeStack[*m_varScopeLexicalScopeStackIndex - 1];
2045                 SymbolTable* parameterSymbolTable = varScope.m_symbolTable;
2046                 entry = parameterSymbolTable-&gt;get(NoLockingNecessary, functionName.impl());
2047             }
2048             RELEASE_ASSERT(!entry.isNull());
2049             bool isLexicallyScoped = false;
2050             emitPutToScope(varScope.m_scope, variableForLocalEntry(functionName, entry, varScope.m_symbolTableConstantIndex, isLexicallyScoped), currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2051         } else {
2052             Variable currentFunctionVariable = variable(functionName);
2053             RefPtr&lt;RegisterID&gt; currentValue;
2054             if (RegisterID* local = currentFunctionVariable.local())
2055                 currentValue = local;
2056             else {
2057                 RefPtr&lt;RegisterID&gt; scope = emitResolveScope(nullptr, currentFunctionVariable);
2058                 currentValue = emitGetFromScope(newTemporary(), scope.get(), currentFunctionVariable, DoNotThrowIfNotFound);
2059             }
2060 
2061             RefPtr&lt;RegisterID&gt; scopeId = emitResolveScopeForHoistingFuncDeclInEval(nullptr, functionName);
2062             RefPtr&lt;RegisterID&gt; checkResult = emitIsUndefined(newTemporary(), scopeId.get());
2063 
2064             Ref&lt;Label&gt; isNotVarScopeLabel = newLabel();
2065             emitJumpIfTrue(checkResult.get(), isNotVarScopeLabel.get());
2066 
2067             // Put to outer scope
2068             emitPutToScope(scopeId.get(), functionName, currentValue.get(), DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2069             emitLabel(isNotVarScopeLabel.get());
2070 
2071         }
2072     }
2073 }
2074 
2075 RegisterID* BytecodeGenerator::emitResolveScopeForHoistingFuncDeclInEval(RegisterID* dst, const Identifier&amp; property)
2076 {
2077     ASSERT(m_codeType == EvalCode);
2078 
2079     dst = finalDestination(dst);
2080     OpResolveScopeForHoistingFuncDeclInEval::emit(this, kill(dst), m_topMostScope, addConstant(property));
2081     return dst;
2082 }
2083 
2084 void BytecodeGenerator::popLexicalScope(VariableEnvironmentNode* node)
2085 {
2086     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2087     popLexicalScopeInternal(environment);
2088 }
2089 
2090 void BytecodeGenerator::popLexicalScopeInternal(VariableEnvironment&amp; environment)
2091 {
2092     // NOTE: This function only makes sense for scopes that aren&#39;t ScopeRegisterType::Var (only function name scope right now is ScopeRegisterType::Var).
2093     // This doesn&#39;t make sense for ScopeRegisterType::Var because we deref RegisterIDs here.
2094     if (!environment.size())
2095         return;
2096 
2097     if (shouldEmitDebugHooks())
2098         environment.markAllVariablesAsCaptured();
2099 
2100     auto stackEntry = m_lexicalScopeStack.takeLast();
2101     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2102     bool hasCapturedVariables = false;
2103     for (auto&amp; entry : environment) {
2104         if (entry.value.isCaptured()) {
2105             hasCapturedVariables = true;
2106             continue;
2107         }
2108         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, entry.key.get());
2109         ASSERT(!symbolTableEntry.isNull());
2110         VarOffset offset = symbolTableEntry.varOffset();
2111         ASSERT(offset.isStack());
2112         RegisterID* local = &amp;registerFor(offset.stackOffset());
2113         local-&gt;deref();
2114     }
2115 
2116     if (hasCapturedVariables) {
2117         RELEASE_ASSERT(stackEntry.m_scope);
<a name="64" id="anc64"></a><span class="line-modified">2118         emitGetParentScope(scopeRegister(), stackEntry.m_scope);</span>
2119         popLocalControlFlowScope();
2120         stackEntry.m_scope-&gt;deref();
2121     }
2122 
2123     m_TDZStack.removeLast();
2124     m_cachedVariablesUnderTDZ = { };
2125 }
2126 
2127 void BytecodeGenerator::prepareLexicalScopeForNextForLoopIteration(VariableEnvironmentNode* node, RegisterID* loopSymbolTable)
2128 {
2129     VariableEnvironment&amp; environment = node-&gt;lexicalVariables();
2130     if (!environment.size())
2131         return;
2132     if (shouldEmitDebugHooks())
2133         environment.markAllVariablesAsCaptured();
2134     if (!environment.hasCapturedVariables())
2135         return;
2136 
2137     RELEASE_ASSERT(loopSymbolTable);
2138 
2139     // This function needs to do setup for a for loop&#39;s activation if any of
2140     // the for loop&#39;s lexically declared variables are captured (that is, variables
2141     // declared in the loop header, not the loop body). This function needs to
2142     // make a copy of the current activation and copy the values from the previous
2143     // activation into the new activation because each iteration of a for loop
2144     // gets a new activation.
2145 
2146     auto stackEntry = m_lexicalScopeStack.last();
2147     SymbolTable* symbolTable = stackEntry.m_symbolTable;
2148     RegisterID* loopScope = stackEntry.m_scope;
2149     ASSERT(symbolTable-&gt;scopeSize());
2150     ASSERT(loopScope);
2151     Vector&lt;std::pair&lt;RegisterID*, Identifier&gt;&gt; activationValuesToCopyOver;
2152 
2153     {
2154         activationValuesToCopyOver.reserveInitialCapacity(symbolTable-&gt;scopeSize());
2155 
2156         for (auto end = symbolTable-&gt;end(NoLockingNecessary), ptr = symbolTable-&gt;begin(NoLockingNecessary); ptr != end; ++ptr) {
2157             if (!ptr-&gt;value.varOffset().isScope())
2158                 continue;
2159 
2160             RefPtr&lt;UniquedStringImpl&gt; ident = ptr-&gt;key;
2161             Identifier identifier = Identifier::fromUid(m_vm, ident.get());
2162 
2163             RegisterID* transitionValue = newBlockScopeVariable();
2164             transitionValue-&gt;ref();
2165             emitGetFromScope(transitionValue, loopScope, variableForLocalEntry(identifier, ptr-&gt;value, loopSymbolTable-&gt;index(), true), DoNotThrowIfNotFound);
2166             activationValuesToCopyOver.uncheckedAppend(std::make_pair(transitionValue, identifier));
2167         }
2168     }
2169 
2170     // We need this dynamic behavior of the executing code to ensure
2171     // each loop iteration has a new activation object. (It&#39;s pretty ugly).
2172     // Also, this new activation needs to be assigned to the same register
2173     // as the previous scope because the loop body is compiled under
2174     // the assumption that the scope&#39;s register index is constant even
2175     // though the value in that register will change on each loop iteration.
<a name="65" id="anc65"></a><span class="line-modified">2176     emitGetParentScope(scopeRegister(), loopScope);</span>

2177 
2178     OpCreateLexicalEnvironment::emit(this, loopScope, scopeRegister(), loopSymbolTable, addConstantValue(jsTDZValue()));
2179 
2180     move(scopeRegister(), loopScope);
2181 
2182     {
<a name="66" id="anc66"></a><span class="line-modified">2183         for (const auto&amp; pair : activationValuesToCopyOver) {</span>
2184             const Identifier&amp; identifier = pair.second;
2185             SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, identifier.impl());
2186             RELEASE_ASSERT(!entry.isNull());
2187             RegisterID* transitionValue = pair.first;
2188             emitPutToScope(loopScope, variableForLocalEntry(identifier, entry, loopSymbolTable-&gt;index(), true), transitionValue, DoNotThrowIfNotFound, InitializationMode::NotInitialization);
2189             transitionValue-&gt;deref();
2190         }
2191     }
2192 }
2193 
2194 Variable BytecodeGenerator::variable(const Identifier&amp; property, ThisResolutionType thisResolutionType)
2195 {
2196     if (property == propertyNames().thisIdentifier &amp;&amp; thisResolutionType == ThisResolutionType::Local)
2197         return Variable(property, VarOffset(thisRegister()-&gt;virtualRegister()), thisRegister(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly), Variable::SpecialVariable, 0, false);
2198 
2199     // We can optimize lookups if the lexical variable is found before a &quot;with&quot; or &quot;catch&quot;
2200     // scope because we&#39;re guaranteed static resolution. If we have to pass through
2201     // a &quot;with&quot; or &quot;catch&quot; scope we loose this guarantee.
2202     // We can&#39;t optimize cases like this:
2203     // {
2204     //     let x = ...;
2205     //     with (o) {
2206     //         doSomethingWith(x);
2207     //     }
2208     // }
2209     // Because we can&#39;t gaurantee static resolution on x.
2210     // But, in this case, we are guaranteed static resolution:
2211     // {
2212     //     let x = ...;
2213     //     with (o) {
2214     //         let x = ...;
2215     //         doSomethingWith(x);
2216     //     }
2217     // }
2218     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2219         auto&amp; stackEntry = m_lexicalScopeStack[i];
2220         if (stackEntry.m_isWithScope)
2221             return Variable(property);
2222         SymbolTable* symbolTable = stackEntry.m_symbolTable;
2223         SymbolTableEntry symbolTableEntry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2224         if (symbolTableEntry.isNull())
2225             continue;
2226         bool resultIsCallee = false;
2227         if (symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2228             if (m_usesNonStrictEval) {
2229                 // We don&#39;t know if an eval has introduced a &quot;var&quot; named the same thing as the function name scope variable name.
2230                 // We resort to dynamic lookup to answer this question.
2231                 Variable result = Variable(property);
2232                 return result;
2233             }
2234             resultIsCallee = true;
2235         }
2236         Variable result = variableForLocalEntry(property, symbolTableEntry, stackEntry.m_symbolTableConstantIndex, symbolTable-&gt;scopeType() == SymbolTable::ScopeType::LexicalScope);
2237         if (resultIsCallee)
2238             result.setIsReadOnly();
2239         return result;
2240     }
2241 
2242     return Variable(property);
2243 }
2244 
2245 Variable BytecodeGenerator::variableForLocalEntry(
2246     const Identifier&amp; property, const SymbolTableEntry&amp; entry, int symbolTableConstantIndex, bool isLexicallyScoped)
2247 {
2248     VarOffset offset = entry.varOffset();
2249 
2250     RegisterID* local;
2251     if (offset.isStack())
2252         local = &amp;registerFor(offset.stackOffset());
2253     else
2254         local = nullptr;
2255 
2256     return Variable(property, offset, local, entry.getAttributes(), Variable::NormalVariable, symbolTableConstantIndex, isLexicallyScoped);
2257 }
2258 
2259 void BytecodeGenerator::createVariable(
2260     const Identifier&amp; property, VarKind varKind, SymbolTable* symbolTable, ExistingVariableMode existingVariableMode)
2261 {
2262     ASSERT(property != propertyNames().thisIdentifier);
2263     SymbolTableEntry entry = symbolTable-&gt;get(NoLockingNecessary, property.impl());
2264 
2265     if (!entry.isNull()) {
2266         if (existingVariableMode == IgnoreExisting)
2267             return;
2268 
2269         // Do some checks to ensure that the variable we&#39;re being asked to create is sufficiently
2270         // compatible with the one we have already created.
2271 
2272         VarOffset offset = entry.varOffset();
2273 
2274         // We can&#39;t change our minds about whether it&#39;s captured.
2275         if (offset.kind() != varKind) {
2276             dataLog(
2277                 &quot;Trying to add variable called &quot;, property, &quot; as &quot;, varKind,
2278                 &quot; but it was already added as &quot;, offset, &quot;.\n&quot;);
2279             RELEASE_ASSERT_NOT_REACHED();
2280         }
2281 
2282         return;
2283     }
2284 
2285     VarOffset varOffset;
2286     if (varKind == VarKind::Scope)
2287         varOffset = VarOffset(symbolTable-&gt;takeNextScopeOffset(NoLockingNecessary));
2288     else {
2289         ASSERT(varKind == VarKind::Stack);
2290         varOffset = VarOffset(virtualRegisterForLocal(m_calleeLocals.size()));
2291     }
2292     SymbolTableEntry newEntry(varOffset, 0);
2293     symbolTable-&gt;add(NoLockingNecessary, property.impl(), newEntry);
2294 
2295     if (varKind == VarKind::Stack) {
2296         RegisterID* local = addVar();
2297         RELEASE_ASSERT(local-&gt;index() == varOffset.stackOffset().offset());
2298     }
2299 }
2300 
2301 RegisterID* BytecodeGenerator::emitOverridesHasInstance(RegisterID* dst, RegisterID* constructor, RegisterID* hasInstanceValue)
2302 {
2303     OpOverridesHasInstance::emit(this, dst, constructor, hasInstanceValue);
2304     return dst;
2305 }
2306 
2307 // Indicates the least upper bound of resolve type based on local scope. The bytecode linker
2308 // will start with this ResolveType and compute the least upper bound including intercepting scopes.
2309 ResolveType BytecodeGenerator::resolveType()
2310 {
2311     for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2312         if (m_lexicalScopeStack[i].m_isWithScope)
2313             return Dynamic;
2314         if (m_usesNonStrictEval &amp;&amp; m_lexicalScopeStack[i].m_symbolTable-&gt;scopeType() == SymbolTable::ScopeType::FunctionNameScope) {
2315             // We never want to assign to a FunctionNameScope. Returning Dynamic here achieves this goal.
2316             // If we aren&#39;t in non-strict eval mode, then NodesCodeGen needs to take care not to emit
2317             // a put_to_scope with the destination being the function name scope variable.
2318             return Dynamic;
2319         }
2320     }
2321 
2322     if (m_usesNonStrictEval)
2323         return GlobalPropertyWithVarInjectionChecks;
2324     return GlobalProperty;
2325 }
2326 
2327 RegisterID* BytecodeGenerator::emitResolveScope(RegisterID* dst, const Variable&amp; variable)
2328 {
2329     switch (variable.offset().kind()) {
2330     case VarKind::Stack:
2331         return nullptr;
2332 
2333     case VarKind::DirectArgument:
2334         return argumentsRegister();
2335 
2336     case VarKind::Scope: {
2337         // This always refers to the activation that *we* allocated, and not the current scope that code
2338         // lives in. Note that this will change once we have proper support for block scoping. Once that
2339         // changes, it will be correct for this code to return scopeRegister(). The only reason why we
2340         // don&#39;t do that already is that m_lexicalEnvironment is required by ConstDeclNode. ConstDeclNode
2341         // requires weird things because it is a shameful pile of nonsense, but block scoping would make
2342         // that code sensible and obviate the need for us to do bad things.
2343         for (unsigned i = m_lexicalScopeStack.size(); i--; ) {
2344             auto&amp; stackEntry = m_lexicalScopeStack[i];
2345             // We should not resolve a variable to VarKind::Scope if a &quot;with&quot; scope lies in between the current
2346             // scope and the resolved scope.
2347             RELEASE_ASSERT(!stackEntry.m_isWithScope);
2348 
2349             if (stackEntry.m_symbolTable-&gt;get(NoLockingNecessary, variable.ident().impl()).isNull())
2350                 continue;
2351 
2352             RegisterID* scope = stackEntry.m_scope;
2353             RELEASE_ASSERT(scope);
2354             return scope;
2355         }
2356 
2357         RELEASE_ASSERT_NOT_REACHED();
2358         return nullptr;
2359 
2360     }
2361     case VarKind::Invalid:
2362         // Indicates non-local resolution.
2363 
2364         dst = tempDestination(dst);
2365         OpResolveScope::emit(this, kill(dst), scopeRegister(), addConstant(variable.ident()), resolveType(), localScopeDepth());
<a name="67" id="anc67"></a>
2366         return dst;
2367     }
2368 
2369     RELEASE_ASSERT_NOT_REACHED();
2370     return nullptr;
2371 }
2372 
2373 RegisterID* BytecodeGenerator::emitGetFromScope(RegisterID* dst, RegisterID* scope, const Variable&amp; variable, ResolveMode resolveMode)
2374 {
2375     switch (variable.offset().kind()) {
2376     case VarKind::Stack:
2377         return move(dst, variable.local());
2378 
2379     case VarKind::DirectArgument: {
2380         OpGetFromArguments::emit(this, kill(dst), scope, variable.offset().capturedArgumentsOffset().offset());
2381         return dst;
2382     }
2383 
2384     case VarKind::Scope:
2385     case VarKind::Invalid: {
2386         OpGetFromScope::emit(
2387             this,
2388             kill(dst),
2389             scope,
2390             addConstant(variable.ident()),
2391             GetPutInfo(resolveMode, variable.offset().isScope() ? LocalClosureVar : resolveType(), InitializationMode::NotInitialization),
2392             localScopeDepth(),
2393             variable.offset().isScope() ? variable.offset().scopeOffset().offset() : 0);
<a name="68" id="anc68"></a>
2394         return dst;
2395     } }
2396 
2397     RELEASE_ASSERT_NOT_REACHED();
2398 }
2399 
2400 RegisterID* BytecodeGenerator::emitPutToScope(RegisterID* scope, const Variable&amp; variable, RegisterID* value, ResolveMode resolveMode, InitializationMode initializationMode)
2401 {
2402     switch (variable.offset().kind()) {
2403     case VarKind::Stack:
2404         move(variable.local(), value);
2405         return value;
2406 
2407     case VarKind::DirectArgument:
2408         OpPutToArguments::emit(this, scope, variable.offset().capturedArgumentsOffset().offset(), value);
2409         return value;
2410 
2411     case VarKind::Scope:
2412     case VarKind::Invalid: {
2413         GetPutInfo getPutInfo(0);
2414         SymbolTableOrScopeDepth symbolTableOrScopeDepth;
2415         ScopeOffset offset;
2416         if (variable.offset().isScope()) {
2417             offset = variable.offset().scopeOffset();
2418             getPutInfo = GetPutInfo(resolveMode, LocalClosureVar, initializationMode);
2419             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::symbolTable(VirtualRegister { variable.symbolTableConstantIndex() });
2420         } else {
2421             ASSERT(resolveType() != LocalClosureVar);
2422             getPutInfo = GetPutInfo(resolveMode, resolveType(), initializationMode);
2423             symbolTableOrScopeDepth = SymbolTableOrScopeDepth::scopeDepth(localScopeDepth());
2424         }
2425         OpPutToScope::emit(this, scope, addConstant(variable.ident()), value, getPutInfo, symbolTableOrScopeDepth, !!offset ? offset.offset() : 0);
<a name="69" id="anc69"></a>
2426         return value;
2427     } }
2428 
2429     RELEASE_ASSERT_NOT_REACHED();
2430 }
2431 
2432 RegisterID* BytecodeGenerator::initializeVariable(const Variable&amp; variable, RegisterID* value)
2433 {
2434     RELEASE_ASSERT(variable.offset().kind() != VarKind::Invalid);
2435     RegisterID* scope = emitResolveScope(nullptr, variable);
2436     return emitPutToScope(scope, variable, value, ThrowIfNotFound, InitializationMode::NotInitialization);
2437 }
2438 
2439 RegisterID* BytecodeGenerator::emitInstanceOf(RegisterID* dst, RegisterID* value, RegisterID* basePrototype)
2440 {
2441     OpInstanceof::emit(this, dst, value, basePrototype);
2442     return dst;
2443 }
2444 
2445 RegisterID* BytecodeGenerator::emitInstanceOfCustom(RegisterID* dst, RegisterID* value, RegisterID* constructor, RegisterID* hasInstanceValue)
2446 {
2447     OpInstanceofCustom::emit(this, dst, value, constructor, hasInstanceValue);
2448     return dst;
2449 }
2450 
2451 RegisterID* BytecodeGenerator::emitInByVal(RegisterID* dst, RegisterID* property, RegisterID* base)
2452 {
2453     OpInByVal::emit(this, dst, base, property);
2454     return dst;
2455 }
2456 
2457 RegisterID* BytecodeGenerator::emitInById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2458 {
2459     OpInById::emit(this, dst, base, addConstant(property));
2460     return dst;
2461 }
2462 
2463 RegisterID* BytecodeGenerator::emitTryGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2464 {
2465     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties are not supported with tryGetById.&quot;);
2466 
2467     OpTryGetById::emit(this, kill(dst), base, addConstant(property));
2468     return dst;
2469 }
2470 
2471 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2472 {
2473     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2474 
2475     OpGetById::emit(this, kill(dst), base, addConstant(property));
<a name="70" id="anc70"></a>
2476     return dst;
2477 }
2478 
2479 RegisterID* BytecodeGenerator::emitGetById(RegisterID* dst, RegisterID* base, RegisterID* thisVal, const Identifier&amp; property)
2480 {
2481     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val.&quot;);
2482 
2483     OpGetByIdWithThis::emit(this, kill(dst), base, thisVal, addConstant(property));
2484     return dst;
2485 }
2486 
2487 RegisterID* BytecodeGenerator::emitDirectGetById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2488 {
2489     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with get_by_val_direct.&quot;);
2490 
2491     OpGetByIdDirect::emit(this, kill(dst), base, addConstant(property));
<a name="71" id="anc71"></a>
2492     return dst;
2493 }
2494 
2495 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value)
2496 {
2497     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2498 
2499     unsigned propertyIndex = addConstant(property);
2500 
2501     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2502 
2503     OpPutById::emit(this, base, propertyIndex, value, PutByIdNone); // is not direct
<a name="72" id="anc72"></a>

2504     return value;
2505 }
2506 
2507 RegisterID* BytecodeGenerator::emitPutById(RegisterID* base, RegisterID* thisValue, const Identifier&amp; property, RegisterID* value)
2508 {
2509     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val.&quot;);
2510 
2511     unsigned propertyIndex = addConstant(property);
2512 
2513     OpPutByIdWithThis::emit(this, base, thisValue, propertyIndex, value);
2514 
2515     return value;
2516 }
2517 
2518 RegisterID* BytecodeGenerator::emitDirectPutById(RegisterID* base, const Identifier&amp; property, RegisterID* value, PropertyNode::PutType putType)
2519 {
2520     ASSERT_WITH_MESSAGE(!parseIndex(property), &quot;Indexed properties should be handled with put_by_val(direct).&quot;);
2521 
2522     unsigned propertyIndex = addConstant(property);
2523 
2524     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2525 
2526     PutByIdFlags type = (putType == PropertyNode::KnownDirect || property != m_vm.propertyNames-&gt;underscoreProto) ? PutByIdIsDirect : PutByIdNone;
2527     OpPutById::emit(this, base, propertyIndex, value, type);
<a name="73" id="anc73"></a>
2528     return value;
2529 }
2530 
2531 void BytecodeGenerator::emitPutGetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter)
2532 {
2533     unsigned propertyIndex = addConstant(property);
2534     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2535 
2536     OpPutGetterById::emit(this, base, propertyIndex, attributes, getter);
2537 }
2538 
2539 void BytecodeGenerator::emitPutSetterById(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* setter)
2540 {
2541     unsigned propertyIndex = addConstant(property);
2542     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2543 
2544     OpPutSetterById::emit(this, base, propertyIndex, attributes, setter);
2545 }
2546 
2547 void BytecodeGenerator::emitPutGetterSetter(RegisterID* base, const Identifier&amp; property, unsigned attributes, RegisterID* getter, RegisterID* setter)
2548 {
2549     unsigned propertyIndex = addConstant(property);
2550 
2551     m_staticPropertyAnalyzer.putById(base, propertyIndex);
2552 
2553     OpPutGetterSetterById::emit(this, base, propertyIndex, attributes, getter, setter);
2554 }
2555 
2556 void BytecodeGenerator::emitPutGetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* getter)
2557 {
2558     OpPutGetterByVal::emit(this, base, property, attributes, getter);
2559 }
2560 
2561 void BytecodeGenerator::emitPutSetterByVal(RegisterID* base, RegisterID* property, unsigned attributes, RegisterID* setter)
2562 {
2563     OpPutSetterByVal::emit(this, base, property, attributes, setter);
2564 }
2565 
2566 void BytecodeGenerator::emitPutGeneratorFields(RegisterID* nextFunction)
2567 {
<a name="74" id="anc74"></a><span class="line-modified">2568     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::Next), nextFunction);</span>




2569 
2570     // We do not store &#39;this&#39; in arrow function within constructor,
2571     // because it might be not initialized, if super is called later.
2572     if (!(isDerivedConstructorContext() &amp;&amp; m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionMode))
<a name="75" id="anc75"></a><span class="line-modified">2573         emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSGenerator::Field::This), &amp;m_thisRegister);</span>




2574 }
2575 
2576 void BytecodeGenerator::emitPutAsyncGeneratorFields(RegisterID* nextFunction)
2577 {
2578     ASSERT(isAsyncGeneratorWrapperParseMode(parseMode()));
2579 
<a name="76" id="anc76"></a><span class="line-modified">2580     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::Next), nextFunction);</span>
<span class="line-modified">2581     emitPutInternalField(m_generatorRegister, static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::This), &amp;m_thisRegister);</span>










2582 }
2583 
2584 RegisterID* BytecodeGenerator::emitDeleteById(RegisterID* dst, RegisterID* base, const Identifier&amp; property)
2585 {
2586     OpDelById::emit(this, dst, base, addConstant(property));
2587     return dst;
2588 }
2589 
2590 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2591 {
2592     for (size_t i = m_forInContextStack.size(); i--; ) {
2593         ForInContext&amp; context = m_forInContextStack[i].get();
2594         if (context.local() != property)
2595             continue;
2596 
2597         if (context.isIndexedForInContext()) {
2598             auto&amp; indexedContext = context.asIndexedForInContext();
2599             kill(dst);
2600             if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Narrow&gt;(this, dst, base, property))
2601                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(this, dst, base, indexedContext.index());
2602             else if (OpGetByVal::checkWithoutMetadataID&lt;OpcodeSize::Wide16&gt;(this, dst, base, property))
2603                 OpGetByVal::emitWithSmallestSizeRequirement&lt;OpcodeSize::Wide16&gt;(this, dst, base, indexedContext.index());
2604             else
2605                 OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(this, dst, base, indexedContext.index());
2606             indexedContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2607             return dst;
2608         }
2609 
2610         // We cannot do the above optimization here since OpGetDirectPname =&gt; OpGetByVal conversion involves different metadata ID allocation.
2611         StructureForInContext&amp; structureContext = context.asStructureForInContext();
2612         OpGetDirectPname::emit&lt;OpcodeSize::Wide32&gt;(this, kill(dst), base, property, structureContext.index(), structureContext.enumerator());
2613 
2614         structureContext.addGetInst(m_lastInstruction.offset(), property-&gt;index());
2615         return dst;
2616     }
2617 
2618     OpGetByVal::emit(this, kill(dst), base, property);
2619     return dst;
2620 }
2621 
2622 RegisterID* BytecodeGenerator::emitGetByVal(RegisterID* dst, RegisterID* base, RegisterID* thisValue, RegisterID* property)
2623 {
2624     OpGetByValWithThis::emit(this, kill(dst), base, thisValue, property);
2625     return dst;
2626 }
2627 
2628 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2629 {
2630     OpPutByVal::emit(this, base, property, value);
2631     return value;
2632 }
2633 
2634 RegisterID* BytecodeGenerator::emitPutByVal(RegisterID* base, RegisterID* thisValue, RegisterID* property, RegisterID* value)
2635 {
2636     OpPutByValWithThis::emit(this, base, thisValue, property, value);
2637     return value;
2638 }
2639 
2640 RegisterID* BytecodeGenerator::emitDirectPutByVal(RegisterID* base, RegisterID* property, RegisterID* value)
2641 {
2642     OpPutByValDirect::emit(this, base, property, value);
2643     return value;
2644 }
2645 
2646 RegisterID* BytecodeGenerator::emitDeleteByVal(RegisterID* dst, RegisterID* base, RegisterID* property)
2647 {
2648     OpDelByVal::emit(this, dst, base, property);
2649     return dst;
2650 }
2651 
<a name="77" id="anc77"></a><span class="line-added">2652 RegisterID* BytecodeGenerator::emitGetInternalField(RegisterID* dst, RegisterID* base, unsigned index)</span>
<span class="line-added">2653 {</span>
<span class="line-added">2654     OpGetInternalField::emit(this, dst, base, index);</span>
<span class="line-added">2655     return dst;</span>
<span class="line-added">2656 }</span>
<span class="line-added">2657 </span>
<span class="line-added">2658 RegisterID* BytecodeGenerator::emitPutInternalField(RegisterID* base, unsigned index, RegisterID* value)</span>
<span class="line-added">2659 {</span>
<span class="line-added">2660     OpPutInternalField::emit(this, base, index, value);</span>
<span class="line-added">2661     return value;</span>
<span class="line-added">2662 }</span>
<span class="line-added">2663 </span>
2664 void BytecodeGenerator::emitSuperSamplerBegin()
2665 {
2666     OpSuperSamplerBegin::emit(this);
2667 }
2668 
2669 void BytecodeGenerator::emitSuperSamplerEnd()
2670 {
2671     OpSuperSamplerEnd::emit(this);
2672 }
2673 
2674 RegisterID* BytecodeGenerator::emitIdWithProfile(RegisterID* src, SpeculatedType profile)
2675 {
2676     OpIdentityWithProfile::emit(this, src, static_cast&lt;uint32_t&gt;(profile &gt;&gt; 32), static_cast&lt;uint32_t&gt;(profile));
2677     return src;
2678 }
2679 
2680 void BytecodeGenerator::emitUnreachable()
2681 {
2682     OpUnreachable::emit(this);
2683 }
2684 
2685 RegisterID* BytecodeGenerator::emitGetArgument(RegisterID* dst, int32_t index)
2686 {
2687     OpGetArgument::emit(this, dst, index + 1 /* Including |this| */);
2688     return dst;
2689 }
2690 
2691 RegisterID* BytecodeGenerator::emitCreateThis(RegisterID* dst)
2692 {
2693     OpCreateThis::emit(this, dst, dst, 0);
2694     m_staticPropertyAnalyzer.createThis(dst, m_lastInstruction);
<a name="78" id="anc78"></a><span class="line-added">2695     return dst;</span>
<span class="line-added">2696 }</span>
<span class="line-added">2697 </span>
<span class="line-added">2698 RegisterID* BytecodeGenerator::emitCreatePromise(RegisterID* dst, RegisterID* newTarget, bool isInternalPromise)</span>
<span class="line-added">2699 {</span>
<span class="line-added">2700     OpCreatePromise::emit(this, dst, newTarget, isInternalPromise);</span>
<span class="line-added">2701     return dst;</span>
<span class="line-added">2702 }</span>
<span class="line-added">2703 </span>
<span class="line-added">2704 RegisterID* BytecodeGenerator::emitNewPromise(RegisterID* dst, bool isInternalPromise)</span>
<span class="line-added">2705 {</span>
<span class="line-added">2706     OpNewPromise::emit(this, dst, isInternalPromise);</span>
<span class="line-added">2707     return dst;</span>
<span class="line-added">2708 }</span>
<span class="line-added">2709 </span>
<span class="line-added">2710 RegisterID* BytecodeGenerator::emitCreateGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">2711 {</span>
<span class="line-added">2712     OpCreateGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">2713     return dst;</span>
<span class="line-added">2714 }</span>
<span class="line-added">2715 </span>
<span class="line-added">2716 RegisterID* BytecodeGenerator::emitNewGenerator(RegisterID* dst)</span>
<span class="line-added">2717 {</span>
<span class="line-added">2718     OpNewGenerator::emit(this, dst);</span>
<span class="line-added">2719     return dst;</span>
<span class="line-added">2720 }</span>
<span class="line-added">2721 </span>
<span class="line-added">2722 RegisterID* BytecodeGenerator::emitCreateAsyncGenerator(RegisterID* dst, RegisterID* newTarget)</span>
<span class="line-added">2723 {</span>
<span class="line-added">2724     OpCreateAsyncGenerator::emit(this, dst, newTarget);</span>
<span class="line-added">2725     return dst;</span>
<span class="line-added">2726 }</span>
<span class="line-added">2727 </span>
<span class="line-added">2728 RegisterID* BytecodeGenerator::emitCreateArgumentsButterfly(RegisterID* dst)</span>
<span class="line-added">2729 {</span>
<span class="line-added">2730     OpCreateArgumentsButterfly::emit(this, dst);</span>
<span class="line-added">2731     return dst;</span>
<span class="line-added">2732 }</span>
<span class="line-added">2733 </span>
<span class="line-added">2734 RegisterID* BytecodeGenerator::emitInstanceFieldInitializationIfNeeded(RegisterID* dst, RegisterID* constructor, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)</span>
<span class="line-added">2735 {</span>
<span class="line-added">2736     if (!(isConstructor() || isDerivedConstructorContext()) || needsClassFieldInitializer() == NeedsClassFieldInitializer::No)</span>
<span class="line-added">2737         return dst;</span>
<span class="line-added">2738 </span>
<span class="line-added">2739     RefPtr&lt;RegisterID&gt; initializer = emitDirectGetById(newTemporary(), constructor, propertyNames().builtinNames().instanceFieldInitializerPrivateName());</span>
<span class="line-added">2740     CallArguments args(*this, nullptr);</span>
<span class="line-added">2741     emitMove(args.thisRegister(), dst);</span>
<span class="line-added">2742     emitCall(newTemporary(), initializer.get(), NoExpectedFunction, args, divot, divotStart, divotEnd, DebuggableCall::No);</span>
2743 
<a name="79" id="anc79"></a>
2744     return dst;
2745 }
2746 
2747 void BytecodeGenerator::emitTDZCheck(RegisterID* target)
2748 {
2749     OpCheckTdz::emit(this, target);
2750 }
2751 
2752 bool BytecodeGenerator::needsTDZCheck(const Variable&amp; variable)
2753 {
2754     for (unsigned i = m_TDZStack.size(); i--;) {
2755         auto iter = m_TDZStack[i].find(variable.ident().impl());
2756         if (iter == m_TDZStack[i].end())
2757             continue;
2758         return iter-&gt;value != TDZNecessityLevel::NotNeeded;
2759     }
2760 
2761     return false;
2762 }
2763 
2764 void BytecodeGenerator::emitTDZCheckIfNecessary(const Variable&amp; variable, RegisterID* target, RegisterID* scope)
2765 {
2766     if (needsTDZCheck(variable)) {
2767         if (target)
2768             emitTDZCheck(target);
2769         else {
2770             RELEASE_ASSERT(!variable.isLocal() &amp;&amp; scope);
2771             RefPtr&lt;RegisterID&gt; result = emitGetFromScope(newTemporary(), scope, variable, DoNotThrowIfNotFound);
2772             emitTDZCheck(result.get());
2773         }
2774     }
2775 }
2776 
2777 void BytecodeGenerator::liftTDZCheckIfPossible(const Variable&amp; variable)
2778 {
2779     RefPtr&lt;UniquedStringImpl&gt; identifier(variable.ident().impl());
2780     for (unsigned i = m_TDZStack.size(); i--;) {
2781         auto iter = m_TDZStack[i].find(identifier);
2782         if (iter != m_TDZStack[i].end()) {
2783             if (iter-&gt;value == TDZNecessityLevel::Optimize) {
2784                 m_cachedVariablesUnderTDZ = { };
2785                 iter-&gt;value = TDZNecessityLevel::NotNeeded;
2786             }
2787             break;
2788         }
2789     }
2790 }
2791 
2792 void BytecodeGenerator::pushTDZVariables(const VariableEnvironment&amp; environment, TDZCheckOptimization optimization, TDZRequirement requirement)
2793 {
2794     if (!environment.size())
2795         return;
2796 
2797     TDZNecessityLevel level;
2798     if (requirement == TDZRequirement::UnderTDZ) {
2799         if (optimization == TDZCheckOptimization::Optimize)
2800             level = TDZNecessityLevel::Optimize;
2801         else
2802             level = TDZNecessityLevel::DoNotOptimize;
2803     } else
2804         level = TDZNecessityLevel::NotNeeded;
2805 
2806     TDZMap map;
2807     for (const auto&amp; entry : environment)
2808         map.add(entry.key, entry.value.isFunction() ? TDZNecessityLevel::NotNeeded : level);
2809 
2810     m_TDZStack.append(WTFMove(map));
2811     m_cachedVariablesUnderTDZ = { };
2812 }
2813 
2814 Optional&lt;CompactVariableMap::Handle&gt; BytecodeGenerator::getVariablesUnderTDZ()
2815 {
2816     if (m_cachedVariablesUnderTDZ) {
2817         if (!m_hasCachedVariablesUnderTDZ) {
2818             ASSERT(m_cachedVariablesUnderTDZ.environment().toVariableEnvironment().isEmpty());
2819             return WTF::nullopt;
2820         }
2821         return m_cachedVariablesUnderTDZ;
2822     }
2823 
2824     // We keep track of variablesThatDontNeedTDZ in this algorithm to prevent
2825     // reporting that &quot;x&quot; is under TDZ if this function is called at &quot;...&quot;.
2826     //
2827     //     {
2828     //         {
2829     //             let x;
2830     //             ...
2831     //         }
2832     //         let x;
2833     //     }
2834     SmallPtrSet&lt;UniquedStringImpl*, 16&gt; variablesThatDontNeedTDZ;
2835     VariableEnvironment environment;
2836     for (unsigned i = m_TDZStack.size(); i--; ) {
2837         auto&amp; map = m_TDZStack[i];
2838         for (auto&amp; entry : map)  {
2839             if (entry.value != TDZNecessityLevel::NotNeeded) {
2840                 if (!variablesThatDontNeedTDZ.contains(entry.key.get()))
2841                     environment.add(entry.key.get());
2842             } else
2843                 variablesThatDontNeedTDZ.add(entry.key.get());
2844         }
2845     }
2846 
2847     m_cachedVariablesUnderTDZ = m_vm.m_compactVariableMap-&gt;get(environment);
2848     m_hasCachedVariablesUnderTDZ = !environment.isEmpty();
2849     if (!m_hasCachedVariablesUnderTDZ)
2850         return WTF::nullopt;
2851 
2852     return m_cachedVariablesUnderTDZ;
2853 }
2854 
2855 void BytecodeGenerator::preserveTDZStack(BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2856 {
2857     preservedStack.m_preservedTDZStack = m_TDZStack;
2858 }
2859 
2860 void BytecodeGenerator::restoreTDZStack(const BytecodeGenerator::PreservedTDZStack&amp; preservedStack)
2861 {
2862     m_TDZStack = preservedStack.m_preservedTDZStack;
2863     m_cachedVariablesUnderTDZ = { };
2864 }
2865 
2866 RegisterID* BytecodeGenerator::emitNewObject(RegisterID* dst)
2867 {
2868     OpNewObject::emit(this, dst, 0);
2869     m_staticPropertyAnalyzer.newObject(dst, m_lastInstruction);
2870 
2871     return dst;
2872 }
2873 
2874 JSValue BytecodeGenerator::addBigIntConstant(const Identifier&amp; identifier, uint8_t radix, bool sign)
2875 {
2876     return m_bigIntMap.ensure(BigIntMapEntry(identifier.impl(), radix, sign), [&amp;] {
2877         auto scope = DECLARE_CATCH_SCOPE(vm());
2878         auto parseIntSign = sign ? JSBigInt::ParseIntSign::Signed : JSBigInt::ParseIntSign::Unsigned;
2879         JSBigInt* bigIntInMap = JSBigInt::parseInt(nullptr, vm(), identifier.string(), radix, JSBigInt::ErrorParseMode::ThrowExceptions, parseIntSign);
<a name="80" id="anc80"></a>

2880         scope.assertNoException();
<a name="81" id="anc81"></a>
2881         addConstantValue(bigIntInMap);
2882 
2883         return bigIntInMap;
2884     }).iterator-&gt;value;
2885 }
2886 
2887 JSString* BytecodeGenerator::addStringConstant(const Identifier&amp; identifier)
2888 {
2889     JSString*&amp; stringInMap = m_stringMap.add(identifier.impl(), nullptr).iterator-&gt;value;
2890     if (!stringInMap) {
2891         stringInMap = jsString(vm(), identifier.string());
2892         addConstantValue(stringInMap);
2893     }
2894     return stringInMap;
2895 }
2896 
2897 RegisterID* BytecodeGenerator::addTemplateObjectConstant(Ref&lt;TemplateObjectDescriptor&gt;&amp;&amp; descriptor, int endOffset)
2898 {
2899     auto result = m_templateObjectDescriptorSet.add(WTFMove(descriptor));
2900     JSTemplateObjectDescriptor* descriptorValue = m_templateDescriptorMap.ensure(endOffset, [&amp;] {
2901         return JSTemplateObjectDescriptor::create(vm(), result.iterator-&gt;copyRef(), endOffset);
2902     }).iterator-&gt;value;
2903     int index = addConstantIndex();
2904     m_codeBlock-&gt;addConstant(descriptorValue);
2905     return &amp;m_constantPoolRegisters[index];
2906 }
2907 
2908 RegisterID* BytecodeGenerator::emitNewArrayBuffer(RegisterID* dst, JSImmutableButterfly* array, IndexingType recommendedIndexingType)
2909 {
2910     OpNewArrayBuffer::emit(this, dst, addConstantValue(array), recommendedIndexingType);
2911     return dst;
2912 }
2913 
2914 RegisterID* BytecodeGenerator::emitNewArray(RegisterID* dst, ElementNode* elements, unsigned length, IndexingType recommendedIndexingType)
2915 {
2916     Vector&lt;RefPtr&lt;RegisterID&gt;, 16, UnsafeVectorOverflow&gt; argv;
2917     for (ElementNode* n = elements; n; n = n-&gt;next()) {
2918         if (!length)
2919             break;
2920         length--;
2921         ASSERT(!n-&gt;value()-&gt;isSpreadExpression());
2922         argv.append(newTemporary());
2923         // op_new_array requires the initial values to be a sequential range of registers
2924         ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
2925         emitNode(argv.last().get(), n-&gt;value());
2926     }
2927     ASSERT(!length);
2928     OpNewArray::emit(this, dst, argv.size() ? argv[0].get() : VirtualRegister { 0 }, argv.size(), recommendedIndexingType);
2929     return dst;
2930 }
2931 
2932 RegisterID* BytecodeGenerator::emitNewArrayWithSpread(RegisterID* dst, ElementNode* elements)
2933 {
2934     BitVector bitVector;
2935     Vector&lt;RefPtr&lt;RegisterID&gt;, 16&gt; argv;
2936     for (ElementNode* node = elements; node; node = node-&gt;next()) {
2937         bitVector.set(argv.size(), node-&gt;value()-&gt;isSpreadExpression());
2938 
2939         argv.append(newTemporary());
2940         // op_new_array_with_spread requires the initial values to be a sequential range of registers.
2941         RELEASE_ASSERT(argv.size() == 1 || argv[argv.size() - 1]-&gt;index() == argv[argv.size() - 2]-&gt;index() - 1);
2942     }
2943 
2944     RELEASE_ASSERT(argv.size());
2945 
2946     {
2947         unsigned i = 0;
2948         for (ElementNode* node = elements; node; node = node-&gt;next()) {
2949             if (node-&gt;value()-&gt;isSpreadExpression()) {
2950                 ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(node-&gt;value())-&gt;expression();
2951                 RefPtr&lt;RegisterID&gt; tmp = newTemporary();
2952                 emitNode(tmp.get(), expression);
2953 
2954                 OpSpread::emit(this, argv[i].get(), tmp.get());
2955             } else {
2956                 ExpressionNode* expression = node-&gt;value();
2957                 emitNode(argv[i].get(), expression);
2958             }
2959             i++;
2960         }
2961     }
2962 
2963     unsigned bitVectorIndex = m_codeBlock-&gt;addBitVector(WTFMove(bitVector));
2964     OpNewArrayWithSpread::emit(this, dst, argv[0].get(), argv.size(), bitVectorIndex);
2965     return dst;
2966 }
2967 
2968 RegisterID* BytecodeGenerator::emitNewArrayWithSize(RegisterID* dst, RegisterID* length)
2969 {
2970     OpNewArrayWithSize::emit(this, dst, length);
2971     return dst;
2972 }
2973 
2974 RegisterID* BytecodeGenerator::emitNewRegExp(RegisterID* dst, RegExp* regExp)
2975 {
2976     OpNewRegexp::emit(this, dst, addConstantValue(regExp));
2977     return dst;
2978 }
2979 
2980 void BytecodeGenerator::emitNewFunctionExpressionCommon(RegisterID* dst, FunctionMetadataNode* function)
2981 {
2982     unsigned index = m_codeBlock-&gt;addFunctionExpr(makeFunction(function));
2983 
2984     switch (function-&gt;parseMode()) {
2985     case SourceParseMode::GeneratorWrapperFunctionMode:
2986     case SourceParseMode::GeneratorWrapperMethodMode:
2987         OpNewGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
2988         break;
2989     case SourceParseMode::AsyncFunctionMode:
2990     case SourceParseMode::AsyncMethodMode:
2991     case SourceParseMode::AsyncArrowFunctionMode:
2992         OpNewAsyncFuncExp::emit(this, dst, scopeRegister(), index);
2993         break;
2994     case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
2995     case SourceParseMode::AsyncGeneratorWrapperMethodMode:
2996         OpNewAsyncGeneratorFuncExp::emit(this, dst, scopeRegister(), index);
2997         break;
2998     default:
2999         OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3000         break;
3001     }
3002 }
3003 
3004 RegisterID* BytecodeGenerator::emitNewFunctionExpression(RegisterID* dst, FuncExprNode* func)
3005 {
3006     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3007     return dst;
3008 }
3009 
3010 RegisterID* BytecodeGenerator::emitNewArrowFunctionExpression(RegisterID* dst, ArrowFuncExprNode* func)
3011 {
3012     ASSERT(SourceParseModeSet(SourceParseMode::ArrowFunctionMode, SourceParseMode::AsyncArrowFunctionMode).contains(func-&gt;metadata()-&gt;parseMode()));
3013     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3014     return dst;
3015 }
3016 
3017 RegisterID* BytecodeGenerator::emitNewMethodDefinition(RegisterID* dst, MethodDefinitionNode* func)
3018 {
3019     ASSERT(isMethodParseMode(func-&gt;metadata()-&gt;parseMode()));
3020     emitNewFunctionExpressionCommon(dst, func-&gt;metadata());
3021     return dst;
3022 }
3023 
3024 RegisterID* BytecodeGenerator::emitNewDefaultConstructor(RegisterID* dst, ConstructorKind constructorKind, const Identifier&amp; name,
<a name="82" id="anc82"></a><span class="line-modified">3025     const Identifier&amp; ecmaName, const SourceCode&amp; classSource, NeedsClassFieldInitializer needsClassFieldInitializer)</span>
3026 {
<a name="83" id="anc83"></a><span class="line-modified">3027     UnlinkedFunctionExecutable* executable = m_vm.builtinExecutables()-&gt;createDefaultConstructor(constructorKind, name, needsClassFieldInitializer);</span>
3028     executable-&gt;setInvalidTypeProfilingOffsets();
3029     executable-&gt;setEcmaName(ecmaName);
3030     executable-&gt;setClassSource(classSource);
3031 
3032     unsigned index = m_codeBlock-&gt;addFunctionExpr(executable);
3033 
3034     OpNewFuncExp::emit(this, dst, scopeRegister(), index);
3035     return dst;
3036 }
3037 
<a name="84" id="anc84"></a><span class="line-added">3038 RegisterID* BytecodeGenerator::emitNewInstanceFieldInitializerFunction(RegisterID* dst, Vector&lt;JSTextPosition&gt;&amp;&amp; instanceFieldLocations, bool isDerived)</span>
<span class="line-added">3039 {</span>
<span class="line-added">3040     DerivedContextType newDerivedContextType;</span>
<span class="line-added">3041     SuperBinding superBinding;</span>
<span class="line-added">3042     if (!isDerived) {</span>
<span class="line-added">3043         newDerivedContextType = DerivedContextType::None;</span>
<span class="line-added">3044         superBinding = SuperBinding::NotNeeded;</span>
<span class="line-added">3045     } else {</span>
<span class="line-added">3046         newDerivedContextType = DerivedContextType::DerivedMethodContext;</span>
<span class="line-added">3047         superBinding = SuperBinding::Needed;</span>
<span class="line-added">3048     }</span>
<span class="line-added">3049 </span>
<span class="line-added">3050     Optional&lt;CompactVariableMap::Handle&gt; variablesUnderTDZ = getVariablesUnderTDZ();</span>
<span class="line-added">3051     SourceParseMode parseMode = SourceParseMode::InstanceFieldInitializerMode;</span>
<span class="line-added">3052     ConstructAbility constructAbility = ConstructAbility::CannotConstruct;</span>
<span class="line-added">3053 </span>
<span class="line-added">3054     const bool alwaysStrictInClass = true;</span>
<span class="line-added">3055     FunctionMetadataNode metadata(parserArena(), JSTokenLocation(), JSTokenLocation(), 0, 0, 0, 0, 0, alwaysStrictInClass, ConstructorKind::None, superBinding, 0, parseMode, false);</span>
<span class="line-added">3056     metadata.finishParsing(m_scopeNode-&gt;source(), Identifier(), FunctionMode::MethodDefinition);</span>
<span class="line-added">3057     auto initializer = UnlinkedFunctionExecutable::create(m_vm, m_scopeNode-&gt;source(), &amp;metadata, isBuiltinFunction() ? UnlinkedBuiltinFunction : UnlinkedNormalFunction, constructAbility, scriptMode(), WTFMove(variablesUnderTDZ), newDerivedContextType, NeedsClassFieldInitializer::No);</span>
<span class="line-added">3058     initializer-&gt;setInstanceFieldLocations(WTFMove(instanceFieldLocations));</span>
<span class="line-added">3059 </span>
<span class="line-added">3060     unsigned index = m_codeBlock-&gt;addFunctionExpr(initializer);</span>
<span class="line-added">3061     OpNewFuncExp::emit(this, dst, scopeRegister(), index);</span>
<span class="line-added">3062     return dst;</span>
<span class="line-added">3063 }</span>
<span class="line-added">3064 </span>
3065 RegisterID* BytecodeGenerator::emitNewFunction(RegisterID* dst, FunctionMetadataNode* function)
3066 {
3067     unsigned index = m_codeBlock-&gt;addFunctionDecl(makeFunction(function));
3068     if (isGeneratorWrapperParseMode(function-&gt;parseMode()))
3069         OpNewGeneratorFunc::emit(this, dst, scopeRegister(), index);
3070     else if (function-&gt;parseMode() == SourceParseMode::AsyncFunctionMode)
3071         OpNewAsyncFunc::emit(this, dst, scopeRegister(), index);
3072     else if (isAsyncGeneratorWrapperParseMode(function-&gt;parseMode()))
3073         OpNewAsyncGeneratorFunc::emit(this, dst, scopeRegister(), index);
3074     else
3075         OpNewFunc::emit(this, dst, scopeRegister(), index);
3076     return dst;
3077 }
3078 
<a name="85" id="anc85"></a><span class="line-modified">3079 template&lt;typename LazyNameRegisterFn&gt;</span>
<span class="line-added">3080 void BytecodeGenerator::emitSetFunctionNameIfNeededImpl(ExpressionNode* valueNode, RegisterID* value, const LazyNameRegisterFn&amp; lazyNameFn)</span>
3081 {
3082     if (valueNode-&gt;isBaseFuncExprNode()) {
3083         FunctionMetadataNode* metadata = static_cast&lt;BaseFuncExprNode*&gt;(valueNode)-&gt;metadata();
3084         if (!metadata-&gt;ecmaName().isNull())
3085             return;
3086     } else if (valueNode-&gt;isClassExprNode()) {
3087         ClassExprNode* classExprNode = static_cast&lt;ClassExprNode*&gt;(valueNode);
3088         if (!classExprNode-&gt;ecmaName().isNull())
3089             return;
3090         if (classExprNode-&gt;hasStaticProperty(m_vm.propertyNames-&gt;name))
3091             return;
3092     } else
3093         return;
3094 
<a name="86" id="anc86"></a><span class="line-added">3095     RegisterID* name = lazyNameFn();</span>
<span class="line-added">3096 </span>
3097     // FIXME: We should use an op_call to an internal function here instead.
3098     // https://bugs.webkit.org/show_bug.cgi?id=155547
3099     OpSetFunctionName::emit(this, value, name);
3100 }
3101 
<a name="87" id="anc87"></a><span class="line-added">3102 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, const Identifier&amp; ident)</span>
<span class="line-added">3103 {</span>
<span class="line-added">3104     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return emitLoad(newTemporary(), ident); });</span>
<span class="line-added">3105 }</span>
<span class="line-added">3106 </span>
<span class="line-added">3107 void BytecodeGenerator::emitSetFunctionNameIfNeeded(ExpressionNode* valueNode, RegisterID* value, RegisterID* name)</span>
<span class="line-added">3108 {</span>
<span class="line-added">3109     emitSetFunctionNameIfNeededImpl(valueNode, value, [=]() { return name; });</span>
<span class="line-added">3110 }</span>
<span class="line-added">3111 </span>
3112 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3113 {
3114     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3115 }
3116 
3117 RegisterID* BytecodeGenerator::emitCallInTailPosition(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3118 {
3119     if (m_inTailPosition) {
3120         m_codeBlock-&gt;setHasTailCalls();
3121         return emitCall&lt;OpTailCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3122     }
3123     return emitCall&lt;OpCall&gt;(dst, func, expectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3124 }
3125 
3126 RegisterID* BytecodeGenerator::emitCallEval(RegisterID* dst, RegisterID* func, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3127 {
3128     return emitCall&lt;OpCallEval&gt;(dst, func, NoExpectedFunction, callArguments, divot, divotStart, divotEnd, debuggableCall);
3129 }
3130 
3131 ExpectedFunction BytecodeGenerator::expectedFunctionForIdentifier(const Identifier&amp; identifier)
3132 {
3133     if (identifier == propertyNames().Object || identifier == propertyNames().builtinNames().ObjectPrivateName())
3134         return ExpectObjectConstructor;
3135     if (identifier == propertyNames().Array || identifier == propertyNames().builtinNames().ArrayPrivateName())
3136         return ExpectArrayConstructor;
3137     return NoExpectedFunction;
3138 }
3139 
3140 ExpectedFunction BytecodeGenerator::emitExpectedFunctionSnippet(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, Label&amp; done)
3141 {
3142     Ref&lt;Label&gt; realCall = newLabel();
3143     switch (expectedFunction) {
3144     case ExpectObjectConstructor: {
3145         // If the number of arguments is non-zero, then we can&#39;t do anything interesting.
3146         if (callArguments.argumentCountIncludingThis() &gt;= 2)
3147             return NoExpectedFunction;
3148 
<a name="88" id="anc88"></a><span class="line-modified">3149         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Object), realCall-&gt;bind(this));</span>
3150 
3151         if (dst != ignoredResult())
3152             emitNewObject(dst);
3153         break;
3154     }
3155 
3156     case ExpectArrayConstructor: {
3157         // If you&#39;re doing anything other than &quot;new Array()&quot; or &quot;new Array(foo)&quot; then we
3158         // don&#39;t do inline it, for now. The only reason is that call arguments are in
3159         // the opposite order of what op_new_array expects, so we&#39;d either need to change
3160         // how op_new_array works or we&#39;d need an op_new_array_reverse. Neither of these
3161         // things sounds like it&#39;s worth it.
3162         if (callArguments.argumentCountIncludingThis() &gt; 2)
3163             return NoExpectedFunction;
3164 
<a name="89" id="anc89"></a><span class="line-modified">3165         OpJneqPtr::emit(this, func, moveLinkTimeConstant(nullptr, LinkTimeConstant::Array), realCall-&gt;bind(this));</span>
3166 
3167         if (dst != ignoredResult()) {
3168             if (callArguments.argumentCountIncludingThis() == 2)
3169                 emitNewArrayWithSize(dst, callArguments.argumentRegister(0));
3170             else {
3171                 ASSERT(callArguments.argumentCountIncludingThis() == 1);
3172                 OpNewArray::emit(this, dst, VirtualRegister { 0 }, 0, ArrayWithUndecided);
3173             }
3174         }
3175         break;
3176     }
3177 
3178     default:
3179         ASSERT(expectedFunction == NoExpectedFunction);
3180         return NoExpectedFunction;
3181     }
3182 
3183     OpJmp::emit(this, done.bind(this));
3184     emitLabel(realCall.get());
3185 
3186     return expectedFunction;
3187 }
3188 
3189 template&lt;typename CallOp&gt;
3190 RegisterID* BytecodeGenerator::emitCall(RegisterID* dst, RegisterID* func, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3191 {
3192     constexpr auto opcodeID = CallOp::opcodeID;
3193     ASSERT(opcodeID == op_call || opcodeID == op_call_eval || opcodeID == op_tail_call);
3194     ASSERT(func-&gt;refCount());
3195 
3196     // Generate code for arguments.
3197     unsigned argument = 0;
3198     if (callArguments.argumentsNode()) {
3199         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3200         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3201             RELEASE_ASSERT(!n-&gt;m_next);
3202             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3203             if (expression-&gt;isArrayLiteral()) {
3204                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3205                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3206                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3207                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3208                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3209 
3210                     return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3211                 }
3212             }
3213             RefPtr&lt;RegisterID&gt; argumentRegister;
3214             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3215             RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3216             return emitCallVarargs&lt;typename VarArgsOp&lt;CallOp&gt;::type&gt;(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, debuggableCall);
3217         }
3218         for (; n; n = n-&gt;m_next)
3219             emitNode(callArguments.argumentRegister(argument++), n);
3220     }
3221 
3222     // Reserve space for call frame.
3223     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3224     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3225         callFrame.append(newTemporary());
3226 
3227     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3228         emitDebugHook(WillExecuteExpression, divotStart);
3229 
3230     emitExpressionInfo(divot, divotStart, divotEnd);
3231 
3232     Ref&lt;Label&gt; done = newLabel();
3233     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3234 
3235     if (opcodeID == op_tail_call)
3236         emitLogShadowChickenTailIfNecessary();
3237 
3238     // Emit call.
3239     ASSERT(dst);
3240     ASSERT(dst != ignoredResult());
3241     CallOp::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3242 
3243     if (expectedFunction != NoExpectedFunction)
3244         emitLabel(done.get());
3245 
3246     return dst;
3247 }
3248 
3249 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3250 {
3251     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3252 }
3253 
3254 RegisterID* BytecodeGenerator::emitCallVarargsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3255 {
3256     if (m_inTailPosition)
3257         return emitCallVarargs&lt;OpTailCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3258     return emitCallVarargs&lt;OpCallVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3259 }
3260 
3261 RegisterID* BytecodeGenerator::emitConstructVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3262 {
3263     return emitCallVarargs&lt;OpConstructVarargs&gt;(dst, func, thisRegister, arguments, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3264 }
3265 
3266 RegisterID* BytecodeGenerator::emitCallForwardArgumentsInTailPosition(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3267 {
3268     // We must emit a tail call here because we did not allocate an arguments object thus we would otherwise have no way to correctly make this call.
3269     ASSERT(m_inTailPosition || !Options::useTailCalls());
3270     return emitCallVarargs&lt;OpTailCallForwardArguments&gt;(dst, func, thisRegister, nullptr, firstFreeRegister, firstVarArgOffset, divot, divotStart, divotEnd, debuggableCall);
3271 }
3272 
3273 template&lt;typename VarargsOp&gt;
3274 RegisterID* BytecodeGenerator::emitCallVarargs(RegisterID* dst, RegisterID* func, RegisterID* thisRegister, RegisterID* arguments, RegisterID* firstFreeRegister, int32_t firstVarArgOffset, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, DebuggableCall debuggableCall)
3275 {
3276     if (shouldEmitDebugHooks() &amp;&amp; debuggableCall == DebuggableCall::Yes)
3277         emitDebugHook(WillExecuteExpression, divotStart);
3278 
3279     emitExpressionInfo(divot, divotStart, divotEnd);
3280 
3281     if (VarargsOp::opcodeID == op_tail_call_varargs)
3282         emitLogShadowChickenTailIfNecessary();
3283 
3284     // Emit call.
3285     ASSERT(dst != ignoredResult());
3286     VarargsOp::emit(this, dst, func, thisRegister, arguments ? arguments : VirtualRegister(0), firstFreeRegister, firstVarArgOffset);
<a name="90" id="anc90"></a><span class="line-added">3287     if (VarargsOp::opcodeID != op_tail_call_forward_arguments)</span>
<span class="line-added">3288         ASSERT(m_codeBlock-&gt;hasCheckpoints());</span>
3289     return dst;
3290 }
3291 
3292 void BytecodeGenerator::emitLogShadowChickenPrologueIfNecessary()
3293 {
3294     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3295         return;
3296     OpLogShadowChickenPrologue::emit(this, scopeRegister());
3297 }
3298 
3299 void BytecodeGenerator::emitLogShadowChickenTailIfNecessary()
3300 {
3301     if (!shouldEmitDebugHooks() &amp;&amp; !Options::alwaysUseShadowChicken())
3302         return;
3303     OpLogShadowChickenTail::emit(this, thisRegister(), scopeRegister());
3304 }
3305 
3306 void BytecodeGenerator::emitCallDefineProperty(RegisterID* newObj, RegisterID* propertyNameRegister,
3307     RegisterID* valueRegister, RegisterID* getterRegister, RegisterID* setterRegister, unsigned options, const JSTextPosition&amp; position)
3308 {
3309     DefinePropertyAttributes attributes;
3310     if (options &amp; PropertyConfigurable)
3311         attributes.setConfigurable(true);
3312 
3313     if (options &amp; PropertyWritable)
3314         attributes.setWritable(true);
3315     else if (valueRegister)
3316         attributes.setWritable(false);
3317 
3318     if (options &amp; PropertyEnumerable)
3319         attributes.setEnumerable(true);
3320 
3321     if (valueRegister)
3322         attributes.setValue();
3323     if (getterRegister)
3324         attributes.setGet();
3325     if (setterRegister)
3326         attributes.setSet();
3327 
3328     ASSERT(!valueRegister || (!getterRegister &amp;&amp; !setterRegister));
3329 
3330     emitExpressionInfo(position, position, position);
3331 
3332     if (attributes.hasGet() || attributes.hasSet()) {
3333         RefPtr&lt;RegisterID&gt; throwTypeErrorFunction;
3334         if (!attributes.hasGet() || !attributes.hasSet())
<a name="91" id="anc91"></a><span class="line-modified">3335             throwTypeErrorFunction = moveLinkTimeConstant(nullptr, LinkTimeConstant::throwTypeErrorFunction);</span>
3336 
3337         RefPtr&lt;RegisterID&gt; getter;
3338         if (attributes.hasGet())
3339             getter = getterRegister;
3340         else
3341             getter = throwTypeErrorFunction;
3342 
3343         RefPtr&lt;RegisterID&gt; setter;
3344         if (attributes.hasSet())
3345             setter = setterRegister;
3346         else
3347             setter = throwTypeErrorFunction;
3348 
3349         OpDefineAccessorProperty::emit(this, newObj, propertyNameRegister, getter.get(), setter.get(), emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3350     } else {
3351         OpDefineDataProperty::emit(this, newObj, propertyNameRegister, valueRegister, emitLoad(nullptr, jsNumber(attributes.rawRepresentation())));
3352     }
3353 }
3354 
3355 RegisterID* BytecodeGenerator::emitReturn(RegisterID* src, ReturnFrom from)
3356 {
<a name="92" id="anc92"></a><span class="line-modified">3357     // Normal functions and naked constructors do not handle `return` specially.</span>
<span class="line-added">3358     if (isConstructor() &amp;&amp; constructorKind() != ConstructorKind::Naked) {</span>
3359         bool isDerived = constructorKind() == ConstructorKind::Extends;
3360         bool srcIsThis = src-&gt;index() == m_thisRegister.index();
3361 
3362         if (isDerived &amp;&amp; (srcIsThis || from == ReturnFrom::Finally))
3363             emitTDZCheck(src);
3364 
3365         if (!srcIsThis || from == ReturnFrom::Finally) {
3366             Ref&lt;Label&gt; isObjectLabel = newLabel();
3367             emitJumpIfTrue(emitIsObject(newTemporary(), src), isObjectLabel.get());
3368 
3369             if (isDerived) {
3370                 Ref&lt;Label&gt; isUndefinedLabel = newLabel();
3371                 emitJumpIfTrue(emitIsUndefined(newTemporary(), src), isUndefinedLabel.get());
3372                 emitThrowTypeError(&quot;Cannot return a non-object type in the constructor of a derived class.&quot;);
3373                 emitLabel(isUndefinedLabel.get());
3374                 emitTDZCheck(&amp;m_thisRegister);
3375             }
3376             OpRet::emit(this, &amp;m_thisRegister);
3377             emitLabel(isObjectLabel.get());
3378         }
3379     }
3380 
3381     OpRet::emit(this, src);
3382     return src;
3383 }
3384 
3385 RegisterID* BytecodeGenerator::emitEnd(RegisterID* src)
3386 {
3387     OpEnd::emit(this, src);
3388     return src;
3389 }
3390 
3391 
3392 RegisterID* BytecodeGenerator::emitConstruct(RegisterID* dst, RegisterID* func, RegisterID* lazyThis, ExpectedFunction expectedFunction, CallArguments&amp; callArguments, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
3393 {
3394     ASSERT(func-&gt;refCount());
3395 
3396     // Generate code for arguments.
3397     unsigned argument = 0;
3398     if (ArgumentsNode* argumentsNode = callArguments.argumentsNode()) {
3399 
3400         ArgumentListNode* n = callArguments.argumentsNode()-&gt;m_listNode;
3401         if (n &amp;&amp; n-&gt;m_expr-&gt;isSpreadExpression()) {
3402             RELEASE_ASSERT(!n-&gt;m_next);
3403             auto expression = static_cast&lt;SpreadExpressionNode*&gt;(n-&gt;m_expr)-&gt;expression();
3404             if (expression-&gt;isArrayLiteral()) {
3405                 auto* elements = static_cast&lt;ArrayNode*&gt;(expression)-&gt;elements();
3406                 if (elements &amp;&amp; !elements-&gt;next() &amp;&amp; elements-&gt;value()-&gt;isSpreadExpression()) {
3407                     ExpressionNode* expression = static_cast&lt;SpreadExpressionNode*&gt;(elements-&gt;value())-&gt;expression();
3408                     RefPtr&lt;RegisterID&gt; argumentRegister = emitNode(callArguments.argumentRegister(0), expression);
3409                     OpSpread::emit(this, argumentRegister.get(), argumentRegister.get());
3410 
3411                     move(callArguments.thisRegister(), lazyThis);
3412                     RefPtr&lt;RegisterID&gt; thisRegister = move(newTemporary(), callArguments.thisRegister());
3413                     return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3414                 }
3415             }
3416             RefPtr&lt;RegisterID&gt; argumentRegister;
3417             argumentRegister = expression-&gt;emitBytecode(*this, callArguments.argumentRegister(0));
3418             move(callArguments.thisRegister(), lazyThis);
3419             return emitConstructVarargs(dst, func, callArguments.thisRegister(), argumentRegister.get(), newTemporary(), 0, divot, divotStart, divotEnd, DebuggableCall::No);
3420         }
3421 
3422         for (ArgumentListNode* n = argumentsNode-&gt;m_listNode; n; n = n-&gt;m_next)
3423             emitNode(callArguments.argumentRegister(argument++), n);
3424     }
3425 
3426     move(callArguments.thisRegister(), lazyThis);
3427 
3428     // Reserve space for call frame.
3429     Vector&lt;RefPtr&lt;RegisterID&gt;, CallFrame::headerSizeInRegisters, UnsafeVectorOverflow&gt; callFrame;
3430     for (int i = 0; i &lt; CallFrame::headerSizeInRegisters; ++i)
3431         callFrame.append(newTemporary());
3432 
3433     emitExpressionInfo(divot, divotStart, divotEnd);
3434 
3435     Ref&lt;Label&gt; done = newLabel();
3436     expectedFunction = emitExpectedFunctionSnippet(dst, func, expectedFunction, callArguments, done.get());
3437 
3438     OpConstruct::emit(this, dst, func, callArguments.argumentCountIncludingThis(), callArguments.stackOffset());
3439 
3440     if (expectedFunction != NoExpectedFunction)
3441         emitLabel(done.get());
3442 
3443     return dst;
3444 }
3445 
3446 RegisterID* BytecodeGenerator::emitStrcat(RegisterID* dst, RegisterID* src, int count)
3447 {
3448     OpStrcat::emit(this, dst, src, count);
3449     return dst;
3450 }
3451 
3452 void BytecodeGenerator::emitToPrimitive(RegisterID* dst, RegisterID* src)
3453 {
3454     OpToPrimitive::emit(this, dst, src);
3455 }
3456 
<a name="93" id="anc93"></a><span class="line-added">3457 RegisterID* BytecodeGenerator::emitToPropertyKey(RegisterID* dst, RegisterID* src)</span>
<span class="line-added">3458 {</span>
<span class="line-added">3459     OpToPropertyKey::emit(this, dst, src);</span>
<span class="line-added">3460     return dst;</span>
<span class="line-added">3461 }</span>
<span class="line-added">3462 </span>
3463 void BytecodeGenerator::emitGetScope()
3464 {
3465     OpGetScope::emit(this, scopeRegister());
3466 }
3467 
3468 RegisterID* BytecodeGenerator::emitPushWithScope(RegisterID* objectScope)
3469 {
3470     pushLocalControlFlowScope();
3471     RegisterID* newScope = newBlockScopeVariable();
3472     newScope-&gt;ref();
3473 
3474     OpPushWithScope::emit(this, newScope, scopeRegister(), objectScope);
3475 
3476     move(scopeRegister(), newScope);
3477     m_lexicalScopeStack.append({ nullptr, newScope, true, 0 });
3478 
3479     return newScope;
3480 }
3481 
3482 RegisterID* BytecodeGenerator::emitGetParentScope(RegisterID* dst, RegisterID* scope)
3483 {
3484     OpGetParentScope::emit(this, dst, scope);
3485     return dst;
3486 }
3487 
<a name="94" id="anc94"></a>





3488 void BytecodeGenerator::emitPopWithScope()
3489 {
<a name="95" id="anc95"></a><span class="line-modified">3490     emitGetParentScope(scopeRegister(), scopeRegister());</span>
3491     popLocalControlFlowScope();
3492     auto stackEntry = m_lexicalScopeStack.takeLast();
3493     stackEntry.m_scope-&gt;deref();
3494     RELEASE_ASSERT(stackEntry.m_isWithScope);
3495 }
3496 
3497 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, const JSTextPosition&amp; divot)
3498 {
3499     if (!shouldEmitDebugHooks())
3500         return;
3501 
3502     emitExpressionInfo(divot, divot, divot);
3503     OpDebug::emit(this, debugHookType, false);
3504 }
3505 
3506 void BytecodeGenerator::emitDebugHook(DebugHookType debugHookType, unsigned line, unsigned charOffset, unsigned lineStart)
3507 {
3508     emitDebugHook(debugHookType, JSTextPosition(line, charOffset, lineStart));
3509 }
3510 
3511 void BytecodeGenerator::emitDebugHook(StatementNode* statement)
3512 {
3513     // DebuggerStatementNode will output its own special debug hook.
3514     if (statement-&gt;isDebuggerStatement())
3515         return;
3516 
3517     emitDebugHook(WillExecuteStatement, statement-&gt;position());
3518 }
3519 
3520 void BytecodeGenerator::emitDebugHook(ExpressionNode* expr)
3521 {
3522     emitDebugHook(WillExecuteStatement, expr-&gt;position());
3523 }
3524 
3525 void BytecodeGenerator::emitWillLeaveCallFrameDebugHook()
3526 {
3527     RELEASE_ASSERT(m_scopeNode-&gt;isFunctionNode());
3528     emitDebugHook(WillLeaveCallFrame, m_scopeNode-&gt;lastLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
3529 }
3530 
3531 void BytecodeGenerator::pushFinallyControlFlowScope(FinallyContext&amp; finallyContext)
3532 {
3533     ControlFlowScope scope(ControlFlowScope::Finally, currentLexicalScopeIndex(), &amp;finallyContext);
3534     m_controlFlowScopeStack.append(WTFMove(scope));
3535 
3536     m_finallyDepth++;
3537     m_currentFinallyContext = &amp;finallyContext;
3538 }
3539 
3540 void BytecodeGenerator::popFinallyControlFlowScope()
3541 {
3542     ASSERT(m_controlFlowScopeStack.size());
3543     ASSERT(m_controlFlowScopeStack.last().isFinallyScope());
3544     ASSERT(m_finallyDepth &gt; 0);
3545     ASSERT(m_currentFinallyContext);
3546     m_currentFinallyContext = m_currentFinallyContext-&gt;outerContext();
3547     m_finallyDepth--;
3548     m_controlFlowScopeStack.removeLast();
3549 }
3550 
3551 LabelScope* BytecodeGenerator::breakTarget(const Identifier&amp; name)
3552 {
3553     shrinkToFit(m_labelScopes);
3554 
3555     if (!m_labelScopes.size())
3556         return nullptr;
3557 
3558     // We special-case the following, which is a syntax error in Firefox:
3559     // label:
3560     //     break;
3561     if (name.isEmpty()) {
3562         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3563             LabelScope&amp; scope = m_labelScopes[i];
3564             if (scope.type() != LabelScope::NamedLabel)
3565                 return &amp;scope;
3566         }
3567         return nullptr;
3568     }
3569 
3570     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3571         LabelScope&amp; scope = m_labelScopes[i];
3572         if (scope.name() &amp;&amp; *scope.name() == name)
3573             return &amp;scope;
3574     }
3575     return nullptr;
3576 }
3577 
3578 LabelScope* BytecodeGenerator::continueTarget(const Identifier&amp; name)
3579 {
3580     shrinkToFit(m_labelScopes);
3581 
3582     if (!m_labelScopes.size())
3583         return nullptr;
3584 
3585     if (name.isEmpty()) {
3586         for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3587             LabelScope&amp; scope = m_labelScopes[i];
3588             if (scope.type() == LabelScope::Loop) {
3589                 ASSERT(scope.continueTarget());
3590                 return &amp;scope;
3591             }
3592         }
3593         return nullptr;
3594     }
3595 
3596     // Continue to the loop nested nearest to the label scope that matches
3597     // &#39;name&#39;.
3598     LabelScope* result = nullptr;
3599     for (int i = m_labelScopes.size() - 1; i &gt;= 0; --i) {
3600         LabelScope&amp; scope = m_labelScopes[i];
3601         if (scope.type() == LabelScope::Loop) {
3602             ASSERT(scope.continueTarget());
3603             result = &amp;scope;
3604         }
3605         if (scope.name() &amp;&amp; *scope.name() == name)
3606             return result; // may be null.
3607     }
3608     return nullptr;
3609 }
3610 
<a name="96" id="anc96"></a>










3611 void BytecodeGenerator::allocateAndEmitScope()
3612 {
3613     m_scopeRegister = addVar();
3614     m_scopeRegister-&gt;ref();
3615     m_codeBlock-&gt;setScopeRegister(scopeRegister()-&gt;virtualRegister());
3616     emitGetScope();
3617     m_topMostScope = addVar();
3618     move(m_topMostScope, scopeRegister());
3619 }
3620 
3621 TryData* BytecodeGenerator::pushTry(Label&amp; start, Label&amp; handlerLabel, HandlerType handlerType)
3622 {
3623     m_tryData.append(TryData { handlerLabel, handlerType });
3624     TryData* result = &amp;m_tryData.last();
3625 
3626     m_tryContextStack.append(TryContext {
3627         start,
3628         result
3629     });
3630 
3631     return result;
3632 }
3633 
3634 void BytecodeGenerator::popTry(TryData* tryData, Label&amp; end)
3635 {
3636     m_usesExceptions = true;
3637 
3638     ASSERT_UNUSED(tryData, m_tryContextStack.last().tryData == tryData);
3639 
3640     m_tryRanges.append(TryRange {
3641         m_tryContextStack.last().start.copyRef(),
3642         end,
3643         m_tryContextStack.last().tryData
3644     });
3645     m_tryContextStack.removeLast();
3646 }
3647 
3648 void BytecodeGenerator::emitOutOfLineCatchHandler(RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)
3649 {
3650     RegisterID* unused = newTemporary();
3651     emitOutOfLineExceptionHandler(unused, thrownValueRegister, completionTypeRegister, data);
3652 }
3653 
3654 void BytecodeGenerator::emitOutOfLineFinallyHandler(RegisterID* exceptionRegister, RegisterID* completionTypeRegister, TryData* data)
3655 {
3656     RegisterID* unused = newTemporary();
3657     ASSERT(completionTypeRegister);
3658     emitOutOfLineExceptionHandler(exceptionRegister, unused, completionTypeRegister, data);
3659 }
3660 
3661 void BytecodeGenerator::emitOutOfLineExceptionHandler(RegisterID* exceptionRegister, RegisterID* thrownValueRegister, RegisterID* completionTypeRegister, TryData* data)
3662 {
3663     VirtualRegister completionTypeVirtualRegister = completionTypeRegister ? completionTypeRegister : VirtualRegister();
3664     m_exceptionHandlersToEmit.append({ data, exceptionRegister, thrownValueRegister, completionTypeVirtualRegister });
3665 }
3666 
3667 void BytecodeGenerator::restoreScopeRegister(int lexicalScopeIndex)
3668 {
3669     if (lexicalScopeIndex == CurrentLexicalScopeIndex)
3670         return; // No change needed.
3671 
3672     if (lexicalScopeIndex != OutermostLexicalScopeIndex) {
3673         ASSERT(lexicalScopeIndex &lt; static_cast&lt;int&gt;(m_lexicalScopeStack.size()));
3674         int endIndex = lexicalScopeIndex + 1;
3675         for (size_t i = endIndex; i--; ) {
3676             if (m_lexicalScopeStack[i].m_scope) {
3677                 move(scopeRegister(), m_lexicalScopeStack[i].m_scope);
3678                 return;
3679             }
3680         }
3681     }
3682     // Note that if we don&#39;t find a local scope in the current function/program,
3683     // we must grab the outer-most scope of this bytecode generation.
3684     move(scopeRegister(), m_topMostScope);
3685 }
3686 
3687 void BytecodeGenerator::restoreScopeRegister()
3688 {
3689     restoreScopeRegister(currentLexicalScopeIndex());
3690 }
3691 
3692 int BytecodeGenerator::labelScopeDepthToLexicalScopeIndex(int targetLabelScopeDepth)
3693 {
3694     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
3695     size_t scopeDelta = labelScopeDepth() - targetLabelScopeDepth;
3696     ASSERT(scopeDelta &lt;= m_controlFlowScopeStack.size());
3697     if (!scopeDelta)
3698         return CurrentLexicalScopeIndex;
3699 
3700     ControlFlowScope&amp; targetScope = m_controlFlowScopeStack[targetLabelScopeDepth];
3701     return targetScope.lexicalScopeIndex;
3702 }
3703 
3704 void BytecodeGenerator::emitThrow(RegisterID* exc)
3705 {
3706     m_usesExceptions = true;
3707     OpThrow::emit(this, exc);
3708 }
3709 
3710 RegisterID* BytecodeGenerator::emitArgumentCount(RegisterID* dst)
3711 {
3712     OpArgumentCount::emit(this, dst);
3713     return dst;
3714 }
3715 
3716 unsigned BytecodeGenerator::localScopeDepth() const
3717 {
3718     return m_localScopeDepth;
3719 }
3720 
3721 int BytecodeGenerator::labelScopeDepth() const
3722 {
3723     unsigned depth = localScopeDepth() + m_finallyDepth;
3724     ASSERT(depth == m_controlFlowScopeStack.size());
3725     return depth;
3726 }
3727 
3728 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, RegisterID* raw)
3729 {
3730     RefPtr&lt;RegisterID&gt; message = newTemporary();
3731     emitToString(message.get(), raw);
3732     OpThrowStaticError::emit(this, message.get(), errorType);
3733 }
3734 
3735 void BytecodeGenerator::emitThrowStaticError(ErrorType errorType, const Identifier&amp; message)
3736 {
3737     OpThrowStaticError::emit(this, addConstantValue(addStringConstant(message)), errorType);
3738 }
3739 
3740 void BytecodeGenerator::emitThrowReferenceError(const String&amp; message)
3741 {
3742     emitThrowStaticError(ErrorType::ReferenceError, Identifier::fromString(m_vm, message));
3743 }
3744 
3745 void BytecodeGenerator::emitThrowTypeError(const String&amp; message)
3746 {
3747     emitThrowStaticError(ErrorType::TypeError, Identifier::fromString(m_vm, message));
3748 }
3749 
3750 void BytecodeGenerator::emitThrowTypeError(const Identifier&amp; message)
3751 {
3752     emitThrowStaticError(ErrorType::TypeError, message);
3753 }
3754 
3755 void BytecodeGenerator::emitThrowRangeError(const Identifier&amp; message)
3756 {
3757     emitThrowStaticError(ErrorType::RangeError, message);
3758 }
3759 
3760 void BytecodeGenerator::emitThrowOutOfMemoryError()
3761 {
3762     emitThrowStaticError(ErrorType::Error, Identifier::fromString(m_vm, &quot;Out of memory&quot;));
3763 }
3764 
3765 void BytecodeGenerator::emitPushFunctionNameScope(const Identifier&amp; property, RegisterID* callee, bool isCaptured)
3766 {
3767     // There is some nuance here:
3768     // If we&#39;re in strict mode code, the function name scope variable acts exactly like a &quot;const&quot; variable.
3769     // If we&#39;re not in strict mode code, we want to allow bogus assignments to the name scoped variable.
3770     // This means any assignment to the variable won&#39;t throw, but it won&#39;t actually assign a new value to it.
3771     // To accomplish this, we don&#39;t report that this scope is a lexical scope. This will prevent
3772     // any throws when trying to assign to the variable (while still ensuring it keeps its original
3773     // value). There is some ugliness and exploitation of a leaky abstraction here, but it&#39;s better than
3774     // having a completely new op code and a class to handle name scopes which are so close in functionality
3775     // to lexical environments.
3776     VariableEnvironment nameScopeEnvironment;
3777     auto addResult = nameScopeEnvironment.add(property);
3778     if (isCaptured)
3779         addResult.iterator-&gt;value.setIsCaptured();
3780     addResult.iterator-&gt;value.setIsConst(); // The function name scope name acts like a const variable.
<a name="97" id="anc97"></a><span class="line-modified">3781     unsigned numVars = m_codeBlock-&gt;numVars();</span>
3782     pushLexicalScopeInternal(nameScopeEnvironment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::NotUnderTDZ, ScopeType::FunctionNameScope, ScopeRegisterType::Var);
<a name="98" id="anc98"></a><span class="line-modified">3783     ASSERT_UNUSED(numVars, m_codeBlock-&gt;numVars() == static_cast&lt;int&gt;(numVars + 1)); // Should have only created one new &quot;var&quot; for the function name scope.</span>
3784     bool shouldTreatAsLexicalVariable = isStrictMode();
3785     Variable functionVar = variableForLocalEntry(property, m_lexicalScopeStack.last().m_symbolTable-&gt;get(NoLockingNecessary, property.impl()), m_lexicalScopeStack.last().m_symbolTableConstantIndex, shouldTreatAsLexicalVariable);
3786     emitPutToScope(m_lexicalScopeStack.last().m_scope, functionVar, callee, ThrowIfNotFound, InitializationMode::NotInitialization);
3787 }
3788 
3789 void BytecodeGenerator::pushLocalControlFlowScope()
3790 {
3791     ControlFlowScope scope(ControlFlowScope::Label, currentLexicalScopeIndex());
3792     m_controlFlowScopeStack.append(WTFMove(scope));
3793     m_localScopeDepth++;
3794 }
3795 
3796 void BytecodeGenerator::popLocalControlFlowScope()
3797 {
3798     ASSERT(m_controlFlowScopeStack.size());
3799     ASSERT(!m_controlFlowScopeStack.last().isFinallyScope());
3800     m_controlFlowScopeStack.removeLast();
3801     m_localScopeDepth--;
3802 }
3803 
3804 void BytecodeGenerator::emitPushCatchScope(VariableEnvironment&amp; environment)
3805 {
3806     pushLexicalScopeInternal(environment, TDZCheckOptimization::Optimize, NestedScopeType::IsNotNested, nullptr, TDZRequirement::UnderTDZ, ScopeType::CatchScope, ScopeRegisterType::Block);
3807 }
3808 
3809 void BytecodeGenerator::emitPopCatchScope(VariableEnvironment&amp; environment)
3810 {
3811     popLexicalScopeInternal(environment);
3812 }
3813 
3814 void BytecodeGenerator::beginSwitch(RegisterID* scrutineeRegister, SwitchInfo::SwitchType type)
3815 {
3816     switch (type) {
3817     case SwitchInfo::SwitchImmediate: {
3818         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3819         m_codeBlock-&gt;addSwitchJumpTable();
3820         OpSwitchImm::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3821         break;
3822     }
3823     case SwitchInfo::SwitchCharacter: {
3824         size_t tableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
3825         m_codeBlock-&gt;addSwitchJumpTable();
3826         OpSwitchChar::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3827         break;
3828     }
3829     case SwitchInfo::SwitchString: {
3830         size_t tableIndex = m_codeBlock-&gt;numberOfStringSwitchJumpTables();
3831         m_codeBlock-&gt;addStringSwitchJumpTable();
3832         OpSwitchString::emit(this, tableIndex, BoundLabel(), scrutineeRegister);
3833         break;
3834     }
3835     default:
3836         RELEASE_ASSERT_NOT_REACHED();
3837     }
3838 
3839     SwitchInfo info = { m_lastInstruction.offset(), type };
3840     m_switchContextStack.append(info);
3841 }
3842 
3843 static int32_t keyForImmediateSwitch(ExpressionNode* node, int32_t min, int32_t max)
3844 {
3845     UNUSED_PARAM(max);
3846     ASSERT(node-&gt;isNumber());
3847     double value = static_cast&lt;NumberNode*&gt;(node)-&gt;value();
3848     int32_t key = static_cast&lt;int32_t&gt;(value);
3849     ASSERT(key == value);
3850     ASSERT(key &gt;= min);
3851     ASSERT(key &lt;= max);
3852     return key - min;
3853 }
3854 
3855 static int32_t keyForCharacterSwitch(ExpressionNode* node, int32_t min, int32_t max)
3856 {
3857     UNUSED_PARAM(max);
3858     ASSERT(node-&gt;isString());
3859     StringImpl* clause = static_cast&lt;StringNode*&gt;(node)-&gt;value().impl();
3860     ASSERT(clause-&gt;length() == 1);
3861 
3862     int32_t key = (*clause)[0];
3863     ASSERT(key &gt;= min);
3864     ASSERT(key &lt;= max);
3865     return key - min;
3866 }
3867 
3868 static void prepareJumpTableForSwitch(
3869     UnlinkedSimpleJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount,
3870     const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, int32_t min, int32_t max,
3871     int32_t (*keyGetter)(ExpressionNode*, int32_t min, int32_t max))
3872 {
3873     jumpTable.min = min;
<a name="99" id="anc99"></a><span class="line-modified">3874     jumpTable.branchOffsets = RefCountedArray&lt;int32_t&gt;(max - min + 1);</span>
<span class="line-modified">3875     std::fill(jumpTable.branchOffsets.begin(), jumpTable.branchOffsets.end(), 0);</span>
3876     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3877         // We&#39;re emitting this after the clause labels should have been fixed, so
3878         // the labels should not be &quot;forward&quot; references
3879         ASSERT(!labels[i]-&gt;isForward());
3880         jumpTable.add(keyGetter(nodes[i], min, max), labels[i]-&gt;bind(switchAddress));
3881     }
3882 }
3883 
3884 static void prepareJumpTableForStringSwitch(UnlinkedStringJumpTable&amp; jumpTable, int32_t switchAddress, uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes)
3885 {
3886     for (uint32_t i = 0; i &lt; clauseCount; ++i) {
3887         // We&#39;re emitting this after the clause labels should have been fixed, so
3888         // the labels should not be &quot;forward&quot; references
3889         ASSERT(!labels[i]-&gt;isForward());
3890 
3891         ASSERT(nodes[i]-&gt;isString());
3892         StringImpl* clause = static_cast&lt;StringNode*&gt;(nodes[i])-&gt;value().impl();
3893         jumpTable.offsetTable.add(clause, UnlinkedStringJumpTable::OffsetLocation { labels[i]-&gt;bind(switchAddress) });
3894     }
3895 }
3896 
3897 void BytecodeGenerator::endSwitch(uint32_t clauseCount, const Vector&lt;Ref&lt;Label&gt;, 8&gt;&amp; labels, ExpressionNode** nodes, Label&amp; defaultLabel, int32_t min, int32_t max)
3898 {
3899     SwitchInfo switchInfo = m_switchContextStack.last();
3900     m_switchContextStack.removeLast();
3901 
3902     BoundLabel defaultTarget = defaultLabel.bind(switchInfo.bytecodeOffset);
3903     auto handleSwitch = [&amp;](auto* op, auto bytecode) {
3904         op-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3905             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3906             return BoundLabel();
3907         });
3908 
3909         UnlinkedSimpleJumpTable&amp; jumpTable = m_codeBlock-&gt;switchJumpTable(bytecode.m_tableIndex);
3910         prepareJumpTableForSwitch(
3911             jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes, min, max,
3912             switchInfo.switchType == SwitchInfo::SwitchImmediate
3913                 ? keyForImmediateSwitch
3914                 : keyForCharacterSwitch);
3915     };
3916 
3917     auto ref = m_writer.ref(switchInfo.bytecodeOffset);
3918     switch (switchInfo.switchType) {
3919     case SwitchInfo::SwitchImmediate: {
3920         handleSwitch(ref-&gt;cast&lt;OpSwitchImm&gt;(), ref-&gt;as&lt;OpSwitchImm&gt;());
3921         break;
3922     }
3923     case SwitchInfo::SwitchCharacter: {
3924         handleSwitch(ref-&gt;cast&lt;OpSwitchChar&gt;(), ref-&gt;as&lt;OpSwitchChar&gt;());
3925         break;
3926     }
3927 
3928     case SwitchInfo::SwitchString: {
3929         ref-&gt;cast&lt;OpSwitchString&gt;()-&gt;setDefaultOffset(defaultTarget, [&amp;]() {
3930             m_codeBlock-&gt;addOutOfLineJumpTarget(switchInfo.bytecodeOffset, defaultTarget);
3931             return BoundLabel();
3932         });
3933 
3934         UnlinkedStringJumpTable&amp; jumpTable = m_codeBlock-&gt;stringSwitchJumpTable(ref-&gt;as&lt;OpSwitchString&gt;().m_tableIndex);
3935         prepareJumpTableForStringSwitch(jumpTable, switchInfo.bytecodeOffset, clauseCount, labels, nodes);
3936         break;
3937     }
3938 
3939     default:
3940         RELEASE_ASSERT_NOT_REACHED();
3941         break;
3942     }
3943 }
3944 
3945 RegisterID* BytecodeGenerator::emitThrowExpressionTooDeepException()
3946 {
3947     // It would be nice to do an even better job of identifying exactly where the expression is.
3948     // And we could make the caller pass the node pointer in, if there was some way of getting
3949     // that from an arbitrary node. However, calling emitExpressionInfo without any useful data
3950     // is still good enough to get us an accurate line number.
3951     m_expressionTooDeep = true;
3952     return newTemporary();
3953 }
3954 
3955 bool BytecodeGenerator::isArgumentNumber(const Identifier&amp; ident, int argumentNumber)
3956 {
3957     RegisterID* registerID = variable(ident).local();
3958     if (!registerID)
3959         return false;
3960     return registerID-&gt;index() == CallFrame::argumentOffset(argumentNumber);
3961 }
3962 
3963 bool BytecodeGenerator::emitReadOnlyExceptionIfNeeded(const Variable&amp; variable)
3964 {
3965     // If we&#39;re in strict mode, we always throw.
3966     // If we&#39;re not in strict mode, we throw for &quot;const&quot; variables but not the function callee.
3967     if (isStrictMode() || variable.isConst()) {
3968         emitThrowTypeError(Identifier::fromString(m_vm, ReadonlyPropertyWriteError));
3969         return true;
3970     }
3971     return false;
3972 }
3973 
3974 void BytecodeGenerator::emitEnumeration(ThrowableExpressionData* node, ExpressionNode* subjectNode, const ScopedLambda&lt;void(BytecodeGenerator&amp;, RegisterID*)&gt;&amp; callBack, ForOfNode* forLoopNode, RegisterID* forLoopSymbolTable)
3975 {
3976     bool isForAwait = forLoopNode ? forLoopNode-&gt;isForAwait() : false;
3977     ASSERT(!isForAwait || (isForAwait &amp;&amp; isAsyncFunctionParseMode(parseMode())));
3978 
3979     RefPtr&lt;RegisterID&gt; subject = newTemporary();
3980     emitNode(subject.get(), subjectNode);
3981     RefPtr&lt;RegisterID&gt; iterator = isForAwait ? emitGetAsyncIterator(subject.get(), node) : emitGetIterator(subject.get(), node);
3982     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
3983 
3984     Ref&lt;Label&gt; loopDone = newLabel();
3985     Ref&lt;Label&gt; tryStartLabel = newLabel();
3986     Ref&lt;Label&gt; finallyViaThrowLabel = newLabel();
3987     Ref&lt;Label&gt; finallyLabel = newLabel();
3988     Ref&lt;Label&gt; catchLabel = newLabel();
3989     Ref&lt;Label&gt; endCatchLabel = newLabel();
3990 
3991     // RefPtr&lt;Register&gt; iterator&#39;s lifetime must be longer than IteratorCloseContext.
3992     FinallyContext finallyContext(*this, finallyLabel.get());
3993     pushFinallyControlFlowScope(finallyContext);
3994 
3995     {
3996         Ref&lt;LabelScope&gt; scope = newLabelScope(LabelScope::Loop);
3997         RefPtr&lt;RegisterID&gt; value = newTemporary();
3998         emitLoad(value.get(), jsUndefined());
3999 
4000         emitJump(*scope-&gt;continueTarget());
4001 
4002         Ref&lt;Label&gt; loopStart = newLabel();
4003         emitLabel(loopStart.get());
4004         emitLoopHint();
4005 
4006         emitLabel(tryStartLabel.get());
4007         TryData* tryData = pushTry(tryStartLabel.get(), finallyViaThrowLabel.get(), HandlerType::SynthesizedFinally);
4008         callBack(*this, value.get());
4009         emitJump(*scope-&gt;continueTarget());
4010 
4011         // IteratorClose sequence for abrupt completions.
4012         {
4013             // Finally block for the enumeration.
4014             emitLabel(finallyViaThrowLabel.get());
4015             popTry(tryData, finallyViaThrowLabel.get());
4016 
4017             Ref&lt;Label&gt; finallyBodyLabel = newLabel();
4018             RefPtr&lt;RegisterID&gt; finallyExceptionRegister = newTemporary();
4019 
4020             emitOutOfLineFinallyHandler(finallyContext.completionValueRegister(), finallyContext.completionTypeRegister(), tryData);
4021             move(finallyExceptionRegister.get(), finallyContext.completionValueRegister());
4022             emitJump(finallyBodyLabel.get());
4023 
4024             emitLabel(finallyLabel.get());
4025             moveEmptyValue(finallyExceptionRegister.get());
4026 
4027             // Finally fall through case.
4028             emitLabel(finallyBodyLabel.get());
4029             restoreScopeRegister();
4030 
4031             Ref&lt;Label&gt; finallyDone = newLabel();
4032 
4033             RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4034             emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), finallyDone.get());
4035 
4036             Ref&lt;Label&gt; returnCallTryStart = newLabel();
4037             emitLabel(returnCallTryStart.get());
4038             TryData* returnCallTryData = pushTry(returnCallTryStart.get(), catchLabel.get(), HandlerType::SynthesizedCatch);
4039 
4040             CallArguments returnArguments(*this, nullptr);
4041             move(returnArguments.thisRegister(), iterator.get());
4042             emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4043 
4044             if (isForAwait)
4045                 emitAwait(value.get());
4046 
4047             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), finallyDone.get());
4048             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4049 
4050             emitLabel(finallyDone.get());
4051             emitFinallyCompletion(finallyContext, endCatchLabel.get());
4052 
4053             popTry(returnCallTryData, finallyDone.get());
4054 
4055             // Catch block for exceptions that may be thrown while calling the return
4056             // handler in the enumeration finally block. The only reason we need this
4057             // catch block is because if entered the above finally block due to a thrown
4058             // exception, then we want to re-throw the original exception on exiting
4059             // the finally block. Otherwise, we&#39;ll let any new exception pass through.
4060             {
4061                 emitLabel(catchLabel.get());
4062 
4063                 RefPtr&lt;RegisterID&gt; exceptionRegister = newTemporary();
4064                 emitOutOfLineFinallyHandler(exceptionRegister.get(), finallyContext.completionTypeRegister(), returnCallTryData);
4065                 // Since this is a synthesized catch block and we&#39;re guaranteed to never need
4066                 // to resolve any symbols from the scope, we can skip restoring the scope
4067                 // register here.
4068 
4069                 Ref&lt;Label&gt; throwLabel = newLabel();
4070                 emitJumpIfTrue(emitIsEmpty(newTemporary(), finallyExceptionRegister.get()), throwLabel.get());
4071                 move(exceptionRegister.get(), finallyExceptionRegister.get());
4072 
4073                 emitLabel(throwLabel.get());
4074                 emitThrow(exceptionRegister.get());
4075 
4076                 emitLabel(endCatchLabel.get());
4077             }
4078         }
4079 
4080         emitLabel(*scope-&gt;continueTarget());
4081         if (forLoopNode) {
4082             RELEASE_ASSERT(forLoopNode-&gt;isForOfNode());
4083             prepareLexicalScopeForNextForLoopIteration(forLoopNode, forLoopSymbolTable);
4084             emitDebugHook(forLoopNode-&gt;lexpr());
4085         }
4086 
4087         {
4088             emitIteratorNext(value.get(), nextMethod.get(), iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4089 
4090             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4091             emitGetById(value.get(), value.get(), propertyNames().value);
4092             emitJump(loopStart.get());
4093         }
4094 
4095         bool breakLabelIsBound = scope-&gt;breakTargetMayBeBound();
4096         if (breakLabelIsBound)
4097             emitLabel(scope-&gt;breakTarget());
4098         popFinallyControlFlowScope();
4099         if (breakLabelIsBound) {
4100             // IteratorClose sequence for break-ed control flow.
4101             emitIteratorClose(iterator.get(), node, isForAwait ? EmitAwait::Yes : EmitAwait::No);
4102         }
4103     }
4104     emitLabel(loopDone.get());
4105 }
4106 
4107 RegisterID* BytecodeGenerator::emitGetTemplateObject(RegisterID* dst, TaggedTemplateNode* taggedTemplate)
4108 {
4109     TemplateObjectDescriptor::StringVector rawStrings;
4110     TemplateObjectDescriptor::OptionalStringVector cookedStrings;
4111 
4112     TemplateStringListNode* templateString = taggedTemplate-&gt;templateLiteral()-&gt;templateStrings();
4113     for (; templateString; templateString = templateString-&gt;next()) {
4114         auto* string = templateString-&gt;value();
4115         ASSERT(string-&gt;raw());
4116         rawStrings.append(string-&gt;raw()-&gt;impl());
4117         if (!string-&gt;cooked())
4118             cookedStrings.append(WTF::nullopt);
4119         else
4120             cookedStrings.append(string-&gt;cooked()-&gt;impl());
4121     }
4122     RefPtr&lt;RegisterID&gt; constant = addTemplateObjectConstant(TemplateObjectDescriptor::create(WTFMove(rawStrings), WTFMove(cookedStrings)), taggedTemplate-&gt;endOffset());
4123     if (!dst)
4124         return constant.get();
4125     return move(dst, constant.get());
4126 }
4127 
4128 RegisterID* BytecodeGenerator::emitGetGlobalPrivate(RegisterID* dst, const Identifier&amp; property)
4129 {
4130     dst = tempDestination(dst);
4131     Variable var = variable(property);
4132     if (RegisterID* local = var.local())
4133         return move(dst, local);
4134 
4135     RefPtr&lt;RegisterID&gt; scope = newTemporary();
4136     move(scope.get(), emitResolveScope(scope.get(), var));
4137     return emitGetFromScope(dst, scope.get(), var, ThrowIfNotFound);
4138 }
4139 
4140 RegisterID* BytecodeGenerator::emitGetEnumerableLength(RegisterID* dst, RegisterID* base)
4141 {
4142     OpGetEnumerableLength::emit(this, dst, base);
4143     return dst;
4144 }
4145 
4146 RegisterID* BytecodeGenerator::emitHasGenericProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4147 {
4148     OpHasGenericProperty::emit(this, dst, base, propertyName);
4149     return dst;
4150 }
4151 
4152 RegisterID* BytecodeGenerator::emitHasIndexedProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName)
4153 {
4154     OpHasIndexedProperty::emit(this, dst, base, propertyName);
4155     return dst;
4156 }
4157 
4158 RegisterID* BytecodeGenerator::emitHasStructureProperty(RegisterID* dst, RegisterID* base, RegisterID* propertyName, RegisterID* enumerator)
4159 {
4160     OpHasStructureProperty::emit(this, dst, base, propertyName, enumerator);
4161     return dst;
4162 }
4163 
4164 RegisterID* BytecodeGenerator::emitGetPropertyEnumerator(RegisterID* dst, RegisterID* base)
4165 {
4166     OpGetPropertyEnumerator::emit(this, dst, base);
4167     return dst;
4168 }
4169 
4170 RegisterID* BytecodeGenerator::emitEnumeratorStructurePropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4171 {
4172     OpEnumeratorStructurePname::emit(this, dst, enumerator, index);
4173     return dst;
4174 }
4175 
4176 RegisterID* BytecodeGenerator::emitEnumeratorGenericPropertyName(RegisterID* dst, RegisterID* enumerator, RegisterID* index)
4177 {
4178     OpEnumeratorGenericPname::emit(this, dst, enumerator, index);
4179     return dst;
4180 }
4181 
4182 RegisterID* BytecodeGenerator::emitToIndexString(RegisterID* dst, RegisterID* index)
4183 {
4184     OpToIndexString::emit(this, dst, index);
4185     return dst;
4186 }
4187 
4188 RegisterID* BytecodeGenerator::emitIsCellWithType(RegisterID* dst, RegisterID* src, JSType type)
4189 {
4190     OpIsCellWithType::emit(this, dst, src, type);
4191     return dst;
4192 }
4193 
4194 RegisterID* BytecodeGenerator::emitIsObject(RegisterID* dst, RegisterID* src)
4195 {
4196     OpIsObject::emit(this, dst, src);
4197     return dst;
4198 }
4199 
4200 RegisterID* BytecodeGenerator::emitIsNumber(RegisterID* dst, RegisterID* src)
4201 {
4202     OpIsNumber::emit(this, dst, src);
4203     return dst;
4204 }
4205 
4206 RegisterID* BytecodeGenerator::emitIsUndefined(RegisterID* dst, RegisterID* src)
4207 {
4208     OpIsUndefined::emit(this, dst, src);
4209     return dst;
4210 }
4211 
4212 RegisterID* BytecodeGenerator::emitIsUndefinedOrNull(RegisterID* dst, RegisterID* src)
4213 {
4214     OpIsUndefinedOrNull::emit(this, dst, src);
4215     return dst;
4216 }
4217 
4218 RegisterID* BytecodeGenerator::emitIsEmpty(RegisterID* dst, RegisterID* src)
4219 {
4220     OpIsEmpty::emit(this, dst, src);
4221     return dst;
4222 }
4223 
4224 RegisterID* BytecodeGenerator::emitIteratorNext(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4225 {
4226     {
4227         CallArguments nextArguments(*this, nullptr);
4228         move(nextArguments.thisRegister(), iterator);
4229         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4230 
4231         if (doEmitAwait == EmitAwait::Yes)
4232             emitAwait(dst);
4233     }
4234     {
4235         Ref&lt;Label&gt; typeIsObject = newLabel();
4236         emitJumpIfTrue(emitIsObject(newTemporary(), dst), typeIsObject.get());
4237         emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4238         emitLabel(typeIsObject.get());
4239     }
4240     return dst;
4241 }
4242 
4243 RegisterID* BytecodeGenerator::emitIteratorNextWithValue(RegisterID* dst, RegisterID* nextMethod, RegisterID* iterator, RegisterID* value, const ThrowableExpressionData* node)
4244 {
4245     {
4246         CallArguments nextArguments(*this, nullptr, 1);
4247         move(nextArguments.thisRegister(), iterator);
4248         move(nextArguments.argumentRegister(0), value);
4249         emitCall(dst, nextMethod, NoExpectedFunction, nextArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4250     }
4251 
4252     return dst;
4253 }
4254 
4255 void BytecodeGenerator::emitIteratorClose(RegisterID* iterator, const ThrowableExpressionData* node, EmitAwait doEmitAwait)
4256 {
4257     Ref&lt;Label&gt; done = newLabel();
4258     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator, propertyNames().returnKeyword);
4259     emitJumpIfTrue(emitIsUndefined(newTemporary(), returnMethod.get()), done.get());
4260 
4261     RefPtr&lt;RegisterID&gt; value = newTemporary();
4262     CallArguments returnArguments(*this, nullptr);
4263     move(returnArguments.thisRegister(), iterator);
4264     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4265 
4266     if (doEmitAwait == EmitAwait::Yes)
4267         emitAwait(value.get());
4268 
4269     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), done.get());
4270     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4271     emitLabel(done.get());
4272 }
4273 
4274 void BytecodeGenerator::pushIndexedForInScope(RegisterID* localRegister, RegisterID* indexRegister)
4275 {
4276     if (!localRegister)
4277         return;
4278     unsigned bodyBytecodeStartOffset = instructions().size();
4279     m_forInContextStack.append(adoptRef(*new IndexedForInContext(localRegister, indexRegister, bodyBytecodeStartOffset)));
4280 }
4281 
4282 void BytecodeGenerator::popIndexedForInScope(RegisterID* localRegister)
4283 {
4284     if (!localRegister)
4285         return;
4286     unsigned bodyBytecodeEndOffset = instructions().size();
4287     m_forInContextStack.last()-&gt;asIndexedForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4288     m_forInContextStack.removeLast();
4289 }
4290 
4291 RegisterID* BytecodeGenerator::emitLoadArrowFunctionLexicalEnvironment(const Identifier&amp; identifier)
4292 {
<a name="100" id="anc100"></a><span class="line-modified">4293     ASSERT(m_codeBlock-&gt;isArrowFunction() || m_codeBlock-&gt;isArrowFunctionContext() || constructorKind() == ConstructorKind::Extends || m_codeType == EvalCode || m_codeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode);</span>
4294 
4295     return emitResolveScope(nullptr, variable(identifier, ThisResolutionType::Scoped));
4296 }
4297 
4298 void BytecodeGenerator::emitLoadThisFromArrowFunctionLexicalEnvironment()
4299 {
4300     emitGetFromScope(thisRegister(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier), variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped), DoNotThrowIfNotFound);
4301 }
4302 
4303 RegisterID* BytecodeGenerator::emitLoadNewTargetFromArrowFunctionLexicalEnvironment()
4304 {
4305     Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4306 
4307     return emitGetFromScope(m_newTargetRegister, emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().newTargetLocalPrivateName()), newTargetVar, ThrowIfNotFound);
4308 
4309 }
4310 
4311 RegisterID* BytecodeGenerator::emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment()
4312 {
4313     Variable protoScopeVar = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4314     return emitGetFromScope(newTemporary(), emitLoadArrowFunctionLexicalEnvironment(propertyNames().builtinNames().derivedConstructorPrivateName()), protoScopeVar, ThrowIfNotFound);
4315 }
4316 
<a name="101" id="anc101"></a><span class="line-added">4317 RegisterID* BytecodeGenerator::emitLoadDerivedConstructor()</span>
<span class="line-added">4318 {</span>
<span class="line-added">4319     ASSERT(constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext());</span>
<span class="line-added">4320     if (constructorKind() == ConstructorKind::Extends)</span>
<span class="line-added">4321         return &amp;m_calleeRegister;</span>
<span class="line-added">4322     return emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();</span>
<span class="line-added">4323 }</span>
<span class="line-added">4324 </span>
4325 RegisterID* BytecodeGenerator::ensureThis()
4326 {
4327     if (constructorKind() == ConstructorKind::Extends || isDerivedConstructorContext()) {
4328         if ((needsToUpdateArrowFunctionContext() &amp;&amp; isSuperCallUsedInInnerArrowFunction()) || m_codeBlock-&gt;parseMode() == SourceParseMode::AsyncArrowFunctionBodyMode)
4329             emitLoadThisFromArrowFunctionLexicalEnvironment();
4330 
4331         emitTDZCheck(thisRegister());
4332     }
4333 
4334     return thisRegister();
4335 }
4336 
4337 bool BytecodeGenerator::isThisUsedInInnerArrowFunction()
4338 {
4339     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseThis() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4340 }
4341 
4342 bool BytecodeGenerator::isArgumentsUsedInInnerArrowFunction()
4343 {
4344     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseArguments() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval();
4345 }
4346 
4347 bool BytecodeGenerator::isNewTargetUsedInInnerArrowFunction()
4348 {
4349     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseNewTarget() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4350 }
4351 
4352 bool BytecodeGenerator::isSuperUsedInInnerArrowFunction()
4353 {
4354     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperProperty() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4355 }
4356 
4357 bool BytecodeGenerator::isSuperCallUsedInInnerArrowFunction()
4358 {
4359     return m_scopeNode-&gt;doAnyInnerArrowFunctionsUseSuperCall() || m_scopeNode-&gt;doAnyInnerArrowFunctionsUseEval() || m_codeBlock-&gt;usesEval();
4360 }
4361 
4362 void BytecodeGenerator::emitPutNewTargetToArrowFunctionContextScope()
4363 {
4364     if (isNewTargetUsedInInnerArrowFunction()) {
4365         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4366 
4367         Variable newTargetVar = variable(propertyNames().builtinNames().newTargetLocalPrivateName());
4368         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, newTargetVar, newTarget(), DoNotThrowIfNotFound, InitializationMode::Initialization);
4369     }
4370 }
4371 
4372 void BytecodeGenerator::emitPutDerivedConstructorToArrowFunctionContextScope()
4373 {
4374     if (needsDerivedConstructorInArrowFunctionLexicalEnvironment()) {
4375         ASSERT(m_arrowFunctionContextLexicalEnvironmentRegister);
4376 
4377         Variable protoScope = variable(propertyNames().builtinNames().derivedConstructorPrivateName());
4378         emitPutToScope(m_arrowFunctionContextLexicalEnvironmentRegister, protoScope, &amp;m_calleeRegister, DoNotThrowIfNotFound, InitializationMode::Initialization);
4379     }
4380 }
4381 
4382 void BytecodeGenerator::emitPutThisToArrowFunctionContextScope()
4383 {
4384     if (isThisUsedInInnerArrowFunction() || (m_scopeNode-&gt;usesSuperCall() &amp;&amp; m_codeType == EvalCode)) {
4385         ASSERT(isDerivedConstructorContext() || m_arrowFunctionContextLexicalEnvironmentRegister != nullptr);
4386 
4387         Variable thisVar = variable(propertyNames().thisIdentifier, ThisResolutionType::Scoped);
4388         RegisterID* scope = isDerivedConstructorContext() ? emitLoadArrowFunctionLexicalEnvironment(propertyNames().thisIdentifier) : m_arrowFunctionContextLexicalEnvironmentRegister;
4389 
4390         emitPutToScope(scope, thisVar, thisRegister(), ThrowIfNotFound, InitializationMode::NotInitialization);
4391     }
4392 }
4393 
4394 void BytecodeGenerator::pushStructureForInScope(RegisterID* localRegister, RegisterID* indexRegister, RegisterID* propertyRegister, RegisterID* enumeratorRegister)
4395 {
4396     if (!localRegister)
4397         return;
4398     unsigned bodyBytecodeStartOffset = instructions().size();
4399     m_forInContextStack.append(adoptRef(*new StructureForInContext(localRegister, indexRegister, propertyRegister, enumeratorRegister, bodyBytecodeStartOffset)));
4400 }
4401 
4402 void BytecodeGenerator::popStructureForInScope(RegisterID* localRegister)
4403 {
4404     if (!localRegister)
4405         return;
4406     unsigned bodyBytecodeEndOffset = instructions().size();
4407     m_forInContextStack.last()-&gt;asStructureForInContext().finalize(*this, m_codeBlock.get(), bodyBytecodeEndOffset);
4408     m_forInContextStack.removeLast();
4409 }
4410 
4411 RegisterID* BytecodeGenerator::emitRestParameter(RegisterID* result, unsigned numParametersToSkip)
4412 {
4413     RefPtr&lt;RegisterID&gt; restArrayLength = newTemporary();
4414     OpGetRestLength::emit(this, restArrayLength.get(), numParametersToSkip);
4415 
4416     OpCreateRest::emit(this, result, restArrayLength.get(), numParametersToSkip);
4417 
4418     return result;
4419 }
4420 
4421 void BytecodeGenerator::emitRequireObjectCoercible(RegisterID* value, const String&amp; error)
4422 {
4423     Ref&lt;Label&gt; target = newLabel();
4424     OpJnundefinedOrNull::emit(this, value, target-&gt;bind(this));
4425     emitThrowTypeError(error);
4426     emitLabel(target.get());
4427 }
4428 
<a name="102" id="anc102"></a><span class="line-modified">4429 void BytecodeGenerator::emitYieldPoint(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
4430 {
4431     Ref&lt;Label&gt; mergePoint = newLabel();
4432     unsigned yieldPointIndex = m_yieldPoints++;
4433     emitGeneratorStateChange(yieldPointIndex + 1);
4434 
4435     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode) {
4436         int suspendReason = static_cast&lt;int32_t&gt;(result);
<a name="103" id="anc103"></a><span class="line-modified">4437         emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::SuspendReason), emitLoad(nullptr, jsNumber(suspendReason)));</span>
4438     }
4439 
4440     // Split the try range here.
4441     Ref&lt;Label&gt; savePoint = newEmittedLabel();
4442     for (unsigned i = m_tryContextStack.size(); i--;) {
4443         TryContext&amp; context = m_tryContextStack[i];
4444         m_tryRanges.append(TryRange {
4445             context.start.copyRef(),
4446             savePoint.copyRef(),
4447             context.tryData
4448         });
4449         // Try range will be restared at the merge point.
4450         context.start = mergePoint.get();
4451     }
4452     Vector&lt;TryContext&gt; savedTryContextStack;
4453     m_tryContextStack.swap(savedTryContextStack);
4454 
4455 
4456 #if CPU(NEEDS_ALIGNED_ACCESS)
4457     // conservatively align for the bytecode rewriter: it will delete this yield and
4458     // append a fragment, so we make sure that the start of the fragments is aligned
4459     while (m_writer.position() % OpcodeSize::Wide32)
4460         OpNop::emit&lt;OpcodeSize::Narrow&gt;(this);
4461 #endif
4462     OpYield::emit(this, generatorFrameRegister(), yieldPointIndex, argument);
4463 
4464     // Restore the try contexts, which start offset is updated to the merge point.
4465     m_tryContextStack.swap(savedTryContextStack);
4466     emitLabel(mergePoint.get());
4467 }
4468 
<a name="104" id="anc104"></a><span class="line-modified">4469 RegisterID* BytecodeGenerator::emitYield(RegisterID* argument, JSAsyncGenerator::AsyncGeneratorSuspendReason result)</span>
4470 {
4471     emitYieldPoint(argument, result);
4472 
4473     Ref&lt;Label&gt; normalLabel = newLabel();
4474     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<a name="105" id="anc105"></a><span class="line-modified">4475     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4476     emitJumpIfTrue(condition.get(), normalLabel.get());
4477 
4478     Ref&lt;Label&gt; throwLabel = newLabel();
<a name="106" id="anc106"></a><span class="line-modified">4479     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
4480     emitJumpIfTrue(condition.get(), throwLabel.get());
4481     // Return.
4482     {
4483         RefPtr&lt;RegisterID&gt; returnRegister = generatorValueRegister();
4484         bool hasFinally = emitReturnViaFinallyIfNeeded(returnRegister.get());
4485         if (!hasFinally)
4486             emitReturn(returnRegister.get());
4487     }
4488 
4489     // Throw.
4490     emitLabel(throwLabel.get());
4491     emitThrow(generatorValueRegister());
4492 
4493     // Normal.
4494     emitLabel(normalLabel.get());
4495     return generatorValueRegister();
4496 }
4497 
4498 RegisterID* BytecodeGenerator::emitCallIterator(RegisterID* iterator, RegisterID* argument, ThrowableExpressionData* node)
4499 {
4500     CallArguments args(*this, nullptr);
4501     move(args.thisRegister(), argument);
4502     emitCall(iterator, iterator, NoExpectedFunction, args, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4503 
4504     return iterator;
4505 }
4506 
4507 void BytecodeGenerator::emitAwait(RegisterID* value)
4508 {
<a name="107" id="anc107"></a><span class="line-modified">4509     emitYield(value, JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
4510     move(value, generatorValueRegister());
4511 }
4512 
4513 RegisterID* BytecodeGenerator::emitGetIterator(RegisterID* argument, ThrowableExpressionData* node)
4514 {
4515     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().iteratorSymbol);
4516     emitCallIterator(iterator.get(), argument, node);
4517 
4518     return iterator.get();
4519 }
4520 
4521 RegisterID* BytecodeGenerator::emitGetAsyncIterator(RegisterID* argument, ThrowableExpressionData* node)
4522 {
4523     RefPtr&lt;RegisterID&gt; iterator = emitGetById(newTemporary(), argument, propertyNames().asyncIteratorSymbol);
4524     Ref&lt;Label&gt; asyncIteratorNotFound = newLabel();
4525     Ref&lt;Label&gt; asyncIteratorFound = newLabel();
4526     Ref&lt;Label&gt; iteratorReceived = newLabel();
4527 
4528     emitJumpIfTrue(emitUnaryOp&lt;OpEqNull&gt;(newTemporary(), iterator.get()), asyncIteratorNotFound.get());
4529 
4530     emitJump(asyncIteratorFound.get());
4531     emitLabel(asyncIteratorNotFound.get());
4532 
4533     RefPtr&lt;RegisterID&gt; commonIterator = emitGetIterator(argument, node);
4534     move(iterator.get(), commonIterator.get());
4535 
4536     RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4537 
<a name="108" id="anc108"></a><span class="line-modified">4538     RefPtr&lt;RegisterID&gt; createAsyncFromSyncIterator = moveLinkTimeConstant(nullptr, LinkTimeConstant::createAsyncFromSyncIterator);</span>



4539 
4540     CallArguments args(*this, nullptr, 2);
4541     emitLoad(args.thisRegister(), jsUndefined());
4542 
4543     move(args.argumentRegister(0), iterator.get());
4544     move(args.argumentRegister(1), nextMethod.get());
4545 
4546     JSTextPosition divot(m_scopeNode-&gt;firstLine(), m_scopeNode-&gt;startOffset(), m_scopeNode-&gt;lineStartOffset());
4547     emitCall(iterator.get(), createAsyncFromSyncIterator.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
4548 
4549     emitJump(iteratorReceived.get());
4550 
4551     emitLabel(asyncIteratorFound.get());
4552     emitCallIterator(iterator.get(), argument, node);
4553     emitLabel(iteratorReceived.get());
4554 
4555     return iterator.get();
4556 }
4557 
4558 RegisterID* BytecodeGenerator::emitDelegateYield(RegisterID* argument, ThrowableExpressionData* node)
4559 {
4560     RefPtr&lt;RegisterID&gt; value = newTemporary();
4561     {
4562         RefPtr&lt;RegisterID&gt; iterator = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? emitGetAsyncIterator(argument, node) : emitGetIterator(argument, node);
4563         RefPtr&lt;RegisterID&gt; nextMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().next);
4564 
4565         Ref&lt;Label&gt; loopDone = newLabel();
4566         {
4567             Ref&lt;Label&gt; nextElement = newLabel();
4568             emitLoad(value.get(), jsUndefined());
4569 
4570             emitJump(nextElement.get());
4571 
4572             Ref&lt;Label&gt; loopStart = newLabel();
4573             emitLabel(loopStart.get());
4574             emitLoopHint();
4575 
4576             Ref&lt;Label&gt; branchOnResult = newLabel();
4577             {
<a name="109" id="anc109"></a><span class="line-modified">4578                 emitYieldPoint(value.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
4579 
4580                 Ref&lt;Label&gt; normalLabel = newLabel();
4581                 Ref&lt;Label&gt; returnLabel = newLabel();
4582                 {
4583                     RefPtr&lt;RegisterID&gt; condition = newTemporary();
<a name="110" id="anc110"></a><span class="line-modified">4584                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
4585                     emitJumpIfTrue(condition.get(), normalLabel.get());
4586 
<a name="111" id="anc111"></a><span class="line-modified">4587                     emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generatorResumeModeRegister(), emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ReturnMode))));</span>
4588                     emitJumpIfTrue(condition.get(), returnLabel.get());
4589 
4590                     // Fallthrough to ThrowMode.
4591                 }
4592 
4593                 // Throw.
4594                 {
4595                     Ref&lt;Label&gt; throwMethodFound = newLabel();
4596                     RefPtr&lt;RegisterID&gt; throwMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().throwKeyword);
4597                     emitJumpIfFalse(emitIsUndefined(newTemporary(), throwMethod.get()), throwMethodFound.get());
4598 
4599                     EmitAwait emitAwaitInIteratorClose = parseMode() == SourceParseMode::AsyncGeneratorBodyMode ? EmitAwait::Yes : EmitAwait::No;
4600                     emitIteratorClose(iterator.get(), node, emitAwaitInIteratorClose);
4601 
4602                     emitThrowTypeError(&quot;Delegated generator does not have a &#39;throw&#39; method.&quot;_s);
4603 
4604                     emitLabel(throwMethodFound.get());
4605                     CallArguments throwArguments(*this, nullptr, 1);
4606                     move(throwArguments.thisRegister(), iterator.get());
4607                     move(throwArguments.argumentRegister(0), generatorValueRegister());
4608                     emitCall(value.get(), throwMethod.get(), NoExpectedFunction, throwArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4609 
4610                     emitJump(branchOnResult.get());
4611                 }
4612 
4613                 // Return.
4614                 emitLabel(returnLabel.get());
4615                 {
4616                     Ref&lt;Label&gt; returnMethodFound = newLabel();
4617                     RefPtr&lt;RegisterID&gt; returnMethod = emitGetById(newTemporary(), iterator.get(), propertyNames().returnKeyword);
4618                     emitJumpIfFalse(emitIsUndefined(newTemporary(), returnMethod.get()), returnMethodFound.get());
4619 
4620                     move(value.get(), generatorValueRegister());
4621 
4622                     Ref&lt;Label&gt; returnSequence = newLabel();
4623                     emitJump(returnSequence.get());
4624 
4625                     emitLabel(returnMethodFound.get());
4626                     CallArguments returnArguments(*this, nullptr, 1);
4627                     move(returnArguments.thisRegister(), iterator.get());
4628                     move(returnArguments.argumentRegister(0), generatorValueRegister());
4629                     emitCall(value.get(), returnMethod.get(), NoExpectedFunction, returnArguments, node-&gt;divot(), node-&gt;divotStart(), node-&gt;divotEnd(), DebuggableCall::No);
4630 
4631                     if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4632                         emitAwait(value.get());
4633 
4634                     Ref&lt;Label&gt; returnIteratorResultIsObject = newLabel();
4635                     emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), returnIteratorResultIsObject.get());
4636                     emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4637 
4638                     emitLabel(returnIteratorResultIsObject.get());
4639 
4640                     Ref&lt;Label&gt; returnFromGenerator = newLabel();
4641                     emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), returnFromGenerator.get());
4642 
4643                     emitGetById(value.get(), value.get(), propertyNames().value);
4644                     emitJump(loopStart.get());
4645 
4646                     emitLabel(returnFromGenerator.get());
4647                     emitGetById(value.get(), value.get(), propertyNames().value);
4648 
4649                     emitLabel(returnSequence.get());
4650                     bool hasFinally = emitReturnViaFinallyIfNeeded(value.get());
4651                     if (!hasFinally)
4652                         emitReturn(value.get());
4653                 }
4654 
4655                 // Normal.
4656                 emitLabel(normalLabel.get());
4657                 move(value.get(), generatorValueRegister());
4658             }
4659 
4660             emitLabel(nextElement.get());
4661             emitIteratorNextWithValue(value.get(), nextMethod.get(), iterator.get(), value.get(), node);
4662 
4663             emitLabel(branchOnResult.get());
4664 
4665             if (parseMode() == SourceParseMode::AsyncGeneratorBodyMode)
4666                 emitAwait(value.get());
4667 
4668             Ref&lt;Label&gt; iteratorValueIsObject = newLabel();
4669             emitJumpIfTrue(emitIsObject(newTemporary(), value.get()), iteratorValueIsObject.get());
4670             emitThrowTypeError(&quot;Iterator result interface is not an object.&quot;_s);
4671             emitLabel(iteratorValueIsObject.get());
4672 
4673             emitJumpIfTrue(emitGetById(newTemporary(), value.get(), propertyNames().done), loopDone.get());
4674             emitGetById(value.get(), value.get(), propertyNames().value);
4675 
4676             emitJump(loopStart.get());
4677         }
4678         emitLabel(loopDone.get());
4679     }
4680 
4681     emitGetById(value.get(), value.get(), propertyNames().value);
4682     return value.get();
4683 }
4684 
4685 
4686 void BytecodeGenerator::emitGeneratorStateChange(int32_t state)
4687 {
4688     RegisterID* completedState = emitLoad(nullptr, jsNumber(state));
<a name="112" id="anc112"></a><span class="line-modified">4689     static_assert(static_cast&lt;unsigned&gt;(JSGenerator::Field::State) == static_cast&lt;unsigned&gt;(JSAsyncGenerator::Field::State));</span>
<span class="line-added">4690     emitPutInternalField(generatorRegister(), static_cast&lt;unsigned&gt;(JSGenerator::Field::State), completedState);</span>
4691 }
4692 
4693 bool BytecodeGenerator::emitJumpViaFinallyIfNeeded(int targetLabelScopeDepth, Label&amp; jumpTarget)
4694 {
4695     ASSERT(labelScopeDepth() - targetLabelScopeDepth &gt;= 0);
4696     size_t numberOfScopesToCheckForFinally = labelScopeDepth() - targetLabelScopeDepth;
4697     ASSERT(numberOfScopesToCheckForFinally &lt;= m_controlFlowScopeStack.size());
4698     if (!numberOfScopesToCheckForFinally)
4699         return false;
4700 
4701     FinallyContext* innermostFinallyContext = nullptr;
4702     FinallyContext* outermostFinallyContext = nullptr;
4703     size_t scopeIndex = m_controlFlowScopeStack.size() - 1;
4704     while (numberOfScopesToCheckForFinally--) {
4705         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex--];
4706         if (scope-&gt;isFinallyScope()) {
4707             FinallyContext* finallyContext = scope-&gt;finallyContext;
4708             if (!innermostFinallyContext)
4709                 innermostFinallyContext = finallyContext;
4710             outermostFinallyContext = finallyContext;
4711             finallyContext-&gt;incNumberOfBreaksOrContinues();
4712         }
4713     }
4714     if (!outermostFinallyContext)
4715         return false; // No finallys to thread through.
4716 
4717     auto jumpID = bytecodeOffsetToJumpID(instructions().size());
4718     int lexicalScopeIndex = labelScopeDepthToLexicalScopeIndex(targetLabelScopeDepth);
4719     outermostFinallyContext-&gt;registerJump(jumpID, lexicalScopeIndex, jumpTarget);
4720 
4721     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), jumpID);
4722     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4723     return true; // We&#39;ll be jumping to a finally block.
4724 }
4725 
4726 bool BytecodeGenerator::emitReturnViaFinallyIfNeeded(RegisterID* returnRegister)
4727 {
4728     size_t numberOfScopesToCheckForFinally = m_controlFlowScopeStack.size();
4729     if (!numberOfScopesToCheckForFinally)
4730         return false;
4731 
4732     FinallyContext* innermostFinallyContext = nullptr;
4733     while (numberOfScopesToCheckForFinally) {
4734         size_t scopeIndex = --numberOfScopesToCheckForFinally;
4735         ControlFlowScope* scope = &amp;m_controlFlowScopeStack[scopeIndex];
4736         if (scope-&gt;isFinallyScope()) {
4737             FinallyContext* finallyContext = scope-&gt;finallyContext;
4738             if (!innermostFinallyContext)
4739                 innermostFinallyContext = finallyContext;
4740             finallyContext-&gt;setHandlesReturns();
4741         }
4742     }
4743     if (!innermostFinallyContext)
4744         return false; // No finallys to thread through.
4745 
4746     emitLoad(innermostFinallyContext-&gt;completionTypeRegister(), CompletionType::Return);
4747     move(innermostFinallyContext-&gt;completionValueRegister(), returnRegister);
4748     emitJump(*innermostFinallyContext-&gt;finallyLabel());
4749     return true; // We&#39;ll be jumping to a finally block.
4750 }
4751 
4752 void BytecodeGenerator::emitFinallyCompletion(FinallyContext&amp; context, Label&amp; normalCompletionLabel)
4753 {
4754     if (context.numberOfBreaksOrContinues() || context.handlesReturns()) {
4755         emitJumpIf&lt;OpStricteq&gt;(context.completionTypeRegister(), CompletionType::Normal, normalCompletionLabel);
4756 
4757         FinallyContext* outerContext = context.outerContext();
4758 
4759         size_t numberOfJumps = context.numberOfJumps();
4760         ASSERT(outerContext || numberOfJumps == context.numberOfBreaksOrContinues());
4761 
4762         // Handle Break or Continue completions that jumps into this FinallyContext.
4763         for (size_t i = 0; i &lt; numberOfJumps; i++) {
4764             Ref&lt;Label&gt; nextLabel = newLabel();
4765             auto&amp; jump = context.jumps(i);
4766             emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), jump.jumpID, nextLabel.get());
4767 
4768             // This case is for Break / Continue completions from an inner finally context
4769             // with a jump target that is not beyond the next outer finally context:
4770             //
4771             //     try {
4772             //         for (... stuff ...) {
4773             //             try {
4774             //                 continue; // Sets completionType to jumpID of top of the for loop.
4775             //             } finally {
4776             //             } // Jump to top of the for loop on completion.
4777             //         }
4778             //     } finally {
4779             //     }
4780             //
4781             // Since the jumpID is targetting a label that is inside the outer finally context,
4782             // we can jump to it directly on completion of this finally context: there is no intermediate
4783             // finally blocks to run. After the Break / Continue, we will contnue execution as normal.
4784             // So, we&#39;ll set the completionType to Normal (on behalf of the target) before we jump.
4785             // We can also set the completion value to undefined, but it will never be used for normal
4786             // completion anyway. So, we&#39;ll skip setting it.
4787 
4788             restoreScopeRegister(jump.targetLexicalScopeIndex);
4789             emitLoad(context.completionTypeRegister(), CompletionType::Normal);
4790             emitJump(jump.targetLabel.get());
4791 
4792             emitLabel(nextLabel.get());
4793         }
4794 
4795         // Handle completions that take us out of this FinallyContext.
4796         if (outerContext) {
4797             if (context.handlesReturns()) {
4798                 Ref&lt;Label&gt; isNotReturnLabel = newLabel();
4799                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, isNotReturnLabel.get());
4800 
4801                 // This case is for Return completion from an inner finally context:
4802                 //
4803                 //     try {
4804                 //         try {
4805                 //             return result; // Sets completionType to Return, and completionValue to result.
4806                 //         } finally {
4807                 //         } // Jump to outer finally on completion.
4808                 //     } finally {
4809                 //     }
4810                 //
4811                 // Since we know there&#39;s at least one outer finally context (beyond the current context),
4812                 // we cannot actually return from here. Instead, we pass the completionType and completionValue
4813                 // on to the next outer finally, and let it decide what to do next on its completion. The
4814                 // outer finally may or may not actual return depending on whether it encounters an abrupt
4815                 // completion in its body that overrrides this Return completion.
4816 
4817                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());
4818                 move(outerContext-&gt;completionValueRegister(), context.completionValueRegister());
4819                 emitJump(*outerContext-&gt;finallyLabel());
4820 
4821                 emitLabel(isNotReturnLabel.get());
4822             }
4823 
4824             bool hasBreaksOrContinuesThatEscapeCurrentFinally = context.numberOfBreaksOrContinues() &gt; numberOfJumps;
4825             if (hasBreaksOrContinuesThatEscapeCurrentFinally) {
4826                 Ref&lt;Label&gt; isThrowOrNormalLabel = newLabel();
4827                 emitJumpIf&lt;OpBeloweq&gt;(context.completionTypeRegister(), CompletionType::Throw, isThrowOrNormalLabel.get());
4828 
4829                 // A completionType above Throw means we have a Break or Continue encoded as a jumpID.
4830                 // We already ruled out Return above.
4831                 static_assert(CompletionType::Throw &lt; CompletionType::Return &amp;&amp; CompletionType::Throw &lt; CompletionType::Return, &quot;jumpIDs are above CompletionType::Return&quot;);
4832 
4833                 // This case is for Break / Continue completions in an inner finally context:
4834                 //
4835                 // 10: label:
4836                 // 11: try {
4837                 // 12:     try {
4838                 // 13:         for (... stuff ...)
4839                 // 14:             break label; // Sets completionType to jumpID of label.
4840                 // 15:     } finally {
4841                 // 16:     } // Jumps to outer finally on completion.
4842                 // 17:  } finally {
4843                 // 18:  }
4844                 //
4845                 // The break (line 14) says to continue execution at the label at line 10. Before we can
4846                 // goto line 10, the inner context&#39;s finally (line 15) needs to be run, followed by the
4847                 // outer context&#39;s finally (line 17). &#39;outerContext&#39; being non-null above tells us that
4848                 // there is at least one outer finally context that we need to run after we complete the
4849                 // current finally. Note that unless the body of the outer finally abruptly completes in a
4850                 // different way, that outer finally also needs to complete with a Break / Continue to
4851                 // the same target label. Hence, we need to pass the jumpID in this finally&#39;s completionTypeRegister
4852                 // to the outer finally. The completion value for Break and Continue according to the spec
4853                 // is undefined, but it won&#39;t ever be used. So, we&#39;ll skip setting it.
4854                 //
4855                 // Note that all we&#39;re doing here is passing the Break / Continue completion to the next
4856                 // outer finally context. We don&#39;t worry about finally contexts beyond that. It is the
4857                 // responsibility of the next outer finally to determine what to do next at its completion,
4858                 // and pass on to the next outer context if present and needed.
4859 
4860                 move(outerContext-&gt;completionTypeRegister(), context.completionTypeRegister());
4861                 emitJump(*outerContext-&gt;finallyLabel());
4862 
4863                 emitLabel(isThrowOrNormalLabel.get());
4864             }
4865 
4866         } else {
4867             // We are the outermost finally.
4868             if (context.handlesReturns()) {
4869                 Ref&lt;Label&gt; notReturnLabel = newLabel();
4870                 emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Return, notReturnLabel.get());
4871 
4872                 // This case is for Return completion from the outermost finally context:
4873                 //
4874                 //     try {
4875                 //         return result; // Sets completionType to Return, and completionValue to result.
4876                 //     } finally {
4877                 //     } // Executes the return of the completionValue.
4878                 //
4879                 // Since we know there&#39;s no outer finally context (beyond the current context) to run,
4880                 // we can actually execute a return for this Return completion. The value to return
4881                 // is whatever is in the completionValueRegister.
4882 
4883                 emitWillLeaveCallFrameDebugHook();
4884                 emitReturn(context.completionValueRegister(), ReturnFrom::Finally);
4885 
4886                 emitLabel(notReturnLabel.get());
4887             }
4888         }
4889     }
4890 
4891     // By now, we&#39;ve rule out all Break / Continue / Return completions above. The only remaining
4892     // possibilities are Normal or Throw.
4893 
4894     emitJumpIf&lt;OpNstricteq&gt;(context.completionTypeRegister(), CompletionType::Throw, normalCompletionLabel);
4895 
4896     // We get here because we entered this finally context with Throw completionType (i.e. we have
4897     // an exception that we need to rethrow), and we didn&#39;t encounter a different abrupt completion
4898     // that overrides that incoming completionType. All we have to do here is re-throw the exception
4899     // captured in the completionValue.
4900     //
4901     // Note that unlike for Break / Continue / Return, we don&#39;t need to worry about outer finally
4902     // contexts. This is because any outer finally context (if present) will have its own exception
4903     // handler, which will take care of receiving the Throw completion, and re-capturing the exception
4904     // in its completionValue.
4905 
4906     emitThrow(context.completionValueRegister());
4907 }
4908 
4909 template&lt;typename CompareOp&gt;
4910 void BytecodeGenerator::emitJumpIf(RegisterID* completionTypeRegister, CompletionType type, Label&amp; jumpTarget)
4911 {
4912     RefPtr&lt;RegisterID&gt; tempRegister = newTemporary();
4913     RegisterID* valueConstant = addConstantValue(jsNumber(static_cast&lt;int&gt;(type)));
4914     OperandTypes operandTypes = OperandTypes(ResultType::numberTypeIsInt32(), ResultType::unknownType());
4915 
4916     auto equivalenceResult = emitBinaryOp&lt;CompareOp&gt;(tempRegister.get(), completionTypeRegister, valueConstant, operandTypes);
4917     emitJumpIfTrue(equivalenceResult, jumpTarget);
4918 }
4919 
4920 void BytecodeGenerator::pushOptionalChainTarget()
4921 {
4922     m_optionalChainTargetStack.append(newLabel());
4923 }
4924 
4925 void BytecodeGenerator::popOptionalChainTarget()
4926 {
4927     ASSERT(m_optionalChainTargetStack.size());
4928     emitLabel(m_optionalChainTargetStack.takeLast().get());
4929 }
4930 
4931 void BytecodeGenerator::popOptionalChainTarget(RegisterID* dst, bool isDelete)
4932 {
4933     Ref&lt;Label&gt; endLabel = newLabel();
4934     emitJump(endLabel.get());
4935 
4936     popOptionalChainTarget();
4937     emitLoad(dst, isDelete ? jsBoolean(true) : jsUndefined());
4938 
4939     emitLabel(endLabel.get());
4940 }
4941 
4942 void BytecodeGenerator::emitOptionalCheck(RegisterID* src)
4943 {
4944     ASSERT(m_optionalChainTargetStack.size());
4945     emitJumpIfTrue(emitIsUndefinedOrNull(newTemporary(), src), m_optionalChainTargetStack.last().get());
4946 }
4947 
<a name="113" id="anc113"></a><span class="line-modified">4948 void ForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
4949 {
4950     // Lexically invalidating ForInContexts is kind of weak sauce, but it only occurs if
4951     // either of the following conditions is true:
4952     //
4953     // (1) The loop iteration variable is re-assigned within the body of the loop.
4954     // (2) The loop iteration variable is captured in the lexical scope of the function.
4955     //
4956     // These two situations occur sufficiently rarely that it&#39;s okay to use this style of
4957     // &quot;analysis&quot; to make iteration faster. If we didn&#39;t want to do this, we would either have
4958     // to perform some flow-sensitive analysis to see if/when the loop iteration variable was
4959     // reassigned, or we&#39;d have to resort to runtime checks to see if the variable had been
4960     // reassigned from its original value.
4961 
4962     for (unsigned offset = bodyBytecodeStartOffset(); isValid() &amp;&amp; offset &lt; bodyBytecodeEndOffset;) {
4963         auto instruction = generator.instructions().at(offset);
<a name="114" id="anc114"></a><span class="line-modified">4964         ASSERT(!instruction-&gt;is&lt;OpEnter&gt;());</span>
<span class="line-modified">4965         computeDefsForBytecodeIndex(codeBlock, instruction.ptr(), [&amp;] (VirtualRegister operand) {</span>


4966             if (local()-&gt;virtualRegister() == operand)
4967                 invalidate();
4968         });
4969         offset += instruction-&gt;size();
4970     }
4971 }
4972 
<a name="115" id="anc115"></a><span class="line-modified">4973 void StructureForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
4974 {
4975     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
4976     if (isValid())
4977         return;
4978 
4979     OpcodeID lastOpcodeID = generator.m_lastOpcodeID;
4980     InstructionStream::MutableRef lastInstruction = generator.m_lastInstruction;
4981     for (const auto&amp; instTuple : m_getInsts) {
4982         unsigned instIndex = std::get&lt;0&gt;(instTuple);
4983         int propertyRegIndex = std::get&lt;1&gt;(instTuple);
4984         auto instruction = generator.m_writer.ref(instIndex);
4985         auto end = instIndex + instruction-&gt;size();
4986         ASSERT(instruction-&gt;isWide32());
4987 
4988         generator.m_writer.seek(instIndex);
4989 
4990         auto bytecode = instruction-&gt;as&lt;OpGetDirectPname&gt;();
4991 
4992         // disable peephole optimizations
4993         generator.m_lastOpcodeID = op_end;
4994 
4995         // Change the opcode to get_by_val.
4996         // 1. dst stays the same.
4997         // 2. base stays the same.
4998         // 3. property gets switched to the original property.
4999         OpGetByVal::emit&lt;OpcodeSize::Wide32&gt;(&amp;generator, bytecode.m_dst, bytecode.m_base, VirtualRegister(propertyRegIndex));
5000 
5001         // 4. nop out the remaining bytes
5002         while (generator.m_writer.position() &lt; end)
5003             OpNop::emit&lt;OpcodeSize::Narrow&gt;(&amp;generator);
5004     }
5005     generator.m_writer.seek(generator.m_writer.size());
5006     if (generator.m_lastInstruction.offset() + generator.m_lastInstruction-&gt;size() != generator.m_writer.size()) {
5007         generator.m_lastOpcodeID = lastOpcodeID;
5008         generator.m_lastInstruction = lastInstruction;
5009     }
5010 }
5011 
<a name="116" id="anc116"></a><span class="line-modified">5012 void IndexedForInContext::finalize(BytecodeGenerator&amp; generator, UnlinkedCodeBlockGenerator* codeBlock, unsigned bodyBytecodeEndOffset)</span>
5013 {
5014     Base::finalize(generator, codeBlock, bodyBytecodeEndOffset);
5015     if (isValid())
5016         return;
5017 
5018     for (const auto&amp; instPair : m_getInsts) {
5019         unsigned instIndex = instPair.first;
5020         int propertyRegIndex = instPair.second;
5021         generator.m_writer.ref(instIndex)-&gt;cast&lt;OpGetByVal&gt;()-&gt;setProperty(VirtualRegister(propertyRegIndex), []() {
5022             ASSERT_NOT_REACHED();
5023             return VirtualRegister();
5024         });
5025     }
5026 }
5027 
5028 void StaticPropertyAnalysis::record()
5029 {
5030     auto* instruction = m_instructionRef.ptr();
5031     auto size = m_propertyIndexes.size();
5032     switch (instruction-&gt;opcodeID()) {
5033     case OpNewObject::opcodeID:
5034         instruction-&gt;cast&lt;OpNewObject&gt;()-&gt;setInlineCapacity(size, []() {
5035             return 255;
5036         });
5037         return;
5038     case OpCreateThis::opcodeID:
5039         instruction-&gt;cast&lt;OpCreateThis&gt;()-&gt;setInlineCapacity(size, []() {
5040             return 255;
5041         });
5042         return;
5043     default:
5044         ASSERT_NOT_REACHED();
5045     }
5046 }
5047 
5048 void BytecodeGenerator::emitToThis()
5049 {
5050     OpToThis::emit(this, kill(&amp;m_thisRegister));
<a name="117" id="anc117"></a>
5051 }
5052 
5053 } // namespace JSC
5054 
5055 namespace WTF {
5056 
5057 void printInternal(PrintStream&amp; out, JSC::Variable::VariableKind kind)
5058 {
5059     switch (kind) {
5060     case JSC::Variable::NormalVariable:
5061         out.print(&quot;Normal&quot;);
5062         return;
5063     case JSC::Variable::SpecialVariable:
5064         out.print(&quot;Special&quot;);
5065         return;
5066     }
5067     RELEASE_ASSERT_NOT_REACHED();
5068 }
5069 
5070 } // namespace WTF
5071 
<a name="118" id="anc118"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="118" type="hidden" />
</body>
</html>
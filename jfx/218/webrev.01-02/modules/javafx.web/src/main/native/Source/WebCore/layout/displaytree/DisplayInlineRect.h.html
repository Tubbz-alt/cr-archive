<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayInlineRect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;LayoutUnits.h&quot;
 31 
 32 namespace WebCore {
 33 namespace Display {
 34 
 35 class InlineRect {
 36 public:
 37     InlineRect() = default;
 38     InlineRect(InlineLayoutUnit top, InlineLayoutUnit left, InlineLayoutUnit width, InlineLayoutUnit height);
 39     InlineRect(const InlineLayoutPoint&amp; topLeft, InlineLayoutUnit width, InlineLayoutUnit height);
 40 
 41     InlineLayoutUnit top() const;
 42     InlineLayoutUnit left() const;
 43     InlineLayoutPoint topLeft() const;
 44 
 45     InlineLayoutUnit bottom() const;
 46     InlineLayoutUnit right() const;
 47 
 48     InlineLayoutUnit width() const;
 49     InlineLayoutUnit height() const;
 50     InlineLayoutSize size() const;
 51 
 52     void setTop(InlineLayoutUnit);
 53     void setBottom(InlineLayoutUnit);
 54     void setLeft(InlineLayoutUnit);
 55     void setTopLeft(const InlineLayoutPoint&amp;);
 56     void setWidth(InlineLayoutUnit);
 57     void setHeight(InlineLayoutUnit);
 58 
 59     void moveHorizontally(InlineLayoutUnit);
 60     void moveVertically(InlineLayoutUnit);
 61 
 62     void expand(Optional&lt;InlineLayoutUnit&gt;, Optional&lt;InlineLayoutUnit&gt;);
 63     void expandToContain(const InlineRect&amp;);
 64     void expandHorizontally(InlineLayoutUnit delta) { expand(delta, { }); }
 65     void expandVertically(InlineLayoutUnit delta) { expand({ }, delta); }
 66     void expandVerticallyToContain(const InlineRect&amp;);
 67     void inflate(InlineLayoutUnit);
 68 
 69     operator InlineLayoutRect() const;
 70 
 71 private:
 72 #if ASSERT_ENABLED
 73     void invalidateTop() { m_hasValidTop = false; }
 74     void invalidateLeft() { m_hasValidLeft = false; }
 75     void invalidateWidth() { m_hasValidWidth = false; }
 76     void invalidateHeight() { m_hasValidHeight = false; }
 77     void invalidatePosition();
 78 
 79     bool hasValidPosition() const { return m_hasValidTop &amp;&amp; m_hasValidLeft; }
 80     bool hasValidSize() const { return m_hasValidWidth &amp;&amp; m_hasValidHeight; }
 81     bool hasValidGeometry() const { return hasValidPosition() &amp;&amp; hasValidSize(); }
 82 
 83     void setHasValidPosition();
 84     void setHasValidSize();
 85 
 86     bool m_hasValidTop { false };
 87     bool m_hasValidLeft { false };
 88     bool m_hasValidWidth { false };
 89     bool m_hasValidHeight { false };
 90 #endif // ASSERT_ENABLED
 91     InlineLayoutRect m_rect;
 92 };
 93 
 94 inline InlineRect::InlineRect(InlineLayoutUnit top, InlineLayoutUnit left, InlineLayoutUnit width, InlineLayoutUnit height)
 95     : m_rect(left, top, width, height)
 96 {
 97 #if ASSERT_ENABLED
 98     m_hasValidTop = true;
 99     m_hasValidLeft = true;
100     m_hasValidWidth = true;
101     m_hasValidHeight = true;
102 #endif
103 }
104 
105 inline InlineRect::InlineRect(const InlineLayoutPoint&amp; topLeft, InlineLayoutUnit width, InlineLayoutUnit height)
106     : InlineRect(topLeft.y(), topLeft.x(), width, height)
107 {
108 }
109 
110 #if ASSERT_ENABLED
111 inline void InlineRect::invalidatePosition()
112 {
113     invalidateTop();
114     invalidateLeft();
115 }
116 
117 inline void InlineRect::setHasValidPosition()
118 {
119     m_hasValidTop = true;
120     m_hasValidLeft = true;
121 }
122 
123 inline void InlineRect::setHasValidSize()
124 {
125     m_hasValidWidth = true;
126     m_hasValidHeight = true;
127 }
128 #endif // ASSERT_ENABLED
129 
130 inline InlineLayoutUnit InlineRect::top() const
131 {
132     ASSERT(m_hasValidTop);
133     return m_rect.y();
134 }
135 
136 inline InlineLayoutUnit InlineRect::left() const
137 {
138     ASSERT(m_hasValidLeft);
139     return m_rect.x();
140 }
141 
142 inline InlineLayoutUnit InlineRect::bottom() const
143 {
144     ASSERT(m_hasValidTop &amp;&amp; m_hasValidHeight);
145     return m_rect.maxY();
146 }
147 
148 inline InlineLayoutUnit InlineRect::right() const
149 {
150     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidWidth);
151     return m_rect.maxX();
152 }
153 
154 inline InlineLayoutPoint InlineRect::topLeft() const
155 {
156     ASSERT(hasValidPosition());
157     return m_rect.minXMinYCorner();
158 }
159 
160 inline InlineLayoutSize InlineRect::size() const
161 {
162     ASSERT(hasValidSize());
163     return m_rect.size();
164 }
165 
166 inline InlineLayoutUnit InlineRect::width() const
167 {
168     ASSERT(m_hasValidWidth);
169     return m_rect.width();
170 }
171 
172 inline InlineLayoutUnit InlineRect::height() const
173 {
174     ASSERT(m_hasValidHeight);
175     return m_rect.height();
176 }
177 
178 inline void InlineRect::setTopLeft(const InlineLayoutPoint&amp; topLeft)
179 {
180 #if ASSERT_ENABLED
181     setHasValidPosition();
182 #endif
183     m_rect.setLocation(topLeft);
184 }
185 
186 inline void InlineRect::setTop(InlineLayoutUnit top)
187 {
188 #if ASSERT_ENABLED
189     m_hasValidTop = true;
190 #endif
191     m_rect.setY(top);
192 }
193 
194 inline void InlineRect::setBottom(InlineLayoutUnit bottom)
195 {
196 #if ASSERT_ENABLED
197     m_hasValidTop = true;
198     m_hasValidHeight = true;
199 #endif
200     m_rect.shiftMaxYEdgeTo(bottom);
201 }
202 
203 inline void InlineRect::setLeft(InlineLayoutUnit left)
204 {
205 #if ASSERT_ENABLED
206     m_hasValidLeft = true;
207 #endif
208     m_rect.setX(left);
209 }
210 
211 inline void InlineRect::setWidth(InlineLayoutUnit width)
212 {
213 #if ASSERT_ENABLED
214     m_hasValidWidth = true;
215 #endif
216     m_rect.setWidth(width);
217 }
218 
219 inline void InlineRect::setHeight(InlineLayoutUnit height)
220 {
221 #if ASSERT_ENABLED
222     m_hasValidHeight = true;
223 #endif
224     m_rect.setHeight(height);
225 }
226 
227 inline void InlineRect::moveHorizontally(InlineLayoutUnit offset)
228 {
229     ASSERT(m_hasValidLeft);
230     m_rect.move(InlineLayoutSize { offset, 0 });
231 }
232 
233 inline void InlineRect::moveVertically(InlineLayoutUnit offset)
234 {
235     ASSERT(m_hasValidTop);
236     m_rect.move(InlineLayoutSize { 0, offset });
237 }
238 
239 inline void InlineRect::expand(Optional&lt;InlineLayoutUnit&gt; width, Optional&lt;InlineLayoutUnit&gt; height)
240 {
241     ASSERT(!width || m_hasValidWidth);
242     ASSERT(!height || m_hasValidHeight);
243     m_rect.expand(width.valueOr(0), height.valueOr(0));
244 }
245 
246 inline void InlineRect::expandToContain(const InlineRect&amp; other)
247 {
248     m_rect = unionRect(other, m_rect);
249 }
250 
251 inline void InlineRect::expandVerticallyToContain(const InlineRect&amp; other)
252 {
253     auto containTop = std::min(top(), other.top());
254     auto containBottom = std::max(bottom(), other.bottom());
255     setTop(containTop);
256     setBottom(containBottom);
257 }
258 
259 inline void InlineRect::inflate(InlineLayoutUnit inflate)
260 {
261     ASSERT(hasValidGeometry());
262     m_rect.inflate(inflate);
263 }
264 
265 inline InlineRect::operator InlineLayoutRect() const
266 {
267     ASSERT(hasValidGeometry());
268     return m_rect;
269 }
270 
271 }
272 }
273 #endif
    </pre>
  </body>
</html>
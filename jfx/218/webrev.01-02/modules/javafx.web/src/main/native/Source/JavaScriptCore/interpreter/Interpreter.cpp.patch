diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp
@@ -32,10 +32,11 @@
 
 #include "BatchedTransitionOptimizer.h"
 #include "Bytecodes.h"
 #include "CallFrameClosure.h"
 #include "CatchScope.h"
+#include "CheckpointOSRExitSideState.h"
 #include "CodeBlock.h"
 #include "CodeCache.h"
 #include "DirectArguments.h"
 #include "ExecutableBaseInlines.h"
 #include "Heap.h"
@@ -51,11 +52,10 @@
 #include "InterpreterInlines.h"
 #include "JITCodeInlines.h"
 #include "JSArrayInlines.h"
 #include "JSBoundFunction.h"
 #include "JSCInlines.h"
-#include "JSFixedArray.h"
 #include "JSImmutableButterfly.h"
 #include "JSLexicalEnvironment.h"
 #include "JSModuleEnvironment.h"
 #include "JSString.h"
 #include "JSWithScope.h"
@@ -64,11 +64,11 @@
 #include "LiteralParser.h"
 #include "ModuleProgramCodeBlock.h"
 #include "ObjectPrototype.h"
 #include "Parser.h"
 #include "ProgramCodeBlock.h"
-#include "ProtoCallFrame.h"
+#include "ProtoCallFrameInlines.h"
 #include "RegExpObject.h"
 #include "Register.h"
 #include "RegisterAtOffsetList.h"
 #include "ScopedArguments.h"
 #include "StackAlignment.h"
@@ -99,35 +99,34 @@
 #include "WebAssemblyFunction.h"
 #endif
 
 namespace JSC {
 
-JSValue eval(CallFrame* callFrame)
+JSValue eval(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = callFrame->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!callFrame->argumentCount())
         return jsUndefined();
 
     JSValue program = callFrame->argument(0);
     if (!program.isString())
         return program;
 
     TopCallFrameSetter topCallFrame(vm, callFrame);
-    JSGlobalObject* globalObject = callFrame->lexicalGlobalObject();
     if (!globalObject->evalEnabled()) {
-        throwException(callFrame, scope, createEvalError(callFrame, globalObject->evalDisabledErrorMessage()));
+        throwException(globalObject, scope, createEvalError(globalObject, globalObject->evalDisabledErrorMessage()));
         return jsUndefined();
     }
-    String programSource = asString(program)->value(callFrame);
+    String programSource = asString(program)->value(globalObject);
     RETURN_IF_EXCEPTION(scope, JSValue());
 
     CallFrame* callerFrame = callFrame->callerFrame();
     CallSiteIndex callerCallSiteIndex = callerFrame->callSiteIndex();
     CodeBlock* callerCodeBlock = callerFrame->codeBlock();
-    JSScope* callerScopeChain = callerFrame->uncheckedR(callerCodeBlock->scopeRegister().offset()).Register::scope();
+    JSScope* callerScopeChain = callerFrame->uncheckedR(callerCodeBlock->scopeRegister()).Register::scope();
     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock->unlinkedCodeBlock();
 
     bool isArrowFunctionContext = callerUnlinkedCodeBlock->isArrowFunction() || callerUnlinkedCodeBlock->isArrowFunctionContext();
 
     DerivedContextType derivedContextType = callerUnlinkedCodeBlock->derivedContextType();
@@ -136,201 +135,199 @@
             ? DerivedContextType::DerivedConstructorContext
             : DerivedContextType::DerivedMethodContext;
     }
 
     EvalContextType evalContextType;
-    if (isFunctionParseMode(callerUnlinkedCodeBlock->parseMode()))
+    if (callerUnlinkedCodeBlock->parseMode() == SourceParseMode::InstanceFieldInitializerMode)
+        evalContextType = EvalContextType::InstanceFieldEvalContext;
+    else if (isFunctionParseMode(callerUnlinkedCodeBlock->parseMode()))
         evalContextType = EvalContextType::FunctionEvalContext;
     else if (callerUnlinkedCodeBlock->codeType() == EvalCode)
         evalContextType = callerUnlinkedCodeBlock->evalContextType();
     else
         evalContextType = EvalContextType::None;
 
     DirectEvalExecutable* eval = callerCodeBlock->directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
     if (!eval) {
         if (!callerCodeBlock->isStrictMode()) {
             if (programSource.is8Bit()) {
-                LiteralParser<LChar> preparser(callFrame, programSource.characters8(), programSource.length(), NonStrictJSON);
+                LiteralParser<LChar> preparser(globalObject, programSource.characters8(), programSource.length(), NonStrictJSON, callerCodeBlock);
                 if (JSValue parsedObject = preparser.tryLiteralParse())
                     RELEASE_AND_RETURN(scope, parsedObject);
 
             } else {
-                LiteralParser<UChar> preparser(callFrame, programSource.characters16(), programSource.length(), NonStrictJSON);
+                LiteralParser<UChar> preparser(globalObject, programSource.characters16(), programSource.length(), NonStrictJSON, callerCodeBlock);
                 if (JSValue parsedObject = preparser.tryLiteralParse())
                     RELEASE_AND_RETURN(scope, parsedObject);
 
             }
             RETURN_IF_EXCEPTION(scope, JSValue());
         }
 
         VariableEnvironment variablesUnderTDZ;
         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
-        eval = DirectEvalExecutable::create(callFrame, makeSource(programSource, callerCodeBlock->source().provider()->sourceOrigin()), callerCodeBlock->isStrictMode(), derivedContextType, isArrowFunctionContext, evalContextType, &variablesUnderTDZ);
+        eval = DirectEvalExecutable::create(globalObject, makeSource(programSource, callerCodeBlock->source().provider()->sourceOrigin()), callerCodeBlock->isStrictMode(), derivedContextType, callerUnlinkedCodeBlock->needsClassFieldInitializer(), isArrowFunctionContext, evalContextType, &variablesUnderTDZ);
         EXCEPTION_ASSERT(!!scope.exception() == !eval);
         if (!eval)
             return jsUndefined();
 
-        callerCodeBlock->directEvalCodeCache().set(callFrame, callerCodeBlock, programSource, callerCallSiteIndex, eval);
+        callerCodeBlock->directEvalCodeCache().set(globalObject, callerCodeBlock, programSource, callerCallSiteIndex, eval);
     }
 
     JSValue thisValue = callerFrame->thisValue();
     Interpreter* interpreter = vm.interpreter;
-    RELEASE_AND_RETURN(scope, interpreter->execute(eval, callFrame, thisValue, callerScopeChain));
+    RELEASE_AND_RETURN(scope, interpreter->execute(eval, globalObject, thisValue, callerScopeChain));
 }
 
-unsigned sizeOfVarargs(CallFrame* callFrame, JSValue arguments, uint32_t firstVarArgOffset)
+unsigned sizeOfVarargs(JSGlobalObject* globalObject, JSValue arguments, uint32_t firstVarArgOffset)
 {
-    VM& vm = callFrame->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (UNLIKELY(!arguments.isCell())) {
         if (arguments.isUndefinedOrNull())
             return 0;
 
-        throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame, arguments));
+        throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject, arguments));
         return 0;
     }
 
     JSCell* cell = arguments.asCell();
     unsigned length;
     switch (cell->type()) {
     case DirectArgumentsType:
-        length = jsCast<DirectArguments*>(cell)->length(callFrame);
+        length = jsCast<DirectArguments*>(cell)->length(globalObject);
         break;
     case ScopedArgumentsType:
-        length = jsCast<ScopedArguments*>(cell)->length(callFrame);
-        break;
-    case JSFixedArrayType:
-        length = jsCast<JSFixedArray*>(cell)->size();
+        length = jsCast<ScopedArguments*>(cell)->length(globalObject);
         break;
     case JSImmutableButterflyType:
         length = jsCast<JSImmutableButterfly*>(cell)->length();
         break;
     case StringType:
     case SymbolType:
     case BigIntType:
-        throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame,  arguments));
+        throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject,  arguments));
         return 0;
 
     default:
         RELEASE_ASSERT(arguments.isObject());
-        length = clampToUnsigned(toLength(callFrame, jsCast<JSObject*>(cell)));
+        length = clampToUnsigned(toLength(globalObject, jsCast<JSObject*>(cell)));
         break;
     }
     RETURN_IF_EXCEPTION(scope, 0);
 
+    if (length > maxArguments)
+        throwStackOverflowError(globalObject, scope);
+
     if (length >= firstVarArgOffset)
         length -= firstVarArgOffset;
     else
         length = 0;
 
     return length;
 }
 
-unsigned sizeFrameForForwardArguments(CallFrame* callFrame, VM& vm, unsigned numUsedStackSlots)
+unsigned sizeFrameForForwardArguments(JSGlobalObject* globalObject, CallFrame* callFrame, VM& vm, unsigned numUsedStackSlots)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     unsigned length = callFrame->argumentCount();
     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame->registers())))
-        throwStackOverflowError(callFrame, scope);
+        throwStackOverflowError(globalObject, scope);
 
     return length;
 }
 
-unsigned sizeFrameForVarargs(CallFrame* callFrame, VM& vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)
+unsigned sizeFrameForVarargs(JSGlobalObject* globalObject, CallFrame* callFrame, VM& vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    unsigned length = sizeOfVarargs(callFrame, arguments, firstVarArgOffset);
+    unsigned length = sizeOfVarargs(globalObject, arguments, firstVarArgOffset);
     RETURN_IF_EXCEPTION(scope, 0);
 
     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
     if (UNLIKELY(length > maxArguments || !vm.ensureStackCapacityFor(calleeFrame->registers()))) {
-        throwStackOverflowError(callFrame, scope);
+        throwStackOverflowError(globalObject, scope);
         return 0;
     }
 
     return length;
 }
 
-void loadVarargs(CallFrame* callFrame, VirtualRegister firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)
+void loadVarargs(JSGlobalObject* globalObject, JSValue* firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)
 {
     if (UNLIKELY(!arguments.isCell()) || !length)
         return;
 
-    VM& vm = callFrame->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSCell* cell = arguments.asCell();
 
     switch (cell->type()) {
     case DirectArgumentsType:
         scope.release();
-        jsCast<DirectArguments*>(cell)->copyToArguments(callFrame, firstElementDest, offset, length);
+        jsCast<DirectArguments*>(cell)->copyToArguments(globalObject, firstElementDest, offset, length);
         return;
     case ScopedArgumentsType:
         scope.release();
-        jsCast<ScopedArguments*>(cell)->copyToArguments(callFrame, firstElementDest, offset, length);
-        return;
-    case JSFixedArrayType:
-        scope.release();
-        jsCast<JSFixedArray*>(cell)->copyToArguments(callFrame, firstElementDest, offset, length);
+        jsCast<ScopedArguments*>(cell)->copyToArguments(globalObject, firstElementDest, offset, length);
         return;
     case JSImmutableButterflyType:
         scope.release();
-        jsCast<JSImmutableButterfly*>(cell)->copyToArguments(callFrame, firstElementDest, offset, length);
+        jsCast<JSImmutableButterfly*>(cell)->copyToArguments(globalObject, firstElementDest, offset, length);
         return;
     default: {
         ASSERT(arguments.isObject());
         JSObject* object = jsCast<JSObject*>(cell);
         if (isJSArray(object)) {
             scope.release();
-            jsCast<JSArray*>(object)->copyToArguments(callFrame, firstElementDest, offset, length);
+            jsCast<JSArray*>(object)->copyToArguments(globalObject, firstElementDest, offset, length);
             return;
         }
         unsigned i;
         for (i = 0; i < length && object->canGetIndexQuickly(i + offset); ++i)
-            callFrame->r(firstElementDest + i) = object->getIndexQuickly(i + offset);
+            firstElementDest[i] = object->getIndexQuickly(i + offset);
         for (; i < length; ++i) {
-            JSValue value = object->get(callFrame, i + offset);
+            JSValue value = object->get(globalObject, i + offset);
             RETURN_IF_EXCEPTION(scope, void());
-            callFrame->r(firstElementDest + i) = value;
+            firstElementDest[i] = value;
         }
         return;
     } }
 }
 
-void setupVarargsFrame(CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)
+void setupVarargsFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)
 {
     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 
     loadVarargs(
-        callFrame,
-        calleeFrameOffset + CallFrame::argumentOffset(0),
+        globalObject,
+        bitwise_cast<JSValue*>(&callFrame->r(calleeFrameOffset + CallFrame::argumentOffset(0))),
         arguments, offset, length);
 
     newCallFrame->setArgumentCountIncludingThis(length + 1);
 }
 
-void setupVarargsFrameAndSetThis(CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)
+void setupVarargsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)
 {
-    setupVarargsFrame(callFrame, newCallFrame, arguments, firstVarArgOffset, length);
+    setupVarargsFrame(globalObject, callFrame, newCallFrame, arguments, firstVarArgOffset, length);
     newCallFrame->setThisValue(thisValue);
 }
 
-void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length)
+void setupForwardArgumentsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, uint32_t length)
 {
     ASSERT(length == execCaller->argumentCount());
     unsigned offset = execCaller->argumentOffset(0) * sizeof(Register);
     memcpy(reinterpret_cast<char*>(execCallee) + offset, reinterpret_cast<char*>(execCaller) + offset, length * sizeof(Register));
     execCallee->setArgumentCountIncludingThis(length + 1);
 }
 
-void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)
+void setupForwardArgumentsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)
 {
-    setupForwardArgumentsFrame(execCaller, execCallee, length);
+    setupForwardArgumentsFrame(globalObject, execCaller, execCallee, length);
     execCallee->setThisValue(thisValue);
 }
 
 
 
@@ -338,27 +335,27 @@
     : m_vm(vm)
 #if ENABLE(C_LOOP)
     , m_cloopStack(vm)
 #endif
 {
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     static std::once_flag assertOnceKey;
     std::call_once(assertOnceKey, [] {
         for (unsigned i = 0; i < NUMBER_OF_BYTECODE_IDS; ++i) {
             OpcodeID opcodeID = static_cast<OpcodeID>(i);
             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
         }
     });
-#endif // USE(LLINT_EMBEDDED_OPCODE_ID)
+#endif // ASSERT_ENABLED
 }
 
 Interpreter::~Interpreter()
 {
 }
 
 #if ENABLE(COMPUTED_GOTO_OPCODES)
-#if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
+#if !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED
 HashMap<Opcode, OpcodeID>& Interpreter::opcodeIDTable()
 {
     static NeverDestroyed<HashMap<Opcode, OpcodeID>> opcodeIDTable;
 
     static std::once_flag initializeKey;
@@ -368,25 +365,25 @@
             opcodeIDTable.get().add(opcodeTable[i], static_cast<OpcodeID>(i));
     });
 
     return opcodeIDTable;
 }
-#endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED
+#endif // !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED
 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 bool Interpreter::isOpcode(Opcode opcode)
 {
 #if ENABLE(COMPUTED_GOTO_OPCODES)
     return opcode != HashTraits<Opcode>::emptyValue()
         && !HashTraits<Opcode>::isDeletedValue(opcode)
         && opcodeIDTable().contains(opcode);
 #else
     return opcode >= 0 && opcode <= op_end;
 #endif
 }
-#endif // !ASSERT_DISABLED
+#endif // ASSERT_ENABLED
 
 class GetStackTraceFunctor {
 public:
     GetStackTraceFunctor(VM& vm, JSCell* owner, Vector<StackFrame>& results, size_t framesToSkip, size_t capacity)
         : m_vm(vm)
@@ -408,11 +405,11 @@
         if (m_remainingCapacityForFrameCapture) {
             if (visitor->isWasmFrame()) {
                 m_results.append(StackFrame(visitor->wasmFunctionIndexOrName()));
             } else if (!!visitor->codeBlock() && !visitor->codeBlock()->unlinkedCodeBlock()->isBuiltinFunction()) {
                 m_results.append(
-                    StackFrame(m_vm, m_owner, visitor->callee().asCell(), visitor->codeBlock(), visitor->bytecodeOffset()));
+                    StackFrame(m_vm, m_owner, visitor->callee().asCell(), visitor->codeBlock(), visitor->bytecodeIndex()));
             } else {
                 m_results.append(
                     StackFrame(m_vm, m_owner, visitor->callee().asCell()));
             }
 
@@ -438,11 +435,11 @@
     if (!callFrame || !maxStackSize)
         return;
 
     size_t framesCount = 0;
     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
-    StackVisitor::visit(callFrame, &vm, [&] (StackVisitor&) -> StackVisitor::Status {
+    StackVisitor::visit(callFrame, vm, [&] (StackVisitor&) -> StackVisitor::Status {
         if (++framesCount < maxFramesCountNeeded)
             return StackVisitor::Continue;
         return StackVisitor::Done;
     });
     if (framesCount <= framesToSkip)
@@ -450,11 +447,11 @@
 
     framesCount -= framesToSkip;
     framesCount = std::min(maxStackSize, framesCount);
 
     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
-    StackVisitor::visit(callFrame, &vm, functor);
+    StackVisitor::visit(callFrame, vm, functor);
     ASSERT(results.size() == results.capacity());
 }
 
 String Interpreter::stackTraceAsString(VM& vm, const Vector<StackFrame>& stackTrace)
 {
@@ -478,11 +475,11 @@
     CallFrame* callFrame = visitor->callFrame();
     unsigned exceptionHandlerIndex;
     if (JITCode::isOptimizingJIT(codeBlock->jitType()))
         exceptionHandlerIndex = callFrame->callSiteIndex().bits();
     else
-        exceptionHandlerIndex = callFrame->bytecodeOffset();
+        exceptionHandlerIndex = callFrame->bytecodeIndex().offset();
 
     return codeBlock->handlerForIndex(exceptionHandlerIndex, requiredHandler);
 }
 
 class GetCatchHandlerFunctor {
@@ -513,12 +510,13 @@
     mutable HandlerInfo* m_handler;
 };
 
 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM& vm, CallFrame* callFrame)
 {
+    JSGlobalObject* globalObject = callFrame->lexicalGlobalObject(vm);
     auto catchScope = DECLARE_CATCH_SCOPE(vm);
-    if (Debugger* debugger = vm.vmEntryGlobalObject(callFrame)->debugger()) {
+    if (Debugger* debugger = globalObject->debugger()) {
         SuspendExceptionScope scope(&vm);
         if (callFrame->isAnyWasmCallee()
             || (callFrame->callee().isCell() && callFrame->callee().asCell()->inherits<JSFunction>(vm)))
             debugger->unwindEvent(callFrame);
         else
@@ -543,12 +541,17 @@
         visitor.unwindToMachineCodeBlockFrame();
         m_callFrame = visitor->callFrame();
         m_codeBlock = visitor->codeBlock();
 
         m_handler = nullptr;
-        if (!m_isTermination) {
-            if (m_codeBlock) {
+        if (m_codeBlock) {
+            // FIXME: We should support exception handling in checkpoints.
+#if ENABLE(DFG_JIT)
+            if (removeCodePtrTag(m_returnPC) == LLInt::getCodePtr<NoPtrTag>(checkpoint_osr_exit_from_inlined_call_trampoline).executableAddress())
+                m_codeBlock->vm().findCheckpointOSRSideState(m_callFrame);
+#endif
+            if (!m_isTermination) {
                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
                 if (m_handler)
                     return StackVisitor::Done;
             }
         }
@@ -566,10 +569,11 @@
 
         bool shouldStopUnwinding = visitor->callerIsEntryFrame();
         if (shouldStopUnwinding)
             return StackVisitor::Done;
 
+        m_returnPC = m_callFrame->returnPC().value();
         return StackVisitor::Continue;
     }
 
 private:
     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor& visitor) const
@@ -602,10 +606,11 @@
     VM& m_vm;
     CallFrame*& m_callFrame;
     bool m_isTermination;
     CodeBlock*& m_codeBlock;
     HandlerInfo*& m_handler;
+    mutable const void* m_returnPC { nullptr };
 };
 
 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM& vm, CallFrame*& callFrame, Exception* exception)
 {
     auto scope = DECLARE_CATCH_SCOPE(vm);
@@ -624,20 +629,20 @@
     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 
     // Calculate an exception handler vPC, unwinding call frames as necessary.
     HandlerInfo* handler = nullptr;
     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
-    StackVisitor::visit<StackVisitor::TerminateIfTopEntryFrameIsEmpty>(callFrame, &vm, functor);
+    StackVisitor::visit<StackVisitor::TerminateIfTopEntryFrameIsEmpty>(callFrame, vm, functor);
     if (!handler)
         return nullptr;
 
     return handler;
 }
 
-void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM& vm, CallFrame* callFrame, Exception* exception)
+void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM& vm, JSGlobalObject* globalObject, CallFrame* callFrame, Exception* exception)
 {
-    Debugger* debugger = vm.vmEntryGlobalObject(callFrame)->debugger();
+    Debugger* debugger = globalObject->debugger();
     if (debugger && debugger->needsExceptionCallbacks() && !exception->didNotifyInspectorOfThrow()) {
         // This code assumes that if the debugger is enabled then there is no inlining.
         // If that assumption turns out to be false then we'll ignore the inlined call
         // frames.
         // https://bugs.webkit.org/show_bug.cgi?id=121754
@@ -646,55 +651,56 @@
         bool isTermination = isTerminatedExecutionException(vm, exception);
         if (isTermination)
             hasCatchHandler = false;
         else {
             GetCatchHandlerFunctor functor;
-            StackVisitor::visit(callFrame, &vm, functor);
+            StackVisitor::visit(callFrame, vm, functor);
             HandlerInfo* handler = functor.handler();
             ASSERT(!handler || handler->isCatchHandler());
             hasCatchHandler = !!handler;
         }
 
-        debugger->exception(callFrame, exception->value(), hasCatchHandler);
+        debugger->exception(globalObject, callFrame, exception->value(), hasCatchHandler);
     }
     exception->setDidNotifyInspectorOfThrow();
 }
 
-JSValue Interpreter::executeProgram(const SourceCode& source, CallFrame* callFrame, JSObject* thisObj)
+JSValue Interpreter::executeProgram(const SourceCode& source, JSGlobalObject*, JSObject* thisObj)
 {
     JSScope* scope = thisObj->globalObject()->globalScope();
     VM& vm = scope->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
+    JSGlobalObject* globalObject = scope->globalObject(vm);
+    JSCallee* globalCallee = globalObject->globalCallee();
 
-    ProgramExecutable* program = ProgramExecutable::create(callFrame, source);
+    ProgramExecutable* program = ProgramExecutable::create(globalObject, source);
     EXCEPTION_ASSERT(throwScope.exception() || program);
     RETURN_IF_EXCEPTION(throwScope, { });
 
     throwScope.assertNoException();
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
     if (vm.isCollectorBusyOnCurrentThread())
         return jsNull();
 
     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
-        return checkedReturn(throwStackOverflowError(callFrame, throwScope));
+        return checkedReturn(throwStackOverflowError(globalObject, throwScope));
 
     // First check if the "program" is actually just a JSON object. If so,
     // we'll handle the JSON object here. Else, we'll handle real JS code
     // below at failedJSONP.
 
-    JSGlobalObject* globalObject = scope->globalObject(vm);
     Vector<JSONPData> JSONPData;
     bool parseResult;
     StringView programSource = program->source().view();
     if (programSource.isNull())
         return jsUndefined();
     if (programSource.is8Bit()) {
-        LiteralParser<LChar> literalParser(callFrame, programSource.characters8(), programSource.length(), JSONP);
+        LiteralParser<LChar> literalParser(globalObject, programSource.characters8(), programSource.length(), JSONP);
         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject->globalObjectMethodTable()->supportsRichSourceInfo(globalObject));
     } else {
-        LiteralParser<UChar> literalParser(callFrame, programSource.characters16(), programSource.length(), JSONP);
+        LiteralParser<UChar> literalParser(globalObject, programSource.characters16(), programSource.length(), JSONP);
         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject->globalObjectMethodTable()->supportsRichSourceInfo(globalObject));
     }
 
     RETURN_IF_EXCEPTION(throwScope, { });
     if (parseResult) {
@@ -702,14 +708,14 @@
         for (unsigned entry = 0; entry < JSONPData.size(); entry++) {
             Vector<JSONPPathEntry> JSONPPath;
             JSONPPath.swap(JSONPData[entry].m_path);
             JSValue JSONPValue = JSONPData[entry].m_value.get();
             if (JSONPPath.size() == 1 && JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
-                globalObject->addVar(callFrame, JSONPPath[0].m_pathEntryName);
+                globalObject->addVar(globalObject, JSONPPath[0].m_pathEntryName);
                 RETURN_IF_EXCEPTION(throwScope, { });
                 PutPropertySlot slot(globalObject);
-                globalObject->methodTable(vm)->put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);
+                globalObject->methodTable(vm)->put(globalObject, globalObject, JSONPPath[0].m_pathEntryName, JSONPValue, slot);
                 RETURN_IF_EXCEPTION(throwScope, { });
                 result = jsUndefined();
                 continue;
             }
             JSValue baseObject(globalObject);
@@ -720,12 +726,12 @@
                     if (i == 0) {
                         RELEASE_ASSERT(baseObject == globalObject);
 
                         auto doGet = [&] (JSSegmentedVariableObject* scope) {
                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
-                            if (scope->getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot))
-                                return slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);
+                            if (scope->getPropertySlot(globalObject, JSONPPath[i].m_pathEntryName, slot))
+                                return slot.getValue(globalObject, JSONPPath[i].m_pathEntryName);
                             return JSValue();
                         };
 
                         JSValue result = doGet(globalObject->globalLexicalEnvironment());
                         RETURN_IF_EXCEPTION(throwScope, JSValue());
@@ -740,20 +746,20 @@
                             baseObject = result;
                             continue;
                         }
 
                         if (entry)
-                            return throwException(callFrame, throwScope, createUndefinedVariableError(callFrame, JSONPPath[i].m_pathEntryName));
+                            return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, JSONPPath[i].m_pathEntryName));
                         goto failedJSONP;
                     }
 
-                    baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);
+                    baseObject = baseObject.get(globalObject, JSONPPath[i].m_pathEntryName);
                     RETURN_IF_EXCEPTION(throwScope, JSValue());
                     continue;
                 }
                 case JSONPPathEntryTypeLookup: {
-                    baseObject = baseObject.get(callFrame, static_cast<unsigned>(JSONPPath[i].m_pathIndex));
+                    baseObject = baseObject.get(globalObject, static_cast<unsigned>(JSONPPath[i].m_pathIndex));
                     RETURN_IF_EXCEPTION(throwScope, JSValue());
                     continue;
                 }
                 default:
                     RELEASE_ASSERT_NOT_REACHED();
@@ -762,39 +768,39 @@
             }
 
             if (JSONPPath.size() == 1 && JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
                 RELEASE_ASSERT(baseObject == globalObject);
                 JSGlobalLexicalEnvironment* scope = globalObject->globalLexicalEnvironment();
-                if (scope->hasProperty(callFrame, JSONPPath.last().m_pathEntryName))
+                if (scope->hasProperty(globalObject, JSONPPath.last().m_pathEntryName))
                     baseObject = scope;
                 RETURN_IF_EXCEPTION(throwScope, JSValue());
             }
 
             PutPropertySlot slot(baseObject);
             switch (JSONPPath.last().m_type) {
             case JSONPPathEntryTypeCall: {
-                JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);
+                JSValue function = baseObject.get(globalObject, JSONPPath.last().m_pathEntryName);
                 RETURN_IF_EXCEPTION(throwScope, JSValue());
                 CallData callData;
                 CallType callType = getCallData(vm, function, callData);
                 if (callType == CallType::None)
-                    return throwException(callFrame, throwScope, createNotAFunctionError(callFrame, function));
+                    return throwException(globalObject, throwScope, createNotAFunctionError(globalObject, function));
                 MarkedArgumentBuffer jsonArg;
                 jsonArg.append(JSONPValue);
                 ASSERT(!jsonArg.hasOverflowed());
                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
-                JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);
+                JSONPValue = JSC::call(globalObject, function, callType, callData, thisValue, jsonArg);
                 RETURN_IF_EXCEPTION(throwScope, JSValue());
                 break;
             }
             case JSONPPathEntryTypeDot: {
-                baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);
+                baseObject.put(globalObject, JSONPPath.last().m_pathEntryName, JSONPValue, slot);
                 RETURN_IF_EXCEPTION(throwScope, JSValue());
                 break;
             }
             case JSONPPathEntryTypeLookup: {
-                baseObject.putByIndex(callFrame, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());
+                baseObject.putByIndex(globalObject, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());
                 RETURN_IF_EXCEPTION(throwScope, JSValue());
                 break;
             }
             default:
                 RELEASE_ASSERT_NOT_REACHED();
@@ -809,14 +815,14 @@
     // object.
 
     VMEntryScope entryScope(vm, globalObject);
 
     // Compile source to bytecode if necessary:
-    JSObject* error = program->initializeGlobalProperties(vm, callFrame, scope);
+    JSObject* error = program->initializeGlobalProperties(vm, globalObject, scope);
     EXCEPTION_ASSERT(!throwScope.exception() || !error);
     if (UNLIKELY(error))
-        return checkedReturn(throwException(callFrame, throwScope, error));
+        return checkedReturn(throwException(globalObject, throwScope, error));
 
     ProgramCodeBlock* codeBlock;
     {
         CodeBlock* tempCodeBlock;
         Exception* error = program->prepareForExecution<ProgramExecutable>(vm, nullptr, scope, CodeForCall, tempCodeBlock);
@@ -824,33 +830,33 @@
         if (UNLIKELY(error))
             return checkedReturn(error);
         codeBlock = jsCast<ProgramCodeBlock*>(tempCodeBlock);
     }
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(callFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
     }
 
     if (scope->structure(vm)->isUncacheableDictionary())
         scope->flattenDictionaryObject(vm);
 
     ASSERT(codeBlock->numParameters() == 1); // 1 parameter for 'this'.
 
     ProtoCallFrame protoCallFrame;
-    protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);
+    protoCallFrame.init(codeBlock, globalObject, globalCallee, thisObj, 1);
 
     // Execute the code:
     throwScope.release();
     JSValue result = program->generatedJITCode()->execute(&vm, &protoCallFrame);
     return checkedReturn(result);
 }
 
-JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
+JSValue Interpreter::executeCall(JSGlobalObject* lexicalGlobalObject, JSObject* function, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
 {
-    VM& vm = callFrame->vm();
+    VM& vm = lexicalGlobalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     throwScope.assertNoException();
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     if (vm.isCollectorBusyOnCurrentThread())
@@ -870,12 +876,12 @@
         ASSERT(callType == CallType::Host);
         globalObject = function->globalObject(vm);
     }
 
     VMEntryScope entryScope(vm, globalObject);
-    if (UNLIKELY(!vm.isSafeToRecurseSoft()))
-        return checkedReturn(throwStackOverflowError(callFrame, throwScope));
+    if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() > maxArguments))
+        return checkedReturn(throwStackOverflowError(globalObject, throwScope));
 
     if (isJSCall) {
         // Compile the callee:
         Exception* compileError = callData.js.functionExecutable->prepareForExecution<FunctionExecutable>(vm, jsCast<JSFunction*>(function), scope, CodeForCall, newCodeBlock);
         EXCEPTION_ASSERT(throwScope.exception() == compileError);
@@ -885,18 +891,18 @@
         ASSERT(!!newCodeBlock);
         newCodeBlock->m_shouldAlwaysBeInlined = false;
     } else
         newCodeBlock = 0;
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(callFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
     }
 
     ProtoCallFrame protoCallFrame;
-    protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());
+    protoCallFrame.init(newCodeBlock, globalObject, function, thisValue, argsCount, args.data());
 
     JSValue result;
     {
         // Execute the code:
         if (isJSCall) {
@@ -909,21 +915,21 @@
     }
 
     return checkedReturn(result);
 }
 
-JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData& constructData, const ArgList& args, JSValue newTarget)
+JSObject* Interpreter::executeConstruct(JSGlobalObject* lexicalGlobalObject, JSObject* constructor, ConstructType constructType, const ConstructData& constructData, const ArgList& args, JSValue newTarget)
 {
-    VM& vm = callFrame->vm();
+    VM& vm = lexicalGlobalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
     throwScope.assertNoException();
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     // We throw in this case because we have to return something "valid" but we're
     // already in an invalid state.
     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
-        throwStackOverflowError(callFrame, throwScope);
+        throwStackOverflowError(lexicalGlobalObject, throwScope);
         return nullptr;
     }
 
     bool isJSConstruct = (constructType == ConstructType::JS);
     JSScope* scope = nullptr;
@@ -939,12 +945,12 @@
         ASSERT(constructType == ConstructType::Host);
         globalObject = constructor->globalObject(vm);
     }
 
     VMEntryScope entryScope(vm, globalObject);
-    if (UNLIKELY(!vm.isSafeToRecurseSoft())) {
-        throwStackOverflowError(callFrame, throwScope);
+    if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() > maxArguments)) {
+        throwStackOverflowError(globalObject, throwScope);
         return nullptr;
     }
 
     if (isJSConstruct) {
         // Compile the callee:
@@ -956,18 +962,18 @@
         ASSERT(!!newCodeBlock);
         newCodeBlock->m_shouldAlwaysBeInlined = false;
     } else
         newCodeBlock = 0;
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(callFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, nullptr);
     }
 
     ProtoCallFrame protoCallFrame;
-    protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());
+    protoCallFrame.init(newCodeBlock, globalObject, constructor, newTarget, argsCount, args.data());
 
     JSValue result;
     {
         // Execute the code.
         if (isJSConstruct)
@@ -1002,39 +1008,40 @@
         return CallFrameClosure();
     newCodeBlock->m_shouldAlwaysBeInlined = false;
 
     size_t argsCount = argumentCountIncludingThis;
 
-    protoCallFrame->init(newCodeBlock, function, jsUndefined(), argsCount, args.data());
+    protoCallFrame->init(newCodeBlock, function->globalObject(), function, jsUndefined(), argsCount, args.data());
     // Return the successful closure:
     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &vm, scope, newCodeBlock->numParameters(), argumentCountIncludingThis };
     return result;
 }
 
-JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)
+JSValue Interpreter::execute(EvalExecutable* eval, JSGlobalObject* lexicalGlobalObject, JSValue thisValue, JSScope* scope)
 {
     VM& vm = scope->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
-    ASSERT(&vm == &callFrame->vm());
+    ASSERT_UNUSED(lexicalGlobalObject, &vm == &lexicalGlobalObject->vm());
     throwScope.assertNoException();
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
     if (vm.isCollectorBusyOnCurrentThread())
         return jsNull();
 
-    VMEntryScope entryScope(vm, scope->globalObject(vm));
+    JSGlobalObject* globalObject = scope->globalObject(vm);
+    VMEntryScope entryScope(vm, globalObject);
     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
-        return checkedReturn(throwStackOverflowError(callFrame, throwScope));
+        return checkedReturn(throwStackOverflowError(globalObject, throwScope));
 
     unsigned numVariables = eval->numVariables();
     unsigned numTopLevelFunctionDecls = eval->numTopLevelFunctionDecls();
     unsigned numFunctionHoistingCandidates = eval->numFunctionHoistingCandidates();
 
     JSScope* variableObject;
     if ((numVariables || numTopLevelFunctionDecls) && eval->isStrictMode()) {
-        scope = StrictEvalActivation::create(vm, callFrame->lexicalGlobalObject()->strictEvalActivationStructure(), scope);
+        scope = StrictEvalActivation::create(vm, globalObject->strictEvalActivationStructure(), scope);
         variableObject = scope;
     } else {
         for (JSScope* node = scope; ; node = node->next()) {
             RELEASE_ASSERT(node);
             if (node->isGlobalObject()) {
@@ -1066,20 +1073,20 @@
     if (variableObject->isGlobalObject() && !eval->isStrictMode() && (numVariables || numTopLevelFunctionDecls)) {
         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast<JSGlobalObject*>(variableObject)->globalLexicalEnvironment();
         for (unsigned i = 0; i < numVariables; ++i) {
             const Identifier& ident = unlinkedCodeBlock->variable(i);
             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
-            if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {
-                return checkedReturn(throwTypeError(callFrame, throwScope, makeString("Can't create duplicate global variable in eval: '", String(ident.impl()), "'")));
+            if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, ident, slot)) {
+                return checkedReturn(throwTypeError(globalObject, throwScope, makeString("Can't create duplicate global variable in eval: '", String(ident.impl()), "'")));
             }
         }
 
         for (unsigned i = 0; i < numTopLevelFunctionDecls; ++i) {
             FunctionExecutable* function = codeBlock->functionDecl(i);
             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
-            if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, function->name(), slot)) {
-                return checkedReturn(throwTypeError(callFrame, throwScope, makeString("Can't create duplicate global variable in eval: '", String(function->name().impl()), "'")));
+            if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, function->name(), slot)) {
+                return checkedReturn(throwTypeError(globalObject, throwScope, makeString("Can't create duplicate global variable in eval: '", String(function->name().impl()), "'")));
             }
         }
     }
 
     if (variableObject->structure(vm)->isUncacheableDictionary())
@@ -1090,92 +1097,98 @@
         if (variableObject->next() && !eval->isStrictMode())
             variableObject->globalObject(vm)->varInjectionWatchpoint()->fireAll(vm, "Executed eval, fired VarInjection watchpoint");
 
         for (unsigned i = 0; i < numVariables; ++i) {
             const Identifier& ident = unlinkedCodeBlock->variable(i);
-            bool hasProperty = variableObject->hasProperty(callFrame, ident);
+            bool hasProperty = variableObject->hasProperty(globalObject, ident);
             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
             if (!hasProperty) {
                 PutPropertySlot slot(variableObject);
-                if (!variableObject->isExtensible(callFrame))
-                    return checkedReturn(throwTypeError(callFrame, throwScope, NonExtensibleObjectPropertyDefineError));
-                variableObject->methodTable(vm)->put(variableObject, callFrame, ident, jsUndefined(), slot);
+                if (!variableObject->isExtensible(globalObject))
+                    return checkedReturn(throwTypeError(globalObject, throwScope, NonExtensibleObjectPropertyDefineError));
+                variableObject->methodTable(vm)->put(variableObject, globalObject, ident, jsUndefined(), slot);
                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
             }
         }
 
         if (eval->isStrictMode()) {
             for (unsigned i = 0; i < numTopLevelFunctionDecls; ++i) {
                 FunctionExecutable* function = codeBlock->functionDecl(i);
                 PutPropertySlot slot(variableObject);
                 // We need create this variables because it will be used to emits code by bytecode generator
-                variableObject->methodTable(vm)->put(variableObject, callFrame, function->name(), jsUndefined(), slot);
+                variableObject->methodTable(vm)->put(variableObject, globalObject, function->name(), jsUndefined(), slot);
                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
             }
         } else {
             for (unsigned i = 0; i < numTopLevelFunctionDecls; ++i) {
                 FunctionExecutable* function = codeBlock->functionDecl(i);
-                JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, function->name());
+                JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, function->name());
                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                 if (resolvedScope.isUndefined())
-                    return checkedReturn(throwSyntaxError(callFrame, throwScope, makeString("Can't create duplicate variable in eval: '", String(function->name().impl()), "'")));
+                    return checkedReturn(throwSyntaxError(globalObject, throwScope, makeString("Can't create duplicate variable in eval: '", String(function->name().impl()), "'")));
                 PutPropertySlot slot(variableObject);
                 // We need create this variables because it will be used to emits code by bytecode generator
-                variableObject->methodTable(vm)->put(variableObject, callFrame, function->name(), jsUndefined(), slot);
+                variableObject->methodTable(vm)->put(variableObject, globalObject, function->name(), jsUndefined(), slot);
                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
             }
 
             for (unsigned i = 0; i < numFunctionHoistingCandidates; ++i) {
                 const Identifier& ident = unlinkedCodeBlock->functionHoistingCandidate(i);
-                JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, ident);
+                JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);
                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                 if (!resolvedScope.isUndefined()) {
-                    bool hasProperty = variableObject->hasProperty(callFrame, ident);
+                    bool hasProperty = variableObject->hasProperty(globalObject, ident);
                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                     if (!hasProperty) {
                         PutPropertySlot slot(variableObject);
-                        variableObject->methodTable(vm)->put(variableObject, callFrame, ident, jsUndefined(), slot);
+                        variableObject->methodTable(vm)->put(variableObject, globalObject, ident, jsUndefined(), slot);
                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                     }
                 }
             }
         }
     }
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(callFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
     }
 
     ASSERT(codeBlock->numParameters() == 1); // 1 parameter for 'this'.
 
+    JSCallee* callee = nullptr;
+    if (scope == globalObject->globalScope())
+        callee = globalObject->globalCallee();
+    else
+        callee = JSCallee::create(vm, globalObject, scope);
     ProtoCallFrame protoCallFrame;
-    protoCallFrame.init(codeBlock, JSCallee::create(vm, scope->globalObject(vm), scope), thisValue, 1);
+    protoCallFrame.init(codeBlock, globalObject, callee, thisValue, 1);
 
     // Execute the code:
     throwScope.release();
     JSValue result = eval->generatedJITCode()->execute(&vm, &protoCallFrame);
 
     return checkedReturn(result);
 }
 
-JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)
+JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, JSGlobalObject* lexicalGlobalObject, JSModuleEnvironment* scope)
 {
     VM& vm = scope->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
-    ASSERT(&vm == &callFrame->vm());
+    ASSERT_UNUSED(lexicalGlobalObject, &vm == &lexicalGlobalObject->vm());
     throwScope.assertNoException();
     ASSERT(!vm.isCollectorBusyOnCurrentThread());
     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
     if (vm.isCollectorBusyOnCurrentThread())
         return jsNull();
 
+    JSGlobalObject* globalObject = scope->globalObject(vm);
     VMEntryScope entryScope(vm, scope->globalObject(vm));
     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
-        return checkedReturn(throwStackOverflowError(callFrame, throwScope));
+        return checkedReturn(throwStackOverflowError(globalObject, throwScope));
 
     ModuleProgramCodeBlock* codeBlock;
     {
         CodeBlock* tempCodeBlock;
         Exception* compileError = executable->prepareForExecution<ModuleProgramExecutable>(vm, nullptr, scope, CodeForCall, tempCodeBlock);
@@ -1183,13 +1196,13 @@
         if (UNLIKELY(!!compileError))
             return checkedReturn(compileError);
         codeBlock = jsCast<ModuleProgramCodeBlock*>(tempCodeBlock);
     }
 
-    VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);
-    if (UNLIKELY(vm.needTrapHandling(mask))) {
-        vm.handleTraps(callFrame, mask);
+    constexpr auto trapsMask = VMTraps::interruptingTraps();
+    if (UNLIKELY(vm.needTrapHandling(trapsMask))) {
+        vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);
         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
     }
 
     if (scope->structure(vm)->isUncacheableDictionary())
         scope->flattenDictionaryObject(vm);
@@ -1198,24 +1211,24 @@
 
     // The |this| of the module is always `undefined`.
     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
     ProtoCallFrame protoCallFrame;
-    protoCallFrame.init(codeBlock, JSCallee::create(vm, scope->globalObject(vm), scope), jsUndefined(), 1);
+    protoCallFrame.init(codeBlock, globalObject, JSCallee::create(vm, globalObject, scope), jsUndefined(), 1);
 
     // Execute the code:
     throwScope.release();
     JSValue result = executable->generatedJITCode()->execute(&vm, &protoCallFrame);
 
     return checkedReturn(result);
 }
 
 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
 {
-    VM& vm = callFrame->vm();
+    VM& vm = callFrame->deprecatedVM();
     auto scope = DECLARE_CATCH_SCOPE(vm);
-    Debugger* debugger = vm.vmEntryGlobalObject(callFrame)->debugger();
+    Debugger* debugger = callFrame->lexicalGlobalObject(vm)->debugger();
     if (!debugger)
         return;
 
     ASSERT(callFrame->codeBlock()->hasDebuggerRequests());
     scope.assertNoException();
@@ -1237,12 +1250,12 @@
             debugger->willExecuteProgram(callFrame);
             break;
         case DidExecuteProgram:
             debugger->didExecuteProgram(callFrame);
             break;
-        case DidReachBreakpoint:
-            debugger->didReachBreakpoint(callFrame);
+        case DidReachDebuggerStatement:
+            debugger->didReachDebuggerStatement(callFrame);
             break;
     }
     scope.assertNoException();
 }
 
@@ -1260,12 +1273,12 @@
         out.print("DidExecuteProgram");
         return;
     case JSC::DidEnterCallFrame:
         out.print("DidEnterCallFrame");
         return;
-    case JSC::DidReachBreakpoint:
-        out.print("DidReachBreakpoint");
+    case JSC::DidReachDebuggerStatement:
+        out.print("DidReachDebuggerStatement");
         return;
     case JSC::WillLeaveCallFrame:
         out.print("WillLeaveCallFrame");
         return;
     case JSC::WillExecuteStatement:

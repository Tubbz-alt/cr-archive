<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebMediaSessionManager.h&quot;
 28 
 29 #if ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MediaPlaybackTargetPickerMock.h&quot;
 34 #include &quot;WebMediaSessionManagerClient.h&quot;
 35 #include &lt;wtf/Algorithms.h&gt;
 36 #include &lt;wtf/Logger.h&gt;
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 static const Seconds taskDelayInterval { 100_ms };
 42 
 43 #undef LOGIDENTIFIER
 44 #define LOGIDENTIFIER __func__
 45 
 46 #undef ALWAYS_LOG
 47 #define ALWAYS_LOG logger().logAlways
 48 
 49 struct ClientState {
 50     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 51 
 52     explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
 53         : client(client)
 54         , contextId(contextId)
 55     {
 56     }
 57 
 58     bool operator == (ClientState const&amp; other) const
 59     {
 60         return contextId == other.contextId &amp;&amp; &amp;client == &amp;other.client;
 61     }
 62 
 63     WebMediaSessionManagerClient&amp; client;
 64     uint64_t contextId { 0 };
 65     WebCore::MediaProducer::MediaStateFlags flags { WebCore::MediaProducer::IsNotPlaying };
 66     bool requestedPicker { false };
 67     bool previouslyRequestedPicker { false };
 68     bool configurationRequired { true };
 69     bool playedToEnd { false };
 70 };
 71 
 72 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 73 {
 74     return value &amp; flags;
 75 }
 76 
 77 String mediaProducerStateString(MediaProducer::MediaStateFlags flags)
 78 {
 79     StringBuilder string;
 80     if (flags &amp; MediaProducer::IsPlayingAudio)
 81         string.append(&quot;IsPlayingAudio+&quot;);
 82     if (flags &amp; MediaProducer::IsPlayingVideo)
 83         string.append(&quot;IsPlayingVideo+&quot;);
 84     if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
 85         string.append(&quot;IsPlayingToExternalDevice+&quot;);
 86     if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
 87         string.append(&quot;HasTargetAvailabilityListener+&quot;);
 88     if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
 89         string.append(&quot;RequiresTargetMonitoring+&quot;);
 90     if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
 91         string.append(&quot;ExternalDeviceAutoPlayCandidate+&quot;);
 92     if (flags &amp; MediaProducer::DidPlayToEnd)
 93         string.append(&quot;DidPlayToEnd+&quot;);
 94     if (flags &amp; MediaProducer::HasAudioOrVideo)
 95         string.append(&quot;HasAudioOrVideo+&quot;);
 96     if (string.isEmpty())
 97         string.append(&quot;IsNotPlaying&quot;);
 98     else
 99         string.resize(string.length() - 1);
100 
101     return makeString(&quot; { &quot;, string.toString(), &quot; }&quot;);
102 }
103 
104 class WebMediaSessionLogger {
105     WTF_MAKE_NONCOPYABLE(WebMediaSessionLogger);
106     WTF_MAKE_FAST_ALLOCATED;
107 public:
108 
109     static std::unique_ptr&lt;WebMediaSessionLogger&gt; create(WebMediaSessionManager&amp; manager)
110     {
111         return makeUnique&lt;WebMediaSessionLogger&gt;(manager);
112     }
113 
114     template&lt;typename... Arguments&gt;
115     inline void logAlways(const char* methodName, ClientState* state, const Arguments&amp;... arguments) const
116     {
117         if (!state-&gt;client.alwaysOnLoggingAllowed())
118             return;
119 
120         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), state-&gt;contextId, state-&gt;flags, arguments...);
121     }
122 
123     template&lt;typename... Arguments&gt;
124     inline void logAlways(const char* methodName, const Arguments&amp;... arguments) const
125     {
126         if (!m_manager.alwaysOnLoggingAllowed())
127             return;
128 
129         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), arguments...);
130     }
131 
132 private:
133     friend std::unique_ptr&lt;WebMediaSessionLogger&gt; std::make_unique&lt;WebMediaSessionLogger&gt;(WebMediaSessionManager&amp;);
134     WebMediaSessionLogger(WebMediaSessionManager&amp; manager)
135         : m_manager(manager)
136         , m_logger(Logger::create(this))
137     {
138     }
139 
140     WebMediaSessionManager&amp; m_manager;
141     Ref&lt;Logger&gt; m_logger;
142 };
143 
144 WebMediaSessionLogger&amp; WebMediaSessionManager::logger()
145 {
146     if (!m_logger)
147         m_logger = WebMediaSessionLogger::create(*this);
148 
149     return *m_logger;
150 }
151 
152 bool WebMediaSessionManager::alwaysOnLoggingAllowed() const
153 {
154     return allOf(m_clientState, [] (auto&amp; state) {
155         return state-&gt;client.alwaysOnLoggingAllowed();
156     });
157 }
158 
159 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
160 {
161     if (m_mockPickerEnabled == enabled)
162         return;
163 
164     ALWAYS_LOG(LOGIDENTIFIER);
165     m_mockPickerEnabled = enabled;
166 }
167 
168 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
169 {
170     ALWAYS_LOG(LOGIDENTIFIER);
171     mockPicker().setState(name, state);
172 }
173 
174 void WebMediaSessionManager::mockMediaPlaybackTargetPickerDismissPopup()
175 {
176     ALWAYS_LOG(LOGIDENTIFIER);
177     mockPicker().dismissPopup();
178 }
179 
180 MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
181 {
182     if (!m_pickerOverride)
183         m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
184 
185     return *m_pickerOverride.get();
186 }
187 
188 WebCore::MediaPlaybackTargetPicker&amp; WebMediaSessionManager::targetPicker()
189 {
190     if (m_mockPickerEnabled)
191         return mockPicker();
192 
193     return platformPicker();
194 }
195 
196 WebMediaSessionManager::WebMediaSessionManager()
197     : m_taskTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::taskTimerFired)
198     , m_watchdogTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::watchdogTimerFired)
199 {
200 }
201 
202 WebMediaSessionManager::~WebMediaSessionManager() = default;
203 
204 uint64_t WebMediaSessionManager::addPlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
205 {
206     size_t index = find(&amp;client, contextId);
207     ASSERT(index == notFound);
208     if (index != notFound)
209         return 0;
210 
211     ALWAYS_LOG(LOGIDENTIFIER, contextId);
212     m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
213 
214     if (m_externalOutputDeviceAvailable || m_playbackTarget)
215         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
216 
217     return contextId;
218 }
219 
220 void WebMediaSessionManager::removePlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
221 {
222     size_t index = find(&amp;client, contextId);
223     ASSERT(index != notFound);
224     if (index == notFound)
225         return;
226 
227     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());
228 
229     m_clientState.remove(index);
230     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
231 }
232 
233 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
234 {
235     if (m_clientState.isEmpty())
236         return;
237 
238     for (size_t i = m_clientState.size(); i &gt; 0; --i) {
239         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client) {
240             ALWAYS_LOG(LOGIDENTIFIER, m_clientState[i - 1].get());
241             m_clientState.remove(i - 1);
242         }
243     }
244     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
245 }
246 
247 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
248 {
249     size_t index = find(&amp;client, contextId);
250     ASSERT(index != notFound);
251     if (index == notFound)
252         return;
253 
254     auto&amp; clientRequestingPicker = m_clientState[index];
255     for (auto&amp; state : m_clientState) {
256         state-&gt;requestedPicker = state == clientRequestingPicker;
257         state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
258     }
259 
260     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());
261 
262     bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
263     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
264 }
265 
266 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
267 {
268     size_t index = find(&amp;client, contextId);
269     ASSERT(index != notFound);
270     if (index == notFound)
271         return;
272 
273     auto&amp; changedClientState = m_clientState[index];
274     MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
275     if (newFlags == oldFlags)
276         return;
277 
278     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get(), &quot;new flags = &quot;, newFlags);
279 
280     changedClientState-&gt;flags = newFlags;
281 
282     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
283     if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
284         scheduleDelayedTask(TargetMonitoringConfigurationTask);
285 
286     MediaProducer::MediaStateFlags playingToTargetFlags = MediaProducer::IsPlayingToExternalDevice | MediaProducer::IsPlayingVideo;
287     if ((oldFlags &amp; playingToTargetFlags) != (newFlags &amp; playingToTargetFlags)) {
288         if (flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo) &amp;&amp; !flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) &amp;&amp; flagsAreSet(newFlags, MediaProducer::DidPlayToEnd))
289             changedClientState-&gt;playedToEnd = true;
290         scheduleDelayedTask(WatchdogTimerConfigurationTask);
291     }
292 
293     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute() || !flagsAreSet(newFlags, MediaProducer::ExternalDeviceAutoPlayCandidate))
294         return;
295 
296     // Do not interrupt another element already playing to a device.
297     for (auto&amp; state : m_clientState) {
298         if (state == changedClientState)
299             continue;
300 
301         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo)) {
302             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; returning early&quot;);
303             return;
304         }
305     }
306 
307     // Do not begin playing to the device unless playback has just started.
308     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo)) {
309         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning early, playback didn&#39;t just start&quot;);
310         return;
311     }
312 
313     for (auto&amp; state : m_clientState) {
314         if (state == changedClientState)
315             continue;
316         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);
317         state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
318     }
319 
320     ALWAYS_LOG(LOGIDENTIFIER, changedClientState.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);
321     changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
322 
323     if (index &amp;&amp; m_clientState.size() &gt; 1)
324         std::swap(m_clientState.at(index), m_clientState.at(0));
325 }
326 
327 void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
328 {
329     ALWAYS_LOG(LOGIDENTIFIER, &quot;has active route = &quot;, target-&gt;hasActiveRoute());
330     m_playbackTarget = WTFMove(target);
331     m_targetChanged = true;
332     scheduleDelayedTask(TargetClientsConfigurationTask);
333 }
334 
335 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
336 {
337     ALWAYS_LOG(LOGIDENTIFIER, available);
338     m_externalOutputDeviceAvailable = available;
339     for (auto&amp; state : m_clientState)
340         state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
341 }
342 
343 void WebMediaSessionManager::playbackTargetPickerWasDismissed()
344 {
345     ALWAYS_LOG(LOGIDENTIFIER);
346     m_playbackTargetPickerDismissed = true;
347     scheduleDelayedTask(TargetClientsConfigurationTask);
348 }
349 
350 void WebMediaSessionManager::configureNewClients()
351 {
352     for (auto&amp; state : m_clientState) {
353         if (!state-&gt;configurationRequired)
354             continue;
355 
356         state-&gt;configurationRequired = false;
357         if (m_externalOutputDeviceAvailable)
358             state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, true);
359 
360         if (m_playbackTarget)
361             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
362     }
363 }
364 
365 void WebMediaSessionManager::configurePlaybackTargetClients()
366 {
367     if (m_clientState.isEmpty())
368         return;
369 
370     size_t indexOfClientThatRequestedPicker = notFound;
371     size_t indexOfLastClientToRequestPicker = notFound;
372     size_t indexOfClientWillPlayToTarget = notFound;
373     bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
374 
375     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
376         auto&amp; state = m_clientState[i];
377 
378         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot;, requestedPicker = &quot;, state-&gt;requestedPicker);
379 
380         if ((m_targetChanged || m_playbackTargetPickerDismissed) &amp;&amp; state-&gt;requestedPicker)
381             indexOfClientThatRequestedPicker = i;
382 
383         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
384             indexOfClientWillPlayToTarget = i;
385 
386         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; state-&gt;previouslyRequestedPicker)
387             indexOfLastClientToRequestPicker = i;
388     }
389 
390     if (indexOfClientThatRequestedPicker != notFound)
391         indexOfClientWillPlayToTarget = indexOfClientThatRequestedPicker;
392     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
393         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
394     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
395         indexOfClientWillPlayToTarget = 0;
396 
397     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
398         auto&amp; state = m_clientState[i];
399 
400         if (m_playbackTarget)
401             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
402 
403         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute) {
404             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);
405             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
406         }
407 
408         if (state-&gt;requestedPicker &amp;&amp; m_playbackTargetPickerDismissed) {
409             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling playbackTargetPickerWasDismissed&quot;);
410             state-&gt;client.playbackTargetPickerWasDismissed(state-&gt;contextId);
411         }
412 
413         state-&gt;configurationRequired = false;
414         if (m_targetChanged || m_playbackTargetPickerDismissed)
415             state-&gt;requestedPicker = false;
416     }
417 
418     if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
419         auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
420         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice)) {
421             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);
422             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
423         }
424     }
425 
426     m_targetChanged = false;
427     configureWatchdogTimer();
428 }
429 
430 void WebMediaSessionManager::configurePlaybackTargetMonitoring()
431 {
432     bool monitoringRequired = false;
433     bool hasAvailabilityListener = false;
434     bool haveClientWithMedia = false;
435     for (auto&amp; state : m_clientState) {
436         ALWAYS_LOG(LOGIDENTIFIER, state.get());
437         if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
438             monitoringRequired = true;
439             break;
440         }
441         if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
442             hasAvailabilityListener = true;
443         if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
444             haveClientWithMedia = true;
445     }
446 
447     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)) {
448         ALWAYS_LOG(LOGIDENTIFIER, &quot;starting monitoring&quot;);
449         targetPicker().startingMonitoringPlaybackTargets();
450     } else {
451         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping monitoring&quot;);
452         targetPicker().stopMonitoringPlaybackTargets();
453     }
454 }
455 
456 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
457 {
458     m_taskFlags |= tasks;
459     m_taskTimer.startOneShot(taskDelayInterval);
460 }
461 
462 void WebMediaSessionManager::taskTimerFired()
463 {
464     if (m_taskFlags &amp; InitialConfigurationTask)
465         configureNewClients();
466     if (m_taskFlags &amp; TargetClientsConfigurationTask)
467         configurePlaybackTargetClients();
468     if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
469         configurePlaybackTargetMonitoring();
470     if (m_taskFlags &amp; WatchdogTimerConfigurationTask)
471         configureWatchdogTimer();
472 
473     m_taskFlags = NoTask;
474 }
475 
476 size_t WebMediaSessionManager::find(WebMediaSessionManagerClient* client, uint64_t contextId)
477 {
478     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
479         if (m_clientState[i]-&gt;contextId == contextId &amp;&amp; &amp;m_clientState[i]-&gt;client == client)
480             return i;
481     }
482 
483     return notFound;
484 }
485 
486 void WebMediaSessionManager::configureWatchdogTimer()
487 {
488     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
489     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
490 
491     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
492         if (m_watchdogTimer.isActive()) {
493             ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);
494             m_currentWatchdogInterval = { };
495             m_watchdogTimer.stop();
496         }
497 
498         return;
499     }
500 
501     bool stopTimer = false;
502     bool didPlayToEnd = false;
503     for (auto&amp; state : m_clientState) {
504 
505         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; playedToEnd = &quot;, state-&gt;playedToEnd);
506 
507         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
508             stopTimer = true;
509         if (state-&gt;playedToEnd)
510             didPlayToEnd = true;
511         state-&gt;playedToEnd = false;
512     }
513 
514     if (stopTimer) {
515         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);
516         m_currentWatchdogInterval = { };
517         m_watchdogTimer.stop();
518     } else {
519         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
520         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
521             m_watchdogTimer.startOneShot(interval);
522         }
523         ALWAYS_LOG(LOGIDENTIFIER, &quot;timer scheduled for &quot;, interval.value(), &quot; seconds&quot;);
524         m_currentWatchdogInterval = interval;
525     }
526 }
527 
528 void WebMediaSessionManager::watchdogTimerFired()
529 {
530     if (!m_playbackTarget)
531         return;
532 
533     ALWAYS_LOG(LOGIDENTIFIER);
534     targetPicker().invalidatePlaybackTargets();
535 }
536 
537 } // namespace WebCore
538 
539 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
    </pre>
  </body>
</html>
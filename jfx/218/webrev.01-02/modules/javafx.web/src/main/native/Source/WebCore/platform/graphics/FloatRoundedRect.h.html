<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FloatRoundedRect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013 Adobe Systems Incorporated. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above
  9  *    copyright notice, this list of conditions and the following
 10  *    disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials
 14  *    provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 19  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 20  * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 21  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 23  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 24  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 25  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 26  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 27  * OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #ifndef FloatRoundedRect_h
 31 #define FloatRoundedRect_h
 32 
 33 #include &quot;FloatRect.h&quot;
 34 #include &quot;FloatSize.h&quot;
 35 #include &quot;RoundedRect.h&quot;
 36 
 37 namespace WebCore {
 38 
 39 class FloatRoundedRect {
 40     WTF_MAKE_FAST_ALLOCATED;
 41 public:
 42     class Radii {
 43     public:
 44         Radii() { }
 45         Radii(const FloatSize&amp; topLeft, const FloatSize&amp; topRight, const FloatSize&amp; bottomLeft, const FloatSize&amp; bottomRight)
 46             : m_topLeft(topLeft)
 47             , m_topRight(topRight)
 48             , m_bottomLeft(bottomLeft)
 49             , m_bottomRight(bottomRight)
 50         {
 51         }
 52 
 53         Radii(const RoundedRect::Radii&amp; intRadii)
 54             : m_topLeft(intRadii.topLeft())
 55             , m_topRight(intRadii.topRight())
 56             , m_bottomLeft(intRadii.bottomLeft())
 57             , m_bottomRight(intRadii.bottomRight())
 58         {
 59         }
 60 
 61         explicit Radii(float uniformRadius)
 62             : m_topLeft(uniformRadius, uniformRadius)
 63             , m_topRight(uniformRadius, uniformRadius)
 64             , m_bottomLeft(uniformRadius, uniformRadius)
 65             , m_bottomRight(uniformRadius, uniformRadius)
 66         {
 67         }
 68 
 69         void setTopLeft(const FloatSize&amp; size) { m_topLeft = size; }
 70         void setTopRight(const FloatSize&amp; size) { m_topRight = size; }
 71         void setBottomLeft(const FloatSize&amp; size) { m_bottomLeft = size; }
 72         void setBottomRight(const FloatSize&amp; size) { m_bottomRight = size; }
 73         const FloatSize&amp; topLeft() const { return m_topLeft; }
 74         const FloatSize&amp; topRight() const { return m_topRight; }
 75         const FloatSize&amp; bottomLeft() const { return m_bottomLeft; }
 76         const FloatSize&amp; bottomRight() const { return m_bottomRight; }
 77 
 78         bool isZero() const;
 79         bool isUniformCornerRadius() const; // Including no radius.
 80 
 81         void scale(float factor);
 82         void scale(float horizontalFactor, float verticalFactor);
 83         void expand(float topWidth, float bottomWidth, float leftWidth, float rightWidth);
 84         void expand(float size) { expand(size, size, size, size); }
 85         void shrink(float topWidth, float bottomWidth, float leftWidth, float rightWidth) { expand(-topWidth, -bottomWidth, -leftWidth, -rightWidth); }
 86         void shrink(float size) { shrink(size, size, size, size); }
 87 
 88     private:
 89         FloatSize m_topLeft;
 90         FloatSize m_topRight;
 91         FloatSize m_bottomLeft;
 92         FloatSize m_bottomRight;
 93     };
 94 
 95     WEBCORE_EXPORT explicit FloatRoundedRect(const FloatRect&amp; = FloatRect(), const Radii&amp; = Radii());
 96     explicit FloatRoundedRect(const RoundedRect&amp;);
 97     FloatRoundedRect(float x, float y, float width, float height);
 98     FloatRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeft, const FloatSize&amp; topRight, const FloatSize&amp; bottomLeft, const FloatSize&amp; bottomRight);
 99 
100     const FloatRect&amp; rect() const { return m_rect; }
101     const Radii&amp; radii() const { return m_radii; }
102     bool isRounded() const { return !m_radii.isZero(); }
103     bool isEmpty() const { return m_rect.isEmpty(); }
104 
105     void setRect(const FloatRect&amp; rect) { m_rect = rect; }
106     void setLocation(FloatPoint location) { m_rect.setLocation(location); }
107     void setRadii(const Radii&amp; radii) { m_radii = radii; }
108 
109     void move(const FloatSize&amp; size) { m_rect.move(size); }
110     void inflate(float size) { m_rect.inflate(size);  }
111     void expandRadii(float size) { m_radii.expand(size); }
112     void shrinkRadii(float size) { m_radii.shrink(size); }
113     void inflateWithRadii(float size);
114     void adjustRadii();
115 
116     FloatRect topLeftCorner() const
117     {
118         return FloatRect(m_rect.x(), m_rect.y(), m_radii.topLeft().width(), m_radii.topLeft().height());
119     }
120     FloatRect topRightCorner() const
121     {
122         return FloatRect(m_rect.maxX() - m_radii.topRight().width(), m_rect.y(), m_radii.topRight().width(), m_radii.topRight().height());
123     }
124     FloatRect bottomLeftCorner() const
125     {
126         return FloatRect(m_rect.x(), m_rect.maxY() - m_radii.bottomLeft().height(), m_radii.bottomLeft().width(), m_radii.bottomLeft().height());
127     }
128     FloatRect bottomRightCorner() const
129     {
130         return FloatRect(m_rect.maxX() - m_radii.bottomRight().width(), m_rect.maxY() - m_radii.bottomRight().height(), m_radii.bottomRight().width(), m_radii.bottomRight().height());
131     }
132 
133     bool isRenderable() const;
134     bool xInterceptsAtY(float y, float&amp; minXIntercept, float&amp; maxXIntercept) const;
135 
136     bool intersectionIsRectangular(const FloatRect&amp;) const;
137 
138 private:
139     FloatRect m_rect;
140     Radii m_radii;
141 };
142 
143 inline bool operator==(const FloatRoundedRect::Radii&amp; a, const FloatRoundedRect::Radii&amp; b)
144 {
145     return a.topLeft() == b.topLeft() &amp;&amp; a.topRight() == b.topRight() &amp;&amp; a.bottomLeft() == b.bottomLeft() &amp;&amp; a.bottomRight() == b.bottomRight();
146 }
147 
148 inline bool operator!=(const FloatRoundedRect::Radii&amp; a, const FloatRoundedRect::Radii&amp; b)
149 {
150     return !(a == b);
151 }
152 
153 inline bool operator==(const FloatRoundedRect&amp; a, const FloatRoundedRect&amp; b)
154 {
155     return a.rect() == b.rect() &amp;&amp; a.radii() == b.radii();
156 }
157 
158 inline bool operator!=(const FloatRoundedRect&amp; a, const FloatRoundedRect&amp; b)
159 {
160     return !(a == b);
161 }
162 
163 inline float calcBorderRadiiConstraintScaleFor(const FloatRect&amp; rect, const FloatRoundedRect::Radii&amp; radii)
164 {
165     // Constrain corner radii using CSS3 rules:
166     // http://www.w3.org/TR/css3-background/#the-border-radius
167 
168     float factor = 1;
169     float radiiSum;
170 
171     // top
172     radiiSum = radii.topLeft().width() + radii.topRight().width(); // Casts to avoid integer overflow.
173     if (radiiSum &gt; rect.width())
174         factor = std::min(rect.width() / radiiSum, factor);
175 
176     // bottom
177     radiiSum = radii.bottomLeft().width() + radii.bottomRight().width();
178     if (radiiSum &gt; rect.width())
179         factor = std::min(rect.width() / radiiSum, factor);
180 
181     // left
182     radiiSum = radii.topLeft().height() + radii.bottomLeft().height();
183     if (radiiSum &gt; rect.height())
184         factor = std::min(rect.height() / radiiSum, factor);
185 
186     // right
187     radiiSum = radii.topRight().height() + radii.bottomRight().height();
188     if (radiiSum &gt; rect.height())
189         factor = std::min(rect.height() / radiiSum, factor);
190 
191     ASSERT(factor &lt;= 1);
192     return factor;
193 }
194 
195 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const FloatRoundedRect&amp;);
196 
197 } // namespace WebCore
198 
199 #endif // FloatRoundedRect_h
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoPage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoSharedHeap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoPageInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;IsoHeapImpl.h&quot;
 31 #include &quot;IsoPage.h&quot;
 32 #include &quot;StdLibExtras.h&quot;
 33 #include &quot;VMAllocate.h&quot;
 34 
 35 namespace bmalloc {
 36 
 37 template&lt;typename Config&gt;
 38 IsoPage&lt;Config&gt;* IsoPage&lt;Config&gt;::tryCreate(IsoDirectoryBase&lt;Config&gt;&amp; directory, unsigned index)
 39 {
 40     void* memory = allocatePageMemory();
 41     if (!memory)
 42         return nullptr;
 43 
 44     return new (memory) IsoPage(directory, index);
 45 }
 46 
 47 template&lt;typename Config&gt;
 48 IsoPage&lt;Config&gt;::IsoPage(IsoDirectoryBase&lt;Config&gt;&amp; directory, unsigned index)
 49     : IsoPageBase(false)
<span class="line-removed"> 50     , m_directory(directory)</span>
 51     , m_index(index)

 52 {
 53     memset(m_allocBits, 0, sizeof(m_allocBits));
 54 }
 55 
 56 inline IsoPageBase* IsoPageBase::pageFor(void* ptr)
 57 {
 58     return reinterpret_cast&lt;IsoPageBase*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; ~(pageSize - 1));
 59 }
 60 
 61 template&lt;typename Config&gt;
 62 IsoPage&lt;Config&gt;* IsoPage&lt;Config&gt;::pageFor(void* ptr)
 63 {
 64     return reinterpret_cast&lt;IsoPage&lt;Config&gt;*&gt;(IsoPageBase::pageFor(ptr));
 65 }
 66 
 67 template&lt;typename Config&gt;
<span class="line-modified"> 68 void IsoPage&lt;Config&gt;::free(void* passedPtr)</span>
 69 {
 70     BASSERT(!m_isShared);
 71     unsigned offset = static_cast&lt;char*&gt;(passedPtr) - reinterpret_cast&lt;char*&gt;(this);
 72     unsigned index = offset / Config::objectSize;
 73 
 74     if (!m_eligibilityHasBeenNoted) {
<span class="line-modified"> 75         m_eligibilityTrigger.didBecome(*this);</span>
 76         m_eligibilityHasBeenNoted = true;
 77     }
 78 
 79     unsigned wordIndex = index / 32;
 80     unsigned bitIndex = index % 32;
 81 
 82     unsigned newWord = m_allocBits[wordIndex] &amp;= ~(1 &lt;&lt; bitIndex);
 83     if (!newWord) {
 84         if (!--m_numNonEmptyWords)
<span class="line-modified"> 85             m_emptyTrigger.didBecome(*this);</span>
 86     }
 87 }
 88 
 89 template&lt;typename Config&gt;
<span class="line-modified"> 90 FreeList IsoPage&lt;Config&gt;::startAllocating()</span>
 91 {
 92     static constexpr bool verbose = false;
 93 
 94     if (verbose)
 95         fprintf(stderr, &quot;%p: starting allocation.\n&quot;, this);
 96 
 97     RELEASE_BASSERT(!m_isInUseForAllocation);
 98     m_isInUseForAllocation = true;
 99     m_eligibilityHasBeenNoted = false;
100 
101     FreeList result;
102     if (!m_numNonEmptyWords) {
103         if (verbose)
104             fprintf(stderr, &quot;%p: preparing to bump.\n&quot;, this);
105 
106         char* payloadEnd = reinterpret_cast&lt;char*&gt;(this) + numObjects * Config::objectSize;
107         result.initializeBump(payloadEnd, (numObjects - indexOfFirstObject()) * Config::objectSize);
108 
109         unsigned begin = indexOfFirstObject();
110         unsigned end = numObjects;
</pre>
<hr />
<pre>
191         unsigned bitMask = 1 &lt;&lt; (index &amp; 31);
192         if (word &amp; bitMask)
193             continue;
194         if (!word)
195             m_numNonEmptyWords++;
196         m_allocBits[wordIndex] = word | bitMask;
197         char* cellByte = reinterpret_cast&lt;char*&gt;(this) + index * Config::objectSize;
198         if (verbose)
199             fprintf(stderr, &quot;%p: putting %p on free list.\n&quot;, this, cellByte);
200         FreeCell* cell = bitwise_cast&lt;FreeCell*&gt;(cellByte);
201         cell-&gt;setNext(head, secret);
202         head = cell;
203         bytes += Config::objectSize;
204     }
205 
206     result.initializeList(head, secret, bytes);
207     return result;
208 }
209 
210 template&lt;typename Config&gt;
<span class="line-modified">211 void IsoPage&lt;Config&gt;::stopAllocating(FreeList freeList)</span>
212 {
213     static constexpr bool verbose = false;
214 
215     if (verbose)
216         fprintf(stderr, &quot;%p: stopping allocation.\n&quot;, this);
217 
218     freeList.forEach&lt;Config&gt;(
219         [&amp;] (void* ptr) {
<span class="line-modified">220             free(ptr);</span>
221         });
222 
223     RELEASE_BASSERT(m_isInUseForAllocation);
224     m_isInUseForAllocation = false;
225 
<span class="line-modified">226     m_eligibilityTrigger.handleDeferral(*this);</span>
<span class="line-modified">227     m_emptyTrigger.handleDeferral(*this);</span>
228 }
229 
230 template&lt;typename Config&gt;
231 template&lt;typename Func&gt;
<span class="line-modified">232 void IsoPage&lt;Config&gt;::forEachLiveObject(const Func&amp; func)</span>
233 {
234     for (unsigned wordIndex = 0; wordIndex &lt; bitsArrayLength(numObjects); ++wordIndex) {
235         unsigned word = m_allocBits[wordIndex];
236         if (!word)
237             continue;
238         unsigned firstBitIndex = wordIndex * 32;
239         char* cellByte = reinterpret_cast&lt;char*&gt;(this) + firstBitIndex * Config::objectSize;
240         for (unsigned bitIndex = 0; bitIndex &lt; 32; ++bitIndex) {
241             if (word &amp; 1)
242                 func(static_cast&lt;void*&gt;(cellByte));
243             word &gt;&gt;= 1;
244             cellByte += Config::objectSize;
245         }
246     }
247 }
248 
249 template&lt;typename Config&gt;
250 IsoHeapImpl&lt;Config&gt;&amp; IsoPage&lt;Config&gt;::heap()
251 {
252     return m_directory.heap();
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;IsoHeapImpl.h&quot;
 31 #include &quot;IsoPage.h&quot;
 32 #include &quot;StdLibExtras.h&quot;
 33 #include &quot;VMAllocate.h&quot;
 34 
 35 namespace bmalloc {
 36 
 37 template&lt;typename Config&gt;
 38 IsoPage&lt;Config&gt;* IsoPage&lt;Config&gt;::tryCreate(IsoDirectoryBase&lt;Config&gt;&amp; directory, unsigned index)
 39 {
 40     void* memory = allocatePageMemory();
 41     if (!memory)
 42         return nullptr;
 43 
 44     return new (memory) IsoPage(directory, index);
 45 }
 46 
 47 template&lt;typename Config&gt;
 48 IsoPage&lt;Config&gt;::IsoPage(IsoDirectoryBase&lt;Config&gt;&amp; directory, unsigned index)
 49     : IsoPageBase(false)

 50     , m_index(index)
<span class="line-added"> 51     , m_directory(directory)</span>
 52 {
 53     memset(m_allocBits, 0, sizeof(m_allocBits));
 54 }
 55 
 56 inline IsoPageBase* IsoPageBase::pageFor(void* ptr)
 57 {
 58     return reinterpret_cast&lt;IsoPageBase*&gt;(reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; ~(pageSize - 1));
 59 }
 60 
 61 template&lt;typename Config&gt;
 62 IsoPage&lt;Config&gt;* IsoPage&lt;Config&gt;::pageFor(void* ptr)
 63 {
 64     return reinterpret_cast&lt;IsoPage&lt;Config&gt;*&gt;(IsoPageBase::pageFor(ptr));
 65 }
 66 
 67 template&lt;typename Config&gt;
<span class="line-modified"> 68 void IsoPage&lt;Config&gt;::free(const LockHolder&amp; locker, void* passedPtr)</span>
 69 {
 70     BASSERT(!m_isShared);
 71     unsigned offset = static_cast&lt;char*&gt;(passedPtr) - reinterpret_cast&lt;char*&gt;(this);
 72     unsigned index = offset / Config::objectSize;
 73 
 74     if (!m_eligibilityHasBeenNoted) {
<span class="line-modified"> 75         m_eligibilityTrigger.didBecome(locker, *this);</span>
 76         m_eligibilityHasBeenNoted = true;
 77     }
 78 
 79     unsigned wordIndex = index / 32;
 80     unsigned bitIndex = index % 32;
 81 
 82     unsigned newWord = m_allocBits[wordIndex] &amp;= ~(1 &lt;&lt; bitIndex);
 83     if (!newWord) {
 84         if (!--m_numNonEmptyWords)
<span class="line-modified"> 85             m_emptyTrigger.didBecome(locker, *this);</span>
 86     }
 87 }
 88 
 89 template&lt;typename Config&gt;
<span class="line-modified"> 90 FreeList IsoPage&lt;Config&gt;::startAllocating(const LockHolder&amp;)</span>
 91 {
 92     static constexpr bool verbose = false;
 93 
 94     if (verbose)
 95         fprintf(stderr, &quot;%p: starting allocation.\n&quot;, this);
 96 
 97     RELEASE_BASSERT(!m_isInUseForAllocation);
 98     m_isInUseForAllocation = true;
 99     m_eligibilityHasBeenNoted = false;
100 
101     FreeList result;
102     if (!m_numNonEmptyWords) {
103         if (verbose)
104             fprintf(stderr, &quot;%p: preparing to bump.\n&quot;, this);
105 
106         char* payloadEnd = reinterpret_cast&lt;char*&gt;(this) + numObjects * Config::objectSize;
107         result.initializeBump(payloadEnd, (numObjects - indexOfFirstObject()) * Config::objectSize);
108 
109         unsigned begin = indexOfFirstObject();
110         unsigned end = numObjects;
</pre>
<hr />
<pre>
191         unsigned bitMask = 1 &lt;&lt; (index &amp; 31);
192         if (word &amp; bitMask)
193             continue;
194         if (!word)
195             m_numNonEmptyWords++;
196         m_allocBits[wordIndex] = word | bitMask;
197         char* cellByte = reinterpret_cast&lt;char*&gt;(this) + index * Config::objectSize;
198         if (verbose)
199             fprintf(stderr, &quot;%p: putting %p on free list.\n&quot;, this, cellByte);
200         FreeCell* cell = bitwise_cast&lt;FreeCell*&gt;(cellByte);
201         cell-&gt;setNext(head, secret);
202         head = cell;
203         bytes += Config::objectSize;
204     }
205 
206     result.initializeList(head, secret, bytes);
207     return result;
208 }
209 
210 template&lt;typename Config&gt;
<span class="line-modified">211 void IsoPage&lt;Config&gt;::stopAllocating(const LockHolder&amp; locker, FreeList freeList)</span>
212 {
213     static constexpr bool verbose = false;
214 
215     if (verbose)
216         fprintf(stderr, &quot;%p: stopping allocation.\n&quot;, this);
217 
218     freeList.forEach&lt;Config&gt;(
219         [&amp;] (void* ptr) {
<span class="line-modified">220             free(locker, ptr);</span>
221         });
222 
223     RELEASE_BASSERT(m_isInUseForAllocation);
224     m_isInUseForAllocation = false;
225 
<span class="line-modified">226     m_eligibilityTrigger.handleDeferral(locker, *this);</span>
<span class="line-modified">227     m_emptyTrigger.handleDeferral(locker, *this);</span>
228 }
229 
230 template&lt;typename Config&gt;
231 template&lt;typename Func&gt;
<span class="line-modified">232 void IsoPage&lt;Config&gt;::forEachLiveObject(const LockHolder&amp;, const Func&amp; func)</span>
233 {
234     for (unsigned wordIndex = 0; wordIndex &lt; bitsArrayLength(numObjects); ++wordIndex) {
235         unsigned word = m_allocBits[wordIndex];
236         if (!word)
237             continue;
238         unsigned firstBitIndex = wordIndex * 32;
239         char* cellByte = reinterpret_cast&lt;char*&gt;(this) + firstBitIndex * Config::objectSize;
240         for (unsigned bitIndex = 0; bitIndex &lt; 32; ++bitIndex) {
241             if (word &amp; 1)
242                 func(static_cast&lt;void*&gt;(cellByte));
243             word &gt;&gt;= 1;
244             cellByte += Config::objectSize;
245         }
246     }
247 }
248 
249 template&lt;typename Config&gt;
250 IsoHeapImpl&lt;Config&gt;&amp; IsoPage&lt;Config&gt;::heap()
251 {
252     return m_directory.heap();
</pre>
</td>
</tr>
</table>
<center><a href="IsoPage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoSharedHeap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
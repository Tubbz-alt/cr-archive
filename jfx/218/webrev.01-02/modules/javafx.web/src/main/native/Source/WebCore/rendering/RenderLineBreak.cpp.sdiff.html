<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayoutState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLineBreak.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RenderLineBreak.h&quot;
 24 
 25 #include &quot;Document.h&quot;
 26 #include &quot;FontMetrics.h&quot;
 27 #include &quot;HTMLElement.h&quot;
 28 #include &quot;HTMLWBRElement.h&quot;
 29 #include &quot;InlineElementBox.h&quot;

 30 #include &quot;LogicalSelectionOffsetCaches.h&quot;
 31 #include &quot;RenderBlock.h&quot;
 32 #include &quot;RenderView.h&quot;
 33 #include &quot;RootInlineBox.h&quot;
<span class="line-removed"> 34 #include &quot;SimpleLineLayoutFunctions.h&quot;</span>
 35 #include &quot;VisiblePosition.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 #if PLATFORM(IOS_FAMILY)
 39 #include &quot;SelectionRect.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderLineBreak);
 45 
 46 static const int invalidLineHeight = -1;
 47 
<span class="line-removed"> 48 static const SimpleLineLayout::Layout* simpleLineLayout(const RenderLineBreak&amp; renderer)</span>
<span class="line-removed"> 49 {</span>
<span class="line-removed"> 50     if (!is&lt;RenderBlockFlow&gt;(*renderer.parent()))</span>
<span class="line-removed"> 51         return nullptr;</span>
<span class="line-removed"> 52     return downcast&lt;RenderBlockFlow&gt;(*renderer.parent()).simpleLineLayout();</span>
<span class="line-removed"> 53 }</span>
<span class="line-removed"> 54 </span>
 55 RenderLineBreak::RenderLineBreak(HTMLElement&amp; element, RenderStyle&amp;&amp; style)
 56     : RenderBoxModelObject(element, WTFMove(style), 0)
 57     , m_inlineBoxWrapper(nullptr)
 58     , m_cachedLineHeight(invalidLineHeight)
 59     , m_isWBR(is&lt;HTMLWBRElement&gt;(element))
 60 {
 61     setIsLineBreak();
 62 }
 63 
 64 RenderLineBreak::~RenderLineBreak()
 65 {
 66     delete m_inlineBoxWrapper;
 67 }
 68 
 69 LayoutUnit RenderLineBreak::lineHeight(bool firstLine, LineDirectionMode /*direction*/, LinePositionMode /*linePositionMode*/) const
 70 {
 71     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
 72         const RenderStyle&amp; firstLineStyle = this-&gt;firstLineStyle();
 73         if (&amp;firstLineStyle != &amp;style())
 74             return firstLineStyle.computedLineHeight();
</pre>
<hr />
<pre>
116 
117 void RenderLineBreak::dirtyLineBoxes(bool fullLayout)
118 {
119     if (!m_inlineBoxWrapper)
120         return;
121     if (fullLayout) {
122         delete m_inlineBoxWrapper;
123         m_inlineBoxWrapper = nullptr;
124         return;
125     }
126     m_inlineBoxWrapper-&gt;dirtyLineBoxes();
127 }
128 
129 void RenderLineBreak::ensureLineBoxes()
130 {
131     if (!is&lt;RenderBlockFlow&gt;(*parent()))
132         return;
133     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
134 }
135 
<span class="line-removed">136 void RenderLineBreak::deleteLineBoxesBeforeSimpleLineLayout()</span>
<span class="line-removed">137 {</span>
<span class="line-removed">138     delete m_inlineBoxWrapper;</span>
<span class="line-removed">139     m_inlineBoxWrapper = nullptr;</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
142 int RenderLineBreak::caretMinOffset() const
143 {
144     return 0;
145 }
146 
147 int RenderLineBreak::caretMaxOffset() const
148 {
149     return 1;
150 }
151 
152 bool RenderLineBreak::canBeSelectionLeaf() const
153 {
154     return true;
155 }
156 
157 VisiblePosition RenderLineBreak::positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*)
158 {
159     ensureLineBoxes();
160     return createVisiblePosition(0, DOWNSTREAM);
161 }
</pre>
<hr />
<pre>
166         ensureLineBoxes();
167     RenderBoxModelObject::setSelectionState(state);
168     if (!m_inlineBoxWrapper)
169         return;
170     m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(state != SelectionNone);
171 }
172 
173 LayoutRect RenderLineBreak::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
174 {
175     ASSERT_UNUSED(caretOffset, !caretOffset);
176     ASSERT_UNUSED(inlineBox, inlineBox == m_inlineBoxWrapper);
177     if (!inlineBox)
178         return LayoutRect();
179 
180     const RootInlineBox&amp; rootBox = inlineBox-&gt;root();
181     return rootBox.computeCaretRect(inlineBox-&gt;logicalLeft(), caretWidth, extraWidthToEndOfLine);
182 }
183 
184 IntRect RenderLineBreak::linesBoundingBox() const
185 {
<span class="line-modified">186     if (auto* layout = simpleLineLayout(*this))</span>
<span class="line-modified">187         return SimpleLineLayout::computeBoundingBox(*this, *layout);</span>
<span class="line-modified">188 </span>
<span class="line-removed">189     if (!m_inlineBoxWrapper)</span>
<span class="line-removed">190         return IntRect();</span>
191 
<span class="line-modified">192     float logicalLeftSide = m_inlineBoxWrapper-&gt;logicalLeft();</span>
<span class="line-modified">193     float logicalRightSide = m_inlineBoxWrapper-&gt;logicalRight();</span>
194 
<span class="line-modified">195     bool isHorizontal = style().isHorizontalWritingMode();</span>

















196 
<span class="line-modified">197     float x = isHorizontal ? logicalLeftSide : m_inlineBoxWrapper-&gt;x();</span>
<span class="line-removed">198     float y = isHorizontal ? m_inlineBoxWrapper-&gt;y() : logicalLeftSide;</span>
<span class="line-removed">199     float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_inlineBoxWrapper-&gt;logicalBottom() - x;</span>
<span class="line-removed">200     float height = isHorizontal ? m_inlineBoxWrapper-&gt;logicalBottom() - y : logicalRightSide - logicalLeftSide;</span>
<span class="line-removed">201     return enclosingIntRect(FloatRect(x, y, width, height));</span>
202 }
203 
204 void RenderLineBreak::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
205 {
<span class="line-modified">206     if (auto* layout = simpleLineLayout(*this)) {</span>
<span class="line-modified">207         rects.appendVector(SimpleLineLayout::collectAbsoluteRects(*this, *layout, accumulatedOffset));</span>
208         return;
<span class="line-removed">209     }</span>
210 
<span class="line-modified">211     if (!m_inlineBoxWrapper)</span>
<span class="line-modified">212         return;</span>
<span class="line-removed">213     rects.append(enclosingIntRect(FloatRect(accumulatedOffset + m_inlineBoxWrapper-&gt;topLeft(), m_inlineBoxWrapper-&gt;size())));</span>
214 }
215 
216 void RenderLineBreak::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
217 {
<span class="line-modified">218     if (auto* layout = simpleLineLayout(*this)) {</span>
<span class="line-modified">219         quads.appendVector(SimpleLineLayout::collectAbsoluteQuads(*this, *layout, wasFixed));</span>
<span class="line-removed">220         return;</span>
<span class="line-removed">221     }</span>
<span class="line-removed">222     if (!m_inlineBoxWrapper)</span>
223         return;
<span class="line-modified">224     quads.append(localToAbsoluteQuad(FloatRect(m_inlineBoxWrapper-&gt;topLeft(), m_inlineBoxWrapper-&gt;size()), UseTransforms, wasFixed));</span>


225 }
226 
227 void RenderLineBreak::updateFromStyle()
228 {
229     m_cachedLineHeight = invalidLineHeight;
230 }
231 
232 #if PLATFORM(IOS_FAMILY)
233 void RenderLineBreak::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned, unsigned)
234 {
235     ensureLineBoxes();
236     InlineElementBox* box = m_inlineBoxWrapper;
237     if (!box)
238         return;
239     const RootInlineBox&amp; rootBox = box-&gt;root();
240     LayoutRect rect = rootBox.computeCaretRect(box-&gt;logicalLeft(), 0, nullptr);
241     if (rootBox.isFirstAfterPageBreak()) {
242         if (box-&gt;isHorizontal())
243             rect.shiftYEdgeTo(rootBox.lineTopWithLeading());
244         else
</pre>
</td>
<td>
<hr />
<pre>
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RenderLineBreak.h&quot;
 24 
 25 #include &quot;Document.h&quot;
 26 #include &quot;FontMetrics.h&quot;
 27 #include &quot;HTMLElement.h&quot;
 28 #include &quot;HTMLWBRElement.h&quot;
 29 #include &quot;InlineElementBox.h&quot;
<span class="line-added"> 30 #include &quot;LineLayoutTraversal.h&quot;</span>
 31 #include &quot;LogicalSelectionOffsetCaches.h&quot;
 32 #include &quot;RenderBlock.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &quot;RootInlineBox.h&quot;

 35 #include &quot;VisiblePosition.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 
 38 #if PLATFORM(IOS_FAMILY)
 39 #include &quot;SelectionRect.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderLineBreak);
 45 
 46 static const int invalidLineHeight = -1;
 47 







 48 RenderLineBreak::RenderLineBreak(HTMLElement&amp; element, RenderStyle&amp;&amp; style)
 49     : RenderBoxModelObject(element, WTFMove(style), 0)
 50     , m_inlineBoxWrapper(nullptr)
 51     , m_cachedLineHeight(invalidLineHeight)
 52     , m_isWBR(is&lt;HTMLWBRElement&gt;(element))
 53 {
 54     setIsLineBreak();
 55 }
 56 
 57 RenderLineBreak::~RenderLineBreak()
 58 {
 59     delete m_inlineBoxWrapper;
 60 }
 61 
 62 LayoutUnit RenderLineBreak::lineHeight(bool firstLine, LineDirectionMode /*direction*/, LinePositionMode /*linePositionMode*/) const
 63 {
 64     if (firstLine &amp;&amp; view().usesFirstLineRules()) {
 65         const RenderStyle&amp; firstLineStyle = this-&gt;firstLineStyle();
 66         if (&amp;firstLineStyle != &amp;style())
 67             return firstLineStyle.computedLineHeight();
</pre>
<hr />
<pre>
109 
110 void RenderLineBreak::dirtyLineBoxes(bool fullLayout)
111 {
112     if (!m_inlineBoxWrapper)
113         return;
114     if (fullLayout) {
115         delete m_inlineBoxWrapper;
116         m_inlineBoxWrapper = nullptr;
117         return;
118     }
119     m_inlineBoxWrapper-&gt;dirtyLineBoxes();
120 }
121 
122 void RenderLineBreak::ensureLineBoxes()
123 {
124     if (!is&lt;RenderBlockFlow&gt;(*parent()))
125         return;
126     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
127 }
128 






129 int RenderLineBreak::caretMinOffset() const
130 {
131     return 0;
132 }
133 
134 int RenderLineBreak::caretMaxOffset() const
135 {
136     return 1;
137 }
138 
139 bool RenderLineBreak::canBeSelectionLeaf() const
140 {
141     return true;
142 }
143 
144 VisiblePosition RenderLineBreak::positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*)
145 {
146     ensureLineBoxes();
147     return createVisiblePosition(0, DOWNSTREAM);
148 }
</pre>
<hr />
<pre>
153         ensureLineBoxes();
154     RenderBoxModelObject::setSelectionState(state);
155     if (!m_inlineBoxWrapper)
156         return;
157     m_inlineBoxWrapper-&gt;root().setHasSelectedChildren(state != SelectionNone);
158 }
159 
160 LayoutRect RenderLineBreak::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
161 {
162     ASSERT_UNUSED(caretOffset, !caretOffset);
163     ASSERT_UNUSED(inlineBox, inlineBox == m_inlineBoxWrapper);
164     if (!inlineBox)
165         return LayoutRect();
166 
167     const RootInlineBox&amp; rootBox = inlineBox-&gt;root();
168     return rootBox.computeCaretRect(inlineBox-&gt;logicalLeft(), caretWidth, extraWidthToEndOfLine);
169 }
170 
171 IntRect RenderLineBreak::linesBoundingBox() const
172 {
<span class="line-modified">173     auto box = LineLayoutTraversal::elementBoxFor(*this);</span>
<span class="line-modified">174     if (!box)</span>
<span class="line-modified">175         return { };</span>


176 
<span class="line-modified">177     return enclosingIntRect(box-&gt;rect());</span>
<span class="line-modified">178 }</span>
179 
<span class="line-modified">180 IntRect RenderLineBreak::boundingBoxForRenderTreeDump() const</span>
<span class="line-added">181 {</span>
<span class="line-added">182     auto box = LineLayoutTraversal::elementBoxFor(*this);</span>
<span class="line-added">183     if (!box)</span>
<span class="line-added">184         return { };</span>
<span class="line-added">185 </span>
<span class="line-added">186     auto rect = box-&gt;rect();</span>
<span class="line-added">187 </span>
<span class="line-added">188     // FIXME: Remove and rebase the tests.</span>
<span class="line-added">189     bool inQuirksMode = !document().inNoQuirksMode();</span>
<span class="line-added">190     if (inQuirksMode &amp;&amp; !isWBR() &amp;&amp; box-&gt;useLineBreakBoxRenderTreeDumpQuirk()) {</span>
<span class="line-added">191         if (!box-&gt;isHorizontal()) {</span>
<span class="line-added">192             auto baseline = style().isFlippedBlocksWritingMode() ? rect.x() + box-&gt;baselineOffset() : rect.maxX() - box-&gt;baselineOffset();</span>
<span class="line-added">193             return enclosingIntRect(FloatRect(FloatPoint(baseline, rect.y()), FloatSize(0, rect.height())));</span>
<span class="line-added">194         }</span>
<span class="line-added">195         auto baseline = rect.y() + box-&gt;baselineOffset();</span>
<span class="line-added">196         return enclosingIntRect(FloatRect(FloatPoint(rect.x(), baseline), FloatSize(rect.width(), 0)));</span>
<span class="line-added">197     }</span>
198 
<span class="line-modified">199     return enclosingIntRect(rect);</span>




200 }
201 
202 void RenderLineBreak::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
203 {
<span class="line-modified">204     auto box = LineLayoutTraversal::elementBoxFor(*this);</span>
<span class="line-modified">205     if (!box)</span>
206         return;

207 
<span class="line-modified">208     auto rect = box-&gt;rect();</span>
<span class="line-modified">209     rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));</span>

210 }
211 
212 void RenderLineBreak::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
213 {
<span class="line-modified">214     auto box = LineLayoutTraversal::elementBoxFor(*this);</span>
<span class="line-modified">215     if (!box)</span>



216         return;
<span class="line-modified">217 </span>
<span class="line-added">218     auto rect = box-&gt;rect();</span>
<span class="line-added">219     quads.append(localToAbsoluteQuad(FloatRect(rect.location(), rect.size()), UseTransforms, wasFixed));</span>
220 }
221 
222 void RenderLineBreak::updateFromStyle()
223 {
224     m_cachedLineHeight = invalidLineHeight;
225 }
226 
227 #if PLATFORM(IOS_FAMILY)
228 void RenderLineBreak::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned, unsigned)
229 {
230     ensureLineBoxes();
231     InlineElementBox* box = m_inlineBoxWrapper;
232     if (!box)
233         return;
234     const RootInlineBox&amp; rootBox = box-&gt;root();
235     LayoutRect rect = rootBox.computeCaretRect(box-&gt;logicalLeft(), 0, nullptr);
236     if (rootBox.isFirstAfterPageBreak()) {
237         if (box-&gt;isHorizontal())
238             rect.shiftYEdgeTo(rootBox.lineTopWithLeading());
239         else
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayoutState.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLineBreak.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
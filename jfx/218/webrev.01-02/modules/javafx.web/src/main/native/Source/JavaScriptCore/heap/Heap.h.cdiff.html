<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Heap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapCell.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;CollectionScope.h&quot;
  #include &quot;CollectorPhase.h&quot;
  #include &quot;DeleteAllCodeEffort.h&quot;
  #include &quot;GCConductor.h&quot;
  #include &quot;GCIncomingRefCountedSet.h&quot;
<span class="line-added">+ #include &quot;GCMemoryOperations.h&quot;</span>
  #include &quot;GCRequest.h&quot;
  #include &quot;HandleSet.h&quot;
  #include &quot;HeapFinalizerCallback.h&quot;
  #include &quot;HeapObserver.h&quot;
  #include &quot;MarkedBlock.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,15 ***</span>
  namespace DFG {
  class SpeculativeJIT;
  class Worklist;
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
<span class="line-removed">- #define ENABLE_DFG_DOES_GC_VALIDATION 1</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- #define ENABLE_DFG_DOES_GC_VALIDATION 0</span>
<span class="line-removed">- #endif</span>
  constexpr bool validateDFGDoesGC = ENABLE_DFG_DOES_GC_VALIDATION;
  
  typedef HashCountedSet&lt;JSCell*&gt; ProtectCountSet;
  typedef HashCountedSet&lt;const char*&gt; TypeCountSet;
  
<span class="line-new-header">--- 94,11 ---</span>
  namespace DFG {
  class SpeculativeJIT;
  class Worklist;
  }
  
<span class="line-modified">! #define ENABLE_DFG_DOES_GC_VALIDATION ASSERT_ENABLED</span>
  constexpr bool validateDFGDoesGC = ENABLE_DFG_DOES_GC_VALIDATION;
  
  typedef HashCountedSet&lt;JSCell*&gt; ProtectCountSet;
  typedef HashCountedSet&lt;const char*&gt; TypeCountSet;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,11 ***</span>
  
      // This constant determines how many blocks we iterate between checks of our
      // deadline when calling Heap::isPagedOut. Decreasing it will cause us to detect
      // overstepping our deadline more quickly, while increasing it will cause
      // our scan to run faster.
<span class="line-modified">!     static const unsigned s_timeCheckResolution = 16;</span>
  
      bool isMarked(const void*);
      static bool testAndSetMarked(HeapVersion, const void*);
  
      static size_t cellSize(const void*);
<span class="line-new-header">--- 116,11 ---</span>
  
      // This constant determines how many blocks we iterate between checks of our
      // deadline when calling Heap::isPagedOut. Decreasing it will cause us to detect
      // overstepping our deadline more quickly, while increasing it will cause
      // our scan to run faster.
<span class="line-modified">!     static constexpr unsigned s_timeCheckResolution = 16;</span>
  
      bool isMarked(const void*);
      static bool testAndSetMarked(HeapVersion, const void*);
  
      static size_t cellSize(const void*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,12 ***</span>
  
      // We&#39;re always busy on the collection threads. On the main thread, this returns true if we&#39;re
      // helping heap.
      JS_EXPORT_PRIVATE bool isCurrentThreadBusy();
  
<span class="line-modified">!     typedef void (*Finalizer)(JSCell*);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, Finalizer);</span>
  
      void notifyIsSafeToCollect();
      bool isSafeToCollect() const { return m_isSafeToCollect; }
  
      bool isShuttingDown() const { return m_isShuttingDown; }
<span class="line-new-header">--- 165,14 ---</span>
  
      // We&#39;re always busy on the collection threads. On the main thread, this returns true if we&#39;re
      // helping heap.
      JS_EXPORT_PRIVATE bool isCurrentThreadBusy();
  
<span class="line-modified">!     typedef void (*CFinalizer)(JSCell*);</span>
<span class="line-modified">!     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, CFinalizer);</span>
<span class="line-added">+     using LambdaFinalizer = WTF::Function&lt;void(JSCell*)&gt;;</span>
<span class="line-added">+     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, LambdaFinalizer);</span>
  
      void notifyIsSafeToCollect();
      bool isSafeToCollect() const { return m_isSafeToCollect; }
  
      bool isShuttingDown() const { return m_isShuttingDown; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,13 ***</span>
      friend class WeakSet;
  
      class HeapThread;
      friend class HeapThread;
  
<span class="line-modified">!     static const size_t minExtraMemory = 256;</span>
  
<span class="line-modified">!     class FinalizerOwner : public WeakHandleOwner {</span>
          void finalize(Handle&lt;Unknown&gt;, void* context) override;
      };
  
      JS_EXPORT_PRIVATE bool isValidAllocation(size_t);
      JS_EXPORT_PRIVATE void reportExtraMemoryAllocatedSlowCase(size_t);
<span class="line-new-header">--- 425,17 ---</span>
      friend class WeakSet;
  
      class HeapThread;
      friend class HeapThread;
  
<span class="line-modified">!     static constexpr size_t minExtraMemory = 256;</span>
<span class="line-added">+ </span>
<span class="line-added">+     class CFinalizerOwner : public WeakHandleOwner {</span>
<span class="line-added">+         void finalize(Handle&lt;Unknown&gt;, void* context) override;</span>
<span class="line-added">+     };</span>
  
<span class="line-modified">!     class LambdaFinalizerOwner : public WeakHandleOwner {</span>
          void finalize(Handle&lt;Unknown&gt;, void* context) override;
      };
  
      JS_EXPORT_PRIVATE bool isValidAllocation(size_t);
      JS_EXPORT_PRIVATE void reportExtraMemoryAllocatedSlowCase(size_t);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,11 ***</span>
      Vector&lt;SlotVisitor*&gt; m_availableParallelSlotVisitors;
  
      HandleSet m_handleSet;
      std::unique_ptr&lt;CodeBlockSet&gt; m_codeBlocks;
      std::unique_ptr&lt;JITStubRoutineSet&gt; m_jitStubRoutines;
<span class="line-modified">!     FinalizerOwner m_finalizerOwner;</span>
  
      Lock m_parallelSlotVisitorLock;
      bool m_isSafeToCollect { false };
      bool m_isShuttingDown { false };
      bool m_mutatorShouldBeFenced { Options::forceFencedBarrier() };
<span class="line-new-header">--- 634,12 ---</span>
      Vector&lt;SlotVisitor*&gt; m_availableParallelSlotVisitors;
  
      HandleSet m_handleSet;
      std::unique_ptr&lt;CodeBlockSet&gt; m_codeBlocks;
      std::unique_ptr&lt;JITStubRoutineSet&gt; m_jitStubRoutines;
<span class="line-modified">!     CFinalizerOwner m_cFinalizerOwner;</span>
<span class="line-added">+     LambdaFinalizerOwner m_lambdaFinalizerOwner;</span>
  
      Lock m_parallelSlotVisitorLock;
      bool m_isSafeToCollect { false };
      bool m_isShuttingDown { false };
      bool m_mutatorShouldBeFenced { Options::forceFencedBarrier() };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,11 ***</span>
      std::unique_ptr&lt;MarkStackArray&gt; m_sharedMutatorMarkStack;
      unsigned m_numberOfActiveParallelMarkers { 0 };
      unsigned m_numberOfWaitingParallelMarkers { 0 };
  
      ConcurrentPtrHashSet m_opaqueRoots;
<span class="line-modified">!     static const size_t s_blockFragmentLength = 32;</span>
  
      ParallelHelperClient m_helperClient;
      RefPtr&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; m_bonusVisitorTask;
  
  #if ENABLE(RESOURCE_USAGE)
<span class="line-new-header">--- 680,11 ---</span>
      std::unique_ptr&lt;MarkStackArray&gt; m_sharedMutatorMarkStack;
      unsigned m_numberOfActiveParallelMarkers { 0 };
      unsigned m_numberOfWaitingParallelMarkers { 0 };
  
      ConcurrentPtrHashSet m_opaqueRoots;
<span class="line-modified">!     static constexpr size_t s_blockFragmentLength = 32;</span>
  
      ParallelHelperClient m_helperClient;
      RefPtr&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; m_bonusVisitorTask;
  
  #if ENABLE(RESOURCE_USAGE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 688,16 ***</span>
      size_t m_externalMemorySize { 0 };
  #endif
  
      std::unique_ptr&lt;MutatorScheduler&gt; m_scheduler;
  
<span class="line-modified">!     static const unsigned mutatorHasConnBit = 1u &lt;&lt; 0u; // Must also be protected by threadLock.</span>
<span class="line-modified">!     static const unsigned stoppedBit = 1u &lt;&lt; 1u; // Only set when !hasAccessBit</span>
<span class="line-modified">!     static const unsigned hasAccessBit = 1u &lt;&lt; 2u;</span>
<span class="line-modified">!     static const unsigned gcDidJITBit = 1u &lt;&lt; 3u; // Set when the GC did some JITing, so on resume we need to cpuid.</span>
<span class="line-modified">!     static const unsigned needFinalizeBit = 1u &lt;&lt; 4u;</span>
<span class="line-modified">!     static const unsigned mutatorWaitingBit = 1u &lt;&lt; 5u; // Allows the mutator to use this as a condition variable.</span>
      Atomic&lt;unsigned&gt; m_worldState;
      bool m_worldIsStopped { false };
      Lock m_visitRaceLock;
      Lock m_markingMutex;
      Condition m_markingConditionVariable;
<span class="line-new-header">--- 692,16 ---</span>
      size_t m_externalMemorySize { 0 };
  #endif
  
      std::unique_ptr&lt;MutatorScheduler&gt; m_scheduler;
  
<span class="line-modified">!     static constexpr unsigned mutatorHasConnBit = 1u &lt;&lt; 0u; // Must also be protected by threadLock.</span>
<span class="line-modified">!     static constexpr unsigned stoppedBit = 1u &lt;&lt; 1u; // Only set when !hasAccessBit</span>
<span class="line-modified">!     static constexpr unsigned hasAccessBit = 1u &lt;&lt; 2u;</span>
<span class="line-modified">!     static constexpr unsigned gcDidJITBit = 1u &lt;&lt; 3u; // Set when the GC did some JITing, so on resume we need to cpuid.</span>
<span class="line-modified">!     static constexpr unsigned needFinalizeBit = 1u &lt;&lt; 4u;</span>
<span class="line-modified">!     static constexpr unsigned mutatorWaitingBit = 1u &lt;&lt; 5u; // Allows the mutator to use this as a condition variable.</span>
      Atomic&lt;unsigned&gt; m_worldState;
      bool m_worldIsStopped { false };
      Lock m_visitRaceLock;
      Lock m_markingMutex;
      Condition m_markingConditionVariable;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,13 ***</span>
      uintptr_t m_barriersExecuted { 0 };
  
      CurrentThreadState* m_currentThreadState { nullptr };
      Thread* m_currentThread { nullptr }; // It&#39;s OK if this becomes a dangling pointer.
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">!     unsigned m_precentAvailableMemoryCachedCallCount;</span>
<span class="line-modified">!     bool m_overCriticalMemoryThreshold;</span>
  #endif
  
      bool m_parallelMarkersShouldExit { false };
      Lock m_collectContinuouslyLock;
      Condition m_collectContinuouslyCondition;
<span class="line-new-header">--- 741,13 ---</span>
      uintptr_t m_barriersExecuted { 0 };
  
      CurrentThreadState* m_currentThreadState { nullptr };
      Thread* m_currentThread { nullptr }; // It&#39;s OK if this becomes a dangling pointer.
  
<span class="line-modified">! #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="line-modified">!     unsigned m_percentAvailableMemoryCachedCallCount { 0 };</span>
<span class="line-modified">!     bool m_overCriticalMemoryThreshold { false };</span>
  #endif
  
      bool m_parallelMarkersShouldExit { false };
      Lock m_collectContinuouslyLock;
      Condition m_collectContinuouslyCondition;
</pre>
<center><a href="Heap.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapCell.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
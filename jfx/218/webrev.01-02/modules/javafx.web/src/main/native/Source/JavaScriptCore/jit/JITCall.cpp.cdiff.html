<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITBitXorGenerator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCall32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITCall.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,11 ***</span>
  
  template&lt;typename Op&gt;
  void JIT::emitPutCallResult(const Op&amp; bytecode)
  {
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst.offset());</span>
  }
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID != op_call_varargs &amp;&amp; Op::opcodeID != op_construct_varargs
<span class="line-new-header">--- 49,11 ---</span>
  
  template&lt;typename Op&gt;
  void JIT::emitPutCallResult(const Op&amp; bytecode)
  {
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-modified">!     emitPutVirtualRegister(bytecode.m_dst);</span>
  }
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID != op_call_varargs &amp;&amp; Op::opcodeID != op_construct_varargs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,58 ***</span>
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int argCount = bytecode.m_argc;
      int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
  
      if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         emitGetVirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0), regT0);</span>
          Jump done = branchIfNotCell(regT0);
          load32(Address(regT0, JSCell::structureIDOffset()), regT0);
          store32(regT0, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
          done.link(this);
      }
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">!     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
  }
  
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
      || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
  , void&gt;
  JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
  {
<span class="line-modified">!     int thisValue = bytecode.m_thisValue.offset();</span>
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
<span class="line-modified">!     int firstFreeRegister = bytecode.m_firstFree.offset();</span>
      int firstVarArgOffset = bytecode.m_firstVarArg;
  
      emitGetVirtualRegister(arguments, regT1);
<span class="line-modified">!     Z_JITOperation_EJZZ sizeOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          sizeOperation = operationSizeFrameForForwardArguments;
      else
          sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">!     callOperation(sizeOperation, regT1, -firstFreeRegister, firstVarArgOffset);</span>
      move(TrustedImm32(-firstFreeRegister), regT1);
      emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
      addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), regT1, stackPointerRegister);
      emitGetVirtualRegister(arguments, regT2);
<span class="line-modified">!     F_JITOperation_EFJZZ setupOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          setupOperation = operationSetupForwardArgumentsFrame;
      else
          setupOperation = operationSetupVarargsFrame;
<span class="line-modified">!     callOperation(setupOperation, regT1, regT2, firstVarArgOffset, regT0);</span>
      move(returnValueGPR, regT1);
  
      // Profile the argument count.
<span class="line-modified">!     load32(Address(regT1, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">!     load32(info-&gt;addressOfMaxNumArguments(), regT0);</span>
      Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">!     store32(regT2, info-&gt;addressOfMaxNumArguments());</span>
      notBiggest.link(this);
  
      // Initialize &#39;this&#39;.
      emitGetVirtualRegister(thisValue, regT0);
      store64(regT0, Address(regT1, CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register))));
<span class="line-new-header">--- 64,58 ---</span>
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      int argCount = bytecode.m_argc;
      int registerOffset = -static_cast&lt;int&gt;(bytecode.m_argv);
  
      if (Op::opcodeID == op_call &amp;&amp; shouldEmitProfiling()) {
<span class="line-modified">!         emitGetVirtualRegister(VirtualRegister(registerOffset + CallFrame::argumentOffsetIncludingThis(0)), regT0);</span>
          Jump done = branchIfNotCell(regT0);
          load32(Address(regT0, JSCell::structureIDOffset()), regT0);
          store32(regT0, metadata.m_callLinkInfo.m_arrayProfile.addressOfLastSeenStructureID());
          done.link(this);
      }
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
<span class="line-modified">!     store32(TrustedImm32(argCount), Address(stackPointerRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset - sizeof(CallerFrameAndPC)));</span>
  }
  
  
  template&lt;typename Op&gt;
  std::enable_if_t&lt;
      Op::opcodeID == op_call_varargs || Op::opcodeID == op_construct_varargs
      || Op::opcodeID == op_tail_call_varargs || Op::opcodeID == op_tail_call_forward_arguments
  , void&gt;
  JIT::compileSetupFrame(const Op&amp; bytecode, CallLinkInfo* info)
  {
<span class="line-modified">!     VirtualRegister thisValue = bytecode.m_thisValue;</span>
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
<span class="line-modified">!     int firstFreeRegister = bytecode.m_firstFree.offset(); // FIXME: Why is this a virtual register if we never use it as one...</span>
      int firstVarArgOffset = bytecode.m_firstVarArg;
  
      emitGetVirtualRegister(arguments, regT1);
<span class="line-modified">!     Z_JITOperation_GJZZ sizeOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          sizeOperation = operationSizeFrameForForwardArguments;
      else
          sizeOperation = operationSizeFrameForVarargs;
<span class="line-modified">!     callOperation(sizeOperation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT1, -firstFreeRegister, firstVarArgOffset);</span>
      move(TrustedImm32(-firstFreeRegister), regT1);
      emitSetVarargsFrame(*this, returnValueGPR, false, regT1, regT1);
      addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), regT1, stackPointerRegister);
      emitGetVirtualRegister(arguments, regT2);
<span class="line-modified">!     F_JITOperation_GFJZZ setupOperation;</span>
      if (Op::opcodeID == op_tail_call_forward_arguments)
          setupOperation = operationSetupForwardArgumentsFrame;
      else
          setupOperation = operationSetupVarargsFrame;
<span class="line-modified">!     callOperation(setupOperation, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT1, regT2, firstVarArgOffset, regT0);</span>
      move(returnValueGPR, regT1);
  
      // Profile the argument count.
<span class="line-modified">!     load32(Address(regT1, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset), regT2);</span>
<span class="line-modified">!     load32(info-&gt;addressOfMaxArgumentCountIncludingThis(), regT0);</span>
      Jump notBiggest = branch32(Above, regT0, regT2);
<span class="line-modified">!     store32(regT2, info-&gt;addressOfMaxArgumentCountIncludingThis());</span>
      notBiggest.link(this);
  
      // Initialize &#39;this&#39;.
      emitGetVirtualRegister(thisValue, regT0);
      store64(regT0, Address(regT1, CallFrame::thisArgumentOffset() * static_cast&lt;int&gt;(sizeof(Register))));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,11 ***</span>
      storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
<span class="line-modified">!     callOperation(operationCallEval, regT1);</span>
  
      addSlowCase(branchIfEmpty(regT0));
  
      sampleCodeBlock(m_codeBlock);
  
<span class="line-new-header">--- 136,11 ---</span>
      storePtr(callFrameRegister, Address(regT1, CallFrame::callerFrameOffset()));
  
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
<span class="line-modified">!     callOperation(operationCallEval, m_codeBlock-&gt;globalObject(), regT1);</span>
  
      addSlowCase(branchIfEmpty(regT0));
  
      sampleCodeBlock(m_codeBlock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,18 ***</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
      CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeOffset), regT0);</span>
  
      int registerOffset = -bytecode.m_argv;
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
  
      load64(Address(stackPointerRegister, sizeof(Register) * CallFrameSlot::callee - sizeof(CallerFrameAndPC)), regT0);
<span class="line-modified">!     emitDumbVirtualCall(vm(), info);</span>
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
      sampleCodeBlock(m_codeBlock);
  
<span class="line-new-header">--- 153,18 ---</span>
  {
      linkAllSlowCases(iter);
  
      auto bytecode = instruction-&gt;as&lt;OpCallEval&gt;();
      CallLinkInfo* info = m_codeBlock-&gt;addCallLinkInfo();
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(m_bytecodeIndex), regT0);</span>
  
      int registerOffset = -bytecode.m_argv;
  
      addPtr(TrustedImm32(registerOffset * sizeof(Register) + sizeof(CallerFrameAndPC)), callFrameRegister, stackPointerRegister);
  
      load64(Address(stackPointerRegister, sizeof(Register) * CallFrameSlot::callee - sizeof(CallerFrameAndPC)), regT0);
<span class="line-modified">!     emitDumbVirtualCall(vm(), m_codeBlock-&gt;globalObject(), info);</span>
      addPtr(TrustedImm32(stackPointerOffsetFor(m_codeBlock) * sizeof(Register)), callFrameRegister, stackPointerRegister);
      checkStackPointerAlignment();
  
      sampleCodeBlock(m_codeBlock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,18 ***</span>
  template&lt;&gt;
  bool JIT::compileTailCall(const OpTailCall&amp; bytecode, CallLinkInfo* info, unsigned callLinkInfoIndex)
  {
      CallFrameShuffleData shuffleData;
      shuffleData.numPassedArgs = bytecode.m_argc;
<span class="line-modified">!     shuffleData.tagTypeNumber = GPRInfo::tagTypeNumberRegister;</span>
      shuffleData.numLocals =
          bytecode.m_argv - sizeof(CallerFrameAndPC) / sizeof(Register);
      shuffleData.args.resize(bytecode.m_argc);
      for (unsigned i = 0; i &lt; bytecode.m_argc; ++i) {
          shuffleData.args[i] =
              ValueRecovery::displacedInJSStack(
<span class="line-modified">!                 virtualRegisterForArgument(i) - bytecode.m_argv,</span>
                  DataFormatJS);
      }
      shuffleData.callee =
          ValueRecovery::inGPR(regT0, DataFormatJS);
      shuffleData.setupCalleeSaveRegisters(m_codeBlock);
<span class="line-new-header">--- 180,18 ---</span>
  template&lt;&gt;
  bool JIT::compileTailCall(const OpTailCall&amp; bytecode, CallLinkInfo* info, unsigned callLinkInfoIndex)
  {
      CallFrameShuffleData shuffleData;
      shuffleData.numPassedArgs = bytecode.m_argc;
<span class="line-modified">!     shuffleData.numberTagRegister = GPRInfo::numberTagRegister;</span>
      shuffleData.numLocals =
          bytecode.m_argv - sizeof(CallerFrameAndPC) / sizeof(Register);
      shuffleData.args.resize(bytecode.m_argc);
      for (unsigned i = 0; i &lt; bytecode.m_argc; ++i) {
          shuffleData.args[i] =
              ValueRecovery::displacedInJSStack(
<span class="line-modified">!                 virtualRegisterForArgumentIncludingThis(i) - bytecode.m_argv,</span>
                  DataFormatJS);
      }
      shuffleData.callee =
          ValueRecovery::inGPR(regT0, DataFormatJS);
      shuffleData.setupCalleeSaveRegisters(m_codeBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,11 ***</span>
  template&lt;typename Op&gt;
  void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
  {
      OpcodeID opcodeID = Op::opcodeID;
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     int callee = bytecode.m_callee.offset();</span>
  
      /* Caller always:
          - Updates callFrameRegister to callee callFrame.
          - Initializes ArgumentCount; CallerFrame; Callee.
  
<span class="line-new-header">--- 204,11 ---</span>
  template&lt;typename Op&gt;
  void JIT::compileOpCall(const Instruction* instruction, unsigned callLinkInfoIndex)
  {
      OpcodeID opcodeID = Op::opcodeID;
      auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">!     VirtualRegister callee = bytecode.m_callee;</span>
  
      /* Caller always:
          - Updates callFrameRegister to callee callFrame.
          - Initializes ArgumentCount; CallerFrame; Callee.
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,13 ***</span>
      if (opcodeID != op_call_eval)
          info = m_codeBlock-&gt;addCallLinkInfo();
      compileSetupFrame(bytecode, info);
  
      // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
<span class="line-modified">!     uint32_t bytecodeOffset = m_codeBlock-&gt;bytecodeOffset(instruction);</span>
<span class="line-modified">!     uint32_t locationBits = CallSiteIndex(bytecodeOffset).bits();</span>
<span class="line-modified">!     store32(TrustedImm32(locationBits), Address(callFrameRegister, CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset));</span>
  
      emitGetVirtualRegister(callee, regT0); // regT0 holds callee.
      store64(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) - sizeof(CallerFrameAndPC)));
  
      if (compileCallEval(bytecode)) {
<span class="line-new-header">--- 224,13 ---</span>
      if (opcodeID != op_call_eval)
          info = m_codeBlock-&gt;addCallLinkInfo();
      compileSetupFrame(bytecode, info);
  
      // SP holds newCallFrame + sizeof(CallerFrameAndPC), with ArgumentCount initialized.
<span class="line-modified">!     auto bytecodeIndex = m_codeBlock-&gt;bytecodeIndex(instruction);</span>
<span class="line-modified">!     uint32_t locationBits = CallSiteIndex(bytecodeIndex).bits();</span>
<span class="line-modified">!     store32(TrustedImm32(locationBits), Address(callFrameRegister, CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + TagOffset));</span>
  
      emitGetVirtualRegister(callee, regT0); // regT0 holds callee.
      store64(regT0, Address(stackPointerRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register)) - sizeof(CallerFrameAndPC)));
  
      if (compileCallEval(bytecode)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 240,11 ***</span>
      DataLabelPtr addressOfLinkedFunctionCheck;
      Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
      addSlowCase(slowCase);
  
      ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeOffset), regT0);</span>
      m_callCompilationInfo.append(CallCompilationInfo());
      m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
      m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
  
      if (compileTailCall(bytecode, info, callLinkInfoIndex)) {
<span class="line-new-header">--- 240,11 ---</span>
      DataLabelPtr addressOfLinkedFunctionCheck;
      Jump slowCase = branchPtrWithPatch(NotEqual, regT0, addressOfLinkedFunctionCheck, TrustedImmPtr(nullptr));
      addSlowCase(slowCase);
  
      ASSERT(m_callCompilationInfo.size() == callLinkInfoIndex);
<span class="line-modified">!     info-&gt;setUpCall(CallLinkInfo::callTypeFor(opcodeID), CodeOrigin(m_bytecodeIndex), regT0);</span>
      m_callCompilationInfo.append(CallCompilationInfo());
      m_callCompilationInfo[callLinkInfoIndex].hotPathBegin = addressOfLinkedFunctionCheck;
      m_callCompilationInfo[callLinkInfoIndex].callLinkInfo = info;
  
      if (compileTailCall(bytecode, info, callLinkInfoIndex)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,10 ***</span>
<span class="line-new-header">--- 277,11 ---</span>
      linkAllSlowCases(iter);
  
      if (opcodeID == op_tail_call || opcodeID == op_tail_call_varargs || opcodeID == op_tail_call_forward_arguments)
          emitRestoreCalleeSaves();
  
<span class="line-added">+     move(TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT3);</span>
      move(TrustedImmPtr(m_callCompilationInfo[callLinkInfoIndex].callLinkInfo), regT2);
  
      m_callCompilationInfo[callLinkInfoIndex].callReturnLocation =
          emitNakedCall(m_vm-&gt;getCTIStub(linkCallThunkGenerator).retaggedCode&lt;NoPtrTag&gt;());
  
</pre>
<center><a href="JITBitXorGenerator.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITCall32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3PatchpointSpecial.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3PatchpointSpecial.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3PatchpointSpecial.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/B3PatchpointSpecial.cpp
@@ -52,11 +52,11 @@
     const Procedure& procedure = code().proc();
     PatchpointValue* patchpoint = inst.origin->as<PatchpointValue>();
     unsigned argIndex = 1;
 
     Type type = patchpoint->type();
-    for (; argIndex <= procedure.returnCount(type); ++argIndex) {
+    for (; argIndex <= procedure.resultCount(type); ++argIndex) {
         Arg::Role role;
         if (patchpoint->resultConstraints[argIndex - 1].kind() == ValueRep::SomeEarlyRegister)
             role = Arg::EarlyDef;
         else
             role = Arg::Def;
@@ -79,11 +79,11 @@
     const Procedure& procedure = code().proc();
     PatchpointValue* patchpoint = inst.origin->as<PatchpointValue>();
     unsigned argIndex = 1;
 
     Type type = patchpoint->type();
-    for (; argIndex <= procedure.returnCount(type); ++argIndex) {
+    for (; argIndex <= procedure.resultCount(type); ++argIndex) {
         if (argIndex >= inst.args.size())
             return false;
 
         if (!isArgValidForType(inst.args[argIndex], type.isTuple() ? procedure.extractFromTuple(type, argIndex - 1) : type))
             return false;
@@ -116,11 +116,11 @@
 bool PatchpointSpecial::admitsStack(Inst& inst, unsigned argIndex)
 {
     ASSERT(argIndex);
 
     Type type = inst.origin->type();
-    unsigned returnCount = code().proc().returnCount(type);
+    unsigned returnCount = code().proc().resultCount(type);
 
     if (argIndex <= returnCount) {
         switch (inst.origin->as<PatchpointValue>()->resultConstraints[argIndex - 1].kind()) {
         case ValueRep::WarmAny:
         case ValueRep::StackArgument:
@@ -144,21 +144,21 @@
 bool PatchpointSpecial::admitsExtendedOffsetAddr(Inst& inst, unsigned argIndex)
 {
     return admitsStack(inst, argIndex);
 }
 
-CCallHelpers::Jump PatchpointSpecial::generate(Inst& inst, CCallHelpers& jit, Air::GenerationContext& context)
+MacroAssembler::Jump PatchpointSpecial::generate(Inst& inst, CCallHelpers& jit, Air::GenerationContext& context)
 {
     const Procedure& procedure = code().proc();
     PatchpointValue* value = inst.origin->as<PatchpointValue>();
     ASSERT(value);
 
     Vector<ValueRep> reps;
     unsigned offset = 1;
 
     Type type = value->type();
-    while (offset <= procedure.returnCount(type))
+    while (offset <= procedure.resultCount(type))
         reps.append(repForArg(*context.code, inst.args[offset++]));
     reps.appendVector(repsImpl(context, 0, offset, inst));
     offset += value->numChildren();
 
     StackmapGenerationParams params(value, reps, context);
@@ -168,11 +168,11 @@
     for (unsigned i = value->numFPScratchRegisters; i--;)
         params.m_fpScratch.append(inst.args[offset++].fpr());
 
     value->m_generator->run(jit, params);
 
-    return CCallHelpers::Jump();
+    return MacroAssembler::Jump();
 }
 
 bool PatchpointSpecial::isTerminal(Inst& inst)
 {
     return inst.origin->as<PatchpointValue>()->effects.terminal;

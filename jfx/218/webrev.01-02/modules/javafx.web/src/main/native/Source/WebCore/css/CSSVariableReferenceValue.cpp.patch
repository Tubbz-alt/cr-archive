diff a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSVariableReferenceValue.cpp
@@ -29,10 +29,11 @@
 
 #include "config.h"
 #include "CSSVariableReferenceValue.h"
 
 #include "RenderStyle.h"
+#include "StyleBuilder.h"
 #include "StyleResolver.h"
 
 namespace WebCore {
 
 String CSSVariableReferenceValue::customCSSText() const
@@ -42,37 +43,37 @@
         m_stringValue = m_data->tokenRange().serialize();
     }
     return m_stringValue;
 }
 
-static bool resolveTokenRange(CSSParserTokenRange, Vector<CSSParserToken>&, ApplyCascadedPropertyState&);
+static bool resolveTokenRange(CSSParserTokenRange, Vector<CSSParserToken>&, Style::BuilderState&);
 
-static bool resolveVariableFallback(CSSParserTokenRange range, Vector<CSSParserToken>& result, ApplyCascadedPropertyState& state)
+static bool resolveVariableFallback(CSSParserTokenRange range, Vector<CSSParserToken>& result, Style::BuilderState& builderState)
 {
     if (range.atEnd())
         return false;
     ASSERT(range.peek().type() == CommaToken);
     range.consume();
-    return resolveTokenRange(range, result, state);
+    return resolveTokenRange(range, result, builderState);
 }
 
-static bool resolveVariableReference(CSSParserTokenRange range, Vector<CSSParserToken>& result, ApplyCascadedPropertyState& state)
+static bool resolveVariableReference(CSSParserTokenRange range, Vector<CSSParserToken>& result, Style::BuilderState& builderState)
 {
-    auto& registeredProperties = state.styleResolver->document().getCSSRegisteredCustomPropertySet();
-    auto& style = *state.styleResolver->style();
+    auto& registeredProperties = builderState.document().getCSSRegisteredCustomPropertySet();
+    auto& style = builderState.style();
 
     range.consumeWhitespace();
     ASSERT(range.peek().type() == IdentToken);
     String variableName = range.consumeIncludingWhitespace().value().toString();
     ASSERT(range.atEnd() || (range.peek().type() == CommaToken));
 
     // Apply this variable first, in case it is still unresolved
-    state.styleResolver->applyCascadedCustomProperty(variableName, state);
+    builderState.builder().applyCustomProperty(variableName);
 
     // Apply fallback to detect cycles
     Vector<CSSParserToken> fallbackResult;
-    bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, state);
+    bool fallbackReturn = resolveVariableFallback(CSSParserTokenRange(range), fallbackResult, builderState);
 
     auto* property = style.getCustomProperty(variableName);
 
     if (!property || property->isUnset()) {
         auto* registered = registeredProperties.get(variableName);
@@ -90,28 +91,28 @@
     result.appendVector(property->tokens());
 
     return true;
 }
 
-static bool resolveTokenRange(CSSParserTokenRange range, Vector<CSSParserToken>& result, ApplyCascadedPropertyState& state)
+static bool resolveTokenRange(CSSParserTokenRange range, Vector<CSSParserToken>& result, Style::BuilderState& builderState)
 {
     bool success = true;
     while (!range.atEnd()) {
         if (range.peek().functionId() == CSSValueVar || range.peek().functionId() == CSSValueEnv)
-            success &= resolveVariableReference(range.consumeBlock(), result, state);
+            success &= resolveVariableReference(range.consumeBlock(), result, builderState);
         else
             result.append(range.consume());
     }
     return success;
 }
 
-RefPtr<CSSVariableData> CSSVariableReferenceValue::resolveVariableReferences(ApplyCascadedPropertyState& state) const
+RefPtr<CSSVariableData> CSSVariableReferenceValue::resolveVariableReferences(Style::BuilderState& builderState) const
 {
     Vector<CSSParserToken> resolvedTokens;
     CSSParserTokenRange range = m_data->tokenRange();
 
-    if (!resolveTokenRange(range, resolvedTokens, state))
+    if (!resolveTokenRange(range, resolvedTokens, builderState))
         return nullptr;
 
     return CSSVariableData::create(resolvedTokens);
 }
 

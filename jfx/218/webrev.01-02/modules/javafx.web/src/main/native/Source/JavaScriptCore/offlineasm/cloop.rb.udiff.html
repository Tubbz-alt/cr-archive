<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="asm.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -86,13 +86,13 @@</span>
          when &quot;t5&quot;
              &quot;t5&quot;
          when &quot;csr0&quot;
              &quot;pcBase&quot;
          when &quot;csr1&quot;
<span class="udiff-line-modified-removed">-             &quot;tagTypeNumber&quot;</span>
<span class="udiff-line-modified-added">+             &quot;numberTag&quot;</span>
          when &quot;csr2&quot;
<span class="udiff-line-modified-removed">-             &quot;tagMask&quot;</span>
<span class="udiff-line-modified-added">+             &quot;notCellMask&quot;</span>
          when &quot;csr3&quot;
              &quot;metadataTable&quot;
          when &quot;cfr&quot;
              &quot;cfr&quot;
          when &quot;lr&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158,10 +158,11 @@</span>
  
          valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
  
          case type
          when :int8;    &quot;int8_t(#{valueStr})&quot;
<span class="udiff-line-added">+         when :int16;   &quot;int16_t(#{valueStr})&quot;</span>
          when :int32;   &quot;int32_t(#{valueStr})&quot;
          when :int64;   &quot;int64_t(#{valueStr})&quot;
          when :intptr;  &quot;intptr_t(#{valueStr})&quot;
          when :uint8;   &quot;uint8_t(#{valueStr})&quot;
          when :uint32;  &quot;uint32_t(#{valueStr})&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -181,10 +182,11 @@</span>
          clValue(type)
      end
      def clValue(type=:intptr)
          case type
          when :int8;         int8MemRef
<span class="udiff-line-added">+         when :int16;        int16MemRef</span>
          when :int32;        int32MemRef
          when :int64;        int64MemRef
          when :intptr;       intptrMemRef
          when :uint8;        uint8MemRef
          when :uint32;       uint32MemRef
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,11 +386,11 @@</span>
  end
  
  
  def cloopEmitOperation(operands, type, operator)
      raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \
<span class="udiff-line-modified-removed">-         type == :int64 || type == :uint64 || type == :double</span>
<span class="udiff-line-modified-added">+         type == :int64 || type == :uint64 || type == :double || type == :int16</span>
      if operands.size == 3
          op1 = operands[0]
          op2 = operands[1]
          dst = operands[2]
      else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,10 +401,13 @@</span>
      end
      raise unless not dst.is_a? Immediate
      if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
          truncationHeader = &quot;(uint32_t)(&quot;
          truncationFooter = &quot;)&quot;
<span class="udiff-line-added">+     elsif dst.is_a? RegisterID and (type == :int16)</span>
<span class="udiff-line-added">+         truncationHeader = &quot;(uint16_t)(&quot;</span>
<span class="udiff-line-added">+         truncationFooter = &quot;)&quot;</span>
      else
          truncationHeader = &quot;&quot;
          truncationFooter = &quot;&quot;
      end
      $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -583,10 +588,12 @@</span>
              cloopEmitOperation(operands, :int32, &quot;|&quot;)
          when &quot;orq&quot;
              cloopEmitOperation(operands, :int64, &quot;|&quot;)
          when &quot;orp&quot;
              cloopEmitOperation(operands, :intptr, &quot;|&quot;)
<span class="udiff-line-added">+         when &quot;orh&quot;</span>
<span class="udiff-line-added">+             cloopEmitOperation(operands, :int16, &quot;|&quot;)</span>
  
          when &quot;xori&quot;
              cloopEmitOperation(operands, :int32, &quot;^&quot;)
          when &quot;xorq&quot;
              cloopEmitOperation(operands, :int64, &quot;^&quot;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -683,12 +690,12 @@</span>
              cloopEmitOperation(operands, :double, &quot;-&quot;)
          when &quot;muld&quot;
              cloopEmitOperation(operands, :double, &quot;*&quot;)
  
          # Convert an int value to its double equivalent, and store it in a double register.
<span class="udiff-line-modified-removed">-         when &quot;ci2d&quot;</span>
<span class="udiff-line-modified-removed">-             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2d&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ci2ds&quot;</span>
<span class="udiff-line-modified-added">+             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2ds&quot;</span>
  
          when &quot;bdeq&quot;
              cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
          when &quot;bdneq&quot;
              cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1124,15 +1131,15 @@</span>
              $asm.putc &quot;DISPATCH_OPCODE();&quot;
              $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
  
          # We can&#39;t do generic function calls with an arbitrary set of args, but
          # fortunately we don&#39;t have to here. All native function calls always
<span class="udiff-line-modified-removed">-         # have a fixed prototype of 1 args: the passed ExecState.</span>
<span class="udiff-line-modified-added">+         # have a fixed prototype of 2 args: the passed JSGlobalObject* and CallFrame*.</span>
          when &quot;cloopCallNative&quot;
              $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
              $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
<span class="udiff-line-modified-removed">-             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(t0.execState()));&quot;</span>
<span class="udiff-line-modified-added">+             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(jsCast&lt;JSGlobalObject*&gt;(t0.cell()), t1.callFrame()));&quot;</span>
              $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
              $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
              $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
              $asm.putc &quot;#else // USE_JSVALUE64)&quot;
              $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
</pre>
<center><a href="asm.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="instructions.rb.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
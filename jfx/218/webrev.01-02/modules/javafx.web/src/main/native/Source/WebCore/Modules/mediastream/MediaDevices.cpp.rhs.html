<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaDevices.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Ericsson AB. All rights reserved.
  3  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer
 13  *    in the documentation and/or other materials provided with the
 14  *    distribution.
 15  * 3. Neither the name of Ericsson nor the names of its contributors
 16  *    may be used to endorse or promote products derived from this
 17  *    software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;MediaDevices.h&quot;
 34 
 35 #if ENABLE(MEDIA_STREAM)
 36 
 37 #include &quot;Document.h&quot;
 38 #include &quot;Event.h&quot;
 39 #include &quot;EventNames.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 40 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 41 #include &quot;JSMediaDeviceInfo.h&quot;
 42 #include &quot;MediaTrackSupportedConstraints.h&quot;
 43 #include &quot;RealtimeMediaSourceSettings.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 44 #include &quot;UserGestureIndicator.h&quot;</span>
 45 #include &quot;UserMediaController.h&quot;
 46 #include &quot;UserMediaRequest.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;
 48 #include &lt;wtf/RandomNumber.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaDevices);
 53 
 54 inline MediaDevices::MediaDevices(Document&amp; document)
 55     : ActiveDOMObject(document)
 56     , m_scheduledEventTimer(*this, &amp;MediaDevices::scheduledEventTimerFired)
 57     , m_eventNames(eventNames())
 58 {
 59     suspendIfNeeded();
 60 
 61     static_assert(static_cast&lt;size_t&gt;(MediaDevices::DisplayCaptureSurfaceType::Monitor) == static_cast&lt;size_t&gt;(RealtimeMediaSourceSettings::DisplaySurfaceType::Monitor), &quot;MediaDevices::DisplayCaptureSurfaceType::Monitor is not equal to RealtimeMediaSourceSettings::DisplaySurfaceType::Monitor as expected&quot;);
 62     static_assert(static_cast&lt;size_t&gt;(MediaDevices::DisplayCaptureSurfaceType::Window) == static_cast&lt;size_t&gt;(RealtimeMediaSourceSettings::DisplaySurfaceType::Window), &quot;MediaDevices::DisplayCaptureSurfaceType::Window is not RealtimeMediaSourceSettings::DisplaySurfaceType::Window as expected&quot;);
 63     static_assert(static_cast&lt;size_t&gt;(MediaDevices::DisplayCaptureSurfaceType::Application) == static_cast&lt;size_t&gt;(RealtimeMediaSourceSettings::DisplaySurfaceType::Application), &quot;MediaDevices::DisplayCaptureSurfaceType::Application is not RealtimeMediaSourceSettings::DisplaySurfaceType::Application as expected&quot;);
 64     static_assert(static_cast&lt;size_t&gt;(MediaDevices::DisplayCaptureSurfaceType::Browser) == static_cast&lt;size_t&gt;(RealtimeMediaSourceSettings::DisplaySurfaceType::Browser), &quot;MediaDevices::DisplayCaptureSurfaceType::Browser is not RealtimeMediaSourceSettings::DisplaySurfaceType::Browser as expected&quot;);
<a name="3" id="anc3"></a>




 65 }
 66 
 67 MediaDevices::~MediaDevices() = default;
 68 
 69 void MediaDevices::stop()
 70 {
 71     if (m_deviceChangeToken) {
 72         auto* controller = UserMediaController::from(document()-&gt;page());
<a name="4" id="anc4"></a><span class="line-modified"> 73         if (controller)</span>
<span class="line-added"> 74             controller-&gt;removeDeviceChangeObserver(m_deviceChangeToken);</span>
 75     }
 76     m_devices.clear();
 77     m_scheduledEventTimer.stop();
 78 }
 79 
 80 Ref&lt;MediaDevices&gt; MediaDevices::create(Document&amp; document)
 81 {
 82     return adoptRef(*new MediaDevices(document));
 83 }
 84 
 85 Document* MediaDevices::document() const
 86 {
 87     return downcast&lt;Document&gt;(scriptExecutionContext());
 88 }
 89 
 90 static MediaConstraints createMediaConstraints(const Variant&lt;bool, MediaTrackConstraints&gt;&amp; constraints)
 91 {
 92     return WTF::switchOn(constraints,
 93         [&amp;] (bool isValid) {
 94             MediaConstraints constraints;
 95             constraints.isValid = isValid;
 96             return constraints;
 97         },
 98         [&amp;] (const MediaTrackConstraints&amp; trackConstraints) {
 99             return createMediaConstraints(trackConstraints);
100         }
101     );
102 }
103 
<a name="5" id="anc5"></a><span class="line-modified">104 bool MediaDevices::computeUserGesturePriviledge(GestureAllowedRequest requestType)</span>
<span class="line-added">105 {</span>
<span class="line-added">106     auto* currentGestureToken = UserGestureIndicator::currentUserGesture().get();</span>
<span class="line-added">107     if (m_currentGestureToken.get() != currentGestureToken) {</span>
<span class="line-added">108         m_currentGestureToken = makeWeakPtr(currentGestureToken);</span>
<span class="line-added">109         m_requestTypesForCurrentGesture = { };</span>
<span class="line-added">110     }</span>
<span class="line-added">111 </span>
<span class="line-added">112     bool isUserGesturePriviledged = m_currentGestureToken &amp;&amp; !m_requestTypesForCurrentGesture.contains(requestType);</span>
<span class="line-added">113     m_requestTypesForCurrentGesture.add(requestType);</span>
<span class="line-added">114     return isUserGesturePriviledged;</span>
<span class="line-added">115 }</span>
<span class="line-added">116 </span>
<span class="line-added">117 void MediaDevices::getUserMedia(const StreamConstraints&amp; constraints, Promise&amp;&amp; promise)</span>
118 {
119     auto* document = this-&gt;document();
<a name="6" id="anc6"></a><span class="line-modified">120     if (!document || !document-&gt;isFullyActive()) {</span>
<span class="line-added">121         promise.reject(Exception { InvalidStateError, &quot;Document is not fully active&quot;_s });</span>
122         return;
<a name="7" id="anc7"></a><span class="line-added">123     }</span>
124 
125     auto audioConstraints = createMediaConstraints(constraints.audio);
126     auto videoConstraints = createMediaConstraints(constraints.video);
<a name="8" id="anc8"></a><span class="line-modified">127 </span>
<span class="line-added">128     bool isUserGesturePriviledged = false;</span>
<span class="line-added">129 </span>
<span class="line-added">130     if (audioConstraints.isValid)</span>
<span class="line-added">131         isUserGesturePriviledged |= computeUserGesturePriviledge(GestureAllowedRequest::Microphone);</span>
<span class="line-added">132 </span>
<span class="line-added">133     if (videoConstraints.isValid) {</span>
<span class="line-added">134         isUserGesturePriviledged |= computeUserGesturePriviledge(GestureAllowedRequest::Camera);</span>
135         videoConstraints.setDefaultVideoConstraints();
<a name="9" id="anc9"></a><span class="line-added">136     }</span>
137 
<a name="10" id="anc10"></a><span class="line-modified">138     auto request = UserMediaRequest::create(*document, { MediaStreamRequest::Type::UserMedia, WTFMove(audioConstraints), WTFMove(videoConstraints), isUserGesturePriviledged }, WTFMove(promise));</span>
139     request-&gt;start();
140 }
141 
<a name="11" id="anc11"></a><span class="line-modified">142 void MediaDevices::getDisplayMedia(const DisplayMediaStreamConstraints&amp; constraints, Promise&amp;&amp; promise)</span>
143 {
144     auto* document = this-&gt;document();
145     if (!document)
146         return;
147 
<a name="12" id="anc12"></a><span class="line-modified">148     bool isUserGesturePriviledged = computeUserGesturePriviledge(GestureAllowedRequest::Display);</span>
<span class="line-added">149     if (!isUserGesturePriviledged) {</span>
150         promise.reject(Exception { InvalidAccessError, &quot;getDisplayMedia must be called from a user gesture handler.&quot;_s });
151         return;
152     }
153 
<a name="13" id="anc13"></a><span class="line-modified">154     auto request = UserMediaRequest::create(*document, { MediaStreamRequest::Type::DisplayMedia, { }, createMediaConstraints(constraints.video), isUserGesturePriviledged }, WTFMove(promise));</span>
155     request-&gt;start();
156 }
157 
<a name="14" id="anc14"></a><span class="line-added">158 static inline bool checkCameraAccess(const Document&amp; document)</span>
<span class="line-added">159 {</span>
<span class="line-added">160     return isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Camera, document, LogFeaturePolicyFailure::No);</span>
<span class="line-added">161 }</span>
<span class="line-added">162 </span>
<span class="line-added">163 static inline bool checkMicrophoneAccess(const Document&amp; document)</span>
<span class="line-added">164 {</span>
<span class="line-added">165     return isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Microphone, document, LogFeaturePolicyFailure::No);</span>
<span class="line-added">166 }</span>
<span class="line-added">167 </span>
168 void MediaDevices::refreshDevices(const Vector&lt;CaptureDevice&gt;&amp; newDevices)
169 {
<a name="15" id="anc15"></a><span class="line-added">170     auto* document = this-&gt;document();</span>
<span class="line-added">171     if (!document)</span>
<span class="line-added">172         return;</span>
<span class="line-added">173 </span>
<span class="line-added">174     bool canAccessCamera = checkCameraAccess(*document);</span>
<span class="line-added">175     bool canAccessMicrophone = checkMicrophoneAccess(*document);</span>
<span class="line-added">176 </span>
177     Vector&lt;Ref&lt;MediaDeviceInfo&gt;&gt; devices;
178     for (auto&amp; newDevice : newDevices) {
<a name="16" id="anc16"></a><span class="line-modified">179         if (!canAccessMicrophone &amp;&amp; newDevice.type() == CaptureDevice::DeviceType::Microphone)</span>
180             continue;
<a name="17" id="anc17"></a><span class="line-modified">181         if (!canAccessCamera &amp;&amp; newDevice.type() == CaptureDevice::DeviceType::Camera)</span>
182             continue;
183 
184         auto index = m_devices.findMatching([&amp;newDevice](auto&amp; oldDevice) {
185             return oldDevice-&gt;deviceId() == newDevice.persistentId();
186         });
187         if (index != notFound) {
188             devices.append(m_devices[index].copyRef());
189             continue;
190         }
191 
192         auto deviceType = newDevice.type() == CaptureDevice::DeviceType::Microphone ? MediaDeviceInfo::Kind::Audioinput : MediaDeviceInfo::Kind::Videoinput;
193         devices.append(MediaDeviceInfo::create(newDevice.label(), newDevice.persistentId(), newDevice.groupId(), deviceType));
194     }
195     m_devices = WTFMove(devices);
196 }
197 
198 void MediaDevices::enumerateDevices(EnumerateDevicesPromise&amp;&amp; promise)
199 {
200     auto* document = this-&gt;document();
201     if (!document)
202         return;
203 
204     auto* controller = UserMediaController::from(document-&gt;page());
205     if (!controller) {
206         promise.resolve({ });
207         return;
208     }
<a name="18" id="anc18"></a><span class="line-modified">209 </span>
<span class="line-modified">210     if (!checkCameraAccess(*document) &amp;&amp; !checkMicrophoneAccess(*document)) {</span>
<span class="line-added">211         controller-&gt;logEnumerateDevicesDenial(*document);</span>
212         promise.resolve({ });
213         return;
214     }
215 
216     controller-&gt;enumerateMediaDevices(*document, [this, weakThis = makeWeakPtr(this), promise = WTFMove(promise)](const auto&amp; newDevices, const auto&amp; deviceIDHashSalt) mutable {
217         if (!weakThis || isContextStopped())
218             return;
219 
220         this-&gt;document()-&gt;setDeviceIDHashSalt(deviceIDHashSalt);
221         refreshDevices(newDevices);
222         promise.resolve(m_devices);
223     });
224 }
225 
226 MediaTrackSupportedConstraints MediaDevices::getSupportedConstraints()
227 {
228     auto&amp; supported = RealtimeMediaSourceCenter::singleton().supportedConstraints();
229     MediaTrackSupportedConstraints result;
230     result.width = supported.supportsWidth();
231     result.height = supported.supportsHeight();
232     result.aspectRatio = supported.supportsAspectRatio();
233     result.frameRate = supported.supportsFrameRate();
234     result.facingMode = supported.supportsFacingMode();
235     result.volume = supported.supportsVolume();
236     result.sampleRate = supported.supportsSampleRate();
237     result.sampleSize = supported.supportsSampleSize();
238     result.echoCancellation = supported.supportsEchoCancellation();
239     result.deviceId = supported.supportsDeviceId();
240     result.groupId = supported.supportsGroupId();
241 
242     return result;
243 }
244 
245 void MediaDevices::scheduledEventTimerFired()
246 {
247     ASSERT(!isContextStopped());
248     dispatchEvent(Event::create(eventNames().devicechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));
249 }
250 
251 bool MediaDevices::hasPendingActivity() const
252 {
253     return !isContextStopped() &amp;&amp; hasEventListeners(m_eventNames.devicechangeEvent);
254 }
255 
256 const char* MediaDevices::activeDOMObjectName() const
257 {
258     return &quot;MediaDevices&quot;;
259 }
260 
<a name="19" id="anc19"></a>




261 void MediaDevices::listenForDeviceChanges()
262 {
<a name="20" id="anc20"></a>




263     auto* document = this-&gt;document();
264     auto* controller = document ? UserMediaController::from(document-&gt;page()) : nullptr;
265     if (!controller)
266         return;
267 
<a name="21" id="anc21"></a><span class="line-added">268     bool canAccessCamera = isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Camera, *document, LogFeaturePolicyFailure::No);</span>
<span class="line-added">269     bool canAccessMicrophone = isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Microphone, *document, LogFeaturePolicyFailure::No);</span>
<span class="line-added">270 </span>
<span class="line-added">271     if (m_listeningForDeviceChanges || (!canAccessCamera &amp;&amp; !canAccessMicrophone))</span>
<span class="line-added">272         return;</span>
<span class="line-added">273 </span>
<span class="line-added">274     m_listeningForDeviceChanges = true;</span>
<span class="line-added">275 </span>
276     m_deviceChangeToken = controller-&gt;addDeviceChangeObserver([weakThis = makeWeakPtr(*this), this]() {
277         if (!weakThis || isContextStopped() || m_scheduledEventTimer.isActive())
278             return;
279 
280         m_scheduledEventTimer.startOneShot(Seconds(randomNumber() / 2));
281     });
282 }
283 
284 bool MediaDevices::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
285 {
286     if (eventType == eventNames().devicechangeEvent)
287         listenForDeviceChanges();
288 
289     return EventTargetWithInlineData::addEventListener(eventType, WTFMove(listener), options);
290 }
291 
292 } // namespace WebCore
293 
294 #endif // ENABLE(MEDIA_STREAM)
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/PropertyCascade.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PropertyCascade.h&quot;
 28 
 29 #include &quot;CSSPaintImageValue.h&quot;
 30 #include &quot;CSSPrimitiveValueMappings.h&quot;
 31 #include &quot;CSSValuePool.h&quot;
 32 #include &quot;PaintWorkletGlobalScope.h&quot;
 33 #include &quot;StyleBuilderGenerated.h&quot;
 34 #include &quot;StylePropertyShorthand.h&quot;
 35 
 36 namespace WebCore {
 37 namespace Style {
 38 
 39 static inline bool shouldApplyPropertyInParseOrder(CSSPropertyID propertyID)
 40 {
 41     switch (propertyID) {
 42     case CSSPropertyWebkitBackgroundClip:
 43     case CSSPropertyBackgroundClip:
 44     case CSSPropertyWebkitBackgroundOrigin:
 45     case CSSPropertyBackgroundOrigin:
 46     case CSSPropertyWebkitBackgroundSize:
 47     case CSSPropertyBackgroundSize:
 48     case CSSPropertyWebkitBorderImage:
 49     case CSSPropertyBorderImage:
 50     case CSSPropertyBorderImageSlice:
 51     case CSSPropertyBorderImageSource:
 52     case CSSPropertyBorderImageOutset:
 53     case CSSPropertyBorderImageRepeat:
 54     case CSSPropertyBorderImageWidth:
 55     case CSSPropertyWebkitBoxShadow:
 56     case CSSPropertyBoxShadow:
 57     case CSSPropertyWebkitTextDecoration:
 58     case CSSPropertyTextDecorationLine:
 59     case CSSPropertyTextDecorationStyle:
 60     case CSSPropertyTextDecorationColor:
 61     case CSSPropertyTextDecorationSkip:
 62     case CSSPropertyTextUnderlinePosition:
 63     case CSSPropertyTextUnderlineOffset:
 64     case CSSPropertyTextDecorationThickness:
 65     case CSSPropertyTextDecoration:
 66         return true;
 67     default:
 68         return false;
 69     }
 70 }
 71 
 72 // https://www.w3.org/TR/css-pseudo-4/#marker-pseudo (Editor&#39;s Draft, 25 July 2017)
 73 static inline bool isValidMarkerStyleProperty(CSSPropertyID id)
 74 {
 75     switch (id) {
 76     case CSSPropertyColor:
 77     case CSSPropertyFontFamily:
 78     case CSSPropertyFontFeatureSettings:
 79     case CSSPropertyFontSize:
 80     case CSSPropertyFontStretch:
 81     case CSSPropertyFontStyle:
 82     case CSSPropertyFontSynthesis:
 83     case CSSPropertyFontVariantAlternates:
 84     case CSSPropertyFontVariantCaps:
 85     case CSSPropertyFontVariantEastAsian:
 86     case CSSPropertyFontVariantLigatures:
 87     case CSSPropertyFontVariantNumeric:
 88     case CSSPropertyFontVariantPosition:
 89     case CSSPropertyFontWeight:
 90 #if ENABLE(VARIATION_FONTS)
 91     case CSSPropertyFontOpticalSizing:
 92     case CSSPropertyFontVariationSettings:
 93 #endif
 94         return true;
 95     default:
 96         break;
 97     }
 98     return false;
 99 }
100 
101 #if ENABLE(VIDEO_TRACK)
102 static inline bool isValidCueStyleProperty(CSSPropertyID id)
103 {
104     switch (id) {
105     case CSSPropertyBackground:
106     case CSSPropertyBackgroundAttachment:
107     case CSSPropertyBackgroundClip:
108     case CSSPropertyBackgroundColor:
109     case CSSPropertyBackgroundImage:
110     case CSSPropertyBackgroundOrigin:
111     case CSSPropertyBackgroundPosition:
112     case CSSPropertyBackgroundPositionX:
113     case CSSPropertyBackgroundPositionY:
114     case CSSPropertyBackgroundRepeat:
115     case CSSPropertyBackgroundSize:
116     case CSSPropertyColor:
117     case CSSPropertyFont:
118     case CSSPropertyFontFamily:
119     case CSSPropertyFontSize:
120     case CSSPropertyFontStyle:
121     case CSSPropertyFontVariantCaps:
122     case CSSPropertyFontWeight:
123     case CSSPropertyLineHeight:
124     case CSSPropertyOpacity:
125     case CSSPropertyOutline:
126     case CSSPropertyOutlineColor:
127     case CSSPropertyOutlineOffset:
128     case CSSPropertyOutlineStyle:
129     case CSSPropertyOutlineWidth:
130     case CSSPropertyVisibility:
131     case CSSPropertyWhiteSpace:
132     case CSSPropertyTextDecoration:
133     case CSSPropertyTextShadow:
134     case CSSPropertyBorderStyle:
135     case CSSPropertyPaintOrder:
136     case CSSPropertyStrokeLinejoin:
137     case CSSPropertyStrokeLinecap:
138     case CSSPropertyStrokeColor:
139     case CSSPropertyStrokeWidth:
140         return true;
141     default:
142         break;
143     }
144     return false;
145 }
146 #endif
147 
148 PropertyCascade::PropertyCascade(const MatchResult&amp; matchResult, OptionSet&lt;CascadeLevel&gt; cascadeLevels, IncludedProperties includedProperties, Direction direction)
149     : m_matchResult(matchResult)
150     , m_includedProperties(includedProperties)
151     , m_direction(resolveDirectionAndWritingMode(direction))
152 {
153     buildCascade(cascadeLevels);
154 }
155 
156 PropertyCascade::PropertyCascade(const PropertyCascade&amp; parent, OptionSet&lt;CascadeLevel&gt; cascadeLevels)
157     : m_matchResult(parent.m_matchResult)
158     , m_includedProperties(parent.m_includedProperties)
159     , m_direction(parent.m_direction)
160 {
161     buildCascade(cascadeLevels);
162 }
163 
164 PropertyCascade::~PropertyCascade() = default;
165 
166 void PropertyCascade::buildCascade(OptionSet&lt;CascadeLevel&gt; cascadeLevels)
167 {
168     OptionSet&lt;CascadeLevel&gt; cascadeLevelsWithImportant;
169 
170     for (auto cascadeLevel : cascadeLevels) {
171         bool hasImportant = addNormalMatches(cascadeLevel);
172         if (hasImportant)
173             cascadeLevelsWithImportant.add(cascadeLevel);
174     }
175 
176     for (auto cascadeLevel : { CascadeLevel::Author, CascadeLevel::User, CascadeLevel::UserAgent }) {
177         if (!cascadeLevelsWithImportant.contains(cascadeLevel))
178             continue;
179         addImportantMatches(cascadeLevel);
180     }
181 }
182 
183 void PropertyCascade::setPropertyInternal(Property&amp; property, CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, ScopeOrdinal styleScopeOrdinal)
184 {
185     ASSERT(linkMatchType &lt;= SelectorChecker::MatchAll);
186     property.id = id;
187     property.level = cascadeLevel;
188     property.styleScopeOrdinal = styleScopeOrdinal;
189     if (linkMatchType == SelectorChecker::MatchAll) {
190         property.cssValue[0] = &amp;cssValue;
191         property.cssValue[SelectorChecker::MatchLink] = &amp;cssValue;
192         property.cssValue[SelectorChecker::MatchVisited] = &amp;cssValue;
193     } else
194         property.cssValue[linkMatchType] = &amp;cssValue;
195 }
196 
197 void PropertyCascade::set(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, ScopeOrdinal styleScopeOrdinal)
198 {
199     if (CSSProperty::isDirectionAwareProperty(id))
200         id = CSSProperty::resolveDirectionAwareProperty(id, m_direction.textDirection, m_direction.writingMode);
201 
202     ASSERT(!shouldApplyPropertyInParseOrder(id));
203 
204     auto&amp; property = m_properties[id];
205     ASSERT(id &lt; m_propertyIsPresent.size());
206     if (id == CSSPropertyCustom) {
207         m_propertyIsPresent.set(id);
208         const auto&amp; customValue = downcast&lt;CSSCustomPropertyValue&gt;(cssValue);
209         bool hasValue = m_customProperties.contains(customValue.name());
210         if (!hasValue) {
211             Property property;
212             property.id = id;
213             memset(property.cssValue, 0, sizeof(property.cssValue));
214             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
215             m_customProperties.set(customValue.name(), property);
216         } else {
217             Property property = customProperty(customValue.name());
218             setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
219             m_customProperties.set(customValue.name(), property);
220         }
221         return;
222     }
223 
224     if (!m_propertyIsPresent[id])
225         memset(property.cssValue, 0, sizeof(property.cssValue));
226     m_propertyIsPresent.set(id);
227     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
228 }
229 
230 void PropertyCascade::setDeferred(CSSPropertyID id, CSSValue&amp; cssValue, unsigned linkMatchType, CascadeLevel cascadeLevel, ScopeOrdinal styleScopeOrdinal)
231 {
232     ASSERT(!CSSProperty::isDirectionAwareProperty(id));
233     ASSERT(shouldApplyPropertyInParseOrder(id));
234 
235     Property property;
236     memset(property.cssValue, 0, sizeof(property.cssValue));
237     setPropertyInternal(property, id, cssValue, linkMatchType, cascadeLevel, styleScopeOrdinal);
238     m_deferredProperties.append(property);
239 }
240 
241 
242 bool PropertyCascade::addMatch(const MatchedProperties&amp; matchedProperties, CascadeLevel cascadeLevel, bool important)
243 {
244     auto&amp; styleProperties = *matchedProperties.properties;
245     auto propertyWhitelistType = static_cast&lt;PropertyWhitelistType&gt;(matchedProperties.whitelistType);
246     bool hasImportantProperties = false;
247 
248     for (unsigned i = 0, count = styleProperties.propertyCount(); i &lt; count; ++i) {
249         auto current = styleProperties.propertyAt(i);
250 
251         if (current.isImportant())
252             hasImportantProperties = true;
253         if (important != current.isImportant())
254             continue;
255 
256         if (m_includedProperties == IncludedProperties::InheritedOnly &amp;&amp; !current.isInherited()) {
257             // Inherited only mode is used after matched properties cache hit.
258             // A match with a value that is explicitly inherited should never have been cached.
259             ASSERT(!current.value()-&gt;isInheritedValue());
260             continue;
261         }
262         CSSPropertyID propertyID = current.id();
263 
264 #if ENABLE(VIDEO_TRACK)
265         if (propertyWhitelistType == PropertyWhitelistCue &amp;&amp; !isValidCueStyleProperty(propertyID))
266             continue;
267 #endif
268         if (propertyWhitelistType == PropertyWhitelistMarker &amp;&amp; !isValidMarkerStyleProperty(propertyID))
269             continue;
270 
271         if (shouldApplyPropertyInParseOrder(propertyID))
272             setDeferred(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
273         else
274             set(propertyID, *current.value(), matchedProperties.linkMatchType, cascadeLevel, matchedProperties.styleScopeOrdinal);
275     }
276 
277     return hasImportantProperties;
278 }
279 
280 static auto&amp; declarationsForCascadeLevel(const MatchResult&amp; matchResult, CascadeLevel cascadeLevel)
281 {
282     switch (cascadeLevel) {
283     case CascadeLevel::UserAgent: return matchResult.userAgentDeclarations;
284     case CascadeLevel::User: return matchResult.userDeclarations;
285     case CascadeLevel::Author: return matchResult.authorDeclarations;
286     }
287     ASSERT_NOT_REACHED();
288     return matchResult.authorDeclarations;
289 }
290 
291 bool PropertyCascade::addNormalMatches(CascadeLevel cascadeLevel)
292 {
293     bool hasImportant = false;
294     for (auto&amp; matchedDeclarations : declarationsForCascadeLevel(m_matchResult, cascadeLevel))
295         hasImportant |= addMatch(matchedDeclarations, cascadeLevel, false);
296 
297     return hasImportant;
298 }
299 
300 static bool hasImportantProperties(const StyleProperties&amp; properties)
301 {
302     for (unsigned i = 0, count = properties.propertyCount(); i &lt; count; ++i) {
303         if (properties.propertyAt(i).isImportant())
304             return true;
305     }
306     return false;
307 }
308 
309 void PropertyCascade::addImportantMatches(CascadeLevel cascadeLevel)
310 {
311     struct IndexAndOrdinal {
312         unsigned index;
313         ScopeOrdinal ordinal;
314     };
315     Vector&lt;IndexAndOrdinal&gt; importantMatches;
316     bool hasMatchesFromOtherScopes = false;
317 
318     auto&amp; matchedDeclarations = declarationsForCascadeLevel(m_matchResult, cascadeLevel);
319 
320     for (unsigned i = 0; i &lt; matchedDeclarations.size(); ++i) {
321         const MatchedProperties&amp; matchedProperties = matchedDeclarations[i];
322 
323         if (!hasImportantProperties(*matchedProperties.properties))
324             continue;
325 
326         importantMatches.append({ i, matchedProperties.styleScopeOrdinal });
327 
328         if (matchedProperties.styleScopeOrdinal != ScopeOrdinal::Element)
329             hasMatchesFromOtherScopes = true;
330     }
331 
332     if (importantMatches.isEmpty())
333         return;
334 
335     if (hasMatchesFromOtherScopes) {
336         // For !important properties a later shadow tree wins.
337         // Match results are sorted in reverse tree context order so this is not needed for normal properties.
338         std::stable_sort(importantMatches.begin(), importantMatches.end(), [] (const IndexAndOrdinal&amp; a, const IndexAndOrdinal&amp; b) {
339             return a.ordinal &lt; b.ordinal;
340         });
341     }
342 
343     for (auto&amp; match : importantMatches)
344         addMatch(matchedDeclarations[match.index], cascadeLevel, true);
345 }
346 
347 const PropertyCascade* PropertyCascade::propertyCascadeForRollback(CascadeLevel cascadeLevel) const
348 {
349     switch (cascadeLevel) {
350     case CascadeLevel::Author:
351         if (!m_authorRollbackCascade) {
352             auto cascadeLevels = OptionSet&lt;CascadeLevel&gt; { CascadeLevel::UserAgent, CascadeLevel::User };
353             m_authorRollbackCascade = makeUnique&lt;const PropertyCascade&gt;(*this, cascadeLevels);
354         }
355         return m_authorRollbackCascade.get();
356 
357     case CascadeLevel::User:
358         if (!m_userRollbackCascade) {
359             auto cascadeLevels = OptionSet&lt;CascadeLevel&gt; { CascadeLevel::UserAgent };
360             m_userRollbackCascade = makeUnique&lt;const PropertyCascade&gt;(*this, cascadeLevels);
361         }
362         return m_userRollbackCascade.get();
363 
364     case CascadeLevel::UserAgent:
365         return nullptr;
366     }
367     ASSERT_NOT_REACHED();
368     return nullptr;
369 }
370 
371 PropertyCascade::Direction PropertyCascade::resolveDirectionAndWritingMode(Direction inheritedDirection) const
372 {
373     Direction result = inheritedDirection;
374 
375     bool hadImportantWritingMode = false;
376     bool hadImportantDirection = false;
377 
378     for (auto cascadeLevel : { CascadeLevel::UserAgent, CascadeLevel::User, CascadeLevel::Author }) {
379         for (const auto&amp; matchedProperties : declarationsForCascadeLevel(m_matchResult, cascadeLevel)) {
380             for (unsigned i = 0, count = matchedProperties.properties-&gt;propertyCount(); i &lt; count; ++i) {
381                 auto property = matchedProperties.properties-&gt;propertyAt(i);
382                 if (!property.value()-&gt;isPrimitiveValue())
383                     continue;
384                 switch (property.id()) {
385                 case CSSPropertyWritingMode:
386                     if (!hadImportantWritingMode || property.isImportant()) {
387                         result.writingMode = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
388                         hadImportantWritingMode = property.isImportant();
389                     }
390                     break;
391                 case CSSPropertyDirection:
392                     if (!hadImportantDirection || property.isImportant()) {
393                         result.textDirection = downcast&lt;CSSPrimitiveValue&gt;(*property.value());
394                         hadImportantDirection = property.isImportant();
395                     }
396                     break;
397                 default:
398                     break;
399                 }
400             }
401         }
402     }
403 
404     return result;
405 }
406 
407 }
408 }
    </pre>
  </body>
</html>
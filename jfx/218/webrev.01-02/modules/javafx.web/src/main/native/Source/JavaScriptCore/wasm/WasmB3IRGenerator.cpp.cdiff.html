<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmAirIRGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmB3IRGenerator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 78,33 ***</span>
  
  using namespace B3;
  
  namespace {
  namespace WasmB3IRGeneratorInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  }
  
  class B3IRGenerator {
  public:
      struct ControlData {
<span class="line-modified">!         ControlData(Procedure&amp; proc, Origin origin, Type signature, BlockType type, BasicBlock* continuation, BasicBlock* special = nullptr)</span>
<span class="line-modified">!             : blockType(type)</span>
              , continuation(continuation)
              , special(special)
          {
<span class="line-modified">!             if (signature != Void)</span>
<span class="line-modified">!                 result.append(proc.add&lt;Value&gt;(Phi, toB3Type(signature), origin));</span>
          }
  
          ControlData()
          {
          }
  
          void dump(PrintStream&amp; out) const
          {
<span class="line-modified">!             switch (type()) {</span>
              case BlockType::If:
                  out.print(&quot;If:       &quot;);
                  break;
              case BlockType::Block:
                  out.print(&quot;Block:    &quot;);
<span class="line-new-header">--- 78,45 ---</span>
  
  using namespace B3;
  
  namespace {
  namespace WasmB3IRGeneratorInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  }
  
  class B3IRGenerator {
  public:
<span class="line-added">+     using ExpressionType = Value*;</span>
<span class="line-added">+     using ResultList = Vector&lt;ExpressionType, 8&gt;;</span>
<span class="line-added">+ </span>
      struct ControlData {
<span class="line-modified">!         ControlData(Procedure&amp; proc, Origin origin, BlockSignature signature, BlockType type, BasicBlock* continuation, BasicBlock* special = nullptr)</span>
<span class="line-modified">!             : controlBlockType(type)</span>
<span class="line-added">+             , m_signature(signature)</span>
              , continuation(continuation)
              , special(special)
          {
<span class="line-modified">!             if (type == BlockType::Loop) {</span>
<span class="line-modified">!                 for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i)</span>
<span class="line-added">+                     phis.append(proc.add&lt;Value&gt;(Phi, toB3Type(signature-&gt;argument(i)), origin));</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 for (unsigned i = 0; i &lt; signature-&gt;returnCount(); ++i)</span>
<span class="line-added">+                     phis.append(proc.add&lt;Value&gt;(Phi, toB3Type(signature-&gt;returnType(i)), origin));</span>
<span class="line-added">+             }</span>
          }
  
          ControlData()
          {
          }
  
<span class="line-added">+         static bool isIf(const ControlData&amp; control) { return control.blockType() == BlockType::If; }</span>
<span class="line-added">+         static bool isTopLevel(const ControlData&amp; control) { return control.blockType() == BlockType::TopLevel; }</span>
<span class="line-added">+ </span>
          void dump(PrintStream&amp; out) const
          {
<span class="line-modified">!             switch (blockType()) {</span>
              case BlockType::If:
                  out.print(&quot;If:       &quot;);
                  break;
              case BlockType::Block:
                  out.print(&quot;Block:    &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,160 ***</span>
                  out.print(*special);
              else
                  out.print(&quot;None&quot;);
          }
  
<span class="line-modified">!         BlockType type() const { return blockType; }</span>
  
<span class="line-modified">!         bool hasNonVoidSignature() const { return result.size(); }</span>
  
          BasicBlock* targetBlockForBranch()
          {
<span class="line-modified">!             if (type() == BlockType::Loop)</span>
                  return special;
              return continuation;
          }
  
          void convertIfToBlock()
          {
<span class="line-modified">!             ASSERT(type() == BlockType::If);</span>
<span class="line-modified">!             blockType = BlockType::Block;</span>
              special = nullptr;
          }
  
<span class="line-modified">!         using ResultList = Vector&lt;Value*, 1&gt;; // Value must be a Phi</span>
  
<span class="line-modified">!         ResultList resultForBranch() const</span>
          {
<span class="line-modified">!             if (type() == BlockType::Loop)</span>
<span class="line-modified">!                 return ResultList();</span>
<span class="line-modified">!             return result;</span>
          }
  
      private:
          friend class B3IRGenerator;
<span class="line-modified">!         BlockType blockType;</span>
          BasicBlock* continuation;
          BasicBlock* special;
<span class="line-modified">!         ResultList result;</span>
      };
  
<span class="line-removed">-     typedef Value* ExpressionType;</span>
<span class="line-removed">-     typedef Vector&lt;ExpressionType, 1&gt; ExpressionList;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     friend class Stack;</span>
<span class="line-removed">-     class Stack {</span>
<span class="line-removed">-     public:</span>
<span class="line-removed">-         Stack(B3IRGenerator* generator)</span>
<span class="line-removed">-             : m_generator(generator)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void append(ExpressionType expression)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-removed">-                 Variable* variable = m_generator-&gt;m_proc.addVariable(expression-&gt;type());</span>
<span class="line-removed">-                 m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, Set, m_generator-&gt;origin(), variable, expression);</span>
<span class="line-removed">-                 m_stack.append(variable);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             m_data.append(expression);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ExpressionType takeLast()</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-removed">-                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.takeLast());</span>
<span class="line-removed">-             return m_data.takeLast();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ExpressionType last()</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-removed">-                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.last());</span>
<span class="line-removed">-             return m_data.last();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         unsigned size() const</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-removed">-                 return m_stack.size();</span>
<span class="line-removed">-             return m_data.size();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         bool isEmpty() const { return size() == 0; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ExpressionList convertToExpressionList()</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-removed">-                 ExpressionList results;</span>
<span class="line-removed">-                 for (unsigned i = 0; i &lt; m_stack.size(); ++i)</span>
<span class="line-removed">-                     results.append(at(i));</span>
<span class="line-removed">-                 return results;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             return m_data;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ExpressionType at(unsigned i) const</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-removed">-                 return m_generator-&gt;m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_generator-&gt;m_proc, B3::Get, m_generator-&gt;origin(), m_stack.at(i));</span>
<span class="line-removed">-             return m_data.at(i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         Variable* variableAt(unsigned i) const</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode)</span>
<span class="line-removed">-                 return m_stack.at(i);</span>
<span class="line-removed">-             return nullptr;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void shrink(unsigned i)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-removed">-                 m_stack.shrink(i);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             m_data.shrink(i);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void swap(Stack&amp; stack)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             std::swap(m_generator, stack.m_generator);</span>
<span class="line-removed">-             m_data.swap(stack.m_data);</span>
<span class="line-removed">-             m_stack.swap(stack.m_stack);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         void dump() const</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-             CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-removed">-             dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-removed">-             if (m_generator-&gt;m_compilationMode == CompilationMode::OMGForOSREntryMode) {</span>
<span class="line-removed">-                 for (const auto&amp; variable : m_stack)</span>
<span class="line-removed">-                     dataLog(comma, *variable);</span>
<span class="line-removed">-                 return;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             for (const auto&amp; expression : m_data)</span>
<span class="line-removed">-                 dataLog(comma, *expression);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     private:</span>
<span class="line-removed">-         B3IRGenerator* m_generator { nullptr };</span>
<span class="line-removed">-         ExpressionList m_data;</span>
<span class="line-removed">-         Vector&lt;Variable*&gt; m_stack;</span>
<span class="line-removed">-     };</span>
<span class="line-removed">-     Stack createStack() { return Stack(this); }</span>
<span class="line-removed">- </span>
      using ControlType = ControlData;
<span class="line-modified">!     using ResultList = ControlData::ResultList;</span>
      using ControlEntry = FunctionParser&lt;B3IRGenerator&gt;::ControlEntry;
  
<span class="line-modified">!     static constexpr ExpressionType emptyExpression() { return nullptr; }</span>
  
      typedef String ErrorType;
      typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
      typedef Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt; Result;
      typedef Expected&lt;void, ErrorType&gt; PartialResult;
      template &lt;typename ...Args&gt;
      NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
      {
          using namespace FailureHelper; // See ADL comment in WasmParser.h.
          return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
<span class="line-new-header">--- 133,71 ---</span>
                  out.print(*special);
              else
                  out.print(&quot;None&quot;);
          }
  
<span class="line-modified">!         BlockType blockType() const { return controlBlockType; }</span>
<span class="line-added">+ </span>
<span class="line-added">+         BlockSignature signature() const { return m_signature; }</span>
  
<span class="line-modified">!         bool hasNonVoidresult() const { return m_signature-&gt;returnsVoid(); }</span>
  
          BasicBlock* targetBlockForBranch()
          {
<span class="line-modified">!             if (blockType() == BlockType::Loop)</span>
                  return special;
              return continuation;
          }
  
          void convertIfToBlock()
          {
<span class="line-modified">!             ASSERT(blockType() == BlockType::If);</span>
<span class="line-modified">!             controlBlockType = BlockType::Block;</span>
              special = nullptr;
          }
  
<span class="line-modified">!         SignatureArgCount branchTargetArity() const</span>
<span class="line-added">+         {</span>
<span class="line-added">+             if (blockType() == BlockType::Loop)</span>
<span class="line-added">+                 return m_signature-&gt;argumentCount();</span>
<span class="line-added">+             return m_signature-&gt;returnCount();</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         Type branchTargetType(unsigned i) const</span>
          {
<span class="line-modified">!             ASSERT(i &lt; branchTargetArity());</span>
<span class="line-modified">!             if (blockType() == BlockType::Loop)</span>
<span class="line-modified">!                 return m_signature-&gt;argument(i);</span>
<span class="line-added">+             return m_signature-&gt;returnType(i);</span>
          }
  
      private:
          friend class B3IRGenerator;
<span class="line-modified">!         BlockType controlBlockType;</span>
<span class="line-added">+         BlockSignature m_signature;</span>
          BasicBlock* continuation;
          BasicBlock* special;
<span class="line-modified">!         ResultList phis;</span>
      };
  
      using ControlType = ControlData;
<span class="line-modified">!     using ExpressionList = Vector&lt;ExpressionType, 1&gt;;</span>
<span class="line-added">+ </span>
      using ControlEntry = FunctionParser&lt;B3IRGenerator&gt;::ControlEntry;
<span class="line-added">+     using ControlStack = FunctionParser&lt;B3IRGenerator&gt;::ControlStack;</span>
<span class="line-added">+     using Stack = FunctionParser&lt;B3IRGenerator&gt;::Stack;</span>
<span class="line-added">+     using TypedExpression = FunctionParser&lt;B3IRGenerator&gt;::TypedExpression;</span>
  
<span class="line-modified">!     static_assert(std::is_same_v&lt;ResultList, FunctionParser&lt;B3IRGenerator&gt;::ResultList&gt;);</span>
  
      typedef String ErrorType;
      typedef Unexpected&lt;ErrorType&gt; UnexpectedResult;
      typedef Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, ErrorType&gt; Result;
      typedef Expected&lt;void, ErrorType&gt; PartialResult;
<span class="line-added">+ </span>
<span class="line-added">+     static ExpressionType emptyExpression() { return nullptr; };</span>
<span class="line-added">+ </span>
      template &lt;typename ...Args&gt;
      NEVER_INLINE UnexpectedResult WARN_UNUSED_RETURN fail(Args... args) const
      {
          using namespace FailureHelper; // See ADL comment in WasmParser.h.
          return UnexpectedResult(makeString(&quot;WebAssembly.Module failed compiling: &quot;_s, makeString(args)...));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,26 ***</span>
  #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
          if (UNLIKELY(condition))                  \
              return fail(__VA_ARGS__);             \
      } while (0)
  
<span class="line-modified">!     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, unsigned&amp; osrEntryScratchBufferSize, MemoryMode, CompilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount*, ThrowWasmException);</span>
  
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
  
      // References
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);
  
      // Tables
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType&amp; index, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType&amp; index, ExpressionType&amp; value);</span>
      PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count);</span>
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
      // Globals
<span class="line-new-header">--- 205,26 ---</span>
  #define WASM_COMPILE_FAIL_IF(condition, ...) do { \
          if (UNLIKELY(condition))                  \
              return fail(__VA_ARGS__);             \
      } while (0)
  
<span class="line-modified">!     B3IRGenerator(const ModuleInformation&amp;, Procedure&amp;, InternalFunction*, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp;, unsigned&amp; osrEntryScratchBufferSize, MemoryMode, CompilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount*);</span>
  
      PartialResult WARN_UNUSED_RETURN addArguments(const Signature&amp;);
      PartialResult WARN_UNUSED_RETURN addLocal(Type, uint32_t);
      ExpressionType addConstant(Type, uint64_t);
  
      // References
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addRefIsNull(ExpressionType value, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addRefFunc(uint32_t index, ExpressionType&amp; result);
  
      // Tables
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGet(unsigned, ExpressionType index, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableSet(unsigned, ExpressionType index, ExpressionType value);</span>
      PartialResult WARN_UNUSED_RETURN addTableSize(unsigned, ExpressionType&amp; result);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableGrow(unsigned, ExpressionType fill, ExpressionType delta, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addTableFill(unsigned, ExpressionType offset, ExpressionType fill, ExpressionType count);</span>
      // Locals
      PartialResult WARN_UNUSED_RETURN getLocal(uint32_t index, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN setLocal(uint32_t index, ExpressionType value);
  
      // Globals
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,42 ***</span>
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
      template&lt;OpType&gt;
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
      // Control flow
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addTopLevel(Type signature);</span>
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addBlock(Type signature);</span>
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addLoop(Type signature, const Stack&amp;, uint32_t);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, Type signature, ControlData&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues);</span>
      PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);
      PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);
      PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;);</span>
  
      // Calls
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
  
<span class="line-modified">!     void dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
  
      Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
      void insertConstants();
  
<span class="line-modified">!     ALWAYS_INLINE void didKill(ExpressionType) { }</span>
  
  private:
      void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
  
<span class="line-modified">!     void emitEntryTierUpCheck(int32_t incrementCount, B3::Origin);</span>
<span class="line-modified">!     void emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp;, uint32_t, uint32_t, B3::Origin);</span>
  
      void emitWriteBarrierForJSWrapper();
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      B3::Kind memoryKind(B3::Opcode memoryOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
<span class="line-new-header">--- 242,49 ---</span>
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType arg, ExpressionType&amp; result);
      template&lt;OpType&gt;
      PartialResult WARN_UNUSED_RETURN addOp(ExpressionType left, ExpressionType right, ExpressionType&amp; result);
      PartialResult WARN_UNUSED_RETURN addSelect(ExpressionType condition, ExpressionType nonZero, ExpressionType zero, ExpressionType&amp; result);
  
<span class="line-added">+ </span>
      // Control flow
<span class="line-modified">!     ControlData WARN_UNUSED_RETURN addTopLevel(BlockSignature);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addBlock(BlockSignature, Stack&amp; enclosingStack, ControlType&amp; newBlock, Stack&amp; newStack);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addLoop(BlockSignature, Stack&amp; enclosingStack, ControlType&amp; block, Stack&amp; newStack, uint32_t loopIndex);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addIf(ExpressionType condition, BlockSignature, Stack&amp; enclosingStack, ControlType&amp; result, Stack&amp; newStack);</span>
      PartialResult WARN_UNUSED_RETURN addElse(ControlData&amp;, const Stack&amp;);
      PartialResult WARN_UNUSED_RETURN addElseToUnreachable(ControlData&amp;);
  
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addReturn(const ControlData&amp;, const Stack&amp; returnValues);</span>
      PartialResult WARN_UNUSED_RETURN addBranch(ControlData&amp;, ExpressionType condition, const Stack&amp; returnValues);
      PartialResult WARN_UNUSED_RETURN addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTargets, const Stack&amp; expressionStack);
      PartialResult WARN_UNUSED_RETURN endBlock(ControlEntry&amp;, Stack&amp; expressionStack);
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addEndToUnreachable(ControlEntry&amp;, const Stack&amp; = { });</span>
<span class="line-added">+ </span>
<span class="line-added">+     PartialResult WARN_UNUSED_RETURN endTopLevel(BlockSignature, const Stack&amp;) { return { }; }</span>
  
      // Calls
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCall(uint32_t calleeIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results);</span>
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN addCallIndirect(unsigned tableIndex, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results);</span>
      PartialResult WARN_UNUSED_RETURN addUnreachable();
<span class="line-added">+     B3::Value* createCallPatchpoint(BasicBlock*, Origin, const Signature&amp;, Vector&lt;ExpressionType&gt;&amp; args, const ScopedLambda&lt;void(PatchpointValue*)&gt;&amp; patchpointFunctor);</span>
  
<span class="line-modified">!     void dump(const ControlStack&amp;, const Stack* expressionStack);</span>
      void setParser(FunctionParser&lt;B3IRGenerator&gt;* parser) { m_parser = parser; };
<span class="line-added">+     void didFinishParsingLocals() { }</span>
<span class="line-added">+     void didPopValueFromStack() { }</span>
  
      Value* constant(B3::Type, uint64_t bits, Optional&lt;Origin&gt; = WTF::nullopt);
<span class="line-added">+     Value* framePointer();</span>
      void insertConstants();
  
<span class="line-modified">!     B3::Type toB3ResultType(BlockSignature);</span>
  
  private:
      void emitExceptionCheck(CCallHelpers&amp;, ExceptionType);
  
<span class="line-modified">!     void emitEntryTierUpCheck();</span>
<span class="line-modified">!     void emitLoopTierUpCheck(uint32_t loopIndex, const Stack&amp; enclosingStack);</span>
  
      void emitWriteBarrierForJSWrapper();
      ExpressionType emitCheckAndPreparePointer(ExpressionType pointer, uint32_t offset, uint32_t sizeOfOp);
      B3::Kind memoryKind(B3::Opcode memoryOp);
      ExpressionType emitLoadOp(LoadOpType, ExpressionType pointer, uint32_t offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 394,11 ***</span>
<span class="line-new-header">--- 324,13 ---</span>
      Vector&lt;uint32_t&gt; m_outerLoops;
      Vector&lt;Variable*&gt; m_locals;
      Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; m_unlinkedWasmToWasmCalls; // List each call site and the function index whose address it should be patched with.
      unsigned&amp; m_osrEntryScratchBufferSize;
      HashMap&lt;ValueKey, Value*&gt; m_constantPool;
<span class="line-added">+     HashMap&lt;BlockSignature, B3::Type&gt; m_tupleMap;</span>
      InsertionSet m_constantInsertionValues;
<span class="line-added">+     Value* m_framePointer { nullptr };</span>
      GPRReg m_memoryBaseGPR { InvalidGPRReg };
      GPRReg m_memorySizeGPR { InvalidGPRReg };
      GPRReg m_wasmContextInstanceGPR { InvalidGPRReg };
      bool m_makesCalls { false };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,11 ***</span>
      patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
          jit.move(param[0].gpr(), wasmContextInstanceGPR);
      });
  }
  
<span class="line-modified">! B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
      : m_info(info)
      , m_mode(mode)
      , m_compilationMode(compilationMode)
      , m_functionIndex(functionIndex)
      , m_loopIndexForOSREntry(loopIndexForOSREntry)
<span class="line-new-header">--- 384,11 ---</span>
      patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; param) {
          jit.move(param[0].gpr(), wasmContextInstanceGPR);
      });
  }
  
<span class="line-modified">! B3IRGenerator::B3IRGenerator(const ModuleInformation&amp; info, Procedure&amp; procedure, InternalFunction* compilation, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, MemoryMode mode, CompilationMode compilationMode, unsigned functionIndex, unsigned loopIndexForOSREntry, TierUpCount* tierUp)</span>
      : m_info(info)
      , m_mode(mode)
      , m_compilationMode(compilationMode)
      , m_functionIndex(functionIndex)
      , m_loopIndexForOSREntry(loopIndexForOSREntry)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 483,13 ***</span>
      if (mode != MemoryMode::Signaling) {
          m_memorySizeGPR = pinnedRegs.sizeRegister;
          m_proc.pinRegister(m_memorySizeGPR);
      }
  
<span class="line-removed">-     if (throwWasmException)</span>
<span class="line-removed">-         Thunks::singleton().setThrowWasmException(throwWasmException);</span>
<span class="line-removed">- </span>
      if (info.memory) {
          m_proc.setWasmBoundsCheckGenerator([=] (CCallHelpers&amp; jit, GPRReg pinnedGPR) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              switch (m_mode) {
              case MemoryMode::BoundsChecking:
<span class="line-new-header">--- 415,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,17 ***</span>
                  CRASH();
              break;
          }
      }
  
<span class="line-modified">!     wasmCallingConvention().setupFrameInPrologue(&amp;compilation-&gt;calleeMoveLocation, m_proc, Origin(), m_currentBlock);</span>
  
      {
<span class="line-removed">-         B3::Value* framePointer = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, Origin());</span>
          B3::PatchpointValue* stackOverflowCheck = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, pointerType(), Origin());
          m_instanceValue = stackOverflowCheck;
<span class="line-modified">!         stackOverflowCheck-&gt;appendSomeRegister(framePointer);</span>
          stackOverflowCheck-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!Context::useFastTLS()) {
              // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
              // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
              stackOverflowCheck-&gt;effects.writesPinned = false;
<span class="line-new-header">--- 443,46 ---</span>
                  CRASH();
              break;
          }
      }
  
<span class="line-modified">!     {</span>
<span class="line-added">+         auto* calleeMoveLocation = &amp;compilation-&gt;calleeMoveLocation;</span>
<span class="line-added">+         static_assert(CallFrameSlot::codeBlock * sizeof(Register) &lt; WasmCallingConvention::headerSizeInBytes, &quot;We rely on this here for now.&quot;);</span>
<span class="line-added">+         static_assert(CallFrameSlot::callee * sizeof(Register) &lt; WasmCallingConvention::headerSizeInBytes, &quot;We rely on this here for now.&quot;);</span>
<span class="line-added">+         B3::PatchpointValue* getCalleePatchpoint = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Int64, Origin());</span>
<span class="line-added">+         getCalleePatchpoint-&gt;resultConstraints = { B3::ValueRep::SomeRegister };</span>
<span class="line-added">+         getCalleePatchpoint-&gt;effects = B3::Effects::none();</span>
<span class="line-added">+         getCalleePatchpoint-&gt;setGenerator(</span>
<span class="line-added">+             [=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="line-added">+                 GPRReg result = params[0].gpr();</span>
<span class="line-added">+                 MacroAssembler::DataLabelPtr moveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), result);</span>
<span class="line-added">+                 jit.addLinkTask([calleeMoveLocation, moveLocation] (LinkBuffer&amp; linkBuffer) {</span>
<span class="line-added">+                     *calleeMoveLocation = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(moveLocation);</span>
<span class="line-added">+                 });</span>
<span class="line-added">+             });</span>
<span class="line-added">+ </span>
<span class="line-added">+         B3::Value* offsetOfCallee = m_currentBlock-&gt;appendNew&lt;B3::Const64Value&gt;(m_proc, Origin(), CallFrameSlot::callee * sizeof(Register));</span>
<span class="line-added">+         m_currentBlock-&gt;appendNew&lt;B3::MemoryValue&gt;(m_proc, B3::Store, Origin(),</span>
<span class="line-added">+             getCalleePatchpoint,</span>
<span class="line-added">+             m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, Origin(), framePointer(), offsetOfCallee));</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: We shouldn&#39;t have to store zero into the CodeBlock* spot in the call frame,</span>
<span class="line-added">+         // but there are places that interpret non-null CodeBlock slot to mean a valid CodeBlock.</span>
<span class="line-added">+         // When doing unwinding, we&#39;ll need to verify that the entire runtime is OK with a non-null</span>
<span class="line-added">+         // CodeBlock not implying that the CodeBlock is valid.</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=165321</span>
<span class="line-added">+         B3::Value* offsetOfCodeBlock = m_currentBlock-&gt;appendNew&lt;B3::Const64Value&gt;(m_proc, Origin(), CallFrameSlot::codeBlock * sizeof(Register));</span>
<span class="line-added">+         m_currentBlock-&gt;appendNew&lt;B3::MemoryValue&gt;(m_proc, B3::Store, Origin(),</span>
<span class="line-added">+             m_currentBlock-&gt;appendNew&lt;B3::Const64Value&gt;(m_proc, Origin(), 0),</span>
<span class="line-added">+             m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, Origin(), framePointer(), offsetOfCodeBlock));</span>
<span class="line-added">+     }</span>
  
      {
          B3::PatchpointValue* stackOverflowCheck = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, pointerType(), Origin());
          m_instanceValue = stackOverflowCheck;
<span class="line-modified">!         stackOverflowCheck-&gt;appendSomeRegister(framePointer());</span>
          stackOverflowCheck-&gt;clobber(RegisterSet::macroScratchRegisters());
          if (!Context::useFastTLS()) {
              // FIXME: Because WasmToWasm call clobbers wasmContextInstance register and does not restore it, we need to restore it in the caller side.
              // This prevents us from using ArgumentReg to this (logically) immutable pinned register.
              stackOverflowCheck-&gt;effects.writesPinned = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 544,11 ***</span>
                  // 2. Try to speed things up by skipping stack checks.
                  minimumParentCheckSize,
                  // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
                  // spill all arguments to the stack, we ensure that a stack check here covers the
                  // stack that such a stub would use.
<span class="line-modified">!                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + jscCallingConvention().headerSizeInBytes()).unsafeGet()</span>
              ));
              const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
              bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
              bool needsOverflowCheck = m_makesCalls || wasmFrameSize &gt;= minimumParentCheckSize || needUnderflowCheck;
  
<span class="line-new-header">--- 502,11 ---</span>
                  // 2. Try to speed things up by skipping stack checks.
                  minimumParentCheckSize,
                  // This allows us to elide stack checks in the Wasm -&gt; Embedder call IC stub. Since these will
                  // spill all arguments to the stack, we ensure that a stack check here covers the
                  // stack that such a stub would use.
<span class="line-modified">!                 (Checked&lt;uint32_t&gt;(m_maxNumJSCallArguments) * sizeof(Register) + JSCallingConvention::headerSizeInBytes).unsafeGet()</span>
              ));
              const int32_t checkSize = m_makesCalls ? (wasmFrameSize + extraFrameSize).unsafeGet() : wasmFrameSize.unsafeGet();
              bool needUnderflowCheck = static_cast&lt;unsigned&gt;(checkSize) &gt; Options::reservedZoneSize();
              bool needsOverflowCheck = m_makesCalls || wasmFrameSize &gt;= minimumParentCheckSize || needUnderflowCheck;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,11 ***</span>
                  // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
              }
          });
      }
  
<span class="line-modified">!     emitEntryTierUpCheck(TierUpCount::functionEntryIncrement(), Origin());</span>
  
      if (m_compilationMode == CompilationMode::OMGForOSREntryMode)
          m_currentBlock = m_proc.addBlock();
  }
  
<span class="line-new-header">--- 540,11 ---</span>
                  // We said we&#39;d return a pointer. We don&#39;t actually need to because it isn&#39;t used, but the patchpoint conservatively said it had effects (potential stack check) which prevent it from getting removed.
              }
          });
      }
  
<span class="line-modified">!     emitEntryTierUpCheck();</span>
  
      if (m_compilationMode == CompilationMode::OMGForOSREntryMode)
          m_currentBlock = m_proc.addBlock();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 649,15 ***</span>
<span class="line-new-header">--- 607,42 ---</span>
          return result;
      });
      return result.iterator-&gt;value;
  }
  
<span class="line-added">+ Value* B3IRGenerator::framePointer()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!m_framePointer) {</span>
<span class="line-added">+         m_framePointer = m_proc.add&lt;B3::Value&gt;(B3::FramePointer, Origin());</span>
<span class="line-added">+         ASSERT(m_framePointer);</span>
<span class="line-added">+         m_constantInsertionValues.insertValue(0, m_framePointer);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return m_framePointer;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void B3IRGenerator::insertConstants()
  {
      m_constantInsertionValues.execute(m_proc.at(0));
  }
  
<span class="line-added">+ B3::Type B3IRGenerator::toB3ResultType(BlockSignature returnType)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (returnType-&gt;returnsVoid())</span>
<span class="line-added">+         return B3::Void;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (returnType-&gt;returnCount() == 1)</span>
<span class="line-added">+         return toB3Type(returnType-&gt;returnType(0));</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto result = m_tupleMap.ensure(returnType, [&amp;] {</span>
<span class="line-added">+         Vector&lt;B3::Type&gt; result;</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; returnType-&gt;returnCount(); ++i)</span>
<span class="line-added">+             result.append(toB3Type(returnType-&gt;returnType(i)));</span>
<span class="line-added">+         return m_proc.addTuple(WTFMove(result));</span>
<span class="line-added">+     });</span>
<span class="line-added">+     return result.iterator-&gt;value;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  auto B3IRGenerator::addLocal(Type type, uint32_t count) -&gt; PartialResult
  {
      size_t newSize = m_locals.size() + count;
      ASSERT(!(CheckedUint32(count) + m_locals.size()).hasOverflowed());
      ASSERT(newSize &lt;= maxFunctionLocals);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,30 ***</span>
  {
      ASSERT(!m_locals.size());
      WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(signature.argumentCount()), &quot;can&#39;t allocate memory for &quot;, signature.argumentCount(), &quot; arguments&quot;);
  
      m_locals.grow(signature.argumentCount());
<span class="line-modified">!     wasmCallingConvention().loadArguments(signature, m_proc, m_currentBlock, Origin(),</span>
<span class="line-modified">!         [=] (ExpressionType argument, unsigned i) {</span>
<span class="line-modified">!             Variable* argumentVariable = m_proc.addVariable(argument-&gt;type());</span>
<span class="line-modified">!             m_locals[i] = argumentVariable;</span>
<span class="line-modified">!             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);</span>
<span class="line-modified">!         });</span>
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addRefIsNull(ExpressionType&amp; value, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Equal, origin(), value, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), JSValue::encode(jsNull())));
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableGet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(Anyref), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;getWasmTableElement, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0)));
<span class="line-new-header">--- 661,46 ---</span>
  {
      ASSERT(!m_locals.size());
      WASM_COMPILE_FAIL_IF(!m_locals.tryReserveCapacity(signature.argumentCount()), &quot;can&#39;t allocate memory for &quot;, signature.argumentCount(), &quot; arguments&quot;);
  
      m_locals.grow(signature.argumentCount());
<span class="line-modified">!     CallInformation wasmCallInfo = wasmCallingConvention().callInformationFor(signature, CallRole::Callee);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     for (size_t i = 0; i &lt; signature.argumentCount(); ++i) {</span>
<span class="line-modified">!         B3::Type type = toB3Type(signature.argument(i));</span>
<span class="line-modified">!         B3::Value* argument;</span>
<span class="line-modified">!         auto rep = wasmCallInfo.params[i];</span>
<span class="line-added">+         if (rep.isReg()) {</span>
<span class="line-added">+             argument = m_currentBlock-&gt;appendNew&lt;B3::ArgumentRegValue&gt;(m_proc, Origin(), rep.reg());</span>
<span class="line-added">+             if (type == B3::Int32 || type == B3::Float)</span>
<span class="line-added">+                 argument = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Trunc, Origin(), argument);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             ASSERT(rep.isStack());</span>
<span class="line-added">+             B3::Value* address = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, Origin(), framePointer(),</span>
<span class="line-added">+                 m_currentBlock-&gt;appendNew&lt;B3::Const64Value&gt;(m_proc, Origin(), rep.offsetFromFP()));</span>
<span class="line-added">+             argument = m_currentBlock-&gt;appendNew&lt;B3::MemoryValue&gt;(m_proc, B3::Load, type, Origin(), address);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         Variable* argumentVariable = m_proc.addVariable(argument-&gt;type());</span>
<span class="line-added">+         m_locals[i] = argumentVariable;</span>
<span class="line-added">+         m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), argumentVariable, argument);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addRefIsNull(ExpressionType value, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      result = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Equal, origin(), value, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), JSValue::encode(jsNull())));
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableGet(unsigned tableIndex, ExpressionType index, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(Anyref), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationGetWasmTableElement, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 710,15 ***</span>
      }
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableSet(unsigned tableIndex, ExpressionType&amp; index, ExpressionType&amp; value) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      auto shouldThrow = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int32, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;setWasmTableElement, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index, value);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), shouldThrow, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));
<span class="line-new-header">--- 711,15 ---</span>
      }
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableSet(unsigned tableIndex, ExpressionType index, ExpressionType value) -&gt; PartialResult</span>
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      auto shouldThrow = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int32, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationSetWasmTableElement, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), index, value);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), shouldThrow, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 734,43 ***</span>
  auto B3IRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
  
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int64, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmRefFunc, B3CCallPtrTag)),</span>
          instanceValue(), addConstant(Type::I32, index));
  
      return { };
  }
  
  auto B3IRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
<span class="line-removed">-     uint32_t (*doSize)(Instance*, unsigned) = [] (Instance* instance, unsigned tableIndex) -&gt; uint32_t {</span>
<span class="line-removed">-         return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(doSize, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex));
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableGrow(unsigned tableIndex, ExpressionType&amp; fill, ExpressionType&amp; delta, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableGrow, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), fill, delta);
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableFill(unsigned tableIndex, ExpressionType&amp; offset, ExpressionType&amp; fill, ExpressionType&amp; count) -&gt; PartialResult</span>
  {
      auto result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;doWasmTableFill, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), offset, fill, count);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));
<span class="line-new-header">--- 735,39 ---</span>
  auto B3IRGenerator::addRefFunc(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
  
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Int64, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationWasmRefFunc, B3CCallPtrTag)),</span>
          instanceValue(), addConstant(Type::I32, index));
  
      return { };
  }
  
  auto B3IRGenerator::addTableSize(unsigned tableIndex, ExpressionType&amp; result) -&gt; PartialResult
  {
      // FIXME: Emit this inline &lt;https://bugs.webkit.org/show_bug.cgi?id=198506&gt;.
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationGetWasmTableSize, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex));
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableGrow(unsigned tableIndex, ExpressionType fill, ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationWasmTableGrow, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), fill, delta);
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addTableFill(unsigned tableIndex, ExpressionType offset, ExpressionType fill, ExpressionType count) -&gt; PartialResult</span>
  {
      auto result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, toB3Type(I32), origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationWasmTableFill, B3CCallPtrTag)),</span>
          instanceValue(), m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), tableIndex), offset, fill, count);
  
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
              m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Equal, origin(), result, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), 0)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 800,34 ***</span>
      return { };
  }
  
  auto B3IRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="line-removed">-     int32_t (*growMemory)(void*, Instance*, int32_t) = [] (void* callFrame, Instance* instance, int32_t delta) -&gt; int32_t {</span>
<span class="line-removed">-         instance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (delta &lt; 0)</span>
<span class="line-removed">-             return -1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));</span>
<span class="line-removed">-         if (!grown) {</span>
<span class="line-removed">-             switch (grown.error()) {</span>
<span class="line-removed">-             case Memory::GrowFailReason::InvalidDelta:</span>
<span class="line-removed">-             case Memory::GrowFailReason::InvalidGrowSize:</span>
<span class="line-removed">-             case Memory::GrowFailReason::WouldExceedMaximum:</span>
<span class="line-removed">-             case Memory::GrowFailReason::OutOfMemory:</span>
<span class="line-removed">-                 return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         return grown.value().pageCount();</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(growMemory, B3CCallPtrTag)),</span>
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, origin()), instanceValue(), delta);</span>
  
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::No, m_info.memory, instanceValue(), m_proc, m_currentBlock);
  
      return { };
  }
<span class="line-new-header">--- 797,13 ---</span>
      return { };
  }
  
  auto B3IRGenerator::addGrowMemory(ExpressionType delta, ExpressionType&amp; result) -&gt; PartialResult
  {
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(),
<span class="line-modified">!         m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationGrowMemory, B3CCallPtrTag)),</span>
<span class="line-modified">!         framePointer(), instanceValue(), delta);</span>
  
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::No, m_info.memory, instanceValue(), m_proc, m_currentBlock);
  
      return { };
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 854,24 ***</span>
      return { };
  }
  
  auto B3IRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
      Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
<span class="line-modified">!     result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(m_info.globals[index].type), origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
      return { };
  }
  
  auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
  {
<span class="line-modified">!     ASSERT(toB3Type(m_info.globals[index].type) == value-&gt;type());</span>
      Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
<span class="line-modified">!     m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
  
<span class="line-modified">!     if (isSubtype(m_info.globals[index].type, Anyref))</span>
<span class="line-modified">!         emitWriteBarrierForJSWrapper();</span>
  
      return { };
  }
  
  inline void B3IRGenerator::emitWriteBarrierForJSWrapper()
  {
<span class="line-new-header">--- 830,92 ---</span>
      return { };
  }
  
  auto B3IRGenerator::getGlobal(uint32_t index, ExpressionType&amp; result) -&gt; PartialResult
  {
<span class="line-added">+     const Wasm::GlobalInformation&amp; global = m_info.globals[index];</span>
      Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
<span class="line-modified">!     switch (global.bindingMode) {</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance:</span>
<span class="line-added">+         result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(global.type), origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::Portable: {</span>
<span class="line-added">+         ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+         Value* pointer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
<span class="line-added">+         result = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, toB3Type(global.type), origin(), pointer);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
      return { };
  }
  
  auto B3IRGenerator::setGlobal(uint32_t index, ExpressionType value) -&gt; PartialResult
  {
<span class="line-modified">!     const Wasm::GlobalInformation&amp; global = m_info.globals[index];</span>
<span class="line-added">+     ASSERT(toB3Type(global.type) == value-&gt;type());</span>
      Value* globalsArray = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfGlobals()));
<span class="line-modified">!     switch (global.bindingMode) {</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::EmbeddedInInstance:</span>
<span class="line-added">+         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
<span class="line-added">+         if (isSubtype(global.type, Anyref))</span>
<span class="line-added">+             emitWriteBarrierForJSWrapper();</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case Wasm::GlobalInformation::BindingMode::Portable: {</span>
<span class="line-added">+         ASSERT(global.mutability == Wasm::GlobalInformation::Mutability::Mutable);</span>
<span class="line-added">+         Value* pointer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), globalsArray, safeCast&lt;int32_t&gt;(index * sizeof(Register)));</span>
<span class="line-added">+         m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, pointer);</span>
<span class="line-added">+         // We emit a write-barrier onto JSWebAssemblyGlobal, not JSWebAssemblyInstance.</span>
<span class="line-added">+         if (isSubtype(global.type, Anyref)) {</span>
<span class="line-added">+             Value* instance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfOwner()));</span>
<span class="line-added">+             Value* cell = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), pointer, Wasm::Global::offsetOfOwner() - Wasm::Global::offsetOfValue());</span>
<span class="line-added">+             Value* cellState = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added">+             Value* vm = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instance, safeCast&lt;int32_t&gt;(JSWebAssemblyInstance::offsetOfVM()));</span>
<span class="line-added">+             Value* threshold = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapBarrierThreshold()));</span>
<span class="line-added">+ </span>
<span class="line-added">+             BasicBlock* fenceCheckPath = m_proc.addBlock();</span>
<span class="line-added">+             BasicBlock* fencePath = m_proc.addBlock();</span>
<span class="line-added">+             BasicBlock* doSlowPath = m_proc.addBlock();</span>
<span class="line-added">+             BasicBlock* continuation = m_proc.addBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+             m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added">+                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellState, threshold),</span>
<span class="line-added">+                 FrequentedBlock(continuation), FrequentedBlock(fenceCheckPath, FrequencyClass::Rare));</span>
<span class="line-added">+             fenceCheckPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             m_currentBlock = fenceCheckPath;</span>
<span class="line-added">+ </span>
<span class="line-added">+             Value* shouldFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), vm, safeCast&lt;int32_t&gt;(VM::offsetOfHeapMutatorShouldBeFenced()));</span>
<span class="line-added">+             m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added">+                 shouldFence,</span>
<span class="line-added">+                 FrequentedBlock(fencePath), FrequentedBlock(doSlowPath));</span>
<span class="line-added">+             fencePath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             m_currentBlock = fencePath;</span>
<span class="line-added">+ </span>
<span class="line-added">+             B3::PatchpointValue* doFence = m_currentBlock-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, B3::Void, origin());</span>
<span class="line-added">+             doFence-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {</span>
<span class="line-added">+                 jit.memoryFence();</span>
<span class="line-added">+             });</span>
<span class="line-added">+ </span>
<span class="line-added">+             Value* cellStateLoadAfterFence = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), cell, safeCast&lt;int32_t&gt;(JSCell::cellStateOffset()));</span>
<span class="line-added">+             m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(),</span>
<span class="line-added">+                 m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Above, origin(), cellStateLoadAfterFence, m_currentBlock-&gt;appendNew&lt;Const32Value&gt;(m_proc, origin(), blackThreshold)),</span>
<span class="line-added">+                 FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));</span>
<span class="line-added">+             doSlowPath-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             m_currentBlock = doSlowPath;</span>
  
<span class="line-modified">!             Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationWasmWriteBarrierSlowPath, B3CCallPtrTag));</span>
<span class="line-modified">!             m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);</span>
<span class="line-added">+             m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);</span>
  
<span class="line-added">+             continuation-&gt;addPredecessor(m_currentBlock);</span>
<span class="line-added">+             m_currentBlock = continuation;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
      return { };
  }
  
  inline void B3IRGenerator::emitWriteBarrierForJSWrapper()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,15 ***</span>
          FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));
      doSlowPath-&gt;addPredecessor(m_currentBlock);
      continuation-&gt;addPredecessor(m_currentBlock);
      m_currentBlock = doSlowPath;
  
<span class="line-modified">!     void (*writeBarrier)(JSWebAssemblyInstance*, VM*) = [] (JSWebAssemblyInstance* cell, VM* vm) -&gt; void {</span>
<span class="line-removed">-         vm-&gt;heap.writeBarrierSlowPath(cell);</span>
<span class="line-removed">-     };</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(writeBarrier, B3CCallPtrTag));</span>
      m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
      continuation-&gt;addPredecessor(m_currentBlock);
      m_currentBlock = continuation;
<span class="line-new-header">--- 955,11 ---</span>
          FrequentedBlock(continuation), FrequentedBlock(doSlowPath, FrequencyClass::Rare));
      doSlowPath-&gt;addPredecessor(m_currentBlock);
      continuation-&gt;addPredecessor(m_currentBlock);
      m_currentBlock = doSlowPath;
  
<span class="line-modified">!     Value* writeBarrierAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationWasmWriteBarrierSlowPath, B3CCallPtrTag));</span>
      m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, B3::Void, origin(), writeBarrierAddress, cell, vm);
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
      continuation-&gt;addPredecessor(m_currentBlock);
      m_currentBlock = continuation;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1185,33 ***</span>
      return { };
  }
  
  B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
  {
      return constant(toB3Type(type), value);
  }
  
<span class="line-modified">! void B3IRGenerator::emitEntryTierUpCheck(int32_t incrementCount, Origin origin)</span>
  {
      if (!m_tierUp)
          return;
  
      ASSERT(m_tierUp);
<span class="line-modified">!     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);</span>
  
<span class="line-modified">!     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);</span>
      Effects effects = Effects::none();
      // FIXME: we should have a more precise heap range for the tier up count.
      effects.reads = B3::HeapRange::top();
      effects.writes = B3::HeapRange::top();
      patch-&gt;effects = effects;
      patch-&gt;clobber(RegisterSet::macroScratchRegisters());
  
      patch-&gt;append(countDownLocation, ValueRep::SomeRegister);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
          CCallHelpers::Label tierUpResume = jit.label();
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
<span class="line-new-header">--- 1225,34 ---</span>
      return { };
  }
  
  B3IRGenerator::ExpressionType B3IRGenerator::addConstant(Type type, uint64_t value)
  {
<span class="line-added">+ </span>
      return constant(toB3Type(type), value);
  }
  
<span class="line-modified">! void B3IRGenerator::emitEntryTierUpCheck()</span>
  {
      if (!m_tierUp)
          return;
  
      ASSERT(m_tierUp);
<span class="line-modified">!     Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), Origin());</span>
  
<span class="line-modified">!     PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, Origin());</span>
      Effects effects = Effects::none();
      // FIXME: we should have a more precise heap range for the tier up count.
      effects.reads = B3::HeapRange::top();
      effects.writes = B3::HeapRange::top();
      patch-&gt;effects = effects;
      patch-&gt;clobber(RegisterSet::macroScratchRegisters());
  
      patch-&gt;append(countDownLocation, ValueRep::SomeRegister);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(TierUpCount::functionEntryIncrement()), CCallHelpers::Address(params[0].gpr()));</span>
          CCallHelpers::Label tierUpResume = jit.label();
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              tierUp.link(&amp;jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1231,35 ***</span>
              });
          });
      });
  }
  
<span class="line-modified">! void B3IRGenerator::emitLoopTierUpCheck(int32_t incrementCount, const Stack&amp; expressionStack, uint32_t loopIndex, uint32_t outerLoopIndex, B3::Origin origin)</span>
  {
      if (!m_tierUp)
          return;
  
<span class="line-modified">!     ASSERT(m_tierUp);</span>
<span class="line-removed">- </span>
      ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);
      m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);
      m_tierUp-&gt;outerLoops().append(outerLoopIndex);
  
      Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);
  
      Vector&lt;ExpressionType&gt; stackmap;
<span class="line-removed">-     Vector&lt;B3::Type&gt; types;</span>
      for (auto&amp; local : m_locals) {
<span class="line-modified">!         ExpressionType result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin, local);</span>
          stackmap.append(result);
<span class="line-removed">-         types.append(result-&gt;type());</span>
      }
<span class="line-modified">!     for (unsigned i = 0; i &lt; expressionStack.size(); ++i) {</span>
<span class="line-modified">!         ExpressionType result = expressionStack.at(i);</span>
<span class="line-modified">!         stackmap.append(result);</span>
<span class="line-modified">!         types.append(result-&gt;type());</span>
      }
  
      PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
      Effects effects = Effects::none();
      // FIXME: we should have a more precise heap range for the tier up count.
      effects.reads = B3::HeapRange::top();
<span class="line-new-header">--- 1272,37 ---</span>
              });
          });
      });
  }
  
<span class="line-modified">! void B3IRGenerator::emitLoopTierUpCheck(uint32_t loopIndex, const Stack&amp; enclosingStack)</span>
  {
<span class="line-added">+     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-added">+     m_outerLoops.append(loopIndex);</span>
<span class="line-added">+ </span>
      if (!m_tierUp)
          return;
  
<span class="line-modified">!     Origin origin = this-&gt;origin();</span>
      ASSERT(m_tierUp-&gt;osrEntryTriggers().size() == loopIndex);
      m_tierUp-&gt;osrEntryTriggers().append(TierUpCount::TriggerReason::DontTrigger);
      m_tierUp-&gt;outerLoops().append(outerLoopIndex);
  
      Value* countDownLocation = constant(pointerType(), reinterpret_cast&lt;uint64_t&gt;(&amp;m_tierUp-&gt;m_counter), origin);
  
      Vector&lt;ExpressionType&gt; stackmap;
      for (auto&amp; local : m_locals) {
<span class="line-modified">!         Value* result = m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, B3::Get, origin, local);</span>
          stackmap.append(result);
      }
<span class="line-modified">!     for (unsigned controlIndex = 0; controlIndex &lt; m_parser-&gt;controlStack().size(); ++controlIndex) {</span>
<span class="line-modified">!         auto&amp; expressionStack = m_parser-&gt;controlStack()[controlIndex].enclosedExpressionStack;</span>
<span class="line-modified">!         for (TypedExpression value : expressionStack)</span>
<span class="line-modified">!             stackmap.append(value);</span>
      }
<span class="line-added">+     for (TypedExpression value : enclosingStack)</span>
<span class="line-added">+         stackmap.append(value);</span>
  
      PatchpointValue* patch = m_currentBlock-&gt;appendNew&lt;PatchpointValue&gt;(m_proc, B3::Void, origin);
      Effects effects = Effects::none();
      // FIXME: we should have a more precise heap range for the tier up count.
      effects.reads = B3::HeapRange::top();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1279,88 ***</span>
      static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
      static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(incrementCount), CCallHelpers::Address(params[0].gpr()));</span>
          MacroAssembler::Label tierUpResume = jit.label();
  
          OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);
<span class="line-modified">!         for (unsigned index = 0; index &lt; types.size(); ++index)</span>
<span class="line-modified">!             osrEntryData.values().constructAndAppend(params[index + 1], types[index]);</span>
          OSREntryData* osrEntryDataPtr = &amp;osrEntryData;
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              forceOSREntry.link(&amp;jit);
              tierUp.link(&amp;jit);
  
<span class="line-modified">!             jit.probe(triggerOSREntryNow, osrEntryDataPtr);</span>
              jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);
              jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);
          });
      });
  }
  
<span class="line-modified">! B3IRGenerator::ControlData B3IRGenerator::addLoop(Type signature, const Stack&amp; stack, uint32_t loopIndex)</span>
  {
      BasicBlock* body = m_proc.addBlock();
      BasicBlock* continuation = m_proc.addBlock();
  
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
      if (loopIndex == m_loopIndexForOSREntry) {
          m_currentBlock = m_rootBlock;
<span class="line-removed">-         m_osrEntryScratchBufferSize = m_locals.size() + stack.size();</span>
          Value* pointer = m_rootBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(m_proc, Origin(), GPRInfo::argumentGPR0);
  
<span class="line-modified">!         auto loadFromScratchBuffer = [&amp;] (B3::Type type, unsigned index) {</span>
<span class="line-modified">!             size_t offset = sizeof(uint64_t) * index;</span>
<span class="line-modified">!             switch (type.kind()) {</span>
<span class="line-modified">!             case B3::Int32:</span>
<span class="line-modified">!                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(), pointer, offset);</span>
<span class="line-removed">-             case B3::Int64:</span>
<span class="line-removed">-                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Int64, origin(), pointer, offset);</span>
<span class="line-removed">-             case B3::Float:</span>
<span class="line-removed">-                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Float, origin(), pointer, offset);</span>
<span class="line-removed">-             case B3::Double:</span>
<span class="line-removed">-                 return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, B3::Double, origin(), pointer, offset);</span>
<span class="line-removed">-             default:</span>
<span class="line-removed">-                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-             }</span>
          };
  
<span class="line-removed">-         unsigned indexInBuffer = 0;</span>
          for (auto&amp; local : m_locals)
<span class="line-modified">!             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, loadFromScratchBuffer(local-&gt;type(), indexInBuffer++));</span>
<span class="line-modified">!         for (unsigned i = 0; i &lt; stack.size(); ++i) {</span>
<span class="line-modified">!             auto* variable = stack.variableAt(i);</span>
<span class="line-modified">!             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), variable, loadFromScratchBuffer(variable-&gt;type(), indexInBuffer++));</span>
          }
          m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
          body-&gt;addPredecessor(m_currentBlock);
      }
  
<span class="line-removed">-     uint32_t outerLoopIndex = this-&gt;outerLoopIndex();</span>
<span class="line-removed">-     m_outerLoops.append(loopIndex);</span>
      m_currentBlock = body;
<span class="line-modified">!     emitLoopTierUpCheck(TierUpCount::loopIncrement(), stack, loopIndex, outerLoopIndex, origin());</span>
<span class="line-modified">! </span>
<span class="line-removed">-     return ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);</span>
  }
  
<span class="line-modified">! B3IRGenerator::ControlData B3IRGenerator::addTopLevel(Type signature)</span>
  {
      return ControlData(m_proc, Origin(), signature, BlockType::TopLevel, m_proc.addBlock());
  }
  
<span class="line-modified">! B3IRGenerator::ControlData B3IRGenerator::addBlock(Type signature)</span>
  {
<span class="line-modified">!     return ControlData(m_proc, origin(), signature, BlockType::Block, m_proc.addBlock());</span>
  }
  
<span class="line-modified">! auto B3IRGenerator::addIf(ExpressionType condition, Type signature, ControlType&amp; result) -&gt; PartialResult</span>
  {
      // FIXME: This needs to do some kind of stack passing.
  
      BasicBlock* taken = m_proc.addBlock();
      BasicBlock* notTaken = m_proc.addBlock();
<span class="line-new-header">--- 1322,137 ---</span>
      static_assert(!static_cast&lt;uint8_t&gt;(TierUpCount::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
      static_assert(sizeof(TierUpCount::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
      patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
          AllowMacroScratchRegisterUsage allowScratch(jit);
          CCallHelpers::Jump forceOSREntry = jit.branchTest8(CCallHelpers::NonZero, CCallHelpers::AbsoluteAddress(forceEntryTrigger));
<span class="line-modified">!         CCallHelpers::Jump tierUp = jit.branchAdd32(CCallHelpers::PositiveOrZero, CCallHelpers::TrustedImm32(TierUpCount::loopIncrement()), CCallHelpers::Address(params[0].gpr()));</span>
          MacroAssembler::Label tierUpResume = jit.label();
  
          OSREntryData&amp; osrEntryData = m_tierUp-&gt;addOSREntryData(m_functionIndex, loopIndex);
<span class="line-modified">!         // First argument is the countdown location.</span>
<span class="line-modified">!         for (unsigned i = 1; i &lt; params.value()-&gt;numChildren(); ++i)</span>
<span class="line-added">+             osrEntryData.values().constructAndAppend(params[i], params.value()-&gt;child(i)-&gt;type());</span>
          OSREntryData* osrEntryDataPtr = &amp;osrEntryData;
  
          params.addLatePath([=] (CCallHelpers&amp; jit) {
              AllowMacroScratchRegisterUsage allowScratch(jit);
              forceOSREntry.link(&amp;jit);
              tierUp.link(&amp;jit);
  
<span class="line-modified">!             jit.probe(operationWasmTriggerOSREntryNow, osrEntryDataPtr);</span>
              jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR0).linkTo(tierUpResume, &amp;jit);
              jit.farJump(GPRInfo::argumentGPR1, WasmEntryPtrTag);
          });
      });
  }
  
<span class="line-modified">! auto B3IRGenerator::addLoop(BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; block, Stack&amp; newStack, uint32_t loopIndex) -&gt; PartialResult</span>
  {
      BasicBlock* body = m_proc.addBlock();
      BasicBlock* continuation = m_proc.addBlock();
  
<span class="line-added">+     block = ControlData(m_proc, origin(), signature, BlockType::Loop, continuation, body);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ExpressionList args;</span>
<span class="line-added">+     {</span>
<span class="line-added">+         unsigned offset = enclosingStack.size() - signature-&gt;argumentCount();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; signature-&gt;argumentCount(); ++i) {</span>
<span class="line-added">+             TypedExpression value = enclosingStack.at(offset + i);</span>
<span class="line-added">+             auto* upsilon = m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), value);</span>
<span class="line-added">+             Value* phi = block.phis[i];</span>
<span class="line-added">+             body-&gt;append(phi);</span>
<span class="line-added">+             upsilon-&gt;setPhi(phi);</span>
<span class="line-added">+             newStack.constructAndAppend(value.type(), phi);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         enclosingStack.shrink(offset);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
      if (loopIndex == m_loopIndexForOSREntry) {
<span class="line-added">+         dataLogLnIf(WasmB3IRGeneratorInternal::verbose, &quot;Setting up for OSR entry&quot;);</span>
<span class="line-added">+ </span>
          m_currentBlock = m_rootBlock;
          Value* pointer = m_rootBlock-&gt;appendNew&lt;ArgumentRegValue&gt;(m_proc, Origin(), GPRInfo::argumentGPR0);
  
<span class="line-modified">!         unsigned indexInBuffer = 0;</span>
<span class="line-modified">!         auto loadFromScratchBuffer = [&amp;] (B3::Type type) {</span>
<span class="line-modified">!             size_t offset = sizeof(uint64_t) * indexInBuffer++;</span>
<span class="line-modified">!             RELEASE_ASSERT(type.isNumeric());</span>
<span class="line-modified">!             return m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, type, origin(), pointer, offset);</span>
          };
  
          for (auto&amp; local : m_locals)
<span class="line-modified">!             m_currentBlock-&gt;appendNew&lt;VariableValue&gt;(m_proc, Set, Origin(), local, loadFromScratchBuffer(local-&gt;type()));</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto connectControlEntry = [&amp;](const ControlData&amp; data, Stack&amp; expressionStack) {</span>
<span class="line-modified">!             // For each stack entry enclosed by this loop we need to replace the value with a phi so we can fill it on OSR entry.</span>
<span class="line-added">+             BasicBlock* sourceBlock = nullptr;</span>
<span class="line-added">+             unsigned blockIndex = 0;</span>
<span class="line-added">+             B3::InsertionSet insertionSet(m_proc);</span>
<span class="line-added">+             for (unsigned i = 0; i &lt; expressionStack.size(); i++) {</span>
<span class="line-added">+                 TypedExpression value = expressionStack[i];</span>
<span class="line-added">+                 if (value-&gt;isConstant()) {</span>
<span class="line-added">+                     ++indexInBuffer;</span>
<span class="line-added">+                     continue;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 if (value-&gt;owner != sourceBlock) {</span>
<span class="line-added">+                     if (sourceBlock)</span>
<span class="line-added">+                         insertionSet.execute(sourceBlock);</span>
<span class="line-added">+                     ASSERT(insertionSet.isEmpty());</span>
<span class="line-added">+                     dataLogLnIf(WasmB3IRGeneratorInternal::verbose &amp;&amp; sourceBlock, &quot;Executed insertion set into: &quot;, *sourceBlock);</span>
<span class="line-added">+                     blockIndex = 0;</span>
<span class="line-added">+                     sourceBlock = value-&gt;owner;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 while (sourceBlock-&gt;at(blockIndex++) != value)</span>
<span class="line-added">+                     ASSERT(blockIndex &lt; sourceBlock-&gt;size());</span>
<span class="line-added">+                 ASSERT(sourceBlock-&gt;at(blockIndex - 1) == value);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto* phi = data.continuation-&gt;appendNew&lt;Value&gt;(m_proc, Phi,  value-&gt;type(), value-&gt;origin());</span>
<span class="line-added">+                 expressionStack[i] = TypedExpression { value.type(), phi };</span>
<span class="line-added">+                 m_currentBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, value-&gt;origin(), loadFromScratchBuffer(value-&gt;type()), phi);</span>
<span class="line-added">+ </span>
<span class="line-added">+                 auto* sourceUpsilon = m_proc.add&lt;UpsilonValue&gt;(value-&gt;origin(), value, phi);</span>
<span class="line-added">+                 insertionSet.insertValue(blockIndex, sourceUpsilon);</span>
<span class="line-added">+             }</span>
<span class="line-added">+             if (sourceBlock)</span>
<span class="line-added">+                 insertionSet.execute(sourceBlock);</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (unsigned controlIndex = 0; controlIndex &lt; m_parser-&gt;controlStack().size(); ++controlIndex) {</span>
<span class="line-added">+             auto&amp; data = m_parser-&gt;controlStack()[controlIndex].controlData;</span>
<span class="line-added">+             auto&amp; expressionStack = m_parser-&gt;controlStack()[controlIndex].enclosedExpressionStack;</span>
<span class="line-added">+             connectControlEntry(data, expressionStack);</span>
          }
<span class="line-added">+         connectControlEntry(block, enclosingStack);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_osrEntryScratchBufferSize = indexInBuffer;</span>
          m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), body);
          body-&gt;addPredecessor(m_currentBlock);
      }
  
      m_currentBlock = body;
<span class="line-modified">!     emitLoopTierUpCheck(loopIndex, enclosingStack);</span>
<span class="line-modified">!     return { };</span>
  }
  
<span class="line-modified">! B3IRGenerator::ControlData B3IRGenerator::addTopLevel(BlockSignature signature)</span>
  {
      return ControlData(m_proc, Origin(), signature, BlockType::TopLevel, m_proc.addBlock());
  }
  
<span class="line-modified">! auto B3IRGenerator::addBlock(BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; newBlock, Stack&amp; newStack) -&gt; PartialResult</span>
  {
<span class="line-modified">!     BasicBlock* continuation = m_proc.addBlock();</span>
<span class="line-added">+ </span>
<span class="line-added">+     splitStack(signature, enclosingStack, newStack);</span>
<span class="line-added">+     newBlock = ControlData(m_proc, origin(), signature, BlockType::Block, continuation);</span>
<span class="line-added">+     return { };</span>
  }
  
<span class="line-modified">! auto B3IRGenerator::addIf(ExpressionType condition, BlockSignature signature, Stack&amp; enclosingStack, ControlType&amp; result, Stack&amp; newStack) -&gt; PartialResult</span>
  {
      // FIXME: This needs to do some kind of stack passing.
  
      BasicBlock* taken = m_proc.addBlock();
      BasicBlock* notTaken = m_proc.addBlock();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1370,42 ***</span>
      m_currentBlock-&gt;setSuccessors(FrequentedBlock(taken), FrequentedBlock(notTaken));
      taken-&gt;addPredecessor(m_currentBlock);
      notTaken-&gt;addPredecessor(m_currentBlock);
  
      m_currentBlock = taken;
      result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
      return { };
  }
  
  auto B3IRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(currentStack, data.result);</span>
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      return addElseToUnreachable(data);
  }
  
  auto B3IRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
  {
<span class="line-modified">!     ASSERT(data.type() == BlockType::If);</span>
      m_currentBlock = data.special;
      data.convertIfToBlock();
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addReturn(const ControlData&amp;, const ExpressionList&amp; returnValues) -&gt; PartialResult</span>
  {
<span class="line-modified">!     ASSERT(returnValues.size() &lt;= 1);</span>
<span class="line-modified">!     if (returnValues.size())</span>
<span class="line-modified">!         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin(), returnValues[0]);</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!         m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Return, origin());</span>
      return { };
  }
  
  auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(returnValues, data.resultForBranch());</span>
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
          BasicBlock* continuation = m_proc.addBlock();
          m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
<span class="line-new-header">--- 1462,66 ---</span>
      m_currentBlock-&gt;setSuccessors(FrequentedBlock(taken), FrequentedBlock(notTaken));
      taken-&gt;addPredecessor(m_currentBlock);
      notTaken-&gt;addPredecessor(m_currentBlock);
  
      m_currentBlock = taken;
<span class="line-added">+     splitStack(signature, enclosingStack, newStack);</span>
      result = ControlData(m_proc, origin(), signature, BlockType::If, continuation, notTaken);
      return { };
  }
  
  auto B3IRGenerator::addElse(ControlData&amp; data, const Stack&amp; currentStack) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(currentStack, data.phis);</span>
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      return addElseToUnreachable(data);
  }
  
  auto B3IRGenerator::addElseToUnreachable(ControlData&amp; data) -&gt; PartialResult
  {
<span class="line-modified">!     ASSERT(data.blockType() == BlockType::If);</span>
      m_currentBlock = data.special;
      data.convertIfToBlock();
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addReturn(const ControlData&amp;, const Stack&amp; returnValues) -&gt; PartialResult</span>
  {
<span class="line-modified">!     CallInformation wasmCallInfo = wasmCallingConvention().callInformationFor(m_parser-&gt;signature(), CallRole::Callee);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     PatchpointValue* patch = m_proc.add&lt;PatchpointValue&gt;(B3::Void, origin());</span>
<span class="line-modified">!     patch-&gt;setGenerator([] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {</span>
<span class="line-modified">!         auto calleeSaves = params.code().calleeSaveRegisterAtOffsetList();</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (RegisterAtOffset calleeSave : calleeSaves)</span>
<span class="line-added">+             jit.load64ToReg(CCallHelpers::Address(GPRInfo::callFrameRegister, calleeSave.offset()), calleeSave.reg());</span>
<span class="line-added">+ </span>
<span class="line-added">+         jit.emitFunctionEpilogue();</span>
<span class="line-added">+         jit.ret();</span>
<span class="line-added">+     });</span>
<span class="line-added">+     patch-&gt;effects.terminal = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_ASSERT(returnValues.size() &gt;= wasmCallInfo.results.size());</span>
<span class="line-added">+     unsigned offset = returnValues.size() - wasmCallInfo.results.size();</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; wasmCallInfo.results.size(); ++i) {</span>
<span class="line-added">+         B3::ValueRep rep = wasmCallInfo.results[i];</span>
<span class="line-added">+         if (rep.isStack()) {</span>
<span class="line-added">+             B3::Value* address = m_currentBlock-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, Origin(), framePointer(), constant(pointerType(), rep.offsetFromFP()));</span>
<span class="line-added">+             m_currentBlock-&gt;appendNew&lt;B3::MemoryValue&gt;(m_proc, B3::Store, Origin(), returnValues[offset + i], address);</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             ASSERT(rep.isReg());</span>
<span class="line-added">+             patch-&gt;append(returnValues[offset + i], rep);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_currentBlock-&gt;append(patch);</span>
      return { };
  }
  
  auto B3IRGenerator::addBranch(ControlData&amp; data, ExpressionType condition, const Stack&amp; returnValues) -&gt; PartialResult
  {
<span class="line-modified">!     unifyValuesWithBlock(returnValues, data.phis);</span>
  
      BasicBlock* target = data.targetBlockForBranch();
      if (condition) {
          BasicBlock* continuation = m_proc.addBlock();
          m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, B3::Branch, origin(), condition);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1422,12 ***</span>
  }
  
  auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult
  {
      for (size_t i = 0; i &lt; targets.size(); ++i)
<span class="line-modified">!         unifyValuesWithBlock(expressionStack, targets[i]-&gt;resultForBranch());</span>
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, defaultTarget.resultForBranch());</span>
  
      SwitchValue* switchValue = m_currentBlock-&gt;appendNew&lt;SwitchValue&gt;(m_proc, origin(), condition);
      switchValue-&gt;setFallThrough(FrequentedBlock(defaultTarget.targetBlockForBranch()));
      for (size_t i = 0; i &lt; targets.size(); ++i)
          switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
<span class="line-new-header">--- 1538,12 ---</span>
  }
  
  auto B3IRGenerator::addSwitch(ExpressionType condition, const Vector&lt;ControlData*&gt;&amp; targets, ControlData&amp; defaultTarget, const Stack&amp; expressionStack) -&gt; PartialResult
  {
      for (size_t i = 0; i &lt; targets.size(); ++i)
<span class="line-modified">!         unifyValuesWithBlock(expressionStack, targets[i]-&gt;phis);</span>
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, defaultTarget.phis);</span>
  
      SwitchValue* switchValue = m_currentBlock-&gt;appendNew&lt;SwitchValue&gt;(m_proc, origin(), condition);
      switchValue-&gt;setFallThrough(FrequentedBlock(defaultTarget.targetBlockForBranch()));
      for (size_t i = 0; i &lt; targets.size(); ++i)
          switchValue-&gt;appendCase(SwitchCase(i, FrequentedBlock(targets[i]-&gt;targetBlockForBranch())));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1437,67 ***</span>
  
  auto B3IRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult
  {
      ControlData&amp; data = entry.controlData;
  
<span class="line-modified">!     unifyValuesWithBlock(expressionStack, data.result);</span>
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      data.continuation-&gt;addPredecessor(m_currentBlock);
  
<span class="line-modified">!     if (data.type() == BlockType::Loop)</span>
<span class="line-removed">-         m_outerLoops.removeLast();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return addEndToUnreachable(entry);</span>
  }
  
<span class="line-modified">! </span>
<span class="line-removed">- auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
      m_currentBlock = data.continuation;
  
<span class="line-modified">!     if (data.type() == BlockType::If) {</span>
          data.special-&gt;appendNewControlValue(m_proc, Jump, origin(), m_currentBlock);
          m_currentBlock-&gt;addPredecessor(data.special);
      }
  
<span class="line-modified">!     for (Value* result : data.result) {</span>
<span class="line-modified">!         m_currentBlock-&gt;append(result);</span>
<span class="line-modified">!         entry.enclosedExpressionStack.append(result);</span>
      }
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
<span class="line-modified">!     if (data.type() == BlockType::TopLevel)</span>
<span class="line-modified">!         return addReturn(entry.controlData, entry.enclosedExpressionStack.convertToExpressionList());</span>
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
  
<span class="line-removed">-     Type returnType = signature.returnType();</span>
      Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
  
      if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
          m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
  
<span class="line-modified">!         // FIXME imports can be linked here, instead of generating a patchpoint, because all import stubs are generated before B3 compilation starts. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
          Value* targetInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTargetInstance(functionIndex)));
          // The target instance is 0 unless the call is wasm-&gt;wasm.
          Value* isWasmCall = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), targetInstance, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0));
  
          BasicBlock* isWasmBlock = m_proc.addBlock();
          BasicBlock* isEmbedderBlock = m_proc.addBlock();
          BasicBlock* continuation = m_proc.addBlock();
          m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(), isWasmCall, FrequentedBlock(isWasmBlock), FrequentedBlock(isEmbedderBlock));
  
<span class="line-modified">!         Value* wasmCallResult = wasmCallingConvention().setupCall(m_proc, isWasmBlock, origin(), args, toB3Type(returnType),</span>
<span class="line-modified">!             [=] (PatchpointValue* patchpoint) {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
                  // We need to clobber all potential pinned registers since we might be leaving the instance.
                  // We pessimistically assume we could be calling to something that is bounds checking.
                  // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
<span class="line-new-header">--- 1553,122 ---</span>
  
  auto B3IRGenerator::endBlock(ControlEntry&amp; entry, Stack&amp; expressionStack) -&gt; PartialResult
  {
      ControlData&amp; data = entry.controlData;
  
<span class="line-modified">!     ASSERT(expressionStack.size() == data.signature()-&gt;returnCount());</span>
<span class="line-added">+     if (data.blockType() != BlockType::Loop)</span>
<span class="line-added">+         unifyValuesWithBlock(expressionStack, data.phis);</span>
<span class="line-added">+ </span>
      m_currentBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), data.continuation);
      data.continuation-&gt;addPredecessor(m_currentBlock);
  
<span class="line-modified">!     return addEndToUnreachable(entry, expressionStack);</span>
  }
  
<span class="line-modified">! auto B3IRGenerator::addEndToUnreachable(ControlEntry&amp; entry, const Stack&amp; expressionStack) -&gt; PartialResult</span>
  {
      ControlData&amp; data = entry.controlData;
      m_currentBlock = data.continuation;
  
<span class="line-modified">!     if (data.blockType() == BlockType::If) {</span>
          data.special-&gt;appendNewControlValue(m_proc, Jump, origin(), m_currentBlock);
          m_currentBlock-&gt;addPredecessor(data.special);
      }
  
<span class="line-modified">!     if (data.blockType() != BlockType::Loop) {</span>
<span class="line-modified">!         for (unsigned i = 0; i &lt; data.signature()-&gt;returnCount(); ++i) {</span>
<span class="line-modified">!             Value* result = data.phis[i];</span>
<span class="line-added">+             m_currentBlock-&gt;append(result);</span>
<span class="line-added">+             entry.enclosedExpressionStack.constructAndAppend(data.signature()-&gt;returnType(i), result);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         m_outerLoops.removeLast();</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; data.signature()-&gt;returnCount(); ++i) {</span>
<span class="line-added">+             if (i &lt; expressionStack.size())</span>
<span class="line-added">+                 entry.enclosedExpressionStack.append(expressionStack[i]);</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 Type returnType = data.signature()-&gt;returnType(i);</span>
<span class="line-added">+                 entry.enclosedExpressionStack.constructAndAppend(returnType, constant(toB3Type(returnType), 0xbbadbeef));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
      }
  
      // TopLevel does not have any code after this so we need to make sure we emit a return here.
<span class="line-modified">!     if (data.blockType() == BlockType::TopLevel)</span>
<span class="line-modified">!         return addReturn(entry.controlData, entry.enclosedExpressionStack);</span>
  
      return { };
  }
  
<span class="line-modified">! </span>
<span class="line-added">+ B3::Value* B3IRGenerator::createCallPatchpoint(BasicBlock* block, Origin origin, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, const ScopedLambda&lt;void(PatchpointValue*)&gt;&amp; patchpointFunctor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     Vector&lt;B3::ConstrainedValue&gt; constrainedArguments;</span>
<span class="line-added">+     CallInformation wasmCallInfo = wasmCallingConvention().callInformationFor(signature);</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; args.size(); ++i)</span>
<span class="line-added">+         constrainedArguments.append(B3::ConstrainedValue(args[i], wasmCallInfo.params[i]));</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_proc.requestCallArgAreaSizeInBytes(WTF::roundUpToMultipleOf(stackAlignmentBytes(), wasmCallInfo.headerAndArgumentStackSizeInBytes));</span>
<span class="line-added">+ </span>
<span class="line-added">+     B3::Type returnType = toB3ResultType(&amp;signature);</span>
<span class="line-added">+     B3::PatchpointValue* patchpoint = block-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, returnType, origin);</span>
<span class="line-added">+     patchpoint-&gt;clobberEarly(RegisterSet::macroScratchRegisters());</span>
<span class="line-added">+     patchpoint-&gt;clobberLate(RegisterSet::volatileRegistersForJSCall());</span>
<span class="line-added">+     patchpointFunctor(patchpoint);</span>
<span class="line-added">+     patchpoint-&gt;appendVector(constrainedArguments);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (returnType != B3::Void)</span>
<span class="line-added">+         patchpoint-&gt;resultConstraints = WTFMove(wasmCallInfo.results);</span>
<span class="line-added">+     return patchpoint;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ auto B3IRGenerator::addCall(uint32_t functionIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results) -&gt; PartialResult</span>
  {
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
<span class="line-added">+     B3::Type returnType = toB3ResultType(&amp;signature);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto fillResults = [&amp;] (Value* callResult) {</span>
<span class="line-added">+         ASSERT(returnType == callResult-&gt;type());</span>
<span class="line-added">+ </span>
<span class="line-added">+         switch (returnType.kind()) {</span>
<span class="line-added">+         case B3::Void: {</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         case B3::Tuple: {</span>
<span class="line-added">+             const Vector&lt;B3::Type&gt;&amp; tuple = m_proc.tupleForType(returnType);</span>
<span class="line-added">+             ASSERT(signature.returnCount() == tuple.size());</span>
<span class="line-added">+             for (unsigned i = 0; i &lt; signature.returnCount(); ++i)</span>
<span class="line-added">+                 results.append(m_currentBlock-&gt;appendNew&lt;ExtractValue&gt;(m_proc, origin(), tuple[i], callResult, i));</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         default: {</span>
<span class="line-added">+             results.append(callResult);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     };</span>
  
      Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls = &amp;m_unlinkedWasmToWasmCalls;
  
      if (m_info.isImportedFunctionFromFunctionIndexSpace(functionIndex)) {
          m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
  
<span class="line-modified">!         // FIXME: imports can be linked here, instead of generating a patchpoint, because all import stubs are generated before B3 compilation starts. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
          Value* targetInstance = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTargetInstance(functionIndex)));
          // The target instance is 0 unless the call is wasm-&gt;wasm.
          Value* isWasmCall = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, NotEqual, origin(), targetInstance, m_currentBlock-&gt;appendNew&lt;Const64Value&gt;(m_proc, origin(), 0));
  
          BasicBlock* isWasmBlock = m_proc.addBlock();
          BasicBlock* isEmbedderBlock = m_proc.addBlock();
          BasicBlock* continuation = m_proc.addBlock();
          m_currentBlock-&gt;appendNewControlValue(m_proc, B3::Branch, origin(), isWasmCall, FrequentedBlock(isWasmBlock), FrequentedBlock(isEmbedderBlock));
  
<span class="line-modified">!         Value* wasmCallResult = createCallPatchpoint(isWasmBlock, origin(), signature, args,</span>
<span class="line-modified">!             scopedLambdaRef&lt;void(PatchpointValue*)&gt;([=] (PatchpointValue* patchpoint) -&gt; void {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
                  // We need to clobber all potential pinned registers since we might be leaving the instance.
                  // We pessimistically assume we could be calling to something that is bounds checking.
                  // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1507,70 ***</span>
                      CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                      });
                  });
<span class="line-modified">!             });</span>
<span class="line-modified">!         UpsilonValue* wasmCallResultUpsilon = returnType == Void ? nullptr : isWasmBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), wasmCallResult);</span>
          isWasmBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
          // FIXME: Let&#39;s remove this indirection by creating a PIC friendly IC
          // for calls out to the embedder. This shouldn&#39;t be that hard to do. We could probably
          // implement the IC to be over Context*.
          // https://bugs.webkit.org/show_bug.cgi?id=170375
          Value* jumpDestination = isEmbedderBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc,
              Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfWasmToEmbedderStub(functionIndex)));
  
<span class="line-modified">!         Value* embedderCallResult = wasmCallingConvention().setupCall(m_proc, isEmbedderBlock, origin(), args, toB3Type(returnType),</span>
<span class="line-modified">!             [=] (PatchpointValue* patchpoint) {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
                  patchpoint-&gt;append(jumpDestination, ValueRep::SomeRegister);
                  // We need to clobber all potential pinned registers since we might be leaving the instance.
                  // We pessimistically assume we could be calling to something that is bounds checking.
                  // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
                  patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
                  patchpoint-&gt;setGenerator([returnType] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                     jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);</span>
                  });
<span class="line-modified">!             });</span>
<span class="line-modified">!         UpsilonValue* embedderCallResultUpsilon = returnType == Void ? nullptr : isEmbedderBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), embedderCallResult);</span>
          isEmbedderBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
          m_currentBlock = continuation;
  
<span class="line-modified">!         if (returnType == Void)</span>
<span class="line-modified">!             result = nullptr;</span>
<span class="line-modified">!         else {</span>
<span class="line-modified">!             result = continuation-&gt;appendNew&lt;Value&gt;(m_proc, Phi, toB3Type(returnType), origin());</span>
<span class="line-modified">!             wasmCallResultUpsilon-&gt;setPhi(result);</span>
<span class="line-removed">-             embedderCallResultUpsilon-&gt;setPhi(result);</span>
          }
  
          // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
          restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, continuation);
      } else {
<span class="line-modified">!         result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),</span>
<span class="line-modified">!             [=] (PatchpointValue* patchpoint) {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
  
                  patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
                      CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                      });
                  });
<span class="line-modified">!             });</span>
      }
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ExpressionType&amp; result) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
<span class="line-new-header">--- 1678,74 ---</span>
                      CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                      });
                  });
<span class="line-modified">!             }));</span>
<span class="line-modified">!         UpsilonValue* wasmCallResultUpsilon = returnType == B3::Void ? nullptr : isWasmBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), wasmCallResult);</span>
          isWasmBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
          // FIXME: Let&#39;s remove this indirection by creating a PIC friendly IC
          // for calls out to the embedder. This shouldn&#39;t be that hard to do. We could probably
          // implement the IC to be over Context*.
          // https://bugs.webkit.org/show_bug.cgi?id=170375
          Value* jumpDestination = isEmbedderBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc,
              Load, pointerType(), origin(), instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfWasmToEmbedderStub(functionIndex)));
  
<span class="line-modified">!         Value* embedderCallResult = createCallPatchpoint(isEmbedderBlock, origin(), signature, args,</span>
<span class="line-modified">!             scopedLambdaRef&lt;void(PatchpointValue*)&gt;([=] (PatchpointValue* patchpoint) -&gt; void {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
                  patchpoint-&gt;append(jumpDestination, ValueRep::SomeRegister);
                  // We need to clobber all potential pinned registers since we might be leaving the instance.
                  // We pessimistically assume we could be calling to something that is bounds checking.
                  // FIXME: We shouldn&#39;t have to do this: https://bugs.webkit.org/show_bug.cgi?id=172181
                  patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
                  patchpoint-&gt;setGenerator([returnType] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                     jit.call(params[params.proc().resultCount(returnType)].gpr(), WasmEntryPtrTag);</span>
                  });
<span class="line-modified">!             }));</span>
<span class="line-modified">!         UpsilonValue* embedderCallResultUpsilon = returnType == B3::Void ? nullptr : isEmbedderBlock-&gt;appendNew&lt;UpsilonValue&gt;(m_proc, origin(), embedderCallResult);</span>
          isEmbedderBlock-&gt;appendNewControlValue(m_proc, Jump, origin(), continuation);
  
          m_currentBlock = continuation;
  
<span class="line-modified">!         if (returnType != B3::Void) {</span>
<span class="line-modified">!             Value* phi = continuation-&gt;appendNew&lt;Value&gt;(m_proc, Phi, returnType, origin());</span>
<span class="line-modified">!             wasmCallResultUpsilon-&gt;setPhi(phi);</span>
<span class="line-modified">!             embedderCallResultUpsilon-&gt;setPhi(phi);</span>
<span class="line-modified">!             fillResults(phi);</span>
          }
  
          // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
          restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, continuation);
      } else {
<span class="line-modified">! </span>
<span class="line-modified">!         Value* patch = createCallPatchpoint(m_currentBlock, origin(), signature, args,</span>
<span class="line-added">+             scopedLambdaRef&lt;void(PatchpointValue*)&gt;([=] (PatchpointValue* patchpoint) -&gt; void {</span>
                  patchpoint-&gt;effects.writesPinned = true;
                  patchpoint-&gt;effects.readsPinned = true;
  
<span class="line-added">+                 // We need to clobber the size register since the LLInt always bounds checks</span>
<span class="line-added">+                 if (m_mode == MemoryMode::Signaling)</span>
<span class="line-added">+                     patchpoint-&gt;clobberLate(RegisterSet { PinnedRegisterInfo::get().sizeRegister });</span>
                  patchpoint-&gt;setGenerator([unlinkedWasmToWasmCalls, functionIndex] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp;) {
                      AllowMacroScratchRegisterUsage allowScratch(jit);
                      CCallHelpers::Call call = jit.threadSafePatchableNearCall();
                      jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndex] (LinkBuffer&amp; linkBuffer) {
                          unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndex });
                      });
                  });
<span class="line-modified">!             }));</span>
<span class="line-added">+         fillResults(patch);</span>
      }
  
      return { };
  }
  
<span class="line-modified">! auto B3IRGenerator::addCallIndirect(unsigned tableIndex, const Signature&amp; signature, Vector&lt;ExpressionType&gt;&amp; args, ResultList&amp; results) -&gt; PartialResult</span>
  {
      ExpressionType calleeIndex = args.takeLast();
      ASSERT(signature.argumentCount() == args.size());
  
      m_makesCalls = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1580,23 ***</span>
      m_maxNumJSCallArguments = std::max(m_maxNumJSCallArguments, static_cast&lt;uint32_t&gt;(args.size()));
  
      ExpressionType callableFunctionBuffer;
      ExpressionType instancesBuffer;
      ExpressionType callableFunctionBufferLength;
<span class="line-removed">-     ExpressionType mask;</span>
      {
          ExpressionType table = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
              instanceValue(), safeCast&lt;int32_t&gt;(Instance::offsetOfTablePtr(m_numImportFunctions, tableIndex)));
          callableFunctionBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
              table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfFunctions()));
          instancesBuffer = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
              table, safeCast&lt;int32_t&gt;(FuncRefTable::offsetOfInstances()));
          callableFunctionBufferLength = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),
              table, safeCast&lt;int32_t&gt;(Table::offsetOfLength()));
<span class="line-removed">-         mask = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(),</span>
<span class="line-removed">-             m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, Int32, origin(),</span>
<span class="line-removed">-                 table, safeCast&lt;int32_t&gt;(Table::offsetOfMask())));</span>
      }
  
      // Check the index we are looking for is valid.
      {
          CheckValue* check = m_currentBlock-&gt;appendNew&lt;CheckValue&gt;(m_proc, Check, origin(),
<span class="line-new-header">--- 1755,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1607,13 ***</span>
          });
      }
  
      calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, ZExt32, origin(), calleeIndex);
  
<span class="line-removed">-     if (Options::enableSpectreMitigations())</span>
<span class="line-removed">-         calleeIndex = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, BitAnd, origin(), mask, calleeIndex);</span>
<span class="line-removed">- </span>
      ExpressionType callableFunction;
      {
          // Compute the offset in the table index space we are looking for.
          ExpressionType offset = m_currentBlock-&gt;appendNew&lt;Value&gt;(m_proc, Mul, origin(),
              calleeIndex, constant(pointerType(), sizeof(WasmToWasmImportableFunction)));
<span class="line-new-header">--- 1778,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1699,13 ***</span>
  
      ExpressionType calleeCode = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
          m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), callableFunction,
              safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfEntrypointLoadLocation())));
  
<span class="line-modified">!     Type returnType = signature.returnType();</span>
<span class="line-modified">!     result = wasmCallingConvention().setupCall(m_proc, m_currentBlock, origin(), args, toB3Type(returnType),</span>
<span class="line-modified">!         [=] (PatchpointValue* patchpoint) {</span>
              patchpoint-&gt;effects.writesPinned = true;
              patchpoint-&gt;effects.readsPinned = true;
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we&#39;re always calling something that is bounds checking so
              // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
<span class="line-new-header">--- 1867,13 ---</span>
  
      ExpressionType calleeCode = m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(),
          m_currentBlock-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, pointerType(), origin(), callableFunction,
              safeCast&lt;int32_t&gt;(WasmToWasmImportableFunction::offsetOfEntrypointLoadLocation())));
  
<span class="line-modified">!     B3::Type returnType = toB3ResultType(&amp;signature);</span>
<span class="line-modified">!     ExpressionType callResult = createCallPatchpoint(m_currentBlock, origin(), signature, args,</span>
<span class="line-modified">!         scopedLambdaRef&lt;void(PatchpointValue*)&gt;([=] (PatchpointValue* patchpoint) -&gt; void {</span>
              patchpoint-&gt;effects.writesPinned = true;
              patchpoint-&gt;effects.readsPinned = true;
              // We need to clobber all potential pinned registers since we might be leaving the instance.
              // We pessimistically assume we&#39;re always calling something that is bounds checking so
              // because the wasm-&gt;wasm thunk unconditionally overrides the size registers.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1714,13 ***</span>
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
  
              patchpoint-&gt;append(calleeCode, ValueRep::SomeRegister);
              patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                 jit.call(params[returnType == Void ? 0 : 1].gpr(), WasmEntryPtrTag);</span>
              });
<span class="line-modified">!         });</span>
  
      // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, m_currentBlock);
  
      return { };
<span class="line-new-header">--- 1882,29 ---</span>
              patchpoint-&gt;clobberLate(PinnedRegisterInfo::get().toSave(MemoryMode::BoundsChecking));
  
              patchpoint-&gt;append(calleeCode, ValueRep::SomeRegister);
              patchpoint-&gt;setGenerator([=] (CCallHelpers&amp; jit, const B3::StackmapGenerationParams&amp; params) {
                  AllowMacroScratchRegisterUsage allowScratch(jit);
<span class="line-modified">!                 jit.call(params[params.proc().resultCount(returnType)].gpr(), WasmEntryPtrTag);</span>
              });
<span class="line-modified">!         }));</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (returnType.kind()) {</span>
<span class="line-added">+     case B3::Void: {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case B3::Tuple: {</span>
<span class="line-added">+         const Vector&lt;B3::Type&gt;&amp; tuple = m_proc.tupleForType(returnType);</span>
<span class="line-added">+         for (unsigned i = 0; i &lt; signature.returnCount(); ++i)</span>
<span class="line-added">+             results.append(m_currentBlock-&gt;appendNew&lt;ExtractValue&gt;(m_proc, origin(), tuple[i], callResult, i));</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default: {</span>
<span class="line-added">+         results.append(callResult);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
  
      // The call could have been to another WebAssembly instance, and / or could have modified our Memory.
      restoreWebAssemblyGlobalState(RestoreCachedStackLimit::Yes, m_info.memory, instanceValue(), m_proc, m_currentBlock);
  
      return { };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1737,11 ***</span>
  
      for (size_t i = 0; i &lt; result.size(); ++i)
          unify(result[result.size() - 1 - i], resultStack.at(resultStack.size() - 1 - i));
  }
  
<span class="line-modified">! void B3IRGenerator::dump(const Vector&lt;ControlEntry&gt;&amp; controlStack, const Stack* expressionStack)</span>
  {
      dataLogLn(&quot;Constants:&quot;);
      for (const auto&amp; constant : m_constantPool)
          dataLogLn(deepDump(m_proc, constant.value));
  
<span class="line-new-header">--- 1921,18 ---</span>
  
      for (size_t i = 0; i &lt; result.size(); ++i)
          unify(result[result.size() - 1 - i], resultStack.at(resultStack.size() - 1 - i));
  }
  
<span class="line-modified">! static void dumpExpressionStack(const CommaPrinter&amp; comma, const B3IRGenerator::Stack&amp; expressionStack)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     dataLog(comma, &quot;ExpressionStack:&quot;);</span>
<span class="line-added">+     for (const auto&amp; expression : expressionStack)</span>
<span class="line-added">+         dataLog(comma, *expression);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void B3IRGenerator::dump(const ControlStack&amp; controlStack, const Stack* expressionStack)</span>
  {
      dataLogLn(&quot;Constants:&quot;);
      for (const auto&amp; constant : m_constantPool)
          dataLogLn(deepDump(m_proc, constant.value));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1750,11 ***</span>
      dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
      dataLogLn(&quot;Control stack:&quot;);
      ASSERT(controlStack.size());
      for (size_t i = controlStack.size(); i--;) {
          dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<span class="line-modified">!         expressionStack-&gt;dump();</span>
          expressionStack = &amp;controlStack[i].enclosedExpressionStack;
          dataLogLn();
      }
      dataLogLn();
  }
<span class="line-new-header">--- 1941,12 ---</span>
      dataLogLn(&quot;With current block:&quot;, *m_currentBlock);
      dataLogLn(&quot;Control stack:&quot;);
      ASSERT(controlStack.size());
      for (size_t i = controlStack.size(); i--;) {
          dataLog(&quot;  &quot;, controlStack[i].controlData, &quot;: &quot;);
<span class="line-modified">!         CommaPrinter comma(&quot;, &quot;, &quot;&quot;);</span>
<span class="line-added">+         dumpExpressionStack(comma, *expressionStack);</span>
          expressionStack = &amp;controlStack[i].enclosedExpressionStack;
          dataLogLn();
      }
      dataLogLn();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1764,11 ***</span>
      OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
      ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
      return bitwise_cast&lt;Origin&gt;(origin);
  }
  
<span class="line-modified">! Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const uint8_t* functionStart, size_t functionLength, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, uint32_t loopIndexForOSREntry, TierUpCount* tierUp, ThrowWasmException throwWasmException)</span>
  {
      auto result = makeUnique&lt;InternalFunction&gt;();
  
      compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
      compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
<span class="line-new-header">--- 1956,11 ---</span>
      OpcodeOrigin origin(m_parser-&gt;currentOpcode(), m_parser-&gt;currentOpcodeStartingOffset());
      ASSERT(isValidOpType(static_cast&lt;uint8_t&gt;(origin.opcode())));
      return bitwise_cast&lt;Origin&gt;(origin);
  }
  
<span class="line-modified">! Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompile(CompilationContext&amp; compilationContext, const FunctionData&amp; function, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, unsigned&amp; osrEntryScratchBufferSize, const ModuleInformation&amp; info, MemoryMode mode, CompilationMode compilationMode, uint32_t functionIndex, uint32_t loopIndexForOSREntry, TierUpCount* tierUp)</span>
  {
      auto result = makeUnique&lt;InternalFunction&gt;();
  
      compilationContext.embedderEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
      compilationContext.wasmEntrypointJIT = makeUnique&lt;CCallHelpers&gt;();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1788,18 ***</span>
  
      procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
          ? Options::webAssemblyBBQB3OptimizationLevel()
          : Options::webAssemblyOMGOptimizationLevel());
  
<span class="line-modified">!     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, mode, compilationMode, functionIndex, loopIndexForOSREntry, tierUp, throwWasmException);</span>
<span class="line-modified">!     FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, functionStart, functionLength, signature, info);</span>
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
      irGenerator.insertConstants();
  
      procedure.resetReachability();
<span class="line-modified">!     if (!ASSERT_DISABLED)</span>
          validate(procedure, &quot;After parsing:\n&quot;);
  
      dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Pre SSA: &quot;, procedure);
      fixSSA(procedure);
      dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Post SSA: &quot;, procedure);
<span class="line-new-header">--- 1980,18 ---</span>
  
      procedure.setOptLevel(compilationMode == CompilationMode::BBQMode
          ? Options::webAssemblyBBQB3OptimizationLevel()
          : Options::webAssemblyOMGOptimizationLevel());
  
<span class="line-modified">!     B3IRGenerator irGenerator(info, procedure, result.get(), unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, mode, compilationMode, functionIndex, loopIndexForOSREntry, tierUp);</span>
<span class="line-modified">!     FunctionParser&lt;B3IRGenerator&gt; parser(irGenerator, function.data.data(), function.data.size(), signature, info);</span>
      WASM_FAIL_IF_HELPER_FAILS(parser.parse());
  
      irGenerator.insertConstants();
  
      procedure.resetReachability();
<span class="line-modified">!     if (ASSERT_ENABLED)</span>
          validate(procedure, &quot;After parsing:\n&quot;);
  
      dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Pre SSA: &quot;, procedure);
      fixSSA(procedure);
      dataLogIf(WasmB3IRGeneratorInternal::verbose, &quot;Post SSA: &quot;, procedure);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1956,12 ***</span>
          result = patchpoint;
          return { };
      }
  #endif
  
<span class="line-modified">!     uint32_t (*popcount)(int32_t) = [] (int32_t value) -&gt; uint32_t { return __builtin_popcount(value); };</span>
<span class="line-removed">-     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(popcount, B3CCallPtrTag));</span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(), Effects::none(), funcAddress, arg);
      return { };
  }
  
  template&lt;&gt;
<span class="line-new-header">--- 2148,11 ---</span>
          result = patchpoint;
          return { };
      }
  #endif
  
<span class="line-modified">!     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(&amp;operationPopcount32, B3CCallPtrTag));</span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int32, origin(), Effects::none(), funcAddress, arg);
      return { };
  }
  
  template&lt;&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1978,12 ***</span>
          result = patchpoint;
          return { };
      }
  #endif
  
<span class="line-modified">!     uint64_t (*popcount)(int64_t) = [] (int64_t value) -&gt; uint64_t { return __builtin_popcountll(value); };</span>
<span class="line-removed">-     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(popcount, B3CCallPtrTag));</span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int64, origin(), Effects::none(), funcAddress, arg);
      return { };
  }
  
  template&lt;&gt;
<span class="line-new-header">--- 2169,11 ---</span>
          result = patchpoint;
          return { };
      }
  #endif
  
<span class="line-modified">!     Value* funcAddress = m_currentBlock-&gt;appendNew&lt;ConstPtrValue&gt;(m_proc, origin(), tagCFunctionPtr&lt;void*&gt;(operationPopcount64, B3CCallPtrTag));</span>
      result = m_currentBlock-&gt;appendNew&lt;CCallValue&gt;(m_proc, Int64, origin(), Effects::none(), funcAddress, arg);
      return { };
  }
  
  template&lt;&gt;
</pre>
<center><a href="WasmAirIRGenerator.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmB3IRGenerator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InByIdVariant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineCallFrame.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineAccess.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -150,13 +150,13 @@</span>
  
  
  template &lt;typename Function&gt;
  ALWAYS_INLINE static bool linkCodeInline(const char* name, CCallHelpers&amp; jit, StructureStubInfo&amp; stubInfo, const Function&amp; function)
  {
<span class="udiff-line-modified-removed">-     if (jit.m_assembler.buffer().codeSize() &lt;= stubInfo.patch.inlineSize()) {</span>
<span class="udiff-line-modified-added">+     if (jit.m_assembler.buffer().codeSize() &lt;= stubInfo.inlineSize()) {</span>
          bool needsBranchCompaction = true;
<span class="udiff-line-modified-removed">-         LinkBuffer linkBuffer(jit, stubInfo.patch.start, stubInfo.patch.inlineSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
<span class="udiff-line-modified-added">+         LinkBuffer linkBuffer(jit, stubInfo.start, stubInfo.inlineSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
          ASSERT(linkBuffer.isValid());
          function(linkBuffer);
          FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccessType: &#39;%s&#39;&quot;, name);
          return true;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -167,22 +167,25 @@</span>
      // of randomness. It&#39;s helpful to flip this on when running tests or browsing
      // the web just to see how often it fails. You don&#39;t want an IC size that always fails.
      constexpr bool failIfCantInline = false;
      if (failIfCantInline) {
          dataLog(&quot;Failure for: &quot;, name, &quot;\n&quot;);
<span class="udiff-line-modified-removed">-         dataLog(&quot;real size: &quot;, jit.m_assembler.buffer().codeSize(), &quot; inline size:&quot;, stubInfo.patch.inlineSize(), &quot;\n&quot;);</span>
<span class="udiff-line-modified-added">+         dataLog(&quot;real size: &quot;, jit.m_assembler.buffer().codeSize(), &quot; inline size:&quot;, stubInfo.inlineSize(), &quot;\n&quot;);</span>
          CRASH();
      }
  
      return false;
  }
  
  bool InlineAccess::generateSelfPropertyAccess(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      CCallHelpers jit;
  
<span class="udiff-line-modified-removed">-     GPRReg base = stubInfo.baseGPR();</span>
<span class="udiff-line-modified-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -197,23 +200,23 @@</span>
  
      jit.loadValue(
          MacroAssembler::Address(storage, offsetRelativeToBase(offset)), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;property access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  ALWAYS_INLINE static GPRReg getScratchRegister(StructureStubInfo&amp; stubInfo)
  {
<span class="udiff-line-modified-removed">-     ScratchRegisterAllocator allocator(stubInfo.patch.usedRegisters);</span>
<span class="udiff-line-modified-removed">-     allocator.lock(stubInfo.baseGPR());</span>
<span class="udiff-line-modified-removed">-     allocator.lock(stubInfo.patch.valueGPR);</span>
<span class="udiff-line-modified-added">+     ScratchRegisterAllocator allocator(stubInfo.usedRegisters);</span>
<span class="udiff-line-modified-added">+     allocator.lock(stubInfo.baseGPR);</span>
<span class="udiff-line-modified-added">+     allocator.lock(stubInfo.valueGPR);</span>
  #if USE(JSVALUE32_64)
<span class="udiff-line-modified-removed">-     allocator.lock(stubInfo.patch.baseTagGPR);</span>
<span class="udiff-line-modified-removed">-     allocator.lock(stubInfo.patch.valueTagGPR);</span>
<span class="udiff-line-modified-added">+     allocator.lock(stubInfo.baseTagGPR);</span>
<span class="udiff-line-modified-added">+     allocator.lock(stubInfo.valueTagGPR);</span>
  #endif
      GPRReg scratch = allocator.allocateScratchGPR();
      if (allocator.didReuseRegisters())
          return InvalidGPRReg;
      return scratch;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -224,23 +227,29 @@</span>
      return getScratchRegister(stubInfo) != InvalidGPRReg;
  }
  
  bool InlineAccess::canGenerateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, PropertyOffset offset)
  {
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      if (isInlineOffset(offset))
          return true;
  
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateSelfPropertyReplace(StructureStubInfo&amp; stubInfo, Structure* structure, PropertyOffset offset)
  {
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      ASSERT(canGenerateSelfPropertyReplace(stubInfo, offset));
  
      CCallHelpers jit;
  
<span class="udiff-line-modified-removed">-     GPRReg base = stubInfo.baseGPR();</span>
<span class="udiff-line-modified-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -257,32 +266,38 @@</span>
  
      jit.storeValue(
          value, MacroAssembler::Address(storage, offsetRelativeToBase(offset)));
  
      bool linkedCodeInline = linkCodeInline(&quot;property replace&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(array-&gt;indexingType() &amp; IsArray);
  
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      if (!hasFreeRegister(stubInfo))
          return false;
  
      return !hasAnyArrayStorage(array-&gt;indexingType()) &amp;&amp; array-&gt;indexingType() != ArrayClass;
  }
  
  bool InlineAccess::generateArrayLength(StructureStubInfo&amp; stubInfo, JSArray* array)
  {
      ASSERT(isCacheableArrayLength(stubInfo, array));
  
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      CCallHelpers jit;
  
<span class="udiff-line-modified-removed">-     GPRReg base = stubInfo.baseGPR();</span>
<span class="udiff-line-modified-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      jit.load8(CCallHelpers::Address(base, JSCell::indexingTypeAndMiscOffset()), scratch);
      jit.and32(CCallHelpers::TrustedImm32(IndexingTypeMask), scratch);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,27 +306,33 @@</span>
      jit.loadPtr(CCallHelpers::Address(base, JSObject::butterflyOffset()), value.payloadGPR());
      jit.load32(CCallHelpers::Address(value.payloadGPR(), ArrayStorage::lengthOffset()), value.payloadGPR());
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;array length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  bool InlineAccess::isCacheableStringLength(StructureStubInfo&amp; stubInfo)
  {
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      return hasFreeRegister(stubInfo);
  }
  
  bool InlineAccess::generateStringLength(StructureStubInfo&amp; stubInfo)
  {
      ASSERT(isCacheableStringLength(stubInfo));
  
<span class="udiff-line-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
      CCallHelpers jit;
  
<span class="udiff-line-modified-removed">-     GPRReg base = stubInfo.baseGPR();</span>
<span class="udiff-line-modified-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
      GPRReg scratch = getScratchRegister(stubInfo);
  
      auto branchToSlowPath = jit.patchableBranch8(
          CCallHelpers::NotEqual,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,31 +349,34 @@</span>
  
      done.link(&amp;jit);
      jit.boxInt32(value.payloadGPR(), value);
  
      bool linkedCodeInline = linkCodeInline(&quot;string length&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  
  bool InlineAccess::generateSelfInAccess(StructureStubInfo&amp; stubInfo, Structure* structure)
  {
      CCallHelpers jit;
  
<span class="udiff-line-modified-removed">-     GPRReg base = stubInfo.baseGPR();</span>
<span class="udiff-line-modified-added">+     if (!stubInfo.hasConstantIdentifier)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     GPRReg base = stubInfo.baseGPR;</span>
      JSValueRegs value = stubInfo.valueRegs();
  
      auto branchToSlowPath = jit.patchableBranch32(
          MacroAssembler::NotEqual,
          MacroAssembler::Address(base, JSCell::structureIDOffset()),
          MacroAssembler::TrustedImm32(bitwise_cast&lt;uint32_t&gt;(structure-&gt;id())));
      jit.boxBoolean(true, value);
  
      bool linkedCodeInline = linkCodeInline(&quot;in access&quot;, jit, stubInfo, [&amp;] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation());</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(branchToSlowPath, stubInfo.slowPathStartLocation);</span>
      });
      return linkedCodeInline;
  }
  
  void InlineAccess::rewireStubAsJump(StructureStubInfo&amp; stubInfo, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; target)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -361,11 +385,11 @@</span>
  
      auto jump = jit.jump();
  
      // We don&#39;t need a nop sled here because nobody should be jumping into the middle of an IC.
      bool needsBranchCompaction = false;
<span class="udiff-line-modified-removed">-     LinkBuffer linkBuffer(jit, stubInfo.patch.start, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
<span class="udiff-line-modified-added">+     LinkBuffer linkBuffer(jit, stubInfo.start, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);</span>
      RELEASE_ASSERT(linkBuffer.isValid());
      linkBuffer.link(jump, target);
  
      FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;InlineAccess: linking constant jump&quot;);
  }
</pre>
<center><a href="InByIdVariant.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineCallFrame.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
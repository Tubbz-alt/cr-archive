<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/WorkerMessagePortChannelProvider.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WorkerMessagePortChannelProvider.h&quot;
 28 
 29 #include &quot;MessagePort.h&quot;
 30 #include &quot;WorkerGlobalScope.h&quot;
 31 #include &quot;WorkerThread.h&quot;
 32 #include &lt;wtf/MainThread.h&gt;
 33 #include &lt;wtf/RunLoop.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 WorkerMessagePortChannelProvider::WorkerMessagePortChannelProvider(WorkerGlobalScope&amp; scope)
 38     : m_scope(scope)
 39 {
 40 }
 41 
 42 WorkerMessagePortChannelProvider::~WorkerMessagePortChannelProvider()
 43 {
 44     while (!m_takeAllMessagesCallbacks.isEmpty()) {
 45         auto first = m_takeAllMessagesCallbacks.begin();
 46         first-&gt;value({ }, [] { });
 47         m_takeAllMessagesCallbacks.remove(first);
 48     }
 49     while (!m_activityCallbacks.isEmpty()) {
 50         auto first = m_activityCallbacks.begin();
 51         first-&gt;value(HasActivity::No);
 52         m_activityCallbacks.remove(first);
 53     }
 54 }
 55 
 56 void WorkerMessagePortChannelProvider::createNewMessagePortChannel(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 57 {
 58     callOnMainThread([local, remote] {
 59         MessagePortChannelProvider::singleton().createNewMessagePortChannel(local, remote);
 60     });
 61 }
 62 
 63 void WorkerMessagePortChannelProvider::entangleLocalPortInThisProcessToRemote(const MessagePortIdentifier&amp; local, const MessagePortIdentifier&amp; remote)
 64 {
 65     callOnMainThread([local, remote] {
 66         MessagePortChannelProvider::singleton().entangleLocalPortInThisProcessToRemote(local, remote);
 67     });
 68 }
 69 
 70 void WorkerMessagePortChannelProvider::messagePortDisentangled(const MessagePortIdentifier&amp; local)
 71 {
 72     callOnMainThread([local] {
 73         MessagePortChannelProvider::singleton().messagePortDisentangled(local);
 74     });
 75 }
 76 
 77 void WorkerMessagePortChannelProvider::messagePortClosed(const MessagePortIdentifier&amp;)
 78 {
 79     ASSERT_NOT_REACHED();
 80 }
 81 
 82 void WorkerMessagePortChannelProvider::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
 83 {
 84     callOnMainThread([message = WTFMove(message), remoteTarget]() mutable {
 85         MessagePortChannelProvider::singleton().postMessageToRemote(WTFMove(message), remoteTarget);
 86     });
 87 }
 88 
 89 void WorkerMessagePortChannelProvider::takeAllMessagesForPort(const MessagePortIdentifier&amp; identifier, CompletionHandler&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; callback)
 90 {
 91     uint64_t callbackIdentifier = ++m_lastCallbackIdentifier;
 92     m_takeAllMessagesCallbacks.add(callbackIdentifier, WTFMove(callback));
 93 
 94     callOnMainThread([this, workerThread = makeRef(m_scope.thread()), callbackIdentifier, identifier]() mutable {
 95         MessagePortChannelProvider::singleton().takeAllMessagesForPort(identifier, [this, workerThread = WTFMove(workerThread), callbackIdentifier](Vector&lt;MessageWithMessagePorts&gt;&amp;&amp; messages, Function&lt;void()&gt;&amp;&amp; completionHandler) {
 96             workerThread-&gt;runLoop().postTaskForMode([this, callbackIdentifier, messages = WTFMove(messages), completionHandler = WTFMove(completionHandler)](auto&amp; scope) mutable {
 97                 ASSERT_UNUSED(scope, this == &amp;downcast&lt;WorkerGlobalScope&gt;(scope).messagePortChannelProvider());
 98                 m_takeAllMessagesCallbacks.take(callbackIdentifier)(WTFMove(messages), [completionHandler = WTFMove(completionHandler)]() mutable {
 99                     callOnMainThread(WTFMove(completionHandler));
100                 });
101             }, WorkerRunLoop::defaultMode());
102         });
103     });
104 }
105 
106 void WorkerMessagePortChannelProvider::checkRemotePortForActivity(const MessagePortIdentifier&amp; remoteTarget, CompletionHandler&lt;void(HasActivity)&gt;&amp;&amp; callback)
107 {
108     uint64_t callbackIdentifier = ++m_lastCallbackIdentifier;
109     m_activityCallbacks.add(callbackIdentifier, WTFMove(callback));
110 
111     callOnMainThread([this, workerThread = makeRef(m_scope.thread()), callbackIdentifier, remoteTarget]() mutable {
112         MessagePortChannelProvider::singleton().checkRemotePortForActivity(remoteTarget, [this, workerThread = WTFMove(workerThread), callbackIdentifier](auto hasActivity) {
113             workerThread-&gt;runLoop().postTaskForMode([this, callbackIdentifier, hasActivity](auto&amp; scope) mutable {
114                 ASSERT_UNUSED(scope, this == &amp;downcast&lt;WorkerGlobalScope&gt;(scope).messagePortChannelProvider());
115                 m_activityCallbacks.take(callbackIdentifier)(hasActivity);
116             }, WorkerRunLoop::defaultMode());
117         });
118     });
119 }
120 
121 } // namespace WebCore
    </pre>
  </body>
</html>
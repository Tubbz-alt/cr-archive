<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/paymentrequest/PaymentRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PaymentRequest.h&quot;
 28 
 29 #if ENABLE(PAYMENT_REQUEST)
 30 
 31 #include &quot;ApplePayPaymentHandler.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;JSDOMPromise.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 36 #include &quot;JSPaymentDetailsUpdate.h&quot;
 37 #include &quot;JSPaymentResponse.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PaymentAddress.h&quot;
 40 #include &quot;PaymentCoordinator.h&quot;
 41 #include &quot;PaymentCurrencyAmount.h&quot;
 42 #include &quot;PaymentDetailsInit.h&quot;
 43 #include &quot;PaymentHandler.h&quot;
 44 #include &quot;PaymentMethodChangeEvent.h&quot;
 45 #include &quot;PaymentMethodData.h&quot;
 46 #include &quot;PaymentOptions.h&quot;
 47 #include &quot;PaymentRequestUpdateEvent.h&quot;
 48 #include &quot;PaymentValidationErrors.h&quot;
 49 #include &quot;ScriptController.h&quot;
 50 #include &lt;JavaScriptCore/JSONObject.h&gt;
 51 #include &lt;JavaScriptCore/ThrowScope.h&gt;
 52 #include &lt;wtf/ASCIICType.h&gt;
 53 #include &lt;wtf/IsoMallocInlines.h&gt;
 54 #include &lt;wtf/RunLoop.h&gt;
 55 #include &lt;wtf/Scope.h&gt;
 56 #include &lt;wtf/UUID.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 WTF_MAKE_ISO_ALLOCATED_IMPL(PaymentRequest);
 61 
 62 // Implements the IsWellFormedCurrencyCode abstract operation from ECMA 402
 63 // https://tc39.github.io/ecma402/#sec-iswellformedcurrencycode
 64 static bool isWellFormedCurrencyCode(const String&amp; currency)
 65 {
 66     if (currency.length() == 3)
 67         return currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;();
 68     return false;
 69 }
 70 
 71 // Implements the &quot;valid decimal monetary value&quot; validity checker
 72 // https://www.w3.org/TR/payment-request/#dfn-valid-decimal-monetary-value
 73 static bool isValidDecimalMonetaryValue(StringView value)
 74 {
 75     enum class State {
 76         Start,
 77         Sign,
 78         Digit,
 79         Dot,
 80         DotDigit,
 81     };
 82 
 83     auto state = State::Start;
 84     for (auto character : value.codeUnits()) {
 85         switch (state) {
 86         case State::Start:
 87             if (character == &#39;-&#39;) {
 88                 state = State::Sign;
 89                 break;
 90             }
 91 
 92             if (isASCIIDigit(character)) {
 93                 state = State::Digit;
 94                 break;
 95             }
 96 
 97             return false;
 98 
 99         case State::Sign:
100             if (isASCIIDigit(character)) {
101                 state = State::Digit;
102                 break;
103             }
104 
105             return false;
106 
107         case State::Digit:
108             if (character == &#39;.&#39;) {
109                 state = State::Dot;
110                 break;
111             }
112 
113             if (isASCIIDigit(character)) {
114                 state = State::Digit;
115                 break;
116             }
117 
118             return false;
119 
120         case State::Dot:
121             if (isASCIIDigit(character)) {
122                 state = State::DotDigit;
123                 break;
124             }
125 
126             return false;
127 
128         case State::DotDigit:
129             if (isASCIIDigit(character)) {
130                 state = State::DotDigit;
131                 break;
132             }
133 
134             return false;
135         }
136     }
137 
138     if (state == State::Digit || state == State::DotDigit)
139         return true;
140 
141     return false;
142 }
143 
144 // Implements the &quot;check and canonicalize amount&quot; validity checker
145 // https://www.w3.org/TR/payment-request/#dfn-check-and-canonicalize-amount
146 static ExceptionOr&lt;void&gt; checkAndCanonicalizeAmount(PaymentCurrencyAmount&amp; amount)
147 {
148     if (!isWellFormedCurrencyCode(amount.currency))
149         return Exception { RangeError, makeString(&quot;\&quot;&quot;, amount.currency, &quot;\&quot; is not a valid currency code.&quot;) };
150 
151     if (!isValidDecimalMonetaryValue(amount.value))
152         return Exception { TypeError, makeString(&quot;\&quot;&quot;, amount.value, &quot;\&quot; is not a valid decimal monetary value.&quot;) };
153 
154     amount.currency = amount.currency.convertToASCIIUppercase();
155     return { };
156 }
157 
158 // Implements the &quot;check and canonicalize total&quot; validity checker
159 // https://www.w3.org/TR/payment-request/#dfn-check-and-canonicalize-total
160 static ExceptionOr&lt;void&gt; checkAndCanonicalizeTotal(PaymentCurrencyAmount&amp; total)
161 {
162     auto exception = checkAndCanonicalizeAmount(total);
163     if (exception.hasException())
164         return exception;
165 
166     if (total.value[0] == &#39;-&#39;)
167         return Exception { TypeError, &quot;Total currency values cannot be negative.&quot;_s };
168 
169     return { };
170 }
171 
172 // Implements &quot;validate a standardized payment method identifier&quot;
173 // https://www.w3.org/TR/payment-method-id/#validity-0
174 static bool isValidStandardizedPaymentMethodIdentifier(StringView identifier)
175 {
176     enum class State {
177         Start,
178         Hyphen,
179         LowerAlpha,
180         Digit,
181     };
182 
183     auto state = State::Start;
184     for (auto character : identifier.codeUnits()) {
185         switch (state) {
186         case State::Start:
187         case State::Hyphen:
188             if (isASCIILower(character)) {
189                 state = State::LowerAlpha;
190                 break;
191             }
192 
193             return false;
194 
195         case State::LowerAlpha:
196         case State::Digit:
197             if (isASCIILower(character)) {
198                 state = State::LowerAlpha;
199                 break;
200             }
201 
202             if (isASCIIDigit(character)) {
203                 state = State::Digit;
204                 break;
205             }
206 
207             if (character == &#39;-&#39;) {
208                 state = State::Hyphen;
209                 break;
210             }
211 
212             return false;
213         }
214     }
215 
216     return state == State::LowerAlpha || state == State::Digit;
217 }
218 
219 // Implements &quot;validate a URL-based payment method identifier&quot;
220 // https://www.w3.org/TR/payment-method-id/#validation
221 static bool isValidURLBasedPaymentMethodIdentifier(const URL&amp; url)
222 {
223     if (!url.protocolIs(&quot;https&quot;))
224         return false;
225 
226     if (!url.user().isEmpty() || !url.pass().isEmpty())
227         return false;
228 
229     return true;
230 }
231 
232 // Implements &quot;validate a payment method identifier&quot;
233 // https://www.w3.org/TR/payment-method-id/#validity
234 Optional&lt;PaymentRequest::MethodIdentifier&gt; convertAndValidatePaymentMethodIdentifier(const String&amp; identifier)
235 {
236     URL url { URL(), identifier };
237     if (!url.isValid()) {
238         if (isValidStandardizedPaymentMethodIdentifier(identifier))
239             return { identifier };
240         return WTF::nullopt;
241     }
242 
243     if (isValidURLBasedPaymentMethodIdentifier(url))
244         return { WTFMove(url) };
245 
246     return WTF::nullopt;
247 }
248 
249 enum class ShouldValidatePaymentMethodIdentifier {
250     No,
251     Yes,
252 };
253 
<a name="2" id="anc2"></a><span class="line-modified">254 static ExceptionOr&lt;std::tuple&lt;String, Vector&lt;String&gt;&gt;&gt; checkAndCanonicalizeDetails(JSC::JSGlobalObject&amp; execState, PaymentDetailsBase&amp; details, bool requestShipping, ShouldValidatePaymentMethodIdentifier shouldValidatePaymentMethodIdentifier)</span>
255 {
256     for (auto&amp; item : details.displayItems) {
257         auto exception = checkAndCanonicalizeAmount(item.amount);
258         if (exception.hasException())
259             return exception.releaseException();
260     }
261 
262     String selectedShippingOption;
263     if (requestShipping) {
264         HashSet&lt;String&gt; seenShippingOptionIDs;
265         for (auto&amp; shippingOption : details.shippingOptions) {
266             auto exception = checkAndCanonicalizeAmount(shippingOption.amount);
267             if (exception.hasException())
268                 return exception.releaseException();
269 
270             auto addResult = seenShippingOptionIDs.add(shippingOption.id);
271             if (!addResult.isNewEntry)
272                 return Exception { TypeError, &quot;Shipping option IDs must be unique.&quot; };
273 
274             if (shippingOption.selected)
275                 selectedShippingOption = shippingOption.id;
276         }
277     }
278 
279     Vector&lt;String&gt; serializedModifierData;
280     serializedModifierData.reserveInitialCapacity(details.modifiers.size());
281     for (auto&amp; modifier : details.modifiers) {
282         if (shouldValidatePaymentMethodIdentifier == ShouldValidatePaymentMethodIdentifier::Yes) {
283             auto paymentMethodIdentifier = convertAndValidatePaymentMethodIdentifier(modifier.supportedMethods);
284             if (!paymentMethodIdentifier)
285                 return Exception { RangeError, makeString(&#39;&quot;&#39;, modifier.supportedMethods, &quot;\&quot; is an invalid payment method identifier.&quot;) };
286         }
287 
288         if (modifier.total) {
289             auto exception = checkAndCanonicalizeTotal(modifier.total-&gt;amount);
290             if (exception.hasException())
291                 return exception.releaseException();
292         }
293 
294         for (auto&amp; item : modifier.additionalDisplayItems) {
295             auto exception = checkAndCanonicalizeAmount(item.amount);
296             if (exception.hasException())
297                 return exception.releaseException();
298         }
299 
300         String serializedData;
301         if (modifier.data) {
302             auto scope = DECLARE_THROW_SCOPE(execState.vm());
303             serializedData = JSONStringify(&amp;execState, modifier.data.get(), 0);
304             if (scope.exception())
305                 return Exception { ExistingExceptionError };
306             modifier.data.clear();
307         }
308         serializedModifierData.uncheckedAppend(WTFMove(serializedData));
309     }
310 
311     return std::make_tuple(WTFMove(selectedShippingOption), WTFMove(serializedModifierData));
312 }
313 
<a name="3" id="anc3"></a><span class="line-added">314 static ExceptionOr&lt;JSC::JSValue&gt; parse(ScriptExecutionContext&amp; context, const String&amp; string)</span>
<span class="line-added">315 {</span>
<span class="line-added">316     auto scope = DECLARE_THROW_SCOPE(context.vm());</span>
<span class="line-added">317     JSC::JSValue data = JSONParse(context.execState(), string);</span>
<span class="line-added">318     if (scope.exception())</span>
<span class="line-added">319         return Exception { ExistingExceptionError };</span>
<span class="line-added">320     return data;</span>
<span class="line-added">321 }</span>
<span class="line-added">322 </span>
323 // Implements the PaymentRequest Constructor
324 // https://www.w3.org/TR/payment-request/#constructor
325 ExceptionOr&lt;Ref&lt;PaymentRequest&gt;&gt; PaymentRequest::create(Document&amp; document, Vector&lt;PaymentMethodData&gt;&amp;&amp; methodData, PaymentDetailsInit&amp;&amp; details, PaymentOptions&amp;&amp; options)
326 {
327     auto canCreateSession = PaymentHandler::canCreateSession(document);
328     if (canCreateSession.hasException())
329         return canCreateSession.releaseException();
330 
331     if (details.id.isNull())
332         details.id = createCanonicalUUIDString();
333 
334     if (methodData.isEmpty())
335         return Exception { TypeError, &quot;At least one payment method is required.&quot;_s };
336 
337     Vector&lt;Method&gt; serializedMethodData;
338     serializedMethodData.reserveInitialCapacity(methodData.size());
339     for (auto&amp; paymentMethod : methodData) {
340         auto identifier = convertAndValidatePaymentMethodIdentifier(paymentMethod.supportedMethods);
341         if (!identifier)
342             return Exception { RangeError, makeString(&#39;&quot;&#39;, paymentMethod.supportedMethods, &quot;\&quot; is an invalid payment method identifier.&quot;) };
343 
344         String serializedData;
345         if (paymentMethod.data) {
346             auto scope = DECLARE_THROW_SCOPE(document.execState()-&gt;vm());
347             serializedData = JSONStringify(document.execState(), paymentMethod.data.get(), 0);
348             if (scope.exception())
349                 return Exception { ExistingExceptionError };
<a name="4" id="anc4"></a><span class="line-added">350 </span>
<span class="line-added">351             auto parsedDataOrException = parse(document, serializedData);</span>
<span class="line-added">352             if (parsedDataOrException.hasException())</span>
<span class="line-added">353                 return parsedDataOrException.releaseException();</span>
<span class="line-added">354 </span>
<span class="line-added">355             auto exception = PaymentHandler::validateData(document, parsedDataOrException.releaseReturnValue(), *identifier);</span>
<span class="line-added">356             if (exception.hasException())</span>
<span class="line-added">357                 return exception.releaseException();</span>
358         }
359         serializedMethodData.uncheckedAppend({ WTFMove(*identifier), WTFMove(serializedData) });
360     }
361 
362     auto totalResult = checkAndCanonicalizeTotal(details.total.amount);
363     if (totalResult.hasException())
364         return totalResult.releaseException();
365 
366     auto detailsResult = checkAndCanonicalizeDetails(*document.execState(), details, options.requestShipping, ShouldValidatePaymentMethodIdentifier::No);
367     if (detailsResult.hasException())
368         return detailsResult.releaseException();
369 
370     auto shippingOptionAndModifierData = detailsResult.releaseReturnValue();
371     return adoptRef(*new PaymentRequest(document, WTFMove(options), WTFMove(details), WTFMove(std::get&lt;1&gt;(shippingOptionAndModifierData)), WTFMove(serializedMethodData), WTFMove(std::get&lt;0&gt;(shippingOptionAndModifierData))));
372 }
373 
374 bool PaymentRequest::enabledForContext(ScriptExecutionContext&amp; context)
375 {
376     return PaymentHandler::enabledForContext(context);
377 }
378 
379 PaymentRequest::PaymentRequest(Document&amp; document, PaymentOptions&amp;&amp; options, PaymentDetailsInit&amp;&amp; details, Vector&lt;String&gt;&amp;&amp; serializedModifierData, Vector&lt;Method&gt;&amp;&amp; serializedMethodData, String&amp;&amp; selectedShippingOption)
380     : ActiveDOMObject { document }
381     , m_options { WTFMove(options) }
382     , m_details { WTFMove(details) }
383     , m_serializedModifierData { WTFMove(serializedModifierData) }
384     , m_serializedMethodData { WTFMove(serializedMethodData) }
385     , m_shippingOption { WTFMove(selectedShippingOption) }
386 {
387     suspendIfNeeded();
388 }
389 
390 PaymentRequest::~PaymentRequest()
391 {
392     ASSERT(!hasPendingActivity());
393     ASSERT(!m_activePaymentHandler);
394 }
395 
<a name="5" id="anc5"></a>








396 // https://www.w3.org/TR/payment-request/#show()-method
397 void PaymentRequest::show(Document&amp; document, RefPtr&lt;DOMPromise&gt;&amp;&amp; detailsPromise, ShowPromise&amp;&amp; promise)
398 {
399     if (!document.frame()) {
400         promise.reject(Exception { AbortError });
401         return;
402     }
403 
404     if (!UserGestureIndicator::processingUserGesture()) {
405         promise.reject(Exception { SecurityError, &quot;show() must be triggered by user activation.&quot; });
406         return;
407     }
408 
409     if (m_state != State::Created) {
410         promise.reject(Exception { InvalidStateError });
411         return;
412     }
413 
414     if (PaymentHandler::hasActiveSession(document)) {
415         promise.reject(Exception { AbortError });
416         m_state = State::Closed;
417         return;
418     }
419 
420     m_state = State::Interactive;
421     ASSERT(!m_showPromise);
<a name="6" id="anc6"></a><span class="line-modified">422     m_showPromise = WTF::makeUnique&lt;ShowPromise&gt;(WTFMove(promise));</span>
423 
424     RefPtr&lt;PaymentHandler&gt; selectedPaymentHandler;
425     for (auto&amp; paymentMethod : m_serializedMethodData) {
426         auto data = parse(document, paymentMethod.serializedData);
427         if (data.hasException()) {
428             settleShowPromise(data.releaseException());
429             return;
430         }
431 
432         auto handler = PaymentHandler::create(document, *this, paymentMethod.identifier);
433         if (!handler)
434             continue;
435 
436         auto result = handler-&gt;convertData(data.releaseReturnValue());
437         if (result.hasException()) {
438             settleShowPromise(result.releaseException());
439             return;
440         }
441 
442         if (!selectedPaymentHandler)
443             selectedPaymentHandler = WTFMove(handler);
444     }
445 
446     if (!selectedPaymentHandler) {
447         settleShowPromise(Exception { NotSupportedError });
448         return;
449     }
450 
451     auto exception = selectedPaymentHandler-&gt;show(document);
452     if (exception.hasException()) {
453         settleShowPromise(exception.releaseException());
454         return;
455     }
456 
457     ASSERT(!m_activePaymentHandler);
458     m_activePaymentHandler = PaymentHandlerWithPendingActivity { selectedPaymentHandler.releaseNonNull(), makePendingActivity(*this) };
459 
460     if (!detailsPromise)
461         return;
462 
463     exception = updateWith(UpdateReason::ShowDetailsResolved, detailsPromise.releaseNonNull());
464     ASSERT(!exception.hasException());
465 }
466 
467 void PaymentRequest::abortWithException(Exception&amp;&amp; exception)
468 {
469     ASSERT(m_state == State::Interactive);
470     closeActivePaymentHandler();
471 
472     if (m_response)
473         m_response-&gt;abortWithException(WTFMove(exception));
474     else
475         settleShowPromise(WTFMove(exception));
476 }
477 
478 void PaymentRequest::settleShowPromise(ExceptionOr&lt;PaymentResponse&amp;&gt;&amp;&amp; result)
479 {
<a name="7" id="anc7"></a><span class="line-modified">480     if (auto showPromise = std::exchange(m_showPromise, nullptr))</span>
481         showPromise-&gt;settle(WTFMove(result));
482 }
483 
484 void PaymentRequest::closeActivePaymentHandler()
485 {
486     if (auto activePaymentHandler = std::exchange(m_activePaymentHandler, WTF::nullopt))
487         activePaymentHandler-&gt;paymentHandler-&gt;hide();
488 
489     m_isUpdating = false;
490     m_state = State::Closed;
491 }
492 
493 void PaymentRequest::stop()
494 {
495     closeActivePaymentHandler();
496     settleShowPromise(Exception { AbortError });
497 }
498 
<a name="8" id="anc8"></a><span class="line-added">499 void PaymentRequest::suspend(ReasonForSuspension reason)</span>
<span class="line-added">500 {</span>
<span class="line-added">501     if (reason != ReasonForSuspension::BackForwardCache)</span>
<span class="line-added">502         return;</span>
<span class="line-added">503 </span>
<span class="line-added">504     if (!m_activePaymentHandler) {</span>
<span class="line-added">505         ASSERT(!m_showPromise);</span>
<span class="line-added">506         ASSERT(m_state != State::Interactive);</span>
<span class="line-added">507         return;</span>
<span class="line-added">508     }</span>
<span class="line-added">509 </span>
<span class="line-added">510     stop();</span>
<span class="line-added">511 }</span>
<span class="line-added">512 </span>
513 // https://www.w3.org/TR/payment-request/#abort()-method
514 void PaymentRequest::abort(AbortPromise&amp;&amp; promise)
515 {
516     if (m_response &amp;&amp; m_response-&gt;hasRetryPromise()) {
517         promise.reject(Exception { InvalidStateError });
518         return;
519     }
520 
521     if (m_state != State::Interactive) {
522         promise.reject(Exception { InvalidStateError });
523         return;
524     }
525 
526     abortWithException(Exception { AbortError });
527     promise.resolve();
528 }
529 
530 // https://www.w3.org/TR/payment-request/#canmakepayment()-method
531 void PaymentRequest::canMakePayment(Document&amp; document, CanMakePaymentPromise&amp;&amp; promise)
532 {
533     if (m_state != State::Created) {
534         promise.reject(Exception { InvalidStateError });
535         return;
536     }
537 
538     for (auto&amp; paymentMethod : m_serializedMethodData) {
539         auto handler = PaymentHandler::create(document, *this, paymentMethod.identifier);
540         if (!handler)
541             continue;
542 
543         handler-&gt;canMakePayment(document, [promise = WTFMove(promise)](bool canMakePayment) mutable {
544             promise.resolve(canMakePayment);
545         });
546         return;
547     }
548 
549     promise.resolve(false);
550 }
551 
552 const String&amp; PaymentRequest::id() const
553 {
554     return m_details.id;
555 }
556 
557 Optional&lt;PaymentShippingType&gt; PaymentRequest::shippingType() const
558 {
559     if (m_options.requestShipping)
560         return m_options.shippingType;
561     return WTF::nullopt;
562 }
563 
<a name="9" id="anc9"></a>




564 void PaymentRequest::shippingAddressChanged(Ref&lt;PaymentAddress&gt;&amp;&amp; shippingAddress)
565 {
566     whenDetailsSettled([this, protectedThis = makeRefPtr(this), shippingAddress = makeRefPtr(shippingAddress.get())]() mutable {
567         m_shippingAddress = WTFMove(shippingAddress);
568         dispatchEvent(PaymentRequestUpdateEvent::create(eventNames().shippingaddresschangeEvent));
569     });
570 }
571 
572 void PaymentRequest::shippingOptionChanged(const String&amp; shippingOption)
573 {
574     whenDetailsSettled([this, protectedThis = makeRefPtr(this), shippingOption]() mutable {
575         m_shippingOption = shippingOption;
576         dispatchEvent(PaymentRequestUpdateEvent::create(eventNames().shippingoptionchangeEvent));
577     });
578 }
579 
580 void PaymentRequest::paymentMethodChanged(const String&amp; methodName, PaymentMethodChangeEvent::MethodDetailsFunction&amp;&amp; methodDetailsFunction)
581 {
582     whenDetailsSettled([this, protectedThis = makeRefPtr(this), methodName, methodDetailsFunction = WTFMove(methodDetailsFunction)]() mutable {
583         auto&amp; eventName = eventNames().paymentmethodchangeEvent;
584         if (hasEventListeners(eventName))
585             dispatchEvent(PaymentMethodChangeEvent::create(eventName, methodName, WTFMove(methodDetailsFunction)));
586         else
587             activePaymentHandler()-&gt;detailsUpdated(UpdateReason::PaymentMethodChanged, { }, { }, { }, { });
588     });
589 }
590 
591 ExceptionOr&lt;void&gt; PaymentRequest::updateWith(UpdateReason reason, Ref&lt;DOMPromise&gt;&amp;&amp; promise)
592 {
593     if (m_state != State::Interactive)
594         return Exception { InvalidStateError };
595 
596     if (m_isUpdating)
597         return Exception { InvalidStateError };
598 
599     m_isUpdating = true;
600 
601     ASSERT(!m_detailsPromise);
602     m_detailsPromise = WTFMove(promise);
603     m_detailsPromise-&gt;whenSettled([this, protectedThis = makeRefPtr(this), reason]() {
604         settleDetailsPromise(reason);
605     });
606 
607     return { };
608 }
609 
610 ExceptionOr&lt;void&gt; PaymentRequest::completeMerchantValidation(Event&amp; event, Ref&lt;DOMPromise&gt;&amp;&amp; merchantSessionPromise)
611 {
612     if (m_state != State::Interactive)
613         return Exception { InvalidStateError };
614 
615     event.stopPropagation();
616     event.stopImmediatePropagation();
617 
618     m_merchantSessionPromise = WTFMove(merchantSessionPromise);
619     m_merchantSessionPromise-&gt;whenSettled([this, protectedThis = makeRefPtr(this)]() {
620         if (m_state != State::Interactive)
621             return;
622 
623         if (m_merchantSessionPromise-&gt;status() == DOMPromise::Status::Rejected) {
624             abortWithException(Exception { AbortError });
625             return;
626         }
627 
628         auto exception = activePaymentHandler()-&gt;merchantValidationCompleted(m_merchantSessionPromise-&gt;result());
629         if (exception.hasException()) {
630             abortWithException(exception.releaseException());
631             return;
632         }
633     });
634 
635     return { };
636 }
637 
638 void PaymentRequest::settleDetailsPromise(UpdateReason reason)
639 {
640     auto scopeExit = makeScopeExit([&amp;] {
641         m_isUpdating = false;
642         m_isCancelPending = false;
643         m_detailsPromise = nullptr;
644     });
645 
646     if (m_state != State::Interactive)
647         return;
648 
649     if (m_isCancelPending || m_detailsPromise-&gt;status() == DOMPromise::Status::Rejected) {
650         abortWithException(Exception { AbortError });
651         return;
652     }
653 
654     auto&amp; context = *m_detailsPromise-&gt;scriptExecutionContext();
655     auto throwScope = DECLARE_THROW_SCOPE(context.vm());
656     auto detailsUpdate = convertDictionary&lt;PaymentDetailsUpdate&gt;(*context.execState(), m_detailsPromise-&gt;result());
657     if (throwScope.exception()) {
658         abortWithException(Exception { ExistingExceptionError });
659         return;
660     }
661 
662     auto totalResult = checkAndCanonicalizeTotal(detailsUpdate.total.amount);
663     if (totalResult.hasException()) {
664         abortWithException(totalResult.releaseException());
665         return;
666     }
667 
668     auto detailsResult = checkAndCanonicalizeDetails(*context.execState(), detailsUpdate, m_options.requestShipping, ShouldValidatePaymentMethodIdentifier::Yes);
669     if (detailsResult.hasException()) {
670         abortWithException(detailsResult.releaseException());
671         return;
672     }
673 
674     auto shippingOptionAndModifierData = detailsResult.releaseReturnValue();
675 
676     m_details.total = WTFMove(detailsUpdate.total);
677     m_details.displayItems = WTFMove(detailsUpdate.displayItems);
678     if (m_options.requestShipping) {
679         m_details.shippingOptions = WTFMove(detailsUpdate.shippingOptions);
680         m_shippingOption = WTFMove(std::get&lt;0&gt;(shippingOptionAndModifierData));
681     }
682 
683     m_details.modifiers = WTFMove(detailsUpdate.modifiers);
684     m_serializedModifierData = WTFMove(std::get&lt;1&gt;(shippingOptionAndModifierData));
685 
686     auto result = activePaymentHandler()-&gt;detailsUpdated(reason, WTFMove(detailsUpdate.error), WTFMove(detailsUpdate.shippingAddressErrors), WTFMove(detailsUpdate.payerErrors), detailsUpdate.paymentMethodErrors.get());
687     if (result.hasException()) {
688         abortWithException(result.releaseException());
689         return;
690     }
691 }
692 
693 void PaymentRequest::whenDetailsSettled(std::function&lt;void()&gt;&amp;&amp; callback)
694 {
695     auto whenSettledFunction = [this, callback = WTFMove(callback)] {
696         ASSERT(m_state == State::Interactive);
697         ASSERT(!m_isUpdating);
698         ASSERT(!m_isCancelPending);
699         ASSERT_UNUSED(this, this);
700         callback();
701     };
702 
703     if (!m_detailsPromise) {
704         whenSettledFunction();
705         return;
706     }
707 
708     m_detailsPromise-&gt;whenSettled([this, protectedThis = makeRefPtr(this), whenSettledFunction = WTFMove(whenSettledFunction)] {
709         if (m_state == State::Interactive)
710             whenSettledFunction();
711     });
712 }
713 
714 void PaymentRequest::accept(const String&amp; methodName, PaymentResponse::DetailsFunction&amp;&amp; detailsFunction, Ref&lt;PaymentAddress&gt;&amp;&amp; shippingAddress, const String&amp; payerName, const String&amp; payerEmail, const String&amp; payerPhone)
715 {
716     ASSERT(!m_isUpdating);
717     ASSERT(m_state == State::Interactive);
718 
719     bool isRetry = m_response;
720     if (!isRetry) {
721         m_response = PaymentResponse::create(scriptExecutionContext(), *this);
722         m_response-&gt;setRequestId(m_details.id);
723     }
724 
725     m_response-&gt;setMethodName(methodName);
726     m_response-&gt;setDetailsFunction(WTFMove(detailsFunction));
727     m_response-&gt;setShippingAddress(m_options.requestShipping ? shippingAddress.ptr() : nullptr);
728     m_response-&gt;setShippingOption(m_options.requestShipping ? m_shippingOption : String { });
729     m_response-&gt;setPayerName(m_options.requestPayerName ? payerName : String { });
730     m_response-&gt;setPayerEmail(m_options.requestPayerEmail ? payerEmail : String { });
731     m_response-&gt;setPayerPhone(m_options.requestPayerPhone ? payerPhone : String { });
732 
733     if (!isRetry)
734         settleShowPromise(*m_response);
735     else {
736         ASSERT(m_response-&gt;hasRetryPromise());
737         m_response-&gt;settleRetryPromise();
738     }
739 
740     m_state = State::Closed;
741 }
742 
743 ExceptionOr&lt;void&gt; PaymentRequest::complete(Optional&lt;PaymentComplete&gt;&amp;&amp; result)
744 {
745     ASSERT(m_state == State::Closed);
746     if (!m_activePaymentHandler)
747         return Exception { AbortError };
748 
749     activePaymentHandler()-&gt;complete(WTFMove(result));
750     m_activePaymentHandler = WTF::nullopt;
751     return { };
752 }
753 
754 ExceptionOr&lt;void&gt; PaymentRequest::retry(PaymentValidationErrors&amp;&amp; errors)
755 {
756     ASSERT(m_state == State::Closed);
757     if (!m_activePaymentHandler)
758         return Exception { AbortError };
759 
760     m_state = State::Interactive;
761     return activePaymentHandler()-&gt;retry(WTFMove(errors));
762 }
763 
764 void PaymentRequest::cancel()
765 {
766     m_activePaymentHandler = WTF::nullopt;
767 
768     if (m_isUpdating) {
769         m_isCancelPending = true;
770         return;
771     }
772 
773     abortWithException(Exception { AbortError });
774 }
775 
776 } // namespace WebCore
777 
778 #endif // ENABLE(PAYMENT_REQUEST)
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
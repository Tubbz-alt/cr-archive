<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBRequestCompletionEvent.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBTransaction.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -76,18 +76,16 @@</span>
  
  IDBTransaction::IDBTransaction(IDBDatabase&amp; database, const IDBTransactionInfo&amp; info, IDBOpenDBRequest* request)
      : IDBActiveDOMObject(database.scriptExecutionContext())
      , m_database(database)
      , m_info(info)
<span class="udiff-line-removed">-     , m_pendingOperationTimer(*this, &amp;IDBTransaction::pendingOperationTimerFired)</span>
<span class="udiff-line-removed">-     , m_completedOperationTimer(*this, &amp;IDBTransaction::completedOperationTimerFired)</span>
      , m_openDBRequest(request)
      , m_currentlyCompletingRequest(request)
  
  {
      LOG(IndexedDB, &quot;IDBTransaction::IDBTransaction - %s&quot;, m_info.loggingString().utf8().data());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ++numberOfIDBTransactions;
  
      if (m_info.mode() == IDBTransactionMode::Versionchange) {
          ASSERT(m_openDBRequest);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -111,21 +109,21 @@</span>
  }
  
  IDBTransaction::~IDBTransaction()
  {
      --numberOfIDBTransactions;
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  }
  
  IDBClient::IDBConnectionProxy&amp; IDBTransaction::connectionProxy()
  {
      return m_database-&gt;connectionProxy();
  }
  
  Ref&lt;DOMStringList&gt; IDBTransaction::objectStoreNames() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      const Vector&lt;String&gt; names = isVersionChange() ? m_database-&gt;info().objectStoreNames() : m_info.objectStores();
  
      Ref&lt;DOMStringList&gt; objectStoreNames = DOMStringList::create();
      for (auto&amp; name : names)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -135,24 +133,24 @@</span>
      return objectStoreNames;
  }
  
  IDBDatabase* IDBTransaction::db()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      return m_database.ptr();
  }
  
  DOMException* IDBTransaction::error() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      return m_domError.get();
  }
  
  ExceptionOr&lt;Ref&lt;IDBObjectStore&gt;&gt; IDBTransaction::objectStore(const String&amp; objectStoreName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::objectStore&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (!scriptExecutionContext())
          return Exception { InvalidStateError };
  
      if (isFinishedOrFinishing())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -188,32 +186,32 @@</span>
  
  
  void IDBTransaction::abortDueToFailedRequest(DOMException&amp; error)
  {
      LOG(IndexedDB, &quot;IDBTransaction::abortDueToFailedRequest&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (isFinishedOrFinishing())
          return;
  
      m_domError = &amp;error;
      internalAbort();
  }
  
  void IDBTransaction::transitionedToFinishing(IndexedDB::TransactionState state)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT(!isFinishedOrFinishing());
      m_state = state;
      ASSERT(isFinishedOrFinishing());
  }
  
  ExceptionOr&lt;void&gt; IDBTransaction::abort()
  {
      LOG(IndexedDB, &quot;IDBTransaction::abort&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (isFinishedOrFinishing())
          return Exception { InvalidStateError, &quot;Failed to execute &#39;abort&#39; on &#39;IDBTransaction&#39;: The transaction is inactive or finished.&quot;_s };
  
      internalAbort();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,11 +220,11 @@</span>
  }
  
  void IDBTransaction::internalAbort()
  {
      LOG(IndexedDB, &quot;IDBTransaction::internalAbort&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(!isFinishedOrFinishing());
  
      m_database-&gt;willAbortTransaction(*this);
  
      if (isVersionChange()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -272,27 +270,20 @@</span>
          m_transactionOperationsInProgressQueue.append(operation.get());
          m_currentlyCompletingRequest = nullptr;
          operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
      }
  
<span class="udiff-line-modified-removed">-     Vector&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; completedOnServerAbortVector;</span>
<span class="udiff-line-removed">-     completedOnServerAbortVector.reserveInitialCapacity(m_completedOnServerQueue.size());</span>
<span class="udiff-line-removed">-     while (!m_completedOnServerQueue.isEmpty())</span>
<span class="udiff-line-removed">-         completedOnServerAbortVector.uncheckedAppend(m_completedOnServerQueue.takeFirst().first);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (auto&amp; operation : completedOnServerAbortVector) {</span>
<span class="udiff-line-removed">-         m_currentlyCompletingRequest = nullptr;</span>
<span class="udiff-line-removed">-         operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     m_transactionOperationResultMap.clear();</span>
  
<span class="udiff-line-added">+     m_currentlyCompletingRequest = nullptr;</span>
      connectionProxy().forgetActiveOperations(inProgressAbortVector);
  }
  
  void IDBTransaction::abortOnServerAndCancelRequests(IDBClient::TransactionOperation&amp; operation)
  {
      LOG(IndexedDB, &quot;IDBTransaction::abortOnServerAndCancelRequests&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(m_pendingTransactionOperationQueue.isEmpty());
  
      m_database-&gt;connectionProxy().abortTransaction(*this);
  
      ASSERT(m_transactionOperationMap.contains(operation.identifier()));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -311,36 +302,31 @@</span>
          operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
          m_currentlyCompletingRequest = nullptr;
      }
  
      m_abortQueue.clear();
<span class="udiff-line-added">+     m_openRequests.clear();</span>
      // Since we&#39;re aborting, it should be impossible to have queued any further operations.
      ASSERT(m_pendingTransactionOperationQueue.isEmpty());
  }
  
  const char* IDBTransaction::activeDOMObjectName() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      return &quot;IDBTransaction&quot;;
  }
  
<span class="udiff-line-removed">- bool IDBTransaction::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool IDBTransaction::hasPendingActivity() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()) || Thread::mayBeGCThread());</span>
      return !m_contextStopped &amp;&amp; m_state != IndexedDB::TransactionState::Finished;
  }
  
  void IDBTransaction::stop()
  {
      LOG(IndexedDB, &quot;IDBTransaction::stop - %s&quot;, m_info.loggingString().utf8().data());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      // IDBDatabase::stop() calls IDBTransaction::stop() for each of its active transactions.
      // Since the order of calling ActiveDOMObject::stop() is random, we might already have been stopped.
      if (m_contextStopped)
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -358,122 +344,81 @@</span>
      internalAbort();
  }
  
  bool IDBTransaction::isActive() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      return m_state == IndexedDB::TransactionState::Active;
  }
  
  bool IDBTransaction::isFinishedOrFinishing() const
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      return m_state == IndexedDB::TransactionState::Committing
          || m_state == IndexedDB::TransactionState::Aborting
          || m_state == IndexedDB::TransactionState::Finished;
  }
  
  void IDBTransaction::addRequest(IDBRequest&amp; request)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      m_openRequests.add(&amp;request);
  }
  
  void IDBTransaction::removeRequest(IDBRequest&amp; request)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-added">+     if (m_currentlyCompletingRequest == &amp;request)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
      m_openRequests.remove(&amp;request);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     autoCommit();</span>
  }
  
<span class="udiff-line-modified-removed">- void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation)</span>
<span class="udiff-line-modified-added">+ void IDBTransaction::scheduleOperation(Ref&lt;IDBClient::TransactionOperation&gt;&amp;&amp; operation, IsWriteOperation isWriteOperation)</span>
  {
      ASSERT(!m_transactionOperationMap.contains(operation-&gt;identifier()));
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (isWriteOperation == IsWriteOperation::Yes)</span>
<span class="udiff-line-added">+         m_lastWriteOperationID = operation-&gt;operationID();</span>
  
      auto identifier = operation-&gt;identifier();
      m_pendingTransactionOperationQueue.append(operation.copyRef());
      m_transactionOperationMap.set(identifier, WTFMove(operation));
  
<span class="udiff-line-modified-removed">-     schedulePendingOperationTimer();</span>
<span class="udiff-line-modified-added">+     handlePendingOperations();</span>
  }
  
<span class="udiff-line-modified-removed">- void IDBTransaction::schedulePendingOperationTimer()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!m_pendingOperationTimer.isActive())</span>
<span class="udiff-line-removed">-         m_pendingOperationTimer.startOneShot(0_s);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void IDBTransaction::pendingOperationTimerFired()</span>
<span class="udiff-line-modified-added">+ void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)</span>
  {
<span class="udiff-line-modified-removed">-     LOG(IndexedDB, &quot;IDBTransaction::pendingOperationTimerFired (%p)&quot;, this);</span>
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!m_startedOnServer)</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>
  
<span class="udiff-line-modified-removed">-     // If the last in-progress operation we&#39;ve sent to the server is not an IDBRequest operation,</span>
<span class="udiff-line-removed">-     // then we have to wait until it completes before sending any more.</span>
<span class="udiff-line-removed">-     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())</span>
<span class="udiff-line-modified-added">+     if (!m_transactionOperationMap.contains(operation.identifier()))</span>
          return;
  
<span class="udiff-line-modified-removed">-     // We want to batch operations together without spinning the runloop for performance,</span>
<span class="udiff-line-removed">-     // but don&#39;t want to affect responsiveness of the main thread.</span>
<span class="udiff-line-removed">-     // This number is a good compromise in ad-hoc testing.</span>
<span class="udiff-line-removed">-     static const size_t operationBatchLimit = 128;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     for (size_t iterations = 0; !m_pendingTransactionOperationQueue.isEmpty() &amp;&amp; iterations &lt; operationBatchLimit; ++iterations) {</span>
<span class="udiff-line-removed">-         auto operation = m_pendingTransactionOperationQueue.takeFirst();</span>
<span class="udiff-line-removed">-         m_transactionOperationsInProgressQueue.append(operation.get());</span>
<span class="udiff-line-removed">-         operation-&gt;perform();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         if (!operation-&gt;nextRequestCanGoToServer())</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!m_transactionOperationMap.isEmpty() || !m_openRequests.isEmpty())</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!isFinishedOrFinishing())</span>
<span class="udiff-line-removed">-         commit();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void IDBTransaction::operationCompletedOnServer(const IDBResultData&amp; data, IDBClient::TransactionOperation&amp; operation)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">-     ASSERT(&amp;operation.originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_completedOnServerQueue.append({ &amp;operation, data });</span>
<span class="udiff-line-modified-added">+     m_transactionOperationResultMap.set(&amp;operation, IDBResultData(data));</span>
  
      if (!m_currentlyCompletingRequest)
<span class="udiff-line-modified-removed">-         scheduleCompletedOperationTimer();</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void IDBTransaction::scheduleCompletedOperationTimer()</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!m_completedOperationTimer.isActive())</span>
<span class="udiff-line-removed">-         m_completedOperationTimer.startOneShot(0_s);</span>
<span class="udiff-line-modified-added">+         handleOperationsCompletedOnServer();</span>
  }
  
<span class="udiff-line-modified-removed">- void IDBTransaction::completedOperationTimerFired()</span>
<span class="udiff-line-modified-added">+ void IDBTransaction::handleOperationsCompletedOnServer()</span>
  {
<span class="udiff-line-modified-removed">-     LOG(IndexedDB, &quot;IDBTransaction::completedOperationTimerFired (%p)&quot;, this);</span>
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (m_completedOnServerQueue.isEmpty() || m_currentlyCompletingRequest)</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-modified-added">+     LOG(IndexedDB, &quot;IDBTransaction::handleOperationsCompletedOnServer&quot;);</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
<span class="udiff-line-modified-removed">-     auto iterator = m_completedOnServerQueue.takeFirst();</span>
<span class="udiff-line-modified-removed">-     iterator.first-&gt;doComplete(iterator.second);</span>
<span class="udiff-line-modified-added">+     while (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest) {</span>
<span class="udiff-line-modified-added">+         RefPtr&lt;IDBClient::TransactionOperation&gt; currentOperation = m_transactionOperationsInProgressQueue.first();</span>
<span class="udiff-line-added">+         if (!m_transactionOperationResultMap.contains(currentOperation))</span>
<span class="udiff-line-added">+             return;</span>
  
<span class="udiff-line-modified-removed">-     if (!m_completedOnServerQueue.isEmpty() &amp;&amp; !m_currentlyCompletingRequest)</span>
<span class="udiff-line-modified-removed">-         scheduleCompletedOperationTimer();</span>
<span class="udiff-line-modified-added">+         currentOperation-&gt;doComplete(m_transactionOperationResultMap.take(currentOperation));</span>
<span class="udiff-line-modified-added">+     }</span>
  }
  
  void IDBTransaction::completeNoncursorRequest(IDBRequest&amp; request, const IDBResultData&amp; result)
  {
      ASSERT(!m_currentlyCompletingRequest);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -492,23 +437,23 @@</span>
      m_currentlyCompletingRequest = &amp;request;
  }
  
  void IDBTransaction::finishedDispatchEventForRequest(IDBRequest&amp; request)
  {
<span class="udiff-line-modified-removed">-     if (isFinishedOrFinishing())</span>
<span class="udiff-line-modified-added">+     if (isFinished())</span>
          return;
  
      ASSERT_UNUSED(request, !m_currentlyCompletingRequest || m_currentlyCompletingRequest == &amp;request);
  
      m_currentlyCompletingRequest = nullptr;
<span class="udiff-line-modified-removed">-     scheduleCompletedOperationTimer();</span>
<span class="udiff-line-modified-added">+     handleOperationsCompletedOnServer();</span>
  }
  
  void IDBTransaction::commit()
  {
      LOG(IndexedDB, &quot;IDBTransaction::commit&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(!isFinishedOrFinishing());
  
      transitionedToFinishing(IndexedDB::TransactionState::Committing);
      m_database-&gt;willCommitTransaction(*this);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -519,11 +464,11 @@</span>
  }
  
  void IDBTransaction::commitOnServer(IDBClient::TransactionOperation&amp; operation)
  {
      LOG(IndexedDB, &quot;IDBTransaction::commitOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().commitTransaction(*this);
  
      ASSERT(!m_transactionOperationsInProgressQueue.isEmpty());
      ASSERT(m_transactionOperationsInProgressQueue.last() == &amp;operation);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -534,19 +479,19 @@</span>
  }
  
  void IDBTransaction::finishAbortOrCommit()
  {
      ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_state = IndexedDB::TransactionState::Finished;
  }
  
  void IDBTransaction::didStart(const IDBError&amp; error)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didStart&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;didStartTransaction(*this);
  
      m_startedOnServer = true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -555,16 +500,21 @@</span>
      if (!error.isNull()) {
          didAbort(error);
          return;
      }
  
<span class="udiff-line-modified-removed">-     schedulePendingOperationTimer();</span>
<span class="udiff-line-modified-added">+     handlePendingOperations();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // It&#39;s possible transaction does not create requests (or creates but finishes them early</span>
<span class="udiff-line-added">+     // because of error) during intialization. In this case, since the transaction will</span>
<span class="udiff-line-added">+     // not be active any more, we can end it.</span>
<span class="udiff-line-added">+     autoCommit();</span>
  }
  
  void IDBTransaction::notifyDidAbort(const IDBError&amp; error)
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;didAbortTransaction(*this);
      m_idbError = error;
      fireOnAbort();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -575,11 +525,11 @@</span>
  }
  
  void IDBTransaction::didAbort(const IDBError&amp; error)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didAbort&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (m_state == IndexedDB::TransactionState::Finished)
          return;
  
      notifyDidAbort(error);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -588,11 +538,11 @@</span>
  }
  
  void IDBTransaction::didCommit(const IDBError&amp; error)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didCommit&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(m_state == IndexedDB::TransactionState::Committing);
  
      if (error.isNull()) {
          m_database-&gt;didCommitTransaction(*this);
          fireOnComplete();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -605,41 +555,39 @@</span>
  }
  
  void IDBTransaction::fireOnComplete()
  {
      LOG(IndexedDB, &quot;IDBTransaction::fireOnComplete&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      enqueueEvent(Event::create(eventNames().completeEvent, Event::CanBubble::No, Event::IsCancelable::No));
  }
  
  void IDBTransaction::fireOnAbort()
  {
      LOG(IndexedDB, &quot;IDBTransaction::fireOnAbort&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      enqueueEvent(Event::create(eventNames().abortEvent, Event::CanBubble::Yes, Event::IsCancelable::No));
  }
  
  void IDBTransaction::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
  {
      ASSERT(m_state != IndexedDB::TransactionState::Finished);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (!scriptExecutionContext() || m_contextStopped)
          return;
  
<span class="udiff-line-modified-removed">-     event-&gt;setTarget(this);</span>
<span class="udiff-line-removed">-     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));</span>
<span class="udiff-line-modified-added">+     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));</span>
  }
  
  void IDBTransaction::dispatchEvent(Event&amp; event)
  {
      LOG(IndexedDB, &quot;IDBTransaction::dispatchEvent&quot;);
  
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(scriptExecutionContext());
      ASSERT(!m_contextStopped);
<span class="udiff-line-removed">-     ASSERT(event.target() == this);</span>
      ASSERT(event.type() == eventNames().completeEvent || event.type() == eventNames().abortEvent);
  
      auto protectedThis = makeRef(*this);
  
      EventDispatcher::dispatchEvent({ this, m_database.ptr() }, event);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -663,11 +611,11 @@</span>
  Ref&lt;IDBObjectStore&gt; IDBTransaction::createObjectStore(const IDBObjectStoreInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBTransaction::createObjectStore&quot;);
      ASSERT(isVersionChange());
      ASSERT(scriptExecutionContext());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
  
      auto objectStore = makeUnique&lt;IDBObjectStore&gt;(*scriptExecutionContext(), info, *this);
      auto* rawObjectStore = objectStore.get();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -676,28 +624,28 @@</span>
      LOG(IndexedDBOperations, &quot;IDB create object store operation: %s&quot;, info.condensedLoggingString().utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didCreateObjectStoreOnServer(result);
      }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;createObjectStoreOnServer(operation, info);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  
      return *rawObjectStore;
  }
  
  void IDBTransaction::createObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBTransaction::createObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      m_database-&gt;connectionProxy().createObjectStore(operation, info);
  }
  
  void IDBTransaction::didCreateObjectStoreOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didCreateObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::CreateObjectStoreSuccess || resultData.type() == IDBResultType::Error);
  }
  
  void IDBTransaction::renameObjectStore(IDBObjectStore&amp; objectStore, const String&amp; newName)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -705,11 +653,11 @@</span>
  
      Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
  
      ASSERT(isVersionChange());
      ASSERT(scriptExecutionContext());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT(m_referencedObjectStores.contains(objectStore.info().name()));
      ASSERT(!m_referencedObjectStores.contains(newName));
      ASSERT(m_referencedObjectStores.get(objectStore.info().name()) == &amp;objectStore);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,63 +666,63 @@</span>
      LOG(IndexedDBOperations, &quot;IDB rename object store operation: %s to %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), newName.utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didRenameObjectStoreOnServer(result);
      }, [protectedThis = makeRef(*this), objectStoreIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;renameObjectStoreOnServer(operation, objectStoreIdentifier, newName);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  
      m_referencedObjectStores.set(newName, m_referencedObjectStores.take(objectStore.info().name()));
  }
  
  void IDBTransaction::renameObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; newName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::renameObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      m_database-&gt;connectionProxy().renameObjectStore(operation, objectStoreIdentifier, newName);
  }
  
  void IDBTransaction::didRenameObjectStoreOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didRenameObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameObjectStoreSuccess || resultData.type() == IDBResultType::Error);
  }
  
  std::unique_ptr&lt;IDBIndex&gt; IDBTransaction::createIndex(IDBObjectStore&amp; objectStore, const IDBIndexInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBTransaction::createIndex&quot;);
      ASSERT(isVersionChange());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (!scriptExecutionContext())
          return nullptr;
  
      LOG(IndexedDBOperations, &quot;IDB create index operation: %s under object store %s&quot;, info.condensedLoggingString().utf8().data(), objectStore.info().condensedLoggingString().utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didCreateIndexOnServer(result);
      }, [protectedThis = makeRef(*this), info = info.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;createIndexOnServer(operation, info);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  
      return makeUnique&lt;IDBIndex&gt;(*scriptExecutionContext(), info, objectStore);
  }
  
  void IDBTransaction::createIndexOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBTransaction::createIndexOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      m_database-&gt;connectionProxy().createIndex(operation, info);
  }
  
  void IDBTransaction::didCreateIndexOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didCreateIndexOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (resultData.type() == IDBResultType::CreateIndexSuccess)
          return;
  
      ASSERT(resultData.type() == IDBResultType::Error);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -792,11 +740,11 @@</span>
      LOG(IndexedDB, &quot;IDBTransaction::renameIndex&quot;);
      Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
  
      ASSERT(isVersionChange());
      ASSERT(scriptExecutionContext());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT(m_referencedObjectStores.contains(index.objectStore().info().name()));
      ASSERT(m_referencedObjectStores.get(index.objectStore().info().name()) == &amp;index.objectStore());
  
      index.objectStore().renameReferencedIndex(index, newName);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -807,55 +755,55 @@</span>
      LOG(IndexedDBOperations, &quot;IDB rename index operation: %s to %s under object store %&quot; PRIu64, index.info().condensedLoggingString().utf8().data(), newName.utf8().data(), index.info().objectStoreIdentifier());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didRenameIndexOnServer(result);
      }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexIdentifier, newName = newName.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;renameIndexOnServer(operation, objectStoreIdentifier, indexIdentifier, newName);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  }
  
  void IDBTransaction::renameIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const uint64_t&amp; indexIdentifier, const String&amp; newName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::renameIndexOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      m_database-&gt;connectionProxy().renameIndex(operation, objectStoreIdentifier, indexIdentifier, newName);
  }
  
  void IDBTransaction::didRenameIndexOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didRenameIndexOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::RenameIndexSuccess || resultData.type() == IDBResultType::Error);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBCursorInfo&amp; info)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
          return doRequestOpenCursor(state, IDBCursor::create(objectStore, info));
  
      return doRequestOpenCursor(state, IDBCursorWithValue::create(objectStore, info));
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(ExecState&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestOpenCursor(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBCursorInfo&amp; info)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestOpenCursor&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (info.cursorType() == IndexedDB::CursorType::KeyOnly)
          return doRequestOpenCursor(state, IDBCursor::create(index, info));
  
      return doRequestOpenCursor(state, IDBCursorWithValue::create(index, info));
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(ExecState&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::doRequestOpenCursor(JSGlobalObject&amp; state, Ref&lt;IDBCursor&gt;&amp;&amp; cursor)</span>
  {
      ASSERT(isActive());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), cursor.get(), *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -871,29 +819,29 @@</span>
  }
  
  void IDBTransaction::openCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBTransaction::openCursorOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().openCursor(operation, info);
  }
  
  void IDBTransaction::didOpenCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didOpenCursorOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      completeCursorRequest(request, resultData);
  }
  
  void IDBTransaction::iterateCursor(IDBCursor&amp; cursor, const IDBIterateCursorData&amp; data)
  {
      LOG(IndexedDB, &quot;IDBTransaction::iterateCursor&quot;);
      ASSERT(isActive());
      ASSERT(cursor.request());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      addRequest(*cursor.request());
  
      LOG(IndexedDBOperations, &quot;IDB iterate cursor operation: %s %s&quot;, cursor.info().loggingString().utf8().data(), data.loggingString().utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, *cursor.request(), [protectedThis = makeRef(*this), request = makeRef(*cursor.request())] (const auto&amp; result) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -905,28 +853,44 @@</span>
  
  // FIXME: changes here
  void IDBTransaction::iterateCursorOnServer(IDBClient::TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
  {
      LOG(IndexedDB, &quot;IDBTransaction::iterateCursorOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-added">+     ASSERT(operation.idbRequest());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto* cursor = operation.idbRequest()-&gt;pendingCursor();</span>
<span class="udiff-line-added">+     ASSERT(cursor);</span>
  
<span class="udiff-line-added">+     if (data.keyData.isNull() &amp;&amp; data.primaryKeyData.isNull()) {</span>
<span class="udiff-line-added">+         if (auto getResult = cursor-&gt;iterateWithPrefetchedRecords(data.count, m_lastWriteOperationID)) {</span>
<span class="udiff-line-added">+             auto result = IDBResultData::iterateCursorSuccess(operation.identifier(), getResult.value());</span>
<span class="udiff-line-added">+             m_database-&gt;connectionProxy().iterateCursor(operation, { data.keyData, data.primaryKeyData, data.count, IndexedDB::CursorIterateOption::DoNotReply });</span>
<span class="udiff-line-added">+             operationCompletedOnServer(result, operation);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     cursor-&gt;clearPrefetchedRecords();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(data.option == IndexedDB::CursorIterateOption::Reply);</span>
      m_database-&gt;connectionProxy().iterateCursor(operation, data);
  }
  
  void IDBTransaction::didIterateCursorOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didIterateCursorOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      completeCursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllObjectStoreRecords(JSC::JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetAllObjectStoreRecords&quot;);
      ASSERT(isActive());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -941,15 +905,15 @@</span>
      }));
  
      return request;
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestGetAllIndexRecords(JSC::JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; keyRangeData, IndexedDB::GetAllType getAllType, Optional&lt;uint32_t&gt; count)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetAllIndexRecords&quot;);
      ASSERT(isActive());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -967,19 +931,19 @@</span>
  }
  
  void IDBTransaction::getAllRecordsOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::getAllRecordsOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().getAllRecords(operation, getAllRecordsData);
  }
  
  void IDBTransaction::didGetAllRecordsOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didGetAllRecordsOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (resultData.type() == IDBResultType::Error) {
          completeNoncursorRequest(request, resultData);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -997,16 +961,16 @@</span>
      }
  
      completeNoncursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestGetRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBGetRecordData&amp; getRecordData)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetRecord&quot;);
      ASSERT(isActive());
      ASSERT(!getRecordData.keyRangeData.isNull);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      IndexedDB::ObjectStoreRecordType type = getRecordData.type == IDBGetRecordDataType::KeyAndValue ? IndexedDB::ObjectStoreRecordType::ValueOnly : IndexedDB::ObjectStoreRecordType::KeyOnly;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1021,32 +985,32 @@</span>
      }));
  
      return request;
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestGetValue(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Value, range);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestGetKey(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      return requestIndexRecord(state, index, IndexedDB::IndexRecordType::Key, range);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(ExecState&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestIndexRecord(JSGlobalObject&amp; state, IDBIndex&amp; index, IndexedDB::IndexRecordType type, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestGetValue&quot;);
      ASSERT(isActive());
      ASSERT(!range.isNull);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::createIndexGet(*scriptExecutionContext(), index, type, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1064,19 +1028,19 @@</span>
  }
  
  void IDBTransaction::getRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::getRecordOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().getRecord(operation, getRecordData);
  }
  
  void IDBTransaction::didGetRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didGetRecordOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (resultData.type() == IDBResultType::Error) {
          completeNoncursorRequest(request, resultData);
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1102,16 +1066,16 @@</span>
      }
  
      completeNoncursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBObjectStore)&quot;);
      ASSERT(isActive());
      ASSERT(!range.isNull);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1124,16 +1088,16 @@</span>
      }));
  
      return request;
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(ExecState&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestCount(JSGlobalObject&amp; state, IDBIndex&amp; index, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestCount (IDBIndex)&quot;);
      ASSERT(isActive());
      ASSERT(!range.isNull);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), index, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1149,30 +1113,30 @@</span>
  }
  
  void IDBTransaction::getCountOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
  {
      LOG(IndexedDB, &quot;IDBTransaction::getCountOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().getCount(operation, keyRange);
  }
  
  void IDBTransaction::didGetCountOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didGetCountOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      request.setResult(resultData.resultInteger());
      completeNoncursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(ExecState&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestDeleteRecord(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, const IDBKeyRangeData&amp; range)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestDeleteRecord&quot;);
      ASSERT(isActive());
      ASSERT(!range.isNull);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1180,36 +1144,36 @@</span>
      LOG(IndexedDBOperations, &quot;IDB delete record operation: %s, range %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), range.loggingString().utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
          protectedThis-&gt;didDeleteRecordOnServer(request.get(), result);
      }, [protectedThis = makeRef(*this), range = range.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;deleteRecordOnServer(operation, range);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
      return request;
  }
  
  void IDBTransaction::deleteRecordOnServer(IDBClient::TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
  {
      LOG(IndexedDB, &quot;IDBTransaction::deleteRecordOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().deleteRecord(operation, keyRange);
  }
  
  void IDBTransaction::didDeleteRecordOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didDeleteRecordOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      request.setResultToUndefined();
      completeNoncursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(ExecState&amp; state, IDBObjectStore&amp; objectStore)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestClearObjectStore(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestClearObjectStore&quot;);
      ASSERT(isActive());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1219,39 +1183,39 @@</span>
      LOG(IndexedDBOperations, &quot;IDB clear object store operation: %s&quot;, objectStore.info().condensedLoggingString().utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
          protectedThis-&gt;didClearObjectStoreOnServer(request.get(), result);
      }, [protectedThis = makeRef(*this), objectStoreIdentifier] (auto&amp; operation) {
          protectedThis-&gt;clearObjectStoreOnServer(operation, objectStoreIdentifier);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  
      return request;
  }
  
  void IDBTransaction::clearObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier)
  {
      LOG(IndexedDB, &quot;IDBTransaction::clearObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().clearObjectStore(operation, objectStoreIdentifier);
  }
  
  void IDBTransaction::didClearObjectStoreOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didClearObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      request.setResultToUndefined();
      completeNoncursorRequest(request, resultData);
  }
  
<span class="udiff-line-modified-removed">- Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(ExecState&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
<span class="udiff-line-modified-added">+ Ref&lt;IDBRequest&gt; IDBTransaction::requestPutOrAdd(JSGlobalObject&amp; state, IDBObjectStore&amp; objectStore, RefPtr&lt;IDBKey&gt;&amp;&amp; key, SerializedScriptValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)</span>
  {
      LOG(IndexedDB, &quot;IDBTransaction::requestPutOrAdd&quot;);
      ASSERT(isActive());
      ASSERT(!isReadOnly());
      ASSERT(objectStore.info().autoIncrement() || key);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      ASSERT_UNUSED(state, scriptExecutionContext() == scriptExecutionContextFromExecState(&amp;state));
  
      auto request = IDBRequest::create(*scriptExecutionContext(), objectStore, *this);
      addRequest(request.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1259,19 +1223,19 @@</span>
      LOG(IndexedDBOperations, &quot;IDB putOrAdd operation: %s key: %s&quot;, objectStore.info().condensedLoggingString().utf8().data(), key ? key-&gt;loggingString().utf8().data() : &quot;&lt;null key&gt;&quot;);
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, request.get(), [protectedThis = makeRef(*this), request = request.copyRef()] (const auto&amp; result) {
          protectedThis-&gt;didPutOrAddOnServer(request.get(), result);
      }, [protectedThis = makeRef(*this), key, value = makeRef(value), overwriteMode] (auto&amp; operation) {
          protectedThis-&gt;putOrAddOnServer(operation, key.get(), value.ptr(), overwriteMode);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  
      return request;
  }
  
  void IDBTransaction::putOrAddOnServer(IDBClient::TransactionOperation&amp; operation, RefPtr&lt;IDBKey&gt; key, RefPtr&lt;SerializedScriptValue&gt; value, const IndexedDB::ObjectStoreOverwriteMode&amp; overwriteMode)
  {
      LOG(IndexedDB, &quot;IDBTransaction::putOrAddOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
      ASSERT(!isReadOnly());
      ASSERT(value);
  
      if (!value-&gt;hasBlobURLs()) {
          m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), *value, overwriteMode);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1280,11 +1244,11 @@</span>
  
      // Due to current limitations on our ability to post tasks back to a worker thread,
      // workers currently write blobs to disk synchronously.
      // FIXME: https://bugs.webkit.org/show_bug.cgi?id=157958 - Make this asynchronous after refactoring allows it.
      if (!isMainThread()) {
<span class="udiff-line-modified-removed">-         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously(scriptExecutionContext()-&gt;sessionID());</span>
<span class="udiff-line-modified-added">+         auto idbValue = value-&gt;writeBlobsToDiskForIndexedDBSynchronously();</span>
          if (idbValue.data().data())
              m_database-&gt;connectionProxy().putOrAdd(operation, key.get(), idbValue, overwriteMode);
          else {
              // If the IDBValue doesn&#39;t have any data, then something went wrong writing the blobs to disk.
              // In that case, we cannot successfully store this record, so we callback with an error.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1299,12 +1263,12 @@</span>
  
      // Since this request won&#39;t actually go to the server until the blob writes are complete,
      // stop future requests from going to the server ahead of it.
      operation.setNextRequestCanGoToServer(false);
  
<span class="udiff-line-modified-removed">-     value-&gt;writeBlobsToDiskForIndexedDB(scriptExecutionContext()-&gt;sessionID(), [protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
<span class="udiff-line-modified-removed">-         ASSERT(&amp;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     value-&gt;writeBlobsToDiskForIndexedDB([protectedThis = makeRef(*this), this, protectedOperation = Ref&lt;IDBClient::TransactionOperation&gt;(operation), keyData = IDBKeyData(key.get()).isolatedCopy(), overwriteMode](IDBValue&amp;&amp; idbValue) mutable {</span>
<span class="udiff-line-modified-added">+         ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
          ASSERT(isMainThread());
          if (idbValue.data().data()) {
              m_database-&gt;connectionProxy().putOrAdd(protectedOperation.get(), WTFMove(keyData), idbValue, overwriteMode);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1319,11 +1283,11 @@</span>
  }
  
  void IDBTransaction::didPutOrAddOnServer(IDBRequest&amp; request, const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didPutOrAddOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (auto* result = resultData.resultKey())
          request.setResult(*result);
      else
          request.setResultToUndefined();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1331,11 +1295,11 @@</span>
  }
  
  void IDBTransaction::deleteObjectStore(const String&amp; objectStoreName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStore&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      Locker&lt;Lock&gt; locker(m_referencedObjectStoreLock);
  
      if (auto objectStore = m_referencedObjectStores.take(objectStoreName)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1347,124 +1311,133 @@</span>
      LOG(IndexedDBOperations, &quot;IDB delete object store operation: %s&quot;, objectStoreName.utf8().data());
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didDeleteObjectStoreOnServer(result);
      }, [protectedThis = makeRef(*this), objectStoreName = objectStoreName.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;deleteObjectStoreOnServer(operation, objectStoreName);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  }
  
  void IDBTransaction::deleteObjectStoreOnServer(IDBClient::TransactionOperation&amp; operation, const String&amp; objectStoreName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::deleteObjectStoreOnServer&quot;);
      ASSERT(isVersionChange());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().deleteObjectStore(operation, objectStoreName);
  }
  
  void IDBTransaction::didDeleteObjectStoreOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didDeleteObjectStoreOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteObjectStoreSuccess || resultData.type() == IDBResultType::Error);
  }
  
  void IDBTransaction::deleteIndex(uint64_t objectStoreIdentifier, const String&amp; indexName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::deleteIndex&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT(isVersionChange());
  
      LOG(IndexedDBOperations, &quot;IDB delete index operation: %s (%&quot; PRIu64 &quot;)&quot;, indexName.utf8().data(), objectStoreIdentifier);
      scheduleOperation(IDBClient::TransactionOperationImpl::create(*this, [protectedThis = makeRef(*this)] (const auto&amp; result) {
          protectedThis-&gt;didDeleteIndexOnServer(result);
      }, [protectedThis = makeRef(*this), objectStoreIdentifier, indexName = indexName.isolatedCopy()] (auto&amp; operation) {
          protectedThis-&gt;deleteIndexOnServer(operation, objectStoreIdentifier, indexName);
<span class="udiff-line-modified-removed">-     }));</span>
<span class="udiff-line-modified-added">+     }), IsWriteOperation::Yes);</span>
  }
  
  void IDBTransaction::deleteIndexOnServer(IDBClient::TransactionOperation&amp; operation, const uint64_t&amp; objectStoreIdentifier, const String&amp; indexName)
  {
      LOG(IndexedDB, &quot;IDBTransaction::deleteIndexOnServer&quot;);
      ASSERT(isVersionChange());
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().deleteIndex(operation, objectStoreIdentifier, indexName);
  }
  
  void IDBTransaction::didDeleteIndexOnServer(const IDBResultData&amp; resultData)
  {
      LOG(IndexedDB, &quot;IDBTransaction::didDeleteIndexOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
      ASSERT_UNUSED(resultData, resultData.type() == IDBResultType::DeleteIndexSuccess || resultData.type() == IDBResultType::Error);
  }
  
  void IDBTransaction::operationCompletedOnClient(IDBClient::TransactionOperation&amp; operation)
  {
      LOG(IndexedDB, &quot;IDBTransaction::operationCompletedOnClient&quot;);
  
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-removed">-     ASSERT(&amp;operation.originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(operation.originThread()));</span>
      ASSERT(m_transactionOperationMap.get(operation.identifier()) == &amp;operation);
      ASSERT(m_transactionOperationsInProgressQueue.first() == &amp;operation);
  
      m_transactionOperationMap.remove(operation.identifier());
      m_transactionOperationsInProgressQueue.removeFirst();
  
<span class="udiff-line-modified-removed">-     schedulePendingOperationTimer();</span>
<span class="udiff-line-modified-added">+     if (m_transactionOperationsInProgressQueue.isEmpty())</span>
<span class="udiff-line-added">+         handlePendingOperations();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     autoCommit();</span>
  }
  
  void IDBTransaction::establishOnServer()
  {
      LOG(IndexedDB, &quot;IDBTransaction::establishOnServer&quot;);
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      m_database-&gt;connectionProxy().establishTransaction(*this);
  }
  
  void IDBTransaction::activate()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (isFinishedOrFinishing())
          return;
  
      m_state = IndexedDB::TransactionState::Active;
  }
  
  void IDBTransaction::deactivate()
  {
<span class="udiff-line-modified-removed">-     ASSERT(&amp;m_database-&gt;originThread() == &amp;Thread::current());</span>
<span class="udiff-line-modified-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
  
      if (m_state == IndexedDB::TransactionState::Active)
          m_state = IndexedDB::TransactionState::Inactive;
  
<span class="udiff-line-modified-removed">-     schedulePendingOperationTimer();</span>
<span class="udiff-line-modified-added">+     autoCommit();</span>
  }
  
  void IDBTransaction::connectionClosedFromServer(const IDBError&amp; error)
  {
      LOG(IndexedDB, &quot;IDBTransaction::connectionClosedFromServer - %s&quot;, error.message().utf8().data());
  
      m_database-&gt;willAbortTransaction(*this);
      m_state = IndexedDB::TransactionState::Aborting;
  
<span class="udiff-line-added">+     // Move operations out of m_pendingTransactionOperationQueue, otherwise we may start handling</span>
<span class="udiff-line-added">+     // them after we forcibly complete in-progress transactions.</span>
<span class="udiff-line-added">+     Deque&lt;RefPtr&lt;IDBClient::TransactionOperation&gt;&gt; pendingTransactionOperationQueue;</span>
<span class="udiff-line-added">+     pendingTransactionOperationQueue.swap(m_pendingTransactionOperationQueue);</span>
<span class="udiff-line-added">+ </span>
      abortInProgressOperations(error);
  
      auto operations = copyToVector(m_transactionOperationMap.values());
      for (auto&amp; operation : operations) {
          m_currentlyCompletingRequest = nullptr;
          m_transactionOperationsInProgressQueue.append(operation.get());
          ASSERT(m_transactionOperationsInProgressQueue.first() == operation.get());
          operation-&gt;doComplete(IDBResultData::error(operation-&gt;identifier(), error));
      }
      m_currentlyCompletingRequest = nullptr;
<span class="udiff-line-added">+     m_openRequests.clear();</span>
<span class="udiff-line-added">+     pendingTransactionOperationQueue.clear();</span>
  
      connectionProxy().forgetActiveOperations(operations);
      connectionProxy().forgetTransaction(*this);
  
<span class="udiff-line-removed">-     m_pendingTransactionOperationQueue.clear();</span>
      m_abortQueue.clear();
      m_transactionOperationMap.clear();
  
      m_idbError = error;
      m_domError = error.toDOMException();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1479,8 +1452,54 @@</span>
          visitor.addOpaqueRoot(objectStore.get());
      for (auto&amp; objectStore : m_deletedObjectStores.values())
          visitor.addOpaqueRoot(objectStore.get());
  }
  
<span class="udiff-line-added">+ void IDBTransaction::handlePendingOperations()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(canCurrentThreadAccessThreadLocalData(m_database-&gt;originThread()));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_startedOnServer)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_transactionOperationsInProgressQueue.isEmpty() &amp;&amp; !m_transactionOperationsInProgressQueue.last()-&gt;nextRequestCanGoToServer())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     while (!m_pendingTransactionOperationQueue.isEmpty()) {</span>
<span class="udiff-line-added">+         auto operation = m_pendingTransactionOperationQueue.takeFirst();</span>
<span class="udiff-line-added">+         m_transactionOperationsInProgressQueue.append(operation.get());</span>
<span class="udiff-line-added">+         operation-&gt;perform();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (!operation-&gt;nextRequestCanGoToServer())</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void IDBTransaction::autoCommit()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // If transaction is not inactive, it&#39;s active, finished or finishing.</span>
<span class="udiff-line-added">+     // If it&#39;s active, it may create new requests, so we cannot commit it.</span>
<span class="udiff-line-added">+     if (m_state != IndexedDB::TransactionState::Inactive)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_startedOnServer)</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_transactionOperationMap.isEmpty())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (!m_openRequests.isEmpty())</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     ASSERT(!m_currentlyCompletingRequest);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     commit();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint64_t IDBTransaction::generateOperationID()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     static std::atomic&lt;uint64_t&gt; currentOperationID(1);</span>
<span class="udiff-line-added">+     return currentOperationID += 1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(INDEXED_DATABASE)
</pre>
<center><a href="IDBRequestCompletionEvent.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBTransaction.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
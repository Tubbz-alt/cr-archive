<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/AbstractModuleRecord.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AbstractModuleRecord.h&quot;
 28 
 29 #include &quot;Error.h&quot;
 30 #include &quot;Interpreter.h&quot;
 31 #include &quot;JSCInlines.h&quot;
 32 #include &quot;JSMap.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSModuleNamespaceObject.h&quot;
 35 #include &quot;JSModuleRecord.h&quot;
 36 #include &quot;UnlinkedModuleProgramCodeBlock.h&quot;
 37 #include &quot;WebAssemblyModuleRecord.h&quot;
 38 #include &lt;wtf/Optional.h&gt;
 39 
 40 namespace JSC {
 41 namespace AbstractModuleRecordInternal {
 42 static constexpr bool verbose = false;
 43 } // namespace AbstractModuleRecordInternal
 44 
 45 const ClassInfo AbstractModuleRecord::s_info = { &quot;AbstractModuleRecord&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(AbstractModuleRecord) };
 46 
 47 AbstractModuleRecord::AbstractModuleRecord(VM&amp; vm, Structure* structure, const Identifier&amp; moduleKey)
 48     : Base(vm, structure)
 49     , m_moduleKey(moduleKey)
 50 {
 51 }
 52 
 53 void AbstractModuleRecord::finishCreation(JSGlobalObject* globalObject, VM&amp; vm)
 54 {
 55     Base::finishCreation(vm);
 56     ASSERT(inherits(vm, info()));
 57 
 58     auto scope = DECLARE_THROW_SCOPE(vm);
 59     JSMap* map = JSMap::create(globalObject, vm, globalObject-&gt;mapStructure());
 60     scope.releaseAssertNoException();
 61     m_dependenciesMap.set(vm, this, map);
 62     putDirect(vm, Identifier::fromString(vm, &quot;dependenciesMap&quot;_s), m_dependenciesMap.get());
 63 }
 64 
 65 void AbstractModuleRecord::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 66 {
 67     AbstractModuleRecord* thisObject = jsCast&lt;AbstractModuleRecord*&gt;(cell);
 68     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 69     Base::visitChildren(thisObject, visitor);
 70     visitor.append(thisObject-&gt;m_moduleEnvironment);
 71     visitor.append(thisObject-&gt;m_moduleNamespaceObject);
 72     visitor.append(thisObject-&gt;m_dependenciesMap);
 73 }
 74 
 75 void AbstractModuleRecord::appendRequestedModule(const Identifier&amp; moduleName)
 76 {
 77     m_requestedModules.add(moduleName.impl());
 78 }
 79 
 80 void AbstractModuleRecord::addStarExportEntry(const Identifier&amp; moduleName)
 81 {
 82     m_starExportEntries.add(moduleName.impl());
 83 }
 84 
 85 void AbstractModuleRecord::addImportEntry(const ImportEntry&amp; entry)
 86 {
 87     bool isNewEntry = m_importEntries.add(entry.localName.impl(), entry).isNewEntry;
 88     ASSERT_UNUSED(isNewEntry, isNewEntry); // This is guaranteed by the parser.
 89 }
 90 
 91 void AbstractModuleRecord::addExportEntry(const ExportEntry&amp; entry)
 92 {
 93     bool isNewEntry = m_exportEntries.add(entry.exportName.impl(), entry).isNewEntry;
 94     ASSERT_UNUSED(isNewEntry, isNewEntry); // This is guaranteed by the parser.
 95 }
 96 
 97 auto AbstractModuleRecord::tryGetImportEntry(UniquedStringImpl* localName) -&gt; Optional&lt;ImportEntry&gt;
 98 {
 99     const auto iterator = m_importEntries.find(localName);
100     if (iterator == m_importEntries.end())
101         return WTF::nullopt;
102     return Optional&lt;ImportEntry&gt;(iterator-&gt;value);
103 }
104 
105 auto AbstractModuleRecord::tryGetExportEntry(UniquedStringImpl* exportName) -&gt; Optional&lt;ExportEntry&gt;
106 {
107     const auto iterator = m_exportEntries.find(exportName);
108     if (iterator == m_exportEntries.end())
109         return WTF::nullopt;
110     return Optional&lt;ExportEntry&gt;(iterator-&gt;value);
111 }
112 
113 auto AbstractModuleRecord::ExportEntry::createLocal(const Identifier&amp; exportName, const Identifier&amp; localName) -&gt; ExportEntry
114 {
115     return ExportEntry { Type::Local, exportName, Identifier(), Identifier(), localName };
116 }
117 
118 auto AbstractModuleRecord::ExportEntry::createIndirect(const Identifier&amp; exportName, const Identifier&amp; importName, const Identifier&amp; moduleName) -&gt; ExportEntry
119 {
120     return ExportEntry { Type::Indirect, exportName, moduleName, importName, Identifier() };
121 }
122 
123 auto AbstractModuleRecord::Resolution::notFound() -&gt; Resolution
124 {
125     return Resolution { Type::NotFound, nullptr, Identifier() };
126 }
127 
128 auto AbstractModuleRecord::Resolution::error() -&gt; Resolution
129 {
130     return Resolution { Type::Error, nullptr, Identifier() };
131 }
132 
133 auto AbstractModuleRecord::Resolution::ambiguous() -&gt; Resolution
134 {
135     return Resolution { Type::Ambiguous, nullptr, Identifier() };
136 }
137 
138 AbstractModuleRecord* AbstractModuleRecord::hostResolveImportedModule(JSGlobalObject* globalObject, const Identifier&amp; moduleName)
139 {
140     VM&amp; vm = globalObject-&gt;vm();
141     auto scope = DECLARE_THROW_SCOPE(vm);
142     JSValue moduleNameValue = identifierToJSValue(vm, moduleName);
143     JSValue entry = m_dependenciesMap-&gt;JSMap::get(globalObject, moduleNameValue);
144     RETURN_IF_EXCEPTION(scope, nullptr);
145     RELEASE_AND_RETURN(scope, jsCast&lt;AbstractModuleRecord*&gt;(entry.get(globalObject, Identifier::fromString(vm, &quot;module&quot;))));
146 }
147 
148 auto AbstractModuleRecord::resolveImport(JSGlobalObject* globalObject, const Identifier&amp; localName) -&gt; Resolution
149 {
150     VM&amp; vm = globalObject-&gt;vm();
151     auto scope = DECLARE_THROW_SCOPE(vm);
152 
153     Optional&lt;ImportEntry&gt; optionalImportEntry = tryGetImportEntry(localName.impl());
154     if (!optionalImportEntry)
155         return Resolution::notFound();
156 
157     const ImportEntry&amp; importEntry = *optionalImportEntry;
158     if (importEntry.type == AbstractModuleRecord::ImportEntryType::Namespace)
159         return Resolution::notFound();
160 
161     AbstractModuleRecord* importedModule = hostResolveImportedModule(globalObject, importEntry.moduleRequest);
162     RETURN_IF_EXCEPTION(scope, Resolution::error());
163     return importedModule-&gt;resolveExport(globalObject, importEntry.importName);
164 }
165 
166 struct AbstractModuleRecord::ResolveQuery {
167     struct Hash {
168         static unsigned hash(const ResolveQuery&amp;);
169         static bool equal(const ResolveQuery&amp;, const ResolveQuery&amp;);
170         static constexpr bool safeToCompareToEmptyOrDeleted = true;
171     };
172     using HashTraits = WTF::CustomHashTraits&lt;ResolveQuery&gt;;
173 
174     ResolveQuery(AbstractModuleRecord* moduleRecord, UniquedStringImpl* exportName)
175         : moduleRecord(moduleRecord)
176         , exportName(exportName)
177     {
178     }
179 
180     ResolveQuery(AbstractModuleRecord* moduleRecord, const Identifier&amp; exportName)
181         : ResolveQuery(moduleRecord, exportName.impl())
182     {
183     }
184 
185     enum EmptyValueTag { EmptyValue };
186     ResolveQuery(EmptyValueTag)
187     {
188     }
189 
190     enum DeletedValueTag { DeletedValue };
191     ResolveQuery(DeletedValueTag)
192         : moduleRecord(nullptr)
193         , exportName(WTF::HashTableDeletedValue)
194     {
195     }
196 
197     bool isEmptyValue() const
198     {
199         return !exportName;
200     }
201 
202     bool isDeletedValue() const
203     {
204         return exportName.isHashTableDeletedValue();
205     }
206 
207     void dump(PrintStream&amp; out) const
208     {
209         if (!moduleRecord) {
210             out.print(&quot;&lt;empty&gt;&quot;);
211             return;
212         }
213         out.print(moduleRecord-&gt;moduleKey(), &quot; \&quot;&quot;, exportName.get(), &quot;\&quot;&quot;);
214     }
215 
216     // The module record is not marked from the GC. But these records are reachable from the JSGlobalObject.
217     // So we don&#39;t care the reachability to this record.
218     AbstractModuleRecord* moduleRecord;
219     RefPtr&lt;UniquedStringImpl&gt; exportName;
220 };
221 
222 inline unsigned AbstractModuleRecord::ResolveQuery::Hash::hash(const ResolveQuery&amp; query)
223 {
224     return WTF::PtrHash&lt;AbstractModuleRecord*&gt;::hash(query.moduleRecord) + IdentifierRepHash::hash(query.exportName);
225 }
226 
227 inline bool AbstractModuleRecord::ResolveQuery::Hash::equal(const ResolveQuery&amp; lhs, const ResolveQuery&amp; rhs)
228 {
229     return lhs.moduleRecord == rhs.moduleRecord &amp;&amp; lhs.exportName == rhs.exportName;
230 }
231 
232 auto AbstractModuleRecord::tryGetCachedResolution(UniquedStringImpl* exportName) -&gt; Optional&lt;Resolution&gt;
233 {
234     const auto iterator = m_resolutionCache.find(exportName);
235     if (iterator == m_resolutionCache.end())
236         return WTF::nullopt;
237     return Optional&lt;Resolution&gt;(iterator-&gt;value);
238 }
239 
240 void AbstractModuleRecord::cacheResolution(UniquedStringImpl* exportName, const Resolution&amp; resolution)
241 {
242     m_resolutionCache.add(exportName, resolution);
243 }
244 
245 auto AbstractModuleRecord::resolveExportImpl(JSGlobalObject* globalObject, const ResolveQuery&amp; root) -&gt; Resolution
246 {
247     VM&amp; vm = globalObject-&gt;vm();
248     auto scope = DECLARE_THROW_SCOPE(vm);
249 
250     if (AbstractModuleRecordInternal::verbose)
251         dataLog(&quot;Resolving &quot;, root, &quot;\n&quot;);
252 
253     // https://tc39.github.io/ecma262/#sec-resolveexport
254 
255     // How to avoid C++ recursion in this function:
256     // This function avoids C++ recursion of the naive ResolveExport implementation.
257     // Flatten the recursion to the loop with the task queue and frames.
258     //
259     // 1. pendingTasks
260     //     We enqueue the recursive resolveExport call to this queue to avoid recursive calls in C++.
261     //     The task has 3 types. (1) Query, (2) IndirectFallback and (3) GatherStars.
262     //     (1) Query
263     //         Querying the resolution to the current module.
264     //     (2) IndirectFallback
265     //         Examine the result of the indirect export resolution. Only when the indirect export resolution fails,
266     //         we look into the star exports. (step 5-a-vi).
267     //     (3) GatherStars
268     //         Examine the result of the star export resolutions.
269     //
270     // 2. frames
271     //     When the spec calls the resolveExport recursively, instead we append the frame
272     //     (that holds the result resolution) to the frames and enqueue the task to the pendingTasks.
273     //     The entry in the frames means the *local* resolution result of the specific recursive resolveExport.
274     //
275     // We should maintain the local resolution result instead of holding the global resolution result only.
276     // For example,
277     //
278     //     star
279     // (1) ---&gt; (2) &quot;Resolve&quot;
280     //      |
281     //      |
282     //      +-&gt; (3) &quot;NotFound&quot;
283     //      |
284     //      |       star
285     //      +-&gt; (4) ---&gt; (5) &quot;Resolve&quot; [here]
286     //               |
287     //               |
288     //               +-&gt; (6) &quot;Error&quot;
289     //
290     // Consider the above graph. The numbers represents the modules. Now we are [here].
291     // If we only hold the global resolution result during the resolveExport operation, [here],
292     // we decide the entire result of resolveExport is &quot;Ambiguous&quot;, because there are multiple
293     // &quot;Resolve&quot; (in module (2) and (5)). However, this should become &quot;Error&quot; because (6) will
294     // propagate &quot;Error&quot; state to the (4), (4) will become &quot;Error&quot; and then, (1) will become
295     // &quot;Error&quot;. We should aggregate the results at the star exports point ((4) and (1)).
296     //
297     // Usually, both &quot;Error&quot; and &quot;Ambiguous&quot; states will throw the syntax error. So except for the content of the
298     // error message, there are no difference. (And if we fix the (6) that raises &quot;Error&quot;, next, it will produce
299     // the &quot;Ambiguous&quot; error due to (5). Anyway, user need to fix the both. So which error should be raised at first
300     // doesn&#39;t matter so much.
301     //
302     // However, this may become the problem under the module namespace creation.
303     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
304     // section 15.2.1.18, step 3-d-ii
305     // Here, we distinguish &quot;Ambiguous&quot; and &quot;Error&quot;. When &quot;Error&quot; state is produced, we need to throw the propagated error.
306     // But if &quot;Ambiguous&quot; state comes, we just ignore the result.
307     // To follow the requirement strictly, in this implementation, we keep the local resolution result to produce the
308     // correct result under the above complex cases.
309 
310     // Caching strategy:
311     // The resolveExport operation is frequently called. So caching results is important.
312     // We observe the following aspects and based on them construct the caching strategy.
313     // Here, we attempt to cache the resolution by constructing the map in module records.
314     // That means  Module -&gt; ExportName -&gt; Maybe&lt;Resolution&gt;.
315     // Technically, all the AbstractModuleRecords have the Map&lt;ExportName, Resolution&gt; for caching.
316     //
317     // The important observations are that,
318     //
319     //  - *cacheable* means that traversing to this node from a path will produce the same results as starting from this node.
320     //
321     //    Here, we define the resovling route. We represent [?] as the module that has the local binding.
322     //    And (?) as the module without the local binding.
323     //
324     //      @ -&gt; (A) -&gt; (B) -&gt; [C]
325     //
326     //    We list the resolving route for each node.
327     //
328     //    (A): (A) -&gt; (B) -&gt; [C]
329     //    (B): (B) -&gt; [C]
330     //    [C]: [C]
331     //
332     //    In this case, if we start the tracing from (B), the resolving route becomes (B) -&gt; [C].
333     //    So this is the same. At that time, we can say (B) is cacheable in the first tracing.
334     //
335     //  - The cache ability of a node depends on the resolving route from this node.
336     //
337     // 1. The starting point is always cacheable.
338     //
339     // 2. A module that has resolved a local binding is always cacheable.
340     //
341     //  @ -&gt; (A) -&gt; [B]
342     //
343     //  In the above case, we can see the [B] as cacheable.
344     //  This is because when starting from [B] node, we immediately resolve with the local binding.
345     //  So the resolving route from [B] does not depend on the starting point.
346     //
347     // 3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
348     //
349     //  If there are non star links, it means that there is *no branch* in the module dependency graph.
350     //  This *no branch* feature makes all the modules cachable.
351     //
352     //  I.e, if we traverse one star link (even if we successfully resolve that star link),
353     //  we must still traverse all other star links. I would also explain we don&#39;t run into
354     //  this when resolving a local/indirect link. When resolving a local/indirect link,
355     //  we won&#39;t traverse any star links.
356     //  And since the module can hold only one local/indirect link for the specific export name (if there
357     //  are multiple local/indirect links that has the same export name, it should be syntax error in the
358     //  parsing phase.), there is no multiple outgoing links from a module.
359     //
360     //  @ -&gt; (A) --&gt; (B) -&gt; [C] -&gt; (D) -&gt; (E) -+
361     //                ^                        |
362     //                |                        |
363     //                +------------------------+
364     //
365     //  When starting from @, [C] will be found as the module resolving the given binding.
366     //  In this case, (B) can cache this resolution. Since the resolving route is the same to the one when
367     //  starting from (B). After caching the above result, we attempt to resolve the same binding from (D).
368     //
369     //                              @
370     //                              |
371     //                              v
372     //  @ -&gt; (A) --&gt; (B) -&gt; [C] -&gt; (D) -&gt; (E) -+
373     //                ^                        |
374     //                |                        |
375     //                +------------------------+
376     //
377     //  In this case, we can use the (B)&#39;s cached result. And (E) can be cached.
378     //
379     //    (E): The resolving route is now (E) -&gt; (B) -&gt; [C]. That is the same when starting from (E).
380     //
381     //  No branching makes that the problematic *once-visited* node cannot be seen.
382     //  The *once-visited* node makes the resolving route changed since when we see the *once-visited* node,
383     //  we stop tracing this.
384     //
385     //  If there is no star links and if we look *once-visited* node under no branching graph, *once-visited*
386     //  node cannot resolve the requested binding. If the *once-visited* node can resolve the binding, we
387     //  should have already finished the resolution before reaching this *once-visited* node.
388     //
389     // 4. Once we follow star links, we should not retrieve the result from the cache and should not cache.
390     //
391     //  Star links are only the way to introduce branch.
392     //  Once we follow the star links during the resolution, we cannot cache naively.
393     //  This is because the cacheability depends on the resolving route. And branching produces the problematic *once-visited*
394     //  nodes. Since we don&#39;t follow the *once-visited* node, the resolving route from the node becomes different from
395     //  the resolving route when starting from this node.
396     //
397     //  The following example explains when we should not retrieve the cache and cache the result.
398     //
399     //               +----&gt; (D) ------+
400     //               |                |
401     //               |                v
402     //      (A) *----+----&gt; (B) ---&gt; [C]
403     //                       ^
404     //                       |
405     //                       @
406     //
407     //  When starting from (B), we find [C]. In this resolving route, we don&#39;t find any star link.
408     //  And by definition, (B) and [C] are cachable. (B) is the starting point. And [C] has the local binding.
409     //
410     //               +----&gt; (D) ------+
411     //               |                |
412     //               |                v
413     //  @-&gt; (A) *----+----&gt; (B) ---&gt; [C]
414     //
415     //  But when starting from (A), we should not get the value from the cache. Because,
416     //
417     //    1. When looking (D), we reach [C] and make both resolved.
418     //    2. When looking (B), if we retrieved the last cache from (B), (B) becomes resolved.
419     //    3. But actually, (B) is not-found in this trial because (C) is already *once-visited*.
420     //    4. If we accidentally make (B) resolved, (A) becomes ambiguous. But the correct answer is resolved.
421     //
422     //  Why is this problem caused? This is because the *once-visited* node makes the result not-found.
423     //  In the second trial, (B) -&gt; [C] result is changed from resolved to not-found.
424     //
425     //  When does this become a problem? If the status of the *once-visited* node group is resolved,
426     //  changing the result to not-found makes the result changed.
427     //
428     //  This problem does not happen when we don&#39;t see any star link yet. Now, consider the minimum case.
429     //
430     //  @-&gt; (A) -&gt; [ some graph ]
431     //       ^            |
432     //       |            |
433     //       +------------+
434     //
435     //  In (A), we don&#39;t see any star link yet. So we can say that all the visited nodes does not have any local
436     //  resolution. Because if they had a local/indirect resolution, we should have already finished the tracing.
437     //
438     //  And even if the some graph will see the *once-visited* node (in this case, (A)), that does not affect the
439     //  result of the resolution. Because even if we follow the link to (A) or not follow the link to (A), the status
440     //  of the link is always not-found since (A) does not have any local resolution.
441     //  In the above case, we can use the result of the [some graph].
442     //
443     // 5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
444     //
445     //  Here is the reason why:
446     //
447     //       +-------------+
448     //       |             |
449     //       v             |
450     //      (A) -&gt; (B) -&gt; (C) *-&gt; [E]
451     //       *             ^
452     //       |             |
453     //       v             @
454     //      [D]
455     //
456     //  In the above case, (C) will be resolved with [D].
457     //  (C) will see (A) and (A) gives up in (A) -&gt; (B) -&gt; (C) route. So, (A) will fallback to [D].
458     //
459     //       +-------------+
460     //       |             |
461     //       v             |
462     //  @-&gt; (A) -&gt; (B) -&gt; (C) *-&gt; [E]
463     //       *
464     //       |
465     //       v
466     //      [D]
467     //
468     //  But in this case, (A) will be resolved with [E] (not [D]).
469     //  (C) will attempt to follow the link to (A), but it fails.
470     //  So (C) will fallback to the star link and found [E]. In this senario,
471     //  (C) is now resolved with [E]&#39;s result.
472     //
473     //  The cause of this problem is also the same to 4.
474     //  In the latter case, when looking (C), we cannot use the cached result in (C).
475     //  Because the cached result of (C) depends on the *once-visited* node (A) and
476     //  (A) has the fallback system with the star link.
477     //  In the latter trial, we now assume that (A)&#39;s status is not-found.
478     //  But, actually, in the former trial, (A)&#39;s status becomes resolved due to the fallback to the [D].
479     //
480     // To summarize the observations.
481     //
482     //  1. The starting point is always cacheable.
483     //  2. A module that has resolved a local binding is always cacheable.
484     //  3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
485     //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
486     //  5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
487 
488     using ResolveSet = WTF::HashSet&lt;ResolveQuery, ResolveQuery::Hash, ResolveQuery::HashTraits&gt;;
489     enum class Type { Query, IndirectFallback, GatherStars };
490     struct Task {
491         ResolveQuery query;
492         Type type;
493     };
494 
495     auto typeString = [] (Type type) -&gt; const char* {
496         switch (type) {
497         case Type::Query:
498             return &quot;Query&quot;;
499         case Type::IndirectFallback:
500             return &quot;IndirectFallback&quot;;
501         case Type::GatherStars:
502             return &quot;GatherStars&quot;;
503         }
504         RELEASE_ASSERT_NOT_REACHED();
505         return nullptr;
506     };
507 
508     Vector&lt;Task, 8&gt; pendingTasks;
509     ResolveSet resolveSet;
510 
511     Vector&lt;Resolution, 8&gt; frames;
512 
513     bool foundStarLinks = false;
514 
515     frames.append(Resolution::notFound());
516 
517     // Call when the query is not resolved in the current module.
518     // It will enqueue the star resolution requests. Return &quot;false&quot; if the error occurs.
519     auto resolveNonLocal = [&amp;](const ResolveQuery&amp; query) -&gt; bool {
520         // https://tc39.github.io/ecma262/#sec-resolveexport
521         // section 15.2.1.16.3, step 6
522         // If the &quot;default&quot; name is not resolved in the current module, we need to throw an error and stop resolution immediately,
523         // Rationale to this error: A default export cannot be provided by an export *.
524         VM&amp; vm = globalObject-&gt;vm();
525         auto scope = DECLARE_THROW_SCOPE(vm);
526         if (query.exportName == vm.propertyNames-&gt;defaultKeyword.impl())
527             return false;
528 
529         // Enqueue the task to gather the results of the stars.
530         // And append the new Resolution frame to gather the local result of the stars.
531         pendingTasks.append(Task { query, Type::GatherStars });
532         foundStarLinks = true;
533         frames.append(Resolution::notFound());
534 
535         // Enqueue the tasks in reverse order.
536         for (auto iterator = query.moduleRecord-&gt;starExportEntries().rbegin(), end = query.moduleRecord-&gt;starExportEntries().rend(); iterator != end; ++iterator) {
537             const RefPtr&lt;UniquedStringImpl&gt;&amp; starModuleName = *iterator;
538             AbstractModuleRecord* importedModuleRecord = query.moduleRecord-&gt;hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));
539             RETURN_IF_EXCEPTION(scope, false);
540             pendingTasks.append(Task { ResolveQuery(importedModuleRecord, query.exportName.get()), Type::Query });
541         }
542         return true;
543     };
544 
545     // Return the current resolution value of the top frame.
546     auto currentTop = [&amp;] () -&gt; Resolution&amp; {
547         ASSERT(!frames.isEmpty());
548         return frames.last();
549     };
550 
551     // Merge the given resolution to the current resolution value of the top frame.
552     // If there is ambiguity, return &quot;false&quot;. When the &quot;false&quot; is returned, we should make the result &quot;ambiguous&quot;.
553     auto mergeToCurrentTop = [&amp;] (const Resolution&amp; resolution) -&gt; bool {
554         if (resolution.type == Resolution::Type::NotFound)
555             return true;
556 
557         if (currentTop().type == Resolution::Type::NotFound) {
558             currentTop() = resolution;
559             return true;
560         }
561 
562         if (currentTop().moduleRecord != resolution.moduleRecord || currentTop().localName != resolution.localName)
563             return false;
564 
565         return true;
566     };
567 
568     auto cacheResolutionForQuery = [] (const ResolveQuery&amp; query, const Resolution&amp; resolution) {
569         ASSERT(resolution.type == Resolution::Type::Resolved);
570         query.moduleRecord-&gt;cacheResolution(query.exportName.get(), resolution);
571     };
572 
573     pendingTasks.append(Task { root, Type::Query });
574     while (!pendingTasks.isEmpty()) {
575         const Task task = pendingTasks.takeLast();
576         const ResolveQuery&amp; query = task.query;
577 
578         if (AbstractModuleRecordInternal::verbose)
579             dataLog(&quot;    &quot;, typeString(task.type), &quot; &quot;, task.query, &quot;\n&quot;);
580 
581         switch (task.type) {
582         case Type::Query: {
583             AbstractModuleRecord* moduleRecord = query.moduleRecord;
584 
585             if (!resolveSet.add(task.query).isNewEntry)
586                 continue;
587 
588             //  5. Once we see star links, even if we have not yet traversed that star link path, we should disable caching.
589             if (!moduleRecord-&gt;starExportEntries().isEmpty())
590                 foundStarLinks = true;
591 
592             //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
593             if (!foundStarLinks) {
594                 if (Optional&lt;Resolution&gt; cachedResolution = moduleRecord-&gt;tryGetCachedResolution(query.exportName.get())) {
595                     if (!mergeToCurrentTop(*cachedResolution))
596                         return Resolution::ambiguous();
597                     continue;
598                 }
599             }
600 
601             const Optional&lt;ExportEntry&gt; optionalExportEntry = moduleRecord-&gt;tryGetExportEntry(query.exportName.get());
602             if (!optionalExportEntry) {
603                 // If there is no matched exported binding in the current module,
604                 // we need to look into the stars.
605                 bool success = resolveNonLocal(task.query);
606                 EXCEPTION_ASSERT(!scope.exception() || !success);
607                 if (!success)
608                     return Resolution::error();
609                 continue;
610             }
611 
612             const ExportEntry&amp; exportEntry = *optionalExportEntry;
613             switch (exportEntry.type) {
614             case ExportEntry::Type::Local: {
615                 ASSERT(!exportEntry.localName.isNull());
616                 Resolution resolution { Resolution::Type::Resolved, moduleRecord, exportEntry.localName };
617                 //  2. A module that has resolved a local binding is always cacheable.
618                 cacheResolutionForQuery(query, resolution);
619                 if (!mergeToCurrentTop(resolution))
620                     return Resolution::ambiguous();
621                 continue;
622             }
623 
624             case ExportEntry::Type::Indirect: {
625                 AbstractModuleRecord* importedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(globalObject, exportEntry.moduleName);
626                 RETURN_IF_EXCEPTION(scope, Resolution::error());
627 
628                 // When the imported module does not produce any resolved binding, we need to look into the stars in the *current*
629                 // module. To do this, we append the `IndirectFallback` task to the task queue.
630                 pendingTasks.append(Task { query, Type::IndirectFallback });
631                 // And append the new Resolution frame to check the indirect export will be resolved or not.
632                 frames.append(Resolution::notFound());
633                 pendingTasks.append(Task { ResolveQuery(importedModuleRecord, exportEntry.importName), Type::Query });
634                 continue;
635             }
636             }
637             break;
638         }
639 
640         case Type::IndirectFallback: {
641             Resolution resolution = frames.takeLast();
642 
643             if (resolution.type == Resolution::Type::NotFound) {
644                 // Indirect export entry does not produce any resolved binding.
645                 // So we will investigate the stars.
646                 bool success = resolveNonLocal(task.query);
647                 EXCEPTION_ASSERT(!scope.exception() || !success);
648                 if (!success)
649                     return Resolution::error();
650                 continue;
651             }
652 
653             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved comes.&quot;);
654 
655             //  3. If we don&#39;t follow any star links during the resolution, we can see all the traced nodes are cacheable.
656             //  4. Once we follow star links, we should not retrieve the result from the cache and should not cache the result.
657             if (!foundStarLinks)
658                 cacheResolutionForQuery(query, resolution);
659 
660             // If indirect export entry produces Resolved, we should merge it to the upper frame.
661             // And do not investigate the stars of the current module.
662             if (!mergeToCurrentTop(resolution))
663                 return Resolution::ambiguous();
664             break;
665         }
666 
667         case Type::GatherStars: {
668             Resolution resolution = frames.takeLast();
669             ASSERT_WITH_MESSAGE(resolution.type == Resolution::Type::Resolved || resolution.type == Resolution::Type::NotFound, &quot;When we see Error and Ambiguous, we immediately return from this loop. So here, only Resolved and NotFound comes.&quot;);
670 
671             // Merge the star resolution to the upper frame.
672             if (!mergeToCurrentTop(resolution))
673                 return Resolution::ambiguous();
674             break;
675         }
676         }
677     }
678 
679     ASSERT(frames.size() == 1);
680     //  1. The starting point is always cacheable.
681     if (frames[0].type == Resolution::Type::Resolved)
682         cacheResolutionForQuery(root, frames[0]);
683     return frames[0];
684 }
685 
686 auto AbstractModuleRecord::resolveExport(JSGlobalObject* globalObject, const Identifier&amp; exportName) -&gt; Resolution
687 {
688     // Look up the cached resolution first before entering the resolving loop, since the loop setup takes some cost.
689     if (Optional&lt;Resolution&gt; cachedResolution = tryGetCachedResolution(exportName.impl()))
690         return *cachedResolution;
691     return resolveExportImpl(globalObject, ResolveQuery(this, exportName.impl()));
692 }
693 
694 static void getExportedNames(JSGlobalObject* globalObject, AbstractModuleRecord* root, IdentifierSet&amp; exportedNames)
695 {
696     VM&amp; vm = globalObject-&gt;vm();
697     auto scope = DECLARE_THROW_SCOPE(vm);
698 
699     HashSet&lt;AbstractModuleRecord*&gt; exportStarSet;
700     Vector&lt;AbstractModuleRecord*, 8&gt; pendingModules;
701 
702     pendingModules.append(root);
703 
704     while (!pendingModules.isEmpty()) {
705         AbstractModuleRecord* moduleRecord = pendingModules.takeLast();
706         if (exportStarSet.contains(moduleRecord))
707             continue;
708         exportStarSet.add(moduleRecord);
709 
710         for (const auto&amp; pair : moduleRecord-&gt;exportEntries()) {
711             const AbstractModuleRecord::ExportEntry&amp; exportEntry = pair.value;
712             if (moduleRecord == root || vm.propertyNames-&gt;defaultKeyword != exportEntry.exportName)
713                 exportedNames.add(exportEntry.exportName.impl());
714         }
715 
716         for (const auto&amp; starModuleName : moduleRecord-&gt;starExportEntries()) {
717             AbstractModuleRecord* requestedModuleRecord = moduleRecord-&gt;hostResolveImportedModule(globalObject, Identifier::fromUid(vm, starModuleName.get()));
718             RETURN_IF_EXCEPTION(scope, void());
719             pendingModules.append(requestedModuleRecord);
720         }
721     }
722 }
723 
724 JSModuleNamespaceObject* AbstractModuleRecord::getModuleNamespace(JSGlobalObject* globalObject)
725 {
726     VM&amp; vm = globalObject-&gt;vm();
727     auto scope = DECLARE_THROW_SCOPE(vm);
728 
729     // http://www.ecma-international.org/ecma-262/6.0/#sec-getmodulenamespace
730     if (m_moduleNamespaceObject)
731         return m_moduleNamespaceObject.get();
732 
733     IdentifierSet exportedNames;
734     getExportedNames(globalObject, this, exportedNames);
735     RETURN_IF_EXCEPTION(scope, nullptr);
736 
737     Vector&lt;std::pair&lt;Identifier, Resolution&gt;&gt; resolutions;
738     for (auto&amp; name : exportedNames) {
739         Identifier ident = Identifier::fromUid(vm, name.get());
740         const Resolution resolution = resolveExport(globalObject, ident);
741         RETURN_IF_EXCEPTION(scope, nullptr);
742         switch (resolution.type) {
743         case Resolution::Type::NotFound:
744             throwSyntaxError(globalObject, scope, makeString(&quot;Exported binding name &#39;&quot;, String(name.get()), &quot;&#39; is not found.&quot;));
745             return nullptr;
746 
747         case Resolution::Type::Error:
748             throwSyntaxError(globalObject, scope, makeString(&quot;Exported binding name &#39;default&#39; cannot be resolved by star export entries.&quot;));
749             return nullptr;
750 
751         case Resolution::Type::Ambiguous:
752             break;
753 
754         case Resolution::Type::Resolved:
755             resolutions.append({ WTFMove(ident), resolution });
756             break;
757         }
758     }
759 
760     auto* moduleNamespaceObject = JSModuleNamespaceObject::create(globalObject, globalObject-&gt;moduleNamespaceObjectStructure(), this, WTFMove(resolutions));
761     RETURN_IF_EXCEPTION(scope, nullptr);
762     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
763     return moduleNamespaceObject;
764 }
765 
766 void AbstractModuleRecord::link(JSGlobalObject* globalObject, JSValue scriptFetcher)
767 {
768     VM&amp; vm = globalObject-&gt;vm();
769     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
770         return jsModuleRecord-&gt;link(globalObject, scriptFetcher);
771 #if ENABLE(WEBASSEMBLY)
772     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
773         return wasmModuleRecord-&gt;link(globalObject, scriptFetcher, nullptr, Wasm::CreationMode::FromModuleLoader);
774 #endif
775     RELEASE_ASSERT_NOT_REACHED();
776 }
777 
778 JS_EXPORT_PRIVATE JSValue AbstractModuleRecord::evaluate(JSGlobalObject* globalObject)
779 {
780     VM&amp; vm = globalObject-&gt;vm();
781     if (auto* jsModuleRecord = jsDynamicCast&lt;JSModuleRecord*&gt;(vm, this))
782         return jsModuleRecord-&gt;evaluate(globalObject);
783 #if ENABLE(WEBASSEMBLY)
784     if (auto* wasmModuleRecord = jsDynamicCast&lt;WebAssemblyModuleRecord*&gt;(vm, this))
785         return wasmModuleRecord-&gt;evaluate(globalObject);
786 #endif
787     RELEASE_ASSERT_NOT_REACHED();
788     return jsUndefined();
789 }
790 
791 static String printableName(const RefPtr&lt;UniquedStringImpl&gt;&amp; uid)
792 {
793     if (uid-&gt;isSymbol())
794         return uid.get();
795     return WTF::makeString(&quot;&#39;&quot;, String(uid.get()), &quot;&#39;&quot;);
796 }
797 
798 static String printableName(const Identifier&amp; ident)
799 {
800     return printableName(ident.impl());
801 }
802 
803 void AbstractModuleRecord::dump()
804 {
805     dataLog(&quot;\nAnalyzing ModuleRecord key(&quot;, printableName(m_moduleKey), &quot;)\n&quot;);
806 
807     dataLog(&quot;    Dependencies: &quot;, m_requestedModules.size(), &quot; modules\n&quot;);
808     for (const auto&amp; moduleName : m_requestedModules)
809         dataLog(&quot;      module(&quot;, printableName(moduleName), &quot;)\n&quot;);
810 
811     dataLog(&quot;    Import: &quot;, m_importEntries.size(), &quot; entries\n&quot;);
812     for (const auto&amp; pair : m_importEntries) {
813         const ImportEntry&amp; importEntry = pair.value;
814         dataLog(&quot;      import(&quot;, printableName(importEntry.importName), &quot;), local(&quot;, printableName(importEntry.localName), &quot;), module(&quot;, printableName(importEntry.moduleRequest), &quot;)\n&quot;);
815     }
816 
817     dataLog(&quot;    Export: &quot;, m_exportEntries.size(), &quot; entries\n&quot;);
818     for (const auto&amp; pair : m_exportEntries) {
819         const ExportEntry&amp; exportEntry = pair.value;
820         switch (exportEntry.type) {
821         case ExportEntry::Type::Local:
822             dataLog(&quot;      [Local] &quot;, &quot;export(&quot;, printableName(exportEntry.exportName), &quot;), local(&quot;, printableName(exportEntry.localName), &quot;)\n&quot;);
823             break;
824 
825         case ExportEntry::Type::Indirect:
826             dataLog(&quot;      [Indirect] &quot;, &quot;export(&quot;, printableName(exportEntry.exportName), &quot;), import(&quot;, printableName(exportEntry.importName), &quot;), module(&quot;, printableName(exportEntry.moduleName), &quot;)\n&quot;);
827             break;
828         }
829     }
830     for (const auto&amp; moduleName : m_starExportEntries)
831         dataLog(&quot;      [Star] module(&quot;, printableName(moduleName.get()), &quot;)\n&quot;);
832 }
833 
834 } // namespace JSC
    </pre>
  </body>
</html>
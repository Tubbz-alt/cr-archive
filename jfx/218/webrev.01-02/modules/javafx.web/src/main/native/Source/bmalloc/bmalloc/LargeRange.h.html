<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/LargeRange.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef LargeRange_h
 27 #define LargeRange_h
 28 
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;Range.h&quot;
 31 
 32 namespace bmalloc {
 33 
 34 class LargeRange : public Range {
 35 public:
 36     LargeRange()
 37         : Range()
 38         , m_startPhysicalSize(0)
 39         , m_totalPhysicalSize(0)
 40 #if !BUSE(PARTIAL_SCAVENGE)
 41         , m_isEligible(true)
 42         , m_usedSinceLastScavenge(false)
 43 #endif
 44     {
 45     }
 46 
 47     LargeRange(const Range&amp; other, size_t startPhysicalSize, size_t totalPhysicalSize)
 48         : Range(other)
 49         , m_startPhysicalSize(startPhysicalSize)
 50         , m_totalPhysicalSize(totalPhysicalSize)
 51 #if !BUSE(PARTIAL_SCAVENGE)
 52         , m_isEligible(true)
 53         , m_usedSinceLastScavenge(false)
 54 #endif
 55     {
 56         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 57         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 58     }
 59 
 60 #if BUSE(PARTIAL_SCAVENGE)
 61     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize)
 62         : Range(begin, size)
 63         , m_startPhysicalSize(startPhysicalSize)
 64         , m_totalPhysicalSize(totalPhysicalSize)
 65     {
 66         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 67         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 68     }
 69 #else
 70     LargeRange(void* begin, size_t size, size_t startPhysicalSize, size_t totalPhysicalSize, bool usedSinceLastScavenge = false)
 71         : Range(begin, size)
 72         , m_startPhysicalSize(startPhysicalSize)
 73         , m_totalPhysicalSize(totalPhysicalSize)
 74         , m_isEligible(true)
 75         , m_usedSinceLastScavenge(usedSinceLastScavenge)
 76     {
 77         BASSERT(this-&gt;size() &gt;= this-&gt;totalPhysicalSize());
 78         BASSERT(this-&gt;totalPhysicalSize() &gt;= this-&gt;startPhysicalSize());
 79     }
 80 #endif
 81 
 82     // Returns a lower bound on physical size at the start of the range. Ranges that
 83     // span non-physical fragments use this number to remember the physical size of
 84     // the first fragment.
 85     size_t startPhysicalSize() const { return m_startPhysicalSize; }
 86     void setStartPhysicalSize(size_t startPhysicalSize) { m_startPhysicalSize = startPhysicalSize; }
 87 
 88     // This is accurate in the sense that if you take a range A and split it N ways
 89     // and sum totalPhysicalSize over each of the N splits, you&#39;ll end up with A&#39;s
 90     // totalPhysicalSize. This means if you take a LargeRange out of a LargeMap, split it,
 91     // then insert the subsequent two ranges back into the LargeMap, the sum of the
 92     // totalPhysicalSize of each LargeRange in the LargeMap will stay constant. This
 93     // property is not true of startPhysicalSize. This invariant about totalPhysicalSize
 94     // is good enough to get an accurate footprint estimate for memory used in bmalloc.
 95     // The reason this is just an estimate is that splitting LargeRanges may lead to this
 96     // number being rebalanced in arbitrary ways between the two resulting ranges. This
 97     // is why the footprint is just an estimate. In practice, this arbitrary rebalance
 98     // doesn&#39;t really affect accuracy.
 99     size_t totalPhysicalSize() const { return m_totalPhysicalSize; }
100     void setTotalPhysicalSize(size_t totalPhysicalSize) { m_totalPhysicalSize = totalPhysicalSize; }
101 
102     std::pair&lt;LargeRange, LargeRange&gt; split(size_t) const;
103 
104     void setEligible(bool eligible) { m_isEligible = eligible; }
105     bool isEligibile() const { return m_isEligible; }
106 
107 #if !BUSE(PARTIAL_SCAVENGE)
108     bool usedSinceLastScavenge() const { return m_usedSinceLastScavenge; }
109     void clearUsedSinceLastScavenge() { m_usedSinceLastScavenge = false; }
110     void setUsedSinceLastScavenge() { m_usedSinceLastScavenge = true; }
111 #endif
112 
113     bool operator&lt;(const void* other) const { return begin() &lt; other; }
114     bool operator&lt;(const LargeRange&amp; other) const { return begin() &lt; other.begin(); }
115 
116 private:
117     size_t m_startPhysicalSize;
118     size_t m_totalPhysicalSize;
119 #if BUSE(PARTIAL_SCAVENGE)
120     bool m_isEligible { true };
121 #else
122     unsigned m_isEligible: 1;
123     unsigned m_usedSinceLastScavenge: 1;
124 #endif
125 };
126 
127 inline bool canMerge(const LargeRange&amp; a, const LargeRange&amp; b)
128 {
129     if (!a.isEligibile() || !b.isEligibile()) {
130         // FIXME: We can make this work if we find it&#39;s helpful as long as the merged
131         // range is only eligible if a and b are eligible.
132         return false;
133     }
134 
135     if (a.end() == b.begin())
136         return true;
137 
138     if (b.end() == a.begin())
139         return true;
140 
141     return false;
142 }
143 
144 inline LargeRange merge(const LargeRange&amp; a, const LargeRange&amp; b)
145 {
146     const LargeRange&amp; left = std::min(a, b);
147 #if !BUSE(PARTIAL_SCAVENGE)
148     bool mergedUsedSinceLastScavenge = a.usedSinceLastScavenge() || b.usedSinceLastScavenge();
149 #endif
150     if (left.size() == left.startPhysicalSize()) {
151         return LargeRange(
152             left.begin(),
153             a.size() + b.size(),
154             a.startPhysicalSize() + b.startPhysicalSize(),
155             a.totalPhysicalSize() + b.totalPhysicalSize()
156 #if !BUSE(PARTIAL_SCAVENGE)
157             , mergedUsedSinceLastScavenge
158 #endif
159         );
160 
161     }
162 
163     return LargeRange(
164         left.begin(),
165         a.size() + b.size(),
166         left.startPhysicalSize(),
167         a.totalPhysicalSize() + b.totalPhysicalSize()
168 #if !BUSE(PARTIAL_SCAVENGE)
169         , mergedUsedSinceLastScavenge
170 #endif
171     );
172 }
173 
174 inline std::pair&lt;LargeRange, LargeRange&gt; LargeRange::split(size_t leftSize) const
175 {
176     BASSERT(leftSize &lt;= this-&gt;size());
177     size_t rightSize = this-&gt;size() - leftSize;
178 
179     if (leftSize &lt;= startPhysicalSize()) {
180         BASSERT(totalPhysicalSize() &gt;= leftSize);
181         LargeRange left(begin(), leftSize, leftSize, leftSize);
182         LargeRange right(left.end(), rightSize, startPhysicalSize() - leftSize, totalPhysicalSize() - leftSize);
183         return std::make_pair(left, right);
184     }
185 
186     double ratio = static_cast&lt;double&gt;(leftSize) / static_cast&lt;double&gt;(this-&gt;size());
187     size_t leftTotalPhysicalSize = static_cast&lt;size_t&gt;(ratio * totalPhysicalSize());
188     BASSERT(leftTotalPhysicalSize &lt;= leftSize);
189     leftTotalPhysicalSize = std::max(startPhysicalSize(), leftTotalPhysicalSize);
190     size_t rightTotalPhysicalSize = totalPhysicalSize() - leftTotalPhysicalSize;
191     if (rightTotalPhysicalSize &gt; rightSize) { // This may happen because of rounding.
192         leftTotalPhysicalSize += rightTotalPhysicalSize - rightSize;
193         BASSERT(leftTotalPhysicalSize &lt;= leftSize);
194         rightTotalPhysicalSize = rightSize;
195     }
196 
197     LargeRange left(begin(), leftSize, startPhysicalSize(), leftTotalPhysicalSize);
198     LargeRange right(left.end(), rightSize, 0, rightTotalPhysicalSize);
199     return std::make_pair(left, right);
200 }
201 
202 } // namespace bmalloc
203 
204 #endif // LargeRange_h
    </pre>
  </body>
</html>
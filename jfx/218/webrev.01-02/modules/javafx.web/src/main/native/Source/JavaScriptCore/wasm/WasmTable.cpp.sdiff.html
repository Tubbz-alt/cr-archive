<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmStreamingParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmTable.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 42 
 43 void Table::setLength(uint32_t length)
 44 {
 45     m_length = length;
 46     m_mask = WTF::maskForSize(length);
 47     ASSERT(isValidLength(length));
 48     ASSERT(m_mask == WTF::maskForSize(allocatedLength(length)));
 49 }
 50 
 51 Table::Table(uint32_t initial, Optional&lt;uint32_t&gt; maximum, TableElementType type)
 52     : m_type(type)
 53     , m_maximum(maximum)
 54     , m_owner(nullptr)
 55 {
 56     setLength(initial);
 57     ASSERT(!m_maximum || *m_maximum &gt;= m_length);
 58 
 59     // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
 60     // But for now, we&#39;re not doing that.
 61     // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified"> 62     m_jsValues = MallocPtr&lt;WriteBarrier&lt;Unknown&gt;&gt;::malloc((sizeof(WriteBarrier&lt;Unknown&gt;) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
 63     for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
 64         new (&amp;m_jsValues.get()[i]) WriteBarrier&lt;Unknown&gt;();
 65         m_jsValues.get()[i].setStartingValue(jsNull());
 66     }
 67 }
 68 
 69 RefPtr&lt;Table&gt; Table::tryCreate(uint32_t initial, Optional&lt;uint32_t&gt; maximum, TableElementType type)
 70 {
 71     if (!isValidLength(initial))
 72         return nullptr;
 73     switch (type) {
 74     case TableElementType::Funcref:
 75         return adoptRef(new FuncRefTable(initial, maximum));
 76     case TableElementType::Anyref:
 77         return adoptRef(new Table(initial, maximum));
 78     }
 79 
 80     RELEASE_ASSERT_NOT_REACHED();
 81 }
 82 
</pre>
<hr />
<pre>
160 }
161 
162 void Table::visitAggregate(SlotVisitor&amp; visitor)
163 {
164     RELEASE_ASSERT(m_owner);
165     auto locker = holdLock(m_owner-&gt;cellLock());
166     for (unsigned i = 0; i &lt; m_length; ++i)
167         visitor.append(m_jsValues.get()[i]);
168 }
169 
170 FuncRefTable* Table::asFuncrefTable()
171 {
172     return m_type == TableElementType::Funcref ? static_cast&lt;FuncRefTable*&gt;(this) : nullptr;
173 }
174 
175 FuncRefTable::FuncRefTable(uint32_t initial, Optional&lt;uint32_t&gt; maximum)
176     : Table(initial, maximum, TableElementType::Funcref)
177 {
178     // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
179     // But for now, we&#39;re not doing that.
<span class="line-modified">180     m_importableFunctions = MallocPtr&lt;WasmToWasmImportableFunction&gt;::malloc((sizeof(WasmToWasmImportableFunction) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
181     // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">182     m_instances = MallocPtr&lt;Instance*&gt;::malloc((sizeof(Instance*) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
183     for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
184         new (&amp;m_importableFunctions.get()[i]) WasmToWasmImportableFunction();
185         ASSERT(m_importableFunctions.get()[i].signatureIndex == Wasm::Signature::invalidIndex); // We rely on this in compiled code.
186         m_instances.get()[i] = nullptr;
187     }
188 }
189 
190 void FuncRefTable::setFunction(uint32_t index, JSObject* optionalWrapper, WasmToWasmImportableFunction function, Instance* instance)
191 {
192     RELEASE_ASSERT(index &lt; length());
193     RELEASE_ASSERT(m_owner);
194     clear(index);
195     if (optionalWrapper)
196         m_jsValues.get()[index &amp; m_mask].set(m_owner-&gt;vm(), m_owner, optionalWrapper);
197     m_importableFunctions.get()[index &amp; m_mask] = function;
198     m_instances.get()[index &amp; m_mask] = instance;
199 }
200 










201 } } // namespace JSC::Table
202 
203 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 42 
 43 void Table::setLength(uint32_t length)
 44 {
 45     m_length = length;
 46     m_mask = WTF::maskForSize(length);
 47     ASSERT(isValidLength(length));
 48     ASSERT(m_mask == WTF::maskForSize(allocatedLength(length)));
 49 }
 50 
 51 Table::Table(uint32_t initial, Optional&lt;uint32_t&gt; maximum, TableElementType type)
 52     : m_type(type)
 53     , m_maximum(maximum)
 54     , m_owner(nullptr)
 55 {
 56     setLength(initial);
 57     ASSERT(!m_maximum || *m_maximum &gt;= m_length);
 58 
 59     // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
 60     // But for now, we&#39;re not doing that.
 61     // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified"> 62     m_jsValues = MallocPtr&lt;WriteBarrier&lt;Unknown&gt;, VMMalloc&gt;::malloc((sizeof(WriteBarrier&lt;Unknown&gt;) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
 63     for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
 64         new (&amp;m_jsValues.get()[i]) WriteBarrier&lt;Unknown&gt;();
 65         m_jsValues.get()[i].setStartingValue(jsNull());
 66     }
 67 }
 68 
 69 RefPtr&lt;Table&gt; Table::tryCreate(uint32_t initial, Optional&lt;uint32_t&gt; maximum, TableElementType type)
 70 {
 71     if (!isValidLength(initial))
 72         return nullptr;
 73     switch (type) {
 74     case TableElementType::Funcref:
 75         return adoptRef(new FuncRefTable(initial, maximum));
 76     case TableElementType::Anyref:
 77         return adoptRef(new Table(initial, maximum));
 78     }
 79 
 80     RELEASE_ASSERT_NOT_REACHED();
 81 }
 82 
</pre>
<hr />
<pre>
160 }
161 
162 void Table::visitAggregate(SlotVisitor&amp; visitor)
163 {
164     RELEASE_ASSERT(m_owner);
165     auto locker = holdLock(m_owner-&gt;cellLock());
166     for (unsigned i = 0; i &lt; m_length; ++i)
167         visitor.append(m_jsValues.get()[i]);
168 }
169 
170 FuncRefTable* Table::asFuncrefTable()
171 {
172     return m_type == TableElementType::Funcref ? static_cast&lt;FuncRefTable*&gt;(this) : nullptr;
173 }
174 
175 FuncRefTable::FuncRefTable(uint32_t initial, Optional&lt;uint32_t&gt; maximum)
176     : Table(initial, maximum, TableElementType::Funcref)
177 {
178     // FIXME: It might be worth trying to pre-allocate maximum here. The spec recommends doing so.
179     // But for now, we&#39;re not doing that.
<span class="line-modified">180     m_importableFunctions = MallocPtr&lt;WasmToWasmImportableFunction, VMMalloc&gt;::malloc((sizeof(WasmToWasmImportableFunction) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
181     // FIXME this over-allocates and could be smarter about not committing all of that memory https://bugs.webkit.org/show_bug.cgi?id=181425
<span class="line-modified">182     m_instances = MallocPtr&lt;Instance*, VMMalloc&gt;::malloc((sizeof(Instance*) * Checked&lt;size_t&gt;(allocatedLength(m_length))).unsafeGet());</span>
183     for (uint32_t i = 0; i &lt; allocatedLength(m_length); ++i) {
184         new (&amp;m_importableFunctions.get()[i]) WasmToWasmImportableFunction();
185         ASSERT(m_importableFunctions.get()[i].signatureIndex == Wasm::Signature::invalidIndex); // We rely on this in compiled code.
186         m_instances.get()[i] = nullptr;
187     }
188 }
189 
190 void FuncRefTable::setFunction(uint32_t index, JSObject* optionalWrapper, WasmToWasmImportableFunction function, Instance* instance)
191 {
192     RELEASE_ASSERT(index &lt; length());
193     RELEASE_ASSERT(m_owner);
194     clear(index);
195     if (optionalWrapper)
196         m_jsValues.get()[index &amp; m_mask].set(m_owner-&gt;vm(), m_owner, optionalWrapper);
197     m_importableFunctions.get()[index &amp; m_mask] = function;
198     m_instances.get()[index &amp; m_mask] = instance;
199 }
200 
<span class="line-added">201 const WasmToWasmImportableFunction&amp; FuncRefTable::function(uint32_t index) const</span>
<span class="line-added">202 {</span>
<span class="line-added">203     return m_importableFunctions.get()[index &amp; m_mask];</span>
<span class="line-added">204 }</span>
<span class="line-added">205 </span>
<span class="line-added">206 Instance* FuncRefTable::instance(uint32_t index) const</span>
<span class="line-added">207 {</span>
<span class="line-added">208     return m_instances.get()[index &amp; m_mask];</span>
<span class="line-added">209 }</span>
<span class="line-added">210 </span>
211 } } // namespace JSC::Table
212 
213 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmStreamingParser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmTable.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
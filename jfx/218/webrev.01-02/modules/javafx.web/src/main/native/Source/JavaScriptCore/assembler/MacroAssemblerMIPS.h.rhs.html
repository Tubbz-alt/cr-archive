<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerMIPS.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 MIPS Technologies, Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY MIPS TECHNOLOGIES, INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MIPS TECHNOLOGIES, INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
  30 
  31 #include &quot;MIPSAssembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerMIPS : public AbstractMacroAssembler&lt;Assembler&gt; {
  39 public:
  40     typedef MIPSRegisters::FPRegisterID FPRegisterID;
<a name="2" id="anc2"></a><span class="line-modified">  41     static constexpr unsigned numGPRs = 32;</span>
<span class="line-modified">  42     static constexpr unsigned numFPRs = 32;</span>
  43 
  44     MacroAssemblerMIPS()
  45         : m_fixedWidth(false)
  46     {
  47     }
  48 
  49     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  50     {
  51         return value &gt;= -2147483647 - 1 &amp;&amp; value &lt;= 2147483647;
  52     }
  53 
  54     inline bool isPowerOf2(int32_t v)
  55     {
  56         return hasOneBitSet(v);
  57     }
  58 
  59     inline int bitPosition(int32_t v)
  60     {
  61         return getLSBSet(v);
  62     }
  63 
<a name="3" id="anc3"></a><span class="line-modified">  64     static constexpr Scale ScalePtr = TimesFour;</span>
  65 
  66     // For storing immediate number
<a name="4" id="anc4"></a><span class="line-modified">  67     static constexpr RegisterID immTempRegister = MIPSRegisters::t0;</span>
  68     // For storing data loaded from the memory
<a name="5" id="anc5"></a><span class="line-modified">  69     static constexpr RegisterID dataTempRegister = MIPSRegisters::t1;</span>
  70     // For storing address base
<a name="6" id="anc6"></a><span class="line-modified">  71     static constexpr RegisterID addrTempRegister = MIPSRegisters::t7;</span>
  72     // For storing compare result
<a name="7" id="anc7"></a><span class="line-modified">  73     static constexpr RegisterID cmpTempRegister = MIPSRegisters::t8;</span>
  74 
  75     // FP temp register
<a name="8" id="anc8"></a><span class="line-modified">  76     static constexpr FPRegisterID fpTempRegister = MIPSRegisters::f16;</span>
  77 
<a name="9" id="anc9"></a><span class="line-modified">  78     static constexpr int MaximumCompactPtrAlignedAddressOffset = 0x7FFFFFFF;</span>
  79 
  80     enum RelationalCondition {
  81         Equal,
  82         NotEqual,
  83         Above,
  84         AboveOrEqual,
  85         Below,
  86         BelowOrEqual,
  87         GreaterThan,
  88         GreaterThanOrEqual,
  89         LessThan,
  90         LessThanOrEqual
  91     };
  92 
  93     enum ResultCondition {
  94         Overflow,
  95         Signed,
  96         PositiveOrZero,
  97         Zero,
  98         NonZero
  99     };
 100 
 101     enum DoubleCondition {
 102         DoubleEqual,
 103         DoubleNotEqual,
 104         DoubleGreaterThan,
 105         DoubleGreaterThanOrEqual,
 106         DoubleLessThan,
 107         DoubleLessThanOrEqual,
 108         DoubleEqualOrUnordered,
 109         DoubleNotEqualOrUnordered,
 110         DoubleGreaterThanOrUnordered,
 111         DoubleGreaterThanOrEqualOrUnordered,
 112         DoubleLessThanOrUnordered,
 113         DoubleLessThanOrEqualOrUnordered
 114     };
 115 
 116     enum class LoadAddressMode {
 117         ScaleAndAddOffsetIfOffsetIsOutOfBounds,
 118         Scale
 119     };
 120 
<a name="10" id="anc10"></a><span class="line-modified"> 121     static constexpr RegisterID stackPointerRegister = MIPSRegisters::sp;</span>
<span class="line-modified"> 122     static constexpr RegisterID framePointerRegister = MIPSRegisters::fp;</span>
<span class="line-modified"> 123     static constexpr RegisterID returnAddressRegister = MIPSRegisters::ra;</span>
 124 
 125     // Integer arithmetic operations:
 126     //
 127     // Operations are typically two operand - operation(source, srcDst)
 128     // For many operations the source may be an TrustedImm32, the srcDst operand
 129     // may often be a memory location (explictly described using an Address
 130     // object).
 131 
 132     void add32(RegisterID src, RegisterID dest)
 133     {
 134         m_assembler.addu(dest, dest, src);
 135     }
 136 
 137     void add32(RegisterID op1, RegisterID op2, RegisterID dest)
 138     {
 139         m_assembler.addu(dest, op1, op2);
 140     }
 141 
 142     void add32(TrustedImm32 imm, RegisterID dest)
 143     {
 144         add32(imm, dest, dest);
 145     }
 146 
 147     void add32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 148     {
 149         if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767
 150             &amp;&amp; !m_fixedWidth) {
 151             /*
 152               addiu     dest, src, imm
 153             */
 154             m_assembler.addiu(dest, src, imm.m_value);
 155         } else {
 156             /*
 157               li        immTemp, imm
 158               addu      dest, src, immTemp
 159             */
 160             move(imm, immTempRegister);
 161             m_assembler.addu(dest, src, immTempRegister);
 162         }
 163     }
 164 
 165     void add32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 166     {
 167         add32(imm, src, dest);
 168     }
 169 
 170     void add32(TrustedImm32 imm, Address address)
 171     {
 172         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
 173             &amp;&amp; !m_fixedWidth) {
 174             /*
 175               lw        dataTemp, offset(base)
 176               li        immTemp, imm
 177               addu      dataTemp, dataTemp, immTemp
 178               sw        dataTemp, offset(base)
 179             */
 180             m_assembler.lw(dataTempRegister, address.base, address.offset);
 181             if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767
 182                 &amp;&amp; !m_fixedWidth)
 183                 m_assembler.addiu(dataTempRegister, dataTempRegister, imm.m_value);
 184             else {
 185                 move(imm, immTempRegister);
 186                 m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
 187             }
 188             m_assembler.sw(dataTempRegister, address.base, address.offset);
 189         } else {
 190             /*
 191               lui       addrTemp, (offset + 0x8000) &gt;&gt; 16
 192               addu      addrTemp, addrTemp, base
 193               lw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 194               li        immtemp, imm
 195               addu      dataTemp, dataTemp, immTemp
 196               sw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 197             */
 198             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 199             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 200             m_assembler.lw(dataTempRegister, addrTempRegister, address.offset);
 201 
 202             if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767 &amp;&amp; !m_fixedWidth)
 203                 m_assembler.addiu(dataTempRegister, dataTempRegister, imm.m_value);
 204             else {
 205                 move(imm, immTempRegister);
 206                 m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
 207             }
 208             m_assembler.sw(dataTempRegister, addrTempRegister, address.offset);
 209         }
 210     }
 211 
 212     void add32(Address src, RegisterID dest)
 213     {
 214         load32(src, dataTempRegister);
 215         add32(dataTempRegister, dest);
 216     }
 217 
 218     void add32(AbsoluteAddress src, RegisterID dest)
 219     {
 220         load32(src.m_ptr, dataTempRegister);
 221         add32(dataTempRegister, dest);
 222     }
 223 
 224     void add32(RegisterID src, Address dest)
 225     {
 226         if (dest.offset &gt;= -32768 &amp;&amp; dest.offset &lt;= 32767 &amp;&amp; !m_fixedWidth) {
 227             /*
 228               lw        dataTemp, offset(base)
 229               addu      dataTemp, dataTemp, src
 230               sw        dataTemp, offset(base)
 231             */
 232             m_assembler.lw(dataTempRegister, dest.base, dest.offset);
 233             m_assembler.addu(dataTempRegister, dataTempRegister, src);
 234             m_assembler.sw(dataTempRegister, dest.base, dest.offset);
 235         } else {
 236             /*
 237               lui       addrTemp, (offset + 0x8000) &gt;&gt; 16
 238               addu      addrTemp, addrTemp, base
 239               lw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 240               addu      dataTemp, dataTemp, src
 241               sw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 242             */
 243             m_assembler.lui(addrTempRegister, (dest.offset + 0x8000) &gt;&gt; 16);
 244             m_assembler.addu(addrTempRegister, addrTempRegister, dest.base);
 245             m_assembler.lw(dataTempRegister, addrTempRegister, dest.offset);
 246             m_assembler.addu(dataTempRegister, dataTempRegister, src);
 247             m_assembler.sw(dataTempRegister, addrTempRegister, dest.offset);
 248         }
 249     }
 250 
 251     void add32(TrustedImm32 imm, AbsoluteAddress address)
 252     {
 253         if (!m_fixedWidth) {
 254             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address.m_ptr);
 255             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 256             m_assembler.lw(cmpTempRegister, addrTempRegister, adr &amp; 0xffff);
 257             if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767)
 258                 m_assembler.addiu(dataTempRegister, cmpTempRegister, imm.m_value);
 259             else {
 260                 move(imm, immTempRegister);
 261                 m_assembler.addu(dataTempRegister, cmpTempRegister, immTempRegister);
 262             }
 263             m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
 264         } else {
 265             /*
 266                li   addrTemp, address
 267                li   immTemp, imm
 268                lw   cmpTemp, 0(addrTemp)
 269                addu dataTemp, cmpTemp, immTemp
 270                sw   dataTemp, 0(addrTemp)
 271             */
 272             move(TrustedImmPtr(address.m_ptr), addrTempRegister);
 273             m_assembler.lw(cmpTempRegister, addrTempRegister, 0);
 274             move(imm, immTempRegister);
 275             m_assembler.addu(dataTempRegister, cmpTempRegister, immTempRegister);
 276             m_assembler.sw(dataTempRegister, addrTempRegister, 0);
 277         }
 278     }
 279 
 280     void add64(TrustedImm32 imm, AbsoluteAddress address)
 281     {
 282         if (!m_fixedWidth) {
 283             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address.m_ptr);
 284             if ((adr &gt;&gt; 15) == ((adr + 4) &gt;&gt; 15)) {
 285                 m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 286                 m_assembler.lw(cmpTempRegister, addrTempRegister, adr &amp; 0xffff);
 287                 if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767)
 288                     m_assembler.addiu(dataTempRegister, cmpTempRegister, imm.m_value);
 289                 else {
 290                     move(imm, immTempRegister);
 291                     m_assembler.addu(dataTempRegister, cmpTempRegister, immTempRegister);
 292                 }
 293                 m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
 294                 m_assembler.sltu(immTempRegister, dataTempRegister, cmpTempRegister);
 295                 m_assembler.lw(dataTempRegister, addrTempRegister, (adr + 4) &amp; 0xffff);
 296                 if (imm.m_value &gt;&gt; 31)
 297                     m_assembler.addiu(dataTempRegister, dataTempRegister, -1);
 298                 m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
 299                 m_assembler.sw(dataTempRegister, addrTempRegister, (adr + 4) &amp; 0xffff);
 300                 return;
 301             }
 302         }
 303         /*
 304             add32(imm, address)
 305             sltu  immTemp, dataTemp, cmpTemp    # set carry-in bit
 306             lw    dataTemp, 4(addrTemp)
 307             addiu dataTemp, imm.m_value &gt;&gt; 31 ? -1 : 0
 308             addu  dataTemp, dataTemp, immTemp
 309             sw    dataTemp, 4(addrTemp)
 310         */
 311         move(TrustedImmPtr(address.m_ptr), addrTempRegister);
 312         m_assembler.lw(cmpTempRegister, addrTempRegister, 0);
 313         if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767 &amp;&amp; !m_fixedWidth)
 314             m_assembler.addiu(dataTempRegister, cmpTempRegister, imm.m_value);
 315         else {
 316             move(imm, immTempRegister);
 317             m_assembler.addu(dataTempRegister, cmpTempRegister, immTempRegister);
 318         }
 319         m_assembler.sw(dataTempRegister, addrTempRegister, 0);
 320         m_assembler.sltu(immTempRegister, dataTempRegister, cmpTempRegister);
 321         m_assembler.lw(dataTempRegister, addrTempRegister, 4);
 322         if (imm.m_value &gt;&gt; 31)
 323             m_assembler.addiu(dataTempRegister, dataTempRegister, -1);
 324         m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
 325         m_assembler.sw(dataTempRegister, addrTempRegister, 4);
 326     }
 327 
 328     void loadAddress(BaseIndex address, LoadAddressMode mode)
 329     {
 330         if (mode == LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds) {
 331             if (!address.scale)
 332                 m_assembler.addu(addrTempRegister, address.index, address.base);
 333             else {
 334                 m_assembler.sll(addrTempRegister, address.index, address.scale);
 335                 m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 336             }
 337             if (address.offset &lt; -32768 || address.offset &gt; 32767) {
 338                 m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 339                 m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
 340             }
 341         } else {
 342             if (!address.scale)
 343                 m_assembler.addu(addrTempRegister, address.index, address.base);
 344             else {
 345                 m_assembler.sll(addrTempRegister, address.index, address.scale);
 346                 m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 347             }
 348         }
 349     }
 350 
 351     void getEffectiveAddress(BaseIndex address, RegisterID dest)
 352     {
 353         if (!address.scale &amp;&amp; !m_fixedWidth)
 354             m_assembler.addu(dest, address.index, address.base);
 355         else {
 356             m_assembler.sll(addrTempRegister, address.index, address.scale);
 357             m_assembler.addu(dest, addrTempRegister, address.base);
 358         }
 359         if (address.offset)
 360             add32(TrustedImm32(address.offset), dest);
 361     }
 362 
 363     void and16(Address src, RegisterID dest)
 364     {
 365         load16(src, dataTempRegister);
 366         and32(dataTempRegister, dest);
 367     }
 368 
 369     void and32(Address src, RegisterID dest)
 370     {
 371         load32(src, dataTempRegister);
 372         and32(dataTempRegister, dest);
 373     }
 374 
 375     void and32(RegisterID src, RegisterID dest)
 376     {
 377         m_assembler.andInsn(dest, dest, src);
 378     }
 379 
 380     void and32(RegisterID op1, RegisterID op2, RegisterID dest)
 381     {
 382         m_assembler.andInsn(dest, op1, op2);
 383     }
 384 
 385     void and32(TrustedImm32 imm, RegisterID dest)
 386     {
 387         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 388             move(MIPSRegisters::zero, dest);
 389         else if (imm.m_value &gt; 0 &amp;&amp; imm.m_value &lt;= 65535 &amp;&amp; !m_fixedWidth)
 390             m_assembler.andi(dest, dest, imm.m_value);
 391         else {
 392             /*
 393               li        immTemp, imm
 394               and       dest, dest, immTemp
 395             */
 396             move(imm, immTempRegister);
 397             m_assembler.andInsn(dest, dest, immTempRegister);
 398         }
 399     }
 400 
 401     void and32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 402     {
 403         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 404             move(MIPSRegisters::zero, dest);
 405         else if (imm.m_value &gt; 0 &amp;&amp; imm.m_value &lt;= 65535 &amp;&amp; !m_fixedWidth)
 406             m_assembler.andi(dest, src, imm.m_value);
 407         else {
 408             move(imm, immTempRegister);
 409             m_assembler.andInsn(dest, src, immTempRegister);
 410         }
 411     }
 412 
 413     void countLeadingZeros32(RegisterID src, RegisterID dest)
 414     {
 415 #if WTF_MIPS_ISA_AT_LEAST(32)
 416         m_assembler.clz(dest, src);
 417 #else
 418         static_assert(false, &quot;CLZ opcode is not available for this ISA&quot;);
 419 #endif
 420     }
 421 
 422     void lshift32(RegisterID shiftAmount, RegisterID dest)
 423     {
 424         m_assembler.sllv(dest, dest, shiftAmount);
 425     }
 426 
 427     void lshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 428     {
 429         m_assembler.sllv(dest, src, shiftAmount);
 430     }
 431 
 432     void lshift32(TrustedImm32 imm, RegisterID dest)
 433     {
 434         m_assembler.sll(dest, dest, imm.m_value);
 435     }
 436 
 437     void lshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 438     {
 439         m_assembler.sll(dest, src, imm.m_value);
 440     }
 441 
 442     void mul32(RegisterID src, RegisterID dest)
 443     {
 444         m_assembler.mul(dest, dest, src);
 445     }
 446 
 447     void mul32(RegisterID op1, RegisterID op2, RegisterID dest)
 448     {
 449         m_assembler.mul(dest, op1, op2);
 450     }
 451 
 452     void mul32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 453     {
 454         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 455             move(MIPSRegisters::zero, dest);
 456         else if (imm.m_value == 1 &amp;&amp; !m_fixedWidth)
 457             move(src, dest);
 458         else {
 459             /*
 460                 li      dataTemp, imm
 461                 mul     dest, src, dataTemp
 462             */
 463             move(imm, dataTempRegister);
 464             m_assembler.mul(dest, src, dataTempRegister);
 465         }
 466     }
 467 
 468     void neg32(RegisterID srcDest)
 469     {
 470         m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
 471     }
 472 
 473     void neg32(RegisterID src, RegisterID dest)
 474     {
 475         m_assembler.subu(dest, MIPSRegisters::zero, src);
 476     }
 477 
<a name="11" id="anc11"></a><span class="line-added"> 478     void or16(TrustedImm32 imm, AbsoluteAddress dest)</span>
<span class="line-added"> 479     {</span>
<span class="line-added"> 480         if (!imm.m_value &amp;&amp; !m_fixedWidth)</span>
<span class="line-added"> 481             return;</span>
<span class="line-added"> 482 </span>
<span class="line-added"> 483         if (m_fixedWidth) {</span>
<span class="line-added"> 484             // TODO: Swap dataTempRegister and immTempRegister usage</span>
<span class="line-added"> 485             load16(dest.m_ptr, immTempRegister);</span>
<span class="line-added"> 486             or32(imm, immTempRegister);</span>
<span class="line-added"> 487             store16(immTempRegister, dest.m_ptr);</span>
<span class="line-added"> 488         } else {</span>
<span class="line-added"> 489             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);</span>
<span class="line-added"> 490             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added"> 491             m_assembler.lhu(immTempRegister, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added"> 492             or32(imm, immTempRegister);</span>
<span class="line-added"> 493             m_assembler.sh(immTempRegister, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added"> 494         }</span>
<span class="line-added"> 495     }</span>
<span class="line-added"> 496 </span>
 497     void or32(RegisterID src, RegisterID dest)
 498     {
 499         m_assembler.orInsn(dest, dest, src);
 500     }
 501 
 502     void or32(RegisterID op1, RegisterID op2, RegisterID dest)
 503     {
 504         m_assembler.orInsn(dest, op1, op2);
 505     }
 506 
 507     void or32(TrustedImm32 imm, AbsoluteAddress dest)
 508     {
 509         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 510             return;
 511 
 512         if (m_fixedWidth) {
 513             // TODO: Swap dataTempRegister and immTempRegister usage
 514             load32(dest.m_ptr, immTempRegister);
 515             or32(imm, immTempRegister);
 516             store32(immTempRegister, dest.m_ptr);
 517         } else {
 518             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);
 519             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 520             m_assembler.lw(immTempRegister, addrTempRegister, adr &amp; 0xffff);
 521             or32(imm, immTempRegister);
 522             m_assembler.sw(immTempRegister, addrTempRegister, adr &amp; 0xffff);
 523         }
 524     }
 525 
 526     void or32(TrustedImm32 imm, RegisterID dest)
 527     {
 528         if (!imm.m_value &amp;&amp; !m_fixedWidth)
 529             return;
 530 
 531         if (imm.m_value &gt; 0 &amp;&amp; imm.m_value &lt;= 65535
 532             &amp;&amp; !m_fixedWidth) {
 533             m_assembler.ori(dest, dest, imm.m_value);
 534             return;
 535         }
 536 
 537         /*
 538             li      dataTemp, imm
 539             or      dest, dest, dataTemp
 540         */
 541         move(imm, dataTempRegister);
 542         m_assembler.orInsn(dest, dest, dataTempRegister);
 543     }
 544 
 545     void or32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 546     {
 547         if (!imm.m_value &amp;&amp; !m_fixedWidth) {
 548             move(src, dest);
 549             return;
 550         }
 551 
 552         if (imm.m_value &gt; 0 &amp;&amp; imm.m_value &lt;= 65535 &amp;&amp; !m_fixedWidth) {
 553             m_assembler.ori(dest, src, imm.m_value);
 554             return;
 555         }
 556 
 557         /*
 558             li      dataTemp, imm
 559             or      dest, src, dataTemp
 560         */
 561         move(imm, dataTempRegister);
 562         m_assembler.orInsn(dest, src, dataTempRegister);
 563     }
 564 
 565     void or32(RegisterID src, AbsoluteAddress dest)
 566     {
 567         if (m_fixedWidth) {
 568             load32(dest.m_ptr, dataTempRegister);
 569             m_assembler.orInsn(dataTempRegister, dataTempRegister, src);
 570             store32(dataTempRegister, dest.m_ptr);
 571         } else {
 572             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);
 573             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 574             m_assembler.lw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
 575             m_assembler.orInsn(dataTempRegister, dataTempRegister, src);
 576             m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
 577         }
 578     }
 579 
 580     void or32(TrustedImm32 imm, Address address)
 581     {
 582         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
 583             &amp;&amp; !m_fixedWidth) {
 584             /*
 585               lw        dataTemp, offset(base)
 586               li        immTemp, imm
 587               or        dataTemp, dataTemp, immTemp
 588               sw        dataTemp, offset(base)
 589             */
 590             m_assembler.lw(dataTempRegister, address.base, address.offset);
 591             if (imm.m_value &gt;= 0 &amp;&amp; imm.m_value &lt;= 65535 &amp;&amp; !m_fixedWidth)
 592                 m_assembler.ori(dataTempRegister, dataTempRegister, imm.m_value);
 593             else {
 594                 move(imm, immTempRegister);
 595                 m_assembler.orInsn(dataTempRegister, dataTempRegister, immTempRegister);
 596             }
 597             m_assembler.sw(dataTempRegister, address.base, address.offset);
 598         } else {
 599             /*
 600               lui       addrTemp, (offset + 0x8000) &gt;&gt; 16
 601               addu      addrTemp, addrTemp, base
 602               lw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 603               li        immtemp, imm
 604               or        dataTemp, dataTemp, immTemp
 605               sw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 606             */
 607             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 608             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 609             m_assembler.lw(dataTempRegister, addrTempRegister, address.offset);
 610 
 611             if (imm.m_value &gt;= 0 &amp;&amp; imm.m_value &lt;= 65535 &amp;&amp; !m_fixedWidth)
 612                 m_assembler.ori(dataTempRegister, dataTempRegister, imm.m_value);
 613             else {
 614                 move(imm, immTempRegister);
 615                 m_assembler.orInsn(dataTempRegister, dataTempRegister, immTempRegister);
 616             }
 617             m_assembler.sw(dataTempRegister, addrTempRegister, address.offset);
 618         }
 619     }
 620 
 621     void rshift32(RegisterID shiftAmount, RegisterID dest)
 622     {
 623         m_assembler.srav(dest, dest, shiftAmount);
 624     }
 625 
 626     void rshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 627     {
 628         m_assembler.srav(dest, src, shiftAmount);
 629     }
 630 
 631     void rshift32(TrustedImm32 imm, RegisterID dest)
 632     {
 633         m_assembler.sra(dest, dest, imm.m_value);
 634     }
 635 
 636     void rshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 637     {
 638         m_assembler.sra(dest, src, imm.m_value);
 639     }
 640 
 641     void urshift32(RegisterID shiftAmount, RegisterID dest)
 642     {
 643         m_assembler.srlv(dest, dest, shiftAmount);
 644     }
 645 
 646     void urshift32(RegisterID src, RegisterID shiftAmount, RegisterID dest)
 647     {
 648         m_assembler.srlv(dest, src, shiftAmount);
 649     }
 650 
 651     void urshift32(TrustedImm32 imm, RegisterID dest)
 652     {
 653         m_assembler.srl(dest, dest, imm.m_value);
 654     }
 655 
 656     void urshift32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 657     {
 658         m_assembler.srl(dest, src, imm.m_value);
 659     }
 660 
 661     void sub32(RegisterID src, RegisterID dest)
 662     {
 663         m_assembler.subu(dest, dest, src);
 664     }
 665 
 666     void sub32(RegisterID op1, RegisterID op2, RegisterID dest)
 667     {
 668         m_assembler.subu(dest, op1, op2);
 669     }
 670 
 671     void sub32(TrustedImm32 imm, RegisterID dest)
 672     {
 673         if (imm.m_value &gt;= -32767 &amp;&amp; imm.m_value &lt;= 32768
 674             &amp;&amp; !m_fixedWidth) {
 675             /*
 676               addiu     dest, src, imm
 677             */
 678             m_assembler.addiu(dest, dest, -imm.m_value);
 679         } else {
 680             /*
 681               li        immTemp, imm
 682               subu      dest, src, immTemp
 683             */
 684             move(imm, immTempRegister);
 685             m_assembler.subu(dest, dest, immTempRegister);
 686         }
 687     }
 688 
 689     void sub32(RegisterID src, TrustedImm32 imm, RegisterID dest)
 690     {
 691         if (imm.m_value &gt;= -32767 &amp;&amp; imm.m_value &lt;= 32768
 692             &amp;&amp; !m_fixedWidth) {
 693             /*
 694               addiu     dest, src, imm
 695             */
 696             m_assembler.addiu(dest, src, -imm.m_value);
 697         } else {
 698             /*
 699               li        immTemp, imm
 700               subu      dest, src, immTemp
 701             */
 702             move(imm, immTempRegister);
 703             m_assembler.subu(dest, src, immTempRegister);
 704         }
 705     }
 706 
 707     void sub32(TrustedImm32 imm, Address address)
 708     {
 709         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
 710             &amp;&amp; !m_fixedWidth) {
 711             /*
 712               lw        dataTemp, offset(base)
 713               li        immTemp, imm
 714               subu      dataTemp, dataTemp, immTemp
 715               sw        dataTemp, offset(base)
 716             */
 717             m_assembler.lw(dataTempRegister, address.base, address.offset);
 718             if (imm.m_value &gt;= -32767 &amp;&amp; imm.m_value &lt;= 32768 &amp;&amp; !m_fixedWidth)
 719                 m_assembler.addiu(dataTempRegister, dataTempRegister, -imm.m_value);
 720             else {
 721                 move(imm, immTempRegister);
 722                 m_assembler.subu(dataTempRegister, dataTempRegister, immTempRegister);
 723             }
 724             m_assembler.sw(dataTempRegister, address.base, address.offset);
 725         } else {
 726             /*
 727               lui       addrTemp, (offset + 0x8000) &gt;&gt; 16
 728               addu      addrTemp, addrTemp, base
 729               lw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 730               li        immtemp, imm
 731               subu      dataTemp, dataTemp, immTemp
 732               sw        dataTemp, (offset &amp; 0xffff)(addrTemp)
 733             */
 734             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 735             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 736             m_assembler.lw(dataTempRegister, addrTempRegister, address.offset);
 737 
 738             if (imm.m_value &gt;= -32767 &amp;&amp; imm.m_value &lt;= 32768
 739                 &amp;&amp; !m_fixedWidth)
 740                 m_assembler.addiu(dataTempRegister, dataTempRegister, -imm.m_value);
 741             else {
 742                 move(imm, immTempRegister);
 743                 m_assembler.subu(dataTempRegister, dataTempRegister, immTempRegister);
 744             }
 745             m_assembler.sw(dataTempRegister, addrTempRegister, address.offset);
 746         }
 747     }
 748 
 749     void sub32(Address src, RegisterID dest)
 750     {
 751         load32(src, dataTempRegister);
 752         sub32(dataTempRegister, dest);
 753     }
 754 
 755     void sub32(TrustedImm32 imm, AbsoluteAddress address)
 756     {
 757         if (!m_fixedWidth) {
 758             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address.m_ptr);
 759             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 760             m_assembler.lw(cmpTempRegister, addrTempRegister, adr &amp; 0xffff);
 761             if (imm.m_value &gt;= -32767 &amp;&amp; imm.m_value &lt;= 32768)
 762                 m_assembler.addiu(dataTempRegister, cmpTempRegister, -imm.m_value);
 763             else {
 764                 move(imm, immTempRegister);
 765                 m_assembler.subu(dataTempRegister, cmpTempRegister, immTempRegister);
 766             }
 767             m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
 768         } else {
 769             /*
 770                li   addrTemp, address
 771                lw   dataTemp, 0(addrTemp)
 772                li   immTemp, imm
 773                subu dataTemp, dataTemp, immTemp
 774                sw   dataTemp, 0(addrTemp)
 775             */
 776             move(TrustedImmPtr(address.m_ptr), addrTempRegister);
 777             m_assembler.lw(cmpTempRegister, addrTempRegister, 0);
 778             move(imm, immTempRegister);
 779             m_assembler.subu(dataTempRegister, cmpTempRegister, immTempRegister);
 780             m_assembler.sw(dataTempRegister, addrTempRegister, 0);
 781         }
 782     }
 783 
 784     void xor32(RegisterID src, RegisterID dest)
 785     {
 786         m_assembler.xorInsn(dest, dest, src);
 787     }
 788 
 789     void xor32(RegisterID op1, RegisterID op2, RegisterID dest)
 790     {
 791         m_assembler.xorInsn(dest, op1, op2);
 792     }
 793 
 794     void xor32(Address src, RegisterID dest)
 795     {
 796         load32(src, dataTempRegister);
 797         xor32(dataTempRegister, dest);
 798     }
 799 
 800     void xor32(TrustedImm32 imm, RegisterID dest)
 801     {
 802         if (!m_fixedWidth) {
 803             if (imm.m_value == -1) {
 804                 m_assembler.nor(dest, dest, MIPSRegisters::zero);
 805                 return;
 806             }
 807             if (imm.m_value &gt;= 0 &amp;&amp; imm.m_value &lt;= 65535) {
 808                 m_assembler.xori(dest, dest, imm.m_value);
 809                 return;
 810             }
 811         }
 812         /*
 813             li  immTemp, imm
 814             xor dest, dest, immTemp
 815         */
 816         move(imm, immTempRegister);
 817         m_assembler.xorInsn(dest, dest, immTempRegister);
 818     }
 819 
 820     void xor32(TrustedImm32 imm, RegisterID src, RegisterID dest)
 821     {
 822         if (!m_fixedWidth) {
 823             if (imm.m_value == -1) {
 824                 m_assembler.nor(dest, src, MIPSRegisters::zero);
 825                 return;
 826             }
 827             if (imm.m_value &gt;= 0 &amp;&amp; imm.m_value &lt;= 65535) {
 828                 m_assembler.xori(dest, src, imm.m_value);
 829                 return;
 830             }
 831         }
 832         /*
 833             li  immTemp, imm
 834             xor dest, src, immTemp
 835         */
 836         move(imm, immTempRegister);
 837         m_assembler.xorInsn(dest, src, immTempRegister);
 838     }
 839 
 840     void not32(RegisterID srcDest)
 841     {
 842         m_assembler.nor(srcDest, srcDest, MIPSRegisters::zero);
 843     }
 844 
 845     void sqrtDouble(FPRegisterID src, FPRegisterID dst)
 846     {
 847         m_assembler.sqrtd(dst, src);
 848     }
 849 
 850     void absDouble(FPRegisterID src, FPRegisterID dst)
 851     {
 852         m_assembler.absd(dst, src);
 853     }
 854 
 855     NO_RETURN_DUE_TO_CRASH void ceilDouble(FPRegisterID, FPRegisterID)
 856     {
 857         ASSERT(!supportsFloatingPointRounding());
 858         CRASH();
 859     }
 860 
 861     NO_RETURN_DUE_TO_CRASH void floorDouble(FPRegisterID, FPRegisterID)
 862     {
 863         ASSERT(!supportsFloatingPointRounding());
 864         CRASH();
 865     }
 866 
 867     NO_RETURN_DUE_TO_CRASH void roundTowardZeroDouble(FPRegisterID, FPRegisterID)
 868     {
 869         ASSERT(!supportsFloatingPointRounding());
 870         CRASH();
 871     }
 872 
 873     ConvertibleLoadLabel convertibleLoadPtr(Address address, RegisterID dest)
 874     {
 875         ConvertibleLoadLabel result(this);
 876         /*
 877             lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
 878             addu    addrTemp, addrTemp, base
 879             lw      dest, (offset &amp; 0xffff)(addrTemp)
 880         */
 881         m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 882         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 883         m_assembler.lw(dest, addrTempRegister, address.offset);
 884         return result;
 885     }
 886 
 887     // Memory access operations:
 888     //
 889     // Loads are of the form load(address, destination) and stores of the form
 890     // store(source, address). The source for a store may be an TrustedImm32. Address
 891     // operand objects to loads and store will be implicitly constructed if a
 892     // register is passed.
 893 
 894     /* Need to use zero-extened load byte for load8.  */
 895     void load8(ImplicitAddress address, RegisterID dest)
 896     {
 897         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
 898             &amp;&amp; !m_fixedWidth)
 899             m_assembler.lbu(dest, address.base, address.offset);
 900         else {
 901             /*
 902                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
 903                 addu    addrTemp, addrTemp, base
 904                 lbu     dest, (offset &amp; 0xffff)(addrTemp)
 905               */
 906             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 907             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 908             m_assembler.lbu(dest, addrTempRegister, address.offset);
 909         }
 910     }
 911 
 912     void load8(BaseIndex address, RegisterID dest)
 913     {
 914         if (!m_fixedWidth) {
 915             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
 916             m_assembler.lbu(dest, addrTempRegister, address.offset);
 917         } else {
 918             /*
 919              sll     addrTemp, address.index, address.scale
 920              addu    addrTemp, addrTemp, address.base
 921              lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
 922              addu    addrTemp, addrTemp, immTemp
 923              lbu     dest, (address.offset &amp; 0xffff)(at)
 924              */
 925             m_assembler.sll(addrTempRegister, address.index, address.scale);
 926             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 927             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 928             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
 929             m_assembler.lbu(dest, addrTempRegister, address.offset);
 930         }
 931     }
 932 
 933     ALWAYS_INLINE void load8(AbsoluteAddress address, RegisterID dest)
 934     {
 935         load8(address.m_ptr, dest);
 936     }
 937 
 938     void load8(const void* address, RegisterID dest)
 939     {
 940         if (m_fixedWidth) {
 941             /*
 942                 li  addrTemp, address
 943                 lbu dest, 0(addrTemp)
 944             */
 945             move(TrustedImmPtr(address), addrTempRegister);
 946             m_assembler.lbu(dest, addrTempRegister, 0);
 947         } else {
 948             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
 949             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
 950             m_assembler.lbu(dest, addrTempRegister, adr &amp; 0xffff);
 951         }
 952     }
 953 
 954     void load8SignedExtendTo32(ImplicitAddress address, RegisterID dest)
 955     {
 956         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
 957             &amp;&amp; !m_fixedWidth)
 958             m_assembler.lb(dest, address.base, address.offset);
 959         else {
 960             /*
 961                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
 962                 addu    addrTemp, addrTemp, base
 963                 lb      dest, (offset &amp; 0xffff)(addrTemp)
 964               */
 965             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 966             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 967             m_assembler.lb(dest, addrTempRegister, address.offset);
 968         }
 969     }
 970 
 971     void load8SignedExtendTo32(BaseIndex address, RegisterID dest)
 972     {
 973         if (!m_fixedWidth) {
 974             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
 975             m_assembler.lb(dest, addrTempRegister, address.offset);
 976         } else {
 977             /*
 978                 sll     addrTemp, address.index, address.scale
 979                 addu    addrTemp, addrTemp, address.base
 980                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
 981                 addu    addrTemp, addrTemp, immTemp
 982                 lb     dest, (address.offset &amp; 0xffff)(at)
 983             */
 984             m_assembler.sll(addrTempRegister, address.index, address.scale);
 985             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
 986             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
 987             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
 988             m_assembler.lb(dest, addrTempRegister, address.offset);
 989         }
 990     }
 991 
 992     ALWAYS_INLINE void load8SignedExtendTo32(AbsoluteAddress address, RegisterID dest)
 993     {
 994         load8SignedExtendTo32(address.m_ptr, dest);
 995     }
 996 
 997     void load8SignedExtendTo32(const void* address, RegisterID dest)
 998     {
 999         if (m_fixedWidth) {
1000             /*
1001                 li  addrTemp, address
1002                 lb dest, 0(addrTemp)
1003             */
1004             move(TrustedImmPtr(address), addrTempRegister);
1005             m_assembler.lb(dest, addrTempRegister, 0);
1006         } else {
1007             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1008             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1009             m_assembler.lb(dest, addrTempRegister, adr &amp; 0xffff);
1010         }
1011     }
1012 
1013 
1014     void load32(ImplicitAddress address, RegisterID dest)
1015     {
1016         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1017             &amp;&amp; !m_fixedWidth)
1018             m_assembler.lw(dest, address.base, address.offset);
1019         else {
1020             /*
1021                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1022                 addu    addrTemp, addrTemp, base
1023                 lw      dest, (offset &amp; 0xffff)(addrTemp)
1024               */
1025             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1026             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1027             m_assembler.lw(dest, addrTempRegister, address.offset);
1028         }
1029     }
1030 
1031     void load32(BaseIndex address, RegisterID dest)
1032     {
1033         if (!m_fixedWidth) {
1034             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1035             m_assembler.lw(dest, addrTempRegister, address.offset);
1036         } else {
1037             /*
1038                 sll     addrTemp, address.index, address.scale
1039                 addu    addrTemp, addrTemp, address.base
1040                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1041                 addu    addrTemp, addrTemp, immTemp
1042                 lw      dest, (address.offset &amp; 0xffff)(at)
1043             */
1044             m_assembler.sll(addrTempRegister, address.index, address.scale);
1045             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1046             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1047             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1048             m_assembler.lw(dest, addrTempRegister, address.offset);
1049         }
1050     }
1051 
1052     void load16Unaligned(BaseIndex address, RegisterID dest)
1053     {
1054         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767 &amp;&amp; !m_fixedWidth) {
1055             /*
1056                 sll     addrtemp, address.index, address.scale
1057                 addu    addrtemp, addrtemp, address.base
1058                 lbu     immTemp, address.offset+x(addrtemp) (x=0 for LE, x=1 for BE)
1059                 lbu     dest, address.offset+x(addrtemp)    (x=1 for LE, x=0 for BE)
1060                 sll     dest, dest, 8
1061                 or      dest, dest, immTemp
1062             */
1063             loadAddress(address, LoadAddressMode::Scale);
1064 #if CPU(BIG_ENDIAN)
1065             m_assembler.lbu(immTempRegister, addrTempRegister, address.offset + 1);
1066             m_assembler.lbu(dest, addrTempRegister, address.offset);
1067 #else
1068             m_assembler.lbu(immTempRegister, addrTempRegister, address.offset);
1069             m_assembler.lbu(dest, addrTempRegister, address.offset + 1);
1070 #endif
1071             m_assembler.sll(dest, dest, 8);
1072             m_assembler.orInsn(dest, dest, immTempRegister);
1073         } else {
1074             /*
1075                 sll     addrTemp, address.index, address.scale
1076                 addu    addrTemp, addrTemp, address.base
1077                 lui     immTemp, address.offset &gt;&gt; 16
1078                 ori     immTemp, immTemp, address.offset &amp; 0xffff
1079                 addu    addrTemp, addrTemp, immTemp
1080                 lbu     immTemp, x(addrtemp) (x=0 for LE, x=1 for BE)
1081                 lbu     dest, x(addrtemp)    (x=1 for LE, x=0 for BE)
1082                 sll     dest, dest, 8
1083                 or      dest, dest, immTemp
1084             */
1085             m_assembler.sll(addrTempRegister, address.index, address.scale);
1086             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1087             m_assembler.lui(immTempRegister, address.offset &gt;&gt; 16);
1088             m_assembler.ori(immTempRegister, immTempRegister, address.offset);
1089             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1090 #if CPU(BIG_ENDIAN)
1091             m_assembler.lbu(immTempRegister, addrTempRegister, 1);
1092             m_assembler.lbu(dest, addrTempRegister, 0);
1093 #else
1094             m_assembler.lbu(immTempRegister, addrTempRegister, 0);
1095             m_assembler.lbu(dest, addrTempRegister, 1);
1096 #endif
1097             m_assembler.sll(dest, dest, 8);
1098             m_assembler.orInsn(dest, dest, immTempRegister);
1099         }
1100     }
1101 
1102     void load32WithUnalignedHalfWords(BaseIndex address, RegisterID dest)
1103     {
1104         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32764
1105             &amp;&amp; !m_fixedWidth) {
1106             /*
1107                 sll     addrTemp, address.index, address.scale
1108                 addu    addrTemp, addrTemp, address.base
1109                 (Big-Endian)
1110                 lwl     dest, address.offset(addrTemp)
1111                 lwr     dest, address.offset+3(addrTemp)
1112                 (Little-Endian)
1113                 lwl     dest, address.offset+3(addrTemp)
1114                 lwr     dest, address.offset(addrTemp)
1115             */
1116             loadAddress(address, LoadAddressMode::Scale);
1117 #if CPU(BIG_ENDIAN)
1118             m_assembler.lwl(dest, addrTempRegister, address.offset);
1119             m_assembler.lwr(dest, addrTempRegister, address.offset + 3);
1120 #else
1121             m_assembler.lwl(dest, addrTempRegister, address.offset + 3);
1122             m_assembler.lwr(dest, addrTempRegister, address.offset);
1123 
1124 #endif
1125         } else {
1126             /*
1127                 sll     addrTemp, address.index, address.scale
1128                 addu    addrTemp, addrTemp, address.base
1129                 lui     immTemp, address.offset &gt;&gt; 16
1130                 ori     immTemp, immTemp, address.offset &amp; 0xffff
1131                 addu    addrTemp, addrTemp, immTemp
1132                 (Big-Endian)
1133                 lw      dest, 0(at)
1134                 lw      dest, 3(at)
1135                 (Little-Endian)
1136                 lw      dest, 3(at)
1137                 lw      dest, 0(at)
1138             */
1139             m_assembler.sll(addrTempRegister, address.index, address.scale);
1140             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1141             m_assembler.lui(immTempRegister, address.offset &gt;&gt; 16);
1142             m_assembler.ori(immTempRegister, immTempRegister, address.offset);
1143             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1144 #if CPU(BIG_ENDIAN)
1145             m_assembler.lwl(dest, addrTempRegister, 0);
1146             m_assembler.lwr(dest, addrTempRegister, 3);
1147 #else
1148             m_assembler.lwl(dest, addrTempRegister, 3);
1149             m_assembler.lwr(dest, addrTempRegister, 0);
1150 #endif
1151         }
1152     }
1153 
1154     void load32(const void* address, RegisterID dest)
1155     {
1156         if (m_fixedWidth) {
1157             /*
1158                 li  addrTemp, address
1159                 lw  dest, 0(addrTemp)
1160             */
1161             move(TrustedImmPtr(address), addrTempRegister);
1162             m_assembler.lw(dest, addrTempRegister, 0);
1163         } else {
1164             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1165             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1166             m_assembler.lw(dest, addrTempRegister, adr &amp; 0xffff);
1167         }
1168     }
1169 
1170     DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
1171     {
1172         m_fixedWidth = true;
1173         /*
1174             lui addrTemp, address.offset &gt;&gt; 16
1175             ori addrTemp, addrTemp, address.offset &amp; 0xffff
1176             addu        addrTemp, addrTemp, address.base
1177             lw  dest, 0(addrTemp)
1178         */
1179         DataLabel32 dataLabel(this);
1180         move(TrustedImm32(address.offset), addrTempRegister);
1181         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1182         m_assembler.lw(dest, addrTempRegister, 0);
1183         m_fixedWidth = false;
1184         return dataLabel;
1185     }
1186 
1187     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
1188     {
1189         DataLabelCompact dataLabel(this);
1190         load32WithAddressOffsetPatch(address, dest);
1191         return dataLabel;
1192     }
1193 
<a name="12" id="anc12"></a><span class="line-added">1194     void load16(const void* address, RegisterID dest)</span>
<span class="line-added">1195     {</span>
<span class="line-added">1196         if (m_fixedWidth) {</span>
<span class="line-added">1197             /*</span>
<span class="line-added">1198                 li  addrTemp, address</span>
<span class="line-added">1199                 lhu  dest, 0(addrTemp)</span>
<span class="line-added">1200             */</span>
<span class="line-added">1201             move(TrustedImmPtr(address), addrTempRegister);</span>
<span class="line-added">1202             m_assembler.lhu(dest, addrTempRegister, 0);</span>
<span class="line-added">1203         } else {</span>
<span class="line-added">1204             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-added">1205             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added">1206             m_assembler.lhu(dest, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added">1207         }</span>
<span class="line-added">1208     }</span>
<span class="line-added">1209 </span>
1210     /* Need to use zero-extened load half-word for load16.  */
1211     void load16(ImplicitAddress address, RegisterID dest)
1212     {
1213         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1214             &amp;&amp; !m_fixedWidth)
1215             m_assembler.lhu(dest, address.base, address.offset);
1216         else {
1217             /*
1218                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1219                 addu    addrTemp, addrTemp, base
1220                 lhu     dest, (offset &amp; 0xffff)(addrTemp)
1221               */
1222             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1223             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1224             m_assembler.lhu(dest, addrTempRegister, address.offset);
1225         }
1226     }
1227 
1228     /* Need to use zero-extened load half-word for load16.  */
1229     void load16(BaseIndex address, RegisterID dest)
1230     {
1231         if (!m_fixedWidth) {
1232             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1233             m_assembler.lhu(dest, addrTempRegister, address.offset);
1234         } else {
1235             /*
1236                 sll     addrTemp, address.index, address.scale
1237                 addu    addrTemp, addrTemp, address.base
1238                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1239                 addu    addrTemp, addrTemp, immTemp
1240                 lhu     dest, (address.offset &amp; 0xffff)(addrTemp)
1241             */
1242             m_assembler.sll(addrTempRegister, address.index, address.scale);
1243             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1244             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1245             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1246             m_assembler.lhu(dest, addrTempRegister, address.offset);
1247         }
1248     }
1249 
1250     void load16SignedExtendTo32(BaseIndex address, RegisterID dest)
1251     {
1252         if (!m_fixedWidth) {
1253             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1254             m_assembler.lh(dest, addrTempRegister, address.offset);
1255         } else {
1256             /*
1257                 sll     addrTemp, address.index, address.scale
1258                 addu    addrTemp, addrTemp, address.base
1259                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1260                 addu    addrTemp, addrTemp, immTemp
1261                 lh     dest, (address.offset &amp; 0xffff)(addrTemp)
1262             */
1263             m_assembler.sll(addrTempRegister, address.index, address.scale);
1264             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1265             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1266             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1267             m_assembler.lh(dest, addrTempRegister, address.offset);
1268         }
1269     }
1270 
1271     DataLabel32 store32WithAddressOffsetPatch(RegisterID src, Address address)
1272     {
1273         m_fixedWidth = true;
1274         /*
1275             lui addrTemp, address.offset &gt;&gt; 16
1276             ori addrTemp, addrTemp, address.offset &amp; 0xffff
1277             addu        addrTemp, addrTemp, address.base
1278             sw  src, 0(addrTemp)
1279         */
1280         DataLabel32 dataLabel(this);
1281         move(TrustedImm32(address.offset), addrTempRegister);
1282         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1283         m_assembler.sw(src, addrTempRegister, 0);
1284         m_fixedWidth = false;
1285         return dataLabel;
1286     }
1287 
1288     void store8(RegisterID src, BaseIndex address)
1289     {
1290         if (!m_fixedWidth) {
1291             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1292             m_assembler.sb(src, addrTempRegister, address.offset);
1293         } else {
1294             /*
1295                 sll     addrTemp, address.index, address.scale
1296                 addu    addrTemp, addrTemp, address.base
1297                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1298                 addu    addrTemp, addrTemp, immTemp
1299                 sb      src, (address.offset &amp; 0xffff)(at)
1300             */
1301             m_assembler.sll(addrTempRegister, address.index, address.scale);
1302             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1303             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1304             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1305             m_assembler.sb(src, addrTempRegister, address.offset);
1306         }
1307     }
1308 
1309     void store8(RegisterID src, void* address)
1310     {
1311         if (m_fixedWidth) {
1312             /*
1313                 li  addrTemp, address
1314                 sb  src, 0(addrTemp)
1315             */
1316             move(TrustedImmPtr(address), addrTempRegister);
1317             m_assembler.sb(src, addrTempRegister, 0);
1318         } else {
1319             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1320             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1321             m_assembler.sb(src, addrTempRegister, adr &amp; 0xffff);
1322         }
1323     }
1324 
1325     void store8(TrustedImm32 imm, void* address)
1326     {
1327         if (m_fixedWidth) {
1328             /*
1329                 li  immTemp, imm
1330                 li  addrTemp, address
1331                 sb  src, 0(addrTemp)
1332             */
1333             TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
1334             move(imm8, immTempRegister);
1335             move(TrustedImmPtr(address), addrTempRegister);
1336             m_assembler.sb(immTempRegister, addrTempRegister, 0);
1337         } else {
1338             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1339             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1340             if (!imm.m_value)
1341                 m_assembler.sb(MIPSRegisters::zero, addrTempRegister, adr &amp; 0xffff);
1342             else {
1343                 TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
1344                 move(imm8, immTempRegister);
1345                 m_assembler.sb(immTempRegister, addrTempRegister, adr &amp; 0xffff);
1346             }
1347         }
1348     }
1349 
1350     void store8(TrustedImm32 imm, ImplicitAddress address)
1351     {
1352         TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
1353         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1354             &amp;&amp; !m_fixedWidth) {
1355             if (!imm8.m_value)
1356                 m_assembler.sb(MIPSRegisters::zero, address.base, address.offset);
1357             else {
1358                 move(imm8, immTempRegister);
1359                 m_assembler.sb(immTempRegister, address.base, address.offset);
1360             }
1361         } else {
1362             /*
1363                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1364                 addu    addrTemp, addrTemp, base
1365                 sb      immTemp, (offset &amp; 0xffff)(addrTemp)
1366               */
1367             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1368             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1369             if (!imm8.m_value &amp;&amp; !m_fixedWidth)
1370                 m_assembler.sb(MIPSRegisters::zero, addrTempRegister, address.offset);
1371             else {
1372                 move(imm8, immTempRegister);
1373                 m_assembler.sb(immTempRegister, addrTempRegister, address.offset);
1374             }
1375         }
1376     }
1377 
<a name="13" id="anc13"></a><span class="line-added">1378     void store16(RegisterID src, const void* address)</span>
<span class="line-added">1379     {</span>
<span class="line-added">1380         if (m_fixedWidth) {</span>
<span class="line-added">1381             /*</span>
<span class="line-added">1382                 li  addrTemp, address</span>
<span class="line-added">1383                 sh  src, 0(addrTemp)</span>
<span class="line-added">1384             */</span>
<span class="line-added">1385             move(TrustedImmPtr(address), addrTempRegister);</span>
<span class="line-added">1386             m_assembler.sh(src, addrTempRegister, 0);</span>
<span class="line-added">1387         } else {</span>
<span class="line-added">1388             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);</span>
<span class="line-added">1389             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);</span>
<span class="line-added">1390             m_assembler.sh(src, addrTempRegister, adr &amp; 0xffff);</span>
<span class="line-added">1391         }</span>
<span class="line-added">1392     }</span>
<span class="line-added">1393 </span>
1394     void store16(RegisterID src, ImplicitAddress address)
1395     {
1396         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1397             &amp;&amp; !m_fixedWidth) {
1398             m_assembler.sh(src, address.base, address.offset);
1399         } else {
1400             /*
1401                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1402                 addu    addrTemp, addrTemp, base
1403                 sh      src, (offset &amp; 0xffff)(addrTemp)
1404               */
1405             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1406             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1407             m_assembler.sh(src, addrTempRegister, address.offset);
1408         }
1409     }
1410 
1411     void store16(RegisterID src, BaseIndex address)
1412     {
1413         if (!m_fixedWidth) {
1414             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1415             m_assembler.sh(src, addrTempRegister, address.offset);
1416         } else {
1417             /*
1418                 sll     addrTemp, address.index, address.scale
1419                 addu    addrTemp, addrTemp, address.base
1420                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1421                 addu    addrTemp, addrTemp, immTemp
1422                 sh      src, (address.offset &amp; 0xffff)(at)
1423             */
1424             m_assembler.sll(addrTempRegister, address.index, address.scale);
1425             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1426             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1427             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1428             m_assembler.sh(src, addrTempRegister, address.offset);
1429         }
1430     }
1431 
1432     void store32(RegisterID src, ImplicitAddress address)
1433     {
1434         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1435             &amp;&amp; !m_fixedWidth)
1436             m_assembler.sw(src, address.base, address.offset);
1437         else {
1438             /*
1439                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1440                 addu    addrTemp, addrTemp, base
1441                 sw      src, (offset &amp; 0xffff)(addrTemp)
1442               */
1443             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1444             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1445             m_assembler.sw(src, addrTempRegister, address.offset);
1446         }
1447     }
1448 
1449     void store32(RegisterID src, BaseIndex address)
1450     {
1451         if (!m_fixedWidth) {
1452             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1453             m_assembler.sw(src, addrTempRegister, address.offset);
1454         } else {
1455             /*
1456                 sll     addrTemp, address.index, address.scale
1457                 addu    addrTemp, addrTemp, address.base
1458                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1459                 addu    addrTemp, addrTemp, immTemp
1460                 sw      src, (address.offset &amp; 0xffff)(at)
1461             */
1462             m_assembler.sll(addrTempRegister, address.index, address.scale);
1463             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1464             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1465             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1466             m_assembler.sw(src, addrTempRegister, address.offset);
1467         }
1468     }
1469 
1470     void store32(TrustedImm32 imm, ImplicitAddress address)
1471     {
1472         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
1473             &amp;&amp; !m_fixedWidth) {
1474             if (!imm.m_value)
1475                 m_assembler.sw(MIPSRegisters::zero, address.base, address.offset);
1476             else {
1477                 move(imm, immTempRegister);
1478                 m_assembler.sw(immTempRegister, address.base, address.offset);
1479             }
1480         } else {
1481             /*
1482                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
1483                 addu    addrTemp, addrTemp, base
1484                 sw      immTemp, (offset &amp; 0xffff)(addrTemp)
1485               */
1486             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1487             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1488             if (!imm.m_value &amp;&amp; !m_fixedWidth)
1489                 m_assembler.sw(MIPSRegisters::zero, addrTempRegister, address.offset);
1490             else {
1491                 move(imm, immTempRegister);
1492                 m_assembler.sw(immTempRegister, addrTempRegister, address.offset);
1493             }
1494         }
1495     }
1496 
1497     void store32(TrustedImm32 imm, BaseIndex address)
1498     {
1499         if (!m_fixedWidth) {
1500             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
1501             if (!imm.m_value)
1502                 m_assembler.sw(MIPSRegisters::zero, addrTempRegister, address.offset);
1503             else {
1504                 move(imm, immTempRegister);
1505                 m_assembler.sw(immTempRegister, addrTempRegister, address.offset);
1506             }
1507         } else {
1508             /*
1509                 sll     addrTemp, address.index, address.scale
1510                 addu    addrTemp, addrTemp, address.base
1511                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
1512                 addu    addrTemp, addrTemp, immTemp
1513                 sw      src, (address.offset &amp; 0xffff)(at)
1514             */
1515             m_assembler.sll(addrTempRegister, address.index, address.scale);
1516             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
1517             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
1518             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
1519             move(imm, immTempRegister);
1520             m_assembler.sw(immTempRegister, addrTempRegister, address.offset);
1521         }
1522     }
1523 
1524 
1525     void store32(RegisterID src, const void* address)
1526     {
1527         if (m_fixedWidth) {
1528             /*
1529                 li  addrTemp, address
1530                 sw  src, 0(addrTemp)
1531             */
1532             move(TrustedImmPtr(address), addrTempRegister);
1533             m_assembler.sw(src, addrTempRegister, 0);
1534         } else {
1535             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1536             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1537             m_assembler.sw(src, addrTempRegister, adr &amp; 0xffff);
1538         }
1539     }
1540 
1541     void store32(TrustedImm32 imm, const void* address)
1542     {
1543         if (m_fixedWidth) {
1544             /*
1545                 li  immTemp, imm
1546                 li  addrTemp, address
1547                 sw  src, 0(addrTemp)
1548             */
1549             move(imm, immTempRegister);
1550             move(TrustedImmPtr(address), addrTempRegister);
1551             m_assembler.sw(immTempRegister, addrTempRegister, 0);
1552         } else {
1553             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address);
1554             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
1555             if (!imm.m_value)
1556                 m_assembler.sw(MIPSRegisters::zero, addrTempRegister, adr &amp; 0xffff);
1557             else {
1558                 move(imm, immTempRegister);
1559                 m_assembler.sw(immTempRegister, addrTempRegister, adr &amp; 0xffff);
1560             }
1561         }
1562     }
1563 
1564     // Floating-point operations:
1565 
1566     static bool supportsFloatingPoint()
1567     {
1568 #if WTF_MIPS_DOUBLE_FLOAT
1569         return true;
1570 #else
1571         return false;
1572 #endif
1573     }
1574 
1575     static bool supportsFloatingPointTruncate()
1576     {
1577 #if WTF_MIPS_DOUBLE_FLOAT &amp;&amp; WTF_MIPS_ISA_AT_LEAST(2)
1578         return true;
1579 #else
1580         return false;
1581 #endif
1582     }
1583 
1584     static bool supportsFloatingPointSqrt()
1585     {
1586 #if WTF_MIPS_DOUBLE_FLOAT &amp;&amp; WTF_MIPS_ISA_AT_LEAST(2)
1587         return true;
1588 #else
1589         return false;
1590 #endif
1591     }
1592 
1593     static bool supportsFloatingPointAbs()
1594     {
1595 #if WTF_MIPS_DOUBLE_FLOAT &amp;&amp; WTF_MIPS_ISA_AT_LEAST(2)
1596         return true;
1597 #else
1598         return false;
1599 #endif
1600     }
1601 
1602     static bool supportsFloatingPointRounding() { return false; }
1603 
1604     // Stack manipulation operations:
1605     //
1606     // The ABI is assumed to provide a stack abstraction to memory,
1607     // containing machine word sized units of data. Push and pop
1608     // operations add and remove a single register sized unit of data
1609     // to or from the stack. Peek and poke operations read or write
1610     // values on the stack, without moving the current stack position.
1611 
1612     void pop(RegisterID dest)
1613     {
1614         m_assembler.lw(dest, MIPSRegisters::sp, 0);
1615         m_assembler.addiu(MIPSRegisters::sp, MIPSRegisters::sp, 4);
1616     }
1617 
1618     void popPair(RegisterID dest1, RegisterID dest2)
1619     {
1620         m_assembler.lw(dest1, MIPSRegisters::sp, 0);
1621         m_assembler.lw(dest2, MIPSRegisters::sp, 4);
1622         m_assembler.addiu(MIPSRegisters::sp, MIPSRegisters::sp, 8);
1623     }
1624 
1625     void push(RegisterID src)
1626     {
1627         m_assembler.addiu(MIPSRegisters::sp, MIPSRegisters::sp, -4);
1628         m_assembler.sw(src, MIPSRegisters::sp, 0);
1629     }
1630 
1631     void push(Address address)
1632     {
1633         load32(address, dataTempRegister);
1634         push(dataTempRegister);
1635     }
1636 
1637     void push(TrustedImm32 imm)
1638     {
1639         move(imm, immTempRegister);
1640         push(immTempRegister);
1641     }
1642 
1643     void pushPair(RegisterID src1, RegisterID src2)
1644     {
1645         m_assembler.addiu(MIPSRegisters::sp, MIPSRegisters::sp, -8);
1646         m_assembler.sw(src2, MIPSRegisters::sp, 4);
1647         m_assembler.sw(src1, MIPSRegisters::sp, 0);
1648     }
1649 
1650     // Register move operations:
1651     //
1652     // Move values in registers.
1653 
1654     void move(TrustedImm32 imm, RegisterID dest)
1655     {
1656         if (!imm.m_value &amp;&amp; !m_fixedWidth)
1657             move(MIPSRegisters::zero, dest);
1658         else if (m_fixedWidth) {
1659             m_assembler.lui(dest, imm.m_value &gt;&gt; 16);
1660             m_assembler.ori(dest, dest, imm.m_value);
1661         } else
1662             m_assembler.li(dest, imm.m_value);
1663     }
1664 
1665     void move(RegisterID src, RegisterID dest)
1666     {
1667         if (src != dest || m_fixedWidth)
1668             m_assembler.move(dest, src);
1669     }
1670 
1671     void move(TrustedImmPtr imm, RegisterID dest)
1672     {
1673         move(TrustedImm32(imm), dest);
1674     }
1675 
1676     void swap(RegisterID reg1, RegisterID reg2)
1677     {
1678         move(reg1, immTempRegister);
1679         move(reg2, reg1);
1680         move(immTempRegister, reg2);
1681     }
1682 
1683     void signExtend32ToPtr(RegisterID src, RegisterID dest)
1684     {
1685         if (src != dest || m_fixedWidth)
1686             move(src, dest);
1687     }
1688 
1689     void zeroExtend32ToPtr(RegisterID src, RegisterID dest)
1690     {
1691         if (src != dest || m_fixedWidth)
1692             move(src, dest);
1693     }
1694 
1695     // Forwards / external control flow operations:
1696     //
1697     // This set of jump and conditional branch operations return a Jump
1698     // object which may linked at a later point, allow forwards jump,
1699     // or jumps that will require external linkage (after the code has been
1700     // relocated).
1701     //
1702     // For branches, signed &lt;, &gt;, &lt;= and &gt;= are denoted as l, g, le, and ge
1703     // respecitvely, for unsigned comparisons the names b, a, be, and ae are
1704     // used (representing the names &#39;below&#39; and &#39;above&#39;).
1705     //
1706     // Operands to the comparision are provided in the expected order, e.g.
1707     // jle32(reg1, TrustedImm32(5)) will branch if the value held in reg1, when
1708     // treated as a signed 32bit value, is less than or equal to 5.
1709     //
1710     // jz and jnz test whether the first operand is equal to zero, and take
1711     // an optional second operand of a mask under which to perform the test.
1712 
1713     Jump branch8(RelationalCondition cond, Address left, TrustedImm32 right)
1714     {
1715         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1716         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, dataTempRegister);
1717         return branch32(cond, dataTempRegister, right8);
1718     }
1719 
1720     Jump branch8(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
1721     {
1722         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1723         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, dataTempRegister);
1724         return branch32(cond, dataTempRegister, right8);
1725     }
1726 
1727     void compare8(RelationalCondition cond, Address left, TrustedImm32 right, RegisterID dest)
1728     {
1729         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1730         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, dataTempRegister);
1731         compare32(cond, dataTempRegister, right8, dest);
1732     }
1733 
1734     Jump branch8(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1735     {
1736         TrustedImm32 right8 = MacroAssemblerHelpers::mask8OnCondition(*this, cond, right);
1737         MacroAssemblerHelpers::load8OnCondition(*this, cond, left, dataTempRegister);
1738         return branch32(cond, dataTempRegister, right8);
1739     }
1740 
1741     Jump branchPtr(RelationalCondition cond, BaseIndex left, RegisterID right)
1742     {
1743         load32(left, dataTempRegister);
1744         return branch32(cond, dataTempRegister, right);
1745     }
1746 
1747     Jump branch32(RelationalCondition cond, RegisterID left, RegisterID right)
1748     {
1749         if (cond == Equal)
1750             return branchEqual(left, right);
1751         if (cond == NotEqual)
1752             return branchNotEqual(left, right);
1753         if (cond == Above) {
1754             m_assembler.sltu(cmpTempRegister, right, left);
1755             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1756         }
1757         if (cond == AboveOrEqual) {
1758             m_assembler.sltu(cmpTempRegister, left, right);
1759             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1760         }
1761         if (cond == Below) {
1762             m_assembler.sltu(cmpTempRegister, left, right);
1763             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1764         }
1765         if (cond == BelowOrEqual) {
1766             m_assembler.sltu(cmpTempRegister, right, left);
1767             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1768         }
1769         if (cond == GreaterThan) {
1770             m_assembler.slt(cmpTempRegister, right, left);
1771             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1772         }
1773         if (cond == GreaterThanOrEqual) {
1774             m_assembler.slt(cmpTempRegister, left, right);
1775             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1776         }
1777         if (cond == LessThan) {
1778             m_assembler.slt(cmpTempRegister, left, right);
1779             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1780         }
1781         if (cond == LessThanOrEqual) {
1782             m_assembler.slt(cmpTempRegister, right, left);
1783             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1784         }
1785         ASSERT(0);
1786 
1787         return Jump();
1788     }
1789 
1790     Jump branch32(RelationalCondition cond, RegisterID left, TrustedImm32 right)
1791     {
1792         if (!m_fixedWidth) {
1793             if (!right.m_value)
1794                 return branch32(cond, left, MIPSRegisters::zero);
1795             if (right.m_value &gt;= -32768 &amp;&amp; right.m_value &lt;= 32767) {
1796                 if (cond == AboveOrEqual) {
1797                     m_assembler.sltiu(cmpTempRegister, left, right.m_value);
1798                     return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1799                 }
1800                 if (cond == Below) {
1801                     m_assembler.sltiu(cmpTempRegister, left, right.m_value);
1802                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1803                 }
1804                 if (cond == GreaterThanOrEqual) {
1805                     m_assembler.slti(cmpTempRegister, left, right.m_value);
1806                     return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1807                 }
1808                 if (cond == LessThan) {
1809                     m_assembler.slti(cmpTempRegister, left, right.m_value);
1810                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1811                 }
1812             }
1813         }
1814         move(right, immTempRegister);
1815         return branch32(cond, left, immTempRegister);
1816     }
1817 
1818     Jump branch32(RelationalCondition cond, RegisterID left, Address right)
1819     {
1820         load32(right, dataTempRegister);
1821         return branch32(cond, left, dataTempRegister);
1822     }
1823 
1824     Jump branch32(RelationalCondition cond, Address left, RegisterID right)
1825     {
1826         load32(left, dataTempRegister);
1827         return branch32(cond, dataTempRegister, right);
1828     }
1829 
1830     Jump branch32(RelationalCondition cond, Address left, TrustedImm32 right)
1831     {
1832         load32(left, dataTempRegister);
1833         return branch32(cond, dataTempRegister, right);
1834     }
1835 
1836     Jump branch32(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1837     {
1838         load32(left, dataTempRegister);
1839         return branch32(cond, dataTempRegister, right);
1840     }
1841 
1842     Jump branch32WithUnalignedHalfWords(RelationalCondition cond, BaseIndex left, TrustedImm32 right)
1843     {
1844         load32WithUnalignedHalfWords(left, dataTempRegister);
1845         return branch32(cond, dataTempRegister, right);
1846     }
1847 
1848     Jump branch32(RelationalCondition cond, AbsoluteAddress left, RegisterID right)
1849     {
1850         load32(left.m_ptr, dataTempRegister);
1851         return branch32(cond, dataTempRegister, right);
1852     }
1853 
1854     Jump branch32(RelationalCondition cond, AbsoluteAddress left, TrustedImm32 right)
1855     {
1856         load32(left.m_ptr, dataTempRegister);
1857         return branch32(cond, dataTempRegister, right);
1858     }
1859 
1860     Jump branchTest32(ResultCondition cond, RegisterID reg, RegisterID mask)
1861     {
1862         ASSERT((cond == Zero) || (cond == NonZero) || (cond == Signed));
1863         m_assembler.andInsn(cmpTempRegister, reg, mask);
1864         switch (cond) {
1865         case Zero:
1866             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1867         case NonZero:
1868             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1869         case Signed:
1870             m_assembler.slt(cmpTempRegister, cmpTempRegister, MIPSRegisters::zero);
1871             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1872         default:
1873             RELEASE_ASSERT_NOT_REACHED();
1874         }
1875     }
1876 
1877     Jump branchTest32(ResultCondition cond, RegisterID reg, TrustedImm32 mask = TrustedImm32(-1))
1878     {
1879         ASSERT((cond == Zero) || (cond == NonZero) || (cond == Signed));
1880         if (!m_fixedWidth) {
1881             if (mask.m_value == -1) {
1882                 switch (cond) {
1883                 case Zero:
1884                     return branchEqual(reg, MIPSRegisters::zero);
1885                 case NonZero:
1886                     return branchNotEqual(reg, MIPSRegisters::zero);
1887                 case Signed:
1888                     m_assembler.slt(cmpTempRegister, reg, MIPSRegisters::zero);
1889                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1890                 default:
1891                     RELEASE_ASSERT_NOT_REACHED();
1892                 }
1893             }
1894 #if WTF_MIPS_ISA_REV(2)
1895             if (isPowerOf2(mask.m_value)) {
1896                 uint16_t pos= bitPosition(mask.m_value);
1897                 m_assembler.ext(cmpTempRegister, reg, pos, 1);
1898                 switch (cond) {
1899                 case Zero:
1900                     return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1901                 case NonZero:
1902                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1903                 case Signed:
1904                     m_assembler.slt(cmpTempRegister, cmpTempRegister, MIPSRegisters::zero);
1905                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1906                 default:
1907                     RELEASE_ASSERT_NOT_REACHED();
1908                 }
1909             }
1910 #endif
1911             if (mask.m_value &gt;= 0 &amp;&amp; mask.m_value &lt;= 65535) {
1912                 m_assembler.andi(cmpTempRegister, reg, mask.m_value);
1913                 switch (cond) {
1914                 case Zero:
1915                     return branchEqual(cmpTempRegister, MIPSRegisters::zero);
1916                 case NonZero:
1917                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1918                 case Signed:
1919                     m_assembler.slt(cmpTempRegister, cmpTempRegister, MIPSRegisters::zero);
1920                     return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
1921                 default:
1922                     RELEASE_ASSERT_NOT_REACHED();
1923                 }
1924             }
1925         }
1926         move(mask, immTempRegister);
1927         return branchTest32(cond, reg, immTempRegister);
1928     }
1929 
1930     Jump branchTest32(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
1931     {
1932         load32(address, dataTempRegister);
1933         return branchTest32(cond, dataTempRegister, mask);
1934     }
1935 
1936     Jump branchTest32(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
1937     {
1938         load32(address, dataTempRegister);
1939         return branchTest32(cond, dataTempRegister, mask);
1940     }
1941 
1942     TrustedImm32 mask8OnTest(ResultCondition cond, TrustedImm32 mask)
1943     {
1944         if (mask.m_value == -1 &amp;&amp; !m_fixedWidth)
1945             return TrustedImm32(-1);
1946         return MacroAssemblerHelpers::mask8OnCondition(*this, cond, mask);
1947     }
1948 
1949     Jump branchTest8(ResultCondition cond, BaseIndex address, TrustedImm32 mask = TrustedImm32(-1))
1950     {
1951         TrustedImm32 mask8 = mask8OnTest(cond, mask);
1952         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, dataTempRegister);
1953         return branchTest32(cond, dataTempRegister, mask8);
1954     }
1955 
1956     Jump branchTest8(ResultCondition cond, Address address, TrustedImm32 mask = TrustedImm32(-1))
1957     {
1958         TrustedImm32 mask8 = mask8OnTest(cond, mask);
1959         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, dataTempRegister);
1960         return branchTest32(cond, dataTempRegister, mask8);
1961     }
1962 
1963     Jump branchTest8(ResultCondition cond, AbsoluteAddress address, TrustedImm32 mask = TrustedImm32(-1))
1964     {
1965         TrustedImm32 mask8 = mask8OnTest(cond, mask);
1966         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, dataTempRegister);
1967         return branchTest32(cond, dataTempRegister, mask8);
1968     }
1969 
1970     Jump jump()
1971     {
1972         return branchEqual(MIPSRegisters::zero, MIPSRegisters::zero);
1973     }
1974 
1975     void farJump(RegisterID target, PtrTag)
1976     {
1977         move(target, MIPSRegisters::t9);
1978         m_assembler.jr(MIPSRegisters::t9);
1979         m_assembler.nop();
1980     }
1981 
1982     void farJump(Address address, PtrTag)
1983     {
1984         m_fixedWidth = true;
1985         load32(address, MIPSRegisters::t9);
1986         m_assembler.jr(MIPSRegisters::t9);
1987         m_assembler.nop();
1988         m_fixedWidth = false;
1989     }
1990 
1991     void farJump(AbsoluteAddress address, PtrTag)
1992     {
1993         m_fixedWidth = true;
1994         load32(address.m_ptr, MIPSRegisters::t9);
1995         m_assembler.jr(MIPSRegisters::t9);
1996         m_assembler.nop();
1997         m_fixedWidth = false;
1998     }
1999 
2000     ALWAYS_INLINE void farJump(RegisterID target, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(target, NoPtrTag); }
2001     ALWAYS_INLINE void farJump(Address address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
2002     ALWAYS_INLINE void farJump(AbsoluteAddress address, RegisterID jumpTag) { UNUSED_PARAM(jumpTag), farJump(address, NoPtrTag); }
2003 
2004     void moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2)
2005     {
2006         m_assembler.vmov(dest1, dest2, src);
2007     }
2008 
2009     void moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch)
2010     {
2011         UNUSED_PARAM(scratch);
2012         m_assembler.vmov(dest, src1, src2);
2013     }
2014 
2015     // Arithmetic control flow operations:
2016     //
2017     // This set of conditional branch operations branch based
2018     // on the result of an arithmetic operation. The operation
2019     // is performed as normal, storing the result.
2020     //
2021     // * jz operations branch if the result is zero.
2022     // * jo operations branch if the (signed) arithmetic
2023     //   operation caused an overflow to occur.
2024 
2025     Jump branchAdd32(ResultCondition cond, RegisterID src, RegisterID dest)
2026     {
2027         ASSERT((cond == Overflow) || (cond == Signed) || (cond == PositiveOrZero) || (cond == Zero) || (cond == NonZero));
2028         if (cond == Overflow) {
2029             /*
2030                 move    dest, dataTemp
2031                 xor     cmpTemp, dataTemp, src
2032                 bltz    cmpTemp, No_overflow    # diff sign bit -&gt; no overflow
2033                 addu    dest, dataTemp, src
2034                 xor     cmpTemp, dest, dataTemp
2035                 bgez    cmpTemp, No_overflow    # same sign big -&gt; no overflow
2036                 nop
2037                 b       Overflow
2038                 nop
2039                 b       No_overflow
2040                 nop
2041                 nop
2042                 nop
2043             No_overflow:
2044             */
2045             move(dest, dataTempRegister);
2046             m_assembler.xorInsn(cmpTempRegister, dataTempRegister, src);
2047             m_assembler.bltz(cmpTempRegister, 10);
2048             m_assembler.addu(dest, dataTempRegister, src);
2049             m_assembler.xorInsn(cmpTempRegister, dest, dataTempRegister);
2050             m_assembler.bgez(cmpTempRegister, 7);
2051             m_assembler.nop();
2052             return jump();
2053         }
2054         if (cond == Signed) {
2055             add32(src, dest);
2056             // Check if dest is negative.
2057             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2058             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2059         }
2060         if (cond == PositiveOrZero) {
2061             add32(src, dest);
2062             // Check if dest is not negative.
2063             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2064             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
2065         }
2066         if (cond == Zero) {
2067             add32(src, dest);
2068             return branchEqual(dest, MIPSRegisters::zero);
2069         }
2070         if (cond == NonZero) {
2071             add32(src, dest);
2072             return branchNotEqual(dest, MIPSRegisters::zero);
2073         }
2074         ASSERT(0);
2075         return Jump();
2076     }
2077 
2078     Jump branchAdd32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
2079     {
2080         ASSERT((cond == Overflow) || (cond == Signed) || (cond == PositiveOrZero) || (cond == Zero) || (cond == NonZero));
2081         if (cond == Overflow) {
2082             /*
2083                 move    dataTemp, op1
2084                 xor     cmpTemp, dataTemp, op2
2085                 bltz    cmpTemp, No_overflow    # diff sign bit -&gt; no overflow
2086                 addu    dest, dataTemp, op2
2087                 xor     cmpTemp, dest, dataTemp
2088                 bgez    cmpTemp, No_overflow    # same sign big -&gt; no overflow
2089                 nop
2090                 b       Overflow
2091                 nop
2092                 b       No_overflow
2093                 nop
2094                 nop
2095                 nop
2096             No_overflow:
2097             */
2098             move(op1, dataTempRegister);
2099             m_assembler.xorInsn(cmpTempRegister, dataTempRegister, op2);
2100             m_assembler.bltz(cmpTempRegister, 10);
2101             m_assembler.addu(dest, dataTempRegister, op2);
2102             m_assembler.xorInsn(cmpTempRegister, dest, dataTempRegister);
2103             m_assembler.bgez(cmpTempRegister, 7);
2104             m_assembler.nop();
2105             return jump();
2106         }
2107         if (cond == Signed) {
2108             add32(op1, op2, dest);
2109             // Check if dest is negative.
2110             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2111             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2112         }
2113         if (cond == PositiveOrZero) {
2114             add32(op1, op2, dest);
2115             // Check if dest is not negative.
2116             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2117             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
2118         }
2119         if (cond == Zero) {
2120             add32(op1, op2, dest);
2121             return branchEqual(dest, MIPSRegisters::zero);
2122         }
2123         if (cond == NonZero) {
2124             add32(op1, op2, dest);
2125             return branchNotEqual(dest, MIPSRegisters::zero);
2126         }
2127         ASSERT(0);
2128         return Jump();
2129     }
2130 
2131     Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
2132     {
2133         return branchAdd32(cond, dest, imm, dest);
2134     }
2135 
2136     Jump branchAdd32(ResultCondition cond, Address address, RegisterID dest)
2137     {
2138         load32(address, immTempRegister);
2139         return branchAdd32(cond, immTempRegister, dest);
2140     }
2141 
2142     Jump branchAdd32(ResultCondition cond, RegisterID src, TrustedImm32 imm, RegisterID dest)
2143     {
2144         if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt;= 32767 &amp;&amp; !m_fixedWidth) {
2145             ASSERT((cond == Overflow) || (cond == Signed) || (cond == PositiveOrZero) || (cond == Zero) || (cond == NonZero));
2146             if (cond == Overflow) {
2147                 if (imm.m_value &gt;= 0) {
2148                     m_assembler.bltz(src, 9);
2149                     m_assembler.addiu(dest, src, imm.m_value);
2150                     m_assembler.bgez(dest, 7);
2151                     m_assembler.nop();
2152                 } else {
2153                     m_assembler.bgez(src, 9);
2154                     m_assembler.addiu(dest, src, imm.m_value);
2155                     m_assembler.bltz(dest, 7);
2156                     m_assembler.nop();
2157                 }
2158                 return jump();
2159             }
2160             m_assembler.addiu(dest, src, imm.m_value);
2161             if (cond == Signed) {
2162                 // Check if dest is negative.
2163                 m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2164                 return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2165             }
2166             if (cond == PositiveOrZero) {
2167                 // Check if dest is not negative.
2168                 m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2169                 return branchEqual(cmpTempRegister, MIPSRegisters::zero);
2170             }
2171             if (cond == Zero)
2172                 return branchEqual(dest, MIPSRegisters::zero);
2173             if (cond == NonZero)
2174                 return branchNotEqual(dest, MIPSRegisters::zero);
2175             ASSERT_NOT_REACHED();
2176             return Jump();
2177         }
2178         move(imm, immTempRegister);
2179         return branchAdd32(cond, src, immTempRegister, dest);
2180     }
2181 
2182     Jump branchAdd32(ResultCondition cond, TrustedImm32 imm, AbsoluteAddress dest)
2183     {
2184         ASSERT((cond == Overflow) || (cond == Signed) || (cond == PositiveOrZero) || (cond == Zero) || (cond == NonZero));
2185         if (cond == Overflow) {
2186             if (m_fixedWidth) {
2187                 /*
2188                     load    dest, dataTemp
2189                     move    imm, immTemp
2190                     xor     cmpTemp, dataTemp, immTemp
2191                     addu    dataTemp, dataTemp, immTemp
2192                     store   dataTemp, dest
2193                     bltz    cmpTemp, No_overflow    # diff sign bit -&gt; no overflow
2194                     xor     cmpTemp, dataTemp, immTemp
2195                     bgez    cmpTemp, No_overflow    # same sign big -&gt; no overflow
2196                     nop
2197                     b       Overflow
2198                     nop
2199                     b       No_overflow
2200                     nop
2201                     nop
2202                     nop
2203                 No_overflow:
2204                 */
2205                 load32(dest.m_ptr, dataTempRegister);
2206                 move(imm, immTempRegister);
2207                 m_assembler.xorInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2208                 m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
2209                 store32(dataTempRegister, dest.m_ptr);
2210                 m_assembler.bltz(cmpTempRegister, 9);
2211                 m_assembler.xorInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2212                 m_assembler.bgez(cmpTempRegister, 7);
2213                 m_assembler.nop();
2214             } else {
2215                 uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);
2216                 m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
2217                 m_assembler.lw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2218                 if (imm.m_value &gt;= 0 &amp;&amp; imm.m_value  &lt;= 32767) {
2219                     move(dataTempRegister, cmpTempRegister);
2220                     m_assembler.addiu(dataTempRegister, dataTempRegister, imm.m_value);
2221                     m_assembler.bltz(cmpTempRegister, 9);
2222                     m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2223                     m_assembler.bgez(dataTempRegister, 7);
2224                     m_assembler.nop();
2225                 } else if (imm.m_value &gt;= -32768 &amp;&amp; imm.m_value &lt; 0) {
2226                     move(dataTempRegister, cmpTempRegister);
2227                     m_assembler.addiu(dataTempRegister, dataTempRegister, imm.m_value);
2228                     m_assembler.bgez(cmpTempRegister, 9);
2229                     m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2230                     m_assembler.bltz(cmpTempRegister, 7);
2231                     m_assembler.nop();
2232                 } else {
2233                     move(imm, immTempRegister);
2234                     m_assembler.xorInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2235                     m_assembler.addu(dataTempRegister, dataTempRegister, immTempRegister);
2236                     m_assembler.bltz(cmpTempRegister, 10);
2237                     m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2238                     m_assembler.xorInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2239                     m_assembler.bgez(cmpTempRegister, 7);
2240                     m_assembler.nop();
2241                 }
2242             }
2243             return jump();
2244         }
2245         if (m_fixedWidth) {
2246             move(imm, immTempRegister);
2247             load32(dest.m_ptr, dataTempRegister);
2248             add32(immTempRegister, dataTempRegister);
2249             store32(dataTempRegister, dest.m_ptr);
2250         } else {
2251             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(dest.m_ptr);
2252             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
2253             m_assembler.lw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2254             add32(imm, dataTempRegister);
2255             m_assembler.sw(dataTempRegister, addrTempRegister, adr &amp; 0xffff);
2256         }
2257         if (cond == Signed) {
2258             // Check if dest is negative.
2259             m_assembler.slt(cmpTempRegister, dataTempRegister, MIPSRegisters::zero);
2260             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2261         }
2262         if (cond == PositiveOrZero) {
2263             // Check if dest is not negative.
2264             m_assembler.slt(cmpTempRegister, dataTempRegister, MIPSRegisters::zero);
2265             return branchEqual(cmpTempRegister, MIPSRegisters::zero);
2266         }
2267         if (cond == Zero)
2268             return branchEqual(dataTempRegister, MIPSRegisters::zero);
2269         if (cond == NonZero)
2270             return branchNotEqual(dataTempRegister, MIPSRegisters::zero);
2271         ASSERT(0);
2272         return Jump();
2273     }
2274 
2275     Jump branchMul32(ResultCondition cond, RegisterID src1, RegisterID src2, RegisterID dest)
2276     {
2277         ASSERT((cond == Overflow) || (cond == Signed) || (cond == Zero) || (cond == NonZero));
2278         if (cond == Overflow) {
2279             /*
2280                 mult    src, dest
2281                 mfhi    dataTemp
2282                 mflo    dest
2283                 sra     addrTemp, dest, 31
2284                 beq     dataTemp, addrTemp, No_overflow # all sign bits (bit 63 to bit 31) are the same -&gt; no overflow
2285                 nop
2286                 b       Overflow
2287                 nop
2288                 b       No_overflow
2289                 nop
2290                 nop
2291                 nop
2292             No_overflow:
2293             */
2294             m_assembler.mult(src1, src2);
2295             m_assembler.mfhi(dataTempRegister);
2296             m_assembler.mflo(dest);
2297             m_assembler.sra(addrTempRegister, dest, 31);
2298             m_assembler.beq(dataTempRegister, addrTempRegister, 7);
2299             m_assembler.nop();
2300             return jump();
2301         }
2302         if (cond == Signed) {
2303             mul32(src1, src2, dest);
2304             // Check if dest is negative.
2305             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2306             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2307         }
2308         if (cond == Zero) {
2309             mul32(src1, src2, dest);
2310             return branchEqual(dest, MIPSRegisters::zero);
2311         }
2312         if (cond == NonZero) {
2313             mul32(src1, src2, dest);
2314             return branchNotEqual(dest, MIPSRegisters::zero);
2315         }
2316         ASSERT(0);
2317         return Jump();
2318     }
2319 
2320     Jump branchMul32(ResultCondition cond, RegisterID src, RegisterID dest)
2321     {
2322         ASSERT((cond == Overflow) || (cond == Signed) || (cond == Zero) || (cond == NonZero));
2323         if (cond == Overflow) {
2324             /*
2325                 mult    src, dest
2326                 mfhi    dataTemp
2327                 mflo    dest
2328                 sra     addrTemp, dest, 31
2329                 beq     dataTemp, addrTemp, No_overflow # all sign bits (bit 63 to bit 31) are the same -&gt; no overflow
2330                 nop
2331                 b       Overflow
2332                 nop
2333                 b       No_overflow
2334                 nop
2335                 nop
2336                 nop
2337             No_overflow:
2338             */
2339             m_assembler.mult(src, dest);
2340             m_assembler.mfhi(dataTempRegister);
2341             m_assembler.mflo(dest);
2342             m_assembler.sra(addrTempRegister, dest, 31);
2343             m_assembler.beq(dataTempRegister, addrTempRegister, 7);
2344             m_assembler.nop();
2345             return jump();
2346         }
2347         if (cond == Signed) {
2348             mul32(src, dest);
2349             // Check if dest is negative.
2350             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2351             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2352         }
2353         if (cond == Zero) {
2354             mul32(src, dest);
2355             return branchEqual(dest, MIPSRegisters::zero);
2356         }
2357         if (cond == NonZero) {
2358             mul32(src, dest);
2359             return branchNotEqual(dest, MIPSRegisters::zero);
2360         }
2361         ASSERT(0);
2362         return Jump();
2363     }
2364 
2365     Jump branchMul32(ResultCondition cond, RegisterID src, TrustedImm32 imm, RegisterID dest)
2366     {
2367         move(imm, immTempRegister);
2368         return branchMul32(cond, immTempRegister, src, dest);
2369     }
2370 
2371     Jump branchSub32(ResultCondition cond, RegisterID src, RegisterID dest)
2372     {
2373         ASSERT((cond == Overflow) || (cond == Signed) || (cond == Zero) || (cond == NonZero));
2374         if (cond == Overflow) {
2375             /*
2376                 move    dest, dataTemp
2377                 xor     cmpTemp, dataTemp, src
2378                 bgez    cmpTemp, No_overflow    # same sign bit -&gt; no overflow
2379                 subu    dest, dataTemp, src
2380                 xor     cmpTemp, dest, dataTemp
2381                 bgez    cmpTemp, No_overflow    # same sign bit -&gt; no overflow
2382                 nop
2383                 b       Overflow
2384                 nop
2385                 b       No_overflow
2386                 nop
2387                 nop
2388                 nop
2389             No_overflow:
2390             */
2391             move(dest, dataTempRegister);
2392             m_assembler.xorInsn(cmpTempRegister, dataTempRegister, src);
2393             m_assembler.bgez(cmpTempRegister, 10);
2394             m_assembler.subu(dest, dataTempRegister, src);
2395             m_assembler.xorInsn(cmpTempRegister, dest, dataTempRegister);
2396             m_assembler.bgez(cmpTempRegister, 7);
2397             m_assembler.nop();
2398             return jump();
2399         }
2400         if (cond == Signed) {
2401             sub32(src, dest);
2402             // Check if dest is negative.
2403             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2404             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2405         }
2406         if (cond == Zero) {
2407             sub32(src, dest);
2408             return branchEqual(dest, MIPSRegisters::zero);
2409         }
2410         if (cond == NonZero) {
2411             sub32(src, dest);
2412             return branchNotEqual(dest, MIPSRegisters::zero);
2413         }
2414         ASSERT(0);
2415         return Jump();
2416     }
2417 
2418     Jump branchSub32(ResultCondition cond, TrustedImm32 imm, RegisterID dest)
2419     {
2420         move(imm, immTempRegister);
2421         return branchSub32(cond, immTempRegister, dest);
2422     }
2423 
2424     Jump branchSub32(ResultCondition cond, RegisterID src, TrustedImm32 imm, RegisterID dest)
2425     {
2426         move(imm, immTempRegister);
2427         return branchSub32(cond, src, immTempRegister, dest);
2428     }
2429 
2430     Jump branchSub32(ResultCondition cond, RegisterID op1, RegisterID op2, RegisterID dest)
2431     {
2432         ASSERT((cond == Overflow) || (cond == Signed) || (cond == Zero) || (cond == NonZero));
2433         if (cond == Overflow) {
2434             /*
2435                 move    dataTemp, op1
2436                 xor     cmpTemp, dataTemp, op2
2437                 bgez    cmpTemp, No_overflow    # same sign bit -&gt; no overflow
2438                 subu    dest, dataTemp, op2
2439                 xor     cmpTemp, dest, dataTemp
2440                 bgez    cmpTemp, No_overflow    # same sign bit -&gt; no overflow
2441                 nop
2442                 b       Overflow
2443                 nop
2444                 b       No_overflow
2445                 nop
2446                 nop
2447                 nop
2448             No_overflow:
2449             */
2450             move(op1, dataTempRegister);
2451             m_assembler.xorInsn(cmpTempRegister, dataTempRegister, op2);
2452             m_assembler.bgez(cmpTempRegister, 10);
2453             m_assembler.subu(dest, dataTempRegister, op2);
2454             m_assembler.xorInsn(cmpTempRegister, dest, dataTempRegister);
2455             m_assembler.bgez(cmpTempRegister, 7);
2456             m_assembler.nop();
2457             return jump();
2458         }
2459         if (cond == Signed) {
2460             sub32(op1, op2, dest);
2461             // Check if dest is negative.
2462             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2463             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2464         }
2465         if (cond == Zero) {
2466             sub32(op1, op2, dest);
2467             return branchEqual(dest, MIPSRegisters::zero);
2468         }
2469         if (cond == NonZero) {
2470             sub32(op1, op2, dest);
2471             return branchNotEqual(dest, MIPSRegisters::zero);
2472         }
2473         ASSERT(0);
2474         return Jump();
2475     }
2476 
2477     Jump branchNeg32(ResultCondition cond, RegisterID srcDest)
2478     {
2479         ASSERT((cond == Overflow) || (cond == Signed) || (cond == Zero) || (cond == NonZero));
2480         if (cond == Overflow) {
2481             /*
2482                 bgez    srcDest, No_overflow    # positive input -&gt; no overflow
2483                 subu    srcDest, zero, srcDest
2484                 bgez    srcDest, No_overflow    # negative input, positive output -&gt; no overflow
2485                 nop
2486                 b       Overflow
2487                 nop
2488                 b       No_overflow
2489                 nop
2490                 nop
2491                 nop
2492             No_overflow:
2493             */
2494             m_assembler.bgez(srcDest, 9);
2495             m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
2496             m_assembler.bgez(srcDest, 7);
2497             m_assembler.nop();
2498             return jump();
2499         }
2500         if (cond == Signed) {
2501             m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
2502             // Check if dest is negative.
2503             m_assembler.slt(cmpTempRegister, srcDest, MIPSRegisters::zero);
2504             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2505         }
2506         if (cond == Zero) {
2507             m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
2508             return branchEqual(srcDest, MIPSRegisters::zero);
2509         }
2510         if (cond == NonZero) {
2511             m_assembler.subu(srcDest, MIPSRegisters::zero, srcDest);
2512             return branchNotEqual(srcDest, MIPSRegisters::zero);
2513         }
2514         ASSERT_NOT_REACHED();
2515         return Jump();
2516     }
2517 
2518     Jump branchOr32(ResultCondition cond, RegisterID src, RegisterID dest)
2519     {
2520         ASSERT((cond == Signed) || (cond == Zero) || (cond == NonZero));
2521         if (cond == Signed) {
2522             or32(src, dest);
2523             // Check if dest is negative.
2524             m_assembler.slt(cmpTempRegister, dest, MIPSRegisters::zero);
2525             return branchNotEqual(cmpTempRegister, MIPSRegisters::zero);
2526         }
2527         if (cond == Zero) {
2528             or32(src, dest);
2529             return branchEqual(dest, MIPSRegisters::zero);
2530         }
2531         if (cond == NonZero) {
2532             or32(src, dest);
2533             return branchNotEqual(dest, MIPSRegisters::zero);
2534         }
2535         ASSERT(0);
2536         return Jump();
2537     }
2538 
2539     // Miscellaneous operations:
2540 
2541     void breakpoint()
2542     {
2543         m_assembler.bkpt();
2544     }
2545 
2546     static bool isBreakpoint(void* address) { return MIPSAssembler::isBkpt(address); }
2547 
2548     Call nearCall()
2549     {
2550         /* We need two words for relaxation. */
2551         m_assembler.nop();
2552         m_assembler.nop();
2553         m_assembler.jal();
2554         m_assembler.nop();
2555         return Call(m_assembler.label(), Call::LinkableNear);
2556     }
2557 
2558     Call nearTailCall()
2559     {
2560         m_assembler.nop();
2561         m_assembler.nop();
2562         m_assembler.beq(MIPSRegisters::zero, MIPSRegisters::zero, 0);
2563         m_assembler.nop();
2564         insertRelaxationWords();
2565         return Call(m_assembler.label(), Call::LinkableNearTail);
2566     }
2567 
2568     Call call(PtrTag)
2569     {
2570         m_assembler.lui(MIPSRegisters::t9, 0);
2571         m_assembler.ori(MIPSRegisters::t9, MIPSRegisters::t9, 0);
2572         m_assembler.jalr(MIPSRegisters::t9);
2573         m_assembler.nop();
2574         return Call(m_assembler.label(), Call::Linkable);
2575     }
2576 
2577     Call call(RegisterID target, PtrTag)
2578     {
2579         move(target, MIPSRegisters::t9);
2580         m_assembler.jalr(MIPSRegisters::t9);
2581         m_assembler.nop();
2582         return Call(m_assembler.label(), Call::None);
2583     }
2584 
2585     Call call(Address address, PtrTag)
2586     {
2587         m_fixedWidth = true;
2588         load32(address, MIPSRegisters::t9);
2589         m_assembler.jalr(MIPSRegisters::t9);
2590         m_assembler.nop();
2591         m_fixedWidth = false;
2592         return Call(m_assembler.label(), Call::None);
2593     }
2594 
2595     ALWAYS_INLINE Call call(RegisterID callTag) { return UNUSED_PARAM(callTag), call(NoPtrTag); }
2596     ALWAYS_INLINE Call call(RegisterID target, RegisterID callTag) { return UNUSED_PARAM(callTag), call(target, NoPtrTag); }
2597     ALWAYS_INLINE Call call(Address address, RegisterID callTag) { return UNUSED_PARAM(callTag), call(address, NoPtrTag); }
2598 
2599     void ret()
2600     {
2601         m_assembler.jr(MIPSRegisters::ra);
2602         m_assembler.nop();
2603     }
2604 
2605     void compare32(RelationalCondition cond, RegisterID left, RegisterID right, RegisterID dest)
2606     {
2607         if (cond == Equal) {
2608             if (right == MIPSRegisters::zero &amp;&amp; !m_fixedWidth)
2609                 m_assembler.sltiu(dest, left, 1);
2610             else {
2611                 m_assembler.xorInsn(dest, left, right);
2612                 m_assembler.sltiu(dest, dest, 1);
2613             }
2614         } else if (cond == NotEqual) {
2615             if (right == MIPSRegisters::zero &amp;&amp; !m_fixedWidth)
2616                 m_assembler.sltu(dest, MIPSRegisters::zero, left);
2617             else {
2618                 m_assembler.xorInsn(dest, left, right);
2619                 m_assembler.sltu(dest, MIPSRegisters::zero, dest);
2620             }
2621         } else if (cond == Above)
2622             m_assembler.sltu(dest, right, left);
2623         else if (cond == AboveOrEqual) {
2624             m_assembler.sltu(dest, left, right);
2625             m_assembler.xori(dest, dest, 1);
2626         } else if (cond == Below)
2627             m_assembler.sltu(dest, left, right);
2628         else if (cond == BelowOrEqual) {
2629             m_assembler.sltu(dest, right, left);
2630             m_assembler.xori(dest, dest, 1);
2631         } else if (cond == GreaterThan)
2632             m_assembler.slt(dest, right, left);
2633         else if (cond == GreaterThanOrEqual) {
2634             m_assembler.slt(dest, left, right);
2635             m_assembler.xori(dest, dest, 1);
2636         } else if (cond == LessThan)
2637             m_assembler.slt(dest, left, right);
2638         else if (cond == LessThanOrEqual) {
2639             m_assembler.slt(dest, right, left);
2640             m_assembler.xori(dest, dest, 1);
2641         }
2642     }
2643 
2644     void compare32(RelationalCondition cond, RegisterID left, TrustedImm32 right, RegisterID dest)
2645     {
2646         if (!right.m_value &amp;&amp; !m_fixedWidth)
2647             compare32(cond, left, MIPSRegisters::zero, dest);
2648         else {
2649             move(right, immTempRegister);
2650             compare32(cond, left, immTempRegister, dest);
2651         }
2652     }
2653 
2654     void test8(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
2655     {
2656         ASSERT((cond == Zero) || (cond == NonZero));
2657         TrustedImm32 mask8 = mask8OnTest(cond, mask);
2658         MacroAssemblerHelpers::load8OnCondition(*this, cond, address, dataTempRegister);
2659         if ((mask8.m_value &amp; 0xff) == 0xff &amp;&amp; !m_fixedWidth) {
2660             if (cond == Zero)
2661                 m_assembler.sltiu(dest, dataTempRegister, 1);
2662             else
2663                 m_assembler.sltu(dest, MIPSRegisters::zero, dataTempRegister);
2664         } else {
2665             move(mask8, immTempRegister);
2666             m_assembler.andInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2667             if (cond == Zero)
2668                 m_assembler.sltiu(dest, cmpTempRegister, 1);
2669             else
2670                 m_assembler.sltu(dest, MIPSRegisters::zero, cmpTempRegister);
2671         }
2672     }
2673 
2674     void test32(ResultCondition cond, Address address, TrustedImm32 mask, RegisterID dest)
2675     {
2676         ASSERT((cond == Zero) || (cond == NonZero));
2677         load32(address, dataTempRegister);
2678         if (mask.m_value == -1 &amp;&amp; !m_fixedWidth) {
2679             if (cond == Zero)
2680                 m_assembler.sltiu(dest, dataTempRegister, 1);
2681             else
2682                 m_assembler.sltu(dest, MIPSRegisters::zero, dataTempRegister);
2683         } else {
2684             move(mask, immTempRegister);
2685             m_assembler.andInsn(cmpTempRegister, dataTempRegister, immTempRegister);
2686             if (cond == Zero)
2687                 m_assembler.sltiu(dest, cmpTempRegister, 1);
2688             else
2689                 m_assembler.sltu(dest, MIPSRegisters::zero, cmpTempRegister);
2690         }
2691     }
2692 
2693     DataLabel32 moveWithPatch(TrustedImm32 imm, RegisterID dest)
2694     {
2695         m_fixedWidth = true;
2696         DataLabel32 label(this);
2697         move(imm, dest);
2698         m_fixedWidth = false;
2699         return label;
2700     }
2701 
2702     DataLabelPtr moveWithPatch(TrustedImmPtr initialValue, RegisterID dest)
2703     {
2704         m_fixedWidth = true;
2705         DataLabelPtr label(this);
2706         move(initialValue, dest);
2707         m_fixedWidth = false;
2708         return label;
2709     }
2710 
2711     Jump branchPtrWithPatch(RelationalCondition cond, RegisterID left, DataLabelPtr&amp; dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(nullptr))
2712     {
2713         m_fixedWidth = true;
2714         dataLabel = moveWithPatch(initialRightValue, immTempRegister);
2715         m_assembler.nop();
2716         m_assembler.nop();
2717         Jump temp = branch32(cond, left, immTempRegister);
2718         m_fixedWidth = false;
2719         return temp;
2720     }
2721 
2722     Jump branchPtrWithPatch(RelationalCondition cond, Address left, DataLabelPtr&amp; dataLabel, TrustedImmPtr initialRightValue = TrustedImmPtr(nullptr))
2723     {
2724         m_fixedWidth = true;
2725         load32(left, dataTempRegister);
2726         dataLabel = moveWithPatch(initialRightValue, immTempRegister);
2727         m_assembler.nop();
2728         m_assembler.nop();
2729         Jump temp = branch32(cond, dataTempRegister, immTempRegister);
2730         m_fixedWidth = false;
2731         return temp;
2732     }
2733 
2734     Jump branch32WithPatch(RelationalCondition cond, Address left, DataLabel32&amp; dataLabel, TrustedImm32 initialRightValue = TrustedImm32(0))
2735     {
2736         m_fixedWidth = true;
2737         load32(left, dataTempRegister);
2738         dataLabel = moveWithPatch(initialRightValue, immTempRegister);
2739         Jump temp = branch32(cond, dataTempRegister, immTempRegister);
2740         m_fixedWidth = false;
2741         return temp;
2742     }
2743 
2744     DataLabelPtr storePtrWithPatch(TrustedImmPtr initialValue, ImplicitAddress address)
2745     {
2746         m_fixedWidth = true;
2747         DataLabelPtr dataLabel = moveWithPatch(initialValue, dataTempRegister);
2748         store32(dataTempRegister, address);
2749         m_fixedWidth = false;
2750         return dataLabel;
2751     }
2752 
2753     DataLabelPtr storePtrWithPatch(ImplicitAddress address)
2754     {
2755         return storePtrWithPatch(TrustedImmPtr(nullptr), address);
2756     }
2757 
2758     void loadFloat(BaseIndex address, FPRegisterID dest)
2759     {
2760         if (!m_fixedWidth) {
2761             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2762             m_assembler.lwc1(dest, addrTempRegister, address.offset);
2763         } else {
2764             /*
2765                 sll     addrTemp, address.index, address.scale
2766                 addu    addrTemp, addrTemp, address.base
2767                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2768                 addu    addrTemp, addrTemp, immTemp
2769                 lwc1    dest, (address.offset &amp; 0xffff)(at)
2770             */
2771             m_assembler.sll(addrTempRegister, address.index, address.scale);
2772             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2773             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2774             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
2775             m_assembler.lwc1(dest, addrTempRegister, address.offset);
2776         }
2777     }
2778 
2779     void loadFloat(ImplicitAddress address, FPRegisterID dest)
2780     {
2781         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
2782             &amp;&amp; !m_fixedWidth) {
2783             m_assembler.lwc1(dest, address.base, address.offset);
2784         } else {
2785             /*
2786                lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
2787                addu    addrTemp, addrTemp, base
2788                lwc1    dest, (offset &amp; 0xffff)(addrTemp)
2789                */
2790             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2791             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2792             m_assembler.lwc1(dest, addrTempRegister, address.offset);
2793         }
2794     }
2795 
2796     void loadDouble(ImplicitAddress address, FPRegisterID dest)
2797     {
2798 #if WTF_MIPS_ISA(1)
2799         /*
2800             li          addrTemp, address.offset
2801             addu        addrTemp, addrTemp, base
2802             lwc1        dest, 0(addrTemp)
2803             lwc1        dest+1, 4(addrTemp)
2804          */
2805         move(TrustedImm32(address.offset), addrTempRegister);
2806         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2807         m_assembler.lwc1(dest, addrTempRegister, 0);
2808         m_assembler.lwc1(FPRegisterID(dest + 1), addrTempRegister, 4);
2809 #else
2810         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
2811             &amp;&amp; !m_fixedWidth) {
2812             m_assembler.ldc1(dest, address.base, address.offset);
2813         } else {
2814             /*
2815                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
2816                 addu    addrTemp, addrTemp, base
2817                 ldc1    dest, (offset &amp; 0xffff)(addrTemp)
2818               */
2819             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2820             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2821             m_assembler.ldc1(dest, addrTempRegister, address.offset);
2822         }
2823 #endif
2824     }
2825 
2826     void loadDouble(BaseIndex address, FPRegisterID dest)
2827     {
2828 #if WTF_MIPS_ISA(1)
2829         if (!m_fixedWidth) {
2830             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2831             m_assembler.lwc1(dest, addrTempRegister, address.offset);
2832             m_assembler.lwc1(FPRegisterID(dest + 1), addrTempRegister, address.offset + 4);
2833         } else {
2834             /*
2835                 sll     addrTemp, address.index, address.scale
2836                 addu    addrTemp, addrTemp, address.base
2837                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2838                 addu    addrTemp, addrTemp, immTemp
2839                 lwc1    dest, (address.offset &amp; 0xffff)(at)
2840                 lwc1    dest+1, (address.offset &amp; 0xffff + 4)(at)
2841             */
2842             m_assembler.sll(addrTempRegister, address.index, address.scale);
2843             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2844             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2845             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
2846             m_assembler.lwc1(dest, addrTempRegister, address.offset);
2847             m_assembler.lwc1(FPRegisterID(dest + 1), addrTempRegister, address.offset + 4);
2848         }
2849 #else
2850         if (!m_fixedWidth) {
2851             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2852             m_assembler.ldc1(dest, addrTempRegister, address.offset);
2853         } else {
2854             /*
2855                 sll     addrTemp, address.index, address.scale
2856                 addu    addrTemp, addrTemp, address.base
2857                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2858                 addu    addrTemp, addrTemp, immTemp
2859                 ldc1    dest, (address.offset &amp; 0xffff)(at)
2860             */
2861             m_assembler.sll(addrTempRegister, address.index, address.scale);
2862             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2863             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2864             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
2865             m_assembler.ldc1(dest, addrTempRegister, address.offset);
2866         }
2867 #endif
2868     }
2869 
2870     void loadDouble(TrustedImmPtr address, FPRegisterID dest)
2871     {
2872 #if WTF_MIPS_ISA(1)
2873         /*
2874             li          addrTemp, address
2875             lwc1        dest, 0(addrTemp)
2876             lwc1        dest+1, 4(addrTemp)
2877          */
2878         move(address, addrTempRegister);
2879         m_assembler.lwc1(dest, addrTempRegister, 0);
2880         m_assembler.lwc1(FPRegisterID(dest + 1), addrTempRegister, 4);
2881 #else
2882         if (m_fixedWidth) {
2883             /*
2884                 li  addrTemp, address
2885                 ldc1        dest, 0(addrTemp)
2886             */
2887             move(TrustedImmPtr(address), addrTempRegister);
2888             m_assembler.ldc1(dest, addrTempRegister, 0);
2889         } else {
2890             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address.m_value);
2891             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
2892             m_assembler.ldc1(dest, addrTempRegister, adr &amp; 0xffff);
2893         }
2894 #endif
2895     }
2896 
2897     void storeFloat(FPRegisterID src, BaseIndex address)
2898     {
2899         if (!m_fixedWidth) {
2900             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2901             m_assembler.swc1(src, addrTempRegister, address.offset);
2902         } else {
2903             /*
2904                 sll     addrTemp, address.index, address.scale
2905                 addu    addrTemp, addrTemp, address.base
2906                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2907                 addu    addrTemp, addrTemp, immTemp
2908                 swc1    src, (address.offset &amp; 0xffff)(at)
2909             */
2910             m_assembler.sll(addrTempRegister, address.index, address.scale);
2911             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2912             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2913             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
2914             m_assembler.swc1(src, addrTempRegister, address.offset);
2915         }
2916     }
2917 
2918     void storeFloat(FPRegisterID src, ImplicitAddress address)
2919     {
2920         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
2921             &amp;&amp; !m_fixedWidth)
2922             m_assembler.swc1(src, address.base, address.offset);
2923         else {
2924             /*
2925                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
2926                 addu    addrTemp, addrTemp, base
2927                 swc1    src, (offset &amp; 0xffff)(addrTemp)
2928               */
2929             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2930             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2931             m_assembler.swc1(src, addrTempRegister, address.offset);
2932         }
2933     }
2934 
2935     void storeDouble(FPRegisterID src, ImplicitAddress address)
2936     {
2937 #if WTF_MIPS_ISA(1)
2938         /*
2939             li          addrTemp, address.offset
2940             addu        addrTemp, addrTemp, base
2941             swc1        dest, 0(addrTemp)
2942             swc1        dest+1, 4(addrTemp)
2943          */
2944         move(TrustedImm32(address.offset), addrTempRegister);
2945         m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2946         m_assembler.swc1(src, addrTempRegister, 0);
2947         m_assembler.swc1(FPRegisterID(src + 1), addrTempRegister, 4);
2948 #else
2949         if (address.offset &gt;= -32768 &amp;&amp; address.offset &lt;= 32767
2950             &amp;&amp; !m_fixedWidth)
2951             m_assembler.sdc1(src, address.base, address.offset);
2952         else {
2953             /*
2954                 lui     addrTemp, (offset + 0x8000) &gt;&gt; 16
2955                 addu    addrTemp, addrTemp, base
2956                 sdc1    src, (offset &amp; 0xffff)(addrTemp)
2957               */
2958             m_assembler.lui(addrTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2959             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2960             m_assembler.sdc1(src, addrTempRegister, address.offset);
2961         }
2962 #endif
2963     }
2964 
2965     void storeDouble(FPRegisterID src, BaseIndex address)
2966     {
2967 #if WTF_MIPS_ISA(1)
2968         if (!m_fixedWidth) {
2969             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2970             m_assembler.swc1(src, addrTempRegister, address.offset);
2971             m_assembler.swc1(FPRegisterID(src + 1), addrTempRegister, address.offset + 4);
2972         } else {
2973             /*
2974                 sll     addrTemp, address.index, address.scale
2975                 addu    addrTemp, addrTemp, address.base
2976                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2977                 addu    addrTemp, addrTemp, immTemp
2978                 swc1    src, (address.offset &amp; 0xffff)(at)
2979                 swc1    src+1, (address.offset &amp; 0xffff + 4)(at)
2980             */
2981             m_assembler.sll(addrTempRegister, address.index, address.scale);
2982             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
2983             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
2984             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
2985             m_assembler.swc1(src, addrTempRegister, address.offset);
2986             m_assembler.swc1(FPRegisterID(src + 1), addrTempRegister, address.offset + 4);
2987         }
2988 #else
2989         if (!m_fixedWidth) {
2990             loadAddress(address, LoadAddressMode::ScaleAndAddOffsetIfOffsetIsOutOfBounds);
2991             m_assembler.sdc1(src, addrTempRegister, address.offset);
2992         } else {
2993             /*
2994                 sll     addrTemp, address.index, address.scale
2995                 addu    addrTemp, addrTemp, address.base
2996                 lui     immTemp, (address.offset + 0x8000) &gt;&gt; 16
2997                 addu    addrTemp, addrTemp, immTemp
2998                 sdc1    src, (address.offset &amp; 0xffff)(at)
2999             */
3000             m_assembler.sll(addrTempRegister, address.index, address.scale);
3001             m_assembler.addu(addrTempRegister, addrTempRegister, address.base);
3002             m_assembler.lui(immTempRegister, (address.offset + 0x8000) &gt;&gt; 16);
3003             m_assembler.addu(addrTempRegister, addrTempRegister, immTempRegister);
3004             m_assembler.sdc1(src, addrTempRegister, address.offset);
3005         }
3006 #endif
3007     }
3008 
3009     void storeDouble(FPRegisterID src, TrustedImmPtr address)
3010     {
3011 #if WTF_MIPS_ISA(1)
3012         move(address, addrTempRegister);
3013         m_assembler.swc1(src, addrTempRegister, 0);
3014         m_assembler.swc1(FPRegisterID(src + 1), addrTempRegister, 4);
3015 #else
3016         if (m_fixedWidth) {
3017             /*
3018                 li  addrTemp, address
3019                 sdc1  src, 0(addrTemp)
3020             */
3021             move(TrustedImmPtr(address), addrTempRegister);
3022             m_assembler.sdc1(src, addrTempRegister, 0);
3023         } else {
3024             uintptr_t adr = reinterpret_cast&lt;uintptr_t&gt;(address.m_value);
3025             m_assembler.lui(addrTempRegister, (adr + 0x8000) &gt;&gt; 16);
3026             m_assembler.sdc1(src, addrTempRegister, adr &amp; 0xffff);
3027         }
3028 #endif
3029     }
3030 
3031     void moveDouble(FPRegisterID src, FPRegisterID dest)
3032     {
3033         if (src != dest || m_fixedWidth)
3034             m_assembler.movd(dest, src);
3035     }
3036 
3037     void moveDouble(FPRegisterID src, RegisterID dest)
3038     {
3039         m_assembler.mfc1(dest, src);
3040         m_assembler.mfc1(RegisterID(dest + 1), FPRegisterID(src + 1));
3041     }
3042 
3043     void moveZeroToDouble(FPRegisterID reg)
3044     {
3045         convertInt32ToDouble(MIPSRegisters::zero, reg);
3046     }
3047 
3048     void swap(FPRegisterID fr1, FPRegisterID fr2)
3049     {
3050         moveDouble(fr1, fpTempRegister);
3051         moveDouble(fr2, fr1);
3052         moveDouble(fpTempRegister, fr2);
3053     }
3054 
3055     void addDouble(FPRegisterID src, FPRegisterID dest)
3056     {
3057         m_assembler.addd(dest, dest, src);
3058     }
3059 
3060     void addDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
3061     {
3062         m_assembler.addd(dest, op1, op2);
3063     }
3064 
3065     void addDouble(Address src, FPRegisterID dest)
3066     {
3067         loadDouble(src, fpTempRegister);
3068         m_assembler.addd(dest, dest, fpTempRegister);
3069     }
3070 
3071     void addDouble(AbsoluteAddress address, FPRegisterID dest)
3072     {
3073         loadDouble(TrustedImmPtr(address.m_ptr), fpTempRegister);
3074         m_assembler.addd(dest, dest, fpTempRegister);
3075     }
3076 
3077     void subDouble(FPRegisterID src, FPRegisterID dest)
3078     {
3079         m_assembler.subd(dest, dest, src);
3080     }
3081 
3082     void subDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
3083     {
3084         m_assembler.subd(dest, op1, op2);
3085     }
3086 
3087     void subDouble(Address src, FPRegisterID dest)
3088     {
3089         loadDouble(src, fpTempRegister);
3090         m_assembler.subd(dest, dest, fpTempRegister);
3091     }
3092 
3093     void mulDouble(FPRegisterID src, FPRegisterID dest)
3094     {
3095         m_assembler.muld(dest, dest, src);
3096     }
3097 
3098     void mulDouble(Address src, FPRegisterID dest)
3099     {
3100         loadDouble(src, fpTempRegister);
3101         m_assembler.muld(dest, dest, fpTempRegister);
3102     }
3103 
3104     void mulDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
3105     {
3106         m_assembler.muld(dest, op1, op2);
3107     }
3108 
3109     void divDouble(FPRegisterID src, FPRegisterID dest)
3110     {
3111         m_assembler.divd(dest, dest, src);
3112     }
3113 
3114     void divDouble(FPRegisterID op1, FPRegisterID op2, FPRegisterID dest)
3115     {
3116         m_assembler.divd(dest, op1, op2);
3117     }
3118 
3119     void divDouble(Address src, FPRegisterID dest)
3120     {
3121         loadDouble(src, fpTempRegister);
3122         m_assembler.divd(dest, dest, fpTempRegister);
3123     }
3124 
3125     void negateDouble(FPRegisterID src, FPRegisterID dest)
3126     {
3127         m_assembler.negd(dest, src);
3128     }
3129 
3130     void convertInt32ToDouble(RegisterID src, FPRegisterID dest)
3131     {
3132         m_assembler.mtc1(src, fpTempRegister);
3133         m_assembler.cvtdw(dest, fpTempRegister);
3134     }
3135 
3136     void convertInt32ToDouble(Address src, FPRegisterID dest)
3137     {
3138         load32(src, dataTempRegister);
3139         m_assembler.mtc1(dataTempRegister, fpTempRegister);
3140         m_assembler.cvtdw(dest, fpTempRegister);
3141     }
3142 
3143     void convertInt32ToDouble(AbsoluteAddress src, FPRegisterID dest)
3144     {
3145         load32(src.m_ptr, dataTempRegister);
3146         m_assembler.mtc1(dataTempRegister, fpTempRegister);
3147         m_assembler.cvtdw(dest, fpTempRegister);
3148     }
3149 
3150     void convertFloatToDouble(FPRegisterID src, FPRegisterID dst)
3151     {
3152         m_assembler.cvtds(dst, src);
3153     }
3154 
3155     void convertDoubleToFloat(FPRegisterID src, FPRegisterID dst)
3156     {
3157         m_assembler.cvtsd(dst, src);
3158     }
3159 
3160     void insertRelaxationWords()
3161     {
3162         /* We need four words for relaxation. */
3163         m_assembler.beq(MIPSRegisters::zero, MIPSRegisters::zero, 3); // Jump over nops;
3164         m_assembler.nop();
3165         m_assembler.nop();
3166         m_assembler.nop();
3167     }
3168 
3169     Jump branchTrue()
3170     {
3171         m_assembler.appendJump();
3172         m_assembler.bc1t();
3173         m_assembler.nop();
3174         insertRelaxationWords();
3175         return Jump(m_assembler.label());
3176     }
3177 
3178     Jump branchFalse()
3179     {
3180         m_assembler.appendJump();
3181         m_assembler.bc1f();
3182         m_assembler.nop();
3183         insertRelaxationWords();
3184         return Jump(m_assembler.label());
3185     }
3186 
3187     Jump branchEqual(RegisterID rs, RegisterID rt)
3188     {
3189         m_assembler.appendJump();
3190         m_assembler.beq(rs, rt, 0);
3191         m_assembler.nop();
3192         insertRelaxationWords();
3193         return Jump(m_assembler.label());
3194     }
3195 
3196     Jump branchNotEqual(RegisterID rs, RegisterID rt)
3197     {
3198         m_assembler.appendJump();
3199         m_assembler.bne(rs, rt, 0);
3200         m_assembler.nop();
3201         insertRelaxationWords();
3202         return Jump(m_assembler.label());
3203     }
3204 
3205     Jump branchDouble(DoubleCondition cond, FPRegisterID left, FPRegisterID right)
3206     {
3207         if (cond == DoubleEqual) {
3208             m_assembler.ceqd(left, right);
3209             return branchTrue();
3210         }
3211         if (cond == DoubleNotEqual) {
3212             m_assembler.cueqd(left, right);
3213             return branchFalse(); // false
3214         }
3215         if (cond == DoubleGreaterThan) {
3216             m_assembler.cngtd(left, right);
3217             return branchFalse(); // false
3218         }
3219         if (cond == DoubleGreaterThanOrEqual) {
3220             m_assembler.cnged(left, right);
3221             return branchFalse(); // false
3222         }
3223         if (cond == DoubleLessThan) {
3224             m_assembler.cltd(left, right);
3225             return branchTrue();
3226         }
3227         if (cond == DoubleLessThanOrEqual) {
3228             m_assembler.cled(left, right);
3229             return branchTrue();
3230         }
3231         if (cond == DoubleEqualOrUnordered) {
3232             m_assembler.cueqd(left, right);
3233             return branchTrue();
3234         }
3235         if (cond == DoubleNotEqualOrUnordered) {
3236             m_assembler.ceqd(left, right);
3237             return branchFalse(); // false
3238         }
3239         if (cond == DoubleGreaterThanOrUnordered) {
3240             m_assembler.coled(left, right);
3241             return branchFalse(); // false
3242         }
3243         if (cond == DoubleGreaterThanOrEqualOrUnordered) {
3244             m_assembler.coltd(left, right);
3245             return branchFalse(); // false
3246         }
3247         if (cond == DoubleLessThanOrUnordered) {
3248             m_assembler.cultd(left, right);
3249             return branchTrue();
3250         }
3251         if (cond == DoubleLessThanOrEqualOrUnordered) {
3252             m_assembler.culed(left, right);
3253             return branchTrue();
3254         }
3255         ASSERT(0);
3256 
3257         return Jump();
3258     }
3259 
3260     // Truncates &#39;src&#39; to an integer, and places the resulting &#39;dest&#39;.
3261     // If the result is not representable as a 32 bit value, branch.
3262     enum BranchTruncateType { BranchIfTruncateFailed, BranchIfTruncateSuccessful };
3263 
3264     Jump branchTruncateDoubleToInt32(FPRegisterID src, RegisterID dest, BranchTruncateType branchType = BranchIfTruncateFailed)
3265     {
3266         m_assembler.truncwd(fpTempRegister, src);
3267         m_assembler.cfc1(dataTempRegister, MIPSRegisters::fcsr);
3268         m_assembler.mfc1(dest, fpTempRegister);
3269         and32(TrustedImm32(MIPSAssembler::FP_CAUSE_INVALID_OPERATION), dataTempRegister);
3270         return branch32(branchType == BranchIfTruncateFailed ? NotEqual : Equal, dataTempRegister, MIPSRegisters::zero);
3271     }
3272 
3273     // Result is undefined if the value is outside of the integer range.
3274     void truncateDoubleToInt32(FPRegisterID src, RegisterID dest)
3275     {
3276         m_assembler.truncwd(fpTempRegister, src);
3277         m_assembler.mfc1(dest, fpTempRegister);
3278     }
3279 
3280     // Result is undefined if src &gt; 2^31
3281     void truncateDoubleToUint32(FPRegisterID src, RegisterID dest)
3282     {
3283         m_assembler.truncwd(fpTempRegister, src);
3284         m_assembler.mfc1(dest, fpTempRegister);
3285     }
3286 
3287     // Convert &#39;src&#39; to an integer, and places the resulting &#39;dest&#39;.
3288     // If the result is not representable as a 32 bit value, branch.
3289     // May also branch for some values that are representable in 32 bits
3290     // (specifically, in this case, 0).
3291     void branchConvertDoubleToInt32(FPRegisterID src, RegisterID dest, JumpList&amp; failureCases, FPRegisterID fpTemp, bool negZeroCheck = true)
3292     {
3293         m_assembler.cvtwd(fpTempRegister, src);
3294         m_assembler.mfc1(dest, fpTempRegister);
3295 
3296         // If the result is zero, it might have been -0.0, and the double comparison won&#39;t catch this!
3297         if (negZeroCheck)
3298             failureCases.append(branch32(Equal, dest, MIPSRegisters::zero));
3299 
3300         // Convert the integer result back to float &amp; compare to the original value - if not equal or unordered (NaN) then jump.
3301         convertInt32ToDouble(dest, fpTemp);
3302         failureCases.append(branchDouble(DoubleNotEqualOrUnordered, fpTemp, src));
3303     }
3304 
3305     Jump branchDoubleNonZero(FPRegisterID reg, FPRegisterID scratch)
3306     {
3307         m_assembler.vmov(scratch, MIPSRegisters::zero, MIPSRegisters::zero);
3308         return branchDouble(DoubleNotEqual, reg, scratch);
3309     }
3310 
3311     Jump branchDoubleZeroOrNaN(FPRegisterID reg, FPRegisterID scratch)
3312     {
3313         m_assembler.vmov(scratch, MIPSRegisters::zero, MIPSRegisters::zero);
3314         return branchDouble(DoubleEqualOrUnordered, reg, scratch);
3315     }
3316 
3317     // Invert a relational condition, e.g. == becomes !=, &lt; becomes &gt;=, etc.
3318     static RelationalCondition invert(RelationalCondition cond)
3319     {
3320         RelationalCondition r;
3321         if (cond == Equal)
3322             r = NotEqual;
3323         else if (cond == NotEqual)
3324             r = Equal;
3325         else if (cond == Above)
3326             r = BelowOrEqual;
3327         else if (cond == AboveOrEqual)
3328             r = Below;
3329         else if (cond == Below)
3330             r = AboveOrEqual;
3331         else if (cond == BelowOrEqual)
3332             r = Above;
3333         else if (cond == GreaterThan)
3334             r = LessThanOrEqual;
3335         else if (cond == GreaterThanOrEqual)
3336             r = LessThan;
3337         else if (cond == LessThan)
3338             r = GreaterThanOrEqual;
3339         else if (cond == LessThanOrEqual)
3340             r = GreaterThan;
3341         return r;
3342     }
3343 
3344     void nop()
3345     {
3346         m_assembler.nop();
3347     }
3348 
3349     void memoryFence()
3350     {
3351         m_assembler.sync();
3352     }
3353 
3354     void abortWithReason(AbortReason reason)
3355     {
3356         move(TrustedImm32(reason), dataTempRegister);
3357         breakpoint();
3358     }
3359 
3360     void storeFence()
3361     {
3362         m_assembler.sync();
3363     }
3364 
3365     void abortWithReason(AbortReason reason, intptr_t misc)
3366     {
3367         move(TrustedImm32(misc), immTempRegister);
3368         abortWithReason(reason);
3369     }
3370 
3371     template&lt;PtrTag resultTag, PtrTag locationTag&gt;
3372     static FunctionPtr&lt;resultTag&gt; readCallTarget(CodeLocationCall&lt;locationTag&gt; call)
3373     {
3374         return FunctionPtr&lt;resultTag&gt;(reinterpret_cast&lt;void(*)()&gt;(MIPSAssembler::readCallTarget(call.dataLocation())));
3375     }
3376 
3377     template&lt;PtrTag startTag, PtrTag destTag&gt;
3378     static void replaceWithJump(CodeLocationLabel&lt;startTag&gt; instructionStart, CodeLocationLabel&lt;destTag&gt; destination)
3379     {
3380         MIPSAssembler::replaceWithJump(instructionStart.dataLocation(), destination.dataLocation());
3381     }
3382 
3383     static ptrdiff_t maxJumpReplacementSize()
3384     {
3385         MIPSAssembler::maxJumpReplacementSize();
3386         return 0;
3387     }
3388 
3389     static ptrdiff_t patchableJumpSize()
3390     {
3391         return MIPSAssembler::patchableJumpSize();
3392     }
3393 
3394     static bool canJumpReplacePatchableBranchPtrWithPatch() { return false; }
3395     static bool canJumpReplacePatchableBranch32WithPatch() { return false; }
3396 
3397     template&lt;PtrTag tag&gt;
3398     static CodeLocationLabel&lt;tag&gt; startOfPatchableBranch32WithPatchOnAddress(CodeLocationDataLabel32&lt;tag&gt;)
3399     {
3400         UNREACHABLE_FOR_PLATFORM();
3401         return CodeLocationLabel&lt;tag&gt;();
3402     }
3403 
3404     template&lt;PtrTag tag&gt;
3405     static CodeLocationLabel&lt;tag&gt; startOfBranchPtrWithPatchOnRegister(CodeLocationDataLabelPtr&lt;tag&gt; label)
3406     {
3407         return label.labelAtOffset(0);
3408     }
3409 
3410     template&lt;PtrTag tag&gt;
3411     static void revertJumpReplacementToBranchPtrWithPatch(CodeLocationLabel&lt;tag&gt; instructionStart, RegisterID, void* initialValue)
3412     {
3413         MIPSAssembler::revertJumpToMove(instructionStart.dataLocation(), immTempRegister, reinterpret_cast&lt;int&gt;(initialValue) &amp; 0xffff);
3414     }
3415 
3416     template&lt;PtrTag tag&gt;
3417     static CodeLocationLabel&lt;tag&gt; startOfPatchableBranchPtrWithPatchOnAddress(CodeLocationDataLabelPtr&lt;tag&gt;)
3418     {
3419         UNREACHABLE_FOR_PLATFORM();
3420         return CodeLocationLabel&lt;tag&gt;();
3421     }
3422 
3423     template&lt;PtrTag tag&gt;
3424     static void revertJumpReplacementToPatchableBranch32WithPatch(CodeLocationLabel&lt;tag&gt;, Address, int32_t)
3425     {
3426         UNREACHABLE_FOR_PLATFORM();
3427     }
3428 
3429     template&lt;PtrTag tag&gt;
3430     static void revertJumpReplacementToPatchableBranchPtrWithPatch(CodeLocationLabel&lt;tag&gt;, Address, void*)
3431     {
3432         UNREACHABLE_FOR_PLATFORM();
3433     }
3434 
3435     template&lt;PtrTag callTag, PtrTag destTag&gt;
3436     static void repatchCall(CodeLocationCall&lt;callTag&gt; call, CodeLocationLabel&lt;destTag&gt; destination)
3437     {
3438         MIPSAssembler::relinkCall(call.dataLocation(), destination.executableAddress());
3439     }
3440 
3441     template&lt;PtrTag callTag, PtrTag destTag&gt;
3442     static void repatchCall(CodeLocationCall&lt;callTag&gt; call, FunctionPtr&lt;destTag&gt; destination)
3443     {
3444         MIPSAssembler::relinkCall(call.dataLocation(), destination.executableAddress());
3445     }
3446 
3447 private:
3448     // If m_fixedWidth is true, we will generate a fixed number of instructions.
3449     // Otherwise, we can emit any number of instructions.
3450     bool m_fixedWidth;
3451 
3452     friend class LinkBuffer;
3453 
3454     template&lt;PtrTag tag&gt;
3455     static void linkCall(void* code, Call call, FunctionPtr&lt;tag&gt; function)
3456     {
3457         if (call.isFlagSet(Call::Tail))
3458             MIPSAssembler::linkJump(code, call.m_label, function.executableAddress());
3459         else
3460             MIPSAssembler::linkCall(code, call.m_label, function.executableAddress());
3461     }
3462 
3463 };
3464 
3465 } // namespace JSC
3466 
3467 #endif // ENABLE(ASSEMBLER) &amp;&amp; CPU(MIPS)
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
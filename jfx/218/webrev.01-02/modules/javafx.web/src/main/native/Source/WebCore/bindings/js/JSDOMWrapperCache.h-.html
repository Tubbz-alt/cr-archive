<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMWrapperCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2006, 2008-2009, 2013, 2016 Apple Inc. All rights reserved.
  4  *  Copyright (C) 2007 Samuel Weinig &lt;sam@webkit.org&gt;
  5  *  Copyright (C) 2009 Google, Inc. All rights reserved.
  6  *  Copyright (C) 2012 Ericsson AB. All rights reserved.
  7  *  Copyright (C) 2013 Michael Pruett &lt;michael@68k.org&gt;
  8  *
  9  *  This library is free software; you can redistribute it and/or
 10  *  modify it under the terms of the GNU Lesser General Public
 11  *  License as published by the Free Software Foundation; either
 12  *  version 2 of the License, or (at your option) any later version.
 13  *
 14  *  This library is distributed in the hope that it will be useful,
 15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  *  Lesser General Public License for more details.
 18  *
 19  *  You should have received a copy of the GNU Lesser General Public
 20  *  License along with this library; if not, write to the Free Software
 21  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 22  */
 23 
 24 #pragma once
 25 
 26 #include &quot;DOMWrapperWorld.h&quot;
 27 #include &quot;JSDOMGlobalObject.h&quot;
 28 #include &quot;JSDOMWrapper.h&quot;
 29 #include &quot;ScriptWrappable.h&quot;
 30 #include &quot;ScriptWrappableInlines.h&quot;
 31 #include &quot;WebCoreTypedArrayController.h&quot;
 32 #include &lt;JavaScriptCore/JSArrayBuffer.h&gt;
 33 #include &lt;JavaScriptCore/TypedArrayInlines.h&gt;
 34 #include &lt;JavaScriptCore/Weak.h&gt;
 35 #include &lt;JavaScriptCore/WeakInlines.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 WEBCORE_EXPORT JSC::Structure* getCachedDOMStructure(JSDOMGlobalObject&amp;, const JSC::ClassInfo*);
 40 WEBCORE_EXPORT JSC::Structure* cacheDOMStructure(JSDOMGlobalObject&amp;, JSC::Structure*, const JSC::ClassInfo*);
 41 
 42 template&lt;typename WrapperClass&gt; JSC::Structure* getDOMStructure(JSC::VM&amp;, JSDOMGlobalObject&amp;);
 43 template&lt;typename WrapperClass&gt; JSC::Structure* deprecatedGetDOMStructure(JSC::ExecState*);
 44 template&lt;typename WrapperClass&gt; JSC::JSObject* getDOMPrototype(JSC::VM&amp;, JSC::JSGlobalObject*);
 45 
 46 JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 47 void* wrapperKey(JSC::ArrayBuffer*);
 48 
 49 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*);
 50 JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*);
 51 JSC::JSArrayBuffer* getInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*);
 52 
 53 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*);
 54 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 55 bool setInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper, JSC::WeakHandleOwner* wrapperOwner);
 56 
 57 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*);
 58 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, ScriptWrappable*, JSDOMObject* wrapper);
 59 bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, JSC::ArrayBuffer*, JSC::JSArrayBuffer* wrapper);
 60 
 61 template&lt;typename DOMClass&gt; JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp;, DOMClass&amp;);
 62 template&lt;typename DOMClass&gt; inline JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp; world, Ref&lt;DOMClass&gt;&amp; object) { return getCachedWrapper(world, object.get()); }
 63 template&lt;typename DOMClass, typename WrapperClass&gt; void cacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 64 template&lt;typename DOMClass, typename WrapperClass&gt; void uncacheWrapper(DOMWrapperWorld&amp;, DOMClass*, WrapperClass*);
 65 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 66 template&lt;typename DOMClass, typename T&gt; auto createWrapper(JSDOMGlobalObject*, Ref&lt;T&gt;&amp;&amp;) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type;
 67 
 68 template&lt;typename DOMClass&gt; JSC::JSValue wrap(JSC::ExecState*, JSDOMGlobalObject*, DOMClass&amp;);
 69 
 70 
 71 // Inline functions and template definitions.
 72 
 73 inline JSDOMGlobalObject* deprecatedGlobalObjectForPrototype(JSC::ExecState* exec)
 74 {
 75     // FIXME: Callers to this function should be using the global object
 76     // from which the object is being created, instead of assuming the lexical one.
 77     // e.g. subframe.document.body should use the subframe&#39;s global object, not the lexical one.
 78     return JSC::jsCast&lt;JSDOMGlobalObject*&gt;(exec-&gt;lexicalGlobalObject());
 79 }
 80 
 81 template&lt;typename WrapperClass&gt; inline JSC::Structure* getDOMStructure(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 82 {
 83     if (JSC::Structure* structure = getCachedDOMStructure(globalObject, WrapperClass::info()))
 84         return structure;
 85     return cacheDOMStructure(globalObject, WrapperClass::createStructure(vm, &amp;globalObject, WrapperClass::createPrototype(vm, globalObject)), WrapperClass::info());
 86 }
 87 
 88 template&lt;typename WrapperClass&gt; inline JSC::Structure* deprecatedGetDOMStructure(JSC::ExecState* exec)
 89 {
 90     // FIXME: This function is wrong. It uses the wrong global object for creating the prototype structure.
 91     return getDOMStructure&lt;WrapperClass&gt;(exec-&gt;vm(), *deprecatedGlobalObjectForPrototype(exec));
 92 }
 93 
 94 template&lt;typename WrapperClass&gt; inline JSC::JSObject* getDOMPrototype(JSC::VM&amp; vm, JSDOMGlobalObject&amp; globalObject)
 95 {
 96     return JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(getDOMStructure&lt;WrapperClass&gt;(vm, globalObject)-&gt;storedPrototype()));
 97 }
 98 
 99 inline JSC::WeakHandleOwner* wrapperOwner(DOMWrapperWorld&amp; world, JSC::ArrayBuffer*)
100 {
101     return static_cast&lt;WebCoreTypedArrayController*&gt;(world.vm().m_typedArrayController.get())-&gt;wrapperOwner();
102 }
103 
104 inline void* wrapperKey(JSC::ArrayBuffer* domObject)
105 {
106     return domObject;
107 }
108 
109 inline JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp;, void*) { return nullptr; }
110 inline bool setInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*, JSC::WeakHandleOwner*) { return false; }
111 inline bool clearInlineCachedWrapper(DOMWrapperWorld&amp;, void*, JSDOMObject*) { return false; }
112 
113 inline JSDOMObject* getInlineCachedWrapper(DOMWrapperWorld&amp; world, ScriptWrappable* domObject)
114 {
115     if (!world.isNormal())
116         return nullptr;
117     return domObject-&gt;wrapper();
118 }
119 
120 inline JSC::JSArrayBuffer* getInlineCachedWrapper(DOMWrapperWorld&amp; world, JSC::ArrayBuffer* buffer)
121 {
122     if (!world.isNormal())
123         return nullptr;
124     return buffer-&gt;m_wrapper.get();
125 }
126 
127 inline bool setInlineCachedWrapper(DOMWrapperWorld&amp; world, ScriptWrappable* domObject, JSDOMObject* wrapper, JSC::WeakHandleOwner* wrapperOwner)
128 {
129     if (!world.isNormal())
130         return false;
131     domObject-&gt;setWrapper(wrapper, wrapperOwner, &amp;world);
132     return true;
133 }
134 
135 inline bool setInlineCachedWrapper(DOMWrapperWorld&amp; world, JSC::ArrayBuffer* domObject, JSC::JSArrayBuffer* wrapper, JSC::WeakHandleOwner* wrapperOwner)
136 {
137     if (!world.isNormal())
138         return false;
139     domObject-&gt;m_wrapper = JSC::Weak&lt;JSC::JSArrayBuffer&gt;(wrapper, wrapperOwner, &amp;world);
140     return true;
141 }
142 
143 inline bool clearInlineCachedWrapper(DOMWrapperWorld&amp; world, ScriptWrappable* domObject, JSDOMObject* wrapper)
144 {
145     if (!world.isNormal())
146         return false;
147     domObject-&gt;clearWrapper(wrapper);
148     return true;
149 }
150 
151 inline bool clearInlineCachedWrapper(DOMWrapperWorld&amp; world, JSC::ArrayBuffer* domObject, JSC::JSArrayBuffer* wrapper)
152 {
153     if (!world.isNormal())
154         return false;
155     weakClear(domObject-&gt;m_wrapper, wrapper);
156     return true;
157 }
158 
159 template&lt;typename DOMClass&gt; inline JSC::JSObject* getCachedWrapper(DOMWrapperWorld&amp; world, DOMClass&amp; domObject)
160 {
161     if (auto* wrapper = getInlineCachedWrapper(world, &amp;domObject))
162         return wrapper;
163     return world.wrappers().get(wrapperKey(&amp;domObject));
164 }
165 
166 template&lt;typename DOMClass, typename WrapperClass&gt; inline void cacheWrapper(DOMWrapperWorld&amp; world, DOMClass* domObject, WrapperClass* wrapper)
167 {
168     JSC::WeakHandleOwner* owner = wrapperOwner(world, domObject);
169     if (setInlineCachedWrapper(world, domObject, wrapper, owner))
170         return;
171     weakAdd(world.wrappers(), wrapperKey(domObject), JSC::Weak&lt;JSC::JSObject&gt;(wrapper, owner, &amp;world));
172 }
173 
174 template&lt;typename DOMClass, typename WrapperClass&gt; inline void uncacheWrapper(DOMWrapperWorld&amp; world, DOMClass* domObject, WrapperClass* wrapper)
175 {
176     if (clearInlineCachedWrapper(world, domObject, wrapper))
177         return;
178     weakRemove(world.wrappers(), wrapperKey(domObject), wrapper);
179 }
180 
181 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
182 {
183     using WrapperClass = typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass;
184 
185     ASSERT(!getCachedWrapper(globalObject-&gt;world(), domObject));
186     auto* domObjectPtr = domObject.ptr();
187     auto* wrapper = WrapperClass::create(getDOMStructure&lt;WrapperClass&gt;(globalObject-&gt;vm(), *globalObject), globalObject, WTFMove(domObject));
188     cacheWrapper(globalObject-&gt;world(), domObjectPtr, wrapper);
189     return wrapper;
190 }
191 
192 template&lt;typename DOMClass, typename T&gt; inline auto createWrapper(JSDOMGlobalObject* globalObject, Ref&lt;T&gt;&amp;&amp; domObject) -&gt; typename std::enable_if&lt;!std::is_same&lt;DOMClass, T&gt;::value, typename JSDOMWrapperConverterTraits&lt;DOMClass&gt;::WrapperClass*&gt;::type
193 {
194     return createWrapper&lt;DOMClass&gt;(globalObject, static_reference_cast&lt;DOMClass&gt;(WTFMove(domObject)));
195 }
196 
197 template&lt;typename DOMClass&gt; inline JSC::JSValue wrap(JSC::ExecState* state, JSDOMGlobalObject* globalObject, DOMClass&amp; domObject)
198 {
199     if (auto* wrapper = getCachedWrapper(globalObject-&gt;world(), domObject))
200         return wrapper;
201     return toJSNewlyCreated(state, globalObject, Ref&lt;DOMClass&gt;(domObject));
202 }
203 
204 } // namespace WebCore
    </pre>
  </body>
</html>
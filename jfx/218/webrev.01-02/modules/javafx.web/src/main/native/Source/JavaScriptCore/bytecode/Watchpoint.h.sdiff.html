<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Watchpoint.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Watchpoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../bytecompiler/BytecodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Watchpoint.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 98 // 1. Calling Watchpoint::~Watchpoint directly is illegal.
 99 // 2. `delete watchpoint` where watchpoint is non-final derived class is illegal. If watchpoint is final derived class, it works.
100 // 3. If we really want to do (2), we need to call `watchpoint-&gt;destroy()` instead, and dispatch an appropriate destructor in Watchpoint::destroy.
101 //
102 // Luckily, none of our derived watchpoint classes have members which require destructors. So we do not dispatch
103 // the destructor call to the drived class in the base class. If it becomes really required, we can introduce
104 // a custom deleter for some classes which directly call &quot;delete&quot; to the allocated non-final Watchpoint class
105 // (e.g. std::unique_ptr&lt;Watchpoint&gt;, RefPtr&lt;Watchpoint&gt;), and call Watchpoint::destroy instead of &quot;delete&quot;
106 // operator. But since we do not require it for now, we are doing the simplest thing.
107 #define JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
108     macro(AdaptiveInferredPropertyValueStructure, AdaptiveInferredPropertyValueWatchpointBase::StructureWatchpoint) \
109     macro(AdaptiveInferredPropertyValueProperty, AdaptiveInferredPropertyValueWatchpointBase::PropertyWatchpoint) \
110     macro(CodeBlockJettisoning, CodeBlockJettisoningWatchpoint) \
111     macro(LLIntPrototypeLoadAdaptiveStructure, LLIntPrototypeLoadAdaptiveStructureWatchpoint) \
112     macro(FunctionRareDataAllocationProfileClearing, FunctionRareData::AllocationProfileClearingWatchpoint) \
113     macro(ObjectToStringAdaptiveStructure, ObjectToStringAdaptiveStructureWatchpoint)
114 
115 #if ENABLE(JIT)
116 #define JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
117     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
<span class="line-modified">118     macro(StructureStubClearing, StructureStubClearingWatchpoint)</span>
119 
120 #if ENABLE(DFG_JIT)
121 #define JSC_WATCHPOINT_TYPES(macro) \
122     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
123     macro(AdaptiveStructure, DFG::AdaptiveStructureWatchpoint)
124 #else
125 #define JSC_WATCHPOINT_TYPES(macro) \
126     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro)
127 #endif
128 
129 #else
130 #define JSC_WATCHPOINT_TYPES(macro) \
131     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro)
132 #endif
133 
134 #define JSC_WATCHPOINT_FIELD(type, member) \
135     type member; \
136     static_assert(std::is_trivially_destructible&lt;type&gt;::value, &quot;&quot;); \
137 

138 
139 class Watchpoint : public PackedRawSentinelNode&lt;Watchpoint&gt; {
140     WTF_MAKE_NONCOPYABLE(Watchpoint);
141     WTF_MAKE_NONMOVABLE(Watchpoint);
<span class="line-modified">142     WTF_MAKE_FAST_ALLOCATED;</span>
143 public:
144 #define JSC_DEFINE_WATCHPOINT_TYPES(type, _) type,
145     enum class Type : uint8_t {
146         JSC_WATCHPOINT_TYPES(JSC_DEFINE_WATCHPOINT_TYPES)
147     };
148 #undef JSC_DEFINE_WATCHPOINT_TYPES
149 
150     Watchpoint(Type type)
151         : m_type(type)
152     { }
153 
154 protected:
155     ~Watchpoint();
156 
157 private:
158     friend class WatchpointSet;
159     void fire(VM&amp;, const FireDetail&amp;);
160 
161     Type m_type;
162 };
163 
164 // Make sure that the state can be represented in 2 bits.
165 enum WatchpointState : uint8_t {
166     ClearWatchpoint = 0,
167     IsWatched = 1,
168     IsInvalidated = 2
169 };
170 
171 class InlineWatchpointSet;
172 class DeferredWatchpointFire;
173 class VM;
174 


175 class WatchpointSet : public ThreadSafeRefCounted&lt;WatchpointSet&gt; {

176     friend class LLIntOffsetsExtractor;
177     friend class DeferredWatchpointFire;
178 public:
179     JS_EXPORT_PRIVATE WatchpointSet(WatchpointState);
180 
181     // FIXME: In many cases, it would be amazing if this *did* fire the watchpoints. I suspect that
182     // this might be hard to get right, but still, it might be awesome.
183     JS_EXPORT_PRIVATE ~WatchpointSet(); // Note that this will not fire any of the watchpoints; if you need to know when a WatchpointSet dies then you need a separate mechanism for this.
184 
185     static Ref&lt;WatchpointSet&gt; create(WatchpointState state)
186     {
187         return adoptRef(*new WatchpointSet(state));
188     }
189 
190     // Fast way of getting the state, which only works from the main thread.
191     WatchpointState stateOnJSThread() const
192     {
193         return static_cast&lt;WatchpointState&gt;(m_state);
194     }
195 
</pre>
<hr />
<pre>
458     //   the assumptions that the DFG thread used are still valid when the DFG code is installed.
459     bool isBeingWatched() const
460     {
461         if (isFat())
462             return fat()-&gt;isBeingWatched();
463         return false;
464     }
465 
466     // We expose this because sometimes a client knows its about to start
467     // watching this InlineWatchpointSet, hence it&#39;ll become inflated regardless.
468     // Such clients may find it useful to have a WatchpointSet* pointer, for example,
469     // if they collect a Vector of WatchpointSet*.
470     WatchpointSet* inflate()
471     {
472         if (LIKELY(isFat()))
473             return fat();
474         return inflateSlow();
475     }
476 
477 private:
<span class="line-modified">478     static const uintptr_t IsThinFlag        = 1;</span>
<span class="line-modified">479     static const uintptr_t StateMask         = 6;</span>
<span class="line-modified">480     static const uintptr_t StateShift        = 1;</span>
481 
482     static bool isThin(uintptr_t data) { return data &amp; IsThinFlag; }
483     static bool isFat(uintptr_t data) { return !isThin(data); }
484 
485     static WatchpointState decodeState(uintptr_t data)
486     {
487         ASSERT(isThin(data));
488         return static_cast&lt;WatchpointState&gt;((data &amp; StateMask) &gt;&gt; StateShift);
489     }
490 
491     static uintptr_t encodeState(WatchpointState state)
492     {
493         return (static_cast&lt;uintptr_t&gt;(state) &lt;&lt; StateShift) | IsThinFlag;
494     }
495 
496     bool isThin() const { return isThin(m_data); }
497     bool isFat() const { return isFat(m_data); };
498 
499     static WatchpointSet* fat(uintptr_t data)
500     {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 98 // 1. Calling Watchpoint::~Watchpoint directly is illegal.
 99 // 2. `delete watchpoint` where watchpoint is non-final derived class is illegal. If watchpoint is final derived class, it works.
100 // 3. If we really want to do (2), we need to call `watchpoint-&gt;destroy()` instead, and dispatch an appropriate destructor in Watchpoint::destroy.
101 //
102 // Luckily, none of our derived watchpoint classes have members which require destructors. So we do not dispatch
103 // the destructor call to the drived class in the base class. If it becomes really required, we can introduce
104 // a custom deleter for some classes which directly call &quot;delete&quot; to the allocated non-final Watchpoint class
105 // (e.g. std::unique_ptr&lt;Watchpoint&gt;, RefPtr&lt;Watchpoint&gt;), and call Watchpoint::destroy instead of &quot;delete&quot;
106 // operator. But since we do not require it for now, we are doing the simplest thing.
107 #define JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
108     macro(AdaptiveInferredPropertyValueStructure, AdaptiveInferredPropertyValueWatchpointBase::StructureWatchpoint) \
109     macro(AdaptiveInferredPropertyValueProperty, AdaptiveInferredPropertyValueWatchpointBase::PropertyWatchpoint) \
110     macro(CodeBlockJettisoning, CodeBlockJettisoningWatchpoint) \
111     macro(LLIntPrototypeLoadAdaptiveStructure, LLIntPrototypeLoadAdaptiveStructureWatchpoint) \
112     macro(FunctionRareDataAllocationProfileClearing, FunctionRareData::AllocationProfileClearingWatchpoint) \
113     macro(ObjectToStringAdaptiveStructure, ObjectToStringAdaptiveStructureWatchpoint)
114 
115 #if ENABLE(JIT)
116 #define JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
117     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
<span class="line-modified">118     macro(StructureTransitionStructureStubClearing, StructureTransitionStructureStubClearingWatchpoint)</span>
119 
120 #if ENABLE(DFG_JIT)
121 #define JSC_WATCHPOINT_TYPES(macro) \
122     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
123     macro(AdaptiveStructure, DFG::AdaptiveStructureWatchpoint)
124 #else
125 #define JSC_WATCHPOINT_TYPES(macro) \
126     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro)
127 #endif
128 
129 #else
130 #define JSC_WATCHPOINT_TYPES(macro) \
131     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro)
132 #endif
133 
134 #define JSC_WATCHPOINT_FIELD(type, member) \
135     type member; \
136     static_assert(std::is_trivially_destructible&lt;type&gt;::value, &quot;&quot;); \
137 
<span class="line-added">138 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Watchpoint);</span>
139 
140 class Watchpoint : public PackedRawSentinelNode&lt;Watchpoint&gt; {
141     WTF_MAKE_NONCOPYABLE(Watchpoint);
142     WTF_MAKE_NONMOVABLE(Watchpoint);
<span class="line-modified">143     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(Watchpoint);</span>
144 public:
145 #define JSC_DEFINE_WATCHPOINT_TYPES(type, _) type,
146     enum class Type : uint8_t {
147         JSC_WATCHPOINT_TYPES(JSC_DEFINE_WATCHPOINT_TYPES)
148     };
149 #undef JSC_DEFINE_WATCHPOINT_TYPES
150 
151     Watchpoint(Type type)
152         : m_type(type)
153     { }
154 
155 protected:
156     ~Watchpoint();
157 
158 private:
159     friend class WatchpointSet;
160     void fire(VM&amp;, const FireDetail&amp;);
161 
162     Type m_type;
163 };
164 
165 // Make sure that the state can be represented in 2 bits.
166 enum WatchpointState : uint8_t {
167     ClearWatchpoint = 0,
168     IsWatched = 1,
169     IsInvalidated = 2
170 };
171 
172 class InlineWatchpointSet;
173 class DeferredWatchpointFire;
174 class VM;
175 
<span class="line-added">176 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(WatchpointSet);</span>
<span class="line-added">177 </span>
178 class WatchpointSet : public ThreadSafeRefCounted&lt;WatchpointSet&gt; {
<span class="line-added">179     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(WatchpointSet);</span>
180     friend class LLIntOffsetsExtractor;
181     friend class DeferredWatchpointFire;
182 public:
183     JS_EXPORT_PRIVATE WatchpointSet(WatchpointState);
184 
185     // FIXME: In many cases, it would be amazing if this *did* fire the watchpoints. I suspect that
186     // this might be hard to get right, but still, it might be awesome.
187     JS_EXPORT_PRIVATE ~WatchpointSet(); // Note that this will not fire any of the watchpoints; if you need to know when a WatchpointSet dies then you need a separate mechanism for this.
188 
189     static Ref&lt;WatchpointSet&gt; create(WatchpointState state)
190     {
191         return adoptRef(*new WatchpointSet(state));
192     }
193 
194     // Fast way of getting the state, which only works from the main thread.
195     WatchpointState stateOnJSThread() const
196     {
197         return static_cast&lt;WatchpointState&gt;(m_state);
198     }
199 
</pre>
<hr />
<pre>
462     //   the assumptions that the DFG thread used are still valid when the DFG code is installed.
463     bool isBeingWatched() const
464     {
465         if (isFat())
466             return fat()-&gt;isBeingWatched();
467         return false;
468     }
469 
470     // We expose this because sometimes a client knows its about to start
471     // watching this InlineWatchpointSet, hence it&#39;ll become inflated regardless.
472     // Such clients may find it useful to have a WatchpointSet* pointer, for example,
473     // if they collect a Vector of WatchpointSet*.
474     WatchpointSet* inflate()
475     {
476         if (LIKELY(isFat()))
477             return fat();
478         return inflateSlow();
479     }
480 
481 private:
<span class="line-modified">482     static constexpr uintptr_t IsThinFlag        = 1;</span>
<span class="line-modified">483     static constexpr uintptr_t StateMask         = 6;</span>
<span class="line-modified">484     static constexpr uintptr_t StateShift        = 1;</span>
485 
486     static bool isThin(uintptr_t data) { return data &amp; IsThinFlag; }
487     static bool isFat(uintptr_t data) { return !isThin(data); }
488 
489     static WatchpointState decodeState(uintptr_t data)
490     {
491         ASSERT(isThin(data));
492         return static_cast&lt;WatchpointState&gt;((data &amp; StateMask) &gt;&gt; StateShift);
493     }
494 
495     static uintptr_t encodeState(WatchpointState state)
496     {
497         return (static_cast&lt;uintptr_t&gt;(state) &lt;&lt; StateShift) | IsThinFlag;
498     }
499 
500     bool isThin() const { return isThin(m_data); }
501     bool isFat() const { return isFat(m_data); };
502 
503     static WatchpointSet* fat(uintptr_t data)
504     {
</pre>
</td>
</tr>
</table>
<center><a href="Watchpoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../bytecompiler/BytecodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
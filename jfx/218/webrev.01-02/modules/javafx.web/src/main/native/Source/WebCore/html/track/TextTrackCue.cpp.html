<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/track/TextTrackCue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011, 2013 Google Inc.  All rights reserved.
  3  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TextTrackCue.h&quot;
 34 
 35 #if ENABLE(VIDEO_TRACK)
 36 
 37 #include &quot;CSSPropertyNames.h&quot;
 38 #include &quot;CSSValueKeywords.h&quot;
 39 #include &quot;DOMRect.h&quot;
 40 #include &quot;Event.h&quot;
 41 #include &quot;HTMLCollection.h&quot;
 42 #include &quot;HTMLDivElement.h&quot;
 43 #include &quot;HTMLStyleElement.h&quot;
 44 #include &quot;Logging.h&quot;
 45 #include &quot;NodeTraversal.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;ScriptDisallowedScope.h&quot;
 48 #include &quot;Text.h&quot;
 49 #include &quot;TextTrack.h&quot;
 50 #include &quot;TextTrackCueList.h&quot;
 51 #include &quot;VTTCue.h&quot;
 52 #include &quot;VTTRegionList.h&quot;
 53 #include &lt;limits.h&gt;
 54 #include &lt;wtf/HexNumber.h&gt;
 55 #include &lt;wtf/IsoMallocInlines.h&gt;
 56 #include &lt;wtf/MathExtras.h&gt;
 57 #include &lt;wtf/NeverDestroyed.h&gt;
 58 #include &lt;wtf/OptionSet.h&gt;
 59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 60 
 61 namespace WebCore {
 62 
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrackCue);
 64 WTF_MAKE_ISO_ALLOCATED_IMPL(TextTrackCueBox);
 65 
 66 const AtomString&amp; TextTrackCue::cueShadowPseudoId()
 67 {
 68     static NeverDestroyed&lt;const AtomString&gt; cue(&quot;cue&quot;, AtomString::ConstructFromLiteral);
 69     return cue;
 70 }
 71 
 72 const AtomString&amp; TextTrackCue::cueBoxShadowPseudoId()
 73 {
 74     static NeverDestroyed&lt;const AtomString&gt; trackDisplayBoxShadowPseudoId(&quot;-webkit-media-text-track-display&quot;, AtomString::ConstructFromLiteral);
 75     return trackDisplayBoxShadowPseudoId;
 76 }
 77 
 78 const AtomString&amp; TextTrackCue::cueBackdropShadowPseudoId()
 79 {
 80     static NeverDestroyed&lt;const AtomString&gt; cueBackdropShadowPseudoId(&quot;-webkit-media-text-track-display-backdrop&quot;, AtomString::ConstructFromLiteral);
 81     return cueBackdropShadowPseudoId;
 82 }
 83 
 84 static const QualifiedName&amp; cueAttributName()
 85 {
 86     static NeverDestroyed&lt;QualifiedName&gt; cueTag(nullAtom(), &quot;cue&quot;, nullAtom());
 87     return cueTag;
 88 }
 89 
 90 static const QualifiedName&amp; cueBackgroundAttributName()
 91 {
 92     static NeverDestroyed&lt;QualifiedName&gt; cueBackgroundTag(nullAtom(), &quot;cuebackground&quot;, nullAtom());
 93     return cueBackgroundTag;
 94 }
 95 
 96 TextTrackCueBox::TextTrackCueBox(Document&amp; document, TextTrackCue&amp; cue)
 97     : HTMLElement(HTMLNames::divTag, document)
 98     , m_cue(makeWeakPtr(cue))
 99 {
100     setHasCustomStyleResolveCallbacks();
101     setPseudo(TextTrackCue::cueBoxShadowPseudoId());
102 }
103 
104 TextTrackCue* TextTrackCueBox::getCue() const
105 {
106     return m_cue.get();
107 }
108 
109 static inline bool isLegalNode(Node&amp; node)
110 {
111     return node.hasTagName(HTMLNames::brTag)
112         || node.hasTagName(HTMLNames::divTag)
113         || node.hasTagName(HTMLNames::imgTag)
114         || node.hasTagName(HTMLNames::pTag)
115         || node.hasTagName(HTMLNames::rbTag)
116         || node.hasTagName(HTMLNames::rtTag)
117         || node.hasTagName(HTMLNames::rtcTag)
118         || node.hasTagName(HTMLNames::rubyTag)
119         || node.hasTagName(HTMLNames::spanTag)
120         || node.nodeType() == Node::TEXT_NODE;
121 }
122 
123 static Exception invalidNodeException(Node&amp; node)
124 {
125     return Exception { InvalidNodeTypeError, makeString(&quot;Invalid node type: &quot;, node.nodeName()) };
126 }
127 
128 static ExceptionOr&lt;void&gt; checkForInvalidNodeTypes(Node&amp; root)
129 {
130     if (!isLegalNode(root))
131         return invalidNodeException(root);
132 
133     for (auto* child = root.firstChild(); child; child = child-&gt;nextSibling()) {
134         if (!isLegalNode(*child))
135             return invalidNodeException(*child);
136 
137         if (is&lt;ContainerNode&gt;(*child)) {
138             auto result = checkForInvalidNodeTypes(*child);
139             if (result.hasException())
140                 return result.releaseException();
141         }
142     }
143 
144     return { };
145 }
146 
147 enum RequiredNodes {
148     Cue = 1 &lt;&lt; 0,
149     CueBackground = 1 &lt;&lt; 1,
150 };
151 
152 static OptionSet&lt;RequiredNodes&gt; tagPseudoObjects(Node&amp; node)
153 {
154     if (!is&lt;Element&gt;(node))
155         return { };
156 
157     OptionSet&lt;RequiredNodes&gt; nodeTypes = { };
158 
159     auto&amp; element = downcast&lt;Element&gt;(node);
160     if (element.hasAttributeWithoutSynchronization(cueAttributName())) {
161         element.setPseudo(TextTrackCue::cueShadowPseudoId());
162         nodeTypes = { RequiredNodes::Cue };
163     } else if (element.hasAttributeWithoutSynchronization(cueBackgroundAttributName())) {
164         element.setPseudo(TextTrackCue::cueBackdropShadowPseudoId());
165         nodeTypes = { RequiredNodes::CueBackground };
166     }
167 
168     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling())
169         nodeTypes.add(tagPseudoObjects(*child));
170 
171     return nodeTypes;
172 }
173 
174 static void removePseudoAttributes(Node&amp; node)
175 {
176     if (!is&lt;Element&gt;(node))
177         return;
178 
179     auto&amp; element = downcast&lt;Element&gt;(node);
180     if (element.hasAttributeWithoutSynchronization(cueAttributName()) || element.hasAttributeWithoutSynchronization(cueBackgroundAttributName()))
181         element.removeAttribute(HTMLNames::pseudoAttr);
182 
183     for (auto* child = element.firstChild(); child; child = child-&gt;nextSibling())
184         removePseudoAttributes(*child);
185 }
186 
187 ExceptionOr&lt;Ref&lt;TextTrackCue&gt;&gt; TextTrackCue::create(ScriptExecutionContext&amp; context, double start, double end, DocumentFragment&amp; cueDocument)
188 {
189     ASSERT(context.isDocument());
190     ASSERT(is&lt;DocumentFragment&gt;(cueDocument));
191 
192     if (!cueDocument.firstChild())
193         return Exception { InvalidNodeTypeError, &quot;Empty cue fragment&quot; };
194 
195     for (Node* node = cueDocument.firstChild(); node; node = node-&gt;nextSibling()) {
196         auto result = checkForInvalidNodeTypes(*node);
197         if (result.hasException())
198             return result.releaseException();
199     }
200 
201     auto fragment = DocumentFragment::create(downcast&lt;Document&gt;(context));
202     for (Node* node = cueDocument.firstChild(); node; node = node-&gt;nextSibling()) {
203         auto result = fragment-&gt;ensurePreInsertionValidity(*node, nullptr);
204         if (result.hasException())
205             return result.releaseException();
206     }
207     cueDocument.cloneChildNodes(fragment);
208 
209     OptionSet&lt;RequiredNodes&gt; nodeTypes = { };
210     for (Node* node = fragment-&gt;firstChild(); node; node = node-&gt;nextSibling())
211         nodeTypes.add(tagPseudoObjects(*node));
212 
213     if (!nodeTypes.contains(RequiredNodes::Cue))
214         return Exception { InvalidStateError, makeString(&quot;Missing required attribute: &quot;, cueAttributName().toString()) };
215     if (!nodeTypes.contains(RequiredNodes::CueBackground))
216         return Exception { InvalidStateError, makeString(&quot;Missing required attribute: &quot;, cueBackgroundAttributName().toString()) };
217 
218     return adoptRef(*new TextTrackCue(context, MediaTime::createWithDouble(start), MediaTime::createWithDouble(end), WTFMove(fragment.get())));
219 }
220 
221 TextTrackCue::TextTrackCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end, DocumentFragment&amp;&amp; cueFragment)
222     : TextTrackCue(context, start, end)
223 {
224     m_cueNode = &amp;cueFragment;
225 }
226 
227 TextTrackCue::TextTrackCue(ScriptExecutionContext&amp; context, const MediaTime&amp; start, const MediaTime&amp; end)
228     : m_startTime(start)
229     , m_endTime(end)
230     , m_scriptExecutionContext(context)
231 {
232     ASSERT(m_scriptExecutionContext.isDocument());
233 }
234 
235 void TextTrackCue::willChange()
236 {
237     if (++m_processingCueChanges &gt; 1)
238         return;
239 
240     if (m_track)
241         m_track-&gt;cueWillChange(this);
242 }
243 
244 void TextTrackCue::didChange()
245 {
246     ASSERT(m_processingCueChanges);
247     if (--m_processingCueChanges)
248         return;
249 
250     m_displayTreeNeedsUpdate = true;
251 
252     if (m_track)
253         m_track-&gt;cueDidChange(this);
254 }
255 
256 TextTrack* TextTrackCue::track() const
257 {
258     return m_track;
259 }
260 
261 void TextTrackCue::setTrack(TextTrack* track)
262 {
263     m_track = track;
264 }
265 
266 void TextTrackCue::setId(const String&amp; id)
267 {
268     if (m_id == id)
269         return;
270 
271     willChange();
272     m_id = id;
273     didChange();
274 }
275 
276 void TextTrackCue::setStartTime(double value)
277 {
278     // TODO(93143): Add spec-compliant behavior for negative time values.
279     if (m_startTime.toDouble() == value || value &lt; 0)
280         return;
281 
282     setStartTime(MediaTime::createWithDouble(value));
283 }
284 
285 void TextTrackCue::setStartTime(const MediaTime&amp; value)
286 {
287     willChange();
288     m_startTime = value;
289     didChange();
290 }
291 
292 void TextTrackCue::setEndTime(double value)
293 {
294     // TODO(93143): Add spec-compliant behavior for negative time values.
295     if (m_endTime.toDouble() == value || value &lt; 0)
296         return;
297 
298     setEndTime(MediaTime::createWithDouble(value));
299 }
300 
301 void TextTrackCue::setEndTime(const MediaTime&amp; value)
302 {
303     willChange();
304     m_endTime = value;
305     didChange();
306 }
307 
308 void TextTrackCue::setPauseOnExit(bool value)
309 {
310     if (m_pauseOnExit == value)
311         return;
312 
313     m_pauseOnExit = value;
314 }
315 
316 void TextTrackCue::dispatchEvent(Event&amp; event)
317 {
318     // When a TextTrack&#39;s mode is disabled: no cues are active, no events fired.
319     if (!track() || track()-&gt;mode() == TextTrack::Mode::Disabled)
320         return;
321 
322     EventTarget::dispatchEvent(event);
323 }
324 
325 bool TextTrackCue::isActive()
326 {
327     return m_isActive &amp;&amp; track() &amp;&amp; track()-&gt;mode() != TextTrack::Mode::Disabled;
328 }
329 
330 void TextTrackCue::setIsActive(bool active)
331 {
332     m_isActive = active;
333 
334     if (m_isActive || !m_displayTree)
335         return;
336 
337     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
338     ScriptDisallowedScope::EventAllowedScope allowedScope(*m_displayTree);
339     m_displayTree-&gt;remove();
340 }
341 
342 unsigned TextTrackCue::cueIndex() const
343 {
344     ASSERT(m_track &amp;&amp; m_track-&gt;cues());
345     if (!m_track || !m_track-&gt;cues())
346         return std::numeric_limits&lt;unsigned&gt;::max();
347 
348     return m_track-&gt;cues()-&gt;cueIndex(*this);
349 }
350 
351 bool TextTrackCue::isOrderedBefore(const TextTrackCue* other) const
352 {
353     // ... cues must be sorted by their start time, earliest first;
354     if (startMediaTime() != other-&gt;startMediaTime())
355         return startMediaTime() &lt; other-&gt;startMediaTime();
356 
357     // then, any cues with the same start time must be sorted by their end time, latest first;
358     if (endMediaTime() != other-&gt;endMediaTime())
359         return endMediaTime() &gt; other-&gt;endMediaTime();
360 
361     // and finally, any cues with identical end times must be sorted in the order they were last added to
362     // their respective text track list of cues, oldest first (so e.g. for cues from a WebVTT file, that
363     // would initially be the order in which the cues were listed in the file)
364     return cueIndex() &lt; other-&gt;cueIndex();
365 }
366 
367 bool TextTrackCue::cueContentsMatch(const TextTrackCue&amp; cue) const
368 {
369     if (cueType() != cue.cueType())
370         return false;
371 
372     if (id() != cue.id())
373         return false;
374 
375     return true;
376 }
377 
378 bool TextTrackCue::isEqual(const TextTrackCue&amp; cue, TextTrackCue::CueMatchRules match) const
379 {
380     if (cueType() != cue.cueType())
381         return false;
382 
383     if (match != IgnoreDuration &amp;&amp; endMediaTime() != cue.endMediaTime())
384         return false;
385     if (!hasEquivalentStartTime(cue))
386         return false;
387     if (!cueContentsMatch(cue))
388         return false;
389 
390     return true;
391 }
392 
393 bool TextTrackCue::hasEquivalentStartTime(const TextTrackCue&amp; cue) const
394 {
395     MediaTime startTimeVariance = MediaTime::zeroTime();
396     if (track())
397         startTimeVariance = track()-&gt;startTimeVariance();
398     else if (cue.track())
399         startTimeVariance = cue.track()-&gt;startTimeVariance();
400 
401     return abs(abs(startMediaTime()) - abs(cue.startMediaTime())) &lt;= startTimeVariance;
402 }
403 
404 bool TextTrackCue::doesExtendCue(const TextTrackCue&amp; cue) const
405 {
406     if (!cueContentsMatch(cue))
407         return false;
408 
409     if (endMediaTime() != cue.startMediaTime())
410         return false;
411 
412     return true;
413 }
414 
415 void TextTrackCue::toJSON(JSON::Object&amp; value) const
416 {
417     ASCIILiteral type = &quot;Generic&quot;_s;
418     switch (cueType()) {
419     case TextTrackCue::ConvertedToWebVTT:
420         type = &quot;ConvertedToWebVTT&quot;_s;
421         break;
422     case TextTrackCue::WebVTT:
423         type = &quot;WebVTT&quot;_s;
424         break;
425     case TextTrackCue::Data:
426         type = &quot;Data&quot;_s;
427         break;
428     case TextTrackCue::Generic:
429         type = &quot;Generic&quot;_s;
430         break;
431     }
432 
433     value.setString(&quot;type&quot;_s, type);
434     value.setDouble(&quot;startTime&quot;_s, startTime());
435     value.setDouble(&quot;endTime&quot;_s, endTime());
436 }
437 
438 String TextTrackCue::toJSONString() const
439 {
440     auto object = JSON::Object::create();
441 
442     toJSON(object.get());
443 
444     return object-&gt;toJSONString();
445 }
446 
447 #ifndef NDEBUG
448 
449 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const TextTrackCue&amp; cue)
450 {
451     String text;
452     if (is&lt;VTTCue&gt;(cue))
453         text = toVTTCue(&amp;cue)-&gt;text();
454     return stream &lt;&lt; &amp;cue &lt;&lt; &quot; id=&quot; &lt;&lt; cue.id() &lt;&lt; &quot; interval=&quot; &lt;&lt; cue.startTime() &lt;&lt; &quot;--&gt;&quot; &lt;&lt; cue.endTime() &lt;&lt; &quot; cue=&quot; &lt;&lt; text &lt;&lt; &#39;)&#39;;
455 }
456 
457 #endif
458 
459 RefPtr&lt;DocumentFragment&gt; TextTrackCue::getCueAsHTML()
460 {
461     if (!m_cueNode)
462         return nullptr;
463 
464     auto clonedFragment = DocumentFragment::create(ownerDocument());
465     m_cueNode-&gt;cloneChildNodes(clonedFragment);
466 
467     for (Node* node = clonedFragment-&gt;firstChild(); node; node = node-&gt;nextSibling())
468         removePseudoAttributes(*node);
469 
470     return clonedFragment;
471 }
472 
473 bool TextTrackCue::isRenderable() const
474 {
475     return m_cueNode &amp;&amp; m_cueNode-&gt;firstChild();
476 }
477 
478 RefPtr&lt;TextTrackCueBox&gt; TextTrackCue::getDisplayTree(const IntSize&amp;, int)
479 {
480     if (m_displayTree &amp;&amp; !m_displayTreeNeedsUpdate)
481         return m_displayTree;
482 
483     rebuildDisplayTree();
484 
485     return m_displayTree;
486 }
487 
488 void TextTrackCue::removeDisplayTree()
489 {
490     if (!m_displayTree)
491         return;
492 
493     // The display tree is never exposed to author scripts so it&#39;s safe to dispatch events here.
494     ScriptDisallowedScope::EventAllowedScope allowedScope(*m_displayTree);
495     m_displayTree-&gt;remove();
496 }
497 
498 void TextTrackCue::setFontSize(int fontSize, const IntSize&amp;, bool important)
499 {
500     if (fontSize == m_fontSize &amp;&amp; important == m_fontSizeIsImportant)
501         return;
502 
503     m_displayTreeNeedsUpdate = true;
504     m_fontSizeIsImportant = important;
505     m_fontSize = fontSize;
506 }
507 
508 void TextTrackCue::rebuildDisplayTree()
509 {
510     if (!m_cueNode)
511         return;
512 
513     ScriptDisallowedScope::EventAllowedScope allowedScopeForReferenceTree(*m_cueNode);
514 
515     if (!m_displayTree) {
516         m_displayTree = TextTrackCueBox::create(ownerDocument(), *this);
517         m_displayTree-&gt;setPseudo(AtomString(&quot;-webkit-generic-cue-root&quot;, AtomString::ConstructFromLiteral));
518     }
519 
520     m_displayTree-&gt;removeChildren();
521     auto clonedFragment = DocumentFragment::create(ownerDocument());
522     m_cueNode-&gt;cloneChildNodes(clonedFragment);
523     m_displayTree-&gt;appendChild(clonedFragment);
524 
525     if (m_fontSize &amp;&amp; ownerDocument().page()) {
526         StringBuilder builder;
527         builder.append(ownerDocument().page()-&gt;captionUserPreferencesStyleSheet());
528         builder.appendLiteral(&quot; ::&quot;);
529         builder.append(TextTrackCue::cueShadowPseudoId());
530         builder.append(&#39;{&#39;);
531         builder.append(getPropertyNameString(CSSPropertyFontSize));
532         builder.append(&#39;:&#39;);
533         builder.append(makeString(m_fontSize, &quot;px&quot;));
534         if (m_fontSizeIsImportant)
535             builder.appendLiteral(&quot; !important&quot;);
536         builder.appendLiteral(&quot;; }&quot;);
537 
538         auto style = HTMLStyleElement::create(HTMLNames::styleTag, ownerDocument(), false);
539         style-&gt;setTextContent(builder.toString());
540         m_displayTree-&gt;appendChild(style);
541     }
542 
543     if (track()) {
544         if (const auto&amp; styleSheets = track()-&gt;styleSheets()) {
545             for (const auto&amp; cssString : *styleSheets) {
546                 auto style = HTMLStyleElement::create(HTMLNames::styleTag, m_displayTree-&gt;document(), false);
547                 style-&gt;setTextContent(cssString);
548                 m_displayTree-&gt;appendChild(style);
549             }
550         }
551     }
552 
553     m_displayTreeNeedsUpdate = false;
554 }
555 
556 } // namespace WebCore
557 
558 #endif
    </pre>
  </body>
</html>
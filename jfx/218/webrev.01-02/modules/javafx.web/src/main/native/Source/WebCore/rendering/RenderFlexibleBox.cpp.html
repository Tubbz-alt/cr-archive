<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFlexibleBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions are
   6  * met:
   7  *
   8  *     * Redistributions of source code must retain the above copyright
   9  * notice, this list of conditions and the following disclaimer.
  10  *     * Redistributions in binary form must reproduce the above
  11  * copyright notice, this list of conditions and the following disclaimer
  12  * in the documentation and/or other materials provided with the
  13  * distribution.
  14  *     * Neither the name of Google Inc. nor the names of its
  15  * contributors may be used to endorse or promote products derived from
  16  * this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;RenderFlexibleBox.h&quot;
  33 
  34 #include &quot;FlexibleBoxAlgorithm.h&quot;
  35 #include &quot;LayoutRepainter.h&quot;
  36 #include &quot;RenderChildIterator.h&quot;
  37 #include &quot;RenderLayer.h&quot;
  38 #include &quot;RenderLayoutState.h&quot;
  39 #include &quot;RenderView.h&quot;
  40 #include &lt;limits&gt;
  41 #include &lt;wtf/IsoMallocInlines.h&gt;
  42 #include &lt;wtf/MathExtras.h&gt;
  43 #include &lt;wtf/SetForScope.h&gt;
  44 
  45 namespace WebCore {
  46 
  47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFlexibleBox);
  48 
  49 struct RenderFlexibleBox::LineContext {
  50     LineContext(LayoutUnit crossAxisOffset, LayoutUnit crossAxisExtent, LayoutUnit maxAscent, Vector&lt;FlexItem&gt;&amp;&amp; flexItems)
  51         : crossAxisOffset(crossAxisOffset)
  52         , crossAxisExtent(crossAxisExtent)
  53         , maxAscent(maxAscent)
  54         , flexItems(flexItems)
  55     {
  56     }
  57 
  58     LayoutUnit crossAxisOffset;
  59     LayoutUnit crossAxisExtent;
  60     LayoutUnit maxAscent;
  61     Vector&lt;FlexItem&gt; flexItems;
  62 };
  63 
  64 RenderFlexibleBox::RenderFlexibleBox(Element&amp; element, RenderStyle&amp;&amp; style)
  65     : RenderBlock(element, WTFMove(style), 0)
  66 {
  67     setChildrenInline(false); // All of our children must be block-level.
  68 }
  69 
  70 RenderFlexibleBox::RenderFlexibleBox(Document&amp; document, RenderStyle&amp;&amp; style)
  71     : RenderBlock(document, WTFMove(style), 0)
  72 {
  73     setChildrenInline(false); // All of our children must be block-level.
  74 }
  75 
  76 RenderFlexibleBox::~RenderFlexibleBox() = default;
  77 
  78 const char* RenderFlexibleBox::renderName() const
  79 {
  80     return &quot;RenderFlexibleBox&quot;;
  81 }
  82 
  83 void RenderFlexibleBox::computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const
  84 {
  85     LayoutUnit childMinWidth;
  86     LayoutUnit childMaxWidth;
  87     bool hadExcludedChildren = computePreferredWidthsForExcludedChildren(childMinWidth, childMaxWidth);
  88 
  89     // FIXME: We&#39;re ignoring flex-basis here and we shouldn&#39;t. We can&#39;t start
  90     // honoring it though until the flex shorthand stops setting it to 0. See
  91     // https://bugs.webkit.org/show_bug.cgi?id=116117 and
  92     // https://crbug.com/240765.
  93     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
  94         if (child-&gt;isOutOfFlowPositioned() || child-&gt;isExcludedFromNormalLayout())
  95             continue;
  96 
  97         LayoutUnit margin = marginIntrinsicLogicalWidthForChild(*child);
  98 
  99         LayoutUnit minPreferredLogicalWidth;
 100         LayoutUnit maxPreferredLogicalWidth;
 101         computeChildPreferredLogicalWidths(*child, minPreferredLogicalWidth, maxPreferredLogicalWidth);
 102 
 103         minPreferredLogicalWidth += margin;
 104         maxPreferredLogicalWidth += margin;
 105 
 106         if (!isColumnFlow()) {
 107             maxLogicalWidth += maxPreferredLogicalWidth;
 108             if (isMultiline()) {
 109                 // For multiline, the min preferred width is if you put a break between
 110                 // each item.
 111                 minLogicalWidth = std::max(minLogicalWidth, minPreferredLogicalWidth);
 112             } else
 113                 minLogicalWidth += minPreferredLogicalWidth;
 114         } else {
 115             minLogicalWidth = std::max(minPreferredLogicalWidth, minLogicalWidth);
 116             maxLogicalWidth = std::max(maxPreferredLogicalWidth, maxLogicalWidth);
 117         }
 118     }
 119 
 120     maxLogicalWidth = std::max(minLogicalWidth, maxLogicalWidth);
 121 
 122     // Due to negative margins, it is possible that we calculated a negative
 123     // intrinsic width. Make sure that we never return a negative width.
 124     minLogicalWidth = std::max(0_lu, minLogicalWidth);
 125     maxLogicalWidth = std::max(0_lu, maxLogicalWidth);
 126 
 127     if (hadExcludedChildren) {
 128         minLogicalWidth = std::max(minLogicalWidth, childMinWidth);
 129         maxLogicalWidth = std::max(maxLogicalWidth, childMaxWidth);
 130     }
 131 
 132     LayoutUnit scrollbarWidth(scrollbarLogicalWidth());
 133     maxLogicalWidth += scrollbarWidth;
 134     minLogicalWidth += scrollbarWidth;
 135 }
 136 
 137 void RenderFlexibleBox::computePreferredLogicalWidths()
 138 {
 139     ASSERT(preferredLogicalWidthsDirty());
 140 
 141     m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = 0;
 142 
 143     const RenderStyle&amp; styleToUse = style();
 144     // FIXME: This should probably be checking for isSpecified since you should be able to use percentage, calc or viewport relative values for width.
 145     if (styleToUse.logicalWidth().isFixed() &amp;&amp; styleToUse.logicalWidth().value() &gt; 0)
 146         m_minPreferredLogicalWidth = m_maxPreferredLogicalWidth = adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalWidth().value());
 147     else
 148         computeIntrinsicLogicalWidths(m_minPreferredLogicalWidth, m_maxPreferredLogicalWidth);
 149 
 150     // FIXME: This should probably be checking for isSpecified since you should be able to use percentage, calc or viewport relative values for min-width.
 151     if (styleToUse.logicalMinWidth().isFixed() &amp;&amp; styleToUse.logicalMinWidth().value() &gt; 0) {
 152         m_maxPreferredLogicalWidth = std::max(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
 153         m_minPreferredLogicalWidth = std::max(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMinWidth().value()));
 154     }
 155 
 156     // FIXME: This should probably be checking for isSpecified since you should be able to use percentage, calc or viewport relative values for maxWidth.
 157     if (styleToUse.logicalMaxWidth().isFixed()) {
 158         m_maxPreferredLogicalWidth = std::min(m_maxPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
 159         m_minPreferredLogicalWidth = std::min(m_minPreferredLogicalWidth, adjustContentBoxLogicalWidthForBoxSizing(styleToUse.logicalMaxWidth().value()));
 160     }
 161 
 162     LayoutUnit borderAndPadding = borderAndPaddingLogicalWidth();
 163     m_minPreferredLogicalWidth += borderAndPadding;
 164     m_maxPreferredLogicalWidth += borderAndPadding;
 165 
 166     setPreferredLogicalWidthsDirty(false);
 167 }
 168 
 169 static int synthesizedBaselineFromBorderBox(const RenderBox&amp; box, LineDirectionMode direction)
 170 {
 171     return (direction == HorizontalLine ? box.size().height() : box.size().width()).toInt();
 172 }
 173 
 174 int RenderFlexibleBox::baselinePosition(FontBaseline, bool, LineDirectionMode direction, LinePositionMode) const
 175 {
 176     auto baseline = firstLineBaseline();
 177     if (!baseline)
 178         return synthesizedBaselineFromBorderBox(*this, direction) + marginLogicalHeight();
 179 
 180     return baseline.value() + (direction == HorizontalLine ? marginTop() : marginRight()).toInt();
 181 }
 182 
 183 Optional&lt;int&gt; RenderFlexibleBox::firstLineBaseline() const
 184 {
 185     if (isWritingModeRoot() || m_numberOfInFlowChildrenOnFirstLine &lt;= 0)
 186         return Optional&lt;int&gt;();
 187     RenderBox* baselineChild = nullptr;
 188     int childNumber = 0;
 189     for (RenderBox* child = m_orderIterator.first(); child; child = m_orderIterator.next()) {
 190         if (m_orderIterator.shouldSkipChild(*child))
 191             continue;
 192         if (alignmentForChild(*child) == ItemPosition::Baseline &amp;&amp; !hasAutoMarginsInCrossAxis(*child)) {
 193             baselineChild = child;
 194             break;
 195         }
 196         if (!baselineChild)
 197             baselineChild = child;
 198 
 199         ++childNumber;
 200         if (childNumber == m_numberOfInFlowChildrenOnFirstLine)
 201             break;
 202     }
 203 
 204     if (!baselineChild)
 205         return Optional&lt;int&gt;();
 206 
 207     if (!isColumnFlow() &amp;&amp; hasOrthogonalFlow(*baselineChild))
 208         return Optional&lt;int&gt;(crossAxisExtentForChild(*baselineChild) + baselineChild-&gt;logicalTop());
 209     if (isColumnFlow() &amp;&amp; !hasOrthogonalFlow(*baselineChild))
 210         return Optional&lt;int&gt;(mainAxisExtentForChild(*baselineChild) + baselineChild-&gt;logicalTop());
 211 
 212     Optional&lt;int&gt; baseline = baselineChild-&gt;firstLineBaseline();
 213     if (!baseline) {
 214         // FIXME: We should pass |direction| into firstLineBoxBaseline and stop bailing out if we&#39;re a writing mode root.
 215         // This would also fix some cases where the flexbox is orthogonal to its container.
 216         LineDirectionMode direction = isHorizontalWritingMode() ? HorizontalLine : VerticalLine;
 217         return Optional&lt;int&gt;(synthesizedBaselineFromBorderBox(*baselineChild, direction) + baselineChild-&gt;logicalTop());
 218     }
 219 
 220     return Optional&lt;int&gt;(baseline.value() + baselineChild-&gt;logicalTop());
 221 }
 222 
 223 Optional&lt;int&gt; RenderFlexibleBox::inlineBlockBaseline(LineDirectionMode) const
 224 {
 225     return firstLineBaseline();
 226 }
 227 
 228 static const StyleContentAlignmentData&amp; contentAlignmentNormalBehavior()
 229 {
 230     // The justify-content property applies along the main axis, but since
 231     // flexing in the main axis is controlled by flex, stretch behaves as
 232     // flex-start (ignoring the specified fallback alignment, if any).
 233     // https://drafts.csswg.org/css-align/#distribution-flex
 234     static const StyleContentAlignmentData normalBehavior = { ContentPosition::Normal, ContentDistribution::Stretch};
 235     return normalBehavior;
 236 }
 237 
 238 void RenderFlexibleBox::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 239 {
 240     RenderBlock::styleDidChange(diff, oldStyle);
 241     if (!oldStyle || diff != StyleDifference::Layout)
 242         return;
 243 
 244     if (oldStyle-&gt;resolvedAlignItems(selfAlignmentNormalBehavior()).position() == ItemPosition::Stretch) {
 245         // Flex items that were previously stretching need to be relayed out so we
 246         // can compute new available cross axis space. This is only necessary for
 247         // stretching since other alignment values don&#39;t change the size of the
 248         // box.
 249         for (auto&amp; child : childrenOfType&lt;RenderBox&gt;(*this)) {
 250             ItemPosition previousAlignment = child.style().resolvedAlignSelf(oldStyle, selfAlignmentNormalBehavior()).position();
 251             if (previousAlignment == ItemPosition::Stretch &amp;&amp; previousAlignment != child.style().resolvedAlignSelf(&amp;style(), selfAlignmentNormalBehavior()).position())
 252                 child.setChildNeedsLayout(MarkOnlyThis);
 253         }
 254     }
 255 }
 256 
 257 void RenderFlexibleBox::layoutBlock(bool relayoutChildren, LayoutUnit)
 258 {
 259     ASSERT(needsLayout());
 260 
 261     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 262         return;
 263 
 264     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 265 
 266     resetLogicalHeightBeforeLayoutIfNeeded();
 267     m_relaidOutChildren.clear();
 268 
 269     bool oldInLayout = m_inLayout;
 270     m_inLayout = true;
 271 
 272     if (recomputeLogicalWidth())
 273         relayoutChildren = true;
 274 
 275     LayoutUnit previousHeight = logicalHeight();
 276     setLogicalHeight(borderAndPaddingLogicalHeight() + scrollbarLogicalHeight());
 277     {
 278         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
 279 
 280         preparePaginationBeforeBlockLayout(relayoutChildren);
 281 
 282         m_numberOfInFlowChildrenOnFirstLine = -1;
 283 
 284         beginUpdateScrollInfoAfterLayoutTransaction();
 285 
 286         prepareOrderIteratorAndMargins();
 287 
 288         // Fieldsets need to find their legend and position it inside the border of the object.
 289         // The legend then gets skipped during normal layout. The same is true for ruby text.
 290         // It doesn&#39;t get included in the normal layout process but is instead skipped.
 291         layoutExcludedChildren(relayoutChildren);
 292 
 293         ChildFrameRects oldChildRects;
 294         appendChildFrameRects(oldChildRects);
 295 
 296         layoutFlexItems(relayoutChildren);
 297 
 298         endAndCommitUpdateScrollInfoAfterLayoutTransaction();
 299 
 300         if (logicalHeight() != previousHeight)
 301             relayoutChildren = true;
 302 
 303         layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());
 304 
 305         repaintChildrenDuringLayoutIfMoved(oldChildRects);
 306         // FIXME: css3/flexbox/repaint-rtl-column.html seems to repaint more overflow than it needs to.
 307         computeOverflow(clientLogicalBottomAfterRepositioning());
 308     }
 309     updateLayerTransform();
 310 
 311     // We have to reset this, because changes to our ancestors&#39; style can affect
 312     // this value. Also, this needs to be before we call updateAfterLayout, as
 313     // that function may re-enter this one.
 314     m_hasDefiniteHeight = SizeDefiniteness::Unknown;
 315 
 316     // Update our scroll information if we&#39;re overflow:auto/scroll/hidden now that we know if we overflow or not.
 317     updateScrollInfoAfterLayout();
 318 
 319     repainter.repaintAfterLayout();
 320 
 321     clearNeedsLayout();
 322 
 323     m_inLayout = oldInLayout;
 324 }
 325 
 326 void RenderFlexibleBox::appendChildFrameRects(ChildFrameRects&amp; childFrameRects)
 327 {
 328     for (RenderBox* child = m_orderIterator.first(); child; child = m_orderIterator.next()) {
 329         if (!child-&gt;isOutOfFlowPositioned())
 330             childFrameRects.append(child-&gt;frameRect());
 331     }
 332 }
 333 
 334 void RenderFlexibleBox::repaintChildrenDuringLayoutIfMoved(const ChildFrameRects&amp; oldChildRects)
 335 {
 336     size_t childIndex = 0;
 337     for (RenderBox* child = m_orderIterator.first(); child; child = m_orderIterator.next()) {
 338         if (child-&gt;isOutOfFlowPositioned())
 339             continue;
 340 
 341         // If the child moved, we have to repaint it as well as any floating/positioned
 342         // descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
 343         // repaint ourselves (and the child) anyway.
 344         if (!selfNeedsLayout() &amp;&amp; child-&gt;checkForRepaintDuringLayout())
 345             child-&gt;repaintDuringLayoutIfMoved(oldChildRects[childIndex]);
 346         ++childIndex;
 347     }
 348     ASSERT(childIndex == oldChildRects.size());
 349 }
 350 
 351 void RenderFlexibleBox::paintChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset, PaintInfo&amp; paintInfoForChild, bool usePrintRect)
 352 {
 353     for (RenderBox* child = m_orderIterator.first(); child; child = m_orderIterator.next()) {
 354         if (!paintChild(*child, paintInfo, paintOffset, paintInfoForChild, usePrintRect, PaintAsInlineBlock))
 355             return;
 356     }
 357 }
 358 
 359 void RenderFlexibleBox::repositionLogicalHeightDependentFlexItems(Vector&lt;LineContext&gt;&amp; lineContexts)
 360 {
 361     LayoutUnit crossAxisStartEdge = lineContexts.isEmpty() ? 0_lu : lineContexts[0].crossAxisOffset;
 362     alignFlexLines(lineContexts);
 363 
 364     alignChildren(lineContexts);
 365 
 366     if (style().flexWrap() == FlexWrap::Reverse)
 367         flipForWrapReverse(lineContexts, crossAxisStartEdge);
 368 
 369     // direction:rtl + flex-direction:column means the cross-axis direction is
 370     // flipped.
 371     flipForRightToLeftColumn(lineContexts);
 372 }
 373 
 374 LayoutUnit RenderFlexibleBox::clientLogicalBottomAfterRepositioning()
 375 {
 376     LayoutUnit maxChildLogicalBottom;
 377     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
 378         if (child-&gt;isOutOfFlowPositioned())
 379             continue;
 380         LayoutUnit childLogicalBottom = logicalTopForChild(*child) + logicalHeightForChild(*child) + marginAfterForChild(*child);
 381         maxChildLogicalBottom = std::max(maxChildLogicalBottom, childLogicalBottom);
 382     }
 383     return std::max(clientLogicalBottom(), maxChildLogicalBottom + paddingAfter());
 384 }
 385 
 386 bool RenderFlexibleBox::hasOrthogonalFlow(const RenderBox&amp; child) const
 387 {
 388     return isHorizontalFlow() != child.isHorizontalWritingMode();
 389 }
 390 
 391 bool RenderFlexibleBox::isColumnFlow() const
 392 {
 393     return style().isColumnFlexDirection();
 394 }
 395 
 396 bool RenderFlexibleBox::isHorizontalFlow() const
 397 {
 398     if (isHorizontalWritingMode())
 399         return !isColumnFlow();
 400     return isColumnFlow();
 401 }
 402 
 403 bool RenderFlexibleBox::isLeftToRightFlow() const
 404 {
 405     if (isColumnFlow())
 406         return style().writingMode() == TopToBottomWritingMode || style().writingMode() == LeftToRightWritingMode;
 407     return style().isLeftToRightDirection() ^ (style().flexDirection() == FlexDirection::RowReverse);
 408 }
 409 
 410 bool RenderFlexibleBox::isMultiline() const
 411 {
 412     return style().flexWrap() != FlexWrap::NoWrap;
 413 }
 414 
 415 Length RenderFlexibleBox::flexBasisForChild(const RenderBox&amp; child) const
 416 {
 417     Length flexLength = child.style().flexBasis();
 418     if (flexLength.isAuto())
 419         flexLength = isHorizontalFlow() ? child.style().width() : child.style().height();
 420     return flexLength;
 421 }
 422 
 423 LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(const RenderBox&amp; child) const
 424 {
 425     return isHorizontalFlow() ? child.height() : child.width();
 426 }
 427 
 428 LayoutUnit RenderFlexibleBox::cachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child) const
 429 {
 430     if (child.isRenderReplaced())
 431         return downcast&lt;RenderReplaced&gt;(child).intrinsicLogicalHeight();
 432 
 433     if (m_intrinsicContentLogicalHeights.contains(&amp;child))
 434         return m_intrinsicContentLogicalHeights.get(&amp;child);
 435 
 436     return child.contentLogicalHeight();
 437 }
 438 
 439 void RenderFlexibleBox::setCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child, LayoutUnit height)
 440 {
 441     if (child.isRenderReplaced())
 442         return; // Replaced elements know their intrinsic height already, so save space by not caching.
 443     m_intrinsicContentLogicalHeights.set(&amp;child, height);
 444 }
 445 
 446 void RenderFlexibleBox::clearCachedChildIntrinsicContentLogicalHeight(const RenderBox&amp; child)
 447 {
 448     if (child.isRenderReplaced())
 449         return; // Replaced elements know their intrinsic height already, so nothing to do.
 450     m_intrinsicContentLogicalHeights.remove(&amp;child);
 451 }
 452 
 453 LayoutUnit RenderFlexibleBox::childIntrinsicLogicalHeight(const RenderBox&amp; child) const
 454 {
 455     // This should only be called if the logical height is the cross size
 456     ASSERT(!hasOrthogonalFlow(child));
 457     if (needToStretchChildLogicalHeight(child)) {
 458         LayoutUnit childContentHeight = cachedChildIntrinsicContentLogicalHeight(child);
 459         LayoutUnit childLogicalHeight = childContentHeight + child.scrollbarLogicalHeight() + child.borderAndPaddingLogicalHeight();
 460         return child.constrainLogicalHeightByMinMax(childLogicalHeight, childContentHeight);
 461     }
 462     return child.logicalHeight();
 463 }
 464 
 465 LayoutUnit RenderFlexibleBox::childIntrinsicLogicalWidth(const RenderBox&amp; child) const
 466 {
 467     // This should only be called if the logical width is the cross size
 468     ASSERT(hasOrthogonalFlow(child));
 469     // If our height is auto, make sure that our returned height is unaffected by
 470     // earlier layouts by returning the max preferred logical width
 471     if (!crossAxisLengthIsDefinite(child, child.style().logicalWidth()))
 472         return child.maxPreferredLogicalWidth();
 473     return child.logicalWidth();
 474 }
 475 
 476 LayoutUnit RenderFlexibleBox::crossAxisIntrinsicExtentForChild(const RenderBox&amp; child) const
 477 {
 478     return hasOrthogonalFlow(child) ? childIntrinsicLogicalWidth(child) : childIntrinsicLogicalHeight(child);
 479 }
 480 
 481 LayoutUnit RenderFlexibleBox::mainAxisExtentForChild(const RenderBox&amp; child) const
 482 {
 483     return isHorizontalFlow() ? child.size().width() : child.size().height();
 484 }
 485 
 486 LayoutUnit RenderFlexibleBox::mainAxisContentExtentForChildIncludingScrollbar(const RenderBox&amp; child) const
 487 {
 488     return isHorizontalFlow() ? child.contentWidth() + child.verticalScrollbarWidth() : child.contentHeight() + child.horizontalScrollbarHeight();
 489 }
 490 
 491 LayoutUnit RenderFlexibleBox::crossAxisExtent() const
 492 {
 493     return isHorizontalFlow() ? size().height() : size().width();
 494 }
 495 
 496 LayoutUnit RenderFlexibleBox::mainAxisExtent() const
 497 {
 498     return isHorizontalFlow() ? size().width() : size().height();
 499 }
 500 
 501 LayoutUnit RenderFlexibleBox::crossAxisContentExtent() const
 502 {
 503     return isHorizontalFlow() ? contentHeight() : contentWidth();
 504 }
 505 
 506 LayoutUnit RenderFlexibleBox::mainAxisContentExtent(LayoutUnit contentLogicalHeight)
 507 {
 508     if (isColumnFlow()) {
 509         LayoutUnit borderPaddingAndScrollbar = borderAndPaddingLogicalHeight() + scrollbarLogicalHeight();
 510         LayoutUnit borderBoxLogicalHeight = contentLogicalHeight + borderPaddingAndScrollbar;
 511         auto computedValues = computeLogicalHeight(borderBoxLogicalHeight, logicalTop());
 512         if (computedValues.m_extent == LayoutUnit::max())
 513             return computedValues.m_extent;
 514         return std::max(0_lu, computedValues.m_extent - borderPaddingAndScrollbar);
 515     }
 516     return contentLogicalWidth();
 517 }
 518 
 519 Optional&lt;LayoutUnit&gt; RenderFlexibleBox::computeMainAxisExtentForChild(const RenderBox&amp; child, SizeType sizeType, const Length&amp; size)
 520 {
 521     // If we have a horizontal flow, that means the main size is the width.
 522     // That&#39;s the logical width for horizontal writing modes, and the logical
 523     // height in vertical writing modes. For a vertical flow, main size is the
 524     // height, so it&#39;s the inverse. So we need the logical width if we have a
 525     // horizontal flow and horizontal writing mode, or vertical flow and vertical
 526     // writing mode. Otherwise we need the logical height.
 527     if (isHorizontalFlow() != child.style().isHorizontalWritingMode()) {
 528         // We don&#39;t have to check for &quot;auto&quot; here - computeContentLogicalHeight
 529         // will just return a null Optional for that case anyway. It&#39;s safe to access
 530         // scrollbarLogicalHeight here because ComputeNextFlexLine will have
 531         // already forced layout on the child. We previously did a layout out the child
 532         // if necessary (see ComputeNextFlexLine and the call to
 533         // childHasIntrinsicMainAxisSize) so we can be sure that the two height
 534         // calls here will return up-to-date data.
 535         Optional&lt;LayoutUnit&gt; height = child.computeContentLogicalHeight(sizeType, size, cachedChildIntrinsicContentLogicalHeight(child));
 536         if (!height)
 537             return height;
 538         return height.value() + child.scrollbarLogicalHeight();
 539     }
 540 
 541     // computeLogicalWidth always re-computes the intrinsic widths. However, when
 542     // our logical width is auto, we can just use our cached value. So let&#39;s do
 543     // that here. (Compare code in LayoutBlock::computePreferredLogicalWidths)
 544     LayoutUnit borderAndPadding = child.borderAndPaddingLogicalWidth();
 545     if (child.style().logicalWidth().isAuto() &amp;&amp; !child.hasAspectRatio()) {
 546         if (size.type() == MinContent)
 547             return child.minPreferredLogicalWidth() - borderAndPadding;
 548         if (size.type() == MaxContent)
 549             return child.maxPreferredLogicalWidth() - borderAndPadding;
 550     }
 551 
 552     // FIXME: Figure out how this should work for regions and pass in the appropriate values.
 553     RenderFragmentContainer* fragment = nullptr;
 554     return child.computeLogicalWidthInFragmentUsing(sizeType, size, contentLogicalWidth(), *this, fragment) - borderAndPadding;
 555 }
 556 
 557 
 558 WritingMode RenderFlexibleBox::transformedWritingMode() const
 559 {
 560     WritingMode mode = style().writingMode();
 561     if (!isColumnFlow())
 562         return mode;
 563 
 564     switch (mode) {
 565     case TopToBottomWritingMode:
 566     case BottomToTopWritingMode:
 567         return style().isLeftToRightDirection() ? LeftToRightWritingMode : RightToLeftWritingMode;
 568     case LeftToRightWritingMode:
 569     case RightToLeftWritingMode:
 570         return style().isLeftToRightDirection() ? TopToBottomWritingMode : BottomToTopWritingMode;
 571     }
 572     ASSERT_NOT_REACHED();
 573     return TopToBottomWritingMode;
 574 }
 575 
 576 LayoutUnit RenderFlexibleBox::flowAwareBorderStart() const
 577 {
 578     if (isHorizontalFlow())
 579         return isLeftToRightFlow() ? borderLeft() : borderRight();
 580     return isLeftToRightFlow() ? borderTop() : borderBottom();
 581 }
 582 
 583 LayoutUnit RenderFlexibleBox::flowAwareBorderEnd() const
 584 {
 585     if (isHorizontalFlow())
 586         return isLeftToRightFlow() ? borderRight() : borderLeft();
 587     return isLeftToRightFlow() ? borderBottom() : borderTop();
 588 }
 589 
 590 LayoutUnit RenderFlexibleBox::flowAwareBorderBefore() const
 591 {
 592     switch (transformedWritingMode()) {
 593     case TopToBottomWritingMode:
 594         return borderTop();
 595     case BottomToTopWritingMode:
 596         return borderBottom();
 597     case LeftToRightWritingMode:
 598         return borderLeft();
 599     case RightToLeftWritingMode:
 600         return borderRight();
 601     }
 602     ASSERT_NOT_REACHED();
 603     return borderTop();
 604 }
 605 
 606 LayoutUnit RenderFlexibleBox::flowAwareBorderAfter() const
 607 {
 608     switch (transformedWritingMode()) {
 609     case TopToBottomWritingMode:
 610         return borderBottom();
 611     case BottomToTopWritingMode:
 612         return borderTop();
 613     case LeftToRightWritingMode:
 614         return borderRight();
 615     case RightToLeftWritingMode:
 616         return borderLeft();
 617     }
 618     ASSERT_NOT_REACHED();
 619     return borderTop();
 620 }
 621 
 622 LayoutUnit RenderFlexibleBox::flowAwarePaddingStart() const
 623 {
 624     if (isHorizontalFlow())
 625         return isLeftToRightFlow() ? paddingLeft() : paddingRight();
 626     return isLeftToRightFlow() ? paddingTop() : paddingBottom();
 627 }
 628 
 629 LayoutUnit RenderFlexibleBox::flowAwarePaddingEnd() const
 630 {
 631     if (isHorizontalFlow())
 632         return isLeftToRightFlow() ? paddingRight() : paddingLeft();
 633     return isLeftToRightFlow() ? paddingBottom() : paddingTop();
 634 }
 635 
 636 LayoutUnit RenderFlexibleBox::flowAwarePaddingBefore() const
 637 {
 638     switch (transformedWritingMode()) {
 639     case TopToBottomWritingMode:
 640         return paddingTop();
 641     case BottomToTopWritingMode:
 642         return paddingBottom();
 643     case LeftToRightWritingMode:
 644         return paddingLeft();
 645     case RightToLeftWritingMode:
 646         return paddingRight();
 647     }
 648     ASSERT_NOT_REACHED();
 649     return paddingTop();
 650 }
 651 
 652 LayoutUnit RenderFlexibleBox::flowAwarePaddingAfter() const
 653 {
 654     switch (transformedWritingMode()) {
 655     case TopToBottomWritingMode:
 656         return paddingBottom();
 657     case BottomToTopWritingMode:
 658         return paddingTop();
 659     case LeftToRightWritingMode:
 660         return paddingRight();
 661     case RightToLeftWritingMode:
 662         return paddingLeft();
 663     }
 664     ASSERT_NOT_REACHED();
 665     return paddingTop();
 666 }
 667 
 668 LayoutUnit RenderFlexibleBox::flowAwareMarginStartForChild(const RenderBox&amp; child) const
 669 {
 670     if (isHorizontalFlow())
 671         return isLeftToRightFlow() ? child.marginLeft() : child.marginRight();
 672     return isLeftToRightFlow() ? child.marginTop() : child.marginBottom();
 673 }
 674 
 675 LayoutUnit RenderFlexibleBox::flowAwareMarginEndForChild(const RenderBox&amp; child) const
 676 {
 677     if (isHorizontalFlow())
 678         return isLeftToRightFlow() ? child.marginRight() : child.marginLeft();
 679     return isLeftToRightFlow() ? child.marginBottom() : child.marginTop();
 680 }
 681 
 682 LayoutUnit RenderFlexibleBox::flowAwareMarginBeforeForChild(const RenderBox&amp; child) const
 683 {
 684     switch (transformedWritingMode()) {
 685     case TopToBottomWritingMode:
 686         return child.marginTop();
 687     case BottomToTopWritingMode:
 688         return child.marginBottom();
 689     case LeftToRightWritingMode:
 690         return child.marginLeft();
 691     case RightToLeftWritingMode:
 692         return child.marginRight();
 693     }
 694     ASSERT_NOT_REACHED();
 695     return marginTop();
 696 }
 697 
 698 LayoutUnit RenderFlexibleBox::crossAxisMarginExtentForChild(const RenderBox&amp; child) const
 699 {
 700     return isHorizontalFlow() ? child.verticalMarginExtent() : child.horizontalMarginExtent();
 701 }
 702 
 703 LayoutUnit RenderFlexibleBox::crossAxisScrollbarExtent() const
 704 {
 705     return isHorizontalFlow() ? horizontalScrollbarHeight() : verticalScrollbarWidth();
 706 }
 707 
 708 LayoutPoint RenderFlexibleBox::flowAwareLocationForChild(const RenderBox&amp; child) const
 709 {
 710     return isHorizontalFlow() ? child.location() : child.location().transposedPoint();
 711 }
 712 
 713 bool RenderFlexibleBox::useChildAspectRatio(const RenderBox&amp; child) const
 714 {
 715     if (!child.hasAspectRatio())
 716         return false;
 717     if (!child.intrinsicSize().height()) {
 718         // We can&#39;t compute a ratio in this case.
 719         return false;
 720     }
 721     Length crossSize;
 722     if (isHorizontalFlow())
 723         crossSize = child.style().height();
 724     else
 725         crossSize = child.style().width();
 726     return crossAxisLengthIsDefinite(child, crossSize);
 727 }
 728 
 729 
 730 LayoutUnit RenderFlexibleBox::computeMainSizeFromAspectRatioUsing(const RenderBox&amp; child, Length crossSizeLength) const
 731 {
 732     ASSERT(child.hasAspectRatio());
 733     ASSERT(child.intrinsicSize().height());
 734 
 735     Optional&lt;LayoutUnit&gt; crossSize;
 736     if (crossSizeLength.isFixed())
 737         crossSize = LayoutUnit(crossSizeLength.value());
 738     else {
 739         ASSERT(crossSizeLength.isPercentOrCalculated());
 740         crossSize = hasOrthogonalFlow(child) ? adjustBorderBoxLogicalWidthForBoxSizing(valueForLength(crossSizeLength, contentWidth())) : child.computePercentageLogicalHeight(crossSizeLength);
 741         if (!crossSize)
 742             return 0_lu;
 743     }
 744 
 745     const LayoutSize&amp; childIntrinsicSize = child.intrinsicSize();
 746     double ratio = childIntrinsicSize.width().toFloat() /
 747     childIntrinsicSize.height().toFloat();
 748     if (isHorizontalFlow())
 749         return LayoutUnit(crossSize.value() * ratio);
 750     return LayoutUnit(crossSize.value() / ratio);
 751 }
 752 
 753 void RenderFlexibleBox::setFlowAwareLocationForChild(RenderBox&amp; child, const LayoutPoint&amp; location)
 754 {
 755     if (isHorizontalFlow())
 756         child.setLocation(location);
 757     else
 758         child.setLocation(location.transposedPoint());
 759 }
 760 
 761 bool RenderFlexibleBox::mainAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; flexBasis) const
 762 {
 763     if (flexBasis.isAuto())
 764         return false;
 765     if (flexBasis.isPercentOrCalculated()) {
 766         if (!isColumnFlow() || m_hasDefiniteHeight == SizeDefiniteness::Definite)
 767             return true;
 768         if (m_hasDefiniteHeight == SizeDefiniteness::Indefinite)
 769             return false;
 770         bool definite = child.computePercentageLogicalHeight(flexBasis) != WTF::nullopt;
 771         if (m_inLayout) {
 772             // We can reach this code even while we&#39;re not laying ourselves out, such
 773             // as from mainSizeForPercentageResolution.
 774             m_hasDefiniteHeight = definite ? SizeDefiniteness::Definite : SizeDefiniteness::Indefinite;
 775         }
 776         return definite;
 777     }
 778     return true;
 779 }
 780 
 781 bool RenderFlexibleBox::crossAxisLengthIsDefinite(const RenderBox&amp; child, const Length&amp; length) const
 782 {
 783     if (length.isAuto())
 784         return false;
 785     if (length.isPercentOrCalculated()) {
 786         if (hasOrthogonalFlow(child) || m_hasDefiniteHeight == SizeDefiniteness::Definite)
 787             return true;
 788         if (m_hasDefiniteHeight == SizeDefiniteness::Indefinite)
 789             return false;
 790         bool definite = bool(child.computePercentageLogicalHeight(length));
 791         m_hasDefiniteHeight = definite ? SizeDefiniteness::Definite : SizeDefiniteness::Indefinite;
 792         return definite;
 793     }
 794     // FIXME: Eventually we should support other types of sizes here.
 795     // Requires updating computeMainSizeFromAspectRatioUsing.
 796     return length.isFixed();
 797 }
 798 
 799 void RenderFlexibleBox::cacheChildMainSize(const RenderBox&amp; child)
 800 {
 801     ASSERT(!child.needsLayout());
 802     LayoutUnit mainSize;
 803     if (hasOrthogonalFlow(child))
 804         mainSize = child.logicalHeight();
 805     else
 806         mainSize = child.maxPreferredLogicalWidth();
 807     m_intrinsicSizeAlongMainAxis.set(&amp;child, mainSize);
 808     m_relaidOutChildren.add(&amp;child);
 809 }
 810 
 811 void RenderFlexibleBox::clearCachedMainSizeForChild(const RenderBox&amp; child)
 812 {
 813     m_intrinsicSizeAlongMainAxis.remove(&amp;child);
 814 }
 815 
 816 
 817 LayoutUnit RenderFlexibleBox::computeInnerFlexBaseSizeForChild(RenderBox&amp; child, LayoutUnit mainAxisBorderAndPadding, bool relayoutChildren)
 818 {
 819     child.clearOverrideContentSize();
 820 
 821     Length flexBasis = flexBasisForChild(child);
 822     if (mainAxisLengthIsDefinite(child, flexBasis))
 823         return std::max(0_lu, computeMainAxisExtentForChild(child, MainOrPreferredSize, flexBasis).value());
 824 
 825     // The flex basis is indefinite (=auto), so we need to compute the actual
 826     // width of the child. For the logical width axis we just use the preferred
 827     // width; for the height we need to lay out the child.
 828     LayoutUnit mainAxisExtent;
 829     if (hasOrthogonalFlow(child)) {
 830         updateBlockChildDirtyBitsBeforeLayout(relayoutChildren, child);
 831         if (child.needsLayout() || relayoutChildren || !m_intrinsicSizeAlongMainAxis.contains(&amp;child)) {
 832             if (!child.needsLayout())
 833                 child.setChildNeedsLayout(MarkOnlyThis);
 834             child.layoutIfNeeded();
 835             cacheChildMainSize(child);
 836         }
 837         mainAxisExtent = m_intrinsicSizeAlongMainAxis.get(&amp;child);
 838     } else {
 839         // We don&#39;t need to add scrollbarLogicalWidth here because the preferred
 840         // width includes the scrollbar, even for overflow: auto.
 841         mainAxisExtent = child.maxPreferredLogicalWidth();
 842     }
 843     return mainAxisExtent - mainAxisBorderAndPadding;
 844 }
 845 
 846 void RenderFlexibleBox::layoutFlexItems(bool relayoutChildren)
 847 {
 848     Vector&lt;LineContext&gt; lineContexts;
 849     LayoutUnit sumFlexBaseSize;
 850     double totalFlexGrow;
 851     double totalFlexShrink;
 852     double totalWeightedFlexShrink;
 853     LayoutUnit sumHypotheticalMainSize;
 854 
 855     // Set up our master list of flex items. All of the rest of the algorithm
 856     // should work off this list of a subset.
 857     // TODO(cbiesinger): That second part is not yet true.
 858     Vector&lt;FlexItem&gt; allItems;
 859     m_orderIterator.first();
 860     for (RenderBox* child = m_orderIterator.currentChild(); child; child = m_orderIterator.next()) {
 861         if (m_orderIterator.shouldSkipChild(*child)) {
 862             // Out-of-flow children are not flex items, so we skip them here.
 863             if (child-&gt;isOutOfFlowPositioned())
 864                 prepareChildForPositionedLayout(*child);
 865             continue;
 866         }
 867         allItems.append(constructFlexItem(*child, relayoutChildren));
 868     }
 869 
 870     const LayoutUnit lineBreakLength = mainAxisContentExtent(LayoutUnit::max());
 871     FlexLayoutAlgorithm flexAlgorithm(style(), lineBreakLength, allItems);
 872     LayoutUnit crossAxisOffset = flowAwareBorderBefore() + flowAwarePaddingBefore();
 873     Vector&lt;FlexItem&gt; lineItems;
 874     size_t nextIndex = 0;
 875     while (flexAlgorithm.computeNextFlexLine(nextIndex, lineItems, sumFlexBaseSize, totalFlexGrow, totalFlexShrink, totalWeightedFlexShrink, sumHypotheticalMainSize)) {
 876         LayoutUnit containerMainInnerSize = mainAxisContentExtent(sumHypotheticalMainSize);
 877         // availableFreeSpace is the initial amount of free space in this flexbox.
 878         // remainingFreeSpace starts out at the same value but as we place and lay
 879         // out flex items we subtract from it. Note that both values can be
 880         // negative.
 881         LayoutUnit remainingFreeSpace = containerMainInnerSize - sumFlexBaseSize;
 882         FlexSign flexSign = (sumHypotheticalMainSize &lt; containerMainInnerSize) ? PositiveFlexibility : NegativeFlexibility;
 883         freezeInflexibleItems(flexSign, lineItems, remainingFreeSpace, totalFlexGrow, totalFlexShrink, totalWeightedFlexShrink);
 884         // The initial free space gets calculated after freezing inflexible items.
 885         // https://drafts.csswg.org/css-flexbox/#resolve-flexible-lengths step 3
 886         const LayoutUnit initialFreeSpace = remainingFreeSpace;
 887         while (!resolveFlexibleLengths(flexSign, lineItems, initialFreeSpace, remainingFreeSpace, totalFlexGrow, totalFlexShrink, totalWeightedFlexShrink)) {
 888             ASSERT(totalFlexGrow &gt;= 0);
 889             ASSERT(totalWeightedFlexShrink &gt;= 0);
 890         }
 891 
 892         // Recalculate the remaining free space. The adjustment for flex factors
 893         // between 0..1 means we can&#39;t just use remainingFreeSpace here.
 894         remainingFreeSpace = containerMainInnerSize;
 895         for (size_t i = 0; i &lt; lineItems.size(); ++i) {
 896             FlexItem&amp; flexItem = lineItems[i];
 897             ASSERT(!flexItem.box.isOutOfFlowPositioned());
 898             remainingFreeSpace -= flexItem.flexedMarginBoxSize();
 899         }
 900         // This will std::move lineItems into a newly-created LineContext.
 901         layoutAndPlaceChildren(crossAxisOffset, lineItems, remainingFreeSpace, relayoutChildren, lineContexts);
 902     }
 903 
 904     if (hasLineIfEmpty()) {
 905         // Even if computeNextFlexLine returns true, the flexbox might not have
 906         // a line because all our children might be out of flow positioned.
 907         // Instead of just checking if we have a line, make sure the flexbox
 908         // has at least a line&#39;s worth of height to cover this case.
 909         LayoutUnit minHeight = borderAndPaddingLogicalHeight() + lineHeight(true, isHorizontalWritingMode() ? HorizontalLine : VerticalLine, PositionOfInteriorLineBoxes) + scrollbarLogicalHeight();
 910         if (size().height() &lt; minHeight)
 911             setLogicalHeight(minHeight);
 912     }
 913 
 914     updateLogicalHeight();
 915     repositionLogicalHeightDependentFlexItems(lineContexts);
 916 }
 917 
 918 LayoutUnit RenderFlexibleBox::autoMarginOffsetInMainAxis(const Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; availableFreeSpace)
 919 {
 920     if (availableFreeSpace &lt;= 0_lu)
 921         return 0_lu;
 922 
 923     int numberOfAutoMargins = 0;
 924     bool isHorizontal = isHorizontalFlow();
 925     for (size_t i = 0; i &lt; children.size(); ++i) {
 926         const auto&amp; child = children[i].box;
 927         ASSERT(!child.isOutOfFlowPositioned());
 928         if (isHorizontal) {
 929             if (child.style().marginLeft().isAuto())
 930                 ++numberOfAutoMargins;
 931             if (child.style().marginRight().isAuto())
 932                 ++numberOfAutoMargins;
 933         } else {
 934             if (child.style().marginTop().isAuto())
 935                 ++numberOfAutoMargins;
 936             if (child.style().marginBottom().isAuto())
 937                 ++numberOfAutoMargins;
 938         }
 939     }
 940     if (!numberOfAutoMargins)
 941         return 0_lu;
 942 
 943     LayoutUnit sizeOfAutoMargin = availableFreeSpace / numberOfAutoMargins;
 944     availableFreeSpace = 0_lu;
 945     return sizeOfAutoMargin;
 946 }
 947 
 948 void RenderFlexibleBox::updateAutoMarginsInMainAxis(RenderBox&amp; child, LayoutUnit autoMarginOffset)
 949 {
 950     ASSERT(autoMarginOffset &gt;= 0_lu);
 951 
 952     if (isHorizontalFlow()) {
 953         if (child.style().marginLeft().isAuto())
 954             child.setMarginLeft(autoMarginOffset);
 955         if (child.style().marginRight().isAuto())
 956             child.setMarginRight(autoMarginOffset);
 957     } else {
 958         if (child.style().marginTop().isAuto())
 959             child.setMarginTop(autoMarginOffset);
 960         if (child.style().marginBottom().isAuto())
 961             child.setMarginBottom(autoMarginOffset);
 962     }
 963 }
 964 
 965 bool RenderFlexibleBox::hasAutoMarginsInCrossAxis(const RenderBox&amp; child) const
 966 {
 967     if (isHorizontalFlow())
 968         return child.style().marginTop().isAuto() || child.style().marginBottom().isAuto();
 969     return child.style().marginLeft().isAuto() || child.style().marginRight().isAuto();
 970 }
 971 
 972 LayoutUnit RenderFlexibleBox::availableAlignmentSpaceForChild(LayoutUnit lineCrossAxisExtent, const RenderBox&amp; child)
 973 {
 974     ASSERT(!child.isOutOfFlowPositioned());
 975     LayoutUnit childCrossExtent = crossAxisMarginExtentForChild(child) + crossAxisExtentForChild(child);
 976     return lineCrossAxisExtent - childCrossExtent;
 977 }
 978 
 979 bool RenderFlexibleBox::updateAutoMarginsInCrossAxis(RenderBox&amp; child, LayoutUnit availableAlignmentSpace)
 980 {
 981     ASSERT(!child.isOutOfFlowPositioned());
 982     ASSERT(availableAlignmentSpace &gt;= 0_lu);
 983 
 984     bool isHorizontal = isHorizontalFlow();
 985     Length topOrLeft = isHorizontal ? child.style().marginTop() : child.style().marginLeft();
 986     Length bottomOrRight = isHorizontal ? child.style().marginBottom() : child.style().marginRight();
 987     if (topOrLeft.isAuto() &amp;&amp; bottomOrRight.isAuto()) {
 988         adjustAlignmentForChild(child, availableAlignmentSpace / 2);
 989         if (isHorizontal) {
 990             child.setMarginTop(availableAlignmentSpace / 2);
 991             child.setMarginBottom(availableAlignmentSpace / 2);
 992         } else {
 993             child.setMarginLeft(availableAlignmentSpace / 2);
 994             child.setMarginRight(availableAlignmentSpace / 2);
 995         }
 996         return true;
 997     }
 998     bool shouldAdjustTopOrLeft = true;
 999     if (isColumnFlow() &amp;&amp; !child.style().isLeftToRightDirection()) {
1000         // For column flows, only make this adjustment if topOrLeft corresponds to
1001         // the &quot;before&quot; margin, so that flipForRightToLeftColumn will do the right
1002         // thing.
1003         shouldAdjustTopOrLeft = false;
1004     }
1005     if (!isColumnFlow() &amp;&amp; child.style().isFlippedBlocksWritingMode()) {
1006         // If we are a flipped writing mode, we need to adjust the opposite side.
1007         // This is only needed for row flows because this only affects the
1008         // block-direction axis.
1009         shouldAdjustTopOrLeft = false;
1010     }
1011 
1012     if (topOrLeft.isAuto()) {
1013         if (shouldAdjustTopOrLeft)
1014             adjustAlignmentForChild(child, availableAlignmentSpace);
1015 
1016         if (isHorizontal)
1017             child.setMarginTop(availableAlignmentSpace);
1018         else
1019             child.setMarginLeft(availableAlignmentSpace);
1020         return true;
1021     }
1022 
1023     if (bottomOrRight.isAuto()) {
1024         if (!shouldAdjustTopOrLeft)
1025             adjustAlignmentForChild(child, availableAlignmentSpace);
1026 
1027         if (isHorizontal)
1028             child.setMarginBottom(availableAlignmentSpace);
1029         else
1030             child.setMarginRight(availableAlignmentSpace);
1031         return true;
1032     }
1033     return false;
1034 }
1035 
1036 LayoutUnit RenderFlexibleBox::marginBoxAscentForChild(const RenderBox&amp; child)
1037 {
1038     LayoutUnit ascent = child.firstLineBaseline().valueOr(crossAxisExtentForChild(child));
1039     return ascent + flowAwareMarginBeforeForChild(child);
1040 }
1041 
1042 LayoutUnit RenderFlexibleBox::computeChildMarginValue(Length margin)
1043 {
1044     // When resolving the margins, we use the content size for resolving percent and calc (for percents in calc expressions) margins.
1045     // Fortunately, percent margins are always computed with respect to the block&#39;s width, even for margin-top and margin-bottom.
1046     LayoutUnit availableSize = contentLogicalWidth();
1047     return minimumValueForLength(margin, availableSize);
1048 }
1049 
1050 void RenderFlexibleBox::prepareOrderIteratorAndMargins()
1051 {
1052     OrderIteratorPopulator populator(m_orderIterator);
1053 
1054     for (RenderBox* child = firstChildBox(); child; child = child-&gt;nextSiblingBox()) {
1055         if (!populator.collectChild(*child))
1056             continue;
1057 
1058         // Before running the flex algorithm, &#39;auto&#39; has a margin of 0.
1059         // Also, if we&#39;re not auto sizing, we don&#39;t do a layout that computes the start/end margins.
1060         if (isHorizontalFlow()) {
1061             child-&gt;setMarginLeft(computeChildMarginValue(child-&gt;style().marginLeft()));
1062             child-&gt;setMarginRight(computeChildMarginValue(child-&gt;style().marginRight()));
1063         } else {
1064             child-&gt;setMarginTop(computeChildMarginValue(child-&gt;style().marginTop()));
1065             child-&gt;setMarginBottom(computeChildMarginValue(child-&gt;style().marginBottom()));
1066         }
1067     }
1068 }
1069 
1070 LayoutUnit RenderFlexibleBox::adjustChildSizeForMinAndMax(const RenderBox&amp; child, LayoutUnit childSize)
1071 {
1072     Length max = isHorizontalFlow() ? child.style().maxWidth() : child.style().maxHeight();
1073     Optional&lt;LayoutUnit&gt; maxExtent = WTF::nullopt;
1074     if (max.isSpecifiedOrIntrinsic()) {
1075         maxExtent = computeMainAxisExtentForChild(child, MaxSize, max);
1076         childSize = std::min(childSize, maxExtent.valueOr(childSize));
1077     }
1078 
1079     Length min = isHorizontalFlow() ? child.style().minWidth() : child.style().minHeight();
1080     if (min.isSpecifiedOrIntrinsic())
1081         return std::max(childSize, std::max(0_lu, computeMainAxisExtentForChild(child, MinSize, min).valueOr(childSize)));
1082 
1083     if (!isFlexibleBoxImpl() &amp;&amp; min.isAuto() &amp;&amp; mainAxisOverflowForChild(child) == Overflow::Visible &amp;&amp; !(isColumnFlow() &amp;&amp; is&lt;RenderFlexibleBox&gt;(child))) {
1084         // FIXME: For now, we do not handle min-height: auto for nested
1085         // column flexboxes. We need to implement
1086         // https://drafts.csswg.org/css-flexbox/#intrinsic-sizes before that
1087         // produces reasonable results. Tracking bug: https://crbug.com/581553
1088         // css-flexbox section 4.5
1089         // FIXME: If the min value is expected to be valid here, we need to come up with a non optional version of computeMainAxisExtentForChild and
1090         // ensure it&#39;s valid through the virtual calls of computeIntrinsicLogicalContentHeightUsing.
1091         LayoutUnit contentSize = computeMainAxisExtentForChild(child, MinSize, Length(MinContent)).valueOr(0);
1092         ASSERT(contentSize &gt;= 0);
1093         if (child.hasAspectRatio() &amp;&amp; child.intrinsicSize().height() &gt; 0)
1094             contentSize = adjustChildSizeForAspectRatioCrossAxisMinAndMax(child, contentSize);
1095         contentSize = std::min(contentSize, maxExtent.valueOr(contentSize));
1096 
1097         Length mainSize = isHorizontalFlow() ? child.style().width() : child.style().height();
1098         if (mainAxisLengthIsDefinite(child, mainSize)) {
1099             LayoutUnit resolvedMainSize = computeMainAxisExtentForChild(child, MainOrPreferredSize, mainSize).valueOr(0);
1100             ASSERT(resolvedMainSize &gt;= 0);
1101             LayoutUnit specifiedSize = std::min(resolvedMainSize, maxExtent.valueOr(resolvedMainSize));
1102             return std::max(childSize, std::min(specifiedSize, contentSize));
1103         }
1104 
1105         if (useChildAspectRatio(child)) {
1106             Length crossSizeLength = isHorizontalFlow() ? child.style().height() : child.style().width();
1107             Optional&lt;LayoutUnit&gt; transferredSize = computeMainSizeFromAspectRatioUsing(child, crossSizeLength);
1108             if (transferredSize) {
1109                 transferredSize = adjustChildSizeForAspectRatioCrossAxisMinAndMax(child, transferredSize.value());
1110                 return std::max(childSize, std::min(transferredSize.value(), contentSize));
1111             }
1112         }
1113 
1114         return std::max(childSize, contentSize);
1115     }
1116 
1117     return std::max(0_lu, childSize);
1118 }
1119 
1120 Optional&lt;LayoutUnit&gt; RenderFlexibleBox::crossSizeForPercentageResolution(const RenderBox&amp; child)
1121 {
1122     if (alignmentForChild(child) != ItemPosition::Stretch)
1123         return WTF::nullopt;
1124 
1125     // Here we implement https://drafts.csswg.org/css-flexbox/#algo-stretch
1126     if (hasOrthogonalFlow(child) &amp;&amp; child.hasOverrideContentLogicalWidth())
1127         return child.overrideContentLogicalWidth();
1128     if (!hasOrthogonalFlow(child) &amp;&amp; child.hasOverrideContentLogicalHeight())
1129         return child.overrideContentLogicalHeight();
1130 
1131     // We don&#39;t currently implement the optimization from
1132     // https://drafts.csswg.org/css-flexbox/#definite-sizes case 1. While that
1133     // could speed up a specialized case, it requires determining if we have a
1134     // definite size, which itself is not cheap. We can consider implementing it
1135     // at a later time. (The correctness is ensured by redoing layout in
1136     // applyStretchAlignmentToChild)
1137     return WTF::nullopt;
1138 }
1139 
1140 Optional&lt;LayoutUnit&gt; RenderFlexibleBox::mainSizeForPercentageResolution(const RenderBox&amp; child)
1141 {
1142     // This function implements section 9.8. Definite and Indefinite Sizes, case
1143     // 2) of the flexbox spec.
1144     // We need to check for the flexbox to have a definite main size, and for the
1145     // flex item to have a definite flex basis.
1146     const Length&amp; flexBasis = flexBasisForChild(child);
1147     if (!mainAxisLengthIsDefinite(child, flexBasis))
1148         return WTF::nullopt;
1149     if (!flexBasis.isPercentOrCalculated()) {
1150         // If flex basis had a percentage, our size is guaranteed to be definite or
1151         // the flex item&#39;s size could not be definite. Otherwise, we make up a
1152         // percentage to check whether we have a definite size.
1153         if (!mainAxisLengthIsDefinite(child, Length(0, Percent)))
1154             return WTF::nullopt;
1155     }
1156 
1157     if (hasOrthogonalFlow(child))
1158         return child.hasOverrideContentLogicalHeight() ? Optional&lt;LayoutUnit&gt;(child.overrideContentLogicalHeight()) : WTF::nullopt;
1159     return child.hasOverrideContentLogicalWidth() ? Optional&lt;LayoutUnit&gt;(child.overrideContentLogicalWidth()) : WTF::nullopt;
1160 }
1161 
1162 Optional&lt;LayoutUnit&gt; RenderFlexibleBox::childLogicalHeightForPercentageResolution(const RenderBox&amp; child)
1163 {
1164     if (!hasOrthogonalFlow(child))
1165         return crossSizeForPercentageResolution(child);
1166     return mainSizeForPercentageResolution(child);
1167 }
1168 
1169 LayoutUnit RenderFlexibleBox::adjustChildSizeForAspectRatioCrossAxisMinAndMax(const RenderBox&amp; child, LayoutUnit childSize)
1170 {
1171     Length crossMin = isHorizontalFlow() ? child.style().minHeight() : child.style().minWidth();
1172     Length crossMax = isHorizontalFlow() ? child.style().maxHeight() : child.style().maxWidth();
1173 
1174     if (crossAxisLengthIsDefinite(child, crossMax)) {
1175         LayoutUnit maxValue = computeMainSizeFromAspectRatioUsing(child, crossMax);
1176         childSize = std::min(maxValue, childSize);
1177     }
1178 
1179     if (crossAxisLengthIsDefinite(child, crossMin)) {
1180         LayoutUnit minValue = computeMainSizeFromAspectRatioUsing(child, crossMin);
1181         childSize = std::max(minValue, childSize);
1182     }
1183 
1184     return childSize;
1185 }
1186 
1187 FlexItem RenderFlexibleBox::constructFlexItem(RenderBox&amp; child, bool relayoutChildren)
1188 {
1189     // If this condition is true, then computeMainAxisExtentForChild will call
1190     // child.intrinsicContentLogicalHeight() and
1191     // child.scrollbarLogicalHeight(), so if the child has intrinsic
1192     // min/max/preferred size, run layout on it now to make sure its logical
1193     // height and scroll bars are up to date.
1194     if (childHasIntrinsicMainAxisSize(child) &amp;&amp; child.needsLayout()) {
1195         child.clearOverrideContentSize();
1196         child.setChildNeedsLayout(MarkOnlyThis);
1197         child.layoutIfNeeded();
1198         cacheChildMainSize(child);
1199         relayoutChildren = false;
1200     }
1201 
1202     LayoutUnit borderAndPadding = isHorizontalFlow() ? child.horizontalBorderAndPaddingExtent() : child.verticalBorderAndPaddingExtent();
1203     LayoutUnit childInnerFlexBaseSize = computeInnerFlexBaseSizeForChild(child, borderAndPadding, relayoutChildren);
1204     LayoutUnit childMinMaxAppliedMainAxisExtent = adjustChildSizeForMinAndMax(child, childInnerFlexBaseSize);
1205     LayoutUnit margin = isHorizontalFlow() ? child.horizontalMarginExtent() : child.verticalMarginExtent();
1206     return FlexItem(child, childInnerFlexBaseSize, childMinMaxAppliedMainAxisExtent, borderAndPadding, margin);
1207 }
1208 
1209 void RenderFlexibleBox::freezeViolations(Vector&lt;FlexItem*&gt;&amp; violations, LayoutUnit&amp; availableFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink)
1210 {
1211     for (size_t i = 0; i &lt; violations.size(); ++i) {
1212         ASSERT(!violations[i]-&gt;frozen);
1213         const auto&amp; child = violations[i]-&gt;box;
1214         LayoutUnit childSize = violations[i]-&gt;flexedContentSize;
1215         availableFreeSpace -= childSize - violations[i]-&gt;flexBaseContentSize;
1216         totalFlexGrow -= child.style().flexGrow();
1217         totalFlexShrink -= child.style().flexShrink();
1218         totalWeightedFlexShrink -= child.style().flexShrink() * violations[i]-&gt;flexBaseContentSize;
1219         // totalWeightedFlexShrink can be negative when we exceed the precision of
1220         // a double when we initially calcuate totalWeightedFlexShrink. We then
1221         // subtract each child&#39;s weighted flex shrink with full precision, now
1222         // leading to a negative result. See
1223         // css3/flexbox/large-flex-shrink-assert.html
1224         totalWeightedFlexShrink = std::max(totalWeightedFlexShrink, 0.0);
1225         violations[i]-&gt;frozen = true;
1226     }
1227 }
1228 
1229 void RenderFlexibleBox::freezeInflexibleItems(FlexSign flexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink)
1230 {
1231     // Per https://drafts.csswg.org/css-flexbox/#resolve-flexible-lengths step 2,
1232     // we freeze all items with a flex factor of 0 as well as those with a min/max
1233     // size violation.
1234     Vector&lt;FlexItem*&gt; newInflexibleItems;
1235     for (size_t i = 0; i &lt; children.size(); ++i) {
1236         FlexItem&amp; flexItem = children[i];
1237         const auto&amp; child = flexItem.box;
1238         ASSERT(!flexItem.box.isOutOfFlowPositioned());
1239         ASSERT(!flexItem.frozen);
1240         float flexFactor = (flexSign == PositiveFlexibility) ? child.style().flexGrow() : child.style().flexShrink();
1241         if (!flexFactor || (flexSign == PositiveFlexibility &amp;&amp; flexItem.flexBaseContentSize &gt; flexItem.hypotheticalMainContentSize) || (flexSign == NegativeFlexibility &amp;&amp; flexItem.flexBaseContentSize &lt; flexItem.hypotheticalMainContentSize)) {
1242             flexItem.flexedContentSize = flexItem.hypotheticalMainContentSize;
1243             newInflexibleItems.append(&amp;flexItem);
1244         }
1245     }
1246     freezeViolations(newInflexibleItems, remainingFreeSpace, totalFlexGrow, totalFlexShrink, totalWeightedFlexShrink);
1247 }
1248 
1249 // Returns true if we successfully ran the algorithm and sized the flex items.
1250 bool RenderFlexibleBox::resolveFlexibleLengths(FlexSign flexSign, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit initialFreeSpace, LayoutUnit&amp; remainingFreeSpace, double&amp; totalFlexGrow, double&amp; totalFlexShrink, double&amp; totalWeightedFlexShrink)
1251 {
1252     LayoutUnit totalViolation;
1253     LayoutUnit usedFreeSpace;
1254     Vector&lt;FlexItem*&gt; minViolations;
1255     Vector&lt;FlexItem*&gt; maxViolations;
1256 
1257     double sumFlexFactors = (flexSign == PositiveFlexibility) ? totalFlexGrow : totalFlexShrink;
1258     if (sumFlexFactors &gt; 0 &amp;&amp; sumFlexFactors &lt; 1) {
1259         LayoutUnit fractional(initialFreeSpace * sumFlexFactors);
1260         if (fractional.abs() &lt; remainingFreeSpace.abs())
1261             remainingFreeSpace = fractional;
1262     }
1263 
1264     for (size_t i = 0; i &lt; children.size(); ++i) {
1265         FlexItem&amp; flexItem = children[i];
1266         const auto&amp; child = flexItem.box;
1267 
1268         // This check also covers out-of-flow children.
1269         if (flexItem.frozen)
1270             continue;
1271 
1272         LayoutUnit childSize = flexItem.flexBaseContentSize;
1273         double extraSpace = 0;
1274         if (remainingFreeSpace &gt; 0 &amp;&amp; totalFlexGrow &gt; 0 &amp;&amp; flexSign == PositiveFlexibility &amp;&amp; std::isfinite(totalFlexGrow))
1275             extraSpace = remainingFreeSpace * child.style().flexGrow() / totalFlexGrow;
1276         else if (remainingFreeSpace &lt; 0 &amp;&amp; totalWeightedFlexShrink &gt; 0 &amp;&amp; flexSign == NegativeFlexibility &amp;&amp; std::isfinite(totalWeightedFlexShrink) &amp;&amp; child.style().flexShrink())
1277             extraSpace = remainingFreeSpace * child.style().flexShrink() * flexItem.flexBaseContentSize / totalWeightedFlexShrink;
1278         if (std::isfinite(extraSpace))
1279             childSize += LayoutUnit::fromFloatRound(extraSpace);
1280 
1281         LayoutUnit adjustedChildSize = adjustChildSizeForMinAndMax(child, childSize);
1282         ASSERT(adjustedChildSize &gt;= 0);
1283         flexItem.flexedContentSize = adjustedChildSize;
1284         usedFreeSpace += adjustedChildSize - flexItem.flexBaseContentSize;
1285 
1286         LayoutUnit violation = adjustedChildSize - childSize;
1287         if (violation &gt; 0)
1288             minViolations.append(&amp;flexItem);
1289         else if (violation &lt; 0)
1290             maxViolations.append(&amp;flexItem);
1291         totalViolation += violation;
1292     }
1293 
1294     if (totalViolation)
1295         freezeViolations(totalViolation &lt; 0 ? maxViolations : minViolations, remainingFreeSpace, totalFlexGrow, totalFlexShrink, totalWeightedFlexShrink);
1296     else
1297         remainingFreeSpace -= usedFreeSpace;
1298 
1299     return !totalViolation;
1300 }
1301 
1302 static LayoutUnit initialJustifyContentOffset(LayoutUnit availableFreeSpace, ContentPosition justifyContent, ContentDistribution justifyContentDistribution, unsigned numberOfChildren)
1303 {
1304     if (justifyContent == ContentPosition::FlexEnd)
1305         return availableFreeSpace;
1306     if (justifyContent == ContentPosition::Center)
1307         return availableFreeSpace / 2;
1308     if (justifyContentDistribution == ContentDistribution::SpaceAround) {
1309         if (availableFreeSpace &gt; 0 &amp;&amp; numberOfChildren)
1310             return availableFreeSpace / (2 * numberOfChildren);
1311         else
1312             return availableFreeSpace / 2;
1313     }
1314     if (justifyContentDistribution == ContentDistribution::SpaceEvenly) {
1315         if (availableFreeSpace &gt; 0 &amp;&amp; numberOfChildren)
1316             return availableFreeSpace / (numberOfChildren + 1);
1317         // Fallback to &#39;center&#39;
1318         return availableFreeSpace / 2;
1319     }
1320     return 0;
1321 }
1322 
1323 static LayoutUnit justifyContentSpaceBetweenChildren(LayoutUnit availableFreeSpace, ContentDistribution justifyContentDistribution, unsigned numberOfChildren)
1324 {
1325     if (availableFreeSpace &gt; 0 &amp;&amp; numberOfChildren &gt; 1) {
1326         if (justifyContentDistribution == ContentDistribution::SpaceBetween)
1327             return availableFreeSpace / (numberOfChildren - 1);
1328         if (justifyContentDistribution == ContentDistribution::SpaceAround)
1329             return availableFreeSpace / numberOfChildren;
1330         if (justifyContentDistribution == ContentDistribution::SpaceEvenly)
1331             return availableFreeSpace / (numberOfChildren + 1);
1332     }
1333     return 0;
1334 }
1335 
1336 
1337 static LayoutUnit alignmentOffset(LayoutUnit availableFreeSpace, ItemPosition position, LayoutUnit ascent, LayoutUnit maxAscent, bool isWrapReverse)
1338 {
1339     switch (position) {
1340     case ItemPosition::Legacy:
1341     case ItemPosition::Auto:
1342     case ItemPosition::Normal:
1343         ASSERT_NOT_REACHED();
1344         break;
1345     case ItemPosition::Stretch:
1346         // Actual stretching must be handled by the caller. Since wrap-reverse
1347         // flips cross start and cross end, stretch children should be aligned
1348         // with the cross end. This matters because applyStretchAlignment
1349         // doesn&#39;t always stretch or stretch fully (explicit cross size given, or
1350         // stretching constrained by max-height/max-width). For flex-start and
1351         // flex-end this is handled by alignmentForChild().
1352         if (isWrapReverse)
1353             return availableFreeSpace;
1354         break;
1355     case ItemPosition::FlexStart:
1356         break;
1357     case ItemPosition::FlexEnd:
1358         return availableFreeSpace;
1359     case ItemPosition::Center:
1360         return availableFreeSpace / 2;
1361     case ItemPosition::Baseline:
1362         // FIXME: If we get here in columns, we want the use the descent, except
1363         // we currently can&#39;t get the ascent/descent of orthogonal children.
1364         // https://bugs.webkit.org/show_bug.cgi?id=98076
1365         return maxAscent - ascent;
1366     case ItemPosition::LastBaseline:
1367     case ItemPosition::SelfStart:
1368     case ItemPosition::SelfEnd:
1369     case ItemPosition::Start:
1370     case ItemPosition::End:
1371     case ItemPosition::Left:
1372     case ItemPosition::Right:
1373         // FIXME: Implement the extended grammar, enabled when the Grid Layout
1374         // feature was enabled by default.
1375         break;
1376     }
1377     return 0;
1378 }
1379 
1380 void RenderFlexibleBox::setOverrideMainAxisContentSizeForChild(RenderBox&amp; child, LayoutUnit childPreferredSize)
1381 {
1382     if (hasOrthogonalFlow(child))
1383         child.setOverrideContentLogicalHeight(childPreferredSize);
1384     else
1385         child.setOverrideContentLogicalWidth(childPreferredSize);
1386 }
1387 
1388 LayoutUnit RenderFlexibleBox::staticMainAxisPositionForPositionedChild(const RenderBox&amp; child)
1389 {
1390     const LayoutUnit availableSpace = mainAxisContentExtent(contentLogicalHeight()) - mainAxisExtentForChild(child);
1391 
1392     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehavior());
1393     ContentDistribution distribution = style().resolvedJustifyContentDistribution(contentAlignmentNormalBehavior());
1394     LayoutUnit offset = initialJustifyContentOffset(availableSpace, position, distribution, 1);
1395     if (style().flexDirection() == FlexDirection::RowReverse || style().flexDirection() == FlexDirection::ColumnReverse)
1396         offset = availableSpace - offset;
1397     return offset;
1398 }
1399 
1400 LayoutUnit RenderFlexibleBox::staticCrossAxisPositionForPositionedChild(const RenderBox&amp; child)
1401 {
1402     LayoutUnit availableSpace = crossAxisContentExtent() - crossAxisExtentForChild(child);
1403     return alignmentOffset(availableSpace, alignmentForChild(child), 0_lu, 0_lu, style().flexWrap() == FlexWrap::Reverse);
1404 }
1405 
1406 LayoutUnit RenderFlexibleBox::staticInlinePositionForPositionedChild(const RenderBox&amp; child)
1407 {
1408     return startOffsetForContent() + (isColumnFlow() ? staticCrossAxisPositionForPositionedChild(child) : staticMainAxisPositionForPositionedChild(child));
1409 }
1410 
1411 LayoutUnit RenderFlexibleBox::staticBlockPositionForPositionedChild(const RenderBox&amp; child)
1412 {
1413     return borderAndPaddingBefore() + (isColumnFlow() ? staticMainAxisPositionForPositionedChild(child) : staticCrossAxisPositionForPositionedChild(child));
1414 }
1415 
1416 bool RenderFlexibleBox::setStaticPositionForPositionedLayout(const RenderBox&amp; child)
1417 {
1418     bool positionChanged = false;
1419     auto* childLayer = child.layer();
1420     if (child.style().hasStaticInlinePosition(style().isHorizontalWritingMode())) {
1421         LayoutUnit inlinePosition = staticInlinePositionForPositionedChild(child);
1422         if (childLayer-&gt;staticInlinePosition() != inlinePosition) {
1423             childLayer-&gt;setStaticInlinePosition(inlinePosition);
1424             positionChanged = true;
1425         }
1426     }
1427     if (child.style().hasStaticBlockPosition(style().isHorizontalWritingMode())) {
1428         LayoutUnit blockPosition = staticBlockPositionForPositionedChild(child);
1429         if (childLayer-&gt;staticBlockPosition() != blockPosition) {
1430             childLayer-&gt;setStaticBlockPosition(blockPosition);
1431             positionChanged = true;
1432         }
1433     }
1434     return positionChanged;
1435 }
1436 
1437 void RenderFlexibleBox::prepareChildForPositionedLayout(RenderBox&amp; child)
1438 {
1439     ASSERT(child.isOutOfFlowPositioned());
1440     child.containingBlock()-&gt;insertPositionedObject(child);
1441     auto* childLayer = child.layer();
1442     LayoutUnit staticInlinePosition = flowAwareBorderStart() + flowAwarePaddingStart();
1443     if (childLayer-&gt;staticInlinePosition() != staticInlinePosition) {
1444         childLayer-&gt;setStaticInlinePosition(staticInlinePosition);
1445         if (child.style().hasStaticInlinePosition(style().isHorizontalWritingMode()))
1446             child.setChildNeedsLayout(MarkOnlyThis);
1447     }
1448 
1449     LayoutUnit staticBlockPosition = flowAwareBorderBefore() + flowAwarePaddingBefore();
1450     if (childLayer-&gt;staticBlockPosition() != staticBlockPosition) {
1451         childLayer-&gt;setStaticBlockPosition(staticBlockPosition);
1452         if (child.style().hasStaticBlockPosition(style().isHorizontalWritingMode()))
1453             child.setChildNeedsLayout(MarkOnlyThis);
1454     }
1455 }
1456 
1457 ItemPosition RenderFlexibleBox::alignmentForChild(const RenderBox&amp; child) const
1458 {
1459     ItemPosition align = child.style().resolvedAlignSelf(&amp;style(), selfAlignmentNormalBehavior()).position();
1460     ASSERT(align != ItemPosition::Auto &amp;&amp; align != ItemPosition::Normal);
1461 
1462     if (align == ItemPosition::Baseline &amp;&amp; hasOrthogonalFlow(child))
1463         align = ItemPosition::FlexStart;
1464 
1465     if (style().flexWrap() == FlexWrap::Reverse) {
1466         if (align == ItemPosition::FlexStart)
1467             align = ItemPosition::FlexEnd;
1468         else if (align == ItemPosition::FlexEnd)
1469             align = ItemPosition::FlexStart;
1470     }
1471 
1472     return align;
1473 }
1474 
1475 void RenderFlexibleBox::resetAutoMarginsAndLogicalTopInCrossAxis(RenderBox&amp; child)
1476 {
1477     if (hasAutoMarginsInCrossAxis(child)) {
1478         child.updateLogicalHeight();
1479         if (isHorizontalFlow()) {
1480             if (child.style().marginTop().isAuto())
1481                 child.setMarginTop(0_lu);
1482             if (child.style().marginBottom().isAuto())
1483                 child.setMarginBottom(0_lu);
1484         } else {
1485             if (child.style().marginLeft().isAuto())
1486                 child.setMarginLeft(0_lu);
1487             if (child.style().marginRight().isAuto())
1488                 child.setMarginRight(0_lu);
1489         }
1490     }
1491 }
1492 
1493 bool RenderFlexibleBox::needToStretchChildLogicalHeight(const RenderBox&amp; child) const
1494 {
1495     // This function is a little bit magical. It relies on the fact that blocks
1496     // intrinsically &quot;stretch&quot; themselves in their inline axis, i.e. a &lt;div&gt; has
1497     // an implicit width: 100%. So the child will automatically stretch if our
1498     // cross axis is the child&#39;s inline axis. That&#39;s the case if:
1499     // - We are horizontal and the child is in vertical writing mode
1500     // - We are vertical and the child is in horizontal writing mode
1501     // Otherwise, we need to stretch if the cross axis size is auto.
1502     if (alignmentForChild(child) != ItemPosition::Stretch)
1503         return false;
1504 
1505     if (isHorizontalFlow() != child.style().isHorizontalWritingMode())
1506         return false;
1507 
1508     return child.style().logicalHeight().isAuto();
1509 }
1510 
1511 bool RenderFlexibleBox::childHasIntrinsicMainAxisSize(const RenderBox&amp; child) const
1512 {
1513     bool result = false;
1514     if (isHorizontalFlow() != child.style().isHorizontalWritingMode()) {
1515         Length childFlexBasis = flexBasisForChild(child);
1516         Length childMinSize = isHorizontalFlow() ? child.style().minWidth() : child.style().minHeight();
1517         Length childMaxSize = isHorizontalFlow() ? child.style().maxWidth() : child.style().maxHeight();
1518         if (childFlexBasis.isIntrinsic() || childMinSize.isIntrinsicOrAuto() || childMaxSize.isIntrinsic())
1519             result = true;
1520     }
1521     return result;
1522 }
1523 
1524 Overflow RenderFlexibleBox::mainAxisOverflowForChild(const RenderBox&amp; child) const
1525 {
1526     if (isHorizontalFlow())
1527         return child.style().overflowX();
1528     return child.style().overflowY();
1529 }
1530 
1531 Overflow RenderFlexibleBox::crossAxisOverflowForChild(const RenderBox&amp; child) const
1532 {
1533     if (isHorizontalFlow())
1534         return child.style().overflowY();
1535     return child.style().overflowX();
1536 }
1537 
1538 bool RenderFlexibleBox::hasPercentHeightDescendants(const RenderBox&amp; renderer) const
1539 {
1540     // FIXME: This function can be removed soon after webkit.org/b/204318 is fixed.
1541     if (!is&lt;RenderBlock&gt;(renderer))
1542         return false;
1543     auto&amp; renderBlock = downcast&lt;RenderBlock&gt;(renderer);
1544     if (!renderBlock.hasPercentHeightDescendants())
1545         return false;
1546 
1547     auto* percentHeightDescendants = renderBlock.percentHeightDescendants();
1548     if (!percentHeightDescendants)
1549         return false;
1550 
1551     for (auto it = percentHeightDescendants-&gt;begin(), end = percentHeightDescendants-&gt;end(); it != end; ++it) {
1552         bool hasOutOfFlowAncestor = false;
1553         for (auto* ancestor = (*it)-&gt;containingBlock(); ancestor &amp;&amp; ancestor != &amp;renderBlock; ancestor = ancestor-&gt;containingBlock()) {
1554             if (ancestor-&gt;isOutOfFlowPositioned()) {
1555                 hasOutOfFlowAncestor = true;
1556                 break;
1557             }
1558         }
1559         if (!hasOutOfFlowAncestor)
1560             return true;
1561     }
1562     return false;
1563 }
1564 
1565 void RenderFlexibleBox::layoutAndPlaceChildren(LayoutUnit&amp; crossAxisOffset, Vector&lt;FlexItem&gt;&amp; children, LayoutUnit availableFreeSpace, bool relayoutChildren, Vector&lt;LineContext&gt;&amp; lineContexts)
1566 {
1567     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehavior());
1568     ContentDistribution distribution = style().resolvedJustifyContentDistribution(contentAlignmentNormalBehavior());
1569 
1570     LayoutUnit autoMarginOffset = autoMarginOffsetInMainAxis(children, availableFreeSpace);
1571     LayoutUnit mainAxisOffset = flowAwareBorderStart() + flowAwarePaddingStart();
1572     mainAxisOffset += initialJustifyContentOffset(availableFreeSpace, position, distribution, children.size());
1573     if (style().flexDirection() == FlexDirection::RowReverse)
1574         mainAxisOffset += isHorizontalFlow() ? verticalScrollbarWidth() : horizontalScrollbarHeight();
1575 
1576     LayoutUnit totalMainExtent = mainAxisExtent();
1577     LayoutUnit maxAscent, maxDescent; // Used when align-items: baseline.
1578     LayoutUnit maxChildCrossAxisExtent;
1579     bool shouldFlipMainAxis = !isColumnFlow() &amp;&amp; !isLeftToRightFlow();
1580     for (size_t i = 0; i &lt; children.size(); ++i) {
1581         const auto&amp; flexItem = children[i];
1582         auto&amp; child = flexItem.box;
1583         bool childHadLayout = child.everHadLayout();
1584 
1585         ASSERT(!flexItem.box.isOutOfFlowPositioned());
1586 
1587         setOverrideMainAxisContentSizeForChild(child, flexItem.flexedContentSize);
1588         // The flexed content size and the override size include the scrollbar
1589         // width, so we need to compare to the size including the scrollbar.
1590         // TODO(cbiesinger): Should it include the scrollbar?
1591         if (flexItem.flexedContentSize != mainAxisContentExtentForChildIncludingScrollbar(child))
1592             child.setChildNeedsLayout(MarkOnlyThis);
1593         else {
1594             // To avoid double applying margin changes in
1595             // updateAutoMarginsInCrossAxis, we reset the margins here.
1596             resetAutoMarginsAndLogicalTopInCrossAxis(child);
1597         }
1598         // We may have already forced relayout for orthogonal flowing children in
1599         // computeInnerFlexBaseSizeForChild.
1600         bool forceChildRelayout = relayoutChildren &amp;&amp; !m_relaidOutChildren.contains(&amp;child);
1601         if (!forceChildRelayout &amp;&amp; hasPercentHeightDescendants(child)) {
1602             // Have to force another relayout even though the child is sized
1603             // correctly, because its descendants are not sized correctly yet. Our
1604             // previous layout of the child was done without an override height set.
1605             // So, redo it here.
1606             forceChildRelayout = true;
1607         }
1608         updateBlockChildDirtyBitsBeforeLayout(forceChildRelayout, child);
1609         if (!child.needsLayout())
1610             child.markForPaginationRelayoutIfNeeded();
1611         if (child.needsLayout())
1612             m_relaidOutChildren.add(&amp;child);
1613         child.layoutIfNeeded();
1614         if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) {
1615             child.repaint();
1616             child.repaintOverhangingFloats(true);
1617         }
1618 
1619         updateAutoMarginsInMainAxis(child, autoMarginOffset);
1620 
1621         LayoutUnit childCrossAxisMarginBoxExtent;
1622         if (alignmentForChild(child) == ItemPosition::Baseline &amp;&amp; !hasAutoMarginsInCrossAxis(child)) {
1623             LayoutUnit ascent = marginBoxAscentForChild(child);
1624             LayoutUnit descent = (crossAxisMarginExtentForChild(child) + crossAxisExtentForChild(child)) - ascent;
1625 
1626             maxAscent = std::max(maxAscent, ascent);
1627             maxDescent = std::max(maxDescent, descent);
1628 
1629             // FIXME: Take scrollbar into account
1630             childCrossAxisMarginBoxExtent = maxAscent + maxDescent;
1631         } else
1632             childCrossAxisMarginBoxExtent = crossAxisIntrinsicExtentForChild(child) + crossAxisMarginExtentForChild(child);
1633 
1634         if (!isColumnFlow())
1635             setLogicalHeight(std::max(logicalHeight(), crossAxisOffset + flowAwareBorderAfter() + flowAwarePaddingAfter() + childCrossAxisMarginBoxExtent + crossAxisScrollbarExtent()));
1636         maxChildCrossAxisExtent = std::max(maxChildCrossAxisExtent, childCrossAxisMarginBoxExtent);
1637 
1638         mainAxisOffset += flowAwareMarginStartForChild(child);
1639 
1640         LayoutUnit childMainExtent = mainAxisExtentForChild(child);
1641         // In an RTL column situation, this will apply the margin-right/margin-end
1642         // on the left. This will be fixed later in flipForRightToLeftColumn.
1643         LayoutPoint childLocation(shouldFlipMainAxis ? totalMainExtent - mainAxisOffset - childMainExtent : mainAxisOffset, crossAxisOffset + flowAwareMarginBeforeForChild(child));
1644         setFlowAwareLocationForChild(child, childLocation);
1645         mainAxisOffset += childMainExtent + flowAwareMarginEndForChild(child);
1646 
1647         if (i != children.size() - 1) {
1648             // The last item does not get extra space added.
1649             mainAxisOffset += justifyContentSpaceBetweenChildren(availableFreeSpace, distribution, children.size());
1650         }
1651 
1652         // FIXME: Deal with pagination.
1653     }
1654 
1655     if (isColumnFlow())
1656         setLogicalHeight(std::max(logicalHeight(), mainAxisOffset + flowAwareBorderEnd() + flowAwarePaddingEnd() + scrollbarLogicalHeight()));
1657 
1658     if (style().flexDirection() == FlexDirection::ColumnReverse) {
1659         // We have to do an extra pass for column-reverse to reposition the flex
1660         // items since the start depends on the height of the flexbox, which we
1661         // only know after we&#39;ve positioned all the flex items.
1662         updateLogicalHeight();
1663         layoutColumnReverse(children, crossAxisOffset, availableFreeSpace);
1664     }
1665 
1666     if (m_numberOfInFlowChildrenOnFirstLine == -1)
1667         m_numberOfInFlowChildrenOnFirstLine = children.size();
1668     lineContexts.append(LineContext(crossAxisOffset, maxChildCrossAxisExtent, maxAscent, WTFMove(children)));
1669     crossAxisOffset += maxChildCrossAxisExtent;
1670 }
1671 
1672 void RenderFlexibleBox::layoutColumnReverse(const Vector&lt;FlexItem&gt;&amp; children, LayoutUnit crossAxisOffset, LayoutUnit availableFreeSpace)
1673 {
1674     ContentPosition position = style().resolvedJustifyContentPosition(contentAlignmentNormalBehavior());
1675     ContentDistribution distribution = style().resolvedJustifyContentDistribution(contentAlignmentNormalBehavior());
1676 
1677     // This is similar to the logic in layoutAndPlaceChildren, except we place
1678     // the children starting from the end of the flexbox. We also don&#39;t need to
1679     // layout anything since we&#39;re just moving the children to a new position.
1680     LayoutUnit mainAxisOffset = logicalHeight() - flowAwareBorderEnd() - flowAwarePaddingEnd();
1681     mainAxisOffset -= initialJustifyContentOffset(availableFreeSpace, position, distribution, children.size());
1682     mainAxisOffset -= isHorizontalFlow() ? verticalScrollbarWidth() : horizontalScrollbarHeight();
1683 
1684     for (size_t i = 0; i &lt; children.size(); ++i) {
1685         auto&amp; child = children[i].box;
1686         ASSERT(!child.isOutOfFlowPositioned());
1687         mainAxisOffset -= mainAxisExtentForChild(child) + flowAwareMarginEndForChild(child);
1688         setFlowAwareLocationForChild(child, LayoutPoint(mainAxisOffset, crossAxisOffset + flowAwareMarginBeforeForChild(child)));
1689         mainAxisOffset -= flowAwareMarginStartForChild(child);
1690         mainAxisOffset -= justifyContentSpaceBetweenChildren(availableFreeSpace, distribution, children.size());
1691     }
1692 }
1693 
1694 static LayoutUnit initialAlignContentOffset(LayoutUnit availableFreeSpace, ContentPosition alignContent, ContentDistribution alignContentDistribution, unsigned numberOfLines)
1695 {
1696     if (numberOfLines &lt;= 1)
1697         return 0_lu;
1698     if (alignContent == ContentPosition::FlexEnd)
1699         return availableFreeSpace;
1700     if (alignContent == ContentPosition::Center)
1701         return availableFreeSpace / 2;
1702     if (alignContentDistribution == ContentDistribution::SpaceAround) {
1703         if (availableFreeSpace &gt; 0 &amp;&amp; numberOfLines)
1704             return availableFreeSpace / (2 * numberOfLines);
1705         if (availableFreeSpace &lt; 0)
1706             return availableFreeSpace / 2;
1707     }
1708     if (alignContentDistribution == ContentDistribution::SpaceEvenly) {
1709         if (availableFreeSpace &gt; 0)
1710             return availableFreeSpace / (numberOfLines + 1);
1711         // Fallback to &#39;center&#39;
1712         return availableFreeSpace / 2;
1713     }
1714     return 0_lu;
1715 }
1716 
1717 static LayoutUnit alignContentSpaceBetweenChildren(LayoutUnit availableFreeSpace, ContentDistribution alignContentDistribution, unsigned numberOfLines)
1718 {
1719     if (availableFreeSpace &gt; 0 &amp;&amp; numberOfLines &gt; 1) {
1720         if (alignContentDistribution == ContentDistribution::SpaceBetween)
1721             return availableFreeSpace / (numberOfLines - 1);
1722         if (alignContentDistribution == ContentDistribution::SpaceAround || alignContentDistribution == ContentDistribution::Stretch)
1723             return availableFreeSpace / numberOfLines;
1724         if (alignContentDistribution == ContentDistribution::SpaceEvenly)
1725             return availableFreeSpace / (numberOfLines + 1);
1726     }
1727     return 0_lu;
1728 }
1729 
1730 void RenderFlexibleBox::alignFlexLines(Vector&lt;LineContext&gt;&amp; lineContexts)
1731 {
1732     ContentPosition position = style().resolvedAlignContentPosition(contentAlignmentNormalBehavior());
1733     ContentDistribution distribution = style().resolvedAlignContentDistribution(contentAlignmentNormalBehavior());
1734 
1735     // If we have a single line flexbox or a multiline line flexbox with only one
1736     // flex line, the line height is all the available space. For
1737     // flex-direction: row, this means we need to use the height, so we do this
1738     // after calling updateLogicalHeight.
1739     if (lineContexts.size() == 1) {
1740         lineContexts[0].crossAxisExtent = crossAxisContentExtent();
1741         return;
1742     }
1743 
1744     if (position == ContentPosition::FlexStart)
1745         return;
1746 
1747     LayoutUnit availableCrossAxisSpace = crossAxisContentExtent();
1748     for (size_t i = 0; i &lt; lineContexts.size(); ++i)
1749         availableCrossAxisSpace -= lineContexts[i].crossAxisExtent;
1750 
1751     LayoutUnit lineOffset = initialAlignContentOffset(availableCrossAxisSpace, position, distribution, lineContexts.size());
1752     for (unsigned lineNumber = 0; lineNumber &lt; lineContexts.size(); ++lineNumber) {
1753         LineContext&amp; lineContext = lineContexts[lineNumber];
1754         lineContext.crossAxisOffset += lineOffset;
1755         for (size_t childNumber = 0; childNumber &lt; lineContext.flexItems.size(); ++childNumber) {
1756             FlexItem&amp; flexItem = lineContext.flexItems[childNumber];
1757             adjustAlignmentForChild(flexItem.box, lineOffset);
1758         }
1759 
1760         if (distribution == ContentDistribution::Stretch &amp;&amp; availableCrossAxisSpace &gt; 0)
1761             lineContexts[lineNumber].crossAxisExtent += availableCrossAxisSpace / static_cast&lt;unsigned&gt;(lineContexts.size());
1762 
1763         lineOffset += alignContentSpaceBetweenChildren(availableCrossAxisSpace, distribution, lineContexts.size());
1764     }
1765 }
1766 
1767 void RenderFlexibleBox::adjustAlignmentForChild(RenderBox&amp; child, LayoutUnit delta)
1768 {
1769     ASSERT(!child.isOutOfFlowPositioned());
1770     setFlowAwareLocationForChild(child, flowAwareLocationForChild(child) + LayoutSize(0_lu, delta));
1771 }
1772 
1773 void RenderFlexibleBox::alignChildren(const Vector&lt;LineContext&gt;&amp; lineContexts)
1774 {
1775     // Keep track of the space between the baseline edge and the after edge of
1776     // the box for each line.
1777     Vector&lt;LayoutUnit&gt; minMarginAfterBaselines;
1778 
1779     for (size_t lineNumber = 0; lineNumber &lt; lineContexts.size(); ++lineNumber) {
1780         const LineContext&amp; lineContext = lineContexts[lineNumber];
1781 
1782         LayoutUnit minMarginAfterBaseline = LayoutUnit::max();
1783         LayoutUnit lineCrossAxisExtent = lineContext.crossAxisExtent;
1784         LayoutUnit maxAscent = lineContext.maxAscent;
1785 
1786         for (size_t childNumber = 0; childNumber &lt; lineContext.flexItems.size(); ++childNumber) {
1787             const auto&amp; flexItem = lineContext.flexItems[childNumber];
1788             ASSERT(!flexItem.box.isOutOfFlowPositioned());
1789 
1790             if (updateAutoMarginsInCrossAxis(flexItem.box, std::max(0_lu, availableAlignmentSpaceForChild(lineCrossAxisExtent, flexItem.box))))
1791                 continue;
1792 
1793             ItemPosition position = alignmentForChild(flexItem.box);
1794             if (position == ItemPosition::Stretch)
1795                 applyStretchAlignmentToChild(flexItem.box, lineCrossAxisExtent);
1796             LayoutUnit availableSpace =
1797             availableAlignmentSpaceForChild(lineCrossAxisExtent, flexItem.box);
1798             LayoutUnit offset = alignmentOffset(availableSpace, position, marginBoxAscentForChild(flexItem.box), maxAscent, style().flexWrap() == FlexWrap::Reverse);
1799             adjustAlignmentForChild(flexItem.box, offset);
1800             if (position == ItemPosition::Baseline &amp;&amp; style().flexWrap() == FlexWrap::Reverse)
1801                 minMarginAfterBaseline = std::min(minMarginAfterBaseline, availableAlignmentSpaceForChild(lineCrossAxisExtent, flexItem.box) - offset);
1802         }
1803 
1804         minMarginAfterBaselines.append(minMarginAfterBaseline);
1805     }
1806 
1807     if (style().flexWrap() != FlexWrap::Reverse)
1808         return;
1809 
1810     // wrap-reverse flips the cross axis start and end. For baseline alignment,
1811     // this means we need to align the after edge of baseline elements with the
1812     // after edge of the flex line.
1813     for (size_t lineNumber = 0; lineNumber &lt; lineContexts.size(); ++lineNumber) {
1814         const LineContext&amp; lineContext = lineContexts[lineNumber];
1815         LayoutUnit minMarginAfterBaseline = minMarginAfterBaselines[lineNumber];
1816         for (size_t childNumber = 0; childNumber &lt; lineContext.flexItems.size(); ++childNumber) {
1817             const auto&amp; flexItem = lineContext.flexItems[childNumber];
1818             if (alignmentForChild(flexItem.box) == ItemPosition::Baseline &amp;&amp; !hasAutoMarginsInCrossAxis(flexItem.box) &amp;&amp; minMarginAfterBaseline)
1819                 adjustAlignmentForChild(flexItem.box, minMarginAfterBaseline);
1820         }
1821     }
1822 }
1823 
1824 void RenderFlexibleBox::applyStretchAlignmentToChild(RenderBox&amp; child, LayoutUnit lineCrossAxisExtent)
1825 {
1826     if (!hasOrthogonalFlow(child) &amp;&amp; child.style().logicalHeight().isAuto()) {
1827         LayoutUnit stretchedLogicalHeight = std::max(child.borderAndPaddingLogicalHeight(),
1828         lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1829         ASSERT(!child.needsLayout());
1830         LayoutUnit desiredLogicalHeight = child.constrainLogicalHeightByMinMax(stretchedLogicalHeight, cachedChildIntrinsicContentLogicalHeight(child));
1831 
1832         // FIXME: Can avoid laying out here in some cases. See https://webkit.org/b/87905.
1833         bool childNeedsRelayout = desiredLogicalHeight != child.logicalHeight();
1834         if (child.isRenderBlock() &amp;&amp; downcast&lt;RenderBlock&gt;(child).hasPercentHeightDescendants() &amp;&amp; m_relaidOutChildren.contains(&amp;child)) {
1835             // Have to force another relayout even though the child is sized
1836             // correctly, because its descendants are not sized correctly yet. Our
1837             // previous layout of the child was done without an override height set.
1838             // So, redo it here.
1839             childNeedsRelayout = true;
1840         }
1841         if (childNeedsRelayout || !child.hasOverrideContentLogicalHeight())
1842             child.setOverrideContentLogicalHeight(desiredLogicalHeight - child.borderAndPaddingLogicalHeight());
1843         if (childNeedsRelayout) {
1844             SetForScope&lt;bool&gt; resetChildLogicalHeight(m_shouldResetChildLogicalHeightBeforeLayout, true);
1845             // We cache the child&#39;s intrinsic content logical height to avoid it being
1846             // reset to the stretched height.
1847             // FIXME: This is fragile. RenderBoxes should be smart enough to
1848             // determine their intrinsic content logical height correctly even when
1849             // there&#39;s an overrideHeight.
1850             LayoutUnit childIntrinsicContentLogicalHeight = cachedChildIntrinsicContentLogicalHeight(child);
1851             child.setChildNeedsLayout(MarkOnlyThis);
1852 
1853             // Don&#39;t use layoutChildIfNeeded to avoid setting cross axis cached size twice.
1854             child.layoutIfNeeded();
1855 
1856             setCachedChildIntrinsicContentLogicalHeight(child, childIntrinsicContentLogicalHeight);
1857         }
1858     } else if (hasOrthogonalFlow(child) &amp;&amp; child.style().logicalWidth().isAuto()) {
1859         LayoutUnit childWidth = std::max(0_lu, lineCrossAxisExtent - crossAxisMarginExtentForChild(child));
1860         childWidth = child.constrainLogicalWidthInFragmentByMinMax(childWidth, crossAxisContentExtent(), *this, nullptr);
1861 
1862         if (childWidth != child.logicalWidth()) {
1863             child.setOverrideContentLogicalWidth(childWidth - child.borderAndPaddingLogicalWidth());
1864             child.setChildNeedsLayout(MarkOnlyThis);
1865             child.layoutIfNeeded();
1866         }
1867     }
1868 }
1869 
1870 void RenderFlexibleBox::flipForRightToLeftColumn(const Vector&lt;LineContext&gt;&amp; lineContexts)
1871 {
1872     if (style().isLeftToRightDirection() || !isColumnFlow())
1873         return;
1874 
1875     LayoutUnit crossExtent = crossAxisExtent();
1876     for (size_t lineNumber = 0; lineNumber &lt; lineContexts.size(); ++lineNumber) {
1877         const LineContext&amp; lineContext = lineContexts[lineNumber];
1878         for (size_t childNumber = 0; childNumber &lt; lineContext.flexItems.size(); ++childNumber) {
1879             const auto&amp; flexItem = lineContext.flexItems[childNumber];
1880             ASSERT(!flexItem.box.isOutOfFlowPositioned());
1881 
1882             LayoutPoint location = flowAwareLocationForChild(flexItem.box);
1883             // For vertical flows, setFlowAwareLocationForChild will transpose x and
1884             // y, so using the y axis for a column cross axis extent is correct.
1885             location.setY(crossExtent - crossAxisExtentForChild(flexItem.box) - location.y());
1886             if (!isHorizontalWritingMode())
1887                 location.move(LayoutSize(0, -horizontalScrollbarHeight()));
1888             setFlowAwareLocationForChild(flexItem.box, location);
1889         }
1890     }
1891 }
1892 
1893 void RenderFlexibleBox::flipForWrapReverse(const Vector&lt;LineContext&gt;&amp; lineContexts, LayoutUnit crossAxisStartEdge)
1894 {
1895     LayoutUnit contentExtent = crossAxisContentExtent();
1896     for (size_t lineNumber = 0; lineNumber &lt; lineContexts.size(); ++lineNumber) {
1897         const LineContext&amp; lineContext = lineContexts[lineNumber];
1898         for (size_t childNumber = 0; childNumber &lt; lineContext.flexItems.size(); ++childNumber) {
1899             const auto&amp; flexItem = lineContext.flexItems[childNumber];
1900             LayoutUnit lineCrossAxisExtent = lineContexts[lineNumber].crossAxisExtent;
1901             LayoutUnit originalOffset = lineContexts[lineNumber].crossAxisOffset - crossAxisStartEdge;
1902             LayoutUnit newOffset = contentExtent - originalOffset - lineCrossAxisExtent;
1903             adjustAlignmentForChild(flexItem.box, newOffset - originalOffset);
1904         }
1905     }
1906 }
1907 
1908 bool RenderFlexibleBox::isTopLayoutOverflowAllowed() const
1909 {
1910     bool hasTopOverflow = RenderBlock::isTopLayoutOverflowAllowed();
1911     if (hasTopOverflow || !style().isReverseFlexDirection())
1912         return hasTopOverflow;
1913 
1914     return !isHorizontalFlow();
1915 }
1916 
1917 bool RenderFlexibleBox::isLeftLayoutOverflowAllowed() const
1918 {
1919     bool hasLeftOverflow = RenderBlock::isLeftLayoutOverflowAllowed();
1920     if (hasLeftOverflow || !style().isReverseFlexDirection())
1921         return hasLeftOverflow;
1922 
1923     return isHorizontalFlow();
1924 }
1925 
1926 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorNetworkAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011 Google Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;InspectorNetworkAgent.h&quot;
  34 
  35 #include &quot;CachedCSSStyleSheet.h&quot;
  36 #include &quot;CachedRawResource.h&quot;
  37 #include &quot;CachedResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;CachedResourceRequestInitiators.h&quot;
  40 #include &quot;CachedScript.h&quot;
  41 #include &quot;CertificateInfo.h&quot;
  42 #include &quot;CustomHeaderFields.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentThreadableLoader.h&quot;
  46 #include &quot;Frame.h&quot;
  47 #include &quot;FrameLoader.h&quot;
  48 #include &quot;HTTPHeaderMap.h&quot;
  49 #include &quot;HTTPHeaderNames.h&quot;
  50 #include &quot;InspectorDOMAgent.h&quot;
  51 #include &quot;InspectorTimelineAgent.h&quot;
  52 #include &quot;InstrumentingAgents.h&quot;
  53 #include &quot;JSExecState.h&quot;
  54 #include &quot;JSWebSocket.h&quot;
  55 #include &quot;LoaderStrategy.h&quot;
  56 #include &quot;MIMETypeRegistry.h&quot;
  57 #include &quot;MemoryCache.h&quot;
  58 #include &quot;NetworkResourcesData.h&quot;
  59 #include &quot;Page.h&quot;
  60 #include &quot;PlatformStrategies.h&quot;
  61 #include &quot;ProgressTracker.h&quot;
  62 #include &quot;ResourceError.h&quot;
  63 #include &quot;ResourceLoader.h&quot;
  64 #include &quot;ResourceRequest.h&quot;
  65 #include &quot;ResourceResponse.h&quot;
<a name="2" id="anc2"></a>
  66 #include &quot;ScriptState.h&quot;
  67 #include &quot;ScriptableDocumentParser.h&quot;
  68 #include &quot;SubresourceLoader.h&quot;
  69 #include &quot;TextResourceDecoder.h&quot;
  70 #include &quot;ThreadableLoaderClient.h&quot;
  71 #include &lt;wtf/URL.h&gt;
  72 #include &quot;WebSocket.h&quot;
  73 #include &quot;WebSocketChannel.h&quot;
  74 #include &quot;WebSocketFrame.h&quot;
  75 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
  76 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
  77 #include &lt;JavaScriptCore/InjectedScript.h&gt;
  78 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  79 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;</span>
  80 #include &lt;JavaScriptCore/JSCInlines.h&gt;
  81 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
  82 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
<a name="4" id="anc4"></a><span class="line-added">  83 #include &lt;wtf/HashMap.h&gt;</span>
<span class="line-added">  84 #include &lt;wtf/HashSet.h&gt;</span>
  85 #include &lt;wtf/JSONValues.h&gt;
  86 #include &lt;wtf/Lock.h&gt;
  87 #include &lt;wtf/RefPtr.h&gt;
  88 #include &lt;wtf/Stopwatch.h&gt;
  89 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
  90 #include &lt;wtf/text/Base64.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
<a name="5" id="anc5"></a><span class="line-added">  92 #include &lt;wtf/text/WTFString.h&gt;</span>
  93 
  94 typedef Inspector::NetworkBackendDispatcherHandler::LoadResourceCallback LoadResourceCallback;
  95 
  96 namespace WebCore {
  97 
  98 using namespace Inspector;
  99 
 100 namespace {
 101 
 102 class InspectorThreadableLoaderClient final : public ThreadableLoaderClient {
 103     WTF_MAKE_NONCOPYABLE(InspectorThreadableLoaderClient);
 104 public:
 105     InspectorThreadableLoaderClient(RefPtr&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 106         : m_callback(WTFMove(callback))
 107     {
 108     }
 109 
<a name="6" id="anc6"></a><span class="line-modified"> 110     ~InspectorThreadableLoaderClient() override = default;</span>
 111 
 112     void didReceiveResponse(unsigned long, const ResourceResponse&amp; response) override
 113     {
 114         m_mimeType = response.mimeType();
 115         m_statusCode = response.httpStatusCode();
 116 
 117         // FIXME: This assumes text only responses. We should support non-text responses as well.
 118         TextEncoding textEncoding(response.textEncodingName());
 119         bool useDetector = false;
 120         if (!textEncoding.isValid()) {
 121             textEncoding = UTF8Encoding();
 122             useDetector = true;
 123         }
 124 
 125         m_decoder = TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncoding, useDetector);
 126     }
 127 
 128     void didReceiveData(const char* data, int dataLength) override
 129     {
 130         if (!dataLength)
 131             return;
 132 
 133         if (dataLength == -1)
 134             dataLength = strlen(data);
 135 
 136         m_responseText.append(m_decoder-&gt;decode(data, dataLength));
 137     }
 138 
 139     void didFinishLoading(unsigned long) override
 140     {
 141         if (m_decoder)
 142             m_responseText.append(m_decoder-&gt;flush());
 143 
 144         m_callback-&gt;sendSuccess(m_responseText.toString(), m_mimeType, m_statusCode);
 145         dispose();
 146     }
 147 
 148     void didFail(const ResourceError&amp; error) override
 149     {
 150         m_callback-&gt;sendFailure(error.isAccessControl() ? &quot;Loading resource for inspector failed access control check&quot;_s : &quot;Loading resource for inspector failed&quot;_s);
 151         dispose();
 152     }
 153 
 154     void setLoader(RefPtr&lt;ThreadableLoader&gt;&amp;&amp; loader)
 155     {
 156         m_loader = WTFMove(loader);
 157     }
 158 
 159 private:
 160     void dispose()
 161     {
 162         m_loader = nullptr;
 163         delete this;
 164     }
 165 
 166     RefPtr&lt;LoadResourceCallback&gt; m_callback;
 167     RefPtr&lt;ThreadableLoader&gt; m_loader;
 168     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
 169     String m_mimeType;
 170     StringBuilder m_responseText;
 171     int m_statusCode;
 172 };
 173 
 174 } // namespace
 175 
 176 InspectorNetworkAgent::InspectorNetworkAgent(WebAgentContext&amp; context)
 177     : InspectorAgentBase(&quot;Network&quot;_s, context)
 178     , m_frontendDispatcher(makeUnique&lt;Inspector::NetworkFrontendDispatcher&gt;(context.frontendRouter))
 179     , m_backendDispatcher(Inspector::NetworkBackendDispatcher::create(context.backendDispatcher, this))
 180     , m_injectedScriptManager(context.injectedScriptManager)
 181     , m_resourcesData(makeUnique&lt;NetworkResourcesData&gt;())
 182 {
 183 }
 184 
 185 InspectorNetworkAgent::~InspectorNetworkAgent() = default;
 186 
 187 void InspectorNetworkAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 188 {
 189 }
 190 
 191 void InspectorNetworkAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 192 {
 193     ErrorString ignored;
 194     disable(ignored);
 195 }
 196 
 197 static Ref&lt;JSON::Object&gt; buildObjectForHeaders(const HTTPHeaderMap&amp; headers)
 198 {
 199     Ref&lt;JSON::Object&gt; headersObject = JSON::Object::create();
 200 
 201     for (const auto&amp; header : headers)
 202         headersObject-&gt;setString(header.key, header.value);
 203     return headersObject;
 204 }
 205 
 206 Ref&lt;Inspector::Protocol::Network::ResourceTiming&gt; InspectorNetworkAgent::buildObjectForTiming(const NetworkLoadMetrics&amp; timing, ResourceLoader&amp; resourceLoader)
 207 {
 208     auto&amp; loadTiming = resourceLoader.loadTiming();
 209 
 210     auto elapsedTimeSince = [&amp;] (const MonotonicTime&amp; time) {
 211         return m_environment.executionStopwatch()-&gt;elapsedTimeSince(time).seconds();
 212     };
 213 
 214     return Inspector::Protocol::Network::ResourceTiming::create()
 215         .setStartTime(elapsedTimeSince(loadTiming.startTime()))
 216         .setRedirectStart(elapsedTimeSince(loadTiming.redirectStart()))
 217         .setRedirectEnd(elapsedTimeSince(loadTiming.redirectEnd()))
 218         .setFetchStart(elapsedTimeSince(loadTiming.fetchStart()))
 219         .setDomainLookupStart(timing.domainLookupStart.milliseconds())
 220         .setDomainLookupEnd(timing.domainLookupEnd.milliseconds())
 221         .setConnectStart(timing.connectStart.milliseconds())
 222         .setConnectEnd(timing.connectEnd.milliseconds())
 223         .setSecureConnectionStart(timing.secureConnectionStart.milliseconds())
 224         .setRequestStart(timing.requestStart.milliseconds())
 225         .setResponseStart(timing.responseStart.milliseconds())
 226         .setResponseEnd(timing.responseEnd.milliseconds())
 227         .release();
 228 }
 229 
 230 static Inspector::Protocol::Network::Metrics::Priority toProtocol(NetworkLoadPriority priority)
 231 {
 232     switch (priority) {
 233     case NetworkLoadPriority::Low:
 234         return Inspector::Protocol::Network::Metrics::Priority::Low;
 235     case NetworkLoadPriority::Medium:
 236         return Inspector::Protocol::Network::Metrics::Priority::Medium;
 237     case NetworkLoadPriority::High:
 238         return Inspector::Protocol::Network::Metrics::Priority::High;
 239     case NetworkLoadPriority::Unknown:
 240         break;
 241     }
 242 
 243     ASSERT_NOT_REACHED();
 244     return Inspector::Protocol::Network::Metrics::Priority::Medium;
 245 }
 246 
 247 Ref&lt;Inspector::Protocol::Network::Metrics&gt; InspectorNetworkAgent::buildObjectForMetrics(const NetworkLoadMetrics&amp; networkLoadMetrics)
 248 {
 249     auto metrics = Inspector::Protocol::Network::Metrics::create().release();
 250 
 251     if (!networkLoadMetrics.protocol.isNull())
 252         metrics-&gt;setProtocol(networkLoadMetrics.protocol);
 253     if (networkLoadMetrics.priority != NetworkLoadPriority::Unknown)
 254         metrics-&gt;setPriority(toProtocol(networkLoadMetrics.priority));
 255     if (!networkLoadMetrics.remoteAddress.isNull())
 256         metrics-&gt;setRemoteAddress(networkLoadMetrics.remoteAddress);
 257     if (!networkLoadMetrics.connectionIdentifier.isNull())
 258         metrics-&gt;setConnectionIdentifier(networkLoadMetrics.connectionIdentifier);
 259     if (!networkLoadMetrics.requestHeaders.isEmpty())
 260         metrics-&gt;setRequestHeaders(buildObjectForHeaders(networkLoadMetrics.requestHeaders));
 261 
 262     if (networkLoadMetrics.requestHeaderBytesSent != std::numeric_limits&lt;uint32_t&gt;::max())
 263         metrics-&gt;setRequestHeaderBytesSent(networkLoadMetrics.requestHeaderBytesSent);
 264     if (networkLoadMetrics.requestBodyBytesSent != std::numeric_limits&lt;uint64_t&gt;::max())
 265         metrics-&gt;setRequestBodyBytesSent(networkLoadMetrics.requestBodyBytesSent);
 266     if (networkLoadMetrics.responseHeaderBytesReceived != std::numeric_limits&lt;uint32_t&gt;::max())
 267         metrics-&gt;setResponseHeaderBytesReceived(networkLoadMetrics.responseHeaderBytesReceived);
 268     if (networkLoadMetrics.responseBodyBytesReceived != std::numeric_limits&lt;uint64_t&gt;::max())
 269         metrics-&gt;setResponseBodyBytesReceived(networkLoadMetrics.responseBodyBytesReceived);
 270     if (networkLoadMetrics.responseBodyDecodedSize != std::numeric_limits&lt;uint64_t&gt;::max())
 271         metrics-&gt;setResponseBodyDecodedSize(networkLoadMetrics.responseBodyDecodedSize);
 272 
 273     auto connectionPayload = Inspector::Protocol::Security::Connection::create()
 274         .release();
 275 
 276     if (!networkLoadMetrics.tlsProtocol.isEmpty())
 277         connectionPayload-&gt;setProtocol(networkLoadMetrics.tlsProtocol);
 278 
 279     if (!networkLoadMetrics.tlsCipher.isEmpty())
 280         connectionPayload-&gt;setCipher(networkLoadMetrics.tlsCipher);
 281 
 282     metrics-&gt;setSecurityConnection(WTFMove(connectionPayload));
 283 
 284     return metrics;
 285 }
 286 
 287 static Ref&lt;Inspector::Protocol::Network::Request&gt; buildObjectForResourceRequest(const ResourceRequest&amp; request)
 288 {
 289     auto requestObject = Inspector::Protocol::Network::Request::create()
 290         .setUrl(request.url().string())
 291         .setMethod(request.httpMethod())
 292         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 293         .release();
 294     if (request.httpBody() &amp;&amp; !request.httpBody()-&gt;isEmpty()) {
 295         auto bytes = request.httpBody()-&gt;flatten();
 296         requestObject-&gt;setPostData(String::fromUTF8WithLatin1Fallback(bytes.data(), bytes.size()));
 297     }
 298     return requestObject;
 299 }
 300 
 301 static Inspector::Protocol::Network::Response::Source responseSource(ResourceResponse::Source source)
 302 {
 303     switch (source) {
<a name="7" id="anc7"></a><span class="line-added"> 304     case ResourceResponse::Source::DOMCache:</span>
 305     case ResourceResponse::Source::ApplicationCache:
 306         // FIXME: Add support for ApplicationCache in inspector.
 307     case ResourceResponse::Source::Unknown:
 308         return Inspector::Protocol::Network::Response::Source::Unknown;
 309     case ResourceResponse::Source::Network:
 310         return Inspector::Protocol::Network::Response::Source::Network;
 311     case ResourceResponse::Source::MemoryCache:
 312     case ResourceResponse::Source::MemoryCacheAfterValidation:
 313         return Inspector::Protocol::Network::Response::Source::MemoryCache;
 314     case ResourceResponse::Source::DiskCache:
 315     case ResourceResponse::Source::DiskCacheAfterValidation:
 316         return Inspector::Protocol::Network::Response::Source::DiskCache;
 317     case ResourceResponse::Source::ServiceWorker:
 318         return Inspector::Protocol::Network::Response::Source::ServiceWorker;
<a name="8" id="anc8"></a><span class="line-added"> 319     case ResourceResponse::Source::InspectorOverride:</span>
<span class="line-added"> 320         return Inspector::Protocol::Network::Response::Source::InspectorOverride;</span>
 321     }
 322 
 323     ASSERT_NOT_REACHED();
 324     return Inspector::Protocol::Network::Response::Source::Unknown;
 325 }
 326 
 327 RefPtr&lt;Inspector::Protocol::Network::Response&gt; InspectorNetworkAgent::buildObjectForResourceResponse(const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 328 {
 329     if (response.isNull())
 330         return nullptr;
 331 
 332     Ref&lt;JSON::Object&gt; headers = buildObjectForHeaders(response.httpHeaderFields());
 333 
 334     auto responseObject = Inspector::Protocol::Network::Response::create()
 335         .setUrl(response.url().string())
 336         .setStatus(response.httpStatusCode())
 337         .setStatusText(response.httpStatusText())
 338         .setHeaders(WTFMove(headers))
 339         .setMimeType(response.mimeType())
 340         .setSource(responseSource(response.source()))
 341         .release();
 342 
 343     if (resourceLoader)
 344         responseObject-&gt;setTiming(buildObjectForTiming(response.deprecatedNetworkLoadMetrics(), *resourceLoader));
 345 
 346     if (auto&amp; certificateInfo = response.certificateInfo()) {
 347         auto securityPayload = Inspector::Protocol::Security::Security::create()
 348             .release();
 349 
 350         if (auto certificateSummaryInfo = certificateInfo.value().summaryInfo()) {
 351             auto certificatePayload = Inspector::Protocol::Security::Certificate::create()
 352                 .release();
 353 
 354             certificatePayload-&gt;setSubject(certificateSummaryInfo.value().subject);
 355 
 356             if (auto validFrom = certificateSummaryInfo.value().validFrom)
 357                 certificatePayload-&gt;setValidFrom(validFrom.seconds());
 358 
 359             if (auto validUntil = certificateSummaryInfo.value().validUntil)
 360                 certificatePayload-&gt;setValidUntil(validUntil.seconds());
 361 
 362             auto dnsNamesPayload = JSON::ArrayOf&lt;String&gt;::create();
 363             for (auto&amp; dnsName : certificateSummaryInfo.value().dnsNames)
 364                 dnsNamesPayload-&gt;addItem(dnsName);
 365             if (dnsNamesPayload-&gt;length())
 366                 certificatePayload-&gt;setDnsNames(WTFMove(dnsNamesPayload));
 367 
 368             auto ipAddressesPayload = JSON::ArrayOf&lt;String&gt;::create();
 369             for (auto&amp; ipAddress : certificateSummaryInfo.value().ipAddresses)
 370                 ipAddressesPayload-&gt;addItem(ipAddress);
 371             if (ipAddressesPayload-&gt;length())
 372                 certificatePayload-&gt;setIpAddresses(WTFMove(ipAddressesPayload));
 373 
 374             securityPayload-&gt;setCertificate(WTFMove(certificatePayload));
 375         }
 376 
 377         responseObject-&gt;setSecurity(WTFMove(securityPayload));
 378     }
 379 
 380     return responseObject;
 381 }
 382 
 383 Ref&lt;Inspector::Protocol::Network::CachedResource&gt; InspectorNetworkAgent::buildObjectForCachedResource(CachedResource* cachedResource)
 384 {
 385     auto resourceObject = Inspector::Protocol::Network::CachedResource::create()
 386         .setUrl(cachedResource-&gt;url())
 387         .setType(InspectorPageAgent::cachedResourceTypeJSON(*cachedResource))
 388         .setBodySize(cachedResource-&gt;encodedSize())
 389         .release();
 390 
 391     auto resourceResponse = buildObjectForResourceResponse(cachedResource-&gt;response(), cachedResource-&gt;loader());
 392     resourceObject-&gt;setResponse(WTFMove(resourceResponse));
 393 
 394     String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
 395     if (!sourceMappingURL.isEmpty())
 396         resourceObject-&gt;setSourceMapURL(sourceMappingURL);
 397 
 398     return resourceObject;
 399 }
 400 
 401 double InspectorNetworkAgent::timestamp()
 402 {
 403     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
 404 }
 405 
 406 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse, InspectorPageAgent::ResourceType type)
 407 {
 408     if (request.hiddenFromInspector()) {
 409         m_hiddenRequestIdentifiers.add(identifier);
 410         return;
 411     }
 412 
 413     double sendTimestamp = timestamp();
 414     WallTime walltime = WallTime::now();
 415 
 416     String requestId = IdentifiersFactory::requestId(identifier);
 417     String frameId = frameIdentifier(loader);
 418     String loaderId = loaderIdentifier(loader);
 419     String targetId = request.initiatorIdentifier();
 420 
 421     if (type == InspectorPageAgent::OtherResource) {
 422         if (m_loadingXHRSynchronously)
 423             type = InspectorPageAgent::XHRResource;
 424         else if (loader &amp;&amp; equalIgnoringFragmentIdentifier(request.url(), loader-&gt;url()) &amp;&amp; !loader-&gt;isCommitted())
 425             type = InspectorPageAgent::DocumentResource;
 426         else if (loader) {
 427             for (auto&amp; linkIcon : loader-&gt;linkIcons()) {
 428                 if (equalIgnoringFragmentIdentifier(request.url(), linkIcon.url)) {
 429                     type = InspectorPageAgent::ImageResource;
 430                     break;
 431                 }
 432             }
 433         }
 434     }
 435 
 436     m_resourcesData-&gt;resourceCreated(requestId, loaderId, type);
 437 
 438     for (auto&amp; entry : m_extraRequestHeaders)
 439         request.setHTTPHeaderField(entry.key, entry.value);
 440 
 441     auto protocolResourceType = InspectorPageAgent::resourceTypeJSON(type);
 442 
 443     Document* document = loader &amp;&amp; loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr;
 444     auto initiatorObject = buildInitiatorObject(document, request);
 445 
 446     String url = loader ? loader-&gt;url().string() : request.url();
 447     m_frontendDispatcher-&gt;requestWillBeSent(requestId, frameId, loaderId, url, buildObjectForResourceRequest(request), sendTimestamp, walltime.secondsSinceEpoch().seconds(), initiatorObject, buildObjectForResourceResponse(redirectResponse, nullptr), type != InspectorPageAgent::OtherResource ? &amp;protocolResourceType : nullptr, targetId.isEmpty() ? nullptr : &amp;targetId);
 448 }
 449 
 450 static InspectorPageAgent::ResourceType resourceTypeForCachedResource(CachedResource* resource)
 451 {
 452     if (resource)
 453         return InspectorPageAgent::inspectorResourceType(*resource);
 454     return InspectorPageAgent::OtherResource;
 455 }
 456 
 457 static InspectorPageAgent::ResourceType resourceTypeForLoadType(InspectorInstrumentation::LoadType loadType)
 458 {
 459     switch (loadType) {
 460     case InspectorInstrumentation::LoadType::Ping:
 461         return InspectorPageAgent::PingResource;
 462     case InspectorInstrumentation::LoadType::Beacon:
 463         return InspectorPageAgent::BeaconResource;
 464     }
 465 
 466     ASSERT_NOT_REACHED();
 467     return InspectorPageAgent::OtherResource;
 468 }
 469 
 470 void InspectorNetworkAgent::willSendRequest(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
 471 {
 472     auto* cachedResource = loader ? InspectorPageAgent::cachedResource(loader-&gt;frame(), request.url()) : nullptr;
 473     willSendRequest(identifier, loader, request, redirectResponse, resourceTypeForCachedResource(cachedResource));
 474 }
 475 
 476 void InspectorNetworkAgent::willSendRequestOfType(unsigned long identifier, DocumentLoader* loader, ResourceRequest&amp; request, InspectorInstrumentation::LoadType loadType)
 477 {
 478     willSendRequest(identifier, loader, request, ResourceResponse(), resourceTypeForLoadType(loadType));
 479 }
 480 
 481 void InspectorNetworkAgent::didReceiveResponse(unsigned long identifier, DocumentLoader* loader, const ResourceResponse&amp; response, ResourceLoader* resourceLoader)
 482 {
 483     if (m_hiddenRequestIdentifiers.contains(identifier))
 484         return;
 485 
 486     String requestId = IdentifiersFactory::requestId(identifier);
 487 
 488     Optional&lt;ResourceResponse&gt; realResponse;
 489     if (platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 490         callOnMainThreadAndWait([&amp;] {
 491             // We do not need to isolate response since it comes straight from IPC, but we might want to isolate it for extra safety.
 492             auto response = platformStrategies()-&gt;loaderStrategy()-&gt;responseFromResourceLoadIdentifier(identifier);
 493             if (!response.isNull())
 494                 realResponse = WTFMove(response);
 495         });
 496     }
 497 
 498     RefPtr&lt;Inspector::Protocol::Network::Response&gt; resourceResponse = buildObjectForResourceResponse(realResponse ? *realResponse : response, resourceLoader);
 499 
 500     bool isNotModified = response.httpStatusCode() == 304;
 501 
 502     CachedResource* cachedResource = nullptr;
 503     if (is&lt;SubresourceLoader&gt;(resourceLoader) &amp;&amp; !isNotModified)
 504         cachedResource = downcast&lt;SubresourceLoader&gt;(resourceLoader)-&gt;cachedResource();
 505     if (!cachedResource &amp;&amp; loader)
 506         cachedResource = InspectorPageAgent::cachedResource(loader-&gt;frame(), response.url());
 507 
 508     if (cachedResource) {
 509         // Use mime type from cached resource in case the one in response is empty.
 510         if (resourceResponse &amp;&amp; response.mimeType().isEmpty())
 511             resourceResponse-&gt;setString(Inspector::Protocol::Network::Response::MimeType, cachedResource-&gt;response().mimeType());
 512         m_resourcesData-&gt;addCachedResource(requestId, cachedResource);
 513     }
 514 
 515     InspectorPageAgent::ResourceType type = m_resourcesData-&gt;resourceType(requestId);
 516     InspectorPageAgent::ResourceType newType = cachedResource ? InspectorPageAgent::inspectorResourceType(*cachedResource) : type;
 517 
 518     // FIXME: XHRResource is returned for CachedResource::Type::RawResource, it should be OtherResource unless it truly is an XHR.
 519     // RawResource is used for loading worker scripts, and those should stay as ScriptResource and not change to XHRResource.
 520     if (type != newType &amp;&amp; newType != InspectorPageAgent::XHRResource &amp;&amp; newType != InspectorPageAgent::OtherResource)
 521         type = newType;
 522 
 523     String frameId = frameIdentifier(loader);
 524     String loaderId = loaderIdentifier(loader);
 525 
 526     m_resourcesData-&gt;responseReceived(requestId, frameId, response, type, shouldForceBufferingNetworkResourceData());
 527 
 528     m_frontendDispatcher-&gt;responseReceived(requestId, frameId, loaderId, timestamp(), InspectorPageAgent::resourceTypeJSON(type), resourceResponse);
 529 
 530     // If we revalidated the resource and got Not modified, send content length following didReceiveResponse
 531     // as there will be no calls to didReceiveData from the network stack.
 532     if (isNotModified &amp;&amp; cachedResource &amp;&amp; cachedResource-&gt;encodedSize())
 533         didReceiveData(identifier, nullptr, cachedResource-&gt;encodedSize(), 0);
 534 }
 535 
 536 void InspectorNetworkAgent::didReceiveData(unsigned long identifier, const char* data, int dataLength, int encodedDataLength)
 537 {
 538     if (m_hiddenRequestIdentifiers.contains(identifier))
 539         return;
 540 
 541     String requestId = IdentifiersFactory::requestId(identifier);
 542 
 543     if (data) {
 544         NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;maybeAddResourceData(requestId, data, dataLength);
 545 
 546         // For a synchronous XHR, if we didn&#39;t add data then we can apply it here as base64 encoded content.
 547         // Often the data is text and we would have a decoder, but for non-text we won&#39;t have a decoder.
 548         // Sync XHRs may not have a cached resource, while non-sync XHRs usually transfer data over on completion.
 549         if (m_loadingXHRSynchronously &amp;&amp; resourceData &amp;&amp; !resourceData-&gt;hasBufferedData() &amp;&amp; !resourceData-&gt;cachedResource())
 550             m_resourcesData-&gt;setResourceContent(requestId, base64Encode(data, dataLength), true);
 551     }
 552 
 553     m_frontendDispatcher-&gt;dataReceived(requestId, timestamp(), dataLength, encodedDataLength);
 554 }
 555 
 556 void InspectorNetworkAgent::didFinishLoading(unsigned long identifier, DocumentLoader* loader, const NetworkLoadMetrics&amp; networkLoadMetrics, ResourceLoader* resourceLoader)
 557 {
 558     if (m_hiddenRequestIdentifiers.remove(identifier))
 559         return;
 560 
 561     double elapsedFinishTime;
 562     if (resourceLoader &amp;&amp; networkLoadMetrics.isComplete()) {
 563         MonotonicTime fetchStart = resourceLoader-&gt;loadTiming().fetchStart();
 564         Seconds fetchStartInInspector = m_environment.executionStopwatch()-&gt;elapsedTimeSince(fetchStart);
 565         elapsedFinishTime = (fetchStartInInspector + networkLoadMetrics.responseEnd).seconds();
 566     } else
 567         elapsedFinishTime = timestamp();
 568 
 569     String requestId = IdentifiersFactory::requestId(identifier);
 570     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource)
 571         m_resourcesData-&gt;addResourceSharedBuffer(requestId, loader-&gt;frameLoader()-&gt;documentLoader()-&gt;mainResourceData(), loader-&gt;frame()-&gt;document()-&gt;encoding());
 572 
 573     m_resourcesData-&gt;maybeDecodeDataToContent(requestId);
 574 
 575     String sourceMappingURL;
 576     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 577     if (resourceData &amp;&amp; resourceData-&gt;cachedResource())
 578         sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(resourceData-&gt;cachedResource());
 579 
 580     Optional&lt;NetworkLoadMetrics&gt; realMetrics;
 581     if (platformStrategies()-&gt;loaderStrategy()-&gt;shouldPerformSecurityChecks() &amp;&amp; !networkLoadMetrics.isComplete()) {
 582         callOnMainThreadAndWait([&amp;] {
 583             realMetrics = platformStrategies()-&gt;loaderStrategy()-&gt;networkMetricsFromResourceLoadIdentifier(identifier).isolatedCopy();
 584         });
 585     }
 586     RefPtr&lt;Inspector::Protocol::Network::Metrics&gt; metrics = buildObjectForMetrics(realMetrics ? *realMetrics : networkLoadMetrics);
 587 
 588     m_frontendDispatcher-&gt;loadingFinished(requestId, elapsedFinishTime, !sourceMappingURL.isEmpty() ? &amp;sourceMappingURL : nullptr, metrics);
 589 }
 590 
 591 void InspectorNetworkAgent::didFailLoading(unsigned long identifier, DocumentLoader* loader, const ResourceError&amp; error)
 592 {
 593     if (m_hiddenRequestIdentifiers.remove(identifier))
 594         return;
 595 
 596     String requestId = IdentifiersFactory::requestId(identifier);
 597 
 598     if (loader &amp;&amp; m_resourcesData-&gt;resourceType(requestId) == InspectorPageAgent::DocumentResource) {
 599         Frame* frame = loader-&gt;frame();
 600         if (frame &amp;&amp; frame-&gt;loader().documentLoader() &amp;&amp; frame-&gt;document()) {
 601             m_resourcesData-&gt;addResourceSharedBuffer(requestId,
 602                 frame-&gt;loader().documentLoader()-&gt;mainResourceData(),
 603                 frame-&gt;document()-&gt;encoding());
 604         }
 605     }
 606 
 607     bool canceled = error.isCancellation();
 608     m_frontendDispatcher-&gt;loadingFailed(requestId, timestamp(), error.localizedDescription(), canceled ? &amp;canceled : nullptr);
 609 }
 610 
 611 void InspectorNetworkAgent::didLoadResourceFromMemoryCache(DocumentLoader* loader, CachedResource&amp; resource)
 612 {
 613     ASSERT(loader);
 614     if (!loader)
 615         return;
 616 
 617     unsigned long identifier = loader-&gt;frame()-&gt;page()-&gt;progress().createUniqueIdentifier();
 618     String requestId = IdentifiersFactory::requestId(identifier);
 619     String loaderId = loaderIdentifier(loader);
 620     String frameId = frameIdentifier(loader);
 621 
 622     m_resourcesData-&gt;resourceCreated(requestId, loaderId, resource);
 623 
 624     auto initiatorObject = buildInitiatorObject(loader-&gt;frame() ? loader-&gt;frame()-&gt;document() : nullptr, resource.resourceRequest());
 625 
 626     // FIXME: It would be ideal to generate the Network.Response with the MemoryCache source
 627     // instead of whatever ResourceResponse::Source the CachedResources&#39;s response has.
 628     // The frontend already knows for certain that this was served from the memory cache.
 629 
 630     m_frontendDispatcher-&gt;requestServedFromMemoryCache(requestId, frameId, loaderId, loader-&gt;url().string(), timestamp(), initiatorObject, buildObjectForCachedResource(&amp;resource));
 631 }
 632 
 633 void InspectorNetworkAgent::setInitialScriptContent(unsigned long identifier, const String&amp; sourceString)
 634 {
 635     m_resourcesData-&gt;setResourceContent(IdentifiersFactory::requestId(identifier), sourceString);
 636 }
 637 
 638 void InspectorNetworkAgent::didReceiveScriptResponse(unsigned long identifier)
 639 {
 640     m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::ScriptResource);
 641 }
 642 
 643 void InspectorNetworkAgent::didReceiveThreadableLoaderResponse(unsigned long identifier, DocumentThreadableLoader&amp; documentThreadableLoader)
 644 {
 645     String initiator = documentThreadableLoader.options().initiator;
 646     if (initiator == cachedResourceRequestInitiators().fetch)
 647         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::FetchResource);
 648     else if (initiator == cachedResourceRequestInitiators().xmlhttprequest)
 649         m_resourcesData-&gt;setResourceType(IdentifiersFactory::requestId(identifier), InspectorPageAgent::XHRResource);
 650 }
 651 
 652 void InspectorNetworkAgent::willLoadXHRSynchronously()
 653 {
 654     m_loadingXHRSynchronously = true;
 655 }
 656 
 657 void InspectorNetworkAgent::didLoadXHRSynchronously()
 658 {
 659     m_loadingXHRSynchronously = false;
 660 }
 661 
 662 void InspectorNetworkAgent::willDestroyCachedResource(CachedResource&amp; cachedResource)
 663 {
 664     Vector&lt;String&gt; requestIds = m_resourcesData-&gt;removeCachedResource(&amp;cachedResource);
 665     if (!requestIds.size())
 666         return;
 667 
 668     String content;
 669     bool base64Encoded;
 670     if (!InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;content, &amp;base64Encoded))
 671         return;
 672 
 673     for (auto&amp; id : requestIds)
 674         m_resourcesData-&gt;setResourceContent(id, content, base64Encoded);
 675 }
 676 
 677 void InspectorNetworkAgent::willRecalculateStyle()
 678 {
 679     m_isRecalculatingStyle = true;
 680 }
 681 
 682 void InspectorNetworkAgent::didRecalculateStyle()
 683 {
 684     m_isRecalculatingStyle = false;
 685     m_styleRecalculationInitiator = nullptr;
 686 }
 687 
 688 void InspectorNetworkAgent::didScheduleStyleRecalculation(Document&amp; document)
 689 {
 690     if (!m_styleRecalculationInitiator)
 691         m_styleRecalculationInitiator = buildInitiatorObject(&amp;document);
 692 }
 693 
 694 RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; InspectorNetworkAgent::buildInitiatorObject(Document* document, Optional&lt;const ResourceRequest&amp;&gt; resourceRequest)
 695 {
 696     // FIXME: Worker support.
 697     if (!isMainThread()) {
 698         return Inspector::Protocol::Network::Initiator::create()
 699             .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 700             .release();
 701     }
 702 
 703     RefPtr&lt;Inspector::Protocol::Network::Initiator&gt; initiatorObject;
 704 
 705     Ref&lt;ScriptCallStack&gt; stackTrace = createScriptCallStack(JSExecState::currentState());
 706     if (stackTrace-&gt;size() &gt; 0) {
 707         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 708             .setType(Inspector::Protocol::Network::Initiator::Type::Script)
 709             .release();
 710         initiatorObject-&gt;setStackTrace(stackTrace-&gt;buildInspectorArray());
 711     } else if (document &amp;&amp; document-&gt;scriptableDocumentParser()) {
 712         initiatorObject = Inspector::Protocol::Network::Initiator::create()
 713             .setType(Inspector::Protocol::Network::Initiator::Type::Parser)
 714             .release();
 715         initiatorObject-&gt;setUrl(document-&gt;url().string());
 716         initiatorObject-&gt;setLineNumber(document-&gt;scriptableDocumentParser()-&gt;textPosition().m_line.oneBasedInt());
 717     }
 718 
 719     auto domAgent = m_instrumentingAgents.inspectorDOMAgent();
 720     if (domAgent &amp;&amp; resourceRequest) {
 721         if (auto inspectorInitiatorNodeIdentifier = resourceRequest-&gt;inspectorInitiatorNodeIdentifier()) {
 722             if (!initiatorObject) {
 723                 initiatorObject = Inspector::Protocol::Network::Initiator::create()
 724                     .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 725                     .release();
 726             }
 727 
 728             initiatorObject-&gt;setNodeId(*inspectorInitiatorNodeIdentifier);
 729         }
 730     }
 731 
 732     if (initiatorObject)
 733         return initiatorObject;
 734 
 735     if (m_isRecalculatingStyle &amp;&amp; m_styleRecalculationInitiator)
 736         return m_styleRecalculationInitiator;
 737 
 738     return Inspector::Protocol::Network::Initiator::create()
 739         .setType(Inspector::Protocol::Network::Initiator::Type::Other)
 740         .release();
 741 }
 742 
 743 void InspectorNetworkAgent::didCreateWebSocket(unsigned long identifier, const URL&amp; requestURL)
 744 {
 745     m_frontendDispatcher-&gt;webSocketCreated(IdentifiersFactory::requestId(identifier), requestURL.string());
 746 }
 747 
 748 void InspectorNetworkAgent::willSendWebSocketHandshakeRequest(unsigned long identifier, const ResourceRequest&amp; request)
 749 {
 750     auto requestObject = Inspector::Protocol::Network::WebSocketRequest::create()
 751         .setHeaders(buildObjectForHeaders(request.httpHeaderFields()))
 752         .release();
 753     m_frontendDispatcher-&gt;webSocketWillSendHandshakeRequest(IdentifiersFactory::requestId(identifier), timestamp(), WallTime::now().secondsSinceEpoch().seconds(), WTFMove(requestObject));
 754 }
 755 
 756 void InspectorNetworkAgent::didReceiveWebSocketHandshakeResponse(unsigned long identifier, const ResourceResponse&amp; response)
 757 {
 758     auto responseObject = Inspector::Protocol::Network::WebSocketResponse::create()
 759         .setStatus(response.httpStatusCode())
 760         .setStatusText(response.httpStatusText())
 761         .setHeaders(buildObjectForHeaders(response.httpHeaderFields()))
 762         .release();
 763     m_frontendDispatcher-&gt;webSocketHandshakeResponseReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(responseObject));
 764 }
 765 
 766 void InspectorNetworkAgent::didCloseWebSocket(unsigned long identifier)
 767 {
 768     m_frontendDispatcher-&gt;webSocketClosed(IdentifiersFactory::requestId(identifier), timestamp());
 769 }
 770 
 771 void InspectorNetworkAgent::didReceiveWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 772 {
 773     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 774         .setOpcode(frame.opCode)
 775         .setMask(frame.masked)
 776         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 777         .setPayloadLength(frame.payloadLength)
 778         .release();
 779     m_frontendDispatcher-&gt;webSocketFrameReceived(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 780 }
 781 
 782 void InspectorNetworkAgent::didSendWebSocketFrame(unsigned long identifier, const WebSocketFrame&amp; frame)
 783 {
 784     auto frameObject = Inspector::Protocol::Network::WebSocketFrame::create()
 785         .setOpcode(frame.opCode)
 786         .setMask(frame.masked)
 787         .setPayloadData(String::fromUTF8WithLatin1Fallback(frame.payload, frame.payloadLength))
 788         .setPayloadLength(frame.payloadLength)
 789         .release();
 790     m_frontendDispatcher-&gt;webSocketFrameSent(IdentifiersFactory::requestId(identifier), timestamp(), WTFMove(frameObject));
 791 }
 792 
 793 void InspectorNetworkAgent::didReceiveWebSocketFrameError(unsigned long identifier, const String&amp; errorMessage)
 794 {
 795     m_frontendDispatcher-&gt;webSocketFrameError(IdentifiersFactory::requestId(identifier), timestamp(), errorMessage);
 796 }
 797 
 798 void InspectorNetworkAgent::enable(ErrorString&amp;)
 799 {
 800     enable();
 801 }
 802 
 803 void InspectorNetworkAgent::enable()
 804 {
 805     m_enabled = true;
 806     m_instrumentingAgents.setInspectorNetworkAgent(this);
 807 
 808     {
 809         LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 810 
 811         for (WebSocket* webSocket : activeWebSockets(lock)) {
 812             ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 813             WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 814 
 815             unsigned identifier = channel-&gt;identifier();
 816             didCreateWebSocket(identifier, webSocket-&gt;url());
 817             auto cookieRequestHeaderFieldValue = [document = makeWeakPtr(channel-&gt;document())] (const URL&amp; url) -&gt; String {
 818                 if (!document || !document-&gt;page())
 819                     return { };
 820                 return document-&gt;page()-&gt;cookieJar().cookieRequestHeaderFieldValue(*document, url);
 821             };
 822             willSendWebSocketHandshakeRequest(identifier, channel-&gt;clientHandshakeRequest(WTFMove(cookieRequestHeaderFieldValue)));
 823 
 824             if (channel-&gt;handshakeMode() == WebSocketHandshake::Connected)
 825                 didReceiveWebSocketHandshakeResponse(identifier, channel-&gt;serverHandshakeResponse());
 826 
 827             if (webSocket-&gt;readyState() == WebSocket::CLOSED)
 828                 didCloseWebSocket(identifier);
 829         }
 830     }
 831 }
 832 
 833 void InspectorNetworkAgent::disable(ErrorString&amp;)
 834 {
 835     m_enabled = false;
<a name="9" id="anc9"></a><span class="line-added"> 836     m_interceptionEnabled = false;</span>
<span class="line-added"> 837     m_intercepts.clear();</span>
 838     m_instrumentingAgents.setInspectorNetworkAgent(nullptr);
 839     m_resourcesData-&gt;clear();
 840     m_extraRequestHeaders.clear();
 841 
<a name="10" id="anc10"></a><span class="line-added"> 842     continuePendingResponses();</span>
<span class="line-added"> 843 </span>
 844     setResourceCachingDisabled(false);
 845 }
 846 
<a name="11" id="anc11"></a><span class="line-added"> 847 bool InspectorNetworkAgent::shouldIntercept(URL url)</span>
<span class="line-added"> 848 {</span>
<span class="line-added"> 849     url.removeFragmentIdentifier();</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851     String urlString = url.string();</span>
<span class="line-added"> 852     if (urlString.isEmpty())</span>
<span class="line-added"> 853         return false;</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855     for (auto&amp; intercept : m_intercepts) {</span>
<span class="line-added"> 856         auto searchStringType = intercept.isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ExactString;</span>
<span class="line-added"> 857         auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(intercept.url, intercept.caseSensitive, searchStringType);</span>
<span class="line-added"> 858         if (regex.match(urlString) != -1)</span>
<span class="line-added"> 859             return true;</span>
<span class="line-added"> 860     }</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862     return false;</span>
<span class="line-added"> 863 }</span>
<span class="line-added"> 864 </span>
<span class="line-added"> 865 void InspectorNetworkAgent::continuePendingResponses()</span>
<span class="line-added"> 866 {</span>
<span class="line-added"> 867     for (auto&amp; pendingInterceptResponse : m_pendingInterceptResponses.values())</span>
<span class="line-added"> 868         pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added"> 869     m_pendingInterceptResponses.clear();</span>
<span class="line-added"> 870 }</span>
<span class="line-added"> 871 </span>
 872 void InspectorNetworkAgent::setExtraHTTPHeaders(ErrorString&amp;, const JSON::Object&amp; headers)
 873 {
 874     for (auto&amp; entry : headers) {
 875         String stringValue;
 876         if (entry.value-&gt;asString(stringValue))
 877             m_extraRequestHeaders.set(entry.key, stringValue);
 878     }
 879 }
 880 
 881 void InspectorNetworkAgent::getResponseBody(ErrorString&amp; errorString, const String&amp; requestId, String* content, bool* base64Encoded)
 882 {
 883     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
 884     if (!resourceData) {
 885         errorString = &quot;Missing resource for given requestId&quot;_s;
 886         return;
 887     }
 888 
 889     if (resourceData-&gt;hasContent()) {
 890         *base64Encoded = resourceData-&gt;base64Encoded();
 891         *content = resourceData-&gt;content();
 892         return;
 893     }
 894 
 895     if (resourceData-&gt;isContentEvicted()) {
 896         errorString = &quot;Resource content was evicted from inspector cache&quot;_s;
 897         return;
 898     }
 899 
 900     if (resourceData-&gt;buffer() &amp;&amp; !resourceData-&gt;textEncodingName().isNull()) {
 901         *base64Encoded = false;
 902         if (InspectorPageAgent::sharedBufferContent(resourceData-&gt;buffer(), resourceData-&gt;textEncodingName(), *base64Encoded, content))
 903             return;
 904     }
 905 
 906     if (resourceData-&gt;cachedResource()) {
 907         if (InspectorNetworkAgent::cachedResourceContent(*resourceData-&gt;cachedResource(), content, base64Encoded))
 908             return;
 909     }
 910 
 911     errorString = &quot;Missing content of resource for given requestId&quot;_s;
 912 }
 913 
 914 void InspectorNetworkAgent::setResourceCachingDisabled(ErrorString&amp;, bool disabled)
 915 {
 916     setResourceCachingDisabled(disabled);
 917 }
 918 
 919 void InspectorNetworkAgent::loadResource(const String&amp; frameId, const String&amp; urlString, Ref&lt;LoadResourceCallback&gt;&amp;&amp; callback)
 920 {
 921     ErrorString errorString;
 922     auto* context = scriptExecutionContext(errorString, frameId);
 923     if (!context) {
 924         callback-&gt;sendFailure(errorString);
 925         return;
 926     }
 927 
 928     URL url = context-&gt;completeURL(urlString);
 929     ResourceRequest request(url);
 930     request.setHTTPMethod(&quot;GET&quot;_s);
 931     request.setHiddenFromInspector(true);
 932 
 933     ThreadableLoaderOptions options;
 934     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks; // So we remove this from m_hiddenRequestIdentifiers on completion.
 935     options.defersLoadingPolicy = DefersLoadingPolicy::DisallowDefersLoading; // So the request is never deferred.
 936     options.mode = FetchOptions::Mode::NoCors;
 937     options.credentials = FetchOptions::Credentials::SameOrigin;
 938     options.contentSecurityPolicyEnforcement = ContentSecurityPolicyEnforcement::DoNotEnforce;
 939 
 940     // InspectorThreadableLoaderClient deletes itself when the load completes or fails.
 941     InspectorThreadableLoaderClient* inspectorThreadableLoaderClient = new InspectorThreadableLoaderClient(callback.copyRef());
 942     auto loader = ThreadableLoader::create(*context, *inspectorThreadableLoaderClient, WTFMove(request), options);
 943     if (!loader) {
 944         callback-&gt;sendFailure(&quot;Could not load requested resource.&quot;_s);
 945         return;
 946     }
 947 
 948     // If the load already completed, inspectorThreadableLoaderClient will have been deleted and we will have already called the callback.
 949     if (!callback-&gt;isActive())
 950         return;
 951 
 952     inspectorThreadableLoaderClient-&gt;setLoader(WTFMove(loader));
 953 }
 954 
 955 void InspectorNetworkAgent::getSerializedCertificate(ErrorString&amp; errorString, const String&amp; requestId, String* serializedCertificate)
 956 {
 957     auto* resourceData = m_resourcesData-&gt;data(requestId);
 958     if (!resourceData) {
 959         errorString = &quot;Missing resource for given requestId&quot;_s;
 960         return;
 961     }
 962 
 963     auto&amp; certificate = resourceData-&gt;certificateInfo();
 964     if (!certificate || certificate.value().isEmpty()) {
 965         errorString = &quot;Missing certificate of resource for given requestId&quot;_s;
 966         return;
 967     }
 968 
 969     WTF::Persistence::Encoder encoder;
 970     encoder &lt;&lt; certificate.value();
 971     *serializedCertificate = base64Encode(encoder.buffer(), encoder.bufferSize());
 972 }
 973 
 974 WebSocket* InspectorNetworkAgent::webSocketForRequestId(const String&amp; requestId)
 975 {
 976     LockHolder lock(WebSocket::allActiveWebSocketsMutex());
 977 
 978     for (WebSocket* webSocket : activeWebSockets(lock)) {
 979         ASSERT(is&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get()));
 980         WebSocketChannel* channel = downcast&lt;WebSocketChannel&gt;(webSocket-&gt;channel().get());
 981         if (IdentifiersFactory::requestId(channel-&gt;identifier()) == requestId)
 982             return webSocket;
 983     }
 984 
 985     return nullptr;
 986 }
 987 
<a name="12" id="anc12"></a><span class="line-modified"> 988 static JSC::JSValue webSocketAsScriptValue(JSC::JSGlobalObject&amp; state, WebSocket* webSocket)</span>
 989 {
 990     JSC::JSLockHolder lock(&amp;state);
 991     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), webSocket);
 992 }
 993 
 994 void InspectorNetworkAgent::resolveWebSocket(ErrorString&amp; errorString, const String&amp; requestId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
 995 {
 996     WebSocket* webSocket = webSocketForRequestId(requestId);
 997     if (!webSocket) {
 998         errorString = &quot;Missing web socket for given requestId&quot;_s;
 999         return;
1000     }
1001 
1002     // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s and worker&#39;s WebSockets
1003     if (!is&lt;Document&gt;(webSocket-&gt;scriptExecutionContext()))
1004         return;
1005 
1006     auto* document = downcast&lt;Document&gt;(webSocket-&gt;scriptExecutionContext());
1007     auto* frame = document-&gt;frame();
1008     if (!frame) {
1009         errorString = &quot;Missing frame of web socket for given requestId&quot;_s;
1010         return;
1011     }
1012 
1013     auto&amp; state = *mainWorldExecState(frame);
1014     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
1015     ASSERT(!injectedScript.hasNoValue());
1016 
1017     String objectGroupName = objectGroup ? *objectGroup : String();
1018     result = injectedScript.wrapObject(webSocketAsScriptValue(state, webSocket), objectGroupName);
1019 }
1020 
<a name="13" id="anc13"></a><span class="line-added">1021 void InspectorNetworkAgent::setInterceptionEnabled(ErrorString&amp; errorString, bool enabled)</span>
<span class="line-added">1022 {</span>
<span class="line-added">1023     if (m_interceptionEnabled == enabled) {</span>
<span class="line-added">1024         errorString = m_interceptionEnabled ? &quot;Interception already enabled&quot;_s : &quot;Interception already disabled&quot;_s;</span>
<span class="line-added">1025         return;</span>
<span class="line-added">1026     }</span>
<span class="line-added">1027 </span>
<span class="line-added">1028     m_interceptionEnabled = enabled;</span>
<span class="line-added">1029 </span>
<span class="line-added">1030     if (!m_interceptionEnabled)</span>
<span class="line-added">1031         continuePendingResponses();</span>
<span class="line-added">1032 }</span>
<span class="line-added">1033 </span>
<span class="line-added">1034 void InspectorNetworkAgent::addInterception(ErrorString&amp; errorString, const String&amp; url, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* networkStageString)</span>
<span class="line-added">1035 {</span>
<span class="line-added">1036     if (networkStageString) {</span>
<span class="line-added">1037         auto networkStage = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Network::NetworkStage&gt;(*networkStageString);</span>
<span class="line-added">1038         if (!networkStage) {</span>
<span class="line-added">1039             errorString = makeString(&quot;Unknown networkStage: &quot;_s, *networkStageString);</span>
<span class="line-added">1040             return;</span>
<span class="line-added">1041         }</span>
<span class="line-added">1042     }</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     Intercept intercept;</span>
<span class="line-added">1045     intercept.url = url;</span>
<span class="line-added">1046     if (optionalCaseSensitive)</span>
<span class="line-added">1047         intercept.caseSensitive = *optionalCaseSensitive;</span>
<span class="line-added">1048     if (optionalIsRegex)</span>
<span class="line-added">1049         intercept.isRegex = *optionalIsRegex;</span>
<span class="line-added">1050 </span>
<span class="line-added">1051     // FIXME: Support intercepting requests.</span>
<span class="line-added">1052 </span>
<span class="line-added">1053     if (!m_intercepts.appendIfNotContains(intercept))</span>
<span class="line-added">1054         errorString = &quot;Intercept for given url and given isRegex already exists&quot;_s;</span>
<span class="line-added">1055 }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057 void InspectorNetworkAgent::removeInterception(ErrorString&amp; errorString, const String&amp; url, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* networkStageString)</span>
<span class="line-added">1058 {</span>
<span class="line-added">1059     if (networkStageString) {</span>
<span class="line-added">1060         auto networkStage = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Network::NetworkStage&gt;(*networkStageString);</span>
<span class="line-added">1061         if (!networkStage) {</span>
<span class="line-added">1062             errorString = makeString(&quot;Unknown networkStage: &quot;_s, *networkStageString);</span>
<span class="line-added">1063             return;</span>
<span class="line-added">1064         }</span>
<span class="line-added">1065     }</span>
<span class="line-added">1066 </span>
<span class="line-added">1067     Intercept intercept;</span>
<span class="line-added">1068     intercept.url = url;</span>
<span class="line-added">1069     if (optionalCaseSensitive)</span>
<span class="line-added">1070         intercept.caseSensitive = *optionalCaseSensitive;</span>
<span class="line-added">1071     if (optionalIsRegex)</span>
<span class="line-added">1072         intercept.isRegex = *optionalIsRegex;</span>
<span class="line-added">1073 </span>
<span class="line-added">1074     // FIXME: Support intercepting requests.</span>
<span class="line-added">1075 </span>
<span class="line-added">1076     if (!m_intercepts.removeAll(intercept))</span>
<span class="line-added">1077         errorString = &quot;Missing intercept for given url and given isRegex&quot;_s;</span>
<span class="line-added">1078 }</span>
<span class="line-added">1079 </span>
<span class="line-added">1080 bool InspectorNetworkAgent::willInterceptRequest(const ResourceRequest&amp; request)</span>
<span class="line-added">1081 {</span>
<span class="line-added">1082     if (!m_interceptionEnabled)</span>
<span class="line-added">1083         return false;</span>
<span class="line-added">1084 </span>
<span class="line-added">1085     return shouldIntercept(request.url());</span>
<span class="line-added">1086 }</span>
<span class="line-added">1087 </span>
<span class="line-added">1088 bool InspectorNetworkAgent::shouldInterceptResponse(const ResourceResponse&amp; response)</span>
<span class="line-added">1089 {</span>
<span class="line-added">1090     if (!m_interceptionEnabled)</span>
<span class="line-added">1091         return false;</span>
<span class="line-added">1092 </span>
<span class="line-added">1093     return shouldIntercept(response.url());</span>
<span class="line-added">1094 }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096 void InspectorNetworkAgent::interceptResponse(const ResourceResponse&amp; response, unsigned long identifier, CompletionHandler&lt;void(const ResourceResponse&amp;, RefPtr&lt;SharedBuffer&gt;)&gt;&amp;&amp; handler)</span>
<span class="line-added">1097 {</span>
<span class="line-added">1098     ASSERT(m_enabled);</span>
<span class="line-added">1099     ASSERT(m_interceptionEnabled);</span>
<span class="line-added">1100 </span>
<span class="line-added">1101     String requestId = IdentifiersFactory::requestId(identifier);</span>
<span class="line-added">1102     if (m_pendingInterceptResponses.contains(requestId)) {</span>
<span class="line-added">1103         ASSERT_NOT_REACHED();</span>
<span class="line-added">1104         handler(response, nullptr);</span>
<span class="line-added">1105         return;</span>
<span class="line-added">1106     }</span>
<span class="line-added">1107 </span>
<span class="line-added">1108     m_pendingInterceptResponses.set(requestId, makeUnique&lt;PendingInterceptResponse&gt;(response, WTFMove(handler)));</span>
<span class="line-added">1109 </span>
<span class="line-added">1110     m_frontendDispatcher-&gt;responseIntercepted(requestId, buildObjectForResourceResponse(response, nullptr));</span>
<span class="line-added">1111 }</span>
<span class="line-added">1112 </span>
<span class="line-added">1113 void InspectorNetworkAgent::interceptContinue(ErrorString&amp; errorString, const String&amp; requestId)</span>
<span class="line-added">1114 {</span>
<span class="line-added">1115     auto pendingInterceptResponse = m_pendingInterceptResponses.take(requestId);</span>
<span class="line-added">1116     if (!pendingInterceptResponse) {</span>
<span class="line-added">1117         errorString = &quot;Missing pending intercept response for given requestId&quot;_s;</span>
<span class="line-added">1118         return;</span>
<span class="line-added">1119     }</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added">1122 }</span>
<span class="line-added">1123 </span>
<span class="line-added">1124 void InspectorNetworkAgent::interceptWithResponse(ErrorString&amp; errorString, const String&amp; requestId, const String&amp; content, bool base64Encoded, const String* mimeType, const int* status, const String* statusText, const JSON::Object* headers)</span>
<span class="line-added">1125 {</span>
<span class="line-added">1126     auto pendingInterceptResponse = m_pendingInterceptResponses.take(requestId);</span>
<span class="line-added">1127     if (!pendingInterceptResponse) {</span>
<span class="line-added">1128         errorString = &quot;Missing pending intercept response for given requestId&quot;_s;</span>
<span class="line-added">1129         return;</span>
<span class="line-added">1130     }</span>
<span class="line-added">1131 </span>
<span class="line-added">1132     ResourceResponse overrideResponse(pendingInterceptResponse-&gt;originalResponse());</span>
<span class="line-added">1133     overrideResponse.setSource(ResourceResponse::Source::InspectorOverride);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135     if (status)</span>
<span class="line-added">1136         overrideResponse.setHTTPStatusCode(*status);</span>
<span class="line-added">1137     if (statusText)</span>
<span class="line-added">1138         overrideResponse.setHTTPStatusText(*statusText);</span>
<span class="line-added">1139     if (mimeType)</span>
<span class="line-added">1140         overrideResponse.setMimeType(*mimeType);</span>
<span class="line-added">1141     if (headers) {</span>
<span class="line-added">1142         HTTPHeaderMap explicitHeaders;</span>
<span class="line-added">1143         for (auto&amp; header : *headers) {</span>
<span class="line-added">1144             String headerValue;</span>
<span class="line-added">1145             if (header.value-&gt;asString(headerValue))</span>
<span class="line-added">1146                 explicitHeaders.add(header.key, headerValue);</span>
<span class="line-added">1147         }</span>
<span class="line-added">1148         overrideResponse.setHTTPHeaderFields(WTFMove(explicitHeaders));</span>
<span class="line-added">1149         overrideResponse.setHTTPHeaderField(HTTPHeaderName::ContentType, overrideResponse.mimeType());</span>
<span class="line-added">1150     }</span>
<span class="line-added">1151 </span>
<span class="line-added">1152     RefPtr&lt;SharedBuffer&gt; overrideData;</span>
<span class="line-added">1153     if (base64Encoded) {</span>
<span class="line-added">1154         Vector&lt;uint8_t&gt; buffer;</span>
<span class="line-added">1155         if (!base64Decode(content, buffer)) {</span>
<span class="line-added">1156             errorString = &quot;Unable to decode given content&quot;_s;</span>
<span class="line-added">1157             pendingInterceptResponse-&gt;respondWithOriginalResponse();</span>
<span class="line-added">1158             return;</span>
<span class="line-added">1159         }</span>
<span class="line-added">1160         overrideData = SharedBuffer::create(WTFMove(buffer));</span>
<span class="line-added">1161     } else</span>
<span class="line-added">1162         overrideData = SharedBuffer::create(content.utf8().data(), content.utf8().length());</span>
<span class="line-added">1163 </span>
<span class="line-added">1164     pendingInterceptResponse-&gt;respond(overrideResponse, overrideData);</span>
<span class="line-added">1165 }</span>
<span class="line-added">1166 </span>
1167 bool InspectorNetworkAgent::shouldTreatAsText(const String&amp; mimeType)
1168 {
1169     return startsWithLettersIgnoringASCIICase(mimeType, &quot;text/&quot;)
1170         || MIMETypeRegistry::isSupportedJavaScriptMIMEType(mimeType)
1171         || MIMETypeRegistry::isSupportedJSONMIMEType(mimeType)
1172         || MIMETypeRegistry::isXMLMIMEType(mimeType)
1173         || MIMETypeRegistry::isTextMediaPlaylistMIMEType(mimeType);
1174 }
1175 
1176 Ref&lt;TextResourceDecoder&gt; InspectorNetworkAgent::createTextDecoder(const String&amp; mimeType, const String&amp; textEncodingName)
1177 {
1178     if (!textEncodingName.isEmpty())
1179         return TextResourceDecoder::create(&quot;text/plain&quot;_s, textEncodingName);
1180 
1181     if (MIMETypeRegistry::isTextMIMEType(mimeType))
1182         return TextResourceDecoder::create(mimeType, &quot;UTF-8&quot;);
1183     if (MIMETypeRegistry::isXMLMIMEType(mimeType)) {
1184         auto decoder = TextResourceDecoder::create(&quot;application/xml&quot;_s);
1185         decoder-&gt;useLenientXMLDecoding();
1186         return decoder;
1187     }
1188 
1189     return TextResourceDecoder::create(&quot;text/plain&quot;_s, &quot;UTF-8&quot;);
1190 }
1191 
1192 Optional&lt;String&gt; InspectorNetworkAgent::textContentForCachedResource(CachedResource&amp; cachedResource)
1193 {
1194     if (!InspectorNetworkAgent::shouldTreatAsText(cachedResource.mimeType()))
1195         return WTF::nullopt;
1196 
1197     String result;
1198     bool base64Encoded;
1199     if (InspectorNetworkAgent::cachedResourceContent(cachedResource, &amp;result, &amp;base64Encoded)) {
1200         ASSERT(!base64Encoded);
1201         return result;
1202     }
1203 
1204     return WTF::nullopt;
1205 }
1206 
1207 bool InspectorNetworkAgent::cachedResourceContent(CachedResource&amp; resource, String* result, bool* base64Encoded)
1208 {
1209     ASSERT(result);
1210     ASSERT(base64Encoded);
1211 
1212     if (!resource.encodedSize()) {
1213         *base64Encoded = false;
1214         *result = String();
1215         return true;
1216     }
1217 
1218     switch (resource.type()) {
1219     case CachedResource::Type::CSSStyleSheet:
1220         *base64Encoded = false;
1221         *result = downcast&lt;CachedCSSStyleSheet&gt;(resource).sheetText();
1222         // The above can return a null String if the MIME type is invalid.
1223         return !result-&gt;isNull();
1224     case CachedResource::Type::Script:
1225         *base64Encoded = false;
1226         *result = downcast&lt;CachedScript&gt;(resource).script().toString();
1227         return true;
1228     default:
1229         auto* buffer = resource.resourceBuffer();
1230         if (!buffer)
1231             return false;
1232 
1233         if (InspectorNetworkAgent::shouldTreatAsText(resource.mimeType())) {
1234             auto decoder = InspectorNetworkAgent::createTextDecoder(resource.mimeType(), resource.response().textEncodingName());
1235             *base64Encoded = false;
1236             *result = decoder-&gt;decodeAndFlush(buffer-&gt;data(), buffer-&gt;size());
1237             return true;
1238         }
1239 
1240         *base64Encoded = true;
1241         *result = base64Encode(buffer-&gt;data(), buffer-&gt;size());
1242         return true;
1243     }
1244 }
1245 
1246 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; requestId, const String&amp; frameId, const String&amp; url, int matchesCount)
1247 {
1248     auto searchResult = Inspector::Protocol::Page::SearchResult::create()
1249         .setUrl(url)
1250         .setFrameId(frameId)
1251         .setMatchesCount(matchesCount)
1252         .release();
1253     searchResult-&gt;setRequestId(requestId);
1254     return searchResult;
1255 }
1256 
1257 static Optional&lt;String&gt; textContentForResourceData(const NetworkResourcesData::ResourceData&amp; resourceData)
1258 {
1259     if (resourceData.hasContent() &amp;&amp; !resourceData.base64Encoded())
1260         return resourceData.content();
1261 
1262     if (resourceData.cachedResource())
1263         return InspectorNetworkAgent::textContentForCachedResource(*resourceData.cachedResource());
1264 
1265     return WTF::nullopt;
1266 }
1267 
1268 void InspectorNetworkAgent::searchOtherRequests(const JSC::Yarr::RegularExpression&amp; regex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
1269 {
1270     Vector&lt;NetworkResourcesData::ResourceData*&gt; resources = m_resourcesData-&gt;resources();
1271     for (auto* resourceData : resources) {
1272         if (auto textContent = textContentForResourceData(*resourceData)) {
1273             int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, resourceData-&gt;content());
1274             if (matchesCount)
1275                 result-&gt;addItem(buildObjectForSearchResult(resourceData-&gt;requestId(), resourceData-&gt;frameId(), resourceData-&gt;url(), matchesCount));
1276         }
1277     }
1278 }
1279 
1280 void InspectorNetworkAgent::searchInRequest(ErrorString&amp; errorString, const String&amp; requestId, const String&amp; query, bool caseSensitive, bool isRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
1281 {
1282     NetworkResourcesData::ResourceData const* resourceData = m_resourcesData-&gt;data(requestId);
1283     if (!resourceData) {
1284         errorString = &quot;Missing resource for given requestId&quot;_s;
1285         return;
1286     }
1287 
1288     if (!resourceData-&gt;hasContent()) {
1289         errorString = &quot;Missing content of resource for given requestId&quot;_s;
1290         return;
1291     }
1292 
1293     results = ContentSearchUtilities::searchInTextByLines(resourceData-&gt;content(), query, caseSensitive, isRegex);
1294 }
1295 
1296 void InspectorNetworkAgent::mainFrameNavigated(DocumentLoader&amp; loader)
1297 {
1298     m_resourcesData-&gt;clear(loaderIdentifier(&amp;loader));
1299 }
1300 
1301 } // namespace WebCore
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
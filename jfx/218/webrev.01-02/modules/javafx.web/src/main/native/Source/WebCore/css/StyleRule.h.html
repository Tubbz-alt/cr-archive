<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  * (C) 2002-2003 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2002, 2006, 2008, 2012, 2013 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSSelectorList.h&quot;
 25 #include &quot;CompiledSelector.h&quot;
 26 #include &quot;StyleProperties.h&quot;
 27 #include &quot;StyleRuleType.h&quot;
 28 #include &lt;wtf/RefPtr.h&gt;
 29 #include &lt;wtf/TypeCasts.h&gt;
 30 #include &lt;wtf/UniqueArray.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class CSSRule;
 35 class CSSStyleRule;
 36 class CSSStyleSheet;
 37 class MediaQuerySet;
 38 class MutableStyleProperties;
 39 class StyleRuleKeyframe;
 40 class StyleProperties;
 41 class StyleRuleKeyframes;
 42 
 43 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRuleBase);
 44 class StyleRuleBase : public WTF::RefCountedBase {
 45     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRuleBase);
 46 public:
 47     StyleRuleType type() const { return static_cast&lt;StyleRuleType&gt;(m_type); }
 48 
 49     bool isCharsetRule() const { return type() == StyleRuleType::Charset; }
 50     bool isFontFaceRule() const { return type() == StyleRuleType::FontFace; }
 51     bool isKeyframesRule() const { return type() == StyleRuleType::Keyframes; }
 52     bool isKeyframeRule() const { return type() == StyleRuleType::Keyframe; }
 53     bool isNamespaceRule() const { return type() == StyleRuleType::Namespace; }
 54     bool isMediaRule() const { return type() == StyleRuleType::Media; }
 55     bool isPageRule() const { return type() == StyleRuleType::Page; }
 56     bool isStyleRule() const { return type() == StyleRuleType::Style; }
 57     bool isSupportsRule() const { return type() == StyleRuleType::Supports; }
 58 #if ENABLE(CSS_DEVICE_ADAPTATION)
 59     bool isViewportRule() const { return type() == StyleRuleType::Viewport; }
 60 #endif
 61     bool isImportRule() const { return type() == StyleRuleType::Import; }
 62 
 63     Ref&lt;StyleRuleBase&gt; copy() const;
 64 
 65     void deref() const
 66     {
 67         if (derefBase())
 68             const_cast&lt;StyleRuleBase&amp;&gt;(*this).destroy();
 69     }
 70 
 71     // FIXME: There shouldn&#39;t be any need for the null parent version.
 72     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet = nullptr) const;
 73     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSRule* parentRule) const;
 74 
 75 protected:
 76     StyleRuleBase(StyleRuleType type, bool hasDocumentSecurityOrigin = false)
 77         : m_type(static_cast&lt;unsigned&gt;(type))
 78         , m_hasDocumentSecurityOrigin(hasDocumentSecurityOrigin)
 79     {
 80     }
 81 
 82     StyleRuleBase(const StyleRuleBase&amp; o)
 83         : WTF::RefCountedBase()
 84         , m_type(o.m_type)
 85         , m_hasDocumentSecurityOrigin(o.m_hasDocumentSecurityOrigin)
 86     {
 87     }
 88 
 89     ~StyleRuleBase() = default;
 90 
 91     bool hasDocumentSecurityOrigin() const { return m_hasDocumentSecurityOrigin; }
 92 
 93 private:
 94     WEBCORE_EXPORT void destroy();
 95 
 96     Ref&lt;CSSRule&gt; createCSSOMWrapper(CSSStyleSheet* parentSheet, CSSRule* parentRule) const;
 97 
 98     unsigned m_type : 5; // StyleRuleType
 99     // This is only needed to support getMatchedCSSRules.
100     unsigned m_hasDocumentSecurityOrigin : 1;
101 };
102 
103 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRule);
104 class StyleRule final : public StyleRuleBase {
105     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StyleRule);
106 public:
107     static Ref&lt;StyleRule&gt; create(Ref&lt;StylePropertiesBase&gt;&amp;&amp; properties, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp; selectors)
108     {
109         return adoptRef(*new StyleRule(WTFMove(properties), hasDocumentSecurityOrigin, WTFMove(selectors)));
110     }
111 
112     ~StyleRule();
113 
114     const CSSSelectorList&amp; selectorList() const { return m_selectorList; }
115 
116     const StyleProperties&amp; properties() const;
117     MutableStyleProperties&amp; mutableProperties();
118     const StyleProperties* propertiesWithoutDeferredParsing() const;
119 
120     using StyleRuleBase::hasDocumentSecurityOrigin;
121 
122     void wrapperAdoptSelectorList(CSSSelectorList&amp;&amp; selectors)
123     {
124         m_selectorList = WTFMove(selectors);
125 #if ENABLE(CSS_SELECTOR_JIT)
126         m_compiledSelectors = nullptr;
127 #endif
128     }
129 
130     Ref&lt;StyleRule&gt; copy() const { return adoptRef(*new StyleRule(*this)); }
131 
132     Vector&lt;RefPtr&lt;StyleRule&gt;&gt; splitIntoMultipleRulesWithMaximumSelectorComponentCount(unsigned) const;
133 
134 #if ENABLE(CSS_SELECTOR_JIT)
135     CompiledSelector&amp; compiledSelectorForListIndex(unsigned index) const
136     {
137         if (!m_compiledSelectors)
138             m_compiledSelectors = makeUniqueArray&lt;CompiledSelector&gt;(m_selectorList.listSize());
139         return m_compiledSelectors[index];
140     }
141     void releaseCompiledSelectors() const
142     {
143         m_compiledSelectors = nullptr;
144     }
145 #endif
146 
147     static unsigned averageSizeInBytes();
148 
149 private:
150     StyleRule(Ref&lt;StylePropertiesBase&gt;&amp;&amp;, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp;);
151     StyleRule(const StyleRule&amp;);
152 
153     static Ref&lt;StyleRule&gt; createForSplitting(const Vector&lt;const CSSSelector*&gt;&amp;, Ref&lt;StyleProperties&gt;&amp;&amp;, bool hasDocumentSecurityOrigin);
154 
155     mutable Ref&lt;StylePropertiesBase&gt; m_properties;
156     CSSSelectorList m_selectorList;
157 
158 #if ENABLE(CSS_SELECTOR_JIT)
159     mutable UniqueArray&lt;CompiledSelector&gt; m_compiledSelectors;
160 #endif
161 };
162 
163 inline const StyleProperties* StyleRule::propertiesWithoutDeferredParsing() const
164 {
165     return m_properties-&gt;type() != DeferredPropertiesType ? &amp;downcast&lt;StyleProperties&gt;(m_properties.get()) : nullptr;
166 }
167 
168 class StyleRuleFontFace final : public StyleRuleBase {
169 public:
170     static Ref&lt;StyleRuleFontFace&gt; create(Ref&lt;StyleProperties&gt;&amp;&amp; properties) { return adoptRef(*new StyleRuleFontFace(WTFMove(properties))); }
171 
172     ~StyleRuleFontFace();
173 
174     const StyleProperties&amp; properties() const { return m_properties; }
175     MutableStyleProperties&amp; mutableProperties();
176 
177     Ref&lt;StyleRuleFontFace&gt; copy() const { return adoptRef(*new StyleRuleFontFace(*this)); }
178 
179 private:
180     explicit StyleRuleFontFace(Ref&lt;StyleProperties&gt;&amp;&amp;);
181     StyleRuleFontFace(const StyleRuleFontFace&amp;);
182 
183     Ref&lt;StyleProperties&gt; m_properties;
184 };
185 
186 class StyleRulePage final : public StyleRuleBase {
187 public:
188     static Ref&lt;StyleRulePage&gt; create(Ref&lt;StyleProperties&gt;&amp;&amp; properties, CSSSelectorList&amp;&amp; selectors) { return adoptRef(*new StyleRulePage(WTFMove(properties), WTFMove(selectors))); }
189 
190     ~StyleRulePage();
191 
192     const CSSSelector* selector() const { return m_selectorList.first(); }
193     const StyleProperties&amp; properties() const { return m_properties; }
194     MutableStyleProperties&amp; mutableProperties();
195 
196     void wrapperAdoptSelectorList(CSSSelectorList&amp;&amp; selectors) { m_selectorList = WTFMove(selectors); }
197 
198     Ref&lt;StyleRulePage&gt; copy() const { return adoptRef(*new StyleRulePage(*this)); }
199 
200 private:
201     explicit StyleRulePage(Ref&lt;StyleProperties&gt;&amp;&amp;, CSSSelectorList&amp;&amp;);
202     StyleRulePage(const StyleRulePage&amp;);
203 
204     Ref&lt;StyleProperties&gt; m_properties;
205     CSSSelectorList m_selectorList;
206 };
207 
208 class DeferredStyleGroupRuleList final {
209     WTF_MAKE_FAST_ALLOCATED;
210 public:
211     DeferredStyleGroupRuleList(const CSSParserTokenRange&amp;, CSSDeferredParser&amp;);
212 
213     void parseDeferredRules(Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);
214     void parseDeferredKeyframes(StyleRuleKeyframes&amp;);
215 
216 private:
217     Vector&lt;CSSParserToken&gt; m_tokens;
218     Ref&lt;CSSDeferredParser&gt; m_parser;
219 };
220 
221 class StyleRuleGroup : public StyleRuleBase {
222 public:
223     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules() const;
224     const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* childRulesWithoutDeferredParsing() const;
225 
226     void wrapperInsertRule(unsigned, Ref&lt;StyleRuleBase&gt;&amp;&amp;);
227     void wrapperRemoveRule(unsigned);
228 
229 protected:
230     StyleRuleGroup(StyleRuleType, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp;);
231     StyleRuleGroup(StyleRuleType, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp;);
232     StyleRuleGroup(const StyleRuleGroup&amp;);
233 
234 private:
235     void parseDeferredRulesIfNeeded() const;
236 
237     mutable Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; m_childRules;
238     mutable std::unique_ptr&lt;DeferredStyleGroupRuleList&gt; m_deferredRules;
239 };
240 
241 inline const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;* StyleRuleGroup::childRulesWithoutDeferredParsing() const
242 {
243     return !m_deferredRules ? &amp;m_childRules : nullptr;
244 }
245 
246 class StyleRuleMedia final : public StyleRuleGroup {
247 public:
248     static Ref&lt;StyleRuleMedia&gt; create(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
249     {
250         return adoptRef(*new StyleRuleMedia(WTFMove(media), adoptRules));
251     }
252 
253     static Ref&lt;StyleRuleMedia&gt; create(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp; deferredChildRules)
254     {
255         return adoptRef(*new StyleRuleMedia(WTFMove(media), WTFMove(deferredChildRules)));
256     }
257 
258     MediaQuerySet* mediaQueries() const { return m_mediaQueries.get(); }
259 
260     Ref&lt;StyleRuleMedia&gt; copy() const { return adoptRef(*new StyleRuleMedia(*this)); }
261 
262 private:
263     StyleRuleMedia(Ref&lt;MediaQuerySet&gt;&amp;&amp;, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules);
264     StyleRuleMedia(Ref&lt;MediaQuerySet&gt;&amp;&amp;, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp;);
265     StyleRuleMedia(const StyleRuleMedia&amp;);
266 
267     RefPtr&lt;MediaQuerySet&gt; m_mediaQueries;
268 };
269 
270 class StyleRuleSupports final : public StyleRuleGroup {
271 public:
272     static Ref&lt;StyleRuleSupports&gt; create(const String&amp; conditionText, bool conditionIsSupported, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
273     {
274         return adoptRef(*new StyleRuleSupports(conditionText, conditionIsSupported, adoptRules));
275     }
276 
277     static Ref&lt;StyleRuleSupports&gt; create(const String&amp; conditionText, bool conditionIsSupported, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp; deferredChildRules)
278     {
279         return adoptRef(*new StyleRuleSupports(conditionText, conditionIsSupported, WTFMove(deferredChildRules)));
280     }
281 
282     String conditionText() const { return m_conditionText; }
283     bool conditionIsSupported() const { return m_conditionIsSupported; }
284     Ref&lt;StyleRuleSupports&gt; copy() const { return adoptRef(*new StyleRuleSupports(*this)); }
285 
286 private:
287     StyleRuleSupports(const String&amp; conditionText, bool conditionIsSupported, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules);
288     StyleRuleSupports(const String&amp; conditionText, bool conditionIsSupported, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp;);
289 
290     StyleRuleSupports(const StyleRuleSupports&amp;);
291 
292     String m_conditionText;
293     bool m_conditionIsSupported;
294 };
295 
296 #if ENABLE(CSS_DEVICE_ADAPTATION)
297 class StyleRuleViewport final : public StyleRuleBase {
298 public:
299     static Ref&lt;StyleRuleViewport&gt; create(Ref&lt;StyleProperties&gt;&amp;&amp; properties) { return adoptRef(*new StyleRuleViewport(WTFMove(properties))); }
300 
301     ~StyleRuleViewport();
302 
303     const StyleProperties&amp; properties() const { return m_properties.get(); }
304     MutableStyleProperties&amp; mutableProperties();
305 
306     Ref&lt;StyleRuleViewport&gt; copy() const { return adoptRef(*new StyleRuleViewport(*this)); }
307 
308 private:
309     explicit StyleRuleViewport(Ref&lt;StyleProperties&gt;&amp;&amp;);
310     StyleRuleViewport(const StyleRuleViewport&amp;);
311 
312     Ref&lt;StyleProperties&gt; m_properties;
313 };
314 #endif // ENABLE(CSS_DEVICE_ADAPTATION)
315 
316 // This is only used by the CSS parser.
317 class StyleRuleCharset final : public StyleRuleBase {
318 public:
319     static Ref&lt;StyleRuleCharset&gt; create() { return adoptRef(*new StyleRuleCharset()); }
320 
321     ~StyleRuleCharset();
322 
323     Ref&lt;StyleRuleCharset&gt; copy() const { return adoptRef(*new StyleRuleCharset(*this)); }
324 
325 private:
326     explicit StyleRuleCharset();
327     StyleRuleCharset(const StyleRuleCharset&amp;);
328 };
329 
330 class StyleRuleNamespace final : public StyleRuleBase {
331 public:
332     static Ref&lt;StyleRuleNamespace&gt; create(AtomString prefix, AtomString uri)
333     {
334         return adoptRef(*new StyleRuleNamespace(prefix, uri));
335     }
336 
337     ~StyleRuleNamespace();
338 
339     Ref&lt;StyleRuleNamespace&gt; copy() const { return adoptRef(*new StyleRuleNamespace(*this)); }
340 
341     AtomString prefix() const { return m_prefix; }
342     AtomString uri() const { return m_uri; }
343 
344 private:
345     StyleRuleNamespace(AtomString prefix, AtomString uri);
346     StyleRuleNamespace(const StyleRuleNamespace&amp;);
347 
348     AtomString m_prefix;
349     AtomString m_uri;
350 };
351 
352 } // namespace WebCore
353 
354 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRule)
355     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isStyleRule(); }
356 SPECIALIZE_TYPE_TRAITS_END()
357 
358 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleFontFace)
359     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isFontFaceRule(); }
360 SPECIALIZE_TYPE_TRAITS_END()
361 
362 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleMedia)
363     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isMediaRule(); }
364 SPECIALIZE_TYPE_TRAITS_END()
365 
366 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRulePage)
367     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isPageRule(); }
368 SPECIALIZE_TYPE_TRAITS_END()
369 
370 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleSupports)
371     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isSupportsRule(); }
372 SPECIALIZE_TYPE_TRAITS_END()
373 
374 #if ENABLE(CSS_DEVICE_ADAPTATION)
375 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleViewport)
376     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isViewportRule(); }
377 SPECIALIZE_TYPE_TRAITS_END()
378 #endif // ENABLE(CSS_DEVICE_ADAPTATION)
379 
380 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleNamespace)
381     static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isNamespaceRule(); }
382 SPECIALIZE_TYPE_TRAITS_END()
383 
384 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleKeyframe)
385 static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isKeyframeRule(); }
386 SPECIALIZE_TYPE_TRAITS_END()
387 
388 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::StyleRuleCharset)
389 static bool isType(const WebCore::StyleRuleBase&amp; rule) { return rule.isCharsetRule(); }
390 SPECIALIZE_TYPE_TRAITS_END()
391 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLDepthTexture.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLDrawBuffers.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLDrawBuffers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 #include &quot;WebGLDrawBuffers.h&quot;
 30 
<span class="line-modified"> 31 #include &quot;Extensions3D.h&quot;</span>
 32 
 33 namespace WebCore {
 34 
 35 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
 36     : WebGLExtension(context)
 37 {

 38 }
 39 
 40 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 41 
 42 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
 43 {
 44     return WebGLExtension::WebGLDrawBuffersName;
 45 }
 46 
 47 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
 48 {
<span class="line-modified"> 49     return context.graphicsContext3D()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)</span>



 50         &amp;&amp; satisfiesWebGLRequirements(context);

 51 }
 52 
<span class="line-modified"> 53 void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GC3Denum&gt;&amp; buffers)</span>
 54 {
 55     if (m_context.isContextLost())
 56         return;
<span class="line-modified"> 57     GC3Dsizei n = buffers.size();</span>
<span class="line-modified"> 58     const GC3Denum* bufs = buffers.data();</span>
 59     if (!m_context.m_framebufferBinding) {
 60         if (n != 1) {
<span class="line-modified"> 61             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);</span>
 62             return;
 63         }
<span class="line-modified"> 64         if (bufs[0] != GraphicsContext3D::BACK &amp;&amp; bufs[0] != GraphicsContext3D::NONE) {</span>
<span class="line-modified"> 65             m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);</span>
 66             return;
 67         }
 68         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified"> 69         GC3Denum value = (bufs[0] == GraphicsContext3D::BACK) ? GraphicsContext3D::COLOR_ATTACHMENT0 : GraphicsContext3D::NONE;</span>
<span class="line-modified"> 70         m_context.graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
 71         m_context.setBackDrawBuffer(bufs[0]);
 72     } else {
 73         if (n &gt; m_context.getMaxDrawBuffers()) {
<span class="line-modified"> 74             m_context.synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);</span>
 75             return;
 76         }
<span class="line-modified"> 77         for (GC3Dsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified"> 78             if (bufs[i] != GraphicsContext3D::NONE &amp;&amp; bufs[i] != static_cast&lt;GC3Denum&gt;(Extensions3D::COLOR_ATTACHMENT0_EXT + i)) {</span>
<span class="line-modified"> 79                 m_context.synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);</span>
 80                 return;
 81             }
 82         }
 83         m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
 84     }
 85 }
 86 
 87 // static
 88 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
 89 {
<span class="line-modified"> 90     GraphicsContext3D* context = webglContext.graphicsContext3D();</span>
 91 
 92     // This is called after we make sure GL_EXT_draw_buffers is supported.
<span class="line-modified"> 93     GC3Dint maxDrawBuffers = 0;</span>
<span class="line-modified"> 94     GC3Dint maxColorAttachments = 0;</span>
<span class="line-modified"> 95     context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);</span>
<span class="line-modified"> 96     context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);</span>
 97     if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
 98         return false;
 99 
<span class="line-modified">100     Platform3DObject fbo = context-&gt;createFramebuffer();</span>
<span class="line-modified">101     context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, fbo);</span>
102 
103     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
104     bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
105         || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
106     bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
107         || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
<span class="line-modified">108     Platform3DObject depthStencil = 0;</span>
109     if (supportsDepthStencil) {
110         depthStencil = context-&gt;createTexture();
<span class="line-modified">111         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depthStencil);</span>
<span class="line-modified">112         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_STENCIL, 1, 1, 0, GraphicsContext3D::DEPTH_STENCIL, GraphicsContext3D::UNSIGNED_INT_24_8, buffer);</span>
113     }
<span class="line-modified">114     Platform3DObject depth = 0;</span>
115     if (supportsDepth) {
116         depth = context-&gt;createTexture();
<span class="line-modified">117         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, depth);</span>
<span class="line-modified">118         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::DEPTH_COMPONENT, 1, 1, 0, GraphicsContext3D::DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT, buffer);</span>
119     }
120 
<span class="line-modified">121     Vector&lt;Platform3DObject&gt; colors;</span>
122     bool ok = true;
<span class="line-modified">123     GC3Dint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);</span>
<span class="line-modified">124     for (GC3Dint i = 0; i &lt; maxAllowedBuffers; ++i) {</span>
<span class="line-modified">125         Platform3DObject color = context-&gt;createTexture();</span>
126         colors.append(color);
<span class="line-modified">127         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, color);</span>
<span class="line-modified">128         context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1, 0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, buffer);</span>
<span class="line-modified">129         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::COLOR_ATTACHMENT0 + i, GraphicsContext3D::TEXTURE_2D, color, 0);</span>
<span class="line-modified">130         if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
131             ok = false;
132             break;
133         }
134         if (supportsDepth) {
<span class="line-modified">135             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depth, 0);</span>
<span class="line-modified">136             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
137                 ok = false;
138                 break;
139             }
<span class="line-modified">140             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
141         }
142         if (supportsDepthStencil) {
<span class="line-modified">143             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">144             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">145             if (context-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
146                 ok = false;
147                 break;
148             }
<span class="line-modified">149             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
<span class="line-modified">150             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::TEXTURE_2D, 0, 0);</span>
151         }
152     }
153 
154     webglContext.restoreCurrentFramebuffer();
155     context-&gt;deleteFramebuffer(fbo);
156     webglContext.restoreCurrentTexture2D();
157     if (supportsDepth)
158         context-&gt;deleteTexture(depth);
159     if (supportsDepthStencil)
160         context-&gt;deleteTexture(depthStencil);
161     for (auto&amp; color : colors)
162         context-&gt;deleteTexture(color);
163     return ok;
164 }
165 
166 } // namespace WebCore
167 
168 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 #include &quot;WebGLDrawBuffers.h&quot;
 30 
<span class="line-modified"> 31 #include &quot;ExtensionsGL.h&quot;</span>
 32 
 33 namespace WebCore {
 34 
 35 WebGLDrawBuffers::WebGLDrawBuffers(WebGLRenderingContextBase&amp; context)
 36     : WebGLExtension(context)
 37 {
<span class="line-added"> 38     context.graphicsContextGL()-&gt;getExtensions().ensureEnabled(&quot;GL_EXT_draw_buffers&quot;);</span>
 39 }
 40 
 41 WebGLDrawBuffers::~WebGLDrawBuffers() = default;
 42 
 43 WebGLExtension::ExtensionName WebGLDrawBuffers::getName() const
 44 {
 45     return WebGLExtension::WebGLDrawBuffersName;
 46 }
 47 
 48 bool WebGLDrawBuffers::supported(WebGLRenderingContextBase&amp; context)
 49 {
<span class="line-modified"> 50 #if USE(ANGLE)</span>
<span class="line-added"> 51     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;);</span>
<span class="line-added"> 52 #else</span>
<span class="line-added"> 53     return context.graphicsContextGL()-&gt;getExtensions().supports(&quot;GL_EXT_draw_buffers&quot;)</span>
 54         &amp;&amp; satisfiesWebGLRequirements(context);
<span class="line-added"> 55 #endif</span>
 56 }
 57 
<span class="line-modified"> 58 void WebGLDrawBuffers::drawBuffersWEBGL(const Vector&lt;GCGLenum&gt;&amp; buffers)</span>
 59 {
 60     if (m_context.isContextLost())
 61         return;
<span class="line-modified"> 62     GCGLsizei n = buffers.size();</span>
<span class="line-modified"> 63     const GCGLenum* bufs = buffers.data();</span>
 64     if (!m_context.m_framebufferBinding) {
 65         if (n != 1) {
<span class="line-modified"> 66             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than one buffer&quot;);</span>
 67             return;
 68         }
<span class="line-modified"> 69         if (bufs[0] != GraphicsContextGL::BACK &amp;&amp; bufs[0] != GraphicsContextGL::NONE) {</span>
<span class="line-modified"> 70             m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;BACK or NONE&quot;);</span>
 71             return;
 72         }
 73         // Because the backbuffer is simulated on all current WebKit ports, we need to change BACK to COLOR_ATTACHMENT0.
<span class="line-modified"> 74         GCGLenum value = (bufs[0] == GraphicsContextGL::BACK) ? GraphicsContextGL::COLOR_ATTACHMENT0 : GraphicsContextGL::NONE;</span>
<span class="line-modified"> 75         m_context.graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(1, &amp;value);</span>
 76         m_context.setBackDrawBuffer(bufs[0]);
 77     } else {
 78         if (n &gt; m_context.getMaxDrawBuffers()) {
<span class="line-modified"> 79             m_context.synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;drawBuffersWEBGL&quot;, &quot;more than max draw buffers&quot;);</span>
 80             return;
 81         }
<span class="line-modified"> 82         for (GCGLsizei i = 0; i &lt; n; ++i) {</span>
<span class="line-modified"> 83             if (bufs[i] != GraphicsContextGL::NONE &amp;&amp; bufs[i] != static_cast&lt;GCGLenum&gt;(ExtensionsGL::COLOR_ATTACHMENT0_EXT + i)) {</span>
<span class="line-modified"> 84                 m_context.synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawBuffersWEBGL&quot;, &quot;COLOR_ATTACHMENTi_EXT or NONE&quot;);</span>
 85                 return;
 86             }
 87         }
 88         m_context.m_framebufferBinding-&gt;drawBuffers(buffers);
 89     }
 90 }
 91 
 92 // static
 93 bool WebGLDrawBuffers::satisfiesWebGLRequirements(WebGLRenderingContextBase&amp; webglContext)
 94 {
<span class="line-modified"> 95     GraphicsContextGLOpenGL* context = webglContext.graphicsContextGL();</span>
 96 
 97     // This is called after we make sure GL_EXT_draw_buffers is supported.
<span class="line-modified"> 98     GCGLint maxDrawBuffers = 0;</span>
<span class="line-modified"> 99     GCGLint maxColorAttachments = 0;</span>
<span class="line-modified">100     context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;maxDrawBuffers);</span>
<span class="line-modified">101     context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;maxColorAttachments);</span>
102     if (maxDrawBuffers &lt; 4 || maxColorAttachments &lt; 4)
103         return false;
104 
<span class="line-modified">105     PlatformGLObject fbo = context-&gt;createFramebuffer();</span>
<span class="line-modified">106     context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, fbo);</span>
107 
108     const unsigned char buffer[4] = { 0, 0, 0, 0 }; // textures are required to be initialized for other ports.
109     bool supportsDepth = context-&gt;getExtensions().supports(&quot;GL_OES_depth_texture&quot;)
110         || context-&gt;getExtensions().supports(&quot;GL_ARB_depth_texture&quot;);
111     bool supportsDepthStencil = (context-&gt;getExtensions().supports(&quot;GL_EXT_packed_depth_stencil&quot;)
112         || context-&gt;getExtensions().supports(&quot;GL_OES_packed_depth_stencil&quot;));
<span class="line-modified">113     PlatformGLObject depthStencil = 0;</span>
114     if (supportsDepthStencil) {
115         depthStencil = context-&gt;createTexture();
<span class="line-modified">116         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depthStencil);</span>
<span class="line-modified">117         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_STENCIL, 1, 1, 0, GraphicsContextGL::DEPTH_STENCIL, GraphicsContextGL::UNSIGNED_INT_24_8, buffer);</span>
118     }
<span class="line-modified">119     PlatformGLObject depth = 0;</span>
120     if (supportsDepth) {
121         depth = context-&gt;createTexture();
<span class="line-modified">122         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, depth);</span>
<span class="line-modified">123         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::DEPTH_COMPONENT, 1, 1, 0, GraphicsContextGL::DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT, buffer);</span>
124     }
125 
<span class="line-modified">126     Vector&lt;PlatformGLObject&gt; colors;</span>
127     bool ok = true;
<span class="line-modified">128     GCGLint maxAllowedBuffers = std::min(maxDrawBuffers, maxColorAttachments);</span>
<span class="line-modified">129     for (GCGLint i = 0; i &lt; maxAllowedBuffers; ++i) {</span>
<span class="line-modified">130         PlatformGLObject color = context-&gt;createTexture();</span>
131         colors.append(color);
<span class="line-modified">132         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, color);</span>
<span class="line-modified">133         context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1, 0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, buffer);</span>
<span class="line-modified">134         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::COLOR_ATTACHMENT0 + i, GraphicsContextGL::TEXTURE_2D, color, 0);</span>
<span class="line-modified">135         if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
136             ok = false;
137             break;
138         }
139         if (supportsDepth) {
<span class="line-modified">140             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depth, 0);</span>
<span class="line-modified">141             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
142                 ok = false;
143                 break;
144             }
<span class="line-modified">145             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
146         }
147         if (supportsDepthStencil) {
<span class="line-modified">148             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">149             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, depthStencil, 0);</span>
<span class="line-modified">150             if (context-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
151                 ok = false;
152                 break;
153             }
<span class="line-modified">154             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
<span class="line-modified">155             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::TEXTURE_2D, 0, 0);</span>
156         }
157     }
158 
159     webglContext.restoreCurrentFramebuffer();
160     context-&gt;deleteFramebuffer(fbo);
161     webglContext.restoreCurrentTexture2D();
162     if (supportsDepth)
163         context-&gt;deleteTexture(depth);
164     if (supportsDepthStencil)
165         context-&gt;deleteTexture(depthStencil);
166     for (auto&amp; color : colors)
167         context-&gt;deleteTexture(color);
168     return ok;
169 }
170 
171 } // namespace WebCore
172 
173 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLDepthTexture.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLDrawBuffers.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
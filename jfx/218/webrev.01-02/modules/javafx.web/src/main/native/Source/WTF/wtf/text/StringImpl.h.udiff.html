<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringImpl.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringToIntegerConversion.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,8 +1,8 @@</span>
  /*
   * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
<span class="udiff-line-modified-removed">-  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2005-2020 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2009 Google Inc. All rights reserved.
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -24,12 +24,14 @@</span>
  
  #include &lt;limits.h&gt;
  #include &lt;unicode/ustring.h&gt;
  #include &lt;wtf/ASCIICType.h&gt;
  #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/DebugHeap.h&gt;</span>
  #include &lt;wtf/Expected.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/Packed.h&gt;</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/Vector.h&gt;
  #include &lt;wtf/text/ASCIIFastPath.h&gt;
  #include &lt;wtf/text/ConversionMode.h&gt;
  #include &lt;wtf/text/StringCommon.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -92,11 +94,11 @@</span>
      }
  
      void removeString(StringImpl&amp;);
      void printStats();
  
<span class="udiff-line-modified-removed">-     static const unsigned s_printStringStatsFrequency = 5000;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned s_printStringStatsFrequency = 5000;</span>
      static std::atomic&lt;unsigned&gt; s_stringRemovesTillPrintStats;
  
      std::atomic&lt;unsigned&gt; m_refCalls;
      std::atomic&lt;unsigned&gt; m_derefCalls;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -158,12 +160,14 @@</span>
  // The actual string inside a StringImpl is immutable, so you can&#39;t modify a string using a StringImpl&amp;.
  // We could mark every member function const and always use &quot;const StringImpl&amp;&quot; and &quot;const StringImpl*&quot;.
  // Or we could say that &quot;const&quot; doesn&#39;t make sense at all and use &quot;StringImpl&amp;&quot; and &quot;StringImpl*&quot; everywhere.
  // Right now we use a mix of both, which makes code more confusing and has no benefit.
  
<span class="udiff-line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);</span>
  class StringImpl : private StringImplShape {
<span class="udiff-line-modified-removed">-     WTF_MAKE_NONCOPYABLE(StringImpl); WTF_MAKE_FAST_ALLOCATED;</span>
<span class="udiff-line-modified-added">+     WTF_MAKE_NONCOPYABLE(StringImpl);</span>
<span class="udiff-line-added">+     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(StringImpl);</span>
  
      friend class AtomStringImpl;
      friend class JSC::LLInt::Data;
      friend class JSC::LLIntOffsetsExtractor;
      friend class PrivateSymbolImpl;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -185,10 +189,11 @@</span>
  
      static constexpr unsigned MaxLength = StringImplShape::MaxLength;
  
      // The bottom 6 bits in the hash are flags.
      static constexpr const unsigned s_flagCount = 6;
<span class="udiff-line-added">+ </span>
  private:
      static constexpr const unsigned s_flagMask = (1u &lt;&lt; s_flagCount) - 1;
      static_assert(s_flagCount &lt;= StringHasher::flagCount, &quot;StringHasher reserves enough bits for StringImpl flags&quot;);
      static constexpr const unsigned s_flagStringKindCount = 4;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,12 +216,12 @@</span>
  
      // Create a normal 16-bit string with internal storage (BufferInternal).
      explicit StringImpl(unsigned length);
  
      // Create a StringImpl adopting ownership of the provided buffer (BufferOwned).
<span class="udiff-line-modified-removed">-     StringImpl(MallocPtr&lt;LChar&gt;, unsigned length);</span>
<span class="udiff-line-modified-removed">-     StringImpl(MallocPtr&lt;UChar&gt;, unsigned length);</span>
<span class="udiff-line-modified-added">+     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;LChar, Malloc&gt;, unsigned length);</span>
<span class="udiff-line-modified-added">+     template&lt;typename Malloc&gt; StringImpl(MallocPtr&lt;UChar, Malloc&gt;, unsigned length);</span>
      enum ConstructWithoutCopyingTag { ConstructWithoutCopying };
      StringImpl(const UChar*, unsigned length, ConstructWithoutCopyingTag);
      StringImpl(const LChar*, unsigned length, ConstructWithoutCopyingTag);
  
      // Used to create new strings that are a substring of an existing StringImpl (BufferSubstring).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -248,10 +253,12 @@</span>
      WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createWithoutCopying(const LChar*, unsigned length);
      WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, LChar*&amp;);
      WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createUninitialized(unsigned length, UChar*&amp;);
      template&lt;typename CharacterType&gt; static RefPtr&lt;StringImpl&gt; tryCreateUninitialized(unsigned length, CharacterType*&amp;);
  
<span class="udiff-line-added">+     WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; createStaticStringImpl(const char*, unsigned length);</span>
<span class="udiff-line-added">+ </span>
      // Reallocate the StringImpl. The originalString must be only owned by the Ref,
      // and the buffer ownership must be BufferInternal. Just like the input pointer of realloc(),
      // the originalString can&#39;t be used after this function.
      static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data);
      static Ref&lt;StringImpl&gt; reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -263,12 +270,12 @@</span>
      static constexpr unsigned flagIsAtom() { return s_hashFlagStringKindIsAtom; }
      static constexpr unsigned flagIsSymbol() { return s_hashFlagStringKindIsSymbol; }
      static constexpr unsigned maskStringKind() { return s_hashMaskStringKind; }
      static unsigned dataOffset() { return OBJECT_OFFSETOF(StringImpl, m_data8); }
  
<span class="udiff-line-modified-removed">-     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">-     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp;);</span>
<span class="udiff-line-modified-added">+     template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+     static Ref&lt;StringImpl&gt; adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp;);</span>
  
      WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;UChar&gt;&amp;&amp;);
      WTF_EXPORT_PRIVATE static Ref&lt;StringImpl&gt; adopt(StringBuffer&lt;LChar&gt;&amp;&amp;);
  
      unsigned length() const { return m_length; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -368,12 +375,11 @@</span>
  
      WTF_EXPORT_PRIVATE static StaticStringImpl s_emptyAtomString;
      ALWAYS_INLINE static StringImpl* empty() { return reinterpret_cast&lt;StringImpl*&gt;(&amp;s_emptyAtomString); }
  
      // FIXME: Does this really belong in StringImpl?
<span class="udiff-line-modified-removed">-     template&lt;typename CharacterType&gt; static void copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters);</span>
<span class="udiff-line-removed">-     static void copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters);</span>
<span class="udiff-line-modified-added">+     template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt; static void copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters);</span>
  
      // Some string features, like reference counting and the atomicity flag, are not
      // thread-safe. We achieve thread safety by isolation, giving each thread
      // its own copy of the string.
      Ref&lt;StringImpl&gt; isolatedCopy() const;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,12 +523,12 @@</span>
      template&lt;typename CharacterType&gt; static Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp;, unsigned, CharacterType*&amp;);
      template&lt;typename CharacterType&gt; static Ref&lt;StringImpl&gt; createInternal(const CharacterType*, unsigned);
      WTF_EXPORT_PRIVATE NEVER_INLINE unsigned hashSlowCase() const;
  
      // The bottom bit in the ref count indicates a static (immortal) string.
<span class="udiff-line-modified-removed">-     static const unsigned s_refCountFlagIsStaticString = 0x1;</span>
<span class="udiff-line-modified-removed">-     static const unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned s_refCountFlagIsStaticString = 0x1;</span>
<span class="udiff-line-modified-added">+     static constexpr unsigned s_refCountIncrement = 0x2; // This allows us to ref / deref without disturbing the static string flag.</span>
  
  #if STRING_STATS
      WTF_EXPORT_PRIVATE static StringStats m_stringStats;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,20 +538,20 @@</span>
  
  using StaticStringImpl = StringImpl::StaticStringImpl;
  
  static_assert(sizeof(StringImpl) == sizeof(StaticStringImpl), &quot;&quot;);
  
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  
  // StringImpls created from StaticStringImpl will ASSERT in the generic ValueCheck&lt;T&gt;::checkConsistency
  // as they are not allocated by fastMalloc. We don&#39;t currently have any way to detect that case
  // so we ignore the consistency check for all StringImpl*.
  template&lt;&gt; struct ValueCheck&lt;StringImpl*&gt; {
      static void checkConsistency(const StringImpl*) { }
  };
  
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+ #endif // ASSERT_ENABLED</span>
  
  WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const StringImpl*);
  WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*);
  inline bool equal(const StringImpl* a, const char* b) { return equal(a, reinterpret_cast&lt;const LChar*&gt;(b)); }
  WTF_EXPORT_PRIVATE bool equal(const StringImpl*, const LChar*, unsigned);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -593,10 +599,13 @@</span>
      typedef StringHash Hash;
  };
  template&lt;&gt; struct DefaultHash&lt;RefPtr&lt;StringImpl&gt;&gt; {
      typedef StringHash Hash;
  };
<span class="udiff-line-added">+ template&lt;&gt; struct DefaultHash&lt;PackedPtr&lt;StringImpl&gt;&gt; {</span>
<span class="udiff-line-added">+     using Hash = StringHash;</span>
<span class="udiff-line-added">+ };</span>
  
  #define MAKE_STATIC_STRING_IMPL(characters) ([] { \
          static StaticStringImpl impl(characters); \
          return &amp;impl; \
      }())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -856,13 +865,21 @@</span>
      ASSERT(m_length);
  
      STRING_STATS_ADD_16BIT_STRING(m_length);
  }
  
<span class="udiff-line-modified-removed">- inline StringImpl::StringImpl(MallocPtr&lt;LChar&gt; characters, unsigned length)</span>
<span class="udiff-line-modified-removed">-     : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), s_hashFlag8BitBuffer | StringNormal | BufferOwned)</span>
<span class="udiff-line-modified-added">+ template&lt;typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline StringImpl::StringImpl(MallocPtr&lt;LChar, Malloc&gt; characters, unsigned length)</span>
<span class="udiff-line-added">+     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const LChar*&gt;(nullptr), s_hashFlag8BitBuffer | StringNormal | BufferOwned)</span>
  {
<span class="udiff-line-added">+     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="udiff-line-added">+         m_data8 = characters.leakPtr();</span>
<span class="udiff-line-added">+     else {</span>
<span class="udiff-line-added">+         m_data8 = static_cast&lt;const LChar*&gt;(StringImplMalloc::malloc(length));</span>
<span class="udiff-line-added">+         memcpy((void*)m_data8, characters.get(), length);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ASSERT(m_data8);
      ASSERT(m_length);
  
      STRING_STATS_ADD_8BIT_STRING(m_length);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -883,13 +900,21 @@</span>
      ASSERT(m_length);
  
      STRING_STATS_ADD_8BIT_STRING(m_length);
  }
  
<span class="udiff-line-modified-removed">- inline StringImpl::StringImpl(MallocPtr&lt;UChar&gt; characters, unsigned length)</span>
<span class="udiff-line-modified-removed">-     : StringImplShape(s_refCountIncrement, length, characters.leakPtr(), StringNormal | BufferOwned)</span>
<span class="udiff-line-modified-added">+ template&lt;typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline StringImpl::StringImpl(MallocPtr&lt;UChar, Malloc&gt; characters, unsigned length)</span>
<span class="udiff-line-added">+     : StringImplShape(s_refCountIncrement, length, static_cast&lt;const UChar*&gt;(nullptr), StringNormal | BufferOwned)</span>
  {
<span class="udiff-line-added">+     if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="udiff-line-added">+         m_data16 = characters.leakPtr();</span>
<span class="udiff-line-added">+     else {</span>
<span class="udiff-line-added">+         m_data16 = static_cast&lt;const UChar*&gt;(StringImplMalloc::malloc(length * sizeof(UChar)));</span>
<span class="udiff-line-added">+         memcpy((void*)m_data16, characters.get(), length * sizeof(UChar));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ASSERT(m_data16);
      ASSERT(m_length);
  
      STRING_STATS_ADD_16BIT_STRING(m_length);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -943,11 +968,11 @@</span>
      }
  
      auto* ownerRep = ((rep.bufferOwnership() == BufferSubstring) ? rep.substringBuffer() : &amp;rep);
  
      // We allocate a buffer that contains both the StringImpl struct as well as the pointer to the owner string.
<span class="udiff-line-modified-removed">-     auto* stringImpl = static_cast&lt;StringImpl*&gt;(fastMalloc(substringSize));</span>
<span class="udiff-line-modified-added">+     auto* stringImpl = static_cast&lt;StringImpl*&gt;(StringImplMalloc::malloc(substringSize));</span>
      if (rep.is8Bit())
          return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data8 + offset, length, *ownerRep));
      return adoptRef(*new (NotNull, stringImpl) StringImpl(rep.m_data16 + offset, length, *ownerRep));
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -969,27 +994,38 @@</span>
      if (length &gt; maxInternalLength&lt;CharacterType&gt;()) {
          output = nullptr;
          return nullptr;
      }
      StringImpl* result;
<span class="udiff-line-modified-removed">-     if (!tryFastMalloc(allocationSize&lt;CharacterType&gt;(length)).getValue(result)) {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     result = (StringImpl*)StringImplMalloc::tryMalloc(allocationSize&lt;CharacterType&gt;(length));</span>
<span class="udiff-line-added">+     if (!result) {</span>
          output = nullptr;
          return nullptr;
      }
      output = result-&gt;tailPointer&lt;CharacterType&gt;();
  
      return constructInternal&lt;CharacterType&gt;(*result, length);
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="udiff-line-modified-removed">- inline Ref&lt;StringImpl&gt; StringImpl::adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; vector)</span>
<span class="udiff-line-modified-added">+ template&lt;typename CharacterType, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="udiff-line-modified-added">+ inline Ref&lt;StringImpl&gt; StringImpl::adopt(Vector&lt;CharacterType, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; vector)</span>
  {
      if (size_t size = vector.size()) {
          ASSERT(vector.data());
          if (size &gt; MaxLength)
              CRASH();
<span class="udiff-line-modified-removed">-         return adoptRef(*new StringImpl(vector.releaseBuffer(), size));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         if constexpr (std::is_same&lt;Malloc, StringImplMalloc&gt;::value)</span>
<span class="udiff-line-added">+             return adoptRef(*new StringImpl(vector.releaseBuffer(), size));</span>
<span class="udiff-line-added">+         else {</span>
<span class="udiff-line-added">+             // We have to copy between malloc zones.</span>
<span class="udiff-line-added">+             auto vectorBuffer = vector.releaseBuffer();</span>
<span class="udiff-line-added">+             auto stringImplBuffer = MallocPtr&lt;CharacterType, StringImplMalloc&gt;::malloc(size);</span>
<span class="udiff-line-added">+             memcpy(stringImplBuffer.get(), vectorBuffer.get(), size);</span>
<span class="udiff-line-added">+             return adoptRef(*new StringImpl(WTFMove(stringImplBuffer), size));</span>
<span class="udiff-line-added">+         }</span>
      }
      return *empty();
  }
  
  inline size_t StringImpl::cost() const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1072,23 +1108,27 @@</span>
          return;
      }
      m_refCount = tempRefCount;
  }
  
<span class="udiff-line-modified-removed">- template&lt;typename CharacterType&gt; inline void StringImpl::copyCharacters(CharacterType* destination, const CharacterType* source, unsigned numCharacters)</span>
<span class="udiff-line-modified-added">+ template&lt;typename SourceCharacterType, typename DestinationCharacterType&gt;</span>
<span class="udiff-line-added">+ inline void StringImpl::copyCharacters(DestinationCharacterType* destination, const SourceCharacterType* source, unsigned numCharacters)</span>
  {
<span class="udiff-line-modified-removed">-     if (numCharacters == 1) {</span>
<span class="udiff-line-modified-removed">-         *destination = *source;</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+     static_assert(std::is_same&lt;SourceCharacterType, LChar&gt;::value || std::is_same&lt;SourceCharacterType, UChar&gt;::value);</span>
<span class="udiff-line-modified-added">+     static_assert(std::is_same&lt;DestinationCharacterType, LChar&gt;::value || std::is_same&lt;DestinationCharacterType, UChar&gt;::value);</span>
<span class="udiff-line-modified-added">+     if constexpr (std::is_same&lt;SourceCharacterType, DestinationCharacterType&gt;::value) {</span>
<span class="udiff-line-added">+         if (numCharacters == 1) {</span>
<span class="udiff-line-added">+             *destination = *source;</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         memcpy(destination, source, numCharacters * sizeof(DestinationCharacterType));</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+         // FIXME: We should ensure that UChar -&gt; LChar copying happens when UChar only contains Latin-1.</span>
<span class="udiff-line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=205355</span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; numCharacters; ++i)</span>
<span class="udiff-line-added">+             destination[i] = source[i];</span>
      }
<span class="udiff-line-removed">-     memcpy(destination, source, numCharacters * sizeof(CharacterType));</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- ALWAYS_INLINE void StringImpl::copyCharacters(UChar* destination, const LChar* source, unsigned numCharacters)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     for (unsigned i = 0; i &lt; numCharacters; ++i)</span>
<span class="udiff-line-removed">-         destination[i] = source[i];</span>
  }
  
  inline UChar StringImpl::at(unsigned i) const
  {
      ASSERT_WITH_SECURITY_IMPLICATION(i &lt; m_length);
</pre>
<center><a href="StringImpl.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringToIntegerConversion.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
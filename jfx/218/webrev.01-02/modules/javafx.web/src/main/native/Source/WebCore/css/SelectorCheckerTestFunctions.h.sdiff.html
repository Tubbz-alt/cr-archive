<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/SelectorCheckerTestFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorPseudoClassAndCompatibilityElementMap.in.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/SelectorCheckerTestFunctions.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;FocusController.h&quot;
 30 #include &quot;FullscreenManager.h&quot;
 31 #include &quot;HTMLFrameElement.h&quot;
 32 #include &quot;HTMLIFrameElement.h&quot;
 33 #include &quot;HTMLInputElement.h&quot;
 34 #include &quot;HTMLOptionElement.h&quot;
<span class="line-modified"> 35 #include &quot;RenderScrollbar.h&quot;</span>
<span class="line-removed"> 36 #include &quot;ScrollableArea.h&quot;</span>
<span class="line-removed"> 37 #include &quot;ScrollbarTheme.h&quot;</span>
 38 #include &lt;wtf/Compiler.h&gt;
 39 
 40 #if ENABLE(ATTACHMENT_ELEMENT)
 41 #include &quot;HTMLAttachmentElement.h&quot;
 42 #endif
 43 
 44 #if ENABLE(VIDEO_TRACK)
 45 #include &quot;WebVTTElement.h&quot;
 46 #endif
 47 




 48 namespace WebCore {
 49 
 50 ALWAYS_INLINE bool isAutofilled(const Element&amp; element)
 51 {
 52     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled();
 53 }
 54 
 55 ALWAYS_INLINE bool isAutofilledStrongPassword(const Element&amp; element)
 56 {
 57     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled() &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).hasAutoFillStrongPasswordButton();
 58 }
 59 
 60 ALWAYS_INLINE bool isAutofilledStrongPasswordViewable(const Element&amp; element)
 61 {
 62     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilledAndViewable();
 63 }
 64 
 65 ALWAYS_INLINE bool matchesDefaultPseudoClass(const Element&amp; element)
 66 {
 67     return element.matchesDefaultPseudoClass();
</pre>
<hr />
<pre>
232     return false;
233 }
234 
235 ALWAYS_INLINE bool matchesReadOnlyPseudoClass(const Element&amp; element)
236 {
237     return !element.matchesReadWritePseudoClass();
238 }
239 
240 ALWAYS_INLINE bool matchesReadWritePseudoClass(const Element&amp; element)
241 {
242     return element.matchesReadWritePseudoClass();
243 }
244 
245 ALWAYS_INLINE bool matchesIndeterminatePseudoClass(const Element&amp; element)
246 {
247     return element.matchesIndeterminatePseudoClass();
248 }
249 
250 ALWAYS_INLINE bool scrollbarMatchesEnabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
251 {
<span class="line-modified">252     return context.scrollbar &amp;&amp; context.scrollbar-&gt;enabled();</span>
253 }
254 
255 ALWAYS_INLINE bool scrollbarMatchesDisabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
256 {
<span class="line-modified">257     return context.scrollbar &amp;&amp; !context.scrollbar-&gt;enabled();</span>
258 }
259 
260 ALWAYS_INLINE bool scrollbarMatchesHoverPseudoClass(const SelectorChecker::CheckingContext&amp; context)
261 {
<span class="line-modified">262     if (!context.scrollbar)</span>
263         return false;
<span class="line-modified">264     ScrollbarPart hoveredPart = context.scrollbar-&gt;hoveredPart();</span>
<span class="line-modified">265     if (context.scrollbarPart == ScrollbarBGPart)</span>

266         return hoveredPart != NoPart;
<span class="line-modified">267     if (context.scrollbarPart == TrackBGPart)</span>
268         return hoveredPart == BackTrackPart || hoveredPart == ForwardTrackPart || hoveredPart == ThumbPart;
<span class="line-modified">269     return context.scrollbarPart == hoveredPart;</span>
270 }
271 
272 ALWAYS_INLINE bool scrollbarMatchesActivePseudoClass(const SelectorChecker::CheckingContext&amp; context)
273 {
<span class="line-modified">274     if (!context.scrollbar)</span>
275         return false;
<span class="line-modified">276     ScrollbarPart pressedPart = context.scrollbar-&gt;pressedPart();</span>
<span class="line-modified">277     if (context.scrollbarPart == ScrollbarBGPart)</span>

278         return pressedPart != NoPart;
<span class="line-modified">279     if (context.scrollbarPart == TrackBGPart)</span>
280         return pressedPart == BackTrackPart || pressedPart == ForwardTrackPart || pressedPart == ThumbPart;
<span class="line-modified">281     return context.scrollbarPart == pressedPart;</span>
282 }
283 
284 ALWAYS_INLINE bool scrollbarMatchesHorizontalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
285 {
<span class="line-modified">286     return context.scrollbar &amp;&amp; context.scrollbar-&gt;orientation() == HorizontalScrollbar;</span>
287 }
288 
289 ALWAYS_INLINE bool scrollbarMatchesVerticalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
290 {
<span class="line-modified">291     return context.scrollbar &amp;&amp; context.scrollbar-&gt;orientation() == VerticalScrollbar;</span>
292 }
293 
294 ALWAYS_INLINE bool scrollbarMatchesDecrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
295 {
<span class="line-modified">296     return context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == BackTrackPart;</span>



297 }
298 
299 ALWAYS_INLINE bool scrollbarMatchesIncrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
300 {
<span class="line-modified">301     return context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart;</span>



302 }
303 
304 ALWAYS_INLINE bool scrollbarMatchesStartPseudoClass(const SelectorChecker::CheckingContext&amp; context)
305 {
<span class="line-modified">306     return context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == BackTrackPart;</span>



307 }
308 
309 ALWAYS_INLINE bool scrollbarMatchesEndPseudoClass(const SelectorChecker::CheckingContext&amp; context)
310 {
<span class="line-modified">311     return context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart;</span>



312 }
313 
314 ALWAYS_INLINE bool scrollbarMatchesDoubleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
315 {
<span class="line-modified">316     if (!context.scrollbar)</span>
317         return false;
<span class="line-modified">318     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">319     if (context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonStartPart || context.scrollbarPart == BackTrackPart)</span>

320         return buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth;
<span class="line-modified">321     if (context.scrollbarPart == BackButtonEndPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == ForwardTrackPart)</span>
322         return buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth;
323     return false;
324 }
325 
326 ALWAYS_INLINE bool scrollbarMatchesSingleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
327 {
<span class="line-modified">328     if (!context.scrollbar)</span>
329         return false;
<span class="line-modified">330     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">331     if (context.scrollbarPart == BackButtonStartPart || context.scrollbarPart == ForwardButtonEndPart || context.scrollbarPart == BackTrackPart || context.scrollbarPart == ForwardTrackPart)</span>

332         return buttonsPlacement == ScrollbarButtonsSingle;
333     return false;
334 }
335 
336 ALWAYS_INLINE bool scrollbarMatchesNoButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
337 {
<span class="line-modified">338     if (!context.scrollbar)</span>
339         return false;
<span class="line-modified">340     ScrollbarButtonsPlacement buttonsPlacement = context.scrollbar-&gt;theme().buttonsPlacement();</span>
<span class="line-modified">341     if (context.scrollbarPart == BackTrackPart)</span>

342         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleEnd;
<span class="line-modified">343     if (context.scrollbarPart == ForwardTrackPart)</span>
344         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleStart;
345     return false;
346 }
347 
348 ALWAYS_INLINE bool scrollbarMatchesCornerPresentPseudoClass(const SelectorChecker::CheckingContext&amp; context)
349 {
<span class="line-modified">350     return context.scrollbar &amp;&amp; context.scrollbar-&gt;scrollableArea().isScrollCornerVisible();</span>
351 }
352 
353 #if ENABLE(FULLSCREEN_API)
354 
355 ALWAYS_INLINE bool matchesFullScreenPseudoClass(const Element&amp; element)
356 {
357     // While a Document is in the fullscreen state, and the document&#39;s current fullscreen
358     // element is an element in the document, the &#39;full-screen&#39; pseudoclass applies to
359     // that element. Also, an &lt;iframe&gt;, &lt;object&gt; or &lt;embed&gt; element whose child browsing
360     // context&#39;s Document is in the fullscreen state has the &#39;full-screen&#39; pseudoclass applied.
361     if (is&lt;HTMLFrameElementBase&gt;(element) &amp;&amp; element.containsFullScreenElement())
362         return true;
363     if (!element.document().fullscreenManager().isFullscreen())
364         return false;
365     return &amp;element == element.document().fullscreenManager().currentFullscreenElement();
366 }
367 
368 ALWAYS_INLINE bool matchesFullScreenAnimatingFullScreenTransitionPseudoClass(const Element&amp; element)
369 {
370     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
</pre>
<hr />
<pre>
378 }
379 
380 ALWAYS_INLINE bool matchesFullScreenDocumentPseudoClass(const Element&amp; element)
381 {
382     // While a Document is in the fullscreen state, the &#39;full-screen-document&#39; pseudoclass applies
383     // to all elements of that Document.
384     if (!element.document().fullscreenManager().isFullscreen())
385         return false;
386     return true;
387 }
388 
389 ALWAYS_INLINE bool matchesFullScreenControlsHiddenPseudoClass(const Element&amp; element)
390 {
391     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
392         return false;
393     return element.document().fullscreenManager().areFullscreenControlsHidden();
394 }
395 
396 #endif
397 









398 #if ENABLE(VIDEO_TRACK)
399 
400 ALWAYS_INLINE bool matchesFutureCuePseudoClass(const Element&amp; element)
401 {
402     return is&lt;WebVTTElement&gt;(element) &amp;&amp; !downcast&lt;WebVTTElement&gt;(element).isPastNode();
403 }
404 
405 ALWAYS_INLINE bool matchesPastCuePseudoClass(const Element&amp; element)
406 {
407     return is&lt;WebVTTElement&gt;(element) &amp;&amp; downcast&lt;WebVTTElement&gt;(element).isPastNode();
408 }
409 
410 #endif
411 
412 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 24  * THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;FocusController.h&quot;
 30 #include &quot;FullscreenManager.h&quot;
 31 #include &quot;HTMLFrameElement.h&quot;
 32 #include &quot;HTMLIFrameElement.h&quot;
 33 #include &quot;HTMLInputElement.h&quot;
 34 #include &quot;HTMLOptionElement.h&quot;
<span class="line-modified"> 35 #include &quot;SelectorChecker.h&quot;</span>


 36 #include &lt;wtf/Compiler.h&gt;
 37 
 38 #if ENABLE(ATTACHMENT_ELEMENT)
 39 #include &quot;HTMLAttachmentElement.h&quot;
 40 #endif
 41 
 42 #if ENABLE(VIDEO_TRACK)
 43 #include &quot;WebVTTElement.h&quot;
 44 #endif
 45 
<span class="line-added"> 46 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 47 #include &quot;HTMLVideoElement.h&quot;</span>
<span class="line-added"> 48 #endif</span>
<span class="line-added"> 49 </span>
 50 namespace WebCore {
 51 
 52 ALWAYS_INLINE bool isAutofilled(const Element&amp; element)
 53 {
 54     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled();
 55 }
 56 
 57 ALWAYS_INLINE bool isAutofilledStrongPassword(const Element&amp; element)
 58 {
 59     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilled() &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).hasAutoFillStrongPasswordButton();
 60 }
 61 
 62 ALWAYS_INLINE bool isAutofilledStrongPasswordViewable(const Element&amp; element)
 63 {
 64     return is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isAutoFilledAndViewable();
 65 }
 66 
 67 ALWAYS_INLINE bool matchesDefaultPseudoClass(const Element&amp; element)
 68 {
 69     return element.matchesDefaultPseudoClass();
</pre>
<hr />
<pre>
234     return false;
235 }
236 
237 ALWAYS_INLINE bool matchesReadOnlyPseudoClass(const Element&amp; element)
238 {
239     return !element.matchesReadWritePseudoClass();
240 }
241 
242 ALWAYS_INLINE bool matchesReadWritePseudoClass(const Element&amp; element)
243 {
244     return element.matchesReadWritePseudoClass();
245 }
246 
247 ALWAYS_INLINE bool matchesIndeterminatePseudoClass(const Element&amp; element)
248 {
249     return element.matchesIndeterminatePseudoClass();
250 }
251 
252 ALWAYS_INLINE bool scrollbarMatchesEnabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
253 {
<span class="line-modified">254     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;enabled;</span>
255 }
256 
257 ALWAYS_INLINE bool scrollbarMatchesDisabledPseudoClass(const SelectorChecker::CheckingContext&amp; context)
258 {
<span class="line-modified">259     return context.scrollbarState &amp;&amp; !context.scrollbarState-&gt;enabled;</span>
260 }
261 
262 ALWAYS_INLINE bool scrollbarMatchesHoverPseudoClass(const SelectorChecker::CheckingContext&amp; context)
263 {
<span class="line-modified">264     if (!context.scrollbarState)</span>
265         return false;
<span class="line-modified">266     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">267     auto hoveredPart = context.scrollbarState-&gt;hoveredPart;</span>
<span class="line-added">268     if (scrollbarPart == ScrollbarBGPart)</span>
269         return hoveredPart != NoPart;
<span class="line-modified">270     if (scrollbarPart == TrackBGPart)</span>
271         return hoveredPart == BackTrackPart || hoveredPart == ForwardTrackPart || hoveredPart == ThumbPart;
<span class="line-modified">272     return scrollbarPart == hoveredPart;</span>
273 }
274 
275 ALWAYS_INLINE bool scrollbarMatchesActivePseudoClass(const SelectorChecker::CheckingContext&amp; context)
276 {
<span class="line-modified">277     if (!context.scrollbarState)</span>
278         return false;
<span class="line-modified">279     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">280     auto pressedPart = context.scrollbarState-&gt;pressedPart;</span>
<span class="line-added">281     if (scrollbarPart == ScrollbarBGPart)</span>
282         return pressedPart != NoPart;
<span class="line-modified">283     if (scrollbarPart == TrackBGPart)</span>
284         return pressedPart == BackTrackPart || pressedPart == ForwardTrackPart || pressedPart == ThumbPart;
<span class="line-modified">285     return scrollbarPart == pressedPart;</span>
286 }
287 
288 ALWAYS_INLINE bool scrollbarMatchesHorizontalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
289 {
<span class="line-modified">290     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == HorizontalScrollbar;</span>
291 }
292 
293 ALWAYS_INLINE bool scrollbarMatchesVerticalPseudoClass(const SelectorChecker::CheckingContext&amp; context)
294 {
<span class="line-modified">295     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;orientation == VerticalScrollbar;</span>
296 }
297 
298 ALWAYS_INLINE bool scrollbarMatchesDecrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
299 {
<span class="line-modified">300     if (!context.scrollbarState)</span>
<span class="line-added">301         return false;</span>
<span class="line-added">302     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">303     return scrollbarPart == BackButtonStartPart || scrollbarPart == BackButtonEndPart || scrollbarPart == BackTrackPart;</span>
304 }
305 
306 ALWAYS_INLINE bool scrollbarMatchesIncrementPseudoClass(const SelectorChecker::CheckingContext&amp; context)
307 {
<span class="line-modified">308     if (!context.scrollbarState)</span>
<span class="line-added">309         return false;</span>
<span class="line-added">310     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">311     return scrollbarPart == ForwardButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;</span>
312 }
313 
314 ALWAYS_INLINE bool scrollbarMatchesStartPseudoClass(const SelectorChecker::CheckingContext&amp; context)
315 {
<span class="line-modified">316     if (!context.scrollbarState)</span>
<span class="line-added">317         return false;</span>
<span class="line-added">318     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">319     return scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart;</span>
320 }
321 
322 ALWAYS_INLINE bool scrollbarMatchesEndPseudoClass(const SelectorChecker::CheckingContext&amp; context)
323 {
<span class="line-modified">324     if (!context.scrollbarState)</span>
<span class="line-added">325         return false;</span>
<span class="line-added">326     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-added">327     return scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart;</span>
328 }
329 
330 ALWAYS_INLINE bool scrollbarMatchesDoubleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
331 {
<span class="line-modified">332     if (!context.scrollbarState)</span>
333         return false;
<span class="line-modified">334     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">335     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">336     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonStartPart || scrollbarPart == BackTrackPart)</span>
337         return buttonsPlacement == ScrollbarButtonsDoubleStart || buttonsPlacement == ScrollbarButtonsDoubleBoth;
<span class="line-modified">338     if (scrollbarPart == BackButtonEndPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == ForwardTrackPart)</span>
339         return buttonsPlacement == ScrollbarButtonsDoubleEnd || buttonsPlacement == ScrollbarButtonsDoubleBoth;
340     return false;
341 }
342 
343 ALWAYS_INLINE bool scrollbarMatchesSingleButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
344 {
<span class="line-modified">345     if (!context.scrollbarState)</span>
346         return false;
<span class="line-modified">347     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">348     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">349     if (scrollbarPart == BackButtonStartPart || scrollbarPart == ForwardButtonEndPart || scrollbarPart == BackTrackPart || scrollbarPart == ForwardTrackPart)</span>
350         return buttonsPlacement == ScrollbarButtonsSingle;
351     return false;
352 }
353 
354 ALWAYS_INLINE bool scrollbarMatchesNoButtonPseudoClass(const SelectorChecker::CheckingContext&amp; context)
355 {
<span class="line-modified">356     if (!context.scrollbarState)</span>
357         return false;
<span class="line-modified">358     auto scrollbarPart = context.scrollbarState-&gt;scrollbarPart;</span>
<span class="line-modified">359     auto buttonsPlacement = context.scrollbarState-&gt;buttonsPlacement;</span>
<span class="line-added">360     if (scrollbarPart == BackTrackPart)</span>
361         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleEnd;
<span class="line-modified">362     if (scrollbarPart == ForwardTrackPart)</span>
363         return buttonsPlacement == ScrollbarButtonsNone || buttonsPlacement == ScrollbarButtonsDoubleStart;
364     return false;
365 }
366 
367 ALWAYS_INLINE bool scrollbarMatchesCornerPresentPseudoClass(const SelectorChecker::CheckingContext&amp; context)
368 {
<span class="line-modified">369     return context.scrollbarState &amp;&amp; context.scrollbarState-&gt;scrollCornerIsVisible;</span>
370 }
371 
372 #if ENABLE(FULLSCREEN_API)
373 
374 ALWAYS_INLINE bool matchesFullScreenPseudoClass(const Element&amp; element)
375 {
376     // While a Document is in the fullscreen state, and the document&#39;s current fullscreen
377     // element is an element in the document, the &#39;full-screen&#39; pseudoclass applies to
378     // that element. Also, an &lt;iframe&gt;, &lt;object&gt; or &lt;embed&gt; element whose child browsing
379     // context&#39;s Document is in the fullscreen state has the &#39;full-screen&#39; pseudoclass applied.
380     if (is&lt;HTMLFrameElementBase&gt;(element) &amp;&amp; element.containsFullScreenElement())
381         return true;
382     if (!element.document().fullscreenManager().isFullscreen())
383         return false;
384     return &amp;element == element.document().fullscreenManager().currentFullscreenElement();
385 }
386 
387 ALWAYS_INLINE bool matchesFullScreenAnimatingFullScreenTransitionPseudoClass(const Element&amp; element)
388 {
389     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
</pre>
<hr />
<pre>
397 }
398 
399 ALWAYS_INLINE bool matchesFullScreenDocumentPseudoClass(const Element&amp; element)
400 {
401     // While a Document is in the fullscreen state, the &#39;full-screen-document&#39; pseudoclass applies
402     // to all elements of that Document.
403     if (!element.document().fullscreenManager().isFullscreen())
404         return false;
405     return true;
406 }
407 
408 ALWAYS_INLINE bool matchesFullScreenControlsHiddenPseudoClass(const Element&amp; element)
409 {
410     if (&amp;element != element.document().fullscreenManager().currentFullscreenElement())
411         return false;
412     return element.document().fullscreenManager().areFullscreenControlsHidden();
413 }
414 
415 #endif
416 
<span class="line-added">417 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">418 </span>
<span class="line-added">419 ALWAYS_INLINE bool matchesPictureInPicturePseudoClass(const Element&amp; element)</span>
<span class="line-added">420 {</span>
<span class="line-added">421     return is&lt;HTMLVideoElement&gt;(element) &amp;&amp; element.document().pictureInPictureElement() == &amp;element;</span>
<span class="line-added">422 }</span>
<span class="line-added">423 </span>
<span class="line-added">424 #endif</span>
<span class="line-added">425 </span>
426 #if ENABLE(VIDEO_TRACK)
427 
428 ALWAYS_INLINE bool matchesFutureCuePseudoClass(const Element&amp; element)
429 {
430     return is&lt;WebVTTElement&gt;(element) &amp;&amp; !downcast&lt;WebVTTElement&gt;(element).isPastNode();
431 }
432 
433 ALWAYS_INLINE bool matchesPastCuePseudoClass(const Element&amp; element)
434 {
435     return is&lt;WebVTTElement&gt;(element) &amp;&amp; downcast&lt;WebVTTElement&gt;(element).isPastNode();
436 }
437 
438 #endif
439 
440 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="SelectorChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorPseudoClassAndCompatibilityElementMap.in.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaRecorder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaRecorder.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediarecorder/MediaRecorder.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 54     struct Options {
 55         String mimeType;
 56         unsigned audioBitsPerSecond;
 57         unsigned videoBitsPerSecond;
 58         unsigned bitsPerSecond;
 59     };
 60 
 61     ~MediaRecorder();
 62 
 63     static ExceptionOr&lt;Ref&lt;MediaRecorder&gt;&gt; create(Document&amp;, Ref&lt;MediaStream&gt;&amp;&amp;, Options&amp;&amp; = { });
 64 
 65     WEBCORE_EXPORT static void setCustomPrivateRecorderCreator(creatorFunction);
 66 
 67     RecordingState state() const { return m_state; }
 68 
 69     using RefCounted::ref;
 70     using RefCounted::deref;
 71 
 72     ExceptionOr&lt;void&gt; startRecording(Optional&lt;int&gt;);
 73     ExceptionOr&lt;void&gt; stopRecording();



 74 
 75 private:
 76     MediaRecorder(Document&amp;, Ref&lt;MediaStream&gt;&amp;&amp;, std::unique_ptr&lt;MediaRecorderPrivate&gt;&amp;&amp;, Options&amp;&amp; = { });
 77 
<span class="line-modified"> 78     static std::unique_ptr&lt;MediaRecorderPrivate&gt; getPrivateImpl(const MediaStreamPrivate&amp;);</span>
 79 
<span class="line-modified"> 80     Ref&lt;Blob&gt; createRecordingDataBlob();</span>
 81 
 82     // EventTarget
 83     void refEventTarget() final { ref(); }
 84     void derefEventTarget() final { deref(); }
 85     EventTargetInterface eventTargetInterface() const final { return MediaRecorderEventTargetInterfaceType; }
 86     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
 87 
 88     // ActiveDOMObject API.

 89     void stop() final;
 90     const char* activeDOMObjectName() const final;
<span class="line-removed"> 91     bool canSuspendForDocumentSuspension() const final;</span>
 92 
 93     void stopRecordingInternal();
 94 


 95     // MediaStream::Observer
 96     void didAddOrRemoveTrack() final;
 97 
 98     // MediaStreamTrackPrivate::Observer
 99     void trackEnded(MediaStreamTrackPrivate&amp;) final;
100     void trackMutedChanged(MediaStreamTrackPrivate&amp;) final { };
101     void trackSettingsChanged(MediaStreamTrackPrivate&amp;) final { };
102     void trackEnabledChanged(MediaStreamTrackPrivate&amp;) final { };
103     void sampleBufferUpdated(MediaStreamTrackPrivate&amp;, MediaSample&amp;) final;
104     void audioSamplesAvailable(MediaStreamTrackPrivate&amp;, const MediaTime&amp;, const PlatformAudioData&amp;, const AudioStreamDescription&amp;, size_t) final;
105 
106     void scheduleDeferredTask(Function&lt;void()&gt;&amp;&amp;);
107 
108     static creatorFunction m_customCreator;
109 
110     Options m_options;
111     Ref&lt;MediaStream&gt; m_stream;
112     std::unique_ptr&lt;MediaRecorderPrivate&gt; m_private;
113     RecordingState m_state { RecordingState::Inactive };
114     Vector&lt;Ref&lt;MediaStreamTrackPrivate&gt;&gt; m_tracks;
</pre>
</td>
<td>
<hr />
<pre>
 54     struct Options {
 55         String mimeType;
 56         unsigned audioBitsPerSecond;
 57         unsigned videoBitsPerSecond;
 58         unsigned bitsPerSecond;
 59     };
 60 
 61     ~MediaRecorder();
 62 
 63     static ExceptionOr&lt;Ref&lt;MediaRecorder&gt;&gt; create(Document&amp;, Ref&lt;MediaStream&gt;&amp;&amp;, Options&amp;&amp; = { });
 64 
 65     WEBCORE_EXPORT static void setCustomPrivateRecorderCreator(creatorFunction);
 66 
 67     RecordingState state() const { return m_state; }
 68 
 69     using RefCounted::ref;
 70     using RefCounted::deref;
 71 
 72     ExceptionOr&lt;void&gt; startRecording(Optional&lt;int&gt;);
 73     ExceptionOr&lt;void&gt; stopRecording();
<span class="line-added"> 74     ExceptionOr&lt;void&gt; requestData();</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     MediaStream&amp; stream() { return m_stream.get(); }</span>
 77 
 78 private:
 79     MediaRecorder(Document&amp;, Ref&lt;MediaStream&gt;&amp;&amp;, std::unique_ptr&lt;MediaRecorderPrivate&gt;&amp;&amp;, Options&amp;&amp; = { });
 80 
<span class="line-modified"> 81     static std::unique_ptr&lt;MediaRecorderPrivate&gt; createMediaRecorderPrivate(Document&amp;, const MediaStreamPrivate&amp;);</span>
 82 
<span class="line-modified"> 83     Document* document() const;</span>
 84 
 85     // EventTarget
 86     void refEventTarget() final { ref(); }
 87     void derefEventTarget() final { deref(); }
 88     EventTargetInterface eventTargetInterface() const final { return MediaRecorderEventTargetInterfaceType; }
 89     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
 90 
 91     // ActiveDOMObject API.
<span class="line-added"> 92     void suspend(ReasonForSuspension) final;</span>
 93     void stop() final;
 94     const char* activeDOMObjectName() const final;

 95 
 96     void stopRecordingInternal();
 97 
<span class="line-added"> 98     void dispatchError(Exception&amp;&amp;);</span>
<span class="line-added"> 99 </span>
100     // MediaStream::Observer
101     void didAddOrRemoveTrack() final;
102 
103     // MediaStreamTrackPrivate::Observer
104     void trackEnded(MediaStreamTrackPrivate&amp;) final;
105     void trackMutedChanged(MediaStreamTrackPrivate&amp;) final { };
106     void trackSettingsChanged(MediaStreamTrackPrivate&amp;) final { };
107     void trackEnabledChanged(MediaStreamTrackPrivate&amp;) final { };
108     void sampleBufferUpdated(MediaStreamTrackPrivate&amp;, MediaSample&amp;) final;
109     void audioSamplesAvailable(MediaStreamTrackPrivate&amp;, const MediaTime&amp;, const PlatformAudioData&amp;, const AudioStreamDescription&amp;, size_t) final;
110 
111     void scheduleDeferredTask(Function&lt;void()&gt;&amp;&amp;);
112 
113     static creatorFunction m_customCreator;
114 
115     Options m_options;
116     Ref&lt;MediaStream&gt; m_stream;
117     std::unique_ptr&lt;MediaRecorderPrivate&gt; m_private;
118     RecordingState m_state { RecordingState::Inactive };
119     Vector&lt;Ref&lt;MediaStreamTrackPrivate&gt;&gt; m_tracks;
</pre>
</td>
</tr>
</table>
<center><a href="MediaRecorder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaRecorder.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
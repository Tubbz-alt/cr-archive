<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTextAreaElement.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTextFormControlElement.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextFormControlElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -63,10 +63,11 @@</span>
  HTMLTextFormControlElement::HTMLTextFormControlElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
      : HTMLFormControlElementWithState(tagName, document, form)
      , m_cachedSelectionDirection(SelectionHasNoDirection)
      , m_lastChangeWasUserEdit(false)
      , m_isPlaceholderVisible(false)
<span class="udiff-line-added">+     , m_canShowPlaceholder(true)</span>
      , m_cachedSelectionStart(-1)
      , m_cachedSelectionEnd(-1)
  {
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,11 +157,11 @@</span>
  
  bool HTMLTextFormControlElement::placeholderShouldBeVisible() const
  {
      // This function is used by the style resolver to match the :placeholder-shown pseudo class.
      // Since it is used for styling, it must not use any value depending on the style.
<span class="udiff-line-modified-removed">-     return supportsPlaceholder() &amp;&amp; isEmptyValue() &amp;&amp; !isPlaceholderEmpty();</span>
<span class="udiff-line-modified-added">+     return supportsPlaceholder() &amp;&amp; isEmptyValue() &amp;&amp; !isPlaceholderEmpty() &amp;&amp; m_canShowPlaceholder;</span>
  }
  
  void HTMLTextFormControlElement::updatePlaceholderVisibility()
  {
      bool placeHolderWasVisible = m_isPlaceholderVisible;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170,10 +171,16 @@</span>
          return;
  
      invalidateStyleForSubtree();
  }
  
<span class="udiff-line-added">+ void HTMLTextFormControlElement::setCanShowPlaceholder(bool canShowPlaceholder)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     m_canShowPlaceholder = canShowPlaceholder;</span>
<span class="udiff-line-added">+     updatePlaceholderVisibility();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void HTMLTextFormControlElement::setSelectionStart(int start)
  {
      setSelectionRange(start, std::max(start, selectionEnd()), selectionDirection());
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -287,13 +294,21 @@</span>
      start = std::min(std::max(start, 0), end);
  
      auto innerText = innerTextElement();
      bool hasFocus = document().focusedElement() == this;
      if (!hasFocus &amp;&amp; innerText) {
<span class="udiff-line-added">+         if (!isConnected()) {</span>
<span class="udiff-line-added">+             cacheSelection(start, end, direction);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          // FIXME: Removing this synchronous layout requires fixing setSelectionWithoutUpdatingAppearance not needing up-to-date style.
          document().updateLayoutIgnorePendingStylesheets();
  
<span class="udiff-line-added">+         if (!isTextField())</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+ </span>
          // Double-check the state of innerTextElement after the layout.
          innerText = innerTextElement();
          auto* rendererTextControl = renderer();
  
          if (innerText &amp;&amp; rendererTextControl) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -641,16 +656,20 @@</span>
              ++index;
      }
  
      unsigned length = innerTextValue().length();
      index = std::min(index, length); // FIXME: We shouldn&#39;t have to call innerTextValue() just to ignore the last LF. See finishText.
<span class="udiff-line-modified-removed">- #ifndef ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if 0</span>
<span class="udiff-line-added">+     // FIXME: This assertion code was never built, has bit rotted, and needs to be fixed before it can be enabled:</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=205706.</span>
<span class="udiff-line-added">+ #if ASSERT_ENABLED</span>
      VisiblePosition visiblePosition = passedPosition;
      unsigned indexComputedByVisiblePosition = 0;
      if (visiblePosition.isNotNull())
          indexComputedByVisiblePosition = WebCore::indexForVisiblePosition(innerText, visiblePosition, false /* forSelectionPreservation */);
      ASSERT(index == indexComputedByVisiblePosition);
<span class="udiff-line-added">+ #endif</span>
  #endif
      return index;
  }
  
  #if PLATFORM(IOS_FAMILY)
</pre>
<center><a href="HTMLTextAreaElement.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLTextFormControlElement.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
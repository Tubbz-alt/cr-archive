diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.cpp
@@ -236,10 +236,14 @@
     }
 }
 
 RenderLayerBacking::~RenderLayerBacking()
 {
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "~RenderLayerBacking: m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "~RenderLayerBacking: m_owningLayer is null (55699292)");
+#endif
     // Note that m_owningLayer->backing() is null here.
     updateAncestorClipping(false, nullptr);
     updateChildClippingStrategy(false);
     updateDescendantClippingLayer(false);
     updateOverflowControlsLayers(false, false, false);
@@ -256,10 +260,15 @@
     destroyGraphicsLayers();
 }
 
 void RenderLayerBacking::willBeDestroyed()
 {
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::willBeDestroyed(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::willBeDestroyed(): m_owningLayer is null (55699292)");
+#endif
+
     ASSERT(m_owningLayer.backing() == this);
     compositor().removeFromScrollCoordinatedLayers(m_owningLayer);
 
     clearBackingSharingLayers();
 }
@@ -268,16 +277,17 @@
 {
     if (layer && layer->type() == GraphicsLayer::Type::Normal && layer->tiledBacking())
         compositor().layerTiledBackingUsageChanged(layer, false);
 }
 
-static void clearBackingSharingLayerProviders(Vector<WeakPtr<RenderLayer>>& sharingLayers)
+static void clearBackingSharingLayerProviders(Vector<WeakPtr<RenderLayer>>& sharingLayers, const RenderLayer& providerLayer)
 {
     for (auto& layerWeakPtr : sharingLayers) {
         if (!layerWeakPtr)
             continue;
-        layerWeakPtr->setBackingProviderLayer(nullptr);
+        if (layerWeakPtr->backingProviderLayer() == &providerLayer)
+            layerWeakPtr->setBackingProviderLayer(nullptr);
     }
 }
 
 void RenderLayerBacking::setBackingSharingLayers(Vector<WeakPtr<RenderLayer>>&& sharingLayers)
 {
@@ -290,14 +300,17 @@
             if (!sharingLayers.contains(oldSharingLayer) && !oldSharingLayer->isComposited())
                 oldSharingLayer->computeRepaintRectsIncludingDescendants();
         }
     }
 
-    clearBackingSharingLayerProviders(m_backingSharingLayers);
+    clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);
 
-    if (sharingLayers != m_backingSharingLayers)
+    if (sharingLayers != m_backingSharingLayers) {
+        if (sharingLayers.size())
+            setRequiresOwnBackingStore(true);
         setContentsNeedDisplay(); // This could be optimized to only repaint rects for changed layers.
+    }
 
     auto oldSharingLayers = WTFMove(m_backingSharingLayers);
     m_backingSharingLayers = WTFMove(sharingLayers);
 
     for (auto& layerWeakPtr : m_backingSharingLayers)
@@ -318,11 +331,11 @@
     m_backingSharingLayers.removeAll(&layer);
 }
 
 void RenderLayerBacking::clearBackingSharingLayers()
 {
-    clearBackingSharingLayerProviders(m_backingSharingLayers);
+    clearBackingSharingLayerProviders(m_backingSharingLayers, m_owningLayer);
     m_backingSharingLayers.clear();
 }
 
 Ref<GraphicsLayer> RenderLayerBacking::createGraphicsLayer(const String& name, GraphicsLayer::Type layerType)
 {
@@ -693,10 +706,15 @@
         || (style.transformOriginY().type() == Fixed && style.transformOriginY().value());
 }
 
 bool RenderLayerBacking::updateCompositedBounds()
 {
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::updateCompositedBounds(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::updateCompositedBounds(): m_owningLayer is null (55699292)");
+#endif
+
     LayoutRect layerBounds = m_owningLayer.calculateLayerBounds(&m_owningLayer, { }, RenderLayer::defaultCalculateLayerBoundsFlags() | RenderLayer::ExcludeHiddenDescendants | RenderLayer::DontConstrainForMask);
     // Clip to the size of the document or enclosing overflow-scroll layer.
     // If this or an ancestor is transformed, we can't currently compute the correct rect to intersect with.
     // We'd need RenderObject::convertContainerToLocalQuad(), which doesn't yet exist.
     if (shouldClipCompositedBounds()) {
@@ -784,10 +802,15 @@
     }
 }
 
 void RenderLayerBacking::updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint)
 {
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::updateAfterLayout(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::updateAfterLayout(): m_owningLayer is null (55699292)");
+#endif
+
     LOG(Compositing, "RenderLayerBacking %p updateAfterLayout (layer %p)", this, &m_owningLayer);
 
     // This is the main trigger for layout changing layer geometry, but we have to do the work again in updateBackingAndHierarchy()
     // when we know the final compositing hierarchy. We can't just set dirty bits from RenderLayer::setSize() because that doesn't
     // take overflow into account.
@@ -829,11 +852,11 @@
     updateBlendMode(style);
 #endif
     updateCustomAppearance(style);
 }
 
-bool RenderLayerBacking::updateConfiguration()
+bool RenderLayerBacking::updateConfiguration(const RenderLayer* compositingAncestor)
 {
     ASSERT(!m_owningLayer.normalFlowListDirty());
     ASSERT(!m_owningLayer.zOrderListsDirty());
     ASSERT(!renderer().view().needsLayout());
 
@@ -863,11 +886,11 @@
         layerConfigChanged = true;
 
     if (updateDescendantClippingLayer(needsDescendantsClippingLayer))
         layerConfigChanged = true;
 
-    auto* compositingAncestor = m_owningLayer.ancestorCompositingLayer();
+    ASSERT(compositingAncestor == m_owningLayer.ancestorCompositingLayer());
     if (updateAncestorClipping(compositor.clippedByAncestor(m_owningLayer, compositingAncestor), compositingAncestor))
         layerConfigChanged = true;
 
     if (updateOverflowControlsLayers(requiresHorizontalScrollbarLayer(), requiresVerticalScrollbarLayer(), requiresScrollCornerLayer()))
         layerConfigChanged = true;
@@ -949,10 +972,15 @@
     }
 
     if (layerConfigChanged)
         updatePaintingPhases();
 
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::updateConfiguration(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::updateConfiguration(): m_owningLayer is null (55699292)");
+#endif
+
     return layerConfigChanged;
 }
 
 static LayoutRect clipBox(RenderBox& renderer)
 {
@@ -1024,12 +1052,13 @@
     return ancestorRendererOffsetFromAncestorGraphicsLayer + toLayoutSize(location);
 }
 
 class ComputedOffsets {
 public:
-    ComputedOffsets(const RenderLayer& renderLayer, const LayoutRect& localRect, const LayoutRect& parentGraphicsLayerRect, const LayoutRect& primaryGraphicsLayerRect)
+    ComputedOffsets(const RenderLayer& renderLayer, const RenderLayer* compositingAncestor, const LayoutRect& localRect, const LayoutRect& parentGraphicsLayerRect, const LayoutRect& primaryGraphicsLayerRect)
         : m_renderLayer(renderLayer)
+        , m_compositingAncestor(compositingAncestor)
         , m_location(localRect.location())
         , m_parentGraphicsLayerOffset(toLayoutSize(parentGraphicsLayerRect.location()))
         , m_primaryGraphicsLayerOffset(toLayoutSize(primaryGraphicsLayerRect.location()))
         , m_deviceScaleFactor(renderLayer.renderer().document().deviceScaleFactor())
     {
@@ -1051,32 +1080,32 @@
 
 private:
     LayoutSize fromAncestorGraphicsLayer()
     {
         if (!m_fromAncestorGraphicsLayer) {
-            auto* compositedAncestor = m_renderLayer.ancestorCompositingLayer();
-            LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(compositedAncestor, m_location, RenderLayer::AdjustForColumns);
-            m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(compositedAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
+            LayoutPoint localPointInAncestorRenderLayerCoords = m_renderLayer.convertToLayerCoords(m_compositingAncestor, m_location, RenderLayer::AdjustForColumns);
+            m_fromAncestorGraphicsLayer = computeOffsetFromAncestorGraphicsLayer(m_compositingAncestor, localPointInAncestorRenderLayerCoords, m_deviceScaleFactor);
         }
         return m_fromAncestorGraphicsLayer.value();
     }
 
     Optional<LayoutSize> m_fromAncestorGraphicsLayer;
     Optional<LayoutSize> m_fromParentGraphicsLayer;
     Optional<LayoutSize> m_fromPrimaryGraphicsLayer;
 
     const RenderLayer& m_renderLayer;
+    const RenderLayer* m_compositingAncestor;
     // Location is relative to the renderer.
     const LayoutPoint m_location;
     const LayoutSize m_parentGraphicsLayerOffset;
     const LayoutSize m_primaryGraphicsLayerOffset;
     float m_deviceScaleFactor;
 };
 
-LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const LayoutRect& parentGraphicsLayerRect) const
+LayoutRect RenderLayerBacking::computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect& parentGraphicsLayerRect) const
 {
-    ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, { });
+    ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, { });
     return LayoutRect(encloseRectToDevicePixels(LayoutRect(toLayoutPoint(compositedBoundsOffset.fromParentGraphicsLayer()), compositedBounds().size()),
         deviceScaleFactor()));
 }
 
 // FIXME: See if we need this now that updateGeometry() is always called in post-order traversal.
@@ -1110,11 +1139,11 @@
     }
 
     return parentGraphicsLayerRect;
 }
 
-void RenderLayerBacking::updateGeometry()
+void RenderLayerBacking::updateGeometry(const RenderLayer* compositedAncestor)
 {
     ASSERT(!m_owningLayer.normalFlowListDirty());
     ASSERT(!m_owningLayer.zOrderListsDirty());
     ASSERT(!m_owningLayer.descendantDependentFlagsAreDirty());
     ASSERT(!renderer().view().needsLayout());
@@ -1136,11 +1165,11 @@
 #endif
 #if ENABLE(CSS_COMPOSITING)
     updateBlendMode(style);
 #endif
 
-    auto* compositedAncestor = m_owningLayer.ancestorCompositingLayer();
+    ASSERT(compositedAncestor == m_owningLayer.ancestorCompositingLayer());
     LayoutRect parentGraphicsLayerRect = computeParentGraphicsLayerRect(compositedAncestor);
 
     if (m_ancestorClippingStack) {
         // All clipRects in the stack are computed relative to m_owningLayer, so convert them back to compositedAncestor.
         auto offsetFromCompositedAncestor = toLayoutSize(m_owningLayer.convertToLayerCoords(compositedAncestor, { }, RenderLayer::AdjustForColumns));
@@ -1166,14 +1195,14 @@
         }
 
         parentGraphicsLayerRect = lastClipLayerRect;
     }
 
-    LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(parentGraphicsLayerRect);
+    LayoutRect primaryGraphicsLayerRect = computePrimaryGraphicsLayerRect(compositedAncestor, parentGraphicsLayerRect);
 
-    ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
-    ComputedOffsets rendererOffset(m_owningLayer, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);
+    ComputedOffsets compositedBoundsOffset(m_owningLayer, compositedAncestor, compositedBounds(), parentGraphicsLayerRect, primaryGraphicsLayerRect);
+    ComputedOffsets rendererOffset(m_owningLayer, compositedAncestor, { }, parentGraphicsLayerRect, primaryGraphicsLayerRect);
 
     m_compositedBoundsOffsetFromGraphicsLayer = compositedBoundsOffset.fromPrimaryGraphicsLayer();
 
     auto primaryLayerPosition = primaryGraphicsLayerRect.location();
 
@@ -1279,11 +1308,11 @@
             m_contentsContainmentLayer->setAnchorPoint(FloatPoint3D(0.5, 0.5, 0));
     }
 
     if (m_owningLayer.reflectionLayer() && m_owningLayer.reflectionLayer()->isComposited()) {
         auto* reflectionBacking = m_owningLayer.reflectionLayer()->backing();
-        reflectionBacking->updateGeometry();
+        reflectionBacking->updateGeometry(&m_owningLayer);
 
         // The reflection layer has the bounds of m_owningLayer.reflectionLayer(),
         // but the reflected layer is the bounds of this layer, so we need to position it appropriately.
         FloatRect layerBounds = this->compositedBounds();
         FloatRect reflectionLayerBounds = reflectionBacking->compositedBounds();
@@ -1425,10 +1454,15 @@
     m_graphicsLayer->setContentsVisible(m_owningLayer.hasVisibleContent() || hasVisibleNonCompositedDescendants());
     if (m_scrollContainerLayer) {
         m_scrollContainerLayer->setContentsVisible(renderer().style().visibility() == Visibility::Visible);
         m_scrollContainerLayer->setUserInteractionEnabled(renderer().style().pointerEvents() != PointerEvents::None);
     }
+
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::updateAfterDescendants(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::updateAfterDescendants(): m_owningLayer is null (55699292)");
+#endif
 }
 
 // FIXME: Avoid repaints when clip path changes.
 void RenderLayerBacking::updateMaskingLayerGeometry()
 {
@@ -1589,29 +1623,34 @@
     hasTouchActionElements = renderer().document().mayHaveElementsWithNonAutoTouchAction();
 #endif
     if (m_owningLayer.isRenderViewLayer() && !hasTouchActionElements)
         return;
 
-    GraphicsContext nullContext(nullptr);
-    RenderLayer::LayerPaintingInfo paintingInfo(&m_owningLayer, compositedBounds(), { }, LayoutSize());
+    auto updateEventRegionForLayer = [&](GraphicsLayer& graphicsLayer) {
+        GraphicsContext nullContext(nullptr);
+        EventRegion eventRegion;
+        auto eventRegionContext = eventRegion.makeContext();
+        auto layerOffset = graphicsLayer.scrollOffset() - roundedIntSize(graphicsLayer.offsetFromRenderer());
 
-    EventRegion eventRegion;
-    auto eventRegionContext = eventRegion.makeContext();
-    paintingInfo.eventRegionContext = &eventRegionContext;
+        if (&graphicsLayer == m_scrolledContentsLayer && renderer().visibleToHitTesting()) {
+            // Initialize scrolled contents layer with layer-sized event region as it can all used for scrolling.
+            // This avoids generating unnecessarily complex event regions. We still need to to do the paint to capture touch-action regions.
+            eventRegionContext.unite(enclosingIntRect(FloatRect(-layerOffset, graphicsLayer.size())), RenderStyle::defaultStyle());
+        }
 
-    auto paintFlags = RenderLayer::paintLayerPaintingCompositingAllPhasesFlags() | RenderLayer::PaintLayerCollectingEventRegion;
-    m_owningLayer.paintLayerContents(nullContext, paintingInfo, paintFlags);
+        auto dirtyRect = enclosingIntRect(FloatRect(FloatPoint(graphicsLayer.offsetFromRenderer()), graphicsLayer.size()));
+        paintIntoLayer(&graphicsLayer, nullContext, dirtyRect, { }, &eventRegionContext);
 
-    for (auto& layer : m_backingSharingLayers)
-        layer->paintLayerWithEffects(nullContext, paintingInfo, paintFlags);
+        eventRegion.translate(toIntSize(layerOffset));
 
-    GraphicsLayer& layerForEventRegion = m_scrolledContentsLayer ? *m_scrolledContentsLayer : *m_graphicsLayer;
+        graphicsLayer.setEventRegion(WTFMove(eventRegion));
+    };
 
-    auto layerOffset = toIntSize(layerForEventRegion.scrollOffset()) - roundedIntSize(layerForEventRegion.offsetFromRenderer());
-    eventRegion.translate(layerOffset);
+    updateEventRegionForLayer(*m_graphicsLayer);
 
-    layerForEventRegion.setEventRegion(WTFMove(eventRegion));
+    if (m_scrolledContentsLayer)
+        updateEventRegionForLayer(*m_scrolledContentsLayer);
 #endif
 }
 
 bool RenderLayerBacking::updateAncestorClippingStack(Vector<CompositedClipData>&& clippingData)
 {
@@ -1929,11 +1968,11 @@
     if (hasClippingLayer() && needsDescendantsClippingLayer) {
         if (is<RenderBox>(renderer()) && (renderer().style().clipPath() || renderer().style().hasBorderRadius())) {
             auto* clipLayer = clippingLayer();
             LayoutRect boxRect(LayoutPoint(), downcast<RenderBox>(renderer()).size());
             FloatRoundedRect contentsClippingRect = renderer().style().getRoundedInnerBorderFor(boxRect).pixelSnappedRoundedRectForPainting(deviceScaleFactor());
-            contentsClippingRect.move(LayoutSize(clipLayer->offsetFromRenderer()));
+            contentsClippingRect.move(LayoutSize(-clipLayer->offsetFromRenderer()));
             // Note that we have to set this rounded rect again during the geometry update (clipLayer->offsetFromRenderer() may be stale here).
             if (clipLayer->setMasksToBoundsRect(contentsClippingRect)) {
                 clipLayer->setMaskLayer(nullptr);
                 GraphicsLayer::clear(m_childClippingMaskLayer);
                 return;
@@ -2095,11 +2134,11 @@
     if (style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isVisible())
         return false;
 
     // FIXME: support gradients with isGeneratedImage.
     auto* styleImage = fillLayer.image();
-    if (!styleImage->isCachedImage())
+    if (!styleImage->hasCachedImage())
         return false;
 
     auto* image = styleImage->cachedImage()->image();
     if (!image->isBitmapImage())
         return false;
@@ -2268,11 +2307,11 @@
     // https://bugs.webkit.org/show_bug.cgi?id=119461
     if (hasPerspectiveOrPreserves3D(style))
         return false;
 
     // FIXME: we should be able to allow backgroundComposite; However since this is not a common use case it has been deferred for now.
-    if (style.backgroundComposite() != CompositeSourceOver)
+    if (style.backgroundComposite() != CompositeOperator::SourceOver)
         return false;
 
     return true;
 }
 
@@ -2363,11 +2402,11 @@
 static LayerTraversal traverseVisibleNonCompositedDescendantLayers(RenderLayer& parent, const WTF::Function<LayerTraversal (const RenderLayer&)>& layerFunc)
 {
     // FIXME: We shouldn't be called with a stale z-order lists. See bug 85512.
     parent.updateLayerListsIfNeeded();
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(parent);
 #endif
 
     for (auto* childLayer : parent.normalFlowLayers()) {
         if (compositedWithOwnBackingStore(*childLayer))
@@ -2773,70 +2812,64 @@
     }
 }
 
 void RenderLayerBacking::paintIntoLayer(const GraphicsLayer* graphicsLayer, GraphicsContext& context,
     const IntRect& paintDirtyRect, // In the coords of rootLayer.
-    OptionSet<PaintBehavior> paintBehavior, OptionSet<GraphicsLayerPaintingPhase> paintingPhase)
+    OptionSet<PaintBehavior> paintBehavior, EventRegionContext* eventRegionContext)
 {
-    if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) && paintingPhase != OptionSet<GraphicsLayerPaintingPhase>(GraphicsLayerPaintingPhase::ChildClippingMask)) {
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::paintIntoLayer(): m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::paintIntoLayer(): m_owningLayer is null (55699292)");
+#endif
+
+    if ((paintsIntoWindow() || paintsIntoCompositedAncestor()) && graphicsLayer->paintingPhase() != OptionSet<GraphicsLayerPaintingPhase>(GraphicsLayerPaintingPhase::ChildClippingMask)) {
 #if !PLATFORM(IOS_FAMILY) && !OS(WINDOWS)
         // FIXME: Looks like the CALayer tree is out of sync with the GraphicsLayer heirarchy
-        // when pages are restored from the PageCache.
-        // <rdar://problem/8712587> ASSERT: When Going Back to Page with Plugins in PageCache
+        // when pages are restored from the BackForwardCache.
+        // <rdar://problem/8712587> ASSERT: When Going Back to Page with Plugins in BackForwardCache
         ASSERT_NOT_REACHED();
 #endif
         return;
     }
 
-    OptionSet<RenderLayer::PaintLayerFlag> paintFlags;
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))
-        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))
-        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))
-        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))
-        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))
-        paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))
-        paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
-    if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))
-        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
+    auto paintFlags = paintFlagsForLayer(*graphicsLayer);
 
-    if (graphicsLayer == m_backgroundLayer.get() && m_backgroundLayerPaintsFixedRootBackground)
-        paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
-    else if (compositor().fixedRootBackgroundLayer())
-        paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
+    if (eventRegionContext)
+        paintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);
 
 #ifndef NDEBUG
     RenderElement::SetLayoutNeededForbiddenScope forbidSetNeedsLayout(&renderer());
 #endif
 
     auto paintOneLayer = [&](RenderLayer& layer, OptionSet<RenderLayer::PaintLayerFlag> paintFlags) {
-        InspectorInstrumentation::willPaint(layer.renderer());
-
         FrameView::PaintingState paintingState;
-        if (layer.isRenderViewLayer())
-            renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);
+        if (!eventRegionContext) {
+            InspectorInstrumentation::willPaint(layer.renderer());
+
+            if (layer.isRenderViewLayer())
+                renderer().view().frameView().willPaintContents(context, paintDirtyRect, paintingState);
+        }
 
         RenderLayer::LayerPaintingInfo paintingInfo(&m_owningLayer, paintDirtyRect, paintBehavior, -m_subpixelOffsetFromRenderer);
+        paintingInfo.eventRegionContext = eventRegionContext;
 
         if (&layer == &m_owningLayer) {
             layer.paintLayerContents(context, paintingInfo, paintFlags);
 
-            if (layer.containsDirtyOverlayScrollbars())
+            if (layer.containsDirtyOverlayScrollbars() && !eventRegionContext)
                 layer.paintLayerContents(context, paintingInfo, paintFlags | RenderLayer::PaintLayerPaintingOverlayScrollbars);
         } else
             layer.paintLayerWithEffects(context, paintingInfo, paintFlags);
 
-        if (layer.isRenderViewLayer())
-            renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);
+        if (!eventRegionContext) {
+            if (layer.isRenderViewLayer())
+                renderer().view().frameView().didPaintContents(context, paintDirtyRect, paintingState);
 
-        ASSERT(!m_owningLayer.m_usedTransparency);
+            InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);
+        }
 
-        InspectorInstrumentation::didPaint(layer.renderer(), paintDirtyRect);
+        ASSERT(!m_owningLayer.m_usedTransparency);
     };
 
     paintOneLayer(m_owningLayer, paintFlags);
 
     // FIXME: Need to check m_foregroundLayer, masking etc. webkit.org/b/197565.
@@ -2845,18 +2878,54 @@
     if (graphicsLayer == destinationForSharingLayers) {
         OptionSet<RenderLayer::PaintLayerFlag> sharingLayerPaintFlags = {
             RenderLayer::PaintLayerPaintingCompositingBackgroundPhase,
             RenderLayer::PaintLayerPaintingCompositingForegroundPhase };
 
-        if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))
+        if (graphicsLayer->paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))
             sharingLayerPaintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
+        if (eventRegionContext)
+            sharingLayerPaintFlags.add(RenderLayer::PaintLayerCollectingEventRegion);
 
         for (auto& layerWeakPtr : m_backingSharingLayers)
             paintOneLayer(*layerWeakPtr, sharingLayerPaintFlags);
     }
 
-    compositor().didPaintBacking(this);
+    if (!eventRegionContext)
+        compositor().didPaintBacking(this);
+
+#if USE(OWNING_LAYER_BEAR_TRAP)
+    RELEASE_ASSERT_WITH_MESSAGE(m_owningLayerBearTrap == BEAR_TRAP_VALUE, "RenderLayerBacking::paintIntoLayer() end: m_owningLayerBearTrap caught the bear (55699292)");
+    RELEASE_ASSERT_WITH_MESSAGE(&m_owningLayer, "RenderLayerBacking::paintIntoLayer() end: m_owningLayer is null (55699292)");
+#endif
+}
+
+OptionSet<RenderLayer::PaintLayerFlag> RenderLayerBacking::paintFlagsForLayer(const GraphicsLayer& graphicsLayer) const
+{
+    OptionSet<RenderLayer::PaintLayerFlag> paintFlags;
+
+    auto paintingPhase = graphicsLayer.paintingPhase();
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Background))
+        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingBackgroundPhase);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Foreground))
+        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingForegroundPhase);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::Mask))
+        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingMaskPhase);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::ClipPath))
+        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingClipPathPhase);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::ChildClippingMask))
+        paintFlags.add(RenderLayer::PaintLayerPaintingChildClippingMaskPhase);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))
+        paintFlags.add(RenderLayer::PaintLayerPaintingOverflowContents);
+    if (paintingPhase.contains(GraphicsLayerPaintingPhase::CompositedScroll))
+        paintFlags.add(RenderLayer::PaintLayerPaintingCompositingScrollingPhase);
+
+    if (&graphicsLayer == m_backgroundLayer.get() && m_backgroundLayerPaintsFixedRootBackground)
+        paintFlags.add({ RenderLayer::PaintLayerPaintingRootBackgroundOnly, RenderLayer::PaintLayerPaintingCompositingForegroundPhase }); // Need PaintLayerPaintingCompositingForegroundPhase to walk child layers.
+    else if (compositor().fixedRootBackgroundLayer())
+        paintFlags.add(RenderLayer::PaintLayerPaintingSkipRootBackground);
+
+    return paintFlags;
 }
 
 #if ENABLE(POINTER_EVENTS)
 static RefPtr<Pattern> patternForTouchAction(TouchAction touchAction, FloatSize contentOffset, GraphicsContext& destContext)
 {
@@ -2896,11 +2965,11 @@
     if (!actionIndex || actionIndex >= ARRAY_SIZE(actionsAndColors))
         return nullptr;
 
     const FloatSize tileSize { 32, 18 };
 
-    auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpaceSRGB, destContext);
+    auto imageBuffer = ImageBuffer::createCompatibleBuffer(tileSize, ColorSpace::SRGB, destContext);
     if (!imageBuffer)
         return nullptr;
 
     const auto& touchActionData = actionsAndColors[actionIndex];
     {
@@ -2975,11 +3044,11 @@
     }
 #endif // ENABLE(POINTER_EVENTS)
 }
 
 // Up-call from compositing layer drawing callback.
-void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext& context, OptionSet<GraphicsLayerPaintingPhase> paintingPhase, const FloatRect& clip, GraphicsLayerPaintBehavior layerPaintBehavior)
+void RenderLayerBacking::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext& context, const FloatRect& clip, GraphicsLayerPaintBehavior layerPaintBehavior)
 {
 #ifndef NDEBUG
     renderer().page().setIsPainting(true);
 #endif
 
@@ -3000,22 +3069,22 @@
         || graphicsLayer == m_backgroundLayer.get()
         || graphicsLayer == m_maskLayer.get()
         || graphicsLayer == m_childClippingMaskLayer.get()
         || graphicsLayer == m_scrolledContentsLayer.get()) {
 
-        if (!paintingPhase.contains(GraphicsLayerPaintingPhase::OverflowContents))
+        if (!graphicsLayer->paintingPhase().contains(GraphicsLayerPaintingPhase::OverflowContents))
             dirtyRect.intersect(enclosingIntRect(compositedBoundsIncludingMargin()));
 
         // We have to use the same root as for hit testing, because both methods can compute and cache clipRects.
         OptionSet<PaintBehavior> behavior = PaintBehavior::Normal;
         if (layerPaintBehavior == GraphicsLayerPaintSnapshotting)
             behavior.add(PaintBehavior::Snapshotting);
 
         if (layerPaintBehavior == GraphicsLayerPaintFirstTilePaint)
             behavior.add(PaintBehavior::TileFirstPaint);
 
-        paintIntoLayer(graphicsLayer, context, dirtyRect, behavior, paintingPhase);
+        paintIntoLayer(graphicsLayer, context, dirtyRect, behavior);
 
         if (renderer().settings().visibleDebugOverlayRegions() & NonFastScrollableRegion) // Piggy-back off the setting that shows touch handler regions.
             paintDebugOverlays(graphicsLayer, context);
 
     } else if (graphicsLayer == layerForHorizontalScrollbar()) {
@@ -3212,12 +3281,14 @@
 #if ENABLE(FILTERS_LEVEL_2)
     if (hasBackdropFilter && m_graphicsLayer->addAnimation(backdropFilterVector, IntSize { }, &animation, keyframes.animationName(), timeOffset))
         didAnimate = true;
 #endif
 
-    if (didAnimate)
+    if (didAnimate) {
         m_owningLayer.setNeedsPostLayoutCompositingUpdate();
+        m_owningLayer.setNeedsCompositingGeometryUpdate();
+    }
 
     return didAnimate;
 }
 
 void RenderLayerBacking::animationPaused(double timeOffset, const String& animationName)
@@ -3232,10 +3303,11 @@
 
 void RenderLayerBacking::animationFinished(const String& animationName)
 {
     m_graphicsLayer->removeAnimation(animationName);
     m_owningLayer.setNeedsPostLayoutCompositingUpdate();
+    m_owningLayer.setNeedsCompositingGeometryUpdate();
 }
 
 bool RenderLayerBacking::startTransition(double timeOffset, CSSPropertyID property, const RenderStyle* fromStyle, const RenderStyle* toStyle)
 {
     bool didAnimate = false;
@@ -3323,11 +3395,12 @@
     }
 }
 
 void RenderLayerBacking::notifyAnimationStarted(const GraphicsLayer*, const String&, MonotonicTime time)
 {
-    renderer().animation().notifyAnimationStarted(renderer(), time);
+    if (!RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
+        renderer().animation().notifyAnimationStarted(renderer(), time);
 }
 
 void RenderLayerBacking::notifyFlushRequired(const GraphicsLayer* layer)
 {
     if (renderer().renderTreeBeingDestroyed())

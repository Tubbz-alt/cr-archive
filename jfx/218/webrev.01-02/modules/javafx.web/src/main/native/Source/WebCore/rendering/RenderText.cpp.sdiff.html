<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTableSection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderText.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;BreakLines.h&quot;
  30 #include &quot;BreakingContext.h&quot;
  31 #include &quot;CharacterProperties.h&quot;
  32 #include &quot;DocumentMarkerController.h&quot;
  33 #include &quot;EllipsisBox.h&quot;
  34 #include &quot;FloatQuad.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;Hyphenation.h&quot;
  39 #include &quot;InlineTextBox.h&quot;

  40 #include &quot;Range.h&quot;
  41 #include &quot;RenderBlock.h&quot;
  42 #include &quot;RenderCombineText.h&quot;
  43 #include &quot;RenderInline.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderView.h&quot;
  46 #include &quot;RenderedDocumentMarker.h&quot;
  47 #include &quot;Settings.h&quot;
  48 #include &quot;SimpleLineLayoutFunctions.h&quot;
  49 #include &quot;Text.h&quot;
  50 #include &quot;TextResourceDecoder.h&quot;
  51 #include &quot;VisiblePosition.h&quot;
  52 #include &lt;wtf/IsoMallocInlines.h&gt;
  53 #include &lt;wtf/NeverDestroyed.h&gt;
  54 #include &lt;wtf/text/StringBuilder.h&gt;
  55 #include &lt;wtf/text/TextBreakIterator.h&gt;
  56 #include &lt;wtf/unicode/CharacterNames.h&gt;
  57 
  58 #if PLATFORM(IOS_FAMILY)
  59 #include &quot;Document.h&quot;
</pre>
<hr />
<pre>
 289     else
 290         m_lineBoxes.invalidateParentChildLists();
 291 #endif
 292     m_lineBoxes.deleteAll();
 293 }
 294 
 295 void RenderText::willBeDestroyed()
 296 {
 297     secureTextTimers().remove(this);
 298 
 299     removeAndDestroyTextBoxes();
 300 
 301     if (m_originalTextDiffersFromRendered)
 302         originalTextMap().remove(this);
 303 
 304     setInlineWrapperForDisplayContents(nullptr);
 305 
 306     RenderObject::willBeDestroyed();
 307 }
 308 
<span class="line-removed"> 309 void RenderText::deleteLineBoxesBeforeSimpleLineLayout()</span>
<span class="line-removed"> 310 {</span>
<span class="line-removed"> 311     m_lineBoxes.deleteAll();</span>
<span class="line-removed"> 312 }</span>
<span class="line-removed"> 313 </span>
 314 String RenderText::originalText() const
 315 {
 316     return m_originalTextDiffersFromRendered ? originalTextMap().get(this) : m_text;
 317 }
 318 
 319 void RenderText::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 320 {
<span class="line-modified"> 321     if (auto* layout = simpleLineLayout()) {</span>
<span class="line-modified"> 322         rects.appendVector(SimpleLineLayout::collectAbsoluteRects(*this, *layout, accumulatedOffset));</span>
<span class="line-modified"> 323         return;</span>
 324     }
<span class="line-removed"> 325     rects.appendVector(m_lineBoxes.absoluteRects(accumulatedOffset));</span>
 326 }
 327 
 328 Vector&lt;IntRect&gt; RenderText::absoluteRectsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
 329 {
 330     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
 331 
 332     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 333     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 334     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 335     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 336     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 337     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 338     ASSERT(start &lt;= INT_MAX);
 339     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 340     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 341 
 342     return m_lineBoxes.absoluteRectsForRange(*this, start, end, useSelectionHeight, wasFixed);
 343 }
 344 
 345 #if PLATFORM(IOS_FAMILY)
 346 // This function is similar in spirit to addLineBoxRects, but returns rectangles
 347 // which are annotated with additional state which helps the iPhone draw selections in its unique way.
 348 // Full annotations are added in this class.
 349 void RenderText::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned start, unsigned end)
 350 {
 351     // FIXME: Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 352     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 353     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 354     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 355     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 356     ASSERT(end == std::numeric_limits&lt;unsigned&gt;::max() || end &lt;= std::numeric_limits&lt;int&gt;::max());
 357     ASSERT(start &lt;= std::numeric_limits&lt;int&gt;::max());
 358     start = std::min(start, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 359     end = std::min(end, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 360 
 361     for (InlineTextBox* box = firstTextBox(); box; box = box-&gt;nextTextBox()) {
 362         LayoutRect rect;
<span class="line-modified"> 363         // Note, box-&gt;end() returns the index of the last character, not the index past it.</span>
<span class="line-removed"> 364         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt; end)</span>
 365             rect = box-&gt;localSelectionRect(start, end);
 366         else {
<span class="line-modified"> 367             unsigned realEnd = std::min(box-&gt;end() + 1, end);</span>
 368             rect = box-&gt;localSelectionRect(start, realEnd);
 369             if (rect.isEmpty())
 370                 continue;
 371         }
 372 
 373         if (box-&gt;root().isFirstAfterPageBreak()) {
 374             if (box-&gt;isHorizontal())
 375                 rect.shiftYEdgeTo(box-&gt;root().lineTopWithLeading());
 376             else
 377                 rect.shiftXEdgeTo(box-&gt;root().lineTopWithLeading());
 378         }
 379 
 380         RenderBlock* containingBlock = this-&gt;containingBlock();
 381         // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
 382         LogicalSelectionOffsetCaches cache(*containingBlock);
 383         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 384         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 385         LayoutRect extentsRect = rect;
 386         if (box-&gt;isHorizontal()) {
 387             extentsRect.setX(leftOffset);
 388             extentsRect.setWidth(rightOffset - leftOffset);
 389         } else {
 390             extentsRect.setY(leftOffset);
 391             extentsRect.setHeight(rightOffset - leftOffset);
 392         }
 393         extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
 394         if (!box-&gt;isHorizontal())
 395             extentsRect = extentsRect.transposedRect();
 396         bool isFirstOnLine = !box-&gt;previousOnLineExists();
 397         bool isLastOnLine = !box-&gt;nextOnLineExists();
 398         if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
 399             isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 400 
<span class="line-modified"> 401         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() + 1 &gt;= start;</span>
<span class="line-modified"> 402         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() + 1 &gt;= end;</span>
 403 
 404         bool isFixed = false;
 405         IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
 406         bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
 407         // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
 408         // to determine the orientation of the block. In this case we also use the inlineBoxWrapper to
 409         // determine if the element is the last on the line.
 410         if (containingBlock-&gt;inlineBoxWrapper()) {
 411             if (containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal() != boxIsHorizontal) {
 412                 boxIsHorizontal = containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal();
 413                 isLastOnLine = !containingBlock-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 414             }
 415         }
 416 
 417         rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, containsStart, containsEnd, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
 418     }
 419 }
 420 #endif
 421 











 422 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsClippedToEllipsis() const
 423 {
<span class="line-modified"> 424     if (auto* layout = simpleLineLayout()) {</span>
 425         ASSERT(style().textOverflow() != TextOverflow::Ellipsis);
<span class="line-modified"> 426         return SimpleLineLayout::collectAbsoluteQuads(*this, *layout, nullptr);</span>
 427     }
 428     return m_lineBoxes.absoluteQuads(*this, nullptr, RenderTextLineBoxes::ClipToEllipsis);
 429 }
 430 
 431 void RenderText::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 432 {
<span class="line-modified"> 433     if (auto* layout = simpleLineLayout()) {</span>
<span class="line-modified"> 434         quads.appendVector(SimpleLineLayout::collectAbsoluteQuads(*this, *layout, wasFixed));</span>
 435         return;
 436     }
 437     quads.appendVector(m_lineBoxes.absoluteQuads(*this, wasFixed, RenderTextLineBoxes::NoClipping));
 438 }
 439 
<span class="line-modified"> 440 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const</span>
 441 {
 442     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 443     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 444     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 445     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 446     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 447     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 448     ASSERT(start &lt;= INT_MAX);
 449     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 450     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 451     if (simpleLineLayout() &amp;&amp; !useSelectionHeight)
<span class="line-modified"> 452         return collectAbsoluteQuadsForRange(*this, start, end, *simpleLineLayout(), wasFixed);</span>
 453     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
<span class="line-modified"> 454     return m_lineBoxes.absoluteQuadsForRange(*this, start, end, useSelectionHeight, wasFixed);</span>
 455 }
 456 
 457 Position RenderText::positionForPoint(const LayoutPoint&amp; point)
 458 {
 459     if (simpleLineLayout() &amp;&amp; parent()-&gt;firstChild() == parent()-&gt;lastChild()) {
 460         auto offset = SimpleLineLayout::textOffsetForPoint(point, *this, *simpleLineLayout());
 461         // Did not find a valid offset. Fall back to the normal line layout based Position.
 462         if (offset == text().length())
 463             return positionForPoint(point, nullptr).deepEquivalent();
 464         auto position = Position(textNode(), offset);
 465         ASSERT(position == positionForPoint(point, nullptr).deepEquivalent());
 466         return position;
 467     }
 468     return positionForPoint(point, nullptr).deepEquivalent();
 469 }
 470 
 471 VisiblePosition RenderText::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
 472 {
 473     ensureLineBoxes();
 474     return m_lineBoxes.positionForPoint(*this, point);
</pre>
<hr />
<pre>
1064     if (markers.isEmpty())
1065         return { };
1066 
1067     Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; draggedContentRanges;
1068     for (auto* marker : markers) {
1069         unsigned markerStart = std::max(marker-&gt;startOffset(), startOffset);
1070         unsigned markerEnd = std::min(marker-&gt;endOffset(), endOffset);
1071         if (markerStart &gt;= markerEnd || markerStart &gt; endOffset || markerEnd &lt; startOffset)
1072             continue;
1073 
1074         std::pair&lt;unsigned, unsigned&gt; draggedContentRange;
1075         draggedContentRange.first = markerStart;
1076         draggedContentRange.second = markerEnd;
1077         draggedContentRanges.append(draggedContentRange);
1078     }
1079     return draggedContentRanges;
1080 }
1081 
1082 IntPoint RenderText::firstRunLocation() const
1083 {
<span class="line-modified">1084     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">1085         return SimpleLineLayout::computeFirstRunLocation(*this, *layout);</span>
<span class="line-modified">1086 </span>
<span class="line-modified">1087     return m_lineBoxes.firstRunLocation();</span>
1088 }
1089 
1090 void RenderText::setSelectionState(SelectionState state)
1091 {
1092     if (state != SelectionNone)
1093         ensureLineBoxes();
1094 
1095     RenderObject::setSelectionState(state);
1096 
1097     if (canUpdateSelectionOnRootLineBoxes())
1098         m_lineBoxes.setSelectionState(*this, state);
1099 
1100     // The containing block can be null in case of an orphaned tree.
1101     RenderBlock* containingBlock = this-&gt;containingBlock();
1102     if (containingBlock &amp;&amp; !containingBlock-&gt;isRenderView())
1103         containingBlock-&gt;setSelectionState(state);
1104 }
1105 
1106 void RenderText::setTextWithOffset(const String&amp; newText, unsigned offset, unsigned length, bool force)
1107 {
1108     if (!force &amp;&amp; text() == newText)
1109         return;
1110 
1111     int delta = newText.length() - text().length();
<span class="line-modified">1112     unsigned end = length ? offset + length - 1 : offset;</span>
1113 
1114     m_linesDirty = simpleLineLayout() || m_lineBoxes.dirtyRange(*this, offset, end, delta);
1115 
1116     setText(newText, force || m_linesDirty);
1117 }
1118 
1119 static inline bool isInlineFlowOrEmptyText(const RenderObject&amp; renderer)
1120 {
1121     return is&lt;RenderInline&gt;(renderer) || (is&lt;RenderText&gt;(renderer) &amp;&amp; downcast&lt;RenderText&gt;(renderer).text().isEmpty());
1122 }
1123 
1124 UChar RenderText::previousCharacter() const
1125 {
1126     // find previous text renderer if one exists
1127     const RenderObject* previousText = this;
1128     while ((previousText = previousText-&gt;previousInPreOrder())) {
1129         if (!isInlineFlowOrEmptyText(*previousText))
1130             break;
1131     }
1132     if (!is&lt;RenderText&gt;(previousText))
</pre>
<hr />
<pre>
1318 {
1319     if (!textBox.hasTextContent())
1320         return;
1321     m_containsReversedText |= !textBox.isLeftToRightDirection();
1322 }
1323 
1324 void RenderText::ensureLineBoxes()
1325 {
1326     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1327         return;
1328     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
1329 }
1330 
1331 const SimpleLineLayout::Layout* RenderText::simpleLineLayout() const
1332 {
1333     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1334         return nullptr;
1335     return downcast&lt;RenderBlockFlow&gt;(*parent()).simpleLineLayout();
1336 }
1337 




















1338 float RenderText::width(unsigned from, unsigned len, float xPos, bool firstLine, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1339 {
1340     if (from &gt;= text().length())
1341         return 0;
1342 
1343     if (from + len &gt; text().length())
1344         len = text().length() - from;
1345 
1346     const RenderStyle&amp; lineStyle = firstLine ? firstLineStyle() : style();
1347     return width(from, len, lineStyle.fontCascade(), xPos, fallbackFonts, glyphOverflow);
1348 }
1349 
1350 float RenderText::width(unsigned from, unsigned len, const FontCascade&amp; f, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1351 {
1352     ASSERT(from + len &lt;= text().length());
1353     if (!text().length())
1354         return 0;
1355 
1356     const RenderStyle&amp; style = this-&gt;style();
1357     float w;
</pre>
<hr />
<pre>
1366                 }
1367                 w = m_maxWidth;
1368             } else
1369                 w = maxLogicalWidth();
1370         } else
1371             w = widthFromCache(f, from, len, xPos, fallbackFonts, glyphOverflow, style);
1372     } else {
1373         TextRun run = RenderBlock::constructTextRun(*this, from, len, style);
1374         run.setCharacterScanForCodePath(!canUseSimpleFontCodePath());
1375         run.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
1376         run.setXPos(xPos);
1377 
1378         w = f.width(run, fallbackFonts, glyphOverflow);
1379     }
1380 
1381     return w;
1382 }
1383 
1384 IntRect RenderText::linesBoundingBox() const
1385 {
<span class="line-modified">1386     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">1387         return SimpleLineLayout::computeBoundingBox(*this, *layout);</span>

1388 
<span class="line-modified">1389     return m_lineBoxes.boundingBox(*this);</span>




1390 }
1391 
1392 LayoutRect RenderText::linesVisualOverflowBoundingBox() const
1393 {
1394     ASSERT(!simpleLineLayout());
1395     return m_lineBoxes.visualOverflowBoundingBox(*this);
1396 }
1397 
1398 LayoutRect RenderText::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
1399 {
1400     RenderObject* rendererToRepaint = containingBlock();
1401 
1402     // Do not cross self-painting layer boundaries.
1403     RenderObject&amp; enclosingLayerRenderer = enclosingLayer()-&gt;renderer();
1404     if (&amp;enclosingLayerRenderer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(&amp;enclosingLayerRenderer))
1405         rendererToRepaint = &amp;enclosingLayerRenderer;
1406 
1407     // The renderer we chose to repaint may be an ancestor of repaintContainer, but we need to do a repaintContainer-relative repaint.
1408     if (repaintContainer &amp;&amp; repaintContainer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(repaintContainer))
1409         return repaintContainer-&gt;clippedOverflowRectForRepaint(repaintContainer);
1410 
1411     return rendererToRepaint-&gt;clippedOverflowRectForRepaint(repaintContainer);
1412 }
1413 
1414 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;* rects)
1415 {
1416     ASSERT(!needsLayout());
1417     ASSERT(!simpleLineLayout());
1418 
1419     if (selectionState() == SelectionNone)
1420         return LayoutRect();
1421     if (!containingBlock())
1422         return LayoutRect();
1423 
1424     // Now calculate startPos and endPos for painting selection.
1425     // We include a selection while endPos &gt; 0
<span class="line-modified">1426     unsigned startPos;</span>
<span class="line-modified">1427     unsigned endPos;</span>
1428     if (selectionState() == SelectionInside) {
1429         // We are fully selected.
<span class="line-modified">1430         startPos = 0;</span>
<span class="line-modified">1431         endPos = text().length();</span>
1432     } else {
<span class="line-modified">1433         startPos = view().selection().startPosition();</span>
<span class="line-modified">1434         endPos = view().selection().endPosition();</span>
1435         if (selectionState() == SelectionStart)
<span class="line-modified">1436             endPos = text().length();</span>
1437         else if (selectionState() == SelectionEnd)
<span class="line-modified">1438             startPos = 0;</span>
1439     }
1440 
<span class="line-modified">1441     if (startPos == endPos)</span>
1442         return IntRect();
1443 
1444     LayoutRect resultRect;
1445     if (!rects)
<span class="line-modified">1446         resultRect = m_lineBoxes.selectionRectForRange(startPos, endPos);</span>
1447     else {
<span class="line-modified">1448         m_lineBoxes.collectSelectionRectsForRange(startPos, endPos, *rects);</span>
1449         for (auto&amp; rect : *rects) {
1450             resultRect.unite(rect);
1451             rect = localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
1452         }
1453     }
1454 
1455     if (clipToVisibleContent)
1456         return computeRectForRepaint(resultRect, repaintContainer);
1457     return localToContainerQuad(FloatRect(resultRect), repaintContainer).enclosingBoundingBox();
1458 }
1459 
1460 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;&amp; rects)
1461 {
1462     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, &amp;rects);
1463 }
1464 
1465 LayoutRect RenderText::selectionRectForRepaint(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent)
1466 {
1467     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, nullptr);
1468 }
1469 
1470 int RenderText::caretMinOffset() const
1471 {
<span class="line-modified">1472     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">1473         return SimpleLineLayout::findCaretMinimumOffset(*this, *layout);</span>
<span class="line-modified">1474     return m_lineBoxes.caretMinOffset();</span>






1475 }
1476 
1477 int RenderText::caretMaxOffset() const
1478 {
<span class="line-modified">1479     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">1480         return SimpleLineLayout::findCaretMaximumOffset(*this, *layout);</span>
<span class="line-modified">1481     return m_lineBoxes.caretMaxOffset(*this);</span>






1482 }
1483 
1484 unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
1485 {
<span class="line-modified">1486     ASSERT(!simpleLineLayout());</span>
<span class="line-modified">1487     return m_lineBoxes.countCharacterOffsetsUntil(offset);</span>































1488 }
1489 
1490 bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
1491 {
<span class="line-modified">1492     if (auto* layout = simpleLineLayout())</span>
<span class="line-removed">1493         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CharacterOffset);</span>
<span class="line-removed">1494     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CharacterOffset);</span>
1495 }
1496 
1497 bool RenderText::containsCaretOffset(unsigned offset) const
1498 {
<span class="line-modified">1499     if (auto* layout = simpleLineLayout())</span>
<span class="line-removed">1500         return SimpleLineLayout::containsOffset(*this, *layout, offset, SimpleLineLayout::OffsetType::CaretOffset);</span>
<span class="line-removed">1501     return m_lineBoxes.containsOffset(*this, offset, RenderTextLineBoxes::CaretOffset);</span>
1502 }
1503 
1504 bool RenderText::hasRenderedText() const
1505 {
<span class="line-modified">1506     if (auto* layout = simpleLineLayout())</span>
<span class="line-modified">1507         return SimpleLineLayout::isTextRendered(*this, *layout);</span>
<span class="line-modified">1508     return m_lineBoxes.hasRenderedText();</span>


1509 }
1510 
1511 int RenderText::previousOffset(int current) const
1512 {
1513     if (m_isAllASCII || text().is8Bit())
1514         return current - 1;
1515 
1516     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1517     return iterator.preceding(current).valueOr(current - 1);
1518 }
1519 
1520 int RenderText::previousOffsetForBackwardDeletion(int current) const
1521 {
1522     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Delete, nullAtom());
1523     return iterator.preceding(current).valueOr(0);
1524 }
1525 
1526 int RenderText::nextOffset(int current) const
1527 {
1528     if (m_isAllASCII || text().is8Bit())
</pre>
</td>
<td>
<hr />
<pre>
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderText.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;BreakLines.h&quot;
  30 #include &quot;BreakingContext.h&quot;
  31 #include &quot;CharacterProperties.h&quot;
  32 #include &quot;DocumentMarkerController.h&quot;
  33 #include &quot;EllipsisBox.h&quot;
  34 #include &quot;FloatQuad.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;Hyphenation.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
<span class="line-added">  40 #include &quot;LineLayoutTraversal.h&quot;</span>
  41 #include &quot;Range.h&quot;
  42 #include &quot;RenderBlock.h&quot;
  43 #include &quot;RenderCombineText.h&quot;
  44 #include &quot;RenderInline.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;RenderedDocumentMarker.h&quot;
  48 #include &quot;Settings.h&quot;
  49 #include &quot;SimpleLineLayoutFunctions.h&quot;
  50 #include &quot;Text.h&quot;
  51 #include &quot;TextResourceDecoder.h&quot;
  52 #include &quot;VisiblePosition.h&quot;
  53 #include &lt;wtf/IsoMallocInlines.h&gt;
  54 #include &lt;wtf/NeverDestroyed.h&gt;
  55 #include &lt;wtf/text/StringBuilder.h&gt;
  56 #include &lt;wtf/text/TextBreakIterator.h&gt;
  57 #include &lt;wtf/unicode/CharacterNames.h&gt;
  58 
  59 #if PLATFORM(IOS_FAMILY)
  60 #include &quot;Document.h&quot;
</pre>
<hr />
<pre>
 290     else
 291         m_lineBoxes.invalidateParentChildLists();
 292 #endif
 293     m_lineBoxes.deleteAll();
 294 }
 295 
 296 void RenderText::willBeDestroyed()
 297 {
 298     secureTextTimers().remove(this);
 299 
 300     removeAndDestroyTextBoxes();
 301 
 302     if (m_originalTextDiffersFromRendered)
 303         originalTextMap().remove(this);
 304 
 305     setInlineWrapperForDisplayContents(nullptr);
 306 
 307     RenderObject::willBeDestroyed();
 308 }
 309 





 310 String RenderText::originalText() const
 311 {
 312     return m_originalTextDiffersFromRendered ? originalTextMap().get(this) : m_text;
 313 }
 314 
 315 void RenderText::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 316 {
<span class="line-modified"> 317     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-modified"> 318         auto rect = box.rect();</span>
<span class="line-modified"> 319         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));</span>
 320     }

 321 }
 322 
 323 Vector&lt;IntRect&gt; RenderText::absoluteRectsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
 324 {
 325     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
 326 
 327     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 328     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 329     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 330     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 331     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 332     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 333     ASSERT(start &lt;= INT_MAX);
 334     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 335     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 336 
 337     return m_lineBoxes.absoluteRectsForRange(*this, start, end, useSelectionHeight, wasFixed);
 338 }
 339 
 340 #if PLATFORM(IOS_FAMILY)
 341 // This function is similar in spirit to addLineBoxRects, but returns rectangles
 342 // which are annotated with additional state which helps the iPhone draw selections in its unique way.
 343 // Full annotations are added in this class.
 344 void RenderText::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned start, unsigned end)
 345 {
 346     // FIXME: Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 347     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 348     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 349     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 350     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 351     ASSERT(end == std::numeric_limits&lt;unsigned&gt;::max() || end &lt;= std::numeric_limits&lt;int&gt;::max());
 352     ASSERT(start &lt;= std::numeric_limits&lt;int&gt;::max());
 353     start = std::min(start, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 354     end = std::min(end, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 355 
 356     for (InlineTextBox* box = firstTextBox(); box; box = box-&gt;nextTextBox()) {
 357         LayoutRect rect;
<span class="line-modified"> 358         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end)</span>

 359             rect = box-&gt;localSelectionRect(start, end);
 360         else {
<span class="line-modified"> 361             unsigned realEnd = std::min(box-&gt;end(), end);</span>
 362             rect = box-&gt;localSelectionRect(start, realEnd);
 363             if (rect.isEmpty())
 364                 continue;
 365         }
 366 
 367         if (box-&gt;root().isFirstAfterPageBreak()) {
 368             if (box-&gt;isHorizontal())
 369                 rect.shiftYEdgeTo(box-&gt;root().lineTopWithLeading());
 370             else
 371                 rect.shiftXEdgeTo(box-&gt;root().lineTopWithLeading());
 372         }
 373 
 374         RenderBlock* containingBlock = this-&gt;containingBlock();
 375         // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
 376         LogicalSelectionOffsetCaches cache(*containingBlock);
 377         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 378         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 379         LayoutRect extentsRect = rect;
 380         if (box-&gt;isHorizontal()) {
 381             extentsRect.setX(leftOffset);
 382             extentsRect.setWidth(rightOffset - leftOffset);
 383         } else {
 384             extentsRect.setY(leftOffset);
 385             extentsRect.setHeight(rightOffset - leftOffset);
 386         }
 387         extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
 388         if (!box-&gt;isHorizontal())
 389             extentsRect = extentsRect.transposedRect();
 390         bool isFirstOnLine = !box-&gt;previousOnLineExists();
 391         bool isLastOnLine = !box-&gt;nextOnLineExists();
 392         if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
 393             isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 394 
<span class="line-modified"> 395         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() &gt;= start;</span>
<span class="line-modified"> 396         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() &gt;= end;</span>
 397 
 398         bool isFixed = false;
 399         IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
 400         bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
 401         // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
 402         // to determine the orientation of the block. In this case we also use the inlineBoxWrapper to
 403         // determine if the element is the last on the line.
 404         if (containingBlock-&gt;inlineBoxWrapper()) {
 405             if (containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal() != boxIsHorizontal) {
 406                 boxIsHorizontal = containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal();
 407                 isLastOnLine = !containingBlock-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 408             }
 409         }
 410 
 411         rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, containsStart, containsEnd, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
 412     }
 413 }
 414 #endif
 415 
<span class="line-added"> 416 static Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForNonComplexPaths(const RenderText&amp; textRenderer, bool* wasFixed)</span>
<span class="line-added"> 417 {</span>
<span class="line-added"> 418     // FIXME: This generic function doesn&#39;t currently cover everything that is needed for the complex line layout path.</span>
<span class="line-added"> 419     ASSERT(!textRenderer.usesComplexLineLayoutPath());</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     Vector&lt;FloatQuad&gt; quads;</span>
<span class="line-added"> 422     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(textRenderer))</span>
<span class="line-added"> 423         quads.append(textRenderer.localToAbsoluteQuad(FloatQuad(box.rect()), UseTransforms, wasFixed));</span>
<span class="line-added"> 424     return quads;</span>
<span class="line-added"> 425 }</span>
<span class="line-added"> 426 </span>
 427 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsClippedToEllipsis() const
 428 {
<span class="line-modified"> 429     if (!usesComplexLineLayoutPath()) {</span>
 430         ASSERT(style().textOverflow() != TextOverflow::Ellipsis);
<span class="line-modified"> 431         return collectAbsoluteQuadsForNonComplexPaths(*this, nullptr);</span>
 432     }
 433     return m_lineBoxes.absoluteQuads(*this, nullptr, RenderTextLineBoxes::ClipToEllipsis);
 434 }
 435 
 436 void RenderText::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 437 {
<span class="line-modified"> 438     if (!usesComplexLineLayoutPath()) {</span>
<span class="line-modified"> 439         quads.appendVector(collectAbsoluteQuadsForNonComplexPaths(*this, wasFixed));</span>
 440         return;
 441     }
 442     quads.appendVector(m_lineBoxes.absoluteQuads(*this, wasFixed, RenderTextLineBoxes::NoClipping));
 443 }
 444 
<span class="line-modified"> 445 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const</span>
 446 {
 447     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 448     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 449     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 450     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 451     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 452     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 453     ASSERT(start &lt;= INT_MAX);
 454     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 455     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 456     if (simpleLineLayout() &amp;&amp; !useSelectionHeight)
<span class="line-modified"> 457         return collectAbsoluteQuadsForRange(*this, start, end, *simpleLineLayout(), ignoreEmptyTextSelections, wasFixed);</span>
 458     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
<span class="line-modified"> 459     return m_lineBoxes.absoluteQuadsForRange(*this, start, end, useSelectionHeight, ignoreEmptyTextSelections, wasFixed);</span>
 460 }
 461 
 462 Position RenderText::positionForPoint(const LayoutPoint&amp; point)
 463 {
 464     if (simpleLineLayout() &amp;&amp; parent()-&gt;firstChild() == parent()-&gt;lastChild()) {
 465         auto offset = SimpleLineLayout::textOffsetForPoint(point, *this, *simpleLineLayout());
 466         // Did not find a valid offset. Fall back to the normal line layout based Position.
 467         if (offset == text().length())
 468             return positionForPoint(point, nullptr).deepEquivalent();
 469         auto position = Position(textNode(), offset);
 470         ASSERT(position == positionForPoint(point, nullptr).deepEquivalent());
 471         return position;
 472     }
 473     return positionForPoint(point, nullptr).deepEquivalent();
 474 }
 475 
 476 VisiblePosition RenderText::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
 477 {
 478     ensureLineBoxes();
 479     return m_lineBoxes.positionForPoint(*this, point);
</pre>
<hr />
<pre>
1069     if (markers.isEmpty())
1070         return { };
1071 
1072     Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; draggedContentRanges;
1073     for (auto* marker : markers) {
1074         unsigned markerStart = std::max(marker-&gt;startOffset(), startOffset);
1075         unsigned markerEnd = std::min(marker-&gt;endOffset(), endOffset);
1076         if (markerStart &gt;= markerEnd || markerStart &gt; endOffset || markerEnd &lt; startOffset)
1077             continue;
1078 
1079         std::pair&lt;unsigned, unsigned&gt; draggedContentRange;
1080         draggedContentRange.first = markerStart;
1081         draggedContentRange.second = markerEnd;
1082         draggedContentRanges.append(draggedContentRange);
1083     }
1084     return draggedContentRanges;
1085 }
1086 
1087 IntPoint RenderText::firstRunLocation() const
1088 {
<span class="line-modified">1089     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">1090     if (!first)</span>
<span class="line-modified">1091         return { };</span>
<span class="line-modified">1092     return IntPoint(first-&gt;rect().location());</span>
1093 }
1094 
1095 void RenderText::setSelectionState(SelectionState state)
1096 {
1097     if (state != SelectionNone)
1098         ensureLineBoxes();
1099 
1100     RenderObject::setSelectionState(state);
1101 
1102     if (canUpdateSelectionOnRootLineBoxes())
1103         m_lineBoxes.setSelectionState(*this, state);
1104 
1105     // The containing block can be null in case of an orphaned tree.
1106     RenderBlock* containingBlock = this-&gt;containingBlock();
1107     if (containingBlock &amp;&amp; !containingBlock-&gt;isRenderView())
1108         containingBlock-&gt;setSelectionState(state);
1109 }
1110 
1111 void RenderText::setTextWithOffset(const String&amp; newText, unsigned offset, unsigned length, bool force)
1112 {
1113     if (!force &amp;&amp; text() == newText)
1114         return;
1115 
1116     int delta = newText.length() - text().length();
<span class="line-modified">1117     unsigned end = offset + length;</span>
1118 
1119     m_linesDirty = simpleLineLayout() || m_lineBoxes.dirtyRange(*this, offset, end, delta);
1120 
1121     setText(newText, force || m_linesDirty);
1122 }
1123 
1124 static inline bool isInlineFlowOrEmptyText(const RenderObject&amp; renderer)
1125 {
1126     return is&lt;RenderInline&gt;(renderer) || (is&lt;RenderText&gt;(renderer) &amp;&amp; downcast&lt;RenderText&gt;(renderer).text().isEmpty());
1127 }
1128 
1129 UChar RenderText::previousCharacter() const
1130 {
1131     // find previous text renderer if one exists
1132     const RenderObject* previousText = this;
1133     while ((previousText = previousText-&gt;previousInPreOrder())) {
1134         if (!isInlineFlowOrEmptyText(*previousText))
1135             break;
1136     }
1137     if (!is&lt;RenderText&gt;(previousText))
</pre>
<hr />
<pre>
1323 {
1324     if (!textBox.hasTextContent())
1325         return;
1326     m_containsReversedText |= !textBox.isLeftToRightDirection();
1327 }
1328 
1329 void RenderText::ensureLineBoxes()
1330 {
1331     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1332         return;
1333     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
1334 }
1335 
1336 const SimpleLineLayout::Layout* RenderText::simpleLineLayout() const
1337 {
1338     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1339         return nullptr;
1340     return downcast&lt;RenderBlockFlow&gt;(*parent()).simpleLineLayout();
1341 }
1342 
<span class="line-added">1343 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">1344 const LayoutIntegration::LineLayout* RenderText::layoutFormattingContextLineLayout() const</span>
<span class="line-added">1345 {</span>
<span class="line-added">1346     if (!is&lt;RenderBlockFlow&gt;(*parent()))</span>
<span class="line-added">1347         return nullptr;</span>
<span class="line-added">1348     return downcast&lt;RenderBlockFlow&gt;(*parent()).layoutFormattingContextLineLayout();</span>
<span class="line-added">1349 }</span>
<span class="line-added">1350 #endif</span>
<span class="line-added">1351 </span>
<span class="line-added">1352 bool RenderText::usesComplexLineLayoutPath() const</span>
<span class="line-added">1353 {</span>
<span class="line-added">1354     if (simpleLineLayout())</span>
<span class="line-added">1355         return false;</span>
<span class="line-added">1356 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">1357     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">1358         return false;</span>
<span class="line-added">1359 #endif</span>
<span class="line-added">1360     return true;</span>
<span class="line-added">1361 }</span>
<span class="line-added">1362 </span>
1363 float RenderText::width(unsigned from, unsigned len, float xPos, bool firstLine, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1364 {
1365     if (from &gt;= text().length())
1366         return 0;
1367 
1368     if (from + len &gt; text().length())
1369         len = text().length() - from;
1370 
1371     const RenderStyle&amp; lineStyle = firstLine ? firstLineStyle() : style();
1372     return width(from, len, lineStyle.fontCascade(), xPos, fallbackFonts, glyphOverflow);
1373 }
1374 
1375 float RenderText::width(unsigned from, unsigned len, const FontCascade&amp; f, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1376 {
1377     ASSERT(from + len &lt;= text().length());
1378     if (!text().length())
1379         return 0;
1380 
1381     const RenderStyle&amp; style = this-&gt;style();
1382     float w;
</pre>
<hr />
<pre>
1391                 }
1392                 w = m_maxWidth;
1393             } else
1394                 w = maxLogicalWidth();
1395         } else
1396             w = widthFromCache(f, from, len, xPos, fallbackFonts, glyphOverflow, style);
1397     } else {
1398         TextRun run = RenderBlock::constructTextRun(*this, from, len, style);
1399         run.setCharacterScanForCodePath(!canUseSimpleFontCodePath());
1400         run.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
1401         run.setXPos(xPos);
1402 
1403         w = f.width(run, fallbackFonts, glyphOverflow);
1404     }
1405 
1406     return w;
1407 }
1408 
1409 IntRect RenderText::linesBoundingBox() const
1410 {
<span class="line-modified">1411     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">1412     if (!first)</span>
<span class="line-added">1413         return { };</span>
1414 
<span class="line-modified">1415     auto boundingBox = first-&gt;rect();</span>
<span class="line-added">1416     for (auto box = first; ++box;)</span>
<span class="line-added">1417         boundingBox.uniteEvenIfEmpty(box-&gt;rect());</span>
<span class="line-added">1418 </span>
<span class="line-added">1419     return enclosingIntRect(boundingBox);</span>
1420 }
1421 
1422 LayoutRect RenderText::linesVisualOverflowBoundingBox() const
1423 {
1424     ASSERT(!simpleLineLayout());
1425     return m_lineBoxes.visualOverflowBoundingBox(*this);
1426 }
1427 
1428 LayoutRect RenderText::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
1429 {
1430     RenderObject* rendererToRepaint = containingBlock();
1431 
1432     // Do not cross self-painting layer boundaries.
1433     RenderObject&amp; enclosingLayerRenderer = enclosingLayer()-&gt;renderer();
1434     if (&amp;enclosingLayerRenderer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(&amp;enclosingLayerRenderer))
1435         rendererToRepaint = &amp;enclosingLayerRenderer;
1436 
1437     // The renderer we chose to repaint may be an ancestor of repaintContainer, but we need to do a repaintContainer-relative repaint.
1438     if (repaintContainer &amp;&amp; repaintContainer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(repaintContainer))
1439         return repaintContainer-&gt;clippedOverflowRectForRepaint(repaintContainer);
1440 
1441     return rendererToRepaint-&gt;clippedOverflowRectForRepaint(repaintContainer);
1442 }
1443 
1444 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;* rects)
1445 {
1446     ASSERT(!needsLayout());
1447     ASSERT(!simpleLineLayout());
1448 
1449     if (selectionState() == SelectionNone)
1450         return LayoutRect();
1451     if (!containingBlock())
1452         return LayoutRect();
1453 
1454     // Now calculate startPos and endPos for painting selection.
1455     // We include a selection while endPos &gt; 0
<span class="line-modified">1456     unsigned startOffset;</span>
<span class="line-modified">1457     unsigned endOffset;</span>
1458     if (selectionState() == SelectionInside) {
1459         // We are fully selected.
<span class="line-modified">1460         startOffset = 0;</span>
<span class="line-modified">1461         endOffset = text().length();</span>
1462     } else {
<span class="line-modified">1463         startOffset = view().selection().startOffset();</span>
<span class="line-modified">1464         endOffset = view().selection().endOffset();</span>
1465         if (selectionState() == SelectionStart)
<span class="line-modified">1466             endOffset = text().length();</span>
1467         else if (selectionState() == SelectionEnd)
<span class="line-modified">1468             startOffset = 0;</span>
1469     }
1470 
<span class="line-modified">1471     if (startOffset == endOffset)</span>
1472         return IntRect();
1473 
1474     LayoutRect resultRect;
1475     if (!rects)
<span class="line-modified">1476         resultRect = m_lineBoxes.selectionRectForRange(startOffset, endOffset);</span>
1477     else {
<span class="line-modified">1478         m_lineBoxes.collectSelectionRectsForRange(startOffset, endOffset, *rects);</span>
1479         for (auto&amp; rect : *rects) {
1480             resultRect.unite(rect);
1481             rect = localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
1482         }
1483     }
1484 
1485     if (clipToVisibleContent)
1486         return computeRectForRepaint(resultRect, repaintContainer);
1487     return localToContainerQuad(FloatRect(resultRect), repaintContainer).enclosingBoundingBox();
1488 }
1489 
1490 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;&amp; rects)
1491 {
1492     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, &amp;rects);
1493 }
1494 
1495 LayoutRect RenderText::selectionRectForRepaint(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent)
1496 {
1497     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, nullptr);
1498 }
1499 
1500 int RenderText::caretMinOffset() const
1501 {
<span class="line-modified">1502     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">1503     if (!first)</span>
<span class="line-modified">1504         return 0;</span>
<span class="line-added">1505 </span>
<span class="line-added">1506     int minOffset = first-&gt;localStartOffset();</span>
<span class="line-added">1507     for (auto box = first; ++box;)</span>
<span class="line-added">1508         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;localStartOffset());</span>
<span class="line-added">1509 </span>
<span class="line-added">1510     return minOffset;</span>
1511 }
1512 
1513 int RenderText::caretMaxOffset() const
1514 {
<span class="line-modified">1515     auto first = LineLayoutTraversal::firstTextBoxFor(*this);</span>
<span class="line-modified">1516     if (!first)</span>
<span class="line-modified">1517         return text().length();</span>
<span class="line-added">1518 </span>
<span class="line-added">1519     int maxOffset = first-&gt;localEndOffset();</span>
<span class="line-added">1520     for (auto box = first; ++box;)</span>
<span class="line-added">1521         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;localEndOffset());</span>
<span class="line-added">1522 </span>
<span class="line-added">1523     return maxOffset;</span>
1524 }
1525 
1526 unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
1527 {
<span class="line-modified">1528     unsigned result = 0;</span>
<span class="line-modified">1529     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-added">1530         auto start = box.localStartOffset();</span>
<span class="line-added">1531         auto length = box.length();</span>
<span class="line-added">1532         if (offset &lt; start)</span>
<span class="line-added">1533             return result;</span>
<span class="line-added">1534         if (offset &lt;= start + length) {</span>
<span class="line-added">1535             result += offset - start;</span>
<span class="line-added">1536             return result;</span>
<span class="line-added">1537         }</span>
<span class="line-added">1538         result += length;</span>
<span class="line-added">1539     }</span>
<span class="line-added">1540     return result;</span>
<span class="line-added">1541 }</span>
<span class="line-added">1542 </span>
<span class="line-added">1543 enum class OffsetType { Character, Caret };</span>
<span class="line-added">1544 static bool containsOffset(const RenderText&amp; text, unsigned offset, OffsetType type)</span>
<span class="line-added">1545 {</span>
<span class="line-added">1546     for (auto box = LineLayoutTraversal::firstTextBoxInTextOrderFor(text); box; box.traverseNextInTextOrder()) {</span>
<span class="line-added">1547         auto start = box-&gt;localStartOffset();</span>
<span class="line-added">1548         if (offset &lt; start)</span>
<span class="line-added">1549             return false;</span>
<span class="line-added">1550         unsigned end = box-&gt;localEndOffset();</span>
<span class="line-added">1551         if (offset &gt;= start &amp;&amp; offset &lt;= end) {</span>
<span class="line-added">1552             if (offset == end &amp;&amp; (type == OffsetType::Character || box-&gt;isLineBreak()))</span>
<span class="line-added">1553                 continue;</span>
<span class="line-added">1554             if (type == OffsetType::Character)</span>
<span class="line-added">1555                 return true;</span>
<span class="line-added">1556             // Return false for offsets inside composed characters.</span>
<span class="line-added">1557             return !offset || offset == static_cast&lt;unsigned&gt;(text.nextOffset(text.previousOffset(offset)));</span>
<span class="line-added">1558         }</span>
<span class="line-added">1559     }</span>
<span class="line-added">1560     return false;</span>
1561 }
1562 
1563 bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
1564 {
<span class="line-modified">1565     return containsOffset(*this, offset, OffsetType::Character);</span>


1566 }
1567 
1568 bool RenderText::containsCaretOffset(unsigned offset) const
1569 {
<span class="line-modified">1570     return containsOffset(*this, offset, OffsetType::Caret);</span>


1571 }
1572 
1573 bool RenderText::hasRenderedText() const
1574 {
<span class="line-modified">1575     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {</span>
<span class="line-modified">1576         if (box.length())</span>
<span class="line-modified">1577             return true;</span>
<span class="line-added">1578     }</span>
<span class="line-added">1579     return false;</span>
1580 }
1581 
1582 int RenderText::previousOffset(int current) const
1583 {
1584     if (m_isAllASCII || text().is8Bit())
1585         return current - 1;
1586 
1587     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1588     return iterator.preceding(current).valueOr(current - 1);
1589 }
1590 
1591 int RenderText::previousOffsetForBackwardDeletion(int current) const
1592 {
1593     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Delete, nullAtom());
1594     return iterator.preceding(current).valueOr(0);
1595 }
1596 
1597 int RenderText::nextOffset(int current) const
1598 {
1599     if (m_isAllASCII || text().is8Bit())
</pre>
</td>
</tr>
</table>
<center><a href="RenderTableSection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
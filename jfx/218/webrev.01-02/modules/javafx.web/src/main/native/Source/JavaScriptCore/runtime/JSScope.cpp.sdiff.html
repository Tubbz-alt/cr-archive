<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSRunLoopTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSWithScope.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;VariableEnvironment.h&quot;
 37 
 38 namespace JSC {
 39 
 40 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSScope);
 41 
 42 const ClassInfo JSScope::s_info = { &quot;Scope&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSScope) };
 43 
 44 void JSScope::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 45 {
 46     JSScope* thisObject = jsCast&lt;JSScope*&gt;(cell);
 47     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 48     Base::visitChildren(thisObject, visitor);
 49     visitor.append(thisObject-&gt;m_next);
 50 }
 51 
 52 // Returns true if we found enough information to terminate optimization.
<span class="line-modified"> 53 static inline bool abstractAccess(ExecState* exec, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, size_t depth, bool&amp; needsVarInjectionChecks, ResolveOp&amp; op, InitializationMode initializationMode)</span>
 54 {
<span class="line-modified"> 55     VM&amp; vm = exec-&gt;vm();</span>
 56     auto throwScope = DECLARE_THROW_SCOPE(vm);
 57 
 58     if (scope-&gt;isJSLexicalEnvironment()) {
 59         JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
 60 
 61         SymbolTable* symbolTable = lexicalEnvironment-&gt;symbolTable();
 62         {
 63             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 64             auto iter = symbolTable-&gt;find(locker, ident.impl());
 65             if (iter != symbolTable-&gt;end(locker)) {
 66                 SymbolTableEntry&amp; entry = iter-&gt;value;
 67                 ASSERT(!entry.isNull());
 68                 if (entry.isReadOnly() &amp;&amp; getOrPut == Put) {
 69                     // We know the property will be at this lexical environment scope, but we don&#39;t know how to cache it.
 70                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
 71                     return true;
 72                 }
 73 
 74                 op = ResolveOp(makeType(ClosureVar, needsVarInjectionChecks), depth, 0, lexicalEnvironment, entry.watchpointSet(), entry.scopeOffset().offset());
 75                 return true;
 76             }
 77         }
 78 
 79         if (scope-&gt;type() == ModuleEnvironmentType) {
 80             JSModuleEnvironment* moduleEnvironment = jsCast&lt;JSModuleEnvironment*&gt;(scope);
 81             AbstractModuleRecord* moduleRecord = moduleEnvironment-&gt;moduleRecord();
<span class="line-modified"> 82             AbstractModuleRecord::Resolution resolution = moduleRecord-&gt;resolveImport(exec, ident);</span>
 83             RETURN_IF_EXCEPTION(throwScope, false);
 84             if (resolution.type == AbstractModuleRecord::Resolution::Type::Resolved) {
 85                 AbstractModuleRecord* importedRecord = resolution.moduleRecord;
 86                 JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironment();
 87                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
 88                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 89                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
 90                 ASSERT(iter != symbolTable-&gt;end(locker));
 91                 SymbolTableEntry&amp; entry = iter-&gt;value;
 92                 ASSERT(!entry.isNull());
 93                 op = ResolveOp(makeType(ModuleVar, needsVarInjectionChecks), depth, 0, importedEnvironment, entry.watchpointSet(), entry.scopeOffset().offset(), resolution.localName.impl());
 94                 return true;
 95             }
 96         }
 97 
 98         if (symbolTable-&gt;usesNonStrictEval())
 99             needsVarInjectionChecks = true;
100         return false;
101     }
102 
</pre>
<hr />
<pre>
138             SymbolTable* symbolTable = globalObject-&gt;symbolTable();
139             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
140             auto iter = symbolTable-&gt;find(locker, ident.impl());
141             if (iter != symbolTable-&gt;end(locker)) {
142                 SymbolTableEntry&amp; entry = iter-&gt;value;
143                 ASSERT(!entry.isNull());
144                 if (getOrPut == Put &amp;&amp; entry.isReadOnly()) {
145                     // We know the property will be at global scope, but we don&#39;t know how to cache it.
146                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
147                     return true;
148                 }
149 
150                 op = ResolveOp(
151                     makeType(GlobalVar, needsVarInjectionChecks), depth, 0, 0, entry.watchpointSet(),
152                     reinterpret_cast&lt;uintptr_t&gt;(globalObject-&gt;variableAt(entry.scopeOffset()).slot()));
153                 return true;
154             }
155         }
156 
157         PropertySlot slot(globalObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">158         bool hasOwnProperty = globalObject-&gt;getOwnPropertySlot(globalObject, exec, ident, slot);</span>
159         if (!hasOwnProperty) {
160             op = ResolveOp(makeType(UnresolvedProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
161             return true;
162         }
163 
164         Structure* structure = globalObject-&gt;structure(vm);
165         if (!slot.isCacheableValue()
166             || !structure-&gt;propertyAccessesAreCacheable()
167             || (structure-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() &amp;&amp; getOrPut == Put)) {
168             // We know the property will be at global scope, but we don&#39;t know how to cache it.
169             ASSERT(!scope-&gt;next());
170             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
171             return true;
172         }
173 
174 
175         WatchpointState state = structure-&gt;ensurePropertyReplacementWatchpointSet(vm, slot.cachedOffset())-&gt;state();
176         if (state == IsWatched &amp;&amp; getOrPut == Put) {
177             // The field exists, but because the replacement watchpoint is still intact. This is
178             // kind of dangerous. We have two options:
</pre>
<hr />
<pre>
184             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, 0, 0, 0, 0);
185         } else
186             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, structure, 0, 0, slot.cachedOffset());
187         return true;
188     }
189 
190     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
191     return true;
192 }
193 
194 JSObject* JSScope::objectAtScope(JSScope* scope)
195 {
196     JSObject* object = scope;
197     if (object-&gt;type() == WithScopeType)
198         return jsCast&lt;JSWithScope*&gt;(object)-&gt;object();
199 
200     return object;
201 }
202 
203 // When an exception occurs, the result of isUnscopable becomes false.
<span class="line-modified">204 static inline bool isUnscopable(ExecState* exec, JSScope* scope, JSObject* object, const Identifier&amp; ident)</span>
205 {
<span class="line-modified">206     VM&amp; vm = exec-&gt;vm();</span>
207     auto throwScope = DECLARE_THROW_SCOPE(vm);
208     if (scope-&gt;type() != WithScopeType)
209         return false;
210 
<span class="line-modified">211     JSValue unscopables = object-&gt;get(exec, vm.propertyNames-&gt;unscopablesSymbol);</span>
212     RETURN_IF_EXCEPTION(throwScope, false);
213     if (!unscopables.isObject())
214         return false;
<span class="line-modified">215     JSValue blocked = jsCast&lt;JSObject*&gt;(unscopables)-&gt;get(exec, ident);</span>
216     RETURN_IF_EXCEPTION(throwScope, false);
217 
<span class="line-modified">218     return blocked.toBoolean(exec);</span>
219 }
220 
221 template&lt;typename ReturnPredicateFunctor, typename SkipPredicateFunctor&gt;
<span class="line-modified">222 ALWAYS_INLINE JSObject* JSScope::resolve(ExecState* exec, JSScope* scope, const Identifier&amp; ident, ReturnPredicateFunctor returnPredicate, SkipPredicateFunctor skipPredicate)</span>
223 {
<span class="line-modified">224     VM&amp; vm = exec-&gt;vm();</span>
225     auto throwScope = DECLARE_THROW_SCOPE(vm);
226     ScopeChainIterator end = scope-&gt;end();
227     ScopeChainIterator it = scope-&gt;begin();
228     while (1) {
229         JSScope* scope = it.scope();
230         JSObject* object = it.get();
231 
232         // Global scope.
233         if (++it == end) {
234             JSScope* globalScopeExtension = scope-&gt;globalObject(vm)-&gt;globalScopeExtension();
235             if (UNLIKELY(globalScopeExtension)) {
<span class="line-modified">236                 bool hasProperty = object-&gt;hasProperty(exec, ident);</span>
237                 RETURN_IF_EXCEPTION(throwScope, nullptr);
238                 if (hasProperty)
239                     return object;
240                 JSObject* extensionScopeObject = JSScope::objectAtScope(globalScopeExtension);
<span class="line-modified">241                 hasProperty = extensionScopeObject-&gt;hasProperty(exec, ident);</span>
242                 RETURN_IF_EXCEPTION(throwScope, nullptr);
243                 if (hasProperty)
244                     return extensionScopeObject;
245             }
246             return object;
247         }
248 
249         if (skipPredicate(scope))
250             continue;
251 
<span class="line-modified">252         bool hasProperty = object-&gt;hasProperty(exec, ident);</span>
253         RETURN_IF_EXCEPTION(throwScope, nullptr);
254         if (hasProperty) {
<span class="line-modified">255             bool unscopable = isUnscopable(exec, scope, object, ident);</span>
256             EXCEPTION_ASSERT(!throwScope.exception() || !unscopable);
257             if (!unscopable)
258                 return object;
259         }
260 
261         if (returnPredicate(scope))
262             return object;
263     }
264 }
265 
<span class="line-modified">266 JSValue JSScope::resolveScopeForHoistingFuncDeclInEval(ExecState* exec, JSScope* scope, const Identifier&amp; ident)</span>
267 {
<span class="line-modified">268     VM&amp; vm = exec-&gt;vm();</span>
269     auto throwScope = DECLARE_THROW_SCOPE(vm);
270 
271     auto returnPredicate = [&amp;] (JSScope* scope) -&gt; bool {
272         return scope-&gt;isVarScope();
273     };
274     auto skipPredicate = [&amp;] (JSScope* scope) -&gt; bool {
275         return scope-&gt;isWithScope();
276     };
<span class="line-modified">277     JSObject* object = resolve(exec, scope, ident, returnPredicate, skipPredicate);</span>
278     RETURN_IF_EXCEPTION(throwScope, { });
279 
280     bool result = false;
281     if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(vm, object)) {
282         if (SymbolTable* scopeSymbolTable = scope-&gt;symbolTable(vm)) {
283             result = scope-&gt;isGlobalObject()
<span class="line-modified">284                 ? JSObject::isExtensible(object, exec)</span>
285                 : scopeSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
286         }
287     }
288 
289     return result ? JSValue(object) : jsUndefined();
290 }
291 
<span class="line-modified">292 JSObject* JSScope::resolve(ExecState* exec, JSScope* scope, const Identifier&amp; ident)</span>
293 {
294     auto predicate1 = [&amp;] (JSScope*) -&gt; bool {
295         return false;
296     };
297     auto predicate2 = [&amp;] (JSScope*) -&gt; bool {
298         return false;
299     };
<span class="line-modified">300     return resolve(exec, scope, ident, predicate1, predicate2);</span>
301 }
302 
<span class="line-modified">303 ResolveOp JSScope::abstractResolve(ExecState* exec, size_t depthOffset, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, ResolveType unlinkedType, InitializationMode initializationMode)</span>
304 {
<span class="line-modified">305     VM&amp; vm = exec-&gt;vm();</span>
306     auto throwScope = DECLARE_THROW_SCOPE(vm);
307 
308     ResolveOp op(Dynamic, 0, 0, 0, 0, 0);
309     if (unlinkedType == Dynamic)
310         return op;
311 
312     bool needsVarInjectionChecks = JSC::needsVarInjectionChecks(unlinkedType);
313     size_t depth = depthOffset;
314     for (; scope; scope = scope-&gt;next()) {
<span class="line-modified">315         bool success = abstractAccess(exec, scope, ident, getOrPut, depth, needsVarInjectionChecks, op, initializationMode);</span>
316         RETURN_IF_EXCEPTION(throwScope, ResolveOp(Dynamic, 0, 0, 0, 0, 0));
317         if (success)
318             break;
319         ++depth;
320     }
321 
322     return op;
323 }
324 
325 void JSScope::collectClosureVariablesUnderTDZ(JSScope* scope, VariableEnvironment&amp; result)
326 {
327     for (; scope; scope = scope-&gt;next()) {
328         if (!scope-&gt;isLexicalScope() &amp;&amp; !scope-&gt;isCatchScope())
329             continue;
330 
331         if (scope-&gt;isModuleScope()) {
332             AbstractModuleRecord* moduleRecord = jsCast&lt;JSModuleEnvironment*&gt;(scope)-&gt;moduleRecord();
333             for (const auto&amp; pair : moduleRecord-&gt;importEntries())
334                 result.add(pair.key);
335         }
</pre>
<hr />
<pre>
392         return codeBlock-&gt;globalObject();
393     case GlobalLexicalVarWithVarInjectionChecks:
394     case GlobalLexicalVar:
395         return codeBlock-&gt;globalObject()-&gt;globalLexicalEnvironment();
396     default:
397         return nullptr;
398     }
399 
400     RELEASE_ASSERT_NOT_REACHED();
401     return nullptr;
402 }
403 
404 SymbolTable* JSScope::symbolTable(VM&amp; vm)
405 {
406     if (JSSymbolTableObject* symbolTableObject = jsDynamicCast&lt;JSSymbolTableObject*&gt;(vm, this))
407         return symbolTableObject-&gt;symbolTable();
408 
409     return nullptr;
410 }
411 
<span class="line-modified">412 JSValue JSScope::toThis(JSCell*, ExecState* exec, ECMAMode ecmaMode)</span>
413 {
414     if (ecmaMode == StrictMode)
415         return jsUndefined();
<span class="line-modified">416     return exec-&gt;globalThisValue();</span>
417 }
418 
419 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSWithScope.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;VariableEnvironment.h&quot;
 37 
 38 namespace JSC {
 39 
 40 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSScope);
 41 
 42 const ClassInfo JSScope::s_info = { &quot;Scope&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSScope) };
 43 
 44 void JSScope::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 45 {
 46     JSScope* thisObject = jsCast&lt;JSScope*&gt;(cell);
 47     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 48     Base::visitChildren(thisObject, visitor);
 49     visitor.append(thisObject-&gt;m_next);
 50 }
 51 
 52 // Returns true if we found enough information to terminate optimization.
<span class="line-modified"> 53 static inline bool abstractAccess(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, size_t depth, bool&amp; needsVarInjectionChecks, ResolveOp&amp; op, InitializationMode initializationMode)</span>
 54 {
<span class="line-modified"> 55     VM&amp; vm = globalObject-&gt;vm();</span>
 56     auto throwScope = DECLARE_THROW_SCOPE(vm);
 57 
 58     if (scope-&gt;isJSLexicalEnvironment()) {
 59         JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(scope);
 60 
 61         SymbolTable* symbolTable = lexicalEnvironment-&gt;symbolTable();
 62         {
 63             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 64             auto iter = symbolTable-&gt;find(locker, ident.impl());
 65             if (iter != symbolTable-&gt;end(locker)) {
 66                 SymbolTableEntry&amp; entry = iter-&gt;value;
 67                 ASSERT(!entry.isNull());
 68                 if (entry.isReadOnly() &amp;&amp; getOrPut == Put) {
 69                     // We know the property will be at this lexical environment scope, but we don&#39;t know how to cache it.
 70                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
 71                     return true;
 72                 }
 73 
 74                 op = ResolveOp(makeType(ClosureVar, needsVarInjectionChecks), depth, 0, lexicalEnvironment, entry.watchpointSet(), entry.scopeOffset().offset());
 75                 return true;
 76             }
 77         }
 78 
 79         if (scope-&gt;type() == ModuleEnvironmentType) {
 80             JSModuleEnvironment* moduleEnvironment = jsCast&lt;JSModuleEnvironment*&gt;(scope);
 81             AbstractModuleRecord* moduleRecord = moduleEnvironment-&gt;moduleRecord();
<span class="line-modified"> 82             AbstractModuleRecord::Resolution resolution = moduleRecord-&gt;resolveImport(globalObject, ident);</span>
 83             RETURN_IF_EXCEPTION(throwScope, false);
 84             if (resolution.type == AbstractModuleRecord::Resolution::Type::Resolved) {
 85                 AbstractModuleRecord* importedRecord = resolution.moduleRecord;
 86                 JSModuleEnvironment* importedEnvironment = importedRecord-&gt;moduleEnvironment();
 87                 SymbolTable* symbolTable = importedEnvironment-&gt;symbolTable();
 88                 ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
 89                 auto iter = symbolTable-&gt;find(locker, resolution.localName.impl());
 90                 ASSERT(iter != symbolTable-&gt;end(locker));
 91                 SymbolTableEntry&amp; entry = iter-&gt;value;
 92                 ASSERT(!entry.isNull());
 93                 op = ResolveOp(makeType(ModuleVar, needsVarInjectionChecks), depth, 0, importedEnvironment, entry.watchpointSet(), entry.scopeOffset().offset(), resolution.localName.impl());
 94                 return true;
 95             }
 96         }
 97 
 98         if (symbolTable-&gt;usesNonStrictEval())
 99             needsVarInjectionChecks = true;
100         return false;
101     }
102 
</pre>
<hr />
<pre>
138             SymbolTable* symbolTable = globalObject-&gt;symbolTable();
139             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
140             auto iter = symbolTable-&gt;find(locker, ident.impl());
141             if (iter != symbolTable-&gt;end(locker)) {
142                 SymbolTableEntry&amp; entry = iter-&gt;value;
143                 ASSERT(!entry.isNull());
144                 if (getOrPut == Put &amp;&amp; entry.isReadOnly()) {
145                     // We know the property will be at global scope, but we don&#39;t know how to cache it.
146                     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
147                     return true;
148                 }
149 
150                 op = ResolveOp(
151                     makeType(GlobalVar, needsVarInjectionChecks), depth, 0, 0, entry.watchpointSet(),
152                     reinterpret_cast&lt;uintptr_t&gt;(globalObject-&gt;variableAt(entry.scopeOffset()).slot()));
153                 return true;
154             }
155         }
156 
157         PropertySlot slot(globalObject, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">158         bool hasOwnProperty = globalObject-&gt;getOwnPropertySlot(globalObject, globalObject, ident, slot);</span>
159         if (!hasOwnProperty) {
160             op = ResolveOp(makeType(UnresolvedProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
161             return true;
162         }
163 
164         Structure* structure = globalObject-&gt;structure(vm);
165         if (!slot.isCacheableValue()
166             || !structure-&gt;propertyAccessesAreCacheable()
167             || (structure-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto() &amp;&amp; getOrPut == Put)) {
168             // We know the property will be at global scope, but we don&#39;t know how to cache it.
169             ASSERT(!scope-&gt;next());
170             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), 0, 0, 0, 0, 0);
171             return true;
172         }
173 
174 
175         WatchpointState state = structure-&gt;ensurePropertyReplacementWatchpointSet(vm, slot.cachedOffset())-&gt;state();
176         if (state == IsWatched &amp;&amp; getOrPut == Put) {
177             // The field exists, but because the replacement watchpoint is still intact. This is
178             // kind of dangerous. We have two options:
</pre>
<hr />
<pre>
184             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, 0, 0, 0, 0);
185         } else
186             op = ResolveOp(makeType(GlobalProperty, needsVarInjectionChecks), depth, structure, 0, 0, slot.cachedOffset());
187         return true;
188     }
189 
190     op = ResolveOp(Dynamic, 0, 0, 0, 0, 0);
191     return true;
192 }
193 
194 JSObject* JSScope::objectAtScope(JSScope* scope)
195 {
196     JSObject* object = scope;
197     if (object-&gt;type() == WithScopeType)
198         return jsCast&lt;JSWithScope*&gt;(object)-&gt;object();
199 
200     return object;
201 }
202 
203 // When an exception occurs, the result of isUnscopable becomes false.
<span class="line-modified">204 static inline bool isUnscopable(JSGlobalObject* globalObject, JSScope* scope, JSObject* object, const Identifier&amp; ident)</span>
205 {
<span class="line-modified">206     VM&amp; vm = globalObject-&gt;vm();</span>
207     auto throwScope = DECLARE_THROW_SCOPE(vm);
208     if (scope-&gt;type() != WithScopeType)
209         return false;
210 
<span class="line-modified">211     JSValue unscopables = object-&gt;get(globalObject, vm.propertyNames-&gt;unscopablesSymbol);</span>
212     RETURN_IF_EXCEPTION(throwScope, false);
213     if (!unscopables.isObject())
214         return false;
<span class="line-modified">215     JSValue blocked = jsCast&lt;JSObject*&gt;(unscopables)-&gt;get(globalObject, ident);</span>
216     RETURN_IF_EXCEPTION(throwScope, false);
217 
<span class="line-modified">218     return blocked.toBoolean(globalObject);</span>
219 }
220 
221 template&lt;typename ReturnPredicateFunctor, typename SkipPredicateFunctor&gt;
<span class="line-modified">222 ALWAYS_INLINE JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident, ReturnPredicateFunctor returnPredicate, SkipPredicateFunctor skipPredicate)</span>
223 {
<span class="line-modified">224     VM&amp; vm = globalObject-&gt;vm();</span>
225     auto throwScope = DECLARE_THROW_SCOPE(vm);
226     ScopeChainIterator end = scope-&gt;end();
227     ScopeChainIterator it = scope-&gt;begin();
228     while (1) {
229         JSScope* scope = it.scope();
230         JSObject* object = it.get();
231 
232         // Global scope.
233         if (++it == end) {
234             JSScope* globalScopeExtension = scope-&gt;globalObject(vm)-&gt;globalScopeExtension();
235             if (UNLIKELY(globalScopeExtension)) {
<span class="line-modified">236                 bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
237                 RETURN_IF_EXCEPTION(throwScope, nullptr);
238                 if (hasProperty)
239                     return object;
240                 JSObject* extensionScopeObject = JSScope::objectAtScope(globalScopeExtension);
<span class="line-modified">241                 hasProperty = extensionScopeObject-&gt;hasProperty(globalObject, ident);</span>
242                 RETURN_IF_EXCEPTION(throwScope, nullptr);
243                 if (hasProperty)
244                     return extensionScopeObject;
245             }
246             return object;
247         }
248 
249         if (skipPredicate(scope))
250             continue;
251 
<span class="line-modified">252         bool hasProperty = object-&gt;hasProperty(globalObject, ident);</span>
253         RETURN_IF_EXCEPTION(throwScope, nullptr);
254         if (hasProperty) {
<span class="line-modified">255             bool unscopable = isUnscopable(globalObject, scope, object, ident);</span>
256             EXCEPTION_ASSERT(!throwScope.exception() || !unscopable);
257             if (!unscopable)
258                 return object;
259         }
260 
261         if (returnPredicate(scope))
262             return object;
263     }
264 }
265 
<span class="line-modified">266 JSValue JSScope::resolveScopeForHoistingFuncDeclInEval(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
267 {
<span class="line-modified">268     VM&amp; vm = globalObject-&gt;vm();</span>
269     auto throwScope = DECLARE_THROW_SCOPE(vm);
270 
271     auto returnPredicate = [&amp;] (JSScope* scope) -&gt; bool {
272         return scope-&gt;isVarScope();
273     };
274     auto skipPredicate = [&amp;] (JSScope* scope) -&gt; bool {
275         return scope-&gt;isWithScope();
276     };
<span class="line-modified">277     JSObject* object = resolve(globalObject, scope, ident, returnPredicate, skipPredicate);</span>
278     RETURN_IF_EXCEPTION(throwScope, { });
279 
280     bool result = false;
281     if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(vm, object)) {
282         if (SymbolTable* scopeSymbolTable = scope-&gt;symbolTable(vm)) {
283             result = scope-&gt;isGlobalObject()
<span class="line-modified">284                 ? JSObject::isExtensible(object, globalObject)</span>
285                 : scopeSymbolTable-&gt;scopeType() == SymbolTable::ScopeType::VarScope;
286         }
287     }
288 
289     return result ? JSValue(object) : jsUndefined();
290 }
291 
<span class="line-modified">292 JSObject* JSScope::resolve(JSGlobalObject* globalObject, JSScope* scope, const Identifier&amp; ident)</span>
293 {
294     auto predicate1 = [&amp;] (JSScope*) -&gt; bool {
295         return false;
296     };
297     auto predicate2 = [&amp;] (JSScope*) -&gt; bool {
298         return false;
299     };
<span class="line-modified">300     return resolve(globalObject, scope, ident, predicate1, predicate2);</span>
301 }
302 
<span class="line-modified">303 ResolveOp JSScope::abstractResolve(JSGlobalObject* globalObject, size_t depthOffset, JSScope* scope, const Identifier&amp; ident, GetOrPut getOrPut, ResolveType unlinkedType, InitializationMode initializationMode)</span>
304 {
<span class="line-modified">305     VM&amp; vm = globalObject-&gt;vm();</span>
306     auto throwScope = DECLARE_THROW_SCOPE(vm);
307 
308     ResolveOp op(Dynamic, 0, 0, 0, 0, 0);
309     if (unlinkedType == Dynamic)
310         return op;
311 
312     bool needsVarInjectionChecks = JSC::needsVarInjectionChecks(unlinkedType);
313     size_t depth = depthOffset;
314     for (; scope; scope = scope-&gt;next()) {
<span class="line-modified">315         bool success = abstractAccess(globalObject, scope, ident, getOrPut, depth, needsVarInjectionChecks, op, initializationMode);</span>
316         RETURN_IF_EXCEPTION(throwScope, ResolveOp(Dynamic, 0, 0, 0, 0, 0));
317         if (success)
318             break;
319         ++depth;
320     }
321 
322     return op;
323 }
324 
325 void JSScope::collectClosureVariablesUnderTDZ(JSScope* scope, VariableEnvironment&amp; result)
326 {
327     for (; scope; scope = scope-&gt;next()) {
328         if (!scope-&gt;isLexicalScope() &amp;&amp; !scope-&gt;isCatchScope())
329             continue;
330 
331         if (scope-&gt;isModuleScope()) {
332             AbstractModuleRecord* moduleRecord = jsCast&lt;JSModuleEnvironment*&gt;(scope)-&gt;moduleRecord();
333             for (const auto&amp; pair : moduleRecord-&gt;importEntries())
334                 result.add(pair.key);
335         }
</pre>
<hr />
<pre>
392         return codeBlock-&gt;globalObject();
393     case GlobalLexicalVarWithVarInjectionChecks:
394     case GlobalLexicalVar:
395         return codeBlock-&gt;globalObject()-&gt;globalLexicalEnvironment();
396     default:
397         return nullptr;
398     }
399 
400     RELEASE_ASSERT_NOT_REACHED();
401     return nullptr;
402 }
403 
404 SymbolTable* JSScope::symbolTable(VM&amp; vm)
405 {
406     if (JSSymbolTableObject* symbolTableObject = jsDynamicCast&lt;JSSymbolTableObject*&gt;(vm, this))
407         return symbolTableObject-&gt;symbolTable();
408 
409     return nullptr;
410 }
411 
<span class="line-modified">412 JSValue JSScope::toThis(JSCell*, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
413 {
414     if (ecmaMode == StrictMode)
415         return jsUndefined();
<span class="line-modified">416     return globalObject-&gt;globalThis();</span>
417 }
418 
419 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSRunLoopTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
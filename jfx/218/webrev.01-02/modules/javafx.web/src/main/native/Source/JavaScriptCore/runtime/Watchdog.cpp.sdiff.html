<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Watchdog.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VarOffset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Watchdog.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Watchdog.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Watchdog.h&quot;
 28 
 29 #include &quot;CallFrame.h&quot;
 30 #include &lt;wtf/CPUTime.h&gt;
 31 #include &lt;wtf/MathExtras.h&gt;
 32 
 33 namespace JSC {
 34 
<span class="line-removed"> 35 const Seconds Watchdog::noTimeLimit { Seconds::infinity() };</span>
<span class="line-removed"> 36 </span>
 37 Watchdog::Watchdog(VM* vm)
 38     : m_vm(vm)
 39     , m_timeLimit(noTimeLimit)
 40     , m_cpuDeadline(noTimeLimit)
 41     , m_deadline(MonotonicTime::infinity())
 42     , m_callback(0)
 43     , m_callbackData1(0)
 44     , m_callbackData2(0)
 45     , m_timerQueue(WorkQueue::create(&quot;jsc.watchdog.queue&quot;, WorkQueue::Type::Serial, WorkQueue::QOS::Utility))
 46 {
 47 }
 48 
 49 void Watchdog::setTimeLimit(Seconds limit,
 50     ShouldTerminateCallback callback, void* data1, void* data2)
 51 {
 52     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());
 53 
 54     m_timeLimit = limit;
 55     m_callback = callback;
 56     m_callbackData1 = data1;
 57     m_callbackData2 = data2;
 58 
 59     if (m_hasEnteredVM &amp;&amp; hasTimeLimit())
 60         startTimer(m_timeLimit);
 61 }
 62 
<span class="line-modified"> 63 bool Watchdog::shouldTerminate(ExecState* exec)</span>
 64 {
 65     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());
 66     if (MonotonicTime::now() &lt; m_deadline)
 67         return false; // Just a stale timer firing. Nothing to do.
 68 
 69     // Set m_deadline to MonotonicTime::infinity() here so that we can reject all future
 70     // spurious wakes.
 71     m_deadline = MonotonicTime::infinity();
 72 
 73     auto cpuTime = CPUTime::forCurrentThread();
 74     if (cpuTime &lt; m_cpuDeadline) {
 75         auto remainingCPUTime = m_cpuDeadline - cpuTime;
 76         startTimer(remainingCPUTime);
 77         return false;
 78     }
 79 
 80     // Note: we should not be holding the lock while calling the callbacks. The callbacks may
 81     // call setTimeLimit() which will try to lock as well.
 82 
 83     // If m_callback is not set, then we terminate by default.
 84     // Else, we let m_callback decide if we should terminate or not.
 85     bool needsTermination = !m_callback
<span class="line-modified"> 86         || m_callback(exec, m_callbackData1, m_callbackData2);</span>
 87     if (needsTermination)
 88         return true;
 89 
 90     // If we get here, then the callback above did not want to terminate execution. As a
 91     // result, the callback may have done one of the following:
 92     //   1. cleared the time limit (i.e. watchdog is disabled),
 93     //   2. set a new time limit via Watchdog::setTimeLimit(), or
 94     //   3. did nothing (i.e. allow another cycle of the current time limit).
 95     //
 96     // In the case of 1, we don&#39;t have to do anything.
 97     // In the case of 2, Watchdog::setTimeLimit() would already have started the timer.
 98     // In the case of 3, we need to re-start the timer here.
 99 
100     ASSERT(m_hasEnteredVM);
101     bool callbackAlreadyStartedTimer = (m_cpuDeadline != noTimeLimit);
102     if (hasTimeLimit() &amp;&amp; !callbackAlreadyStartedTimer)
103         startTimer(m_timeLimit);
104 
105     return false;
106 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Watchdog.h&quot;
 28 
 29 #include &quot;CallFrame.h&quot;
 30 #include &lt;wtf/CPUTime.h&gt;
 31 #include &lt;wtf/MathExtras.h&gt;
 32 
 33 namespace JSC {
 34 


 35 Watchdog::Watchdog(VM* vm)
 36     : m_vm(vm)
 37     , m_timeLimit(noTimeLimit)
 38     , m_cpuDeadline(noTimeLimit)
 39     , m_deadline(MonotonicTime::infinity())
 40     , m_callback(0)
 41     , m_callbackData1(0)
 42     , m_callbackData2(0)
 43     , m_timerQueue(WorkQueue::create(&quot;jsc.watchdog.queue&quot;, WorkQueue::Type::Serial, WorkQueue::QOS::Utility))
 44 {
 45 }
 46 
 47 void Watchdog::setTimeLimit(Seconds limit,
 48     ShouldTerminateCallback callback, void* data1, void* data2)
 49 {
 50     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());
 51 
 52     m_timeLimit = limit;
 53     m_callback = callback;
 54     m_callbackData1 = data1;
 55     m_callbackData2 = data2;
 56 
 57     if (m_hasEnteredVM &amp;&amp; hasTimeLimit())
 58         startTimer(m_timeLimit);
 59 }
 60 
<span class="line-modified"> 61 bool Watchdog::shouldTerminate(JSGlobalObject* globalObject)</span>
 62 {
 63     ASSERT(m_vm-&gt;currentThreadIsHoldingAPILock());
 64     if (MonotonicTime::now() &lt; m_deadline)
 65         return false; // Just a stale timer firing. Nothing to do.
 66 
 67     // Set m_deadline to MonotonicTime::infinity() here so that we can reject all future
 68     // spurious wakes.
 69     m_deadline = MonotonicTime::infinity();
 70 
 71     auto cpuTime = CPUTime::forCurrentThread();
 72     if (cpuTime &lt; m_cpuDeadline) {
 73         auto remainingCPUTime = m_cpuDeadline - cpuTime;
 74         startTimer(remainingCPUTime);
 75         return false;
 76     }
 77 
 78     // Note: we should not be holding the lock while calling the callbacks. The callbacks may
 79     // call setTimeLimit() which will try to lock as well.
 80 
 81     // If m_callback is not set, then we terminate by default.
 82     // Else, we let m_callback decide if we should terminate or not.
 83     bool needsTermination = !m_callback
<span class="line-modified"> 84         || m_callback(globalObject, m_callbackData1, m_callbackData2);</span>
 85     if (needsTermination)
 86         return true;
 87 
 88     // If we get here, then the callback above did not want to terminate execution. As a
 89     // result, the callback may have done one of the following:
 90     //   1. cleared the time limit (i.e. watchdog is disabled),
 91     //   2. set a new time limit via Watchdog::setTimeLimit(), or
 92     //   3. did nothing (i.e. allow another cycle of the current time limit).
 93     //
 94     // In the case of 1, we don&#39;t have to do anything.
 95     // In the case of 2, Watchdog::setTimeLimit() would already have started the timer.
 96     // In the case of 3, we need to re-start the timer here.
 97 
 98     ASSERT(m_hasEnteredVM);
 99     bool callbackAlreadyStartedTimer = (m_cpuDeadline != noTimeLimit);
100     if (hasTimeLimit() &amp;&amp; !callbackAlreadyStartedTimer)
101         startTimer(m_timeLimit);
102 
103     return false;
104 }
</pre>
</td>
</tr>
</table>
<center><a href="VarOffset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Watchdog.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
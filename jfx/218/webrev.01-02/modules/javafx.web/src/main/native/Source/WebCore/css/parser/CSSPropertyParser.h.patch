diff a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.h
@@ -30,37 +30,40 @@
 
 class CSSProperty;
 class CSSValue;
 class StylePropertyShorthand;
 class StyleSheetContents;
-class StyleResolver;
+
+namespace Style {
+class BuilderState;
+}
 
 // Inputs: PropertyID, isImportant bool, CSSParserTokenRange.
 // Outputs: Vector of CSSProperties
 
 class CSSPropertyParser {
     WTF_MAKE_NONCOPYABLE(CSSPropertyParser);
 public:
     static bool parseValue(CSSPropertyID, bool important,
         const CSSParserTokenRange&, const CSSParserContext&,
-        Vector<CSSProperty, 256>&, StyleRule::Type);
+        Vector<CSSProperty, 256>&, StyleRuleType);
 
     // Parses a non-shorthand CSS property
     static RefPtr<CSSValue> parseSingleValue(CSSPropertyID, const CSSParserTokenRange&, const CSSParserContext&);
     static bool canParseTypedCustomPropertyValue(const String& syntax, const CSSParserTokenRange&, const CSSParserContext&);
-    static RefPtr<CSSCustomPropertyValue> parseTypedCustomPropertyValue(const String& name, const String& syntax, const CSSParserTokenRange&, const StyleResolver&, const CSSParserContext&);
+    static RefPtr<CSSCustomPropertyValue> parseTypedCustomPropertyValue(const String& name, const String& syntax, const CSSParserTokenRange&, const Style::BuilderState&, const CSSParserContext&);
     static void collectParsedCustomPropertyValueDependencies(const String& syntax, bool isRoot, HashSet<CSSPropertyID>& dependencies, const CSSParserTokenRange&, const CSSParserContext&);
 
 private:
     CSSPropertyParser(const CSSParserTokenRange&, const CSSParserContext&, Vector<CSSProperty, 256>*, bool consumeWhitespace = true);
 
     // FIXME: Rename once the CSSParserValue-based parseValue is removed
     bool parseValueStart(CSSPropertyID, bool important);
     bool consumeCSSWideKeyword(CSSPropertyID, bool important);
     RefPtr<CSSValue> parseSingleValue(CSSPropertyID, CSSPropertyID = CSSPropertyInvalid);
     bool canParseTypedCustomPropertyValue(const String& syntax);
-    RefPtr<CSSCustomPropertyValue> parseTypedCustomPropertyValue(const String& name, const String& syntax, const StyleResolver&);
+    RefPtr<CSSCustomPropertyValue> parseTypedCustomPropertyValue(const String& name, const String& syntax, const Style::BuilderState&);
     void collectParsedCustomPropertyValueDependencies(const String& syntax, bool isRoot, HashSet<CSSPropertyID>& dependencies);
 
     bool inQuirksMode() const { return m_context.mode == HTMLQuirksMode; }
 
     bool parseViewportDescriptor(CSSPropertyID propId, bool important);
@@ -77,10 +80,11 @@
     bool consume4ValueShorthand(const StylePropertyShorthand&, bool important);
 
     // Legacy parsing allows <string>s for animation-name
     bool consumeAnimationShorthand(const StylePropertyShorthand&, bool important);
     bool consumeBackgroundShorthand(const StylePropertyShorthand&, bool important);
+    bool consumeOverflowShorthand(bool important);
 
     bool consumeColumns(bool important);
 
     bool consumeGridItemPositionShorthand(CSSPropertyID, bool important);
     bool consumeGridTemplateRowsAndAreasAndColumns(CSSPropertyID, bool important);
@@ -116,11 +120,11 @@
     // Outputs:
     Vector<CSSProperty, 256>* m_parsedProperties;
 };
 
 CSSPropertyID cssPropertyID(StringView);
-CSSValueID cssValueKeywordID(StringView);
+WEBCORE_EXPORT CSSValueID cssValueKeywordID(StringView);
 bool isCustomPropertyName(const String&);
 
 #if PLATFORM(IOS_FAMILY)
 void cssPropertyNameIOSAliasing(const char* propertyName, const char*& propertyNameAlias, unsigned& newLength);
 #endif

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGPropertyTraits.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGPropertyRegistry.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGValuePropertyAnimatorImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGPropertyTraits.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSParser.h&quot;
 25 #include &quot;Color.h&quot;
 26 #include &quot;FloatPoint.h&quot;
 27 #include &quot;FloatRect.h&quot;
 28 #include &quot;QualifiedName.h&quot;
 29 #include &quot;SVGParserUtilities.h&quot;
<span class="line-removed"> 30 #include &lt;wtf/text/StringBuilder.h&gt;</span>
<span class="line-removed"> 31 #include &lt;wtf/text/WTFString.h&gt;</span>
 32 
 33 namespace WebCore {
 34 
 35 template&lt;typename PropertyType&gt;
 36 struct SVGPropertyTraits { };
 37 
 38 template&lt;&gt;
 39 struct SVGPropertyTraits&lt;bool&gt; {
 40     static bool initialValue() { return false; }
 41     static bool fromString(const String&amp; string) { return string == &quot;true&quot;; }
 42     static Optional&lt;bool&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 43     static String toString(bool type) { return type ? &quot;true&quot; : &quot;false&quot;; }
 44 };
 45 
 46 template&lt;&gt;
 47 struct SVGPropertyTraits&lt;Color&gt; {
 48     static Color initialValue() { return Color(); }
 49     static Color fromString(const String&amp; string) { return CSSParser::parseColor(string.stripWhiteSpace()); }
 50     static Optional&lt;Color&gt; parse(const QualifiedName&amp;, const String&amp; string)
 51     {
</pre>
<hr />
<pre>
 86     static String toString(std::pair&lt;int, int&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
 87 };
 88 
 89 template&lt;&gt;
 90 struct SVGPropertyTraits&lt;float&gt; {
 91     static float initialValue() { return 0; }
 92     static float fromString(const String&amp; string)
 93     {
 94         float number = 0;
 95         if (!parseNumberFromString(string, number))
 96             return 0;
 97         return number;
 98     }
 99     static Optional&lt;float&gt; parse(const QualifiedName&amp;, const String&amp; string)
100     {
101         float number;
102         if (!parseNumberFromString(string, number))
103             return WTF::nullopt;
104         return number;
105     }
<span class="line-modified">106     static String toString(float type) { return String::numberToStringFixedPrecision(type); }</span>
107 };
108 
109 template&lt;&gt;
110 struct SVGPropertyTraits&lt;std::pair&lt;float, float&gt;&gt; {
111     static std::pair&lt;float, float&gt; initialValue() { return { }; }
112     static std::pair&lt;float, float&gt; fromString(const String&amp; string)
113     {
114         float firstNumber = 0, secondNumber = 0;
115         if (!parseNumberOptionalNumber(string, firstNumber, secondNumber))
116             return { };
117         return std::make_pair(firstNumber, secondNumber);
118     }
119     static Optional&lt;std::pair&lt;float, float&gt;&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
120     static String toString(std::pair&lt;float, float&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
121 };
122 
123 template&lt;&gt;
124 struct SVGPropertyTraits&lt;FloatPoint&gt; {
125     static FloatPoint initialValue() { return FloatPoint(); }
126     static FloatPoint fromString(const String&amp; string)
127     {
128         FloatPoint point;
129         if (!parsePoint(string, point))
130             return { };
131         return point;
132     }
133     static Optional&lt;FloatPoint&gt; parse(const QualifiedName&amp;, const String&amp; string)
134     {
135         FloatPoint point;
136         if (!parsePoint(string, point))
137             return WTF::nullopt;
138         return point;
139     }
140     static String toString(const FloatPoint&amp; type)
141     {
<span class="line-modified">142         StringBuilder builder;</span>
<span class="line-removed">143         builder.appendFixedPrecisionNumber(type.x());</span>
<span class="line-removed">144         builder.append(&#39; &#39;);</span>
<span class="line-removed">145         builder.appendFixedPrecisionNumber(type.y());</span>
<span class="line-removed">146         return builder.toString();</span>
147     }
148 };
149 
150 template&lt;&gt;
151 struct SVGPropertyTraits&lt;FloatRect&gt; {
152     static FloatRect initialValue() { return FloatRect(); }
153     static FloatRect fromString(const String&amp; string)
154     {
155         FloatRect rect;
156         if (!parseRect(string, rect))
157             return { };
158         return rect;
159     }
160     static Optional&lt;FloatRect&gt; parse(const QualifiedName&amp;, const String&amp; string)
161     {
162         FloatRect rect;
163         if (!parseRect(string, rect))
164             return WTF::nullopt;
165         return rect;
166     }
167     static String toString(const FloatRect&amp; type)
168     {
<span class="line-modified">169         StringBuilder builder;</span>
<span class="line-removed">170         builder.appendFixedPrecisionNumber(type.x());</span>
<span class="line-removed">171         builder.append(&#39; &#39;);</span>
<span class="line-removed">172         builder.appendFixedPrecisionNumber(type.y());</span>
<span class="line-removed">173         builder.append(&#39; &#39;);</span>
<span class="line-removed">174         builder.appendFixedPrecisionNumber(type.width());</span>
<span class="line-removed">175         builder.append(&#39; &#39;);</span>
<span class="line-removed">176         builder.appendFixedPrecisionNumber(type.height());</span>
<span class="line-removed">177         return builder.toString();</span>
178     }
179 };
180 
181 template&lt;&gt;
182 struct SVGPropertyTraits&lt;String&gt; {
183     static String initialValue() { return String(); }
184     static String fromString(const String&amp; string) { return string; }
185     static Optional&lt;String&gt; parse(const QualifiedName&amp;, const String&amp; string) { return string; }
186     static String toString(const String&amp; string) { return string; }
187 };
188 
189 template&lt;typename EnumType&gt;
190 struct SVGIDLEnumLimits {
191     // Specialize this function for a particular enumeration to limit the values that are exposed through the DOM.
192     static unsigned highestExposedEnumValue() { return SVGPropertyTraits&lt;EnumType&gt;::highestEnumValue(); }
193 };
194 
195 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSParser.h&quot;
 25 #include &quot;Color.h&quot;
 26 #include &quot;FloatPoint.h&quot;
 27 #include &quot;FloatRect.h&quot;
 28 #include &quot;QualifiedName.h&quot;
 29 #include &quot;SVGParserUtilities.h&quot;


 30 
 31 namespace WebCore {
 32 
 33 template&lt;typename PropertyType&gt;
 34 struct SVGPropertyTraits { };
 35 
 36 template&lt;&gt;
 37 struct SVGPropertyTraits&lt;bool&gt; {
 38     static bool initialValue() { return false; }
 39     static bool fromString(const String&amp; string) { return string == &quot;true&quot;; }
 40     static Optional&lt;bool&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 41     static String toString(bool type) { return type ? &quot;true&quot; : &quot;false&quot;; }
 42 };
 43 
 44 template&lt;&gt;
 45 struct SVGPropertyTraits&lt;Color&gt; {
 46     static Color initialValue() { return Color(); }
 47     static Color fromString(const String&amp; string) { return CSSParser::parseColor(string.stripWhiteSpace()); }
 48     static Optional&lt;Color&gt; parse(const QualifiedName&amp;, const String&amp; string)
 49     {
</pre>
<hr />
<pre>
 84     static String toString(std::pair&lt;int, int&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
 85 };
 86 
 87 template&lt;&gt;
 88 struct SVGPropertyTraits&lt;float&gt; {
 89     static float initialValue() { return 0; }
 90     static float fromString(const String&amp; string)
 91     {
 92         float number = 0;
 93         if (!parseNumberFromString(string, number))
 94             return 0;
 95         return number;
 96     }
 97     static Optional&lt;float&gt; parse(const QualifiedName&amp;, const String&amp; string)
 98     {
 99         float number;
100         if (!parseNumberFromString(string, number))
101             return WTF::nullopt;
102         return number;
103     }
<span class="line-modified">104     static String toString(float type) { return String::number(type); }</span>
105 };
106 
107 template&lt;&gt;
108 struct SVGPropertyTraits&lt;std::pair&lt;float, float&gt;&gt; {
109     static std::pair&lt;float, float&gt; initialValue() { return { }; }
110     static std::pair&lt;float, float&gt; fromString(const String&amp; string)
111     {
112         float firstNumber = 0, secondNumber = 0;
113         if (!parseNumberOptionalNumber(string, firstNumber, secondNumber))
114             return { };
115         return std::make_pair(firstNumber, secondNumber);
116     }
117     static Optional&lt;std::pair&lt;float, float&gt;&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
118     static String toString(std::pair&lt;float, float&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
119 };
120 
121 template&lt;&gt;
122 struct SVGPropertyTraits&lt;FloatPoint&gt; {
123     static FloatPoint initialValue() { return FloatPoint(); }
124     static FloatPoint fromString(const String&amp; string)
125     {
126         FloatPoint point;
127         if (!parsePoint(string, point))
128             return { };
129         return point;
130     }
131     static Optional&lt;FloatPoint&gt; parse(const QualifiedName&amp;, const String&amp; string)
132     {
133         FloatPoint point;
134         if (!parsePoint(string, point))
135             return WTF::nullopt;
136         return point;
137     }
138     static String toString(const FloatPoint&amp; type)
139     {
<span class="line-modified">140         return makeString(type.x(), &#39; &#39;, type.y());</span>




141     }
142 };
143 
144 template&lt;&gt;
145 struct SVGPropertyTraits&lt;FloatRect&gt; {
146     static FloatRect initialValue() { return FloatRect(); }
147     static FloatRect fromString(const String&amp; string)
148     {
149         FloatRect rect;
150         if (!parseRect(string, rect))
151             return { };
152         return rect;
153     }
154     static Optional&lt;FloatRect&gt; parse(const QualifiedName&amp;, const String&amp; string)
155     {
156         FloatRect rect;
157         if (!parseRect(string, rect))
158             return WTF::nullopt;
159         return rect;
160     }
161     static String toString(const FloatRect&amp; type)
162     {
<span class="line-modified">163         return makeString(type.x(), &#39; &#39;, type.y(), &#39; &#39;, type.width(), &#39; &#39;, type.height());</span>








164     }
165 };
166 
167 template&lt;&gt;
168 struct SVGPropertyTraits&lt;String&gt; {
169     static String initialValue() { return String(); }
170     static String fromString(const String&amp; string) { return string; }
171     static Optional&lt;String&gt; parse(const QualifiedName&amp;, const String&amp; string) { return string; }
172     static String toString(const String&amp; string) { return string; }
173 };
174 
175 template&lt;typename EnumType&gt;
176 struct SVGIDLEnumLimits {
177     // Specialize this function for a particular enumeration to limit the values that are exposed through the DOM.
178     static unsigned highestExposedEnumValue() { return SVGPropertyTraits&lt;EnumType&gt;::highestEnumValue(); }
179 };
180 
181 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="SVGPropertyRegistry.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGValuePropertyAnimatorImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
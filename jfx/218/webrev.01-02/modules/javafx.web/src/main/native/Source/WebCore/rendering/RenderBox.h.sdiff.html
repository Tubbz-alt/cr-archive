<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36 class RenderFragmentContainer;
 37 struct PaintInfo;
 38 
 39 enum SizeType { MainOrPreferredSize, MinSize, MaxSize };
 40 enum AvailableLogicalHeightType { ExcludeMarginBorderPadding, IncludeMarginBorderPadding };
 41 enum OverlayScrollbarSizeRelevancy { IgnoreOverlayScrollbarSize, IncludeOverlayScrollbarSize };
 42 
 43 enum ShouldComputePreferred { ComputeActual, ComputePreferred };
 44 
 45 class RenderBox : public RenderBoxModelObject {
 46     WTF_MAKE_ISO_ALLOCATED(RenderBox);
 47 public:
 48     virtual ~RenderBox();
 49 
 50     // hasAutoZIndex only returns true if the element is positioned or a flex-item since
 51     // position:static elements that are not flex-items get their z-index coerced to auto.
 52     bool requiresLayer() const override
 53     {
 54         return isDocumentElementRenderer() || isPositioned() || createsGroup() || hasClipPath() || hasOverflowClip()
 55             || hasTransformRelatedProperty() || hasHiddenBackface() || hasReflection() || style().specifiesColumns()
<span class="line-modified"> 56             || !style().hasAutoZIndex() || hasRunningAcceleratedAnimations();</span>
 57     }
 58 
 59     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const final;
 60 
 61     // Returns false for the body renderer if its background is propagated to the root.
 62     bool paintsOwnBackground() const;
 63 
 64     LayoutUnit x() const { return m_frameRect.x(); }
 65     LayoutUnit y() const { return m_frameRect.y(); }
 66     LayoutUnit width() const { return m_frameRect.width(); }
 67     LayoutUnit height() const { return m_frameRect.height(); }
 68 
 69     // These represent your location relative to your container as a physical offset.
 70     // In layout related methods you almost always want the logical location (e.g. x() and y()).
 71     LayoutUnit top() const { return topLeftLocation().y(); }
 72     LayoutUnit left() const { return topLeftLocation().x(); }
 73 
 74     template&lt;typename T&gt; void setX(T x) { m_frameRect.setX(x); }
 75     template&lt;typename T&gt; void setY(T y) { m_frameRect.setY(y); }
 76     template&lt;typename T&gt; void setWidth(T width) { m_frameRect.setWidth(width); }
</pre>
<hr />
<pre>
200     void addLayoutOverflow(const LayoutRect&amp;);
201     void addVisualOverflow(const LayoutRect&amp;);
202     void clearOverflow();
203 
204     virtual bool isTopLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; !isHorizontalWritingMode(); }
205     virtual bool isLeftLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode(); }
206 
207     void addVisualEffectOverflow();
208     LayoutRect applyVisualEffectOverflow(const LayoutRect&amp;) const;
209     void addOverflowFromChild(const RenderBox* child) { addOverflowFromChild(child, child-&gt;locationOffset()); }
210     void addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta);
211 
212     void updateLayerTransform();
213 
214     LayoutSize contentSize() const { return { contentWidth(), contentHeight() }; }
215     LayoutUnit contentWidth() const { return paddingBoxWidth() - paddingLeft() - paddingRight(); }
216     LayoutUnit contentHeight() const { return paddingBoxHeight() - paddingTop() - paddingBottom(); }
217     LayoutUnit contentLogicalWidth() const { return style().isHorizontalWritingMode() ? contentWidth() : contentHeight(); }
218     LayoutUnit contentLogicalHeight() const { return style().isHorizontalWritingMode() ? contentHeight() : contentWidth(); }
219 
<span class="line-modified">220     LayoutUnit paddingBoxWidth() const { return width() - borderLeft() - borderRight() - verticalScrollbarWidth(); }</span>
<span class="line-modified">221     LayoutUnit paddingBoxHeight() const { return height() - borderTop() - borderBottom() - horizontalScrollbarHeight(); }</span>
222     LayoutRect paddingBoxRect() const;
223     LayoutRect paddingBoxRectIncludingScrollbar() const { return LayoutRect(borderLeft(), borderTop(), width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom()); }
224 
225     // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (RenderFlow)
226     // to return the remaining width on a given line (and the height of a single line).
227     LayoutUnit offsetWidth() const override { return width(); }
228     LayoutUnit offsetHeight() const override { return height(); }
229 
230     // More IE extensions.  clientWidth and clientHeight represent the interior of an object
231     // excluding border and scrollbar.  clientLeft/Top are just the borderLeftWidth and borderTopWidth.
232     LayoutUnit clientLeft() const { return borderLeft(); }
233     LayoutUnit clientTop() const { return borderTop(); }
234     WEBCORE_EXPORT LayoutUnit clientWidth() const;
235     WEBCORE_EXPORT LayoutUnit clientHeight() const;
236     LayoutUnit clientLogicalWidth() const { return style().isHorizontalWritingMode() ? clientWidth() : clientHeight(); }
237     LayoutUnit clientLogicalHeight() const { return style().isHorizontalWritingMode() ? clientHeight() : clientWidth(); }
238     LayoutUnit clientLogicalBottom() const { return borderBefore() + clientLogicalHeight(); }
239     LayoutRect clientBoxRect() const { return LayoutRect(clientLeft(), clientTop(), clientWidth(), clientHeight()); }
240 
241     // scrollWidth/scrollHeight will be the same as clientWidth/clientHeight unless the
</pre>
<hr />
<pre>
637 
638     const RenderBox* findEnclosingScrollableContainer() const;
639 
640     bool isGridItem() const { return parent() &amp;&amp; parent()-&gt;isRenderGrid() &amp;&amp; !isExcludedFromNormalLayout(); }
641     bool isFlexItem() const { return parent() &amp;&amp; parent()-&gt;isFlexibleBox() &amp;&amp; !isExcludedFromNormalLayout(); }
642 
643     virtual void adjustBorderBoxRectForPainting(LayoutRect&amp;) { };
644 
645 protected:
646     RenderBox(Element&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
647     RenderBox(Document&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
648 
649     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
650     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
651     void updateFromStyle() override;
652 
653     void willBeDestroyed() override;
654 
655     bool createsNewFormattingContext() const;
656 



657     virtual ItemPosition selfAlignmentNormalBehavior(const RenderBox* = nullptr) const { return ItemPosition::Stretch; }
658 
659     // Returns false if it could not cheaply compute the extent (e.g. fixed background), in which case the returned rect may be incorrect.
660     bool getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp;) const;
661     virtual bool foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const;
662     bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset) override;
663 
664     void paintBackground(const PaintInfo&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone);
665 
666     void paintFillLayer(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance, CompositeOperator, RenderElement* backgroundObject, BaseBackgroundColorUsage = BaseBackgroundColorUse);
<span class="line-modified">667     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeSourceOver, RenderElement* backgroundObject = nullptr);</span>
668 
669     void paintMaskImages(const PaintInfo&amp;, const LayoutRect&amp;);
670 
671     BackgroundBleedAvoidance determineBackgroundBleedAvoidance(GraphicsContext&amp;) const;
672     bool backgroundHasOpaqueTopLayer() const;
673 
674     void computePositionedLogicalWidth(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
675 
676     LayoutUnit computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const;
677     virtual Optional&lt;LayoutUnit&gt; computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const;
678 
679     virtual bool shouldComputeSizeAsReplaced() const { return isReplaced() &amp;&amp; !isInlineBlockOrInlineTable(); }
680 
681     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
682     const RenderObject* pushMappingToContainer(const RenderLayerModelObject*, RenderGeometryMap&amp;) const override;
683     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
684 
685     void paintRootBoxFillLayers(const PaintInfo&amp;);
686 
687     bool skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const;
</pre>
</td>
<td>
<hr />
<pre>
 36 class RenderFragmentContainer;
 37 struct PaintInfo;
 38 
 39 enum SizeType { MainOrPreferredSize, MinSize, MaxSize };
 40 enum AvailableLogicalHeightType { ExcludeMarginBorderPadding, IncludeMarginBorderPadding };
 41 enum OverlayScrollbarSizeRelevancy { IgnoreOverlayScrollbarSize, IncludeOverlayScrollbarSize };
 42 
 43 enum ShouldComputePreferred { ComputeActual, ComputePreferred };
 44 
 45 class RenderBox : public RenderBoxModelObject {
 46     WTF_MAKE_ISO_ALLOCATED(RenderBox);
 47 public:
 48     virtual ~RenderBox();
 49 
 50     // hasAutoZIndex only returns true if the element is positioned or a flex-item since
 51     // position:static elements that are not flex-items get their z-index coerced to auto.
 52     bool requiresLayer() const override
 53     {
 54         return isDocumentElementRenderer() || isPositioned() || createsGroup() || hasClipPath() || hasOverflowClip()
 55             || hasTransformRelatedProperty() || hasHiddenBackface() || hasReflection() || style().specifiesColumns()
<span class="line-modified"> 56             || !style().hasAutoUsedZIndex() || hasRunningAcceleratedAnimations();</span>
 57     }
 58 
 59     bool backgroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect) const final;
 60 
 61     // Returns false for the body renderer if its background is propagated to the root.
 62     bool paintsOwnBackground() const;
 63 
 64     LayoutUnit x() const { return m_frameRect.x(); }
 65     LayoutUnit y() const { return m_frameRect.y(); }
 66     LayoutUnit width() const { return m_frameRect.width(); }
 67     LayoutUnit height() const { return m_frameRect.height(); }
 68 
 69     // These represent your location relative to your container as a physical offset.
 70     // In layout related methods you almost always want the logical location (e.g. x() and y()).
 71     LayoutUnit top() const { return topLeftLocation().y(); }
 72     LayoutUnit left() const { return topLeftLocation().x(); }
 73 
 74     template&lt;typename T&gt; void setX(T x) { m_frameRect.setX(x); }
 75     template&lt;typename T&gt; void setY(T y) { m_frameRect.setY(y); }
 76     template&lt;typename T&gt; void setWidth(T width) { m_frameRect.setWidth(width); }
</pre>
<hr />
<pre>
200     void addLayoutOverflow(const LayoutRect&amp;);
201     void addVisualOverflow(const LayoutRect&amp;);
202     void clearOverflow();
203 
204     virtual bool isTopLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; !isHorizontalWritingMode(); }
205     virtual bool isLeftLayoutOverflowAllowed() const { return !style().isLeftToRightDirection() &amp;&amp; isHorizontalWritingMode(); }
206 
207     void addVisualEffectOverflow();
208     LayoutRect applyVisualEffectOverflow(const LayoutRect&amp;) const;
209     void addOverflowFromChild(const RenderBox* child) { addOverflowFromChild(child, child-&gt;locationOffset()); }
210     void addOverflowFromChild(const RenderBox* child, const LayoutSize&amp; delta);
211 
212     void updateLayerTransform();
213 
214     LayoutSize contentSize() const { return { contentWidth(), contentHeight() }; }
215     LayoutUnit contentWidth() const { return paddingBoxWidth() - paddingLeft() - paddingRight(); }
216     LayoutUnit contentHeight() const { return paddingBoxHeight() - paddingTop() - paddingBottom(); }
217     LayoutUnit contentLogicalWidth() const { return style().isHorizontalWritingMode() ? contentWidth() : contentHeight(); }
218     LayoutUnit contentLogicalHeight() const { return style().isHorizontalWritingMode() ? contentHeight() : contentWidth(); }
219 
<span class="line-modified">220     LayoutUnit paddingBoxWidth() const { return std::max(0_lu, width() - borderLeft() - borderRight() - verticalScrollbarWidth()); }</span>
<span class="line-modified">221     LayoutUnit paddingBoxHeight() const { return std::max(0_lu, height() - borderTop() - borderBottom() - horizontalScrollbarHeight()); }</span>
222     LayoutRect paddingBoxRect() const;
223     LayoutRect paddingBoxRectIncludingScrollbar() const { return LayoutRect(borderLeft(), borderTop(), width() - borderLeft() - borderRight(), height() - borderTop() - borderBottom()); }
224 
225     // IE extensions. Used to calculate offsetWidth/Height.  Overridden by inlines (RenderFlow)
226     // to return the remaining width on a given line (and the height of a single line).
227     LayoutUnit offsetWidth() const override { return width(); }
228     LayoutUnit offsetHeight() const override { return height(); }
229 
230     // More IE extensions.  clientWidth and clientHeight represent the interior of an object
231     // excluding border and scrollbar.  clientLeft/Top are just the borderLeftWidth and borderTopWidth.
232     LayoutUnit clientLeft() const { return borderLeft(); }
233     LayoutUnit clientTop() const { return borderTop(); }
234     WEBCORE_EXPORT LayoutUnit clientWidth() const;
235     WEBCORE_EXPORT LayoutUnit clientHeight() const;
236     LayoutUnit clientLogicalWidth() const { return style().isHorizontalWritingMode() ? clientWidth() : clientHeight(); }
237     LayoutUnit clientLogicalHeight() const { return style().isHorizontalWritingMode() ? clientHeight() : clientWidth(); }
238     LayoutUnit clientLogicalBottom() const { return borderBefore() + clientLogicalHeight(); }
239     LayoutRect clientBoxRect() const { return LayoutRect(clientLeft(), clientTop(), clientWidth(), clientHeight()); }
240 
241     // scrollWidth/scrollHeight will be the same as clientWidth/clientHeight unless the
</pre>
<hr />
<pre>
637 
638     const RenderBox* findEnclosingScrollableContainer() const;
639 
640     bool isGridItem() const { return parent() &amp;&amp; parent()-&gt;isRenderGrid() &amp;&amp; !isExcludedFromNormalLayout(); }
641     bool isFlexItem() const { return parent() &amp;&amp; parent()-&gt;isFlexibleBox() &amp;&amp; !isExcludedFromNormalLayout(); }
642 
643     virtual void adjustBorderBoxRectForPainting(LayoutRect&amp;) { };
644 
645 protected:
646     RenderBox(Element&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
647     RenderBox(Document&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
648 
649     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
650     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
651     void updateFromStyle() override;
652 
653     void willBeDestroyed() override;
654 
655     bool createsNewFormattingContext() const;
656 
<span class="line-added">657     virtual bool shouldResetLogicalHeightBeforeLayout() const { return false; }</span>
<span class="line-added">658     void resetLogicalHeightBeforeLayoutIfNeeded();</span>
<span class="line-added">659 </span>
660     virtual ItemPosition selfAlignmentNormalBehavior(const RenderBox* = nullptr) const { return ItemPosition::Stretch; }
661 
662     // Returns false if it could not cheaply compute the extent (e.g. fixed background), in which case the returned rect may be incorrect.
663     bool getBackgroundPaintedExtent(const LayoutPoint&amp; paintOffset, LayoutRect&amp;) const;
664     virtual bool foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const;
665     bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset) override;
666 
667     void paintBackground(const PaintInfo&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone);
668 
669     void paintFillLayer(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance, CompositeOperator, RenderElement* backgroundObject, BaseBackgroundColorUsage = BaseBackgroundColorUse);
<span class="line-modified">670     void paintFillLayers(const PaintInfo&amp;, const Color&amp;, const FillLayer&amp;, const LayoutRect&amp;, BackgroundBleedAvoidance = BackgroundBleedNone, CompositeOperator = CompositeOperator::SourceOver, RenderElement* backgroundObject = nullptr);</span>
671 
672     void paintMaskImages(const PaintInfo&amp;, const LayoutRect&amp;);
673 
674     BackgroundBleedAvoidance determineBackgroundBleedAvoidance(GraphicsContext&amp;) const;
675     bool backgroundHasOpaqueTopLayer() const;
676 
677     void computePositionedLogicalWidth(LogicalExtentComputedValues&amp;, RenderFragmentContainer* = nullptr) const;
678 
679     LayoutUnit computeIntrinsicLogicalWidthUsing(Length logicalWidthLength, LayoutUnit availableLogicalWidth, LayoutUnit borderAndPadding) const;
680     virtual Optional&lt;LayoutUnit&gt; computeIntrinsicLogicalContentHeightUsing(Length logicalHeightLength, Optional&lt;LayoutUnit&gt; intrinsicContentHeight, LayoutUnit borderAndPadding) const;
681 
682     virtual bool shouldComputeSizeAsReplaced() const { return isReplaced() &amp;&amp; !isInlineBlockOrInlineTable(); }
683 
684     void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed) const override;
685     const RenderObject* pushMappingToContainer(const RenderLayerModelObject*, RenderGeometryMap&amp;) const override;
686     void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const override;
687 
688     void paintRootBoxFillLayers(const PaintInfo&amp;);
689 
690     bool skipContainingBlockForPercentHeightCalculation(const RenderBox&amp; containingBlock, bool isPerpendicularWritingMode) const;
</pre>
</td>
</tr>
</table>
<center><a href="RenderBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
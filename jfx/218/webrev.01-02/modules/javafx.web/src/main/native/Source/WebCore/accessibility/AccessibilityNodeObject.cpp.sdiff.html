<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityMenuListPopup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityNodeObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  89 
  90 AccessibilityNodeObject::~AccessibilityNodeObject()
  91 {
  92     ASSERT(isDetached());
  93 }
  94 
  95 void AccessibilityNodeObject::init()
  96 {
  97 #ifndef NDEBUG
  98     ASSERT(!m_initialized);
  99     m_initialized = true;
 100 #endif
 101     m_role = determineAccessibilityRole();
 102 }
 103 
 104 Ref&lt;AccessibilityNodeObject&gt; AccessibilityNodeObject::create(Node* node)
 105 {
 106     return adoptRef(*new AccessibilityNodeObject(node));
 107 }
 108 
<span class="line-modified"> 109 void AccessibilityNodeObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)</span>
 110 {
 111     // AccessibilityObject calls clearChildren.
<span class="line-modified"> 112     AccessibilityObject::detach(detachmentType, cache);</span>
 113     m_node = nullptr;
 114 }
 115 
 116 void AccessibilityNodeObject::childrenChanged()
 117 {
 118     // This method is meant as a quick way of marking a portion of the accessibility tree dirty.
 119     if (!node() &amp;&amp; !renderer())
 120         return;
 121 
 122     AXObjectCache* cache = axObjectCache();
 123     if (!cache)
 124         return;
 125     cache-&gt;postNotification(this, document(), AXObjectCache::AXChildrenChanged);
 126 
 127     // Should make the sub tree dirty so that everything below will be updated correctly.
 128     this-&gt;setNeedsToUpdateSubtree();
 129     bool shouldStopUpdatingParent = false;
 130 
 131     // Go up the accessibility parent chain, but only if the element already exists. This method is
 132     // called during render layouts, minimal work should be done.
</pre>
<hr />
<pre>
 895         return false;
 896 
 897     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute()) || roleValue() == AccessibilityRole::Button;
 898 }
 899 
 900 bool AccessibilityNodeObject::isFieldset() const
 901 {
 902     Node* node = this-&gt;node();
 903     if (!node)
 904         return false;
 905 
 906     return node-&gt;hasTagName(fieldsetTag);
 907 }
 908 
 909 bool AccessibilityNodeObject::isGroup() const
 910 {
 911     AccessibilityRole role = roleValue();
 912     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 913 }
 914 
<span class="line-modified"> 915 AccessibilityObject* AccessibilityNodeObject::selectedRadioButton()</span>
 916 {
 917     if (!isRadioGroup())
 918         return nullptr;
 919 
 920     // Find the child radio button that is selected (ie. the intValue == 1).
 921     for (const auto&amp; child : children()) {
 922         if (child-&gt;roleValue() == AccessibilityRole::RadioButton &amp;&amp; child-&gt;checkboxOrRadioValue() == AccessibilityButtonState::On)
 923             return child.get();
 924     }
 925     return nullptr;
 926 }
 927 
<span class="line-modified"> 928 AccessibilityObject* AccessibilityNodeObject::selectedTabItem()</span>
 929 {
 930     if (!isTabList())
 931         return nullptr;
 932 
 933     // FIXME: Is this valid? ARIA tab items support aria-selected; not aria-checked.
 934     // Find the child tab item that is selected (ie. the intValue == 1).
<span class="line-modified"> 935     AccessibilityObject::AccessibilityChildrenVector tabs;</span>
 936     tabChildren(tabs);
 937 
 938     for (const auto&amp; child : children()) {
 939         if (child-&gt;isTabItem() &amp;&amp; (child-&gt;isChecked() || child-&gt;isSelected()))
 940             return child.get();
 941     }
 942     return nullptr;
 943 }
 944 
 945 AccessibilityButtonState AccessibilityNodeObject::checkboxOrRadioValue() const
 946 {
 947     if (isNativeCheckboxOrRadio())
 948         return isIndeterminate() ? AccessibilityButtonState::Mixed : isChecked() ? AccessibilityButtonState::On : AccessibilityButtonState::Off;
 949 
 950     return AccessibilityObject::checkboxOrRadioValue();
 951 }
 952 
 953 Element* AccessibilityNodeObject::anchorElement() const
 954 {
 955     Node* node = this-&gt;node();
</pre>
<hr />
<pre>
1087 
1088 void AccessibilityNodeObject::increment()
1089 {
1090     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1091     alterSliderValue(true);
1092 }
1093 
1094 void AccessibilityNodeObject::decrement()
1095 {
1096     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1097     alterSliderValue(false);
1098 }
1099 
1100 void AccessibilityNodeObject::changeValueByStep(bool increase)
1101 {
1102     float step = stepValueForRange();
1103     float value = valueForRange();
1104 
1105     value += increase ? step : -step;
1106 
<span class="line-modified">1107     setValue(String::numberToStringFixedPrecision(value));</span>
1108 
1109     auto objectCache = axObjectCache();
1110     if (objectCache)
1111         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);
1112 }
1113 
1114 void AccessibilityNodeObject::changeValueByPercent(float percentChange)
1115 {
1116     float range = maxValueForRange() - minValueForRange();
1117     float step = range * (percentChange / 100);
1118     float value = valueForRange();
1119 
1120     // Make sure the specified percent will cause a change of one integer step or larger.
1121     if (std::abs(step) &lt; 1)
1122         step = std::abs(percentChange) * (1 / percentChange);
1123 
1124     value += step;
<span class="line-modified">1125     setValue(String::numberToStringFixedPrecision(value));</span>
1126 
1127     auto objectCache = axObjectCache();
1128     if (objectCache)
1129         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);
1130 }
1131 
1132 bool AccessibilityNodeObject::isGenericFocusableElement() const
1133 {
1134     if (!canSetFocusAttribute())
1135         return false;
1136 
1137     // If it&#39;s a control, it&#39;s not generic.
1138     if (isControl())
1139         return false;
1140 
1141     AccessibilityRole role = roleValue();
1142     if (role == AccessibilityRole::Video || role == AccessibilityRole::Audio)
1143         return false;
1144 
1145     // If it has an aria role, it&#39;s not generic.
</pre>
<hr />
<pre>
1450         String text = textUnderElement(mode);
1451         if (!text.isEmpty())
1452             textOrder.append(AccessibilityText(text, AccessibilityTextSource::Children));
1453     }
1454 }
1455 
1456 void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1457 {
1458     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);
1459     if (!ariaHelp.isEmpty())
1460         textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
1461 
1462     String describedBy = ariaDescribedByAttribute();
1463     if (!describedBy.isEmpty())
1464         textOrder.append(AccessibilityText(describedBy, AccessibilityTextSource::Summary));
1465     else if (isControl()) {
1466         // For controls, use their fieldset parent&#39;s described-by text if available.
1467         auto matchFunc = [] (const AccessibilityObject&amp; object) {
1468             return object.isFieldset() &amp;&amp; !object.ariaDescribedByAttribute().isEmpty();
1469         };
<span class="line-modified">1470         if (const auto* parent = AccessibilityObject::matchedParent(*this, false, WTFMove(matchFunc)))</span>
1471             textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
1472     }
1473 
1474     // Summary attribute used as help text on tables.
1475     const AtomString&amp; summary = getAttribute(summaryAttr);
1476     if (!summary.isEmpty())
1477         textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
1478 
1479     // The title attribute should be used as help text unless it is already being used as descriptive text.
1480     // However, when the title attribute is the only text alternative provided, it may be exposed as the
1481     // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
1482     // can expose units through this attribute. Therefore, if the element is a meter, change its source
1483     // type to AccessibilityTextSource::Help.
1484     const AtomString&amp; title = getAttribute(titleAttr);
1485     if (!title.isEmpty()) {
1486         if (!isMeter() &amp;&amp; !roleIgnoresTitle())
1487             textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
1488         else
1489             textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
1490     }
</pre>
<hr />
<pre>
1496     alternativeText(textOrder);
1497     visibleText(textOrder);
1498     helpText(textOrder);
1499 
1500     String placeholder = placeholderValue();
1501     if (!placeholder.isEmpty())
1502         textOrder.append(AccessibilityText(placeholder, AccessibilityTextSource::Placeholder));
1503 }
1504 
1505 void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1506 {
1507     String ariaLabeledBy = ariaLabeledByAttribute();
1508     if (!ariaLabeledBy.isEmpty()) {
1509         auto objectCache = axObjectCache();
1510         if (!objectCache)
1511             return;
1512 
1513         Vector&lt;Element*&gt; elements;
1514         ariaLabeledByElements(elements);
1515 
<span class="line-modified">1516         Vector&lt;RefPtr&lt;AccessibilityObject&gt;&gt; axElements;</span>
1517         for (const auto&amp; element : elements)
1518             axElements.append(objectCache-&gt;getOrCreate(element));
1519 
<span class="line-modified">1520         textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, WTFMove(axElements)));</span>
1521     }
1522 }
1523 
1524 String AccessibilityNodeObject::alternativeTextForWebArea() const
1525 {
1526     // The WebArea description should follow this order:
1527     //     aria-label on the &lt;html&gt;
1528     //     title on the &lt;html&gt;
1529     //     &lt;title&gt; inside the &lt;head&gt; (of it was set through JS)
1530     //     name on the &lt;html&gt;
1531     // For iframes:
1532     //     aria-label on the &lt;iframe&gt;
1533     //     title on the &lt;iframe&gt;
1534     //     name on the &lt;iframe&gt;
1535 
1536     Document* document = this-&gt;document();
1537     if (!document)
1538         return String();
1539 
1540     // Check if the HTML element has an aria-label for the webpage.
</pre>
<hr />
<pre>
1753     if (!builder.length() || !childText.length())
1754         return false;
1755 
1756     // We don&#39;t need to add an additional space before or after a line break.
1757     return !(isHTMLLineBreak(childText[0]) || isHTMLLineBreak(builder[builder.length() - 1]));
1758 }
1759 
1760 static void appendNameToStringBuilder(StringBuilder&amp; builder, const String&amp; text)
1761 {
1762     if (shouldAddSpaceBeforeAppendingNextElement(builder, text))
1763         builder.append(&#39; &#39;);
1764     builder.append(text);
1765 }
1766 
1767 String AccessibilityNodeObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
1768 {
1769     Node* node = this-&gt;node();
1770     if (is&lt;Text&gt;(node))
1771         return downcast&lt;Text&gt;(*node).wholeText();
1772 
<span class="line-modified">1773     bool isAriaVisible = AccessibilityObject::matchedParent(*this, true, [] (const AccessibilityObject&amp; object) {</span>
1774         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;false&quot;);
1775     }) != nullptr;
1776 
1777     // The Accname specification states that if the current node is hidden, and not directly
1778     // referenced by aria-labelledby or aria-describedby, and is not a host language text
1779     // alternative, the empty string should be returned.
1780     if (isDOMHidden() &amp;&amp; !isAriaVisible &amp;&amp; !is&lt;HTMLLabelElement&gt;(node) &amp;&amp; (node &amp;&amp; !ancestorsOfType&lt;HTMLCanvasElement&gt;(*node).first())) {
1781         AccessibilityObject::AccessibilityChildrenVector labelFor;
1782         AccessibilityObject::AccessibilityChildrenVector descriptionFor;
1783         ariaLabelledByReferencingElements(labelFor);
1784         ariaDescribedByReferencingElements(descriptionFor);
1785         if (!labelFor.size() &amp;&amp; !descriptionFor.size())
1786             return String();
1787     }
1788 
1789     StringBuilder builder;
1790     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
1791         if (mode.ignoredChildNode &amp;&amp; child-&gt;node() == mode.ignoredChildNode)
1792             continue;
1793 
</pre>
</td>
<td>
<hr />
<pre>
  89 
  90 AccessibilityNodeObject::~AccessibilityNodeObject()
  91 {
  92     ASSERT(isDetached());
  93 }
  94 
  95 void AccessibilityNodeObject::init()
  96 {
  97 #ifndef NDEBUG
  98     ASSERT(!m_initialized);
  99     m_initialized = true;
 100 #endif
 101     m_role = determineAccessibilityRole();
 102 }
 103 
 104 Ref&lt;AccessibilityNodeObject&gt; AccessibilityNodeObject::create(Node* node)
 105 {
 106     return adoptRef(*new AccessibilityNodeObject(node));
 107 }
 108 
<span class="line-modified"> 109 void AccessibilityNodeObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
 110 {
 111     // AccessibilityObject calls clearChildren.
<span class="line-modified"> 112     AccessibilityObject::detachRemoteParts(detachmentType);</span>
 113     m_node = nullptr;
 114 }
 115 
 116 void AccessibilityNodeObject::childrenChanged()
 117 {
 118     // This method is meant as a quick way of marking a portion of the accessibility tree dirty.
 119     if (!node() &amp;&amp; !renderer())
 120         return;
 121 
 122     AXObjectCache* cache = axObjectCache();
 123     if (!cache)
 124         return;
 125     cache-&gt;postNotification(this, document(), AXObjectCache::AXChildrenChanged);
 126 
 127     // Should make the sub tree dirty so that everything below will be updated correctly.
 128     this-&gt;setNeedsToUpdateSubtree();
 129     bool shouldStopUpdatingParent = false;
 130 
 131     // Go up the accessibility parent chain, but only if the element already exists. This method is
 132     // called during render layouts, minimal work should be done.
</pre>
<hr />
<pre>
 895         return false;
 896 
 897     return is&lt;HTMLFormControlElement&gt;(*node) || AccessibilityObject::isARIAControl(ariaRoleAttribute()) || roleValue() == AccessibilityRole::Button;
 898 }
 899 
 900 bool AccessibilityNodeObject::isFieldset() const
 901 {
 902     Node* node = this-&gt;node();
 903     if (!node)
 904         return false;
 905 
 906     return node-&gt;hasTagName(fieldsetTag);
 907 }
 908 
 909 bool AccessibilityNodeObject::isGroup() const
 910 {
 911     AccessibilityRole role = roleValue();
 912     return role == AccessibilityRole::Group || role == AccessibilityRole::TextGroup || role == AccessibilityRole::ApplicationGroup || role == AccessibilityRole::ApplicationTextGroup;
 913 }
 914 
<span class="line-modified"> 915 AXCoreObject* AccessibilityNodeObject::selectedRadioButton()</span>
 916 {
 917     if (!isRadioGroup())
 918         return nullptr;
 919 
 920     // Find the child radio button that is selected (ie. the intValue == 1).
 921     for (const auto&amp; child : children()) {
 922         if (child-&gt;roleValue() == AccessibilityRole::RadioButton &amp;&amp; child-&gt;checkboxOrRadioValue() == AccessibilityButtonState::On)
 923             return child.get();
 924     }
 925     return nullptr;
 926 }
 927 
<span class="line-modified"> 928 AXCoreObject* AccessibilityNodeObject::selectedTabItem()</span>
 929 {
 930     if (!isTabList())
 931         return nullptr;
 932 
 933     // FIXME: Is this valid? ARIA tab items support aria-selected; not aria-checked.
 934     // Find the child tab item that is selected (ie. the intValue == 1).
<span class="line-modified"> 935     AXCoreObject::AccessibilityChildrenVector tabs;</span>
 936     tabChildren(tabs);
 937 
 938     for (const auto&amp; child : children()) {
 939         if (child-&gt;isTabItem() &amp;&amp; (child-&gt;isChecked() || child-&gt;isSelected()))
 940             return child.get();
 941     }
 942     return nullptr;
 943 }
 944 
 945 AccessibilityButtonState AccessibilityNodeObject::checkboxOrRadioValue() const
 946 {
 947     if (isNativeCheckboxOrRadio())
 948         return isIndeterminate() ? AccessibilityButtonState::Mixed : isChecked() ? AccessibilityButtonState::On : AccessibilityButtonState::Off;
 949 
 950     return AccessibilityObject::checkboxOrRadioValue();
 951 }
 952 
 953 Element* AccessibilityNodeObject::anchorElement() const
 954 {
 955     Node* node = this-&gt;node();
</pre>
<hr />
<pre>
1087 
1088 void AccessibilityNodeObject::increment()
1089 {
1090     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1091     alterSliderValue(true);
1092 }
1093 
1094 void AccessibilityNodeObject::decrement()
1095 {
1096     UserGestureIndicator gestureIndicator(ProcessingUserGesture, document());
1097     alterSliderValue(false);
1098 }
1099 
1100 void AccessibilityNodeObject::changeValueByStep(bool increase)
1101 {
1102     float step = stepValueForRange();
1103     float value = valueForRange();
1104 
1105     value += increase ? step : -step;
1106 
<span class="line-modified">1107     setValue(String::number(value));</span>
1108 
1109     auto objectCache = axObjectCache();
1110     if (objectCache)
1111         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);
1112 }
1113 
1114 void AccessibilityNodeObject::changeValueByPercent(float percentChange)
1115 {
1116     float range = maxValueForRange() - minValueForRange();
1117     float step = range * (percentChange / 100);
1118     float value = valueForRange();
1119 
1120     // Make sure the specified percent will cause a change of one integer step or larger.
1121     if (std::abs(step) &lt; 1)
1122         step = std::abs(percentChange) * (1 / percentChange);
1123 
1124     value += step;
<span class="line-modified">1125     setValue(String::number(value));</span>
1126 
1127     auto objectCache = axObjectCache();
1128     if (objectCache)
1129         objectCache-&gt;postNotification(node(), AXObjectCache::AXValueChanged);
1130 }
1131 
1132 bool AccessibilityNodeObject::isGenericFocusableElement() const
1133 {
1134     if (!canSetFocusAttribute())
1135         return false;
1136 
1137     // If it&#39;s a control, it&#39;s not generic.
1138     if (isControl())
1139         return false;
1140 
1141     AccessibilityRole role = roleValue();
1142     if (role == AccessibilityRole::Video || role == AccessibilityRole::Audio)
1143         return false;
1144 
1145     // If it has an aria role, it&#39;s not generic.
</pre>
<hr />
<pre>
1450         String text = textUnderElement(mode);
1451         if (!text.isEmpty())
1452             textOrder.append(AccessibilityText(text, AccessibilityTextSource::Children));
1453     }
1454 }
1455 
1456 void AccessibilityNodeObject::helpText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1457 {
1458     const AtomString&amp; ariaHelp = getAttribute(aria_helpAttr);
1459     if (!ariaHelp.isEmpty())
1460         textOrder.append(AccessibilityText(ariaHelp, AccessibilityTextSource::Help));
1461 
1462     String describedBy = ariaDescribedByAttribute();
1463     if (!describedBy.isEmpty())
1464         textOrder.append(AccessibilityText(describedBy, AccessibilityTextSource::Summary));
1465     else if (isControl()) {
1466         // For controls, use their fieldset parent&#39;s described-by text if available.
1467         auto matchFunc = [] (const AccessibilityObject&amp; object) {
1468             return object.isFieldset() &amp;&amp; !object.ariaDescribedByAttribute().isEmpty();
1469         };
<span class="line-modified">1470         if (const auto* parent = Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, false, WTFMove(matchFunc)))</span>
1471             textOrder.append(AccessibilityText(parent-&gt;ariaDescribedByAttribute(), AccessibilityTextSource::Summary));
1472     }
1473 
1474     // Summary attribute used as help text on tables.
1475     const AtomString&amp; summary = getAttribute(summaryAttr);
1476     if (!summary.isEmpty())
1477         textOrder.append(AccessibilityText(summary, AccessibilityTextSource::Summary));
1478 
1479     // The title attribute should be used as help text unless it is already being used as descriptive text.
1480     // However, when the title attribute is the only text alternative provided, it may be exposed as the
1481     // descriptive text. This is problematic in the case of meters because the HTML spec suggests authors
1482     // can expose units through this attribute. Therefore, if the element is a meter, change its source
1483     // type to AccessibilityTextSource::Help.
1484     const AtomString&amp; title = getAttribute(titleAttr);
1485     if (!title.isEmpty()) {
1486         if (!isMeter() &amp;&amp; !roleIgnoresTitle())
1487             textOrder.append(AccessibilityText(title, AccessibilityTextSource::TitleTag));
1488         else
1489             textOrder.append(AccessibilityText(title, AccessibilityTextSource::Help));
1490     }
</pre>
<hr />
<pre>
1496     alternativeText(textOrder);
1497     visibleText(textOrder);
1498     helpText(textOrder);
1499 
1500     String placeholder = placeholderValue();
1501     if (!placeholder.isEmpty())
1502         textOrder.append(AccessibilityText(placeholder, AccessibilityTextSource::Placeholder));
1503 }
1504 
1505 void AccessibilityNodeObject::ariaLabeledByText(Vector&lt;AccessibilityText&gt;&amp; textOrder) const
1506 {
1507     String ariaLabeledBy = ariaLabeledByAttribute();
1508     if (!ariaLabeledBy.isEmpty()) {
1509         auto objectCache = axObjectCache();
1510         if (!objectCache)
1511             return;
1512 
1513         Vector&lt;Element*&gt; elements;
1514         ariaLabeledByElements(elements);
1515 
<span class="line-modified">1516         Vector&lt;AXCoreObject*&gt; axElements;</span>
1517         for (const auto&amp; element : elements)
1518             axElements.append(objectCache-&gt;getOrCreate(element));
1519 
<span class="line-modified">1520         textOrder.append(AccessibilityText(ariaLabeledBy, AccessibilityTextSource::Alternative, axElements));</span>
1521     }
1522 }
1523 
1524 String AccessibilityNodeObject::alternativeTextForWebArea() const
1525 {
1526     // The WebArea description should follow this order:
1527     //     aria-label on the &lt;html&gt;
1528     //     title on the &lt;html&gt;
1529     //     &lt;title&gt; inside the &lt;head&gt; (of it was set through JS)
1530     //     name on the &lt;html&gt;
1531     // For iframes:
1532     //     aria-label on the &lt;iframe&gt;
1533     //     title on the &lt;iframe&gt;
1534     //     name on the &lt;iframe&gt;
1535 
1536     Document* document = this-&gt;document();
1537     if (!document)
1538         return String();
1539 
1540     // Check if the HTML element has an aria-label for the webpage.
</pre>
<hr />
<pre>
1753     if (!builder.length() || !childText.length())
1754         return false;
1755 
1756     // We don&#39;t need to add an additional space before or after a line break.
1757     return !(isHTMLLineBreak(childText[0]) || isHTMLLineBreak(builder[builder.length() - 1]));
1758 }
1759 
1760 static void appendNameToStringBuilder(StringBuilder&amp; builder, const String&amp; text)
1761 {
1762     if (shouldAddSpaceBeforeAppendingNextElement(builder, text))
1763         builder.append(&#39; &#39;);
1764     builder.append(text);
1765 }
1766 
1767 String AccessibilityNodeObject::textUnderElement(AccessibilityTextUnderElementMode mode) const
1768 {
1769     Node* node = this-&gt;node();
1770     if (is&lt;Text&gt;(node))
1771         return downcast&lt;Text&gt;(*node).wholeText();
1772 
<span class="line-modified">1773     bool isAriaVisible = Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [] (const AccessibilityObject&amp; object) {</span>
1774         return equalLettersIgnoringASCIICase(object.getAttribute(aria_hiddenAttr), &quot;false&quot;);
1775     }) != nullptr;
1776 
1777     // The Accname specification states that if the current node is hidden, and not directly
1778     // referenced by aria-labelledby or aria-describedby, and is not a host language text
1779     // alternative, the empty string should be returned.
1780     if (isDOMHidden() &amp;&amp; !isAriaVisible &amp;&amp; !is&lt;HTMLLabelElement&gt;(node) &amp;&amp; (node &amp;&amp; !ancestorsOfType&lt;HTMLCanvasElement&gt;(*node).first())) {
1781         AccessibilityObject::AccessibilityChildrenVector labelFor;
1782         AccessibilityObject::AccessibilityChildrenVector descriptionFor;
1783         ariaLabelledByReferencingElements(labelFor);
1784         ariaDescribedByReferencingElements(descriptionFor);
1785         if (!labelFor.size() &amp;&amp; !descriptionFor.size())
1786             return String();
1787     }
1788 
1789     StringBuilder builder;
1790     for (AccessibilityObject* child = firstChild(); child; child = child-&gt;nextSibling()) {
1791         if (mode.ignoredChildNode &amp;&amp; child-&gt;node() == mode.ignoredChildNode)
1792             continue;
1793 
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityMenuListPopup.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityNodeObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h
@@ -28,10 +28,11 @@
 #include "ArrayBufferView.h"
 #include "DeferGC.h"
 #include "Error.h"
 #include "ExceptionHelpers.h"
 #include "JSArrayBuffer.h"
+#include "JSCellInlines.h"
 #include "JSGenericTypedArrayView.h"
 #include "TypeError.h"
 #include "TypedArrays.h"
 #include <wtf/text/StringConcatenateNumbers.h>
 
@@ -44,17 +45,17 @@
 {
 }
 
 template<typename Adaptor>
 JSGenericTypedArrayView<Adaptor>* JSGenericTypedArrayView<Adaptor>::create(
-    ExecState* exec, Structure* structure, unsigned length)
+    JSGlobalObject* globalObject, Structure* structure, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
     if (!context) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
     JSGenericTypedArrayView* result =
         new (NotNull, allocateCell<JSGenericTypedArrayView>(vm.heap))
         JSGenericTypedArrayView(vm, context);
@@ -62,32 +63,32 @@
     return result;
 }
 
 template<typename Adaptor>
 JSGenericTypedArrayView<Adaptor>* JSGenericTypedArrayView<Adaptor>::createWithFastVector(
-    ExecState* exec, Structure* structure, unsigned length, void* vector)
+    JSGlobalObject* globalObject, Structure* structure, unsigned length, void* vector)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     ConstructionContext context(structure, length, vector);
     RELEASE_ASSERT(context);
     JSGenericTypedArrayView* result =
         new (NotNull, allocateCell<JSGenericTypedArrayView>(vm.heap))
         JSGenericTypedArrayView(vm, context);
     result->finishCreation(vm);
     return result;
 }
 
 template<typename Adaptor>
-JSGenericTypedArrayView<Adaptor>* JSGenericTypedArrayView<Adaptor>::createUninitialized(ExecState* exec, Structure* structure, unsigned length)
+JSGenericTypedArrayView<Adaptor>* JSGenericTypedArrayView<Adaptor>::createUninitialized(JSGlobalObject* globalObject, Structure* structure, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ConstructionContext context(
         vm, structure, length, sizeof(typename Adaptor::Type),
         ConstructionContext::DontInitialize);
     if (!context) {
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         return nullptr;
     }
     JSGenericTypedArrayView* result =
         new (NotNull, allocateCell<JSGenericTypedArrayView>(vm.heap))
         JSGenericTypedArrayView(vm, context);
@@ -95,23 +96,23 @@
     return result;
 }
 
 template<typename Adaptor>
 JSGenericTypedArrayView<Adaptor>* JSGenericTypedArrayView<Adaptor>::create(
-    ExecState* exec, Structure* structure, RefPtr<ArrayBuffer>&& buffer,
+    JSGlobalObject* globalObject, Structure* structure, RefPtr<ArrayBuffer>&& buffer,
     unsigned byteOffset, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     size_t size = sizeof(typename Adaptor::Type);
     ASSERT(buffer);
     if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
-        throwException(exec, scope, createRangeError(exec, "Length out of range of buffer"));
+        throwException(globalObject, scope, createRangeError(globalObject, "Length out of range of buffer"));
         return nullptr;
     }
     if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
-        throwException(exec, scope, createRangeError(exec, "Byte offset is not aligned"));
+        throwException(globalObject, scope, createRangeError(globalObject, "Byte offset is not aligned"));
         return nullptr;
     }
     ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
     ASSERT(context);
     JSGenericTypedArrayView* result =
@@ -142,25 +143,25 @@
     return create(globalObject->vm(), structure, WTFMove(impl));
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::validateRange(
-    ExecState* exec, unsigned offset, unsigned length)
+    JSGlobalObject* globalObject, unsigned offset, unsigned length)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (canAccessRangeQuickly(offset, length))
         return true;
 
-    throwException(exec, scope, createRangeError(exec, "Range consisting of offset and length are out of bounds"));
+    throwException(globalObject, scope, createRangeError(globalObject, "Range consisting of offset and length are out of bounds"));
     return false;
 }
 
 template<typename Adaptor>
 template<typename OtherAdaptor>
 bool JSGenericTypedArrayView<Adaptor>::setWithSpecificType(
-    ExecState* exec, unsigned offset, JSGenericTypedArrayView<OtherAdaptor>* other,
+    JSGlobalObject* globalObject, unsigned offset, JSGenericTypedArrayView<OtherAdaptor>* other,
     unsigned otherOffset, unsigned length, CopyType type)
 {
     // Handle the hilarious case: the act of getting the length could have resulted
     // in neutering. Well, no. That'll never happen because there cannot be
     // side-effects on getting the length of a typed array. But predicting where there
@@ -168,11 +169,11 @@
     // check. Worst case, if we're wrong, people start seeing less things get copied
     // but we won't have a security vulnerability.
     length = std::min(length, other->length());
 
     RELEASE_ASSERT(other->canAccessRangeQuickly(otherOffset, length));
-    if (!validateRange(exec, offset, length))
+    if (!validateRange(globalObject, offset, length))
         return false;
 
     // This method doesn't support copying between the same array. Note that
     // set() will only call this if the types differ, which implicitly guarantees
     // that we can't be the same array. This is relevant because the way we detect
@@ -237,23 +238,23 @@
     return true;
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::set(
-    ExecState* exec, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)
+    JSGlobalObject* globalObject, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     const ClassInfo* ci = object->classInfo(vm);
     if (ci->typedArrayStorageType == Adaptor::typeValue) {
         // The super fast case: we can just memcpy since we're the same type.
         JSGenericTypedArrayView* other = jsCast<JSGenericTypedArrayView*>(object);
         length = std::min(length, other->length());
 
         RELEASE_ASSERT(other->canAccessRangeQuickly(objectOffset, length));
-        bool success = validateRange(exec, offset, length);
+        bool success = validateRange(globalObject, offset, length);
         EXCEPTION_ASSERT(!scope.exception() == success);
         if (!success)
             return false;
 
         memmove(typedVector() + offset, other->typedVector() + objectOffset, length * elementSize);
@@ -261,47 +262,47 @@
     }
 
     switch (ci->typedArrayStorageType) {
     case TypeInt8:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Int8Adaptor>(
-            exec, offset, jsCast<JSInt8Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSInt8Array*>(object), objectOffset, length, type));
     case TypeInt16:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Int16Adaptor>(
-            exec, offset, jsCast<JSInt16Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSInt16Array*>(object), objectOffset, length, type));
     case TypeInt32:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Int32Adaptor>(
-            exec, offset, jsCast<JSInt32Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSInt32Array*>(object), objectOffset, length, type));
     case TypeUint8:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Uint8Adaptor>(
-            exec, offset, jsCast<JSUint8Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSUint8Array*>(object), objectOffset, length, type));
     case TypeUint8Clamped:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Uint8ClampedAdaptor>(
-            exec, offset, jsCast<JSUint8ClampedArray*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSUint8ClampedArray*>(object), objectOffset, length, type));
     case TypeUint16:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Uint16Adaptor>(
-            exec, offset, jsCast<JSUint16Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSUint16Array*>(object), objectOffset, length, type));
     case TypeUint32:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Uint32Adaptor>(
-            exec, offset, jsCast<JSUint32Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSUint32Array*>(object), objectOffset, length, type));
     case TypeFloat32:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Float32Adaptor>(
-            exec, offset, jsCast<JSFloat32Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSFloat32Array*>(object), objectOffset, length, type));
     case TypeFloat64:
         RELEASE_AND_RETURN(scope, setWithSpecificType<Float64Adaptor>(
-            exec, offset, jsCast<JSFloat64Array*>(object), objectOffset, length, type));
+            globalObject, offset, jsCast<JSFloat64Array*>(object), objectOffset, length, type));
     case NotTypedArray:
     case TypeDataView: {
-        bool success = validateRange(exec, offset, length);
+        bool success = validateRange(globalObject, offset, length);
         EXCEPTION_ASSERT(!scope.exception() == success);
         if (!success)
             return false;
 
         // We could optimize this case. But right now, we don't.
         for (unsigned i = 0; i < length; ++i) {
-            JSValue value = object->get(exec, i + objectOffset);
+            JSValue value = object->get(globalObject, i + objectOffset);
             RETURN_IF_EXCEPTION(scope, false);
-            bool success = setIndex(exec, offset + i, value);
+            bool success = setIndex(globalObject, offset + i, value);
             EXCEPTION_ASSERT(!scope.exception() || !success);
             if (!success)
                 return false;
         }
         return true;
@@ -328,21 +329,21 @@
 {
     return existingBufferInButterfly();
 }
 
 template<typename Adaptor>
-EncodedJSValue JSGenericTypedArrayView<Adaptor>::throwNeuteredTypedArrayTypeError(ExecState* exec, EncodedJSValue object, PropertyName)
+EncodedJSValue JSGenericTypedArrayView<Adaptor>::throwNeuteredTypedArrayTypeError(JSGlobalObject* globalObject, EncodedJSValue object, PropertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     ASSERT_UNUSED(object, jsCast<JSGenericTypedArrayView*>(JSValue::decode(object))->isNeutered());
-    return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);
+    return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::getOwnPropertySlot(
-    JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot& slot)
+    JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot& slot)
 {
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(object);
 
     if (Optional<uint32_t> index = parseIndex(propertyName)) {
         if (thisObject->isNeutered()) {
@@ -365,51 +366,51 @@
         }
 
         return false;
     }
 
-    return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);
+    return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::put(
-    JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,
+    JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,
     PutPropertySlot& slot)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(cell);
 
     // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
     // Ignore the receiver even if the receiver is altered to non base value.
     // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
     if (Optional<uint32_t> index = parseIndex(propertyName))
-        RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));
+        RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));
 
     if (isCanonicalNumericIndexString(propertyName)) {
         if (thisObject->isNeutered())
-            throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);
+            throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
         return false;
     }
 
-    RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));
+    RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::defineOwnProperty(
-    JSObject* object, ExecState* exec, PropertyName propertyName,
+    JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName,
     const PropertyDescriptor& descriptor, bool shouldThrow)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(object);
 
     if (Optional<uint32_t> index = parseIndex(propertyName)) {
         auto throwTypeErrorIfNeeded = [&] (const char* errorMessage) -> bool {
             if (shouldThrow)
-                throwTypeError(exec, scope, makeString(errorMessage, *index));
+                throwTypeError(globalObject, scope, makeString(errorMessage, *index));
             return false;
         };
 
         if (index.value() >= thisObject->m_length)
             return false;
@@ -422,41 +423,41 @@
 
         if (!descriptor.enumerable() || !descriptor.writable())
             return throwTypeErrorIfNeeded("Attempting to store non-enumerable or non-writable property on a typed array at index: ");
 
         if (descriptor.value())
-            RELEASE_AND_RETURN(scope, thisObject->putByIndex(thisObject, exec, index.value(), descriptor.value(), shouldThrow));
+            RELEASE_AND_RETURN(scope, thisObject->putByIndex(thisObject, globalObject, index.value(), descriptor.value(), shouldThrow));
 
         return true;
     }
 
     if (isCanonicalNumericIndexString(propertyName))
         return false;
 
-    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow));
+    RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow));
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::deleteProperty(
-    JSCell* cell, ExecState* exec, PropertyName propertyName)
+    JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(cell);
 
     if (thisObject->isNeutered())
-        return typeError(exec, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);
+        return typeError(globalObject, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);
 
     if (parseIndex(propertyName))
         return false;
 
-    return Base::deleteProperty(thisObject, exec, propertyName);
+    return Base::deleteProperty(thisObject, globalObject, propertyName);
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::getOwnPropertySlotByIndex(
-    JSObject* object, ExecState*, unsigned propertyName, PropertySlot& slot)
+    JSObject* object, JSGlobalObject*, unsigned propertyName, PropertySlot& slot)
 {
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(object);
 
     if (thisObject->isNeutered()) {
         slot.setCustom(thisObject, static_cast<unsigned>(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
@@ -470,37 +471,37 @@
     return true;
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::putByIndex(
-    JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool)
+    JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool)
 {
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(cell);
-    return thisObject->setIndex(exec, propertyName, value);
+    return thisObject->setIndex(globalObject, propertyName, value);
 }
 
 template<typename Adaptor>
 bool JSGenericTypedArrayView<Adaptor>::deletePropertyByIndex(
-    JSCell* cell, ExecState* exec, unsigned propertyName)
+    JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)
 {
-    VM& vm = exec->vm();
-    return cell->methodTable(vm)->deleteProperty(cell, exec, Identifier::from(vm, propertyName));
+    VM& vm = globalObject->vm();
+    return cell->methodTable(vm)->deleteProperty(cell, globalObject, Identifier::from(vm, propertyName));
 }
 
 template<typename Adaptor>
 void JSGenericTypedArrayView<Adaptor>::getOwnPropertyNames(
-    JSObject* object, ExecState* exec, PropertyNameArray& array, EnumerationMode mode)
+    JSObject* object, JSGlobalObject* globalObject, PropertyNameArray& array, EnumerationMode mode)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSGenericTypedArrayView* thisObject = jsCast<JSGenericTypedArrayView*>(object);
 
     if (array.includeStringProperties()) {
         for (unsigned i = 0; i < thisObject->m_length; ++i)
             array.add(Identifier::from(vm, i));
     }
 
-    return Base::getOwnPropertyNames(object, exec, array, mode);
+    return Base::getOwnPropertyNames(object, globalObject, array, mode);
 }
 
 template<typename Adaptor>
 size_t JSGenericTypedArrayView<Adaptor>::estimatedSize(JSCell* cell, VM& vm)
 {

diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/SlotAssignment.cpp
@@ -46,20 +46,20 @@
         return SlotAssignment::defaultSlotName();
 
     return slotNameFromAttributeValue(downcast<Element>(child).attributeWithoutSynchronization(slotAttr));
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 static HTMLSlotElement* findSlotElement(ShadowRoot& shadowRoot, const AtomString& slotName)
 {
     for (auto& slotElement : descendantsOfType<HTMLSlotElement>(shadowRoot)) {
         if (slotNameFromAttributeValue(slotElement.attributeWithoutSynchronization(nameAttr)) == slotName)
             return &slotElement;
     }
     return nullptr;
 }
-#endif
+#endif // ASSERT_ENABLED
 
 static HTMLSlotElement* nextSlotElementSkippingSubtree(ContainerNode& startingNode, ContainerNode* skippedSubtree)
 {
     Node* node = &startingNode;
     do {
@@ -104,24 +104,21 @@
     addSlotElementByName(newName, slotElement, shadowRoot);
 }
 
 void SlotAssignment::addSlotElementByName(const AtomString& name, HTMLSlotElement& slotElement, ShadowRoot& shadowRoot)
 {
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     ASSERT(!m_slotElementsForConsistencyCheck.contains(&slotElement));
     m_slotElementsForConsistencyCheck.add(&slotElement);
 #endif
 
     // FIXME: We should be able to do a targeted reconstruction.
     shadowRoot.host()->invalidateStyleAndRenderersForSubtree();
 
     auto& slotName = slotNameFromAttributeValue(name);
     auto addResult = m_slots.ensure(slotName, [&] {
-        // Unlike named slots, assignSlots doesn't collect nodes assigned to the default slot
-        // to avoid always having a vector of all child nodes of a shadow host.
-        if (slotName == defaultSlotName())
-            m_slotAssignmentsIsValid = false;
+        m_slotAssignmentsIsValid = false;
         return makeUnique<Slot>();
     });
     auto& slot = *addResult.iterator->value;
     bool needsSlotchangeEvent = shadowRoot.shouldFireSlotchangeEvent() && hasAssignedNodes(shadowRoot, slot);
 
@@ -143,11 +140,11 @@
     resolveSlotsAfterSlotMutation(shadowRoot, SlotMutationType::Insertion);
 }
 
 void SlotAssignment::removeSlotElementByName(const AtomString& name, HTMLSlotElement& slotElement, ContainerNode* oldParentOfRemovedTreeForRemoval, ShadowRoot& shadowRoot)
 {
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     ASSERT(m_slotElementsForConsistencyCheck.contains(&slotElement));
     m_slotElementsForConsistencyCheck.remove(&slotElement);
 #endif
 
     if (auto* host = shadowRoot.host()) // FIXME: We should be able to do a targeted reconstruction.
@@ -236,11 +233,11 @@
         return;
 
     if (mutationType == SlotMutationType::Insertion) {
         // This code path is taken only when continue above for !currentSlot is taken.
         // i.e. there is a new slot being inserted into the tree but we have yet to invoke addSlotElementByName on it.
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
         for (auto& entry : m_slots)
             ASSERT(entry.value->seenFirstElement || !findSlotElement(shadowRoot, entry.key));
 #endif
         return;
     }
@@ -342,14 +339,12 @@
 HTMLSlotElement* SlotAssignment::findFirstSlotElement(Slot& slot, ShadowRoot& shadowRoot)
 {
     if (slot.shouldResolveSlotElement())
         resolveAllSlotElements(shadowRoot);
 
-#ifndef NDEBUG
     ASSERT(!slot.element || m_slotElementsForConsistencyCheck.contains(slot.element.get()));
     ASSERT(!!slot.element == !!slot.elementCount);
-#endif
 
     return slot.element.get();
 }
 
 void SlotAssignment::resolveAllSlotElements(ShadowRoot& shadowRoot)

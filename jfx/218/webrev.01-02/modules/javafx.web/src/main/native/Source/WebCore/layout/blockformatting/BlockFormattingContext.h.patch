diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.h b/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContext.h
@@ -26,11 +26,10 @@
 #pragma once
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
 #include "FormattingContext.h"
-#include "MarginTypes.h"
 #include <wtf/HashMap.h>
 #include <wtf/IsoMalloc.h>
 
 namespace WebCore {
 
@@ -42,110 +41,156 @@
 class Box;
 class FloatingContext;
 
 // This class implements the layout logic for block formatting contexts.
 // https://www.w3.org/TR/CSS22/visuren.html#block-formatting
-class BlockFormattingContext : public FormattingContext {
+class BlockFormattingContext final : public FormattingContext {
     WTF_MAKE_ISO_ALLOCATED(BlockFormattingContext);
 public:
-    BlockFormattingContext(const Box& formattingContextRoot, BlockFormattingState&);
+    BlockFormattingContext(const Container& formattingContextRoot, BlockFormattingState&);
 
-    void layout() const override;
+    void layoutInFlowContent(InvalidationState&, const HorizontalConstraints&, const VerticalConstraints&) override;
 
 private:
-    void layoutFormattingContextRoot(FloatingContext&, const Box&) const;
-    void placeInFlowPositionedChildren(const Box&) const;
 
-    void computeWidthAndMargin(const Box&, Optional<LayoutUnit> usedAvailableWidth = { }) const;
-    void computeHeightAndMargin(const Box&) const;
+    template<typename T>
+    struct ConstraintsPair {
+        const T root;
+        const T containingBlock;
+    };
+    void placeInFlowPositionedChildren(const Box&, const ConstraintsPair<HorizontalConstraints>&);
+
+    void computeWidthAndMargin(const FloatingContext&, const Box&, const ConstraintsPair<HorizontalConstraints>&);
+    void computeHeightAndMargin(const Box&, const ConstraintsPair<HorizontalConstraints>&, const ConstraintsPair<VerticalConstraints>&);
 
-    void computeStaticHorizontalPosition(const Box&) const;
-    void computeStaticVerticalPosition(const FloatingContext&, const Box&) const;
-    void computeStaticPosition(const FloatingContext&, const Box&) const;
-    void computeFloatingPosition(const FloatingContext&, const Box&) const;
-    void computePositionToAvoidFloats(const FloatingContext&, const Box&) const;
+    void computeStaticHorizontalPosition(const Box&, const ConstraintsPair<HorizontalConstraints>&);
+    void computeStaticVerticalPosition(const Box&, const ConstraintsPair<VerticalConstraints>&);
+    void computePositionToAvoidFloats(const FloatingContext&, const Box&, const ConstraintsPair<HorizontalConstraints>&, const ConstraintsPair<VerticalConstraints>&);
+    void computeVerticalPositionForFloatClear(const FloatingContext&, const Box&);
 
-    void computeEstimatedVerticalPosition(const Box&) const;
-    void computeEstimatedVerticalPositionForAncestors(const Box&) const;
-    void computeEstimatedVerticalPositionForFormattingRoot(const Box&) const;
-    void computeEstimatedVerticalPositionForFloatClear(const FloatingContext&, const Box&) const;
+    void precomputeVerticalPosition(const Box&, const HorizontalConstraints&, const VerticalConstraints&);
+    void precomputeVerticalPositionForAncestors(const Box&, const ConstraintsPair<HorizontalConstraints>&, const ConstraintsPair<VerticalConstraints>&);
+    void precomputeVerticalPositionForFormattingRoot(const FloatingContext&, const Box&, const ConstraintsPair<HorizontalConstraints>&, const ConstraintsPair<VerticalConstraints>&);
 
-    IntrinsicWidthConstraints computedIntrinsicWidthConstraints() const override;
-    LayoutUnit verticalPositionWithMargin(const Box&, const UsedVerticalMargin&) const;
+    IntrinsicWidthConstraints computedIntrinsicWidthConstraints() override;
+    LayoutUnit verticalPositionWithMargin(const Box&, const UsedVerticalMargin&, const VerticalConstraints&) const;
 
     // This class implements positioning and sizing for boxes participating in a block formatting context.
     class Geometry : public FormattingContext::Geometry {
     public:
-        static HeightAndMargin inFlowHeightAndMargin(const LayoutState&, const Box&, UsedVerticalValues);
-        static WidthAndMargin inFlowWidthAndMargin(LayoutState&, const Box&, UsedHorizontalValues);
+        ContentHeightAndMargin inFlowHeightAndMargin(const Box&, const HorizontalConstraints&, const OverrideVerticalValues&);
+        ContentWidthAndMargin inFlowWidthAndMargin(const Box&, const HorizontalConstraints&, const OverrideHorizontalValues&);
 
-        static Point staticPosition(const LayoutState&, const Box&);
-        static LayoutUnit staticVerticalPosition(const LayoutState&, const Box&);
-        static LayoutUnit staticHorizontalPosition(const LayoutState&, const Box&);
+        Point staticPosition(const Box&, const HorizontalConstraints&, const VerticalConstraints&) const;
+        LayoutUnit staticVerticalPosition(const Box&, const VerticalConstraints&) const;
+        LayoutUnit staticHorizontalPosition(const Box&, const HorizontalConstraints&) const;
 
-        static IntrinsicWidthConstraints intrinsicWidthConstraints(LayoutState&, const Box&);
+        IntrinsicWidthConstraints intrinsicWidthConstraints(const Box&);
 
     private:
-        static HeightAndMargin inFlowNonReplacedHeightAndMargin(const LayoutState&, const Box&, UsedVerticalValues);
-        static WidthAndMargin inFlowNonReplacedWidthAndMargin(const LayoutState&, const Box&, UsedHorizontalValues);
-        static WidthAndMargin inFlowReplacedWidthAndMargin(const LayoutState&, const Box&, UsedHorizontalValues);
-        static Point staticPositionForOutOfFlowPositioned(const LayoutState&, const Box&);
+        friend class BlockFormattingContext;
+        Geometry(const BlockFormattingContext&);
+
+        ContentHeightAndMargin inFlowNonReplacedHeightAndMargin(const Box&, const HorizontalConstraints&, const OverrideVerticalValues&);
+        ContentWidthAndMargin inFlowNonReplacedWidthAndMargin(const Box&, const HorizontalConstraints&, const OverrideHorizontalValues&) const;
+        ContentWidthAndMargin inFlowReplacedWidthAndMargin(const Box&, const HorizontalConstraints&, const OverrideHorizontalValues&) const;
+        Point staticPositionForOutOfFlowPositioned(const Box&) const;
+
+        const BlockFormattingContext& formattingContext() const { return downcast<BlockFormattingContext>(FormattingContext::Geometry::formattingContext()); }
     };
+    BlockFormattingContext::Geometry geometry() const { return Geometry(*this); }
 
     // This class implements margin collapsing for block formatting context.
     class MarginCollapse {
     public:
-        static UsedVerticalMargin::CollapsedValues collapsedVerticalValues(const LayoutState&, const Box&, const UsedVerticalMargin::NonCollapsedValues&);
+        UsedVerticalMargin::CollapsedValues collapsedVerticalValues(const Box&, UsedVerticalMargin::NonCollapsedValues);
 
-        static EstimatedMarginBefore estimatedMarginBefore(const LayoutState&, const Box&);
-        static LayoutUnit marginBeforeIgnoringCollapsingThrough(const LayoutState&, const Box&, const UsedVerticalMargin::NonCollapsedValues&);
-        static void updateMarginAfterForPreviousSibling(const LayoutState&, const Box&);
-        static void updatePositiveNegativeMarginValues(const LayoutState&, const Box&);
+        PrecomputedMarginBefore precomputedMarginBefore(const Box&, UsedVerticalMargin::NonCollapsedValues);
+        LayoutUnit marginBeforeIgnoringCollapsingThrough(const Box&, UsedVerticalMargin::NonCollapsedValues);
+        static void updateMarginAfterForPreviousSibling(BlockFormattingContext&, const MarginCollapse&, const Box&);
+        PositiveAndNegativeVerticalMargin resolvedPositiveNegativeMarginValues(const Box&, const UsedVerticalMargin::NonCollapsedValues&);
 
-        static bool marginBeforeCollapsesWithParentMarginBefore(const LayoutState&, const Box&);
-        static bool marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const LayoutState&, const Box&);
-        static bool marginBeforeCollapsesWithParentMarginAfter(const LayoutState&, const Box&);
-        static bool marginBeforeCollapsesWithPreviousSiblingMarginAfter(const LayoutState&, const Box&);
+        bool marginBeforeCollapsesWithParentMarginBefore(const Box&) const;
+        bool marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const Box&) const;
+        bool marginBeforeCollapsesWithParentMarginAfter(const Box&) const;
+        bool marginBeforeCollapsesWithPreviousSiblingMarginAfter(const Box&) const;
 
-        static bool marginAfterCollapsesWithParentMarginAfter(const LayoutState&, const Box&);
-        static bool marginAfterCollapsesWithLastInFlowChildMarginAfter(const LayoutState&, const Box&);
-        static bool marginAfterCollapsesWithParentMarginBefore(const LayoutState&, const Box&);
-        static bool marginAfterCollapsesWithNextSiblingMarginBefore(const LayoutState&, const Box&);
-        static bool marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const LayoutState&, const Box&);
+        bool marginAfterCollapsesWithParentMarginAfter(const Box&) const;
+        bool marginAfterCollapsesWithLastInFlowChildMarginAfter(const Box&) const;
+        bool marginAfterCollapsesWithParentMarginBefore(const Box&) const;
+        bool marginAfterCollapsesWithNextSiblingMarginBefore(const Box&) const;
+        bool marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const Box&) const;
 
-        static bool marginsCollapseThrough(const LayoutState&, const Box&);
+        bool marginsCollapseThrough(const Box&) const;
 
     private:
+        friend class BlockFormattingContext;
+        MarginCollapse(const BlockFormattingContext&);
+
         enum class MarginType { Before, After };
-        static PositiveAndNegativeVerticalMargin::Values positiveNegativeValues(const LayoutState&, const Box&, MarginType);
-        static PositiveAndNegativeVerticalMargin::Values positiveNegativeMarginBefore(const LayoutState&, const Box&, const UsedVerticalMargin::NonCollapsedValues&);
-        static PositiveAndNegativeVerticalMargin::Values positiveNegativeMarginAfter(const LayoutState&, const Box&, const UsedVerticalMargin::NonCollapsedValues&);
+        PositiveAndNegativeVerticalMargin::Values positiveNegativeValues(const Box&, MarginType) const;
+        PositiveAndNegativeVerticalMargin::Values positiveNegativeMarginBefore(const Box&, UsedVerticalMargin::NonCollapsedValues) const;
+        PositiveAndNegativeVerticalMargin::Values positiveNegativeMarginAfter(const Box&, UsedVerticalMargin::NonCollapsedValues) const;
+        bool hasClearance(const Box&) const;
+
+        LayoutState& layoutState() { return m_blockFormattingContext.layoutState(); }
+        const LayoutState& layoutState() const { return m_blockFormattingContext.layoutState(); }
+        const BlockFormattingContext& formattingContext() const { return m_blockFormattingContext; }
+
+        const BlockFormattingContext& m_blockFormattingContext;
     };
+    MarginCollapse marginCollapse() const { return MarginCollapse(*this); }
 
-    class Quirks {
+    class Quirks : public FormattingContext::Quirks {
     public:
-        static bool needsStretching(const LayoutState&, const Box&);
-        static HeightAndMargin stretchedInFlowHeight(const LayoutState&, const Box&, HeightAndMargin);
+        bool needsStretching(const Box&) const;
+        ContentHeightAndMargin stretchedInFlowHeight(const Box&, ContentHeightAndMargin);
+
+        bool shouldIgnoreCollapsedQuirkMargin(const Box&) const;
+        bool shouldIgnoreMarginBefore(const Box&) const;
+        bool shouldIgnoreMarginAfter(const Box&) const;
+
+    private:
+        friend class BlockFormattingContext;
+        Quirks(const BlockFormattingContext&);
+
+        const BlockFormattingContext& formattingContext() const { return downcast<BlockFormattingContext>(FormattingContext::Quirks::formattingContext()); }
 
-        static bool shouldIgnoreCollapsedQuirkMargin(const LayoutState&, const Box&);
-        static bool shouldIgnoreMarginBefore(const LayoutState&, const Box&);
-        static bool shouldIgnoreMarginAfter(const LayoutState&, const Box&);
     };
+    BlockFormattingContext::Quirks quirks() const { return Quirks(*this); }
 
-    void setEstimatedMarginBefore(const Box&, const EstimatedMarginBefore&) const;
-    void removeEstimatedMarginBefore(const Box& layoutBox) const { m_estimatedMarginBeforeList.remove(&layoutBox); }
-    bool hasEstimatedMarginBefore(const Box&) const;
-    Optional<LayoutUnit> usedAvailableWidthForFloatAvoider(const FloatingContext&, const Box&) const;
-#ifndef NDEBUG
-    EstimatedMarginBefore estimatedMarginBefore(const Box& layoutBox) const { return m_estimatedMarginBeforeList.get(&layoutBox); }
+    void setPrecomputedMarginBefore(const Box&, const PrecomputedMarginBefore&);
+    void removePrecomputedMarginBefore(const Box& layoutBox) { m_precomputedMarginBeforeList.remove(&layoutBox); }
     bool hasPrecomputedMarginBefore(const Box&) const;
+    Optional<LayoutUnit> usedAvailableWidthForFloatAvoider(const FloatingContext&, const Box&) const;
+#if ASSERT_ENABLED
+    PrecomputedMarginBefore precomputedMarginBefore(const Box& layoutBox) const { return m_precomputedMarginBeforeList.get(&layoutBox); }
 #endif
 
-    BlockFormattingState& formattingState() const { return downcast<BlockFormattingState>(FormattingContext::formattingState()); }
+    const BlockFormattingState& formattingState() const { return downcast<BlockFormattingState>(FormattingContext::formattingState()); }
+    BlockFormattingState& formattingState() { return downcast<BlockFormattingState>(FormattingContext::formattingState()); }
 
 private:
-    mutable HashMap<const Box*, EstimatedMarginBefore> m_estimatedMarginBeforeList;
+    HashMap<const Box*, PrecomputedMarginBefore> m_precomputedMarginBeforeList;
 };
 
+inline BlockFormattingContext::Geometry::Geometry(const BlockFormattingContext& blockFormattingContext)
+    : FormattingContext::Geometry(blockFormattingContext)
+{
+}
+
+inline BlockFormattingContext::Quirks::Quirks(const BlockFormattingContext& blockFormattingContext)
+    : FormattingContext::Quirks(blockFormattingContext)
+{
+}
+
+inline BlockFormattingContext::MarginCollapse::MarginCollapse(const BlockFormattingContext& blockFormattingContext)
+    : m_blockFormattingContext(blockFormattingContext)
+{
+}
+
 }
 }
+
+SPECIALIZE_TYPE_TRAITS_LAYOUT_FORMATTING_CONTEXT(BlockFormattingContext, isBlockFormattingContext())
+
 #endif

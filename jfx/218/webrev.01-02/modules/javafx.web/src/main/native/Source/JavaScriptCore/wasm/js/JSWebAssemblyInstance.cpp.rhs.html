<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyInstance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSWebAssemblyInstance.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;AbstractModuleRecord.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;JSModuleEnvironment.h&quot;
 34 #include &quot;JSModuleNamespaceObject.h&quot;
 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyLinkError.h&quot;
 37 #include &quot;JSWebAssemblyMemory.h&quot;
 38 #include &quot;JSWebAssemblyModule.h&quot;
 39 #include &quot;WebAssemblyModuleRecord.h&quot;
<a name="1" id="anc1"></a>
 40 #include &lt;wtf/StdLibExtras.h&gt;
 41 
 42 namespace JSC {
 43 
 44 const ClassInfo JSWebAssemblyInstance::s_info = { &quot;WebAssembly.Instance&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebAssemblyInstance) };
 45 
 46 Structure* JSWebAssemblyInstance::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 47 {
 48     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 49 }
 50 
 51 JSWebAssemblyInstance::JSWebAssemblyInstance(VM&amp; vm, Structure* structure, Ref&lt;Wasm::Instance&gt;&amp;&amp; instance)
 52     : Base(vm, structure)
 53     , m_instance(WTFMove(instance))
 54     , m_vm(&amp;vm)
<a name="2" id="anc2"></a><span class="line-added"> 55     , m_globalObject(vm, this, structure-&gt;globalObject())</span>
 56     , m_tables(m_instance-&gt;module().moduleInformation().tableCount())
 57 {
 58     for (unsigned i = 0; i &lt; this-&gt;instance().numImportFunctions(); ++i)
 59         new (this-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(i)) WriteBarrier&lt;JSObject&gt;();
 60 }
 61 
 62 void JSWebAssemblyInstance::finishCreation(VM&amp; vm, JSWebAssemblyModule* module, JSModuleNamespaceObject* moduleNamespaceObject)
 63 {
 64     Base::finishCreation(vm);
 65     ASSERT(inherits(vm, info()));
 66 
 67     m_module.set(vm, this, module);
 68     m_moduleNamespaceObject.set(vm, this, moduleNamespaceObject);
<a name="3" id="anc3"></a>
 69 
 70     vm.heap.reportExtraMemoryAllocated(m_instance-&gt;extraMemoryAllocated());
 71 }
 72 
 73 void JSWebAssemblyInstance::destroy(JSCell* cell)
 74 {
 75     static_cast&lt;JSWebAssemblyInstance*&gt;(cell)-&gt;JSWebAssemblyInstance::~JSWebAssemblyInstance();
 76 }
 77 
 78 void JSWebAssemblyInstance::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 79 {
 80     auto* thisObject = jsCast&lt;JSWebAssemblyInstance*&gt;(cell);
 81     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 82 
 83     Base::visitChildren(thisObject, visitor);
 84     visitor.append(thisObject-&gt;m_module);
 85     visitor.append(thisObject-&gt;m_codeBlock);
 86     visitor.append(thisObject-&gt;m_moduleNamespaceObject);
 87     visitor.append(thisObject-&gt;m_memory);
 88     for (unsigned i = 0; i &lt; thisObject-&gt;instance().module().moduleInformation().tableCount(); ++i)
 89         visitor.append(thisObject-&gt;m_tables[i]);
<a name="4" id="anc4"></a>
 90     visitor.reportExtraMemoryVisited(thisObject-&gt;m_instance-&gt;extraMemoryAllocated());
 91     for (unsigned i = 0; i &lt; thisObject-&gt;instance().numImportFunctions(); ++i)
 92         visitor.append(*thisObject-&gt;instance().importFunction&lt;WriteBarrier&lt;JSObject&gt;&gt;(i)); // This also keeps the functions&#39; JSWebAssemblyInstance alive.
 93 
<a name="5" id="anc5"></a><span class="line-added"> 94     for (size_t i : thisObject-&gt;instance().globalsToBinding()) {</span>
<span class="line-added"> 95         Wasm::Global* binding = thisObject-&gt;instance().getGlobalBinding(i);</span>
<span class="line-added"> 96         if (binding)</span>
<span class="line-added"> 97             visitor.appendUnbarriered(binding-&gt;owner&lt;JSWebAssemblyGlobal&gt;());</span>
<span class="line-added"> 98     }</span>
 99     for (size_t i : thisObject-&gt;instance().globalsToMark())
100         visitor.appendUnbarriered(JSValue::decode(thisObject-&gt;instance().loadI64Global(i)));
101 
102     auto locker = holdLock(cell-&gt;cellLock());
103     for (auto&amp; wrapper : thisObject-&gt;instance().functionWrappers())
104         visitor.appendUnbarriered(wrapper.get());
105 }
106 
<a name="6" id="anc6"></a><span class="line-modified">107 void JSWebAssemblyInstance::finalizeCreation(VM&amp; vm, JSGlobalObject* globalObject, Ref&lt;Wasm::CodeBlock&gt;&amp;&amp; wasmCodeBlock, JSObject* importObject, Wasm::CreationMode creationMode)</span>
108 {
109     m_instance-&gt;finalizeCreation(this, wasmCodeBlock.copyRef());
110 
111     auto scope = DECLARE_THROW_SCOPE(vm);
112 
113     if (!wasmCodeBlock-&gt;runnable()) {
<a name="7" id="anc7"></a><span class="line-modified">114         throwException(globalObject, scope, JSWebAssemblyLinkError::create(globalObject, vm, this-&gt;globalObject()-&gt;webAssemblyLinkErrorStructure(), wasmCodeBlock-&gt;errorMessage()));</span>
115         return;
116     }
117 
118     RELEASE_ASSERT(wasmCodeBlock-&gt;isSafeToRun(memoryMode()));
119     JSWebAssemblyCodeBlock* jsCodeBlock = m_module-&gt;codeBlock(memoryMode());
120     if (jsCodeBlock) {
121         // A CodeBlock might have already been compiled. If so, it means
122         // that the CodeBlock we are trying to compile must be the same
123         // because we will never compile a CodeBlock again once it&#39;s
124         // runnable.
125         ASSERT(&amp;jsCodeBlock-&gt;codeBlock() == wasmCodeBlock.ptr());
126         m_codeBlock.set(vm, this, jsCodeBlock);
127     } else {
128         jsCodeBlock = JSWebAssemblyCodeBlock::create(vm, WTFMove(wasmCodeBlock), module()-&gt;module().moduleInformation());
129         if (UNLIKELY(!jsCodeBlock-&gt;runnable())) {
<a name="8" id="anc8"></a><span class="line-modified">130             throwException(globalObject, scope, JSWebAssemblyLinkError::create(globalObject, vm, this-&gt;globalObject()-&gt;webAssemblyLinkErrorStructure(), jsCodeBlock-&gt;errorMessage()));</span>
131             return;
132         }
133         m_codeBlock.set(vm, this, jsCodeBlock);
134         m_module-&gt;setCodeBlock(vm, memoryMode(), jsCodeBlock);
135     }
136 
137     for (unsigned importFunctionNum = 0; importFunctionNum &lt; instance().numImportFunctions(); ++importFunctionNum) {
138         auto* info = instance().importFunctionInfo(importFunctionNum);
139         info-&gt;wasmToEmbedderStub = m_codeBlock-&gt;wasmToEmbedderStub(importFunctionNum);
140     }
141 
142     auto* moduleRecord = jsCast&lt;WebAssemblyModuleRecord*&gt;(m_moduleNamespaceObject-&gt;moduleRecord());
143     moduleRecord-&gt;prepareLink(vm, this);
144 
145     if (creationMode == Wasm::CreationMode::FromJS) {
<a name="9" id="anc9"></a><span class="line-modified">146         moduleRecord-&gt;link(globalObject, jsNull(), importObject, creationMode);</span>
147         RETURN_IF_EXCEPTION(scope, void());
148 
<a name="10" id="anc10"></a><span class="line-modified">149         JSValue startResult = moduleRecord-&gt;evaluate(globalObject);</span>
150         UNUSED_PARAM(startResult);
151         RETURN_IF_EXCEPTION(scope, void());
152     }
153 }
154 
155 Identifier JSWebAssemblyInstance::createPrivateModuleKey()
156 {
157     return Identifier::fromUid(PrivateName(PrivateName::Description, &quot;WebAssemblyInstance&quot;));
158 }
159 
<a name="11" id="anc11"></a><span class="line-modified">160 JSWebAssemblyInstance* JSWebAssemblyInstance::tryCreate(VM&amp; vm, JSGlobalObject* globalObject, const Identifier&amp; moduleKey, JSWebAssemblyModule* jsModule, JSObject* importObject, Structure* instanceStructure, Ref&lt;Wasm::Module&gt;&amp;&amp; module, Wasm::CreationMode creationMode)</span>
161 {
162     auto throwScope = DECLARE_THROW_SCOPE(vm);
<a name="12" id="anc12"></a>
163 
164     const Wasm::ModuleInformation&amp; moduleInformation = jsModule-&gt;moduleInformation();
165 
166     auto exception = [&amp;] (JSObject* error) {
<a name="13" id="anc13"></a><span class="line-modified">167         throwException(globalObject, throwScope, error);</span>
168         return nullptr;
169     };
170 
171     if (!globalObject-&gt;webAssemblyEnabled())
<a name="14" id="anc14"></a><span class="line-modified">172         return exception(createEvalError(globalObject, globalObject-&gt;webAssemblyDisabledErrorMessage()));</span>
173 
174     auto importFailMessage = [&amp;] (const Wasm::Import&amp; import, const char* before, const char* after) {
175         return makeString(before, &quot; &quot;, String::fromUTF8(import.module), &quot;:&quot;, String::fromUTF8(import.field), &quot; &quot;, after);
176     };
177 
<a name="15" id="anc15"></a><span class="line-modified">178     WebAssemblyModuleRecord* moduleRecord = WebAssemblyModuleRecord::create(globalObject, vm, globalObject-&gt;webAssemblyModuleRecordStructure(), moduleKey, moduleInformation);</span>
179     RETURN_IF_EXCEPTION(throwScope, nullptr);
180 
<a name="16" id="anc16"></a><span class="line-modified">181     JSModuleNamespaceObject* moduleNamespace = moduleRecord-&gt;getModuleNamespace(globalObject);</span>
182 
183     auto storeTopCallFrame = [&amp;vm] (void* topCallFrame) {
<a name="17" id="anc17"></a><span class="line-modified">184         vm.topCallFrame = bitwise_cast&lt;CallFrame*&gt;(topCallFrame);</span>
185     };
186 
187     // FIXME: These objects could be pretty big we should try to throw OOM here.
188     auto* jsInstance = new (NotNull, allocateCell&lt;JSWebAssemblyInstance&gt;(vm.heap)) JSWebAssemblyInstance(vm, instanceStructure,
189         Wasm::Instance::create(&amp;vm.wasmContext, WTFMove(module), &amp;vm.topEntryFrame, vm.addressOfSoftStackLimit(), WTFMove(storeTopCallFrame)));
190     jsInstance-&gt;finishCreation(vm, jsModule, moduleNamespace);
191     RETURN_IF_EXCEPTION(throwScope, nullptr);
192 
193     // Let funcs, memories and tables be initially-empty lists of callable JavaScript objects, WebAssembly.Memory objects and WebAssembly.Table objects, respectively.
194     // Let imports be an initially-empty list of external values.
195     bool hasMemoryImport = false;
196 
197     if (creationMode == Wasm::CreationMode::FromJS) {
198         // If the list of module.imports is not empty and Type(importObject) is not Object, a TypeError is thrown.
199         if (moduleInformation.imports.size() &amp;&amp; !importObject)
<a name="18" id="anc18"></a><span class="line-modified">200             return exception(createTypeError(globalObject, &quot;can&#39;t make WebAssembly.Instance because there is no imports Object and the WebAssembly.Module requires imports&quot;_s));</span>
201     }
202 
203     // For each import i in module.imports:
204     for (auto&amp; import : moduleInformation.imports) {
205         Identifier moduleName = Identifier::fromString(vm, String::fromUTF8(import.module));
206         Identifier fieldName = Identifier::fromString(vm, String::fromUTF8(import.field));
207         moduleRecord-&gt;appendRequestedModule(moduleName);
208         moduleRecord-&gt;addImportEntry(WebAssemblyModuleRecord::ImportEntry {
209             WebAssemblyModuleRecord::ImportEntryType::Single,
210             moduleName,
211             fieldName,
212             Identifier::fromUid(PrivateName(PrivateName::Description, &quot;WebAssemblyImportName&quot;)),
213         });
214 
215         // Skip Wasm::ExternalKind::Function validation here. It will be done in WebAssemblyModuleRecord::link.
216         // Eventually we will move all the linking code here to WebAssemblyModuleRecord::link.
217         switch (import.kind) {
218         case Wasm::ExternalKind::Function:
219         case Wasm::ExternalKind::Global:
220         case Wasm::ExternalKind::Table:
221             continue;
222         case Wasm::ExternalKind::Memory:
223             break;
224         }
225 
226         JSValue value;
227         if (creationMode == Wasm::CreationMode::FromJS) {
228             // 1. Let o be the resultant value of performing Get(importObject, i.module_name).
<a name="19" id="anc19"></a><span class="line-modified">229             JSValue importModuleValue = importObject-&gt;get(globalObject, moduleName);</span>
230             RETURN_IF_EXCEPTION(throwScope, nullptr);
231             // 2. If Type(o) is not Object, throw a TypeError.
232             if (!importModuleValue.isObject())
<a name="20" id="anc20"></a><span class="line-modified">233                 return exception(createTypeError(globalObject, importFailMessage(import, &quot;import&quot;, &quot;must be an object&quot;), defaultSourceAppender, runtimeTypeForValue(vm, importModuleValue)));</span>
234 
235             // 3. Let v be the value of performing Get(o, i.item_name)
236             JSObject* object = jsCast&lt;JSObject*&gt;(importModuleValue);
<a name="21" id="anc21"></a><span class="line-modified">237             value = object-&gt;get(globalObject, fieldName);</span>
238             RETURN_IF_EXCEPTION(throwScope, nullptr);
239         }
240         if (!value)
241             value = jsUndefined();
242 
243         switch (import.kind) {
244         case Wasm::ExternalKind::Function:
245         case Wasm::ExternalKind::Global:
246         case Wasm::ExternalKind::Table:
247             break;
248 
249         case Wasm::ExternalKind::Memory: {
250             // 6. If i is a memory import:
251             RELEASE_ASSERT(!hasMemoryImport); // This should be guaranteed by a validation failure.
252             RELEASE_ASSERT(moduleInformation.memory);
253             hasMemoryImport = true;
254             JSWebAssemblyMemory* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, value);
255             // i. If v is not a WebAssembly.Memory object, throw a WebAssembly.LinkError.
256             if (!memory)
<a name="22" id="anc22"></a><span class="line-modified">257                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;is not an instance of WebAssembly.Memory&quot;)));</span>
258 
259             Wasm::PageCount declaredInitial = moduleInformation.memory.initial();
260             Wasm::PageCount importedInitial = memory-&gt;memory().initial();
261             if (importedInitial &lt; declaredInitial)
<a name="23" id="anc23"></a><span class="line-modified">262                 return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided an &#39;initial&#39; that is smaller than the module&#39;s declared &#39;initial&#39; import memory size&quot;)));</span>
263 
264             if (Wasm::PageCount declaredMaximum = moduleInformation.memory.maximum()) {
265                 Wasm::PageCount importedMaximum = memory-&gt;memory().maximum();
266                 if (!importedMaximum)
<a name="24" id="anc24"></a><span class="line-modified">267                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;did not have a &#39;maximum&#39; but the module requires that it does&quot;)));</span>
268 
269                 if (importedMaximum &gt; declaredMaximum)
<a name="25" id="anc25"></a><span class="line-modified">270                     return exception(createJSWebAssemblyLinkError(globalObject, vm, importFailMessage(import, &quot;Memory import&quot;, &quot;provided a &#39;maximum&#39; that is larger than the module&#39;s declared &#39;maximum&#39; import memory size&quot;)));</span>
271             }
272 
273             // ii. Append v to memories.
274             // iii. Append v.[[Memory]] to imports.
275             jsInstance-&gt;setMemory(vm, memory);
276             RETURN_IF_EXCEPTION(throwScope, nullptr);
277             break;
278         }
279         }
280     }
281     ASSERT(moduleRecord-&gt;importEntries().size() == moduleInformation.imports.size());
282 
283     {
284         if (!!moduleInformation.memory &amp;&amp; moduleInformation.memory.isImport()) {
285             // We should either have a Memory import or we should have thrown an exception.
286             RELEASE_ASSERT(hasMemoryImport);
287         }
288 
289         if (moduleInformation.memory &amp;&amp; !hasMemoryImport) {
290             // We create a memory when it&#39;s a memory definition.
291             RELEASE_ASSERT(!moduleInformation.memory.isImport());
292 
<a name="26" id="anc26"></a><span class="line-modified">293             auto* jsMemory = JSWebAssemblyMemory::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
294             RETURN_IF_EXCEPTION(throwScope, nullptr);
295 
296             RefPtr&lt;Wasm::Memory&gt; memory = Wasm::Memory::tryCreate(moduleInformation.memory.initial(), moduleInformation.memory.maximum(),
297                 [&amp;vm] (Wasm::Memory::NotifyPressure) { vm.heap.collectAsync(CollectionScope::Full); },
298                 [&amp;vm] (Wasm::Memory::SyncTryToReclaim) { vm.heap.collectSync(CollectionScope::Full); },
299                 [&amp;vm, jsMemory] (Wasm::Memory::GrowSuccess, Wasm::PageCount oldPageCount, Wasm::PageCount newPageCount) { jsMemory-&gt;growSuccessCallback(vm, oldPageCount, newPageCount); });
300             if (!memory)
<a name="27" id="anc27"></a><span class="line-modified">301                 return exception(createOutOfMemoryError(globalObject));</span>
302 
303             jsMemory-&gt;adopt(memory.releaseNonNull());
304             jsInstance-&gt;setMemory(vm, jsMemory);
305             RETURN_IF_EXCEPTION(throwScope, nullptr);
306         }
307     }
308 
309     if (!jsInstance-&gt;memory()) {
310         // Make sure we have a dummy memory, so that wasm -&gt; wasm thunks avoid checking for a nullptr Memory when trying to set pinned registers.
<a name="28" id="anc28"></a><span class="line-modified">311         auto* jsMemory = JSWebAssemblyMemory::tryCreate(globalObject, vm, globalObject-&gt;webAssemblyMemoryStructure());</span>
<span class="line-added">312         RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
313         jsMemory-&gt;adopt(Wasm::Memory::create());
314         jsInstance-&gt;setMemory(vm, jsMemory);
315         RETURN_IF_EXCEPTION(throwScope, nullptr);
316     }
317 
318     return jsInstance;
319 }
320 
321 } // namespace JSC
322 
323 #endif // ENABLE(WEBASSEMBLY)
<a name="29" id="anc29"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="29" type="hidden" />
</body>
</html>
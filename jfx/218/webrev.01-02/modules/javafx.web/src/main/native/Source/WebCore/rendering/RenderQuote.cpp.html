<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderQuote.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Nokia Inc.  All rights reserved.
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  * Copyright (C) 2013, 2017 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 #include &quot;RenderQuote.h&quot;
 25 
 26 #include &quot;QuotesData.h&quot;
 27 #include &quot;RenderTextFragment.h&quot;
 28 #include &quot;RenderTreeBuilder.h&quot;
 29 #include &quot;RenderView.h&quot;
 30 #include &lt;wtf/IsoMallocInlines.h&gt;
 31 #include &lt;wtf/unicode/CharacterNames.h&gt;
 32 
 33 namespace WebCore {
 34 using namespace WTF::Unicode;
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderQuote);
 37 
 38 RenderQuote::RenderQuote(Document&amp; document, RenderStyle&amp;&amp; style, QuoteType quote)
 39     : RenderInline(document, WTFMove(style))
 40     , m_type(quote)
 41     , m_text(emptyString())
 42 {
 43 }
 44 
 45 RenderQuote::~RenderQuote()
 46 {
 47     // Do not add any code here. Add it to willBeDestroyed() instead.
 48 }
 49 
 50 void RenderQuote::insertedIntoTree()
 51 {
 52     RenderInline::insertedIntoTree();
 53     view().setHasQuotesNeedingUpdate(true);
 54 }
 55 
 56 void RenderQuote::willBeRemovedFromTree()
 57 {
 58     view().setHasQuotesNeedingUpdate(true);
 59     RenderInline::willBeRemovedFromTree();
 60 }
 61 
 62 void RenderQuote::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 63 {
 64     RenderInline::styleDidChange(diff, oldStyle);
 65     if (diff &gt;= StyleDifference::Layout) {
 66         m_needsTextUpdate = true;
 67         view().setHasQuotesNeedingUpdate(true);
 68     }
 69 }
 70 
 71 const unsigned maxDistinctQuoteCharacters = 16;
 72 
 73 #if ASSERT_ENABLED
 74 
 75 static void checkNumberOfDistinctQuoteCharacters(UChar character)
 76 {
 77     ASSERT(character);
 78     static UChar distinctQuoteCharacters[maxDistinctQuoteCharacters];
 79     for (unsigned i = 0; i &lt; maxDistinctQuoteCharacters; ++i) {
 80         if (distinctQuoteCharacters[i] == character)
 81             return;
 82         if (!distinctQuoteCharacters[i]) {
 83             distinctQuoteCharacters[i] = character;
 84             return;
 85         }
 86     }
 87     ASSERT_NOT_REACHED();
 88 }
 89 
 90 #endif // ASSERT_ENABLED
 91 
 92 struct QuotesForLanguage {
 93     const char* language;
 94     UChar open1;
 95     UChar close1;
 96     UChar open2;
 97     UChar close2;
 98 };
 99 
100 static int quoteTableLanguageComparisonFunction(const void* a, const void* b)
101 {
102     return strcmp(static_cast&lt;const QuotesForLanguage*&gt;(a)-&gt;language,
103         static_cast&lt;const QuotesForLanguage*&gt;(b)-&gt;language);
104 }
105 
106 static const QuotesForLanguage* quotesForLanguage(const String&amp; language)
107 {
108     // Table of quotes from http://www.whatwg.org/specs/web-apps/current-work/multipage/rendering.html#quotes
109     static const QuotesForLanguage quoteTable[] = {
110         { &quot;af&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
111         { &quot;agq&quot;,        0x201e, 0x201d, 0x201a, 0x2019 },
112         { &quot;ak&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
113         { &quot;am&quot;,         0x00ab, 0x00bb, 0x2039, 0x203a },
114         { &quot;ar&quot;,         0x201d, 0x201c, 0x2019, 0x2018 },
115         { &quot;asa&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
116         { &quot;az-cyrl&quot;,    0x00ab, 0x00bb, 0x2039, 0x203a },
117         { &quot;bas&quot;,        0x00ab, 0x00bb, 0x201e, 0x201c },
118         { &quot;bem&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
119         { &quot;bez&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
120         { &quot;bg&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
121         { &quot;bm&quot;,         0x00ab, 0x00bb, 0x201c, 0x201d },
122         { &quot;bn&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
123         { &quot;br&quot;,         0x00ab, 0x00bb, 0x2039, 0x203a },
124         { &quot;brx&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
125         { &quot;bs-cyrl&quot;,    0x201e, 0x201c, 0x201a, 0x2018 },
126         { &quot;ca&quot;,         0x201c, 0x201d, 0x00ab, 0x00bb },
127         { &quot;cgg&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
128         { &quot;chr&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
129         { &quot;cs&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
130         { &quot;da&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
131         { &quot;dav&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
132         { &quot;de&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
133         { &quot;de-ch&quot;,      0x00ab, 0x00bb, 0x2039, 0x203a },
134         { &quot;dje&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
135         { &quot;dua&quot;,        0x00ab, 0x00bb, 0x2018, 0x2019 },
136         { &quot;dyo&quot;,        0x00ab, 0x00bb, 0x201c, 0x201d },
137         { &quot;dz&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
138         { &quot;ebu&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
139         { &quot;ee&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
140         { &quot;el&quot;,         0x00ab, 0x00bb, 0x201c, 0x201d },
141         { &quot;en&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
142         { &quot;en-gb&quot;,      0x201c, 0x201d, 0x2018, 0x2019 },
143         { &quot;es&quot;,         0x201c, 0x201d, 0x00ab, 0x00bb },
144         { &quot;et&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
145         { &quot;eu&quot;,         0x201c, 0x201d, 0x00ab, 0x00bb },
146         { &quot;ewo&quot;,        0x00ab, 0x00bb, 0x201c, 0x201d },
147         { &quot;fa&quot;,         0x00ab, 0x00bb, 0x2039, 0x203a },
148         { &quot;ff&quot;,         0x201e, 0x201d, 0x201a, 0x2019 },
149         { &quot;fi&quot;,         0x201d, 0x201d, 0x2019, 0x2019 },
150         { &quot;fr&quot;,         0x00ab, 0x00bb, 0x00ab, 0x00bb },
151         { &quot;fr-ca&quot;,      0x00ab, 0x00bb, 0x2039, 0x203a },
152         { &quot;fr-ch&quot;,      0x00ab, 0x00bb, 0x2039, 0x203a },
153         { &quot;gsw&quot;,        0x00ab, 0x00bb, 0x2039, 0x203a },
154         { &quot;gu&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
155         { &quot;guz&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
156         { &quot;ha&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
157         { &quot;he&quot;,         0x0022, 0x0022, 0x0027, 0x0027 },
158         { &quot;hi&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
159         { &quot;hr&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
160         { &quot;hu&quot;,         0x201e, 0x201d, 0x00bb, 0x00ab },
161         { &quot;id&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
162         { &quot;ig&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
163         { &quot;it&quot;,         0x00ab, 0x00bb, 0x201c, 0x201d },
164         { &quot;ja&quot;,         0x300c, 0x300d, 0x300e, 0x300f },
165         { &quot;jgo&quot;,        0x00ab, 0x00bb, 0x2039, 0x203a },
166         { &quot;jmc&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
167         { &quot;kab&quot;,        0x00ab, 0x00bb, 0x201c, 0x201d },
168         { &quot;kam&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
169         { &quot;kde&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
170         { &quot;kea&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
171         { &quot;khq&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
172         { &quot;ki&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
173         { &quot;kkj&quot;,        0x00ab, 0x00bb, 0x2039, 0x203a },
174         { &quot;kln&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
175         { &quot;km&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
176         { &quot;kn&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
177         { &quot;ko&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
178         { &quot;ksb&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
179         { &quot;ksf&quot;,        0x00ab, 0x00bb, 0x2018, 0x2019 },
180         { &quot;lag&quot;,        0x201d, 0x201d, 0x2019, 0x2019 },
181         { &quot;lg&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
182         { &quot;ln&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
183         { &quot;lo&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
184         { &quot;lt&quot;,         0x201e, 0x201c, 0x201e, 0x201c },
185         { &quot;lu&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
186         { &quot;luo&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
187         { &quot;luy&quot;,        0x201e, 0x201c, 0x201a, 0x2018 },
188         { &quot;lv&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
189         { &quot;mas&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
190         { &quot;mer&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
191         { &quot;mfe&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
192         { &quot;mg&quot;,         0x00ab, 0x00bb, 0x201c, 0x201d },
193         { &quot;mgo&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
194         { &quot;mk&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
195         { &quot;ml&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
196         { &quot;mr&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
197         { &quot;ms&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
198         { &quot;mua&quot;,        0x00ab, 0x00bb, 0x201c, 0x201d },
199         { &quot;my&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
200         { &quot;naq&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
201         { &quot;nb&quot;,         0x00ab, 0x00bb, 0x2018, 0x2019 },
202         { &quot;nd&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
203         { &quot;nl&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
204         { &quot;nmg&quot;,        0x201e, 0x201d, 0x00ab, 0x00bb },
205         { &quot;nn&quot;,         0x00ab, 0x00bb, 0x2018, 0x2019 },
206         { &quot;nnh&quot;,        0x00ab, 0x00bb, 0x201c, 0x201d },
207         { &quot;nus&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
208         { &quot;nyn&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
209         { &quot;pl&quot;,         0x201e, 0x201d, 0x00ab, 0x00bb },
210         { &quot;pt&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
211         { &quot;pt-pt&quot;,      0x00ab, 0x00bb, 0x201c, 0x201d },
212         { &quot;rn&quot;,         0x201d, 0x201d, 0x2019, 0x2019 },
213         { &quot;ro&quot;,         0x201e, 0x201d, 0x00ab, 0x00bb },
214         { &quot;rof&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
215         { &quot;ru&quot;,         0x00ab, 0x00bb, 0x201e, 0x201c },
216         { &quot;rw&quot;,         0x00ab, 0x00bb, 0x2018, 0x2019 },
217         { &quot;rwk&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
218         { &quot;saq&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
219         { &quot;sbp&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
220         { &quot;seh&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
221         { &quot;ses&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
222         { &quot;sg&quot;,         0x00ab, 0x00bb, 0x201c, 0x201d },
223         { &quot;shi&quot;,        0x00ab, 0x00bb, 0x201e, 0x201d },
224         { &quot;shi-tfng&quot;,   0x00ab, 0x00bb, 0x201e, 0x201d },
225         { &quot;si&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
226         { &quot;sk&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
227         { &quot;sl&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
228         { &quot;sn&quot;,         0x201d, 0x201d, 0x2019, 0x2019 },
229         { &quot;so&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
230         { &quot;sq&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
231         { &quot;sr&quot;,         0x201e, 0x201c, 0x201a, 0x2018 },
232         { &quot;sr-latn&quot;,    0x201e, 0x201c, 0x201a, 0x2018 },
233         { &quot;sv&quot;,         0x201d, 0x201d, 0x2019, 0x2019 },
234         { &quot;sw&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
235         { &quot;swc&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
236         { &quot;ta&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
237         { &quot;te&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
238         { &quot;teo&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
239         { &quot;th&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
240         { &quot;ti-er&quot;,      0x2018, 0x2019, 0x201c, 0x201d },
241         { &quot;to&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
242         { &quot;tr&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
243         { &quot;twq&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
244         { &quot;tzm&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
245         { &quot;uk&quot;,         0x00ab, 0x00bb, 0x201e, 0x201c },
246         { &quot;ur&quot;,         0x201d, 0x201c, 0x2019, 0x2018 },
247         { &quot;vai&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
248         { &quot;vai-latn&quot;,   0x201c, 0x201d, 0x2018, 0x2019 },
249         { &quot;vi&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
250         { &quot;vun&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
251         { &quot;xh&quot;,         0x2018, 0x2019, 0x201c, 0x201d },
252         { &quot;xog&quot;,        0x201c, 0x201d, 0x2018, 0x2019 },
253         { &quot;yav&quot;,        0x00ab, 0x00bb, 0x00ab, 0x00bb },
254         { &quot;yo&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
255         { &quot;zh&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
256         { &quot;zh-hant&quot;,    0x300c, 0x300d, 0x300e, 0x300f },
257         { &quot;zu&quot;,         0x201c, 0x201d, 0x2018, 0x2019 },
258     };
259 
260     const unsigned maxLanguageLength = 8;
261 
262 #if ASSERT_ENABLED
263     // One time check that the table meets the constraints that the code below relies on.
264 
265     static bool didOneTimeCheck = false;
266     if (!didOneTimeCheck) {
267         didOneTimeCheck = true;
268 
269         checkNumberOfDistinctQuoteCharacters(quotationMark);
270         checkNumberOfDistinctQuoteCharacters(apostrophe);
271 
272         for (unsigned i = 0; i &lt; WTF_ARRAY_LENGTH(quoteTable); ++i) {
273             ASSERT(strlen(quoteTable[i].language) &lt;= maxLanguageLength);
274 
275             if (i)
276                 ASSERT(strcmp(quoteTable[i - 1].language, quoteTable[i].language) &lt; 0);
277 
278             for (unsigned j = 0; UChar character = quoteTable[i].language[j]; ++j)
279                 ASSERT(isASCIILower(character) || character == &#39;-&#39;);
280 
281             checkNumberOfDistinctQuoteCharacters(quoteTable[i].open1);
282             checkNumberOfDistinctQuoteCharacters(quoteTable[i].close1);
283             checkNumberOfDistinctQuoteCharacters(quoteTable[i].open2);
284             checkNumberOfDistinctQuoteCharacters(quoteTable[i].close2);
285         }
286     }
287 #endif // ASSERT_ENABLED
288 
289     unsigned length = language.length();
290     if (!length || length &gt; maxLanguageLength)
291         return 0;
292 
293     char languageKeyBuffer[maxLanguageLength + 1];
294     for (unsigned i = 0; i &lt; length; ++i) {
295         UChar character = toASCIILower(language[i]);
296         if (!(isASCIILower(character) || character == &#39;-&#39;))
297             return 0;
298         languageKeyBuffer[i] = static_cast&lt;char&gt;(character);
299     }
300     languageKeyBuffer[length] = 0;
301 
302     QuotesForLanguage languageKey = { languageKeyBuffer, 0, 0, 0, 0 };
303 
304     return static_cast&lt;const QuotesForLanguage*&gt;(bsearch(&amp;languageKey,
305         quoteTable, WTF_ARRAY_LENGTH(quoteTable), sizeof(quoteTable[0]), quoteTableLanguageComparisonFunction));
306 }
307 
308 static StringImpl* stringForQuoteCharacter(UChar character)
309 {
310     // Use linear search because there is a small number of distinct characters, thus binary search is unneeded.
311     ASSERT(character);
312     struct StringForCharacter {
313         UChar character;
314         StringImpl* string;
315     };
316     static StringForCharacter strings[maxDistinctQuoteCharacters];
317     for (unsigned i = 0; i &lt; maxDistinctQuoteCharacters; ++i) {
318         if (strings[i].character == character)
319             return strings[i].string;
320         if (!strings[i].character) {
321             strings[i].character = character;
322             strings[i].string = &amp;StringImpl::create8BitIfPossible(&amp;character, 1).leakRef();
323             return strings[i].string;
324         }
325     }
326     ASSERT_NOT_REACHED();
327     return StringImpl::empty();
328 }
329 
330 static inline StringImpl* quotationMarkString()
331 {
332     static StringImpl* quotationMarkString = stringForQuoteCharacter(quotationMark);
333     return quotationMarkString;
334 }
335 
336 static inline StringImpl* apostropheString()
337 {
338     static StringImpl* apostropheString = stringForQuoteCharacter(apostrophe);
339     return apostropheString;
340 }
341 
342 static RenderTextFragment* quoteTextRenderer(RenderObject* lastChild)
343 {
344     if (!lastChild)
345         return nullptr;
346 
347     if (!is&lt;RenderTextFragment&gt;(lastChild))
348         return nullptr;
349 
350     return downcast&lt;RenderTextFragment&gt;(lastChild);
351 }
352 
353 void RenderQuote::updateTextRenderer(RenderTreeBuilder&amp; builder)
354 {
355     ASSERT_WITH_SECURITY_IMPLICATION(document().inRenderTreeUpdate());
356     String text = computeText();
357     if (m_text == text)
358         return;
359     m_text = text;
360     if (auto* renderText = quoteTextRenderer(lastChild())) {
361         renderText-&gt;setContentString(m_text);
362         renderText-&gt;dirtyLineBoxes(false);
363         return;
364     }
365     builder.attach(*this, createRenderer&lt;RenderTextFragment&gt;(document(), m_text));
366 }
367 
368 String RenderQuote::computeText() const
369 {
370     if (m_depth &lt; 0)
371         return emptyString();
372     bool isOpenQuote = false;
373     switch (m_type) {
374     case QuoteType::NoOpenQuote:
375     case QuoteType::NoCloseQuote:
376         return emptyString();
377     case QuoteType::OpenQuote:
378         isOpenQuote = true;
379         FALLTHROUGH;
380     case QuoteType::CloseQuote:
381         if (const QuotesData* quotes = style().quotes())
382             return isOpenQuote ? quotes-&gt;openQuote(m_depth).impl() : quotes-&gt;closeQuote(m_depth).impl();
383         if (const QuotesForLanguage* quotes = quotesForLanguage(style().locale()))
384             return stringForQuoteCharacter(isOpenQuote ? (m_depth ? quotes-&gt;open2 : quotes-&gt;open1) : (m_depth ? quotes-&gt;close2 : quotes-&gt;close1));
385         // FIXME: Should the default be the quotes for &quot;en&quot; rather than straight quotes?
386         return m_depth ? apostropheString() : quotationMarkString();
387     }
388     ASSERT_NOT_REACHED();
389     return emptyString();
390 }
391 
392 bool RenderQuote::isOpen() const
393 {
394     switch (m_type) {
395     case QuoteType::OpenQuote:
396     case QuoteType::NoOpenQuote:
397         return true;
398     case QuoteType::CloseQuote:
399     case QuoteType::NoCloseQuote:
400         return false;
401     }
402     ASSERT_NOT_REACHED();
403     return false;
404 }
405 
406 void RenderQuote::updateRenderer(RenderTreeBuilder&amp; builder, RenderQuote* previousQuote)
407 {
408     ASSERT_WITH_SECURITY_IMPLICATION(document().inRenderTreeUpdate());
409     int depth = -1;
410     if (previousQuote) {
411         depth = previousQuote-&gt;m_depth;
412         if (previousQuote-&gt;isOpen())
413             ++depth;
414     }
415 
416     if (!isOpen())
417         --depth;
418     else if (depth &lt; 0)
419         depth = 0;
420 
421     if (m_depth == depth &amp;&amp; !m_needsTextUpdate)
422         return;
423 
424     m_depth = depth;
425     m_needsTextUpdate = false;
426     updateTextRenderer(builder);
427 }
428 
429 } // namespace WebCore
    </pre>
  </body>
</html>
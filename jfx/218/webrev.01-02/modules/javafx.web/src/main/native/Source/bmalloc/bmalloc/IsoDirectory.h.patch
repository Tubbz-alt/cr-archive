diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h
@@ -26,10 +26,11 @@
 #pragma once
 
 #include "Bits.h"
 #include "EligibilityResult.h"
 #include "IsoPage.h"
+#include "Packed.h"
 #include "Vector.h"
 
 namespace bmalloc {
 
 template<typename Config> class IsoHeapImpl;
@@ -47,11 +48,11 @@
 public:
     IsoDirectoryBase(IsoHeapImpl<Config>&);
 
     IsoHeapImpl<Config>& heap() { return m_heap; }
 
-    virtual void didBecome(IsoPage<Config>*, IsoPageTrigger) = 0;
+    virtual void didBecome(const LockHolder&, IsoPage<Config>*, IsoPageTrigger) = 0;
 
 protected:
     IsoHeapImpl<Config>& m_heap;
 };
 
@@ -62,34 +63,40 @@
 
     IsoDirectory(IsoHeapImpl<Config>&);
 
     // Find the first page that is eligible for allocation and return it. May return null if there is no
     // such thing. May allocate a new page if we have an uncommitted page.
-    EligibilityResult<Config> takeFirstEligible();
+    EligibilityResult<Config> takeFirstEligible(const LockHolder&);
 
-    void didBecome(IsoPage<Config>*, IsoPageTrigger) override;
+    void didBecome(const LockHolder&, IsoPage<Config>*, IsoPageTrigger) override;
 
     // This gets called from a bulk decommit function in the Scavenger, so no locks are held. This function
     // needs to get the heap lock.
     void didDecommit(unsigned index) override;
 
     // Iterate over all empty and committed pages, and put them into the vector. This also records the
     // pages as being decommitted. It's the caller's job to do the actual decommitting.
-    void scavenge(Vector<DeferredDecommit>&);
+    void scavenge(const LockHolder&, Vector<DeferredDecommit>&);
+#if BUSE(PARTIAL_SCAVENGE)
+    void scavengeToHighWatermark(const LockHolder&, Vector<DeferredDecommit>&);
+#endif
 
     template<typename Func>
-    void forEachCommittedPage(const Func&);
+    void forEachCommittedPage(const LockHolder&, const Func&);
 
 private:
-    void scavengePage(size_t, Vector<DeferredDecommit>&);
+    void scavengePage(const LockHolder&, size_t, Vector<DeferredDecommit>&);
 
+    std::array<PackedAlignedPtr<IsoPage<Config>, IsoPage<Config>::pageSize>, numPages> m_pages { };
     // NOTE: I suppose that this could be two bitvectors. But from working on the GC, I found that the
     // number of bitvectors does not matter as much as whether or not they make intuitive sense.
     Bits<numPages> m_eligible;
     Bits<numPages> m_empty;
     Bits<numPages> m_committed;
-    std::array<IsoPage<Config>*, numPages> m_pages;
     unsigned m_firstEligibleOrDecommitted { 0 };
+#if BUSE(PARTIAL_SCAVENGE)
+    unsigned m_highWatermark { 0 };
+#endif
 };
 
 } // namespace bmalloc
 

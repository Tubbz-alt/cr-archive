diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h b/modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/Node.h
@@ -475,18 +475,18 @@
     WEBCORE_EXPORT void dispatchInputEvent();
 
     // Perform the default action for an event.
     virtual void defaultEventHandler(Event&);
 
-    void ref();
-    void deref();
+    void ref() const;
+    void deref() const;
     bool hasOneRef() const;
     unsigned refCount() const;
 
-#ifndef NDEBUG
+#if ASSERT_ENABLED
     bool m_deletionHasBegun { false };
-    bool m_inRemovedLastRefFunction { false };
+    mutable bool m_inRemovedLastRefFunction { false };
     bool m_adoptionIsRequired { true };
 #endif
 
     EventTargetData* eventTargetData() final;
     EventTargetData* eventTargetDataConcurrently() final;
@@ -666,56 +666,56 @@
 
     struct NodeRareDataDeleter {
         void operator()(NodeRareData*) const;
     };
 
-    uint32_t m_refCountAndParentBit { s_refCountIncrement };
+    mutable uint32_t m_refCountAndParentBit { s_refCountIncrement };
     mutable uint32_t m_nodeFlags;
 
     ContainerNode* m_parentNode { nullptr };
     TreeScope* m_treeScope { nullptr };
     Node* m_previous { nullptr };
     Node* m_next { nullptr };
     CompactPointerTuple<RenderObject*, uint8_t> m_rendererWithStyleFlags;
     std::unique_ptr<NodeRareData, NodeRareDataDeleter> m_rareData;
 };
 
-#ifndef NDEBUG
+#if ASSERT_ENABLED
 inline void adopted(Node* node)
 {
     if (!node)
         return;
     ASSERT(!node->m_deletionHasBegun);
     ASSERT(!node->m_inRemovedLastRefFunction);
     node->m_adoptionIsRequired = false;
 }
-#endif
+#endif // ASSERT_ENABLED
 
-ALWAYS_INLINE void Node::ref()
+ALWAYS_INLINE void Node::ref() const
 {
     ASSERT(isMainThread());
     ASSERT(!m_deletionHasBegun);
     ASSERT(!m_inRemovedLastRefFunction);
     ASSERT(!m_adoptionIsRequired);
     m_refCountAndParentBit += s_refCountIncrement;
 }
 
-ALWAYS_INLINE void Node::deref()
+ALWAYS_INLINE void Node::deref() const
 {
     ASSERT(isMainThread());
     ASSERT(refCount());
     ASSERT(!m_deletionHasBegun);
     ASSERT(!m_inRemovedLastRefFunction);
     ASSERT(!m_adoptionIsRequired);
     auto updatedRefCount = m_refCountAndParentBit - s_refCountIncrement;
     if (!updatedRefCount) {
         // Don't update m_refCountAndParentBit to avoid double destruction through use of Ref<T>/RefPtr<T>.
         // (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
-#ifndef NDEBUG
+#if ASSERT_ENABLED
         m_inRemovedLastRefFunction = true;
 #endif
-        removedLastRef();
+        const_cast<Node&>(*this).removedLastRef();
         return;
     }
     m_refCountAndParentBit = updatedRefCount;
 }
 
@@ -788,10 +788,12 @@
     ASSERT(!m_deletionHasBegun);
     if (m_treeScope != &newTreeScope)
         moveTreeToNewScope(*this, *m_treeScope, newTreeScope);
 }
 
+bool areNodesConnectedInSameTreeScope(const Node*, const Node*);
+
 } // namespace WebCore
 
 #if ENABLE(TREE_DEBUGGING)
 // Outside the WebCore namespace for ease of invocation from the debugger.
 void showTree(const WebCore::Node*);

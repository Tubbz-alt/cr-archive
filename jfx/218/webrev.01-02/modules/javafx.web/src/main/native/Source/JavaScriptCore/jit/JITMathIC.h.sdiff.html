<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITMathIC.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITLeftShiftGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITMulGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITMathIC.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 #include &quot;JITNegGenerator.h&quot;
 36 #include &quot;JITSubGenerator.h&quot;
 37 #include &quot;LinkBuffer.h&quot;
 38 #include &quot;Repatch.h&quot;
 39 
 40 namespace JSC {
 41 
 42 class LinkBuffer;
 43 
 44 struct MathICGenerationState {
 45     MacroAssembler::Label fastPathStart;
 46     MacroAssembler::Label fastPathEnd;
 47     MacroAssembler::Label slowPathStart;
 48     MacroAssembler::Call slowPathCall;
 49     MacroAssembler::JumpList slowPathJumps;
 50     bool shouldSlowPathRepatch;
 51 };
 52 
 53 #define ENABLE_MATH_IC_STATS 0
 54 
<span class="line-modified"> 55 template &lt;typename GeneratorType, bool(*isProfileEmpty)(ArithProfile&amp;)&gt;</span>
 56 class JITMathIC {
 57     WTF_MAKE_FAST_ALLOCATED;
 58 public:
<span class="line-modified"> 59     JITMathIC(ArithProfile* arithProfile)</span>
 60         : m_arithProfile(arithProfile)
 61     {
 62     }
 63 
 64     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return m_inlineEnd; }
 65     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return m_slowPathCallLocation; }
 66     CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathStartLocation() { return m_slowPathStartLocation; }
 67 
 68     bool generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, bool shouldEmitProfiling = true)
 69     {
 70         state.fastPathStart = jit.label();
 71         size_t startSize = jit.m_assembler.buffer().codeSize();
 72 
<span class="line-modified"> 73         if (m_arithProfile) {</span>
<span class="line-modified"> 74             if (isProfileEmpty(*m_arithProfile)) {</span>
<span class="line-modified"> 75                 // It looks like the MathIC has yet to execute. We don&#39;t want to emit code in this</span>
<span class="line-modified"> 76                 // case for a couple reasons. First, the operation may never execute, so if we don&#39;t emit</span>
<span class="line-modified"> 77                 // code, it&#39;s a win. Second, if the operation does execute, we can emit better code</span>
<span class="line-modified"> 78                 // once we have an idea about the types.</span>
<span class="line-modified"> 79                 state.slowPathJumps.append(jit.patchableJump());</span>
<span class="line-modified"> 80                 size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;</span>
<span class="line-modified"> 81                 ASSERT_UNUSED(inlineSize, static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt;= MacroAssembler::patchableJumpSize());</span>
<span class="line-modified"> 82                 state.shouldSlowPathRepatch = true;</span>
<span class="line-modified"> 83                 state.fastPathEnd = jit.label();</span>
<span class="line-modified"> 84                 ASSERT(!m_generateFastPathOnRepatch); // We should have gathered some observed type info about the types before trying to regenerate again.</span>
<span class="line-modified"> 85                 m_generateFastPathOnRepatch = true;</span>
<span class="line-removed"> 86                 return true;</span>
<span class="line-removed"> 87             }</span>
 88         }
 89 
 90         JITMathICInlineResult result = m_generator.generateInline(jit, state, m_arithProfile);
 91 
 92         switch (result) {
 93         case JITMathICInlineResult::GeneratedFastPath: {
 94             size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;
 95             if (static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt; MacroAssembler::patchableJumpSize()) {
 96                 size_t nopsToEmitInBytes = MacroAssembler::patchableJumpSize() - inlineSize;
 97                 jit.emitNops(nopsToEmitInBytes);
 98             }
 99             state.shouldSlowPathRepatch = true;
100             state.fastPathEnd = jit.label();
101             return true;
102         }
103         case JITMathICInlineResult::GenerateFullSnippet: {
104             MacroAssembler::JumpList endJumpList;
105             bool result = m_generator.generateFastPath(jit, endJumpList, state.slowPathJumps, m_arithProfile, shouldEmitProfiling);
106             if (result) {
107                 state.fastPathEnd = jit.label();
</pre>
<hr />
<pre>
206 
207             m_code = FINALIZE_CODE_FOR(
208                 codeBlock, linkBuffer, JITStubRoutinePtrTag, &quot;JITMathIC: generating out of line IC snippet&quot;);
209         }
210 
211         linkJumpToOutOfLineSnippet();
212     }
213 
214     void finalizeInlineCode(const MathICGenerationState&amp; state, LinkBuffer&amp; linkBuffer)
215     {
216         CodeLocationLabel&lt;JSInternalPtrTag&gt; start = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathStart);
217         m_inlineStart = start;
218 
219         m_inlineEnd = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathEnd);
220         ASSERT(m_inlineEnd.untaggedExecutableAddress() &gt; m_inlineStart.untaggedExecutableAddress());
221 
222         m_slowPathCallLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathCall);
223         m_slowPathStartLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathStart);
224     }
225 
<span class="line-modified">226     ArithProfile* arithProfile() const { return m_arithProfile; }</span>
227 
228 #if ENABLE(MATH_IC_STATS)
229     size_t m_generatedCodeSize { 0 };
230     size_t codeSize() const
231     {
232         size_t result = m_generatedCodeSize;
233         if (m_code)
234             result += m_code.size();
235         return result;
236     }
237 #endif
238 
<span class="line-modified">239     ArithProfile* m_arithProfile;</span>
240     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; m_code;
241     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineStart;
242     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineEnd;
243     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathCallLocation;
244     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathStartLocation;
245     bool m_generateFastPathOnRepatch { false };
246     GeneratorType m_generator;
247 };
248 
<span class="line-removed">249 inline bool isBinaryProfileEmpty(ArithProfile&amp; arithProfile)</span>
<span class="line-removed">250 {</span>
<span class="line-removed">251     return arithProfile.lhsObservedType().isEmpty() || arithProfile.rhsObservedType().isEmpty();</span>
<span class="line-removed">252 }</span>
253 template &lt;typename GeneratorType&gt;
<span class="line-modified">254 class JITBinaryMathIC : public JITMathIC&lt;GeneratorType, isBinaryProfileEmpty&gt; {</span>
255 public:
<span class="line-modified">256     JITBinaryMathIC(ArithProfile* arithProfile)</span>
<span class="line-modified">257         : JITMathIC&lt;GeneratorType, isBinaryProfileEmpty&gt;(arithProfile)</span>
258     {
259     }
260 };
261 
262 typedef JITBinaryMathIC&lt;JITAddGenerator&gt; JITAddIC;
263 typedef JITBinaryMathIC&lt;JITMulGenerator&gt; JITMulIC;
264 typedef JITBinaryMathIC&lt;JITSubGenerator&gt; JITSubIC;
265 
<span class="line-removed">266 </span>
<span class="line-removed">267 inline bool isUnaryProfileEmpty(ArithProfile&amp; arithProfile)</span>
<span class="line-removed">268 {</span>
<span class="line-removed">269     return arithProfile.lhsObservedType().isEmpty();</span>
<span class="line-removed">270 }</span>
271 template &lt;typename GeneratorType&gt;
<span class="line-modified">272 class JITUnaryMathIC : public JITMathIC&lt;GeneratorType, isUnaryProfileEmpty&gt; {</span>
273 public:
<span class="line-modified">274     JITUnaryMathIC(ArithProfile* arithProfile)</span>
<span class="line-modified">275         : JITMathIC&lt;GeneratorType, isUnaryProfileEmpty&gt;(arithProfile)</span>
276     {
277     }
278 };
279 
280 typedef JITUnaryMathIC&lt;JITNegGenerator&gt; JITNegIC;
281 
282 } // namespace JSC
283 
284 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
 35 #include &quot;JITNegGenerator.h&quot;
 36 #include &quot;JITSubGenerator.h&quot;
 37 #include &quot;LinkBuffer.h&quot;
 38 #include &quot;Repatch.h&quot;
 39 
 40 namespace JSC {
 41 
 42 class LinkBuffer;
 43 
 44 struct MathICGenerationState {
 45     MacroAssembler::Label fastPathStart;
 46     MacroAssembler::Label fastPathEnd;
 47     MacroAssembler::Label slowPathStart;
 48     MacroAssembler::Call slowPathCall;
 49     MacroAssembler::JumpList slowPathJumps;
 50     bool shouldSlowPathRepatch;
 51 };
 52 
 53 #define ENABLE_MATH_IC_STATS 0
 54 
<span class="line-modified"> 55 template &lt;typename GeneratorType, typename ArithProfileType&gt;</span>
 56 class JITMathIC {
 57     WTF_MAKE_FAST_ALLOCATED;
 58 public:
<span class="line-modified"> 59     JITMathIC(ArithProfileType* arithProfile)</span>
 60         : m_arithProfile(arithProfile)
 61     {
 62     }
 63 
 64     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return m_inlineEnd; }
 65     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return m_slowPathCallLocation; }
 66     CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathStartLocation() { return m_slowPathStartLocation; }
 67 
 68     bool generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, bool shouldEmitProfiling = true)
 69     {
 70         state.fastPathStart = jit.label();
 71         size_t startSize = jit.m_assembler.buffer().codeSize();
 72 
<span class="line-modified"> 73         if (m_arithProfile &amp;&amp; m_arithProfile-&gt;isObservedTypeEmpty()) {</span>
<span class="line-modified"> 74             // It looks like the MathIC has yet to execute. We don&#39;t want to emit code in this</span>
<span class="line-modified"> 75             // case for a couple reasons. First, the operation may never execute, so if we don&#39;t emit</span>
<span class="line-modified"> 76             // code, it&#39;s a win. Second, if the operation does execute, we can emit better code</span>
<span class="line-modified"> 77             // once we have an idea about the types.</span>
<span class="line-modified"> 78             state.slowPathJumps.append(jit.patchableJump());</span>
<span class="line-modified"> 79             size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;</span>
<span class="line-modified"> 80             ASSERT_UNUSED(inlineSize, static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt;= MacroAssembler::patchableJumpSize());</span>
<span class="line-modified"> 81             state.shouldSlowPathRepatch = true;</span>
<span class="line-modified"> 82             state.fastPathEnd = jit.label();</span>
<span class="line-modified"> 83             ASSERT(!m_generateFastPathOnRepatch); // We should have gathered some observed type info about the types before trying to regenerate again.</span>
<span class="line-modified"> 84             m_generateFastPathOnRepatch = true;</span>
<span class="line-modified"> 85             return true;</span>


 86         }
 87 
 88         JITMathICInlineResult result = m_generator.generateInline(jit, state, m_arithProfile);
 89 
 90         switch (result) {
 91         case JITMathICInlineResult::GeneratedFastPath: {
 92             size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;
 93             if (static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt; MacroAssembler::patchableJumpSize()) {
 94                 size_t nopsToEmitInBytes = MacroAssembler::patchableJumpSize() - inlineSize;
 95                 jit.emitNops(nopsToEmitInBytes);
 96             }
 97             state.shouldSlowPathRepatch = true;
 98             state.fastPathEnd = jit.label();
 99             return true;
100         }
101         case JITMathICInlineResult::GenerateFullSnippet: {
102             MacroAssembler::JumpList endJumpList;
103             bool result = m_generator.generateFastPath(jit, endJumpList, state.slowPathJumps, m_arithProfile, shouldEmitProfiling);
104             if (result) {
105                 state.fastPathEnd = jit.label();
</pre>
<hr />
<pre>
204 
205             m_code = FINALIZE_CODE_FOR(
206                 codeBlock, linkBuffer, JITStubRoutinePtrTag, &quot;JITMathIC: generating out of line IC snippet&quot;);
207         }
208 
209         linkJumpToOutOfLineSnippet();
210     }
211 
212     void finalizeInlineCode(const MathICGenerationState&amp; state, LinkBuffer&amp; linkBuffer)
213     {
214         CodeLocationLabel&lt;JSInternalPtrTag&gt; start = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathStart);
215         m_inlineStart = start;
216 
217         m_inlineEnd = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathEnd);
218         ASSERT(m_inlineEnd.untaggedExecutableAddress() &gt; m_inlineStart.untaggedExecutableAddress());
219 
220         m_slowPathCallLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathCall);
221         m_slowPathStartLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathStart);
222     }
223 
<span class="line-modified">224     ArithProfileType* arithProfile() const { return m_arithProfile; }</span>
225 
226 #if ENABLE(MATH_IC_STATS)
227     size_t m_generatedCodeSize { 0 };
228     size_t codeSize() const
229     {
230         size_t result = m_generatedCodeSize;
231         if (m_code)
232             result += m_code.size();
233         return result;
234     }
235 #endif
236 
<span class="line-modified">237     ArithProfileType* m_arithProfile;</span>
238     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; m_code;
239     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineStart;
240     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineEnd;
241     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathCallLocation;
242     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathStartLocation;
243     bool m_generateFastPathOnRepatch { false };
244     GeneratorType m_generator;
245 };
246 




247 template &lt;typename GeneratorType&gt;
<span class="line-modified">248 class JITBinaryMathIC : public JITMathIC&lt;GeneratorType, BinaryArithProfile&gt; {</span>
249 public:
<span class="line-modified">250     JITBinaryMathIC(BinaryArithProfile* arithProfile)</span>
<span class="line-modified">251         : JITMathIC&lt;GeneratorType, BinaryArithProfile&gt;(arithProfile)</span>
252     {
253     }
254 };
255 
256 typedef JITBinaryMathIC&lt;JITAddGenerator&gt; JITAddIC;
257 typedef JITBinaryMathIC&lt;JITMulGenerator&gt; JITMulIC;
258 typedef JITBinaryMathIC&lt;JITSubGenerator&gt; JITSubIC;
259 





260 template &lt;typename GeneratorType&gt;
<span class="line-modified">261 class JITUnaryMathIC : public JITMathIC&lt;GeneratorType, UnaryArithProfile&gt; {</span>
262 public:
<span class="line-modified">263     JITUnaryMathIC(UnaryArithProfile* arithProfile)</span>
<span class="line-modified">264         : JITMathIC&lt;GeneratorType, UnaryArithProfile&gt;(arithProfile)</span>
265     {
266     }
267 };
268 
269 typedef JITUnaryMathIC&lt;JITNegGenerator&gt; JITNegIC;
270 
271 } // namespace JSC
272 
273 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITLeftShiftGenerator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITMulGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
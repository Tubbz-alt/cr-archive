<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringHasher.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller ( mueller@kde.org )
<span class="line-modified">   5  * Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   6  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  85     double percent8Bit = m_totalNumberStrings ? ((double)m_number8BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  86     double average8bitLength = m_number8BitStrings ? (double)m_total8BitData / (double)m_number8BitStrings : 0.0;
  87     dataLogF(&quot;%8u (%5.2f%%) 8 bit        %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number8BitStrings.load(), percent8Bit, m_total8BitData.load(), m_total8BitData.load(), average8bitLength);
  88 
  89     double percent16Bit = m_totalNumberStrings ? ((double)m_number16BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  90     double average16bitLength = m_number16BitStrings ? (double)m_total16BitData / (double)m_number16BitStrings : 0.0;
  91     dataLogF(&quot;%8u (%5.2f%%) 16 bit       %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number16BitStrings.load(), percent16Bit, m_total16BitData.load(), m_total16BitData * 2, average16bitLength);
  92 
  93     double averageLength = m_totalNumberStrings ? (double)totalNumberCharacters / (double)m_totalNumberStrings : 0.0;
  94     unsigned long long totalDataBytes = m_total8BitData + m_total16BitData * 2;
  95     dataLogF(&quot;%8u Total                 %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_totalNumberStrings.load(), totalNumberCharacters, totalDataBytes, averageLength);
  96     unsigned long long totalSavedBytes = m_total8BitData;
  97     double percentSavings = totalSavedBytes ? ((double)totalSavedBytes * 100) / (double)(totalDataBytes + totalSavedBytes) : 0.0;
  98     dataLogF(&quot;         Total savings %12llu bytes (%5.2f%%)\n&quot;, totalSavedBytes, percentSavings);
  99 
 100     dataLogF(&quot;%8u StringImpl::ref calls\n&quot;, m_refCalls.load());
 101     dataLogF(&quot;%8u StringImpl::deref calls\n&quot;, m_derefCalls.load());
 102 }
 103 #endif
 104 


 105 StringImpl::StaticStringImpl StringImpl::s_emptyAtomString(&quot;&quot;, StringImpl::StringAtom);
 106 
 107 StringImpl::~StringImpl()
 108 {
 109     ASSERT(!isStatic());
 110 
 111     StringView::invalidate(*this);
 112 
 113     STRING_STATS_REMOVE_STRING(*this);
 114 
 115     if (isAtom()) {
 116         ASSERT(!isSymbol());
 117         if (length())
 118             AtomStringImpl::remove(static_cast&lt;AtomStringImpl*&gt;(this));
 119     } else if (isSymbol()) {
 120         auto&amp; symbol = static_cast&lt;SymbolImpl&amp;&gt;(*this);
 121         auto* symbolRegistry = symbol.symbolRegistry();
 122         if (symbolRegistry)
 123             symbolRegistry-&gt;remove(*symbol.asRegisteredSymbolImpl());
 124     }
 125 
 126     BufferOwnership ownership = bufferOwnership();
 127 
 128     if (ownership == BufferInternal)
 129         return;
 130     if (ownership == BufferOwned) {
 131         // We use m_data8, but since it is a union with m_data16 this works either way.
 132         ASSERT(m_data8);
<span class="line-modified"> 133         fastFree(const_cast&lt;LChar*&gt;(m_data8));</span>
 134         return;
 135     }
 136     if (ownership == BufferExternal) {
 137         auto* external = static_cast&lt;ExternalStringImpl*&gt;(this);
 138         external-&gt;freeExternalBuffer(const_cast&lt;LChar*&gt;(m_data8), sizeInBytes());
 139         external-&gt;m_free.~ExternalStringImplFreeFunction();
 140         return;
 141     }
 142 
 143     ASSERT(ownership == BufferSubstring);
 144     ASSERT(substringBuffer());
 145     substringBuffer()-&gt;deref();
 146 }
 147 
 148 void StringImpl::destroy(StringImpl* stringImpl)
 149 {
 150     stringImpl-&gt;~StringImpl();
<span class="line-modified"> 151     fastFree(stringImpl);</span>
 152 }
 153 
 154 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters, unsigned length)
 155 {
 156     ASSERT_WITH_MESSAGE(length, &quot;Use StringImpl::empty() to create an empty string&quot;);
<span class="line-modified"> 157     ASSERT(charactersAreAllASCII&lt;LChar&gt;(reinterpret_cast&lt;const LChar*&gt;(characters), length));</span>
 158     return adoptRef(*new StringImpl(reinterpret_cast&lt;const LChar*&gt;(characters), length, ConstructWithoutCopying));
 159 }
 160 
 161 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters)
 162 {
 163     return createFromLiteral(characters, strlen(characters));
 164 }
 165 
 166 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const UChar* characters, unsigned length)
 167 {
 168     if (!length)
 169         return *empty();
 170     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 171 }
 172 
 173 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const LChar* characters, unsigned length)
 174 {
 175     if (!length)
 176         return *empty();
 177     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 178 }
 179 
 180 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternal(unsigned length, CharacterType*&amp; data)
 181 {
 182     if (!length) {
 183         data = 0;
 184         return *empty();
 185     }
 186     return createUninitializedInternalNonEmpty(length, data);
 187 }
 188 
 189 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternalNonEmpty(unsigned length, CharacterType*&amp; data)
 190 {
 191     ASSERT(length);
 192 
 193     // Allocate a single buffer large enough to contain the StringImpl
 194     // struct as well as the data which it contains. This removes one
 195     // heap allocation from this call.
 196     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 197         CRASH();
<span class="line-modified"> 198     StringImpl* string = static_cast&lt;StringImpl*&gt;(fastMalloc(allocationSize&lt;CharacterType&gt;(length)));</span>
<span class="line-removed"> 199 </span>
 200     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 201     return constructInternal&lt;CharacterType&gt;(*string, length);
 202 }
 203 
 204 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, LChar*&amp; data)
 205 {
 206     return createUninitializedInternal(length, data);
 207 }
 208 
 209 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, UChar*&amp; data)
 210 {
 211     return createUninitializedInternal(length, data);
 212 }
 213 
 214 template&lt;typename CharacterType&gt; inline Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; StringImpl::reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, CharacterType*&amp; data)
 215 {
 216     ASSERT(originalString-&gt;hasOneRef());
 217     ASSERT(originalString-&gt;bufferOwnership() == BufferInternal);
 218 
 219     if (!length) {
 220         data = 0;
 221         return Ref&lt;StringImpl&gt;(*empty());
 222     }
 223 
 224     // Same as createUninitialized() except here we use fastRealloc.
 225     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 226         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 227 
 228     originalString-&gt;~StringImpl();
<span class="line-modified"> 229     StringImpl* string;</span>
<span class="line-modified"> 230     if (!tryFastRealloc(&amp;originalString.leakRef(), allocationSize&lt;CharacterType&gt;(length)).getValue(string))</span>
 231         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 232 
 233     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 234     return constructInternal&lt;CharacterType&gt;(*string, length);
 235 }
 236 
 237 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data)
 238 {
 239     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 240     RELEASE_ASSERT(expectedStringImpl);
 241     return WTFMove(expectedStringImpl.value());
 242 }
 243 
 244 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data)
 245 {
 246     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 247     RELEASE_ASSERT(expectedStringImpl);
 248     return WTFMove(expectedStringImpl.value());
 249 }
 250 
</pre>
<hr />
<pre>
 263 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createInternal(const CharacterType* characters, unsigned length)
 264 {
 265     if (!characters || !length)
 266         return *empty();
 267     CharacterType* data;
 268     auto string = createUninitializedInternalNonEmpty(length, data);
 269     copyCharacters(data, characters, length);
 270     return string;
 271 }
 272 
 273 Ref&lt;StringImpl&gt; StringImpl::create(const UChar* characters, unsigned length)
 274 {
 275     return createInternal(characters, length);
 276 }
 277 
 278 Ref&lt;StringImpl&gt; StringImpl::create(const LChar* characters, unsigned length)
 279 {
 280     return createInternal(characters, length);
 281 }
 282 










 283 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* characters, unsigned length)
 284 {
 285     if (!characters || !length)
 286         return *empty();
 287 
 288     LChar* data;
 289     auto string = createUninitializedInternalNonEmpty(length, data);
 290 
 291     for (size_t i = 0; i &lt; length; ++i) {
 292         if (!isLatin1(characters[i]))
 293             return create(characters, length);
 294         data[i] = static_cast&lt;LChar&gt;(characters[i]);
 295     }
 296 
 297     return string;
 298 }
 299 
 300 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* string)
 301 {
 302     return StringImpl::create8BitIfPossible(string, lengthOfNullTerminatedString(string));
</pre>
<hr />
<pre>
 332 {
 333     if (is8Bit())
 334         return m_data8[i];
 335     if (U16_IS_SINGLE(m_data16[i]))
 336         return m_data16[i];
 337     if (i + 1 &lt; m_length &amp;&amp; U16_IS_LEAD(m_data16[i]) &amp;&amp; U16_IS_TRAIL(m_data16[i + 1]))
 338         return U16_GET_SUPPLEMENTARY(m_data16[i], m_data16[i + 1]);
 339     return 0;
 340 }
 341 
 342 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocale()
 343 {
 344     // Note: At one time this was a hot function in the Dromaeo benchmark, specifically the
 345     // no-op code path that may return ourself if we find no upper case letters and no invalid
 346     // ASCII letters.
 347 
 348     // First scan the string for uppercase and non-ASCII characters:
 349     if (is8Bit()) {
 350         for (unsigned i = 0; i &lt; m_length; ++i) {
 351             LChar character = m_data8[i];
<span class="line-modified"> 352             if (UNLIKELY((character &amp; ~0x7F) || isASCIIUpper(character)))</span>
 353                 return convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(i);
 354         }
 355 
 356         return *this;
 357     }
 358 
 359     bool noUpper = true;
 360     unsigned ored = 0;
 361 
 362     for (unsigned i = 0; i &lt; m_length; ++i) {
 363         UChar character = m_data16[i];
 364         if (UNLIKELY(isASCIIUpper(character)))
 365             noUpper = false;
 366         ored |= character;
 367     }
 368     // Nothing to do if the string is all ASCII with no uppercase.
 369     if (noUpper &amp;&amp; !(ored &amp; ~0x7F))
 370         return *this;
 371 
 372     if (!(ored &amp; ~0x7F)) {
</pre>
<hr />
<pre>
 388     UErrorCode status = U_ZERO_ERROR;
 389     int32_t realLength = u_strToLower(data16, length, m_data16, m_length, &quot;&quot;, &amp;status);
 390     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 391         return newImpl;
 392 
 393     newImpl = createUninitialized(realLength, data16);
 394     status = U_ZERO_ERROR;
 395     u_strToLower(data16, realLength, m_data16, m_length, &quot;&quot;, &amp;status);
 396     if (U_FAILURE(status))
 397         return *this;
 398     return newImpl;
 399 }
 400 
 401 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned failingIndex)
 402 {
 403     ASSERT(is8Bit());
 404     LChar* data8;
 405     auto newImpl = createUninitializedInternalNonEmpty(m_length, data8);
 406 
 407     for (unsigned i = 0; i &lt; failingIndex; ++i) {
<span class="line-modified"> 408         ASSERT(!(m_data8[i] &amp; ~0x7F) &amp;&amp; !isASCIIUpper(m_data8[i]));</span>

 409         data8[i] = m_data8[i];
 410     }
 411 
 412     for (unsigned i = failingIndex; i &lt; m_length; ++i) {
 413         LChar character = m_data8[i];
<span class="line-modified"> 414         if (!(character &amp; ~0x7F))</span>
 415             data8[i] = toASCIILower(character);
 416         else {
 417             ASSERT(isLatin1(u_tolower(character)));
 418             data8[i] = static_cast&lt;LChar&gt;(u_tolower(character));
 419         }
 420     }
 421 
 422     return newImpl;
 423 }
 424 
 425 Ref&lt;StringImpl&gt; StringImpl::convertToUppercaseWithoutLocale()
 426 {
 427     // This function could be optimized for no-op cases the way
 428     // convertToLowercaseWithoutLocale() is, but in empirical testing,
 429     // few actual calls to upper() are no-ops, so it wouldn&#39;t be worth
 430     // the extra time for pre-scanning.
 431 
 432     if (m_length &gt; MaxLength)
 433         CRASH();
 434     int32_t length = m_length;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2001 Dirk Mueller ( mueller@kde.org )
<span class="line-modified">   5  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
   6  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
  85     double percent8Bit = m_totalNumberStrings ? ((double)m_number8BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  86     double average8bitLength = m_number8BitStrings ? (double)m_total8BitData / (double)m_number8BitStrings : 0.0;
  87     dataLogF(&quot;%8u (%5.2f%%) 8 bit        %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number8BitStrings.load(), percent8Bit, m_total8BitData.load(), m_total8BitData.load(), average8bitLength);
  88 
  89     double percent16Bit = m_totalNumberStrings ? ((double)m_number16BitStrings * 100) / (double)m_totalNumberStrings : 0.0;
  90     double average16bitLength = m_number16BitStrings ? (double)m_total16BitData / (double)m_number16BitStrings : 0.0;
  91     dataLogF(&quot;%8u (%5.2f%%) 16 bit       %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_number16BitStrings.load(), percent16Bit, m_total16BitData.load(), m_total16BitData * 2, average16bitLength);
  92 
  93     double averageLength = m_totalNumberStrings ? (double)totalNumberCharacters / (double)m_totalNumberStrings : 0.0;
  94     unsigned long long totalDataBytes = m_total8BitData + m_total16BitData * 2;
  95     dataLogF(&quot;%8u Total                 %12llu chars  %12llu bytes  avg length %6.1f\n&quot;, m_totalNumberStrings.load(), totalNumberCharacters, totalDataBytes, averageLength);
  96     unsigned long long totalSavedBytes = m_total8BitData;
  97     double percentSavings = totalSavedBytes ? ((double)totalSavedBytes * 100) / (double)(totalDataBytes + totalSavedBytes) : 0.0;
  98     dataLogF(&quot;         Total savings %12llu bytes (%5.2f%%)\n&quot;, totalSavedBytes, percentSavings);
  99 
 100     dataLogF(&quot;%8u StringImpl::ref calls\n&quot;, m_refCalls.load());
 101     dataLogF(&quot;%8u StringImpl::deref calls\n&quot;, m_derefCalls.load());
 102 }
 103 #endif
 104 
<span class="line-added"> 105 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StringImpl);</span>
<span class="line-added"> 106 </span>
 107 StringImpl::StaticStringImpl StringImpl::s_emptyAtomString(&quot;&quot;, StringImpl::StringAtom);
 108 
 109 StringImpl::~StringImpl()
 110 {
 111     ASSERT(!isStatic());
 112 
 113     StringView::invalidate(*this);
 114 
 115     STRING_STATS_REMOVE_STRING(*this);
 116 
 117     if (isAtom()) {
 118         ASSERT(!isSymbol());
 119         if (length())
 120             AtomStringImpl::remove(static_cast&lt;AtomStringImpl*&gt;(this));
 121     } else if (isSymbol()) {
 122         auto&amp; symbol = static_cast&lt;SymbolImpl&amp;&gt;(*this);
 123         auto* symbolRegistry = symbol.symbolRegistry();
 124         if (symbolRegistry)
 125             symbolRegistry-&gt;remove(*symbol.asRegisteredSymbolImpl());
 126     }
 127 
 128     BufferOwnership ownership = bufferOwnership();
 129 
 130     if (ownership == BufferInternal)
 131         return;
 132     if (ownership == BufferOwned) {
 133         // We use m_data8, but since it is a union with m_data16 this works either way.
 134         ASSERT(m_data8);
<span class="line-modified"> 135         StringImplMalloc::free(const_cast&lt;LChar*&gt;(m_data8));</span>
 136         return;
 137     }
 138     if (ownership == BufferExternal) {
 139         auto* external = static_cast&lt;ExternalStringImpl*&gt;(this);
 140         external-&gt;freeExternalBuffer(const_cast&lt;LChar*&gt;(m_data8), sizeInBytes());
 141         external-&gt;m_free.~ExternalStringImplFreeFunction();
 142         return;
 143     }
 144 
 145     ASSERT(ownership == BufferSubstring);
 146     ASSERT(substringBuffer());
 147     substringBuffer()-&gt;deref();
 148 }
 149 
 150 void StringImpl::destroy(StringImpl* stringImpl)
 151 {
 152     stringImpl-&gt;~StringImpl();
<span class="line-modified"> 153     StringImplMalloc::free(stringImpl);</span>
 154 }
 155 
 156 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters, unsigned length)
 157 {
 158     ASSERT_WITH_MESSAGE(length, &quot;Use StringImpl::empty() to create an empty string&quot;);
<span class="line-modified"> 159     ASSERT(charactersAreAllASCII(reinterpret_cast&lt;const LChar*&gt;(characters), length));</span>
 160     return adoptRef(*new StringImpl(reinterpret_cast&lt;const LChar*&gt;(characters), length, ConstructWithoutCopying));
 161 }
 162 
 163 Ref&lt;StringImpl&gt; StringImpl::createFromLiteral(const char* characters)
 164 {
 165     return createFromLiteral(characters, strlen(characters));
 166 }
 167 
 168 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const UChar* characters, unsigned length)
 169 {
 170     if (!length)
 171         return *empty();
 172     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 173 }
 174 
 175 Ref&lt;StringImpl&gt; StringImpl::createWithoutCopying(const LChar* characters, unsigned length)
 176 {
 177     if (!length)
 178         return *empty();
 179     return adoptRef(*new StringImpl(characters, length, ConstructWithoutCopying));
 180 }
 181 
 182 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternal(unsigned length, CharacterType*&amp; data)
 183 {
 184     if (!length) {
 185         data = 0;
 186         return *empty();
 187     }
 188     return createUninitializedInternalNonEmpty(length, data);
 189 }
 190 
 191 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createUninitializedInternalNonEmpty(unsigned length, CharacterType*&amp; data)
 192 {
 193     ASSERT(length);
 194 
 195     // Allocate a single buffer large enough to contain the StringImpl
 196     // struct as well as the data which it contains. This removes one
 197     // heap allocation from this call.
 198     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 199         CRASH();
<span class="line-modified"> 200     StringImpl* string = static_cast&lt;StringImpl*&gt;(StringImplMalloc::malloc(allocationSize&lt;CharacterType&gt;(length)));</span>

 201     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 202     return constructInternal&lt;CharacterType&gt;(*string, length);
 203 }
 204 
 205 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, LChar*&amp; data)
 206 {
 207     return createUninitializedInternal(length, data);
 208 }
 209 
 210 Ref&lt;StringImpl&gt; StringImpl::createUninitialized(unsigned length, UChar*&amp; data)
 211 {
 212     return createUninitializedInternal(length, data);
 213 }
 214 
 215 template&lt;typename CharacterType&gt; inline Expected&lt;Ref&lt;StringImpl&gt;, UTF8ConversionError&gt; StringImpl::reallocateInternal(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, CharacterType*&amp; data)
 216 {
 217     ASSERT(originalString-&gt;hasOneRef());
 218     ASSERT(originalString-&gt;bufferOwnership() == BufferInternal);
 219 
 220     if (!length) {
 221         data = 0;
 222         return Ref&lt;StringImpl&gt;(*empty());
 223     }
 224 
 225     // Same as createUninitialized() except here we use fastRealloc.
 226     if (length &gt; maxInternalLength&lt;CharacterType&gt;())
 227         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 228 
 229     originalString-&gt;~StringImpl();
<span class="line-modified"> 230     auto* string = static_cast&lt;StringImpl*&gt;(StringImplMalloc::tryRealloc(&amp;originalString.leakRef(), allocationSize&lt;CharacterType&gt;(length)));</span>
<span class="line-modified"> 231     if (!string)</span>
 232         return makeUnexpected(UTF8ConversionError::OutOfMemory);
 233 
 234     data = string-&gt;tailPointer&lt;CharacterType&gt;();
 235     return constructInternal&lt;CharacterType&gt;(*string, length);
 236 }
 237 
 238 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, LChar*&amp; data)
 239 {
 240     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 241     RELEASE_ASSERT(expectedStringImpl);
 242     return WTFMove(expectedStringImpl.value());
 243 }
 244 
 245 Ref&lt;StringImpl&gt; StringImpl::reallocate(Ref&lt;StringImpl&gt;&amp;&amp; originalString, unsigned length, UChar*&amp; data)
 246 {
 247     auto expectedStringImpl = tryReallocate(WTFMove(originalString), length, data);
 248     RELEASE_ASSERT(expectedStringImpl);
 249     return WTFMove(expectedStringImpl.value());
 250 }
 251 
</pre>
<hr />
<pre>
 264 template&lt;typename CharacterType&gt; inline Ref&lt;StringImpl&gt; StringImpl::createInternal(const CharacterType* characters, unsigned length)
 265 {
 266     if (!characters || !length)
 267         return *empty();
 268     CharacterType* data;
 269     auto string = createUninitializedInternalNonEmpty(length, data);
 270     copyCharacters(data, characters, length);
 271     return string;
 272 }
 273 
 274 Ref&lt;StringImpl&gt; StringImpl::create(const UChar* characters, unsigned length)
 275 {
 276     return createInternal(characters, length);
 277 }
 278 
 279 Ref&lt;StringImpl&gt; StringImpl::create(const LChar* characters, unsigned length)
 280 {
 281     return createInternal(characters, length);
 282 }
 283 
<span class="line-added"> 284 Ref&lt;StringImpl&gt; StringImpl::createStaticStringImpl(const char* characters, unsigned length)</span>
<span class="line-added"> 285 {</span>
<span class="line-added"> 286     const LChar* lcharCharacters = reinterpret_cast&lt;const LChar*&gt;(characters);</span>
<span class="line-added"> 287     ASSERT(charactersAreAllASCII(lcharCharacters, length));</span>
<span class="line-added"> 288     Ref&lt;StringImpl&gt; result = createInternal(lcharCharacters, length);</span>
<span class="line-added"> 289     result-&gt;setHash(StringHasher::computeHashAndMaskTop8Bits(lcharCharacters, length));</span>
<span class="line-added"> 290     result-&gt;m_refCount |= s_refCountFlagIsStaticString;</span>
<span class="line-added"> 291     return result;</span>
<span class="line-added"> 292 }</span>
<span class="line-added"> 293 </span>
 294 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* characters, unsigned length)
 295 {
 296     if (!characters || !length)
 297         return *empty();
 298 
 299     LChar* data;
 300     auto string = createUninitializedInternalNonEmpty(length, data);
 301 
 302     for (size_t i = 0; i &lt; length; ++i) {
 303         if (!isLatin1(characters[i]))
 304             return create(characters, length);
 305         data[i] = static_cast&lt;LChar&gt;(characters[i]);
 306     }
 307 
 308     return string;
 309 }
 310 
 311 Ref&lt;StringImpl&gt; StringImpl::create8BitIfPossible(const UChar* string)
 312 {
 313     return StringImpl::create8BitIfPossible(string, lengthOfNullTerminatedString(string));
</pre>
<hr />
<pre>
 343 {
 344     if (is8Bit())
 345         return m_data8[i];
 346     if (U16_IS_SINGLE(m_data16[i]))
 347         return m_data16[i];
 348     if (i + 1 &lt; m_length &amp;&amp; U16_IS_LEAD(m_data16[i]) &amp;&amp; U16_IS_TRAIL(m_data16[i + 1]))
 349         return U16_GET_SUPPLEMENTARY(m_data16[i], m_data16[i + 1]);
 350     return 0;
 351 }
 352 
 353 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocale()
 354 {
 355     // Note: At one time this was a hot function in the Dromaeo benchmark, specifically the
 356     // no-op code path that may return ourself if we find no upper case letters and no invalid
 357     // ASCII letters.
 358 
 359     // First scan the string for uppercase and non-ASCII characters:
 360     if (is8Bit()) {
 361         for (unsigned i = 0; i &lt; m_length; ++i) {
 362             LChar character = m_data8[i];
<span class="line-modified"> 363             if (UNLIKELY(!isASCII(character) || isASCIIUpper(character)))</span>
 364                 return convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(i);
 365         }
 366 
 367         return *this;
 368     }
 369 
 370     bool noUpper = true;
 371     unsigned ored = 0;
 372 
 373     for (unsigned i = 0; i &lt; m_length; ++i) {
 374         UChar character = m_data16[i];
 375         if (UNLIKELY(isASCIIUpper(character)))
 376             noUpper = false;
 377         ored |= character;
 378     }
 379     // Nothing to do if the string is all ASCII with no uppercase.
 380     if (noUpper &amp;&amp; !(ored &amp; ~0x7F))
 381         return *this;
 382 
 383     if (!(ored &amp; ~0x7F)) {
</pre>
<hr />
<pre>
 399     UErrorCode status = U_ZERO_ERROR;
 400     int32_t realLength = u_strToLower(data16, length, m_data16, m_length, &quot;&quot;, &amp;status);
 401     if (U_SUCCESS(status) &amp;&amp; realLength == length)
 402         return newImpl;
 403 
 404     newImpl = createUninitialized(realLength, data16);
 405     status = U_ZERO_ERROR;
 406     u_strToLower(data16, realLength, m_data16, m_length, &quot;&quot;, &amp;status);
 407     if (U_FAILURE(status))
 408         return *this;
 409     return newImpl;
 410 }
 411 
 412 Ref&lt;StringImpl&gt; StringImpl::convertToLowercaseWithoutLocaleStartingAtFailingIndex8Bit(unsigned failingIndex)
 413 {
 414     ASSERT(is8Bit());
 415     LChar* data8;
 416     auto newImpl = createUninitializedInternalNonEmpty(m_length, data8);
 417 
 418     for (unsigned i = 0; i &lt; failingIndex; ++i) {
<span class="line-modified"> 419         ASSERT(isASCII(m_data8[i]));</span>
<span class="line-added"> 420         ASSERT(!isASCIIUpper(m_data8[i]));</span>
 421         data8[i] = m_data8[i];
 422     }
 423 
 424     for (unsigned i = failingIndex; i &lt; m_length; ++i) {
 425         LChar character = m_data8[i];
<span class="line-modified"> 426         if (isASCII(character))</span>
 427             data8[i] = toASCIILower(character);
 428         else {
 429             ASSERT(isLatin1(u_tolower(character)));
 430             data8[i] = static_cast&lt;LChar&gt;(u_tolower(character));
 431         }
 432     }
 433 
 434     return newImpl;
 435 }
 436 
 437 Ref&lt;StringImpl&gt; StringImpl::convertToUppercaseWithoutLocale()
 438 {
 439     // This function could be optimized for no-op cases the way
 440     // convertToLowercaseWithoutLocale() is, but in empirical testing,
 441     // few actual calls to upper() are no-ops, so it wouldn&#39;t be worth
 442     // the extra time for pre-scanning.
 443 
 444     if (m_length &gt; MaxLength)
 445         CRASH();
 446     int32_t length = m_length;
</pre>
</td>
</tr>
</table>
<center><a href="StringHasher.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/UserAgentStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
  4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
  5  * Copyright (C) 2005-2017 Apple Inc. All rights reserved.
  6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
  7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
  8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
 10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
 11  * Copyright (C) 2012 Google Inc. All rights reserved.
 12  *
 13  * This library is free software; you can redistribute it and/or
 14  * modify it under the terms of the GNU Library General Public
 15  * License as published by the Free Software Foundation; either
 16  * version 2 of the License, or (at your option) any later version.
 17  *
 18  * This library is distributed in the hope that it will be useful,
 19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 21  * Library General Public License for more details.
 22  *
 23  * You should have received a copy of the GNU Library General Public License
 24  * along with this library; see the file COPYING.LIB.  If not, write to
 25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 26  * Boston, MA 02110-1301, USA.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;UserAgentStyle.h&quot;
 31 
 32 #include &quot;Chrome.h&quot;
 33 #include &quot;ChromeClient.h&quot;
 34 #include &quot;FullscreenManager.h&quot;
 35 #include &quot;HTMLAnchorElement.h&quot;
 36 #include &quot;HTMLBRElement.h&quot;
 37 #include &quot;HTMLBodyElement.h&quot;
 38 #include &quot;HTMLDataListElement.h&quot;
 39 #include &quot;HTMLDialogElement.h&quot;
 40 #include &quot;HTMLDivElement.h&quot;
 41 #include &quot;HTMLEmbedElement.h&quot;
 42 #include &quot;HTMLHeadElement.h&quot;
 43 #include &quot;HTMLHtmlElement.h&quot;
 44 #include &quot;HTMLInputElement.h&quot;
 45 #include &quot;HTMLMediaElement.h&quot;
 46 #include &quot;HTMLObjectElement.h&quot;
 47 #include &quot;HTMLSpanElement.h&quot;
 48 #include &quot;MathMLElement.h&quot;
 49 #include &quot;MediaQueryEvaluator.h&quot;
 50 #include &quot;Page.h&quot;
 51 #include &quot;Quirks.h&quot;
 52 #include &quot;RenderTheme.h&quot;
 53 #include &quot;RuleSet.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &quot;SVGElement.h&quot;
 56 #include &quot;StyleSheetContents.h&quot;
 57 #include &quot;UserAgentStyleSheets.h&quot;
 58 #include &lt;wtf/NeverDestroyed.h&gt;
 59 
 60 namespace WebCore {
 61 namespace Style {
 62 
 63 using namespace HTMLNames;
 64 
 65 RuleSet* UserAgentStyle::defaultStyle;
 66 RuleSet* UserAgentStyle::defaultQuirksStyle;
 67 RuleSet* UserAgentStyle::defaultPrintStyle;
 68 unsigned UserAgentStyle::defaultStyleVersion;
 69 
 70 StyleSheetContents* UserAgentStyle::simpleDefaultStyleSheet;
 71 StyleSheetContents* UserAgentStyle::defaultStyleSheet;
 72 StyleSheetContents* UserAgentStyle::quirksStyleSheet;
 73 StyleSheetContents* UserAgentStyle::dialogStyleSheet;
 74 StyleSheetContents* UserAgentStyle::svgStyleSheet;
 75 StyleSheetContents* UserAgentStyle::mathMLStyleSheet;
 76 StyleSheetContents* UserAgentStyle::mediaControlsStyleSheet;
 77 StyleSheetContents* UserAgentStyle::fullscreenStyleSheet;
 78 StyleSheetContents* UserAgentStyle::plugInsStyleSheet;
 79 StyleSheetContents* UserAgentStyle::imageControlsStyleSheet;
 80 StyleSheetContents* UserAgentStyle::mediaQueryStyleSheet;
 81 #if ENABLE(DATALIST_ELEMENT)
 82 StyleSheetContents* UserAgentStyle::dataListStyleSheet;
 83 #endif
 84 #if ENABLE(INPUT_TYPE_COLOR)
 85 StyleSheetContents* UserAgentStyle::colorInputStyleSheet;
 86 #endif
 87 
 88 #if PLATFORM(IOS_FAMILY)
 89 #define DEFAULT_OUTLINE_WIDTH &quot;3px&quot;
 90 #else
 91 #define DEFAULT_OUTLINE_WIDTH &quot;5px&quot;
 92 #endif
 93 
 94 #if HAVE(OS_DARK_MODE_SUPPORT)
 95 #define CSS_DARK_MODE_ADDITION &quot;html{color:text}&quot;
 96 #else
 97 #define CSS_DARK_MODE_ADDITION &quot;&quot;
 98 #endif
 99 
100 // FIXME: It would be nice to use some mechanism that guarantees this is in sync with the real UA stylesheet.
101 static const char simpleUserAgentStyleSheet[] = &quot;html,body,div{display:block}&quot; CSS_DARK_MODE_ADDITION &quot;head{display:none}body{margin:8px}div:focus,span:focus,a:focus{outline:auto &quot; DEFAULT_OUTLINE_WIDTH &quot; -webkit-focus-ring-color}a:any-link{color:-webkit-link;text-decoration:underline}a:any-link:active{color:-webkit-activelink}&quot;;
102 
103 static inline bool elementCanUseSimpleDefaultStyle(const Element&amp; element)
104 {
105     return is&lt;HTMLHtmlElement&gt;(element) || is&lt;HTMLHeadElement&gt;(element)
106         || is&lt;HTMLBodyElement&gt;(element) || is&lt;HTMLDivElement&gt;(element)
107         || is&lt;HTMLSpanElement&gt;(element) || is&lt;HTMLBRElement&gt;(element)
108         || is&lt;HTMLAnchorElement&gt;(element);
109 }
110 
111 static const MediaQueryEvaluator&amp; screenEval()
112 {
113     static NeverDestroyed&lt;const MediaQueryEvaluator&gt; staticScreenEval(String(MAKE_STATIC_STRING_IMPL(&quot;screen&quot;)));
114     return staticScreenEval;
115 }
116 
117 static const MediaQueryEvaluator&amp; printEval()
118 {
119     static NeverDestroyed&lt;const MediaQueryEvaluator&gt; staticPrintEval(String(MAKE_STATIC_STRING_IMPL(&quot;print&quot;)));
120     return staticPrintEval;
121 }
122 
123 static StyleSheetContents* parseUASheet(const String&amp; str)
124 {
125     StyleSheetContents&amp; sheet = StyleSheetContents::create(CSSParserContext(UASheetMode)).leakRef(); // leak the sheet on purpose
126     sheet.parseString(str);
127     return &amp;sheet;
128 }
129 
130 static StyleSheetContents* parseUASheet(const char* characters, unsigned size)
131 {
132     return parseUASheet(String(characters, size));
133 }
134 
135 void UserAgentStyle::initDefaultStyle(const Element* root)
136 {
137     if (!defaultStyle) {
138         if (!root || elementCanUseSimpleDefaultStyle(*root))
139             loadSimpleDefaultStyle();
140         else
141             loadFullDefaultStyle();
142     }
143 }
144 
145 void UserAgentStyle::addToDefaultStyle(StyleSheetContents&amp; sheet)
146 {
147     defaultStyle-&gt;addRulesFromSheet(sheet, screenEval());
148     defaultPrintStyle-&gt;addRulesFromSheet(sheet, printEval());
149 
150     // Build a stylesheet consisting of non-trivial media queries seen in default style.
151     // Rulesets for these can&#39;t be global and need to be built in document context.
152     for (auto&amp; rule : sheet.childRules()) {
153         if (!is&lt;StyleRuleMedia&gt;(*rule))
154             continue;
155         auto&amp; mediaRule = downcast&lt;StyleRuleMedia&gt;(*rule);
156         auto* mediaQuery = mediaRule.mediaQueries();
157         if (!mediaQuery)
158             continue;
159         if (screenEval().evaluate(*mediaQuery, nullptr))
160             continue;
161         if (printEval().evaluate(*mediaQuery, nullptr))
162             continue;
163         mediaQueryStyleSheet-&gt;parserAppendRule(mediaRule.copy());
164     }
165 
166     ++defaultStyleVersion;
167 }
168 
169 void UserAgentStyle::loadFullDefaultStyle()
170 {
171     if (defaultStyle &amp;&amp; !simpleDefaultStyleSheet)
172         return;
173 
174     if (simpleDefaultStyleSheet) {
175         ASSERT(defaultStyle);
176         ASSERT(defaultPrintStyle == defaultStyle);
177         defaultStyle-&gt;deref();
178         simpleDefaultStyleSheet-&gt;deref();
179         simpleDefaultStyleSheet = nullptr;
180     } else {
181         ASSERT(!defaultStyle);
182         defaultQuirksStyle = &amp;RuleSet::create().leakRef();
183     }
184 
185     defaultStyle = &amp;RuleSet::create().leakRef();
186     defaultPrintStyle = &amp;RuleSet::create().leakRef();
187     mediaQueryStyleSheet = &amp;StyleSheetContents::create(CSSParserContext(UASheetMode)).leakRef();
188 
189     // Strict-mode rules.
190     String defaultRules = String(htmlUserAgentStyleSheet, sizeof(htmlUserAgentStyleSheet)) + RenderTheme::singleton().extraDefaultStyleSheet();
191     defaultStyleSheet = parseUASheet(defaultRules);
192     addToDefaultStyle(*defaultStyleSheet);
193 
194     // Quirks-mode rules.
195     String quirksRules = String(quirksUserAgentStyleSheet, sizeof(quirksUserAgentStyleSheet)) + RenderTheme::singleton().extraQuirksStyleSheet();
196     quirksStyleSheet = parseUASheet(quirksRules);
197     defaultQuirksStyle-&gt;addRulesFromSheet(*quirksStyleSheet, screenEval());
198 }
199 
200 void UserAgentStyle::loadSimpleDefaultStyle()
201 {
202     ASSERT(!defaultStyle);
203     ASSERT(!simpleDefaultStyleSheet);
204 
205     defaultStyle = &amp;RuleSet::create().leakRef();
206     // There are no media-specific rules in the simple default style.
207     defaultPrintStyle = defaultStyle;
208     defaultQuirksStyle = &amp;RuleSet::create().leakRef();
209 
210     simpleDefaultStyleSheet = parseUASheet(simpleUserAgentStyleSheet, strlen(simpleUserAgentStyleSheet));
211     defaultStyle-&gt;addRulesFromSheet(*simpleDefaultStyleSheet, screenEval());
212     ++defaultStyleVersion;
213     // No need to initialize quirks sheet yet as there are no quirk rules for elements allowed in simple default style.
214 }
215 
216 void UserAgentStyle::ensureDefaultStyleSheetsForElement(const Element&amp; element)
217 {
218     if (simpleDefaultStyleSheet &amp;&amp; !elementCanUseSimpleDefaultStyle(element)) {
219         loadFullDefaultStyle();
220         ++defaultStyleVersion;
221     }
222 
223     if (is&lt;HTMLElement&gt;(element)) {
224         if (is&lt;HTMLObjectElement&gt;(element) || is&lt;HTMLEmbedElement&gt;(element)) {
225             if (!plugInsStyleSheet &amp;&amp; element.document().page()) {
226                 String plugInsRules = RenderTheme::singleton().extraPlugInsStyleSheet() + element.document().page()-&gt;chrome().client().plugInExtraStyleSheet();
227                 if (plugInsRules.isEmpty())
228                     plugInsRules = String(plugInsUserAgentStyleSheet, sizeof(plugInsUserAgentStyleSheet));
229                 plugInsStyleSheet = parseUASheet(plugInsRules);
230                 addToDefaultStyle(*plugInsStyleSheet);
231             }
232         }
233         else if (is&lt;HTMLDialogElement&gt;(element) &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().dialogElementEnabled()) {
234             if (!dialogStyleSheet) {
235                 dialogStyleSheet = parseUASheet(dialogUserAgentStyleSheet, sizeof(dialogUserAgentStyleSheet));
236                 addToDefaultStyle(*dialogStyleSheet);
237             }
238         }
239 #if ENABLE(VIDEO)
240         else if (is&lt;HTMLMediaElement&gt;(element)) {
241             if (!mediaControlsStyleSheet) {
242                 String mediaRules = RenderTheme::singleton().mediaControlsStyleSheet();
243                 if (mediaRules.isEmpty())
244                     mediaRules = String(mediaControlsUserAgentStyleSheet, sizeof(mediaControlsUserAgentStyleSheet)) + RenderTheme::singleton().extraMediaControlsStyleSheet();
245                 mediaControlsStyleSheet = parseUASheet(mediaRules);
246                 addToDefaultStyle(*mediaControlsStyleSheet);
247 
248             }
249         }
250 #endif // ENABLE(VIDEO)
251 #if ENABLE(SERVICE_CONTROLS)
252         else if (is&lt;HTMLDivElement&gt;(element) &amp;&amp; element.isImageControlsRootElement()) {
253             if (!imageControlsStyleSheet) {
254                 String imageControlsRules = RenderTheme::singleton().imageControlsStyleSheet();
255                 imageControlsStyleSheet = parseUASheet(imageControlsRules);
256                 addToDefaultStyle(*imageControlsStyleSheet);
257             }
258         }
259 #endif // ENABLE(SERVICE_CONTROLS)
260 #if ENABLE(DATALIST_ELEMENT)
261         else if (!dataListStyleSheet &amp;&amp; is&lt;HTMLDataListElement&gt;(element)) {
262             dataListStyleSheet = parseUASheet(RenderTheme::singleton().dataListStyleSheet());
263             addToDefaultStyle(*dataListStyleSheet);
264         }
265 #endif // ENABLE(DATALIST_ELEMENT)
266 #if ENABLE(INPUT_TYPE_COLOR)
267         else if (!colorInputStyleSheet &amp;&amp; is&lt;HTMLInputElement&gt;(element) &amp;&amp; downcast&lt;HTMLInputElement&gt;(element).isColorControl()) {
268             colorInputStyleSheet = parseUASheet(RenderTheme::singleton().colorInputStyleSheet());
269             addToDefaultStyle(*colorInputStyleSheet);
270         }
271 #endif // ENABLE(INPUT_TYPE_COLOR)
272     } else if (is&lt;SVGElement&gt;(element)) {
273         if (!svgStyleSheet) {
274             // SVG rules.
275             svgStyleSheet = parseUASheet(svgUserAgentStyleSheet, sizeof(svgUserAgentStyleSheet));
276             addToDefaultStyle(*svgStyleSheet);
277         }
278     }
279 #if ENABLE(MATHML)
280     else if (is&lt;MathMLElement&gt;(element)) {
281         if (!mathMLStyleSheet) {
282             // MathML rules.
283             mathMLStyleSheet = parseUASheet(mathmlUserAgentStyleSheet, sizeof(mathmlUserAgentStyleSheet));
284             addToDefaultStyle(*mathMLStyleSheet);
285         }
286     }
287 #endif // ENABLE(MATHML)
288 
289 #if ENABLE(FULLSCREEN_API)
290     if (!fullscreenStyleSheet &amp;&amp; element.document().fullscreenManager().isFullscreen()) {
291         StringBuilder fullscreenRules;
292         fullscreenRules.appendCharacters(fullscreenUserAgentStyleSheet, sizeof(fullscreenUserAgentStyleSheet));
293         fullscreenRules.append(RenderTheme::singleton().extraFullScreenStyleSheet());
294         fullscreenStyleSheet = parseUASheet(fullscreenRules.toString());
295         addToDefaultStyle(*fullscreenStyleSheet);
296     }
297 #endif // ENABLE(FULLSCREEN_API)
298 
299     ASSERT(defaultStyle-&gt;features().idsInRules.isEmpty());
300     ASSERT(mathMLStyleSheet || defaultStyle-&gt;features().siblingRules.isEmpty());
301 }
302 
303 } // namespace Style
304 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilderTable.h&quot;
 28 
 29 #include &quot;RenderTableCaption.h&quot;
 30 #include &quot;RenderTableCell.h&quot;
 31 #include &quot;RenderTableCol.h&quot;
 32 #include &quot;RenderTableRow.h&quot;
 33 #include &quot;RenderTreeBuilder.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 RenderTreeBuilder::Table::Table(RenderTreeBuilder&amp; builder)
 38     : m_builder(builder)
 39 {
 40 }
 41 
 42 RenderElement&amp; RenderTreeBuilder::Table::findOrCreateParentForChild(RenderTableRow&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
 43 {
 44     if (is&lt;RenderTableCell&gt;(child))
 45         return parent;
 46 
 47     if (beforeChild &amp;&amp; !beforeChild-&gt;isAnonymous() &amp;&amp; beforeChild-&gt;parent() == &amp;parent) {
 48         auto* previousSibling = beforeChild-&gt;previousSibling();
 49         if (is&lt;RenderTableCell&gt;(previousSibling) &amp;&amp; previousSibling-&gt;isAnonymous()) {
 50             beforeChild = nullptr;
 51             return downcast&lt;RenderElement&gt;(*previousSibling);
 52         }
 53     }
 54 
 55     auto* lastChild = beforeChild ? beforeChild : parent.lastCell();
 56     if (lastChild) {
 57         if (is&lt;RenderTableCell&gt;(*lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeOrAfterContent()) {
 58             if (beforeChild == lastChild)
 59                 beforeChild = downcast&lt;RenderElement&gt;(*lastChild).firstChild();
 60             return downcast&lt;RenderElement&gt;(*lastChild);
 61         }
 62 
 63         // Try to find an anonymous container for the child.
 64         if (auto* lastChildParent = lastChild-&gt;parent()) {
 65             if (lastChildParent-&gt;isAnonymous() &amp;&amp; !lastChildParent-&gt;isBeforeOrAfterContent()) {
 66                 // If beforeChild is inside an anonymous cell, insert into the cell.
 67                 if (!is&lt;RenderTableCell&gt;(*lastChild))
 68                     return *lastChildParent;
 69                 // If beforeChild is inside an anonymous row, insert into the row.
 70                 if (is&lt;RenderTableRow&gt;(*lastChildParent)) {
 71                     auto newCell = RenderTableCell::createAnonymousWithParentRenderer(parent);
 72                     auto&amp; cell = *newCell;
 73                     m_builder.attach(*lastChildParent, WTFMove(newCell), beforeChild);
 74                     beforeChild = nullptr;
 75                     return cell;
 76                 }
 77             }
 78         }
 79     }
 80     auto newCell = RenderTableCell::createAnonymousWithParentRenderer(parent);
 81     auto&amp; cell = *newCell;
 82     m_builder.attach(parent, WTFMove(newCell), beforeChild);
 83     beforeChild = nullptr;
 84     return cell;
 85 }
 86 
 87 RenderElement&amp; RenderTreeBuilder::Table::findOrCreateParentForChild(RenderTableSection&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
 88 {
 89     if (is&lt;RenderTableRow&gt;(child))
 90         return parent;
 91 
 92     auto* lastChild = beforeChild ? beforeChild : parent.lastRow();
 93     if (is&lt;RenderTableRow&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeOrAfterContent()) {
 94         if (beforeChild == lastChild)
 95             beforeChild = downcast&lt;RenderTableRow&gt;(*lastChild).firstCell();
 96         return downcast&lt;RenderElement&gt;(*lastChild);
 97     }
 98 
 99     if (beforeChild &amp;&amp; !beforeChild-&gt;isAnonymous() &amp;&amp; beforeChild-&gt;parent() == &amp;parent) {
100         auto* row = beforeChild-&gt;previousSibling();
101         if (is&lt;RenderTableRow&gt;(row) &amp;&amp; row-&gt;isAnonymous()) {
102             beforeChild = nullptr;
103             return downcast&lt;RenderElement&gt;(*row);
104         }
105     }
106 
107     // If beforeChild is inside an anonymous cell/row, insert into the cell or into
108     // the anonymous row containing it, if there is one.
109     auto* parentCandidate = lastChild;
110     while (parentCandidate &amp;&amp; parentCandidate-&gt;parent()-&gt;isAnonymous() &amp;&amp; !is&lt;RenderTableRow&gt;(*parentCandidate))
111         parentCandidate = parentCandidate-&gt;parent();
112     if (is&lt;RenderTableRow&gt;(parentCandidate) &amp;&amp; parentCandidate-&gt;isAnonymous() &amp;&amp; !parentCandidate-&gt;isBeforeOrAfterContent())
113         return downcast&lt;RenderElement&gt;(*parentCandidate);
114 
115     auto newRow = RenderTableRow::createAnonymousWithParentRenderer(parent);
116     auto&amp; row = *newRow;
117     m_builder.attach(parent, WTFMove(newRow), beforeChild);
118     beforeChild = nullptr;
119     return row;
120 }
121 
122 RenderElement&amp; RenderTreeBuilder::Table::findOrCreateParentForChild(RenderTable&amp; parent, const RenderObject&amp; child, RenderObject*&amp; beforeChild)
123 {
124     if (is&lt;RenderTableCaption&gt;(child) || is&lt;RenderTableCol&gt;(child) || is&lt;RenderTableSection&gt;(child))
125         return parent;
126 
127     auto* lastChild = parent.lastChild();
128     if (!beforeChild &amp;&amp; is&lt;RenderTableSection&gt;(lastChild) &amp;&amp; lastChild-&gt;isAnonymous() &amp;&amp; !lastChild-&gt;isBeforeContent())
129         return downcast&lt;RenderElement&gt;(*lastChild);
130 
131     if (beforeChild &amp;&amp; !beforeChild-&gt;isAnonymous() &amp;&amp; beforeChild-&gt;parent() == &amp;parent) {
132         auto* section = beforeChild-&gt;previousSibling();
133         if (is&lt;RenderTableSection&gt;(section) &amp;&amp; section-&gt;isAnonymous()) {
134             beforeChild = nullptr;
135             return downcast&lt;RenderElement&gt;(*section);
136         }
137     }
138 
139     auto* parentCandidate = beforeChild;
140     while (parentCandidate &amp;&amp; parentCandidate-&gt;parent()-&gt;isAnonymous()
141         &amp;&amp; !is&lt;RenderTableSection&gt;(*parentCandidate)
142         &amp;&amp; parentCandidate-&gt;style().display() != DisplayType::TableCaption
143         &amp;&amp; parentCandidate-&gt;style().display() != DisplayType::TableColumnGroup)
144         parentCandidate = parentCandidate-&gt;parent();
145 
146     if (parentCandidate &amp;&amp; is&lt;RenderTableSection&gt;(*parentCandidate) &amp;&amp; parentCandidate-&gt;isAnonymous() &amp;&amp; !parent.isAfterContent(parentCandidate)) {
147         if (beforeChild == parentCandidate)
148             beforeChild = downcast&lt;RenderTableSection&gt;(*parentCandidate).firstRow();
149         return downcast&lt;RenderElement&gt;(*parentCandidate);
150     }
151 
152     if (beforeChild &amp;&amp; !is&lt;RenderTableSection&gt;(*beforeChild)
153         &amp;&amp; beforeChild-&gt;style().display() != DisplayType::TableCaption
154         &amp;&amp; beforeChild-&gt;style().display() != DisplayType::TableColumnGroup)
155         beforeChild = nullptr;
156 
157     auto newSection = RenderTableSection::createAnonymousWithParentRenderer(parent);
158     auto&amp; section = *newSection;
159     m_builder.attach(parent, WTFMove(newSection), beforeChild);
160     beforeChild = nullptr;
161     return section;
162 }
163 
164 void RenderTreeBuilder::Table::attach(RenderTableRow&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
165 {
166     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
167         beforeChild = m_builder.splitAnonymousBoxesAroundChild(parent, *beforeChild);
168 
169     auto&amp; newChild = *child.get();
170     ASSERT(!beforeChild || is&lt;RenderTableCell&gt;(*beforeChild));
171     m_builder.attachToRenderElement(parent, WTFMove(child), beforeChild);
172     // FIXME: child should always be a RenderTableCell at this point.
173     if (is&lt;RenderTableCell&gt;(newChild))
174         parent.didInsertTableCell(downcast&lt;RenderTableCell&gt;(newChild), beforeChild);
175 }
176 
177 void RenderTreeBuilder::Table::attach(RenderTableSection&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
178 {
179     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
180         beforeChild = m_builder.splitAnonymousBoxesAroundChild(parent, *beforeChild);
181 
182     // FIXME: child should always be a RenderTableRow at this point.
183     if (is&lt;RenderTableRow&gt;(*child.get()))
184         parent.willInsertTableRow(downcast&lt;RenderTableRow&gt;(*child.get()), beforeChild);
185     ASSERT(!beforeChild || is&lt;RenderTableRow&gt;(*beforeChild));
186     m_builder.attachToRenderElement(parent, WTFMove(child), beforeChild);
187 }
188 
189 void RenderTreeBuilder::Table::attach(RenderTable&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
190 {
191     if (beforeChild &amp;&amp; beforeChild-&gt;parent() != &amp;parent)
192         beforeChild = m_builder.splitAnonymousBoxesAroundChild(parent, *beforeChild);
193 
194     auto&amp; newChild = *child.get();
195     if (is&lt;RenderTableSection&gt;(newChild))
196         parent.willInsertTableSection(downcast&lt;RenderTableSection&gt;(newChild), beforeChild);
197     else if (is&lt;RenderTableCol&gt;(newChild))
198         parent.willInsertTableColumn(downcast&lt;RenderTableCol&gt;(newChild), beforeChild);
199 
200     m_builder.attachToRenderElement(parent, WTFMove(child), beforeChild);
201 }
202 
203 bool RenderTreeBuilder::Table::childRequiresTable(const RenderElement&amp; parent, const RenderObject&amp; child)
204 {
205     if (is&lt;RenderTableCol&gt;(child)) {
206         const RenderTableCol&amp; newTableColumn = downcast&lt;RenderTableCol&gt;(child);
207         bool isColumnInColumnGroup = newTableColumn.isTableColumn() &amp;&amp; is&lt;RenderTableCol&gt;(parent);
208         return !is&lt;RenderTable&gt;(parent) &amp;&amp; !isColumnInColumnGroup;
209     }
210     if (is&lt;RenderTableCaption&gt;(child))
211         return !is&lt;RenderTable&gt;(parent);
212 
213     if (is&lt;RenderTableSection&gt;(child))
214         return !is&lt;RenderTable&gt;(parent);
215 
216     if (is&lt;RenderTableRow&gt;(child))
217         return !is&lt;RenderTableSection&gt;(parent);
218 
219     if (is&lt;RenderTableCell&gt;(child))
220         return !is&lt;RenderTableRow&gt;(parent);
221 
222     return false;
223 }
224 
225 void RenderTreeBuilder::Table::collapseAndDestroyAnonymousSiblingRows(RenderTableRow&amp; row)
226 {
227     auto* section = row.section();
228     if (!section)
229         return;
230 
231     // All siblings generated?
232     for (auto* current = section-&gt;firstRow(); current; current = current-&gt;nextRow()) {
233         if (current == &amp;row)
234             continue;
235         if (!current-&gt;isAnonymous())
236             return;
237     }
238 
239     RenderTableRow* rowToInsertInto = nullptr;
240     auto* currentRow = section-&gt;firstRow();
241     while (currentRow) {
242         if (currentRow == &amp;row) {
243             currentRow = currentRow-&gt;nextRow();
244             continue;
245         }
246         if (!rowToInsertInto) {
247             rowToInsertInto = currentRow;
248             currentRow = currentRow-&gt;nextRow();
249             continue;
250         }
251         m_builder.moveAllChildren(*currentRow, *rowToInsertInto, RenderTreeBuilder::NormalizeAfterInsertion::No);
252         auto toDestroy = m_builder.detach(*section, *currentRow);
253         currentRow = currentRow-&gt;nextRow();
254     }
255     if (rowToInsertInto)
256         rowToInsertInto-&gt;setNeedsLayout();
257 }
258 
259 }
    </pre>
  </body>
</html>
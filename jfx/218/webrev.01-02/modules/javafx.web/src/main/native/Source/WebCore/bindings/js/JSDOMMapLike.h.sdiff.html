<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMMapLike.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMNamedConstructor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMMapLike.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSDOMBinding.h&quot;
 29 #include &quot;JSDOMConvert.h&quot;
<span class="line-removed"> 30 #include &quot;JSDOMGuardedObject.h&quot;</span>
 31 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
 32 #include &lt;JavaScriptCore/CommonIdentifiers.h&gt;
<span class="line-removed"> 33 #include &lt;JavaScriptCore/JSMap.h&gt;</span>
 34 
 35 namespace WebCore {
 36 
<span class="line-modified"> 37 JSC::JSMap&amp; createBackingMap(JSC::ExecState&amp;, JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);</span>
<span class="line-modified"> 38 void initializeBackingMap(JSC::VM&amp;, JSC::JSObject&amp;, JSC::JSMap&amp;);</span>
<span class="line-modified"> 39 JSC::JSValue forwardAttributeGetterToBackingMap(JSC::ExecState&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);</span>
<span class="line-modified"> 40 JSC::JSValue forwardFunctionCallToBackingMap(JSC::ExecState&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);</span>
<span class="line-modified"> 41 JSC::JSValue forwardForEachCallToBackingMap(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, JSC::JSObject&amp;);</span>
<span class="line-modified"> 42 </span>
<span class="line-modified"> 43 template&lt;typename WrapperClass&gt; void synchronizeBackingMap(JSC::ExecState&amp;, JSDOMGlobalObject&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 44 template&lt;typename WrapperClass&gt; JSC::JSValue forwardSizeToMapLike(JSC::ExecState&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 45 template&lt;typename WrapperClass&gt; JSC::JSValue forwardEntriesToMapLike(JSC::ExecState&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 46 template&lt;typename WrapperClass&gt; JSC::JSValue forwardKeysToMapLike(JSC::ExecState&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 47 template&lt;typename WrapperClass&gt; JSC::JSValue forwardValuesToMapLike(JSC::ExecState&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 48 template&lt;typename WrapperClass&gt; JSC::JSValue forwardClearToMapLike(JSC::ExecState&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 49 template&lt;typename WrapperClass, typename Callback&gt; JSC::JSValue forwardForEachToMapLike(JSC::ExecState&amp;, WrapperClass&amp;, Callback&amp;&amp;);</span>
<span class="line-modified"> 50 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardGetToMapLike(JSC::ExecState&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 51 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardHasToMapLike(JSC::ExecState&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 52 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardAddToMapLike(JSC::ExecState&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 53 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardDeleteToMapLike(JSC::ExecState&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 54 </span>
<span class="line-modified"> 55 class DOMMapLike final : public DOMGuarded&lt;JSC::JSMap&gt; {</span>
 56 public:
<span class="line-modified"> 57     static Ref&lt;DOMMapLike&gt; create(JSDOMGlobalObject&amp; globalObject, JSC::JSMap&amp; map) { return adoptRef(*new DOMMapLike(globalObject, map)); }</span>


 58 
<span class="line-modified"> 59     template&lt;typename Key, typename Value&gt; void set(typename Key::ParameterType&amp;&amp;, typename Value::ParameterType&amp;&amp;);</span>
<span class="line-modified"> 60 </span>
<span class="line-modified"> 61     JSC::JSMap* backingMap() { return guarded(); }</span>
<span class="line-removed"> 62 </span>
<span class="line-removed"> 63 protected:</span>
<span class="line-removed"> 64     DOMMapLike(JSDOMGlobalObject&amp; globalObject, JSC::JSMap&amp; map) : DOMGuarded&lt;JSC::JSMap&gt;(globalObject, map) { }</span>
 65 };
 66 
<span class="line-modified"> 67 template&lt;typename Key, typename Value&gt; inline void DOMMapLike::set(typename Key::ParameterType&amp;&amp; key, typename Value::ParameterType&amp;&amp; value)</span>


 68 {
<span class="line-removed"> 69     if (isEmpty())</span>
<span class="line-removed"> 70         return;</span>
<span class="line-removed"> 71     auto* state = globalObject()-&gt;globalExec();</span>
<span class="line-removed"> 72     JSC::JSLockHolder locker(state);</span>
<span class="line-removed"> 73     backingMap()-&gt;set(state,</span>
<span class="line-removed"> 74         toJS&lt;Key&gt;(*state, *globalObject(), std::forward&lt;typename Key::ParameterType&gt;(key)),</span>
<span class="line-removed"> 75         toJS&lt;Value&gt;(*state, *globalObject(), std::forward&lt;typename Value::ParameterType&gt;(value)));</span>
 76 }
 77 
<span class="line-modified"> 78 template&lt;typename WrapperClass&gt; inline void synchronizeBackingMap(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, WrapperClass&amp; mapLike)</span>

 79 {
<span class="line-modified"> 80     auto backingMap = mapLike.wrapped().backingMap();</span>
<span class="line-modified"> 81     if (backingMap) {</span>
<span class="line-modified"> 82         ASSERT(backingMap-&gt;backingMap());</span>
<span class="line-modified"> 83         initializeBackingMap(state.vm(), mapLike, *backingMap-&gt;backingMap());</span>
<span class="line-modified"> 84         return;</span>







 85     }
<span class="line-modified"> 86     auto&amp; map = createBackingMap(state, globalObject, mapLike);</span>
<span class="line-removed"> 87     mapLike.wrapped().synchronizeBackingMap(DOMMapLike::create(globalObject, map));</span>
 88 }
 89 
<span class="line-modified"> 90 template&lt;typename WrapperClass&gt; inline JSC::JSValue forwardSizeToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike)</span>
 91 {
<span class="line-modified"> 92     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified"> 93     return forwardAttributeGetterToBackingMap(state, mapLike, vm.propertyNames-&gt;size);</span>
 94 }
 95 
<span class="line-modified"> 96 template&lt;typename WrapperClass&gt; inline JSC::JSValue forwardEntriesToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike)</span>
 97 {
<span class="line-modified"> 98     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified"> 99     return forwardFunctionCallToBackingMap(state, mapLike, vm.propertyNames-&gt;builtinNames().entriesPublicName());</span>
100 }
101 
<span class="line-modified">102 template&lt;typename WrapperClass&gt; inline JSC::JSValue forwardKeysToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike)</span>
103 {
<span class="line-modified">104     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified">105     return forwardFunctionCallToBackingMap(state, mapLike, vm.propertyNames-&gt;builtinNames().keysPublicName());</span>
106 }
107 
<span class="line-modified">108 template&lt;typename WrapperClass&gt; inline JSC::JSValue forwardValuesToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike)</span>
109 {
<span class="line-modified">110     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified">111     return forwardFunctionCallToBackingMap(state, mapLike, vm.propertyNames-&gt;builtinNames().valuesPublicName());</span>
112 }
113 
<span class="line-modified">114 template&lt;typename WrapperClass&gt; inline JSC::JSValue forwardClearToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike)</span>
115 {
116     mapLike.wrapped().clear();
<span class="line-modified">117     return forwardFunctionCallToBackingMap(state, mapLike, state.vm().propertyNames-&gt;clear);</span>

118 }
119 
<span class="line-modified">120 template&lt;typename WrapperClass, typename Callback&gt; inline JSC::JSValue forwardForEachToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike, Callback&amp;&amp;)</span>
121 {
<span class="line-modified">122     return forwardForEachCallToBackingMap(state, *mapLike.globalObject(), mapLike);</span>

123 }
124 
<span class="line-modified">125 template&lt;typename WrapperClass, typename ItemType&gt; inline JSC::JSValue forwardGetToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike, ItemType&amp;&amp;)</span>
126 {
<span class="line-modified">127     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified">128     return forwardFunctionCallToBackingMap(state, mapLike, vm.propertyNames-&gt;builtinNames().getPublicName());</span>
129 }
130 
<span class="line-modified">131 template&lt;typename WrapperClass, typename ItemType&gt; inline JSC::JSValue forwardHasToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike, ItemType&amp;&amp;)</span>
132 {
<span class="line-modified">133     JSC::VM&amp; vm = state.vm();</span>
<span class="line-modified">134     return forwardFunctionCallToBackingMap(state, mapLike, vm.propertyNames-&gt;builtinNames().hasPublicName());</span>
135 }
136 
<span class="line-modified">137 template&lt;typename WrapperClass, typename ItemType&gt; inline JSC::JSValue forwardAddToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike, ItemType&amp;&amp; item)</span>
138 {
<span class="line-modified">139     if (mapLike.wrapped().addFromMapLike(std::forward&lt;ItemType&gt;(item)))</span>
<span class="line-modified">140         forwardFunctionCallToBackingMap(state, mapLike, state.vm().propertyNames-&gt;add);</span>

141     return &amp;mapLike;
142 }
143 
<span class="line-modified">144 template&lt;typename WrapperClass, typename ItemType&gt; inline JSC::JSValue forwardDeleteToMapLike(JSC::ExecState&amp; state, WrapperClass&amp; mapLike, ItemType&amp;&amp; item)</span>
145 {
146     auto isDeleted = mapLike.wrapped().remove(std::forward&lt;ItemType&gt;(item));
147     UNUSED_PARAM(isDeleted);
<span class="line-modified">148     auto result = forwardFunctionCallToBackingMap(state, mapLike, state.vm().propertyNames-&gt;deleteKeyword);</span>



149     ASSERT_UNUSED(result, result.asBoolean() == isDeleted);
150     return result;
151 }
152 
153 }
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;JSDOMBinding.h&quot;
 29 #include &quot;JSDOMConvert.h&quot;

 30 #include &lt;JavaScriptCore/BuiltinNames.h&gt;
 31 #include &lt;JavaScriptCore/CommonIdentifiers.h&gt;

 32 
 33 namespace WebCore {
 34 
<span class="line-modified"> 35 WEBCORE_EXPORT std::pair&lt;bool, std::reference_wrapper&lt;JSC::JSObject&gt;&gt; getBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp; mapLike);</span>
<span class="line-modified"> 36 WEBCORE_EXPORT JSC::JSValue forwardAttributeGetterToBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);</span>
<span class="line-modified"> 37 WEBCORE_EXPORT JSC::JSValue forwardFunctionCallToBackingMap(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, JSC::JSObject&amp;, const JSC::Identifier&amp;);</span>
<span class="line-modified"> 38 WEBCORE_EXPORT JSC::JSValue forwardForEachCallToBackingMap(JSDOMGlobalObject&amp;, JSC::CallFrame&amp;, JSC::JSObject&amp;);</span>
<span class="line-modified"> 39 WEBCORE_EXPORT void clearBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);</span>
<span class="line-modified"> 40 WEBCORE_EXPORT void setToBackingMap(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;, JSC::JSValue, JSC::JSValue);</span>
<span class="line-modified"> 41 </span>
<span class="line-modified"> 42 template&lt;typename WrapperClass&gt; JSC::JSValue forwardSizeToMapLike(JSC::JSGlobalObject&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 43 template&lt;typename WrapperClass&gt; JSC::JSValue forwardEntriesToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 44 template&lt;typename WrapperClass&gt; JSC::JSValue forwardKeysToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 45 template&lt;typename WrapperClass&gt; JSC::JSValue forwardValuesToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 46 template&lt;typename WrapperClass&gt; JSC::JSValue forwardClearToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;);</span>
<span class="line-modified"> 47 template&lt;typename WrapperClass, typename Callback&gt; JSC::JSValue forwardForEachToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, Callback&amp;&amp;);</span>
<span class="line-modified"> 48 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardGetToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 49 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardHasToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 50 template&lt;typename WrapperClass, typename ItemType, typename ValueType&gt; JSC::JSValue forwardSetToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;, ValueType&amp;&amp;);</span>
<span class="line-modified"> 51 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardDeleteToMapLike(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, WrapperClass&amp;, ItemType&amp;&amp;);</span>
<span class="line-modified"> 52 </span>
<span class="line-modified"> 53 class DOMMapAdapter {</span>
 54 public:
<span class="line-modified"> 55     DOMMapAdapter(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);</span>
<span class="line-added"> 56     template&lt;typename IDLKeyType, typename IDLValueType&gt; void set(typename IDLKeyType::ParameterType, typename IDLValueType::ParameterType);</span>
<span class="line-added"> 57     void clear();</span>
 58 
<span class="line-modified"> 59 private:</span>
<span class="line-modified"> 60     JSC::JSGlobalObject&amp; m_lexicalGlobalObject;</span>
<span class="line-modified"> 61     JSC::JSObject&amp; m_backingMap;</span>



 62 };
 63 
<span class="line-modified"> 64 inline DOMMapAdapter::DOMMapAdapter(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSObject&amp; backingMap)</span>
<span class="line-added"> 65     : m_lexicalGlobalObject(lexicalGlobalObject)</span>
<span class="line-added"> 66     , m_backingMap(backingMap)</span>
 67 {







 68 }
 69 
<span class="line-modified"> 70 template&lt;typename IDLKeyType, typename IDLValueType&gt;</span>
<span class="line-added"> 71 void DOMMapAdapter::set(typename IDLKeyType::ParameterType key, typename IDLValueType::ParameterType value)</span>
 72 {
<span class="line-modified"> 73     JSC::JSLockHolder locker(&amp;m_lexicalGlobalObject);</span>
<span class="line-modified"> 74     auto jsKey = toJS&lt;IDLKeyType&gt;(m_lexicalGlobalObject, *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;m_lexicalGlobalObject), std::forward&lt;typename IDLKeyType::ParameterType&gt;(key));</span>
<span class="line-modified"> 75     auto jsValue = toJS&lt;IDLValueType&gt;(m_lexicalGlobalObject, *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;m_lexicalGlobalObject), std::forward&lt;typename IDLValueType::ParameterType&gt;(value));</span>
<span class="line-modified"> 76     setToBackingMap(m_lexicalGlobalObject, m_backingMap, jsKey, jsValue);</span>
<span class="line-modified"> 77 }</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79 template&lt;typename WrapperClass&gt; JSC::JSObject&amp; getAndInitializeBackingMap(JSC::JSGlobalObject&amp; lexicalGlobalObject, WrapperClass&amp; mapLike)</span>
<span class="line-added"> 80 {</span>
<span class="line-added"> 81     auto pair = getBackingMap(lexicalGlobalObject, mapLike);</span>
<span class="line-added"> 82     if (pair.first) {</span>
<span class="line-added"> 83         DOMMapAdapter adapter { lexicalGlobalObject, pair.second.get() };</span>
<span class="line-added"> 84         mapLike.wrapped().initializeMapLike(adapter);</span>
 85     }
<span class="line-modified"> 86     return pair.second.get();</span>

 87 }
 88 
<span class="line-modified"> 89 template&lt;typename WrapperClass&gt; JSC::JSValue forwardSizeToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, WrapperClass&amp; mapLike)</span>
 90 {
<span class="line-modified"> 91     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified"> 92     return forwardAttributeGetterToBackingMap(lexicalGlobalObject, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;size);</span>
 93 }
 94 
<span class="line-modified"> 95 template&lt;typename WrapperClass&gt; JSC::JSValue forwardEntriesToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)</span>
 96 {
<span class="line-modified"> 97     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified"> 98     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().entriesPublicName());</span>
 99 }
100 
<span class="line-modified">101 template&lt;typename WrapperClass&gt; JSC::JSValue forwardKeysToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)</span>
102 {
<span class="line-modified">103     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">104     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().keysPublicName());</span>
105 }
106 
<span class="line-modified">107 template&lt;typename WrapperClass&gt; JSC::JSValue forwardValuesToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)</span>
108 {
<span class="line-modified">109     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">110     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().valuesPublicName());</span>
111 }
112 
<span class="line-modified">113 template&lt;typename WrapperClass&gt; JSC::JSValue forwardClearToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike)</span>
114 {
115     mapLike.wrapped().clear();
<span class="line-modified">116     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-added">117     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;clear);</span>
118 }
119 
<span class="line-modified">120 template&lt;typename WrapperClass, typename Callback&gt; JSC::JSValue forwardForEachToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, Callback&amp;&amp;)</span>
121 {
<span class="line-modified">122     getAndInitializeBackingMap(lexicalGlobalObject, mapLike);</span>
<span class="line-added">123     return forwardForEachCallToBackingMap(*JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), callFrame, mapLike);</span>
124 }
125 
<span class="line-modified">126 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardGetToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp;)</span>
127 {
<span class="line-modified">128     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">129     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().getPublicName());</span>
130 }
131 
<span class="line-modified">132 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardHasToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp;)</span>
133 {
<span class="line-modified">134     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">135     return forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;builtinNames().hasPublicName());</span>
136 }
137 
<span class="line-modified">138 template&lt;typename WrapperClass, typename KeyType, typename ValueType&gt; JSC::JSValue forwardSetToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, KeyType&amp;&amp; key, ValueType&amp;&amp; value)</span>
139 {
<span class="line-modified">140     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-modified">141     mapLike.wrapped().setFromMapLike(std::forward&lt;KeyType&gt;(key), std::forward&lt;ValueType&gt;(value));</span>
<span class="line-added">142     forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;set);</span>
143     return &amp;mapLike;
144 }
145 
<span class="line-modified">146 template&lt;typename WrapperClass, typename ItemType&gt; JSC::JSValue forwardDeleteToMapLike(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, WrapperClass&amp; mapLike, ItemType&amp;&amp; item)</span>
147 {
148     auto isDeleted = mapLike.wrapped().remove(std::forward&lt;ItemType&gt;(item));
149     UNUSED_PARAM(isDeleted);
<span class="line-modified">150 </span>
<span class="line-added">151     auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
<span class="line-added">152     auto result = forwardFunctionCallToBackingMap(lexicalGlobalObject, callFrame, getAndInitializeBackingMap(lexicalGlobalObject, mapLike), vm.propertyNames-&gt;deleteKeyword);</span>
<span class="line-added">153 </span>
154     ASSERT_UNUSED(result, result.asBoolean() == isDeleted);
155     return result;
156 }
157 
158 }
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMMapLike.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMNamedConstructor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/SingleRootGraph.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/FastMalloc.h&gt;
 29 #include &lt;wtf/GraphNodeWorklist.h&gt;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 #include &lt;wtf/StdLibExtras.h&gt;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &lt;wtf/StringPrintStream.h&gt;</span>
 33 
 34 namespace WTF {
 35 
 36 template &lt;typename Graph&gt;
 37 class SingleRootGraphNode {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 public:
 40     // We use &quot;#root&quot; to refer to the synthetic root we have created.
 41     static const char* rootName() { return &quot;#root&quot;; };
 42 
 43     SingleRootGraphNode(typename Graph::Node node = typename Graph::Node())
 44         : m_node(node)
 45     {
 46     }
 47 
 48     static SingleRootGraphNode root()
 49     {
 50         SingleRootGraphNode result;
 51         result.m_node = 0;
 52         result.m_isRoot = true;
 53         return result;
 54     }
 55 
 56     bool operator==(const SingleRootGraphNode&amp; other) const
 57     {
 58         return m_node == other.m_node
 59             &amp;&amp; m_isRoot == other.m_isRoot;
 60     }
 61 
 62     bool operator!=(const SingleRootGraphNode&amp; other) const
 63     {
 64         return !(*this == other);
 65     }
 66 
 67     explicit operator bool() const { return *this != SingleRootGraphNode(); }
 68 
 69     bool isRoot() const
 70     {
 71         return m_isRoot;
 72     }
 73 
 74     typename Graph::Node node() const
 75     {
 76         ASSERT(!m_isRoot);
 77         return m_node;
 78     }
 79 
 80 private:
 81     typename Graph::Node m_node;
 82     bool m_isRoot { false };
 83 };
 84 
 85 template &lt;typename Graph&gt;
 86 class SingleRootGraphSet {
 87     WTF_MAKE_FAST_ALLOCATED;
 88     using Node = SingleRootGraphNode&lt;Graph&gt;;
 89 public:
 90     SingleRootGraphSet() = default;
 91 
 92     bool add(const Node&amp; node)
 93     {
 94         if (node.isRoot())
 95             return checkAndSet(m_hasRoot, true);
 96         return m_set.add(node.node());
 97     }
 98 
 99     bool remove(const Node&amp; node)
100     {
101         if (node.isRoot())
102             return checkAndSet(m_hasRoot, false);
103         return m_set.remove(node.node());
104     }
105 
106     bool contains(const Node&amp; node)
107     {
108         if (node.isRoot())
109             return m_hasRoot;
110         return m_set.contains(node.node());
111     }
112 
113     void dump(PrintStream&amp; out) const
114     {
115         if (m_hasRoot)
116             out.print(Node::rootName(), &quot; &quot;);
117         out.print(m_set);
118     }
119 
120 private:
121     typename Graph::Set m_set;
122     bool m_hasRoot { false };
123 };
124 
125 template&lt;typename T, typename Graph&gt;
126 class SingleRootMap {
127     WTF_MAKE_FAST_ALLOCATED;
128     using Node = SingleRootGraphNode&lt;Graph&gt;;
129 public:
130     SingleRootMap(Graph&amp; graph)
131         : m_map(graph.template newMap&lt;T&gt;())
132     {
133     }
134 
135     SingleRootMap(SingleRootMap&amp;&amp; other)
136         : m_map(WTFMove(other.m_map))
137         , m_root(WTFMove(other.m_root))
138     {
139     }
140 
141     void clear()
142     {
143         m_map.clear();
144         m_root = T();
145     }
146 
147     size_t size() const { return m_map.size() + 1; }
148 
149     T&amp; operator[](size_t index)
150     {
151         if (!index)
152             return m_root;
153         return m_map[index - 1];
154     }
155 
156     const T&amp; operator[](size_t index) const
157     {
158         return (*const_cast&lt;SingleRootMap*&gt;(this))[index];
159     }
160 
161     T&amp; operator[](const Node&amp; node)
162     {
163         if (node.isRoot())
164             return m_root;
165         return m_map[node.node()];
166     }
167 
168     const T&amp; operator[](const Node&amp; node) const
169     {
170         return (*const_cast&lt;SingleRootMap*&gt;(this))[node];
171     }
172 
173 private:
174     typename Graph::template Map&lt;T&gt; m_map;
175     T m_root;
176 };
177 
178 template&lt;typename Graph&gt;
179 class SingleRootGraph {
180     WTF_MAKE_NONCOPYABLE(SingleRootGraph);
181     WTF_MAKE_FAST_ALLOCATED;
182 public:
183 
184     using Node = SingleRootGraphNode&lt;Graph&gt;;
185     using Set = SingleRootGraphSet&lt;Graph&gt;;
186     template &lt;typename T&gt; using Map = SingleRootMap&lt;T, Graph&gt;;
187     using List = Vector&lt;Node, 4&gt;;
188 
189     SingleRootGraph(Graph&amp; graph)
190         : m_graph(graph)
191     {
192         for (typename Graph::Node realRoot : m_graph.roots()) {
193             ASSERT(m_graph.predecessors(realRoot).isEmpty());
194             m_rootSuccessorList.append(realRoot);
195             m_rootSuccessorSet.add(realRoot);
196         }
197         ASSERT(m_rootSuccessorList.size());
198     }
199 
200     Node root() const { return Node::root(); }
201 
202     template&lt;typename T&gt;
203     Map&lt;T&gt; newMap() { return Map&lt;T&gt;(m_graph); }
204 
205     List successors(const Node&amp; node) const
206     {
207         assertIsConsistent();
208 
209         if (node.isRoot())
210             return m_rootSuccessorList;
211         List result;
212         for (typename Graph::Node successor : m_graph.successors(node.node()))
213             result.append(successor);
214         return result;
215     }
216 
217     List predecessors(const Node&amp; node) const
218     {
219         assertIsConsistent();
220 
221         if (node.isRoot())
222             return List { };
223 
224         if (m_rootSuccessorSet.contains(node.node())) {
225             ASSERT(m_graph.predecessors(node.node()).isEmpty());
226             return List { root() };
227         }
228 
229         List result;
230         for (typename Graph::Node predecessor : m_graph.predecessors(node.node()))
231             result.append(predecessor);
232         return result;
233     }
234 
235     unsigned index(const Node&amp; node) const
236     {
237         if (node.isRoot())
238             return 0;
239         return m_graph.index(node.node()) + 1;
240     }
241 
242     Node node(unsigned index) const
243     {
244         if (!index)
245             return root();
246         return m_graph.node(index - 1);
247     }
248 
249     unsigned numNodes() const
250     {
251         return m_graph.numNodes() + 1;
252     }
253 
254     CString dump(Node node) const
255     {
256         StringPrintStream out;
257         if (!node)
258             out.print(&quot;&lt;null&gt;&quot;);
259         else if (node.isRoot())
260             out.print(Node::rootName());
261         else
262             out.print(m_graph.dump(node.node()));
263         return out.toCString();
264     }
265 
266     void dump(PrintStream&amp; out) const
267     {
268         for (unsigned i = 0; i &lt; numNodes(); ++i) {
269             Node node = this-&gt;node(i);
270             if (!node)
271                 continue;
272             out.print(dump(node), &quot;:\n&quot;);
273             out.print(&quot;    Preds: &quot;);
274             CommaPrinter comma;
275             for (Node predecessor : predecessors(node))
276                 out.print(comma, dump(predecessor));
277             out.print(&quot;\n&quot;);
278             out.print(&quot;    Succs: &quot;);
279             comma = CommaPrinter();
280             for (Node successor : successors(node))
281                 out.print(comma, dump(successor));
282             out.print(&quot;\n&quot;);
283         }
284     }
285 
286 private:
287     ALWAYS_INLINE void assertIsConsistent() const
288     {
<a name="2" id="anc2"></a><span class="line-modified">289 #if ASSERT_ENABLED</span>
290         // We expect the roots() function to be idempotent while we&#39;re alive so we can cache
291         // the result in the constructor. If a user of this changes the result of its roots()
292         // function, it&#39;s expected that the user will create a new instance of this class.
293         List rootSuccessorList;
294         for (typename Graph::Node realRoot : m_graph.roots()) {
295             ASSERT(m_graph.predecessors(realRoot).isEmpty());
296             rootSuccessorList.append(realRoot);
297         }
298         ASSERT(rootSuccessorList.size());
299         ASSERT(rootSuccessorList == m_rootSuccessorList);
300 #endif
301     }
302 
303     Graph&amp; m_graph;
304     List m_rootSuccessorList;
305     typename Graph::Set m_rootSuccessorSet;
306 };
307 
308 } // namespace WTF
309 
310 using WTF::SingleRootGraph;
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITArithmetic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITBitAndGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITArithmetic32_64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 
 32 #include &quot;CodeBlock.h&quot;
 33 #include &quot;JITInlines.h&quot;
 34 #include &quot;JSArray.h&quot;
 35 #include &quot;JSFunction.h&quot;
 36 #include &quot;Interpreter.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;ResultType.h&quot;
 39 #include &quot;SlowPathCall.h&quot;
 40 
 41 
 42 namespace JSC {
 43 
 44 template &lt;typename Op&gt;
 45 void JIT::emit_compareAndJump(const Instruction* instruction, RelationalCondition condition)
 46 {
 47     JumpList notInt32Op1;
 48     JumpList notInt32Op2;
 49 
 50     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified"> 51     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified"> 52     int op2 = bytecode.m_rhs.offset();</span>
 53     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
 54 
 55     // Character less.
 56     if (isOperandConstantChar(op1)) {
 57         emitLoad(op2, regT1, regT0);
 58         addSlowCase(branchIfNotCell(regT1));
 59         JumpList failures;
 60         emitLoadCharacterString(regT0, regT0, failures);
 61         addSlowCase(failures);
 62         addJump(branch32(commute(condition), regT0, Imm32(asString(getConstantOperand(op1))-&gt;tryGetValue()[0])), target);
 63         return;
 64     }
 65     if (isOperandConstantChar(op2)) {
 66         emitLoad(op1, regT1, regT0);
 67         addSlowCase(branchIfNotCell(regT1));
 68         JumpList failures;
 69         emitLoadCharacterString(regT0, regT0, failures);
 70         addSlowCase(failures);
 71         addJump(branch32(condition, regT0, Imm32(asString(getConstantOperand(op2))-&gt;tryGetValue()[0])), target);
 72         return;
</pre>
<hr />
<pre>
 85         notInt32Op2.append(branchIfNotInt32(regT3));
 86         addJump(branch32(condition, regT0, regT2), target);
 87     }
 88 
 89     if (!supportsFloatingPoint()) {
 90         addSlowCase(notInt32Op1);
 91         addSlowCase(notInt32Op2);
 92         return;
 93     }
 94     Jump end = jump();
 95 
 96     // Double less.
 97     emitBinaryDoubleOp&lt;Op&gt;(instruction, OperandTypes(), notInt32Op1, notInt32Op2, !isOperandConstantInt(op1), isOperandConstantInt(op1) || !isOperandConstantInt(op2));
 98     end.link(this);
 99 }
100 
101 template &lt;typename Op&gt;
102 void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
103 {
104     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">105     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">106     int op2 = bytecode.m_rhs.offset();</span>
107     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
108 
109     if (isOperandConstantInt(op1)) {
110         emitLoad(op2, regT3, regT2);
111         addJump(branch32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32())), target);
112     } else if (isOperandConstantInt(op2)) {
113         emitLoad(op1, regT1, regT0);
114         addJump(branch32(condition, regT0, Imm32(getConstantOperand(op2).asInt32())), target);
115     } else {
116         emitLoad2(op1, regT1, regT0, op2, regT3, regT2);
117         addJump(branch32(condition, regT0, regT2), target);
118     }
119 }
120 
121 template &lt;typename Op&gt;
122 void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
123 {
124     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">125     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">126     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">127     int op2 = bytecode.m_rhs.offset();</span>
128 
129     if (isOperandConstantInt(op1)) {
130         emitLoad(op2, regT3, regT2);
131         compare32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32()), regT0);
132     } else if (isOperandConstantInt(op2)) {
133         emitLoad(op1, regT1, regT0);
134         compare32(condition, regT0, Imm32(getConstantOperand(op2).asInt32()), regT0);
135     } else {
136         emitLoad2(op1, regT1, regT0, op2, regT3, regT2);
137         compare32(condition, regT0, regT2, regT0);
138     }
139     emitStoreBool(dst, regT0);
140 }
141 
142 template &lt;typename Op&gt;
<span class="line-modified">143 void JIT::emit_compareAndJumpSlow(const Instruction *instruction, DoubleCondition, size_t (JIT_OPERATION *operation)(ExecState*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
144 {
145     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">146     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">147     int op2 = bytecode.m_rhs.offset();</span>
148     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
149 
150     linkAllSlowCases(iter);
151 
152     emitLoad(op1, regT1, regT0);
153     emitLoad(op2, regT3, regT2);
<span class="line-modified">154     callOperation(operation, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
155     emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
156 }
157 
158 void JIT::emit_op_unsigned(const Instruction* currentInstruction)
159 {
160     auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">161     int result = bytecode.m_dst.offset();</span>
<span class="line-modified">162     int op1 = bytecode.m_operand.offset();</span>
163 
164     emitLoad(op1, regT1, regT0);
165 
166     addSlowCase(branchIfNotInt32(regT1));
167     addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
168     emitStoreInt32(result, regT0, result == op1);
169 }
170 
171 void JIT::emit_op_inc(const Instruction* currentInstruction)
172 {
173     auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">174     int srcDst = bytecode.m_srcDst.offset();</span>
175 
176     emitLoad(srcDst, regT1, regT0);
177 
178     addSlowCase(branchIfNotInt32(regT1));
179     addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
180     emitStoreInt32(srcDst, regT0, true);
181 }
182 
183 void JIT::emit_op_dec(const Instruction* currentInstruction)
184 {
185     auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">186     int srcDst = bytecode.m_srcDst.offset();</span>
187 
188     emitLoad(srcDst, regT1, regT0);
189 
190     addSlowCase(branchIfNotInt32(regT1));
191     addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
192     emitStoreInt32(srcDst, regT0, true);
193 }
194 
195 template &lt;typename Op&gt;
196 void JIT::emitBinaryDoubleOp(const Instruction *instruction, OperandTypes types, JumpList&amp; notInt32Op1, JumpList&amp; notInt32Op2, bool op1IsInRegisters, bool op2IsInRegisters)
197 {
198     JumpList end;
199 
200     auto bytecode = instruction-&gt;as&lt;Op&gt;();
201     int opcodeID = Op::opcodeID;
202     int target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-modified">203     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-modified">204     int op2 = bytecode.m_rhs.offset();</span>
205 
206     if (!notInt32Op1.empty()) {
207         // Double case 1: Op1 is not int32; Op2 is unknown.
208         notInt32Op1.link(this);
209 
210         ASSERT(op1IsInRegisters);
211 
212         // Verify Op1 is double.
213         if (!types.first().definitelyIsNumber())
214             addSlowCase(branch32(Above, regT1, TrustedImm32(JSValue::LowestTag)));
215 
216         if (!op2IsInRegisters)
217             emitLoad(op2, regT3, regT2);
218 
219         Jump doubleOp2 = branch32(Below, regT3, TrustedImm32(JSValue::LowestTag));
220 
221         if (!types.second().definitelyIsNumber())
222             addSlowCase(branchIfNotInt32(regT3));
223 
224         convertInt32ToDouble(regT2, fpRegT0);
</pre>
<hr />
<pre>
317                 addJump(branchDouble(DoubleGreaterThanOrEqualOrUnordered, fpRegT1, fpRegT0), target);
318                 break;
319             case op_jngreatereq:
320                 emitLoadDouble(op2, fpRegT1);
321                 addJump(branchDouble(DoubleGreaterThanOrUnordered, fpRegT1, fpRegT0), target);
322                 break;
323             default:
324                 RELEASE_ASSERT_NOT_REACHED();
325         }
326     }
327 
328     end.link(this);
329 }
330 
331 // Mod (%)
332 
333 /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
334 
335 void JIT::emit_op_mod(const Instruction* currentInstruction)
336 {
<span class="line-removed">337 #if CPU(X86)</span>
<span class="line-removed">338     auto bytecode = instruction-&gt;as&lt;OpMod&gt;();</span>
<span class="line-removed">339     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed">340     int op1 = bytecode.m_lhs.offset();</span>
<span class="line-removed">341     int op2 = bytecode.m_rhs.offset();</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     // Make sure registers are correct for x86 IDIV instructions.</span>
<span class="line-removed">344     ASSERT(regT0 == X86Registers::eax);</span>
<span class="line-removed">345     ASSERT(regT1 == X86Registers::edx);</span>
<span class="line-removed">346     ASSERT(regT2 == X86Registers::ecx);</span>
<span class="line-removed">347     ASSERT(regT3 == X86Registers::ebx);</span>
<span class="line-removed">348 </span>
<span class="line-removed">349     emitLoad2(op1, regT0, regT3, op2, regT1, regT2);</span>
<span class="line-removed">350     addSlowCase(branchIfNotInt32(regT1));</span>
<span class="line-removed">351     addSlowCase(branchIfNotInt32(regT0));</span>
<span class="line-removed">352 </span>
<span class="line-removed">353     move(regT3, regT0);</span>
<span class="line-removed">354     addSlowCase(branchTest32(Zero, regT2));</span>
<span class="line-removed">355     Jump denominatorNotNeg1 = branch32(NotEqual, regT2, TrustedImm32(-1));</span>
<span class="line-removed">356     addSlowCase(branch32(Equal, regT0, TrustedImm32(-2147483647-1)));</span>
<span class="line-removed">357     denominatorNotNeg1.link(this);</span>
<span class="line-removed">358     x86ConvertToDoubleWord32();</span>
<span class="line-removed">359     x86Div32(regT2);</span>
<span class="line-removed">360     Jump numeratorPositive = branch32(GreaterThanOrEqual, regT3, TrustedImm32(0));</span>
<span class="line-removed">361     addSlowCase(branchTest32(Zero, regT1));</span>
<span class="line-removed">362     numeratorPositive.link(this);</span>
<span class="line-removed">363     emitStoreInt32(dst, regT1, (op1 == dst || op2 == dst));</span>
<span class="line-removed">364 #else</span>
365     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);
366     slowPathCall.call();
<span class="line-removed">367 #endif</span>
368 }
369 
<span class="line-modified">370 void JIT::emitSlow_op_mod(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
371 {
<span class="line-removed">372 #if CPU(X86)</span>
<span class="line-removed">373     linkAllSlowCases(iter);</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);</span>
<span class="line-removed">376     slowPathCall.call();</span>
<span class="line-removed">377 #else</span>
<span class="line-removed">378     UNUSED_PARAM(currentInstruction);</span>
<span class="line-removed">379     UNUSED_PARAM(iter);</span>
380     // We would have really useful assertions here if it wasn&#39;t for the compiler&#39;s
381     // insistence on attribute noreturn.
382     // RELEASE_ASSERT_NOT_REACHED();
<span class="line-removed">383 #endif</span>
384 }
385 
386 /* ------------------------------ END: OP_MOD ------------------------------ */
387 
388 } // namespace JSC
389 
390 #endif // USE(JSVALUE32_64)
391 #endif // ENABLE(JIT)
</pre>
</td>
<td>
<hr />
<pre>
 31 
 32 #include &quot;CodeBlock.h&quot;
 33 #include &quot;JITInlines.h&quot;
 34 #include &quot;JSArray.h&quot;
 35 #include &quot;JSFunction.h&quot;
 36 #include &quot;Interpreter.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;ResultType.h&quot;
 39 #include &quot;SlowPathCall.h&quot;
 40 
 41 
 42 namespace JSC {
 43 
 44 template &lt;typename Op&gt;
 45 void JIT::emit_compareAndJump(const Instruction* instruction, RelationalCondition condition)
 46 {
 47     JumpList notInt32Op1;
 48     JumpList notInt32Op2;
 49 
 50     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified"> 51     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified"> 52     VirtualRegister op2 = bytecode.m_rhs;</span>
 53     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
 54 
 55     // Character less.
 56     if (isOperandConstantChar(op1)) {
 57         emitLoad(op2, regT1, regT0);
 58         addSlowCase(branchIfNotCell(regT1));
 59         JumpList failures;
 60         emitLoadCharacterString(regT0, regT0, failures);
 61         addSlowCase(failures);
 62         addJump(branch32(commute(condition), regT0, Imm32(asString(getConstantOperand(op1))-&gt;tryGetValue()[0])), target);
 63         return;
 64     }
 65     if (isOperandConstantChar(op2)) {
 66         emitLoad(op1, regT1, regT0);
 67         addSlowCase(branchIfNotCell(regT1));
 68         JumpList failures;
 69         emitLoadCharacterString(regT0, regT0, failures);
 70         addSlowCase(failures);
 71         addJump(branch32(condition, regT0, Imm32(asString(getConstantOperand(op2))-&gt;tryGetValue()[0])), target);
 72         return;
</pre>
<hr />
<pre>
 85         notInt32Op2.append(branchIfNotInt32(regT3));
 86         addJump(branch32(condition, regT0, regT2), target);
 87     }
 88 
 89     if (!supportsFloatingPoint()) {
 90         addSlowCase(notInt32Op1);
 91         addSlowCase(notInt32Op2);
 92         return;
 93     }
 94     Jump end = jump();
 95 
 96     // Double less.
 97     emitBinaryDoubleOp&lt;Op&gt;(instruction, OperandTypes(), notInt32Op1, notInt32Op2, !isOperandConstantInt(op1), isOperandConstantInt(op1) || !isOperandConstantInt(op2));
 98     end.link(this);
 99 }
100 
101 template &lt;typename Op&gt;
102 void JIT::emit_compareUnsignedAndJump(const Instruction* instruction, RelationalCondition condition)
103 {
104     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">105     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">106     VirtualRegister op2 = bytecode.m_rhs;</span>
107     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
108 
109     if (isOperandConstantInt(op1)) {
110         emitLoad(op2, regT3, regT2);
111         addJump(branch32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32())), target);
112     } else if (isOperandConstantInt(op2)) {
113         emitLoad(op1, regT1, regT0);
114         addJump(branch32(condition, regT0, Imm32(getConstantOperand(op2).asInt32())), target);
115     } else {
116         emitLoad2(op1, regT1, regT0, op2, regT3, regT2);
117         addJump(branch32(condition, regT0, regT2), target);
118     }
119 }
120 
121 template &lt;typename Op&gt;
122 void JIT::emit_compareUnsigned(const Instruction* instruction, RelationalCondition condition)
123 {
124     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">125     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">126     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">127     VirtualRegister op2 = bytecode.m_rhs;</span>
128 
129     if (isOperandConstantInt(op1)) {
130         emitLoad(op2, regT3, regT2);
131         compare32(commute(condition), regT2, Imm32(getConstantOperand(op1).asInt32()), regT0);
132     } else if (isOperandConstantInt(op2)) {
133         emitLoad(op1, regT1, regT0);
134         compare32(condition, regT0, Imm32(getConstantOperand(op2).asInt32()), regT0);
135     } else {
136         emitLoad2(op1, regT1, regT0, op2, regT3, regT2);
137         compare32(condition, regT0, regT2, regT0);
138     }
139     emitStoreBool(dst, regT0);
140 }
141 
142 template &lt;typename Op&gt;
<span class="line-modified">143 void JIT::emit_compareAndJumpSlow(const Instruction *instruction, DoubleCondition, size_t (JIT_OPERATION *operation)(JSGlobalObject*, EncodedJSValue, EncodedJSValue), bool invert, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)</span>
144 {
145     auto bytecode = instruction-&gt;as&lt;Op&gt;();
<span class="line-modified">146     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">147     VirtualRegister op2 = bytecode.m_rhs;</span>
148     unsigned target = jumpTarget(instruction, bytecode.m_targetLabel);
149 
150     linkAllSlowCases(iter);
151 
152     emitLoad(op1, regT1, regT0);
153     emitLoad(op2, regT3, regT2);
<span class="line-modified">154     callOperation(operation, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
155     emitJumpSlowToHot(branchTest32(invert ? Zero : NonZero, returnValueGPR), target);
156 }
157 
158 void JIT::emit_op_unsigned(const Instruction* currentInstruction)
159 {
160     auto bytecode = currentInstruction-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified">161     VirtualRegister result = bytecode.m_dst;</span>
<span class="line-modified">162     VirtualRegister op1 = bytecode.m_operand;</span>
163 
164     emitLoad(op1, regT1, regT0);
165 
166     addSlowCase(branchIfNotInt32(regT1));
167     addSlowCase(branch32(LessThan, regT0, TrustedImm32(0)));
168     emitStoreInt32(result, regT0, result == op1);
169 }
170 
171 void JIT::emit_op_inc(const Instruction* currentInstruction)
172 {
173     auto bytecode = currentInstruction-&gt;as&lt;OpInc&gt;();
<span class="line-modified">174     VirtualRegister srcDst = bytecode.m_srcDst;</span>
175 
176     emitLoad(srcDst, regT1, regT0);
177 
178     addSlowCase(branchIfNotInt32(regT1));
179     addSlowCase(branchAdd32(Overflow, TrustedImm32(1), regT0));
180     emitStoreInt32(srcDst, regT0, true);
181 }
182 
183 void JIT::emit_op_dec(const Instruction* currentInstruction)
184 {
185     auto bytecode = currentInstruction-&gt;as&lt;OpDec&gt;();
<span class="line-modified">186     VirtualRegister srcDst = bytecode.m_srcDst;</span>
187 
188     emitLoad(srcDst, regT1, regT0);
189 
190     addSlowCase(branchIfNotInt32(regT1));
191     addSlowCase(branchSub32(Overflow, TrustedImm32(1), regT0));
192     emitStoreInt32(srcDst, regT0, true);
193 }
194 
195 template &lt;typename Op&gt;
196 void JIT::emitBinaryDoubleOp(const Instruction *instruction, OperandTypes types, JumpList&amp; notInt32Op1, JumpList&amp; notInt32Op2, bool op1IsInRegisters, bool op2IsInRegisters)
197 {
198     JumpList end;
199 
200     auto bytecode = instruction-&gt;as&lt;Op&gt;();
201     int opcodeID = Op::opcodeID;
202     int target = jumpTarget(instruction, bytecode.m_targetLabel);
<span class="line-modified">203     VirtualRegister op1 = bytecode.m_lhs;</span>
<span class="line-modified">204     VirtualRegister op2 = bytecode.m_rhs;</span>
205 
206     if (!notInt32Op1.empty()) {
207         // Double case 1: Op1 is not int32; Op2 is unknown.
208         notInt32Op1.link(this);
209 
210         ASSERT(op1IsInRegisters);
211 
212         // Verify Op1 is double.
213         if (!types.first().definitelyIsNumber())
214             addSlowCase(branch32(Above, regT1, TrustedImm32(JSValue::LowestTag)));
215 
216         if (!op2IsInRegisters)
217             emitLoad(op2, regT3, regT2);
218 
219         Jump doubleOp2 = branch32(Below, regT3, TrustedImm32(JSValue::LowestTag));
220 
221         if (!types.second().definitelyIsNumber())
222             addSlowCase(branchIfNotInt32(regT3));
223 
224         convertInt32ToDouble(regT2, fpRegT0);
</pre>
<hr />
<pre>
317                 addJump(branchDouble(DoubleGreaterThanOrEqualOrUnordered, fpRegT1, fpRegT0), target);
318                 break;
319             case op_jngreatereq:
320                 emitLoadDouble(op2, fpRegT1);
321                 addJump(branchDouble(DoubleGreaterThanOrUnordered, fpRegT1, fpRegT0), target);
322                 break;
323             default:
324                 RELEASE_ASSERT_NOT_REACHED();
325         }
326     }
327 
328     end.link(this);
329 }
330 
331 // Mod (%)
332 
333 /* ------------------------------ BEGIN: OP_MOD ------------------------------ */
334 
335 void JIT::emit_op_mod(const Instruction* currentInstruction)
336 {




























337     JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_mod);
338     slowPathCall.call();

339 }
340 
<span class="line-modified">341 void JIT::emitSlow_op_mod(const Instruction*, Vector&lt;SlowCaseEntry&gt;::iterator&amp;)</span>
342 {








343     // We would have really useful assertions here if it wasn&#39;t for the compiler&#39;s
344     // insistence on attribute noreturn.
345     // RELEASE_ASSERT_NOT_REACHED();

346 }
347 
348 /* ------------------------------ END: OP_MOD ------------------------------ */
349 
350 } // namespace JSC
351 
352 #endif // USE(JSVALUE32_64)
353 #endif // ENABLE(JIT)
</pre>
</td>
</tr>
</table>
<center><a href="JITArithmetic.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITBitAndGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
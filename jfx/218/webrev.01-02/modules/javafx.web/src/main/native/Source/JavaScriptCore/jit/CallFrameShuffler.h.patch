diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/CallFrameShuffler.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -103,11 +103,11 @@
         data.numLocals = numLocals();
         data.numPassedArgs = m_numPassedArgs;
         data.callee = getNew(VirtualRegister { CallFrameSlot::callee })->recovery();
         data.args.resize(argCount());
         for (size_t i = 0; i < argCount(); ++i)
-            data.args[i] = getNew(virtualRegisterForArgument(i))->recovery();
+            data.args[i] = getNew(virtualRegisterForArgumentIncludingThis(i))->recovery();
         for (Reg reg = Reg::first(); reg <= Reg::last(); reg = reg.next()) {
             CachedRecovery* cachedRecovery { m_newRegisters[reg] };
             if (!cachedRecovery)
                 continue;
 
@@ -126,11 +126,11 @@
     // this would crash 32bits platforms.
     void setCalleeJSValueRegs(JSValueRegs jsValueRegs)
     {
         ASSERT(isUndecided());
         ASSERT(!getNew(jsValueRegs));
-        CachedRecovery* cachedRecovery { getNew(VirtualRegister(CallFrameSlot::callee)) };
+        CachedRecovery* cachedRecovery { getNew(CallFrameSlot::callee) };
         ASSERT(cachedRecovery);
         addNew(jsValueRegs, cachedRecovery->recovery());
     }
 
     // Ask the suhffler to assume the callee has already be checked to
@@ -139,11 +139,11 @@
     // You obviously must have ensured that this is the case before
     // running any of the prepare methods.
     void assumeCalleeIsCell()
     {
 #if USE(JSVALUE32_64)
-        CachedRecovery& calleeCachedRecovery = *getNew(VirtualRegister(CallFrameSlot::callee));
+        CachedRecovery& calleeCachedRecovery = *getNew(CallFrameSlot::callee);
         switch (calleeCachedRecovery.recovery().technique()) {
         case InPair:
             updateRecovery(
                 calleeCachedRecovery,
                 ValueRecovery::inGPR(
@@ -183,11 +183,11 @@
     // to throw an exception in, or destroyed using
     // CCallHelpers::prepareForTailCallSlow() followed by a tail call.
     void prepareForSlowPath();
 
 private:
-    static const bool verbose = false;
+    static constexpr bool verbose = false;
 
     CCallHelpers& m_jit;
 
     void prepareAny();
 
@@ -410,13 +410,13 @@
     // CachedRecovery means we can trash the current value as we don't
     // care about it.
     RegisterMap<CachedRecovery*> m_registers;
 
 #if USE(JSVALUE64)
-    mutable GPRReg m_tagTypeNumber;
+    mutable GPRReg m_numberTagRegister;
 
-    bool tryAcquireTagTypeNumber();
+    bool tryAcquireNumberTagRegister();
 #endif
 
     // This stores, for each register, information about the recovery
     // for the value that should eventually go into that register. The
     // only registers that have a target recovery will be callee-save
@@ -446,15 +446,15 @@
                     nonTemp = reg;
             }
         }
 
 #if USE(JSVALUE64)
-        if (!nonTemp && m_tagTypeNumber != InvalidGPRReg && check(Reg { m_tagTypeNumber })) {
-            ASSERT(m_lockedRegisters.get(m_tagTypeNumber));
-            m_lockedRegisters.clear(m_tagTypeNumber);
-            nonTemp = Reg { m_tagTypeNumber };
-            m_tagTypeNumber = InvalidGPRReg;
+        if (!nonTemp && m_numberTagRegister != InvalidGPRReg && check(Reg { m_numberTagRegister })) {
+            ASSERT(m_lockedRegisters.get(m_numberTagRegister));
+            m_lockedRegisters.clear(m_numberTagRegister);
+            nonTemp = Reg { m_numberTagRegister };
+            m_numberTagRegister = InvalidGPRReg;
         }
 #endif
         return nonTemp;
     }
 

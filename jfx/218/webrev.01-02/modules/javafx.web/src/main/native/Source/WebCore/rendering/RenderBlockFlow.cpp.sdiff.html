<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 
  27 #include &quot;ComplexLineLayout.h&quot;
  28 #include &quot;Editor.h&quot;
  29 #include &quot;FloatingObjects.h&quot;
  30 #include &quot;Frame.h&quot;
  31 #include &quot;FrameSelection.h&quot;
  32 #include &quot;HTMLElement.h&quot;
  33 #include &quot;HTMLInputElement.h&quot;
  34 #include &quot;HTMLParserIdioms.h&quot;
  35 #include &quot;HTMLTextAreaElement.h&quot;
  36 #include &quot;HitTestLocation.h&quot;
  37 #include &quot;InlineTextBox.h&quot;

  38 #include &quot;LayoutRepainter.h&quot;
  39 #include &quot;Logging.h&quot;
  40 #include &quot;RenderCombineText.h&quot;
  41 #include &quot;RenderFlexibleBox.h&quot;
  42 #include &quot;RenderInline.h&quot;
  43 #include &quot;RenderIterator.h&quot;
  44 #include &quot;RenderLayer.h&quot;
  45 #include &quot;RenderLayoutState.h&quot;
  46 #include &quot;RenderLineBreak.h&quot;
  47 #include &quot;RenderListItem.h&quot;
  48 #include &quot;RenderMarquee.h&quot;
  49 #include &quot;RenderMultiColumnFlow.h&quot;
  50 #include &quot;RenderMultiColumnSet.h&quot;
  51 #include &quot;RenderTableCell.h&quot;
  52 #include &quot;RenderText.h&quot;
  53 #include &quot;RenderTreeBuilder.h&quot;
  54 #include &quot;RenderView.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;SimpleLineLayoutFunctions.h&quot;
  57 #include &quot;SimpleLineLayoutPagination.h&quot;
</pre>
<hr />
<pre>
 135     if (!renderTreeBeingDestroyed()) {
 136         if (firstRootBox()) {
 137             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 138             // because by then we will have nuked the line boxes.
 139             if (isSelectionBorder())
 140                 frame().selection().setNeedsSelectionUpdate();
 141 
 142             // If we are an anonymous block, then our line boxes might have children
 143             // that will outlast this block. In the non-anonymous block case those
 144             // children will be destroyed by the time we return from this function.
 145             if (isAnonymousBlock()) {
 146                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 147                     while (auto childBox = box-&gt;firstChild())
 148                         childBox-&gt;removeFromParent();
 149                 }
 150             }
 151         } else if (parent())
 152             parent()-&gt;dirtyLinesFromChangedChild(*this);
 153     }
 154 
<span class="line-modified"> 155     if (m_complexLineLayout)</span>
<span class="line-modified"> 156         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
 157 
 158     blockWillBeDestroyed();
 159 
 160     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 161     RenderBox::willBeDestroyed();
 162 }
 163 
 164 RenderMultiColumnFlow* RenderBlockFlow::multiColumnFlowSlowCase() const
 165 {
 166     return rareBlockFlowData()-&gt;m_multiColumnFlow.get();
 167 }
 168 
 169 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 170 {
 171     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 172     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 173     // to avoid floats.
 174     parentHasFloats = false;
 175     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 176         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
</pre>
<hr />
<pre>
 455     return false;
 456 }
 457 
 458 void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)
 459 {
 460     ASSERT(needsLayout());
 461 
 462     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 463         return;
 464 
 465     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 466 
 467     if (recomputeLogicalWidthAndColumnWidth())
 468         relayoutChildren = true;
 469 
 470     rebuildFloatingObjectSetFromIntrudingFloats();
 471 
 472     LayoutUnit previousHeight = logicalHeight();
 473     // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
 474     // for consistency with other render classes?
<span class="line-modified"> 475     setLogicalHeight(0);</span>
 476 
 477     bool pageLogicalHeightChanged = false;
 478     checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
 479 
 480     LayoutUnit repaintLogicalTop;
 481     LayoutUnit repaintLogicalBottom;
 482     LayoutUnit maxFloatLogicalBottom;
 483     const RenderStyle&amp; styleToUse = style();
 484     {
 485         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 486 
 487         preparePaginationBeforeBlockLayout(relayoutChildren);
 488 
 489         // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track
 490         // our current maximal positive and negative margins. These values are used when we
 491         // are collapsed with adjacent blocks, so for example, if you have block A and B
 492         // collapsing together, then you&#39;d take the maximal positive margin from both A and B
 493         // and subtract it from the maximal negative margin from both A and B to get the
 494         // true collapsed margin. This algorithm is recursive, so when we finish layout()
 495         // our block knows its current maximal positive/negative values.
</pre>
<hr />
<pre>
 650             adjustPositionedBlock(child, marginInfo);
 651             continue;
 652         }
 653         if (child.isFloating()) {
 654             insertFloatingObject(child);
 655             adjustFloatingBlock(marginInfo);
 656             continue;
 657         }
 658 
 659         // Lay out the child.
 660         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 661     }
 662 
 663     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 664     // determining the correct collapsed bottom margin information.
 665     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 666 }
 667 
 668 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 669 {












 670     if (lineLayoutPath() == UndeterminedPath)
<span class="line-modified"> 671         setLineLayoutPath(SimpleLineLayout::canUseFor(*this) ? SimpleLinesPath : LineBoxesPath);</span>
 672 
 673     if (lineLayoutPath() == SimpleLinesPath) {
 674         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 675         return;
 676     }
 677 
<span class="line-modified"> 678     m_simpleLineLayout = nullptr;</span>





 679 
<span class="line-modified"> 680     if (!m_complexLineLayout)</span>
<span class="line-modified"> 681         m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
 682 
<span class="line-modified"> 683     m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
 684 }
 685 
 686 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 687 {
 688     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 689     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 690 
 691     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 692     child.computeAndSetBlockDirectionMargins(*this);
 693 
 694     // Try to guess our correct logical top position. In most cases this guess will
 695     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 696     // will we have to potentially relayout.
 697     LayoutUnit estimateWithoutPagination;
 698     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 699 
 700     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 701     LayoutRect oldRect = child.frameRect();
 702     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 703 
<span class="line-modified"> 704 #if !ASSERT_DISABLED</span>
 705     LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
 706 #endif
 707     // Position the child as though it didn&#39;t collapse with the top.
 708     setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
 709     estimateFragmentRangeForBoxChild(child);
 710 
 711     RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 712     bool markDescendantsWithFloats = false;
 713     if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 714         markDescendantsWithFloats = true;
 715     else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))
 716         // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for
 717         // very large elements. If it does the comparison with oldLogicalTop might yield a
 718         // false negative as adding and removing margins, borders etc from a saturated number
 719         // might yield incorrect results. If this is the case always mark for layout.
 720         markDescendantsWithFloats = true;
 721     else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) {
 722         // If an element might be affected by the presence of floats, then always mark it for
 723         // layout.
 724         LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());
</pre>
<hr />
<pre>
1757         // line and computing a new height that excludes anything we consider &quot;blank space&quot;. We will discard margins, descent, and even overflow. If we are
1758         // able to fit with the blank space and overflow excluded, we will give the line its own page with the highest non-blank element being aligned with the
1759         // top of the page.
1760         // FIXME: We are still honoring gigantic margins, which does leave open the possibility of blank pages caused by this heuristic. It remains to be seen whether or not
1761         // this will be a real-world issue. For now we don&#39;t try to deal with this problem.
1762         logicalOffset = intMaxForLayoutUnit;
1763         logicalBottom = intMinForLayoutUnit;
1764         lineBox-&gt;computeReplacedAndTextLineTopAndBottom(logicalOffset, logicalBottom);
1765         lineHeight = logicalBottom - logicalOffset;
1766         if (logicalOffset == intMaxForLayoutUnit || lineHeight &gt; pageLogicalHeight) {
1767             // Give up. We&#39;re genuinely too big even after excluding blank space and overflow.
1768             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1769             return;
1770         }
1771         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1772     }
1773 
1774     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1775     overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
1776 
<span class="line-modified">1777     int lineIndex = lineCount(lineBox);</span>
1778     if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
1779         if (lineBreakToAvoidWidow() == lineIndex)
1780             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1781         // If we have a non-uniform page height, then we have to shift further possibly.
1782         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
1783             return;
1784         if (lineHeight &gt; pageLogicalHeight) {
1785             // Split the top margin in order to avoid splitting the visible part of the line.
1786             remainingLogicalHeight -= std::min(lineHeight - pageLogicalHeight, std::max&lt;LayoutUnit&gt;(0, logicalVisualOverflow.y() - lineBox-&gt;lineTopWithLeading()));
1787         }
1788         LayoutUnit remainingLogicalHeightAtNewOffset = pageRemainingLogicalHeightForOffset(logicalOffset + remainingLogicalHeight, ExcludePageBoundary);
1789         overflowsFragment = (lineHeight &gt; remainingLogicalHeightAtNewOffset);
1790         LayoutUnit totalLogicalHeight = lineHeight + std::max&lt;LayoutUnit&gt;(0, logicalOffset);
1791         LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
1792         setPageBreak(logicalOffset, lineHeight - remainingLogicalHeight);
1793         if (((lineBox == firstRootBox() &amp;&amp; totalLogicalHeight &lt; pageLogicalHeightAtNewOffset) || (!style().hasAutoOrphans() &amp;&amp; style().orphans() &gt;= lineIndex))
1794             &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1795             auto firstRootBox = this-&gt;firstRootBox();




1796             auto firstRootBoxOverflowRect = firstRootBox-&gt;logicalVisualOverflowRect(firstRootBox-&gt;lineTop(), firstRootBox-&gt;lineBottom());
1797             auto firstLineUpperOverhang = std::max(-firstRootBoxOverflowRect.y(), 0_lu);
1798             if (needsAppleMailPaginationQuirk(*lineBox))
1799                 return;
1800             setPaginationStrut(remainingLogicalHeight + logicalOffset + firstLineUpperOverhang);
1801         } else {
1802             delta += remainingLogicalHeight;
1803             lineBox-&gt;setPaginationStrut(remainingLogicalHeight);
1804             lineBox-&gt;setIsFirstAfterPageBreak(true);
1805         }
1806     } else if (remainingLogicalHeight == pageLogicalHeight) {
1807         // We&#39;re at the very top of a page or column.
1808         if (lineBox != firstRootBox())
1809             lineBox-&gt;setIsFirstAfterPageBreak(true);
1810         if (lineBox != firstRootBox() || offsetFromLogicalTopOfFirstPage())
1811             setPageBreak(logicalOffset, lineHeight);
1812     }
1813 }
1814 
1815 void RenderBlockFlow::setBreakAtLineToAvoidWidow(int lineToBreak)
</pre>
<hr />
<pre>
2053 
2054         for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(*this)) {
2055             if (ancestor.isRenderView())
2056                 break;
2057             if (ancestor.hasOverhangingFloats()) {
2058                 for (auto it = floatingObjectSet.begin(), end = floatingObjectSet.end(); it != end; ++it) {
2059                     RenderBox&amp; renderer = (*it)-&gt;renderer();
2060                     if (ancestor.hasOverhangingFloat(renderer)) {
2061                         parentBlock = &amp;ancestor;
2062                         break;
2063                     }
2064                 }
2065             }
2066         }
2067 
2068         parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
2069         parentBlock-&gt;markSiblingsWithFloatsForLayout();
2070     }
2071 
2072     if (diff &gt;= StyleDifference::Repaint) {
<span class="line-modified">2073         // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.</span>
<span class="line-modified">2074         if (selfNeedsLayout() || !m_simpleLineLayout || !SimpleLineLayout::canUseFor(*this))</span>











2075             invalidateLineLayoutPath();
2076     }
2077 
2078     if (multiColumnFlow())
2079         updateStylesForColumnChildren();





2080 }
2081 
2082 void RenderBlockFlow::updateStylesForColumnChildren()
2083 {
2084     for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
2085         child-&gt;setStyle(RenderStyle::createAnonymousStyleWithDisplay(style(), DisplayType::Block));
2086 }
2087 
2088 void RenderBlockFlow::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
2089 {
2090     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
2091     s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats() : false;
2092 
2093     if (oldStyle) {
2094         auto oldPosition = oldStyle-&gt;position();
2095         auto newPosition = newStyle.position();
2096 
2097         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2098             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2099                 markAllDescendantsWithFloatsForLayout();
2100         }
2101     }
2102 
2103     RenderBlock::styleWillChange(diff, newStyle);
2104 }
2105 
2106 void RenderBlockFlow::deleteLines()
2107 {
<span class="line-modified">2108     if (containsFloats())</span>
<span class="line-removed">2109         m_floatingObjects-&gt;clearLineBoxTreePointers();</span>
<span class="line-removed">2110 </span>
<span class="line-removed">2111     if (m_simpleLineLayout) {</span>
<span class="line-removed">2112         ASSERT(!m_complexLineLayout);</span>
<span class="line-removed">2113         m_simpleLineLayout = nullptr;</span>
<span class="line-removed">2114     } else if (m_complexLineLayout)</span>
<span class="line-removed">2115         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxTree();</span>
2116 
2117     RenderBlock::deleteLines();
2118 }
2119 
2120 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2121 {
2122     // When a portion of the render tree is being detached, anonymous blocks
2123     // will be combined as their children are deleted. In this process, the
2124     // anonymous block later in the tree is merged into the one preceeding it.
2125     // It can happen that the later block (this) contains floats that the
2126     // previous block (toBlockFlow) did not contain, and thus are not in the
2127     // floating objects list for toBlockFlow. This can result in toBlockFlow
2128     // containing floats that are not in it&#39;s floating objects list, but are in
2129     // the floating objects lists of siblings and parents. This can cause
2130     // problems when the float itself is deleted, since the deletion code
2131     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2132     // objects list, it isn&#39;t in any floating objects list. In order to
2133     // preserve this condition (removing it has serious performance
2134     // implications), we need to copy the floating objects from the old block
2135     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
</pre>
<hr />
<pre>
2322             auto&amp; floatingObject = *it-&gt;get();
2323             if (childrenInline()) {
2324                 LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
2325                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
2326 
2327                 // Fix for https://bugs.webkit.org/show_bug.cgi?id=54995.
2328                 if (logicalBottom &lt; 0 || logicalBottom &lt; logicalTop || logicalTop == LayoutUnit::max())
2329                     logicalBottom = LayoutUnit::max();
2330                 else {
2331                     // Special-case zero- and less-than-zero-height floats: those don&#39;t touch
2332                     // the line that they&#39;re on, but it still needs to be dirtied. This is
2333                     // accomplished by pretending they have a height of 1.
2334                     logicalBottom = std::max(logicalBottom, logicalTop + 1);
2335                 }
2336                 if (floatingObject.originatingLine()) {
2337                     floatingObject.originatingLine()-&gt;removeFloat(floatBox);
2338                     if (!selfNeedsLayout()) {
2339                         ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
2340                         floatingObject.originatingLine()-&gt;markDirty();
2341                     }
<span class="line-modified">2342 #if !ASSERT_DISABLED</span>
2343                     floatingObject.clearOriginatingLine();
2344 #endif
2345                 }
2346                 markLinesDirtyInBlockRange(0, logicalBottom);
2347             }
2348             m_floatingObjects-&gt;remove(&amp;floatingObject);
2349         }
2350     }
2351 }
2352 
2353 void RenderBlockFlow::removeFloatingObjectsBelow(FloatingObject* lastFloat, int logicalOffset)
2354 {
2355     if (!containsFloats())
2356         return;
2357 
2358     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2359     FloatingObject* curr = floatingObjectSet.last().get();
2360     while (curr != lastFloat &amp;&amp; (!curr-&gt;isPlaced() || logicalTopForFloat(*curr) &gt;= logicalOffset)) {
2361         m_floatingObjects-&gt;remove(curr);
2362         if (floatingObjectSet.isEmpty())
</pre>
<hr />
<pre>
2929     for (auto it = floatingObjectSet.end(); it != begin;) {
2930         --it;
2931         const auto&amp; floatingObject = *it-&gt;get();
2932         auto&amp; renderer = floatingObject.renderer();
2933         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2934             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2935             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2936                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2937                 return true;
2938             }
2939         }
2940     }
2941 
2942     return false;
2943 }
2944 
2945 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2946 {
2947     ASSERT(childrenInline());
2948 
<span class="line-modified">2949     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">2950         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
2951 
<span class="line-modified">2952     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>





2953 }
2954 
2955 void RenderBlockFlow::addOverflowFromInlineChildren()
2956 {
2957     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
2958         ASSERT(!hasOverflowClip());
2959         SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);
2960         return;
2961     }
2962 
<span class="line-modified">2963     m_complexLineLayout-&gt;addOverflowFromInlineChildren();</span>








2964 }
2965 
2966 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
2967 {
2968     if (style().visibility() != Visibility::Visible)
2969         return;
2970 
2971     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
2972     // for either overflow or translations via relative positioning.
2973     if (childrenInline()) {
2974         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
2975 
2976         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
2977             if (box-&gt;firstChild())
2978                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
2979             if (box-&gt;lastChild())
2980                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
2981         }
2982     } else {
2983         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
</pre>
<hr />
<pre>
3023     // Clamp to our existing edges. We can never grow. We only shrink.
3024     LayoutUnit leftEdge = borderLeft() + paddingLeft();
3025     LayoutUnit rightEdge = leftEdge + oldWidth;
3026     left = std::min(rightEdge, std::max(leftEdge, left));
3027     right = std::max(leftEdge, std::min(rightEdge, right));
3028 
3029     LayoutUnit newContentWidth = right - left;
3030     if (newContentWidth == oldWidth)
3031         return;
3032 
3033     setOverrideContentLogicalWidth(newContentWidth);
3034     layoutBlock(false);
3035     clearOverrideContentLogicalWidth();
3036 }
3037 
3038 void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
3039 {
3040     if (logicalTop &gt;= logicalBottom)
3041         return;
3042 
<span class="line-modified">3043     // Floats currently affect the choice whether to use simple line layout path.</span>
<span class="line-modified">3044     if (m_simpleLineLayout) {</span>






3045         invalidateLineLayoutPath();
3046         return;
3047     }

3048 
3049     RootInlineBox* lowestDirtyLine = lastRootBox();
3050     RootInlineBox* afterLowest = lowestDirtyLine;
3051     while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
3052         afterLowest = lowestDirtyLine;
3053         lowestDirtyLine = lowestDirtyLine-&gt;prevRootBox();
3054     }
3055 
3056     while (afterLowest &amp;&amp; afterLowest != highest &amp;&amp; (afterLowest-&gt;lineBottomWithLeading() &gt;= logicalTop || afterLowest-&gt;lineBottomWithLeading() &lt; 0)) {
3057         afterLowest-&gt;markDirty();
3058         afterLowest = afterLowest-&gt;prevRootBox();
3059     }
3060 }
3061 
3062 Optional&lt;int&gt; RenderBlockFlow::firstLineBaseline() const
3063 {
3064     if (isWritingModeRoot() &amp;&amp; !isRubyRun() &amp;&amp; !isGridItem())
3065         return WTF::nullopt;
3066 
3067     if (!childrenInline())
3068         return RenderBlock::firstLineBaseline();
3069 
3070     if (!hasLines())
3071         return WTF::nullopt;
3072 
<span class="line-modified">3073     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">3074         return Optional&lt;int&gt;(SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout));</span>





3075 
3076     ASSERT(firstRootBox());
3077     if (style().isFlippedLinesWritingMode())
3078         return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
3079     return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
3080 }
3081 
3082 Optional&lt;int&gt; RenderBlockFlow::inlineBlockBaseline(LineDirectionMode lineDirection) const
3083 {
3084     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
3085         return WTF::nullopt;
3086 
3087     // Note that here we only take the left and bottom into consideration. Our caller takes the right and top into consideration.
3088     float boxHeight = lineDirection == HorizontalLine ? height() + m_marginBox.bottom() : width() + m_marginBox.left();
3089     float lastBaseline;
3090     if (!childrenInline()) {
3091         Optional&lt;int&gt; inlineBlockBaseline = RenderBlock::inlineBlockBaseline(lineDirection);
3092         if (!inlineBlockBaseline)
3093             return inlineBlockBaseline;
3094         lastBaseline = inlineBlockBaseline.value();
3095     } else {
3096         if (!hasLines()) {
3097             if (!hasLineIfEmpty())
3098                 return WTF::nullopt;
3099             const auto&amp; fontMetrics = firstLineStyle().fontMetrics();
3100             return Optional&lt;int&gt;(fontMetrics.ascent()
3101                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
3102                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
3103         }
3104 
<span class="line-modified">3105         if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">3106             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout);</span>




3107         else {
3108             bool isFirstLine = lastRootBox() == firstRootBox();
3109             const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
3110             // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
3111             lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
3112                 + (style.isFlippedLinesWritingMode() ? logicalHeight() - lastRootBox()-&gt;logicalBottom() : lastRootBox()-&gt;logicalTop());
3113         }
3114     }
3115     // According to the CSS spec http://www.w3.org/TR/CSS21/visudet.html, we shouldn&#39;t be performing this min, but should
3116     // instead be returning boxHeight directly. However, we feel that a min here is better behavior (and is consistent
3117     // enough with the spec to not cause tons of breakages).
3118     return style().overflowY() == Overflow::Visible ? lastBaseline : std::min(boxHeight, lastBaseline);
3119 }
3120 
3121 void RenderBlockFlow::setSelectionState(SelectionState state)
3122 {
3123     if (state != SelectionNone)
3124         ensureLineBoxes();
3125     RenderBoxModelObject::setSelectionState(state);
3126 }
3127 
3128 GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
3129     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
3130 {
<span class="line-modified">3131     ASSERT(!m_simpleLineLayout);</span>
3132 
3133     GapRects result;
3134 
3135     bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
3136 
3137     if (!hasLines()) {
3138         if (containsStart) {
3139             // Update our lastLogicalTop to be the bottom of the block. &lt;hr&gt;s or empty blocks with height can trip this case.
3140             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3141             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3142             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3143         }
3144         return result;
3145     }
3146 
3147     RootInlineBox* lastSelectedLine = 0;
3148     RootInlineBox* curr;
3149     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3150 
3151     // Now paint the gaps for the lines.
</pre>
<hr />
<pre>
3217         return nullptr;
3218 
3219     if (childrenInline()) {
3220         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3221             if (!i--)
3222                 return box;
3223         }
3224         return nullptr;
3225     }
3226 
3227     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3228         if (!shouldCheckLines(blockFlow))
3229             continue;
3230         if (RootInlineBox* box = blockFlow.lineAtIndex(i))
3231             return box;
3232     }
3233 
3234     return nullptr;
3235 }
3236 
<span class="line-modified">3237 int RenderBlockFlow::lineCount(const RootInlineBox* stopRootInlineBox, bool* found) const</span>
3238 {

3239     if (style().visibility() != Visibility::Visible)
3240         return 0;
3241 
<span class="line-removed">3242     int count = 0;</span>
<span class="line-removed">3243 </span>
3244     if (childrenInline()) {
<span class="line-modified">3245         if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {</span>
<span class="line-modified">3246             ASSERT(!stopRootInlineBox);</span>
<span class="line-modified">3247             return simpleLineLayout-&gt;lineCount();</span>
<span class="line-modified">3248         }</span>
<span class="line-modified">3249         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {</span>
<span class="line-modified">3250             ++count;</span>
<span class="line-modified">3251             if (box == stopRootInlineBox) {</span>
<span class="line-modified">3252                 if (found)</span>
<span class="line-modified">3253                     *found = true;</span>
<span class="line-modified">3254                 break;</span>
<span class="line-modified">3255             }</span>
<span class="line-removed">3256         }</span>
<span class="line-removed">3257         return count;</span>
3258     }
3259 

3260     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3261         if (!shouldCheckLines(blockFlow))
3262             continue;
<span class="line-modified">3263         bool recursiveFound = false;</span>
<span class="line-removed">3264         count += blockFlow.lineCount(stopRootInlineBox, &amp;recursiveFound);</span>
<span class="line-removed">3265         if (recursiveFound) {</span>
<span class="line-removed">3266             if (found)</span>
<span class="line-removed">3267                 *found = true;</span>
<span class="line-removed">3268             break;</span>
<span class="line-removed">3269         }</span>
3270     }
3271 
3272     return count;
3273 }
3274 
3275 static int getHeightForLineCount(const RenderBlockFlow&amp; block, int lineCount, bool includeBottom, int&amp; count)
3276 {
3277     if (block.style().visibility() != Visibility::Visible)
3278         return -1;
3279 
3280     if (block.childrenInline()) {
3281         for (auto* box = block.firstRootBox(); box; box = box-&gt;nextRootBox()) {
3282             if (++count == lineCount)
3283                 return box-&gt;lineBottom() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3284         }
3285     } else {
3286         RenderBox* normalFlowChildWithoutLines = nullptr;
3287         for (auto* obj = block.firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
3288             if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; shouldCheckLines(downcast&lt;RenderBlockFlow&gt;(*obj))) {
3289                 int result = getHeightForLineCount(downcast&lt;RenderBlockFlow&gt;(*obj), lineCount, false, count);
</pre>
<hr />
<pre>
3311         return;
3312 
3313     if (childrenInline() &amp;&amp; hasMarkupTruncation()) {
3314         ensureLineBoxes();
3315 
3316         setHasMarkupTruncation(false);
3317         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())
3318             box-&gt;clearTruncation();
3319         return;
3320     }
3321 
3322     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3323         if (shouldCheckLines(blockFlow))
3324             blockFlow.clearTruncation();
3325     }
3326 }
3327 
3328 bool RenderBlockFlow::containsNonZeroBidiLevel() const
3329 {
3330     for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
<span class="line-modified">3331         for (auto* box = root-&gt;firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
3332             if (box-&gt;bidiLevel())
3333                 return true;
3334         }
3335     }
3336     return false;
3337 }
3338 
3339 Position RenderBlockFlow::positionForBox(InlineBox *box, bool start) const
3340 {
3341     if (!box)
3342         return Position();
3343 
3344     if (!box-&gt;renderer().nonPseudoNode())
3345         return createLegacyEditingPosition(nonPseudoElement(), start ? caretMinOffset() : caretMaxOffset());
3346 
3347     if (!is&lt;InlineTextBox&gt;(*box))
3348         return createLegacyEditingPosition(box-&gt;renderer().nonPseudoNode(), start ? box-&gt;renderer().caretMinOffset() : box-&gt;renderer().caretMaxOffset());
3349 
3350     auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*box);
3351     return createLegacyEditingPosition(textBox.renderer().nonPseudoNode(), start ? textBox.start() : textBox.start() + textBox.len());
</pre>
<hr />
<pre>
3419 VisiblePosition RenderBlockFlow::positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer* fragment)
3420 {
3421     ASSERT(childrenInline());
3422 
3423     ensureLineBoxes();
3424 
3425     if (!firstRootBox())
3426         return createVisiblePosition(0, DOWNSTREAM);
3427 
3428     bool linesAreFlipped = style().isFlippedLinesWritingMode();
3429     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
3430 
3431     // look for the closest line box in the root box which is at the passed-in y coordinate
3432     InlineBox* closestBox = 0;
3433     RootInlineBox* firstRootBoxWithChildren = 0;
3434     RootInlineBox* lastRootBoxWithChildren = 0;
3435     for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3436         if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
3437             continue;
3438 
<span class="line-modified">3439         if (!root-&gt;firstLeafChild())</span>
3440             continue;
3441         if (!firstRootBoxWithChildren)
3442             firstRootBoxWithChildren = root;
3443 
3444         if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
3445             || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;lineTopWithLeading())))
3446             break;
3447 
3448         lastRootBoxWithChildren = root;
3449 
3450         // check if this root line box is located at this y coordinate
3451         if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
3452             if (linesAreFlipped) {
3453                 RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
<span class="line-modified">3454                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafChild())</span>
3455                     nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
3456 
3457                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3458                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3459                     continue;
3460             }
3461             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3462             if (closestBox)
3463                 break;
3464         }
3465     }
3466 
3467     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3468 
3469     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3470         // y coordinate is below last root line box, pretend we hit it
3471         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3472     }
3473 
3474     if (closestBox) {
3475         if (moveCaretToBoundary) {
3476             LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));
3477             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3478                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
<span class="line-modified">3479                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafChild();</span>
3480                 if (box-&gt;isLineBreak()) {
<span class="line-modified">3481                     if (InlineBox* newBox = box-&gt;nextLeafChildIgnoringLineBreak())</span>
3482                         box = newBox;
3483                 }
3484                 // y coordinate is above first root line box, so return the start of the first
3485                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3486             }
3487         }
3488 
3489         // pass the box a top position that is inside it
3490         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3491         if (!isHorizontalWritingMode())
3492             point = point.transposedPoint();
3493         if (closestBox-&gt;renderer().isReplaced())
3494             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3495         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3496     }
3497 
3498     if (lastRootBoxWithChildren) {
3499         // We hit this case for Mac behavior when the Y coordinate is below the last box.
3500         ASSERT(moveCaretToBoundary);
3501         InlineBox* logicallyLastBox;
</pre>
<hr />
<pre>
3521 {
3522     return RenderBlock::positionForPoint(point, nullptr);
3523 }
3524 
3525 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3526 {
3527     ASSERT(childrenInline());
3528     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
3529         LayoutUnit top = std::max(curr-&gt;lineTop(), LayoutUnit(curr-&gt;top()));
3530         LayoutUnit bottom = std::min(curr-&gt;lineBottom(), LayoutUnit(curr-&gt;top() + curr-&gt;height()));
3531         LayoutRect rect { LayoutUnit(additionalOffset.x() + curr-&gt;x()), additionalOffset.y() + top, LayoutUnit(curr-&gt;width()), bottom - top };
3532         if (!rect.isEmpty())
3533             rects.append(rect);
3534     }
3535 }
3536 
3537 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3538 {
3539     ASSERT(childrenInline());
3540 







3541     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3542         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3543         return;
3544     }
3545 
<span class="line-modified">3546     if (m_complexLineLayout)</span>
<span class="line-modified">3547         m_complexLineLayout-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
3548 }
3549 
3550 bool RenderBlockFlow::relayoutForPagination()
3551 {
3552     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3553         return false;
3554 
3555     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3556     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3557 
3558     bool needsRelayout;
3559     bool neededRelayout = false;
3560     bool firstPass = true;
3561     do {
3562         // Column heights may change here because of balancing. We may have to do multiple layout
3563         // passes, depending on how the contents is fitted to the changed column heights. In most
3564         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3565         // passes than that, though, but the number of retries should not exceed the number of
3566         // columns, unless we have a bug.
3567         needsRelayout = false;
</pre>
<hr />
<pre>
3579         if (needsRelayout) {
3580             // Layout again. Column balancing resulted in a new height.
3581             neededRelayout = true;
3582             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3583             setChildNeedsLayout(MarkOnlyThis);
3584             layoutBlock(false);
3585         }
3586         firstPass = false;
3587     } while (needsRelayout);
3588 
3589     multiColumnFlow()-&gt;setInBalancingPass(false);
3590 
3591     return neededRelayout;
3592 }
3593 
3594 bool RenderBlockFlow::hasLines() const
3595 {
3596     if (!childrenInline())
3597         return false;
3598 
<span class="line-modified">3599     if (auto simpleLineLayout = this-&gt;simpleLineLayout())</span>
<span class="line-modified">3600         return simpleLineLayout-&gt;lineCount();</span>




3601 
<span class="line-modified">3602     return m_complexLineLayout &amp;&amp; m_complexLineLayout-&gt;lineBoxes().firstLineBox();</span>
3603 }
3604 
3605 void RenderBlockFlow::invalidateLineLayoutPath()
3606 {
3607     switch (lineLayoutPath()) {
3608     case UndeterminedPath:
3609     case ForceLineBoxesPath:
<span class="line-modified">3610         ASSERT(!m_simpleLineLayout);</span>
3611         return;
3612     case LineBoxesPath:
<span class="line-modified">3613         ASSERT(!m_simpleLineLayout);</span>
3614         setLineLayoutPath(UndeterminedPath);
3615         return;

3616     case SimpleLinesPath:
3617         // The simple line layout may have become invalid.
<span class="line-modified">3618         m_simpleLineLayout = nullptr;</span>
3619         setLineLayoutPath(UndeterminedPath);
3620         if (needsLayout())
3621             return;
3622         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3623         setNeedsLayout();
3624         return;
3625     }
3626     ASSERT_NOT_REACHED();
3627 }
3628 
3629 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3630 {
<span class="line-modified">3631     bool needsLayout = selfNeedsLayout() || relayoutChildren || !m_simpleLineLayout;</span>
<span class="line-modified">3632     if (needsLayout) {</span>
<span class="line-modified">3633         deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-modified">3634         m_simpleLineLayout = SimpleLineLayout::create(*this);</span>
<span class="line-modified">3635     }</span>

3636     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
<span class="line-modified">3637         m_simpleLineLayout-&gt;setIsPaginated();</span>
<span class="line-modified">3638         SimpleLineLayout::adjustLinePositionsForPagination(*m_simpleLineLayout, *this);</span>
3639     }

3640     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3641         renderer.clearNeedsLayout();
<span class="line-modified">3642     ASSERT(!m_complexLineLayout);</span>
<span class="line-modified">3643     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, *m_simpleLineLayout);</span>
3644     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3645     repaintLogicalTop = lineLayoutTop;
3646     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3647     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3648 }
3649 
<span class="line-modified">3650 void RenderBlockFlow::deleteLineBoxesBeforeSimpleLineLayout()</span>

3651 {
<span class="line-modified">3652     ASSERT(lineLayoutPath() == SimpleLinesPath);</span>

3653 
<span class="line-modified">3654     if (m_complexLineLayout)</span>
<span class="line-removed">3655         m_complexLineLayout-&gt;lineBoxes().deleteLineBoxes();</span>
3656 
<span class="line-modified">3657     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this)) {</span>
<span class="line-modified">3658         if (is&lt;RenderText&gt;(renderer))</span>
<span class="line-removed">3659             downcast&lt;RenderText&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-removed">3660         else if (is&lt;RenderLineBreak&gt;(renderer))</span>
<span class="line-removed">3661             downcast&lt;RenderLineBreak&gt;(renderer).deleteLineBoxesBeforeSimpleLineLayout();</span>
<span class="line-removed">3662         else</span>
<span class="line-removed">3663             ASSERT_NOT_REACHED();</span>
<span class="line-removed">3664     }</span>
3665 
<span class="line-modified">3666     m_complexLineLayout = nullptr;</span>









3667 }

3668 
3669 void RenderBlockFlow::ensureLineBoxes()
3670 {
3671     if (!childrenInline())
3672         return;
3673 
3674     setLineLayoutPath(ForceLineBoxesPath);
3675 
<span class="line-modified">3676     if (!m_simpleLineLayout)</span>
3677         return;
3678 
<span class="line-modified">3679     ASSERT(!m_complexLineLayout);</span>
<span class="line-removed">3680     m_complexLineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
3681 
<span class="line-modified">3682     if (SimpleLineLayout::canUseForLineBoxTree(*this, *m_simpleLineLayout)) {</span>
<span class="line-modified">3683         SimpleLineLayout::generateLineBoxTree(*this, *m_simpleLineLayout);</span>
<span class="line-modified">3684         m_simpleLineLayout = nullptr;</span>
<span class="line-modified">3685         return;</span>



3686     }
<span class="line-removed">3687     bool isPaginated = m_simpleLineLayout-&gt;isPaginated();</span>
<span class="line-removed">3688     m_simpleLineLayout = nullptr;</span>
3689 
<span class="line-modified">3690 #if !ASSERT_DISABLED</span>


3691     LayoutUnit oldHeight = logicalHeight();
3692 #endif
3693     bool didNeedLayout = needsLayout();
3694 
3695     bool relayoutChildren = false;
3696     LayoutUnit repaintLogicalTop;
3697     LayoutUnit repaintLogicalBottom;
<span class="line-modified">3698     if (isPaginated) {</span>
3699         PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">3700         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3701         // This matches relayoutToAvoidWidows.
3702         if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">3703             m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3704         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3705         repaint();
3706     } else
<span class="line-modified">3707         m_complexLineLayout-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3708 
3709     updateLogicalHeight();
3710     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3711 
3712     if (!didNeedLayout)
3713         clearNeedsLayout();
3714 }
3715 
3716 #if ENABLE(TREE_DEBUGGING)
3717 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3718 {
3719     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3720         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3721 
3722     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3723         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3724 }
3725 #endif
3726 
3727 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
</pre>
</td>
<td>
<hr />
<pre>
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;RenderBlockFlow.h&quot;
  26 
  27 #include &quot;ComplexLineLayout.h&quot;
  28 #include &quot;Editor.h&quot;
  29 #include &quot;FloatingObjects.h&quot;
  30 #include &quot;Frame.h&quot;
  31 #include &quot;FrameSelection.h&quot;
  32 #include &quot;HTMLElement.h&quot;
  33 #include &quot;HTMLInputElement.h&quot;
  34 #include &quot;HTMLParserIdioms.h&quot;
  35 #include &quot;HTMLTextAreaElement.h&quot;
  36 #include &quot;HitTestLocation.h&quot;
  37 #include &quot;InlineTextBox.h&quot;
<span class="line-added">  38 #include &quot;LayoutIntegrationLineLayout.h&quot;</span>
  39 #include &quot;LayoutRepainter.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;RenderCombineText.h&quot;
  42 #include &quot;RenderFlexibleBox.h&quot;
  43 #include &quot;RenderInline.h&quot;
  44 #include &quot;RenderIterator.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 #include &quot;RenderLayoutState.h&quot;
  47 #include &quot;RenderLineBreak.h&quot;
  48 #include &quot;RenderListItem.h&quot;
  49 #include &quot;RenderMarquee.h&quot;
  50 #include &quot;RenderMultiColumnFlow.h&quot;
  51 #include &quot;RenderMultiColumnSet.h&quot;
  52 #include &quot;RenderTableCell.h&quot;
  53 #include &quot;RenderText.h&quot;
  54 #include &quot;RenderTreeBuilder.h&quot;
  55 #include &quot;RenderView.h&quot;
  56 #include &quot;Settings.h&quot;
  57 #include &quot;SimpleLineLayoutFunctions.h&quot;
  58 #include &quot;SimpleLineLayoutPagination.h&quot;
</pre>
<hr />
<pre>
 136     if (!renderTreeBeingDestroyed()) {
 137         if (firstRootBox()) {
 138             // We can&#39;t wait for RenderBox::destroy to clear the selection,
 139             // because by then we will have nuked the line boxes.
 140             if (isSelectionBorder())
 141                 frame().selection().setNeedsSelectionUpdate();
 142 
 143             // If we are an anonymous block, then our line boxes might have children
 144             // that will outlast this block. In the non-anonymous block case those
 145             // children will be destroyed by the time we return from this function.
 146             if (isAnonymousBlock()) {
 147                 for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
 148                     while (auto childBox = box-&gt;firstChild())
 149                         childBox-&gt;removeFromParent();
 150                 }
 151             }
 152         } else if (parent())
 153             parent()-&gt;dirtyLinesFromChangedChild(*this);
 154     }
 155 
<span class="line-modified"> 156     if (complexLineLayout())</span>
<span class="line-modified"> 157         complexLineLayout()-&gt;lineBoxes().deleteLineBoxes();</span>
 158 
 159     blockWillBeDestroyed();
 160 
 161     // NOTE: This jumps down to RenderBox, bypassing RenderBlock since it would do duplicate work.
 162     RenderBox::willBeDestroyed();
 163 }
 164 
 165 RenderMultiColumnFlow* RenderBlockFlow::multiColumnFlowSlowCase() const
 166 {
 167     return rareBlockFlowData()-&gt;m_multiColumnFlow.get();
 168 }
 169 
 170 RenderBlockFlow* RenderBlockFlow::previousSiblingWithOverhangingFloats(bool&amp; parentHasFloats) const
 171 {
 172     // Attempt to locate a previous sibling with overhanging floats. We skip any elements that are
 173     // out of flow (like floating/positioned elements), and we also skip over any objects that may have shifted
 174     // to avoid floats.
 175     parentHasFloats = false;
 176     for (RenderObject* sibling = previousSibling(); sibling; sibling = sibling-&gt;previousSibling()) {
 177         if (is&lt;RenderBlockFlow&gt;(*sibling)) {
</pre>
<hr />
<pre>
 456     return false;
 457 }
 458 
 459 void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)
 460 {
 461     ASSERT(needsLayout());
 462 
 463     if (!relayoutChildren &amp;&amp; simplifiedLayout())
 464         return;
 465 
 466     LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
 467 
 468     if (recomputeLogicalWidthAndColumnWidth())
 469         relayoutChildren = true;
 470 
 471     rebuildFloatingObjectSetFromIntrudingFloats();
 472 
 473     LayoutUnit previousHeight = logicalHeight();
 474     // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
 475     // for consistency with other render classes?
<span class="line-modified"> 476     resetLogicalHeightBeforeLayoutIfNeeded();</span>
 477 
 478     bool pageLogicalHeightChanged = false;
 479     checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);
 480 
 481     LayoutUnit repaintLogicalTop;
 482     LayoutUnit repaintLogicalBottom;
 483     LayoutUnit maxFloatLogicalBottom;
 484     const RenderStyle&amp; styleToUse = style();
 485     {
 486         LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);
 487 
 488         preparePaginationBeforeBlockLayout(relayoutChildren);
 489 
 490         // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track
 491         // our current maximal positive and negative margins. These values are used when we
 492         // are collapsed with adjacent blocks, so for example, if you have block A and B
 493         // collapsing together, then you&#39;d take the maximal positive margin from both A and B
 494         // and subtract it from the maximal negative margin from both A and B to get the
 495         // true collapsed margin. This algorithm is recursive, so when we finish layout()
 496         // our block knows its current maximal positive/negative values.
</pre>
<hr />
<pre>
 651             adjustPositionedBlock(child, marginInfo);
 652             continue;
 653         }
 654         if (child.isFloating()) {
 655             insertFloatingObject(child);
 656             adjustFloatingBlock(marginInfo);
 657             continue;
 658         }
 659 
 660         // Lay out the child.
 661         layoutBlockChild(child, marginInfo, previousFloatLogicalBottom, maxFloatLogicalBottom);
 662     }
 663 
 664     // Now do the handling of the bottom of the block, adding in our bottom border/padding and
 665     // determining the correct collapsed bottom margin information.
 666     handleAfterSideOfBlock(beforeEdge, afterEdge, marginInfo);
 667 }
 668 
 669 void RenderBlockFlow::layoutInlineChildren(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
 670 {
<span class="line-added"> 671     auto computeLineLayoutPath = [&amp;] {</span>
<span class="line-added"> 672         bool canUseSimpleLines = SimpleLineLayout::canUseFor(*this);</span>
<span class="line-added"> 673 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 674         if (LayoutIntegration::LineLayout::canUseFor(*this, canUseSimpleLines))</span>
<span class="line-added"> 675             return LayoutFormattingContextPath;</span>
<span class="line-added"> 676 #endif</span>
<span class="line-added"> 677         if (canUseSimpleLines)</span>
<span class="line-added"> 678             return SimpleLinesPath;</span>
<span class="line-added"> 679 </span>
<span class="line-added"> 680         return LineBoxesPath;</span>
<span class="line-added"> 681     };</span>
<span class="line-added"> 682 </span>
 683     if (lineLayoutPath() == UndeterminedPath)
<span class="line-modified"> 684         setLineLayoutPath(computeLineLayoutPath());</span>
 685 
 686     if (lineLayoutPath() == SimpleLinesPath) {
 687         layoutSimpleLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
 688         return;
 689     }
 690 
<span class="line-modified"> 691 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 692     if (lineLayoutPath() == LayoutFormattingContextPath) {</span>
<span class="line-added"> 693         layoutLFCLines(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
<span class="line-added"> 694         return;</span>
<span class="line-added"> 695     }</span>
<span class="line-added"> 696 #endif</span>
 697 
<span class="line-modified"> 698     if (!complexLineLayout())</span>
<span class="line-modified"> 699         m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
 700 
<span class="line-modified"> 701     complexLineLayout()-&gt;layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
 702 }
 703 
 704 void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
 705 {
 706     LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();
 707     LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();
 708 
 709     // The child is a normal flow object. Compute the margins we will use for collapsing now.
 710     child.computeAndSetBlockDirectionMargins(*this);
 711 
 712     // Try to guess our correct logical top position. In most cases this guess will
 713     // be correct. Only if we&#39;re wrong (when we compute the real logical top position)
 714     // will we have to potentially relayout.
 715     LayoutUnit estimateWithoutPagination;
 716     LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);
 717 
 718     // Cache our old rect so that we can dirty the proper repaint rects if the child moves.
 719     LayoutRect oldRect = child.frameRect();
 720     LayoutUnit oldLogicalTop = logicalTopForChild(child);
 721 
<span class="line-modified"> 722 #if ASSERT_ENABLED</span>
 723     LayoutSize oldLayoutDelta = view().frameView().layoutContext().layoutDelta();
 724 #endif
 725     // Position the child as though it didn&#39;t collapse with the top.
 726     setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
 727     estimateFragmentRangeForBoxChild(child);
 728 
 729     RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
 730     bool markDescendantsWithFloats = false;
 731     if (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
 732         markDescendantsWithFloats = true;
 733     else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))
 734         // logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for
 735         // very large elements. If it does the comparison with oldLogicalTop might yield a
 736         // false negative as adding and removing margins, borders etc from a saturated number
 737         // might yield incorrect results. If this is the case always mark for layout.
 738         markDescendantsWithFloats = true;
 739     else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) {
 740         // If an element might be affected by the presence of floats, then always mark it for
 741         // layout.
 742         LayoutUnit fb = std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());
</pre>
<hr />
<pre>
1775         // line and computing a new height that excludes anything we consider &quot;blank space&quot;. We will discard margins, descent, and even overflow. If we are
1776         // able to fit with the blank space and overflow excluded, we will give the line its own page with the highest non-blank element being aligned with the
1777         // top of the page.
1778         // FIXME: We are still honoring gigantic margins, which does leave open the possibility of blank pages caused by this heuristic. It remains to be seen whether or not
1779         // this will be a real-world issue. For now we don&#39;t try to deal with this problem.
1780         logicalOffset = intMaxForLayoutUnit;
1781         logicalBottom = intMinForLayoutUnit;
1782         lineBox-&gt;computeReplacedAndTextLineTopAndBottom(logicalOffset, logicalBottom);
1783         lineHeight = logicalBottom - logicalOffset;
1784         if (logicalOffset == intMaxForLayoutUnit || lineHeight &gt; pageLogicalHeight) {
1785             // Give up. We&#39;re genuinely too big even after excluding blank space and overflow.
1786             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1787             return;
1788         }
1789         pageLogicalHeight = pageLogicalHeightForOffset(logicalOffset);
1790     }
1791 
1792     LayoutUnit remainingLogicalHeight = pageRemainingLogicalHeightForOffset(logicalOffset, ExcludePageBoundary);
1793     overflowsFragment = (lineHeight &gt; remainingLogicalHeight);
1794 
<span class="line-modified">1795     int lineIndex = complexLineLayout()-&gt;lineCountUntil(lineBox);</span>
1796     if (remainingLogicalHeight &lt; lineHeight || (shouldBreakAtLineToAvoidWidow() &amp;&amp; lineBreakToAvoidWidow() == lineIndex)) {
1797         if (lineBreakToAvoidWidow() == lineIndex)
1798             clearShouldBreakAtLineToAvoidWidowIfNeeded(*this);
1799         // If we have a non-uniform page height, then we have to shift further possibly.
1800         if (!hasUniformPageLogicalHeight &amp;&amp; !pushToNextPageWithMinimumLogicalHeight(remainingLogicalHeight, logicalOffset, lineHeight))
1801             return;
1802         if (lineHeight &gt; pageLogicalHeight) {
1803             // Split the top margin in order to avoid splitting the visible part of the line.
1804             remainingLogicalHeight -= std::min(lineHeight - pageLogicalHeight, std::max&lt;LayoutUnit&gt;(0, logicalVisualOverflow.y() - lineBox-&gt;lineTopWithLeading()));
1805         }
1806         LayoutUnit remainingLogicalHeightAtNewOffset = pageRemainingLogicalHeightForOffset(logicalOffset + remainingLogicalHeight, ExcludePageBoundary);
1807         overflowsFragment = (lineHeight &gt; remainingLogicalHeightAtNewOffset);
1808         LayoutUnit totalLogicalHeight = lineHeight + std::max&lt;LayoutUnit&gt;(0, logicalOffset);
1809         LayoutUnit pageLogicalHeightAtNewOffset = hasUniformPageLogicalHeight ? pageLogicalHeight : pageLogicalHeightForOffset(logicalOffset + remainingLogicalHeight);
1810         setPageBreak(logicalOffset, lineHeight - remainingLogicalHeight);
1811         if (((lineBox == firstRootBox() &amp;&amp; totalLogicalHeight &lt; pageLogicalHeightAtNewOffset) || (!style().hasAutoOrphans() &amp;&amp; style().orphans() &gt;= lineIndex))
1812             &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; !isTableCell()) {
1813             auto firstRootBox = this-&gt;firstRootBox();
<span class="line-added">1814             if (!firstRootBox) {</span>
<span class="line-added">1815                 setPaginationStrut(remainingLogicalHeight + logicalOffset);</span>
<span class="line-added">1816                 return;</span>
<span class="line-added">1817             }</span>
1818             auto firstRootBoxOverflowRect = firstRootBox-&gt;logicalVisualOverflowRect(firstRootBox-&gt;lineTop(), firstRootBox-&gt;lineBottom());
1819             auto firstLineUpperOverhang = std::max(-firstRootBoxOverflowRect.y(), 0_lu);
1820             if (needsAppleMailPaginationQuirk(*lineBox))
1821                 return;
1822             setPaginationStrut(remainingLogicalHeight + logicalOffset + firstLineUpperOverhang);
1823         } else {
1824             delta += remainingLogicalHeight;
1825             lineBox-&gt;setPaginationStrut(remainingLogicalHeight);
1826             lineBox-&gt;setIsFirstAfterPageBreak(true);
1827         }
1828     } else if (remainingLogicalHeight == pageLogicalHeight) {
1829         // We&#39;re at the very top of a page or column.
1830         if (lineBox != firstRootBox())
1831             lineBox-&gt;setIsFirstAfterPageBreak(true);
1832         if (lineBox != firstRootBox() || offsetFromLogicalTopOfFirstPage())
1833             setPageBreak(logicalOffset, lineHeight);
1834     }
1835 }
1836 
1837 void RenderBlockFlow::setBreakAtLineToAvoidWidow(int lineToBreak)
</pre>
<hr />
<pre>
2075 
2076         for (auto&amp; ancestor : ancestorsOfType&lt;RenderBlockFlow&gt;(*this)) {
2077             if (ancestor.isRenderView())
2078                 break;
2079             if (ancestor.hasOverhangingFloats()) {
2080                 for (auto it = floatingObjectSet.begin(), end = floatingObjectSet.end(); it != end; ++it) {
2081                     RenderBox&amp; renderer = (*it)-&gt;renderer();
2082                     if (ancestor.hasOverhangingFloat(renderer)) {
2083                         parentBlock = &amp;ancestor;
2084                         break;
2085                     }
2086                 }
2087             }
2088         }
2089 
2090         parentBlock-&gt;markAllDescendantsWithFloatsForLayout();
2091         parentBlock-&gt;markSiblingsWithFloatsForLayout();
2092     }
2093 
2094     if (diff &gt;= StyleDifference::Repaint) {
<span class="line-modified">2095         auto shouldInvalidateLineLayoutPath = [&amp;] {</span>
<span class="line-modified">2096             if (selfNeedsLayout() || complexLineLayout())</span>
<span class="line-added">2097                 return true;</span>
<span class="line-added">2098             // FIXME: This could use a cheaper style-only test instead of SimpleLineLayout::canUseFor.</span>
<span class="line-added">2099             if (simpleLineLayout() &amp;&amp; !SimpleLineLayout::canUseFor(*this))</span>
<span class="line-added">2100                 return true;</span>
<span class="line-added">2101 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">2102             if (layoutFormattingContextLineLayout() &amp;&amp; !LayoutIntegration::LineLayout::canUseFor(*this))</span>
<span class="line-added">2103                 return true;</span>
<span class="line-added">2104 #endif</span>
<span class="line-added">2105             return false;</span>
<span class="line-added">2106         };</span>
<span class="line-added">2107         if (shouldInvalidateLineLayoutPath())</span>
2108             invalidateLineLayoutPath();
2109     }
2110 
2111     if (multiColumnFlow())
2112         updateStylesForColumnChildren();
<span class="line-added">2113 </span>
<span class="line-added">2114 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">2115     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">2116         layoutFormattingContextLineLayout()-&gt;updateStyle();</span>
<span class="line-added">2117 #endif</span>
2118 }
2119 
2120 void RenderBlockFlow::updateStylesForColumnChildren()
2121 {
2122     for (auto* child = firstChildBox(); child &amp;&amp; (child-&gt;isInFlowRenderFragmentedFlow() || child-&gt;isRenderMultiColumnSet()); child = child-&gt;nextSiblingBox())
2123         child-&gt;setStyle(RenderStyle::createAnonymousStyleWithDisplay(style(), DisplayType::Block));
2124 }
2125 
2126 void RenderBlockFlow::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
2127 {
2128     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
2129     s_canPropagateFloatIntoSibling = oldStyle ? !isFloatingOrOutOfFlowPositioned() &amp;&amp; !avoidsFloats() : false;
2130 
2131     if (oldStyle) {
2132         auto oldPosition = oldStyle-&gt;position();
2133         auto newPosition = newStyle.position();
2134 
2135         if (parent() &amp;&amp; diff == StyleDifference::Layout &amp;&amp; oldPosition != newPosition) {
2136             if (containsFloats() &amp;&amp; !isFloating() &amp;&amp; !isOutOfFlowPositioned() &amp;&amp; newStyle.hasOutOfFlowPosition())
2137                 markAllDescendantsWithFloatsForLayout();
2138         }
2139     }
2140 
2141     RenderBlock::styleWillChange(diff, newStyle);
2142 }
2143 
2144 void RenderBlockFlow::deleteLines()
2145 {
<span class="line-modified">2146     m_lineLayout = WTF::Monostate();</span>







2147 
2148     RenderBlock::deleteLines();
2149 }
2150 
2151 void RenderBlockFlow::addFloatsToNewParent(RenderBlockFlow&amp; toBlockFlow) const
2152 {
2153     // When a portion of the render tree is being detached, anonymous blocks
2154     // will be combined as their children are deleted. In this process, the
2155     // anonymous block later in the tree is merged into the one preceeding it.
2156     // It can happen that the later block (this) contains floats that the
2157     // previous block (toBlockFlow) did not contain, and thus are not in the
2158     // floating objects list for toBlockFlow. This can result in toBlockFlow
2159     // containing floats that are not in it&#39;s floating objects list, but are in
2160     // the floating objects lists of siblings and parents. This can cause
2161     // problems when the float itself is deleted, since the deletion code
2162     // assumes that if a float is not in it&#39;s containing block&#39;s floating
2163     // objects list, it isn&#39;t in any floating objects list. In order to
2164     // preserve this condition (removing it has serious performance
2165     // implications), we need to copy the floating objects from the old block
2166     // (this) to the new block (toBlockFlow). The float&#39;s metrics will likely
</pre>
<hr />
<pre>
2353             auto&amp; floatingObject = *it-&gt;get();
2354             if (childrenInline()) {
2355                 LayoutUnit logicalTop = logicalTopForFloat(floatingObject);
2356                 LayoutUnit logicalBottom = logicalBottomForFloat(floatingObject);
2357 
2358                 // Fix for https://bugs.webkit.org/show_bug.cgi?id=54995.
2359                 if (logicalBottom &lt; 0 || logicalBottom &lt; logicalTop || logicalTop == LayoutUnit::max())
2360                     logicalBottom = LayoutUnit::max();
2361                 else {
2362                     // Special-case zero- and less-than-zero-height floats: those don&#39;t touch
2363                     // the line that they&#39;re on, but it still needs to be dirtied. This is
2364                     // accomplished by pretending they have a height of 1.
2365                     logicalBottom = std::max(logicalBottom, logicalTop + 1);
2366                 }
2367                 if (floatingObject.originatingLine()) {
2368                     floatingObject.originatingLine()-&gt;removeFloat(floatBox);
2369                     if (!selfNeedsLayout()) {
2370                         ASSERT(&amp;floatingObject.originatingLine()-&gt;renderer() == this);
2371                         floatingObject.originatingLine()-&gt;markDirty();
2372                     }
<span class="line-modified">2373 #if ASSERT_ENABLED</span>
2374                     floatingObject.clearOriginatingLine();
2375 #endif
2376                 }
2377                 markLinesDirtyInBlockRange(0, logicalBottom);
2378             }
2379             m_floatingObjects-&gt;remove(&amp;floatingObject);
2380         }
2381     }
2382 }
2383 
2384 void RenderBlockFlow::removeFloatingObjectsBelow(FloatingObject* lastFloat, int logicalOffset)
2385 {
2386     if (!containsFloats())
2387         return;
2388 
2389     const FloatingObjectSet&amp; floatingObjectSet = m_floatingObjects-&gt;set();
2390     FloatingObject* curr = floatingObjectSet.last().get();
2391     while (curr != lastFloat &amp;&amp; (!curr-&gt;isPlaced() || logicalTopForFloat(*curr) &gt;= logicalOffset)) {
2392         m_floatingObjects-&gt;remove(curr);
2393         if (floatingObjectSet.isEmpty())
</pre>
<hr />
<pre>
2960     for (auto it = floatingObjectSet.end(); it != begin;) {
2961         --it;
2962         const auto&amp; floatingObject = *it-&gt;get();
2963         auto&amp; renderer = floatingObject.renderer();
2964         if (floatingObject.shouldPaint() &amp;&amp; !renderer.hasSelfPaintingLayer()) {
2965             LayoutPoint childPoint = flipFloatForWritingModeForChild(floatingObject, adjustedLocation + floatingObject.translationOffsetToAncestor());
2966             if (renderer.hitTest(request, result, locationInContainer, childPoint)) {
2967                 updateHitTestResult(result, locationInContainer.point() - toLayoutSize(childPoint));
2968                 return true;
2969             }
2970         }
2971     }
2972 
2973     return false;
2974 }
2975 
2976 bool RenderBlockFlow::hitTestInlineChildren(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
2977 {
2978     ASSERT(childrenInline());
2979 
<span class="line-modified">2980     if (simpleLineLayout())</span>
<span class="line-modified">2981         return SimpleLineLayout::hitTestFlow(*this, *simpleLineLayout(), request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
2982 
<span class="line-modified">2983 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">2984     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">2985         return layoutFormattingContextLineLayout()-&gt;hitTest(request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
<span class="line-added">2986 #endif</span>
<span class="line-added">2987 </span>
<span class="line-added">2988     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().hitTest(this, request, result, locationInContainer, accumulatedOffset, hitTestAction);</span>
2989 }
2990 
2991 void RenderBlockFlow::addOverflowFromInlineChildren()
2992 {
2993     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
2994         ASSERT(!hasOverflowClip());
2995         SimpleLineLayout::collectFlowOverflow(*this, *simpleLineLayout);
2996         return;
2997     }
2998 
<span class="line-modified">2999 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">3000     if (layoutFormattingContextLineLayout()) {</span>
<span class="line-added">3001         layoutFormattingContextLineLayout()-&gt;collectOverflow(*this);</span>
<span class="line-added">3002         return;</span>
<span class="line-added">3003     }</span>
<span class="line-added">3004 #endif</span>
<span class="line-added">3005 </span>
<span class="line-added">3006     if (complexLineLayout())</span>
<span class="line-added">3007         complexLineLayout()-&gt;addOverflowFromInlineChildren();</span>
3008 }
3009 
3010 void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit&amp; left, LayoutUnit&amp; right) const
3011 {
3012     if (style().visibility() != Visibility::Visible)
3013         return;
3014 
3015     // We don&#39;t deal with relative positioning.  Our assumption is that you shrink to fit the lines without accounting
3016     // for either overflow or translations via relative positioning.
3017     if (childrenInline()) {
3018         const_cast&lt;RenderBlockFlow&amp;&gt;(*this).ensureLineBoxes();
3019 
3020         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3021             if (box-&gt;firstChild())
3022                 left = std::min(left, x + LayoutUnit(box-&gt;firstChild()-&gt;x()));
3023             if (box-&gt;lastChild())
3024                 right = std::max(right, x + LayoutUnit(ceilf(box-&gt;lastChild()-&gt;logicalRight())));
3025         }
3026     } else {
3027         for (RenderBox* obj = firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
</pre>
<hr />
<pre>
3067     // Clamp to our existing edges. We can never grow. We only shrink.
3068     LayoutUnit leftEdge = borderLeft() + paddingLeft();
3069     LayoutUnit rightEdge = leftEdge + oldWidth;
3070     left = std::min(rightEdge, std::max(leftEdge, left));
3071     right = std::max(leftEdge, std::min(rightEdge, right));
3072 
3073     LayoutUnit newContentWidth = right - left;
3074     if (newContentWidth == oldWidth)
3075         return;
3076 
3077     setOverrideContentLogicalWidth(newContentWidth);
3078     layoutBlock(false);
3079     clearOverrideContentLogicalWidth();
3080 }
3081 
3082 void RenderBlockFlow::markLinesDirtyInBlockRange(LayoutUnit logicalTop, LayoutUnit logicalBottom, RootInlineBox* highest)
3083 {
3084     if (logicalTop &gt;= logicalBottom)
3085         return;
3086 
<span class="line-modified">3087     // Floats currently affect the choice of layout path.</span>
<span class="line-modified">3088     if (simpleLineLayout()) {</span>
<span class="line-added">3089         invalidateLineLayoutPath();</span>
<span class="line-added">3090         return;</span>
<span class="line-added">3091     }</span>
<span class="line-added">3092 </span>
<span class="line-added">3093 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">3094     if (layoutFormattingContextLineLayout()) {</span>
3095         invalidateLineLayoutPath();
3096         return;
3097     }
<span class="line-added">3098 #endif</span>
3099 
3100     RootInlineBox* lowestDirtyLine = lastRootBox();
3101     RootInlineBox* afterLowest = lowestDirtyLine;
3102     while (lowestDirtyLine &amp;&amp; lowestDirtyLine-&gt;lineBottomWithLeading() &gt;= logicalBottom &amp;&amp; logicalBottom &lt; LayoutUnit::max()) {
3103         afterLowest = lowestDirtyLine;
3104         lowestDirtyLine = lowestDirtyLine-&gt;prevRootBox();
3105     }
3106 
3107     while (afterLowest &amp;&amp; afterLowest != highest &amp;&amp; (afterLowest-&gt;lineBottomWithLeading() &gt;= logicalTop || afterLowest-&gt;lineBottomWithLeading() &lt; 0)) {
3108         afterLowest-&gt;markDirty();
3109         afterLowest = afterLowest-&gt;prevRootBox();
3110     }
3111 }
3112 
3113 Optional&lt;int&gt; RenderBlockFlow::firstLineBaseline() const
3114 {
3115     if (isWritingModeRoot() &amp;&amp; !isRubyRun() &amp;&amp; !isGridItem())
3116         return WTF::nullopt;
3117 
3118     if (!childrenInline())
3119         return RenderBlock::firstLineBaseline();
3120 
3121     if (!hasLines())
3122         return WTF::nullopt;
3123 
<span class="line-modified">3124 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">3125     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">3126         return floorToInt(layoutFormattingContextLineLayout()-&gt;firstLineBaseline());</span>
<span class="line-added">3127 #endif</span>
<span class="line-added">3128 </span>
<span class="line-added">3129     if (simpleLineLayout())</span>
<span class="line-added">3130         return { SimpleLineLayout::computeFlowFirstLineBaseline(*this, *simpleLineLayout()) };</span>
3131 
3132     ASSERT(firstRootBox());
3133     if (style().isFlippedLinesWritingMode())
3134         return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().descent(firstRootBox()-&gt;baselineType());
3135     return firstRootBox()-&gt;logicalTop() + firstLineStyle().fontMetrics().ascent(firstRootBox()-&gt;baselineType());
3136 }
3137 
3138 Optional&lt;int&gt; RenderBlockFlow::inlineBlockBaseline(LineDirectionMode lineDirection) const
3139 {
3140     if (isWritingModeRoot() &amp;&amp; !isRubyRun())
3141         return WTF::nullopt;
3142 
3143     // Note that here we only take the left and bottom into consideration. Our caller takes the right and top into consideration.
3144     float boxHeight = lineDirection == HorizontalLine ? height() + m_marginBox.bottom() : width() + m_marginBox.left();
3145     float lastBaseline;
3146     if (!childrenInline()) {
3147         Optional&lt;int&gt; inlineBlockBaseline = RenderBlock::inlineBlockBaseline(lineDirection);
3148         if (!inlineBlockBaseline)
3149             return inlineBlockBaseline;
3150         lastBaseline = inlineBlockBaseline.value();
3151     } else {
3152         if (!hasLines()) {
3153             if (!hasLineIfEmpty())
3154                 return WTF::nullopt;
3155             const auto&amp; fontMetrics = firstLineStyle().fontMetrics();
3156             return Optional&lt;int&gt;(fontMetrics.ascent()
3157                 + (lineHeight(true, lineDirection, PositionOfInteriorLineBoxes) - fontMetrics.height()) / 2
3158                 + (lineDirection == HorizontalLine ? borderTop() + paddingTop() : borderRight() + paddingRight()));
3159         }
3160 
<span class="line-modified">3161         if (simpleLineLayout())</span>
<span class="line-modified">3162             lastBaseline = SimpleLineLayout::computeFlowLastLineBaseline(*this, *simpleLineLayout());</span>
<span class="line-added">3163 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">3164         else if (layoutFormattingContextLineLayout())</span>
<span class="line-added">3165             lastBaseline = floorToInt(layoutFormattingContextLineLayout()-&gt;lastLineBaseline());</span>
<span class="line-added">3166 #endif</span>
3167         else {
3168             bool isFirstLine = lastRootBox() == firstRootBox();
3169             const auto&amp; style = isFirstLine ? firstLineStyle() : this-&gt;style();
3170             // InlineFlowBox::placeBoxesInBlockDirection will flip lines in case of verticalLR mode, so we can assume verticalRL for now.
3171             lastBaseline = style.fontMetrics().ascent(lastRootBox()-&gt;baselineType())
3172                 + (style.isFlippedLinesWritingMode() ? logicalHeight() - lastRootBox()-&gt;logicalBottom() : lastRootBox()-&gt;logicalTop());
3173         }
3174     }
3175     // According to the CSS spec http://www.w3.org/TR/CSS21/visudet.html, we shouldn&#39;t be performing this min, but should
3176     // instead be returning boxHeight directly. However, we feel that a min here is better behavior (and is consistent
3177     // enough with the spec to not cause tons of breakages).
3178     return style().overflowY() == Overflow::Visible ? lastBaseline : std::min(boxHeight, lastBaseline);
3179 }
3180 
3181 void RenderBlockFlow::setSelectionState(SelectionState state)
3182 {
3183     if (state != SelectionNone)
3184         ensureLineBoxes();
3185     RenderBoxModelObject::setSelectionState(state);
3186 }
3187 
3188 GapRects RenderBlockFlow::inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
3189     LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp; cache, const PaintInfo* paintInfo)
3190 {
<span class="line-modified">3191     ASSERT(!simpleLineLayout());</span>
3192 
3193     GapRects result;
3194 
3195     bool containsStart = selectionState() == SelectionStart || selectionState() == SelectionBoth;
3196 
3197     if (!hasLines()) {
3198         if (containsStart) {
3199             // Update our lastLogicalTop to be the bottom of the block. &lt;hr&gt;s or empty blocks with height can trip this case.
3200             lastLogicalTop = blockDirectionOffset(rootBlock, offsetFromRootBlock) + logicalHeight();
3201             lastLogicalLeft = logicalLeftSelectionOffset(rootBlock, logicalHeight(), cache);
3202             lastLogicalRight = logicalRightSelectionOffset(rootBlock, logicalHeight(), cache);
3203         }
3204         return result;
3205     }
3206 
3207     RootInlineBox* lastSelectedLine = 0;
3208     RootInlineBox* curr;
3209     for (curr = firstRootBox(); curr &amp;&amp; !curr-&gt;hasSelectedChildren(); curr = curr-&gt;nextRootBox()) { }
3210 
3211     // Now paint the gaps for the lines.
</pre>
<hr />
<pre>
3277         return nullptr;
3278 
3279     if (childrenInline()) {
3280         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox()) {
3281             if (!i--)
3282                 return box;
3283         }
3284         return nullptr;
3285     }
3286 
3287     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3288         if (!shouldCheckLines(blockFlow))
3289             continue;
3290         if (RootInlineBox* box = blockFlow.lineAtIndex(i))
3291             return box;
3292     }
3293 
3294     return nullptr;
3295 }
3296 
<span class="line-modified">3297 int RenderBlockFlow::lineCount() const</span>
3298 {
<span class="line-added">3299     // FIXME: This should be tested by clients.</span>
3300     if (style().visibility() != Visibility::Visible)
3301         return 0;
3302 


3303     if (childrenInline()) {
<span class="line-modified">3304 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">3305         if (layoutFormattingContextLineLayout())</span>
<span class="line-modified">3306             return layoutFormattingContextLineLayout()-&gt;lineCount();</span>
<span class="line-modified">3307 #endif</span>
<span class="line-modified">3308         if (simpleLineLayout())</span>
<span class="line-modified">3309             return simpleLineLayout()-&gt;lineCount();</span>
<span class="line-modified">3310 </span>
<span class="line-modified">3311         if (complexLineLayout())</span>
<span class="line-modified">3312             return complexLineLayout()-&gt;lineCount();</span>
<span class="line-modified">3313 </span>
<span class="line-modified">3314         return 0;</span>


3315     }
3316 
<span class="line-added">3317     int count = 0;</span>
3318     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3319         if (!shouldCheckLines(blockFlow))
3320             continue;
<span class="line-modified">3321         count += blockFlow.lineCount();</span>






3322     }
3323 
3324     return count;
3325 }
3326 
3327 static int getHeightForLineCount(const RenderBlockFlow&amp; block, int lineCount, bool includeBottom, int&amp; count)
3328 {
3329     if (block.style().visibility() != Visibility::Visible)
3330         return -1;
3331 
3332     if (block.childrenInline()) {
3333         for (auto* box = block.firstRootBox(); box; box = box-&gt;nextRootBox()) {
3334             if (++count == lineCount)
3335                 return box-&gt;lineBottom() + (includeBottom ? (block.borderBottom() + block.paddingBottom()) : 0_lu);
3336         }
3337     } else {
3338         RenderBox* normalFlowChildWithoutLines = nullptr;
3339         for (auto* obj = block.firstChildBox(); obj; obj = obj-&gt;nextSiblingBox()) {
3340             if (is&lt;RenderBlockFlow&gt;(*obj) &amp;&amp; shouldCheckLines(downcast&lt;RenderBlockFlow&gt;(*obj))) {
3341                 int result = getHeightForLineCount(downcast&lt;RenderBlockFlow&gt;(*obj), lineCount, false, count);
</pre>
<hr />
<pre>
3363         return;
3364 
3365     if (childrenInline() &amp;&amp; hasMarkupTruncation()) {
3366         ensureLineBoxes();
3367 
3368         setHasMarkupTruncation(false);
3369         for (auto* box = firstRootBox(); box; box = box-&gt;nextRootBox())
3370             box-&gt;clearTruncation();
3371         return;
3372     }
3373 
3374     for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) {
3375         if (shouldCheckLines(blockFlow))
3376             blockFlow.clearTruncation();
3377     }
3378 }
3379 
3380 bool RenderBlockFlow::containsNonZeroBidiLevel() const
3381 {
3382     for (auto* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
<span class="line-modified">3383         for (auto* box = root-&gt;firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
3384             if (box-&gt;bidiLevel())
3385                 return true;
3386         }
3387     }
3388     return false;
3389 }
3390 
3391 Position RenderBlockFlow::positionForBox(InlineBox *box, bool start) const
3392 {
3393     if (!box)
3394         return Position();
3395 
3396     if (!box-&gt;renderer().nonPseudoNode())
3397         return createLegacyEditingPosition(nonPseudoElement(), start ? caretMinOffset() : caretMaxOffset());
3398 
3399     if (!is&lt;InlineTextBox&gt;(*box))
3400         return createLegacyEditingPosition(box-&gt;renderer().nonPseudoNode(), start ? box-&gt;renderer().caretMinOffset() : box-&gt;renderer().caretMaxOffset());
3401 
3402     auto&amp; textBox = downcast&lt;InlineTextBox&gt;(*box);
3403     return createLegacyEditingPosition(textBox.renderer().nonPseudoNode(), start ? textBox.start() : textBox.start() + textBox.len());
</pre>
<hr />
<pre>
3471 VisiblePosition RenderBlockFlow::positionForPointWithInlineChildren(const LayoutPoint&amp; pointInLogicalContents, const RenderFragmentContainer* fragment)
3472 {
3473     ASSERT(childrenInline());
3474 
3475     ensureLineBoxes();
3476 
3477     if (!firstRootBox())
3478         return createVisiblePosition(0, DOWNSTREAM);
3479 
3480     bool linesAreFlipped = style().isFlippedLinesWritingMode();
3481     bool blocksAreFlipped = style().isFlippedBlocksWritingMode();
3482 
3483     // look for the closest line box in the root box which is at the passed-in y coordinate
3484     InlineBox* closestBox = 0;
3485     RootInlineBox* firstRootBoxWithChildren = 0;
3486     RootInlineBox* lastRootBoxWithChildren = 0;
3487     for (RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox()) {
3488         if (fragment &amp;&amp; root-&gt;containingFragment() != fragment)
3489             continue;
3490 
<span class="line-modified">3491         if (!root-&gt;firstLeafDescendant())</span>
3492             continue;
3493         if (!firstRootBoxWithChildren)
3494             firstRootBoxWithChildren = root;
3495 
3496         if (!linesAreFlipped &amp;&amp; root-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &lt; root-&gt;lineTopWithLeading()
3497             || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;lineTopWithLeading())))
3498             break;
3499 
3500         lastRootBoxWithChildren = root;
3501 
3502         // check if this root line box is located at this y coordinate
3503         if (pointInLogicalContents.y() &lt; root-&gt;selectionBottom() || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == root-&gt;selectionBottom())) {
3504             if (linesAreFlipped) {
3505                 RootInlineBox* nextRootBoxWithChildren = root-&gt;nextRootBox();
<span class="line-modified">3506                 while (nextRootBoxWithChildren &amp;&amp; !nextRootBoxWithChildren-&gt;firstLeafDescendant())</span>
3507                     nextRootBoxWithChildren = nextRootBoxWithChildren-&gt;nextRootBox();
3508 
3509                 if (nextRootBoxWithChildren &amp;&amp; nextRootBoxWithChildren-&gt;isFirstAfterPageBreak() &amp;&amp; (pointInLogicalContents.y() &gt; nextRootBoxWithChildren-&gt;lineTopWithLeading()
3510                     || (!blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == nextRootBoxWithChildren-&gt;lineTopWithLeading())))
3511                     continue;
3512             }
3513             closestBox = root-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3514             if (closestBox)
3515                 break;
3516         }
3517     }
3518 
3519     bool moveCaretToBoundary = frame().editor().behavior().shouldMoveCaretToHorizontalBoundaryWhenPastTopOrBottom();
3520 
3521     if (!moveCaretToBoundary &amp;&amp; !closestBox &amp;&amp; lastRootBoxWithChildren) {
3522         // y coordinate is below last root line box, pretend we hit it
3523         closestBox = lastRootBoxWithChildren-&gt;closestLeafChildForLogicalLeftPosition(pointInLogicalContents.x());
3524     }
3525 
3526     if (closestBox) {
3527         if (moveCaretToBoundary) {
3528             LayoutUnit firstRootBoxWithChildrenTop = std::min(firstRootBoxWithChildren-&gt;selectionTop(), LayoutUnit(firstRootBoxWithChildren-&gt;logicalTop()));
3529             if (pointInLogicalContents.y() &lt; firstRootBoxWithChildrenTop
3530                 || (blocksAreFlipped &amp;&amp; pointInLogicalContents.y() == firstRootBoxWithChildrenTop)) {
<span class="line-modified">3531                 InlineBox* box = firstRootBoxWithChildren-&gt;firstLeafDescendant();</span>
3532                 if (box-&gt;isLineBreak()) {
<span class="line-modified">3533                     if (InlineBox* newBox = box-&gt;nextLeafOnLineIgnoringLineBreak())</span>
3534                         box = newBox;
3535                 }
3536                 // y coordinate is above first root line box, so return the start of the first
3537                 return VisiblePosition(positionForBox(box, true), DOWNSTREAM);
3538             }
3539         }
3540 
3541         // pass the box a top position that is inside it
3542         LayoutPoint point(pointInLogicalContents.x(), closestBox-&gt;root().blockDirectionPointInLine());
3543         if (!isHorizontalWritingMode())
3544             point = point.transposedPoint();
3545         if (closestBox-&gt;renderer().isReplaced())
3546             return positionForPointRespectingEditingBoundaries(*this, downcast&lt;RenderBox&gt;(closestBox-&gt;renderer()), point);
3547         return closestBox-&gt;renderer().positionForPoint(point, nullptr);
3548     }
3549 
3550     if (lastRootBoxWithChildren) {
3551         // We hit this case for Mac behavior when the Y coordinate is below the last box.
3552         ASSERT(moveCaretToBoundary);
3553         InlineBox* logicallyLastBox;
</pre>
<hr />
<pre>
3573 {
3574     return RenderBlock::positionForPoint(point, nullptr);
3575 }
3576 
3577 void RenderBlockFlow::addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp; rects, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject*)
3578 {
3579     ASSERT(childrenInline());
3580     for (RootInlineBox* curr = firstRootBox(); curr; curr = curr-&gt;nextRootBox()) {
3581         LayoutUnit top = std::max(curr-&gt;lineTop(), LayoutUnit(curr-&gt;top()));
3582         LayoutUnit bottom = std::min(curr-&gt;lineBottom(), LayoutUnit(curr-&gt;top() + curr-&gt;height()));
3583         LayoutRect rect { LayoutUnit(additionalOffset.x() + curr-&gt;x()), additionalOffset.y() + top, LayoutUnit(curr-&gt;width()), bottom - top };
3584         if (!rect.isEmpty())
3585             rects.append(rect);
3586     }
3587 }
3588 
3589 void RenderBlockFlow::paintInlineChildren(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
3590 {
3591     ASSERT(childrenInline());
3592 
<span class="line-added">3593 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">3594     if (layoutFormattingContextLineLayout()) {</span>
<span class="line-added">3595         layoutFormattingContextLineLayout()-&gt;paint(paintInfo, paintOffset);</span>
<span class="line-added">3596         return;</span>
<span class="line-added">3597     }</span>
<span class="line-added">3598 #endif</span>
<span class="line-added">3599 </span>
3600     if (auto simpleLineLayout = this-&gt;simpleLineLayout()) {
3601         SimpleLineLayout::paintFlow(*this, *simpleLineLayout, paintInfo, paintOffset);
3602         return;
3603     }
3604 
<span class="line-modified">3605     if (complexLineLayout())</span>
<span class="line-modified">3606         complexLineLayout()-&gt;lineBoxes().paint(this, paintInfo, paintOffset);</span>
3607 }
3608 
3609 bool RenderBlockFlow::relayoutForPagination()
3610 {
3611     if (!multiColumnFlow() || !multiColumnFlow()-&gt;shouldRelayoutForPagination())
3612         return false;
3613 
3614     multiColumnFlow()-&gt;setNeedsHeightsRecalculation(false);
3615     multiColumnFlow()-&gt;setInBalancingPass(true); // Prevent re-entering this method (and recursion into layout).
3616 
3617     bool needsRelayout;
3618     bool neededRelayout = false;
3619     bool firstPass = true;
3620     do {
3621         // Column heights may change here because of balancing. We may have to do multiple layout
3622         // passes, depending on how the contents is fitted to the changed column heights. In most
3623         // cases, laying out again twice or even just once will suffice. Sometimes we need more
3624         // passes than that, though, but the number of retries should not exceed the number of
3625         // columns, unless we have a bug.
3626         needsRelayout = false;
</pre>
<hr />
<pre>
3638         if (needsRelayout) {
3639             // Layout again. Column balancing resulted in a new height.
3640             neededRelayout = true;
3641             multiColumnFlow()-&gt;setChildNeedsLayout(MarkOnlyThis);
3642             setChildNeedsLayout(MarkOnlyThis);
3643             layoutBlock(false);
3644         }
3645         firstPass = false;
3646     } while (needsRelayout);
3647 
3648     multiColumnFlow()-&gt;setInBalancingPass(false);
3649 
3650     return neededRelayout;
3651 }
3652 
3653 bool RenderBlockFlow::hasLines() const
3654 {
3655     if (!childrenInline())
3656         return false;
3657 
<span class="line-modified">3658 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-modified">3659     if (layoutFormattingContextLineLayout())</span>
<span class="line-added">3660         return layoutFormattingContextLineLayout()-&gt;lineCount();</span>
<span class="line-added">3661 #endif</span>
<span class="line-added">3662     if (simpleLineLayout())</span>
<span class="line-added">3663         return simpleLineLayout()-&gt;lineCount();</span>
3664 
<span class="line-modified">3665     return complexLineLayout() &amp;&amp; complexLineLayout()-&gt;lineBoxes().firstLineBox();</span>
3666 }
3667 
3668 void RenderBlockFlow::invalidateLineLayoutPath()
3669 {
3670     switch (lineLayoutPath()) {
3671     case UndeterminedPath:
3672     case ForceLineBoxesPath:
<span class="line-modified">3673         ASSERT(!simpleLineLayout());</span>
3674         return;
3675     case LineBoxesPath:
<span class="line-modified">3676         ASSERT(!simpleLineLayout());</span>
3677         setLineLayoutPath(UndeterminedPath);
3678         return;
<span class="line-added">3679     case LayoutFormattingContextPath: // FIXME: Not all clients of invalidateLineLayoutPath() actually need to wipe the layout.</span>
3680     case SimpleLinesPath:
3681         // The simple line layout may have become invalid.
<span class="line-modified">3682         m_lineLayout = WTF::Monostate();</span>
3683         setLineLayoutPath(UndeterminedPath);
3684         if (needsLayout())
3685             return;
3686         // FIXME: We should just kick off a subtree layout here (if needed at all) see webkit.org/b/172947.
3687         setNeedsLayout();
3688         return;
3689     }
3690     ASSERT_NOT_REACHED();
3691 }
3692 
3693 void RenderBlockFlow::layoutSimpleLines(bool relayoutChildren, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)
3694 {
<span class="line-modified">3695     bool needsLayout = selfNeedsLayout() || relayoutChildren || !simpleLineLayout();</span>
<span class="line-modified">3696     if (needsLayout)</span>
<span class="line-modified">3697         m_lineLayout = SimpleLineLayout::create(*this);</span>
<span class="line-modified">3698 </span>
<span class="line-modified">3699     auto&amp; simpleLineLayout = *this-&gt;simpleLineLayout();</span>
<span class="line-added">3700 </span>
3701     if (view().frameView().layoutContext().layoutState() &amp;&amp; view().frameView().layoutContext().layoutState()-&gt;isPaginated()) {
<span class="line-modified">3702         simpleLineLayout.setIsPaginated();</span>
<span class="line-modified">3703         SimpleLineLayout::adjustLinePositionsForPagination(simpleLineLayout, *this);</span>
3704     }
<span class="line-added">3705 </span>
3706     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))
3707         renderer.clearNeedsLayout();
<span class="line-modified">3708 </span>
<span class="line-modified">3709     LayoutUnit lineLayoutHeight = SimpleLineLayout::computeFlowHeight(*this, simpleLineLayout);</span>
3710     LayoutUnit lineLayoutTop = borderAndPaddingBefore();
3711     repaintLogicalTop = lineLayoutTop;
3712     repaintLogicalBottom = needsLayout ? repaintLogicalTop + lineLayoutHeight + borderAndPaddingAfter() : repaintLogicalTop;
3713     setLogicalHeight(lineLayoutTop + lineLayoutHeight + borderAndPaddingAfter());
3714 }
3715 
<span class="line-modified">3716 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">3717 void RenderBlockFlow::layoutLFCLines(bool, LayoutUnit&amp; repaintLogicalTop, LayoutUnit&amp; repaintLogicalBottom)</span>
3718 {
<span class="line-modified">3719     if (!layoutFormattingContextLineLayout())</span>
<span class="line-added">3720         m_lineLayout = makeUnique&lt;LayoutIntegration::LineLayout&gt;(*this);</span>
3721 
<span class="line-modified">3722     auto&amp; layoutFormattingContextLineLayout = *this-&gt;layoutFormattingContextLineLayout();</span>

3723 
<span class="line-modified">3724     for (auto&amp; renderer : childrenOfType&lt;RenderObject&gt;(*this))</span>
<span class="line-modified">3725         renderer.clearNeedsLayout();</span>






3726 
<span class="line-modified">3727     layoutFormattingContextLineLayout.layout();</span>
<span class="line-added">3728 </span>
<span class="line-added">3729     auto contentHeight = layoutFormattingContextLineLayout.contentLogicalHeight();</span>
<span class="line-added">3730     auto contentBoxTop = borderAndPaddingBefore();</span>
<span class="line-added">3731     auto contentBoxBottom = contentBoxTop + contentHeight;</span>
<span class="line-added">3732     auto borderBoxBottom = contentBoxBottom + borderAndPaddingAfter();</span>
<span class="line-added">3733 </span>
<span class="line-added">3734     repaintLogicalTop = contentBoxTop;</span>
<span class="line-added">3735     repaintLogicalBottom = borderBoxBottom;</span>
<span class="line-added">3736     setLogicalHeight(borderBoxBottom);</span>
3737 }
<span class="line-added">3738 #endif</span>
3739 
3740 void RenderBlockFlow::ensureLineBoxes()
3741 {
3742     if (!childrenInline())
3743         return;
3744 
3745     setLineLayoutPath(ForceLineBoxesPath);
3746 
<span class="line-modified">3747     if (complexLineLayout() || !hasLineLayout())</span>
3748         return;
3749 
<span class="line-modified">3750     auto simpleLineLayout = makeRefPtr(this-&gt;simpleLineLayout());</span>

3751 
<span class="line-modified">3752     m_lineLayout = makeUnique&lt;ComplexLineLayout&gt;(*this);</span>
<span class="line-modified">3753 </span>
<span class="line-modified">3754     if (simpleLineLayout) {</span>
<span class="line-modified">3755         if (SimpleLineLayout::canUseForLineBoxTree(*this, *simpleLineLayout)) {</span>
<span class="line-added">3756             SimpleLineLayout::generateLineBoxTree(*this, *simpleLineLayout);</span>
<span class="line-added">3757             return;</span>
<span class="line-added">3758         }</span>
3759     }


3760 
<span class="line-modified">3761     auto&amp; complexLineLayout = *this-&gt;complexLineLayout();</span>
<span class="line-added">3762 </span>
<span class="line-added">3763 #if ASSERT_ENABLED</span>
3764     LayoutUnit oldHeight = logicalHeight();
3765 #endif
3766     bool didNeedLayout = needsLayout();
3767 
3768     bool relayoutChildren = false;
3769     LayoutUnit repaintLogicalTop;
3770     LayoutUnit repaintLogicalBottom;
<span class="line-modified">3771     if (simpleLineLayout &amp;&amp; simpleLineLayout-&gt;isPaginated()) {</span>
3772         PaginatedLayoutStateMaintainer state(*this);
<span class="line-modified">3773         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3774         // This matches relayoutToAvoidWidows.
3775         if (shouldBreakAtLineToAvoidWidow())
<span class="line-modified">3776             complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3777         // FIXME: This is needed as long as simple and normal line layout produce different line breakings.
3778         repaint();
3779     } else
<span class="line-modified">3780         complexLineLayout.layoutLineBoxes(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</span>
3781 
3782     updateLogicalHeight();
3783     ASSERT(didNeedLayout || logicalHeight() == oldHeight);
3784 
3785     if (!didNeedLayout)
3786         clearNeedsLayout();
3787 }
3788 
3789 #if ENABLE(TREE_DEBUGGING)
3790 void RenderBlockFlow::outputLineTreeAndMark(WTF::TextStream&amp; stream, const InlineBox* markedBox, int depth) const
3791 {
3792     for (const RootInlineBox* root = firstRootBox(); root; root = root-&gt;nextRootBox())
3793         root-&gt;outputLineTreeAndMark(stream, markedBox, depth);
3794 
3795     if (auto simpleLineLayout = this-&gt;simpleLineLayout())
3796         SimpleLineLayout::outputLineLayoutForFlow(stream, *this, *simpleLineLayout, depth);
3797 }
3798 #endif
3799 
3800 RenderBlockFlow::RenderBlockFlowRareData&amp; RenderBlockFlow::ensureRareBlockFlowData()
</pre>
</td>
</tr>
</table>
<center><a href="RenderBlock.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBlockFlow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
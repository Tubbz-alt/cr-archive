<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLMediaElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMeterElement.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,11 ***</span>
  #pragma once
  
  #if ENABLE(VIDEO)
  
  #include &quot;ActiveDOMObject.h&quot;
<span class="line-removed">- #include &quot;ApplicationStateChangeListener.h&quot;</span>
  #include &quot;AutoplayEvent.h&quot;
  #include &quot;DeferrableTask.h&quot;
  #include &quot;GenericEventQueue.h&quot;
  #include &quot;HTMLElement.h&quot;
  #include &quot;HTMLMediaElementEnums.h&quot;
<span class="line-new-header">--- 26,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,11 ***</span>
  #include &lt;wtf/WeakPtr.h&gt;
  
  #if ENABLE(VIDEO_TRACK)
  #include &quot;AudioTrack.h&quot;
  #include &quot;CaptionUserPreferences.h&quot;
<span class="line-removed">- #include &quot;PODIntervalTree.h&quot;</span>
  #include &quot;TextTrack.h&quot;
  #include &quot;TextTrackCue.h&quot;
  #include &quot;VTTCue.h&quot;
  #include &quot;VideoTrack.h&quot;
  #endif
<span class="line-new-header">--- 44,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,14 ***</span>
  class VideoTrackList;
  class VideoTrackPrivate;
  class WebKitMediaKeys;
  
  template&lt;typename&gt; class DOMPromiseDeferred;
  
  #if ENABLE(VIDEO_TRACK)
<span class="line-modified">! using CueIntervalTree = PODIntervalTree&lt;MediaTime, TextTrackCue*&gt;;</span>
<span class="line-removed">- using CueInterval = CueIntervalTree::IntervalType;</span>
  using CueList = Vector&lt;CueInterval&gt;;
  #endif
  
  using MediaProvider = Optional&lt;Variant&lt;
  #if ENABLE(MEDIA_STREAM)
<span class="line-new-header">--- 102,18 ---</span>
  class VideoTrackList;
  class VideoTrackPrivate;
  class WebKitMediaKeys;
  
  template&lt;typename&gt; class DOMPromiseDeferred;
<span class="line-added">+ template&lt;typename, typename&gt; class PODInterval;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">+ class RemotePlayback;</span>
<span class="line-added">+ #endif</span>
  
  #if ENABLE(VIDEO_TRACK)
<span class="line-modified">! using CueInterval = PODInterval&lt;MediaTime, TextTrackCue*&gt;;</span>
  using CueList = Vector&lt;CueInterval&gt;;
  #endif
  
  using MediaProvider = Optional&lt;Variant&lt;
  #if ENABLE(MEDIA_STREAM)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,11 ***</span>
      , public PlatformMediaSessionClient
      , private MediaCanStartListener
      , private MediaPlayerClient
      , private MediaProducer
      , private VisibilityChangeClient
<span class="line-removed">-     , private ApplicationStateChangeListener</span>
  #if ENABLE(VIDEO_TRACK)
      , private AudioTrackClient
      , private TextTrackClient
      , private VideoTrackClient
  #endif
<span class="line-new-header">--- 131,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,10 ***</span>
<span class="line-new-header">--- 145,11 ---</span>
      , private CDMClient
  #endif
  #if !RELEASE_LOG_DISABLED
      , private LoggerHelper
  #endif
<span class="line-added">+     , public CanMakeWeakPtr&lt;HTMLMediaElement, WeakPtrFactoryInitialization::Eager&gt;</span>
  {
      WTF_MAKE_ISO_ALLOCATED(HTMLMediaElement);
  public:
      using WeakValueType = HTMLElement::WeakValueType;
      using HTMLElement::weakPtrFactory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,12 ***</span>
  
      static HashSet&lt;HTMLMediaElement*&gt;&amp; allMediaElements();
  
      WEBCORE_EXPORT static RefPtr&lt;HTMLMediaElement&gt; bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose);
  
<span class="line-removed">-     static bool isRunningDestructor();</span>
<span class="line-removed">- </span>
      WEBCORE_EXPORT void rewind(double timeDelta);
      WEBCORE_EXPORT void returnToRealtime() override;
  
      // Eventually overloaded in HTMLVideoElement
      bool supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenMode) const override { return false; };
<span class="line-new-header">--- 162,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,13 ***</span>
  #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
      void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
  #ifdef __OBJC__
      PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
  #endif
<span class="line-modified">!     void setVideoFullscreenFrame(FloatRect);</span>
<span class="line-modified">!     void setVideoFullscreenGravity(MediaPlayerEnums::VideoGravity);</span>
<span class="line-modified">!     MediaPlayerEnums::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }</span>
  #endif
  
      void scheduleCheckPlaybackTargetCompatability();
      void checkPlaybackTargetCompatablity();
      void scheduleResolvePendingPlayPromises();
<span class="line-new-header">--- 183,13 ---</span>
  #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
      void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
  #ifdef __OBJC__
      PlatformLayer* videoFullscreenLayer() const { return m_videoFullscreenLayer.get(); }
  #endif
<span class="line-modified">!     virtual void setVideoFullscreenFrame(FloatRect);</span>
<span class="line-modified">!     void setVideoFullscreenGravity(MediaPlayer::VideoGravity);</span>
<span class="line-modified">!     MediaPlayer::VideoGravity videoFullscreenGravity() const { return m_videoFullscreenGravity; }</span>
  #endif
  
      void scheduleCheckPlaybackTargetCompatability();
      void checkPlaybackTargetCompatablity();
      void scheduleResolvePendingPlayPromises();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 198,11 ***</span>
      void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
      void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
      void scheduleNotifyAboutPlaying();
      void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
  
<span class="line-modified">!     MediaPlayerEnums::MovieLoadType movieLoadType() const;</span>
  
      bool inActiveDocument() const { return m_inActiveDocument; }
  
      Document* hostingDocument() const final { return &amp;document(); }
  
<span class="line-new-header">--- 198,11 ---</span>
      void rejectPendingPlayPromises(PlayPromiseVector&amp;&amp;, Ref&lt;DOMException&gt;&amp;&amp;);
      void resolvePendingPlayPromises(PlayPromiseVector&amp;&amp;);
      void scheduleNotifyAboutPlaying();
      void notifyAboutPlaying(PlayPromiseVector&amp;&amp;);
  
<span class="line-modified">!     MediaPlayer::MovieLoadType movieLoadType() const;</span>
  
      bool inActiveDocument() const { return m_inActiveDocument; }
  
      Document* hostingDocument() const final { return &amp;document(); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,11 ***</span>
      VideoTrackList&amp; ensureVideoTracks();
      AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
      TextTrackList* textTracks() const { return m_textTracks.get(); }
      VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
  
<span class="line-modified">!     CueList currentlyActiveCues() const { return m_currentlyActiveCues; }</span>
  
      void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
      void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
      void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
      void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
<span class="line-new-header">--- 343,11 ---</span>
      VideoTrackList&amp; ensureVideoTracks();
      AudioTrackList* audioTracks() const { return m_audioTracks.get(); }
      TextTrackList* textTracks() const { return m_textTracks.get(); }
      VideoTrackList* videoTracks() const { return m_videoTracks.get(); }
  
<span class="line-modified">!     CueList currentlyActiveCues() const;</span>
  
      void addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
      void addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp;);
      void addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp;);
      void removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 401,20 ***</span>
<span class="line-new-header">--- 401,23 ---</span>
      void videoTrackSelectedChanged(VideoTrack&amp;) final;
  
      bool requiresTextTrackRepresentation() const;
      void setTextTrackRepresentation(TextTrackRepresentation*);
      void syncTextTrackBounds();
<span class="line-added">+ </span>
<span class="line-added">+     void captionPreferencesChanged();</span>
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      void webkitShowPlaybackTargetPicker();
      bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;
      bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;
  
      void wirelessRoutesAvailableDidChange() override;
      void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;) override;
      void setShouldPlayToPlaybackTarget(bool) override;
<span class="line-added">+     void playbackTargetPickerWasDismissed() override;</span>
  #endif
      bool isPlayingToWirelessPlaybackTarget() const override { return m_isPlayingToWirelessTarget; };
      void setIsPlayingToWirelessTarget(bool);
      bool webkitCurrentPlaybackTargetIsWireless() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,12 ***</span>
      MediaControls* mediaControls() const;
  
      void sourceWasRemoved(HTMLSourceElement&amp;);
      void sourceWasAdded(HTMLSourceElement&amp;);
  
<span class="line-removed">-     void privateBrowsingStateDidChange(PAL::SessionID) override;</span>
<span class="line-removed">- </span>
      // Media cache management.
      WEBCORE_EXPORT static void setMediaCacheDirectory(const String&amp;);
      WEBCORE_EXPORT static const String&amp; mediaCacheDirectory();
      WEBCORE_EXPORT static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;);
      WEBCORE_EXPORT static void clearMediaCache(const String&amp;, WallTime modifiedSince = { });
<span class="line-new-header">--- 457,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 491,12 ***</span>
  
      void enteredOrExitedFullscreen() { configureMediaControls(); }
  
      unsigned long long fileSize() const;
  
<span class="line-modified">!     void mediaLoadingFailed(MediaPlayerEnums::NetworkState);</span>
<span class="line-modified">!     void mediaLoadingFailedFatally(MediaPlayerEnums::NetworkState);</span>
  
  #if ENABLE(MEDIA_SESSION)
      WEBCORE_EXPORT double playerVolume() const;
  
      const String&amp; kind() const { return m_kind; }
<span class="line-new-header">--- 492,12 ---</span>
  
      void enteredOrExitedFullscreen() { configureMediaControls(); }
  
      unsigned long long fileSize() const;
  
<span class="line-modified">!     void mediaLoadingFailed(MediaPlayer::NetworkState);</span>
<span class="line-modified">!     void mediaLoadingFailedFatally(MediaPlayer::NetworkState);</span>
  
  #if ENABLE(MEDIA_SESSION)
      WEBCORE_EXPORT double playerVolume() const;
  
      const String&amp; kind() const { return m_kind; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,11 ***</span>
      uint64_t elementID() const { return m_elementID; }
  #endif
  
      RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
  
<span class="line-modified">!     MediaPlayerEnums::Preload preloadValue() const { return m_preload; }</span>
      MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      void pageScaleFactorChanged();
      void userInterfaceLayoutDirectionChanged();
<span class="line-new-header">--- 512,11 ---</span>
      uint64_t elementID() const { return m_elementID; }
  #endif
  
      RefPtr&lt;VideoPlaybackQuality&gt; getVideoPlaybackQuality();
  
<span class="line-modified">!     MediaPlayer::Preload preloadValue() const { return m_preload; }</span>
      MediaElementSession&amp; mediaSession() const { return *m_mediaSession; }
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      void pageScaleFactorChanged();
      void userInterfaceLayoutDirectionChanged();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 554,11 ***</span>
      void updateRateChangeRestrictions();
  
      WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
  
  #if ENABLE(MEDIA_STREAM)
<span class="line-modified">!     void mediaStreamCaptureStarted() { resumeAutoplaying(); }</span>
      bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
  #endif
  
      bool supportsSeeking() const override;
  
<span class="line-new-header">--- 555,11 ---</span>
      void updateRateChangeRestrictions();
  
      WEBCORE_EXPORT const MediaResourceLoader* lastMediaResourceLoaderForTesting() const;
  
  #if ENABLE(MEDIA_STREAM)
<span class="line-modified">!     void mediaStreamCaptureStarted();</span>
      bool hasMediaStreamSrcObject() const { return m_mediaProvider &amp;&amp; WTF::holds_alternative&lt;RefPtr&lt;MediaStream&gt;&gt;(*m_mediaProvider); }
  #endif
  
      bool supportsSeeking() const override;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,12 ***</span>
<span class="line-new-header">--- 575,26 ---</span>
      bool isSuspended() const final;
  
      WEBCORE_EXPORT void didBecomeFullscreenElement() override;
      WEBCORE_EXPORT void willExitFullscreen();
  
<span class="line-added">+ #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">+     void scheduleEvent(Ref&lt;Event&gt;&amp;&amp;);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      enum class AutoplayEventPlaybackState { None, PreventedAutoplay, StartedWithUserGesture, StartedWithoutUserGesture };
  
<span class="line-added">+ #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">+     RemotePlayback&amp; remote() { return m_remote; }</span>
<span class="line-added">+     void remoteHasAvailabilityCallbacksChanged();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     void privateBrowsingStateDidChange(PAL::SessionID);</span>
<span class="line-added">+     void mediaVolumeDidChange();</span>
<span class="line-added">+     void applicationWillResignActive();</span>
<span class="line-added">+     void applicationDidBecomeActive();</span>
<span class="line-added">+ </span>
  protected:
      HTMLMediaElement(const QualifiedName&amp;, Document&amp;, bool createdByParser);
      virtual void finishInitialization();
      virtual ~HTMLMediaElement();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 597,25 ***</span>
      DisplayMode displayMode() const { return m_displayMode; }
      virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
  
      bool isMediaElement() const final { return true; }
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK)</span>
<span class="line-removed">-     bool ignoreTrackDisplayUpdateRequests() const { return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueTree.size(); }</span>
<span class="line-removed">-     void beginIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-removed">-     void endIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
      void setMediaControlsDependOnPageScaleFactor(bool);
      void updateMediaControlsAfterPresentationModeChange();
  #endif
  
<span class="line-modified">!     void scheduleEvent(const AtomString&amp; eventName);</span>
  
  private:
      void createMediaPlayer();
  
      bool supportsFocus() const override;
<span class="line-new-header">--- 612,19 ---</span>
      DisplayMode displayMode() const { return m_displayMode; }
      virtual void setDisplayMode(DisplayMode mode) { m_displayMode = mode; }
  
      bool isMediaElement() const final { return true; }
  
      RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;) override;
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      bool mediaControlsDependOnPageScaleFactor() const { return m_mediaControlsDependOnPageScaleFactor; }
      void setMediaControlsDependOnPageScaleFactor(bool);
      void updateMediaControlsAfterPresentationModeChange();
  #endif
  
<span class="line-modified">!     void scheduleEvent(const AtomString&amp;);</span>
  
  private:
      void createMediaPlayer();
  
      bool supportsFocus() const override;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 631,56 ***</span>
      void willBecomeFullscreenElement() override;
      void willStopBeingFullscreenElement() override;
  
      // ActiveDOMObject API.
      const char* activeDOMObjectName() const override;
<span class="line-removed">-     bool canSuspendForDocumentSuspension() const override;</span>
      void suspend(ReasonForSuspension) override;
      void resume() override;
      void stop() override;
      void stopWithoutDestroyingMediaPlayer();
      void contextDestroyed() override;
  
<span class="line-modified">!     void mediaVolumeDidChange() override;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void visibilityStateChanged() override;</span>
  
      virtual void updateDisplayState() { }
  
<span class="line-modified">!     void setReadyState(MediaPlayerEnums::ReadyState);</span>
<span class="line-modified">!     void setNetworkState(MediaPlayerEnums::NetworkState);</span>
  
      double effectivePlaybackRate() const;
      double requestedPlaybackRate() const;
  
<span class="line-modified">!     void mediaPlayerNetworkStateChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerReadyStateChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerTimeChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerVolumeChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerMuteChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerDurationChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerRateChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerPlaybackStateChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerSawUnsupportedTracks(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerResourceNotSupported(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerRepaint(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerSizeChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     bool mediaPlayerRenderingCanBeAccelerated(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerRenderingModeChanged(MediaPlayer*) override;</span>
<span class="line-modified">!     bool mediaPlayerAcceleratedCompositingEnabled() override;</span>
<span class="line-removed">-     void mediaPlayerEngineUpdated(MediaPlayer*) override;</span>
  
      void scheduleMediaEngineWasUpdated();
      void mediaEngineWasUpdated();
  
<span class="line-modified">!     void mediaPlayerFirstVideoFrameAvailable(MediaPlayer*) override;</span>
<span class="line-modified">!     void mediaPlayerCharacteristicChanged(MediaPlayer*) override;</span>
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
<span class="line-modified">!     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const override;</span>
<span class="line-modified">!     bool mediaPlayerKeyNeeded(MediaPlayer*, Uint8Array*) override;</span>
<span class="line-modified">!     String mediaPlayerMediaKeysStorageDirectory() const override;</span>
  #endif
  
  #if ENABLE(ENCRYPTED_MEDIA)
      void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
      void mediaPlayerWaitingForKeyChanged() final;
<span class="line-new-header">--- 640,52 ---</span>
      void willBecomeFullscreenElement() override;
      void willStopBeingFullscreenElement() override;
  
      // ActiveDOMObject API.
      const char* activeDOMObjectName() const override;
      void suspend(ReasonForSuspension) override;
      void resume() override;
      void stop() override;
      void stopWithoutDestroyingMediaPlayer();
      void contextDestroyed() override;
  
<span class="line-modified">!     void visibilityStateChanged() final;</span>
  
      virtual void updateDisplayState() { }
  
<span class="line-modified">!     void setReadyState(MediaPlayer::ReadyState);</span>
<span class="line-modified">!     void setNetworkState(MediaPlayer::NetworkState);</span>
  
      double effectivePlaybackRate() const;
      double requestedPlaybackRate() const;
  
<span class="line-modified">!     void mediaPlayerNetworkStateChanged() final;</span>
<span class="line-modified">!     void mediaPlayerReadyStateChanged() final;</span>
<span class="line-modified">!     void mediaPlayerTimeChanged() final;</span>
<span class="line-modified">!     void mediaPlayerVolumeChanged() final;</span>
<span class="line-modified">!     void mediaPlayerMuteChanged() final;</span>
<span class="line-modified">!     void mediaPlayerDurationChanged() final;</span>
<span class="line-modified">!     void mediaPlayerRateChanged() final;</span>
<span class="line-modified">!     void mediaPlayerPlaybackStateChanged() final;</span>
<span class="line-modified">!     void mediaPlayerResourceNotSupported() final;</span>
<span class="line-modified">!     void mediaPlayerRepaint() final;</span>
<span class="line-modified">!     void mediaPlayerSizeChanged() final;</span>
<span class="line-modified">!     bool mediaPlayerRenderingCanBeAccelerated() final;</span>
<span class="line-modified">!     void mediaPlayerRenderingModeChanged() final;</span>
<span class="line-modified">!     bool mediaPlayerAcceleratedCompositingEnabled() final;</span>
<span class="line-modified">!     void mediaPlayerEngineUpdated() final;</span>
  
      void scheduleMediaEngineWasUpdated();
      void mediaEngineWasUpdated();
  
<span class="line-modified">!     void mediaPlayerFirstVideoFrameAvailable() final;</span>
<span class="line-modified">!     void mediaPlayerCharacteristicChanged() final;</span>
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
<span class="line-modified">!     RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const final;</span>
<span class="line-modified">!     bool mediaPlayerKeyNeeded(Uint8Array*) final;</span>
<span class="line-modified">!     String mediaPlayerMediaKeysStorageDirectory() const final;</span>
  #endif
  
  #if ENABLE(ENCRYPTED_MEDIA)
      void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) final;
      void mediaPlayerWaitingForKeyChanged() final;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,11 ***</span>
      // CDMClient
      void cdmClientAttemptToResumePlaybackIfNecessary() final;
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(MediaPlayer*) override;</span>
      void enqueuePlaybackTargetAvailabilityChangedEvent();
  
      using EventTarget::dispatchEvent;
      void dispatchEvent(Event&amp;) override;
  #endif
<span class="line-new-header">--- 696,11 ---</span>
      // CDMClient
      void cdmClientAttemptToResumePlaybackIfNecessary() final;
  #endif
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<span class="line-modified">!     void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) final;</span>
      void enqueuePlaybackTargetAvailabilityChangedEvent();
  
      using EventTarget::dispatchEvent;
      void dispatchEvent(Event&amp;) override;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,38 ***</span>
      bool mediaPlayerIsFullscreen() const override;
      bool mediaPlayerIsFullscreenPermitted() const override;
      bool mediaPlayerIsVideo() const override;
      LayoutRect mediaPlayerContentBoxRect() const override;
      float mediaPlayerContentsScale() const override;
<span class="line-removed">-     void mediaPlayerSetSize(const IntSize&amp;) override;</span>
      void mediaPlayerPause() override;
      void mediaPlayerPlay() override;
      bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
<span class="line-removed">-     bool mediaPlayerIsPaused() const override;</span>
      bool mediaPlayerIsLooping() const override;
      CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
      RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
      bool mediaPlayerShouldUsePersistentCache() const override;
      const String&amp; mediaPlayerMediaCacheDirectory() const override;
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">!     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter(const MediaPlayer*) const override;</span>
  #endif
  
<span class="line-modified">!     void mediaPlayerActiveSourceBuffersChanged(const MediaPlayer*) override;</span>
  
<span class="line-removed">-     void mediaPlayerHandlePlaybackCommand(PlatformMediaSession::RemoteControlCommandType command) override { didReceiveRemoteControlCommand(command, nullptr); }</span>
      String sourceApplicationIdentifier() const override;
      String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
      Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
  
  #if PLATFORM(IOS_FAMILY)
      String mediaPlayerNetworkInterfaceName() const override;
      bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
  #endif
  
<span class="line-removed">-     bool mediaPlayerIsInMediaDocument() const final;</span>
      void mediaPlayerEngineFailedToLoad() const final;
  
      double mediaPlayerRequestedPlaybackRate() const final;
      VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
      bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
<span class="line-new-header">--- 717,34 ---</span>
      bool mediaPlayerIsFullscreen() const override;
      bool mediaPlayerIsFullscreenPermitted() const override;
      bool mediaPlayerIsVideo() const override;
      LayoutRect mediaPlayerContentBoxRect() const override;
      float mediaPlayerContentsScale() const override;
      void mediaPlayerPause() override;
      void mediaPlayerPlay() override;
      bool mediaPlayerPlatformVolumeConfigurationRequired() const override;
      bool mediaPlayerIsLooping() const override;
      CachedResourceLoader* mediaPlayerCachedResourceLoader() override;
      RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() override;
      bool mediaPlayerShouldUsePersistentCache() const override;
      const String&amp; mediaPlayerMediaCacheDirectory() const override;
  
  #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
<span class="line-modified">!     GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const override;</span>
  #endif
  
<span class="line-modified">!     void mediaPlayerActiveSourceBuffersChanged() override;</span>
  
      String sourceApplicationIdentifier() const override;
      String mediaPlayerSourceApplicationIdentifier() const override { return sourceApplicationIdentifier(); }
      Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const override;
  
  #if PLATFORM(IOS_FAMILY)
      String mediaPlayerNetworkInterfaceName() const override;
      bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const override;
  #endif
  
      void mediaPlayerEngineFailedToLoad() const final;
  
      double mediaPlayerRequestedPlaybackRate() const final;
      VideoFullscreenMode mediaPlayerFullscreenMode() const final { return fullscreenMode(); }
      bool mediaPlayerIsVideoFullscreenStandby() const final { return m_videoFullscreenStandby; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 790,19 ***</span>
      void prepareToPlay();
  
      URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
  
  #if ENABLE(VIDEO_TRACK)
      void updateActiveTextTrackCues(const MediaTime&amp;);
      HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
  
<span class="line-modified">!     enum ReconfigureMode {</span>
<span class="line-removed">-         Immediately,</span>
<span class="line-removed">-         AfterDelay,</span>
<span class="line-removed">-     };</span>
      void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
<span class="line-removed">-     void captionPreferencesChanged() override;</span>
      CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
  #endif
  
      // These &quot;internal&quot; functions do not check user gesture restrictions.
      void playInternal();
<span class="line-new-header">--- 791,19 ---</span>
      void prepareToPlay();
  
      URL selectNextSourceChild(ContentType*, String* keySystem, InvalidURLAction);
  
  #if ENABLE(VIDEO_TRACK)
<span class="line-added">+     bool ignoreTrackDisplayUpdateRequests() const;</span>
<span class="line-added">+     void beginIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added">+     void endIgnoringTrackDisplayUpdateRequests();</span>
<span class="line-added">+ </span>
      void updateActiveTextTrackCues(const MediaTime&amp;);
      HTMLTrackElement* showingTrackWithSameKind(HTMLTrackElement*) const;
  
<span class="line-modified">!     enum ReconfigureMode { Immediately, AfterDelay };</span>
      void markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode);
      CaptionUserPreferences::CaptionDisplayMode captionDisplayMode();
  #endif
  
      // These &quot;internal&quot; functions do not check user gesture restrictions.
      void playInternal();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,10 ***</span>
<span class="line-new-header">--- 836,11 ---</span>
      MediaTime minTimeSeekable() const;
      MediaTime maxTimeSeekable() const;
  
      // Pauses playback without changing any states or generating events
      void setPausedInternal(bool);
<span class="line-added">+     void pauseAndUpdatePlayStateImmediately();</span>
  
      void setPlaybackRateInternal(double);
  
      void mediaCanStart(Document&amp;) final;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 858,18 ***</span>
  
      void updateMediaController();
      bool isBlocked() const;
      bool isBlockedOnMediaController() const;
      bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
<span class="line-modified">!     bool isLiveStream() const override { return movieLoadType() == MediaPlayerEnums::LiveStream; }</span>
  
      void updateSleepDisabling();
<span class="line-modified">!     enum class SleepType {</span>
<span class="line-removed">-         None,</span>
<span class="line-removed">-         Display,</span>
<span class="line-removed">-         System,</span>
<span class="line-removed">-     };</span>
      SleepType shouldDisableSleep() const;
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
      DOMWrapperWorld&amp; ensureIsolatedWorld();
<span class="line-new-header">--- 860,14 ---</span>
  
      void updateMediaController();
      bool isBlocked() const;
      bool isBlockedOnMediaController() const;
      bool hasCurrentSrc() const override { return !m_currentSrc.isEmpty(); }
<span class="line-modified">!     bool isLiveStream() const override { return movieLoadType() == MovieLoadType::LiveStream; }</span>
  
      void updateSleepDisabling();
<span class="line-modified">!     enum class SleepType { None, Display, System };</span>
      SleepType shouldDisableSleep() const;
  
  #if ENABLE(MEDIA_CONTROLS_SCRIPT)
      void didAddUserAgentShadowRoot(ShadowRoot&amp;) override;
      DOMWrapperWorld&amp; ensureIsolatedWorld();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,11 ***</span>
      void unregisterWithDocument(Document&amp;);
  
      void updateCaptionContainer();
      void ensureMediaControlsShadowRoot();
  
<span class="line-modified">!     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::ExecState&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;</span>
      bool setupAndCallJS(const JSSetupFunction&amp;);
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      void prepareForDocumentSuspension() final;
      void resumeFromDocumentSuspension() final;
<span class="line-new-header">--- 908,11 ---</span>
      void unregisterWithDocument(Document&amp;);
  
      void updateCaptionContainer();
      void ensureMediaControlsShadowRoot();
  
<span class="line-modified">!     using JSSetupFunction = WTF::Function&lt;bool(JSDOMGlobalObject&amp;, JSC::JSGlobalObject&amp;, ScriptController&amp;, DOMWrapperWorld&amp;)&gt;;</span>
      bool setupAndCallJS(const JSSetupFunction&amp;);
  
  #if ENABLE(WIRELESS_PLAYBACK_TARGET)
      void prepareForDocumentSuspension() final;
      void resumeFromDocumentSuspension() final;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 940,41 ***</span>
  
      void addBehaviorRestrictionsOnEndIfNecessary();
      void handleSeekToPlaybackPosition(double);
      void seekToPlaybackPositionEndedTimerFired();
  
<span class="line-removed">-     void applicationWillResignActive() final;</span>
<span class="line-removed">-     void applicationDidBecomeActive() final;</span>
<span class="line-removed">- </span>
      void setInActiveDocument(bool);
  
  #if !RELEASE_LOG_DISABLED
      const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
      const Logger&amp; mediaPlayerLogger() final { return logger(); }
  #endif
  
      Timer m_progressEventTimer;
      Timer m_playbackProgressTimer;
      Timer m_scanTimer;
      Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
      Timer m_seekToPlaybackPositionEndedTimer;
      DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
      DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
      DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
      DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
<span class="line-modified">!     DeferrableTask&lt;Timer&gt; m_updatePlayStateTask;</span>
      DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
      DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
      DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
      GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
      RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
<span class="line-modified">!     GenericEventQueue m_asyncEventQueue;</span>
  #if PLATFORM(IOS_FAMILY)
      DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;
  #endif
  
      PlayPromiseVector m_pendingPlayPromises;
<span class="line-new-header">--- 938,41 ---</span>
  
      void addBehaviorRestrictionsOnEndIfNecessary();
      void handleSeekToPlaybackPosition(double);
      void seekToPlaybackPositionEndedTimerFired();
  
      void setInActiveDocument(bool);
  
  #if !RELEASE_LOG_DISABLED
      const void* mediaPlayerLogIdentifier() final { return logIdentifier(); }
      const Logger&amp; mediaPlayerLogger() final { return logger(); }
  #endif
  
<span class="line-added">+     friend class TaskDispatcher&lt;HTMLMediaElement&gt;;</span>
<span class="line-added">+     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp;);</span>
<span class="line-added">+ </span>
      Timer m_progressEventTimer;
      Timer m_playbackProgressTimer;
      Timer m_scanTimer;
      Timer m_playbackControlsManagerBehaviorRestrictionsTimer;
      Timer m_seekToPlaybackPositionEndedTimer;
      DeferrableTask&lt;Timer&gt; m_configureTextTracksTask;
      DeferrableTask&lt;Timer&gt; m_checkPlaybackTargetCompatablityTask;
      DeferrableTask&lt;Timer&gt; m_updateMediaStateTask;
      DeferrableTask&lt;Timer&gt; m_mediaEngineUpdatedTask;
<span class="line-modified">!     DeferrableTask&lt;HTMLMediaElement&gt; m_updatePlayStateTask;</span>
      DeferrableTask&lt;Timer&gt; m_resumeTaskQueue;
      DeferrableTask&lt;Timer&gt; m_seekTaskQueue;
      DeferrableTask&lt;Timer&gt; m_playbackControlsManagerBehaviorRestrictionsQueue;
      GenericTaskQueue&lt;Timer&gt; m_promiseTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_pauseAfterDetachedTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_resourceSelectionTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_visibilityChangeTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_fullscreenTaskQueue;
      GenericTaskQueue&lt;Timer&gt; m_playbackTargetIsWirelessQueue;
      RefPtr&lt;TimeRanges&gt; m_playedTimeRanges;
<span class="line-modified">!     UniqueRef&lt;MainThreadGenericEventQueue&gt; m_asyncEventQueue;</span>
  #if PLATFORM(IOS_FAMILY)
      DeferrableTask&lt;Timer&gt; m_volumeRevertTaskQueue;
  #endif
  
      PlayPromiseVector m_pendingPlayPromises;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1034,16 ***</span>
      bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
  
  #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
      RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
      FloatRect m_videoFullscreenFrame;
<span class="line-modified">!     MediaPlayerEnums::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravityResizeAspect };</span>
  #endif
  
      RefPtr&lt;MediaPlayer&gt; m_player;
  
<span class="line-modified">!     MediaPlayerEnums::Preload m_preload { MediaPlayer::Auto };</span>
  
      DisplayMode m_displayMode { Unknown };
  
      // Counter incremented while processing a callback from the media player, so we can avoid
      // calling the media engine recursively.
<span class="line-new-header">--- 1032,16 ---</span>
      bool m_temporarilyAllowingInlinePlaybackAfterFullscreen { false };
  
  #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
      RetainPtr&lt;PlatformLayer&gt; m_videoFullscreenLayer;
      FloatRect m_videoFullscreenFrame;
<span class="line-modified">!     MediaPlayer::VideoGravity m_videoFullscreenGravity { MediaPlayer::VideoGravity::ResizeAspect };</span>
  #endif
  
      RefPtr&lt;MediaPlayer&gt; m_player;
  
<span class="line-modified">!     MediaPlayer::Preload m_preload { Preload::Auto };</span>
  
      DisplayMode m_displayMode { Unknown };
  
      // Counter incremented while processing a callback from the media player, so we can avoid
      // calling the media engine recursively.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1139,13 ***</span>
      RefPtr&lt;AudioTrackList&gt; m_audioTracks;
      RefPtr&lt;TextTrackList&gt; m_textTracks;
      RefPtr&lt;VideoTrackList&gt; m_videoTracks;
      Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
  
<span class="line-modified">!     CueIntervalTree m_cueTree;</span>
  
<span class="line-removed">-     CueList m_currentlyActiveCues;</span>
      int m_ignoreTrackDisplayUpdate { 0 };
  
      bool m_requireCaptionPreferencesChangedCallbacks { false };
  #endif
  
<span class="line-new-header">--- 1137,13 ---</span>
      RefPtr&lt;AudioTrackList&gt; m_audioTracks;
      RefPtr&lt;TextTrackList&gt; m_textTracks;
      RefPtr&lt;VideoTrackList&gt; m_videoTracks;
      Vector&lt;RefPtr&lt;TextTrack&gt;&gt; m_textTracksWhenResourceSelectionBegan;
  
<span class="line-modified">!     struct CueData;</span>
<span class="line-added">+     std::unique_ptr&lt;CueData&gt; m_cueData;</span>
  
      int m_ignoreTrackDisplayUpdate { 0 };
  
      bool m_requireCaptionPreferencesChangedCallbacks { false };
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1170,17 ***</span>
<span class="line-new-header">--- 1168,22 ---</span>
      MediaProvider m_mediaProvider;
  
  #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
      RefPtr&lt;WebKitMediaKeys&gt; m_webKitMediaKeys;
  #endif
<span class="line-added">+ </span>
  #if ENABLE(ENCRYPTED_MEDIA)
      RefPtr&lt;MediaKeys&gt; m_mediaKeys;
      bool m_attachingMediaKeys { false };
      bool m_playbackBlockedWaitingForKey { false };
      GenericTaskQueue&lt;Timer&gt; m_encryptedMediaQueue;
  #endif
  
<span class="line-added">+ #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added">+     Ref&lt;RemotePlayback&gt; m_remote;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      std::unique_ptr&lt;MediaElementSession&gt; m_mediaSession;
      size_t m_reportedExtraMemoryCost { 0 };
  
  #if !RELEASE_LOG_DISABLED
      RefPtr&lt;Logger&gt; m_logger;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1217,27 ***</span>
  
  template&lt;&gt; struct LogArgument&lt;WebCore::HTMLMediaElement::AutoplayEventPlaybackState&gt; {
      static String toString(WebCore::HTMLMediaElement::AutoplayEventPlaybackState reason) { return convertEnumerationToString(reason); }
  };
  
<span class="line-removed">- #if ENABLE(VIDEO_TRACK) &amp;&amp; !defined(NDEBUG)</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Template specialization required by PodIntervalTree in debug mode.</span>
<span class="line-removed">- template&lt;&gt; struct ValueToString&lt;WebCore::TextTrackCue*&gt; {</span>
<span class="line-removed">-     static String string(const WebCore::TextTrackCue* cue) { return cue-&gt;debugString(); }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifndef NDEBUG</span>
<span class="line-removed">- </span>
<span class="line-removed">- template&lt;&gt; struct ValueToString&lt;MediaTime&gt; {</span>
<span class="line-removed">-     static String string(const MediaTime&amp; time) { return toString(time); }</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  } // namespace WTF
  
  SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::HTMLMediaElement)
      static bool isType(const WebCore::Element&amp; element) { return element.isMediaElement(); }
      static bool isType(const WebCore::Node&amp; node) { return is&lt;WebCore::Element&gt;(node) &amp;&amp; isType(downcast&lt;WebCore::Element&gt;(node)); }
<span class="line-new-header">--- 1220,10 ---</span>
</pre>
<center><a href="HTMLMediaElement.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLMeterElement.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
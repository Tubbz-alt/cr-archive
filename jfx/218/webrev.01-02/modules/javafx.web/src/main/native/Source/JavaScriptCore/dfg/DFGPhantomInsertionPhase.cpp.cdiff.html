<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPhantomInsertionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOperations.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPhantomInsertionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 41,15 ***</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
<span class="line-removed">- namespace DFGPhantomInsertionPhaseInternal {</span>
<span class="line-removed">- static const bool verbose = false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  class PhantomInsertionPhase : public Phase {
  public:
      PhantomInsertionPhase(Graph&amp; graph)
          : Phase(graph, &quot;phantom insertion&quot;)
          , m_insertionSet(graph)
          , m_values(OperandsLike, graph.block(0)-&gt;variablesAtHead)
<span class="line-new-header">--- 41,12 ---</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
  class PhantomInsertionPhase : public Phase {
<span class="line-added">+     static constexpr bool verbose = false;</span>
  public:
      PhantomInsertionPhase(Graph&amp; graph)
          : Phase(graph, &quot;phantom insertion&quot;)
          , m_insertionSet(graph)
          , m_values(OperandsLike, graph.block(0)-&gt;variablesAtHead)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 60,21 ***</span>
      {
          // We assume that DCE has already run. If we run before DCE then we think that all
          // SetLocals execute, which is inaccurate. That causes us to insert too few Phantoms.
          DFG_ASSERT(m_graph, nullptr, m_graph.m_refCountState == ExactRefCount);
  
<span class="line-modified">!         if (DFGPhantomInsertionPhaseInternal::verbose) {</span>
              dataLog(&quot;Graph before Phantom insertion:\n&quot;);
              m_graph.dump();
          }
  
          m_graph.clearEpochs();
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder())
              handleBlock(block);
  
<span class="line-modified">!         if (DFGPhantomInsertionPhaseInternal::verbose) {</span>
              dataLog(&quot;Graph after Phantom insertion:\n&quot;);
              m_graph.dump();
          }
  
          return true;
<span class="line-new-header">--- 57,21 ---</span>
      {
          // We assume that DCE has already run. If we run before DCE then we think that all
          // SetLocals execute, which is inaccurate. That causes us to insert too few Phantoms.
          DFG_ASSERT(m_graph, nullptr, m_graph.m_refCountState == ExactRefCount);
  
<span class="line-modified">!         if (verbose) {</span>
              dataLog(&quot;Graph before Phantom insertion:\n&quot;);
              m_graph.dump();
          }
  
          m_graph.clearEpochs();
  
          for (BasicBlock* block : m_graph.blocksInNaturalOrder())
              handleBlock(block);
  
<span class="line-modified">!         if (verbose) {</span>
              dataLog(&quot;Graph after Phantom insertion:\n&quot;);
              m_graph.dump();
          }
  
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,26 ***</span>
  
          Epoch currentEpoch = Epoch::first();
          unsigned lastExitingIndex = 0;
          for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
              Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!             if (DFGPhantomInsertionPhaseInternal::verbose)</span>
                  dataLog(&quot;Considering &quot;, node, &quot;\n&quot;);
  
              switch (node-&gt;op()) {
              case MovHint:
<span class="line-modified">!                 m_values.operand(node-&gt;unlinkedLocal()) = node-&gt;child1().node();</span>
                  break;
  
              case ZombieHint:
<span class="line-modified">!                 m_values.operand(node-&gt;unlinkedLocal()) = nullptr;</span>
                  break;
  
              case GetLocal:
              case SetArgumentDefinitely:
              case SetArgumentMaybe:
<span class="line-modified">!                 m_values.operand(node-&gt;local()) = nullptr;</span>
                  break;
  
              default:
                  break;
              }
<span class="line-new-header">--- 98,26 ---</span>
  
          Epoch currentEpoch = Epoch::first();
          unsigned lastExitingIndex = 0;
          for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
              Node* node = block-&gt;at(nodeIndex);
<span class="line-modified">!             if (verbose)</span>
                  dataLog(&quot;Considering &quot;, node, &quot;\n&quot;);
  
              switch (node-&gt;op()) {
              case MovHint:
<span class="line-modified">!                 m_values.operand(node-&gt;unlinkedOperand()) = node-&gt;child1().node();</span>
                  break;
  
              case ZombieHint:
<span class="line-modified">!                 m_values.operand(node-&gt;unlinkedOperand()) = nullptr;</span>
                  break;
  
              case GetLocal:
              case SetArgumentDefinitely:
              case SetArgumentMaybe:
<span class="line-modified">!                 m_values.operand(node-&gt;operand()) = nullptr;</span>
                  break;
  
              default:
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,42 ***</span>
              }
  
              m_graph.doToChildren(
                  node,
                  [&amp;] (Edge edge) {
                      edge-&gt;setEpoch(currentEpoch);
                  });
  
              node-&gt;setEpoch(currentEpoch);
  
<span class="line-modified">!             VirtualRegister alreadyKilled;</span>
  
<span class="line-modified">!             auto processKilledOperand = [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">!                 if (DFGPhantomInsertionPhaseInternal::verbose)</span>
<span class="line-removed">-                     dataLog(&quot;    Killed operand: &quot;, reg, &quot;\n&quot;);</span>
  
                  // Already handled from SetLocal.
<span class="line-modified">!                 if (reg == alreadyKilled)</span>
                      return;
  
<span class="line-modified">!                 Node* killedNode = m_values.operand(reg);</span>
<span class="line-modified">!                 if (!killedNode)</span>
                      return;
  
<span class="line-modified">!                 m_values.operand(reg) = nullptr;</span>
  
                  // We only need to insert a Phantom if the node hasn&#39;t been used since the last
                  // exit, and was born before the last exit.
<span class="line-modified">!                 if (killedNode-&gt;epoch() == currentEpoch)</span>
                      return;
<span class="line-removed">- </span>
<span class="line-removed">-                 if (DFGPhantomInsertionPhaseInternal::verbose) {</span>
<span class="line-removed">-                     dataLog(</span>
<span class="line-removed">-                         &quot;    Inserting Phantom on &quot;, killedNode, &quot; after &quot;,</span>
<span class="line-removed">-                         block-&gt;at(lastExitingIndex), &quot;\n&quot;);</span>
                  }
  
                  // We have exact ref counts, so creating a new use means that we have to
                  // increment the ref count.
                  killedNode-&gt;postfixRef();
  
                  Node* lastExitingNode = block-&gt;at(lastExitingIndex);
<span class="line-new-header">--- 129,46 ---</span>
              }
  
              m_graph.doToChildren(
                  node,
                  [&amp;] (Edge edge) {
<span class="line-added">+                     dataLogLnIf(verbose, &quot;Updating epoch for &quot;, edge, &quot; to &quot;, currentEpoch);</span>
                      edge-&gt;setEpoch(currentEpoch);
                  });
  
              node-&gt;setEpoch(currentEpoch);
  
<span class="line-modified">!             Operand alreadyKilled;</span>
  
<span class="line-modified">!             auto processKilledOperand = [&amp;] (Operand operand) {</span>
<span class="line-modified">!                 dataLogLnIf(verbose, &quot;    Killed operand: &quot;, operand);</span>
  
                  // Already handled from SetLocal.
<span class="line-modified">!                 if (operand == alreadyKilled) {</span>
<span class="line-added">+                     dataLogLnIf(verbose, &quot;    Operand &quot;, operand, &quot; already killed by set local&quot;);</span>
                      return;
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 Node* killedNode = m_values.operand(operand);</span>
<span class="line-modified">!                 if (!killedNode) {</span>
<span class="line-added">+                     dataLogLnIf(verbose, &quot;    Operand &quot;, operand, &quot; was not defined in this block.&quot;);</span>
                      return;
<span class="line-added">+                 }</span>
  
<span class="line-modified">!                 m_values.operand(operand) = nullptr;</span>
  
                  // We only need to insert a Phantom if the node hasn&#39;t been used since the last
                  // exit, and was born before the last exit.
<span class="line-modified">!                 if (killedNode-&gt;epoch() == currentEpoch) {</span>
<span class="line-added">+                     dataLogLnIf(verbose, &quot;    Operand &quot;, operand, &quot; has current epoch &quot;, currentEpoch);</span>
                      return;
                  }
  
<span class="line-added">+                 dataLogLnIf(verbose,</span>
<span class="line-added">+                     &quot;    Inserting Phantom on &quot;, killedNode, &quot; after &quot;,</span>
<span class="line-added">+                     block-&gt;at(lastExitingIndex));</span>
<span class="line-added">+ </span>
                  // We have exact ref counts, so creating a new use means that we have to
                  // increment the ref count.
                  killedNode-&gt;postfixRef();
  
                  Node* lastExitingNode = block-&gt;at(lastExitingIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,18 ***</span>
                      lastExitingNode-&gt;origin.forInsertingAfter(m_graph, lastExitingNode),
                      killedNode-&gt;defaultEdge());
              };
  
              if (node-&gt;op() == SetLocal) {
<span class="line-modified">!                 VirtualRegister local = node-&gt;local();</span>
                  if (nodeMayExit) {
                      // If the SetLocal does exit, we need the MovHint of its local
                      // to be live until the SetLocal is done.
<span class="line-modified">!                     processKilledOperand(local);</span>
<span class="line-modified">!                     alreadyKilled = local;</span>
                  }
<span class="line-modified">!                 m_values.operand(local) = nullptr;</span>
              }
  
              forAllKilledOperands(m_graph, node, block-&gt;tryAt(nodeIndex + 1), processKilledOperand);
          }
  
<span class="line-new-header">--- 178,18 ---</span>
                      lastExitingNode-&gt;origin.forInsertingAfter(m_graph, lastExitingNode),
                      killedNode-&gt;defaultEdge());
              };
  
              if (node-&gt;op() == SetLocal) {
<span class="line-modified">!                 Operand operand = node-&gt;operand();</span>
                  if (nodeMayExit) {
                      // If the SetLocal does exit, we need the MovHint of its local
                      // to be live until the SetLocal is done.
<span class="line-modified">!                     processKilledOperand(operand);</span>
<span class="line-modified">!                     alreadyKilled = operand;</span>
                  }
<span class="line-modified">!                 m_values.operand(operand) = nullptr;</span>
              }
  
              forAllKilledOperands(m_graph, node, block-&gt;tryAt(nodeIndex + 1), processKilledOperand);
          }
  
</pre>
<center><a href="DFGOperations.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPlan.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayerCompositor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayoutState.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerModelObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 80 
 81     RenderElement::willBeDestroyed();
 82 
 83     clearRepaintLayoutRects();
 84 }
 85 
 86 void RenderLayerModelObject::destroyLayer()
 87 {
 88     ASSERT(!hasLayer());
 89     ASSERT(m_layer);
 90     if (m_layer-&gt;isSelfPaintingLayer())
 91         clearRepaintLayoutRects();
 92     m_layer = nullptr;
 93 }
 94 
 95 void RenderLayerModelObject::createLayer()
 96 {
 97     ASSERT(!m_layer);
 98     m_layer = makeUnique&lt;RenderLayer&gt;(*this);
 99     setHasLayer(true);
<span class="line-modified">100     m_layer-&gt;insertOnlyThisLayer();</span>
101 }
102 
103 bool RenderLayerModelObject::hasSelfPaintingLayer() const
104 {
105     return m_layer &amp;&amp; m_layer-&gt;isSelfPaintingLayer();
106 }
107 
108 void RenderLayerModelObject::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
109 {
110     s_wasFloating = isFloating();
111     s_hadLayer = hasLayer();
112     s_hadTransform = hasTransform();
113     if (s_hadLayer)
114         s_layerWasSelfPainting = layer()-&gt;isSelfPaintingLayer();
115 
116     // If our z-index changes value or our visibility changes,
117     // we need to dirty our stacking context&#39;s z-order list.
118     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
119     if (oldStyle) {
120         if (parent()) {
121             // Do a repaint with the old style first, e.g., for example if we go from
122             // having an outline to not having an outline.
123             if (diff == StyleDifference::RepaintLayer) {
124                 layer()-&gt;repaintIncludingDescendants();
125                 if (!(oldStyle-&gt;clip() == newStyle.clip()))
126                     layer()-&gt;clearClipRectsIncludingDescendants();
127             } else if (diff == StyleDifference::Repaint || newStyle.outlineSize() &lt; oldStyle-&gt;outlineSize())
128                 repaint();
129         }
130 
131         if (diff == StyleDifference::Layout || diff == StyleDifference::SimplifiedLayout) {
132             // When a layout hint happens, we do a repaint of the layer, since the layer could end up being destroyed.
133             if (hasLayer()) {
134                 if (oldStyle-&gt;position() != newStyle.position()
<span class="line-modified">135                     || oldStyle-&gt;zIndex() != newStyle.zIndex()</span>
<span class="line-modified">136                     || oldStyle-&gt;hasAutoZIndex() != newStyle.hasAutoZIndex()</span>
137                     || !(oldStyle-&gt;clip() == newStyle.clip())
138                     || oldStyle-&gt;hasClip() != newStyle.hasClip()
139                     || oldStyle-&gt;opacity() != newStyle.opacity()
140                     || oldStyle-&gt;transform() != newStyle.transform()
141                     || oldStyle-&gt;filter() != newStyle.filter()
142                     )
143                 layer()-&gt;repaintIncludingDescendants();
144             } else if (newStyle.hasTransform() || newStyle.opacity() &lt; 1 || newStyle.hasFilter() || newStyle.hasBackdropFilter()) {
145                 // If we don&#39;t have a layer yet, but we are going to get one because of transform or opacity,
146                 //  then we need to repaint the old position of the object.
147                 repaint();
148             }
149         }
150     }
151 
152     RenderElement::styleWillChange(diff, newStyle);
153 }
154 
155 #if ENABLE(CSS_SCROLL_SNAP)
156 static bool scrollSnapContainerRequiresUpdateForStyleUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
157 {
158     return oldStyle.scrollSnapPort() != newStyle.scrollSnapPort();
159 }
160 #endif
161 
162 void RenderLayerModelObject::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
163 {
164     RenderElement::styleDidChange(diff, oldStyle);
165     updateFromStyle();
166 
167     if (requiresLayer()) {
168         if (!layer() &amp;&amp; layerCreationAllowedForSubtree()) {
169             if (s_wasFloating &amp;&amp; isFloating())
170                 setChildNeedsLayout();
171             createLayer();
<span class="line-modified">172             if (parent() &amp;&amp; !needsLayout() &amp;&amp; containingBlock()) {</span>
173                 layer()-&gt;setRepaintStatus(NeedsFullRepaint);
<span class="line-removed">174                 layer()-&gt;updateLayerPositionsAfterStyleChange();</span>
<span class="line-removed">175             }</span>
176         }
177     } else if (layer() &amp;&amp; layer()-&gt;parent()) {
178 #if ENABLE(CSS_COMPOSITING)
179         if (oldStyle-&gt;hasBlendMode())
180             layer()-&gt;willRemoveChildWithBlendMode();
181 #endif
<span class="line-modified">182         setHasTransformRelatedProperty(false); // All transform-related propeties force layers, so we know we don&#39;t have one or the object doesn&#39;t support them.</span>
183         setHasReflection(false);
184         // Repaint the about to be destroyed self-painting layer when style change also triggers repaint.
185         if (layer()-&gt;isSelfPaintingLayer() &amp;&amp; layer()-&gt;repaintStatus() == NeedsFullRepaint &amp;&amp; hasRepaintLayoutRects())
186             repaintUsingContainer(containerForRepaint(), repaintLayoutRects().m_repaintRect);
<span class="line-modified">187         layer()-&gt;removeOnlyThisLayer(); // calls destroyLayer() which clears m_layer</span>

188         if (s_wasFloating &amp;&amp; isFloating())
189             setChildNeedsLayout();
190         if (s_hadTransform)
191             setNeedsLayoutAndPrefWidthsRecalc();
192     }
193 
194     if (layer()) {
195         layer()-&gt;styleChanged(diff, oldStyle);
196         if (s_hadLayer &amp;&amp; layer()-&gt;isSelfPaintingLayer() != s_layerWasSelfPainting)
197             setChildNeedsLayout();
198     }
199 
200     bool newStyleIsViewportConstrained = style().hasViewportConstrainedPosition();
201     bool oldStyleIsViewportConstrained = oldStyle &amp;&amp; oldStyle-&gt;hasViewportConstrainedPosition();
202     if (newStyleIsViewportConstrained != oldStyleIsViewportConstrained) {
203         if (newStyleIsViewportConstrained &amp;&amp; layer())
204             view().frameView().addViewportConstrainedObject(this);
205         else
206             view().frameView().removeViewportConstrainedObject(this);
207     }
</pre>
</td>
<td>
<hr />
<pre>
 80 
 81     RenderElement::willBeDestroyed();
 82 
 83     clearRepaintLayoutRects();
 84 }
 85 
 86 void RenderLayerModelObject::destroyLayer()
 87 {
 88     ASSERT(!hasLayer());
 89     ASSERT(m_layer);
 90     if (m_layer-&gt;isSelfPaintingLayer())
 91         clearRepaintLayoutRects();
 92     m_layer = nullptr;
 93 }
 94 
 95 void RenderLayerModelObject::createLayer()
 96 {
 97     ASSERT(!m_layer);
 98     m_layer = makeUnique&lt;RenderLayer&gt;(*this);
 99     setHasLayer(true);
<span class="line-modified">100     m_layer-&gt;insertOnlyThisLayer(RenderLayer::LayerChangeTiming::StyleChange);</span>
101 }
102 
103 bool RenderLayerModelObject::hasSelfPaintingLayer() const
104 {
105     return m_layer &amp;&amp; m_layer-&gt;isSelfPaintingLayer();
106 }
107 
108 void RenderLayerModelObject::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
109 {
110     s_wasFloating = isFloating();
111     s_hadLayer = hasLayer();
112     s_hadTransform = hasTransform();
113     if (s_hadLayer)
114         s_layerWasSelfPainting = layer()-&gt;isSelfPaintingLayer();
115 
116     // If our z-index changes value or our visibility changes,
117     // we need to dirty our stacking context&#39;s z-order list.
118     const RenderStyle* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
119     if (oldStyle) {
120         if (parent()) {
121             // Do a repaint with the old style first, e.g., for example if we go from
122             // having an outline to not having an outline.
123             if (diff == StyleDifference::RepaintLayer) {
124                 layer()-&gt;repaintIncludingDescendants();
125                 if (!(oldStyle-&gt;clip() == newStyle.clip()))
126                     layer()-&gt;clearClipRectsIncludingDescendants();
127             } else if (diff == StyleDifference::Repaint || newStyle.outlineSize() &lt; oldStyle-&gt;outlineSize())
128                 repaint();
129         }
130 
131         if (diff == StyleDifference::Layout || diff == StyleDifference::SimplifiedLayout) {
132             // When a layout hint happens, we do a repaint of the layer, since the layer could end up being destroyed.
133             if (hasLayer()) {
134                 if (oldStyle-&gt;position() != newStyle.position()
<span class="line-modified">135                     || oldStyle-&gt;usedZIndex() != newStyle.usedZIndex()</span>
<span class="line-modified">136                     || oldStyle-&gt;hasAutoUsedZIndex() != newStyle.hasAutoUsedZIndex()</span>
137                     || !(oldStyle-&gt;clip() == newStyle.clip())
138                     || oldStyle-&gt;hasClip() != newStyle.hasClip()
139                     || oldStyle-&gt;opacity() != newStyle.opacity()
140                     || oldStyle-&gt;transform() != newStyle.transform()
141                     || oldStyle-&gt;filter() != newStyle.filter()
142                     )
143                 layer()-&gt;repaintIncludingDescendants();
144             } else if (newStyle.hasTransform() || newStyle.opacity() &lt; 1 || newStyle.hasFilter() || newStyle.hasBackdropFilter()) {
145                 // If we don&#39;t have a layer yet, but we are going to get one because of transform or opacity,
146                 //  then we need to repaint the old position of the object.
147                 repaint();
148             }
149         }
150     }
151 
152     RenderElement::styleWillChange(diff, newStyle);
153 }
154 
155 #if ENABLE(CSS_SCROLL_SNAP)
156 static bool scrollSnapContainerRequiresUpdateForStyleUpdate(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle)
157 {
158     return oldStyle.scrollSnapPort() != newStyle.scrollSnapPort();
159 }
160 #endif
161 
162 void RenderLayerModelObject::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
163 {
164     RenderElement::styleDidChange(diff, oldStyle);
165     updateFromStyle();
166 
167     if (requiresLayer()) {
168         if (!layer() &amp;&amp; layerCreationAllowedForSubtree()) {
169             if (s_wasFloating &amp;&amp; isFloating())
170                 setChildNeedsLayout();
171             createLayer();
<span class="line-modified">172             if (parent() &amp;&amp; !needsLayout() &amp;&amp; containingBlock())</span>
173                 layer()-&gt;setRepaintStatus(NeedsFullRepaint);


174         }
175     } else if (layer() &amp;&amp; layer()-&gt;parent()) {
176 #if ENABLE(CSS_COMPOSITING)
177         if (oldStyle-&gt;hasBlendMode())
178             layer()-&gt;willRemoveChildWithBlendMode();
179 #endif
<span class="line-modified">180         setHasTransformRelatedProperty(false); // All transform-related properties force layers, so we know we don&#39;t have one or the object doesn&#39;t support them.</span>
181         setHasReflection(false);
182         // Repaint the about to be destroyed self-painting layer when style change also triggers repaint.
183         if (layer()-&gt;isSelfPaintingLayer() &amp;&amp; layer()-&gt;repaintStatus() == NeedsFullRepaint &amp;&amp; hasRepaintLayoutRects())
184             repaintUsingContainer(containerForRepaint(), repaintLayoutRects().m_repaintRect);
<span class="line-modified">185 </span>
<span class="line-added">186         layer()-&gt;removeOnlyThisLayer(RenderLayer::LayerChangeTiming::StyleChange); // calls destroyLayer() which clears m_layer</span>
187         if (s_wasFloating &amp;&amp; isFloating())
188             setChildNeedsLayout();
189         if (s_hadTransform)
190             setNeedsLayoutAndPrefWidthsRecalc();
191     }
192 
193     if (layer()) {
194         layer()-&gt;styleChanged(diff, oldStyle);
195         if (s_hadLayer &amp;&amp; layer()-&gt;isSelfPaintingLayer() != s_layerWasSelfPainting)
196             setChildNeedsLayout();
197     }
198 
199     bool newStyleIsViewportConstrained = style().hasViewportConstrainedPosition();
200     bool oldStyleIsViewportConstrained = oldStyle &amp;&amp; oldStyle-&gt;hasViewportConstrainedPosition();
201     if (newStyleIsViewportConstrained != oldStyleIsViewportConstrained) {
202         if (newStyleIsViewportConstrained &amp;&amp; layer())
203             view().frameView().addViewportConstrainedObject(this);
204         else
205             view().frameView().removeViewportConstrainedObject(this);
206     }
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayerCompositor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLayoutState.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
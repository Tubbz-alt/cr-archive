diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp
@@ -92,11 +92,11 @@
     }
 }
 
 bool RootInlineBox::isHyphenated() const
 {
-    for (InlineBox* box = firstLeafChild(); box; box = box->nextLeafChild()) {
+    for (InlineBox* box = firstLeafDescendant(); box; box = box->nextLeafOnLine()) {
         if (is<InlineTextBox>(*box) && downcast<InlineTextBox>(*box).hasHyphen())
             return true;
     }
     return false;
 }
@@ -450,11 +450,11 @@
     // We can see that the |bbb| run is not part of the selection while the runs around it are.
     if (firstBox && firstBox != lastBox) {
         // Now fill in any gaps on the line that occurred between two selected elements.
         LayoutUnit lastLogicalLeft { firstBox->logicalRight() };
         bool isPreviousBoxSelected = firstBox->selectionState() != RenderObject::SelectionNone;
-        for (InlineBox* box = firstBox->nextLeafChild(); box; box = box->nextLeafChild()) {
+        for (InlineBox* box = firstBox->nextLeafOnLine(); box; box = box->nextLeafOnLine()) {
             if (box->selectionState() != RenderObject::SelectionNone) {
                 LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box->logicalLeft() - lastLogicalLeft), selHeight };
                 logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
                 LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
                 if (isPreviousBoxSelected && gapRect.width() > 0 && gapRect.height() > 0) {
@@ -529,11 +529,11 @@
 
 RenderObject::SelectionState RootInlineBox::selectionState()
 {
     // Walk over all of the selected boxes.
     RenderObject::SelectionState state = RenderObject::SelectionNone;
-    for (InlineBox* box = firstLeafChild(); box; box = box->nextLeafChild()) {
+    for (InlineBox* box = firstLeafDescendant(); box; box = box->nextLeafOnLine()) {
         RenderObject::SelectionState boxState = box->selectionState();
         if ((boxState == RenderObject::SelectionStart && state == RenderObject::SelectionEnd) ||
             (boxState == RenderObject::SelectionEnd && state == RenderObject::SelectionStart))
             state = RenderObject::SelectionBoth;
         else if (state == RenderObject::SelectionNone ||
@@ -551,20 +551,20 @@
     return state;
 }
 
 InlineBox* RootInlineBox::firstSelectedBox()
 {
-    for (auto* box = firstLeafChild(); box; box = box->nextLeafChild()) {
+    for (auto* box = firstLeafDescendant(); box; box = box->nextLeafOnLine()) {
         if (box->selectionState() != RenderObject::SelectionNone)
             return box;
     }
     return nullptr;
 }
 
 InlineBox* RootInlineBox::lastSelectedBox()
 {
-    for (auto* box = lastLeafChild(); box; box = box->prevLeafChild()) {
+    for (auto* box = lastLeafDescendant(); box; box = box->previousLeafOnLine()) {
         if (box->selectionState() != RenderObject::SelectionNone)
             return box;
     }
     return nullptr;
 }
@@ -764,18 +764,18 @@
     return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
 }
 
 InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
 {
-    InlineBox* firstLeaf = firstLeafChild();
-    InlineBox* lastLeaf = lastLeafChild();
+    InlineBox* firstLeaf = firstLeafDescendant();
+    InlineBox* lastLeaf = lastLeafDescendant();
 
     if (firstLeaf != lastLeaf) {
         if (firstLeaf->isLineBreak())
-            firstLeaf = firstLeaf->nextLeafChildIgnoringLineBreak();
+            firstLeaf = firstLeaf->nextLeafOnLineIgnoringLineBreak();
         else if (lastLeaf->isLineBreak())
-            lastLeaf = lastLeaf->prevLeafChildIgnoringLineBreak();
+            lastLeaf = lastLeaf->previousLeafOnLineIgnoringLineBreak();
     }
 
     if (firstLeaf == lastLeaf && (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
         return firstLeaf;
 
@@ -789,11 +789,11 @@
         // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
         // Return it.
         return lastLeaf;
 
     InlineBox* closestLeaf = nullptr;
-    for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf->nextLeafChildIgnoringLineBreak()) {
+    for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf->nextLeafOnLineIgnoringLineBreak()) {
         if (!leaf->renderer().isListMarker() && (!onlyEditableLeaves || isEditableLeaf(leaf))) {
             closestLeaf = leaf;
             if (leftPosition < leaf->logicalRight())
                 // The x coordinate is less than the right edge of the box.
                 // Return it.
@@ -826,11 +826,13 @@
     return gEllipsisBoxMap->get(this);
 }
 
 void RootInlineBox::removeLineBoxFromRenderObject()
 {
-    blockFlow().complexLineLayout()->lineBoxes().removeLineBox(this);
+    // Null if we are destroying ComplexLineLayout.
+    if (auto* complexLineLayout = blockFlow().complexLineLayout())
+        complexLineLayout->lineBoxes().removeLineBox(this);
 }
 
 void RootInlineBox::extractLineBoxFromRenderObject()
 {
     blockFlow().complexLineLayout()->lineBoxes().extractLineBox(this);
@@ -880,11 +882,11 @@
     bool ascentDescentSet = false;
 
     // Replaced boxes will return 0 for the line-height if line-box-contain says they are
     // not to be included.
     if (box.renderer().isReplaced()) {
-        if (lineStyle().lineBoxContain() & LineBoxContainReplaced) {
+        if (lineStyle().lineBoxContain().contains(LineBoxContain::Replaced)) {
             ascent = box.baselinePosition(baselineType());
             descent = box.lineHeight() - ascent;
 
             // Replaced elements always affect both the ascent and descent.
             affectsAscent = true;
@@ -1066,70 +1068,63 @@
 bool RootInlineBox::includeLeadingForBox(InlineBox& box) const
 {
     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() && !box.behavesLikeText()))
         return false;
 
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return (lineBoxContain & LineBoxContainInline) || (&box == this && (lineBoxContain & LineBoxContainBlock));
+    auto lineBoxContain = renderer().style().lineBoxContain();
+    return lineBoxContain.contains(LineBoxContain::Inline) || (&box == this && lineBoxContain.contains(LineBoxContain::Block));
 }
 
 bool RootInlineBox::includeFontForBox(InlineBox& box) const
 {
     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() && !box.behavesLikeText()))
         return false;
 
     if (!box.behavesLikeText() && is<InlineFlowBox>(box) && !downcast<InlineFlowBox>(box).hasTextChildren())
         return false;
 
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return (lineBoxContain & LineBoxContainFont);
+    return renderer().style().lineBoxContain().contains(LineBoxContain::Font);
 }
 
 bool RootInlineBox::includeGlyphsForBox(InlineBox& box) const
 {
     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() && !box.behavesLikeText()))
         return false;
 
     if (!box.behavesLikeText() && is<InlineFlowBox>(box) && !downcast<InlineFlowBox>(box).hasTextChildren())
         return false;
 
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return (lineBoxContain & LineBoxContainGlyphs);
+    return renderer().style().lineBoxContain().contains(LineBoxContain::Glyphs);
 }
 
 bool RootInlineBox::includeInitialLetterForBox(InlineBox& box) const
 {
     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() && !box.behavesLikeText()))
         return false;
 
     if (!box.behavesLikeText() && is<InlineFlowBox>(box) && !downcast<InlineFlowBox>(box).hasTextChildren())
         return false;
 
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return (lineBoxContain & LineBoxContainInitialLetter);
+    return renderer().style().lineBoxContain().contains(LineBoxContain::InitialLetter);
 }
 
 bool RootInlineBox::includeMarginForBox(InlineBox& box) const
 {
     if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() && !box.behavesLikeText()))
         return false;
 
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return lineBoxContain & LineBoxContainInlineBox;
+    return renderer().style().lineBoxContain().contains(LineBoxContain::InlineBox);
 }
 
-
 bool RootInlineBox::fitsToGlyphs() const
 {
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return ((lineBoxContain & LineBoxContainGlyphs) || (lineBoxContain & LineBoxContainInitialLetter));
+    return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Glyphs, LineBoxContain::InitialLetter });
 }
 
 bool RootInlineBox::includesRootLineBoxFontOrLeading() const
 {
-    LineBoxContain lineBoxContain = renderer().style().lineBoxContain();
-    return (lineBoxContain & LineBoxContainBlock) || (lineBoxContain & LineBoxContainInline) || (lineBoxContain & LineBoxContainFont);
+    return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Font });
 }
 
 Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*& startBox) const
 {
     Vector<InlineBox*> leafBoxesInLogicalOrder;

diff a/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/shadow/TextControlInnerElements.cpp
@@ -78,11 +78,11 @@
 static inline bool isStrongPasswordTextField(const Element* element)
 {
     return is<HTMLInputElement>(element) && downcast<HTMLInputElement>(element)->hasAutoFillStrongPasswordButton();
 }
 
-Optional<ElementStyle> TextControlInnerContainer::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle*)
+Optional<Style::ElementStyle> TextControlInnerContainer::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle*)
 {
     auto elementStyle = resolveStyle(&parentStyle);
     if (isStrongPasswordTextField(shadowHost())) {
         elementStyle.renderStyle->setFlexWrap(FlexWrap::Wrap);
         elementStyle.renderStyle->setOverflowX(Overflow::Hidden);
@@ -100,11 +100,11 @@
 Ref<TextControlInnerElement> TextControlInnerElement::create(Document& document)
 {
     return adoptRef(*new TextControlInnerElement(document));
 }
 
-Optional<ElementStyle> TextControlInnerElement::resolveCustomStyle(const RenderStyle&, const RenderStyle* shadowHostStyle)
+Optional<Style::ElementStyle> TextControlInnerElement::resolveCustomStyle(const RenderStyle&, const RenderStyle* shadowHostStyle)
 {
     auto newStyle = RenderStyle::createPtr();
     newStyle->inheritFrom(*shadowHostStyle);
     newStyle->setFlexGrow(1);
     newStyle->setMinWidth(Length { 0, Fixed }); // Needed for correct shrinking.
@@ -120,16 +120,16 @@
         newStyle->setOverflowY(Overflow::Hidden);
 
         // Set "flex-basis: 1em". Note that CSSPrimitiveValue::computeLengthInt() only needs the element's
         // style to calculate em lengths. Since the element might not be in a document, just pass nullptr
         // for the root element style and the render view.
-        auto emSize = CSSPrimitiveValue::create(1, CSSPrimitiveValue::CSS_EMS);
+        auto emSize = CSSPrimitiveValue::create(1, CSSUnitType::CSS_EMS);
         int pixels = emSize->computeLength<int>(CSSToLengthConversionData { newStyle.get(), nullptr, nullptr, 1.0, false });
         newStyle->setFlexBasis(Length { pixels, Fixed });
     }
 
-    return ElementStyle { WTFMove(newStyle) };
+    return { WTFMove(newStyle) };
 }
 
 // MARK: TextControlInnerTextElement
 
 inline TextControlInnerTextElement::TextControlInnerTextElement(Document& document)
@@ -169,14 +169,14 @@
 RenderTextControlInnerBlock* TextControlInnerTextElement::renderer() const
 {
     return downcast<RenderTextControlInnerBlock>(HTMLDivElement::renderer());
 }
 
-Optional<ElementStyle> TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&, const RenderStyle* shadowHostStyle)
+Optional<Style::ElementStyle> TextControlInnerTextElement::resolveCustomStyle(const RenderStyle&, const RenderStyle* shadowHostStyle)
 {
     auto style = downcast<HTMLTextFormControlElement>(*shadowHost()).createInnerTextStyle(*shadowHostStyle);
-    return ElementStyle(makeUnique<RenderStyle>(WTFMove(style)));
+    return { makeUnique<RenderStyle>(WTFMove(style)) };
 }
 
 // MARK: TextControlPlaceholderElement
 
 inline TextControlPlaceholderElement::TextControlPlaceholderElement(Document& document)
@@ -189,11 +189,11 @@
 Ref<TextControlPlaceholderElement> TextControlPlaceholderElement::create(Document& document)
 {
     return adoptRef(*new TextControlPlaceholderElement(document));
 }
 
-Optional<ElementStyle> TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle* shadowHostStyle)
+Optional<Style::ElementStyle> TextControlPlaceholderElement::resolveCustomStyle(const RenderStyle& parentStyle, const RenderStyle* shadowHostStyle)
 {
     auto style = resolveStyle(&parentStyle);
 
     auto& controlElement = downcast<HTMLTextFormControlElement>(*containingShadowRoot()->host());
     style.renderStyle->setDisplay(controlElement.isPlaceholderVisible() ? DisplayType::Block : DisplayType::None);

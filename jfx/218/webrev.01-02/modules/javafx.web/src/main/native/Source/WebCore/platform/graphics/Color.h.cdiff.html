<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Color.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ColorSpace.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2003-2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,17 ***</span>
  
  #if PLATFORM(GTK)
  typedef struct _GdkRGBA GdkRGBA;
  #endif
  
<span class="line-removed">- namespace WTF {</span>
<span class="line-removed">- class TextStream;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  namespace WebCore {
  
<span class="line-modified">! typedef unsigned RGBA32; // Deprecated: Type for an RGBA quadruplet. Use RGBA class instead.</span>
  
  WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
  WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
  
  RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling = true);
<span class="line-new-header">--- 50,41 ---</span>
  
  #if PLATFORM(GTK)
  typedef struct _GdkRGBA GdkRGBA;
  #endif
  
  namespace WebCore {
  
<span class="line-modified">! // Color value with 8-bit components for red, green, blue, and alpha.</span>
<span class="line-added">+ // For historical reasons, stored as a 32-bit integer, with alpha in the high bits: ARGB.</span>
<span class="line-added">+ class SimpleColor {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     constexpr SimpleColor(uint32_t value = 0) : m_value { value } { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     constexpr uint32_t value() const { return m_value; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     constexpr uint8_t redComponent() const { return m_value &gt;&gt; 16; }</span>
<span class="line-added">+     constexpr uint8_t greenComponent() const { return m_value &gt;&gt; 8; }</span>
<span class="line-added">+     constexpr uint8_t blueComponent() const { return m_value; }</span>
<span class="line-added">+     constexpr uint8_t alphaComponent() const { return m_value &gt;&gt; 24; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     constexpr bool isOpaque() const { return alphaComponent() == 0xFF; }</span>
<span class="line-added">+     constexpr bool isVisible() const { return alphaComponent(); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     String serializationForHTML() const;</span>
<span class="line-added">+     String serializationForCSS() const;</span>
<span class="line-added">+     String serializationForRenderTreeAsText() const;</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     uint32_t m_value { 0 };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool operator==(SimpleColor, SimpleColor);</span>
<span class="line-added">+ bool operator!=(SimpleColor, SimpleColor);</span>
<span class="line-added">+ </span>
<span class="line-added">+ // FIXME: Remove this after migrating to the new name.</span>
<span class="line-added">+ using RGBA32 = SimpleColor;</span>
  
  WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
  WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
  
  RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling = true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,43 ***</span>
  
  WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
  RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha);
  
  WEBCORE_EXPORT RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
<span class="line-modified">! RGBA32 makeRGBAFromHSLA(double h, double s, double l, double a);</span>
  RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);
  
<span class="line-removed">- inline int redChannel(RGBA32 color) { return (color &gt;&gt; 16) &amp; 0xFF; }</span>
<span class="line-removed">- inline int greenChannel(RGBA32 color) { return (color &gt;&gt; 8) &amp; 0xFF; }</span>
<span class="line-removed">- inline int blueChannel(RGBA32 color) { return color &amp; 0xFF; }</span>
<span class="line-removed">- inline int alphaChannel(RGBA32 color) { return (color &gt;&gt; 24) &amp; 0xFF; }</span>
<span class="line-removed">- </span>
  uint8_t roundAndClampColorChannel(int);
  uint8_t roundAndClampColorChannel(float);
  
<span class="line-removed">- class RGBA {</span>
<span class="line-removed">- public:</span>
<span class="line-removed">-     RGBA(); // all channels zero, including alpha</span>
<span class="line-removed">-     RGBA(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha);</span>
<span class="line-removed">-     RGBA(uint8_t red, uint8_t green, uint8_t blue); // opaque, alpha of 1</span>
<span class="line-removed">- </span>
<span class="line-removed">-     uint8_t red() const;</span>
<span class="line-removed">-     uint8_t green() const;</span>
<span class="line-removed">-     uint8_t blue() const;</span>
<span class="line-removed">-     uint8_t alpha() const;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool hasAlpha() const;</span>
<span class="line-removed">- </span>
<span class="line-removed">- private:</span>
<span class="line-removed">-     friend class Color;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     unsigned m_integer { 0 };</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool operator==(const RGBA&amp;, const RGBA&amp;);</span>
<span class="line-removed">- bool operator!=(const RGBA&amp;, const RGBA&amp;);</span>
<span class="line-removed">- </span>
  class Color {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      Color() { }
  
<span class="line-new-header">--- 92,16 ---</span>
  
  WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
  RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha);
  
  WEBCORE_EXPORT RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
<span class="line-modified">! RGBA32 makeRGBAFromHSLA(float h, float s, float l, float a);</span>
  RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);
  
  uint8_t roundAndClampColorChannel(int);
  uint8_t roundAndClampColorChannel(float);
  
  class Color {
      WTF_MAKE_FAST_ALLOCATED;
  public:
      Color() { }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,11 ***</span>
          if (valid)
              setRGB(color);
      }
  
      enum SemanticTag { Semantic };
<span class="line-removed">- </span>
      Color(RGBA32 color, SemanticTag)
      {
          setRGB(color);
          setIsSemantic();
      }
<span class="line-new-header">--- 112,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,31 ***</span>
      // This creates an ExtendedColor.
      // FIXME: If the colorSpace is sRGB and the values can all be
      // converted exactly to integers, we should make a normal Color.
      WEBCORE_EXPORT Color(float r, float g, float b, float a, ColorSpace colorSpace);
  
<span class="line-removed">-     Color(RGBA, ColorSpace);</span>
      WEBCORE_EXPORT Color(const Color&amp;);
      WEBCORE_EXPORT Color(Color&amp;&amp;);
  
      ~Color()
      {
          if (isExtended())
              m_colorData.extendedColor-&gt;deref();
      }
  
<span class="line-removed">-     static Color createUnchecked(int r, int g, int b)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         RGBA32 color = 0xFF000000 | r &lt;&lt; 16 | g &lt;&lt; 8 | b;</span>
<span class="line-removed">-         return Color(color);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     static Color createUnchecked(int r, int g, int b, int a)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         RGBA32 color = a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b;</span>
<span class="line-removed">-         return Color(color);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // Returns the color serialized according to HTML5
      // &lt;https://html.spec.whatwg.org/multipage/scripting.html#fill-and-stroke-styles&gt; (10 September 2015)
      WEBCORE_EXPORT String serialized() const;
  
      WEBCORE_EXPORT String cssText() const;
<span class="line-new-header">--- 169,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,19 ***</span>
      // Returns the color serialized as either #RRGGBB or #RRGGBBAA
      String nameForRenderTreeAsText() const;
  
      bool isValid() const { return isExtended() || (m_colorData.rgbaAndFlags &amp; validRGBAColorBit); }
  
<span class="line-modified">!     bool isOpaque() const { return isValid() &amp;&amp; (isExtended() ? asExtended().alpha() == 1.0 : alpha() == 255); }</span>
<span class="line-modified">!     bool isVisible() const { return isValid() &amp;&amp; (isExtended() ? asExtended().alpha() &gt; 0.0 : alpha() &gt; 0); }</span>
  
<span class="line-modified">!     int red() const { return redChannel(rgb()); }</span>
<span class="line-modified">!     int green() const { return greenChannel(rgb()); }</span>
<span class="line-modified">!     int blue() const { return blueChannel(rgb()); }</span>
<span class="line-modified">!     int alpha() const { return alphaChannel(rgb()); }</span>
  
<span class="line-modified">!     float alphaAsFloat() const { return isExtended() ? asExtended().alpha() : static_cast&lt;float&gt;(alphaChannel(rgb())) / 255; }</span>
  
      RGBA32 rgb() const;
  
      // FIXME: Like operator==, this will give different values for ExtendedColors that
      // should be identical, since the respective pointer will be different.
<span class="line-new-header">--- 189,19 ---</span>
      // Returns the color serialized as either #RRGGBB or #RRGGBBAA
      String nameForRenderTreeAsText() const;
  
      bool isValid() const { return isExtended() || (m_colorData.rgbaAndFlags &amp; validRGBAColorBit); }
  
<span class="line-modified">!     bool isOpaque() const { return isExtended() ? asExtended().alpha() == 1.0 : rgb().isOpaque(); }</span>
<span class="line-modified">!     bool isVisible() const { return isExtended() ? asExtended().alpha() &gt; 0.0 : rgb().isVisible(); }</span>
  
<span class="line-modified">!     int red() const { return rgb().redComponent(); }</span>
<span class="line-modified">!     int green() const { return rgb().greenComponent(); }</span>
<span class="line-modified">!     int blue() const { return rgb().blueComponent(); }</span>
<span class="line-modified">!     int alpha() const { return rgb().alphaComponent(); }</span>
  
<span class="line-modified">!     float alphaAsFloat() const { return isExtended() ? asExtended().alpha() : static_cast&lt;float&gt;(rgb().alphaComponent()) / 0xFF; }</span>
  
      RGBA32 rgb() const;
  
      // FIXME: Like operator==, this will give different values for ExtendedColors that
      // should be identical, since the respective pointer will be different.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,23 ***</span>
      static bool parseHexColor(const String&amp;, RGBA32&amp;);
      static bool parseHexColor(const StringView&amp;, RGBA32&amp;);
      static bool parseHexColor(const LChar*, unsigned, RGBA32&amp;);
      static bool parseHexColor(const UChar*, unsigned, RGBA32&amp;);
  
<span class="line-modified">!     static const RGBA32 black = 0xFF000000;</span>
<span class="line-modified">!     WEBCORE_EXPORT static const RGBA32 white = 0xFFFFFFFF;</span>
<span class="line-modified">!     static const RGBA32 darkGray = 0xFF808080;</span>
<span class="line-modified">!     static const RGBA32 gray = 0xFFA0A0A0;</span>
<span class="line-modified">!     static const RGBA32 lightGray = 0xFFC0C0C0;</span>
<span class="line-modified">!     WEBCORE_EXPORT static const RGBA32 transparent = 0x00000000;</span>
<span class="line-modified">!     static const RGBA32 cyan = 0xFF00FFFF;</span>
<span class="line-modified">!     static const RGBA32 yellow = 0xFFFFFF00;</span>
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     static const RGBA32 compositionFill = 0x3CAFC0E3;</span>
  #else
<span class="line-modified">!     static const RGBA32 compositionFill = 0xFFE1DD55;</span>
  #endif
  
      bool isExtended() const
      {
          return !(m_colorData.rgbaAndFlags &amp; invalidRGBAColor);
<span class="line-new-header">--- 251,23 ---</span>
      static bool parseHexColor(const String&amp;, RGBA32&amp;);
      static bool parseHexColor(const StringView&amp;, RGBA32&amp;);
      static bool parseHexColor(const LChar*, unsigned, RGBA32&amp;);
      static bool parseHexColor(const UChar*, unsigned, RGBA32&amp;);
  
<span class="line-modified">!     static constexpr SimpleColor black { 0xFF000000 };</span>
<span class="line-modified">!     static constexpr SimpleColor white { 0xFFFFFFFF };</span>
<span class="line-modified">!     static constexpr SimpleColor darkGray { 0xFF808080 };</span>
<span class="line-modified">!     static constexpr SimpleColor gray { 0xFFA0A0A0 };</span>
<span class="line-modified">!     static constexpr SimpleColor lightGray { 0xFFC0C0C0 };</span>
<span class="line-modified">!     static constexpr SimpleColor transparent { 0x00000000 };</span>
<span class="line-modified">!     static constexpr SimpleColor cyan { 0xFF00FFFF };</span>
<span class="line-modified">!     static constexpr SimpleColor yellow { 0xFFFFFF00 };</span>
  
  #if PLATFORM(IOS_FAMILY)
<span class="line-modified">!     static constexpr SimpleColor compositionFill { 0x3CAFC0E3 };</span>
  #else
<span class="line-modified">!     static constexpr SimpleColor compositionFill { 0xFFE1DD55 };</span>
  #endif
  
      bool isExtended() const
      {
          return !(m_colorData.rgbaAndFlags &amp; invalidRGBAColor);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,53 ***</span>
  
  #if USE(CG)
  WEBCORE_EXPORT CGColorRef cachedCGColor(const Color&amp;);
  #endif
  
<span class="line-modified">! inline RGBA::RGBA()</span>
<span class="line-modified">! {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline RGBA::RGBA(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha)</span>
<span class="line-removed">-     : m_integer(alpha &lt;&lt; 24 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline RGBA::RGBA(uint8_t red, uint8_t green, uint8_t blue)</span>
<span class="line-removed">-     : m_integer(0xFF000000 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline uint8_t RGBA::red() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_integer &gt;&gt; 16;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline uint8_t RGBA::green() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_integer &gt;&gt; 8;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline uint8_t RGBA::blue() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_integer;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- inline uint8_t RGBA::alpha() const</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return m_integer &gt;&gt; 24;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! inline bool RGBA::hasAlpha() const</span>
  {
<span class="line-modified">!     return (m_integer &amp; 0xFF000000) != 0xFF000000;</span>
  }
  
<span class="line-modified">! inline Color::Color(RGBA color, ColorSpace space)</span>
  {
<span class="line-modified">!     setRGB(color.m_integer);</span>
<span class="line-removed">-     ASSERT_UNUSED(space, space == ColorSpaceSRGB);</span>
  }
  
  inline bool operator==(const Color&amp; a, const Color&amp; b)
  {
      return a.m_colorData.rgbaAndFlags == b.m_colorData.rgbaAndFlags;
<span class="line-new-header">--- 325,21 ---</span>
  
  #if USE(CG)
  WEBCORE_EXPORT CGColorRef cachedCGColor(const Color&amp;);
  #endif
  
<span class="line-modified">! WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Color&amp;);</span>
<span class="line-modified">! WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ColorSpace);</span>
  
<span class="line-modified">! inline bool operator==(SimpleColor a, SimpleColor b)</span>
  {
<span class="line-modified">!     return a.value() == b.value();</span>
  }
  
<span class="line-modified">! inline bool operator!=(SimpleColor a, SimpleColor b)</span>
  {
<span class="line-modified">!     return !(a == b);</span>
  }
  
  inline bool operator==(const Color&amp; a, const Color&amp; b)
  {
      return a.m_colorData.rgbaAndFlags == b.m_colorData.rgbaAndFlags;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,42 ***</span>
  inline RGBA32 Color::rgb() const
  {
      // FIXME: We should ASSERT(!isExtended()) here, or produce
      // an RGBA32 equivalent for an ExtendedColor. Ideally the former,
      // so we can audit all the rgb() call sites to handle extended.
<span class="line-modified">!     return static_cast&lt;RGBA32&gt;(m_colorData.rgbaAndFlags &gt;&gt; 32);</span>
  }
  
  inline void Color::setRGB(RGBA32 rgb)
  {
<span class="line-modified">!     m_colorData.rgbaAndFlags = static_cast&lt;uint64_t&gt;(rgb) &lt;&lt; 32;</span>
      tagAsValid();
  }
  
  inline bool Color::isBlackColor(const Color&amp; color)
  {
      if (color.isExtended()) {
          const ExtendedColor&amp; extendedColor = color.asExtended();
          return !extendedColor.red() &amp;&amp; !extendedColor.green() &amp;&amp; !extendedColor.blue() &amp;&amp; extendedColor.alpha() == 1;
      }
  
<span class="line-modified">!     return color.isValid() &amp;&amp; color.rgb() == Color::black;</span>
  }
  
  inline bool Color::isWhiteColor(const Color&amp; color)
  {
      if (color.isExtended()) {
          const ExtendedColor&amp; extendedColor = color.asExtended();
          return extendedColor.red() == 1 &amp;&amp; extendedColor.green() == 1 &amp;&amp; extendedColor.blue() == 1 &amp;&amp; extendedColor.alpha() == 1;
      }
  
<span class="line-modified">!     return color.isValid() &amp;&amp; color.rgb() == Color::white;</span>
  }
  
<span class="line-removed">- WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Color&amp;);</span>
<span class="line-removed">- WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ColorSpace);</span>
<span class="line-removed">- </span>
  } // namespace WebCore
  
  namespace WTF {
  template&lt;&gt; struct DefaultHash&lt;WebCore::Color&gt;;
  template&lt;&gt; struct HashTraits&lt;WebCore::Color&gt;;
<span class="line-new-header">--- 387,39 ---</span>
  inline RGBA32 Color::rgb() const
  {
      // FIXME: We should ASSERT(!isExtended()) here, or produce
      // an RGBA32 equivalent for an ExtendedColor. Ideally the former,
      // so we can audit all the rgb() call sites to handle extended.
<span class="line-modified">!     return { static_cast&lt;uint32_t&gt;(m_colorData.rgbaAndFlags &gt;&gt; 32) };</span>
  }
  
  inline void Color::setRGB(RGBA32 rgb)
  {
<span class="line-modified">!     m_colorData.rgbaAndFlags = static_cast&lt;uint64_t&gt;(rgb.value()) &lt;&lt; 32;</span>
      tagAsValid();
  }
  
  inline bool Color::isBlackColor(const Color&amp; color)
  {
      if (color.isExtended()) {
          const ExtendedColor&amp; extendedColor = color.asExtended();
          return !extendedColor.red() &amp;&amp; !extendedColor.green() &amp;&amp; !extendedColor.blue() &amp;&amp; extendedColor.alpha() == 1;
      }
  
<span class="line-modified">!     return color.rgb() == Color::black;</span>
  }
  
  inline bool Color::isWhiteColor(const Color&amp; color)
  {
      if (color.isExtended()) {
          const ExtendedColor&amp; extendedColor = color.asExtended();
          return extendedColor.red() == 1 &amp;&amp; extendedColor.green() == 1 &amp;&amp; extendedColor.blue() == 1 &amp;&amp; extendedColor.alpha() == 1;
      }
  
<span class="line-modified">!     return color.rgb() == Color::white;</span>
  }
  
  } // namespace WebCore
  
  namespace WTF {
  template&lt;&gt; struct DefaultHash&lt;WebCore::Color&gt;;
  template&lt;&gt; struct HashTraits&lt;WebCore::Color&gt;;
</pre>
<center><a href="Color.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ColorSpace.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
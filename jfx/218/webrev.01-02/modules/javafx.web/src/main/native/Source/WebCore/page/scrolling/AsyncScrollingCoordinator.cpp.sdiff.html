<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../linux/ResourceUsageOverlayLinux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AsyncScrollingCoordinator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
 40 #include &quot;RenderLayerCompositor.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;ScrollAnimator.h&quot;
 43 #include &quot;ScrollingConstraints.h&quot;
 44 #include &quot;ScrollingStateFixedNode.h&quot;
 45 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 46 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 47 #include &quot;ScrollingStateOverflowScrollProxyNode.h&quot;
 48 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
 49 #include &quot;ScrollingStatePositionedNode.h&quot;
 50 #include &quot;ScrollingStateStickyNode.h&quot;
 51 #include &quot;ScrollingStateTree.h&quot;
 52 #include &quot;Settings.h&quot;
<span class="line-modified"> 53 #include &quot;WheelEventTestTrigger.h&quot;</span>
 54 #include &lt;wtf/ProcessID.h&gt;
 55 #include &lt;wtf/text/TextStream.h&gt;
 56 
 57 namespace WebCore {
 58 
 59 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 60     : ScrollingCoordinator(page)
 61     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
 62     , m_scrollingStateTree(makeUnique&lt;ScrollingStateTree&gt;(this))
 63 {
 64 }
 65 
 66 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 67 
 68 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 69 {
 70     scheduleTreeStateCommit();
 71 }
 72 
 73 #if ENABLE(CSS_SCROLL_SNAP)
</pre>
<hr />
<pre>
120     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
121     m_eventTrackingRegionsDirty = false;
122 }
123 
124 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
125 {
126     ASSERT(isMainThread());
127     ASSERT(m_page);
128 
129     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
130     if (!m_scrollingStateTree-&gt;rootStateNode())
131         return;
132 
133     setEventTrackingRegionsDirty();
134 
135 #if PLATFORM(COCOA)
136     if (!coordinatesScrollingForFrameView(frameView))
137         return;
138 
139     auto* page = frameView.frame().page();
<span class="line-modified">140     if (page &amp;&amp; page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-modified">141         LOG(WheelEventTestTriggers, &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger=%d&quot;, page-&gt;expectsWheelEventTriggers());</span>
142 
143         auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
144         if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
145             return;
146 
147         auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
<span class="line-modified">148         frameScrollingNode.setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());</span>
149     }
150 #else
151     UNUSED_PARAM(frameView);
152 #endif
153 }
154 
155 void AsyncScrollingCoordinator::frameViewVisualViewportChanged(FrameView&amp; frameView)
156 {
157     ASSERT(isMainThread());
158     ASSERT(m_page);
159 
160     if (!coordinatesScrollingForFrameView(frameView))
161         return;
162 
163     // If the root layer does not have a ScrollingStateNode, then we should create one.
164     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
165     if (!node)
166         return;
167 
168     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
169 
170     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
171         auto layoutViewport = frameView.layoutViewportRect();
172         auto visualViewport = frameView.visualViewportRect();
173         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
174     };
175     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
176 }
177 
<span class="line-modified">178 void AsyncScrollingCoordinator::updateExpectsWheelEventTestTriggerWithFrameView(const FrameView&amp; frameView)</span>
179 {
180     auto* page = frameView.frame().page();
181     if (!page)
182         return;
183 
184     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
185     if (!node)
186         return;
187 
<span class="line-modified">188     node-&gt;setExpectsWheelEventTestTrigger(page-&gt;expectsWheelEventTriggers());</span>
189 }
190 
191 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
192 {
193     if (!m_scrollingStateTree-&gt;rootStateNode())
194         return;
195 
196     setEventTrackingRegionsDirty();
197     DebugPageOverlays::didChangeEventHandlers(frameView.frame());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
201 {
202     ASSERT(isMainThread());
203     ASSERT(m_page);
204 
205     if (!coordinatesScrollingForFrameView(frameView))
206         return;
207 
208     // FIXME: In some navigation scenarios, the FrameView has no RenderView or that RenderView has not been composited.
</pre>
<hr />
<pre>
213     // If the root layer does not have a ScrollingStateNode, then we should create one.
214     ensureRootStateNodeForFrameView(frameView);
215     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
216 
217     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
218 
219     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
220     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
221     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
222     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
223     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
224     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
225     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
226     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
227     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
228     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
229     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
230     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
231 }
232 
<span class="line-modified">233 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition)</span>
234 {
235     ASSERT(isMainThread());
236     ASSERT(m_page);
237 
238     auto scrollingNodeID = scrollableArea.scrollingNodeID();
239     if (!scrollingNodeID)
240         return false;
241 
242     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
243     if (!frameView)
244         return false;
245 
246     if (!coordinatesScrollingForFrameView(*frameView))
247         return false;
248 
<span class="line-modified">249     bool inPageCache = frameView-&gt;frame().document()-&gt;pageCacheState() != Document::NotInPageCache;</span>
250     bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
<span class="line-modified">251     if (inProgrammaticScroll || inPageCache)</span>
252         updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
253 
<span class="line-modified">254     // If this frame view&#39;s document is being put into the page cache, we don&#39;t want to update our</span>


255     // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">256     if (inPageCache)</span>
257         return true;
258 
259     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
260     if (!stateNode)
261         return false;
262 
<span class="line-modified">263     stateNode-&gt;setRequestedScrollPosition(scrollPosition, inProgrammaticScroll);</span>
264     return true;
265 }
266 
267 void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
268 {
269     m_scrollingTree-&gt;applyLayerPositions();
270 }
271 
272 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, ScrollingLayerPositionAction scrollingLayerPositionAction)
273 {
274     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);
275 
276     if (m_updateNodeScrollPositionTimer.isActive()) {
277         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
278             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
279             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
280             return;
281         }
282 
283         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
</pre>
<hr />
<pre>
326     }
327 
328     return nullptr;
329 }
330 
331 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, ScrollType scrollType, ScrollingLayerPositionAction scrollingLayerPositionAction)
332 {
333     ASSERT(isMainThread());
334 
335     if (!m_page)
336         return;
337 
338     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
339     if (!frameViewPtr)
340         return;
341 
342     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
343 
344     auto&amp; frameView = *frameViewPtr;
345 





346     if (scrollingNodeID == frameView.scrollingNodeID()) {
347         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);
<span class="line-removed">348 </span>
<span class="line-removed">349 #if PLATFORM(COCOA)</span>
<span class="line-removed">350         if (m_page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-removed">351             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());</span>
<span class="line-removed">352             if (const auto&amp; trigger = m_page-&gt;testTrigger())</span>
<span class="line-removed">353                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);</span>
<span class="line-removed">354         }</span>
<span class="line-removed">355 #endif</span>
<span class="line-removed">356 </span>
357         return;
358     }
359 
360     // Overflow-scroll area.
361     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
362         auto previousScrollType = scrollableArea-&gt;currentScrollType();
363         scrollableArea-&gt;setCurrentScrollType(scrollType);
<span class="line-modified">364         scrollableArea-&gt;scrollToOffsetWithoutAnimation(ScrollableArea::scrollOffsetFromPosition(scrollPosition, toFloatSize(scrollableArea-&gt;scrollOrigin())));</span>
365         scrollableArea-&gt;setCurrentScrollType(previousScrollType);
366 
367         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
368             m_page-&gt;editorClient().overflowScrollPositionChanged();
<span class="line-removed">369 </span>
<span class="line-removed">370 #if PLATFORM(COCOA)</span>
<span class="line-removed">371         if (m_page-&gt;expectsWheelEventTriggers()) {</span>
<span class="line-removed">372             frameView.scrollAnimator().setWheelEventTestTrigger(m_page-&gt;testTrigger());</span>
<span class="line-removed">373             if (const auto&amp; trigger = m_page-&gt;testTrigger())</span>
<span class="line-removed">374                 trigger-&gt;removeTestDeferralForReason(reinterpret_cast&lt;WheelEventTestTrigger::ScrollableAreaIdentifier&gt;(scrollingNodeID), WheelEventTestTrigger::ScrollingThreadSyncNeeded);</span>
<span class="line-removed">375         }</span>
<span class="line-removed">376 #endif</span>
377     }
378 }
379 
380 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
381 {
382     auto previousScrollType = frameView.currentScrollType();
383     frameView.setCurrentScrollType(scrollType);
384 
385     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; type &quot; &lt;&lt; scrollType &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);
386 
387     Optional&lt;FloatRect&gt; layoutViewportRect;
388 
389     WTF::switchOn(layoutViewportOriginOrOverrideRect,
390         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
391             if (origin)
392                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
393         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability](Optional&lt;FloatRect&gt; overrideRect) {
394             if (!overrideRect)
395                 return;
396 
</pre>
<hr />
<pre>
832     if (!m_page)
833         return;
834 
835     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
836     if (!frameView)
837         return;
838 
839     if (scrollingNodeID == frameView-&gt;scrollingNodeID()) {
840         frameView-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
841         frameView-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
842         return;
843     }
844 
845     // Overflow-scroll area.
846     if (auto* scrollableArea = frameView-&gt;scrollableAreaForScrollLayerID(scrollingNodeID)) {
847         scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
848         scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
849     }
850 }
851 
<span class="line-modified">852 void AsyncScrollingCoordinator::deferTestsForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const</span>
853 {
854     ASSERT(isMainThread());
<span class="line-modified">855     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())</span>
856         return;
857 
<span class="line-modified">858     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {</span>
<span class="line-modified">859         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::deferTestsForReason: Deferring %p for reason %d.&quot;, identifier, reason);</span>
<span class="line-modified">860         trigger-&gt;deferTestsForReason(identifier, reason);</span>
861     }
862 }
863 
<span class="line-modified">864 void AsyncScrollingCoordinator::removeTestDeferralForReason(WheelEventTestTrigger::ScrollableAreaIdentifier identifier, WheelEventTestTrigger::DeferTestTriggerReason reason) const</span>
865 {
866     ASSERT(isMainThread());
<span class="line-modified">867     if (!m_page || !m_page-&gt;expectsWheelEventTriggers())</span>
868         return;
869 
<span class="line-modified">870     if (const auto&amp; trigger = m_page-&gt;testTrigger()) {</span>
<span class="line-modified">871         LOG(WheelEventTestTriggers, &quot;    (!) AsyncScrollingCoordinator::removeTestDeferralForReason: Deferring %p for reason %d.&quot;, identifier, reason);</span>
<span class="line-modified">872         trigger-&gt;removeTestDeferralForReason(identifier, reason);</span>
873     }
874 }
875 #endif
876 
877 #if ENABLE(CSS_SCROLL_SNAP)
878 bool AsyncScrollingCoordinator::isScrollSnapInProgress() const
879 {
880     return scrollingTree()-&gt;isScrollSnapInProgress();
881 }
882 
883 void AsyncScrollingCoordinator::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView)
884 {
885     if (auto node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))) {
886         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Horizontal, frameView.horizontalSnapOffsets(), frameView.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
887         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Vertical, frameView.verticalSnapOffsets(), frameView.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
888         node-&gt;setCurrentHorizontalSnapPointIndex(frameView.currentHorizontalSnapPointIndex());
889         node-&gt;setCurrentVerticalSnapPointIndex(frameView.currentVerticalSnapPointIndex());
890     }
891 }
892 #endif
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &quot;EditorClient.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;GraphicsLayer.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;Page.h&quot;
 39 #include &quot;PerformanceLoggingClient.h&quot;
 40 #include &quot;RenderLayerCompositor.h&quot;
 41 #include &quot;RenderView.h&quot;
 42 #include &quot;ScrollAnimator.h&quot;
 43 #include &quot;ScrollingConstraints.h&quot;
 44 #include &quot;ScrollingStateFixedNode.h&quot;
 45 #include &quot;ScrollingStateFrameHostingNode.h&quot;
 46 #include &quot;ScrollingStateFrameScrollingNode.h&quot;
 47 #include &quot;ScrollingStateOverflowScrollProxyNode.h&quot;
 48 #include &quot;ScrollingStateOverflowScrollingNode.h&quot;
 49 #include &quot;ScrollingStatePositionedNode.h&quot;
 50 #include &quot;ScrollingStateStickyNode.h&quot;
 51 #include &quot;ScrollingStateTree.h&quot;
 52 #include &quot;Settings.h&quot;
<span class="line-modified"> 53 #include &quot;WheelEventTestMonitor.h&quot;</span>
 54 #include &lt;wtf/ProcessID.h&gt;
 55 #include &lt;wtf/text/TextStream.h&gt;
 56 
 57 namespace WebCore {
 58 
 59 AsyncScrollingCoordinator::AsyncScrollingCoordinator(Page* page)
 60     : ScrollingCoordinator(page)
 61     , m_updateNodeScrollPositionTimer(*this, &amp;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScrollTimerFired)
 62     , m_scrollingStateTree(makeUnique&lt;ScrollingStateTree&gt;(this))
 63 {
 64 }
 65 
 66 AsyncScrollingCoordinator::~AsyncScrollingCoordinator() = default;
 67 
 68 void AsyncScrollingCoordinator::scrollingStateTreePropertiesChanged()
 69 {
 70     scheduleTreeStateCommit();
 71 }
 72 
 73 #if ENABLE(CSS_SCROLL_SNAP)
</pre>
<hr />
<pre>
120     m_scrollingStateTree-&gt;rootStateNode()-&gt;setEventTrackingRegions(absoluteEventTrackingRegions());
121     m_eventTrackingRegionsDirty = false;
122 }
123 
124 void AsyncScrollingCoordinator::frameViewLayoutUpdated(FrameView&amp; frameView)
125 {
126     ASSERT(isMainThread());
127     ASSERT(m_page);
128 
129     // If there isn&#39;t a root node yet, don&#39;t do anything. We&#39;ll be called again after creating one.
130     if (!m_scrollingStateTree-&gt;rootStateNode())
131         return;
132 
133     setEventTrackingRegionsDirty();
134 
135 #if PLATFORM(COCOA)
136     if (!coordinatesScrollingForFrameView(frameView))
137         return;
138 
139     auto* page = frameView.frame().page();
<span class="line-modified">140     if (page &amp;&amp; page-&gt;isMonitoringWheelEvents()) {</span>
<span class="line-modified">141         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    AsyncScrollingCoordinator::frameViewLayoutUpdated: Expects wheel event test trigger: &quot; &lt;&lt; page-&gt;isMonitoringWheelEvents());</span>
142 
143         auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
144         if (!is&lt;ScrollingStateFrameScrollingNode&gt;(node))
145             return;
146 
147         auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
<span class="line-modified">148         frameScrollingNode.setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
149     }
150 #else
151     UNUSED_PARAM(frameView);
152 #endif
153 }
154 
155 void AsyncScrollingCoordinator::frameViewVisualViewportChanged(FrameView&amp; frameView)
156 {
157     ASSERT(isMainThread());
158     ASSERT(m_page);
159 
160     if (!coordinatesScrollingForFrameView(frameView))
161         return;
162 
163     // If the root layer does not have a ScrollingStateNode, then we should create one.
164     auto* node = m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID());
165     if (!node)
166         return;
167 
168     auto&amp; frameScrollingNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(*node);
169 
170     auto visualViewportIsSmallerThanLayoutViewport = [](const FrameView&amp; frameView) {
171         auto layoutViewport = frameView.layoutViewportRect();
172         auto visualViewport = frameView.visualViewportRect();
173         return visualViewport.width() &lt; layoutViewport.width() || visualViewport.height() &lt; layoutViewport.height();
174     };
175     frameScrollingNode.setVisualViewportIsSmallerThanLayoutViewport(visualViewportIsSmallerThanLayoutViewport(frameView));
176 }
177 
<span class="line-modified">178 void AsyncScrollingCoordinator::updateIsMonitoringWheelEventsForFrameView(const FrameView&amp; frameView)</span>
179 {
180     auto* page = frameView.frame().page();
181     if (!page)
182         return;
183 
184     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
185     if (!node)
186         return;
187 
<span class="line-modified">188     node-&gt;setIsMonitoringWheelEvents(page-&gt;isMonitoringWheelEvents());</span>
189 }
190 
191 void AsyncScrollingCoordinator::frameViewEventTrackingRegionsChanged(FrameView&amp; frameView)
192 {
193     if (!m_scrollingStateTree-&gt;rootStateNode())
194         return;
195 
196     setEventTrackingRegionsDirty();
197     DebugPageOverlays::didChangeEventHandlers(frameView.frame());
198 }
199 
200 void AsyncScrollingCoordinator::frameViewRootLayerDidChange(FrameView&amp; frameView)
201 {
202     ASSERT(isMainThread());
203     ASSERT(m_page);
204 
205     if (!coordinatesScrollingForFrameView(frameView))
206         return;
207 
208     // FIXME: In some navigation scenarios, the FrameView has no RenderView or that RenderView has not been composited.
</pre>
<hr />
<pre>
213     // If the root layer does not have a ScrollingStateNode, then we should create one.
214     ensureRootStateNodeForFrameView(frameView);
215     ASSERT(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
216 
217     ScrollingCoordinator::frameViewRootLayerDidChange(frameView);
218 
219     auto* node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()));
220     node-&gt;setScrollContainerLayer(scrollContainerLayerForFrameView(frameView));
221     node-&gt;setScrolledContentsLayer(scrolledContentsLayerForFrameView(frameView));
222     node-&gt;setRootContentsLayer(rootContentsLayerForFrameView(frameView));
223     node-&gt;setCounterScrollingLayer(counterScrollingLayerForFrameView(frameView));
224     node-&gt;setInsetClipLayer(insetClipLayerForFrameView(frameView));
225     node-&gt;setContentShadowLayer(contentShadowLayerForFrameView(frameView));
226     node-&gt;setHeaderLayer(headerLayerForFrameView(frameView));
227     node-&gt;setFooterLayer(footerLayerForFrameView(frameView));
228     node-&gt;setScrollBehaviorForFixedElements(frameView.scrollBehaviorForFixedElements());
229     node-&gt;setVerticalScrollbarLayer(frameView.layerForVerticalScrollbar());
230     node-&gt;setHorizontalScrollbarLayer(frameView.layerForHorizontalScrollbar());
231 }
232 
<span class="line-modified">233 bool AsyncScrollingCoordinator::requestScrollPositionUpdate(ScrollableArea&amp; scrollableArea, const IntPoint&amp; scrollPosition, ScrollType scrollType, ScrollClamping clamping)</span>
234 {
235     ASSERT(isMainThread());
236     ASSERT(m_page);
237 
238     auto scrollingNodeID = scrollableArea.scrollingNodeID();
239     if (!scrollingNodeID)
240         return false;
241 
242     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
243     if (!frameView)
244         return false;
245 
246     if (!coordinatesScrollingForFrameView(*frameView))
247         return false;
248 
<span class="line-modified">249     bool inBackForwardCache = frameView-&gt;frame().document()-&gt;backForwardCacheState() != Document::NotInBackForwardCache;</span>
250     bool inProgrammaticScroll = scrollableArea.currentScrollType() == ScrollType::Programmatic;
<span class="line-modified">251     if (inProgrammaticScroll || inBackForwardCache)</span>
252         updateScrollPositionAfterAsyncScroll(scrollingNodeID, scrollPosition, { }, ScrollType::Programmatic, ScrollingLayerPositionAction::Set);
253 
<span class="line-modified">254     ASSERT(inProgrammaticScroll == (scrollType == ScrollType::Programmatic));</span>
<span class="line-added">255 </span>
<span class="line-added">256     // If this frame view&#39;s document is being put into the back/forward cache, we don&#39;t want to update our</span>
257     // main frame scroll position. Just let the FrameView think that we did.
<span class="line-modified">258     if (inBackForwardCache)</span>
259         return true;
260 
261     auto* stateNode = downcast&lt;ScrollingStateScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(scrollingNodeID));
262     if (!stateNode)
263         return false;
264 
<span class="line-modified">265     stateNode-&gt;setRequestedScrollData({ scrollPosition, scrollType, clamping });</span>
266     return true;
267 }
268 
269 void AsyncScrollingCoordinator::applyScrollingTreeLayerPositions()
270 {
271     m_scrollingTree-&gt;applyLayerPositions();
272 }
273 
274 void AsyncScrollingCoordinator::scheduleUpdateScrollPositionAfterAsyncScroll(ScrollingNodeID nodeID, const FloatPoint&amp; scrollPosition, const Optional&lt;FloatPoint&gt;&amp; layoutViewportOrigin, ScrollingLayerPositionAction scrollingLayerPositionAction)
275 {
276     ScheduledScrollUpdate scrollUpdate(nodeID, scrollPosition, layoutViewportOrigin, scrollingLayerPositionAction);
277 
278     if (m_updateNodeScrollPositionTimer.isActive()) {
279         if (m_scheduledScrollUpdate.matchesUpdateType(scrollUpdate)) {
280             m_scheduledScrollUpdate.scrollPosition = scrollPosition;
281             m_scheduledScrollUpdate.layoutViewportOrigin = layoutViewportOrigin;
282             return;
283         }
284 
285         // If the parameters don&#39;t match what was previously scheduled, dispatch immediately.
</pre>
<hr />
<pre>
328     }
329 
330     return nullptr;
331 }
332 
333 void AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll(ScrollingNodeID scrollingNodeID, const FloatPoint&amp; scrollPosition, Optional&lt;FloatPoint&gt; layoutViewportOrigin, ScrollType scrollType, ScrollingLayerPositionAction scrollingLayerPositionAction)
334 {
335     ASSERT(isMainThread());
336 
337     if (!m_page)
338         return;
339 
340     auto* frameViewPtr = frameViewForScrollingNode(scrollingNodeID);
341     if (!frameViewPtr)
342         return;
343 
344     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;AsyncScrollingCoordinator::updateScrollPositionAfterAsyncScroll node &quot; &lt;&lt; scrollingNodeID &lt;&lt; &quot; scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; action &quot; &lt;&lt; scrollingLayerPositionAction);
345 
346     auto&amp; frameView = *frameViewPtr;
347 
<span class="line-added">348     if (!frameViewPtr-&gt;frame().isMainFrame()) {</span>
<span class="line-added">349         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)</span>
<span class="line-added">350             m_page-&gt;editorClient().subFrameScrollPositionChanged();</span>
<span class="line-added">351     }</span>
<span class="line-added">352 </span>
353     if (scrollingNodeID == frameView.scrollingNodeID()) {
354         reconcileScrollingState(frameView, scrollPosition, layoutViewportOrigin, scrollType, ViewportRectStability::Stable, scrollingLayerPositionAction);









355         return;
356     }
357 
358     // Overflow-scroll area.
359     if (auto* scrollableArea = frameView.scrollableAreaForScrollLayerID(scrollingNodeID)) {
360         auto previousScrollType = scrollableArea-&gt;currentScrollType();
361         scrollableArea-&gt;setCurrentScrollType(scrollType);
<span class="line-modified">362         scrollableArea-&gt;notifyScrollPositionChanged(roundedIntPoint(scrollPosition));</span>
363         scrollableArea-&gt;setCurrentScrollType(previousScrollType);
364 
365         if (scrollingLayerPositionAction == ScrollingLayerPositionAction::Set)
366             m_page-&gt;editorClient().overflowScrollPositionChanged();








367     }
368 }
369 
370 void AsyncScrollingCoordinator::reconcileScrollingState(FrameView&amp; frameView, const FloatPoint&amp; scrollPosition, const LayoutViewportOriginOrOverrideRect&amp; layoutViewportOriginOrOverrideRect, ScrollType scrollType, ViewportRectStability viewportRectStability, ScrollingLayerPositionAction scrollingLayerPositionAction)
371 {
372     auto previousScrollType = frameView.currentScrollType();
373     frameView.setCurrentScrollType(scrollType);
374 
375     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; getCurrentProcessID() &lt;&lt; &quot; AsyncScrollingCoordinator &quot; &lt;&lt; this &lt;&lt; &quot; reconcileScrollingState scrollPosition &quot; &lt;&lt; scrollPosition &lt;&lt; &quot; type &quot; &lt;&lt; scrollType &lt;&lt; &quot; stability &quot; &lt;&lt; viewportRectStability &lt;&lt; &quot; &quot; &lt;&lt; scrollingLayerPositionAction);
376 
377     Optional&lt;FloatRect&gt; layoutViewportRect;
378 
379     WTF::switchOn(layoutViewportOriginOrOverrideRect,
380         [&amp;frameView](Optional&lt;FloatPoint&gt; origin) {
381             if (origin)
382                 frameView.setBaseLayoutViewportOrigin(LayoutPoint(origin.value()), FrameView::TriggerLayoutOrNot::No);
383         }, [&amp;frameView, &amp;layoutViewportRect, viewportRectStability](Optional&lt;FloatRect&gt; overrideRect) {
384             if (!overrideRect)
385                 return;
386 
</pre>
<hr />
<pre>
822     if (!m_page)
823         return;
824 
825     auto* frameView = frameViewForScrollingNode(scrollingNodeID);
826     if (!frameView)
827         return;
828 
829     if (scrollingNodeID == frameView-&gt;scrollingNodeID()) {
830         frameView-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
831         frameView-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
832         return;
833     }
834 
835     // Overflow-scroll area.
836     if (auto* scrollableArea = frameView-&gt;scrollableAreaForScrollLayerID(scrollingNodeID)) {
837         scrollableArea-&gt;setCurrentHorizontalSnapPointIndex(horizontalIndex);
838         scrollableArea-&gt;setCurrentVerticalSnapPointIndex(verticalIndex);
839     }
840 }
841 
<span class="line-modified">842 void AsyncScrollingCoordinator::deferWheelEventTestCompletionForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
843 {
844     ASSERT(isMainThread());
<span class="line-modified">845     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
846         return;
847 
<span class="line-modified">848     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">849         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::deferForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">850         trigger-&gt;deferForReason(identifier, reason);</span>
851     }
852 }
853 
<span class="line-modified">854 void AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason(WheelEventTestMonitor::ScrollableAreaIdentifier identifier, WheelEventTestMonitor::DeferReason reason) const</span>
855 {
856     ASSERT(isMainThread());
<span class="line-modified">857     if (!m_page || !m_page-&gt;isMonitoringWheelEvents())</span>
858         return;
859 
<span class="line-modified">860     if (const auto&amp; trigger = m_page-&gt;wheelEventTestMonitor()) {</span>
<span class="line-modified">861         LOG_WITH_STREAM(WheelEventTestMonitor, stream &lt;&lt; &quot;    (!) AsyncScrollingCoordinator::removeWheelEventTestCompletionDeferralForReason: Deferring &quot; &lt;&lt; identifier &lt;&lt; &quot; for reason &quot; &lt;&lt; reason);</span>
<span class="line-modified">862         trigger-&gt;removeDeferralForReason(identifier, reason);</span>
863     }
864 }
865 #endif
866 
867 #if ENABLE(CSS_SCROLL_SNAP)
868 bool AsyncScrollingCoordinator::isScrollSnapInProgress() const
869 {
870     return scrollingTree()-&gt;isScrollSnapInProgress();
871 }
872 
873 void AsyncScrollingCoordinator::updateScrollSnapPropertiesWithFrameView(const FrameView&amp; frameView)
874 {
875     if (auto node = downcast&lt;ScrollingStateFrameScrollingNode&gt;(m_scrollingStateTree-&gt;stateNodeForID(frameView.scrollingNodeID()))) {
876         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Horizontal, frameView.horizontalSnapOffsets(), frameView.horizontalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
877         setStateScrollingNodeSnapOffsetsAsFloat(*node, ScrollEventAxis::Vertical, frameView.verticalSnapOffsets(), frameView.verticalSnapOffsetRanges(), m_page-&gt;deviceScaleFactor());
878         node-&gt;setCurrentHorizontalSnapPointIndex(frameView.currentHorizontalSnapPointIndex());
879         node-&gt;setCurrentVerticalSnapPointIndex(frameView.currentVerticalSnapPointIndex());
880     }
881 }
882 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../linux/ResourceUsageOverlayLinux.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AsyncScrollingCoordinator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
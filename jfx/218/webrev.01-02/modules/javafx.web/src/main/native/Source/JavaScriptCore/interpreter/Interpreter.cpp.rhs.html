<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Interpreter.h&quot;
  32 
  33 #include &quot;BatchedTransitionOptimizer.h&quot;
  34 #include &quot;Bytecodes.h&quot;
  35 #include &quot;CallFrameClosure.h&quot;
  36 #include &quot;CatchScope.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  37 #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  38 #include &quot;CodeBlock.h&quot;
  39 #include &quot;CodeCache.h&quot;
  40 #include &quot;DirectArguments.h&quot;
  41 #include &quot;ExecutableBaseInlines.h&quot;
  42 #include &quot;Heap.h&quot;
  43 #include &quot;Debugger.h&quot;
  44 #include &quot;DebuggerCallFrame.h&quot;
  45 #include &quot;DirectEvalCodeCache.h&quot;
  46 #include &quot;ErrorInstance.h&quot;
  47 #include &quot;EvalCodeBlock.h&quot;
  48 #include &quot;Exception.h&quot;
  49 #include &quot;ExceptionHelpers.h&quot;
  50 #include &quot;FrameTracers.h&quot;
  51 #include &quot;FunctionCodeBlock.h&quot;
  52 #include &quot;InterpreterInlines.h&quot;
  53 #include &quot;JITCodeInlines.h&quot;
  54 #include &quot;JSArrayInlines.h&quot;
  55 #include &quot;JSBoundFunction.h&quot;
  56 #include &quot;JSCInlines.h&quot;
<a name="2" id="anc2"></a>
  57 #include &quot;JSImmutableButterfly.h&quot;
  58 #include &quot;JSLexicalEnvironment.h&quot;
  59 #include &quot;JSModuleEnvironment.h&quot;
  60 #include &quot;JSString.h&quot;
  61 #include &quot;JSWithScope.h&quot;
  62 #include &quot;LLIntCLoop.h&quot;
  63 #include &quot;LLIntThunks.h&quot;
  64 #include &quot;LiteralParser.h&quot;
  65 #include &quot;ModuleProgramCodeBlock.h&quot;
  66 #include &quot;ObjectPrototype.h&quot;
  67 #include &quot;Parser.h&quot;
  68 #include &quot;ProgramCodeBlock.h&quot;
<a name="3" id="anc3"></a><span class="line-modified">  69 #include &quot;ProtoCallFrameInlines.h&quot;</span>
  70 #include &quot;RegExpObject.h&quot;
  71 #include &quot;Register.h&quot;
  72 #include &quot;RegisterAtOffsetList.h&quot;
  73 #include &quot;ScopedArguments.h&quot;
  74 #include &quot;StackAlignment.h&quot;
  75 #include &quot;StackFrame.h&quot;
  76 #include &quot;StackVisitor.h&quot;
  77 #include &quot;StrictEvalActivation.h&quot;
  78 #include &quot;StrongInlines.h&quot;
  79 #include &quot;Symbol.h&quot;
  80 #include &quot;VMEntryScope.h&quot;
  81 #include &quot;VMInlines.h&quot;
  82 #include &quot;VMInspector.h&quot;
  83 #include &quot;VirtualRegister.h&quot;
  84 #include &lt;limits.h&gt;
  85 #include &lt;stdio.h&gt;
  86 #include &lt;wtf/NeverDestroyed.h&gt;
  87 #include &lt;wtf/StackStats.h&gt;
  88 #include &lt;wtf/StdLibExtras.h&gt;
  89 #include &lt;wtf/StringPrintStream.h&gt;
  90 #include &lt;wtf/Threading.h&gt;
  91 #include &lt;wtf/text/StringBuilder.h&gt;
  92 
  93 #if ENABLE(JIT)
  94 #include &quot;JIT.h&quot;
  95 #endif
  96 
  97 #if ENABLE(WEBASSEMBLY)
  98 #include &quot;WasmContextInlines.h&quot;
  99 #include &quot;WebAssemblyFunction.h&quot;
 100 #endif
 101 
 102 namespace JSC {
 103 
<a name="4" id="anc4"></a><span class="line-modified"> 104 JSValue eval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 105 {
<a name="5" id="anc5"></a><span class="line-modified"> 106     VM&amp; vm = globalObject-&gt;vm();</span>
 107     auto scope = DECLARE_THROW_SCOPE(vm);
 108 
 109     if (!callFrame-&gt;argumentCount())
 110         return jsUndefined();
 111 
 112     JSValue program = callFrame-&gt;argument(0);
 113     if (!program.isString())
 114         return program;
 115 
 116     TopCallFrameSetter topCallFrame(vm, callFrame);
<a name="6" id="anc6"></a>
 117     if (!globalObject-&gt;evalEnabled()) {
<a name="7" id="anc7"></a><span class="line-modified"> 118         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
 119         return jsUndefined();
 120     }
<a name="8" id="anc8"></a><span class="line-modified"> 121     String programSource = asString(program)-&gt;value(globalObject);</span>
 122     RETURN_IF_EXCEPTION(scope, JSValue());
 123 
 124     CallFrame* callerFrame = callFrame-&gt;callerFrame();
 125     CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
 126     CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<a name="9" id="anc9"></a><span class="line-modified"> 127     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister()).Register::scope();</span>
 128     UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
 129 
 130     bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
 131 
 132     DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
 133     if (!isArrowFunctionContext &amp;&amp; callerUnlinkedCodeBlock-&gt;isClassContext()) {
 134         derivedContextType = callerUnlinkedCodeBlock-&gt;isConstructor()
 135             ? DerivedContextType::DerivedConstructorContext
 136             : DerivedContextType::DerivedMethodContext;
 137     }
 138 
 139     EvalContextType evalContextType;
<a name="10" id="anc10"></a><span class="line-modified"> 140     if (callerUnlinkedCodeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode)</span>
<span class="line-added"> 141         evalContextType = EvalContextType::InstanceFieldEvalContext;</span>
<span class="line-added"> 142     else if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))</span>
 143         evalContextType = EvalContextType::FunctionEvalContext;
 144     else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
 145         evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
 146     else
 147         evalContextType = EvalContextType::None;
 148 
 149     DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
 150     if (!eval) {
 151         if (!callerCodeBlock-&gt;isStrictMode()) {
 152             if (programSource.is8Bit()) {
<a name="11" id="anc11"></a><span class="line-modified"> 153                 LiteralParser&lt;LChar&gt; preparser(globalObject, programSource.characters8(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
 154                 if (JSValue parsedObject = preparser.tryLiteralParse())
 155                     RELEASE_AND_RETURN(scope, parsedObject);
 156 
 157             } else {
<a name="12" id="anc12"></a><span class="line-modified"> 158                 LiteralParser&lt;UChar&gt; preparser(globalObject, programSource.characters16(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
 159                 if (JSValue parsedObject = preparser.tryLiteralParse())
 160                     RELEASE_AND_RETURN(scope, parsedObject);
 161 
 162             }
 163             RETURN_IF_EXCEPTION(scope, JSValue());
 164         }
 165 
 166         VariableEnvironment variablesUnderTDZ;
 167         JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
<a name="13" id="anc13"></a><span class="line-modified"> 168         eval = DirectEvalExecutable::create(globalObject, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, callerUnlinkedCodeBlock-&gt;needsClassFieldInitializer(), isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);</span>
 169         EXCEPTION_ASSERT(!!scope.exception() == !eval);
 170         if (!eval)
 171             return jsUndefined();
 172 
<a name="14" id="anc14"></a><span class="line-modified"> 173         callerCodeBlock-&gt;directEvalCodeCache().set(globalObject, callerCodeBlock, programSource, callerCallSiteIndex, eval);</span>
 174     }
 175 
 176     JSValue thisValue = callerFrame-&gt;thisValue();
 177     Interpreter* interpreter = vm.interpreter;
<a name="15" id="anc15"></a><span class="line-modified"> 178     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, globalObject, thisValue, callerScopeChain));</span>
 179 }
 180 
<a name="16" id="anc16"></a><span class="line-modified"> 181 unsigned sizeOfVarargs(JSGlobalObject* globalObject, JSValue arguments, uint32_t firstVarArgOffset)</span>
 182 {
<a name="17" id="anc17"></a><span class="line-modified"> 183     VM&amp; vm = globalObject-&gt;vm();</span>
 184     auto scope = DECLARE_THROW_SCOPE(vm);
 185 
 186     if (UNLIKELY(!arguments.isCell())) {
 187         if (arguments.isUndefinedOrNull())
 188             return 0;
 189 
<a name="18" id="anc18"></a><span class="line-modified"> 190         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject, arguments));</span>
 191         return 0;
 192     }
 193 
 194     JSCell* cell = arguments.asCell();
 195     unsigned length;
 196     switch (cell-&gt;type()) {
 197     case DirectArgumentsType:
<a name="19" id="anc19"></a><span class="line-modified"> 198         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(globalObject);</span>
 199         break;
 200     case ScopedArgumentsType:
<a name="20" id="anc20"></a><span class="line-modified"> 201         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(globalObject);</span>



 202         break;
 203     case JSImmutableButterflyType:
 204         length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
 205         break;
 206     case StringType:
 207     case SymbolType:
 208     case BigIntType:
<a name="21" id="anc21"></a><span class="line-modified"> 209         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject,  arguments));</span>
 210         return 0;
 211 
 212     default:
 213         RELEASE_ASSERT(arguments.isObject());
<a name="22" id="anc22"></a><span class="line-modified"> 214         length = clampToUnsigned(toLength(globalObject, jsCast&lt;JSObject*&gt;(cell)));</span>
 215         break;
 216     }
 217     RETURN_IF_EXCEPTION(scope, 0);
 218 
<a name="23" id="anc23"></a><span class="line-added"> 219     if (length &gt; maxArguments)</span>
<span class="line-added"> 220         throwStackOverflowError(globalObject, scope);</span>
<span class="line-added"> 221 </span>
 222     if (length &gt;= firstVarArgOffset)
 223         length -= firstVarArgOffset;
 224     else
 225         length = 0;
 226 
 227     return length;
 228 }
 229 
<a name="24" id="anc24"></a><span class="line-modified"> 230 unsigned sizeFrameForForwardArguments(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)</span>
 231 {
 232     auto scope = DECLARE_THROW_SCOPE(vm);
 233 
 234     unsigned length = callFrame-&gt;argumentCount();
 235     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 236     if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
<a name="25" id="anc25"></a><span class="line-modified"> 237         throwStackOverflowError(globalObject, scope);</span>
 238 
 239     return length;
 240 }
 241 
<a name="26" id="anc26"></a><span class="line-modified"> 242 unsigned sizeFrameForVarargs(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)</span>
 243 {
 244     auto scope = DECLARE_THROW_SCOPE(vm);
 245 
<a name="27" id="anc27"></a><span class="line-modified"> 246     unsigned length = sizeOfVarargs(globalObject, arguments, firstVarArgOffset);</span>
 247     RETURN_IF_EXCEPTION(scope, 0);
 248 
 249     CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
 250     if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
<a name="28" id="anc28"></a><span class="line-modified"> 251         throwStackOverflowError(globalObject, scope);</span>
 252         return 0;
 253     }
 254 
 255     return length;
 256 }
 257 
<a name="29" id="anc29"></a><span class="line-modified"> 258 void loadVarargs(JSGlobalObject* globalObject, JSValue* firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)</span>
 259 {
 260     if (UNLIKELY(!arguments.isCell()) || !length)
 261         return;
 262 
<a name="30" id="anc30"></a><span class="line-modified"> 263     VM&amp; vm = globalObject-&gt;vm();</span>
 264     auto scope = DECLARE_THROW_SCOPE(vm);
 265     JSCell* cell = arguments.asCell();
 266 
 267     switch (cell-&gt;type()) {
 268     case DirectArgumentsType:
 269         scope.release();
<a name="31" id="anc31"></a><span class="line-modified"> 270         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 271         return;
 272     case ScopedArgumentsType:
 273         scope.release();
<a name="32" id="anc32"></a><span class="line-modified"> 274         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>




 275         return;
 276     case JSImmutableButterflyType:
 277         scope.release();
<a name="33" id="anc33"></a><span class="line-modified"> 278         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 279         return;
 280     default: {
 281         ASSERT(arguments.isObject());
 282         JSObject* object = jsCast&lt;JSObject*&gt;(cell);
 283         if (isJSArray(object)) {
 284             scope.release();
<a name="34" id="anc34"></a><span class="line-modified"> 285             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
 286             return;
 287         }
 288         unsigned i;
 289         for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
<a name="35" id="anc35"></a><span class="line-modified"> 290             firstElementDest[i] = object-&gt;getIndexQuickly(i + offset);</span>
 291         for (; i &lt; length; ++i) {
<a name="36" id="anc36"></a><span class="line-modified"> 292             JSValue value = object-&gt;get(globalObject, i + offset);</span>
 293             RETURN_IF_EXCEPTION(scope, void());
<a name="37" id="anc37"></a><span class="line-modified"> 294             firstElementDest[i] = value;</span>
 295         }
 296         return;
 297     } }
 298 }
 299 
<a name="38" id="anc38"></a><span class="line-modified"> 300 void setupVarargsFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)</span>
 301 {
 302     VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
 303 
 304     loadVarargs(
<a name="39" id="anc39"></a><span class="line-modified"> 305         globalObject,</span>
<span class="line-modified"> 306         bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(calleeFrameOffset + CallFrame::argumentOffset(0))),</span>
 307         arguments, offset, length);
 308 
 309     newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
 310 }
 311 
<a name="40" id="anc40"></a><span class="line-modified"> 312 void setupVarargsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)</span>
 313 {
<a name="41" id="anc41"></a><span class="line-modified"> 314     setupVarargsFrame(globalObject, callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
 315     newCallFrame-&gt;setThisValue(thisValue);
 316 }
 317 
<a name="42" id="anc42"></a><span class="line-modified"> 318 void setupForwardArgumentsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, uint32_t length)</span>
 319 {
 320     ASSERT(length == execCaller-&gt;argumentCount());
 321     unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
 322     memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
 323     execCallee-&gt;setArgumentCountIncludingThis(length + 1);
 324 }
 325 
<a name="43" id="anc43"></a><span class="line-modified"> 326 void setupForwardArgumentsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)</span>
 327 {
<a name="44" id="anc44"></a><span class="line-modified"> 328     setupForwardArgumentsFrame(globalObject, execCaller, execCallee, length);</span>
 329     execCallee-&gt;setThisValue(thisValue);
 330 }
 331 
 332 
 333 
 334 Interpreter::Interpreter(VM&amp; vm)
 335     : m_vm(vm)
 336 #if ENABLE(C_LOOP)
 337     , m_cloopStack(vm)
 338 #endif
 339 {
<a name="45" id="anc45"></a><span class="line-modified"> 340 #if ASSERT_ENABLED</span>
 341     static std::once_flag assertOnceKey;
 342     std::call_once(assertOnceKey, [] {
 343         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
 344             OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
 345             RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
 346         }
 347     });
<a name="46" id="anc46"></a><span class="line-modified"> 348 #endif // ASSERT_ENABLED</span>
 349 }
 350 
 351 Interpreter::~Interpreter()
 352 {
 353 }
 354 
 355 #if ENABLE(COMPUTED_GOTO_OPCODES)
<a name="47" id="anc47"></a><span class="line-modified"> 356 #if !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
 357 HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
 358 {
 359     static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
 360 
 361     static std::once_flag initializeKey;
 362     std::call_once(initializeKey, [&amp;] {
 363         const Opcode* opcodeTable = LLInt::opcodeMap();
 364         for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i)
 365             opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
 366     });
 367 
 368     return opcodeIDTable;
 369 }
<a name="48" id="anc48"></a><span class="line-modified"> 370 #endif // !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
 371 #endif // ENABLE(COMPUTED_GOTO_OPCODES)
 372 
<a name="49" id="anc49"></a><span class="line-modified"> 373 #if ASSERT_ENABLED</span>
 374 bool Interpreter::isOpcode(Opcode opcode)
 375 {
 376 #if ENABLE(COMPUTED_GOTO_OPCODES)
 377     return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
 378         &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
 379         &amp;&amp; opcodeIDTable().contains(opcode);
 380 #else
 381     return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
 382 #endif
 383 }
<a name="50" id="anc50"></a><span class="line-modified"> 384 #endif // ASSERT_ENABLED</span>
 385 
 386 class GetStackTraceFunctor {
 387 public:
 388     GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
 389         : m_vm(vm)
 390         , m_owner(owner)
 391         , m_results(results)
 392         , m_framesToSkip(framesToSkip)
 393         , m_remainingCapacityForFrameCapture(capacity)
 394     {
 395         m_results.reserveInitialCapacity(capacity);
 396     }
 397 
 398     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 399     {
 400         if (m_framesToSkip &gt; 0) {
 401             m_framesToSkip--;
 402             return StackVisitor::Continue;
 403         }
 404 
 405         if (m_remainingCapacityForFrameCapture) {
 406             if (visitor-&gt;isWasmFrame()) {
 407                 m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
 408             } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
 409                 m_results.append(
<a name="51" id="anc51"></a><span class="line-modified"> 410                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeIndex()));</span>
 411             } else {
 412                 m_results.append(
 413                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
 414             }
 415 
 416             m_remainingCapacityForFrameCapture--;
 417             return StackVisitor::Continue;
 418         }
 419         return StackVisitor::Done;
 420     }
 421 
 422 private:
 423     VM&amp; m_vm;
 424     JSCell* m_owner;
 425     Vector&lt;StackFrame&gt;&amp; m_results;
 426     mutable size_t m_framesToSkip;
 427     mutable size_t m_remainingCapacityForFrameCapture;
 428 };
 429 
 430 void Interpreter::getStackTrace(JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t maxStackSize)
 431 {
 432     DisallowGC disallowGC;
 433     VM&amp; vm = m_vm;
 434     CallFrame* callFrame = vm.topCallFrame;
 435     if (!callFrame || !maxStackSize)
 436         return;
 437 
 438     size_t framesCount = 0;
 439     size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
<a name="52" id="anc52"></a><span class="line-modified"> 440     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {</span>
 441         if (++framesCount &lt; maxFramesCountNeeded)
 442             return StackVisitor::Continue;
 443         return StackVisitor::Done;
 444     });
 445     if (framesCount &lt;= framesToSkip)
 446         return;
 447 
 448     framesCount -= framesToSkip;
 449     framesCount = std::min(maxStackSize, framesCount);
 450 
 451     GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
<a name="53" id="anc53"></a><span class="line-modified"> 452     StackVisitor::visit(callFrame, vm, functor);</span>
 453     ASSERT(results.size() == results.capacity());
 454 }
 455 
 456 String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
 457 {
 458     // FIXME: JSStringJoiner could be more efficient than StringBuilder here.
 459     StringBuilder builder;
 460     for (unsigned i = 0; i &lt; stackTrace.size(); i++) {
 461         builder.append(String(stackTrace[i].toString(vm)));
 462         if (i != stackTrace.size() - 1)
 463             builder.append(&#39;\n&#39;);
 464     }
 465     return builder.toString();
 466 }
 467 
 468 ALWAYS_INLINE static HandlerInfo* findExceptionHandler(StackVisitor&amp; visitor, CodeBlock* codeBlock, RequiredHandler requiredHandler)
 469 {
 470     ASSERT(codeBlock);
 471 #if ENABLE(DFG_JIT)
 472     ASSERT(!visitor-&gt;isInlinedFrame());
 473 #endif
 474 
 475     CallFrame* callFrame = visitor-&gt;callFrame();
 476     unsigned exceptionHandlerIndex;
 477     if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
 478         exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
 479     else
<a name="54" id="anc54"></a><span class="line-modified"> 480         exceptionHandlerIndex = callFrame-&gt;bytecodeIndex().offset();</span>
 481 
 482     return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
 483 }
 484 
 485 class GetCatchHandlerFunctor {
 486 public:
 487     GetCatchHandlerFunctor()
 488         : m_handler(0)
 489     {
 490     }
 491 
 492     HandlerInfo* handler() { return m_handler; }
 493 
 494     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 495     {
 496         visitor.unwindToMachineCodeBlockFrame();
 497 
 498         CodeBlock* codeBlock = visitor-&gt;codeBlock();
 499         if (!codeBlock)
 500             return StackVisitor::Continue;
 501 
 502         m_handler = findExceptionHandler(visitor, codeBlock, RequiredHandler::CatchHandler);
 503         if (m_handler)
 504             return StackVisitor::Done;
 505 
 506         return StackVisitor::Continue;
 507     }
 508 
 509 private:
 510     mutable HandlerInfo* m_handler;
 511 };
 512 
 513 ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
 514 {
<a name="55" id="anc55"></a><span class="line-added"> 515     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject(vm);</span>
 516     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<a name="56" id="anc56"></a><span class="line-modified"> 517     if (Debugger* debugger = globalObject-&gt;debugger()) {</span>
 518         SuspendExceptionScope scope(&amp;vm);
 519         if (callFrame-&gt;isAnyWasmCallee()
 520             || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
 521             debugger-&gt;unwindEvent(callFrame);
 522         else
 523             debugger-&gt;didExecuteProgram(callFrame);
 524         catchScope.assertNoException();
 525     }
 526 }
 527 
 528 class UnwindFunctor {
 529 public:
 530     UnwindFunctor(VM&amp; vm, CallFrame*&amp; callFrame, bool isTermination, CodeBlock*&amp; codeBlock, HandlerInfo*&amp; handler)
 531         : m_vm(vm)
 532         , m_callFrame(callFrame)
 533         , m_isTermination(isTermination)
 534         , m_codeBlock(codeBlock)
 535         , m_handler(handler)
 536     {
 537     }
 538 
 539     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
 540     {
 541         visitor.unwindToMachineCodeBlockFrame();
 542         m_callFrame = visitor-&gt;callFrame();
 543         m_codeBlock = visitor-&gt;codeBlock();
 544 
 545         m_handler = nullptr;
<a name="57" id="anc57"></a><span class="line-modified"> 546         if (m_codeBlock) {</span>
<span class="line-modified"> 547             // FIXME: We should support exception handling in checkpoints.</span>
<span class="line-added"> 548 #if ENABLE(DFG_JIT)</span>
<span class="line-added"> 549             if (removeCodePtrTag(m_returnPC) == LLInt::getCodePtr&lt;NoPtrTag&gt;(checkpoint_osr_exit_from_inlined_call_trampoline).executableAddress())</span>
<span class="line-added"> 550                 m_codeBlock-&gt;vm().findCheckpointOSRSideState(m_callFrame);</span>
<span class="line-added"> 551 #endif</span>
<span class="line-added"> 552             if (!m_isTermination) {</span>
 553                 m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
 554                 if (m_handler)
 555                     return StackVisitor::Done;
 556             }
 557         }
 558 
 559 #if ENABLE(WEBASSEMBLY)
 560         if (visitor-&gt;callee().isCell()) {
 561             if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(m_vm, visitor-&gt;callee().asCell()))
 562                 m_vm.wasmContext.store(jsToWasmICCallee-&gt;function()-&gt;previousInstance(m_callFrame), m_vm.softStackLimit());
 563         }
 564 #endif
 565 
 566         notifyDebuggerOfUnwinding(m_vm, m_callFrame);
 567 
 568         copyCalleeSavesToEntryFrameCalleeSavesBuffer(visitor);
 569 
 570         bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
 571         if (shouldStopUnwinding)
 572             return StackVisitor::Done;
 573 
<a name="58" id="anc58"></a><span class="line-added"> 574         m_returnPC = m_callFrame-&gt;returnPC().value();</span>
 575         return StackVisitor::Continue;
 576     }
 577 
 578 private:
 579     void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
 580     {
 581 #if ENABLE(ASSEMBLER)
 582         Optional&lt;RegisterAtOffsetList&gt; currentCalleeSaves = visitor-&gt;calleeSaveRegistersForUnwinding();
 583 
 584         if (!currentCalleeSaves)
 585             return;
 586 
 587         RegisterAtOffsetList* allCalleeSaves = RegisterSet::vmCalleeSaveRegisterOffsets();
 588         RegisterSet dontCopyRegisters = RegisterSet::stackRegisters();
 589         CPURegister* frame = reinterpret_cast&lt;CPURegister*&gt;(m_callFrame-&gt;registers());
 590 
 591         unsigned registerCount = currentCalleeSaves-&gt;size();
 592         VMEntryRecord* record = vmEntryRecord(m_vm.topEntryFrame);
 593         for (unsigned i = 0; i &lt; registerCount; i++) {
 594             RegisterAtOffset currentEntry = currentCalleeSaves-&gt;at(i);
 595             if (dontCopyRegisters.get(currentEntry.reg()))
 596                 continue;
 597             RegisterAtOffset* calleeSavesEntry = allCalleeSaves-&gt;find(currentEntry.reg());
 598 
 599             record-&gt;calleeSaveRegistersBuffer[calleeSavesEntry-&gt;offsetAsIndex()] = *(frame + currentEntry.offsetAsIndex());
 600         }
 601 #else
 602         UNUSED_PARAM(visitor);
 603 #endif
 604     }
 605 
 606     VM&amp; m_vm;
 607     CallFrame*&amp; m_callFrame;
 608     bool m_isTermination;
 609     CodeBlock*&amp; m_codeBlock;
 610     HandlerInfo*&amp; m_handler;
<a name="59" id="anc59"></a><span class="line-added"> 611     mutable const void* m_returnPC { nullptr };</span>
 612 };
 613 
 614 NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
 615 {
 616     auto scope = DECLARE_CATCH_SCOPE(vm);
 617 
 618     ASSERT(reinterpret_cast&lt;void*&gt;(callFrame) != vm.topEntryFrame);
 619     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
 620 
 621     JSValue exceptionValue = exception-&gt;value();
 622     ASSERT(!exceptionValue.isEmpty());
 623     ASSERT(!exceptionValue.isCell() || exceptionValue.asCell());
 624     // This shouldn&#39;t be possible (hence the assertions), but we&#39;re already in the slowest of
 625     // slow cases, so let&#39;s harden against it anyway to be safe.
 626     if (exceptionValue.isEmpty() || (exceptionValue.isCell() &amp;&amp; !exceptionValue.asCell()))
 627         exceptionValue = jsNull();
 628 
 629     EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
 630 
 631     // Calculate an exception handler vPC, unwinding call frames as necessary.
 632     HandlerInfo* handler = nullptr;
 633     UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
<a name="60" id="anc60"></a><span class="line-modified"> 634     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, vm, functor);</span>
 635     if (!handler)
 636         return nullptr;
 637 
 638     return handler;
 639 }
 640 
<a name="61" id="anc61"></a><span class="line-modified"> 641 void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, Exception* exception)</span>
 642 {
<a name="62" id="anc62"></a><span class="line-modified"> 643     Debugger* debugger = globalObject-&gt;debugger();</span>
 644     if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
 645         // This code assumes that if the debugger is enabled then there is no inlining.
 646         // If that assumption turns out to be false then we&#39;ll ignore the inlined call
 647         // frames.
 648         // https://bugs.webkit.org/show_bug.cgi?id=121754
 649 
 650         bool hasCatchHandler;
 651         bool isTermination = isTerminatedExecutionException(vm, exception);
 652         if (isTermination)
 653             hasCatchHandler = false;
 654         else {
 655             GetCatchHandlerFunctor functor;
<a name="63" id="anc63"></a><span class="line-modified"> 656             StackVisitor::visit(callFrame, vm, functor);</span>
 657             HandlerInfo* handler = functor.handler();
 658             ASSERT(!handler || handler-&gt;isCatchHandler());
 659             hasCatchHandler = !!handler;
 660         }
 661 
<a name="64" id="anc64"></a><span class="line-modified"> 662         debugger-&gt;exception(globalObject, callFrame, exception-&gt;value(), hasCatchHandler);</span>
 663     }
 664     exception-&gt;setDidNotifyInspectorOfThrow();
 665 }
 666 
<a name="65" id="anc65"></a><span class="line-modified"> 667 JSValue Interpreter::executeProgram(const SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span>
 668 {
 669     JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
 670     VM&amp; vm = scope-&gt;vm();
 671     auto throwScope = DECLARE_THROW_SCOPE(vm);
<a name="66" id="anc66"></a><span class="line-added"> 672     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added"> 673     JSCallee* globalCallee = globalObject-&gt;globalCallee();</span>
 674 
<a name="67" id="anc67"></a><span class="line-modified"> 675     ProgramExecutable* program = ProgramExecutable::create(globalObject, source);</span>
 676     EXCEPTION_ASSERT(throwScope.exception() || program);
 677     RETURN_IF_EXCEPTION(throwScope, { });
 678 
 679     throwScope.assertNoException();
 680     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 681     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
 682     if (vm.isCollectorBusyOnCurrentThread())
 683         return jsNull();
 684 
 685     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<a name="68" id="anc68"></a><span class="line-modified"> 686         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
 687 
 688     // First check if the &quot;program&quot; is actually just a JSON object. If so,
 689     // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
 690     // below at failedJSONP.
 691 
<a name="69" id="anc69"></a>
 692     Vector&lt;JSONPData&gt; JSONPData;
 693     bool parseResult;
 694     StringView programSource = program-&gt;source().view();
 695     if (programSource.isNull())
 696         return jsUndefined();
 697     if (programSource.is8Bit()) {
<a name="70" id="anc70"></a><span class="line-modified"> 698         LiteralParser&lt;LChar&gt; literalParser(globalObject, programSource.characters8(), programSource.length(), JSONP);</span>
 699         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 700     } else {
<a name="71" id="anc71"></a><span class="line-modified"> 701         LiteralParser&lt;UChar&gt; literalParser(globalObject, programSource.characters16(), programSource.length(), JSONP);</span>
 702         parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
 703     }
 704 
 705     RETURN_IF_EXCEPTION(throwScope, { });
 706     if (parseResult) {
 707         JSValue result;
 708         for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
 709             Vector&lt;JSONPPathEntry&gt; JSONPPath;
 710             JSONPPath.swap(JSONPData[entry].m_path);
 711             JSValue JSONPValue = JSONPData[entry].m_value.get();
 712             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
<a name="72" id="anc72"></a><span class="line-modified"> 713                 globalObject-&gt;addVar(globalObject, JSONPPath[0].m_pathEntryName);</span>
 714                 RETURN_IF_EXCEPTION(throwScope, { });
 715                 PutPropertySlot slot(globalObject);
<a name="73" id="anc73"></a><span class="line-modified"> 716                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, globalObject, JSONPPath[0].m_pathEntryName, JSONPValue, slot);</span>
 717                 RETURN_IF_EXCEPTION(throwScope, { });
 718                 result = jsUndefined();
 719                 continue;
 720             }
 721             JSValue baseObject(globalObject);
 722             for (unsigned i = 0; i &lt; JSONPPath.size() - 1; i++) {
 723                 ASSERT(JSONPPath[i].m_type != JSONPPathEntryTypeDeclareVar);
 724                 switch (JSONPPath[i].m_type) {
 725                 case JSONPPathEntryTypeDot: {
 726                     if (i == 0) {
 727                         RELEASE_ASSERT(baseObject == globalObject);
 728 
 729                         auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
 730                             PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<a name="74" id="anc74"></a><span class="line-modified"> 731                             if (scope-&gt;getPropertySlot(globalObject, JSONPPath[i].m_pathEntryName, slot))</span>
<span class="line-modified"> 732                                 return slot.getValue(globalObject, JSONPPath[i].m_pathEntryName);</span>
 733                             return JSValue();
 734                         };
 735 
 736                         JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
 737                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 738                         if (result) {
 739                             baseObject = result;
 740                             continue;
 741                         }
 742 
 743                         result = doGet(globalObject);
 744                         RETURN_IF_EXCEPTION(throwScope, JSValue());
 745                         if (result) {
 746                             baseObject = result;
 747                             continue;
 748                         }
 749 
 750                         if (entry)
<a name="75" id="anc75"></a><span class="line-modified"> 751                             return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, JSONPPath[i].m_pathEntryName));</span>
 752                         goto failedJSONP;
 753                     }
 754 
<a name="76" id="anc76"></a><span class="line-modified"> 755                     baseObject = baseObject.get(globalObject, JSONPPath[i].m_pathEntryName);</span>
 756                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 757                     continue;
 758                 }
 759                 case JSONPPathEntryTypeLookup: {
<a name="77" id="anc77"></a><span class="line-modified"> 760                     baseObject = baseObject.get(globalObject, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));</span>
 761                     RETURN_IF_EXCEPTION(throwScope, JSValue());
 762                     continue;
 763                 }
 764                 default:
 765                     RELEASE_ASSERT_NOT_REACHED();
 766                     return jsUndefined();
 767                 }
 768             }
 769 
 770             if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
 771                 RELEASE_ASSERT(baseObject == globalObject);
 772                 JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
<a name="78" id="anc78"></a><span class="line-modified"> 773                 if (scope-&gt;hasProperty(globalObject, JSONPPath.last().m_pathEntryName))</span>
 774                     baseObject = scope;
 775                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 776             }
 777 
 778             PutPropertySlot slot(baseObject);
 779             switch (JSONPPath.last().m_type) {
 780             case JSONPPathEntryTypeCall: {
<a name="79" id="anc79"></a><span class="line-modified"> 781                 JSValue function = baseObject.get(globalObject, JSONPPath.last().m_pathEntryName);</span>
 782                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 783                 CallData callData;
 784                 CallType callType = getCallData(vm, function, callData);
 785                 if (callType == CallType::None)
<a name="80" id="anc80"></a><span class="line-modified"> 786                     return throwException(globalObject, throwScope, createNotAFunctionError(globalObject, function));</span>
 787                 MarkedArgumentBuffer jsonArg;
 788                 jsonArg.append(JSONPValue);
 789                 ASSERT(!jsonArg.hasOverflowed());
 790                 JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
<a name="81" id="anc81"></a><span class="line-modified"> 791                 JSONPValue = JSC::call(globalObject, function, callType, callData, thisValue, jsonArg);</span>
 792                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 793                 break;
 794             }
 795             case JSONPPathEntryTypeDot: {
<a name="82" id="anc82"></a><span class="line-modified"> 796                 baseObject.put(globalObject, JSONPPath.last().m_pathEntryName, JSONPValue, slot);</span>
 797                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 798                 break;
 799             }
 800             case JSONPPathEntryTypeLookup: {
<a name="83" id="anc83"></a><span class="line-modified"> 801                 baseObject.putByIndex(globalObject, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());</span>
 802                 RETURN_IF_EXCEPTION(throwScope, JSValue());
 803                 break;
 804             }
 805             default:
 806                 RELEASE_ASSERT_NOT_REACHED();
 807                 return jsUndefined();
 808             }
 809             result = JSONPValue;
 810         }
 811         return result;
 812     }
 813 failedJSONP:
 814     // If we get here, then we have already proven that the script is not a JSON
 815     // object.
 816 
 817     VMEntryScope entryScope(vm, globalObject);
 818 
 819     // Compile source to bytecode if necessary:
<a name="84" id="anc84"></a><span class="line-modified"> 820     JSObject* error = program-&gt;initializeGlobalProperties(vm, globalObject, scope);</span>
 821     EXCEPTION_ASSERT(!throwScope.exception() || !error);
 822     if (UNLIKELY(error))
<a name="85" id="anc85"></a><span class="line-modified"> 823         return checkedReturn(throwException(globalObject, throwScope, error));</span>
 824 
 825     ProgramCodeBlock* codeBlock;
 826     {
 827         CodeBlock* tempCodeBlock;
 828         Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
 829         EXCEPTION_ASSERT(throwScope.exception() == error);
 830         if (UNLIKELY(error))
 831             return checkedReturn(error);
 832         codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
 833     }
 834 
<a name="86" id="anc86"></a><span class="line-modified"> 835     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 836     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 837         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 838         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 839     }
 840 
 841     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
 842         scope-&gt;flattenDictionaryObject(vm);
 843 
 844     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
 845 
 846     ProtoCallFrame protoCallFrame;
<a name="87" id="anc87"></a><span class="line-modified"> 847     protoCallFrame.init(codeBlock, globalObject, globalCallee, thisObj, 1);</span>
 848 
 849     // Execute the code:
 850     throwScope.release();
 851     JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 852     return checkedReturn(result);
 853 }
 854 
<a name="88" id="anc88"></a><span class="line-modified"> 855 JSValue Interpreter::executeCall(JSGlobalObject* lexicalGlobalObject, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)</span>
 856 {
<a name="89" id="anc89"></a><span class="line-modified"> 857     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 858     auto throwScope = DECLARE_THROW_SCOPE(vm);
 859 
 860     throwScope.assertNoException();
 861     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 862     if (vm.isCollectorBusyOnCurrentThread())
 863         return jsNull();
 864 
 865     bool isJSCall = (callType == CallType::JS);
 866     JSScope* scope = nullptr;
 867     CodeBlock* newCodeBlock;
 868     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 869 
 870     JSGlobalObject* globalObject;
 871 
 872     if (isJSCall) {
 873         scope = callData.js.scope;
 874         globalObject = scope-&gt;globalObject(vm);
 875     } else {
 876         ASSERT(callType == CallType::Host);
 877         globalObject = function-&gt;globalObject(vm);
 878     }
 879 
 880     VMEntryScope entryScope(vm, globalObject);
<a name="90" id="anc90"></a><span class="line-modified"> 881     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments))</span>
<span class="line-modified"> 882         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
 883 
 884     if (isJSCall) {
 885         // Compile the callee:
 886         Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
 887         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 888         if (UNLIKELY(!!compileError))
 889             return checkedReturn(compileError);
 890 
 891         ASSERT(!!newCodeBlock);
 892         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 893     } else
 894         newCodeBlock = 0;
 895 
<a name="91" id="anc91"></a><span class="line-modified"> 896     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 897     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 898         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 899         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
 900     }
 901 
 902     ProtoCallFrame protoCallFrame;
<a name="92" id="anc92"></a><span class="line-modified"> 903     protoCallFrame.init(newCodeBlock, globalObject, function, thisValue, argsCount, args.data());</span>
 904 
 905     JSValue result;
 906     {
 907         // Execute the code:
 908         if (isJSCall) {
 909             throwScope.release();
 910             result = callData.js.functionExecutable-&gt;generatedJITCodeForCall()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 911         } else {
 912             result = JSValue::decode(vmEntryToNative(callData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 913             RETURN_IF_EXCEPTION(throwScope, JSValue());
 914         }
 915     }
 916 
 917     return checkedReturn(result);
 918 }
 919 
<a name="93" id="anc93"></a><span class="line-modified"> 920 JSObject* Interpreter::executeConstruct(JSGlobalObject* lexicalGlobalObject, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)</span>
 921 {
<a name="94" id="anc94"></a><span class="line-modified"> 922     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 923     auto throwScope = DECLARE_THROW_SCOPE(vm);
 924 
 925     throwScope.assertNoException();
 926     ASSERT(!vm.isCollectorBusyOnCurrentThread());
 927     // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
 928     // already in an invalid state.
 929     if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
<a name="95" id="anc95"></a><span class="line-modified"> 930         throwStackOverflowError(lexicalGlobalObject, throwScope);</span>
 931         return nullptr;
 932     }
 933 
 934     bool isJSConstruct = (constructType == ConstructType::JS);
 935     JSScope* scope = nullptr;
 936     CodeBlock* newCodeBlock;
 937     size_t argsCount = 1 + args.size(); // implicit &quot;this&quot; parameter
 938 
 939     JSGlobalObject* globalObject;
 940 
 941     if (isJSConstruct) {
 942         scope = constructData.js.scope;
 943         globalObject = scope-&gt;globalObject(vm);
 944     } else {
 945         ASSERT(constructType == ConstructType::Host);
 946         globalObject = constructor-&gt;globalObject(vm);
 947     }
 948 
 949     VMEntryScope entryScope(vm, globalObject);
<a name="96" id="anc96"></a><span class="line-modified"> 950     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments)) {</span>
<span class="line-modified"> 951         throwStackOverflowError(globalObject, throwScope);</span>
 952         return nullptr;
 953     }
 954 
 955     if (isJSConstruct) {
 956         // Compile the callee:
 957         Exception* compileError = constructData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(constructor), scope, CodeForConstruct, newCodeBlock);
 958         EXCEPTION_ASSERT(throwScope.exception() == compileError);
 959         if (UNLIKELY(!!compileError))
 960             return nullptr;
 961 
 962         ASSERT(!!newCodeBlock);
 963         newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
 964     } else
 965         newCodeBlock = 0;
 966 
<a name="97" id="anc97"></a><span class="line-modified"> 967     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified"> 968     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified"> 969         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
 970         RETURN_IF_EXCEPTION(throwScope, nullptr);
 971     }
 972 
 973     ProtoCallFrame protoCallFrame;
<a name="98" id="anc98"></a><span class="line-modified"> 974     protoCallFrame.init(newCodeBlock, globalObject, constructor, newTarget, argsCount, args.data());</span>
 975 
 976     JSValue result;
 977     {
 978         // Execute the code.
 979         if (isJSConstruct)
 980             result = constructData.js.functionExecutable-&gt;generatedJITCodeForConstruct()-&gt;execute(&amp;vm, &amp;protoCallFrame);
 981         else {
 982             result = JSValue::decode(vmEntryToNative(constructData.native.function.rawPointer(), &amp;vm, &amp;protoCallFrame));
 983 
 984             if (LIKELY(!throwScope.exception()))
 985                 RELEASE_ASSERT(result.isObject());
 986         }
 987     }
 988 
 989     RETURN_IF_EXCEPTION(throwScope, 0);
 990     ASSERT(result.isObject());
 991     return checkedReturn(asObject(result));
 992 }
 993 
 994 CallFrameClosure Interpreter::prepareForRepeatCall(FunctionExecutable* functionExecutable, CallFrame* callFrame, ProtoCallFrame* protoCallFrame, JSFunction* function, int argumentCountIncludingThis, JSScope* scope, const ArgList&amp; args)
 995 {
 996     VM&amp; vm = scope-&gt;vm();
 997     auto throwScope = DECLARE_THROW_SCOPE(vm);
 998     throwScope.assertNoException();
 999 
1000     if (vm.isCollectorBusyOnCurrentThread())
1001         return CallFrameClosure();
1002 
1003     // Compile the callee:
1004     CodeBlock* newCodeBlock;
1005     Exception* error = functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, function, scope, CodeForCall, newCodeBlock);
1006     EXCEPTION_ASSERT(throwScope.exception() == error);
1007     if (UNLIKELY(error))
1008         return CallFrameClosure();
1009     newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
1010 
1011     size_t argsCount = argumentCountIncludingThis;
1012 
<a name="99" id="anc99"></a><span class="line-modified">1013     protoCallFrame-&gt;init(newCodeBlock, function-&gt;globalObject(), function, jsUndefined(), argsCount, args.data());</span>
1014     // Return the successful closure:
1015     CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
1016     return result;
1017 }
1018 
<a name="100" id="anc100"></a><span class="line-modified">1019 JSValue Interpreter::execute(EvalExecutable* eval, JSGlobalObject* lexicalGlobalObject, JSValue thisValue, JSScope* scope)</span>
1020 {
1021     VM&amp; vm = scope-&gt;vm();
1022     auto throwScope = DECLARE_THROW_SCOPE(vm);
1023 
<a name="101" id="anc101"></a><span class="line-modified">1024     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
1025     throwScope.assertNoException();
1026     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1027     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1028     if (vm.isCollectorBusyOnCurrentThread())
1029         return jsNull();
1030 
<a name="102" id="anc102"></a><span class="line-modified">1031     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added">1032     VMEntryScope entryScope(vm, globalObject);</span>
1033     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<a name="103" id="anc103"></a><span class="line-modified">1034         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
1035 
1036     unsigned numVariables = eval-&gt;numVariables();
1037     unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
1038     unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
1039 
1040     JSScope* variableObject;
1041     if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<a name="104" id="anc104"></a><span class="line-modified">1042         scope = StrictEvalActivation::create(vm, globalObject-&gt;strictEvalActivationStructure(), scope);</span>
1043         variableObject = scope;
1044     } else {
1045         for (JSScope* node = scope; ; node = node-&gt;next()) {
1046             RELEASE_ASSERT(node);
1047             if (node-&gt;isGlobalObject()) {
1048                 variableObject = node;
1049                 break;
1050             }
1051             if (node-&gt;isJSLexicalEnvironment()) {
1052                 JSLexicalEnvironment* lexicalEnvironment = jsCast&lt;JSLexicalEnvironment*&gt;(node);
1053                 if (lexicalEnvironment-&gt;symbolTable()-&gt;scopeType() == SymbolTable::ScopeType::VarScope) {
1054                     variableObject = node;
1055                     break;
1056                 }
1057             }
1058         }
1059     }
1060 
1061     EvalCodeBlock* codeBlock;
1062     {
1063         CodeBlock* tempCodeBlock;
1064         Exception* compileError = eval-&gt;prepareForExecution&lt;EvalExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1065         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1066         if (UNLIKELY(!!compileError))
1067             return checkedReturn(compileError);
1068         codeBlock = jsCast&lt;EvalCodeBlock*&gt;(tempCodeBlock);
1069     }
1070     UnlinkedEvalCodeBlock* unlinkedCodeBlock = codeBlock-&gt;unlinkedEvalCodeBlock();
1071 
1072     // We can&#39;t declare a &quot;var&quot;/&quot;function&quot; that overwrites a global &quot;let&quot;/&quot;const&quot;/&quot;class&quot; in a sloppy-mode eval.
1073     if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
1074         JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
1075         for (unsigned i = 0; i &lt; numVariables; ++i) {
1076             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
1077             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<a name="105" id="anc105"></a><span class="line-modified">1078             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, ident, slot)) {</span>
<span class="line-modified">1079                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));</span>
1080             }
1081         }
1082 
1083         for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1084             FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1085             PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<a name="106" id="anc106"></a><span class="line-modified">1086             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, function-&gt;name(), slot)) {</span>
<span class="line-modified">1087                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1088             }
1089         }
1090     }
1091 
1092     if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
1093         variableObject-&gt;flattenDictionaryObject(vm);
1094 
1095     if (numVariables || numTopLevelFunctionDecls || numFunctionHoistingCandidates) {
1096         BatchedTransitionOptimizer optimizer(vm, variableObject);
1097         if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
1098             variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
1099 
1100         for (unsigned i = 0; i &lt; numVariables; ++i) {
1101             const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
<a name="107" id="anc107"></a><span class="line-modified">1102             bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
1103             RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1104             if (!hasProperty) {
1105                 PutPropertySlot slot(variableObject);
<a name="108" id="anc108"></a><span class="line-modified">1106                 if (!variableObject-&gt;isExtensible(globalObject))</span>
<span class="line-modified">1107                     return checkedReturn(throwTypeError(globalObject, throwScope, NonExtensibleObjectPropertyDefineError));</span>
<span class="line-modified">1108                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
1109                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1110             }
1111         }
1112 
1113         if (eval-&gt;isStrictMode()) {
1114             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1115                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
1116                 PutPropertySlot slot(variableObject);
1117                 // We need create this variables because it will be used to emits code by bytecode generator
<a name="109" id="anc109"></a><span class="line-modified">1118                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
1119                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1120             }
1121         } else {
1122             for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
1123                 FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
<a name="110" id="anc110"></a><span class="line-modified">1124                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, function-&gt;name());</span>
1125                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1126                 if (resolvedScope.isUndefined())
<a name="111" id="anc111"></a><span class="line-modified">1127                     return checkedReturn(throwSyntaxError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
1128                 PutPropertySlot slot(variableObject);
1129                 // We need create this variables because it will be used to emits code by bytecode generator
<a name="112" id="anc112"></a><span class="line-modified">1130                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
1131                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1132             }
1133 
1134             for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
1135                 const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
<a name="113" id="anc113"></a><span class="line-modified">1136                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
1137                 RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1138                 if (!resolvedScope.isUndefined()) {
<a name="114" id="anc114"></a><span class="line-modified">1139                     bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
1140                     RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1141                     if (!hasProperty) {
1142                         PutPropertySlot slot(variableObject);
<a name="115" id="anc115"></a><span class="line-modified">1143                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
1144                         RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
1145                     }
1146                 }
1147             }
1148         }
1149     }
1150 
<a name="116" id="anc116"></a><span class="line-modified">1151     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">1152     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">1153         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
1154         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1155     }
1156 
1157     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1158 
<a name="117" id="anc117"></a><span class="line-added">1159     JSCallee* callee = nullptr;</span>
<span class="line-added">1160     if (scope == globalObject-&gt;globalScope())</span>
<span class="line-added">1161         callee = globalObject-&gt;globalCallee();</span>
<span class="line-added">1162     else</span>
<span class="line-added">1163         callee = JSCallee::create(vm, globalObject, scope);</span>
1164     ProtoCallFrame protoCallFrame;
<a name="118" id="anc118"></a><span class="line-modified">1165     protoCallFrame.init(codeBlock, globalObject, callee, thisValue, 1);</span>
1166 
1167     // Execute the code:
1168     throwScope.release();
1169     JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1170 
1171     return checkedReturn(result);
1172 }
1173 
<a name="119" id="anc119"></a><span class="line-modified">1174 JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, JSGlobalObject* lexicalGlobalObject, JSModuleEnvironment* scope)</span>
1175 {
1176     VM&amp; vm = scope-&gt;vm();
1177     auto throwScope = DECLARE_THROW_SCOPE(vm);
1178 
<a name="120" id="anc120"></a><span class="line-modified">1179     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
1180     throwScope.assertNoException();
1181     ASSERT(!vm.isCollectorBusyOnCurrentThread());
1182     RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
1183     if (vm.isCollectorBusyOnCurrentThread())
1184         return jsNull();
1185 
<a name="121" id="anc121"></a><span class="line-added">1186     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
1187     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
1188     if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<a name="122" id="anc122"></a><span class="line-modified">1189         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
1190 
1191     ModuleProgramCodeBlock* codeBlock;
1192     {
1193         CodeBlock* tempCodeBlock;
1194         Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
1195         EXCEPTION_ASSERT(throwScope.exception() == compileError);
1196         if (UNLIKELY(!!compileError))
1197             return checkedReturn(compileError);
1198         codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
1199     }
1200 
<a name="123" id="anc123"></a><span class="line-modified">1201     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">1202     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">1203         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
1204         RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
1205     }
1206 
1207     if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
1208         scope-&gt;flattenDictionaryObject(vm);
1209 
1210     ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
1211 
1212     // The |this| of the module is always `undefined`.
1213     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
1214     // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
1215     ProtoCallFrame protoCallFrame;
<a name="124" id="anc124"></a><span class="line-modified">1216     protoCallFrame.init(codeBlock, globalObject, JSCallee::create(vm, globalObject, scope), jsUndefined(), 1);</span>
1217 
1218     // Execute the code:
1219     throwScope.release();
1220     JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
1221 
1222     return checkedReturn(result);
1223 }
1224 
1225 NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
1226 {
<a name="125" id="anc125"></a><span class="line-modified">1227     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
1228     auto scope = DECLARE_CATCH_SCOPE(vm);
<a name="126" id="anc126"></a><span class="line-modified">1229     Debugger* debugger = callFrame-&gt;lexicalGlobalObject(vm)-&gt;debugger();</span>
1230     if (!debugger)
1231         return;
1232 
1233     ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
1234     scope.assertNoException();
1235 
1236     switch (debugHookType) {
1237         case DidEnterCallFrame:
1238             debugger-&gt;callEvent(callFrame);
1239             break;
1240         case WillLeaveCallFrame:
1241             debugger-&gt;returnEvent(callFrame);
1242             break;
1243         case WillExecuteStatement:
1244             debugger-&gt;atStatement(callFrame);
1245             break;
1246         case WillExecuteExpression:
1247             debugger-&gt;atExpression(callFrame);
1248             break;
1249         case WillExecuteProgram:
1250             debugger-&gt;willExecuteProgram(callFrame);
1251             break;
1252         case DidExecuteProgram:
1253             debugger-&gt;didExecuteProgram(callFrame);
1254             break;
<a name="127" id="anc127"></a><span class="line-modified">1255         case DidReachDebuggerStatement:</span>
<span class="line-modified">1256             debugger-&gt;didReachDebuggerStatement(callFrame);</span>
1257             break;
1258     }
1259     scope.assertNoException();
1260 }
1261 
1262 } // namespace JSC
1263 
1264 namespace WTF {
1265 
1266 void printInternal(PrintStream&amp; out, JSC::DebugHookType type)
1267 {
1268     switch (type) {
1269     case JSC::WillExecuteProgram:
1270         out.print(&quot;WillExecuteProgram&quot;);
1271         return;
1272     case JSC::DidExecuteProgram:
1273         out.print(&quot;DidExecuteProgram&quot;);
1274         return;
1275     case JSC::DidEnterCallFrame:
1276         out.print(&quot;DidEnterCallFrame&quot;);
1277         return;
<a name="128" id="anc128"></a><span class="line-modified">1278     case JSC::DidReachDebuggerStatement:</span>
<span class="line-modified">1279         out.print(&quot;DidReachDebuggerStatement&quot;);</span>
1280         return;
1281     case JSC::WillLeaveCallFrame:
1282         out.print(&quot;WillLeaveCallFrame&quot;);
1283         return;
1284     case JSC::WillExecuteStatement:
1285         out.print(&quot;WillExecuteStatement&quot;);
1286         return;
1287     case JSC::WillExecuteExpression:
1288         out.print(&quot;WillExecuteExpression&quot;);
1289         return;
1290     }
1291 }
1292 
1293 } // namespace WTF
<a name="129" id="anc129"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="129" type="hidden" />
</body>
</html>
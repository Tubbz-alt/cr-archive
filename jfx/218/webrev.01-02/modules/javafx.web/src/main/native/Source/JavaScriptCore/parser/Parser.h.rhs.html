<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Parser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ExecutableInfo.h&quot;
  26 #include &quot;Lexer.h&quot;
  27 #include &quot;ModuleScopeData.h&quot;
  28 #include &quot;Nodes.h&quot;
  29 #include &quot;ParseHash.h&quot;
  30 #include &quot;ParserArena.h&quot;
  31 #include &quot;ParserError.h&quot;
  32 #include &quot;ParserFunctionInfo.h&quot;
  33 #include &quot;ParserTokens.h&quot;
  34 #include &quot;SourceProvider.h&quot;
  35 #include &quot;SourceProviderCache.h&quot;
  36 #include &quot;SourceProviderCacheItem.h&quot;
  37 #include &quot;VariableEnvironment.h&quot;
  38 #include &lt;wtf/Forward.h&gt;
  39 #include &lt;wtf/Noncopyable.h&gt;
  40 #include &lt;wtf/RefPtr.h&gt;
  41 
  42 namespace JSC {
  43 
  44 class FunctionMetadataNode;
  45 class FunctionParameters;
  46 class Identifier;
  47 class VM;
  48 class SourceCode;
  49 class SyntaxChecker;
  50 struct DebuggerParseData;
  51 
  52 // Macros to make the more common TreeBuilder types a little less verbose
  53 #define TreeStatement typename TreeBuilder::Statement
  54 #define TreeExpression typename TreeBuilder::Expression
  55 #define TreeFormalParameterList typename TreeBuilder::FormalParameterList
  56 #define TreeSourceElements typename TreeBuilder::SourceElements
  57 #define TreeClause typename TreeBuilder::Clause
  58 #define TreeClauseList typename TreeBuilder::ClauseList
  59 #define TreeArguments typename TreeBuilder::Arguments
  60 #define TreeArgumentsList typename TreeBuilder::ArgumentsList
  61 #define TreeFunctionBody typename TreeBuilder::FunctionBody
  62 #define TreeClassExpression typename TreeBuilder::ClassExpression
  63 #define TreeProperty typename TreeBuilder::Property
  64 #define TreePropertyList typename TreeBuilder::PropertyList
  65 #define TreeDestructuringPattern typename TreeBuilder::DestructuringPattern
  66 
  67 COMPILE_ASSERT(LastUntaggedToken &lt; 64, LessThan64UntaggedTokens);
  68 
  69 enum SourceElementsMode { CheckForStrictMode, DontCheckForStrictMode };
  70 enum FunctionBodyType { ArrowFunctionBodyExpression, ArrowFunctionBodyBlock, StandardFunctionBodyBlock };
  71 enum class FunctionNameRequirements { None, Named, Unnamed };
  72 
  73 enum class DestructuringKind {
  74     DestructureToVariables,
  75     DestructureToLet,
  76     DestructureToConst,
  77     DestructureToCatchParameters,
  78     DestructureToParameters,
  79     DestructureToExpressions
  80 };
  81 
  82 enum class DeclarationType {
  83     VarDeclaration,
  84     LetDeclaration,
  85     ConstDeclaration
  86 };
  87 
  88 enum class DeclarationImportType {
  89     Imported,
  90     ImportedNamespace,
  91     NotImported
  92 };
  93 
  94 enum DeclarationResult {
  95     Valid = 0,
  96     InvalidStrictMode = 1 &lt;&lt; 0,
  97     InvalidDuplicateDeclaration = 1 &lt;&lt; 1
  98 };
  99 
 100 typedef uint8_t DeclarationResultMask;
 101 
 102 enum class DeclarationDefaultContext {
 103     Standard,
 104     ExportDefault,
 105 };
 106 
 107 enum class InferName {
 108     Allowed,
 109     Disallowed,
 110 };
 111 
 112 template &lt;typename T&gt; inline bool isEvalNode() { return false; }
 113 template &lt;&gt; inline bool isEvalNode&lt;EvalNode&gt;() { return true; }
 114 
 115 struct ScopeLabelInfo {
 116     UniquedStringImpl* uid;
 117     bool isLoop;
 118 };
 119 
 120 ALWAYS_INLINE static bool isArguments(const VM&amp; vm, const Identifier* ident)
 121 {
 122     return vm.propertyNames-&gt;arguments == *ident;
 123 }
 124 ALWAYS_INLINE static bool isEval(const VM&amp; vm, const Identifier* ident)
 125 {
 126     return vm.propertyNames-&gt;eval == *ident;
 127 }
 128 ALWAYS_INLINE static bool isEvalOrArgumentsIdentifier(const VM&amp; vm, const Identifier* ident)
 129 {
 130     return isEval(vm, ident) || isArguments(vm, ident);
 131 }
 132 ALWAYS_INLINE static bool isIdentifierOrKeyword(const JSToken&amp; token)
 133 {
 134     return token.m_type == IDENT || token.m_type &amp; KeywordTokenFlag;
 135 }
 136 // _Any_ContextualKeyword includes keywords such as &quot;let&quot; or &quot;yield&quot;, which have a specific meaning depending on the current parse mode
 137 // or strict mode. These helpers allow to treat all contextual keywords as identifiers as required.
 138 ALWAYS_INLINE static bool isAnyContextualKeyword(const JSToken&amp; token)
 139 {
 140     return token.m_type &gt;= FirstContextualKeywordToken &amp;&amp; token.m_type &lt;= LastContextualKeywordToken;
 141 }
 142 ALWAYS_INLINE static bool isIdentifierOrAnyContextualKeyword(const JSToken&amp; token)
 143 {
 144     return token.m_type == IDENT || isAnyContextualKeyword(token);
 145 }
 146 // _Safe_ContextualKeyword includes only contextual keywords which can be treated as identifiers independently from parse mode. The exeption
 147 // to this rule is `await`, but matchSpecIdentifier() always treats it as an identifier regardless.
 148 ALWAYS_INLINE static bool isSafeContextualKeyword(const JSToken&amp; token)
 149 {
 150     return token.m_type &gt;= FirstSafeContextualKeywordToken &amp;&amp; token.m_type &lt;= LastSafeContextualKeywordToken;
 151 }
 152 
 153 JS_EXPORT_PRIVATE extern std::atomic&lt;unsigned&gt; globalParseCount;
 154 
 155 struct Scope {
 156     WTF_MAKE_NONCOPYABLE(Scope);
 157 
 158 public:
 159     Scope(const VM&amp; vm, bool isFunction, bool isGenerator, bool strictMode, bool isArrowFunction, bool isAsyncFunction)
 160         : m_vm(vm)
 161         , m_shadowsArguments(false)
 162         , m_usesEval(false)
 163         , m_needsFullActivation(false)
 164         , m_hasDirectSuper(false)
 165         , m_needsSuperBinding(false)
 166         , m_allowsVarDeclarations(true)
 167         , m_allowsLexicalDeclarations(true)
 168         , m_strictMode(strictMode)
 169         , m_isFunction(isFunction)
 170         , m_isGenerator(isGenerator)
 171         , m_isGeneratorBoundary(false)
 172         , m_isArrowFunction(isArrowFunction)
 173         , m_isArrowFunctionBoundary(false)
 174         , m_isAsyncFunction(isAsyncFunction)
 175         , m_isAsyncFunctionBoundary(false)
 176         , m_isLexicalScope(false)
 177         , m_isGlobalCodeScope(false)
 178         , m_isSimpleCatchParameterScope(false)
 179         , m_isFunctionBoundary(false)
 180         , m_isValidStrictMode(true)
 181         , m_hasArguments(false)
 182         , m_isEvalContext(false)
 183         , m_hasNonSimpleParameterList(false)
<a name="1" id="anc1"></a><span class="line-added"> 184         , m_isClassScope(false)</span>
 185         , m_evalContextType(EvalContextType::None)
 186         , m_constructorKind(static_cast&lt;unsigned&gt;(ConstructorKind::None))
 187         , m_expectedSuperBinding(static_cast&lt;unsigned&gt;(SuperBinding::NotNeeded))
 188         , m_loopDepth(0)
 189         , m_switchDepth(0)
 190         , m_innerArrowFunctionFeatures(0)
 191     {
 192         m_usedVariables.append(UniquedStringImplPtrSet());
 193     }
 194 
 195     Scope(Scope&amp;&amp;) = default;
 196 
 197     void startSwitch() { m_switchDepth++; }
 198     void endSwitch() { m_switchDepth--; }
 199     void startLoop() { m_loopDepth++; }
 200     void endLoop() { ASSERT(m_loopDepth); m_loopDepth--; }
 201     bool inLoop() { return !!m_loopDepth; }
 202     bool breakIsValid() { return m_loopDepth || m_switchDepth; }
 203     bool continueIsValid() { return m_loopDepth; }
 204 
 205     void pushLabel(const Identifier* label, bool isLoop)
 206     {
 207         if (!m_labels)
 208             m_labels = makeUnique&lt;LabelStack&gt;();
 209         m_labels-&gt;append(ScopeLabelInfo { label-&gt;impl(), isLoop });
 210     }
 211 
 212     void popLabel()
 213     {
 214         ASSERT(m_labels);
 215         ASSERT(m_labels-&gt;size());
 216         m_labels-&gt;removeLast();
 217     }
 218 
 219     ScopeLabelInfo* getLabel(const Identifier* label)
 220     {
 221         if (!m_labels)
 222             return 0;
 223         for (int i = m_labels-&gt;size(); i &gt; 0; i--) {
 224             if (m_labels-&gt;at(i - 1).uid == label-&gt;impl())
 225                 return &amp;m_labels-&gt;at(i - 1);
 226         }
 227         return 0;
 228     }
 229 
 230     void setSourceParseMode(SourceParseMode mode)
 231     {
 232         switch (mode) {
 233         case SourceParseMode::AsyncGeneratorBodyMode:
 234             setIsAsyncGeneratorFunctionBody();
 235             break;
 236         case SourceParseMode::AsyncArrowFunctionBodyMode:
 237             setIsAsyncArrowFunctionBody();
 238             break;
 239 
 240         case SourceParseMode::AsyncFunctionBodyMode:
 241             setIsAsyncFunctionBody();
 242             break;
 243 
 244         case SourceParseMode::GeneratorBodyMode:
 245             setIsGenerator();
 246             break;
 247 
 248         case SourceParseMode::GeneratorWrapperFunctionMode:
 249         case SourceParseMode::GeneratorWrapperMethodMode:
 250             setIsGeneratorFunction();
 251             break;
 252 
 253         case SourceParseMode::AsyncGeneratorWrapperMethodMode:
 254         case SourceParseMode::AsyncGeneratorWrapperFunctionMode:
 255             setIsAsyncGeneratorFunction();
 256             break;
 257 
 258         case SourceParseMode::NormalFunctionMode:
 259         case SourceParseMode::GetterMode:
 260         case SourceParseMode::SetterMode:
 261         case SourceParseMode::MethodMode:
<a name="2" id="anc2"></a><span class="line-added"> 262         case SourceParseMode::InstanceFieldInitializerMode:</span>
 263             setIsFunction();
 264             break;
 265 
 266         case SourceParseMode::ArrowFunctionMode:
 267             setIsArrowFunction();
 268             break;
 269 
 270         case SourceParseMode::AsyncFunctionMode:
 271         case SourceParseMode::AsyncMethodMode:
 272             setIsAsyncFunction();
 273             break;
 274 
 275         case SourceParseMode::AsyncArrowFunctionMode:
 276             setIsAsyncArrowFunction();
 277             break;
 278 
 279         case SourceParseMode::ProgramMode:
 280         case SourceParseMode::ModuleAnalyzeMode:
 281         case SourceParseMode::ModuleEvaluateMode:
 282             break;
 283         }
 284     }
 285 
 286     bool isFunction() const { return m_isFunction; }
 287     bool isFunctionBoundary() const { return m_isFunctionBoundary; }
 288     bool isGenerator() const { return m_isGenerator; }
 289     bool isGeneratorBoundary() const { return m_isGeneratorBoundary; }
 290     bool isAsyncFunction() const { return m_isAsyncFunction; }
 291     bool isAsyncFunctionBoundary() const { return m_isAsyncFunctionBoundary; }
<a name="3" id="anc3"></a><span class="line-added"> 292     bool isClassScope() const { return m_isClassScope; }</span>
 293 
 294     bool hasArguments() const { return m_hasArguments; }
 295 
 296     void setIsGlobalCodeScope() { m_isGlobalCodeScope = true; }
 297     bool isGlobalCodeScope() const { return m_isGlobalCodeScope; }
 298 
 299     void setIsSimpleCatchParameterScope() { m_isSimpleCatchParameterScope = true; }
 300     bool isSimpleCatchParameterScope() { return m_isSimpleCatchParameterScope; }
 301 
 302     void setIsLexicalScope()
 303     {
 304         m_isLexicalScope = true;
 305         m_allowsLexicalDeclarations = true;
 306     }
<a name="4" id="anc4"></a><span class="line-added"> 307 </span>
<span class="line-added"> 308     void setIsClassScope()</span>
<span class="line-added"> 309     {</span>
<span class="line-added"> 310         m_isClassScope = true;</span>
<span class="line-added"> 311     }</span>
<span class="line-added"> 312 </span>
 313     bool isLexicalScope() { return m_isLexicalScope; }
 314     bool usesEval() { return m_usesEval; }
 315 
 316     const HashSet&lt;UniquedStringImpl*&gt;&amp; closedVariableCandidates() const { return m_closedVariableCandidates; }
 317     VariableEnvironment&amp; declaredVariables() { return m_declaredVariables; }
 318     VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 319     VariableEnvironment&amp; finalizeLexicalEnvironment()
 320     {
 321         if (m_usesEval || m_needsFullActivation)
 322             m_lexicalVariables.markAllVariablesAsCaptured();
 323         else
 324             computeLexicallyCapturedVariablesAndPurgeCandidates();
 325 
 326         return m_lexicalVariables;
 327     }
 328 
 329     void computeLexicallyCapturedVariablesAndPurgeCandidates()
 330     {
 331         // Because variables may be defined at any time in the range of a lexical scope, we must
 332         // track lexical variables that might be captured. Then, when we&#39;re preparing to pop the top
 333         // lexical scope off the stack, we should find which variables are truly captured, and which
 334         // variable still may be captured in a parent scope.
 335         if (m_lexicalVariables.size() &amp;&amp; m_closedVariableCandidates.size()) {
 336             for (UniquedStringImpl* impl : m_closedVariableCandidates)
 337                 m_lexicalVariables.markVariableAsCapturedIfDefined(impl);
 338         }
 339 
 340         // We can now purge values from the captured candidates because they&#39;re captured in this scope.
 341         {
<a name="5" id="anc5"></a><span class="line-modified"> 342             for (const auto&amp; entry : m_lexicalVariables) {</span>
 343                 if (entry.value.isCaptured())
 344                     m_closedVariableCandidates.remove(entry.key.get());
 345             }
 346         }
 347     }
 348 
 349     DeclarationResultMask declareCallee(const Identifier* ident)
 350     {
 351         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 352         // We want to track if callee is captured, but we don&#39;t want to act like it&#39;s a &#39;var&#39;
 353         // because that would cause the BytecodeGenerator to emit bad code.
 354         addResult.iterator-&gt;value.clearIsVar();
 355 
 356         DeclarationResultMask result = DeclarationResult::Valid;
 357         if (isEvalOrArgumentsIdentifier(m_vm, ident))
 358             result |= DeclarationResult::InvalidStrictMode;
 359         return result;
 360     }
 361 
 362     DeclarationResultMask declareVariable(const Identifier* ident)
 363     {
 364         ASSERT(m_allowsVarDeclarations);
 365         DeclarationResultMask result = DeclarationResult::Valid;
 366         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 367         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 368         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 369         addResult.iterator-&gt;value.setIsVar();
 370         if (!isValidStrictMode)
 371             result |= DeclarationResult::InvalidStrictMode;
 372         return result;
 373     }
 374 
 375     DeclarationResultMask declareFunction(const Identifier* ident, bool declareAsVar, bool isSloppyModeHoistingCandidate)
 376     {
 377         ASSERT(m_allowsVarDeclarations || m_allowsLexicalDeclarations);
 378         DeclarationResultMask result = DeclarationResult::Valid;
 379         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 380         if (!isValidStrictMode)
 381             result |= DeclarationResult::InvalidStrictMode;
 382         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 383         auto addResult = declareAsVar ? m_declaredVariables.add(ident-&gt;impl()) : m_lexicalVariables.add(ident-&gt;impl());
 384         if (isSloppyModeHoistingCandidate)
 385             addResult.iterator-&gt;value.setIsSloppyModeHoistingCandidate();
 386         if (declareAsVar) {
 387             addResult.iterator-&gt;value.setIsVar();
 388             if (m_lexicalVariables.contains(ident-&gt;impl()))
 389                 result |= DeclarationResult::InvalidDuplicateDeclaration;
 390         } else {
 391             addResult.iterator-&gt;value.setIsLet();
 392             ASSERT_WITH_MESSAGE(!m_declaredVariables.size(), &quot;We should only declare a function as a lexically scoped variable in scopes where var declarations aren&#39;t allowed. I.e, in strict mode and not at the top-level scope of a function or program.&quot;);
 393             if (!addResult.isNewEntry) {
 394                 if (!isSloppyModeHoistingCandidate || !addResult.iterator-&gt;value.isFunction())
 395                     result |= DeclarationResult::InvalidDuplicateDeclaration;
 396             }
 397         }
 398 
 399         addResult.iterator-&gt;value.setIsFunction();
 400 
 401         return result;
 402     }
 403 
 404     void addVariableBeingHoisted(const Identifier* ident)
 405     {
 406         ASSERT(!m_allowsVarDeclarations);
 407         m_variablesBeingHoisted.add(ident-&gt;impl());
 408     }
 409 
 410     void addSloppyModeHoistableFunctionCandidate(const Identifier* ident)
 411     {
 412         ASSERT(m_allowsVarDeclarations);
 413         m_sloppyModeHoistableFunctionCandidates.add(ident-&gt;impl());
 414     }
 415 
 416     void appendFunction(FunctionMetadataNode* node)
 417     {
 418         ASSERT(node);
 419         m_functionDeclarations.append(node);
 420     }
 421     DeclarationStacks::FunctionStack&amp;&amp; takeFunctionDeclarations() { return WTFMove(m_functionDeclarations); }
 422 
 423 
 424     DeclarationResultMask declareLexicalVariable(const Identifier* ident, bool isConstant, DeclarationImportType importType = DeclarationImportType::NotImported)
 425     {
 426         ASSERT(m_allowsLexicalDeclarations);
 427         DeclarationResultMask result = DeclarationResult::Valid;
 428         bool isValidStrictMode = !isEvalOrArgumentsIdentifier(m_vm, ident);
 429         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 430         auto addResult = m_lexicalVariables.add(ident-&gt;impl());
 431         if (isConstant)
 432             addResult.iterator-&gt;value.setIsConst();
 433         else
 434             addResult.iterator-&gt;value.setIsLet();
 435 
 436         if (importType == DeclarationImportType::Imported)
 437             addResult.iterator-&gt;value.setIsImported();
 438         else if (importType == DeclarationImportType::ImportedNamespace) {
 439             addResult.iterator-&gt;value.setIsImported();
 440             addResult.iterator-&gt;value.setIsImportedNamespace();
 441         }
 442 
 443         if (!addResult.isNewEntry || m_variablesBeingHoisted.contains(ident-&gt;impl()))
 444             result |= DeclarationResult::InvalidDuplicateDeclaration;
 445         if (!isValidStrictMode)
 446             result |= DeclarationResult::InvalidStrictMode;
 447 
 448         return result;
 449     }
 450 
 451     ALWAYS_INLINE bool hasDeclaredVariable(const Identifier&amp; ident)
 452     {
 453         return hasDeclaredVariable(ident.impl());
 454     }
 455 
 456     bool hasDeclaredVariable(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident)
 457     {
 458         auto iter = m_declaredVariables.find(ident.get());
 459         if (iter == m_declaredVariables.end())
 460             return false;
 461         VariableEnvironmentEntry entry = iter-&gt;value;
 462         return entry.isVar(); // The callee isn&#39;t a &quot;var&quot;.
 463     }
 464 
 465     ALWAYS_INLINE bool hasLexicallyDeclaredVariable(const Identifier&amp; ident)
 466     {
 467         return hasLexicallyDeclaredVariable(ident.impl());
 468     }
 469 
 470     bool hasLexicallyDeclaredVariable(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident) const
 471     {
 472         return m_lexicalVariables.contains(ident.get());
 473     }
 474 
 475     ALWAYS_INLINE bool hasDeclaredParameter(const Identifier&amp; ident)
 476     {
 477         return hasDeclaredParameter(ident.impl());
 478     }
 479 
 480     bool hasDeclaredParameter(const RefPtr&lt;UniquedStringImpl&gt;&amp; ident)
 481     {
 482         return m_declaredParameters.contains(ident.get()) || hasDeclaredVariable(ident);
 483     }
 484 
 485     void preventAllVariableDeclarations()
 486     {
 487         m_allowsVarDeclarations = false;
 488         m_allowsLexicalDeclarations = false;
 489     }
 490     void preventVarDeclarations() { m_allowsVarDeclarations = false; }
 491     bool allowsVarDeclarations() const { return m_allowsVarDeclarations; }
 492     bool allowsLexicalDeclarations() const { return m_allowsLexicalDeclarations; }
 493 
 494     DeclarationResultMask declareParameter(const Identifier* ident)
 495     {
 496         ASSERT(m_allowsVarDeclarations);
 497         DeclarationResultMask result = DeclarationResult::Valid;
 498         bool isArgumentsIdent = isArguments(m_vm, ident);
 499         auto addResult = m_declaredVariables.add(ident-&gt;impl());
 500         bool isValidStrictMode = (addResult.isNewEntry || !addResult.iterator-&gt;value.isParameter())
 501             &amp;&amp; m_vm.propertyNames-&gt;eval != *ident &amp;&amp; !isArgumentsIdent;
 502         addResult.iterator-&gt;value.clearIsVar();
 503         addResult.iterator-&gt;value.setIsParameter();
 504         m_isValidStrictMode = m_isValidStrictMode &amp;&amp; isValidStrictMode;
 505         m_declaredParameters.add(ident-&gt;impl());
 506         if (!isValidStrictMode)
 507             result |= DeclarationResult::InvalidStrictMode;
 508         if (isArgumentsIdent)
 509             m_shadowsArguments = true;
 510         if (!addResult.isNewEntry)
 511             result |= DeclarationResult::InvalidDuplicateDeclaration;
 512 
 513         return result;
 514     }
 515 
 516     bool usedVariablesContains(UniquedStringImpl* impl) const
 517     {
 518         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 519             if (set.contains(impl))
 520                 return true;
 521         }
 522         return false;
 523     }
 524     template &lt;typename Func&gt;
 525     void forEachUsedVariable(const Func&amp; func)
 526     {
 527         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables) {
 528             for (UniquedStringImpl* impl : set)
 529                 func(impl);
 530         }
 531     }
 532     void useVariable(const Identifier* ident, bool isEval)
 533     {
 534         useVariable(ident-&gt;impl(), isEval);
 535     }
 536     void useVariable(UniquedStringImpl* impl, bool isEval)
 537     {
 538         m_usesEval |= isEval;
 539         m_usedVariables.last().add(impl);
 540     }
 541 
 542     void pushUsedVariableSet() { m_usedVariables.append(UniquedStringImplPtrSet()); }
 543     size_t currentUsedVariablesSize() { return m_usedVariables.size(); }
 544 
 545     void revertToPreviousUsedVariables(size_t size) { m_usedVariables.resize(size); }
 546 
 547     void setNeedsFullActivation() { m_needsFullActivation = true; }
 548     bool needsFullActivation() const { return m_needsFullActivation; }
 549     bool isArrowFunctionBoundary() { return m_isArrowFunctionBoundary; }
 550     bool isArrowFunction() { return m_isArrowFunction; }
 551 
 552     bool hasDirectSuper() const { return m_hasDirectSuper; }
 553     bool setHasDirectSuper() { return std::exchange(m_hasDirectSuper, true); }
 554 
 555     bool needsSuperBinding() const { return m_needsSuperBinding; }
 556     bool setNeedsSuperBinding() { return std::exchange(m_needsSuperBinding, true); }
 557 
 558     void setEvalContextType(EvalContextType evalContextType) { m_evalContextType = evalContextType; }
 559     EvalContextType evalContextType() { return m_evalContextType; }
 560 
 561     InnerArrowFunctionCodeFeatures innerArrowFunctionFeatures() { return m_innerArrowFunctionFeatures; }
 562 
 563     void setExpectedSuperBinding(SuperBinding superBinding) { m_expectedSuperBinding = static_cast&lt;unsigned&gt;(superBinding); }
 564     SuperBinding expectedSuperBinding() const { return static_cast&lt;SuperBinding&gt;(m_expectedSuperBinding); }
 565     void setConstructorKind(ConstructorKind constructorKind) { m_constructorKind = static_cast&lt;unsigned&gt;(constructorKind); }
 566     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
 567 
 568     void setInnerArrowFunctionUsesSuperCall() { m_innerArrowFunctionFeatures |= SuperCallInnerArrowFunctionFeature; }
 569     void setInnerArrowFunctionUsesSuperProperty() { m_innerArrowFunctionFeatures |= SuperPropertyInnerArrowFunctionFeature; }
 570     void setInnerArrowFunctionUsesEval() { m_innerArrowFunctionFeatures |= EvalInnerArrowFunctionFeature; }
 571     void setInnerArrowFunctionUsesThis() { m_innerArrowFunctionFeatures |= ThisInnerArrowFunctionFeature; }
 572     void setInnerArrowFunctionUsesNewTarget() { m_innerArrowFunctionFeatures |= NewTargetInnerArrowFunctionFeature; }
 573     void setInnerArrowFunctionUsesArguments() { m_innerArrowFunctionFeatures |= ArgumentsInnerArrowFunctionFeature; }
 574 
 575     bool isEvalContext() const { return m_isEvalContext; }
 576     void setIsEvalContext(bool isEvalContext) { m_isEvalContext = isEvalContext; }
 577 
 578     void setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded()
 579     {
 580         ASSERT(m_isArrowFunction);
 581 
 582         if (m_usesEval)
 583             setInnerArrowFunctionUsesEval();
 584 
 585         if (usedVariablesContains(m_vm.propertyNames-&gt;arguments.impl()))
 586             setInnerArrowFunctionUsesArguments();
 587     }
 588 
 589     void addClosedVariableCandidateUnconditionally(UniquedStringImpl* impl)
 590     {
 591         m_closedVariableCandidates.add(impl);
 592     }
 593 
<a name="6" id="anc6"></a><span class="line-added"> 594     void markLastUsedVariablesSetAsCaptured()</span>
<span class="line-added"> 595     {</span>
<span class="line-added"> 596         for (UniquedStringImpl* impl : m_usedVariables.last())</span>
<span class="line-added"> 597             m_closedVariableCandidates.add(impl);</span>
<span class="line-added"> 598     }</span>
<span class="line-added"> 599 </span>
 600     void collectFreeVariables(Scope* nestedScope, bool shouldTrackClosedVariables)
 601     {
 602         if (nestedScope-&gt;m_usesEval)
 603             m_usesEval = true;
 604 
 605         {
 606             UniquedStringImplPtrSet&amp; destinationSet = m_usedVariables.last();
 607             for (const UniquedStringImplPtrSet&amp; usedVariablesSet : nestedScope-&gt;m_usedVariables) {
 608                 for (UniquedStringImpl* impl : usedVariablesSet) {
 609                     if (nestedScope-&gt;m_declaredVariables.contains(impl) || nestedScope-&gt;m_lexicalVariables.contains(impl))
 610                         continue;
 611 
 612                     // &quot;arguments&quot; reference should be resolved at function boudary.
 613                     if (nestedScope-&gt;isFunctionBoundary() &amp;&amp; nestedScope-&gt;hasArguments() &amp;&amp; impl == m_vm.propertyNames-&gt;arguments.impl() &amp;&amp; !nestedScope-&gt;isArrowFunctionBoundary())
 614                         continue;
 615 
 616                     destinationSet.add(impl);
 617                     // We don&#39;t want a declared variable that is used in an inner scope to be thought of as captured if
 618                     // that inner scope is both a lexical scope and not a function. Only inner functions and &quot;catch&quot;
 619                     // statements can cause variables to be captured.
 620                     if (shouldTrackClosedVariables &amp;&amp; (nestedScope-&gt;m_isFunctionBoundary || !nestedScope-&gt;m_isLexicalScope))
 621                         m_closedVariableCandidates.add(impl);
 622                 }
 623             }
 624         }
 625         // Propagate closed variable candidates downwards within the same function.
 626         // Cross function captures will be realized via m_usedVariables propagation.
 627         if (shouldTrackClosedVariables &amp;&amp; !nestedScope-&gt;m_isFunctionBoundary &amp;&amp; nestedScope-&gt;m_closedVariableCandidates.size()) {
 628             auto end = nestedScope-&gt;m_closedVariableCandidates.end();
 629             auto begin = nestedScope-&gt;m_closedVariableCandidates.begin();
 630             m_closedVariableCandidates.add(begin, end);
 631         }
 632     }
 633 
 634     void mergeInnerArrowFunctionFeatures(InnerArrowFunctionCodeFeatures arrowFunctionCodeFeatures)
 635     {
 636         m_innerArrowFunctionFeatures = m_innerArrowFunctionFeatures | arrowFunctionCodeFeatures;
 637     }
 638 
 639     void getSloppyModeHoistedFunctions(UniquedStringImplPtrSet&amp; sloppyModeHoistedFunctions)
 640     {
 641         for (UniquedStringImpl* function : m_sloppyModeHoistableFunctionCandidates) {
 642             // ES6 Annex B.3.3. The only time we can&#39;t hoist a function is if a syntax error would
 643             // be caused by declaring a var with that function&#39;s name or if we have a parameter with
 644             // that function&#39;s name. Note that we would only cause a syntax error if we had a let/const/class
 645             // variable with the same name.
 646             if (!m_lexicalVariables.contains(function)) {
 647                 auto iter = m_declaredVariables.find(function);
 648                 bool isParameter = iter != m_declaredVariables.end() &amp;&amp; iter-&gt;value.isParameter();
 649                 if (!isParameter) {
 650                     auto addResult = m_declaredVariables.add(function);
 651                     addResult.iterator-&gt;value.setIsVar();
 652                     addResult.iterator-&gt;value.setIsSloppyModeHoistingCandidate();
 653                     sloppyModeHoistedFunctions.add(function);
 654                 }
 655             }
 656         }
 657     }
 658 
 659     void getCapturedVars(IdentifierSet&amp; capturedVariables)
 660     {
 661         if (m_needsFullActivation || m_usesEval) {
 662             for (auto&amp; entry : m_declaredVariables)
 663                 capturedVariables.add(entry.key);
 664             return;
 665         }
 666         for (UniquedStringImpl* impl : m_closedVariableCandidates) {
 667             // We refer to m_declaredVariables here directly instead of a hasDeclaredVariable because we want to mark the callee as captured.
 668             if (!m_declaredVariables.contains(impl))
 669                 continue;
 670             capturedVariables.add(impl);
 671         }
 672     }
 673     void setStrictMode() { m_strictMode = true; }
 674     bool strictMode() const { return m_strictMode; }
 675     bool isValidStrictMode() const { return m_isValidStrictMode; }
 676     bool shadowsArguments() const { return m_shadowsArguments; }
 677     void setHasNonSimpleParameterList()
 678     {
 679         m_isValidStrictMode = false;
 680         m_hasNonSimpleParameterList = true;
 681     }
 682     bool hasNonSimpleParameterList() const { return m_hasNonSimpleParameterList; }
 683 
 684     void copyCapturedVariablesToVector(const UniquedStringImplPtrSet&amp; usedVariables, Vector&lt;UniquedStringImpl*, 8&gt;&amp; vector)
 685     {
 686         for (UniquedStringImpl* impl : usedVariables) {
 687             if (m_declaredVariables.contains(impl) || m_lexicalVariables.contains(impl))
 688                 continue;
 689             vector.append(impl);
 690         }
 691     }
 692 
 693     void fillParametersForSourceProviderCache(SourceProviderCacheItemCreationParameters&amp; parameters, const UniquedStringImplPtrSet&amp; capturesFromParameterExpressions)
 694     {
 695         ASSERT(m_isFunction);
 696         parameters.usesEval = m_usesEval;
 697         parameters.strictMode = m_strictMode;
 698         parameters.needsFullActivation = m_needsFullActivation;
 699         parameters.innerArrowFunctionFeatures = m_innerArrowFunctionFeatures;
 700         parameters.needsSuperBinding = m_needsSuperBinding;
 701         for (const UniquedStringImplPtrSet&amp; set : m_usedVariables)
 702             copyCapturedVariablesToVector(set, parameters.usedVariables);
 703 
 704         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=156962
 705         // We add these unconditionally because we currently don&#39;t keep a separate
 706         // declaration scope for a function&#39;s parameters and its var/let/const declarations.
 707         // This is somewhat unfortunate and we should refactor to do this at some point
 708         // because parameters logically form a parent scope to var/let/const variables.
 709         // But because we don&#39;t do this, we must grab capture candidates from a parameter
 710         // list before we parse the body of a function because the body&#39;s declarations
 711         // might make us believe something isn&#39;t actually a capture candidate when it really
 712         // is.
 713         for (UniquedStringImpl* impl : capturesFromParameterExpressions)
 714             parameters.usedVariables.append(impl);
 715     }
 716 
 717     void restoreFromSourceProviderCache(const SourceProviderCacheItem* info)
 718     {
 719         ASSERT(m_isFunction);
 720         m_usesEval = info-&gt;usesEval;
 721         m_strictMode = info-&gt;strictMode;
 722         m_innerArrowFunctionFeatures = info-&gt;innerArrowFunctionFeatures;
 723         m_needsFullActivation = info-&gt;needsFullActivation;
 724         m_needsSuperBinding = info-&gt;needsSuperBinding;
 725         UniquedStringImplPtrSet&amp; destSet = m_usedVariables.last();
 726         for (unsigned i = 0; i &lt; info-&gt;usedVariablesCount; ++i)
<a name="7" id="anc7"></a><span class="line-modified"> 727             destSet.add(info-&gt;usedVariables()[i].get());</span>
 728     }
 729 
 730     class MaybeParseAsGeneratorForScope;
 731 
 732 private:
 733     void setIsFunction()
 734     {
 735         m_isFunction = true;
 736         m_isFunctionBoundary = true;
 737         m_hasArguments = true;
 738         setIsLexicalScope();
 739         m_isGenerator = false;
 740         m_isGeneratorBoundary = false;
 741         m_isArrowFunctionBoundary = false;
 742         m_isArrowFunction = false;
 743         m_isAsyncFunction = false;
 744         m_isAsyncFunctionBoundary = false;
 745     }
 746 
 747     void setIsGeneratorFunction()
 748     {
 749         setIsFunction();
 750         m_isGenerator = true;
 751     }
 752 
 753     void setIsGenerator()
 754     {
 755         setIsFunction();
 756         m_isGenerator = true;
 757         m_isGeneratorBoundary = true;
 758         m_hasArguments = false;
 759     }
 760 
 761     void setIsArrowFunction()
 762     {
 763         setIsFunction();
 764         m_isArrowFunctionBoundary = true;
 765         m_isArrowFunction = true;
 766     }
 767 
 768     void setIsAsyncArrowFunction()
 769     {
 770         setIsArrowFunction();
 771         m_isAsyncFunction = true;
 772     }
 773 
 774     void setIsAsyncFunction()
 775     {
 776         setIsFunction();
 777         m_isAsyncFunction = true;
 778     }
 779 
 780     void setIsAsyncGeneratorFunction()
 781     {
 782         setIsFunction();
 783         m_isAsyncFunction = true;
 784         m_isGenerator = true;
 785     }
 786 
 787     void setIsAsyncGeneratorFunctionBody()
 788     {
 789         setIsFunction();
 790         m_hasArguments = false;
 791         m_isGenerator = true;
 792         m_isGeneratorBoundary = true;
 793         m_isAsyncFunction = true;
 794         m_isAsyncFunctionBoundary = true;
 795     }
 796 
 797     void setIsAsyncFunctionBody()
 798     {
 799         setIsFunction();
 800         m_hasArguments = false;
 801         m_isAsyncFunction = true;
 802         m_isAsyncFunctionBoundary = true;
 803     }
 804 
 805     void setIsAsyncArrowFunctionBody()
 806     {
 807         setIsArrowFunction();
 808         m_hasArguments = false;
 809         m_isAsyncFunction = true;
 810         m_isAsyncFunctionBoundary = true;
 811     }
 812 
 813     const VM&amp; m_vm;
 814     bool m_shadowsArguments;
 815     bool m_usesEval;
 816     bool m_needsFullActivation;
 817     bool m_hasDirectSuper;
 818     bool m_needsSuperBinding;
 819     bool m_allowsVarDeclarations;
 820     bool m_allowsLexicalDeclarations;
 821     bool m_strictMode;
 822     bool m_isFunction;
 823     bool m_isGenerator;
 824     bool m_isGeneratorBoundary;
 825     bool m_isArrowFunction;
 826     bool m_isArrowFunctionBoundary;
 827     bool m_isAsyncFunction;
 828     bool m_isAsyncFunctionBoundary;
 829     bool m_isLexicalScope;
 830     bool m_isGlobalCodeScope;
 831     bool m_isSimpleCatchParameterScope;
 832     bool m_isFunctionBoundary;
 833     bool m_isValidStrictMode;
 834     bool m_hasArguments;
 835     bool m_isEvalContext;
 836     bool m_hasNonSimpleParameterList;
<a name="8" id="anc8"></a><span class="line-added"> 837     bool m_isClassScope;</span>
 838     EvalContextType m_evalContextType;
 839     unsigned m_constructorKind;
 840     unsigned m_expectedSuperBinding;
 841     int m_loopDepth;
 842     int m_switchDepth;
 843     InnerArrowFunctionCodeFeatures m_innerArrowFunctionFeatures;
 844 
 845     typedef Vector&lt;ScopeLabelInfo, 2&gt; LabelStack;
 846     std::unique_ptr&lt;LabelStack&gt; m_labels;
 847     UniquedStringImplPtrSet m_declaredParameters;
 848     VariableEnvironment m_declaredVariables;
 849     VariableEnvironment m_lexicalVariables;
 850     Vector&lt;UniquedStringImplPtrSet, 6&gt; m_usedVariables;
 851     UniquedStringImplPtrSet m_variablesBeingHoisted;
 852     UniquedStringImplPtrSet m_sloppyModeHoistableFunctionCandidates;
 853     HashSet&lt;UniquedStringImpl*&gt; m_closedVariableCandidates;
 854     DeclarationStacks::FunctionStack m_functionDeclarations;
 855 };
 856 
 857 typedef Vector&lt;Scope, 10&gt; ScopeStack;
 858 
 859 struct ScopeRef {
 860     ScopeRef(ScopeStack* scopeStack, unsigned index)
 861         : m_scopeStack(scopeStack)
 862         , m_index(index)
 863     {
 864     }
 865     Scope* operator-&gt;() { return &amp;m_scopeStack-&gt;at(m_index); }
 866     unsigned index() const { return m_index; }
 867 
 868     bool hasContainingScope()
 869     {
 870         return m_index &amp;&amp; !m_scopeStack-&gt;at(m_index).isFunctionBoundary();
 871     }
 872 
 873     ScopeRef containingScope()
 874     {
 875         ASSERT(hasContainingScope());
 876         return ScopeRef(m_scopeStack, m_index - 1);
 877     }
 878 
 879     bool operator==(const ScopeRef&amp; other)
 880     {
 881         ASSERT(other.m_scopeStack == m_scopeStack);
 882         return m_index == other.m_index;
 883     }
 884 
 885     bool operator!=(const ScopeRef&amp; other)
 886     {
 887         return !(*this == other);
 888     }
 889 
 890 private:
 891     ScopeStack* m_scopeStack;
 892     unsigned m_index;
 893 };
 894 
 895 enum class ArgumentType { Normal, Spread };
 896 enum class ParsingContext { Program, FunctionConstructor, Eval };
 897 
 898 template &lt;typename LexerType&gt;
 899 class Parser {
 900     WTF_MAKE_NONCOPYABLE(Parser);
 901     WTF_MAKE_FAST_ALLOCATED;
 902 
 903 public:
<a name="9" id="anc9"></a><span class="line-modified"> 904     Parser(VM&amp;, const SourceCode&amp;, JSParserBuiltinMode, JSParserStrictMode, JSParserScriptMode, SourceParseMode, SuperBinding, ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None, DerivedContextType = DerivedContextType::None, bool isEvalContext = false, EvalContextType = EvalContextType::None, DebuggerParseData* = nullptr);</span>
 905     ~Parser();
 906 
 907     template &lt;class ParsedNode&gt;
<a name="10" id="anc10"></a><span class="line-modified"> 908     std::unique_ptr&lt;ParsedNode&gt; parse(ParserError&amp;, const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
 909 
 910     JSTextPosition positionBeforeLastNewline() const { return m_lexer-&gt;positionBeforeLastNewline(); }
 911     JSTokenLocation locationBeforeLastToken() const { return m_lexer-&gt;lastTokenLocation(); }
 912 
 913     struct CallOrApplyDepthScope {
 914         CallOrApplyDepthScope(Parser* parser)
 915             : m_parser(parser)
 916             , m_parent(parser-&gt;m_callOrApplyDepthScope)
 917             , m_depth(m_parent ? m_parent-&gt;m_depth + 1 : 0)
 918             , m_depthOfInnermostChild(m_depth)
 919         {
 920             parser-&gt;m_callOrApplyDepthScope = this;
 921         }
 922 
 923         size_t distanceToInnermostChild() const
 924         {
 925             ASSERT(m_depthOfInnermostChild &gt;= m_depth);
 926             return m_depthOfInnermostChild - m_depth;
 927         }
 928 
 929         ~CallOrApplyDepthScope()
 930         {
 931             if (m_parent)
 932                 m_parent-&gt;m_depthOfInnermostChild = std::max(m_depthOfInnermostChild, m_parent-&gt;m_depthOfInnermostChild);
 933             m_parser-&gt;m_callOrApplyDepthScope = m_parent;
 934         }
 935 
 936     private:
 937 
 938         Parser* m_parser;
 939         CallOrApplyDepthScope* m_parent;
 940         size_t m_depth;
 941         size_t m_depthOfInnermostChild;
 942     };
 943 
 944 private:
 945     struct AllowInOverride {
 946         AllowInOverride(Parser* parser)
 947             : m_parser(parser)
 948             , m_oldAllowsIn(parser-&gt;m_allowsIn)
 949         {
 950             parser-&gt;m_allowsIn = true;
 951         }
 952         ~AllowInOverride()
 953         {
 954             m_parser-&gt;m_allowsIn = m_oldAllowsIn;
 955         }
 956         Parser* m_parser;
 957         bool m_oldAllowsIn;
 958     };
 959 
 960     struct AutoPopScopeRef : public ScopeRef {
 961         AutoPopScopeRef(Parser* parser, ScopeRef scope)
 962         : ScopeRef(scope)
 963         , m_parser(parser)
 964         {
 965         }
 966 
 967         ~AutoPopScopeRef()
 968         {
 969             if (m_parser)
 970                 m_parser-&gt;popScope(*this, false);
 971         }
 972 
 973         void setPopped()
 974         {
 975             m_parser = 0;
 976         }
 977 
 978     private:
 979         Parser* m_parser;
 980     };
 981 
 982     struct AutoCleanupLexicalScope {
 983         // We can allocate this object on the stack without actually knowing beforehand if we&#39;re
 984         // going to create a new lexical scope. If we decide to create a new lexical scope, we
 985         // can pass the scope into this obejct and it will take care of the cleanup for us if the parse fails.
 986         // This is helpful if we may fail from syntax errors after creating a lexical scope conditionally.
 987         AutoCleanupLexicalScope()
 988             : m_scope(nullptr, UINT_MAX)
 989             , m_parser(nullptr)
 990         {
 991         }
 992 
 993         ~AutoCleanupLexicalScope()
 994         {
 995             // This should only ever be called if we fail from a syntax error. Otherwise
 996             // it&#39;s the intention that a user of this class pops this scope manually on a
 997             // successful parse.
 998             if (isValid())
 999                 m_parser-&gt;popScope(*this, false);
1000         }
1001 
1002         void setIsValid(ScopeRef&amp; scope, Parser* parser)
1003         {
1004             RELEASE_ASSERT(scope-&gt;isLexicalScope());
1005             m_scope = scope;
1006             m_parser = parser;
1007         }
1008 
1009         bool isValid() const { return !!m_parser; }
1010 
1011         void setPopped()
1012         {
1013             m_parser = nullptr;
1014         }
1015 
1016         ScopeRef&amp; scope() { return m_scope; }
1017 
1018     private:
1019         ScopeRef m_scope;
1020         Parser* m_parser;
1021     };
1022 
1023     enum ExpressionErrorClass {
1024         ErrorIndicatesNothing = 0,
1025         ErrorIndicatesPattern,
1026         ErrorIndicatesAsyncArrowFunction
1027     };
1028 
1029     struct ExpressionErrorClassifier {
1030         ExpressionErrorClassifier(Parser* parser)
1031             : m_class(ErrorIndicatesNothing)
1032             , m_previous(parser-&gt;m_expressionErrorClassifier)
1033             , m_parser(parser)
1034         {
1035             m_parser-&gt;m_expressionErrorClassifier = this;
1036         }
1037 
1038         ~ExpressionErrorClassifier()
1039         {
1040             m_parser-&gt;m_expressionErrorClassifier = m_previous;
1041         }
1042 
1043         void classifyExpressionError(ExpressionErrorClass classification)
1044         {
1045             if (m_class != ErrorIndicatesNothing)
1046                 return;
1047             m_class = classification;
1048         }
1049 
1050         void forceClassifyExpressionError(ExpressionErrorClass classification)
1051         {
1052             m_class = classification;
1053         }
1054 
1055         void reclassifyExpressionError(ExpressionErrorClass oldClassification, ExpressionErrorClass classification)
1056         {
1057             if (m_class != oldClassification)
1058                 return;
1059             m_class = classification;
1060         }
1061 
1062         void propagateExpressionErrorClass()
1063         {
1064             if (m_previous)
1065                 m_previous-&gt;m_class = m_class;
1066         }
1067 
1068         bool indicatesPossiblePattern() const { return m_class == ErrorIndicatesPattern; }
1069         bool indicatesPossibleAsyncArrowFunction() const { return m_class == ErrorIndicatesAsyncArrowFunction; }
1070 
1071     private:
1072         ExpressionErrorClass m_class;
1073         ExpressionErrorClassifier* m_previous;
1074         Parser* m_parser;
1075     };
1076 
1077     ALWAYS_INLINE void classifyExpressionError(ExpressionErrorClass classification)
1078     {
1079         if (m_expressionErrorClassifier)
1080             m_expressionErrorClassifier-&gt;classifyExpressionError(classification);
1081     }
1082 
1083     ALWAYS_INLINE void forceClassifyExpressionError(ExpressionErrorClass classification)
1084     {
1085         if (m_expressionErrorClassifier)
1086             m_expressionErrorClassifier-&gt;forceClassifyExpressionError(classification);
1087     }
1088 
1089     ALWAYS_INLINE void reclassifyExpressionError(ExpressionErrorClass oldClassification, ExpressionErrorClass classification)
1090     {
1091         if (m_expressionErrorClassifier)
1092             m_expressionErrorClassifier-&gt;reclassifyExpressionError(oldClassification, classification);
1093     }
1094 
1095     ALWAYS_INLINE DestructuringKind destructuringKindFromDeclarationType(DeclarationType type)
1096     {
1097         switch (type) {
1098         case DeclarationType::VarDeclaration:
1099             return DestructuringKind::DestructureToVariables;
1100         case DeclarationType::LetDeclaration:
1101             return DestructuringKind::DestructureToLet;
1102         case DeclarationType::ConstDeclaration:
1103             return DestructuringKind::DestructureToConst;
1104         }
1105 
1106         RELEASE_ASSERT_NOT_REACHED();
1107         return DestructuringKind::DestructureToVariables;
1108     }
1109 
1110     ALWAYS_INLINE const char* declarationTypeToVariableKind(DeclarationType type)
1111     {
1112         switch (type) {
1113         case DeclarationType::VarDeclaration:
1114             return &quot;variable name&quot;;
1115         case DeclarationType::LetDeclaration:
1116         case DeclarationType::ConstDeclaration:
1117             return &quot;lexical variable name&quot;;
1118         }
1119         RELEASE_ASSERT_NOT_REACHED();
1120         return &quot;invalid&quot;;
1121     }
1122 
1123     ALWAYS_INLINE AssignmentContext assignmentContextFromDeclarationType(DeclarationType type)
1124     {
1125         switch (type) {
1126         case DeclarationType::ConstDeclaration:
1127             return AssignmentContext::ConstDeclarationStatement;
1128         default:
1129             return AssignmentContext::DeclarationStatement;
1130         }
1131     }
1132 
1133     ALWAYS_INLINE bool isEvalOrArguments(const Identifier* ident) { return isEvalOrArgumentsIdentifier(m_vm, ident); }
1134 
1135     ScopeRef upperScope(int n)
1136     {
1137         ASSERT(m_scopeStack.size() &gt;= size_t(1 + n));
1138         return ScopeRef(&amp;m_scopeStack, m_scopeStack.size() - 1 - n);
1139     }
1140 
1141     ScopeRef currentScope()
1142     {
1143         return ScopeRef(&amp;m_scopeStack, m_scopeStack.size() - 1);
1144     }
1145 
1146     ScopeRef currentVariableScope()
1147     {
1148         unsigned i = m_scopeStack.size() - 1;
1149         ASSERT(i &lt; m_scopeStack.size());
1150         while (!m_scopeStack[i].allowsVarDeclarations()) {
1151             i--;
1152             ASSERT(i &lt; m_scopeStack.size());
1153         }
1154         return ScopeRef(&amp;m_scopeStack, i);
1155     }
1156 
1157     ScopeRef currentLexicalDeclarationScope()
1158     {
1159         unsigned i = m_scopeStack.size() - 1;
1160         ASSERT(i &lt; m_scopeStack.size());
1161         while (!m_scopeStack[i].allowsLexicalDeclarations()) {
1162             i--;
1163             ASSERT(i &lt; m_scopeStack.size());
1164         }
1165 
1166         return ScopeRef(&amp;m_scopeStack, i);
1167     }
1168 
1169     ScopeRef currentFunctionScope()
1170     {
1171         unsigned i = m_scopeStack.size() - 1;
1172         ASSERT(i &lt; m_scopeStack.size());
1173         while (i &amp;&amp; !m_scopeStack[i].isFunctionBoundary()) {
1174             i--;
1175             ASSERT(i &lt; m_scopeStack.size());
1176         }
1177         // When reaching the top level scope (it can be non function scope), we return it.
1178         return ScopeRef(&amp;m_scopeStack, i);
1179     }
1180 
1181     ScopeRef closestParentOrdinaryFunctionNonLexicalScope()
1182     {
1183         unsigned i = m_scopeStack.size() - 1;
1184         ASSERT(i &lt; m_scopeStack.size() &amp;&amp; m_scopeStack.size());
1185         while (i &amp;&amp; (!m_scopeStack[i].isFunctionBoundary() || m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary() || m_scopeStack[i].isArrowFunctionBoundary()))
1186             i--;
1187         // When reaching the top level scope (it can be non ordinary function scope), we return it.
1188         return ScopeRef(&amp;m_scopeStack, i);
1189     }
1190 
<a name="11" id="anc11"></a><span class="line-added">1191     ScopeRef closestClassScopeOrTopLevelScope()</span>
<span class="line-added">1192     {</span>
<span class="line-added">1193         unsigned i = m_scopeStack.size() - 1;</span>
<span class="line-added">1194         ASSERT(i &lt; m_scopeStack.size());</span>
<span class="line-added">1195         while (i &amp;&amp; !m_scopeStack[i].isClassScope())</span>
<span class="line-added">1196             i--;</span>
<span class="line-added">1197         return ScopeRef(&amp;m_scopeStack, i);</span>
<span class="line-added">1198     }</span>
<span class="line-added">1199 </span>
1200     ScopeRef pushScope()
1201     {
1202         bool isFunction = false;
1203         bool isStrict = false;
1204         bool isGenerator = false;
1205         bool isArrowFunction = false;
1206         bool isAsyncFunction = false;
1207         if (!m_scopeStack.isEmpty()) {
1208             isStrict = m_scopeStack.last().strictMode();
1209             isFunction = m_scopeStack.last().isFunction();
1210             isGenerator = m_scopeStack.last().isGenerator();
1211             isArrowFunction = m_scopeStack.last().isArrowFunction();
1212             isAsyncFunction = m_scopeStack.last().isAsyncFunction();
1213         }
1214         m_scopeStack.constructAndAppend(m_vm, isFunction, isGenerator, isStrict, isArrowFunction, isAsyncFunction);
1215         return currentScope();
1216     }
1217 
1218     void popScopeInternal(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1219     {
1220         EXCEPTION_ASSERT_UNUSED(scope, scope.index() == m_scopeStack.size() - 1);
1221         ASSERT(m_scopeStack.size() &gt; 1);
1222         m_scopeStack[m_scopeStack.size() - 2].collectFreeVariables(&amp;m_scopeStack.last(), shouldTrackClosedVariables);
1223 
1224         if (m_scopeStack.last().isArrowFunction())
1225             m_scopeStack.last().setInnerArrowFunctionUsesEvalAndUseArgumentsIfNeeded();
1226 
1227         if (!(m_scopeStack.last().isFunctionBoundary() &amp;&amp; !m_scopeStack.last().isArrowFunctionBoundary()))
1228             m_scopeStack[m_scopeStack.size() - 2].mergeInnerArrowFunctionFeatures(m_scopeStack.last().innerArrowFunctionFeatures());
1229 
1230         if (!m_scopeStack.last().isFunctionBoundary() &amp;&amp; m_scopeStack.last().needsFullActivation())
1231             m_scopeStack[m_scopeStack.size() - 2].setNeedsFullActivation();
1232         m_scopeStack.removeLast();
1233     }
1234 
1235     ALWAYS_INLINE void popScope(ScopeRef&amp; scope, bool shouldTrackClosedVariables)
1236     {
1237         popScopeInternal(scope, shouldTrackClosedVariables);
1238     }
1239 
1240     ALWAYS_INLINE void popScope(AutoPopScopeRef&amp; scope, bool shouldTrackClosedVariables)
1241     {
1242         scope.setPopped();
1243         popScopeInternal(scope, shouldTrackClosedVariables);
1244     }
1245 
1246     ALWAYS_INLINE void popScope(AutoCleanupLexicalScope&amp; cleanupScope, bool shouldTrackClosedVariables)
1247     {
1248         RELEASE_ASSERT(cleanupScope.isValid());
1249         ScopeRef&amp; scope = cleanupScope.scope();
1250         cleanupScope.setPopped();
1251         popScopeInternal(scope, shouldTrackClosedVariables);
1252     }
1253 
1254     NEVER_INLINE DeclarationResultMask declareHoistedVariable(const Identifier* ident)
1255     {
1256         unsigned i = m_scopeStack.size() - 1;
1257         ASSERT(i &lt; m_scopeStack.size());
1258         while (true) {
1259             // Annex B.3.5 exempts `try {} catch (e) { var e; }` from being a syntax error.
1260             if (m_scopeStack[i].hasLexicallyDeclaredVariable(*ident) &amp;&amp; !m_scopeStack[i].isSimpleCatchParameterScope())
1261                 return DeclarationResult::InvalidDuplicateDeclaration;
1262 
1263             if (m_scopeStack[i].allowsVarDeclarations())
1264                 return m_scopeStack[i].declareVariable(ident);
1265 
1266             m_scopeStack[i].addVariableBeingHoisted(ident);
1267 
1268             i--;
1269             ASSERT(i &lt; m_scopeStack.size());
1270         }
1271     }
1272 
1273     DeclarationResultMask declareVariable(const Identifier* ident, DeclarationType type = DeclarationType::VarDeclaration, DeclarationImportType importType = DeclarationImportType::NotImported)
1274     {
1275         if (type == DeclarationType::VarDeclaration)
1276             return declareHoistedVariable(ident);
1277 
1278         ASSERT(type == DeclarationType::LetDeclaration || type == DeclarationType::ConstDeclaration);
1279         // Lexical variables declared at a top level scope that shadow arguments or vars are not allowed.
1280         if (!m_lexer-&gt;isReparsingFunction() &amp;&amp; m_statementDepth == 1 &amp;&amp; (hasDeclaredParameter(*ident) || hasDeclaredVariable(*ident)))
1281             return DeclarationResult::InvalidDuplicateDeclaration;
1282 
1283         return currentLexicalDeclarationScope()-&gt;declareLexicalVariable(ident, type == DeclarationType::ConstDeclaration, importType);
1284     }
1285 
1286     std::pair&lt;DeclarationResultMask, ScopeRef&gt; declareFunction(const Identifier* ident)
1287     {
1288         if ((m_statementDepth == 1) || (!strictMode() &amp;&amp; !currentScope()-&gt;isFunction() &amp;&amp; !closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext())) {
1289             // Functions declared at the top-most scope (both in sloppy and strict mode) are declared as vars
1290             // for backwards compatibility. This allows us to declare functions with the same name more than once.
1291             // In sloppy mode, we always declare functions as vars.
1292             bool declareAsVar = true;
1293             bool isSloppyModeHoistingCandidate = false;
1294             ScopeRef variableScope = currentVariableScope();
1295             return std::make_pair(variableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), variableScope);
1296         }
1297 
1298         if (!strictMode()) {
1299             ASSERT(currentScope()-&gt;isFunction() || closestParentOrdinaryFunctionNonLexicalScope()-&gt;isEvalContext());
1300 
1301             // Functions declared inside a function inside a nested block scope in sloppy mode are subject to this
1302             // crazy rule defined inside Annex B.3.3 in the ES6 spec. It basically states that we will create
1303             // the function as a local block scoped variable, but when we evaluate the block that the function is
1304             // contained in, we will assign the function to a &quot;var&quot; variable only if declaring such a &quot;var&quot; wouldn&#39;t
1305             // be a syntax error and if there isn&#39;t a parameter with the same name. (It would only be a syntax error if
1306             // there are is a let/class/const with the same name). Note that this mean we only do the &quot;var&quot; hoisting
1307             // binding if the block evaluates. For example, this means we wont won&#39;t perform the binding if it&#39;s inside
1308             // the untaken branch of an if statement.
1309             bool declareAsVar = false;
1310             bool isSloppyModeHoistingCandidate = true;
1311             ScopeRef lexicalVariableScope = currentLexicalDeclarationScope();
1312             ScopeRef varScope = currentVariableScope();
1313             varScope-&gt;addSloppyModeHoistableFunctionCandidate(ident);
1314             ASSERT(varScope != lexicalVariableScope);
1315             return std::make_pair(lexicalVariableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), lexicalVariableScope);
1316         }
1317 
1318         bool declareAsVar = false;
1319         bool isSloppyModeHoistingCandidate = false;
1320         ScopeRef lexicalVariableScope = currentLexicalDeclarationScope();
1321         return std::make_pair(lexicalVariableScope-&gt;declareFunction(ident, declareAsVar, isSloppyModeHoistingCandidate), lexicalVariableScope);
1322     }
1323 
1324     NEVER_INLINE bool hasDeclaredVariable(const Identifier&amp; ident)
1325     {
1326         unsigned i = m_scopeStack.size() - 1;
1327         ASSERT(i &lt; m_scopeStack.size());
1328         while (!m_scopeStack[i].allowsVarDeclarations()) {
1329             i--;
1330             ASSERT(i &lt; m_scopeStack.size());
1331         }
1332         return m_scopeStack[i].hasDeclaredVariable(ident);
1333     }
1334 
1335     NEVER_INLINE bool hasDeclaredParameter(const Identifier&amp; ident)
1336     {
1337         // FIXME: hasDeclaredParameter() is not valid during reparsing of generator or async function bodies, because their formal
1338         // parameters are declared in a scope unavailable during reparsing. Note that it is redundant to call this function during
1339         // reparsing anyways, as the function is already guaranteed to be valid by the original parsing.
1340         // https://bugs.webkit.org/show_bug.cgi?id=164087
1341         ASSERT(!m_lexer-&gt;isReparsingFunction());
1342 
1343         unsigned i = m_scopeStack.size() - 1;
1344         ASSERT(i &lt; m_scopeStack.size());
1345         while (!m_scopeStack[i].allowsVarDeclarations()) {
1346             i--;
1347             ASSERT(i &lt; m_scopeStack.size());
1348         }
1349 
1350         if (m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary()) {
1351             // The formal parameters which need to be verified for Generators and Async Function bodies occur
1352             // in the outer wrapper function, so pick the outer scope here.
1353             i--;
1354             ASSERT(i &lt; m_scopeStack.size());
1355         }
1356         return m_scopeStack[i].hasDeclaredParameter(ident);
1357     }
1358 
1359     bool exportName(const Identifier&amp; ident)
1360     {
1361         ASSERT(currentScope().index() == 0);
1362         ASSERT(m_moduleScopeData);
1363         return m_moduleScopeData-&gt;exportName(ident);
1364     }
1365 
1366     ScopeStack m_scopeStack;
1367 
1368     const SourceProviderCacheItem* findCachedFunctionInfo(int openBracePos)
1369     {
1370         return m_functionCache ? m_functionCache-&gt;get(openBracePos) : 0;
1371     }
1372 
1373     Parser();
1374 
<a name="12" id="anc12"></a><span class="line-modified">1375     struct ParseInnerResult {</span>
<span class="line-modified">1376         FunctionParameters* parameters;</span>
<span class="line-modified">1377         SourceElements* sourceElements;</span>
<span class="line-added">1378         DeclarationStacks::FunctionStack functionDeclarations;</span>
<span class="line-added">1379         VariableEnvironment varDeclarations;</span>
<span class="line-added">1380         UniquedStringImplPtrSet sloppyModeHoistedFunctions;</span>
<span class="line-added">1381         CodeFeatures features;</span>
<span class="line-added">1382         int numConstants;</span>
<span class="line-added">1383     };</span>
<span class="line-added">1384     Expected&lt;ParseInnerResult, String&gt; parseInner(const Identifier&amp;, SourceParseMode, ParsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt, const Vector&lt;JSTextPosition&gt;* = nullptr);</span>
1385 
1386     // Used to determine type of error to report.
1387     bool isFunctionMetadataNode(ScopeNode*) { return false; }
1388     bool isFunctionMetadataNode(FunctionMetadataNode*) { return true; }
1389 
<a name="13" id="anc13"></a><span class="line-modified">1390     ALWAYS_INLINE void next(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1391     {
1392         int lastLine = m_token.m_location.line;
1393         int lastTokenEnd = m_token.m_location.endOffset;
1394         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1395         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1396         m_lexer-&gt;setLastLineNumber(lastLine);
1397         m_token.m_type = m_lexer-&gt;lex(&amp;m_token, lexerFlags, strictMode());
1398     }
1399 
<a name="14" id="anc14"></a><span class="line-modified">1400     ALWAYS_INLINE void nextWithoutClearingLineTerminator(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1401     {
1402         int lastLine = m_token.m_location.line;
1403         int lastTokenEnd = m_token.m_location.endOffset;
1404         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1405         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1406         m_lexer-&gt;setLastLineNumber(lastLine);
1407         m_token.m_type = m_lexer-&gt;lexWithoutClearingLineTerminator(&amp;m_token, lexerFlags, strictMode());
1408     }
1409 
<a name="15" id="anc15"></a><span class="line-modified">1410     ALWAYS_INLINE void nextExpectIdentifier(OptionSet&lt;LexerFlags&gt; lexerFlags = { })</span>
1411     {
1412         int lastLine = m_token.m_location.line;
1413         int lastTokenEnd = m_token.m_location.endOffset;
1414         int lastTokenLineStart = m_token.m_location.lineStartOffset;
1415         m_lastTokenEndPosition = JSTextPosition(lastLine, lastTokenEnd, lastTokenLineStart);
1416         m_lexer-&gt;setLastLineNumber(lastLine);
1417         m_token.m_type = m_lexer-&gt;lexExpectIdentifier(&amp;m_token, lexerFlags, strictMode());
1418     }
1419 
<a name="16" id="anc16"></a><span class="line-modified">1420     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1421     ALWAYS_INLINE void lexCurrentTokenAgainUnderCurrentContext(TreeBuilder&amp; context)</span>
1422     {
<a name="17" id="anc17"></a><span class="line-modified">1423         auto savePoint = createSavePoint(context);</span>
<span class="line-modified">1424         restoreSavePoint(context, savePoint);</span>
1425     }
1426 
1427     ALWAYS_INLINE bool nextTokenIsColon()
1428     {
1429         return m_lexer-&gt;nextTokenIsColon();
1430     }
1431 
<a name="18" id="anc18"></a><span class="line-modified">1432     ALWAYS_INLINE bool consume(JSTokenType expected, OptionSet&lt;LexerFlags&gt; flags = { })</span>
1433     {
1434         bool result = m_token.m_type == expected;
1435         if (result)
1436             next(flags);
1437         return result;
1438     }
1439 
1440     void printUnexpectedTokenText(WTF::PrintStream&amp;);
1441     ALWAYS_INLINE StringView getToken()
1442     {
1443         return m_lexer-&gt;getToken(m_token);
1444     }
1445 
1446     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
1447     {
1448         return m_lexer-&gt;getToken(token);
1449     }
1450 
1451     ALWAYS_INLINE bool match(JSTokenType expected)
1452     {
1453         return m_token.m_type == expected;
1454     }
1455 
1456     ALWAYS_INLINE bool matchContextualKeyword(const Identifier&amp; identifier)
1457     {
1458         return m_token.m_type == IDENT &amp;&amp; *m_token.m_data.ident == identifier &amp;&amp; !m_token.m_data.escaped;
1459     }
1460 
1461     ALWAYS_INLINE bool matchIdentifierOrKeyword()
1462     {
1463         return isIdentifierOrKeyword(m_token);
1464     }
1465 
1466     ALWAYS_INLINE unsigned tokenStart()
1467     {
1468         return m_token.m_location.startOffset;
1469     }
1470 
1471     ALWAYS_INLINE const JSTextPosition&amp; tokenStartPosition()
1472     {
1473         return m_token.m_startPosition;
1474     }
1475 
1476     ALWAYS_INLINE int tokenLine()
1477     {
1478         return m_token.m_location.line;
1479     }
1480 
1481     ALWAYS_INLINE int tokenColumn()
1482     {
1483         return tokenStart() - tokenLineStart();
1484     }
1485 
1486     ALWAYS_INLINE const JSTextPosition&amp; tokenEndPosition()
1487     {
1488         return m_token.m_endPosition;
1489     }
1490 
1491     ALWAYS_INLINE unsigned tokenLineStart()
1492     {
1493         return m_token.m_location.lineStartOffset;
1494     }
1495 
1496     ALWAYS_INLINE const JSTokenLocation&amp; tokenLocation()
1497     {
1498         return m_token.m_location;
1499     }
1500 
1501     void setErrorMessage(const String&amp; message)
1502     {
1503         ASSERT_WITH_MESSAGE(!message.isEmpty(), &quot;Attempted to set the empty string as an error message. Likely caused by invalid UTF8 used when creating the message.&quot;);
1504         m_errorMessage = message;
1505         if (m_errorMessage.isEmpty())
1506             m_errorMessage = &quot;Unparseable script&quot;_s;
1507     }
1508 
1509     NEVER_INLINE void logError(bool);
1510     template &lt;typename... Args&gt;
1511     NEVER_INLINE void logError(bool, Args&amp;&amp;...);
1512 
1513     NEVER_INLINE void updateErrorWithNameAndMessage(const char* beforeMessage, const String&amp; name, const char* afterMessage)
1514     {
1515         m_errorMessage = makeString(beforeMessage, &quot; &#39;&quot;, name, &quot;&#39; &quot;, afterMessage);
1516     }
1517 
1518     NEVER_INLINE void updateErrorMessage(const char* msg)
1519     {
1520         ASSERT(msg);
1521         m_errorMessage = String(msg);
1522         ASSERT(!m_errorMessage.isNull());
1523     }
1524 
1525     ALWAYS_INLINE void recordPauseLocation(const JSTextPosition&amp;);
1526     ALWAYS_INLINE void recordFunctionEntryLocation(const JSTextPosition&amp;);
1527     ALWAYS_INLINE void recordFunctionLeaveLocation(const JSTextPosition&amp;);
1528 
1529     void startLoop() { currentScope()-&gt;startLoop(); }
1530     void endLoop() { currentScope()-&gt;endLoop(); }
1531     void startSwitch() { currentScope()-&gt;startSwitch(); }
1532     void endSwitch() { currentScope()-&gt;endSwitch(); }
1533     void setStrictMode() { currentScope()-&gt;setStrictMode(); }
1534     bool strictMode() { return currentScope()-&gt;strictMode(); }
1535     bool isValidStrictMode()
1536     {
1537         int i = m_scopeStack.size() - 1;
1538         if (!m_scopeStack[i].isValidStrictMode())
1539             return false;
1540 
1541         // In the case of Generator or Async function bodies, also check the wrapper function, whose name or
1542         // arguments may be invalid.
1543         if (UNLIKELY((m_scopeStack[i].isGeneratorBoundary() || m_scopeStack[i].isAsyncFunctionBoundary()) &amp;&amp; i))
1544             return m_scopeStack[i - 1].isValidStrictMode();
1545         return true;
1546     }
1547     DeclarationResultMask declareParameter(const Identifier* ident) { return currentScope()-&gt;declareParameter(ident); }
1548     bool declareRestOrNormalParameter(const Identifier&amp;, const Identifier**);
1549 
1550     bool breakIsValid()
1551     {
1552         ScopeRef current = currentScope();
1553         while (!current-&gt;breakIsValid()) {
1554             if (!current.hasContainingScope())
1555                 return false;
1556             current = current.containingScope();
1557         }
1558         return true;
1559     }
1560     bool continueIsValid()
1561     {
1562         ScopeRef current = currentScope();
1563         while (!current-&gt;continueIsValid()) {
1564             if (!current.hasContainingScope())
1565                 return false;
1566             current = current.containingScope();
1567         }
1568         return true;
1569     }
1570     void pushLabel(const Identifier* label, bool isLoop) { currentScope()-&gt;pushLabel(label, isLoop); }
1571     void popLabel(ScopeRef scope) { scope-&gt;popLabel(); }
1572     ScopeLabelInfo* getLabel(const Identifier* label)
1573     {
1574         ScopeRef current = currentScope();
1575         ScopeLabelInfo* result = 0;
1576         while (!(result = current-&gt;getLabel(label))) {
1577             if (!current.hasContainingScope())
1578                 return 0;
1579             current = current.containingScope();
1580         }
1581         return result;
1582     }
1583 
1584     // http://ecma-international.org/ecma-262/6.0/#sec-identifiers-static-semantics-early-errors
1585     ALWAYS_INLINE bool isLETMaskedAsIDENT()
1586     {
1587         return match(LET) &amp;&amp; !strictMode();
1588     }
1589 
1590     // http://ecma-international.org/ecma-262/6.0/#sec-identifiers-static-semantics-early-errors
1591     ALWAYS_INLINE bool isYIELDMaskedAsIDENT(bool inGenerator)
1592     {
1593         return match(YIELD) &amp;&amp; !strictMode() &amp;&amp; !inGenerator;
1594     }
1595 
1596     // http://ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions-static-semantics-early-errors
1597     ALWAYS_INLINE bool matchSpecIdentifier(bool inGenerator)
1598     {
1599         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(inGenerator) || isSafeContextualKeyword(m_token);
1600     }
1601 
1602     ALWAYS_INLINE bool matchSpecIdentifier()
1603     {
1604         return match(IDENT) || isLETMaskedAsIDENT() || isYIELDMaskedAsIDENT(currentScope()-&gt;isGenerator()) || isSafeContextualKeyword(m_token);
1605     }
1606 
1607     template &lt;class TreeBuilder&gt; TreeSourceElements parseSourceElements(TreeBuilder&amp;, SourceElementsMode);
1608     template &lt;class TreeBuilder&gt; TreeSourceElements parseGeneratorFunctionSourceElements(TreeBuilder&amp;, const Identifier&amp; name, SourceElementsMode);
1609     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1610     template &lt;class TreeBuilder&gt; TreeSourceElements parseAsyncGeneratorFunctionSourceElements(TreeBuilder&amp;, SourceParseMode, bool isArrowFunctionBodyExpression, SourceElementsMode);
1611     template &lt;class TreeBuilder&gt; TreeSourceElements parseSingleFunction(TreeBuilder&amp;, Optional&lt;int&gt; functionConstructorParametersEndPosition);
<a name="19" id="anc19"></a><span class="line-added">1612     template &lt;class TreeBuilder&gt; TreeSourceElements parseInstanceFieldInitializerSourceElements(TreeBuilder&amp;, const Vector&lt;JSTextPosition&gt;&amp;);</span>
1613     template &lt;class TreeBuilder&gt; TreeStatement parseStatementListItem(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength);
1614     template &lt;class TreeBuilder&gt; TreeStatement parseStatement(TreeBuilder&amp;, const Identifier*&amp; directive, unsigned* directiveLiteralLength = 0);
1615     enum class ExportType { Exported, NotExported };
1616     template &lt;class TreeBuilder&gt; TreeStatement parseClassDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard);
1617     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1618     template &lt;class TreeBuilder&gt; TreeStatement parseFunctionDeclarationStatement(TreeBuilder&amp;, bool isAsync, bool parentAllowsFunctionDeclarationAsStatement);
1619     template &lt;class TreeBuilder&gt; TreeStatement parseAsyncFunctionDeclaration(TreeBuilder&amp;, ExportType = ExportType::NotExported, DeclarationDefaultContext = DeclarationDefaultContext::Standard, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1620     template &lt;class TreeBuilder&gt; NEVER_INLINE bool maybeParseAsyncFunctionDeclarationStatement(TreeBuilder&amp; context, TreeStatement&amp; result, bool parentAllowsFunctionDeclarationAsStatement);
1621     template &lt;class TreeBuilder&gt; TreeStatement parseVariableDeclaration(TreeBuilder&amp;, DeclarationType, ExportType = ExportType::NotExported);
1622     template &lt;class TreeBuilder&gt; TreeStatement parseDoWhileStatement(TreeBuilder&amp;);
1623     template &lt;class TreeBuilder&gt; TreeStatement parseWhileStatement(TreeBuilder&amp;);
1624     template &lt;class TreeBuilder&gt; TreeStatement parseForStatement(TreeBuilder&amp;);
1625     template &lt;class TreeBuilder&gt; TreeStatement parseBreakStatement(TreeBuilder&amp;);
1626     template &lt;class TreeBuilder&gt; TreeStatement parseContinueStatement(TreeBuilder&amp;);
1627     template &lt;class TreeBuilder&gt; TreeStatement parseReturnStatement(TreeBuilder&amp;);
1628     template &lt;class TreeBuilder&gt; TreeStatement parseThrowStatement(TreeBuilder&amp;);
1629     template &lt;class TreeBuilder&gt; TreeStatement parseWithStatement(TreeBuilder&amp;);
1630     template &lt;class TreeBuilder&gt; TreeStatement parseSwitchStatement(TreeBuilder&amp;);
1631     template &lt;class TreeBuilder&gt; TreeClauseList parseSwitchClauses(TreeBuilder&amp;);
1632     template &lt;class TreeBuilder&gt; TreeClause parseSwitchDefaultClause(TreeBuilder&amp;);
1633     template &lt;class TreeBuilder&gt; TreeStatement parseTryStatement(TreeBuilder&amp;);
1634     template &lt;class TreeBuilder&gt; TreeStatement parseDebuggerStatement(TreeBuilder&amp;);
1635     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionStatement(TreeBuilder&amp;);
1636     template &lt;class TreeBuilder&gt; TreeStatement parseExpressionOrLabelStatement(TreeBuilder&amp;, bool allowFunctionDeclarationAsStatement);
1637     template &lt;class TreeBuilder&gt; TreeStatement parseIfStatement(TreeBuilder&amp;);
1638     template &lt;class TreeBuilder&gt; TreeStatement parseBlockStatement(TreeBuilder&amp;);
1639     template &lt;class TreeBuilder&gt; TreeExpression parseExpression(TreeBuilder&amp;);
1640     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;, ExpressionErrorClassifier&amp;);
1641     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpression(TreeBuilder&amp;);
1642     template &lt;class TreeBuilder&gt; TreeExpression parseAssignmentExpressionOrPropagateErrorClass(TreeBuilder&amp;);
1643     template &lt;class TreeBuilder&gt; TreeExpression parseYieldExpression(TreeBuilder&amp;);
1644     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseConditionalExpression(TreeBuilder&amp;);
1645     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseBinaryExpression(TreeBuilder&amp;);
1646     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseUnaryExpression(TreeBuilder&amp;);
1647     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseAwaitExpression(TreeBuilder&amp;);
1648     template &lt;class TreeBuilder&gt; TreeExpression parseMemberExpression(TreeBuilder&amp;);
1649     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parsePrimaryExpression(TreeBuilder&amp;);
1650     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArrayLiteral(TreeBuilder&amp;);
1651     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseObjectLiteral(TreeBuilder&amp;);
<a name="20" id="anc20"></a>
1652     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeClassExpression parseClassExpression(TreeBuilder&amp;);
1653     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseFunctionExpression(TreeBuilder&amp;);
1654     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseAsyncFunctionExpression(TreeBuilder&amp;);
1655     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeArguments parseArguments(TreeBuilder&amp;);
1656     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression parseArgument(TreeBuilder&amp;, ArgumentType&amp;);
1657     template &lt;class TreeBuilder&gt; TreeProperty parseProperty(TreeBuilder&amp;, bool strict);
1658     template &lt;class TreeBuilder&gt; TreeExpression parsePropertyMethod(TreeBuilder&amp; context, const Identifier* methodName, SourceParseMode);
1659     template &lt;class TreeBuilder&gt; TreeProperty parseGetterSetter(TreeBuilder&amp;, bool strict, PropertyNode::Type, unsigned getterOrSetterStartOffset, ConstructorKind, ClassElementTag);
1660     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeFunctionBody parseFunctionBody(TreeBuilder&amp;, SyntaxChecker&amp;, const JSTokenLocation&amp;, int, int functionKeywordStart, int functionNameStart, int parametersStart, ConstructorKind, SuperBinding, FunctionBodyType, unsigned, SourceParseMode);
1661     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool parseFormalParameters(TreeBuilder&amp;, TreeFormalParameterList, bool isArrowFunction, bool isMethod, unsigned&amp;);
1662     enum VarDeclarationListContext { ForLoopContext, VarDeclarationContext };
1663     template &lt;class TreeBuilder&gt; TreeExpression parseVariableDeclarationList(TreeBuilder&amp;, int&amp; declarations, TreeDestructuringPattern&amp; lastPattern, TreeExpression&amp; lastInitializer, JSTextPosition&amp; identStart, JSTextPosition&amp; initStart, JSTextPosition&amp; initEnd, VarDeclarationListContext, DeclarationType, ExportType, bool&amp; forLoopConstDoesNotHaveInitializer);
1664     template &lt;class TreeBuilder&gt; TreeSourceElements parseArrowFunctionSingleExpressionBodySourceElements(TreeBuilder&amp;);
1665     template &lt;class TreeBuilder&gt; TreeExpression parseArrowFunctionExpression(TreeBuilder&amp;, bool isAsync);
<a name="21" id="anc21"></a><span class="line-modified">1666     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createBindingPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier&amp;, const JSToken&amp;, AssignmentContext, const Identifier** duplicateIdentifier);</span>
1667     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern createAssignmentElement(TreeBuilder&amp;, TreeExpression&amp;, const JSTextPosition&amp;, const JSTextPosition&amp;);
1668     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, AssignmentContext bindingContext);
1669     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseBindingOrAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1670     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestAssignmentElement(TreeBuilder&amp; context);
1671     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseAssignmentElement(TreeBuilder&amp; context, DestructuringKind, ExportType, const Identifier** duplicateIdentifier, bool* hasDestructuringPattern, AssignmentContext bindingContext, int depth);
1672     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseObjectRestElement(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement);
1673     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern parseDestructuringPattern(TreeBuilder&amp;, DestructuringKind, ExportType, const Identifier** duplicateIdentifier = nullptr, bool* hasDestructuringPattern = nullptr, AssignmentContext = AssignmentContext::DeclarationStatement, int depth = 0);
1674     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeDestructuringPattern tryParseDestructuringPatternExpression(TreeBuilder&amp;, AssignmentContext);
1675     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeExpression parseDefaultValueForDestructuringPattern(TreeBuilder&amp;);
1676     template &lt;class TreeBuilder&gt; TreeSourceElements parseModuleSourceElements(TreeBuilder&amp;, SourceParseMode);
1677     enum class ImportSpecifierType { NamespaceImport, NamedImport, DefaultImport };
1678     template &lt;class TreeBuilder&gt; typename TreeBuilder::ImportSpecifier parseImportClauseItem(TreeBuilder&amp;, ImportSpecifierType);
1679     template &lt;class TreeBuilder&gt; typename TreeBuilder::ModuleName parseModuleName(TreeBuilder&amp;);
1680     template &lt;class TreeBuilder&gt; TreeStatement parseImportDeclaration(TreeBuilder&amp;);
1681     template &lt;class TreeBuilder&gt; typename TreeBuilder::ExportSpecifier parseExportSpecifier(TreeBuilder&amp; context, Vector&lt;std::pair&lt;const Identifier*, const Identifier*&gt;&gt;&amp; maybeExportedLocalNames, bool&amp; hasKeywordForLocalBindings);
1682     template &lt;class TreeBuilder&gt; TreeStatement parseExportDeclaration(TreeBuilder&amp;);
1683 
1684     template &lt;class TreeBuilder&gt; ALWAYS_INLINE TreeExpression createResolveAndUseVariable(TreeBuilder&amp;, const Identifier*, bool isEval, const JSTextPosition&amp;, const JSTokenLocation&amp;);
1685 
1686     enum class FunctionDefinitionType { Expression, Declaration, Method };
1687     template &lt;class TreeBuilder&gt; NEVER_INLINE bool parseFunctionInfo(TreeBuilder&amp;, FunctionNameRequirements, SourceParseMode, bool nameIsInContainingScope, ConstructorKind, SuperBinding, int functionKeywordStart, ParserFunctionInfo&lt;TreeBuilder&gt;&amp;, FunctionDefinitionType, Optional&lt;int&gt; functionConstructorParametersEndPosition = WTF::nullopt);
1688 
<a name="22" id="anc22"></a><span class="line-modified">1689     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isArrowFunctionParameters(TreeBuilder&amp;);</span>
1690 
1691     template &lt;class TreeBuilder, class FunctionInfoType&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList parseFunctionParameters(TreeBuilder&amp;, SourceParseMode, FunctionInfoType&amp;);
1692     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::FormalParameterList createGeneratorParameters(TreeBuilder&amp;, unsigned&amp; parameterCount);
1693 
1694     template &lt;class TreeBuilder&gt; NEVER_INLINE TreeClassExpression parseClass(TreeBuilder&amp;, FunctionNameRequirements, ParserClassInfo&lt;TreeBuilder&gt;&amp;);
1695 
1696     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateString parseTemplateString(TreeBuilder&amp; context, bool isTemplateHead, typename LexerType::RawStringsBuildMode, bool&amp; elementIsTail);
1697     template &lt;class TreeBuilder&gt; NEVER_INLINE typename TreeBuilder::TemplateLiteral parseTemplateLiteral(TreeBuilder&amp;, typename LexerType::RawStringsBuildMode);
1698 
1699     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool shouldCheckPropertyForUnderscoreProtoDuplicate(TreeBuilder&amp;, const TreeProperty&amp;);
1700 
1701     template &lt;class TreeBuilder&gt; NEVER_INLINE const char* metaPropertyName(TreeBuilder&amp;, TreeExpression);
1702 
1703     template &lt;class TreeBuilder&gt; ALWAYS_INLINE bool isSimpleAssignmentTarget(TreeBuilder&amp;, TreeExpression);
1704 
1705     ALWAYS_INLINE int isBinaryOperator(JSTokenType);
1706     bool allowAutomaticSemicolon();
1707 
1708     bool autoSemiColon()
1709     {
1710         if (m_token.m_type == SEMICOLON) {
1711             next();
1712             return true;
1713         }
1714         return allowAutomaticSemicolon();
1715     }
1716 
1717     bool canRecurse()
1718     {
1719         return m_vm.isSafeToRecurse();
1720     }
1721 
1722     const JSTextPosition&amp; lastTokenEndPosition() const
1723     {
1724         return m_lastTokenEndPosition;
1725     }
1726 
1727     bool hasError() const
1728     {
1729         return !m_errorMessage.isNull();
1730     }
1731 
1732     bool isDisallowedIdentifierLet(const JSToken&amp; token)
1733     {
1734         return token.m_type == LET &amp;&amp; strictMode();
1735     }
1736 
1737     bool isDisallowedIdentifierAwait(const JSToken&amp; token)
1738     {
1739         return token.m_type == AWAIT &amp;&amp; (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary() || m_scriptMode == JSParserScriptMode::Module);
1740     }
1741 
1742     bool isDisallowedIdentifierYield(const JSToken&amp; token)
1743     {
1744         return token.m_type == YIELD &amp;&amp; (strictMode() || currentScope()-&gt;isGenerator());
1745     }
1746 
1747     ALWAYS_INLINE SuperBinding adjustSuperBindingForBaseConstructor(ConstructorKind constructorKind, SuperBinding superBinding, ScopeRef functionScope)
1748     {
1749         return adjustSuperBindingForBaseConstructor(constructorKind, superBinding, functionScope-&gt;needsSuperBinding(), functionScope-&gt;usesEval(), functionScope-&gt;innerArrowFunctionFeatures());
1750     }
1751 
1752     ALWAYS_INLINE SuperBinding adjustSuperBindingForBaseConstructor(ConstructorKind constructorKind, SuperBinding superBinding, bool scopeNeedsSuperBinding, bool currentScopeUsesEval, InnerArrowFunctionCodeFeatures innerArrowFunctionFeatures)
1753     {
1754         SuperBinding methodSuperBinding = superBinding;
1755 
1756         if (constructorKind == ConstructorKind::Base) {
1757             bool isSuperUsedInInnerArrowFunction = innerArrowFunctionFeatures &amp; SuperPropertyInnerArrowFunctionFeature;
1758             methodSuperBinding = (scopeNeedsSuperBinding || isSuperUsedInInnerArrowFunction || currentScopeUsesEval) ? SuperBinding::Needed : SuperBinding::NotNeeded;
1759         }
1760 
1761         return methodSuperBinding;
1762     }
1763 
1764     const char* disallowedIdentifierLetReason()
1765     {
1766         ASSERT(strictMode());
1767         return &quot;in strict mode&quot;;
1768     }
1769 
1770     const char* disallowedIdentifierAwaitReason()
1771     {
1772         if (!m_parserState.allowAwait || currentScope()-&gt;isAsyncFunctionBoundary())
1773             return &quot;in an async function&quot;;
1774         if (m_scriptMode == JSParserScriptMode::Module)
1775             return &quot;in a module&quot;;
1776         RELEASE_ASSERT_NOT_REACHED();
1777         return nullptr;
1778     }
1779 
1780     const char* disallowedIdentifierYieldReason()
1781     {
1782         if (strictMode())
1783             return &quot;in strict mode&quot;;
1784         if (currentScope()-&gt;isGenerator())
1785             return &quot;in a generator function&quot;;
1786         RELEASE_ASSERT_NOT_REACHED();
1787         return nullptr;
1788     }
1789 
1790     enum class FunctionParsePhase { Parameters, Body };
1791     struct ParserState {
1792         int assignmentCount { 0 };
1793         int nonLHSCount { 0 };
1794         int nonTrivialExpressionCount { 0 };
<a name="23" id="anc23"></a><span class="line-added">1795         int unaryTokenStackDepth { 0 };</span>
1796         FunctionParsePhase functionParsePhase { FunctionParsePhase::Body };
1797         const Identifier* lastIdentifier { nullptr };
1798         const Identifier* lastFunctionName { nullptr };
1799         bool allowAwait { true };
<a name="24" id="anc24"></a><span class="line-added">1800         bool isParsingClassFieldInitializer { false };</span>
1801     };
1802 
1803     // If you&#39;re using this directly, you probably should be using
1804     // createSavePoint() instead.
<a name="25" id="anc25"></a><span class="line-modified">1805     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1806     ALWAYS_INLINE ParserState internalSaveParserState(TreeBuilder&amp; context)</span>
1807     {
<a name="26" id="anc26"></a><span class="line-modified">1808         auto parserState = m_parserState;</span>
<span class="line-added">1809         parserState.unaryTokenStackDepth = context.unaryTokenStackDepth();</span>
<span class="line-added">1810         return parserState;</span>
1811     }
1812 
<a name="27" id="anc27"></a><span class="line-modified">1813     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1814     ALWAYS_INLINE void restoreParserState(TreeBuilder&amp; context, const ParserState&amp; state)</span>
1815     {
1816         m_parserState = state;
<a name="28" id="anc28"></a><span class="line-added">1817         context.setUnaryTokenStackDepth(m_parserState.unaryTokenStackDepth);</span>
1818     }
1819 
1820     struct LexerState {
1821         int startOffset;
1822         unsigned oldLineStartOffset;
1823         unsigned oldLastLineNumber;
1824         unsigned oldLineNumber;
1825         bool hasLineTerminatorBeforeToken;
1826     };
1827 
1828     // If you&#39;re using this directly, you probably should be using
1829     // createSavePoint() instead.
1830     // i.e, if you parse any kind of AssignmentExpression between
1831     // saving/restoring, you should definitely not be using this directly.
1832     ALWAYS_INLINE LexerState internalSaveLexerState()
1833     {
1834         LexerState result;
1835         result.startOffset = m_token.m_location.startOffset;
1836         result.oldLineStartOffset = m_token.m_location.lineStartOffset;
1837         result.oldLastLineNumber = m_lexer-&gt;lastLineNumber();
1838         result.oldLineNumber = m_lexer-&gt;lineNumber();
1839         result.hasLineTerminatorBeforeToken = m_lexer-&gt;hasLineTerminatorBeforeToken();
1840         ASSERT(static_cast&lt;unsigned&gt;(result.startOffset) &gt;= result.oldLineStartOffset);
1841         return result;
1842     }
1843 
1844     ALWAYS_INLINE void restoreLexerState(const LexerState&amp; lexerState)
1845     {
1846         // setOffset clears lexer errors.
1847         m_lexer-&gt;setOffset(lexerState.startOffset, lexerState.oldLineStartOffset);
1848         m_lexer-&gt;setLineNumber(lexerState.oldLineNumber);
1849         m_lexer-&gt;setHasLineTerminatorBeforeToken(lexerState.hasLineTerminatorBeforeToken);
1850         nextWithoutClearingLineTerminator();
1851         m_lexer-&gt;setLastLineNumber(lexerState.oldLastLineNumber);
1852     }
1853 
1854     struct SavePoint {
1855         ParserState parserState;
1856         LexerState lexerState;
1857     };
1858 
1859     struct SavePointWithError : public SavePoint {
1860         bool lexerError;
1861         String lexerErrorMessage;
1862         String parserErrorMessage;
1863     };
1864 
<a name="29" id="anc29"></a><span class="line-modified">1865     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1866     ALWAYS_INLINE void internalSaveState(TreeBuilder&amp; context, SavePoint&amp; savePoint)</span>
1867     {
<a name="30" id="anc30"></a><span class="line-modified">1868         savePoint.parserState = internalSaveParserState(context);</span>
1869         savePoint.lexerState = internalSaveLexerState();
1870     }
1871 
<a name="31" id="anc31"></a><span class="line-modified">1872     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1873     ALWAYS_INLINE SavePointWithError swapSavePointForError(TreeBuilder&amp; context, SavePoint&amp; oldSavePoint)</span>
1874     {
1875         SavePointWithError savePoint;
<a name="32" id="anc32"></a><span class="line-modified">1876         internalSaveState(context, savePoint);</span>
1877         savePoint.lexerError = m_lexer-&gt;sawError();
1878         savePoint.lexerErrorMessage = m_lexer-&gt;getErrorMessage();
1879         savePoint.parserErrorMessage = m_errorMessage;
<a name="33" id="anc33"></a><span class="line-added">1880         // Make sure we set our new savepoints unary stack to what oldSavePoint had as it currently may contain stale info.</span>
<span class="line-added">1881         savePoint.parserState.unaryTokenStackDepth = oldSavePoint.parserState.unaryTokenStackDepth;</span>
<span class="line-added">1882         restoreSavePoint(context, oldSavePoint);</span>
1883         return savePoint;
1884     }
1885 
<a name="34" id="anc34"></a><span class="line-modified">1886     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1887     ALWAYS_INLINE SavePoint createSavePoint(TreeBuilder&amp; context)</span>
1888     {
1889         ASSERT(!hasError());
1890         SavePoint savePoint;
<a name="35" id="anc35"></a><span class="line-modified">1891         internalSaveState(context, savePoint);</span>
1892         return savePoint;
1893     }
1894 
<a name="36" id="anc36"></a><span class="line-modified">1895     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1896     ALWAYS_INLINE void internalRestoreState(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
1897     {
1898         restoreLexerState(savePoint.lexerState);
<a name="37" id="anc37"></a><span class="line-modified">1899         restoreParserState(context, savePoint.parserState);</span>
1900     }
1901 
<a name="38" id="anc38"></a><span class="line-modified">1902     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1903     ALWAYS_INLINE void restoreSavePointWithError(TreeBuilder&amp; context, const SavePointWithError&amp; savePoint)</span>
1904     {
<a name="39" id="anc39"></a><span class="line-modified">1905         internalRestoreState(context, savePoint);</span>
1906         m_lexer-&gt;setSawError(savePoint.lexerError);
1907         m_lexer-&gt;setErrorMessage(savePoint.lexerErrorMessage);
1908         m_errorMessage = savePoint.parserErrorMessage;
1909     }
1910 
<a name="40" id="anc40"></a><span class="line-modified">1911     template &lt;class TreeBuilder&gt;</span>
<span class="line-added">1912     ALWAYS_INLINE void restoreSavePoint(TreeBuilder&amp; context, const SavePoint&amp; savePoint)</span>
1913     {
<a name="41" id="anc41"></a><span class="line-modified">1914         internalRestoreState(context, savePoint);</span>
1915         m_errorMessage = String();
1916     }
1917 
1918     VM&amp; m_vm;
1919     const SourceCode* m_source;
1920     ParserArena m_parserArena;
1921     std::unique_ptr&lt;LexerType&gt; m_lexer;
<a name="42" id="anc42"></a>
1922 
1923     ParserState m_parserState;
1924 
1925     bool m_hasStackOverflow;
1926     String m_errorMessage;
1927     JSToken m_token;
1928     bool m_allowsIn;
1929     JSTextPosition m_lastTokenEndPosition;
1930     int m_statementDepth;
1931     RefPtr&lt;SourceProviderCache&gt; m_functionCache;
<a name="43" id="anc43"></a>
1932     bool m_parsingBuiltin;
1933     JSParserScriptMode m_scriptMode;
1934     SuperBinding m_superBinding;
<a name="44" id="anc44"></a><span class="line-modified">1935     ConstructorKind m_defaultConstructorKindForTopLevelFunction;</span>





1936     ExpressionErrorClassifier* m_expressionErrorClassifier;
1937     bool m_isEvalContext;
1938     bool m_immediateParentAllowsFunctionDeclarationInStatement;
1939     RefPtr&lt;ModuleScopeData&gt; m_moduleScopeData;
1940     DebuggerParseData* m_debuggerParseData;
1941     CallOrApplyDepthScope* m_callOrApplyDepthScope { nullptr };
1942     bool m_seenTaggedTemplate { false };
1943 };
1944 
1945 
1946 template &lt;typename LexerType&gt;
1947 template &lt;class ParsedNode&gt;
<a name="45" id="anc45"></a><span class="line-modified">1948 std::unique_ptr&lt;ParsedNode&gt; Parser&lt;LexerType&gt;::parse(ParserError&amp; error, const Identifier&amp; calleeName, SourceParseMode parseMode, ParsingContext parsingContext, Optional&lt;int&gt; functionConstructorParametersEndPosition, const Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
1949 {
1950     int errLine;
1951     String errMsg;
1952 
1953     if (ParsedNode::scopeIsFunction)
1954         m_lexer-&gt;setIsReparsingFunction();
1955 
<a name="46" id="anc46"></a>

1956     errLine = -1;
1957     errMsg = String();
1958 
1959     JSTokenLocation startLocation(tokenLocation());
1960     ASSERT(m_source-&gt;startColumn() &gt; OrdinalNumber::beforeFirst());
1961     unsigned startColumn = m_source-&gt;startColumn().zeroBasedInt();
1962 
<a name="47" id="anc47"></a><span class="line-modified">1963     auto parseResult = parseInner(calleeName, parseMode, parsingContext, functionConstructorParametersEndPosition, instanceFieldLocations);</span>
1964 
1965     int lineNumber = m_lexer-&gt;lineNumber();
1966     bool lexError = m_lexer-&gt;sawError();
1967     String lexErrorMessage = lexError ? m_lexer-&gt;getErrorMessage() : String();
1968     ASSERT(lexErrorMessage.isNull() != lexError);
1969     m_lexer-&gt;clear();
1970 
<a name="48" id="anc48"></a><span class="line-modified">1971     if (!parseResult || lexError) {</span>
1972         errLine = lineNumber;
<a name="49" id="anc49"></a><span class="line-modified">1973         errMsg = !lexErrorMessage.isNull() ? lexErrorMessage : parseResult.error();</span>

1974     }
1975 
1976     std::unique_ptr&lt;ParsedNode&gt; result;
<a name="50" id="anc50"></a><span class="line-modified">1977     if (parseResult) {</span>
1978         JSTokenLocation endLocation;
1979         endLocation.line = m_lexer-&gt;lineNumber();
1980         endLocation.lineStartOffset = m_lexer-&gt;currentLineStartOffset();
1981         endLocation.startOffset = m_lexer-&gt;currentOffset();
1982         unsigned endColumn = endLocation.startOffset - endLocation.lineStartOffset;
1983         result = makeUnique&lt;ParsedNode&gt;(m_parserArena,
1984                                     startLocation,
1985                                     endLocation,
1986                                     startColumn,
1987                                     endColumn,
<a name="51" id="anc51"></a><span class="line-modified">1988                                     parseResult.value().sourceElements,</span>
<span class="line-modified">1989                                     parseResult.value().varDeclarations,</span>
<span class="line-modified">1990                                     WTFMove(parseResult.value().functionDeclarations),</span>
1991                                     currentScope()-&gt;finalizeLexicalEnvironment(),
<a name="52" id="anc52"></a><span class="line-modified">1992                                     WTFMove(parseResult.value().sloppyModeHoistedFunctions),</span>
<span class="line-modified">1993                                     parseResult.value().parameters,</span>
1994                                     *m_source,
<a name="53" id="anc53"></a><span class="line-modified">1995                                     parseResult.value().features,</span>
1996                                     currentScope()-&gt;innerArrowFunctionFeatures(),
<a name="54" id="anc54"></a><span class="line-modified">1997                                     parseResult.value().numConstants,</span>
1998                                     WTFMove(m_moduleScopeData));
1999         result-&gt;setLoc(m_source-&gt;firstLine().oneBasedInt(), m_lexer-&gt;lineNumber(), m_lexer-&gt;currentOffset(), m_lexer-&gt;currentLineStartOffset());
2000         result-&gt;setEndOffset(m_lexer-&gt;currentOffset());
2001 
2002         if (!isFunctionParseMode(parseMode)) {
2003             m_source-&gt;provider()-&gt;setSourceURLDirective(m_lexer-&gt;sourceURLDirective());
2004             m_source-&gt;provider()-&gt;setSourceMappingURLDirective(m_lexer-&gt;sourceMappingURLDirective());
2005         }
2006     } else {
2007         // We can never see a syntax error when reparsing a function, since we should have
2008         // reported the error when parsing the containing program or eval code. So if we&#39;re
2009         // parsing a function body node, we assume that what actually happened here is that
2010         // we ran out of stack while parsing. If we see an error while parsing eval or program
2011         // code we assume that it was a syntax error since running out of stack is much less
2012         // likely, and we are currently unable to distinguish between the two cases.
2013         if (isFunctionMetadataNode(static_cast&lt;ParsedNode*&gt;(0)) || m_hasStackOverflow)
2014             error = ParserError(ParserError::StackOverflow, ParserError::SyntaxErrorNone, m_token);
2015         else {
2016             ParserError::SyntaxErrorType errorType = ParserError::SyntaxErrorIrrecoverable;
2017             if (m_token.m_type == EOFTOK)
2018                 errorType = ParserError::SyntaxErrorRecoverable;
2019             else if (m_token.m_type &amp; UnterminatedErrorTokenFlag) {
2020                 // Treat multiline capable unterminated literals as recoverable.
2021                 if (m_token.m_type == UNTERMINATED_MULTILINE_COMMENT_ERRORTOK || m_token.m_type == UNTERMINATED_TEMPLATE_LITERAL_ERRORTOK)
2022                     errorType = ParserError::SyntaxErrorRecoverable;
2023                 else
2024                     errorType = ParserError::SyntaxErrorUnterminatedLiteral;
2025             }
2026 
2027             if (isEvalNode&lt;ParsedNode&gt;())
2028                 error = ParserError(ParserError::EvalError, errorType, m_token, errMsg, errLine);
2029             else
2030                 error = ParserError(ParserError::SyntaxError, errorType, m_token, errMsg, errLine);
2031         }
2032     }
2033 
2034     return result;
2035 }
2036 
2037 template &lt;class ParsedNode&gt;
2038 std::unique_ptr&lt;ParsedNode&gt; parse(
2039     VM&amp; vm, const SourceCode&amp; source,
2040     const Identifier&amp; name, JSParserBuiltinMode builtinMode,
2041     JSParserStrictMode strictMode, JSParserScriptMode scriptMode, SourceParseMode parseMode, SuperBinding superBinding,
2042     ParserError&amp; error, JSTextPosition* positionBeforeLastNewline = nullptr,
<a name="55" id="anc55"></a><span class="line-modified">2043     ConstructorKind defaultConstructorKindForTopLevelFunction = ConstructorKind::None,</span>
2044     DerivedContextType derivedContextType = DerivedContextType::None,
2045     EvalContextType evalContextType = EvalContextType::None,
<a name="56" id="anc56"></a><span class="line-modified">2046     DebuggerParseData* debuggerParseData = nullptr,</span>
<span class="line-added">2047     const Vector&lt;JSTextPosition&gt;* instanceFieldLocations = nullptr)</span>
2048 {
2049     ASSERT(!source.provider()-&gt;source().isNull());
2050 
2051     MonotonicTime before;
2052     if (UNLIKELY(Options::reportParseTimes()))
2053         before = MonotonicTime::now();
2054 
2055     std::unique_ptr&lt;ParsedNode&gt; result;
2056     if (source.provider()-&gt;source().is8Bit()) {
<a name="57" id="anc57"></a><span class="line-modified">2057         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2058         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
2059         if (positionBeforeLastNewline)
2060             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2061         if (builtinMode == JSParserBuiltinMode::Builtin) {
2062             if (!result) {
2063                 ASSERT(error.isValid());
2064                 if (error.type() != ParserError::StackOverflow)
2065                     dataLogLn(&quot;Unexpected error compiling builtin: &quot;, error.message());
2066             }
2067         }
2068     } else {
<a name="58" id="anc58"></a><span class="line-modified">2069         ASSERT_WITH_MESSAGE(defaultConstructorKindForTopLevelFunction == ConstructorKind::None, &quot;BuiltinExecutables&#39;s special constructors should always use a 8-bit string&quot;);</span>
<span class="line-modified">2070         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, builtinMode, strictMode, scriptMode, parseMode, superBinding, defaultConstructorKindForTopLevelFunction, derivedContextType, isEvalNode&lt;ParsedNode&gt;(), evalContextType, debuggerParseData);</span>
<span class="line-modified">2071         result = parser.parse&lt;ParsedNode&gt;(error, name, parseMode, isEvalNode&lt;ParsedNode&gt;() ? ParsingContext::Eval : ParsingContext::Program, WTF::nullopt, instanceFieldLocations);</span>
2072         if (positionBeforeLastNewline)
2073             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2074     }
2075 
2076     if (UNLIKELY(Options::countParseTimes()))
2077         globalParseCount++;
2078 
2079     if (UNLIKELY(Options::reportParseTimes())) {
2080         MonotonicTime after = MonotonicTime::now();
2081         ParseHash hash(source);
2082         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2083     }
2084 
2085     return result;
2086 }
2087 
2088 inline std::unique_ptr&lt;ProgramNode&gt; parseFunctionForFunctionConstructor(VM&amp; vm, const SourceCode&amp; source, ParserError&amp; error, JSTextPosition* positionBeforeLastNewline, Optional&lt;int&gt; functionConstructorParametersEndPosition)
2089 {
2090     ASSERT(!source.provider()-&gt;source().isNull());
2091 
2092     MonotonicTime before;
2093     if (UNLIKELY(Options::reportParseTimes()))
2094         before = MonotonicTime::now();
2095 
2096     Identifier name;
2097     bool isEvalNode = false;
2098     std::unique_ptr&lt;ProgramNode&gt; result;
2099     if (source.provider()-&gt;source().is8Bit()) {
2100         Parser&lt;Lexer&lt;LChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);
2101         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2102         if (positionBeforeLastNewline)
2103             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2104     } else {
2105         Parser&lt;Lexer&lt;UChar&gt;&gt; parser(vm, source, JSParserBuiltinMode::NotBuiltin, JSParserStrictMode::NotStrict, JSParserScriptMode::Classic, SourceParseMode::ProgramMode, SuperBinding::NotNeeded, ConstructorKind::None, DerivedContextType::None, isEvalNode, EvalContextType::None, nullptr);
2106         result = parser.parse&lt;ProgramNode&gt;(error, name, SourceParseMode::ProgramMode, ParsingContext::FunctionConstructor, functionConstructorParametersEndPosition);
2107         if (positionBeforeLastNewline)
2108             *positionBeforeLastNewline = parser.positionBeforeLastNewline();
2109     }
2110 
2111     if (UNLIKELY(Options::countParseTimes()))
2112         globalParseCount++;
2113 
2114     if (UNLIKELY(Options::reportParseTimes())) {
2115         MonotonicTime after = MonotonicTime::now();
2116         ParseHash hash(source);
2117         dataLogLn(result ? &quot;Parsed #&quot; : &quot;Failed to parse #&quot;, hash.hashForCall(), &quot;/#&quot;, hash.hashForConstruct(), &quot; in &quot;, (after - before).milliseconds(), &quot; ms.&quot;);
2118     }
2119 
2120     return result;
2121 }
2122 
2123 
2124 } // namespace
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGenericTypedArrayViewConstructorInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewPrototypeFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ArrayBufferView.h&quot;
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Error.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;JSArrayBuffer.h&quot;

 33 #include &quot;JSGenericTypedArrayView.h&quot;
 34 #include &quot;TypeError.h&quot;
 35 #include &quot;TypedArrays.h&quot;
 36 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 37 
 38 namespace JSC {
 39 
 40 template&lt;typename Adaptor&gt;
 41 JSGenericTypedArrayView&lt;Adaptor&gt;::JSGenericTypedArrayView(
 42     VM&amp; vm, ConstructionContext&amp; context)
 43     : Base(vm, context)
 44 {
 45 }
 46 
 47 template&lt;typename Adaptor&gt;
 48 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified"> 49     ExecState* exec, Structure* structure, unsigned length)</span>
 50 {
<span class="line-modified"> 51     VM&amp; vm = exec-&gt;vm();</span>
 52     auto scope = DECLARE_THROW_SCOPE(vm);
 53     ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
 54     if (!context) {
<span class="line-modified"> 55         throwOutOfMemoryError(exec, scope);</span>
 56         return nullptr;
 57     }
 58     JSGenericTypedArrayView* result =
 59         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 60         JSGenericTypedArrayView(vm, context);
 61     result-&gt;finishCreation(vm);
 62     return result;
 63 }
 64 
 65 template&lt;typename Adaptor&gt;
 66 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createWithFastVector(
<span class="line-modified"> 67     ExecState* exec, Structure* structure, unsigned length, void* vector)</span>
 68 {
<span class="line-modified"> 69     VM&amp; vm = exec-&gt;vm();</span>
 70     ConstructionContext context(structure, length, vector);
 71     RELEASE_ASSERT(context);
 72     JSGenericTypedArrayView* result =
 73         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 74         JSGenericTypedArrayView(vm, context);
 75     result-&gt;finishCreation(vm);
 76     return result;
 77 }
 78 
 79 template&lt;typename Adaptor&gt;
<span class="line-modified"> 80 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createUninitialized(ExecState* exec, Structure* structure, unsigned length)</span>
 81 {
<span class="line-modified"> 82     VM&amp; vm = exec-&gt;vm();</span>
 83     auto scope = DECLARE_THROW_SCOPE(vm);
 84     ConstructionContext context(
 85         vm, structure, length, sizeof(typename Adaptor::Type),
 86         ConstructionContext::DontInitialize);
 87     if (!context) {
<span class="line-modified"> 88         throwOutOfMemoryError(exec, scope);</span>
 89         return nullptr;
 90     }
 91     JSGenericTypedArrayView* result =
 92         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 93         JSGenericTypedArrayView(vm, context);
 94     result-&gt;finishCreation(vm);
 95     return result;
 96 }
 97 
 98 template&lt;typename Adaptor&gt;
 99 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">100     ExecState* exec, Structure* structure, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer,</span>
101     unsigned byteOffset, unsigned length)
102 {
<span class="line-modified">103     VM&amp; vm = exec-&gt;vm();</span>
104     auto scope = DECLARE_THROW_SCOPE(vm);
105     size_t size = sizeof(typename Adaptor::Type);
106     ASSERT(buffer);
107     if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
<span class="line-modified">108         throwException(exec, scope, createRangeError(exec, &quot;Length out of range of buffer&quot;));</span>
109         return nullptr;
110     }
111     if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
<span class="line-modified">112         throwException(exec, scope, createRangeError(exec, &quot;Byte offset is not aligned&quot;));</span>
113         return nullptr;
114     }
115     ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
116     ASSERT(context);
117     JSGenericTypedArrayView* result =
118         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
119         JSGenericTypedArrayView(vm, context);
120     result-&gt;finishCreation(vm);
121     return result;
122 }
123 
124 template&lt;typename Adaptor&gt;
125 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
126     VM&amp; vm, Structure* structure, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
127 {
128     ConstructionContext context(vm, structure, impl-&gt;possiblySharedBuffer(), impl-&gt;byteOffset(), impl-&gt;length());
129     ASSERT(context);
130     JSGenericTypedArrayView* result =
131         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
132         JSGenericTypedArrayView(vm, context);
133     result-&gt;finishCreation(vm);
134     return result;
135 }
136 
137 template&lt;typename Adaptor&gt;
138 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
139     Structure* structure, JSGlobalObject* globalObject,
140     RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
141 {
142     return create(globalObject-&gt;vm(), structure, WTFMove(impl));
143 }
144 
145 template&lt;typename Adaptor&gt;
146 bool JSGenericTypedArrayView&lt;Adaptor&gt;::validateRange(
<span class="line-modified">147     ExecState* exec, unsigned offset, unsigned length)</span>
148 {
<span class="line-modified">149     VM&amp; vm = exec-&gt;vm();</span>
150     auto scope = DECLARE_THROW_SCOPE(vm);
151     if (canAccessRangeQuickly(offset, length))
152         return true;
153 
<span class="line-modified">154     throwException(exec, scope, createRangeError(exec, &quot;Range consisting of offset and length are out of bounds&quot;));</span>
155     return false;
156 }
157 
158 template&lt;typename Adaptor&gt;
159 template&lt;typename OtherAdaptor&gt;
160 bool JSGenericTypedArrayView&lt;Adaptor&gt;::setWithSpecificType(
<span class="line-modified">161     ExecState* exec, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;* other,</span>
162     unsigned otherOffset, unsigned length, CopyType type)
163 {
164     // Handle the hilarious case: the act of getting the length could have resulted
165     // in neutering. Well, no. That&#39;ll never happen because there cannot be
166     // side-effects on getting the length of a typed array. But predicting where there
167     // are, or aren&#39;t, side-effects is a fool&#39;s game so we resort to this cheap
168     // check. Worst case, if we&#39;re wrong, people start seeing less things get copied
169     // but we won&#39;t have a security vulnerability.
170     length = std::min(length, other-&gt;length());
171 
172     RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(otherOffset, length));
<span class="line-modified">173     if (!validateRange(exec, offset, length))</span>
174         return false;
175 
176     // This method doesn&#39;t support copying between the same array. Note that
177     // set() will only call this if the types differ, which implicitly guarantees
178     // that we can&#39;t be the same array. This is relevant because the way we detect
179     // non-overlapping is by checking if either (a) either array doesn&#39;t have a
180     // backing buffer or (b) the backing buffers are different, but that doesn&#39;t
181     // catch the case where it&#39;s the *same* array - fortunately though, this code
182     // path never needs to worry about that case.
183     ASSERT(static_cast&lt;JSCell*&gt;(this) != static_cast&lt;JSCell*&gt;(other));
184 
185     // 1) If the two arrays are non-overlapping, we can copy in any order we like
186     //    and we don&#39;t need an intermediate buffer. Arrays are definitely
187     //    non-overlapping if either one of them has no backing buffer (that means
188     //    that it *owns* its philosophical backing buffer) or if they have
189     //    different backing buffers.
190     // 2) If the two arrays overlap but have the same element size, we can do a
191     //    memmove-like copy where we flip-flop direction based on which vector
192     //    starts before the other:
193     //    A) If the destination vector is before the source vector, then a forward
</pre>
<hr />
<pre>
222                 offset + i, OtherAdaptor::template convertTo&lt;Adaptor&gt;(
223                     other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset)));
224         }
225         return true;
226     }
227 
228     // Fail: we need an intermediate transfer buffer (i.e. case (3)).
229     Vector&lt;typename Adaptor::Type, 32&gt; transferBuffer(length);
230     for (unsigned i = length; i--;) {
231         transferBuffer[i] = OtherAdaptor::template convertTo&lt;Adaptor&gt;(
232             other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset));
233     }
234     for (unsigned i = length; i--;)
235         setIndexQuicklyToNativeValue(offset + i, transferBuffer[i]);
236 
237     return true;
238 }
239 
240 template&lt;typename Adaptor&gt;
241 bool JSGenericTypedArrayView&lt;Adaptor&gt;::set(
<span class="line-modified">242     ExecState* exec, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)</span>
243 {
<span class="line-modified">244     VM&amp; vm = exec-&gt;vm();</span>
245     auto scope = DECLARE_THROW_SCOPE(vm);
246 
247     const ClassInfo* ci = object-&gt;classInfo(vm);
248     if (ci-&gt;typedArrayStorageType == Adaptor::typeValue) {
249         // The super fast case: we can just memcpy since we&#39;re the same type.
250         JSGenericTypedArrayView* other = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
251         length = std::min(length, other-&gt;length());
252 
253         RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(objectOffset, length));
<span class="line-modified">254         bool success = validateRange(exec, offset, length);</span>
255         EXCEPTION_ASSERT(!scope.exception() == success);
256         if (!success)
257             return false;
258 
259         memmove(typedVector() + offset, other-&gt;typedVector() + objectOffset, length * elementSize);
260         return true;
261     }
262 
263     switch (ci-&gt;typedArrayStorageType) {
264     case TypeInt8:
265         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int8Adaptor&gt;(
<span class="line-modified">266             exec, offset, jsCast&lt;JSInt8Array*&gt;(object), objectOffset, length, type));</span>
267     case TypeInt16:
268         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int16Adaptor&gt;(
<span class="line-modified">269             exec, offset, jsCast&lt;JSInt16Array*&gt;(object), objectOffset, length, type));</span>
270     case TypeInt32:
271         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int32Adaptor&gt;(
<span class="line-modified">272             exec, offset, jsCast&lt;JSInt32Array*&gt;(object), objectOffset, length, type));</span>
273     case TypeUint8:
274         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8Adaptor&gt;(
<span class="line-modified">275             exec, offset, jsCast&lt;JSUint8Array*&gt;(object), objectOffset, length, type));</span>
276     case TypeUint8Clamped:
277         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8ClampedAdaptor&gt;(
<span class="line-modified">278             exec, offset, jsCast&lt;JSUint8ClampedArray*&gt;(object), objectOffset, length, type));</span>
279     case TypeUint16:
280         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint16Adaptor&gt;(
<span class="line-modified">281             exec, offset, jsCast&lt;JSUint16Array*&gt;(object), objectOffset, length, type));</span>
282     case TypeUint32:
283         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint32Adaptor&gt;(
<span class="line-modified">284             exec, offset, jsCast&lt;JSUint32Array*&gt;(object), objectOffset, length, type));</span>
285     case TypeFloat32:
286         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float32Adaptor&gt;(
<span class="line-modified">287             exec, offset, jsCast&lt;JSFloat32Array*&gt;(object), objectOffset, length, type));</span>
288     case TypeFloat64:
289         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float64Adaptor&gt;(
<span class="line-modified">290             exec, offset, jsCast&lt;JSFloat64Array*&gt;(object), objectOffset, length, type));</span>
291     case NotTypedArray:
292     case TypeDataView: {
<span class="line-modified">293         bool success = validateRange(exec, offset, length);</span>
294         EXCEPTION_ASSERT(!scope.exception() == success);
295         if (!success)
296             return false;
297 
298         // We could optimize this case. But right now, we don&#39;t.
299         for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">300             JSValue value = object-&gt;get(exec, i + objectOffset);</span>
301             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">302             bool success = setIndex(exec, offset + i, value);</span>
303             EXCEPTION_ASSERT(!scope.exception() || !success);
304             if (!success)
305                 return false;
306         }
307         return true;
308     } }
309 
310     RELEASE_ASSERT_NOT_REACHED();
311     return false;
312 }
313 
314 template&lt;typename Adaptor&gt;
315 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::possiblySharedTypedImpl()
316 {
317     return Adaptor::ViewType::tryCreate(possiblySharedBuffer(), byteOffset(), length());
318 }
319 
320 template&lt;typename Adaptor&gt;
321 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::unsharedTypedImpl()
322 {
323     return Adaptor::ViewType::tryCreate(unsharedBuffer(), byteOffset(), length());
324 }
325 
326 template&lt;typename Adaptor&gt;
327 ArrayBuffer* JSGenericTypedArrayView&lt;Adaptor&gt;::existingBuffer()
328 {
329     return existingBufferInButterfly();
330 }
331 
332 template&lt;typename Adaptor&gt;
<span class="line-modified">333 EncodedJSValue JSGenericTypedArrayView&lt;Adaptor&gt;::throwNeuteredTypedArrayTypeError(ExecState* exec, EncodedJSValue object, PropertyName)</span>
334 {
<span class="line-modified">335     VM&amp; vm = exec-&gt;vm();</span>
336     auto scope = DECLARE_THROW_SCOPE(vm);
337     ASSERT_UNUSED(object, jsCast&lt;JSGenericTypedArrayView*&gt;(JSValue::decode(object))-&gt;isNeutered());
<span class="line-modified">338     return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
339 }
340 
341 template&lt;typename Adaptor&gt;
342 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlot(
<span class="line-modified">343     JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
344 {
345     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
346 
347     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
348         if (thisObject-&gt;isNeutered()) {
349             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
350             return true;
351         }
352 
353         if (thisObject-&gt;canGetIndexQuickly(index.value())) {
354             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(index.value()));
355             return true;
356         }
357 
358         return false;
359     }
360 
361     if (isCanonicalNumericIndexString(propertyName)) {
362         if (thisObject-&gt;isNeutered()) {
363             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
364             return true;
365         }
366 
367         return false;
368     }
369 
<span class="line-modified">370     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
371 }
372 
373 template&lt;typename Adaptor&gt;
374 bool JSGenericTypedArrayView&lt;Adaptor&gt;::put(
<span class="line-modified">375     JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,</span>
376     PutPropertySlot&amp; slot)
377 {
<span class="line-modified">378     VM&amp; vm = exec-&gt;vm();</span>
379     auto scope = DECLARE_THROW_SCOPE(vm);
380 
381     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
382 
383     // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
384     // Ignore the receiver even if the receiver is altered to non base value.
385     // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
386     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">387         RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));</span>
388 
389     if (isCanonicalNumericIndexString(propertyName)) {
390         if (thisObject-&gt;isNeutered())
<span class="line-modified">391             throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
392         return false;
393     }
394 
<span class="line-modified">395     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
396 }
397 
398 template&lt;typename Adaptor&gt;
399 bool JSGenericTypedArrayView&lt;Adaptor&gt;::defineOwnProperty(
<span class="line-modified">400     JSObject* object, ExecState* exec, PropertyName propertyName,</span>
401     const PropertyDescriptor&amp; descriptor, bool shouldThrow)
402 {
<span class="line-modified">403     VM&amp; vm = exec-&gt;vm();</span>
404     auto scope = DECLARE_THROW_SCOPE(vm);
405     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
406 
407     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
408         auto throwTypeErrorIfNeeded = [&amp;] (const char* errorMessage) -&gt; bool {
409             if (shouldThrow)
<span class="line-modified">410                 throwTypeError(exec, scope, makeString(errorMessage, *index));</span>
411             return false;
412         };
413 
414         if (index.value() &gt;= thisObject-&gt;m_length)
415             return false;
416 
417         if (descriptor.isAccessorDescriptor())
418             return throwTypeErrorIfNeeded(&quot;Attempting to store accessor property on a typed array at index: &quot;);
419 
420         if (descriptor.configurable())
421             return throwTypeErrorIfNeeded(&quot;Attempting to configure non-configurable property on a typed array at index: &quot;);
422 
423         if (!descriptor.enumerable() || !descriptor.writable())
424             return throwTypeErrorIfNeeded(&quot;Attempting to store non-enumerable or non-writable property on a typed array at index: &quot;);
425 
426         if (descriptor.value())
<span class="line-modified">427             RELEASE_AND_RETURN(scope, thisObject-&gt;putByIndex(thisObject, exec, index.value(), descriptor.value(), shouldThrow));</span>
428 
429         return true;
430     }
431 
432     if (isCanonicalNumericIndexString(propertyName))
433         return false;
434 
<span class="line-modified">435     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow));</span>
436 }
437 
438 template&lt;typename Adaptor&gt;
439 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deleteProperty(
<span class="line-modified">440     JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
441 {
<span class="line-modified">442     VM&amp; vm = exec-&gt;vm();</span>
443     auto scope = DECLARE_THROW_SCOPE(vm);
444     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
445 
446     if (thisObject-&gt;isNeutered())
<span class="line-modified">447         return typeError(exec, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);</span>
448 
449     if (parseIndex(propertyName))
450         return false;
451 
<span class="line-modified">452     return Base::deleteProperty(thisObject, exec, propertyName);</span>
453 }
454 
455 template&lt;typename Adaptor&gt;
456 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlotByIndex(
<span class="line-modified">457     JSObject* object, ExecState*, unsigned propertyName, PropertySlot&amp; slot)</span>
458 {
459     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
460 
461     if (thisObject-&gt;isNeutered()) {
462         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
463         return true;
464     }
465 
466     if (!thisObject-&gt;canGetIndexQuickly(propertyName))
467         return false;
468 
469     slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(propertyName));
470     return true;
471 }
472 
473 template&lt;typename Adaptor&gt;
474 bool JSGenericTypedArrayView&lt;Adaptor&gt;::putByIndex(
<span class="line-modified">475     JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool)</span>
476 {
477     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
<span class="line-modified">478     return thisObject-&gt;setIndex(exec, propertyName, value);</span>
479 }
480 
481 template&lt;typename Adaptor&gt;
482 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deletePropertyByIndex(
<span class="line-modified">483     JSCell* cell, ExecState* exec, unsigned propertyName)</span>
484 {
<span class="line-modified">485     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">486     return cell-&gt;methodTable(vm)-&gt;deleteProperty(cell, exec, Identifier::from(vm, propertyName));</span>
487 }
488 
489 template&lt;typename Adaptor&gt;
490 void JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertyNames(
<span class="line-modified">491     JSObject* object, ExecState* exec, PropertyNameArray&amp; array, EnumerationMode mode)</span>
492 {
<span class="line-modified">493     VM&amp; vm = exec-&gt;vm();</span>
494     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
495 
496     if (array.includeStringProperties()) {
497         for (unsigned i = 0; i &lt; thisObject-&gt;m_length; ++i)
498             array.add(Identifier::from(vm, i));
499     }
500 
<span class="line-modified">501     return Base::getOwnPropertyNames(object, exec, array, mode);</span>
502 }
503 
504 template&lt;typename Adaptor&gt;
505 size_t JSGenericTypedArrayView&lt;Adaptor&gt;::estimatedSize(JSCell* cell, VM&amp; vm)
506 {
507     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
508 
509     if (thisObject-&gt;m_mode == OversizeTypedArray)
510         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
511     if (thisObject-&gt;m_mode == FastTypedArray &amp;&amp; thisObject-&gt;hasVector())
512         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
513 
514     return Base::estimatedSize(thisObject, vm);
515 }
516 
517 template&lt;typename Adaptor&gt;
518 void JSGenericTypedArrayView&lt;Adaptor&gt;::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
519 {
520     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
521     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ArrayBufferView.h&quot;
 29 #include &quot;DeferGC.h&quot;
 30 #include &quot;Error.h&quot;
 31 #include &quot;ExceptionHelpers.h&quot;
 32 #include &quot;JSArrayBuffer.h&quot;
<span class="line-added"> 33 #include &quot;JSCellInlines.h&quot;</span>
 34 #include &quot;JSGenericTypedArrayView.h&quot;
 35 #include &quot;TypeError.h&quot;
 36 #include &quot;TypedArrays.h&quot;
 37 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 38 
 39 namespace JSC {
 40 
 41 template&lt;typename Adaptor&gt;
 42 JSGenericTypedArrayView&lt;Adaptor&gt;::JSGenericTypedArrayView(
 43     VM&amp; vm, ConstructionContext&amp; context)
 44     : Base(vm, context)
 45 {
 46 }
 47 
 48 template&lt;typename Adaptor&gt;
 49 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified"> 50     JSGlobalObject* globalObject, Structure* structure, unsigned length)</span>
 51 {
<span class="line-modified"> 52     VM&amp; vm = globalObject-&gt;vm();</span>
 53     auto scope = DECLARE_THROW_SCOPE(vm);
 54     ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
 55     if (!context) {
<span class="line-modified"> 56         throwOutOfMemoryError(globalObject, scope);</span>
 57         return nullptr;
 58     }
 59     JSGenericTypedArrayView* result =
 60         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 61         JSGenericTypedArrayView(vm, context);
 62     result-&gt;finishCreation(vm);
 63     return result;
 64 }
 65 
 66 template&lt;typename Adaptor&gt;
 67 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createWithFastVector(
<span class="line-modified"> 68     JSGlobalObject* globalObject, Structure* structure, unsigned length, void* vector)</span>
 69 {
<span class="line-modified"> 70     VM&amp; vm = globalObject-&gt;vm();</span>
 71     ConstructionContext context(structure, length, vector);
 72     RELEASE_ASSERT(context);
 73     JSGenericTypedArrayView* result =
 74         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 75         JSGenericTypedArrayView(vm, context);
 76     result-&gt;finishCreation(vm);
 77     return result;
 78 }
 79 
 80 template&lt;typename Adaptor&gt;
<span class="line-modified"> 81 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createUninitialized(JSGlobalObject* globalObject, Structure* structure, unsigned length)</span>
 82 {
<span class="line-modified"> 83     VM&amp; vm = globalObject-&gt;vm();</span>
 84     auto scope = DECLARE_THROW_SCOPE(vm);
 85     ConstructionContext context(
 86         vm, structure, length, sizeof(typename Adaptor::Type),
 87         ConstructionContext::DontInitialize);
 88     if (!context) {
<span class="line-modified"> 89         throwOutOfMemoryError(globalObject, scope);</span>
 90         return nullptr;
 91     }
 92     JSGenericTypedArrayView* result =
 93         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
 94         JSGenericTypedArrayView(vm, context);
 95     result-&gt;finishCreation(vm);
 96     return result;
 97 }
 98 
 99 template&lt;typename Adaptor&gt;
100 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">101     JSGlobalObject* globalObject, Structure* structure, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer,</span>
102     unsigned byteOffset, unsigned length)
103 {
<span class="line-modified">104     VM&amp; vm = globalObject-&gt;vm();</span>
105     auto scope = DECLARE_THROW_SCOPE(vm);
106     size_t size = sizeof(typename Adaptor::Type);
107     ASSERT(buffer);
108     if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
<span class="line-modified">109         throwException(globalObject, scope, createRangeError(globalObject, &quot;Length out of range of buffer&quot;));</span>
110         return nullptr;
111     }
112     if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
<span class="line-modified">113         throwException(globalObject, scope, createRangeError(globalObject, &quot;Byte offset is not aligned&quot;));</span>
114         return nullptr;
115     }
116     ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
117     ASSERT(context);
118     JSGenericTypedArrayView* result =
119         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
120         JSGenericTypedArrayView(vm, context);
121     result-&gt;finishCreation(vm);
122     return result;
123 }
124 
125 template&lt;typename Adaptor&gt;
126 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
127     VM&amp; vm, Structure* structure, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
128 {
129     ConstructionContext context(vm, structure, impl-&gt;possiblySharedBuffer(), impl-&gt;byteOffset(), impl-&gt;length());
130     ASSERT(context);
131     JSGenericTypedArrayView* result =
132         new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
133         JSGenericTypedArrayView(vm, context);
134     result-&gt;finishCreation(vm);
135     return result;
136 }
137 
138 template&lt;typename Adaptor&gt;
139 JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
140     Structure* structure, JSGlobalObject* globalObject,
141     RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl)
142 {
143     return create(globalObject-&gt;vm(), structure, WTFMove(impl));
144 }
145 
146 template&lt;typename Adaptor&gt;
147 bool JSGenericTypedArrayView&lt;Adaptor&gt;::validateRange(
<span class="line-modified">148     JSGlobalObject* globalObject, unsigned offset, unsigned length)</span>
149 {
<span class="line-modified">150     VM&amp; vm = globalObject-&gt;vm();</span>
151     auto scope = DECLARE_THROW_SCOPE(vm);
152     if (canAccessRangeQuickly(offset, length))
153         return true;
154 
<span class="line-modified">155     throwException(globalObject, scope, createRangeError(globalObject, &quot;Range consisting of offset and length are out of bounds&quot;));</span>
156     return false;
157 }
158 
159 template&lt;typename Adaptor&gt;
160 template&lt;typename OtherAdaptor&gt;
161 bool JSGenericTypedArrayView&lt;Adaptor&gt;::setWithSpecificType(
<span class="line-modified">162     JSGlobalObject* globalObject, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;* other,</span>
163     unsigned otherOffset, unsigned length, CopyType type)
164 {
165     // Handle the hilarious case: the act of getting the length could have resulted
166     // in neutering. Well, no. That&#39;ll never happen because there cannot be
167     // side-effects on getting the length of a typed array. But predicting where there
168     // are, or aren&#39;t, side-effects is a fool&#39;s game so we resort to this cheap
169     // check. Worst case, if we&#39;re wrong, people start seeing less things get copied
170     // but we won&#39;t have a security vulnerability.
171     length = std::min(length, other-&gt;length());
172 
173     RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(otherOffset, length));
<span class="line-modified">174     if (!validateRange(globalObject, offset, length))</span>
175         return false;
176 
177     // This method doesn&#39;t support copying between the same array. Note that
178     // set() will only call this if the types differ, which implicitly guarantees
179     // that we can&#39;t be the same array. This is relevant because the way we detect
180     // non-overlapping is by checking if either (a) either array doesn&#39;t have a
181     // backing buffer or (b) the backing buffers are different, but that doesn&#39;t
182     // catch the case where it&#39;s the *same* array - fortunately though, this code
183     // path never needs to worry about that case.
184     ASSERT(static_cast&lt;JSCell*&gt;(this) != static_cast&lt;JSCell*&gt;(other));
185 
186     // 1) If the two arrays are non-overlapping, we can copy in any order we like
187     //    and we don&#39;t need an intermediate buffer. Arrays are definitely
188     //    non-overlapping if either one of them has no backing buffer (that means
189     //    that it *owns* its philosophical backing buffer) or if they have
190     //    different backing buffers.
191     // 2) If the two arrays overlap but have the same element size, we can do a
192     //    memmove-like copy where we flip-flop direction based on which vector
193     //    starts before the other:
194     //    A) If the destination vector is before the source vector, then a forward
</pre>
<hr />
<pre>
223                 offset + i, OtherAdaptor::template convertTo&lt;Adaptor&gt;(
224                     other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset)));
225         }
226         return true;
227     }
228 
229     // Fail: we need an intermediate transfer buffer (i.e. case (3)).
230     Vector&lt;typename Adaptor::Type, 32&gt; transferBuffer(length);
231     for (unsigned i = length; i--;) {
232         transferBuffer[i] = OtherAdaptor::template convertTo&lt;Adaptor&gt;(
233             other-&gt;getIndexQuicklyAsNativeValue(i + otherOffset));
234     }
235     for (unsigned i = length; i--;)
236         setIndexQuicklyToNativeValue(offset + i, transferBuffer[i]);
237 
238     return true;
239 }
240 
241 template&lt;typename Adaptor&gt;
242 bool JSGenericTypedArrayView&lt;Adaptor&gt;::set(
<span class="line-modified">243     JSGlobalObject* globalObject, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)</span>
244 {
<span class="line-modified">245     VM&amp; vm = globalObject-&gt;vm();</span>
246     auto scope = DECLARE_THROW_SCOPE(vm);
247 
248     const ClassInfo* ci = object-&gt;classInfo(vm);
249     if (ci-&gt;typedArrayStorageType == Adaptor::typeValue) {
250         // The super fast case: we can just memcpy since we&#39;re the same type.
251         JSGenericTypedArrayView* other = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
252         length = std::min(length, other-&gt;length());
253 
254         RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(objectOffset, length));
<span class="line-modified">255         bool success = validateRange(globalObject, offset, length);</span>
256         EXCEPTION_ASSERT(!scope.exception() == success);
257         if (!success)
258             return false;
259 
260         memmove(typedVector() + offset, other-&gt;typedVector() + objectOffset, length * elementSize);
261         return true;
262     }
263 
264     switch (ci-&gt;typedArrayStorageType) {
265     case TypeInt8:
266         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int8Adaptor&gt;(
<span class="line-modified">267             globalObject, offset, jsCast&lt;JSInt8Array*&gt;(object), objectOffset, length, type));</span>
268     case TypeInt16:
269         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int16Adaptor&gt;(
<span class="line-modified">270             globalObject, offset, jsCast&lt;JSInt16Array*&gt;(object), objectOffset, length, type));</span>
271     case TypeInt32:
272         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int32Adaptor&gt;(
<span class="line-modified">273             globalObject, offset, jsCast&lt;JSInt32Array*&gt;(object), objectOffset, length, type));</span>
274     case TypeUint8:
275         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8Adaptor&gt;(
<span class="line-modified">276             globalObject, offset, jsCast&lt;JSUint8Array*&gt;(object), objectOffset, length, type));</span>
277     case TypeUint8Clamped:
278         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8ClampedAdaptor&gt;(
<span class="line-modified">279             globalObject, offset, jsCast&lt;JSUint8ClampedArray*&gt;(object), objectOffset, length, type));</span>
280     case TypeUint16:
281         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint16Adaptor&gt;(
<span class="line-modified">282             globalObject, offset, jsCast&lt;JSUint16Array*&gt;(object), objectOffset, length, type));</span>
283     case TypeUint32:
284         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint32Adaptor&gt;(
<span class="line-modified">285             globalObject, offset, jsCast&lt;JSUint32Array*&gt;(object), objectOffset, length, type));</span>
286     case TypeFloat32:
287         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float32Adaptor&gt;(
<span class="line-modified">288             globalObject, offset, jsCast&lt;JSFloat32Array*&gt;(object), objectOffset, length, type));</span>
289     case TypeFloat64:
290         RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float64Adaptor&gt;(
<span class="line-modified">291             globalObject, offset, jsCast&lt;JSFloat64Array*&gt;(object), objectOffset, length, type));</span>
292     case NotTypedArray:
293     case TypeDataView: {
<span class="line-modified">294         bool success = validateRange(globalObject, offset, length);</span>
295         EXCEPTION_ASSERT(!scope.exception() == success);
296         if (!success)
297             return false;
298 
299         // We could optimize this case. But right now, we don&#39;t.
300         for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">301             JSValue value = object-&gt;get(globalObject, i + objectOffset);</span>
302             RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">303             bool success = setIndex(globalObject, offset + i, value);</span>
304             EXCEPTION_ASSERT(!scope.exception() || !success);
305             if (!success)
306                 return false;
307         }
308         return true;
309     } }
310 
311     RELEASE_ASSERT_NOT_REACHED();
312     return false;
313 }
314 
315 template&lt;typename Adaptor&gt;
316 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::possiblySharedTypedImpl()
317 {
318     return Adaptor::ViewType::tryCreate(possiblySharedBuffer(), byteOffset(), length());
319 }
320 
321 template&lt;typename Adaptor&gt;
322 RefPtr&lt;typename Adaptor::ViewType&gt; JSGenericTypedArrayView&lt;Adaptor&gt;::unsharedTypedImpl()
323 {
324     return Adaptor::ViewType::tryCreate(unsharedBuffer(), byteOffset(), length());
325 }
326 
327 template&lt;typename Adaptor&gt;
328 ArrayBuffer* JSGenericTypedArrayView&lt;Adaptor&gt;::existingBuffer()
329 {
330     return existingBufferInButterfly();
331 }
332 
333 template&lt;typename Adaptor&gt;
<span class="line-modified">334 EncodedJSValue JSGenericTypedArrayView&lt;Adaptor&gt;::throwNeuteredTypedArrayTypeError(JSGlobalObject* globalObject, EncodedJSValue object, PropertyName)</span>
335 {
<span class="line-modified">336     VM&amp; vm = globalObject-&gt;vm();</span>
337     auto scope = DECLARE_THROW_SCOPE(vm);
338     ASSERT_UNUSED(object, jsCast&lt;JSGenericTypedArrayView*&gt;(JSValue::decode(object))-&gt;isNeutered());
<span class="line-modified">339     return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
340 }
341 
342 template&lt;typename Adaptor&gt;
343 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlot(
<span class="line-modified">344     JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
345 {
346     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
347 
348     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
349         if (thisObject-&gt;isNeutered()) {
350             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
351             return true;
352         }
353 
354         if (thisObject-&gt;canGetIndexQuickly(index.value())) {
355             slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(index.value()));
356             return true;
357         }
358 
359         return false;
360     }
361 
362     if (isCanonicalNumericIndexString(propertyName)) {
363         if (thisObject-&gt;isNeutered()) {
364             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
365             return true;
366         }
367 
368         return false;
369     }
370 
<span class="line-modified">371     return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
372 }
373 
374 template&lt;typename Adaptor&gt;
375 bool JSGenericTypedArrayView&lt;Adaptor&gt;::put(
<span class="line-modified">376     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,</span>
377     PutPropertySlot&amp; slot)
378 {
<span class="line-modified">379     VM&amp; vm = globalObject-&gt;vm();</span>
380     auto scope = DECLARE_THROW_SCOPE(vm);
381 
382     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
383 
384     // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
385     // Ignore the receiver even if the receiver is altered to non base value.
386     // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
387     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">388         RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));</span>
389 
390     if (isCanonicalNumericIndexString(propertyName)) {
391         if (thisObject-&gt;isNeutered())
<span class="line-modified">392             throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
393         return false;
394     }
395 
<span class="line-modified">396     RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
397 }
398 
399 template&lt;typename Adaptor&gt;
400 bool JSGenericTypedArrayView&lt;Adaptor&gt;::defineOwnProperty(
<span class="line-modified">401     JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName,</span>
402     const PropertyDescriptor&amp; descriptor, bool shouldThrow)
403 {
<span class="line-modified">404     VM&amp; vm = globalObject-&gt;vm();</span>
405     auto scope = DECLARE_THROW_SCOPE(vm);
406     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
407 
408     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
409         auto throwTypeErrorIfNeeded = [&amp;] (const char* errorMessage) -&gt; bool {
410             if (shouldThrow)
<span class="line-modified">411                 throwTypeError(globalObject, scope, makeString(errorMessage, *index));</span>
412             return false;
413         };
414 
415         if (index.value() &gt;= thisObject-&gt;m_length)
416             return false;
417 
418         if (descriptor.isAccessorDescriptor())
419             return throwTypeErrorIfNeeded(&quot;Attempting to store accessor property on a typed array at index: &quot;);
420 
421         if (descriptor.configurable())
422             return throwTypeErrorIfNeeded(&quot;Attempting to configure non-configurable property on a typed array at index: &quot;);
423 
424         if (!descriptor.enumerable() || !descriptor.writable())
425             return throwTypeErrorIfNeeded(&quot;Attempting to store non-enumerable or non-writable property on a typed array at index: &quot;);
426 
427         if (descriptor.value())
<span class="line-modified">428             RELEASE_AND_RETURN(scope, thisObject-&gt;putByIndex(thisObject, globalObject, index.value(), descriptor.value(), shouldThrow));</span>
429 
430         return true;
431     }
432 
433     if (isCanonicalNumericIndexString(propertyName))
434         return false;
435 
<span class="line-modified">436     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow));</span>
437 }
438 
439 template&lt;typename Adaptor&gt;
440 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deleteProperty(
<span class="line-modified">441     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
442 {
<span class="line-modified">443     VM&amp; vm = globalObject-&gt;vm();</span>
444     auto scope = DECLARE_THROW_SCOPE(vm);
445     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
446 
447     if (thisObject-&gt;isNeutered())
<span class="line-modified">448         return typeError(globalObject, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);</span>
449 
450     if (parseIndex(propertyName))
451         return false;
452 
<span class="line-modified">453     return Base::deleteProperty(thisObject, globalObject, propertyName);</span>
454 }
455 
456 template&lt;typename Adaptor&gt;
457 bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlotByIndex(
<span class="line-modified">458     JSObject* object, JSGlobalObject*, unsigned propertyName, PropertySlot&amp; slot)</span>
459 {
460     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
461 
462     if (thisObject-&gt;isNeutered()) {
463         slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
464         return true;
465     }
466 
467     if (!thisObject-&gt;canGetIndexQuickly(propertyName))
468         return false;
469 
470     slot.setValue(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete), thisObject-&gt;getIndexQuickly(propertyName));
471     return true;
472 }
473 
474 template&lt;typename Adaptor&gt;
475 bool JSGenericTypedArrayView&lt;Adaptor&gt;::putByIndex(
<span class="line-modified">476     JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool)</span>
477 {
478     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
<span class="line-modified">479     return thisObject-&gt;setIndex(globalObject, propertyName, value);</span>
480 }
481 
482 template&lt;typename Adaptor&gt;
483 bool JSGenericTypedArrayView&lt;Adaptor&gt;::deletePropertyByIndex(
<span class="line-modified">484     JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
485 {
<span class="line-modified">486     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">487     return cell-&gt;methodTable(vm)-&gt;deleteProperty(cell, globalObject, Identifier::from(vm, propertyName));</span>
488 }
489 
490 template&lt;typename Adaptor&gt;
491 void JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertyNames(
<span class="line-modified">492     JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; array, EnumerationMode mode)</span>
493 {
<span class="line-modified">494     VM&amp; vm = globalObject-&gt;vm();</span>
495     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
496 
497     if (array.includeStringProperties()) {
498         for (unsigned i = 0; i &lt; thisObject-&gt;m_length; ++i)
499             array.add(Identifier::from(vm, i));
500     }
501 
<span class="line-modified">502     return Base::getOwnPropertyNames(object, globalObject, array, mode);</span>
503 }
504 
505 template&lt;typename Adaptor&gt;
506 size_t JSGenericTypedArrayView&lt;Adaptor&gt;::estimatedSize(JSCell* cell, VM&amp; vm)
507 {
508     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
509 
510     if (thisObject-&gt;m_mode == OversizeTypedArray)
511         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
512     if (thisObject-&gt;m_mode == FastTypedArray &amp;&amp; thisObject-&gt;hasVector())
513         return Base::estimatedSize(thisObject, vm) + thisObject-&gt;byteSize();
514 
515     return Base::estimatedSize(thisObject, vm);
516 }
517 
518 template&lt;typename Adaptor&gt;
519 void JSGenericTypedArrayView&lt;Adaptor&gt;::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
520 {
521     JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
522     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
</pre>
</td>
</tr>
</table>
<center><a href="JSGenericTypedArrayViewConstructorInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewPrototypeFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
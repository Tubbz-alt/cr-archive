<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersByGraphColoring.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AirAllocateRegistersAndStackAndGenerateCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirAllocateStackByGraphColoring.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirAllocateRegistersByGraphColoring.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,11 ***</span>
          }
      }
  
      bool hasBeenSimplified(IndexType tmpIndex)
      {
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              if (!!m_coalescedTmps[tmpIndex])
                  ASSERT(getAlias(tmpIndex) != tmpIndex);
          }
  
          return m_isOnSelectStack.quickGet(tmpIndex) || !!m_coalescedTmps[tmpIndex];
<span class="line-new-header">--- 160,11 ---</span>
          }
      }
  
      bool hasBeenSimplified(IndexType tmpIndex)
      {
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              if (!!m_coalescedTmps[tmpIndex])
                  ASSERT(getAlias(tmpIndex) != tmpIndex);
          }
  
          return m_isOnSelectStack.quickGet(tmpIndex) || !!m_coalescedTmps[tmpIndex];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,36 ***</span>
          ASSERT(!isPrecolored(v));
  
          const auto&amp; adjacentsOfU = m_adjacencyList[u];
          const auto&amp; adjacentsOfV = m_adjacencyList[v];
  
<span class="line-modified">!         if (adjacentsOfU.size() + adjacentsOfV.size() &lt; registerCount()) {</span>
              // Shortcut: if the total number of adjacents is less than the number of register, the condition is always met.
              return true;
          }
  
<span class="line-removed">-         HashSet&lt;IndexType&gt; highOrderAdjacents;</span>
<span class="line-removed">- </span>
          for (IndexType adjacentTmpIndex : adjacentsOfU) {
              ASSERT(adjacentTmpIndex != v);
              ASSERT(adjacentTmpIndex != u);
              if (!hasBeenSimplified(adjacentTmpIndex) &amp;&amp; m_degrees[adjacentTmpIndex] &gt;= registerCount()) {
<span class="line-modified">!                 auto addResult = highOrderAdjacents.add(adjacentTmpIndex);</span>
<span class="line-modified">!                 if (addResult.isNewEntry &amp;&amp; highOrderAdjacents.size() &gt;= registerCount())</span>
                      return false;
<span class="line-modified">!             }</span>
          }
          for (IndexType adjacentTmpIndex : adjacentsOfV) {
              ASSERT(adjacentTmpIndex != u);
              ASSERT(adjacentTmpIndex != v);
<span class="line-modified">!             if (!hasBeenSimplified(adjacentTmpIndex) &amp;&amp; m_degrees[adjacentTmpIndex] &gt;= registerCount()) {</span>
<span class="line-modified">!                 auto addResult = highOrderAdjacents.add(adjacentTmpIndex);</span>
<span class="line-modified">!                 if (addResult.isNewEntry &amp;&amp; highOrderAdjacents.size() &gt;= registerCount())</span>
                      return false;
<span class="line-modified">!             }</span>
          }
  
          ASSERT(highOrderAdjacents.size() &lt; registerCount());
          return true;
      }
  
      bool precoloredCoalescingHeuristic(IndexType u, IndexType v)
<span class="line-new-header">--- 190,49 ---</span>
          ASSERT(!isPrecolored(v));
  
          const auto&amp; adjacentsOfU = m_adjacencyList[u];
          const auto&amp; adjacentsOfV = m_adjacencyList[v];
  
<span class="line-modified">!         Vector&lt;IndexType, MacroAssembler::numGPRs + MacroAssembler::numFPRs&gt; highOrderAdjacents;</span>
<span class="line-added">+         RELEASE_ASSERT(registerCount() &lt;= MacroAssembler::numGPRs + MacroAssembler::numFPRs);</span>
<span class="line-added">+         unsigned numCandidates = adjacentsOfU.size() + adjacentsOfV.size();</span>
<span class="line-added">+         if (numCandidates &lt; registerCount()) {</span>
              // Shortcut: if the total number of adjacents is less than the number of register, the condition is always met.
              return true;
          }
  
          for (IndexType adjacentTmpIndex : adjacentsOfU) {
              ASSERT(adjacentTmpIndex != v);
              ASSERT(adjacentTmpIndex != u);
<span class="line-added">+             numCandidates--;</span>
              if (!hasBeenSimplified(adjacentTmpIndex) &amp;&amp; m_degrees[adjacentTmpIndex] &gt;= registerCount()) {
<span class="line-modified">!                 ASSERT(std::find(highOrderAdjacents.begin(), highOrderAdjacents.end(), adjacentTmpIndex) == highOrderAdjacents.end());</span>
<span class="line-modified">!                 highOrderAdjacents.uncheckedAppend(adjacentTmpIndex);</span>
<span class="line-added">+                 if (highOrderAdjacents.size() &gt;= registerCount())</span>
                      return false;
<span class="line-modified">!             } else if (highOrderAdjacents.size() + numCandidates &lt; registerCount())</span>
<span class="line-added">+                 return true;</span>
          }
<span class="line-added">+         ASSERT(numCandidates == adjacentsOfV.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto iteratorEndHighOrderAdjacentsOfU = highOrderAdjacents.end();</span>
          for (IndexType adjacentTmpIndex : adjacentsOfV) {
              ASSERT(adjacentTmpIndex != u);
              ASSERT(adjacentTmpIndex != v);
<span class="line-modified">!             numCandidates--;</span>
<span class="line-modified">!             if (!hasBeenSimplified(adjacentTmpIndex)</span>
<span class="line-modified">!                 &amp;&amp; m_degrees[adjacentTmpIndex] &gt;= registerCount()</span>
<span class="line-added">+                 &amp;&amp; std::find(highOrderAdjacents.begin(), iteratorEndHighOrderAdjacentsOfU, adjacentTmpIndex) == iteratorEndHighOrderAdjacentsOfU) {</span>
<span class="line-added">+                 ASSERT(std::find(iteratorEndHighOrderAdjacentsOfU, highOrderAdjacents.end(), adjacentTmpIndex) == highOrderAdjacents.end());</span>
<span class="line-added">+                 highOrderAdjacents.uncheckedAppend(adjacentTmpIndex);</span>
<span class="line-added">+                 if (highOrderAdjacents.size() &gt;= registerCount())</span>
                      return false;
<span class="line-modified">!             } else if (highOrderAdjacents.size() + numCandidates &lt; registerCount())</span>
<span class="line-added">+                 return true;</span>
          }
  
<span class="line-added">+         ASSERT(!numCandidates);</span>
          ASSERT(highOrderAdjacents.size() &lt; registerCount());
          return true;
      }
  
      bool precoloredCoalescingHeuristic(IndexType u, IndexType v)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 501,11 ***</span>
      }
  
      struct InterferenceEdgeHash {
          static unsigned hash(const InterferenceEdge&amp; key) { return key.hash(); }
          static bool equal(const InterferenceEdge&amp; a, const InterferenceEdge&amp; b) { return a == b; }
<span class="line-modified">!         static const bool safeToCompareToEmptyOrDeleted = true;</span>
      };
      typedef SimpleClassHashTraits&lt;InterferenceEdge&gt; InterferenceEdgeHashTraits;
  
      Vector&lt;Reg&gt; m_regsInPriorityOrder;
      IndexType m_lastPrecoloredRegisterIndex { 0 };
<span class="line-new-header">--- 514,11 ---</span>
      }
  
      struct InterferenceEdgeHash {
          static unsigned hash(const InterferenceEdge&amp; key) { return key.hash(); }
          static bool equal(const InterferenceEdge&amp; a, const InterferenceEdge&amp; b) { return a == b; }
<span class="line-modified">!         static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
      };
      typedef SimpleClassHashTraits&lt;InterferenceEdge&gt; InterferenceEdgeHashTraits;
  
      Vector&lt;Reg&gt; m_regsInPriorityOrder;
      IndexType m_lastPrecoloredRegisterIndex { 0 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 633,11 ***</span>
          // list (but not the other way around, note that this is different than IRC because IRC
          // runs this while coalescing, but we do all our coalescing before this). Once a node is
          // added to the select stack, it&#39;s not on either list, but only on the select stack.
          // Once on the select stack, logically, it&#39;s no longer in the interference graph.
          auto assertInvariants = [&amp;] () {
<span class="line-modified">!             if (ASSERT_DISABLED)</span>
                  return;
              if (!shouldValidateIRAtEachPhase())
                  return;
  
              IndexType firstNonRegIndex = m_lastPrecoloredRegisterIndex + 1;
<span class="line-new-header">--- 646,11 ---</span>
          // list (but not the other way around, note that this is different than IRC because IRC
          // runs this while coalescing, but we do all our coalescing before this). Once a node is
          // added to the select stack, it&#39;s not on either list, but only on the select stack.
          // Once on the select stack, logically, it&#39;s no longer in the interference graph.
          auto assertInvariants = [&amp;] () {
<span class="line-modified">!             if (!ASSERT_ENABLED)</span>
                  return;
              if (!shouldValidateIRAtEachPhase())
                  return;
  
              IndexType firstNonRegIndex = m_lastPrecoloredRegisterIndex + 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 674,11 ***</span>
                  changed = true;
                  ASSERT(m_simplifyWorklist.size() == 1);
              }
          } while (changed);
  
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              ASSERT(!m_simplifyWorklist.size());
              ASSERT(m_spillWorklist.isEmpty());
              IndexType firstNonRegIndex = m_lastPrecoloredRegisterIndex + 1;
              for (IndexType i = firstNonRegIndex; i &lt; m_degrees.size(); ++i)
                  ASSERT(hasBeenSimplified(i));
<span class="line-new-header">--- 687,11 ---</span>
                  changed = true;
                  ASSERT(m_simplifyWorklist.size() == 1);
              }
          } while (changed);
  
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              ASSERT(!m_simplifyWorklist.size());
              ASSERT(m_spillWorklist.isEmpty());
              IndexType firstNonRegIndex = m_lastPrecoloredRegisterIndex + 1;
              for (IndexType i = firstNonRegIndex; i &lt; m_degrees.size(); ++i)
                  ASSERT(hasBeenSimplified(i));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,11 ***</span>
  
              // No need to ever consider this move again if it interferes.
              // No coalescing will remove the interference.
              moveIndex = UINT_MAX;
  
<span class="line-modified">!             if (!ASSERT_DISABLED) {</span>
                  if (isPrecolored(v))
                      ASSERT(isPrecolored(u));
              }
  
              if (traceDebug)
<span class="line-new-header">--- 725,11 ---</span>
  
              // No need to ever consider this move again if it interferes.
              // No coalescing will remove the interference.
              moveIndex = UINT_MAX;
  
<span class="line-modified">!             if (ASSERT_ENABLED) {</span>
                  if (isPrecolored(v))
                      ASSERT(isPrecolored(u));
              }
  
              if (traceDebug)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,11 ***</span>
          if (oldDegree == registerCount()) {
              ASSERT(m_degrees[tmpIndex] &lt; registerCount());
              if (traceDebug)
                  dataLogLn(&quot;Moving tmp &quot;, tmpIndex, &quot; from spill list to simplify list because it&#39;s degree is now less than k&quot;);
  
<span class="line-modified">!             if (!ASSERT_DISABLED)</span>
                  ASSERT(m_unspillableTmps.contains(tmpIndex) || m_spillWorklist.contains(tmpIndex));
              m_spillWorklist.quickClear(tmpIndex);
  
              ASSERT(!m_simplifyWorklist.contains(tmpIndex));
              m_simplifyWorklist.append(tmpIndex);
<span class="line-new-header">--- 908,11 ---</span>
          if (oldDegree == registerCount()) {
              ASSERT(m_degrees[tmpIndex] &lt; registerCount());
              if (traceDebug)
                  dataLogLn(&quot;Moving tmp &quot;, tmpIndex, &quot; from spill list to simplify list because it&#39;s degree is now less than k&quot;);
  
<span class="line-modified">!             if (ASSERT_ENABLED)</span>
                  ASSERT(m_unspillableTmps.contains(tmpIndex) || m_spillWorklist.contains(tmpIndex));
              m_spillWorklist.quickClear(tmpIndex);
  
              ASSERT(!m_simplifyWorklist.contains(tmpIndex));
              m_simplifyWorklist.append(tmpIndex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1019,11 ***</span>
                  m_simplifyWorklist.append(i);
          }
      }
  
      // Low-degree vertex can always be colored: just pick any of the color taken by any
<span class="line-modified">!     // other adjacent verices.</span>
      // The &quot;Simplify&quot; phase takes a low-degree out of the interference graph to simplify it.
      void simplify()
      {
          IndexType lastIndex = m_simplifyWorklist.takeLast();
  
<span class="line-new-header">--- 1032,11 ---</span>
                  m_simplifyWorklist.append(i);
          }
      }
  
      // Low-degree vertex can always be colored: just pick any of the color taken by any
<span class="line-modified">!     // other adjacent vertices.</span>
      // The &quot;Simplify&quot; phase takes a low-degree out of the interference graph to simplify it.
      void simplify()
      {
          IndexType lastIndex = m_simplifyWorklist.takeLast();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1787,17 ***</span>
      void run()
      {
          padInterference(m_code);
  
          allocateOnBank&lt;GP&gt;();
<span class="line-removed">-         m_numIterations = 0;</span>
          allocateOnBank&lt;FP&gt;();
  
          fixSpillsAfterTerminals(m_code);
<span class="line-removed">- </span>
<span class="line-removed">-         if (reportStats)</span>
<span class="line-removed">-             dataLog(&quot;Num iterations = &quot;, m_numIterations, &quot;\n&quot;);</span>
      }
  
  private:
      template&lt;Bank bank&gt;
      void allocateOnBank()
<span class="line-new-header">--- 1800,13 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1807,24 ***</span>
          // FIXME: If a Tmp is used only from a Scratch role and that argument is !admitsStack, then
          // we should add the Tmp to unspillableTmps. That will help avoid relooping only to turn the
          // Tmp into an unspillable Tmp.
          // https://bugs.webkit.org/show_bug.cgi?id=152699
  
<span class="line-modified">!         while (true) {</span>
<span class="line-modified">!             ++m_numIterations;</span>
  
              if (traceDebug)
<span class="line-modified">!                 dataLog(&quot;Code at iteration &quot;, m_numIterations, &quot;:\n&quot;, m_code);</span>
  
              // FIXME: One way to optimize this code is to remove the recomputation inside the fixpoint.
              // We need to recompute because spilling adds tmps, but we could just update tmpWidth when we
              // add those tmps. Note that one easy way to remove the recomputation is to make any newly
              // added Tmps get the same use/def widths that the original Tmp got. But, this may hurt the
              // spill code we emit. Since we currently recompute TmpWidth after spilling, the newly
              // created Tmps may get narrower use/def widths. On the other hand, the spiller already
              // selects which move instruction to use based on the original Tmp&#39;s widths, so it may not
<span class="line-modified">!             // matter than a subsequent iteration sees a coservative width for the new Tmps. Also, the</span>
              // recomputation may not actually be a performance problem; it&#39;s likely that a better way to
              // improve performance of TmpWidth is to replace its HashMap with something else. It&#39;s
              // possible that most of the TmpWidth overhead is from queries of TmpWidth rather than the
              // recomputation, in which case speeding up the lookup would be a bigger win.
              // https://bugs.webkit.org/show_bug.cgi?id=152478
<span class="line-new-header">--- 1816,27 ---</span>
          // FIXME: If a Tmp is used only from a Scratch role and that argument is !admitsStack, then
          // we should add the Tmp to unspillableTmps. That will help avoid relooping only to turn the
          // Tmp into an unspillable Tmp.
          // https://bugs.webkit.org/show_bug.cgi?id=152699
  
<span class="line-modified">!         unsigned numIterations = 0;</span>
<span class="line-modified">!         bool done = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+         while (!done) {</span>
<span class="line-added">+             ++numIterations;</span>
  
              if (traceDebug)
<span class="line-modified">!                 dataLog(&quot;Code at iteration &quot;, numIterations, &quot;:\n&quot;, m_code);</span>
  
              // FIXME: One way to optimize this code is to remove the recomputation inside the fixpoint.
              // We need to recompute because spilling adds tmps, but we could just update tmpWidth when we
              // add those tmps. Note that one easy way to remove the recomputation is to make any newly
              // added Tmps get the same use/def widths that the original Tmp got. But, this may hurt the
              // spill code we emit. Since we currently recompute TmpWidth after spilling, the newly
              // created Tmps may get narrower use/def widths. On the other hand, the spiller already
              // selects which move instruction to use based on the original Tmp&#39;s widths, so it may not
<span class="line-modified">!             // matter than a subsequent iteration sees a conservative width for the new Tmps. Also, the</span>
              // recomputation may not actually be a performance problem; it&#39;s likely that a better way to
              // improve performance of TmpWidth is to replace its HashMap with something else. It&#39;s
              // possible that most of the TmpWidth overhead is from queries of TmpWidth rather than the
              // recomputation, in which case speeding up the lookup would be a bigger win.
              // https://bugs.webkit.org/show_bug.cgi?id=152478
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1833,30 ***</span>
              auto doAllocation = [&amp;] (auto&amp; allocator) -&gt; bool {
                  allocator.allocate();
                  if (!allocator.requiresSpilling()) {
                      this-&gt;assignRegistersToTmp&lt;bank&gt;(allocator);
                      if (traceDebug)
<span class="line-modified">!                         dataLog(&quot;Successfull allocation at iteration &quot;, m_numIterations, &quot;:\n&quot;, m_code);</span>
  
                      return true;
                  }
  
                  this-&gt;addSpillAndFill&lt;bank&gt;(allocator, unspillableTmps);
                  return false;
              };
  
<span class="line-removed">-             bool done;</span>
              if (useIRC()) {
                  ColoringAllocator&lt;bank, IRC&gt; allocator(m_code, m_tmpWidth, m_useCounts, unspillableTmps);
                  done = doAllocation(allocator);
              } else {
                  ColoringAllocator&lt;bank, Briggs&gt; allocator(m_code, m_tmpWidth, m_useCounts, unspillableTmps);
                  done = doAllocation(allocator);
              }
<span class="line-removed">-             if (done)</span>
<span class="line-removed">-                 return;</span>
          }
      }
  
      template&lt;Bank bank&gt;
      HashSet&lt;unsigned&gt; computeUnspillableTmps()
      {
<span class="line-new-header">--- 1845,28 ---</span>
              auto doAllocation = [&amp;] (auto&amp; allocator) -&gt; bool {
                  allocator.allocate();
                  if (!allocator.requiresSpilling()) {
                      this-&gt;assignRegistersToTmp&lt;bank&gt;(allocator);
                      if (traceDebug)
<span class="line-modified">!                         dataLog(&quot;Successfull allocation at iteration &quot;, numIterations, &quot;:\n&quot;, m_code);</span>
  
                      return true;
                  }
  
                  this-&gt;addSpillAndFill&lt;bank&gt;(allocator, unspillableTmps);
                  return false;
              };
  
              if (useIRC()) {
                  ColoringAllocator&lt;bank, IRC&gt; allocator(m_code, m_tmpWidth, m_useCounts, unspillableTmps);
                  done = doAllocation(allocator);
              } else {
                  ColoringAllocator&lt;bank, Briggs&gt; allocator(m_code, m_tmpWidth, m_useCounts, unspillableTmps);
                  done = doAllocation(allocator);
              }
          }
<span class="line-added">+         dataLogLnIf(reportStats, &quot;Num iterations = &quot;, numIterations, &quot; for bank: &quot;, bank);</span>
      }
  
      template&lt;Bank bank&gt;
      HashSet&lt;unsigned&gt; computeUnspillableTmps()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2185,11 ***</span>
      }
  
      Code&amp; m_code;
      TmpWidth m_tmpWidth;
      UseCounts&lt;Tmp&gt;&amp; m_useCounts;
<span class="line-removed">-     unsigned m_numIterations { 0 };</span>
  };
  
  } // anonymous namespace
  
  void allocateRegistersByGraphColoring(Code&amp; code)
<span class="line-new-header">--- 2195,10 ---</span>
</pre>
<center><a href="AirAllocateRegistersAndStackAndGenerateCode.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AirAllocateStackByGraphColoring.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
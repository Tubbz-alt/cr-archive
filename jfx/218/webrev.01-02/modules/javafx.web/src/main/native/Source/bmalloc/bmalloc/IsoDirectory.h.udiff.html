<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IsoDeallocatorInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoDirectoryInlines.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoDirectory.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,10 +26,11 @@</span>
  #pragma once
  
  #include &quot;Bits.h&quot;
  #include &quot;EligibilityResult.h&quot;
  #include &quot;IsoPage.h&quot;
<span class="udiff-line-added">+ #include &quot;Packed.h&quot;</span>
  #include &quot;Vector.h&quot;
  
  namespace bmalloc {
  
  template&lt;typename Config&gt; class IsoHeapImpl;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -47,11 +48,11 @@</span>
  public:
      IsoDirectoryBase(IsoHeapImpl&lt;Config&gt;&amp;);
  
      IsoHeapImpl&lt;Config&gt;&amp; heap() { return m_heap; }
  
<span class="udiff-line-modified-removed">-     virtual void didBecome(IsoPage&lt;Config&gt;*, IsoPageTrigger) = 0;</span>
<span class="udiff-line-modified-added">+     virtual void didBecome(const LockHolder&amp;, IsoPage&lt;Config&gt;*, IsoPageTrigger) = 0;</span>
  
  protected:
      IsoHeapImpl&lt;Config&gt;&amp; m_heap;
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -62,34 +63,40 @@</span>
  
      IsoDirectory(IsoHeapImpl&lt;Config&gt;&amp;);
  
      // Find the first page that is eligible for allocation and return it. May return null if there is no
      // such thing. May allocate a new page if we have an uncommitted page.
<span class="udiff-line-modified-removed">-     EligibilityResult&lt;Config&gt; takeFirstEligible();</span>
<span class="udiff-line-modified-added">+     EligibilityResult&lt;Config&gt; takeFirstEligible(const LockHolder&amp;);</span>
  
<span class="udiff-line-modified-removed">-     void didBecome(IsoPage&lt;Config&gt;*, IsoPageTrigger) override;</span>
<span class="udiff-line-modified-added">+     void didBecome(const LockHolder&amp;, IsoPage&lt;Config&gt;*, IsoPageTrigger) override;</span>
  
      // This gets called from a bulk decommit function in the Scavenger, so no locks are held. This function
      // needs to get the heap lock.
      void didDecommit(unsigned index) override;
  
      // Iterate over all empty and committed pages, and put them into the vector. This also records the
      // pages as being decommitted. It&#39;s the caller&#39;s job to do the actual decommitting.
<span class="udiff-line-modified-removed">-     void scavenge(Vector&lt;DeferredDecommit&gt;&amp;);</span>
<span class="udiff-line-modified-added">+     void scavenge(const LockHolder&amp;, Vector&lt;DeferredDecommit&gt;&amp;);</span>
<span class="udiff-line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="udiff-line-added">+     void scavengeToHighWatermark(const LockHolder&amp;, Vector&lt;DeferredDecommit&gt;&amp;);</span>
<span class="udiff-line-added">+ #endif</span>
  
      template&lt;typename Func&gt;
<span class="udiff-line-modified-removed">-     void forEachCommittedPage(const Func&amp;);</span>
<span class="udiff-line-modified-added">+     void forEachCommittedPage(const LockHolder&amp;, const Func&amp;);</span>
  
  private:
<span class="udiff-line-modified-removed">-     void scavengePage(size_t, Vector&lt;DeferredDecommit&gt;&amp;);</span>
<span class="udiff-line-modified-added">+     void scavengePage(const LockHolder&amp;, size_t, Vector&lt;DeferredDecommit&gt;&amp;);</span>
  
<span class="udiff-line-added">+     std::array&lt;PackedAlignedPtr&lt;IsoPage&lt;Config&gt;, IsoPage&lt;Config&gt;::pageSize&gt;, numPages&gt; m_pages { };</span>
      // NOTE: I suppose that this could be two bitvectors. But from working on the GC, I found that the
      // number of bitvectors does not matter as much as whether or not they make intuitive sense.
      Bits&lt;numPages&gt; m_eligible;
      Bits&lt;numPages&gt; m_empty;
      Bits&lt;numPages&gt; m_committed;
<span class="udiff-line-removed">-     std::array&lt;IsoPage&lt;Config&gt;*, numPages&gt; m_pages;</span>
      unsigned m_firstEligibleOrDecommitted { 0 };
<span class="udiff-line-added">+ #if BUSE(PARTIAL_SCAVENGE)</span>
<span class="udiff-line-added">+     unsigned m_highWatermark { 0 };</span>
<span class="udiff-line-added">+ #endif</span>
  };
  
  } // namespace bmalloc
  
</pre>
<center><a href="IsoDeallocatorInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoDirectoryInlines.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptExecutionContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptedAnimationController.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 38,38 ***</span>
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/ObjectIdentifier.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
  class Exception;
<span class="line-removed">- class ExecState;</span>
  class JSPromise;
  class VM;
<span class="line-removed">- template&lt;typename&gt; class Strong;</span>
  }
  
  namespace Inspector {
  class ConsoleMessage;
  class ScriptCallStack;
  }
  
<span class="line-removed">- namespace PAL {</span>
<span class="line-removed">- class SessionID;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  namespace WebCore {
  
  class CachedScript;
  class DatabaseContext;
  class EventQueue;
  class EventTarget;
  class MessagePort;
  class PublicURLManager;
  class RejectedPromiseTracker;
  class ResourceRequest;
  class SecurityOrigin;
  class SocketProvider;
  
  #if ENABLE(SERVICE_WORKER)
  class ServiceWorker;
  class ServiceWorkerContainer;
  #endif
<span class="line-new-header">--- 38,37 ---</span>
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/ObjectIdentifier.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
<span class="line-added">+ class CallFrame;</span>
  class Exception;
  class JSPromise;
  class VM;
  }
  
  namespace Inspector {
  class ConsoleMessage;
  class ScriptCallStack;
  }
  
  namespace WebCore {
  
<span class="line-added">+ class EventLoop;</span>
  class CachedScript;
  class DatabaseContext;
  class EventQueue;
<span class="line-added">+ class EventLoopTaskGroup;</span>
  class EventTarget;
  class MessagePort;
  class PublicURLManager;
  class RejectedPromiseTracker;
  class ResourceRequest;
  class SecurityOrigin;
  class SocketProvider;
<span class="line-added">+ enum class ReferrerPolicy : uint8_t;</span>
<span class="line-added">+ enum class TaskSource : uint8_t;</span>
  
  #if ENABLE(SERVICE_WORKER)
  class ServiceWorker;
  class ServiceWorkerContainer;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 91,16 ***</span>
      virtual bool isWorkletGlobalScope() const { return false; }
  
      virtual bool isContextThread() const { return true; }
      virtual bool isJSExecutionForbidden() const = 0;
  
      virtual const URL&amp; url() const = 0;
<span class="line-modified">!     virtual URL completeURL(const String&amp; url) const = 0;</span>
<span class="line-modified">!     virtual PAL::SessionID sessionID() const = 0;</span>
  
      virtual String userAgent(const URL&amp;) const = 0;
  
      virtual void disableEval(const String&amp; errorMessage) = 0;
      virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
  
  #if ENABLE(INDEXED_DATABASE)
      virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
<span class="line-new-header">--- 90,20 ---</span>
      virtual bool isWorkletGlobalScope() const { return false; }
  
      virtual bool isContextThread() const { return true; }
      virtual bool isJSExecutionForbidden() const = 0;
  
<span class="line-added">+     virtual EventLoopTaskGroup&amp; eventLoop() = 0;</span>
<span class="line-added">+ </span>
      virtual const URL&amp; url() const = 0;
<span class="line-modified">!     enum class ForceUTF8 { No, Yes };</span>
<span class="line-modified">!     virtual URL completeURL(const String&amp; url, ForceUTF8 = ForceUTF8::No) const = 0;</span>
  
      virtual String userAgent(const URL&amp;) const = 0;
  
<span class="line-added">+     virtual ReferrerPolicy referrerPolicy() const = 0;</span>
<span class="line-added">+ </span>
      virtual void disableEval(const String&amp; errorMessage) = 0;
      virtual void disableWebAssembly(const String&amp; errorMessage) = 0;
  
  #if ENABLE(INDEXED_DATABASE)
      virtual IDBClient::IDBConnectionProxy* idbConnectionProxy() = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,31 ***</span>
  
      virtual String resourceRequestIdentifier() const { return String(); };
  
      bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
      void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<span class="line-modified">!     void reportUnhandledPromiseRejection(JSC::ExecState&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
  
      virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
  
      // The following addConsoleMessage functions are deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0);</span>
      virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
  
      virtual SecurityOrigin&amp; topOrigin() const = 0;
<span class="line-removed">-     virtual String origin() const = 0;</span>
  
      virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
  
      PublicURLManager&amp; publicURLManager();
  
<span class="line-removed">-     // Active objects are not garbage collected even if inaccessible, e.g. because their activity may result in callbacks being invoked.</span>
<span class="line-removed">-     WEBCORE_EXPORT bool canSuspendActiveDOMObjectsForDocumentSuspension(Vector&lt;ActiveDOMObject*&gt;* unsuspendableObjects = nullptr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Active objects can be asked to suspend even if canSuspendActiveDOMObjectsForDocumentSuspension() returns &#39;false&#39; -</span>
<span class="line-removed">-     // step-by-step JS debugging is one example.</span>
      virtual void suspendActiveDOMObjects(ReasonForSuspension);
      virtual void resumeActiveDOMObjects(ReasonForSuspension);
      virtual void stopActiveDOMObjects();
  
      bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
<span class="line-new-header">--- 112,25 ---</span>
  
      virtual String resourceRequestIdentifier() const { return String(); };
  
      bool canIncludeErrorDetails(CachedScript*, const String&amp; sourceURL);
      void reportException(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, CachedScript* = nullptr);
<span class="line-modified">!     void reportUnhandledPromiseRejection(JSC::JSGlobalObject&amp;, JSC::JSPromise&amp;, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;);</span>
  
      virtual void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) = 0;
  
      // The following addConsoleMessage functions are deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0);</span>
      virtual void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) = 0;
  
      virtual SecurityOrigin&amp; topOrigin() const = 0;
  
      virtual bool shouldBypassMainWorldContentSecurityPolicy() const { return false; }
  
      PublicURLManager&amp; publicURLManager();
  
      virtual void suspendActiveDOMObjects(ReasonForSuspension);
      virtual void resumeActiveDOMObjects(ReasonForSuspension);
      virtual void stopActiveDOMObjects();
  
      bool activeDOMObjectsAreSuspended() const { return m_activeDOMObjectsAreSuspended; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,10 ***</span>
<span class="line-new-header">--- 188,11 ---</span>
      protected:
          WTF::Function&lt;void (ScriptExecutionContext&amp;)&gt; m_task;
          bool m_isCleanupTask;
      };
  
<span class="line-added">+     void enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function) { postTask(WTFMove(function)); }</span>
      virtual void postTask(Task&amp;&amp;) = 0; // Executes the task on context&#39;s thread asynchronously.
  
      template&lt;typename... Arguments&gt;
      void postCrossThreadTask(Arguments&amp;&amp;... arguments)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,11 ***</span>
      }
  
      // Gets the next id in a circular sequence from 1 to 2^31-1.
      int circularSequentialID();
  
<span class="line-modified">!     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, &amp;timer).isNewEntry; }</span>
      void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
      DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
  
      WEBCORE_EXPORT JSC::VM&amp; vm();
  
<span class="line-new-header">--- 202,11 ---</span>
      }
  
      // Gets the next id in a circular sequence from 1 to 2^31-1.
      int circularSequentialID();
  
<span class="line-modified">!     bool addTimeout(int timeoutId, DOMTimer&amp; timer) { return m_timeouts.add(timeoutId, timer).isNewEntry; }</span>
      void removeTimeout(int timeoutId) { m_timeouts.remove(timeoutId); }
      DOMTimer* findTimeout(int timeoutId) { return m_timeouts.get(timeoutId); }
  
      WEBCORE_EXPORT JSC::VM&amp; vm();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 216,17 ***</span>
      virtual Seconds minimumDOMTimerInterval() const;
  
      void didChangeTimerAlignmentInterval();
      virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
  
<span class="line-removed">-     virtual EventQueue&amp; eventQueue() const = 0;</span>
      virtual EventTarget* errorEventTarget() = 0;
  
      DatabaseContext* databaseContext() { return m_databaseContext.get(); }
      void setDatabaseContext(DatabaseContext*);
  
  #if ENABLE(WEB_CRYPTO)
      virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
      virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
  #endif
  
      int timerNestingLevel() const { return m_timerNestingLevel; }
<span class="line-new-header">--- 214,19 ---</span>
      virtual Seconds minimumDOMTimerInterval() const;
  
      void didChangeTimerAlignmentInterval();
      virtual Seconds domTimerAlignmentInterval(bool hasReachedMaxNestingLevel) const;
  
      virtual EventTarget* errorEventTarget() = 0;
  
      DatabaseContext* databaseContext() { return m_databaseContext.get(); }
      void setDatabaseContext(DatabaseContext*);
  
  #if ENABLE(WEB_CRYPTO)
<span class="line-added">+     // These two methods are used when CryptoKeys are serialized into IndexedDB. As a side effect, it is also</span>
<span class="line-added">+     // used for things that utilize the same structure clone algorithm, for example, message passing between</span>
<span class="line-added">+     // worker and document.</span>
      virtual bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) = 0;
      virtual bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) = 0;
  #endif
  
      int timerNestingLevel() const { return m_timerNestingLevel; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,11 ***</span>
          if (m_rejectedPromiseTracker)
              return *m_rejectedPromiseTracker.get();
          return ensureRejectedPromiseTrackerSlow();
      }
  
<span class="line-modified">!     WEBCORE_EXPORT JSC::ExecState* execState();</span>
  
      WEBCORE_EXPORT String domainForCachePartition() const;
      void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
  
      bool allowsMediaDevices() const;
<span class="line-new-header">--- 237,11 ---</span>
          if (m_rejectedPromiseTracker)
              return *m_rejectedPromiseTracker.get();
          return ensureRejectedPromiseTrackerSlow();
      }
  
<span class="line-modified">!     WEBCORE_EXPORT JSC::JSGlobalObject* execState();</span>
  
      WEBCORE_EXPORT String domainForCachePartition() const;
      void setDomainForCachePartition(String&amp;&amp; domain) { m_domainForCachePartition = WTFMove(domain); }
  
      bool allowsMediaDevices() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,12 ***</span>
      void registerServiceWorker(ServiceWorker&amp;);
      void unregisterServiceWorker(ServiceWorker&amp;);
      ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
  
      ServiceWorkerContainer* serviceWorkerContainer();
<span class="line-modified">! </span>
<span class="line-removed">-     WEBCORE_EXPORT static bool postTaskTo(const DocumentOrWorkerIdentifier&amp;, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp;);</span>
  #endif
      WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
  
      ScriptExecutionContextIdentifier contextIdentifier() const;
  
<span class="line-new-header">--- 253,11 ---</span>
      void registerServiceWorker(ServiceWorker&amp;);
      void unregisterServiceWorker(ServiceWorker&amp;);
      ServiceWorker* serviceWorker(ServiceWorkerIdentifier identifier) { return m_serviceWorkers.get(identifier); }
  
      ServiceWorkerContainer* serviceWorkerContainer();
<span class="line-modified">!     ServiceWorkerContainer* ensureServiceWorkerContainer();</span>
  #endif
      WEBCORE_EXPORT static bool postTaskTo(ScriptExecutionContextIdentifier, Task&amp;&amp;);
  
      ScriptExecutionContextIdentifier contextIdentifier() const;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 287,11 ***</span>
      void removeRejectedPromiseTracker();
  
  private:
      // The following addMessage function is deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
      virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
      bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
  
      virtual void refScriptExecutionContext() = 0;
      virtual void derefScriptExecutionContext() = 0;
<span class="line-new-header">--- 286,11 ---</span>
      void removeRejectedPromiseTracker();
  
  private:
      // The following addMessage function is deprecated.
      // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">!     virtual void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0) = 0;</span>
      virtual void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) = 0;
      bool dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception*, CachedScript*);
  
      virtual void refScriptExecutionContext() = 0;
      virtual void derefScriptExecutionContext() = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
  
      HashSet&lt;MessagePort*&gt; m_messagePorts;
      HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
      HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
  
<span class="line-modified">!     HashMap&lt;int, RefPtr&lt;DOMTimer&gt;&gt; m_timeouts;</span>
  
      struct PendingException;
      std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
      std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
  
<span class="line-new-header">--- 304,11 ---</span>
  
      HashSet&lt;MessagePort*&gt; m_messagePorts;
      HashSet&lt;ContextDestructionObserver*&gt; m_destructionObservers;
      HashSet&lt;ActiveDOMObject*&gt; m_activeDOMObjects;
  
<span class="line-modified">!     HashMap&lt;int, Ref&lt;DOMTimer&gt;&gt; m_timeouts;</span>
  
      struct PendingException;
      std::unique_ptr&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt; m_pendingExceptions;
      std::unique_ptr&lt;RejectedPromiseTracker&gt; m_rejectedPromiseTracker;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 326,11 ***</span>
      bool m_activeDOMObjectsAreStopped { false };
      bool m_inDispatchErrorEvent { false };
      mutable bool m_activeDOMObjectAdditionForbidden { false };
      bool m_willprocessMessageWithMessagePortsSoon { false };
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      bool m_inScriptExecutionContextDestructor { false };
  #endif
  
  #if ENABLE(SERVICE_WORKER)
      RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
<span class="line-new-header">--- 325,11 ---</span>
      bool m_activeDOMObjectsAreStopped { false };
      bool m_inDispatchErrorEvent { false };
      mutable bool m_activeDOMObjectAdditionForbidden { false };
      bool m_willprocessMessageWithMessagePortsSoon { false };
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool m_inScriptExecutionContextDestructor { false };
  #endif
  
  #if ENABLE(SERVICE_WORKER)
      RefPtr&lt;ServiceWorker&gt; m_activeServiceWorker;
</pre>
<center><a href="ScriptExecutionContext.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptedAnimationController.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
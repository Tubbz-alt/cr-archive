<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCommon.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2011-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;DFGCompilationMode.h&quot;
 29 
 30 #if ENABLE(DFG_JIT)
 31 
 32 #include &quot;Options.h&quot;
 33 #include &lt;limits.h&gt;
 34 #include &lt;wtf/text/StringImpl.h&gt;
 35 
 36 namespace JSC { namespace DFG {
 37 
 38 struct Node;
 39 
 40 typedef uint32_t BlockIndex;
<a name="2" id="anc2"></a><span class="line-modified"> 41 static constexpr BlockIndex NoBlock = UINT_MAX;</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 extern const char* const tierName;</span>
 44 
 45 // Use RefChildren if the child ref counts haven&#39;t already been adjusted using
 46 // other means and either of the following is true:
 47 // - The node you&#39;re creating is MustGenerate.
 48 // - The place where you&#39;re inserting a reference to the node you&#39;re creating
 49 //   will not also do RefChildren.
 50 enum RefChildrenMode {
 51     RefChildren,
 52     DontRefChildren
 53 };
 54 
 55 // Use RefNode if you know that the node will be used from another node, and you
 56 // will not already be ref&#39;ing the node to account for that use.
 57 enum RefNodeMode {
 58     RefNode,
 59     DontRefNode
 60 };
 61 
 62 enum SwitchKind {
 63     SwitchImm,
 64     SwitchChar,
 65     SwitchString,
 66     SwitchCell
 67 };
 68 
 69 inline bool verboseCompilationEnabled(CompilationMode mode = DFGMode)
 70 {
 71     return Options::verboseCompilation() || Options::dumpGraphAtEachPhase() || (isFTL(mode) &amp;&amp; Options::verboseFTLCompilation());
 72 }
 73 
 74 inline bool logCompilationChanges(CompilationMode mode = DFGMode)
 75 {
 76     return verboseCompilationEnabled(mode) || Options::logCompilationChanges();
 77 }
 78 
 79 inline bool shouldDumpGraphAtEachPhase(CompilationMode mode)
 80 {
 81     if (isFTL(mode))
 82         return Options::dumpGraphAtEachPhase() || Options::dumpDFGFTLGraphAtEachPhase();
 83     return Options::dumpGraphAtEachPhase() || Options::dumpDFGGraphAtEachPhase();
 84 }
 85 
 86 inline bool validationEnabled()
 87 {
<a name="3" id="anc3"></a><span class="line-modified"> 88 #if ASSERT_ENABLED</span>
 89     return true;
 90 #else
 91     return Options::validateGraph() || Options::validateGraphAtEachPhase();
 92 #endif
 93 }
 94 
 95 inline bool enableInt52()
 96 {
 97 #if USE(JSVALUE64)
 98     return true;
 99 #else
100     return false;
101 #endif
102 }
103 
104 // The prediction propagator effectively does four passes, with the last pass
105 // being done by the separate FixuPhase.
106 enum PredictionPass {
107     // We&#39;re converging in a straight-forward forward flow fixpoint. This is the
108     // most conventional part of the propagator - it makes only monotonic decisions
109     // based on value profiles and rare case profiles. It ignores baseline JIT rare
110     // case profiles. The goal here is to develop a good guess of which variables
111     // are likely to be purely numerical, which generally doesn&#39;t require knowing
112     // the rare case profiles.
113     PrimaryPass,
114 
115     // At this point we know what is numerical and what isn&#39;t. Non-numerical inputs
116     // to arithmetic operations will not have useful information in the Baseline JIT
117     // rare case profiles because Baseline may take slow path on non-numerical
118     // inputs even if the DFG could handle the input on the fast path. Boolean
119     // inputs are the most obvious example. This pass of prediction propagation will
120     // use Baseline rare case profiles for purely numerical operations and it will
121     // ignore them for everything else. The point of this pass is to develop a good
122     // guess of which variables are likely to be doubles.
123     //
124     // This pass is intentionally weird and goes against what is considered good
125     // form when writing a static analysis: a new data flow of booleans will cause
126     // us to ignore rare case profiles except that by then, we will have already
127     // propagated double types based on our prior assumption that we shouldn&#39;t
128     // ignore rare cases. This probably won&#39;t happen because the PrimaryPass is
129     // almost certainly going to establish what is and isn&#39;t numerical. But it&#39;s
130     // conceivable that during this pass we will discover a new boolean data flow.
131     // This ends up being sound because the prediction propagator could literally
132     // make any guesses it wants and still be sound (worst case, we OSR exit more
133     // often or use too general of types are run a bit slower). This will converge
134     // because we force monotonicity on the types of nodes and variables. So, the
135     // worst thing that can happen is that we violate basic laws of theoretical
136     // decency.
137     RareCasePass,
138 
139     // At this point we know what is numerical and what isn&#39;t, and we also know what
140     // is a double and what isn&#39;t. So, we start forcing variables to be double.
141     // Doing so may have a cascading effect so this is a fixpoint. It&#39;s monotonic
142     // in the sense that once a variable is forced double, it cannot be forced in
143     // the other direction.
144     DoubleVotingPass,
145 
146     // This pass occurs once we have converged. At this point we are just installing
147     // type checks based on the conclusions we have already reached. It&#39;s important
148     // for this pass to reach the same conclusions that DoubleVotingPass reached.
149     FixupPass
150 };
151 
152 enum StructureRegistrationState { HaveNotStartedRegistering, AllStructuresAreRegistered };
153 
154 enum StructureRegistrationResult { StructureRegisteredNormally, StructureRegisteredAndWatched };
155 
156 enum OptimizationFixpointState { BeforeFixpoint, FixpointNotConverged, FixpointConverged };
157 
158 // Describes the form you can expect the entire graph to be in.
159 enum GraphForm {
160     // LoadStore form means that basic blocks may freely use GetLocal, SetLocal,
161     // and Flush for accessing local variables and indicating where their live
162     // ranges ought to be. Data flow between local accesses is implicit. Liveness
163     // is only explicit at block heads (variablesAtHead). This is only used by
164     // the DFG simplifier and is only preserved by same.
165     //
166     // For example, LoadStore form gives no easy way to determine which SetLocal&#39;s
167     // flow into a GetLocal. As well, LoadStore form implies no restrictions on
168     // redundancy: you can freely emit multiple GetLocals, or multiple SetLocals
169     // (or any combination thereof) to the same local in the same block. LoadStore
170     // form does not require basic blocks to declare how they affect or use locals,
171     // other than implicitly by using the local ops and by preserving
172     // variablesAtHead. Finally, LoadStore allows flexibility in how liveness of
173     // locals is extended; for example you can replace a GetLocal with a Phantom
174     // and so long as the Phantom retains the GetLocal&#39;s children (i.e. the Phi
175     // most likely) then it implies that the local is still live but that it need
176     // not be stored to the stack necessarily. This implies that Phantom can
177     // reference nodes that have no result, as long as those nodes are valid
178     // GetLocal children (i.e. Phi, SetLocal, SetArgumentDefinitely, SetArgumentMaybe).
179     //
180     // LoadStore form also implies that Phis need not have children. By default,
181     // they end up having no children if you enter LoadStore using the canonical
182     // way (call Graph::dethread).
183     //
184     // LoadStore form is suitable for CFG transformations, as well as strength
185     // reduction, folding, and CSE.
186     LoadStore,
187 
188     // ThreadedCPS form means that basic blocks list up-front which locals they
189     // expect to be live at the head, and which locals they make available at the
190     // tail. ThreadedCPS form also implies that:
191     //
192     // - GetLocals and SetLocals are not redundant within a basic block.
193     //
194     // - All GetLocals and Flushes are linked directly to the last access point
195     //   of the variable, which must not be another GetLocal.
196     //
197     // - Phantom(Phi) is not legal, but PhantomLocal is.
198     //
199     // ThreadedCPS form is suitable for data flow analysis (CFA, prediction
200     // propagation), register allocation, and code generation.
201     ThreadedCPS,
202 
203     // SSA form. See DFGSSAConversionPhase.h for a description.
204     SSA
205 };
206 
207 // Describes the state of the UnionFind structure of VariableAccessData&#39;s.
208 enum UnificationState {
209     // BasicBlock-local accesses to variables are appropriately unified with each other.
210     LocallyUnified,
211 
212     // Unification has been performed globally.
213     GloballyUnified
214 };
215 
216 // Describes how reference counts in the graph behave.
217 enum RefCountState {
218     // Everything has refCount() == 1.
219     EverythingIsLive,
220 
221     // Set after DCE has run.
222     ExactRefCount
223 };
224 
225 enum OperandSpeculationMode { AutomaticOperandSpeculation, ManualOperandSpeculation };
226 
227 enum ProofStatus { NeedsCheck, IsProved };
228 
229 inline bool isProved(ProofStatus proofStatus)
230 {
231     ASSERT(proofStatus == IsProved || proofStatus == NeedsCheck);
232     return proofStatus == IsProved;
233 }
234 
235 inline ProofStatus proofStatusForIsProved(bool isProved)
236 {
237     return isProved ? IsProved : NeedsCheck;
238 }
239 
240 enum KillStatus { DoesNotKill, DoesKill };
241 
242 inline bool doesKill(KillStatus killStatus)
243 {
244     ASSERT(killStatus == DoesNotKill || killStatus == DoesKill);
245     return killStatus == DoesKill;
246 }
247 
248 inline KillStatus killStatusForDoesKill(bool doesKill)
249 {
250     return doesKill ? DoesKill : DoesNotKill;
251 }
252 
253 enum class PlanStage {
254     Initial,
255     AfterFixup
256 };
257 
258 // If possible, this will acquire a lock to make sure that if multiple threads
259 // start crashing at the same time, you get coherent dump output. Use this only
260 // when you&#39;re forcing a crash with diagnostics.
261 void startCrashing();
262 
263 JS_EXPORT_PRIVATE bool isCrashing();
264 
265 struct NodeAndIndex {
266     NodeAndIndex()
267         : node(nullptr)
268         , index(UINT_MAX)
269     {
270     }
271 
272     NodeAndIndex(Node* node, unsigned index)
273         : node(node)
274         , index(index)
275     {
276         ASSERT(!node == (index == UINT_MAX));
277     }
278 
279     bool operator!() const
280     {
281         return !node;
282     }
283 
284     Node* node;
285     unsigned index;
286 };
287 
288 // A less-than operator for strings that is useful for generating string switches. Sorts by &lt;
289 // relation on characters. Ensures that if a is a prefix of b, then a &lt; b.
290 bool stringLessThan(StringImpl&amp; a, StringImpl&amp; b);
291 
292 } } // namespace JSC::DFG
293 
294 namespace WTF {
295 
296 void printInternal(PrintStream&amp;, JSC::DFG::OptimizationFixpointState);
297 void printInternal(PrintStream&amp;, JSC::DFG::GraphForm);
298 void printInternal(PrintStream&amp;, JSC::DFG::UnificationState);
299 void printInternal(PrintStream&amp;, JSC::DFG::RefCountState);
300 void printInternal(PrintStream&amp;, JSC::DFG::ProofStatus);
301 
302 } // namespace WTF
303 
304 #endif // ENABLE(DFG_JIT)
305 
306 namespace JSC { namespace DFG {
307 
308 // Put things here that must be defined even if ENABLE(DFG_JIT) is false.
309 
310 enum CapabilityLevel {
311     CannotCompile,
312     CanCompile,
313     CanCompileAndInline,
314     CapabilityLevelNotSet
315 };
316 
317 inline bool canCompile(CapabilityLevel level)
318 {
319     switch (level) {
320     case CanCompile:
321     case CanCompileAndInline:
322         return true;
323     default:
324         return false;
325     }
326 }
327 
328 inline bool canInline(CapabilityLevel level)
329 {
330     switch (level) {
331     case CanCompileAndInline:
332         return true;
333     default:
334         return false;
335     }
336 }
337 
338 inline CapabilityLevel leastUpperBound(CapabilityLevel a, CapabilityLevel b)
339 {
340     switch (a) {
341     case CannotCompile:
342         return CannotCompile;
343     case CanCompile:
344         switch (b) {
345         case CanCompile:
346         case CanCompileAndInline:
347             return CanCompile;
348         default:
349             return CannotCompile;
350         }
351     case CanCompileAndInline:
352         return b;
353     case CapabilityLevelNotSet:
354         ASSERT_NOT_REACHED();
355         return CannotCompile;
356     }
357     ASSERT_NOT_REACHED();
358     return CannotCompile;
359 }
360 
361 // Unconditionally disable DFG disassembly support if the DFG is not compiled in.
362 inline bool shouldDumpDisassembly(CompilationMode mode = DFGMode)
363 {
364 #if ENABLE(DFG_JIT)
365     return Options::dumpDisassembly() || Options::dumpDFGDisassembly() || (isFTL(mode) &amp;&amp; Options::dumpFTLDisassembly());
366 #else
367     UNUSED_PARAM(mode);
368     return false;
369 #endif
370 }
371 
372 } } // namespace JSC::DFG
373 
374 namespace WTF {
375 
376 void printInternal(PrintStream&amp;, JSC::DFG::CapabilityLevel);
377 
378 } // namespace WTF
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
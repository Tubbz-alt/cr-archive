<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewPrototypeFunctions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Error.h&quot;
 29 #include &quot;JSArrayBufferViewInlines.h&quot;
 30 #include &quot;JSCBuiltins.h&quot;
 31 #include &quot;JSCJSValueInlines.h&quot;
 32 #include &quot;JSFunction.h&quot;
 33 #include &quot;JSGenericTypedArrayViewInlines.h&quot;
 34 #include &quot;JSGenericTypedArrayViewPrototypeInlines.h&quot;
 35 #include &quot;JSStringJoiner.h&quot;
 36 #include &quot;StructureInlines.h&quot;
 37 #include &quot;TypedArrayAdaptors.h&quot;
 38 #include &quot;TypedArrayController.h&quot;
 39 #include &lt;wtf/StdLibExtras.h&gt;
 40 
 41 namespace JSC {
 42 
 43 // This implements 22.2.4.7 TypedArraySpeciesCreate
 44 // Note, that this function throws.
 45 template&lt;typename Functor&gt;
 46 inline JSArrayBufferView* speciesConstruct(JSGlobalObject* globalObject, JSObject* exemplar, MarkedArgumentBuffer&amp; args, const Functor&amp; defaultConstructor)
 47 {
 48     VM&amp; vm = getVM(globalObject);
 49     auto scope = DECLARE_THROW_SCOPE(vm);
 50 
 51     JSValue constructor = exemplar-&gt;get(globalObject, vm.propertyNames-&gt;constructor);
 52     RETURN_IF_EXCEPTION(scope, nullptr);
 53 
 54     if (constructor.isUndefined())
 55         RELEASE_AND_RETURN(scope, defaultConstructor());
 56 
 57     if (!constructor.isObject()) {
 58         throwTypeError(globalObject, scope, &quot;constructor Property should not be null&quot;_s);
 59         return nullptr;
 60     }
 61 
 62     JSValue species = constructor.get(globalObject, vm.propertyNames-&gt;speciesSymbol);
 63     RETURN_IF_EXCEPTION(scope, nullptr);
 64 
 65     if (species.isUndefinedOrNull())
 66         RELEASE_AND_RETURN(scope, defaultConstructor());
 67 
 68 
 69     JSValue result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);
 70     RETURN_IF_EXCEPTION(scope, nullptr);
 71 
 72     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result)) {
 73         if (view-&gt;type() == DataViewType) {
 74             throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);
 75             return nullptr;
 76         }
 77 
 78         if (!view-&gt;isNeutered())
 79             return view;
 80 
 81         throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
 82         return nullptr;
 83     }
 84 
 85     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);
 86     return nullptr;
 87 }
 88 
 89 inline unsigned argumentClampedIndexFromStartOrEnd(JSGlobalObject* globalObject, JSValue value, unsigned length, unsigned undefinedValue = 0)
 90 {
 91     if (value.isUndefined())
 92         return undefinedValue;
 93 
 94     double indexDouble = value.toInteger(globalObject);
 95     if (indexDouble &lt; 0) {
 96         indexDouble += length;
 97         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 98     }
 99     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
100 }
101 
102 template&lt;typename ViewClass&gt;
103 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSet(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
104 {
105     auto scope = DECLARE_THROW_SCOPE(vm);
106 
107     // 22.2.3.22
108     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
109 
110     if (UNLIKELY(!callFrame-&gt;argumentCount()))
111         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);
112 
113     unsigned offset;
114     if (callFrame-&gt;argumentCount() &gt;= 2) {
115         double offsetNumber = callFrame-&gt;uncheckedArgument(1).toInteger(globalObject);
116         RETURN_IF_EXCEPTION(scope, encodedJSValue());
117         if (UNLIKELY(offsetNumber &lt; 0))
118             return throwVMRangeError(globalObject, scope, &quot;Offset should not be negative&quot;);
119         offset = static_cast&lt;unsigned&gt;(std::min(offsetNumber, static_cast&lt;double&gt;(std::numeric_limits&lt;unsigned&gt;::max())));
120     } else
121         offset = 0;
122 
123     if (UNLIKELY(thisObject-&gt;isNeutered()))
124         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
125 
126     JSObject* sourceArray = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;uncheckedArgument(0));
127     if (UNLIKELY(!sourceArray))
128         return throwVMTypeError(globalObject, scope, &quot;First argument should be an object&quot;_s);
129 
130     unsigned length;
131     if (isTypedView(sourceArray-&gt;classInfo(vm)-&gt;typedArrayStorageType)) {
132         JSArrayBufferView* sourceView = jsCast&lt;JSArrayBufferView*&gt;(sourceArray);
133         if (UNLIKELY(sourceView-&gt;isNeutered()))
134             return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
135 
136         length = jsCast&lt;JSArrayBufferView*&gt;(sourceArray)-&gt;length();
137     } else {
138         JSValue lengthValue = sourceArray-&gt;get(globalObject, vm.propertyNames-&gt;length);
139         RETURN_IF_EXCEPTION(scope, encodedJSValue());
140         length = lengthValue.toUInt32(globalObject);
141     }
142 
143     RETURN_IF_EXCEPTION(scope, encodedJSValue());
144 
145     scope.release();
146     thisObject-&gt;set(globalObject, offset, sourceArray, 0, length, CopyType::Unobservable);
147     return JSValue::encode(jsUndefined());
148 }
149 
150 template&lt;typename ViewClass&gt;
151 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncCopyWithin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
152 {
153     auto scope = DECLARE_THROW_SCOPE(vm);
154 
155     // 22.2.3.5
156     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
157     if (thisObject-&gt;isNeutered())
158         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
159 
160     long length = thisObject-&gt;length();
161     long to = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);
162     RETURN_IF_EXCEPTION(scope, encodedJSValue());
163     long from = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);
164     RETURN_IF_EXCEPTION(scope, encodedJSValue());
165     long final = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(2), length, length);
166     RETURN_IF_EXCEPTION(scope, encodedJSValue());
167 
168     if (final &lt; from)
169         return JSValue::encode(callFrame-&gt;thisValue());
170 
171     long count = std::min(length - std::max(to, from), final - from);
172 
173     if (thisObject-&gt;isNeutered())
174         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
175 
176     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
177     memmove(array + to, array + from, count * thisObject-&gt;elementSize);
178 
179     return JSValue::encode(callFrame-&gt;thisValue());
180 }
181 
182 template&lt;typename ViewClass&gt;
183 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIncludes(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
184 {
185     auto scope = DECLARE_THROW_SCOPE(vm);
186 
187     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
188     if (thisObject-&gt;isNeutered())
189         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
190 
191     unsigned length = thisObject-&gt;length();
192 
193     if (!length)
194         return JSValue::encode(jsBoolean(false));
195 
196     JSValue valueToFind = callFrame-&gt;argument(0);
197 
198     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);
199     RETURN_IF_EXCEPTION(scope, encodedJSValue());
200 
201     if (thisObject-&gt;isNeutered())
202         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
203 
204     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
205     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
206     if (!targetOption)
207         return JSValue::encode(jsBoolean(false));
208 
209     scope.assertNoException();
210     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
211 
212     if (std::isnan(static_cast&lt;double&gt;(*targetOption))) {
213         for (; index &lt; length; ++index) {
214             if (std::isnan(static_cast&lt;double&gt;(array[index])))
215                 return JSValue::encode(jsBoolean(true));
216         }
217     } else {
218         for (; index &lt; length; ++index) {
219             if (array[index] == targetOption)
220                 return JSValue::encode(jsBoolean(true));
221         }
222     }
223 
224     return JSValue::encode(jsBoolean(false));
225 }
226 
227 template&lt;typename ViewClass&gt;
228 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
229 {
230     auto scope = DECLARE_THROW_SCOPE(vm);
231 
232     // 22.2.3.13
233     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
234     if (thisObject-&gt;isNeutered())
235         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
236 
237     if (!callFrame-&gt;argumentCount())
238         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);
239 
240     unsigned length = thisObject-&gt;length();
241 
242     JSValue valueToFind = callFrame-&gt;argument(0);
243     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);
244     RETURN_IF_EXCEPTION(scope, encodedJSValue());
245 
246     if (thisObject-&gt;isNeutered())
247         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
248 
249     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
250     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
251     if (!targetOption)
252         return JSValue::encode(jsNumber(-1));
253     scope.assertNoException();
254     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
255 
256     for (; index &lt; length; ++index) {
257         if (array[index] == targetOption)
258             return JSValue::encode(jsNumber(index));
259     }
260 
261     return JSValue::encode(jsNumber(-1));
262 }
263 
264 template&lt;typename ViewClass&gt;
265 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncJoin(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
266 {
267     auto scope = DECLARE_THROW_SCOPE(vm);
268 
269     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
270     if (thisObject-&gt;isNeutered())
271         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
272 
273     // 22.2.3.14
274     auto joinWithSeparator = [&amp;] (StringView separator) -&gt; EncodedJSValue {
275         ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
276         unsigned length = thisObject-&gt;length();
277 
278         JSStringJoiner joiner(globalObject, separator, length);
279         RETURN_IF_EXCEPTION(scope, encodedJSValue());
280         for (unsigned i = 0; i &lt; length; i++) {
281             joiner.append(globalObject, thisObject-&gt;getIndexQuickly(i));
282             RETURN_IF_EXCEPTION(scope, encodedJSValue());
283         }
284         RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(globalObject)));
285     };
286 
287     JSValue separatorValue = callFrame-&gt;argument(0);
288     if (separatorValue.isUndefined()) {
289         const LChar* comma = reinterpret_cast&lt;const LChar*&gt;(&quot;,&quot;);
290         return joinWithSeparator({ comma, 1 });
291     }
292 
293     JSString* separatorString = separatorValue.toString(globalObject);
294     RETURN_IF_EXCEPTION(scope, encodedJSValue());
295 
296     if (thisObject-&gt;isNeutered())
297         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
298     auto viewWithString = separatorString-&gt;viewWithUnderlyingString(globalObject);
299     RETURN_IF_EXCEPTION(scope, encodedJSValue());
300     return joinWithSeparator(viewWithString.view);
301 }
302 
303 template&lt;typename ViewClass&gt;
304 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncLastIndexOf(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
305 {
306     auto scope = DECLARE_THROW_SCOPE(vm);
307 
308     // 22.2.3.16
309     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
310     if (thisObject-&gt;isNeutered())
311         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
312 
313     if (!callFrame-&gt;argumentCount())
314         return throwVMTypeError(globalObject, scope, &quot;Expected at least one argument&quot;_s);
315 
316     unsigned length = thisObject-&gt;length();
317 
318     JSValue valueToFind = callFrame-&gt;argument(0);
319 
320     int index = length - 1;
321     if (callFrame-&gt;argumentCount() &gt;= 2) {
322         JSValue fromValue = callFrame-&gt;uncheckedArgument(1);
323         double fromDouble = fromValue.toInteger(globalObject);
324         RETURN_IF_EXCEPTION(scope, encodedJSValue());
325         if (fromDouble &lt; 0) {
326             fromDouble += length;
327             if (fromDouble &lt; 0)
328                 return JSValue::encode(jsNumber(-1));
329         }
330         if (fromDouble &lt; length)
331             index = static_cast&lt;unsigned&gt;(fromDouble);
332     }
333 
334     if (thisObject-&gt;isNeutered())
335         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
336 
337     auto targetOption = ViewClass::toAdaptorNativeFromValueWithoutCoercion(valueToFind);
338     if (!targetOption)
339         return JSValue::encode(jsNumber(-1));
340 
341     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
342     scope.assertNoException();
343     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
344 
345     for (; index &gt;= 0; --index) {
346         if (array[index] == targetOption)
347             return JSValue::encode(jsNumber(index));
348     }
349 
350     return JSValue::encode(jsNumber(-1));
351 }
352 
353 template&lt;typename ViewClass&gt;
354 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncBuffer(VM&amp;, JSGlobalObject* globalObject, CallFrame* callFrame)
355 {
356     // 22.2.3.3
357     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
358 
359     return JSValue::encode(thisObject-&gt;possiblySharedJSBuffer(globalObject));
360 }
361 
362 template&lt;typename ViewClass&gt;
363 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)
364 {
365     // 22.2.3.17
366     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
367 
368     return JSValue::encode(jsNumber(thisObject-&gt;length()));
369 }
370 
371 template&lt;typename ViewClass&gt;
372 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteLength(VM&amp;, JSGlobalObject*, CallFrame* callFrame)
373 {
374     // 22.2.3.2
375     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
376 
377     return JSValue::encode(jsNumber(thisObject-&gt;byteLength()));
378 }
379 
380 template&lt;typename ViewClass&gt;
381 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoGetterFuncByteOffset(VM&amp;, JSGlobalObject*, CallFrame* callFrame)
382 {
383     // 22.2.3.3
384     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
385 
386     return JSValue::encode(jsNumber(thisObject-&gt;byteOffset()));
387 }
388 
389 template&lt;typename ViewClass&gt;
390 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncReverse(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
391 {
392 //    VM&amp; vm = getVM(globalObject);
393     auto scope = DECLARE_THROW_SCOPE(vm);
394 
395     // 22.2.3.21
396     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
397     if (thisObject-&gt;isNeutered())
398         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
399 
400     typename ViewClass::ElementType* array = thisObject-&gt;typedVector();
401     std::reverse(array, array + thisObject-&gt;length());
402 
403     return JSValue::encode(thisObject);
404 }
405 
406 template&lt;typename ViewClass&gt;
407 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSort(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
408 {
409 //    VM&amp; vm = getVM(globalObject);
410     auto scope = DECLARE_THROW_SCOPE(vm);
411 
412     // 22.2.3.25
413     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;argument(0));
414     if (thisObject-&gt;isNeutered())
415         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
416 
417     thisObject-&gt;sort();
418 
419     return JSValue::encode(thisObject);
420 }
421 
422 template&lt;typename ViewClass&gt;
423 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewProtoFuncSlice(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame)
424 {
425     auto scope = DECLARE_THROW_SCOPE(vm);
426 
427     // 22.2.3.26
428 
429     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
430     if (thisObject-&gt;isNeutered())
431         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
432 
433     unsigned thisLength = thisObject-&gt;length();
434 
435     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);
436     RETURN_IF_EXCEPTION(scope, encodedJSValue());
437     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);
438     RETURN_IF_EXCEPTION(scope, encodedJSValue());
439 
440     if (thisObject-&gt;isNeutered())
441         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
442 
443     // Clamp end to begin.
444     end = std::max(begin, end);
445 
446     ASSERT(end &gt;= begin);
447     unsigned length = end - begin;
448 
449     MarkedArgumentBuffer args;
450     args.append(jsNumber(length));
451     ASSERT(!args.hasOverflowed());
452 
453     JSArrayBufferView* result = speciesConstruct(globalObject, thisObject, args, [&amp;]() {
454         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);
455         return ViewClass::createUninitialized(globalObject, structure, length);
456     });
457     RETURN_IF_EXCEPTION(scope, encodedJSValue());
458 
459     ASSERT(!result-&gt;isNeutered());
460     if (thisObject-&gt;isNeutered())
461         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
462 
463     // We return early here since we don&#39;t allocate a backing store if length is 0 and memmove does not like nullptrs
464     if (!length)
465         return JSValue::encode(result);
466 
467     // The species constructor may return an array with any arbitrary length.
468     length = std::min(length, result-&gt;length());
469     switch (result-&gt;classInfo(vm)-&gt;typedArrayStorageType) {
470     case TypeInt8:
471         scope.release();
472         jsCast&lt;JSInt8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
473         return JSValue::encode(result);
474     case TypeInt16:
475         scope.release();
476         jsCast&lt;JSInt16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
477         return JSValue::encode(result);
478     case TypeInt32:
479         scope.release();
480         jsCast&lt;JSInt32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
481         return JSValue::encode(result);
482     case TypeUint8:
483         scope.release();
484         jsCast&lt;JSUint8Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
485         return JSValue::encode(result);
486     case TypeUint8Clamped:
487         scope.release();
488         jsCast&lt;JSUint8ClampedArray*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
489         return JSValue::encode(result);
490     case TypeUint16:
491         scope.release();
492         jsCast&lt;JSUint16Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
493         return JSValue::encode(result);
494     case TypeUint32:
495         scope.release();
496         jsCast&lt;JSUint32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
497         return JSValue::encode(result);
498     case TypeFloat32:
499         scope.release();
500         jsCast&lt;JSFloat32Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
501         return JSValue::encode(result);
502     case TypeFloat64:
503         scope.release();
504         jsCast&lt;JSFloat64Array*&gt;(result)-&gt;set(globalObject, 0, thisObject, begin, length, CopyType::LeftToRight);
505         return JSValue::encode(result);
506     default:
507         RELEASE_ASSERT_NOT_REACHED();
508     }
509 }
510 
511 template&lt;typename ViewClass&gt;
512 EncodedJSValue JSC_HOST_CALL genericTypedArrayViewPrivateFuncSubarrayCreate(VM&amp;vm, JSGlobalObject* globalObject, CallFrame* callFrame)
513 {
514     auto scope = DECLARE_THROW_SCOPE(vm);
515 
516     // 22.2.3.23
517 
518     ViewClass* thisObject = jsCast&lt;ViewClass*&gt;(callFrame-&gt;thisValue());
519     if (thisObject-&gt;isNeutered())
520         return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
521 
522     // Get the length here; later assert that the length didn&#39;t change.
523     unsigned thisLength = thisObject-&gt;length();
524 
525     // I would assert that the arguments are integers here but that&#39;s not true since
526     // https://tc39.github.io/ecma262/#sec-tointeger allows the result of the operation
527     // to be +/- Infinity and -0.
528     ASSERT(callFrame-&gt;argument(0).isNumber());
529     ASSERT(callFrame-&gt;argument(1).isUndefined() || callFrame-&gt;argument(1).isNumber());
530     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), thisLength);
531     scope.assertNoException();
532     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), thisLength, thisLength);
533     scope.assertNoException();
534 
535     RELEASE_ASSERT(!thisObject-&gt;isNeutered());
536 
537     // Clamp end to begin.
538     end = std::max(begin, end);
539 
540     ASSERT(end &gt;= begin);
541     unsigned offset = begin;
542     unsigned length = end - begin;
543 
544     RefPtr&lt;ArrayBuffer&gt; arrayBuffer = thisObject-&gt;possiblySharedBuffer();
545     RELEASE_ASSERT(thisLength == thisObject-&gt;length());
546 
547     unsigned newByteOffset = thisObject-&gt;byteOffset() + offset * ViewClass::elementSize;
548 
549     JSObject* defaultConstructor = globalObject-&gt;typedArrayConstructor(ViewClass::TypedArrayStorageType);
550     JSValue species = callFrame-&gt;uncheckedArgument(2);
551     if (species == defaultConstructor) {
552         Structure* structure = globalObject-&gt;typedArrayStructure(ViewClass::TypedArrayStorageType);
553 
554         RELEASE_AND_RETURN(scope, JSValue::encode(ViewClass::create(
555             globalObject, structure, WTFMove(arrayBuffer),
556             thisObject-&gt;byteOffset() + offset * ViewClass::elementSize,
557             length)));
558     }
559 
560     MarkedArgumentBuffer args;
561     args.append(vm.m_typedArrayController-&gt;toJS(globalObject, thisObject-&gt;globalObject(vm), arrayBuffer.get()));
562     args.append(jsNumber(newByteOffset));
563     args.append(jsNumber(length));
564     ASSERT(!args.hasOverflowed());
565 
566     JSObject* result = construct(globalObject, species, args, &quot;species is not a constructor&quot;);
567     RETURN_IF_EXCEPTION(scope, encodedJSValue());
568 
569     if (jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, result))
570         return JSValue::encode(result);
571 
572     throwTypeError(globalObject, scope, &quot;species constructor did not return a TypedArray View&quot;_s);
573     return JSValue::encode(JSValue());
574 }
575 
576 } // namespace JSC
    </pre>
  </body>
</html>
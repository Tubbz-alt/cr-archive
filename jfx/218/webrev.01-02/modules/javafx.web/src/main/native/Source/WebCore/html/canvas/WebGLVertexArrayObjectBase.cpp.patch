diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLVertexArrayObjectBase.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLVertexArrayObjectBase.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLVertexArrayObjectBase.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLVertexArrayObjectBase.cpp
@@ -42,25 +42,25 @@
 void WebGLVertexArrayObjectBase::setElementArrayBuffer(WebGLBuffer* buffer)
 {
     if (buffer)
         buffer->onAttached();
     if (m_boundElementArrayBuffer)
-        m_boundElementArrayBuffer->onDetached(context()->graphicsContext3D());
+        m_boundElementArrayBuffer->onDetached(context()->graphicsContextGL());
     m_boundElementArrayBuffer = buffer;
 
 }
 
-void WebGLVertexArrayObjectBase::setVertexAttribState(GC3Duint index, GC3Dsizei bytesPerElement, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, GC3Dintptr offset, WebGLBuffer* buffer)
+void WebGLVertexArrayObjectBase::setVertexAttribState(GCGLuint index, GCGLsizei bytesPerElement, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset, WebGLBuffer* buffer)
 {
-    GC3Dsizei validatedStride = stride ? stride : bytesPerElement;
+    GCGLsizei validatedStride = stride ? stride : bytesPerElement;
 
     auto& state = m_vertexAttribState[index];
 
     if (buffer)
         buffer->onAttached();
     if (state.bufferBinding)
-        state.bufferBinding->onDetached(context()->graphicsContext3D());
+        state.bufferBinding->onDetached(context()->graphicsContextGL());
 
     state.bufferBinding = buffer;
     state.bytesPerElement = bytesPerElement;
     state.size = size;
     state.type = type;
@@ -71,36 +71,36 @@
 }
 
 void WebGLVertexArrayObjectBase::unbindBuffer(WebGLBuffer& buffer)
 {
     if (m_boundElementArrayBuffer == &buffer) {
-        m_boundElementArrayBuffer->onDetached(context()->graphicsContext3D());
+        m_boundElementArrayBuffer->onDetached(context()->graphicsContextGL());
         m_boundElementArrayBuffer = nullptr;
     }
 
     for (size_t i = 0; i < m_vertexAttribState.size(); ++i) {
         auto& state = m_vertexAttribState[i];
         if (state.bufferBinding == &buffer) {
-            buffer.onDetached(context()->graphicsContext3D());
+            buffer.onDetached(context()->graphicsContextGL());
 
             if (!i && !context()->isGLES2Compliant()) {
                 state.bufferBinding = context()->m_vertexAttrib0Buffer;
                 state.bufferBinding->onAttached();
                 state.bytesPerElement = 0;
                 state.size = 4;
-                state.type = GraphicsContext3D::FLOAT;
+                state.type = GraphicsContextGL::FLOAT;
                 state.normalized = false;
                 state.stride = 16;
                 state.originalStride = 0;
                 state.offset = 0;
             } else
                 state.bufferBinding = nullptr;
         }
     }
 }
 
-void WebGLVertexArrayObjectBase::setVertexAttribDivisor(GC3Duint index, GC3Duint divisor)
+void WebGLVertexArrayObjectBase::setVertexAttribDivisor(GCGLuint index, GCGLuint divisor)
 {
     m_vertexAttribState[index].divisor = divisor;
 }
 
 }

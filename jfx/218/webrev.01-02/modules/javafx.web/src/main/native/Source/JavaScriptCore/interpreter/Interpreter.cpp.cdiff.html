<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameTracers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/Interpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,10 ***</span>
<span class="line-new-header">--- 32,11 ---</span>
  
  #include &quot;BatchedTransitionOptimizer.h&quot;
  #include &quot;Bytecodes.h&quot;
  #include &quot;CallFrameClosure.h&quot;
  #include &quot;CatchScope.h&quot;
<span class="line-added">+ #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeCache.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;ExecutableBaseInlines.h&quot;
  #include &quot;Heap.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,11 ***</span>
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JITCodeInlines.h&quot;
  #include &quot;JSArrayInlines.h&quot;
  #include &quot;JSBoundFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;JSModuleEnvironment.h&quot;
  #include &quot;JSString.h&quot;
  #include &quot;JSWithScope.h&quot;
<span class="line-new-header">--- 52,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 64,11 ***</span>
  #include &quot;LiteralParser.h&quot;
  #include &quot;ModuleProgramCodeBlock.h&quot;
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">! #include &quot;ProtoCallFrame.h&quot;</span>
  #include &quot;RegExpObject.h&quot;
  #include &quot;Register.h&quot;
  #include &quot;RegisterAtOffsetList.h&quot;
  #include &quot;ScopedArguments.h&quot;
  #include &quot;StackAlignment.h&quot;
<span class="line-new-header">--- 64,11 ---</span>
  #include &quot;LiteralParser.h&quot;
  #include &quot;ModuleProgramCodeBlock.h&quot;
  #include &quot;ObjectPrototype.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;ProgramCodeBlock.h&quot;
<span class="line-modified">! #include &quot;ProtoCallFrameInlines.h&quot;</span>
  #include &quot;RegExpObject.h&quot;
  #include &quot;Register.h&quot;
  #include &quot;RegisterAtOffsetList.h&quot;
  #include &quot;ScopedArguments.h&quot;
  #include &quot;StackAlignment.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,35 ***</span>
  #include &quot;WebAssemblyFunction.h&quot;
  #endif
  
  namespace JSC {
  
<span class="line-modified">! JSValue eval(CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!callFrame-&gt;argumentCount())
          return jsUndefined();
  
      JSValue program = callFrame-&gt;argument(0);
      if (!program.isString())
          return program;
  
      TopCallFrameSetter topCallFrame(vm, callFrame);
<span class="line-removed">-     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject();</span>
      if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">!         throwException(callFrame, scope, createEvalError(callFrame, globalObject-&gt;evalDisabledErrorMessage()));</span>
          return jsUndefined();
      }
<span class="line-modified">!     String programSource = asString(program)-&gt;value(callFrame);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      CallFrame* callerFrame = callFrame-&gt;callerFrame();
      CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified">!     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister().offset()).Register::scope();</span>
      UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
  
      bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
  
      DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
<span class="line-new-header">--- 99,34 ---</span>
  #include &quot;WebAssemblyFunction.h&quot;
  #endif
  
  namespace JSC {
  
<span class="line-modified">! JSValue eval(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (!callFrame-&gt;argumentCount())
          return jsUndefined();
  
      JSValue program = callFrame-&gt;argument(0);
      if (!program.isString())
          return program;
  
      TopCallFrameSetter topCallFrame(vm, callFrame);
      if (!globalObject-&gt;evalEnabled()) {
<span class="line-modified">!         throwException(globalObject, scope, createEvalError(globalObject, globalObject-&gt;evalDisabledErrorMessage()));</span>
          return jsUndefined();
      }
<span class="line-modified">!     String programSource = asString(program)-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, JSValue());
  
      CallFrame* callerFrame = callFrame-&gt;callerFrame();
      CallSiteIndex callerCallSiteIndex = callerFrame-&gt;callSiteIndex();
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
<span class="line-modified">!     JSScope* callerScopeChain = callerFrame-&gt;uncheckedR(callerCodeBlock-&gt;scopeRegister()).Register::scope();</span>
      UnlinkedCodeBlock* callerUnlinkedCodeBlock = callerCodeBlock-&gt;unlinkedCodeBlock();
  
      bool isArrowFunctionContext = callerUnlinkedCodeBlock-&gt;isArrowFunction() || callerUnlinkedCodeBlock-&gt;isArrowFunctionContext();
  
      DerivedContextType derivedContextType = callerUnlinkedCodeBlock-&gt;derivedContextType();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,201 ***</span>
              ? DerivedContextType::DerivedConstructorContext
              : DerivedContextType::DerivedMethodContext;
      }
  
      EvalContextType evalContextType;
<span class="line-modified">!     if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))</span>
          evalContextType = EvalContextType::FunctionEvalContext;
      else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
          evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
      else
          evalContextType = EvalContextType::None;
  
      DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
      if (!eval) {
          if (!callerCodeBlock-&gt;isStrictMode()) {
              if (programSource.is8Bit()) {
<span class="line-modified">!                 LiteralParser&lt;LChar&gt; preparser(callFrame, programSource.characters8(), programSource.length(), NonStrictJSON);</span>
                  if (JSValue parsedObject = preparser.tryLiteralParse())
                      RELEASE_AND_RETURN(scope, parsedObject);
  
              } else {
<span class="line-modified">!                 LiteralParser&lt;UChar&gt; preparser(callFrame, programSource.characters16(), programSource.length(), NonStrictJSON);</span>
                  if (JSValue parsedObject = preparser.tryLiteralParse())
                      RELEASE_AND_RETURN(scope, parsedObject);
  
              }
              RETURN_IF_EXCEPTION(scope, JSValue());
          }
  
          VariableEnvironment variablesUnderTDZ;
          JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
<span class="line-modified">!         eval = DirectEvalExecutable::create(callFrame, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !eval);
          if (!eval)
              return jsUndefined();
  
<span class="line-modified">!         callerCodeBlock-&gt;directEvalCodeCache().set(callFrame, callerCodeBlock, programSource, callerCallSiteIndex, eval);</span>
      }
  
      JSValue thisValue = callerFrame-&gt;thisValue();
      Interpreter* interpreter = vm.interpreter;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, callFrame, thisValue, callerScopeChain));</span>
  }
  
<span class="line-modified">! unsigned sizeOfVarargs(CallFrame* callFrame, JSValue arguments, uint32_t firstVarArgOffset)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(!arguments.isCell())) {
          if (arguments.isUndefinedOrNull())
              return 0;
  
<span class="line-modified">!         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame, arguments));</span>
          return 0;
      }
  
      JSCell* cell = arguments.asCell();
      unsigned length;
      switch (cell-&gt;type()) {
      case DirectArgumentsType:
<span class="line-modified">!         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(callFrame);</span>
          break;
      case ScopedArgumentsType:
<span class="line-modified">!         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(callFrame);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JSFixedArrayType:</span>
<span class="line-removed">-         length = jsCast&lt;JSFixedArray*&gt;(cell)-&gt;size();</span>
          break;
      case JSImmutableButterflyType:
          length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
          break;
      case StringType:
      case SymbolType:
      case BigIntType:
<span class="line-modified">!         throwException(callFrame, scope, createInvalidFunctionApplyParameterError(callFrame,  arguments));</span>
          return 0;
  
      default:
          RELEASE_ASSERT(arguments.isObject());
<span class="line-modified">!         length = clampToUnsigned(toLength(callFrame, jsCast&lt;JSObject*&gt;(cell)));</span>
          break;
      }
      RETURN_IF_EXCEPTION(scope, 0);
  
      if (length &gt;= firstVarArgOffset)
          length -= firstVarArgOffset;
      else
          length = 0;
  
      return length;
  }
  
<span class="line-modified">! unsigned sizeFrameForForwardArguments(CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = callFrame-&gt;argumentCount();
      CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
      if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
<span class="line-modified">!         throwStackOverflowError(callFrame, scope);</span>
  
      return length;
  }
  
<span class="line-modified">! unsigned sizeFrameForVarargs(CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     unsigned length = sizeOfVarargs(callFrame, arguments, firstVarArgOffset);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
      if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
<span class="line-modified">!         throwStackOverflowError(callFrame, scope);</span>
          return 0;
      }
  
      return length;
  }
  
<span class="line-modified">! void loadVarargs(CallFrame* callFrame, VirtualRegister firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)</span>
  {
      if (UNLIKELY(!arguments.isCell()) || !length)
          return;
  
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSCell* cell = arguments.asCell();
  
      switch (cell-&gt;type()) {
      case DirectArgumentsType:
          scope.release();
<span class="line-modified">!         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
          return;
      case ScopedArgumentsType:
          scope.release();
<span class="line-modified">!         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     case JSFixedArrayType:</span>
<span class="line-removed">-         scope.release();</span>
<span class="line-removed">-         jsCast&lt;JSFixedArray*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
          return;
      case JSImmutableButterflyType:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
          return;
      default: {
          ASSERT(arguments.isObject());
          JSObject* object = jsCast&lt;JSObject*&gt;(cell);
          if (isJSArray(object)) {
              scope.release();
<span class="line-modified">!             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(callFrame, firstElementDest, offset, length);</span>
              return;
          }
          unsigned i;
          for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
<span class="line-modified">!             callFrame-&gt;r(firstElementDest + i) = object-&gt;getIndexQuickly(i + offset);</span>
          for (; i &lt; length; ++i) {
<span class="line-modified">!             JSValue value = object-&gt;get(callFrame, i + offset);</span>
              RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!             callFrame-&gt;r(firstElementDest + i) = value;</span>
          }
          return;
      } }
  }
  
<span class="line-modified">! void setupVarargsFrame(CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)</span>
  {
      VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
  
      loadVarargs(
<span class="line-modified">!         callFrame,</span>
<span class="line-modified">!         calleeFrameOffset + CallFrame::argumentOffset(0),</span>
          arguments, offset, length);
  
      newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
  }
  
<span class="line-modified">! void setupVarargsFrameAndSetThis(CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)</span>
  {
<span class="line-modified">!     setupVarargsFrame(callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
      newCallFrame-&gt;setThisValue(thisValue);
  }
  
<span class="line-modified">! void setupForwardArgumentsFrame(CallFrame* execCaller, CallFrame* execCallee, uint32_t length)</span>
  {
      ASSERT(length == execCaller-&gt;argumentCount());
      unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
      memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
      execCallee-&gt;setArgumentCountIncludingThis(length + 1);
  }
  
<span class="line-modified">! void setupForwardArgumentsFrameAndSetThis(CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)</span>
  {
<span class="line-modified">!     setupForwardArgumentsFrame(execCaller, execCallee, length);</span>
      execCallee-&gt;setThisValue(thisValue);
  }
  
  
  
<span class="line-new-header">--- 135,199 ---</span>
              ? DerivedContextType::DerivedConstructorContext
              : DerivedContextType::DerivedMethodContext;
      }
  
      EvalContextType evalContextType;
<span class="line-modified">!     if (callerUnlinkedCodeBlock-&gt;parseMode() == SourceParseMode::InstanceFieldInitializerMode)</span>
<span class="line-added">+         evalContextType = EvalContextType::InstanceFieldEvalContext;</span>
<span class="line-added">+     else if (isFunctionParseMode(callerUnlinkedCodeBlock-&gt;parseMode()))</span>
          evalContextType = EvalContextType::FunctionEvalContext;
      else if (callerUnlinkedCodeBlock-&gt;codeType() == EvalCode)
          evalContextType = callerUnlinkedCodeBlock-&gt;evalContextType();
      else
          evalContextType = EvalContextType::None;
  
      DirectEvalExecutable* eval = callerCodeBlock-&gt;directEvalCodeCache().tryGet(programSource, callerCallSiteIndex);
      if (!eval) {
          if (!callerCodeBlock-&gt;isStrictMode()) {
              if (programSource.is8Bit()) {
<span class="line-modified">!                 LiteralParser&lt;LChar&gt; preparser(globalObject, programSource.characters8(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
                  if (JSValue parsedObject = preparser.tryLiteralParse())
                      RELEASE_AND_RETURN(scope, parsedObject);
  
              } else {
<span class="line-modified">!                 LiteralParser&lt;UChar&gt; preparser(globalObject, programSource.characters16(), programSource.length(), NonStrictJSON, callerCodeBlock);</span>
                  if (JSValue parsedObject = preparser.tryLiteralParse())
                      RELEASE_AND_RETURN(scope, parsedObject);
  
              }
              RETURN_IF_EXCEPTION(scope, JSValue());
          }
  
          VariableEnvironment variablesUnderTDZ;
          JSScope::collectClosureVariablesUnderTDZ(callerScopeChain, variablesUnderTDZ);
<span class="line-modified">!         eval = DirectEvalExecutable::create(globalObject, makeSource(programSource, callerCodeBlock-&gt;source().provider()-&gt;sourceOrigin()), callerCodeBlock-&gt;isStrictMode(), derivedContextType, callerUnlinkedCodeBlock-&gt;needsClassFieldInitializer(), isArrowFunctionContext, evalContextType, &amp;variablesUnderTDZ);</span>
          EXCEPTION_ASSERT(!!scope.exception() == !eval);
          if (!eval)
              return jsUndefined();
  
<span class="line-modified">!         callerCodeBlock-&gt;directEvalCodeCache().set(globalObject, callerCodeBlock, programSource, callerCallSiteIndex, eval);</span>
      }
  
      JSValue thisValue = callerFrame-&gt;thisValue();
      Interpreter* interpreter = vm.interpreter;
<span class="line-modified">!     RELEASE_AND_RETURN(scope, interpreter-&gt;execute(eval, globalObject, thisValue, callerScopeChain));</span>
  }
  
<span class="line-modified">! unsigned sizeOfVarargs(JSGlobalObject* globalObject, JSValue arguments, uint32_t firstVarArgOffset)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (UNLIKELY(!arguments.isCell())) {
          if (arguments.isUndefinedOrNull())
              return 0;
  
<span class="line-modified">!         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject, arguments));</span>
          return 0;
      }
  
      JSCell* cell = arguments.asCell();
      unsigned length;
      switch (cell-&gt;type()) {
      case DirectArgumentsType:
<span class="line-modified">!         length = jsCast&lt;DirectArguments*&gt;(cell)-&gt;length(globalObject);</span>
          break;
      case ScopedArgumentsType:
<span class="line-modified">!         length = jsCast&lt;ScopedArguments*&gt;(cell)-&gt;length(globalObject);</span>
          break;
      case JSImmutableButterflyType:
          length = jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;length();
          break;
      case StringType:
      case SymbolType:
      case BigIntType:
<span class="line-modified">!         throwException(globalObject, scope, createInvalidFunctionApplyParameterError(globalObject,  arguments));</span>
          return 0;
  
      default:
          RELEASE_ASSERT(arguments.isObject());
<span class="line-modified">!         length = clampToUnsigned(toLength(globalObject, jsCast&lt;JSObject*&gt;(cell)));</span>
          break;
      }
      RETURN_IF_EXCEPTION(scope, 0);
  
<span class="line-added">+     if (length &gt; maxArguments)</span>
<span class="line-added">+         throwStackOverflowError(globalObject, scope);</span>
<span class="line-added">+ </span>
      if (length &gt;= firstVarArgOffset)
          length -= firstVarArgOffset;
      else
          length = 0;
  
      return length;
  }
  
<span class="line-modified">! unsigned sizeFrameForForwardArguments(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, unsigned numUsedStackSlots)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      unsigned length = callFrame-&gt;argumentCount();
      CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
      if (UNLIKELY(!vm.ensureStackCapacityFor(calleeFrame-&gt;registers())))
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
  
      return length;
  }
  
<span class="line-modified">! unsigned sizeFrameForVarargs(JSGlobalObject* globalObject, CallFrame* callFrame, VM&amp; vm, JSValue arguments, unsigned numUsedStackSlots, uint32_t firstVarArgOffset)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     unsigned length = sizeOfVarargs(globalObject, arguments, firstVarArgOffset);</span>
      RETURN_IF_EXCEPTION(scope, 0);
  
      CallFrame* calleeFrame = calleeFrameForVarargs(callFrame, numUsedStackSlots, length + 1);
      if (UNLIKELY(length &gt; maxArguments || !vm.ensureStackCapacityFor(calleeFrame-&gt;registers()))) {
<span class="line-modified">!         throwStackOverflowError(globalObject, scope);</span>
          return 0;
      }
  
      return length;
  }
  
<span class="line-modified">! void loadVarargs(JSGlobalObject* globalObject, JSValue* firstElementDest, JSValue arguments, uint32_t offset, uint32_t length)</span>
  {
      if (UNLIKELY(!arguments.isCell()) || !length)
          return;
  
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSCell* cell = arguments.asCell();
  
      switch (cell-&gt;type()) {
      case DirectArgumentsType:
          scope.release();
<span class="line-modified">!         jsCast&lt;DirectArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
          return;
      case ScopedArgumentsType:
          scope.release();
<span class="line-modified">!         jsCast&lt;ScopedArguments*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
          return;
      case JSImmutableButterflyType:
          scope.release();
<span class="line-modified">!         jsCast&lt;JSImmutableButterfly*&gt;(cell)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
          return;
      default: {
          ASSERT(arguments.isObject());
          JSObject* object = jsCast&lt;JSObject*&gt;(cell);
          if (isJSArray(object)) {
              scope.release();
<span class="line-modified">!             jsCast&lt;JSArray*&gt;(object)-&gt;copyToArguments(globalObject, firstElementDest, offset, length);</span>
              return;
          }
          unsigned i;
          for (i = 0; i &lt; length &amp;&amp; object-&gt;canGetIndexQuickly(i + offset); ++i)
<span class="line-modified">!             firstElementDest[i] = object-&gt;getIndexQuickly(i + offset);</span>
          for (; i &lt; length; ++i) {
<span class="line-modified">!             JSValue value = object-&gt;get(globalObject, i + offset);</span>
              RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!             firstElementDest[i] = value;</span>
          }
          return;
      } }
  }
  
<span class="line-modified">! void setupVarargsFrame(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue arguments, uint32_t offset, uint32_t length)</span>
  {
      VirtualRegister calleeFrameOffset(newCallFrame - callFrame);
  
      loadVarargs(
<span class="line-modified">!         globalObject,</span>
<span class="line-modified">!         bitwise_cast&lt;JSValue*&gt;(&amp;callFrame-&gt;r(calleeFrameOffset + CallFrame::argumentOffset(0))),</span>
          arguments, offset, length);
  
      newCallFrame-&gt;setArgumentCountIncludingThis(length + 1);
  }
  
<span class="line-modified">! void setupVarargsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* callFrame, CallFrame* newCallFrame, JSValue thisValue, JSValue arguments, uint32_t firstVarArgOffset, uint32_t length)</span>
  {
<span class="line-modified">!     setupVarargsFrame(globalObject, callFrame, newCallFrame, arguments, firstVarArgOffset, length);</span>
      newCallFrame-&gt;setThisValue(thisValue);
  }
  
<span class="line-modified">! void setupForwardArgumentsFrame(JSGlobalObject*, CallFrame* execCaller, CallFrame* execCallee, uint32_t length)</span>
  {
      ASSERT(length == execCaller-&gt;argumentCount());
      unsigned offset = execCaller-&gt;argumentOffset(0) * sizeof(Register);
      memcpy(reinterpret_cast&lt;char*&gt;(execCallee) + offset, reinterpret_cast&lt;char*&gt;(execCaller) + offset, length * sizeof(Register));
      execCallee-&gt;setArgumentCountIncludingThis(length + 1);
  }
  
<span class="line-modified">! void setupForwardArgumentsFrameAndSetThis(JSGlobalObject* globalObject, CallFrame* execCaller, CallFrame* execCallee, JSValue thisValue, uint32_t length)</span>
  {
<span class="line-modified">!     setupForwardArgumentsFrame(globalObject, execCaller, execCallee, length);</span>
      execCallee-&gt;setThisValue(thisValue);
  }
  
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,27 ***</span>
      : m_vm(vm)
  #if ENABLE(C_LOOP)
      , m_cloopStack(vm)
  #endif
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      static std::once_flag assertOnceKey;
      std::call_once(assertOnceKey, [] {
          for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
              OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
              RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
          }
      });
<span class="line-modified">! #endif // USE(LLINT_EMBEDDED_OPCODE_ID)</span>
  }
  
  Interpreter::~Interpreter()
  {
  }
  
  #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified">! #if !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
  HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
  {
      static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
  
      static std::once_flag initializeKey;
<span class="line-new-header">--- 335,27 ---</span>
      : m_vm(vm)
  #if ENABLE(C_LOOP)
      , m_cloopStack(vm)
  #endif
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      static std::once_flag assertOnceKey;
      std::call_once(assertOnceKey, [] {
          for (unsigned i = 0; i &lt; NUMBER_OF_BYTECODE_IDS; ++i) {
              OpcodeID opcodeID = static_cast&lt;OpcodeID&gt;(i);
              RELEASE_ASSERT(getOpcodeID(getOpcode(opcodeID)) == opcodeID);
          }
      });
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  }
  
  Interpreter::~Interpreter()
  {
  }
  
  #if ENABLE(COMPUTED_GOTO_OPCODES)
<span class="line-modified">! #if !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
  HashMap&lt;Opcode, OpcodeID&gt;&amp; Interpreter::opcodeIDTable()
  {
      static NeverDestroyed&lt;HashMap&lt;Opcode, OpcodeID&gt;&gt; opcodeIDTable;
  
      static std::once_flag initializeKey;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 368,25 ***</span>
              opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
      });
  
      return opcodeIDTable;
  }
<span class="line-modified">! #endif // !USE(LLINT_EMBEDDED_OPCODE_ID) || !ASSERT_DISABLED</span>
  #endif // ENABLE(COMPUTED_GOTO_OPCODES)
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  bool Interpreter::isOpcode(Opcode opcode)
  {
  #if ENABLE(COMPUTED_GOTO_OPCODES)
      return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
          &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
          &amp;&amp; opcodeIDTable().contains(opcode);
  #else
      return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
  #endif
  }
<span class="line-modified">! #endif // !ASSERT_DISABLED</span>
  
  class GetStackTraceFunctor {
  public:
      GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
          : m_vm(vm)
<span class="line-new-header">--- 365,25 ---</span>
              opcodeIDTable.get().add(opcodeTable[i], static_cast&lt;OpcodeID&gt;(i));
      });
  
      return opcodeIDTable;
  }
<span class="line-modified">! #endif // !ENABLE(LLINT_EMBEDDED_OPCODE_ID) || ASSERT_ENABLED</span>
  #endif // ENABLE(COMPUTED_GOTO_OPCODES)
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  bool Interpreter::isOpcode(Opcode opcode)
  {
  #if ENABLE(COMPUTED_GOTO_OPCODES)
      return opcode != HashTraits&lt;Opcode&gt;::emptyValue()
          &amp;&amp; !HashTraits&lt;Opcode&gt;::isDeletedValue(opcode)
          &amp;&amp; opcodeIDTable().contains(opcode);
  #else
      return opcode &gt;= 0 &amp;&amp; opcode &lt;= op_end;
  #endif
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  class GetStackTraceFunctor {
  public:
      GetStackTraceFunctor(VM&amp; vm, JSCell* owner, Vector&lt;StackFrame&gt;&amp; results, size_t framesToSkip, size_t capacity)
          : m_vm(vm)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 408,11 ***</span>
          if (m_remainingCapacityForFrameCapture) {
              if (visitor-&gt;isWasmFrame()) {
                  m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
              } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
                  m_results.append(
<span class="line-modified">!                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeOffset()));</span>
              } else {
                  m_results.append(
                      StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
              }
  
<span class="line-new-header">--- 405,11 ---</span>
          if (m_remainingCapacityForFrameCapture) {
              if (visitor-&gt;isWasmFrame()) {
                  m_results.append(StackFrame(visitor-&gt;wasmFunctionIndexOrName()));
              } else if (!!visitor-&gt;codeBlock() &amp;&amp; !visitor-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;isBuiltinFunction()) {
                  m_results.append(
<span class="line-modified">!                     StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell(), visitor-&gt;codeBlock(), visitor-&gt;bytecodeIndex()));</span>
              } else {
                  m_results.append(
                      StackFrame(m_vm, m_owner, visitor-&gt;callee().asCell()));
              }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 438,11 ***</span>
      if (!callFrame || !maxStackSize)
          return;
  
      size_t framesCount = 0;
      size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
<span class="line-modified">!     StackVisitor::visit(callFrame, &amp;vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {</span>
          if (++framesCount &lt; maxFramesCountNeeded)
              return StackVisitor::Continue;
          return StackVisitor::Done;
      });
      if (framesCount &lt;= framesToSkip)
<span class="line-new-header">--- 435,11 ---</span>
      if (!callFrame || !maxStackSize)
          return;
  
      size_t framesCount = 0;
      size_t maxFramesCountNeeded = maxStackSize + framesToSkip;
<span class="line-modified">!     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp;) -&gt; StackVisitor::Status {</span>
          if (++framesCount &lt; maxFramesCountNeeded)
              return StackVisitor::Continue;
          return StackVisitor::Done;
      });
      if (framesCount &lt;= framesToSkip)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
  
      framesCount -= framesToSkip;
      framesCount = std::min(maxStackSize, framesCount);
  
      GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
<span class="line-modified">!     StackVisitor::visit(callFrame, &amp;vm, functor);</span>
      ASSERT(results.size() == results.capacity());
  }
  
  String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
  {
<span class="line-new-header">--- 447,11 ---</span>
  
      framesCount -= framesToSkip;
      framesCount = std::min(maxStackSize, framesCount);
  
      GetStackTraceFunctor functor(vm, owner, results, framesToSkip, framesCount);
<span class="line-modified">!     StackVisitor::visit(callFrame, vm, functor);</span>
      ASSERT(results.size() == results.capacity());
  }
  
  String Interpreter::stackTraceAsString(VM&amp; vm, const Vector&lt;StackFrame&gt;&amp; stackTrace)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 478,11 ***</span>
      CallFrame* callFrame = visitor-&gt;callFrame();
      unsigned exceptionHandlerIndex;
      if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
          exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
      else
<span class="line-modified">!         exceptionHandlerIndex = callFrame-&gt;bytecodeOffset();</span>
  
      return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
  }
  
  class GetCatchHandlerFunctor {
<span class="line-new-header">--- 475,11 ---</span>
      CallFrame* callFrame = visitor-&gt;callFrame();
      unsigned exceptionHandlerIndex;
      if (JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
          exceptionHandlerIndex = callFrame-&gt;callSiteIndex().bits();
      else
<span class="line-modified">!         exceptionHandlerIndex = callFrame-&gt;bytecodeIndex().offset();</span>
  
      return codeBlock-&gt;handlerForIndex(exceptionHandlerIndex, requiredHandler);
  }
  
  class GetCatchHandlerFunctor {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 513,12 ***</span>
      mutable HandlerInfo* m_handler;
  };
  
  ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
  {
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     if (Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger()) {</span>
          SuspendExceptionScope scope(&amp;vm);
          if (callFrame-&gt;isAnyWasmCallee()
              || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
              debugger-&gt;unwindEvent(callFrame);
          else
<span class="line-new-header">--- 510,13 ---</span>
      mutable HandlerInfo* m_handler;
  };
  
  ALWAYS_INLINE static void notifyDebuggerOfUnwinding(VM&amp; vm, CallFrame* callFrame)
  {
<span class="line-added">+     JSGlobalObject* globalObject = callFrame-&gt;lexicalGlobalObject(vm);</span>
      auto catchScope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     if (Debugger* debugger = globalObject-&gt;debugger()) {</span>
          SuspendExceptionScope scope(&amp;vm);
          if (callFrame-&gt;isAnyWasmCallee()
              || (callFrame-&gt;callee().isCell() &amp;&amp; callFrame-&gt;callee().asCell()-&gt;inherits&lt;JSFunction&gt;(vm)))
              debugger-&gt;unwindEvent(callFrame);
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 543,12 ***</span>
          visitor.unwindToMachineCodeBlockFrame();
          m_callFrame = visitor-&gt;callFrame();
          m_codeBlock = visitor-&gt;codeBlock();
  
          m_handler = nullptr;
<span class="line-modified">!         if (!m_isTermination) {</span>
<span class="line-modified">!             if (m_codeBlock) {</span>
                  m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
                  if (m_handler)
                      return StackVisitor::Done;
              }
          }
<span class="line-new-header">--- 541,17 ---</span>
          visitor.unwindToMachineCodeBlockFrame();
          m_callFrame = visitor-&gt;callFrame();
          m_codeBlock = visitor-&gt;codeBlock();
  
          m_handler = nullptr;
<span class="line-modified">!         if (m_codeBlock) {</span>
<span class="line-modified">!             // FIXME: We should support exception handling in checkpoints.</span>
<span class="line-added">+ #if ENABLE(DFG_JIT)</span>
<span class="line-added">+             if (removeCodePtrTag(m_returnPC) == LLInt::getCodePtr&lt;NoPtrTag&gt;(checkpoint_osr_exit_from_inlined_call_trampoline).executableAddress())</span>
<span class="line-added">+                 m_codeBlock-&gt;vm().findCheckpointOSRSideState(m_callFrame);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             if (!m_isTermination) {</span>
                  m_handler = findExceptionHandler(visitor, m_codeBlock, RequiredHandler::AnyHandler);
                  if (m_handler)
                      return StackVisitor::Done;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,10 ***</span>
<span class="line-new-header">--- 569,11 ---</span>
  
          bool shouldStopUnwinding = visitor-&gt;callerIsEntryFrame();
          if (shouldStopUnwinding)
              return StackVisitor::Done;
  
<span class="line-added">+         m_returnPC = m_callFrame-&gt;returnPC().value();</span>
          return StackVisitor::Continue;
      }
  
  private:
      void copyCalleeSavesToEntryFrameCalleeSavesBuffer(StackVisitor&amp; visitor) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 602,10 ***</span>
<span class="line-new-header">--- 606,11 ---</span>
      VM&amp; m_vm;
      CallFrame*&amp; m_callFrame;
      bool m_isTermination;
      CodeBlock*&amp; m_codeBlock;
      HandlerInfo*&amp; m_handler;
<span class="line-added">+     mutable const void* m_returnPC { nullptr };</span>
  };
  
  NEVER_INLINE HandlerInfo* Interpreter::unwind(VM&amp; vm, CallFrame*&amp; callFrame, Exception* exception)
  {
      auto scope = DECLARE_CATCH_SCOPE(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 624,20 ***</span>
      EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
  
      // Calculate an exception handler vPC, unwinding call frames as necessary.
      HandlerInfo* handler = nullptr;
      UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
<span class="line-modified">!     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, &amp;vm, functor);</span>
      if (!handler)
          return nullptr;
  
      return handler;
  }
  
<span class="line-modified">! void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, CallFrame* callFrame, Exception* exception)</span>
  {
<span class="line-modified">!     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();</span>
      if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
          // This code assumes that if the debugger is enabled then there is no inlining.
          // If that assumption turns out to be false then we&#39;ll ignore the inlined call
          // frames.
          // https://bugs.webkit.org/show_bug.cgi?id=121754
<span class="line-new-header">--- 629,20 ---</span>
      EXCEPTION_ASSERT_UNUSED(scope, scope.exception());
  
      // Calculate an exception handler vPC, unwinding call frames as necessary.
      HandlerInfo* handler = nullptr;
      UnwindFunctor functor(vm, callFrame, isTerminatedExecutionException(vm, exception), codeBlock, handler);
<span class="line-modified">!     StackVisitor::visit&lt;StackVisitor::TerminateIfTopEntryFrameIsEmpty&gt;(callFrame, vm, functor);</span>
      if (!handler)
          return nullptr;
  
      return handler;
  }
  
<span class="line-modified">! void Interpreter::notifyDebuggerOfExceptionToBeThrown(VM&amp; vm, JSGlobalObject* globalObject, CallFrame* callFrame, Exception* exception)</span>
  {
<span class="line-modified">!     Debugger* debugger = globalObject-&gt;debugger();</span>
      if (debugger &amp;&amp; debugger-&gt;needsExceptionCallbacks() &amp;&amp; !exception-&gt;didNotifyInspectorOfThrow()) {
          // This code assumes that if the debugger is enabled then there is no inlining.
          // If that assumption turns out to be false then we&#39;ll ignore the inlined call
          // frames.
          // https://bugs.webkit.org/show_bug.cgi?id=121754
</pre>
<hr />
<pre>
<span class="line-old-header">*** 646,55 ***</span>
          bool isTermination = isTerminatedExecutionException(vm, exception);
          if (isTermination)
              hasCatchHandler = false;
          else {
              GetCatchHandlerFunctor functor;
<span class="line-modified">!             StackVisitor::visit(callFrame, &amp;vm, functor);</span>
              HandlerInfo* handler = functor.handler();
              ASSERT(!handler || handler-&gt;isCatchHandler());
              hasCatchHandler = !!handler;
          }
  
<span class="line-modified">!         debugger-&gt;exception(callFrame, exception-&gt;value(), hasCatchHandler);</span>
      }
      exception-&gt;setDidNotifyInspectorOfThrow();
  }
  
<span class="line-modified">! JSValue Interpreter::executeProgram(const SourceCode&amp; source, CallFrame* callFrame, JSObject* thisObj)</span>
  {
      JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ProgramExecutable* program = ProgramExecutable::create(callFrame, source);</span>
      EXCEPTION_ASSERT(throwScope.exception() || program);
      RETURN_IF_EXCEPTION(throwScope, { });
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
  
      // First check if the &quot;program&quot; is actually just a JSON object. If so,
      // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
      // below at failedJSONP.
  
<span class="line-removed">-     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
      Vector&lt;JSONPData&gt; JSONPData;
      bool parseResult;
      StringView programSource = program-&gt;source().view();
      if (programSource.isNull())
          return jsUndefined();
      if (programSource.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; literalParser(callFrame, programSource.characters8(), programSource.length(), JSONP);</span>
          parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; literalParser(callFrame, programSource.characters16(), programSource.length(), JSONP);</span>
          parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
      }
  
      RETURN_IF_EXCEPTION(throwScope, { });
      if (parseResult) {
<span class="line-new-header">--- 651,56 ---</span>
          bool isTermination = isTerminatedExecutionException(vm, exception);
          if (isTermination)
              hasCatchHandler = false;
          else {
              GetCatchHandlerFunctor functor;
<span class="line-modified">!             StackVisitor::visit(callFrame, vm, functor);</span>
              HandlerInfo* handler = functor.handler();
              ASSERT(!handler || handler-&gt;isCatchHandler());
              hasCatchHandler = !!handler;
          }
  
<span class="line-modified">!         debugger-&gt;exception(globalObject, callFrame, exception-&gt;value(), hasCatchHandler);</span>
      }
      exception-&gt;setDidNotifyInspectorOfThrow();
  }
  
<span class="line-modified">! JSValue Interpreter::executeProgram(const SourceCode&amp; source, JSGlobalObject*, JSObject* thisObj)</span>
  {
      JSScope* scope = thisObj-&gt;globalObject()-&gt;globalScope();
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
<span class="line-added">+     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added">+     JSCallee* globalCallee = globalObject-&gt;globalCallee();</span>
  
<span class="line-modified">!     ProgramExecutable* program = ProgramExecutable::create(globalObject, source);</span>
      EXCEPTION_ASSERT(throwScope.exception() || program);
      RETURN_IF_EXCEPTION(throwScope, { });
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
  
      // First check if the &quot;program&quot; is actually just a JSON object. If so,
      // we&#39;ll handle the JSON object here. Else, we&#39;ll handle real JS code
      // below at failedJSONP.
  
      Vector&lt;JSONPData&gt; JSONPData;
      bool parseResult;
      StringView programSource = program-&gt;source().view();
      if (programSource.isNull())
          return jsUndefined();
      if (programSource.is8Bit()) {
<span class="line-modified">!         LiteralParser&lt;LChar&gt; literalParser(globalObject, programSource.characters8(), programSource.length(), JSONP);</span>
          parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
      } else {
<span class="line-modified">!         LiteralParser&lt;UChar&gt; literalParser(globalObject, programSource.characters16(), programSource.length(), JSONP);</span>
          parseResult = literalParser.tryJSONPParse(JSONPData, globalObject-&gt;globalObjectMethodTable()-&gt;supportsRichSourceInfo(globalObject));
      }
  
      RETURN_IF_EXCEPTION(throwScope, { });
      if (parseResult) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 702,14 ***</span>
          for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
              Vector&lt;JSONPPathEntry&gt; JSONPPath;
              JSONPPath.swap(JSONPData[entry].m_path);
              JSValue JSONPValue = JSONPData[entry].m_value.get();
              if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
<span class="line-modified">!                 globalObject-&gt;addVar(callFrame, JSONPPath[0].m_pathEntryName);</span>
                  RETURN_IF_EXCEPTION(throwScope, { });
                  PutPropertySlot slot(globalObject);
<span class="line-modified">!                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, callFrame, JSONPPath[0].m_pathEntryName, JSONPValue, slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, { });
                  result = jsUndefined();
                  continue;
              }
              JSValue baseObject(globalObject);
<span class="line-new-header">--- 708,14 ---</span>
          for (unsigned entry = 0; entry &lt; JSONPData.size(); entry++) {
              Vector&lt;JSONPPathEntry&gt; JSONPPath;
              JSONPPath.swap(JSONPData[entry].m_path);
              JSValue JSONPValue = JSONPData[entry].m_value.get();
              if (JSONPPath.size() == 1 &amp;&amp; JSONPPath[0].m_type == JSONPPathEntryTypeDeclareVar) {
<span class="line-modified">!                 globalObject-&gt;addVar(globalObject, JSONPPath[0].m_pathEntryName);</span>
                  RETURN_IF_EXCEPTION(throwScope, { });
                  PutPropertySlot slot(globalObject);
<span class="line-modified">!                 globalObject-&gt;methodTable(vm)-&gt;put(globalObject, globalObject, JSONPPath[0].m_pathEntryName, JSONPValue, slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, { });
                  result = jsUndefined();
                  continue;
              }
              JSValue baseObject(globalObject);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 720,12 ***</span>
                      if (i == 0) {
                          RELEASE_ASSERT(baseObject == globalObject);
  
                          auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
                              PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!                             if (scope-&gt;getPropertySlot(callFrame, JSONPPath[i].m_pathEntryName, slot))</span>
<span class="line-modified">!                                 return slot.getValue(callFrame, JSONPPath[i].m_pathEntryName);</span>
                              return JSValue();
                          };
  
                          JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
                          RETURN_IF_EXCEPTION(throwScope, JSValue());
<span class="line-new-header">--- 726,12 ---</span>
                      if (i == 0) {
                          RELEASE_ASSERT(baseObject == globalObject);
  
                          auto doGet = [&amp;] (JSSegmentedVariableObject* scope) {
                              PropertySlot slot(scope, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!                             if (scope-&gt;getPropertySlot(globalObject, JSONPPath[i].m_pathEntryName, slot))</span>
<span class="line-modified">!                                 return slot.getValue(globalObject, JSONPPath[i].m_pathEntryName);</span>
                              return JSValue();
                          };
  
                          JSValue result = doGet(globalObject-&gt;globalLexicalEnvironment());
                          RETURN_IF_EXCEPTION(throwScope, JSValue());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,20 ***</span>
                              baseObject = result;
                              continue;
                          }
  
                          if (entry)
<span class="line-modified">!                             return throwException(callFrame, throwScope, createUndefinedVariableError(callFrame, JSONPPath[i].m_pathEntryName));</span>
                          goto failedJSONP;
                      }
  
<span class="line-modified">!                     baseObject = baseObject.get(callFrame, JSONPPath[i].m_pathEntryName);</span>
                      RETURN_IF_EXCEPTION(throwScope, JSValue());
                      continue;
                  }
                  case JSONPPathEntryTypeLookup: {
<span class="line-modified">!                     baseObject = baseObject.get(callFrame, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));</span>
                      RETURN_IF_EXCEPTION(throwScope, JSValue());
                      continue;
                  }
                  default:
                      RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 746,20 ---</span>
                              baseObject = result;
                              continue;
                          }
  
                          if (entry)
<span class="line-modified">!                             return throwException(globalObject, throwScope, createUndefinedVariableError(globalObject, JSONPPath[i].m_pathEntryName));</span>
                          goto failedJSONP;
                      }
  
<span class="line-modified">!                     baseObject = baseObject.get(globalObject, JSONPPath[i].m_pathEntryName);</span>
                      RETURN_IF_EXCEPTION(throwScope, JSValue());
                      continue;
                  }
                  case JSONPPathEntryTypeLookup: {
<span class="line-modified">!                     baseObject = baseObject.get(globalObject, static_cast&lt;unsigned&gt;(JSONPPath[i].m_pathIndex));</span>
                      RETURN_IF_EXCEPTION(throwScope, JSValue());
                      continue;
                  }
                  default:
                      RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,39 ***</span>
              }
  
              if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
                  RELEASE_ASSERT(baseObject == globalObject);
                  JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
<span class="line-modified">!                 if (scope-&gt;hasProperty(callFrame, JSONPPath.last().m_pathEntryName))</span>
                      baseObject = scope;
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
              }
  
              PutPropertySlot slot(baseObject);
              switch (JSONPPath.last().m_type) {
              case JSONPPathEntryTypeCall: {
<span class="line-modified">!                 JSValue function = baseObject.get(callFrame, JSONPPath.last().m_pathEntryName);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  CallData callData;
                  CallType callType = getCallData(vm, function, callData);
                  if (callType == CallType::None)
<span class="line-modified">!                     return throwException(callFrame, throwScope, createNotAFunctionError(callFrame, function));</span>
                  MarkedArgumentBuffer jsonArg;
                  jsonArg.append(JSONPValue);
                  ASSERT(!jsonArg.hasOverflowed());
                  JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
<span class="line-modified">!                 JSONPValue = JSC::call(callFrame, function, callType, callData, thisValue, jsonArg);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              case JSONPPathEntryTypeDot: {
<span class="line-modified">!                 baseObject.put(callFrame, JSONPPath.last().m_pathEntryName, JSONPValue, slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              case JSONPPathEntryTypeLookup: {
<span class="line-modified">!                 baseObject.putByIndex(callFrame, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 768,39 ---</span>
              }
  
              if (JSONPPath.size() == 1 &amp;&amp; JSONPPath.last().m_type != JSONPPathEntryTypeLookup) {
                  RELEASE_ASSERT(baseObject == globalObject);
                  JSGlobalLexicalEnvironment* scope = globalObject-&gt;globalLexicalEnvironment();
<span class="line-modified">!                 if (scope-&gt;hasProperty(globalObject, JSONPPath.last().m_pathEntryName))</span>
                      baseObject = scope;
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
              }
  
              PutPropertySlot slot(baseObject);
              switch (JSONPPath.last().m_type) {
              case JSONPPathEntryTypeCall: {
<span class="line-modified">!                 JSValue function = baseObject.get(globalObject, JSONPPath.last().m_pathEntryName);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  CallData callData;
                  CallType callType = getCallData(vm, function, callData);
                  if (callType == CallType::None)
<span class="line-modified">!                     return throwException(globalObject, throwScope, createNotAFunctionError(globalObject, function));</span>
                  MarkedArgumentBuffer jsonArg;
                  jsonArg.append(JSONPValue);
                  ASSERT(!jsonArg.hasOverflowed());
                  JSValue thisValue = JSONPPath.size() == 1 ? jsUndefined() : baseObject;
<span class="line-modified">!                 JSONPValue = JSC::call(globalObject, function, callType, callData, thisValue, jsonArg);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              case JSONPPathEntryTypeDot: {
<span class="line-modified">!                 baseObject.put(globalObject, JSONPPath.last().m_pathEntryName, JSONPValue, slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              case JSONPPathEntryTypeLookup: {
<span class="line-modified">!                 baseObject.putByIndex(globalObject, JSONPPath.last().m_pathIndex, JSONPValue, slot.isStrictMode());</span>
                  RETURN_IF_EXCEPTION(throwScope, JSValue());
                  break;
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 809,14 ***</span>
      // object.
  
      VMEntryScope entryScope(vm, globalObject);
  
      // Compile source to bytecode if necessary:
<span class="line-modified">!     JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);</span>
      EXCEPTION_ASSERT(!throwScope.exception() || !error);
      if (UNLIKELY(error))
<span class="line-modified">!         return checkedReturn(throwException(callFrame, throwScope, error));</span>
  
      ProgramCodeBlock* codeBlock;
      {
          CodeBlock* tempCodeBlock;
          Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
<span class="line-new-header">--- 815,14 ---</span>
      // object.
  
      VMEntryScope entryScope(vm, globalObject);
  
      // Compile source to bytecode if necessary:
<span class="line-modified">!     JSObject* error = program-&gt;initializeGlobalProperties(vm, globalObject, scope);</span>
      EXCEPTION_ASSERT(!throwScope.exception() || !error);
      if (UNLIKELY(error))
<span class="line-modified">!         return checkedReturn(throwException(globalObject, throwScope, error));</span>
  
      ProgramCodeBlock* codeBlock;
      {
          CodeBlock* tempCodeBlock;
          Exception* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 824,33 ***</span>
          if (UNLIKELY(error))
              return checkedReturn(error);
          codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
      }
  
<span class="line-modified">!     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">!         vm.handleTraps(callFrame, mask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
          scope-&gt;flattenDictionaryObject(vm);
  
      ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, JSCallee::create(vm, globalObject, scope), thisObj, 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSValue Interpreter::executeCall(CallFrame* callFrame, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      if (vm.isCollectorBusyOnCurrentThread())
<span class="line-new-header">--- 830,33 ---</span>
          if (UNLIKELY(error))
              return checkedReturn(error);
          codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);
      }
  
<span class="line-modified">!     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">!         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
          scope-&gt;flattenDictionaryObject(vm);
  
      ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, globalObject, globalCallee, thisObj, 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = program-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSValue Interpreter::executeCall(JSGlobalObject* lexicalGlobalObject, JSObject* function, CallType callType, const CallData&amp; callData, JSValue thisValue, const ArgList&amp; args)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      if (vm.isCollectorBusyOnCurrentThread())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,12 ***</span>
          ASSERT(callType == CallType::Host);
          globalObject = function-&gt;globalObject(vm);
      }
  
      VMEntryScope entryScope(vm, globalObject);
<span class="line-modified">!     if (UNLIKELY(!vm.isSafeToRecurseSoft()))</span>
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
  
      if (isJSCall) {
          // Compile the callee:
          Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
          EXCEPTION_ASSERT(throwScope.exception() == compileError);
<span class="line-new-header">--- 876,12 ---</span>
          ASSERT(callType == CallType::Host);
          globalObject = function-&gt;globalObject(vm);
      }
  
      VMEntryScope entryScope(vm, globalObject);
<span class="line-modified">!     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments))</span>
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
  
      if (isJSCall) {
          // Compile the callee:
          Exception* compileError = callData.js.functionExecutable-&gt;prepareForExecution&lt;FunctionExecutable&gt;(vm, jsCast&lt;JSFunction*&gt;(function), scope, CodeForCall, newCodeBlock);
          EXCEPTION_ASSERT(throwScope.exception() == compileError);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,18 ***</span>
          ASSERT(!!newCodeBlock);
          newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
      } else
          newCodeBlock = 0;
  
<span class="line-modified">!     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">!         vm.handleTraps(callFrame, mask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(newCodeBlock, function, thisValue, argsCount, args.data());</span>
  
      JSValue result;
      {
          // Execute the code:
          if (isJSCall) {
<span class="line-new-header">--- 891,18 ---</span>
          ASSERT(!!newCodeBlock);
          newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
      } else
          newCodeBlock = 0;
  
<span class="line-modified">!     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">!         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(newCodeBlock, globalObject, function, thisValue, argsCount, args.data());</span>
  
      JSValue result;
      {
          // Execute the code:
          if (isJSCall) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 909,21 ***</span>
      }
  
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSObject* Interpreter::executeConstruct(CallFrame* callFrame, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
      // already in an invalid state.
      if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
<span class="line-modified">!         throwStackOverflowError(callFrame, throwScope);</span>
          return nullptr;
      }
  
      bool isJSConstruct = (constructType == ConstructType::JS);
      JSScope* scope = nullptr;
<span class="line-new-header">--- 915,21 ---</span>
      }
  
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSObject* Interpreter::executeConstruct(JSGlobalObject* lexicalGlobalObject, JSObject* constructor, ConstructType constructType, const ConstructData&amp; constructData, const ArgList&amp; args, JSValue newTarget)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      // We throw in this case because we have to return something &quot;valid&quot; but we&#39;re
      // already in an invalid state.
      if (UNLIKELY(vm.isCollectorBusyOnCurrentThread())) {
<span class="line-modified">!         throwStackOverflowError(lexicalGlobalObject, throwScope);</span>
          return nullptr;
      }
  
      bool isJSConstruct = (constructType == ConstructType::JS);
      JSScope* scope = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 939,12 ***</span>
          ASSERT(constructType == ConstructType::Host);
          globalObject = constructor-&gt;globalObject(vm);
      }
  
      VMEntryScope entryScope(vm, globalObject);
<span class="line-modified">!     if (UNLIKELY(!vm.isSafeToRecurseSoft())) {</span>
<span class="line-modified">!         throwStackOverflowError(callFrame, throwScope);</span>
          return nullptr;
      }
  
      if (isJSConstruct) {
          // Compile the callee:
<span class="line-new-header">--- 945,12 ---</span>
          ASSERT(constructType == ConstructType::Host);
          globalObject = constructor-&gt;globalObject(vm);
      }
  
      VMEntryScope entryScope(vm, globalObject);
<span class="line-modified">!     if (UNLIKELY(!vm.isSafeToRecurseSoft() || args.size() &gt; maxArguments)) {</span>
<span class="line-modified">!         throwStackOverflowError(globalObject, throwScope);</span>
          return nullptr;
      }
  
      if (isJSConstruct) {
          // Compile the callee:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,18 ***</span>
          ASSERT(!!newCodeBlock);
          newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
      } else
          newCodeBlock = 0;
  
<span class="line-modified">!     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">!         vm.handleTraps(callFrame, mask);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
      }
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(newCodeBlock, constructor, newTarget, argsCount, args.data());</span>
  
      JSValue result;
      {
          // Execute the code.
          if (isJSConstruct)
<span class="line-new-header">--- 962,18 ---</span>
          ASSERT(!!newCodeBlock);
          newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
      } else
          newCodeBlock = 0;
  
<span class="line-modified">!     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">!         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
          RETURN_IF_EXCEPTION(throwScope, nullptr);
      }
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(newCodeBlock, globalObject, constructor, newTarget, argsCount, args.data());</span>
  
      JSValue result;
      {
          // Execute the code.
          if (isJSConstruct)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1002,39 ***</span>
          return CallFrameClosure();
      newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
  
      size_t argsCount = argumentCountIncludingThis;
  
<span class="line-modified">!     protoCallFrame-&gt;init(newCodeBlock, function, jsUndefined(), argsCount, args.data());</span>
      // Return the successful closure:
      CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
      return result;
  }
  
<span class="line-modified">! JSValue Interpreter::execute(EvalExecutable* eval, CallFrame* callFrame, JSValue thisValue, JSScope* scope)</span>
  {
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());</span>
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
<span class="line-modified">!     VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));</span>
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
  
      unsigned numVariables = eval-&gt;numVariables();
      unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
      unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
  
      JSScope* variableObject;
      if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">!         scope = StrictEvalActivation::create(vm, callFrame-&gt;lexicalGlobalObject()-&gt;strictEvalActivationStructure(), scope);</span>
          variableObject = scope;
      } else {
          for (JSScope* node = scope; ; node = node-&gt;next()) {
              RELEASE_ASSERT(node);
              if (node-&gt;isGlobalObject()) {
<span class="line-new-header">--- 1008,40 ---</span>
          return CallFrameClosure();
      newCodeBlock-&gt;m_shouldAlwaysBeInlined = false;
  
      size_t argsCount = argumentCountIncludingThis;
  
<span class="line-modified">!     protoCallFrame-&gt;init(newCodeBlock, function-&gt;globalObject(), function, jsUndefined(), argsCount, args.data());</span>
      // Return the successful closure:
      CallFrameClosure result = { callFrame, protoCallFrame, function, functionExecutable, &amp;vm, scope, newCodeBlock-&gt;numParameters(), argumentCountIncludingThis };
      return result;
  }
  
<span class="line-modified">! JSValue Interpreter::execute(EvalExecutable* eval, JSGlobalObject* lexicalGlobalObject, JSValue thisValue, JSScope* scope)</span>
  {
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
<span class="line-modified">!     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
<span class="line-added">+     VMEntryScope entryScope(vm, globalObject);</span>
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
  
      unsigned numVariables = eval-&gt;numVariables();
      unsigned numTopLevelFunctionDecls = eval-&gt;numTopLevelFunctionDecls();
      unsigned numFunctionHoistingCandidates = eval-&gt;numFunctionHoistingCandidates();
  
      JSScope* variableObject;
      if ((numVariables || numTopLevelFunctionDecls) &amp;&amp; eval-&gt;isStrictMode()) {
<span class="line-modified">!         scope = StrictEvalActivation::create(vm, globalObject-&gt;strictEvalActivationStructure(), scope);</span>
          variableObject = scope;
      } else {
          for (JSScope* node = scope; ; node = node-&gt;next()) {
              RELEASE_ASSERT(node);
              if (node-&gt;isGlobalObject()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,20 ***</span>
      if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
          JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
          for (unsigned i = 0; i &lt; numVariables; ++i) {
              const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
              PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, ident, slot)) {</span>
<span class="line-modified">!                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));</span>
              }
          }
  
          for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
              FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
              PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, callFrame, function-&gt;name(), slot)) {</span>
<span class="line-modified">!                 return checkedReturn(throwTypeError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
              }
          }
      }
  
      if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
<span class="line-new-header">--- 1073,20 ---</span>
      if (variableObject-&gt;isGlobalObject() &amp;&amp; !eval-&gt;isStrictMode() &amp;&amp; (numVariables || numTopLevelFunctionDecls)) {
          JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalObject*&gt;(variableObject)-&gt;globalLexicalEnvironment();
          for (unsigned i = 0; i &lt; numVariables; ++i) {
              const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
              PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, ident, slot)) {</span>
<span class="line-modified">!                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(ident.impl()), &quot;&#39;&quot;)));</span>
              }
          }
  
          for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
              FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
              PropertySlot slot(globalLexicalEnvironment, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!             if (JSGlobalLexicalEnvironment::getOwnPropertySlot(globalLexicalEnvironment, globalObject, function-&gt;name(), slot)) {</span>
<span class="line-modified">!                 return checkedReturn(throwTypeError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate global variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
              }
          }
      }
  
      if (variableObject-&gt;structure(vm)-&gt;isUncacheableDictionary())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1090,92 ***</span>
          if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
              variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
  
          for (unsigned i = 0; i &lt; numVariables; ++i) {
              const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
<span class="line-modified">!             bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);</span>
              RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              if (!hasProperty) {
                  PutPropertySlot slot(variableObject);
<span class="line-modified">!                 if (!variableObject-&gt;isExtensible(callFrame))</span>
<span class="line-modified">!                     return checkedReturn(throwTypeError(callFrame, throwScope, NonExtensibleObjectPropertyDefineError));</span>
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
          }
  
          if (eval-&gt;isStrictMode()) {
              for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
                  FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
                  PutPropertySlot slot(variableObject);
                  // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
          } else {
              for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
                  FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
<span class="line-modified">!                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, function-&gt;name());</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                  if (resolvedScope.isUndefined())
<span class="line-modified">!                     return checkedReturn(throwSyntaxError(callFrame, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
                  PutPropertySlot slot(variableObject);
                  // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, function-&gt;name(), jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
  
              for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
                  const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
<span class="line-modified">!                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(callFrame, scope, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                  if (!resolvedScope.isUndefined()) {
<span class="line-modified">!                     bool hasProperty = variableObject-&gt;hasProperty(callFrame, ident);</span>
                      RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                      if (!hasProperty) {
                          PutPropertySlot slot(variableObject);
<span class="line-modified">!                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, callFrame, ident, jsUndefined(), slot);</span>
                          RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                      }
                  }
              }
          }
      }
  
<span class="line-modified">!     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">!         vm.handleTraps(callFrame, mask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
  
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), thisValue, 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
  
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, CallFrame* callFrame, JSModuleEnvironment* scope)</span>
  {
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT(&amp;vm == &amp;callFrame-&gt;vm());</span>
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
      VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(callFrame, throwScope));</span>
  
      ModuleProgramCodeBlock* codeBlock;
      {
          CodeBlock* tempCodeBlock;
          Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
<span class="line-new-header">--- 1097,98 ---</span>
          if (variableObject-&gt;next() &amp;&amp; !eval-&gt;isStrictMode())
              variableObject-&gt;globalObject(vm)-&gt;varInjectionWatchpoint()-&gt;fireAll(vm, &quot;Executed eval, fired VarInjection watchpoint&quot;);
  
          for (unsigned i = 0; i &lt; numVariables; ++i) {
              const Identifier&amp; ident = unlinkedCodeBlock-&gt;variable(i);
<span class="line-modified">!             bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
              RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              if (!hasProperty) {
                  PutPropertySlot slot(variableObject);
<span class="line-modified">!                 if (!variableObject-&gt;isExtensible(globalObject))</span>
<span class="line-modified">!                     return checkedReturn(throwTypeError(globalObject, throwScope, NonExtensibleObjectPropertyDefineError));</span>
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
          }
  
          if (eval-&gt;isStrictMode()) {
              for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
                  FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
                  PutPropertySlot slot(variableObject);
                  // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
          } else {
              for (unsigned i = 0; i &lt; numTopLevelFunctionDecls; ++i) {
                  FunctionExecutable* function = codeBlock-&gt;functionDecl(i);
<span class="line-modified">!                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, function-&gt;name());</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                  if (resolvedScope.isUndefined())
<span class="line-modified">!                     return checkedReturn(throwSyntaxError(globalObject, throwScope, makeString(&quot;Can&#39;t create duplicate variable in eval: &#39;&quot;, String(function-&gt;name().impl()), &quot;&#39;&quot;)));</span>
                  PutPropertySlot slot(variableObject);
                  // We need create this variables because it will be used to emits code by bytecode generator
<span class="line-modified">!                 variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, function-&gt;name(), jsUndefined(), slot);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
              }
  
              for (unsigned i = 0; i &lt; numFunctionHoistingCandidates; ++i) {
                  const Identifier&amp; ident = unlinkedCodeBlock-&gt;functionHoistingCandidate(i);
<span class="line-modified">!                 JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
                  RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                  if (!resolvedScope.isUndefined()) {
<span class="line-modified">!                     bool hasProperty = variableObject-&gt;hasProperty(globalObject, ident);</span>
                      RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                      if (!hasProperty) {
                          PutPropertySlot slot(variableObject);
<span class="line-modified">!                         variableObject-&gt;methodTable(vm)-&gt;put(variableObject, globalObject, ident, jsUndefined(), slot);</span>
                          RETURN_IF_EXCEPTION(throwScope, checkedReturn(throwScope.exception()));
                      }
                  }
              }
          }
      }
  
<span class="line-modified">!     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">!         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      ASSERT(codeBlock-&gt;numParameters() == 1); // 1 parameter for &#39;this&#39;.
  
<span class="line-added">+     JSCallee* callee = nullptr;</span>
<span class="line-added">+     if (scope == globalObject-&gt;globalScope())</span>
<span class="line-added">+         callee = globalObject-&gt;globalCallee();</span>
<span class="line-added">+     else</span>
<span class="line-added">+         callee = JSCallee::create(vm, globalObject, scope);</span>
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, globalObject, callee, thisValue, 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = eval-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
  
      return checkedReturn(result);
  }
  
<span class="line-modified">! JSValue Interpreter::executeModuleProgram(ModuleProgramExecutable* executable, JSGlobalObject* lexicalGlobalObject, JSModuleEnvironment* scope)</span>
  {
      VM&amp; vm = scope-&gt;vm();
      auto throwScope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     ASSERT_UNUSED(lexicalGlobalObject, &amp;vm == &amp;lexicalGlobalObject-&gt;vm());</span>
      throwScope.assertNoException();
      ASSERT(!vm.isCollectorBusyOnCurrentThread());
      RELEASE_ASSERT(vm.currentThreadIsHoldingAPILock());
      if (vm.isCollectorBusyOnCurrentThread())
          return jsNull();
  
<span class="line-added">+     JSGlobalObject* globalObject = scope-&gt;globalObject(vm);</span>
      VMEntryScope entryScope(vm, scope-&gt;globalObject(vm));
      if (UNLIKELY(!vm.isSafeToRecurseSoft()))
<span class="line-modified">!         return checkedReturn(throwStackOverflowError(globalObject, throwScope));</span>
  
      ModuleProgramCodeBlock* codeBlock;
      {
          CodeBlock* tempCodeBlock;
          Exception* compileError = executable-&gt;prepareForExecution&lt;ModuleProgramExecutable&gt;(vm, nullptr, scope, CodeForCall, tempCodeBlock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,13 ***</span>
          if (UNLIKELY(!!compileError))
              return checkedReturn(compileError);
          codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
      }
  
<span class="line-modified">!     VMTraps::Mask mask(VMTraps::NeedTermination, VMTraps::NeedWatchdogCheck);</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(mask))) {</span>
<span class="line-modified">!         vm.handleTraps(callFrame, mask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
          scope-&gt;flattenDictionaryObject(vm);
<span class="line-new-header">--- 1196,13 ---</span>
          if (UNLIKELY(!!compileError))
              return checkedReturn(compileError);
          codeBlock = jsCast&lt;ModuleProgramCodeBlock*&gt;(tempCodeBlock);
      }
  
<span class="line-modified">!     constexpr auto trapsMask = VMTraps::interruptingTraps();</span>
<span class="line-modified">!     if (UNLIKELY(vm.needTrapHandling(trapsMask))) {</span>
<span class="line-modified">!         vm.handleTraps(globalObject, vm.topCallFrame, trapsMask);</span>
          RETURN_IF_EXCEPTION(throwScope, throwScope.exception());
      }
  
      if (scope-&gt;structure(vm)-&gt;isUncacheableDictionary())
          scope-&gt;flattenDictionaryObject(vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1198,24 ***</span>
  
      // The |this| of the module is always `undefined`.
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, JSCallee::create(vm, scope-&gt;globalObject(vm), scope), jsUndefined(), 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
  
      return checkedReturn(result);
  }
  
  NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     Debugger* debugger = vm.vmEntryGlobalObject(callFrame)-&gt;debugger();</span>
      if (!debugger)
          return;
  
      ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
      scope.assertNoException();
<span class="line-new-header">--- 1211,24 ---</span>
  
      // The |this| of the module is always `undefined`.
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-hasthisbinding
      // http://www.ecma-international.org/ecma-262/6.0/#sec-module-environment-records-getthisbinding
      ProtoCallFrame protoCallFrame;
<span class="line-modified">!     protoCallFrame.init(codeBlock, globalObject, JSCallee::create(vm, globalObject, scope), jsUndefined(), 1);</span>
  
      // Execute the code:
      throwScope.release();
      JSValue result = executable-&gt;generatedJITCode()-&gt;execute(&amp;vm, &amp;protoCallFrame);
  
      return checkedReturn(result);
  }
  
  NEVER_INLINE void Interpreter::debug(CallFrame* callFrame, DebugHookType debugHookType)
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified">!     Debugger* debugger = callFrame-&gt;lexicalGlobalObject(vm)-&gt;debugger();</span>
      if (!debugger)
          return;
  
      ASSERT(callFrame-&gt;codeBlock()-&gt;hasDebuggerRequests());
      scope.assertNoException();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1237,12 ***</span>
              debugger-&gt;willExecuteProgram(callFrame);
              break;
          case DidExecuteProgram:
              debugger-&gt;didExecuteProgram(callFrame);
              break;
<span class="line-modified">!         case DidReachBreakpoint:</span>
<span class="line-modified">!             debugger-&gt;didReachBreakpoint(callFrame);</span>
              break;
      }
      scope.assertNoException();
  }
  
<span class="line-new-header">--- 1250,12 ---</span>
              debugger-&gt;willExecuteProgram(callFrame);
              break;
          case DidExecuteProgram:
              debugger-&gt;didExecuteProgram(callFrame);
              break;
<span class="line-modified">!         case DidReachDebuggerStatement:</span>
<span class="line-modified">!             debugger-&gt;didReachDebuggerStatement(callFrame);</span>
              break;
      }
      scope.assertNoException();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1260,12 ***</span>
          out.print(&quot;DidExecuteProgram&quot;);
          return;
      case JSC::DidEnterCallFrame:
          out.print(&quot;DidEnterCallFrame&quot;);
          return;
<span class="line-modified">!     case JSC::DidReachBreakpoint:</span>
<span class="line-modified">!         out.print(&quot;DidReachBreakpoint&quot;);</span>
          return;
      case JSC::WillLeaveCallFrame:
          out.print(&quot;WillLeaveCallFrame&quot;);
          return;
      case JSC::WillExecuteStatement:
<span class="line-new-header">--- 1273,12 ---</span>
          out.print(&quot;DidExecuteProgram&quot;);
          return;
      case JSC::DidEnterCallFrame:
          out.print(&quot;DidEnterCallFrame&quot;);
          return;
<span class="line-modified">!     case JSC::DidReachDebuggerStatement:</span>
<span class="line-modified">!         out.print(&quot;DidReachDebuggerStatement&quot;);</span>
          return;
      case JSC::WillLeaveCallFrame:
          out.print(&quot;WillLeaveCallFrame&quot;);
          return;
      case JSC::WillExecuteStatement:
</pre>
<center><a href="FrameTracers.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Interpreter.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerCompositor.cpp
@@ -30,20 +30,20 @@
 #include "CSSAnimationController.h"
 #include "CSSPropertyNames.h"
 #include "CanvasRenderingContext.h"
 #include "Chrome.h"
 #include "ChromeClient.h"
-#include "DocumentTimeline.h"
 #include "Frame.h"
 #include "FrameView.h"
 #include "FullscreenManager.h"
 #include "GraphicsLayer.h"
 #include "HTMLCanvasElement.h"
 #include "HTMLIFrameElement.h"
 #include "HTMLNames.h"
 #include "HitTestResult.h"
 #include "InspectorInstrumentation.h"
+#include "KeyframeEffectStack.h"
 #include "LayerAncestorClippingStack.h"
 #include "LayerOverlapMap.h"
 #include "Logging.h"
 #include "NodeList.h"
 #include "Page.h"
@@ -65,10 +65,11 @@
 #include "TiledBacking.h"
 #include "TransformState.h"
 #include <wtf/HexNumber.h>
 #include <wtf/MemoryPressureHandler.h>
 #include <wtf/SetForScope.h>
+#include <wtf/SystemTracing.h>
 #include <wtf/text/CString.h>
 #include <wtf/text/StringBuilder.h>
 #include <wtf/text/StringConcatenateNumbers.h>
 #include <wtf/text/TextStream.h>
 
@@ -196,10 +197,32 @@
 #if !LOG_DISABLED
     unsigned depth { 0 };
 #endif
 };
 
+struct RenderLayerCompositor::UpdateBackingTraversalState {
+
+    UpdateBackingTraversalState(RenderLayer* compAncestor = nullptr)
+        : compositingAncestor(compAncestor)
+    {
+    }
+
+    UpdateBackingTraversalState stateForDescendants() const
+    {
+        UpdateBackingTraversalState state(compositingAncestor);
+#if !LOG_DISABLED
+        state.depth = depth + 1;
+#endif
+        return state;
+    }
+
+    RenderLayer* compositingAncestor;
+#if !LOG_DISABLED
+    unsigned depth { 0 };
+#endif
+};
+
 class RenderLayerCompositor::BackingSharingState {
     WTF_MAKE_NONCOPYABLE(BackingSharingState);
 public:
     BackingSharingState() = default;
 
@@ -679,22 +702,24 @@
 // Returns true on a successful update.
 bool RenderLayerCompositor::updateCompositingLayers(CompositingUpdateType updateType, RenderLayer* updateRoot)
 {
     LOG_WITH_STREAM(Compositing, stream << "RenderLayerCompositor " << this << " updateCompositingLayers " << updateType << " contentLayersCount " << m_contentLayersCount);
 
+    TraceScope tracingScope(CompositingUpdateStart, CompositingUpdateEnd);
+
 #if ENABLE(TREE_DEBUGGING)
     if (compositingLogEnabled())
         showPaintOrderTree(m_renderView.layer());
 #endif
 
     if (updateType == CompositingUpdateType::AfterStyleChange || updateType == CompositingUpdateType::AfterLayout)
         cacheAcceleratedCompositingFlagsAfterLayout(); // Some flags (e.g. forceCompositingMode) depend on layout.
 
     m_updateCompositingLayersTimer.stop();
 
-    ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache
-        || m_renderView.document().pageCacheState() == Document::AboutToEnterPageCache);
+    ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache
+        || m_renderView.document().backForwardCacheState() == Document::AboutToEnterBackForwardCache);
 
     // Compositing layers will be updated in Document::setVisualUpdatesAllowed(bool) if suppressed here.
     if (!m_renderView.document().visualUpdatesAllowed())
         return false;
 
@@ -786,12 +811,13 @@
     if (updateRoot->hasDescendantNeedingUpdateBackingOrHierarchyTraversal() || updateRoot->needsUpdateBackingOrHierarchyTraversal()) {
         ScrollingTreeState scrollingTreeState = { 0, 0 };
         if (!m_renderView.frame().isMainFrame())
             scrollingTreeState.parentNodeID = frameHostingNodeForFrame(m_renderView.frame());
 
+        UpdateBackingTraversalState traversalState;
         Vector<Ref<GraphicsLayer>> childList;
-        updateBackingAndHierarchy(*updateRoot, childList, scrollingTreeState);
+        updateBackingAndHierarchy(*updateRoot, childList, traversalState, scrollingTreeState);
 
         // Host the document layer in the RenderView's root layer.
         appendDocumentOverlayLayers(childList);
         // Even when childList is empty, don't drop out of compositing mode if there are
         // composited layers that we didn't hit in our traversal (e.g. because of visibility:hidden).
@@ -836,10 +862,13 @@
     return layer.ancestorLayerIsInContainingBlockChain(sharedLayer);
 }
 
 void RenderLayerCompositor::computeCompositingRequirements(RenderLayer* ancestorLayer, RenderLayer& layer, LayerOverlapMap& overlapMap, CompositingState& compositingState, BackingSharingState& backingSharingState, bool& descendantHas3DTransform)
 {
+    layer.updateDescendantDependentFlags();
+    layer.updateLayerListsIfNeeded();
+
     if (!layer.hasDescendantNeedingCompositingRequirementsTraversal()
         && !layer.needsCompositingRequirementsTraversal()
         && !compositingState.fullPaintOrderTraversalRequired
         && !compositingState.descendantsRequireCompositingUpdate) {
         traverseUnchangedSubtree(ancestorLayer, layer, overlapMap, compositingState, backingSharingState, descendantHas3DTransform);
@@ -850,13 +879,10 @@
 
     // FIXME: maybe we can avoid updating all remaining layers in paint order.
     compositingState.fullPaintOrderTraversalRequired |= layer.needsCompositingRequirementsTraversal();
     compositingState.descendantsRequireCompositingUpdate |= layer.descendantsNeedCompositingRequirementsTraversal();
 
-    layer.updateDescendantDependentFlags();
-    layer.updateLayerListsIfNeeded();
-
     layer.setHasCompositingDescendant(false);
 
     // We updated compositing for direct reasons in layerStyleChanged(). Here, check for compositing that can only be evaluated after layout.
     RequiresCompositingData queryData;
     bool willBeComposited = layer.isComposited();
@@ -965,11 +991,11 @@
         LOG_WITH_STREAM(CompositingOverlap, stream << "layer " << &layer << " will share, pushed container " << overlapMap);
     }
 
     backingSharingState.updateBeforeDescendantTraversal(layer, willBeComposited);
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(layer);
 #endif
 
     bool anyDescendantHas3DTransform = false;
     bool descendantsAddedToOverlap = currentState.hasNonRootCompositedAncestor();
@@ -1009,27 +1035,23 @@
     }
 
     ASSERT(!layer.hasNotIsolatedCompositedBlendingDescendants() || layer.hasNotIsolatedBlendingDescendants());
 #endif
     // Now check for reasons to become composited that depend on the state of descendant layers.
-    IndirectCompositingReason indirectCompositingReason;
-    if (!willBeComposited && canBeComposited(layer)
-        && requiresCompositingForIndirectReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking, indirectCompositingReason)) {
-        layer.setIndirectCompositingReason(indirectCompositingReason);
-        layerWillCompositePostDescendants();
+    if (!willBeComposited && canBeComposited(layer)) {
+        auto indirectReason = computeIndirectCompositingReason(layer, currentState.subtreeIsCompositing, anyDescendantHas3DTransform, layerPaintsIntoProvidedBacking);
+        if (indirectReason != IndirectCompositingReason::None) {
+            layer.setIndirectCompositingReason(indirectReason);
+            layerWillCompositePostDescendants();
+        }
     }
 
     if (layer.reflectionLayer()) {
         // FIXME: Shouldn't we call computeCompositingRequirements to handle a reflection overlapping with another renderer?
         layer.reflectionLayer()->setIndirectCompositingReason(willBeComposited ? IndirectCompositingReason::Stacking : IndirectCompositingReason::None);
     }
 
-    // setHasCompositingDescendant() may have changed the answer to needsToBeComposited() when clipping, so test that now.
-    bool isCompositedClippingLayer = canBeComposited(layer) && clipsCompositingDescendants(layer);
-    if (isCompositedClippingLayer & !willBeComposited)
-        layerWillCompositePostDescendants();
-
     // If we're back at the root, and no other layers need to be composited, and the root layer itself doesn't need
     // to be composited, then we can drop out of compositing mode altogether. However, don't drop out of compositing mode
     // if there are composited layers that we didn't hit in our traversal (e.g. because of visibility:hidden).
     RequiresCompositingData rootLayerQueryData;
     if (layer.isRenderViewLayer() && !currentState.subtreeIsCompositing && !requiresCompositingLayer(layer, rootLayerQueryData) && !m_forceCompositingMode && !needsCompositingForContentOrOverlays()) {
@@ -1051,11 +1073,11 @@
         // The composited bounds of enclosing layers depends on which descendants are composited, so they need a geometry update.
         layer.setNeedsCompositingGeometryUpdateOnAncestors();
     }
 
     // Update layer state bits.
-    if (layer.reflectionLayer() && updateLayerCompositingState(*layer.reflectionLayer(), queryData, CompositingChangeRepaintNow))
+    if (layer.reflectionLayer() && updateLayerCompositingState(*layer.reflectionLayer(), &layer, queryData, CompositingChangeRepaintNow))
         layer.setNeedsCompositingLayerConnection();
 
     // FIXME: clarify needsCompositingPaintOrderChildrenUpdate. If a composited layer gets a new ancestor, it needs geometry computations.
     if (layer.needsCompositingPaintOrderChildrenUpdate()) {
         layer.setChildrenNeedCompositingGeometryUpdate();
@@ -1081,19 +1103,19 @@
 }
 
 // We have to traverse unchanged layers to fill in the overlap map.
 void RenderLayerCompositor::traverseUnchangedSubtree(RenderLayer* ancestorLayer, RenderLayer& layer, LayerOverlapMap& overlapMap, CompositingState& compositingState, BackingSharingState& backingSharingState, bool& descendantHas3DTransform)
 {
+    layer.updateDescendantDependentFlags();
+    layer.updateLayerListsIfNeeded();
+
     ASSERT(!compositingState.fullPaintOrderTraversalRequired);
     ASSERT(!layer.hasDescendantNeedingCompositingRequirementsTraversal());
     ASSERT(!layer.needsCompositingRequirementsTraversal());
 
     LOG_WITH_STREAM(Compositing, stream << TextStream::Repeat(compositingState.depth * 2, ' ') << &layer << (layer.isNormalFlowOnly() ? " n" : " s") << " traverseUnchangedSubtree");
 
-    layer.updateDescendantDependentFlags();
-    layer.updateLayerListsIfNeeded();
-
     bool layerIsComposited = layer.isComposited();
     bool layerPaintsIntoProvidedBacking = false;
     bool didPushOverlapContainer = false;
 
     OverlapExtent layerExtent;
@@ -1138,11 +1160,11 @@
         LOG_WITH_STREAM(CompositingOverlap, stream << "unchangedSubtree: layer " << &layer << " will share, pushed container " << overlapMap);
     }
 
     backingSharingState.updateBeforeDescendantTraversal(layer, layerIsComposited);
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(layer);
 #endif
 
     bool anyDescendantHas3DTransform = false;
 
@@ -1174,20 +1196,21 @@
     overlapMap.geometryMap().popMappingsToAncestor(ancestorLayer);
 
     ASSERT(!layer.needsCompositingRequirementsTraversal());
 }
 
-void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer& layer, Vector<Ref<GraphicsLayer>>& childLayersOfEnclosingLayer, ScrollingTreeState& scrollingTreeState, OptionSet<UpdateLevel> updateLevel, int depth)
+void RenderLayerCompositor::updateBackingAndHierarchy(RenderLayer& layer, Vector<Ref<GraphicsLayer>>& childLayersOfEnclosingLayer, UpdateBackingTraversalState& traversalState, ScrollingTreeState& scrollingTreeState, OptionSet<UpdateLevel> updateLevel)
 {
     layer.updateDescendantDependentFlags();
     layer.updateLayerListsIfNeeded();
 
     bool layerNeedsUpdate = !updateLevel.isEmpty();
     if (layer.descendantsNeedUpdateBackingAndHierarchyTraversal())
         updateLevel.add(UpdateLevel::AllDescendants);
 
-    ScrollingTreeState stateForDescendants = scrollingTreeState;
+    ScrollingTreeState scrollingStateForDescendants = scrollingTreeState;
+    UpdateBackingTraversalState traversalStateForDescendants = traversalState.stateForDescendants();
 
     auto* layerBacking = layer.backing();
     if (layerBacking) {
         updateLevel.remove(UpdateLevel::CompositedChildren);
 
@@ -1198,21 +1221,21 @@
             // Our geometry can affect descendants.
             updateLevel.add(UpdateLevel::CompositedChildren);
         }
 
         if (layerNeedsUpdate || layer.needsCompositingConfigurationUpdate()) {
-            if (layerBacking->updateConfiguration()) {
+            if (layerBacking->updateConfiguration(traversalState.compositingAncestor)) {
                 layerNeedsUpdate = true; // We also need to update geometry.
                 layer.setNeedsCompositingLayerConnection();
             }
 
             layerBacking->updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
         }
 
         OptionSet<ScrollingNodeChangeFlags> scrollingNodeChanges = { ScrollingNodeChangeFlags::Layer };
         if (layerNeedsUpdate || layer.needsCompositingGeometryUpdate()) {
-            layerBacking->updateGeometry();
+            layerBacking->updateGeometry(traversalState.compositingAncestor);
             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
         } else if (layer.needsScrollingTreeUpdate())
             scrollingNodeChanges.add(ScrollingNodeChangeFlags::LayerGeometry);
 
         // This needs to happen after any geometry update.
@@ -1221,27 +1244,27 @@
             layerBacking->updateEventRegion();
 
         if (auto* reflection = layer.reflectionLayer()) {
             if (auto* reflectionBacking = reflection->backing()) {
                 reflectionBacking->updateCompositedBounds();
-                reflectionBacking->updateGeometry();
+                reflectionBacking->updateGeometry(&layer);
                 reflectionBacking->updateAfterDescendants();
             }
         }
 
         if (!layer.parent())
             updateRootLayerPosition();
 
         // FIXME: do based on dirty flags. Need to do this for changes of geometry, configuration and hierarchy.
         // Need to be careful to do the right thing when a scroll-coordinated layer loses a scroll-coordinated ancestor.
-        stateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, scrollingTreeState, scrollingNodeChanges);
-        stateForDescendants.nextChildIndex = 0;
+        scrollingStateForDescendants.parentNodeID = updateScrollCoordinationForLayer(layer, traversalState.compositingAncestor, scrollingTreeState, scrollingNodeChanges);
+        scrollingStateForDescendants.nextChildIndex = 0;
+
+        traversalStateForDescendants.compositingAncestor = &layer;
 
 #if !LOG_DISABLED
-        logLayerInfo(layer, "updateBackingAndHierarchy", depth);
-#else
-        UNUSED_PARAM(depth);
+        logLayerInfo(layer, "updateBackingAndHierarchy", traversalState.depth);
 #endif
     }
 
     if (layer.childrenNeedCompositingGeometryUpdate())
         updateLevel.add(UpdateLevel::CompositedChildren);
@@ -1254,11 +1277,11 @@
     bool requireDescendantTraversal = layer.hasDescendantNeedingUpdateBackingOrHierarchyTraversal()
         || (layer.hasCompositingDescendant() && (!layerBacking || layer.needsCompositingLayerConnection() || !updateLevel.isEmpty()));
 
     bool requiresChildRebuild = layerBacking && layer.needsCompositingLayerConnection() && !layer.hasCompositingDescendant();
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(layer);
 #endif
 
     auto appendForegroundLayerIfNecessary = [&] {
         // If a negative z-order child is compositing, we get a foreground layer which needs to get parented.
@@ -1268,19 +1291,19 @@
         }
     };
 
     if (requireDescendantTraversal) {
         for (auto* renderLayer : layer.negativeZOrderLayers())
-            updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
+            updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
 
         appendForegroundLayerIfNecessary();
 
         for (auto* renderLayer : layer.normalFlowLayers())
-            updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
+            updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
 
         for (auto* renderLayer : layer.positiveZOrderLayers())
-            updateBackingAndHierarchy(*renderLayer, childList, stateForDescendants, updateLevel, depth + 1);
+            updateBackingAndHierarchy(*renderLayer, childList, traversalStateForDescendants, scrollingStateForDescendants, updateLevel);
     } else if (requiresChildRebuild)
         appendForegroundLayerIfNecessary();
 
     if (layerBacking) {
         if (requireDescendantTraversal || requiresChildRebuild) {
@@ -1366,14 +1389,14 @@
 
     LayoutRect absoluteBounds = backing->compositedBounds();
     absoluteBounds.move(layer.offsetFromAncestor(m_renderView.layer()));
 
     StringBuilder logString;
-    logString.append(pad(' ', 12 + depth * 2, hex(reinterpret_cast<uintptr_t>(&layer))), " id ", backing->graphicsLayer()->primaryLayerID(), " (", FormattedNumber::fixedWidth(absoluteBounds.x().toFloat(), 3), ',', FormattedNumber::fixedWidth(absoluteBounds.y().toFloat(), 3), '-', FormattedNumber::fixedWidth(absoluteBounds.maxX().toFloat(), 3), ',', FormattedNumber::fixedWidth(absoluteBounds.maxY().toFloat(), 3), ") ", FormattedNumber::fixedWidth(backing->backingStoreMemoryEstimate() / 1024, 2), "KB");
+    logString.append(pad(' ', 12 + depth * 2, hex(reinterpret_cast<uintptr_t>(&layer), Lowercase)), " id ", backing->graphicsLayer()->primaryLayerID(), " (", absoluteBounds.x().toFloat(), ',', absoluteBounds.y().toFloat(), '-', absoluteBounds.maxX().toFloat(), ',', absoluteBounds.maxY().toFloat(), ") ", FormattedNumber::fixedWidth(backing->backingStoreMemoryEstimate() / 1024, 2), "KB");
 
-    if (!layer.renderer().style().hasAutoZIndex())
-        logString.append(" z-index: ", layer.renderer().style().zIndex());
+    if (!layer.renderer().style().hasAutoUsedZIndex())
+        logString.append(" z-index: ", layer.renderer().style().usedZIndex());
 
     logString.append(" (", logReasonsForCompositing(layer), ") ");
 
     if (backing->graphicsLayer()->contentsOpaque() || backing->paintsIntoCompositedAncestor() || backing->foregroundLayer() || backing->backgroundLayer()) {
         logString.append('[');
@@ -1688,17 +1711,17 @@
         layer.backing()->updateDebugIndicators(m_showDebugBorders, m_showRepaintCounter);
 
     return layerChanged;
 }
 
-bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer& layer, RequiresCompositingData& queryData, CompositingChangeRepaint shouldRepaint)
+bool RenderLayerCompositor::updateLayerCompositingState(RenderLayer& layer, const RenderLayer* compositingAncestor, RequiresCompositingData& queryData, CompositingChangeRepaint shouldRepaint)
 {
     bool layerChanged = updateBacking(layer, queryData, shouldRepaint);
 
     // See if we need content or clipping layers. Methods called here should assume
     // that the compositing state of descendant layers has not been updated yet.
-    if (layer.backing() && layer.backing()->updateConfiguration())
+    if (layer.backing() && layer.backing()->updateConfiguration(compositingAncestor))
         layerChanged = true;
 
     return layerChanged;
 }
 
@@ -1882,12 +1905,12 @@
     } else
         clipRect = layer.backgroundClipRect(RenderLayer::ClipRectsContext(&rootRenderLayer(), AbsoluteClipRects)).rect(); // FIXME: Incorrect for CSS regions.
 
     auto clippedBounds = extent.bounds;
     if (!clipRect.isInfinite()) {
-        // On iOS, pageScaleFactor() is not applied by RenderView, so we should not scale here.
-        if (!m_renderView.settings().delegatesPageScaling())
+        // With delegated page scaling, pageScaleFactor() is not applied by RenderView, so we should not scale here.
+        if (!page().delegatesScaling())
             clipRect.scale(pageScaleFactor());
 
         clippedBounds.intersect(clipRect);
     }
 
@@ -1905,11 +1928,11 @@
 
         OverlapExtent layerExtent;
         addToOverlapMap(overlapMap, layer, layerExtent);
     }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(const_cast<RenderLayer&>(layer));
 #endif
 
     for (auto* renderLayer : layer.negativeZOrderLayers())
         addDescendantsToOverlapMapRecursive(overlapMap, *renderLayer, &layer);
@@ -2081,10 +2104,11 @@
     }
 }
 
 String RenderLayerCompositor::layerTreeAsText(LayerTreeFlags flags)
 {
+    LOG_WITH_STREAM(Compositing, stream << "RenderLayerCompositor " << this << " layerTreeAsText");
     updateCompositingLayers(CompositingUpdateType::AfterLayout);
 
     if (!m_rootContentsLayer)
         return String();
 
@@ -2112,10 +2136,12 @@
         layerTreeBehavior |= LayerTreeAsTextIncludeBackingStoreAttached;
     if (flags & LayerTreeFlagsIncludeRootLayerProperties)
         layerTreeBehavior |= LayerTreeAsTextIncludeRootLayerProperties;
     if (flags & LayerTreeFlagsIncludeEventRegion)
         layerTreeBehavior |= LayerTreeAsTextIncludeEventRegion;
+    if (flags & LayerTreeFlagsIncludeDeepColor)
+        layerTreeBehavior |= LayerTreeAsTextIncludeDeepColor;
 
     // We skip dumping the scroll and clip layers to keep layerTreeAsText output
     // similar between platforms.
     String layerTreeText = m_rootContentsLayer->layerTreeAsText(layerTreeBehavior);
 
@@ -2189,11 +2215,11 @@
 
     // FIXME: This method does not work correctly with transforms.
     if (layer.isComposited() && !layer.backing()->paintsIntoCompositedAncestor())
         layer.setBackingNeedsRepaint();
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(layer);
 #endif
 
     if (layer.hasCompositingDescendant()) {
         for (auto* renderLayer : layer.negativeZOrderLayers())
@@ -2316,11 +2342,10 @@
     auto& renderer = rendererForCompositingTests(layer);
 
     // The root layer always has a compositing layer, but it may not have backing.
     return requiresCompositingForTransform(renderer)
         || requiresCompositingForAnimation(renderer)
-        || clipsCompositingDescendants(*renderer.layer())
         || requiresCompositingForPosition(renderer, *renderer.layer(), queryData)
         || requiresCompositingForCanvas(renderer)
         || requiresCompositingForFilters(renderer)
         || requiresCompositingForWillChange(renderer)
         || requiresCompositingForBackfaceVisibility(renderer)
@@ -2396,26 +2421,27 @@
         || renderer.hasReflection()
         || renderer.hasFilter()
         || renderer.hasBackdropFilter())
         return true;
 
+    if (layer.isComposited() && layer.backing()->hasBackingSharingLayers())
+        return true;
+
+    // FIXME: We really need to keep track of the ancestor layer that has its own backing store.
+    if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
+        return true;
+
     if (layer.mustCompositeForIndirectReasons()) {
         IndirectCompositingReason reason = layer.indirectCompositingReason();
         return reason == IndirectCompositingReason::Overlap
             || reason == IndirectCompositingReason::OverflowScrollPositioning
             || reason == IndirectCompositingReason::Stacking
             || reason == IndirectCompositingReason::BackgroundLayer
             || reason == IndirectCompositingReason::GraphicalEffect
             || reason == IndirectCompositingReason::Preserve3D; // preserve-3d has to create backing store to ensure that 3d-transformed elements intersect.
     }
 
-    if (!ancestorCompositedBounds.contains(layerCompositedBoundsInAncestor))
-        return true;
-
-    if (layer.isComposited() && layer.backing()->hasBackingSharingLayers())
-        return true;
-
     return false;
 }
 
 OptionSet<CompositingReason> RenderLayerCompositor::reasonsForCompositing(const RenderLayer& layer) const
 {
@@ -2443,13 +2469,10 @@
         reasons.add(CompositingReason::EmbeddedView);
 
     if ((canRender3DTransforms() && renderer.style().backfaceVisibility() == BackfaceVisibility::Hidden))
         reasons.add(CompositingReason::BackfaceVisibilityHidden);
 
-    if (clipsCompositingDescendants(*renderer.layer()))
-        reasons.add(CompositingReason::ClipsCompositingDescendants);
-
     if (requiresCompositingForAnimation(renderer))
         reasons.add(CompositingReason::Animation);
 
     if (requiresCompositingForFilters(renderer))
         reasons.add(CompositingReason::Filters);
@@ -2464,10 +2487,13 @@
         reasons.add(CompositingReason::OverflowScrolling);
 
     switch (renderer.layer()->indirectCompositingReason()) {
     case IndirectCompositingReason::None:
         break;
+    case IndirectCompositingReason::Clipping:
+        reasons.add(CompositingReason::ClipsCompositingDescendants);
+        break;
     case IndirectCompositingReason::Stacking:
         reasons.add(CompositingReason::Stacking);
         break;
     case IndirectCompositingReason::OverflowScrollPositioning:
         reasons.add(CompositingReason::OverflowScrollPositioning);
@@ -2750,13 +2776,18 @@
 {
     if (!(m_compositingTriggers & ChromeClient::AnimationTrigger))
         return false;
 
     if (auto* element = renderer.element()) {
-        if (auto* timeline = element->document().existingTimeline()) {
-            if (timeline->runningAnimationsForElementAreAllAccelerated(*element))
-                return true;
+        if (auto* effectsStack = element->keyframeEffectStack()) {
+            return (effectsStack->isCurrentlyAffectingProperty(CSSPropertyOpacity)
+                && (usesCompositing() || (m_compositingTriggers & ChromeClient::AnimatedOpacityTrigger)))
+                || effectsStack->isCurrentlyAffectingProperty(CSSPropertyFilter)
+#if ENABLE(FILTERS_LEVEL_2)
+                || effectsStack->isCurrentlyAffectingProperty(CSSPropertyWebkitBackdropFilter)
+#endif
+                || effectsStack->isCurrentlyAffectingProperty(CSSPropertyTransform);
         }
     }
 
     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
         return false;
@@ -2948,11 +2979,11 @@
 bool RenderLayerCompositor::requiresCompositingForScrollableFrame(RequiresCompositingData& queryData) const
 {
     if (isMainFrameCompositor())
         return false;
 
-#if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)
+#if PLATFORM(COCOA) || USE(NICOSIA)
     if (!m_renderView.settings().asyncFrameScrollingEnabled())
         return false;
 #endif
 
     if (!(m_compositingTriggers & ChromeClient::ScrollableNonMainFrameTrigger))
@@ -3037,46 +3068,40 @@
     }
 
     return layer.hasCompositedScrollableOverflow();
 }
 
-// FIXME: why doesn't this handle the clipping cases?
-bool RenderLayerCompositor::requiresCompositingForIndirectReason(const RenderLayer& layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking, IndirectCompositingReason& reason) const
+IndirectCompositingReason RenderLayerCompositor::computeIndirectCompositingReason(const RenderLayer& layer, bool hasCompositedDescendants, bool has3DTransformedDescendants, bool paintsIntoProvidedBacking) const
 {
     // When a layer has composited descendants, some effects, like 2d transforms, filters, masks etc must be implemented
     // via compositing so that they also apply to those composited descendants.
     auto& renderer = layer.renderer();
-    if (hasCompositedDescendants && (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection())) {
-        reason = IndirectCompositingReason::GraphicalEffect;
-        return true;
-    }
+    if (hasCompositedDescendants && (layer.isolatesCompositedBlending() || layer.transform() || renderer.createsGroup() || renderer.hasReflection()))
+        return IndirectCompositingReason::GraphicalEffect;
 
     // A layer with preserve-3d or perspective only needs to be composited if there are descendant layers that
     // will be affected by the preserve-3d or perspective.
     if (has3DTransformedDescendants) {
-        if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D) {
-            reason = IndirectCompositingReason::Preserve3D;
-            return true;
-        }
+        if (renderer.style().transformStyle3D() == TransformStyle3D::Preserve3D)
+            return IndirectCompositingReason::Preserve3D;
 
-        if (renderer.style().hasPerspective()) {
-            reason = IndirectCompositingReason::Perspective;
-            return true;
-        }
+        if (renderer.style().hasPerspective())
+            return IndirectCompositingReason::Perspective;
     }
 
     // If this layer scrolls independently from the layer that it would paint into, it needs to get composited.
     if (!paintsIntoProvidedBacking && layer.hasCompositedScrollingAncestor()) {
         auto* paintDestination = layer.paintOrderParent();
-        if (paintDestination && layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None) {
-            reason = IndirectCompositingReason::OverflowScrollPositioning;
-            return true;
-        }
+        if (paintDestination && layerScrollBehahaviorRelativeToCompositedAncestor(layer, *paintDestination) != ScrollPositioningBehavior::None)
+            return IndirectCompositingReason::OverflowScrollPositioning;
     }
 
-    reason = IndirectCompositingReason::None;
-    return false;
+    // Check for clipping last; if compositing just for clipping, the layer doesn't need its own backing store.
+    if (hasCompositedDescendants && clipsCompositingDescendants(layer))
+        return IndirectCompositingReason::Clipping;
+
+    return IndirectCompositingReason::None;
 }
 
 bool RenderLayerCompositor::styleChangeMayAffectIndirectCompositingReasons(const RenderStyle& oldStyle, const RenderStyle& newStyle)
 {
     if (RenderElement::createsGroupForStyle(newStyle) != RenderElement::createsGroupForStyle(oldStyle))
@@ -3247,11 +3272,11 @@
 
         return AncestorTraversal::Continue;
     });
 }
 
-ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer& layer) const
+ScrollPositioningBehavior RenderLayerCompositor::computeCoordinatedPositioningForLayer(const RenderLayer& layer, const RenderLayer* compositedAncestor) const
 {
     if (layer.isRenderViewLayer())
         return ScrollPositioningBehavior::None;
 
     if (layer.renderer().isFixedPositioned())
@@ -3262,11 +3287,10 @@
 
     auto* scrollingCoordinator = this->scrollingCoordinator();
     if (!scrollingCoordinator)
         return ScrollPositioningBehavior::None;
 
-    auto* compositedAncestor = layer.ancestorCompositingLayer();
     if (!compositedAncestor) {
         ASSERT_NOT_REACHED();
         return ScrollPositioningBehavior::None;
     }
 
@@ -3316,17 +3340,18 @@
 bool RenderLayerCompositor::isRunningTransformAnimation(RenderLayerModelObject& renderer) const
 {
     if (!(m_compositingTriggers & ChromeClient::AnimationTrigger))
         return false;
 
-    if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
-        if (auto* element = renderer.element()) {
-            if (auto* timeline = element->document().existingTimeline())
-                return timeline->isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
-        }
-        return false;
+    if (auto* element = renderer.element()) {
+        if (auto* effectsStack = element->keyframeEffectStack())
+            return effectsStack->isCurrentlyAffectingProperty(CSSPropertyTransform);
     }
+
+    if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled())
+        return false;
+
     return renderer.animation().isRunningAnimationOnRenderer(renderer, CSSPropertyTransform);
 }
 
 // If an element has composited negative z-index children, those children render in front of the
 // layer background, so we need an extra 'contents' layer for the foreground of the layer object.
@@ -3365,11 +3390,11 @@
     transformedClip.moveBy(scrollbarRect.location());
     scrollbar->paint(context, transformedClip);
     context.restore();
 }
 
-void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext& context, OptionSet<GraphicsLayerPaintingPhase>, const FloatRect& clip, GraphicsLayerPaintBehavior)
+void RenderLayerCompositor::paintContents(const GraphicsLayer* graphicsLayer, GraphicsContext& context, const FloatRect& clip, GraphicsLayerPaintBehavior)
 {
 #if PLATFORM(MAC)
     LocalDefaultSystemAppearance localAppearance(m_renderView.useDarkAppearance());
 #endif
 
@@ -4092,11 +4117,11 @@
     if (style.transformStyle3D() == TransformStyle3D::Preserve3D || style.hasPerspective() || style.transform().has3DOperation())
         return true;
 
     const_cast<RenderLayer&>(layer).updateLayerListsIfNeeded();
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     LayerListMutationDetector mutationChecker(const_cast<RenderLayer&>(layer));
 #endif
 
     for (auto* renderLayer : layer.negativeZOrderLayers()) {
         if (layerHas3DContent(*renderLayer))
@@ -4317,20 +4342,20 @@
         detachScrollCoordinatedLayerWithRole(layer, *scrollingCoordinator, ScrollCoordinationRole::Positioning);
 
     backing->detachFromScrollingCoordinator(roles);
 }
 
-OptionSet<ScrollCoordinationRole> RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer& layer) const
+OptionSet<ScrollCoordinationRole> RenderLayerCompositor::coordinatedScrollingRolesForLayer(const RenderLayer& layer, const RenderLayer* compositingAncestor) const
 {
     OptionSet<ScrollCoordinationRole> coordinationRoles;
     if (isViewportConstrainedFixedOrStickyLayer(layer))
         coordinationRoles.add(ScrollCoordinationRole::ViewportConstrained);
 
     if (useCoordinatedScrollingForLayer(layer))
         coordinationRoles.add(ScrollCoordinationRole::Scrolling);
 
-    auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer);
+    auto coordinatedPositioning = computeCoordinatedPositioningForLayer(layer, compositingAncestor);
     switch (coordinatedPositioning) {
     case ScrollPositioningBehavior::Moves:
         coordinationRoles.add(ScrollCoordinationRole::ScrollingProxy);
         break;
     case ScrollPositioningBehavior::Stationary:
@@ -4344,13 +4369,13 @@
         coordinationRoles.add(ScrollCoordinationRole::FrameHosting);
 
     return coordinationRoles;
 }
 
-ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer& layer, ScrollingTreeState& treeState, OptionSet<ScrollingNodeChangeFlags> changes)
+ScrollingNodeID RenderLayerCompositor::updateScrollCoordinationForLayer(RenderLayer& layer, const RenderLayer* compositingAncestor, ScrollingTreeState& treeState, OptionSet<ScrollingNodeChangeFlags> changes)
 {
-    auto roles = coordinatedScrollingRolesForLayer(layer);
+    auto roles = coordinatedScrollingRolesForLayer(layer, compositingAncestor);
 
 #if PLATFORM(IOS_FAMILY)
     if (m_legacyScrollingLayerCoordinator) {
         if (roles.contains(ScrollCoordinationRole::ViewportConstrained))
             m_legacyScrollingLayerCoordinator->addViewportConstrainedLayer(layer);
@@ -4369,11 +4394,11 @@
     ScrollingTreeState childTreeState;
     ScrollingTreeState* currentTreeState = &treeState;
 
     // If there's a positioning node, it's the parent scrolling node for fixed/sticky/scrolling/frame hosting.
     if (roles.contains(ScrollCoordinationRole::Positioning)) {
-        newNodeID = updateScrollingNodeForPositioningRole(layer, *currentTreeState, changes);
+        newNodeID = updateScrollingNodeForPositioningRole(layer, compositingAncestor, *currentTreeState, changes);
         childTreeState.parentNodeID = newNodeID;
         currentTreeState = &childTreeState;
     } else
         detachScrollCoordinatedLayer(layer, ScrollCoordinationRole::Positioning);
 
@@ -4595,11 +4620,11 @@
     }
 
     return newNodeID;
 }
 
-ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer& layer, ScrollingTreeState& treeState, OptionSet<ScrollingNodeChangeFlags> changes)
+ScrollingNodeID RenderLayerCompositor::updateScrollingNodeForPositioningRole(RenderLayer& layer, const RenderLayer* compositingAncestor, ScrollingTreeState& treeState, OptionSet<ScrollingNodeChangeFlags> changes)
 {
     auto* scrollingCoordinator = this->scrollingCoordinator();
 
     auto newNodeID = attachScrollingNode(layer, ScrollingNodeType::Positioned, treeState);
     if (!newNodeID) {
@@ -4612,11 +4637,11 @@
         scrollingCoordinator->setNodeLayers(newNodeID, { backing.graphicsLayer() });
     }
 
     if (changes & ScrollingNodeChangeFlags::LayerGeometry && treeState.parentNodeID) {
         // Would be nice to avoid calling computeCoordinatedPositioningForLayer() again.
-        auto positioningBehavior = computeCoordinatedPositioningForLayer(layer);
+        auto positioningBehavior = computeCoordinatedPositioningForLayer(layer, compositingAncestor);
         auto relatedNodeIDs = collectRelatedCoordinatedScrollingNodes(layer, positioningBehavior);
         scrollingCoordinator->setRelatedOverflowScrollingNodes(newNodeID, WTFMove(relatedNodeIDs));
 
         auto* graphicsLayer = layer.backing()->graphicsLayer();
         AbsolutePositionConstraints constraints;
@@ -4640,11 +4665,11 @@
 {
     if (scrollingCoordinator())
         return;
 
 #if PLATFORM(IOS_FAMILY)
-    ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
+    ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);
     if (m_legacyScrollingLayerCoordinator)
         m_legacyScrollingLayerCoordinator->removeScrollingLayer(layer, backing);
 #else
     UNUSED_PARAM(layer);
     UNUSED_PARAM(backing);
@@ -4656,11 +4681,11 @@
 {
     if (scrollingCoordinator())
         return;
 
 #if PLATFORM(IOS_FAMILY)
-    ASSERT(m_renderView.document().pageCacheState() == Document::NotInPageCache);
+    ASSERT(m_renderView.document().backForwardCacheState() == Document::NotInBackForwardCache);
     if (m_legacyScrollingLayerCoordinator)
         m_legacyScrollingLayerCoordinator->addScrollingLayer(layer);
 #else
     UNUSED_PARAM(layer);
 #endif

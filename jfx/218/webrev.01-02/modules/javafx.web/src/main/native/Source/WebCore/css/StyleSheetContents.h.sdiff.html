<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleSheetContents.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TransformFunctions.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48     static Ref&lt;StyleSheetContents&gt; create(const CSSParserContext&amp; context = CSSParserContext(HTMLStandardMode))
 49     {
 50         return adoptRef(*new StyleSheetContents(0, String(), context));
 51     }
 52     static Ref&lt;StyleSheetContents&gt; create(const String&amp; originalURL, const CSSParserContext&amp; context)
 53     {
 54         return adoptRef(*new StyleSheetContents(0, originalURL, context));
 55     }
 56     static Ref&lt;StyleSheetContents&gt; create(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp; context)
 57     {
 58         return adoptRef(*new StyleSheetContents(ownerRule, originalURL, context));
 59     }
 60 
 61     WEBCORE_EXPORT ~StyleSheetContents();
 62 
 63     const CSSParserContext&amp; parserContext() const { return m_parserContext; }
 64 
 65     const AtomString&amp; defaultNamespace() { return m_defaultNamespace; }
 66     const AtomString&amp; namespaceURIFromPrefix(const AtomString&amp; prefix);
 67 
<span class="line-modified"> 68     void parseAuthorStyleSheet(const CachedCSSStyleSheet*, const SecurityOrigin*);</span>
 69     WEBCORE_EXPORT bool parseString(const String&amp;);
 70 
 71     bool isCacheable() const;
 72 
 73     bool isLoading() const;
 74     bool subresourcesAllowReuse(CachePolicy, FrameLoader&amp;) const;
 75     WEBCORE_EXPORT bool isLoadingSubresources() const;
 76 
 77     void checkLoaded();
 78     void startLoadingDynamicSheet();
 79 
 80     StyleSheetContents* rootStyleSheet() const;
 81     Node* singleOwnerNode() const;
 82     Document* singleOwnerDocument() const;
 83 
 84     const String&amp; charset() const { return m_parserContext.charset; }
 85 
 86     bool loadCompleted() const { return m_loadCompleted; }
 87 
 88     URL completeURL(const String&amp; url) const;
</pre>
<hr />
<pre>
130     void wrapperDeleteRule(unsigned index);
131 
132     Ref&lt;StyleSheetContents&gt; copy() const { return adoptRef(*new StyleSheetContents(*this)); }
133 
134     void registerClient(CSSStyleSheet*);
135     void unregisterClient(CSSStyleSheet*);
136     bool hasOneClient() { return m_clients.size() == 1; }
137 
138     bool isMutable() const { return m_isMutable; }
139     void setMutable() { m_isMutable = true; }
140 
141     bool isInMemoryCache() const { return m_inMemoryCacheCount; }
142     void addedToMemoryCache();
143     void removedFromMemoryCache();
144 
145     void shrinkToFit();
146 
147     void setAsOpaque() { m_parserContext.isContentOpaque = true; }
148     bool isContentOpaque() const { return m_parserContext.isContentOpaque; }
149 


150 private:
151     WEBCORE_EXPORT StyleSheetContents(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp;);
152     StyleSheetContents(const StyleSheetContents&amp;);
153 
154     void clearCharsetRule();
155 
156     StyleRuleImport* m_ownerRule;
157 
158     String m_originalURL;
159 
160     String m_encodingFromCharsetRule;
161     Vector&lt;RefPtr&lt;StyleRuleImport&gt;&gt; m_importRules;
162     Vector&lt;RefPtr&lt;StyleRuleNamespace&gt;&gt; m_namespaceRules;
163     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; m_childRules;
164     typedef HashMap&lt;AtomString, AtomString&gt; PrefixNamespaceURIMap;
165     PrefixNamespaceURIMap m_namespaces;
166     AtomString m_defaultNamespace;
167 
168     bool m_isUserStyleSheet;
169     bool m_loadCompleted { false };
</pre>
</td>
<td>
<hr />
<pre>
 48     static Ref&lt;StyleSheetContents&gt; create(const CSSParserContext&amp; context = CSSParserContext(HTMLStandardMode))
 49     {
 50         return adoptRef(*new StyleSheetContents(0, String(), context));
 51     }
 52     static Ref&lt;StyleSheetContents&gt; create(const String&amp; originalURL, const CSSParserContext&amp; context)
 53     {
 54         return adoptRef(*new StyleSheetContents(0, originalURL, context));
 55     }
 56     static Ref&lt;StyleSheetContents&gt; create(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp; context)
 57     {
 58         return adoptRef(*new StyleSheetContents(ownerRule, originalURL, context));
 59     }
 60 
 61     WEBCORE_EXPORT ~StyleSheetContents();
 62 
 63     const CSSParserContext&amp; parserContext() const { return m_parserContext; }
 64 
 65     const AtomString&amp; defaultNamespace() { return m_defaultNamespace; }
 66     const AtomString&amp; namespaceURIFromPrefix(const AtomString&amp; prefix);
 67 
<span class="line-modified"> 68     bool parseAuthorStyleSheet(const CachedCSSStyleSheet*, const SecurityOrigin*);</span>
 69     WEBCORE_EXPORT bool parseString(const String&amp;);
 70 
 71     bool isCacheable() const;
 72 
 73     bool isLoading() const;
 74     bool subresourcesAllowReuse(CachePolicy, FrameLoader&amp;) const;
 75     WEBCORE_EXPORT bool isLoadingSubresources() const;
 76 
 77     void checkLoaded();
 78     void startLoadingDynamicSheet();
 79 
 80     StyleSheetContents* rootStyleSheet() const;
 81     Node* singleOwnerNode() const;
 82     Document* singleOwnerDocument() const;
 83 
 84     const String&amp; charset() const { return m_parserContext.charset; }
 85 
 86     bool loadCompleted() const { return m_loadCompleted; }
 87 
 88     URL completeURL(const String&amp; url) const;
</pre>
<hr />
<pre>
130     void wrapperDeleteRule(unsigned index);
131 
132     Ref&lt;StyleSheetContents&gt; copy() const { return adoptRef(*new StyleSheetContents(*this)); }
133 
134     void registerClient(CSSStyleSheet*);
135     void unregisterClient(CSSStyleSheet*);
136     bool hasOneClient() { return m_clients.size() == 1; }
137 
138     bool isMutable() const { return m_isMutable; }
139     void setMutable() { m_isMutable = true; }
140 
141     bool isInMemoryCache() const { return m_inMemoryCacheCount; }
142     void addedToMemoryCache();
143     void removedFromMemoryCache();
144 
145     void shrinkToFit();
146 
147     void setAsOpaque() { m_parserContext.isContentOpaque = true; }
148     bool isContentOpaque() const { return m_parserContext.isContentOpaque; }
149 
<span class="line-added">150     void setLoadErrorOccured() { m_didLoadErrorOccur = true; }</span>
<span class="line-added">151 </span>
152 private:
153     WEBCORE_EXPORT StyleSheetContents(StyleRuleImport* ownerRule, const String&amp; originalURL, const CSSParserContext&amp;);
154     StyleSheetContents(const StyleSheetContents&amp;);
155 
156     void clearCharsetRule();
157 
158     StyleRuleImport* m_ownerRule;
159 
160     String m_originalURL;
161 
162     String m_encodingFromCharsetRule;
163     Vector&lt;RefPtr&lt;StyleRuleImport&gt;&gt; m_importRules;
164     Vector&lt;RefPtr&lt;StyleRuleNamespace&gt;&gt; m_namespaceRules;
165     Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt; m_childRules;
166     typedef HashMap&lt;AtomString, AtomString&gt; PrefixNamespaceURIMap;
167     PrefixNamespaceURIMap m_namespaces;
168     AtomString m_defaultNamespace;
169 
170     bool m_isUserStyleSheet;
171     bool m_loadCompleted { false };
</pre>
</td>
</tr>
</table>
<center><a href="StyleSheetContents.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TransformFunctions.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPromotedHeapLocation.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPromotedHeapLocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPropertyTypeKey.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPromotedHeapLocation.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 37 struct Node;
 38 
 39 // Promoted locations are like heap locations but are meant to be more precise. A heap location is
 40 // applicable to CSE scenarios, where it makes sense to speak of a location very abstractly. A
 41 // promoted heap location is for cases where we speak of a specific object and the compiler knows
 42 // this object&#39;s identity - for example, the object allocation has been eliminated and we turned the
 43 // fields into local variables. Because these two cases have subtly different needs, we use subtly
 44 // different structures. One of the really significant differences is that promoted locations can be
 45 // spoken of using either a descriptor which does not refer to any Node*&#39;s or with a heap location,
 46 // which is a descriptor with a Node* base.
 47 
 48 enum PromotedLocationKind {
 49     InvalidPromotedLocationKind,
 50 
 51     ActivationScopePLoc,
 52     ActivationSymbolTablePLoc,
 53     ArgumentCountPLoc,
 54     ArgumentPLoc,
 55     ArgumentsCalleePLoc,
 56     ClosureVarPLoc,

 57     FunctionActivationPLoc,
 58     FunctionExecutablePLoc,
 59     IndexedPropertyPLoc,
 60     NamedPropertyPLoc,
 61     PublicLengthPLoc,
 62     StructurePLoc,
 63     VectorLengthPLoc,
 64     SpreadPLoc,
 65     NewArrayWithSpreadArgumentPLoc,
 66     NewArrayBufferPLoc,
 67     RegExpObjectRegExpPLoc,
 68     RegExpObjectLastIndexPLoc,
 69 };
 70 
 71 class PromotedLocationDescriptor {
 72 public:
 73     PromotedLocationDescriptor(
 74         PromotedLocationKind kind = InvalidPromotedLocationKind, unsigned info = 0)
 75         : m_kind(kind)
 76         , m_info(info)
</pre>
<hr />
<pre>
103         return m_kind == other.m_kind
104             &amp;&amp; m_info == other.m_info;
105     }
106 
107     bool operator!=(const PromotedLocationDescriptor&amp; other) const
108     {
109         return !(*this == other);
110     }
111 
112     bool isHashTableDeletedValue() const
113     {
114         return m_kind == InvalidPromotedLocationKind &amp;&amp; m_info;
115     }
116 
117     bool neededForMaterialization() const
118     {
119         switch (kind()) {
120         case NamedPropertyPLoc:
121         case ClosureVarPLoc:
122         case RegExpObjectLastIndexPLoc:

123             return false;
124 
125         default:
126             return true;
127         }
128     }
129 
130     void dump(PrintStream&amp; out) const;
131 
132 private:
133     PromotedLocationKind m_kind;
134     unsigned m_info;
135 };
136 
137 struct PromotedLocationDescriptorHash {
138     static unsigned hash(const PromotedLocationDescriptor&amp; key) { return key.hash(); }
139     static bool equal(const PromotedLocationDescriptor&amp; a, const PromotedLocationDescriptor&amp; b) { return a == b; }
<span class="line-modified">140     static const bool safeToCompareToEmptyOrDeleted = true;</span>
141 };
142 
143 class PromotedHeapLocation {
144 public:
145     PromotedHeapLocation(
146         PromotedLocationKind kind = InvalidPromotedLocationKind,
147         Node* base = nullptr, unsigned info = 0)
148         : m_base(base)
149         , m_meta(kind, info)
150     {
151     }
152 
153     PromotedHeapLocation(
154         PromotedLocationKind kind, Edge base, unsigned info = 0)
155         : PromotedHeapLocation(kind, base.node(), info)
156     {
157     }
158 
159     PromotedHeapLocation(Node* base, PromotedLocationDescriptor meta)
160         : m_base(base)
</pre>
<hr />
<pre>
186     {
187         return m_base == other.m_base
188             &amp;&amp; m_meta == other.m_meta;
189     }
190 
191     bool isHashTableDeletedValue() const
192     {
193         return m_meta.isHashTableDeletedValue();
194     }
195 
196     void dump(PrintStream&amp; out) const;
197 
198 private:
199     Node* m_base;
200     PromotedLocationDescriptor m_meta;
201 };
202 
203 struct PromotedHeapLocationHash {
204     static unsigned hash(const PromotedHeapLocation&amp; key) { return key.hash(); }
205     static bool equal(const PromotedHeapLocation&amp; a, const PromotedHeapLocation&amp; b) { return a == b; }
<span class="line-modified">206     static const bool safeToCompareToEmptyOrDeleted = true;</span>
207 };
208 
209 } } // namespace JSC::DFG
210 
211 namespace WTF {
212 
213 void printInternal(PrintStream&amp;, JSC::DFG::PromotedLocationKind);
214 
215 template&lt;typename T&gt; struct DefaultHash;
216 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedHeapLocation&gt; {
217     typedef JSC::DFG::PromotedHeapLocationHash Hash;
218 };
219 
220 template&lt;typename T&gt; struct HashTraits;
221 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; {
<span class="line-modified">222     static const bool emptyValueIsZero = false;</span>
223 };
224 
225 template&lt;typename T&gt; struct DefaultHash;
226 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
227     typedef JSC::DFG::PromotedLocationDescriptorHash Hash;
228 };
229 
230 template&lt;typename T&gt; struct HashTraits;
231 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
<span class="line-modified">232     static const bool emptyValueIsZero = false;</span>
233 };
234 
235 } // namespace WTF
236 
237 #endif // ENABLE(DFG_JIT)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 37 struct Node;
 38 
 39 // Promoted locations are like heap locations but are meant to be more precise. A heap location is
 40 // applicable to CSE scenarios, where it makes sense to speak of a location very abstractly. A
 41 // promoted heap location is for cases where we speak of a specific object and the compiler knows
 42 // this object&#39;s identity - for example, the object allocation has been eliminated and we turned the
 43 // fields into local variables. Because these two cases have subtly different needs, we use subtly
 44 // different structures. One of the really significant differences is that promoted locations can be
 45 // spoken of using either a descriptor which does not refer to any Node*&#39;s or with a heap location,
 46 // which is a descriptor with a Node* base.
 47 
 48 enum PromotedLocationKind {
 49     InvalidPromotedLocationKind,
 50 
 51     ActivationScopePLoc,
 52     ActivationSymbolTablePLoc,
 53     ArgumentCountPLoc,
 54     ArgumentPLoc,
 55     ArgumentsCalleePLoc,
 56     ClosureVarPLoc,
<span class="line-added"> 57     InternalFieldObjectPLoc,</span>
 58     FunctionActivationPLoc,
 59     FunctionExecutablePLoc,
 60     IndexedPropertyPLoc,
 61     NamedPropertyPLoc,
 62     PublicLengthPLoc,
 63     StructurePLoc,
 64     VectorLengthPLoc,
 65     SpreadPLoc,
 66     NewArrayWithSpreadArgumentPLoc,
 67     NewArrayBufferPLoc,
 68     RegExpObjectRegExpPLoc,
 69     RegExpObjectLastIndexPLoc,
 70 };
 71 
 72 class PromotedLocationDescriptor {
 73 public:
 74     PromotedLocationDescriptor(
 75         PromotedLocationKind kind = InvalidPromotedLocationKind, unsigned info = 0)
 76         : m_kind(kind)
 77         , m_info(info)
</pre>
<hr />
<pre>
104         return m_kind == other.m_kind
105             &amp;&amp; m_info == other.m_info;
106     }
107 
108     bool operator!=(const PromotedLocationDescriptor&amp; other) const
109     {
110         return !(*this == other);
111     }
112 
113     bool isHashTableDeletedValue() const
114     {
115         return m_kind == InvalidPromotedLocationKind &amp;&amp; m_info;
116     }
117 
118     bool neededForMaterialization() const
119     {
120         switch (kind()) {
121         case NamedPropertyPLoc:
122         case ClosureVarPLoc:
123         case RegExpObjectLastIndexPLoc:
<span class="line-added">124         case InternalFieldObjectPLoc:</span>
125             return false;
126 
127         default:
128             return true;
129         }
130     }
131 
132     void dump(PrintStream&amp; out) const;
133 
134 private:
135     PromotedLocationKind m_kind;
136     unsigned m_info;
137 };
138 
139 struct PromotedLocationDescriptorHash {
140     static unsigned hash(const PromotedLocationDescriptor&amp; key) { return key.hash(); }
141     static bool equal(const PromotedLocationDescriptor&amp; a, const PromotedLocationDescriptor&amp; b) { return a == b; }
<span class="line-modified">142     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
143 };
144 
145 class PromotedHeapLocation {
146 public:
147     PromotedHeapLocation(
148         PromotedLocationKind kind = InvalidPromotedLocationKind,
149         Node* base = nullptr, unsigned info = 0)
150         : m_base(base)
151         , m_meta(kind, info)
152     {
153     }
154 
155     PromotedHeapLocation(
156         PromotedLocationKind kind, Edge base, unsigned info = 0)
157         : PromotedHeapLocation(kind, base.node(), info)
158     {
159     }
160 
161     PromotedHeapLocation(Node* base, PromotedLocationDescriptor meta)
162         : m_base(base)
</pre>
<hr />
<pre>
188     {
189         return m_base == other.m_base
190             &amp;&amp; m_meta == other.m_meta;
191     }
192 
193     bool isHashTableDeletedValue() const
194     {
195         return m_meta.isHashTableDeletedValue();
196     }
197 
198     void dump(PrintStream&amp; out) const;
199 
200 private:
201     Node* m_base;
202     PromotedLocationDescriptor m_meta;
203 };
204 
205 struct PromotedHeapLocationHash {
206     static unsigned hash(const PromotedHeapLocation&amp; key) { return key.hash(); }
207     static bool equal(const PromotedHeapLocation&amp; a, const PromotedHeapLocation&amp; b) { return a == b; }
<span class="line-modified">208     static constexpr bool safeToCompareToEmptyOrDeleted = true;</span>
209 };
210 
211 } } // namespace JSC::DFG
212 
213 namespace WTF {
214 
215 void printInternal(PrintStream&amp;, JSC::DFG::PromotedLocationKind);
216 
217 template&lt;typename T&gt; struct DefaultHash;
218 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedHeapLocation&gt; {
219     typedef JSC::DFG::PromotedHeapLocationHash Hash;
220 };
221 
222 template&lt;typename T&gt; struct HashTraits;
223 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedHeapLocation&gt; {
<span class="line-modified">224     static constexpr bool emptyValueIsZero = false;</span>
225 };
226 
227 template&lt;typename T&gt; struct DefaultHash;
228 template&lt;&gt; struct DefaultHash&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
229     typedef JSC::DFG::PromotedLocationDescriptorHash Hash;
230 };
231 
232 template&lt;typename T&gt; struct HashTraits;
233 template&lt;&gt; struct HashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; : SimpleClassHashTraits&lt;JSC::DFG::PromotedLocationDescriptor&gt; {
<span class="line-modified">234     static constexpr bool emptyValueIsZero = false;</span>
235 };
236 
237 } // namespace WTF
238 
239 #endif // ENABLE(DFG_JIT)
</pre>
</td>
</tr>
</table>
<center><a href="DFGPromotedHeapLocation.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPropertyTypeKey.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
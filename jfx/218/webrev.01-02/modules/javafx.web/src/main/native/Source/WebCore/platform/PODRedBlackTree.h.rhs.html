<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-added">  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // A red-black tree, which is a form of a balanced binary tree. It
 28 // supports efficient insertion, deletion and queries of comparable
 29 // elements. The same element may be inserted multiple times. The
 30 // algorithmic complexity of common operations is:
 31 //
 32 //   Insertion: O(lg(n))
 33 //   Deletion:  O(lg(n))
 34 //   Querying:  O(lg(n))
 35 //
<a name="2" id="anc2"></a>





 36 // Type T must supply a default constructor, a copy constructor, and
 37 // the &quot;&lt;&quot; and &quot;==&quot; operators.
 38 //
 39 // In debug mode, printing of the data contained in the tree is
<a name="3" id="anc3"></a><span class="line-modified"> 40 // enabled. This makes use of WTF::TextStream.</span>
















 41 //
 42 // This red-black tree is designed to be _augmented_; subclasses can
 43 // add additional and summary information to each node to efficiently
 44 // store and index more complex data structures. A concrete example is
 45 // the IntervalTree, which extends each node with a summary statistic
 46 // to efficiently store one-dimensional intervals.
 47 //
 48 // The design of this red-black tree comes from Cormen, Leiserson,
 49 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 50 
<a name="4" id="anc4"></a><span class="line-modified"> 51 #pragma once</span>

 52 
 53 #include &lt;wtf/Assertions.h&gt;
 54 #include &lt;wtf/Noncopyable.h&gt;
<a name="5" id="anc5"></a><span class="line-modified"> 55 </span>
 56 #ifndef NDEBUG
 57 #include &lt;wtf/text/StringBuilder.h&gt;
<a name="6" id="anc6"></a><span class="line-modified"> 58 #include &lt;wtf/text/TextStream.h&gt;</span>
 59 #endif
 60 
<a name="7" id="anc7"></a><span class="line-added"> 61 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types too.</span>
<span class="line-added"> 62 // FIXME: Extend WTF::RedBlackTree and implement this on top of it rather than keeping two quite similar class templates around.</span>
<span class="line-added"> 63 </span>
 64 namespace WebCore {
 65 
<a name="8" id="anc8"></a><span class="line-modified"> 66 template&lt;typename T, typename NodeUpdaterType&gt; class PODRedBlackTree {</span>
<span class="line-modified"> 67     WTF_MAKE_NONCOPYABLE(PODRedBlackTree);</span>

 68 public:
<a name="9" id="anc9"></a><span class="line-modified"> 69     PODRedBlackTree() = default;</span>
 70 
<a name="10" id="anc10"></a><span class="line-modified"> 71     ~PODRedBlackTree()</span>

















 72     {
 73         clear();
 74     }
 75 
<a name="11" id="anc11"></a>

 76     void clear()
 77     {
<a name="12" id="anc12"></a><span class="line-modified"> 78         if (!m_root)</span>
<span class="line-modified"> 79             return;</span>
<span class="line-added"> 80         Node* next;</span>
<span class="line-added"> 81         for (Node* node = treeMinimum(m_root); node; node = next) {</span>
<span class="line-added"> 82             next = treeSuccessorInPostOrder(node);</span>
<span class="line-added"> 83             delete node;</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85         m_root = nullptr;</span>
 86     }
 87 
 88     void add(const T&amp; data)
 89     {
<a name="13" id="anc13"></a><span class="line-modified"> 90         add(T { data });</span>
<span class="line-modified"> 91     }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     void add(T&amp;&amp; data)</span>
<span class="line-added"> 94     {</span>
<span class="line-added"> 95         insertNode(new Node(WTFMove(data)));</span>
 96     }
 97 
 98     // Returns true if the datum was found in the tree.
 99     bool remove(const T&amp; data)
100     {
101         Node* node = treeSearch(data);
102         if (node) {
103             deleteNode(node);
104             return true;
105         }
106         return false;
107     }
108 
109     bool contains(const T&amp; data) const
110     {
111         return treeSearch(data);
112     }
113 
<a name="14" id="anc14"></a><span class="line-modified">114     bool isEmpty() const</span>
115     {
<a name="15" id="anc15"></a><span class="line-modified">116         return !m_root;</span>









117     }
118 
<a name="16" id="anc16"></a><span class="line-modified">119 #ifndef NDEBUG</span>




120 
<a name="17" id="anc17"></a><span class="line-modified">121     bool checkInvariants() const</span>
122     {
123         int blackCount;
<a name="18" id="anc18"></a><span class="line-modified">124         return checkInvariantsFromNode(m_root, blackCount);</span>
125     }
126 
<a name="19" id="anc19"></a><span class="line-modified">127     // Dumps the tree&#39;s contents to the logging info stream for debugging purposes.</span>


128     void dump() const
129     {
<a name="20" id="anc20"></a><span class="line-modified">130         dumpSubtree(m_root, 0);</span>
131     }
132 
133     // Turns on or off verbose debugging of the tree, causing many
134     // messages to be logged during insertion and other operations in
135     // debug mode.
136     void setVerboseDebugging(bool verboseDebugging)
137     {
138         m_verboseDebugging = verboseDebugging;
139     }
<a name="21" id="anc21"></a><span class="line-added">140 </span>
141 #endif
142 
<a name="22" id="anc22"></a><span class="line-modified">143 protected:</span>
<span class="line-modified">144     enum Color { Red, Black };</span>


145 
<a name="23" id="anc23"></a>


146     class Node {
147         WTF_MAKE_FAST_ALLOCATED;
148         WTF_MAKE_NONCOPYABLE(Node);
149     public:
<a name="24" id="anc24"></a><span class="line-modified">150         explicit Node(T&amp;&amp; data)</span>
<span class="line-modified">151             : m_data(WTFMove(data))</span>





152         {
153         }
154 
<a name="25" id="anc25"></a>

155         Color color() const { return m_color; }
156         void setColor(Color color) { m_color = color; }
157 
<a name="26" id="anc26"></a>
158         T&amp; data() { return m_data; }
159 
<a name="27" id="anc27"></a><span class="line-modified">160         void moveDataFrom(Node&amp; src) { m_data = WTFMove(src.m_data); }</span>






161 
162         Node* left() const { return m_left; }
163         void setLeft(Node* node) { m_left = node; }
164 
165         Node* right() const { return m_right; }
166         void setRight(Node* node) { m_right = node; }
167 
168         Node* parent() const { return m_parent; }
169         void setParent(Node* node) { m_parent = node; }
170 
171     private:
<a name="28" id="anc28"></a><span class="line-modified">172         Node* m_left { nullptr };</span>
<span class="line-modified">173         Node* m_right { nullptr };</span>
<span class="line-modified">174         Node* m_parent { nullptr };</span>
<span class="line-modified">175         Color m_color { Red };</span>
176         T m_data;
177     };
178 
<a name="29" id="anc29"></a>
179     // Returns the root of the tree, which is needed by some subclasses.
180     Node* root() const { return m_root; }
181 
182 private:
<a name="30" id="anc30"></a><span class="line-modified">183     // The update function is the hook that subclasses should use when</span>
184     // augmenting the red-black tree with additional per-node summary
185     // information. For example, in the case of an interval tree, this
186     // is used to compute the maximum endpoint of the subtree below the
187     // given node based on the values in the left and right children. It
188     // is guaranteed that this will be called in the correct order to
189     // properly update such summary information based only on the values
<a name="31" id="anc31"></a><span class="line-modified">190     // in the left and right children. The function should return true if</span>
191     // the node&#39;s summary information changed.
<a name="32" id="anc32"></a><span class="line-modified">192     static bool updateNode(Node&amp; node)</span>







193     {
<a name="33" id="anc33"></a><span class="line-modified">194         return NodeUpdaterType::update(node);</span>



195     }
196 
<a name="34" id="anc34"></a><span class="line-modified">197     Node* treeSearch(const T&amp; data) const</span>


198     {
<a name="35" id="anc35"></a><span class="line-modified">199         for (auto* current = m_root; current; ) {</span>
200             if (current-&gt;data() == data)
201                 return current;
202             if (data &lt; current-&gt;data())
203                 current = current-&gt;left();
204             else
205                 current = current-&gt;right();
206         }
<a name="36" id="anc36"></a><span class="line-modified">207         return nullptr;</span>




















208     }
209 
210     void treeInsert(Node* z)
211     {
<a name="37" id="anc37"></a><span class="line-modified">212         Node* y = nullptr;</span>
213         Node* x = m_root;
214         while (x) {
215             y = x;
216             if (z-&gt;data() &lt; x-&gt;data())
217                 x = x-&gt;left();
218             else
219                 x = x-&gt;right();
220         }
221         z-&gt;setParent(y);
222         if (!y)
223             m_root = z;
224         else {
225             if (z-&gt;data() &lt; y-&gt;data())
226                 y-&gt;setLeft(z);
227             else
228                 y-&gt;setRight(z);
229         }
230     }
231 
232     // Finds the node following the given one in sequential ordering of
233     // their data, or null if none exists.
<a name="38" id="anc38"></a><span class="line-modified">234     static Node* treeSuccessor(Node* x)</span>
235     {
236         if (x-&gt;right())
237             return treeMinimum(x-&gt;right());
238         Node* y = x-&gt;parent();
239         while (y &amp;&amp; x == y-&gt;right()) {
240             x = y;
241             y = y-&gt;parent();
242         }
243         return y;
244     }
245 
<a name="39" id="anc39"></a><span class="line-modified">246     // Finds the minimum element in the sub-tree rooted at the given node.</span>
<span class="line-modified">247     static Node* treeMinimum(Node* x)</span>

248     {
249         while (x-&gt;left())
250             x = x-&gt;left();
251         return x;
252     }
253 
<a name="40" id="anc40"></a><span class="line-modified">254     static Node* treeSuccessorInPostOrder(Node* x)</span>

255     {
<a name="41" id="anc41"></a><span class="line-modified">256         Node* y = x-&gt;parent();</span>
<span class="line-modified">257         if (y &amp;&amp; x == y-&gt;left() &amp;&amp; y-&gt;right())</span>
<span class="line-modified">258             return treeMinimum(y-&gt;right());</span>
<span class="line-modified">259         return y;</span>

260     }
261 
262     //----------------------------------------------------------------------
263     // Red-Black tree operations
264     //
265 
266     // Left-rotates the subtree rooted at x.
267     // Returns the new root of the subtree (x&#39;s right child).
268     Node* leftRotate(Node* x)
269     {
270         // Set y.
271         Node* y = x-&gt;right();
272 
273         // Turn y&#39;s left subtree into x&#39;s right subtree.
274         x-&gt;setRight(y-&gt;left());
275         if (y-&gt;left())
276             y-&gt;left()-&gt;setParent(x);
277 
278         // Link x&#39;s parent to y.
279         y-&gt;setParent(x-&gt;parent());
280         if (!x-&gt;parent())
281             m_root = y;
282         else {
283             if (x == x-&gt;parent()-&gt;left())
284                 x-&gt;parent()-&gt;setLeft(y);
285             else
286                 x-&gt;parent()-&gt;setRight(y);
287         }
288 
289         // Put x on y&#39;s left.
290         y-&gt;setLeft(x);
291         x-&gt;setParent(y);
292 
293         // Update nodes lowest to highest.
<a name="42" id="anc42"></a><span class="line-modified">294         updateNode(*x);</span>
<span class="line-modified">295         updateNode(*y);</span>
296         return y;
297     }
298 
<a name="43" id="anc43"></a><span class="line-added">299     static void propagateUpdates(Node* start)</span>
<span class="line-added">300     {</span>
<span class="line-added">301         while (start &amp;&amp; updateNode(*start))</span>
<span class="line-added">302             start = start-&gt;parent();</span>
<span class="line-added">303     }</span>
<span class="line-added">304 </span>
305     // Right-rotates the subtree rooted at y.
306     // Returns the new root of the subtree (y&#39;s left child).
307     Node* rightRotate(Node* y)
308     {
309         // Set x.
310         Node* x = y-&gt;left();
311 
312         // Turn x&#39;s right subtree into y&#39;s left subtree.
313         y-&gt;setLeft(x-&gt;right());
314         if (x-&gt;right())
315             x-&gt;right()-&gt;setParent(y);
316 
317         // Link y&#39;s parent to x.
318         x-&gt;setParent(y-&gt;parent());
319         if (!y-&gt;parent())
320             m_root = x;
321         else {
322             if (y == y-&gt;parent()-&gt;left())
323                 y-&gt;parent()-&gt;setLeft(x);
324             else
325                 y-&gt;parent()-&gt;setRight(x);
326         }
327 
328         // Put y on x&#39;s right.
329         x-&gt;setRight(y);
330         y-&gt;setParent(x);
331 
332         // Update nodes lowest to highest.
<a name="44" id="anc44"></a><span class="line-modified">333         updateNode(*y);</span>
<span class="line-modified">334         updateNode(*x);</span>
335         return x;
336     }
337 
338     // Inserts the given node into the tree.
339     void insertNode(Node* x)
340     {
341         treeInsert(x);
342         x-&gt;setColor(Red);
<a name="45" id="anc45"></a><span class="line-modified">343         updateNode(*x);</span>
344 
345         logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
346 
347         // The node from which to start propagating updates upwards.
348         Node* updateStart = x-&gt;parent();
349 
350         while (x != m_root &amp;&amp; x-&gt;parent()-&gt;color() == Red) {
351             if (x-&gt;parent() == x-&gt;parent()-&gt;parent()-&gt;left()) {
352                 Node* y = x-&gt;parent()-&gt;parent()-&gt;right();
353                 if (y &amp;&amp; y-&gt;color() == Red) {
354                     // Case 1
355                     logIfVerbose(&quot;  Case 1/1&quot;);
356                     x-&gt;parent()-&gt;setColor(Black);
357                     y-&gt;setColor(Black);
358                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<a name="46" id="anc46"></a><span class="line-modified">359                     updateNode(*x-&gt;parent());</span>
360                     x = x-&gt;parent()-&gt;parent();
<a name="47" id="anc47"></a><span class="line-modified">361                     updateNode(*x);</span>
362                     updateStart = x-&gt;parent();
363                 } else {
364                     if (x == x-&gt;parent()-&gt;right()) {
365                         logIfVerbose(&quot;  Case 1/2&quot;);
366                         // Case 2
367                         x = x-&gt;parent();
368                         leftRotate(x);
369                     }
370                     // Case 3
371                     logIfVerbose(&quot;  Case 1/3&quot;);
372                     x-&gt;parent()-&gt;setColor(Black);
373                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
374                     Node* newSubTreeRoot = rightRotate(x-&gt;parent()-&gt;parent());
375                     updateStart = newSubTreeRoot-&gt;parent();
376                 }
377             } else {
378                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot; exchanged.
379                 Node* y = x-&gt;parent()-&gt;parent()-&gt;left();
380                 if (y &amp;&amp; y-&gt;color() == Red) {
381                     // Case 1
382                     logIfVerbose(&quot;  Case 2/1&quot;);
383                     x-&gt;parent()-&gt;setColor(Black);
384                     y-&gt;setColor(Black);
385                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
<a name="48" id="anc48"></a><span class="line-modified">386                     updateNode(*x-&gt;parent());</span>
387                     x = x-&gt;parent()-&gt;parent();
<a name="49" id="anc49"></a><span class="line-modified">388                     updateNode(*x);</span>
389                     updateStart = x-&gt;parent();
390                 } else {
391                     if (x == x-&gt;parent()-&gt;left()) {
392                         // Case 2
393                         logIfVerbose(&quot;  Case 2/2&quot;);
394                         x = x-&gt;parent();
395                         rightRotate(x);
396                     }
397                     // Case 3
398                     logIfVerbose(&quot;  Case 2/3&quot;);
399                     x-&gt;parent()-&gt;setColor(Black);
400                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
401                     Node* newSubTreeRoot = leftRotate(x-&gt;parent()-&gt;parent());
402                     updateStart = newSubTreeRoot-&gt;parent();
403                 }
404             }
405         }
406 
407         propagateUpdates(updateStart);
408 
409         m_root-&gt;setColor(Black);
410     }
411 
412     // Restores the red-black property to the tree after splicing out
<a name="50" id="anc50"></a><span class="line-modified">413     // a node. Note that x may be null, which is why xParent must be supplied.</span>

414     void deleteFixup(Node* x, Node* xParent)
415     {
416         while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
417             if (x == xParent-&gt;left()) {
418                 // Note: the text points out that w can not be null.
419                 // The reason is not obvious from simply looking at
420                 // the code; it comes about from the properties of the
421                 // red-black tree.
422                 Node* w = xParent-&gt;right();
423                 ASSERT(w); // x&#39;s sibling should not be null.
424                 if (w-&gt;color() == Red) {
425                     // Case 1
426                     w-&gt;setColor(Black);
427                     xParent-&gt;setColor(Red);
428                     leftRotate(xParent);
429                     w = xParent-&gt;right();
430                 }
431                 if ((!w-&gt;left() || w-&gt;left()-&gt;color() == Black)
432                     &amp;&amp; (!w-&gt;right() || w-&gt;right()-&gt;color() == Black)) {
433                     // Case 2
434                     w-&gt;setColor(Red);
435                     x = xParent;
436                     xParent = x-&gt;parent();
437                 } else {
438                     if (!w-&gt;right() || w-&gt;right()-&gt;color() == Black) {
439                         // Case 3
440                         w-&gt;left()-&gt;setColor(Black);
441                         w-&gt;setColor(Red);
442                         rightRotate(w);
443                         w = xParent-&gt;right();
444                     }
445                     // Case 4
446                     w-&gt;setColor(xParent-&gt;color());
447                     xParent-&gt;setColor(Black);
448                     if (w-&gt;right())
449                         w-&gt;right()-&gt;setColor(Black);
450                     leftRotate(xParent);
451                     x = m_root;
452                     xParent = x-&gt;parent();
453                 }
454             } else {
455                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot;
456                 // exchanged.
457 
458                 // Note: the text points out that w can not be null.
459                 // The reason is not obvious from simply looking at
460                 // the code; it comes about from the properties of the
461                 // red-black tree.
462                 Node* w = xParent-&gt;left();
463                 ASSERT(w); // x&#39;s sibling should not be null.
464                 if (w-&gt;color() == Red) {
465                     // Case 1
466                     w-&gt;setColor(Black);
467                     xParent-&gt;setColor(Red);
468                     rightRotate(xParent);
469                     w = xParent-&gt;left();
470                 }
471                 if ((!w-&gt;right() || w-&gt;right()-&gt;color() == Black)
472                     &amp;&amp; (!w-&gt;left() || w-&gt;left()-&gt;color() == Black)) {
473                     // Case 2
474                     w-&gt;setColor(Red);
475                     x = xParent;
476                     xParent = x-&gt;parent();
477                 } else {
478                     if (!w-&gt;left() || w-&gt;left()-&gt;color() == Black) {
479                         // Case 3
480                         w-&gt;right()-&gt;setColor(Black);
481                         w-&gt;setColor(Red);
482                         leftRotate(w);
483                         w = xParent-&gt;left();
484                     }
485                     // Case 4
486                     w-&gt;setColor(xParent-&gt;color());
487                     xParent-&gt;setColor(Black);
488                     if (w-&gt;left())
489                         w-&gt;left()-&gt;setColor(Black);
490                     rightRotate(xParent);
491                     x = m_root;
492                     xParent = x-&gt;parent();
493                 }
494             }
495         }
496         if (x)
497             x-&gt;setColor(Black);
498     }
499 
500     // Deletes the given node from the tree. Note that this
501     // particular node may not actually be removed from the tree;
502     // instead, another node might be removed and its contents
503     // copied into z.
504     void deleteNode(Node* z)
505     {
506         // Y is the node to be unlinked from the tree.
507         Node* y;
508         if (!z-&gt;left() || !z-&gt;right())
509             y = z;
510         else
511             y = treeSuccessor(z);
512 
513         // Y is guaranteed to be non-null at this point.
514         Node* x;
515         if (y-&gt;left())
516             x = y-&gt;left();
517         else
518             x = y-&gt;right();
519 
520         // X is the child of y which might potentially replace y in
521         // the tree. X might be null at this point.
522         Node* xParent;
523         if (x) {
524             x-&gt;setParent(y-&gt;parent());
525             xParent = x-&gt;parent();
526         } else
527             xParent = y-&gt;parent();
528         if (!y-&gt;parent())
529             m_root = x;
530         else {
531             if (y == y-&gt;parent()-&gt;left())
532                 y-&gt;parent()-&gt;setLeft(x);
533             else
534                 y-&gt;parent()-&gt;setRight(x);
535         }
536         if (y != z) {
<a name="51" id="anc51"></a><span class="line-modified">537             z-&gt;moveDataFrom(*y);</span>
538             // This node has changed location in the tree and must be updated.
<a name="52" id="anc52"></a><span class="line-modified">539             updateNode(*z);</span>
540             // The parent and its parents may now be out of date.
541             propagateUpdates(z-&gt;parent());
542         }
543 
544         // If we haven&#39;t already updated starting from xParent, do so now.
545         if (xParent &amp;&amp; xParent != y &amp;&amp; xParent != z)
546             propagateUpdates(xParent);
547         if (y-&gt;color() == Black)
548             deleteFixup(x, xParent);
549 
550         delete y;
551     }
552 
<a name="53" id="anc53"></a>






































553     //----------------------------------------------------------------------
554     // Verification and debugging routines
555     //
556 
<a name="54" id="anc54"></a><span class="line-added">557 #ifndef NDEBUG</span>
<span class="line-added">558 </span>
559     // Returns in the &quot;blackCount&quot; parameter the number of black
560     // children along all paths to all leaves of the given node.
<a name="55" id="anc55"></a><span class="line-modified">561     bool checkInvariantsFromNode(Node* node, int&amp; blackCount) const</span>
562     {
563         // Base case is a leaf node.
564         if (!node) {
<a name="56" id="anc56"></a><span class="line-modified">565             blackCount = 1;</span>
566             return true;
567         }
568 
569         // Each node is either red or black.
570         if (!(node-&gt;color() == Red || node-&gt;color() == Black))
571             return false;
572 
573         // Every leaf (or null) is black.
574 
575         if (node-&gt;color() == Red) {
576             // Both of its children are black.
577             if (!((!node-&gt;left() || node-&gt;left()-&gt;color() == Black)))
578                 return false;
579             if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
580                 return false;
581         }
582 
<a name="57" id="anc57"></a><span class="line-modified">583         // Every simple path to a leaf node contains the same number of black nodes.</span>

584         int leftCount = 0, rightCount = 0;
<a name="58" id="anc58"></a><span class="line-modified">585         bool leftValid = checkInvariantsFromNode(node-&gt;left(), leftCount);</span>
<span class="line-modified">586         bool rightValid = checkInvariantsFromNode(node-&gt;right(), rightCount);</span>
587         if (!leftValid || !rightValid)
588             return false;
<a name="59" id="anc59"></a><span class="line-modified">589         blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);</span>
590         return leftCount == rightCount;
591     }
592 
<a name="60" id="anc60"></a><span class="line-added">593 #endif</span>
<span class="line-added">594 </span>
595 #ifdef NDEBUG
596     void logIfVerbose(const char*) const { }
597 #else
598     void logIfVerbose(const char* output) const
599     {
600         if (m_verboseDebugging)
601             LOG_ERROR(&quot;%s&quot;, output);
602     }
603 #endif
604 
605 #ifndef NDEBUG
<a name="61" id="anc61"></a><span class="line-modified">606 </span>
<span class="line-modified">607     void dumpSubtree(Node* node, int indentation) const</span>
608     {
609         StringBuilder builder;
610         for (int i = 0; i &lt; indentation; i++)
611             builder.append(&#39; &#39;);
612         builder.append(&#39;-&#39;);
613         if (node) {
614             builder.append(&#39; &#39;);
<a name="62" id="anc62"></a><span class="line-modified">615             TextStream stream;</span>
<span class="line-added">616             stream &lt;&lt; node-&gt;data();</span>
<span class="line-added">617             builder.append(stream.release());</span>
618             builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
619         }
<a name="63" id="anc63"></a><span class="line-modified">620         LOG_ERROR(&quot;%s&quot;, builder.toString().utf8().data());</span>
621         if (node) {
<a name="64" id="anc64"></a><span class="line-modified">622             dumpSubtree(node-&gt;left(), indentation + 2);</span>
<span class="line-modified">623             dumpSubtree(node-&gt;right(), indentation + 2);</span>
624         }
625     }
<a name="65" id="anc65"></a>
626 
<a name="66" id="anc66"></a><span class="line-modified">627 #endif</span>

628 
<a name="67" id="anc67"></a><span class="line-modified">629     Node* m_root { nullptr };</span>

630 #ifndef NDEBUG
<a name="68" id="anc68"></a><span class="line-modified">631     bool m_verboseDebugging { false };</span>
632 #endif
633 };
634 
635 } // namespace WebCore
<a name="69" id="anc69"></a>

<a name="70" id="anc70"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="70" type="hidden" />
</body>
</html>
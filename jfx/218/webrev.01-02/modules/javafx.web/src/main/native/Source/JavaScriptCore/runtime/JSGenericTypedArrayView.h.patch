diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013, 2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -91,25 +91,25 @@
 static const ASCIILiteral typedArrayBufferHasBeenDetachedErrorMessage { "Underlying ArrayBuffer has been detached from the view"_s };
 
 template<typename Adaptor>
 class JSGenericTypedArrayView final : public JSArrayBufferView {
 public:
-    typedef JSArrayBufferView Base;
+    using Base = JSArrayBufferView;
     typedef typename Adaptor::Type ElementType;
 
-    static const unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;
 
-    static const unsigned elementSize = sizeof(typename Adaptor::Type);
+    static constexpr unsigned elementSize = sizeof(typename Adaptor::Type);
 
 protected:
     JSGenericTypedArrayView(VM&, ConstructionContext&);
 
 public:
-    static JSGenericTypedArrayView* create(ExecState*, Structure*, unsigned length);
-    static JSGenericTypedArrayView* createWithFastVector(ExecState*, Structure*, unsigned length, void* vector);
-    static JSGenericTypedArrayView* createUninitialized(ExecState*, Structure*, unsigned length);
-    static JSGenericTypedArrayView* create(ExecState*, Structure*, RefPtr<ArrayBuffer>&&, unsigned byteOffset, unsigned length);
+    static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, unsigned length);
+    static JSGenericTypedArrayView* createWithFastVector(JSGlobalObject*, Structure*, unsigned length, void* vector);
+    static JSGenericTypedArrayView* createUninitialized(JSGlobalObject*, Structure*, unsigned length);
+    static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, RefPtr<ArrayBuffer>&&, unsigned byteOffset, unsigned length);
     static JSGenericTypedArrayView* create(VM&, Structure*, RefPtr<typename Adaptor::ViewType>&& impl);
     static JSGenericTypedArrayView* create(Structure*, JSGlobalObject*, RefPtr<typename Adaptor::ViewType>&& impl);
 
     unsigned byteLength() const { return m_length * sizeof(typename Adaptor::Type); }
     size_t byteSize() const { return sizeOf(m_length, sizeof(typename Adaptor::Type)); }
@@ -165,31 +165,31 @@
     {
         ASSERT(!value.isObject());
         setIndexQuicklyToNativeValue(i, toNativeFromValue<Adaptor>(value));
     }
 
-    bool setIndex(ExecState* exec, unsigned i, JSValue jsValue)
+    bool setIndex(JSGlobalObject* globalObject, unsigned i, JSValue jsValue)
     {
-        VM& vm = exec->vm();
+        VM& vm = getVM(globalObject);
         auto scope = DECLARE_THROW_SCOPE(vm);
 
-        typename Adaptor::Type value = toNativeFromValue<Adaptor>(exec, jsValue);
+        typename Adaptor::Type value = toNativeFromValue<Adaptor>(globalObject, jsValue);
         RETURN_IF_EXCEPTION(scope, false);
 
         if (isNeutered()) {
-            throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);
+            throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);
             return false;
         }
 
         if (i >= m_length)
             return false;
 
         setIndexQuicklyToNativeValue(i, value);
         return true;
     }
 
-    static ElementType toAdaptorNativeFromValue(ExecState* exec, JSValue jsValue) { return toNativeFromValue<Adaptor>(exec, jsValue); }
+    static ElementType toAdaptorNativeFromValue(JSGlobalObject* globalObject, JSValue jsValue) { return toNativeFromValue<Adaptor>(globalObject, jsValue); }
 
     static Optional<ElementType> toAdaptorNativeFromValueWithoutCoercion(JSValue jsValue) { return toNativeFromValueWithoutCoercion<Adaptor>(jsValue); }
 
     void sort()
     {
@@ -217,15 +217,15 @@
             && offset + length >= offset;
     }
 
     // Like canSetQuickly, except: if it returns false, it will throw the
     // appropriate exception.
-    bool validateRange(ExecState*, unsigned offset, unsigned length);
+    bool validateRange(JSGlobalObject*, unsigned offset, unsigned length);
 
     // Returns true if successful, and false on error; if it returns false
     // then it will have thrown an exception.
-    bool set(ExecState*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);
+    bool set(JSGlobalObject*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);
 
     RefPtr<typename Adaptor::ViewType> possiblySharedTypedImpl();
     RefPtr<typename Adaptor::ViewType> unsharedTypedImpl();
 
     static Structure* createStructure(VM& vm, JSGlobalObject* globalObject, JSValue prototype)
@@ -256,11 +256,39 @@
             return getFloat32ArrayClassInfo();
         case TypeFloat64:
             return getFloat64ArrayClassInfo();
         default:
             RELEASE_ASSERT_NOT_REACHED();
-            return 0;
+            return nullptr;
+        }
+    }
+
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
+    {
+        switch (Adaptor::typeValue) {
+        case TypeInt8:
+            return vm.int8ArraySpace<mode>();
+        case TypeInt16:
+            return vm.int16ArraySpace<mode>();
+        case TypeInt32:
+            return vm.int32ArraySpace<mode>();
+        case TypeUint8:
+            return vm.uint8ArraySpace<mode>();
+        case TypeUint8Clamped:
+            return vm.uint8ClampedArraySpace<mode>();
+        case TypeUint16:
+            return vm.uint16ArraySpace<mode>();
+        case TypeUint32:
+            return vm.uint32ArraySpace<mode>();
+        case TypeFloat32:
+            return vm.float32ArraySpace<mode>();
+        case TypeFloat64:
+            return vm.float64ArraySpace<mode>();
+        default:
+            RELEASE_ASSERT_NOT_REACHED();
+            return nullptr;
         }
     }
 
     ArrayBuffer* existingBuffer();
 
@@ -270,31 +298,31 @@
     static RefPtr<typename Adaptor::ViewType> toWrapped(VM&, JSValue);
 
 protected:
     friend struct TypedArrayClassInfos;
 
-    static EncodedJSValue throwNeuteredTypedArrayTypeError(ExecState*, EncodedJSValue, PropertyName);
+    static EncodedJSValue throwNeuteredTypedArrayTypeError(JSGlobalObject*, EncodedJSValue, PropertyName);
 
-    static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&);
-    static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&);
-    static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&, bool shouldThrow);
-    static bool deleteProperty(JSCell*, ExecState*, PropertyName);
+    static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&);
+    static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&);
+    static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&, bool shouldThrow);
+    static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);
 
-    static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&);
-    static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);
-    static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);
+    static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&);
+    static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);
+    static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);
 
-    static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&, EnumerationMode);
+    static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&, EnumerationMode);
 
     static size_t estimatedSize(JSCell*, VM&);
     static void visitChildren(JSCell*, SlotVisitor&);
 
 private:
     // Returns true if successful, and false on error; it will throw on error.
     template<typename OtherAdaptor>
     bool setWithSpecificType(
-        ExecState*, unsigned offset, JSGenericTypedArrayView<OtherAdaptor>*,
+        JSGlobalObject*, unsigned offset, JSGenericTypedArrayView<OtherAdaptor>*,
         unsigned objectOffset, unsigned length, CopyType);
 
     // The ECMA 6 spec states that floating point Typed Arrays should have the following ordering:
     //
     // -Inifinity < negative finite numbers < -0.0 < 0.0 < positive finite numbers < Infinity < NaN

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FileList.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FileReader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/fileapi/FileReader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;FileReader.h&quot;
 33 

 34 #include &quot;EventNames.h&quot;
 35 #include &quot;File.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;ProgressEvent.h&quot;
 38 #include &quot;ScriptExecutionContext.h&quot;
 39 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 #include &lt;wtf/text/CString.h&gt;
 42 
 43 namespace WebCore {
 44 
 45 WTF_MAKE_ISO_ALLOCATED_IMPL(FileReader);
 46 
 47 // Fire the progress event at least every 50ms.
 48 static const auto progressNotificationInterval = 50_ms;
 49 
 50 Ref&lt;FileReader&gt; FileReader::create(ScriptExecutionContext&amp; context)
 51 {
 52     auto fileReader = adoptRef(*new FileReader(context));
 53     fileReader-&gt;suspendIfNeeded();
 54     return fileReader;
 55 }
 56 
 57 FileReader::FileReader(ScriptExecutionContext&amp; context)
 58     : ActiveDOMObject(&amp;context)
 59 {
 60 }
 61 
 62 FileReader::~FileReader()
 63 {
 64     if (m_loader)
 65         m_loader-&gt;cancel();
 66 }
 67 
<span class="line-removed"> 68 bool FileReader::canSuspendForDocumentSuspension() const</span>
<span class="line-removed"> 69 {</span>
<span class="line-removed"> 70     return !hasPendingActivity();</span>
<span class="line-removed"> 71 }</span>
<span class="line-removed"> 72 </span>
 73 const char* FileReader::activeDOMObjectName() const
 74 {
 75     return &quot;FileReader&quot;;
 76 }
 77 
 78 void FileReader::stop()
 79 {

 80     if (m_loader) {
 81         m_loader-&gt;cancel();
 82         m_loader = nullptr;
 83     }
 84     m_state = DONE;
<span class="line-modified"> 85     m_loadingActivity = nullptr;</span>




 86 }
 87 
 88 ExceptionOr&lt;void&gt; FileReader::readAsArrayBuffer(Blob* blob)
 89 {
 90     if (!blob)
 91         return { };
 92 
 93     LOG(FileAPI, &quot;FileReader: reading as array buffer: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
 94 
 95     return readInternal(*blob, FileReaderLoader::ReadAsArrayBuffer);
 96 }
 97 
 98 ExceptionOr&lt;void&gt; FileReader::readAsBinaryString(Blob* blob)
 99 {
100     if (!blob)
101         return { };
102 
103     LOG(FileAPI, &quot;FileReader: reading as binary: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
104 
105     return readInternal(*blob, FileReaderLoader::ReadAsBinaryString);
</pre>
<hr />
<pre>
115     m_encoding = encoding;
116     return readInternal(*blob, FileReaderLoader::ReadAsText);
117 }
118 
119 ExceptionOr&lt;void&gt; FileReader::readAsDataURL(Blob* blob)
120 {
121     if (!blob)
122         return { };
123 
124     LOG(FileAPI, &quot;FileReader: reading as data URL: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
125 
126     return readInternal(*blob, FileReaderLoader::ReadAsDataURL);
127 }
128 
129 ExceptionOr&lt;void&gt; FileReader::readInternal(Blob&amp; blob, FileReaderLoader::ReadType type)
130 {
131     // If multiple concurrent read methods are called on the same FileReader, InvalidStateError should be thrown when the state is LOADING.
132     if (m_state == LOADING)
133         return Exception { InvalidStateError };
134 
<span class="line-removed">135     m_loadingActivity = makePendingActivity(*this);</span>
<span class="line-removed">136 </span>
137     m_blob = &amp;blob;
138     m_readType = type;
139     m_state = LOADING;
140     m_error = nullptr;
141 
142     m_loader = makeUnique&lt;FileReaderLoader&gt;(m_readType, static_cast&lt;FileReaderLoaderClient*&gt;(this));
143     m_loader-&gt;setEncoding(m_encoding);
144     m_loader-&gt;setDataType(m_blob-&gt;type());
145     m_loader-&gt;start(scriptExecutionContext(), blob);
146 
147     return { };
148 }
149 
150 void FileReader::abort()
151 {
152     LOG(FileAPI, &quot;FileReader: aborting\n&quot;);
153 
154     if (m_aborting || m_state != LOADING)
155         return;
156     m_aborting = true;
157 
158     // Schedule to have the abort done later since abort() might be called from the event handler and we do not want the resource loading code to be in the stack.
<span class="line-modified">159     scriptExecutionContext()-&gt;postTask([this, protectedThis = makeRef(*this)] (ScriptExecutionContext&amp;) {</span>
<span class="line-modified">160         if (isContextStopped())</span>
<span class="line-removed">161             return;</span>
<span class="line-removed">162 </span>
163         ASSERT(m_state != DONE);
164 
165         stop();
166         m_aborting = false;
167 
168         m_error = FileError::create(FileError::ABORT_ERR);
169 
170         fireEvent(eventNames().errorEvent);
171         fireEvent(eventNames().abortEvent);
172         fireEvent(eventNames().loadendEvent);
173     });
174 }
175 
176 void FileReader::didStartLoading()
177 {
<span class="line-modified">178     fireEvent(eventNames().loadstartEvent);</span>


179 }
180 
181 void FileReader::didReceiveData()
182 {
<span class="line-modified">183     auto now = MonotonicTime::now();</span>
<span class="line-modified">184     if (std::isnan(m_lastProgressNotificationTime)) {</span>
<span class="line-modified">185         m_lastProgressNotificationTime = now;</span>
<span class="line-modified">186         return;</span>
<span class="line-modified">187     }</span>
<span class="line-modified">188     if (now - m_lastProgressNotificationTime &gt; progressNotificationInterval) {</span>
<span class="line-modified">189         fireEvent(eventNames().progressEvent);</span>
<span class="line-modified">190         m_lastProgressNotificationTime = now;</span>
<span class="line-modified">191     }</span>


192 }
193 
194 void FileReader::didFinishLoading()
195 {
196     if (m_aborting)
197         return;
198 
<span class="line-modified">199     ASSERT(m_state != DONE);</span>
<span class="line-modified">200     m_state = DONE;</span>
<span class="line-modified">201 </span>
<span class="line-removed">202     fireEvent(eventNames().progressEvent);</span>
<span class="line-removed">203     fireEvent(eventNames().loadEvent);</span>
<span class="line-removed">204     fireEvent(eventNames().loadendEvent);</span>
205 
<span class="line-modified">206     m_loadingActivity = nullptr;</span>



207 }
208 
209 void FileReader::didFail(int errorCode)
210 {
211     // If we&#39;re aborting, do not proceed with normal error handling since it is covered in aborting code.
212     if (m_aborting)
213         return;
214 
<span class="line-modified">215     ASSERT(m_state != DONE);</span>
<span class="line-modified">216     m_state = DONE;</span>
<span class="line-modified">217 </span>
<span class="line-removed">218     m_error = FileError::create(static_cast&lt;FileError::ErrorCode&gt;(errorCode));</span>
<span class="line-removed">219     fireEvent(eventNames().errorEvent);</span>
<span class="line-removed">220     fireEvent(eventNames().loadendEvent);</span>
221 
<span class="line-modified">222     m_loadingActivity = nullptr;</span>



223 }
224 
225 void FileReader::fireEvent(const AtomString&amp; type)
226 {

227     dispatchEvent(ProgressEvent::create(type, true, m_loader ? m_loader-&gt;bytesLoaded() : 0, m_loader ? m_loader-&gt;totalBytes() : 0));
228 }
229 
230 Optional&lt;Variant&lt;String, RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&gt; FileReader::result() const
231 {
232     if (!m_loader || m_error)
233         return WTF::nullopt;
234     if (m_readType == FileReaderLoader::ReadAsArrayBuffer) {
235         auto result = m_loader-&gt;arrayBufferResult();
236         if (!result)
237             return WTF::nullopt;
238         return { result };
239     }
240     String result = m_loader-&gt;stringResult();
241     if (result.isNull())
242         return WTF::nullopt;
243     return { WTFMove(result) };
244 }
245 
















246 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #include &quot;config.h&quot;
 32 #include &quot;FileReader.h&quot;
 33 
<span class="line-added"> 34 #include &quot;EventLoop.h&quot;</span>
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;File.h&quot;
 37 #include &quot;Logging.h&quot;
 38 #include &quot;ProgressEvent.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &lt;JavaScriptCore/ArrayBuffer.h&gt;
 41 #include &lt;wtf/IsoMallocInlines.h&gt;
 42 #include &lt;wtf/text/CString.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 WTF_MAKE_ISO_ALLOCATED_IMPL(FileReader);
 47 
 48 // Fire the progress event at least every 50ms.
 49 static const auto progressNotificationInterval = 50_ms;
 50 
 51 Ref&lt;FileReader&gt; FileReader::create(ScriptExecutionContext&amp; context)
 52 {
 53     auto fileReader = adoptRef(*new FileReader(context));
 54     fileReader-&gt;suspendIfNeeded();
 55     return fileReader;
 56 }
 57 
 58 FileReader::FileReader(ScriptExecutionContext&amp; context)
 59     : ActiveDOMObject(&amp;context)
 60 {
 61 }
 62 
 63 FileReader::~FileReader()
 64 {
 65     if (m_loader)
 66         m_loader-&gt;cancel();
 67 }
 68 





 69 const char* FileReader::activeDOMObjectName() const
 70 {
 71     return &quot;FileReader&quot;;
 72 }
 73 
 74 void FileReader::stop()
 75 {
<span class="line-added"> 76     m_pendingTasks.clear();</span>
 77     if (m_loader) {
 78         m_loader-&gt;cancel();
 79         m_loader = nullptr;
 80     }
 81     m_state = DONE;
<span class="line-modified"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 bool FileReader::hasPendingActivity() const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     return m_state == LOADING || ActiveDOMObject::hasPendingActivity();</span>
 87 }
 88 
 89 ExceptionOr&lt;void&gt; FileReader::readAsArrayBuffer(Blob* blob)
 90 {
 91     if (!blob)
 92         return { };
 93 
 94     LOG(FileAPI, &quot;FileReader: reading as array buffer: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
 95 
 96     return readInternal(*blob, FileReaderLoader::ReadAsArrayBuffer);
 97 }
 98 
 99 ExceptionOr&lt;void&gt; FileReader::readAsBinaryString(Blob* blob)
100 {
101     if (!blob)
102         return { };
103 
104     LOG(FileAPI, &quot;FileReader: reading as binary: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
105 
106     return readInternal(*blob, FileReaderLoader::ReadAsBinaryString);
</pre>
<hr />
<pre>
116     m_encoding = encoding;
117     return readInternal(*blob, FileReaderLoader::ReadAsText);
118 }
119 
120 ExceptionOr&lt;void&gt; FileReader::readAsDataURL(Blob* blob)
121 {
122     if (!blob)
123         return { };
124 
125     LOG(FileAPI, &quot;FileReader: reading as data URL: %s %s\n&quot;, blob-&gt;url().string().utf8().data(), is&lt;File&gt;(*blob) ? downcast&lt;File&gt;(*blob).path().utf8().data() : &quot;&quot;);
126 
127     return readInternal(*blob, FileReaderLoader::ReadAsDataURL);
128 }
129 
130 ExceptionOr&lt;void&gt; FileReader::readInternal(Blob&amp; blob, FileReaderLoader::ReadType type)
131 {
132     // If multiple concurrent read methods are called on the same FileReader, InvalidStateError should be thrown when the state is LOADING.
133     if (m_state == LOADING)
134         return Exception { InvalidStateError };
135 


136     m_blob = &amp;blob;
137     m_readType = type;
138     m_state = LOADING;
139     m_error = nullptr;
140 
141     m_loader = makeUnique&lt;FileReaderLoader&gt;(m_readType, static_cast&lt;FileReaderLoaderClient*&gt;(this));
142     m_loader-&gt;setEncoding(m_encoding);
143     m_loader-&gt;setDataType(m_blob-&gt;type());
144     m_loader-&gt;start(scriptExecutionContext(), blob);
145 
146     return { };
147 }
148 
149 void FileReader::abort()
150 {
151     LOG(FileAPI, &quot;FileReader: aborting\n&quot;);
152 
153     if (m_aborting || m_state != LOADING)
154         return;
155     m_aborting = true;
156 
157     // Schedule to have the abort done later since abort() might be called from the event handler and we do not want the resource loading code to be in the stack.
<span class="line-modified">158     m_pendingTasks.clear();</span>
<span class="line-modified">159     enqueueTask([this] {</span>


160         ASSERT(m_state != DONE);
161 
162         stop();
163         m_aborting = false;
164 
165         m_error = FileError::create(FileError::ABORT_ERR);
166 
167         fireEvent(eventNames().errorEvent);
168         fireEvent(eventNames().abortEvent);
169         fireEvent(eventNames().loadendEvent);
170     });
171 }
172 
173 void FileReader::didStartLoading()
174 {
<span class="line-modified">175     enqueueTask([this] {</span>
<span class="line-added">176         fireEvent(eventNames().loadstartEvent);</span>
<span class="line-added">177     });</span>
178 }
179 
180 void FileReader::didReceiveData()
181 {
<span class="line-modified">182     enqueueTask([this] {</span>
<span class="line-modified">183         auto now = MonotonicTime::now();</span>
<span class="line-modified">184         if (std::isnan(m_lastProgressNotificationTime)) {</span>
<span class="line-modified">185             m_lastProgressNotificationTime = now;</span>
<span class="line-modified">186             return;</span>
<span class="line-modified">187         }</span>
<span class="line-modified">188         if (now - m_lastProgressNotificationTime &gt; progressNotificationInterval) {</span>
<span class="line-modified">189             fireEvent(eventNames().progressEvent);</span>
<span class="line-modified">190             m_lastProgressNotificationTime = now;</span>
<span class="line-added">191         }</span>
<span class="line-added">192     });</span>
193 }
194 
195 void FileReader::didFinishLoading()
196 {
197     if (m_aborting)
198         return;
199 
<span class="line-modified">200     enqueueTask([this] {</span>
<span class="line-modified">201         ASSERT(m_state != DONE);</span>
<span class="line-modified">202         m_state = DONE;</span>



203 
<span class="line-modified">204         fireEvent(eventNames().progressEvent);</span>
<span class="line-added">205         fireEvent(eventNames().loadEvent);</span>
<span class="line-added">206         fireEvent(eventNames().loadendEvent);</span>
<span class="line-added">207     });</span>
208 }
209 
210 void FileReader::didFail(int errorCode)
211 {
212     // If we&#39;re aborting, do not proceed with normal error handling since it is covered in aborting code.
213     if (m_aborting)
214         return;
215 
<span class="line-modified">216     enqueueTask([this, errorCode] {</span>
<span class="line-modified">217         ASSERT(m_state != DONE);</span>
<span class="line-modified">218         m_state = DONE;</span>



219 
<span class="line-modified">220         m_error = FileError::create(static_cast&lt;FileError::ErrorCode&gt;(errorCode));</span>
<span class="line-added">221         fireEvent(eventNames().errorEvent);</span>
<span class="line-added">222         fireEvent(eventNames().loadendEvent);</span>
<span class="line-added">223     });</span>
224 }
225 
226 void FileReader::fireEvent(const AtomString&amp; type)
227 {
<span class="line-added">228     RELEASE_ASSERT(isAllowedToRunScript());</span>
229     dispatchEvent(ProgressEvent::create(type, true, m_loader ? m_loader-&gt;bytesLoaded() : 0, m_loader ? m_loader-&gt;totalBytes() : 0));
230 }
231 
232 Optional&lt;Variant&lt;String, RefPtr&lt;JSC::ArrayBuffer&gt;&gt;&gt; FileReader::result() const
233 {
234     if (!m_loader || m_error)
235         return WTF::nullopt;
236     if (m_readType == FileReaderLoader::ReadAsArrayBuffer) {
237         auto result = m_loader-&gt;arrayBufferResult();
238         if (!result)
239             return WTF::nullopt;
240         return { result };
241     }
242     String result = m_loader-&gt;stringResult();
243     if (result.isNull())
244         return WTF::nullopt;
245     return { WTFMove(result) };
246 }
247 
<span class="line-added">248 void FileReader::enqueueTask(Function&lt;void()&gt;&amp;&amp; task)</span>
<span class="line-added">249 {</span>
<span class="line-added">250     auto* context = scriptExecutionContext();</span>
<span class="line-added">251     if (!context)</span>
<span class="line-added">252         return;</span>
<span class="line-added">253 </span>
<span class="line-added">254     static uint64_t taskIdentifierSeed = 0;</span>
<span class="line-added">255     uint64_t taskIdentifier = ++taskIdentifierSeed;</span>
<span class="line-added">256     m_pendingTasks.add(taskIdentifier, WTFMove(task));</span>
<span class="line-added">257     context-&gt;eventLoop().queueTask(TaskSource::FileReading, [this, protectedThis = makeRef(*this), pendingActivity = makePendingActivity(*this), taskIdentifier] {</span>
<span class="line-added">258         auto task = m_pendingTasks.take(taskIdentifier);</span>
<span class="line-added">259         if (task)</span>
<span class="line-added">260             task();</span>
<span class="line-added">261     });</span>
<span class="line-added">262 }</span>
<span class="line-added">263 </span>
264 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="FileList.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FileReader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
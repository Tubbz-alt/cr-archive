<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSAPIWrapperObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/API/JSBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,14 ***</span>
<span class="line-new-header">--- 31,16 ---</span>
  #include &quot;APICast.h&quot;
  #include &quot;CallFrame.h&quot;
  #include &quot;Completion.h&quot;
  #include &quot;Exception.h&quot;
  #include &quot;GCActivityCallback.h&quot;
<span class="line-added">+ #include &quot;Identifier.h&quot;</span>
  #include &quot;InitializeThreading.h&quot;
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSLock.h&quot;
  #include &quot;JSObject.h&quot;
<span class="line-added">+ #include &quot;ObjectConstructor.h&quot;</span>
  #include &quot;OpaqueJSString.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;SourceCode.h&quot;
  #include &lt;wtf/text/StringHash.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,85 ***</span>
  #include &quot;JSGlobalObjectInspectorController.h&quot;
  #endif
  
  using namespace JSC;
  
<span class="line-modified">! JSValueRef JSEvaluateScriptInternal(const JSLockHolder&amp;, ExecState* exec, JSContextRef ctx, JSObjectRef thisObject, const SourceCode&amp; source, JSValueRef* exception)</span>
  {
<span class="line-removed">-     UNUSED_PARAM(ctx);</span>
<span class="line-removed">- </span>
      JSObject* jsThisObject = toJS(thisObject);
  
      // evaluate sets &quot;this&quot; to the global object if it is NULL
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">-     JSGlobalObject* globalObject = vm.vmEntryGlobalObject(exec);</span>
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue returnValue = profiledEvaluate(globalObject-&gt;globalExec(), ProfilingReason::API, source, jsThisObject, evaluationException);</span>
  
      if (evaluationException) {
          if (exception)
<span class="line-modified">!             *exception = toRef(exec, evaluationException-&gt;value());</span>
  #if ENABLE(REMOTE_INSPECTOR)
          // FIXME: If we have a debugger attached we could learn about ParseError exceptions through
          // ScriptDebugServer::sourceParsed and this path could produce a duplicate warning. The
          // Debugger path is currently ignored by inspector.
          // NOTE: If we don&#39;t have a debugger, this SourceCode will be forever lost to the inspector.
          // We could stash it in the inspector in case an inspector is ever opened.
<span class="line-modified">!         globalObject-&gt;inspectorController().reportAPIException(exec, evaluationException);</span>
  #endif
          return nullptr;
      }
  
      if (returnValue)
<span class="line-modified">!         return toRef(exec, returnValue);</span>
  
      // happens, for example, when the only statement is an empty (&#39;;&#39;) statement
<span class="line-modified">!     return toRef(exec, jsUndefined());</span>
  }
  
  JSValueRef JSEvaluateScript(JSContextRef ctx, JSStringRef script, JSObjectRef thisObject, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
      SourceCode source = makeSource(script-&gt;string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
  
<span class="line-modified">!     return JSEvaluateScriptInternal(locker, exec, ctx, thisObject, source, exception);</span>
  }
  
  bool JSCheckScriptSyntax(JSContextRef ctx, JSStringRef script, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
      SourceCode source = makeSource(script-&gt;string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
  
      JSValue syntaxException;
<span class="line-modified">!     bool isValidSyntax = checkSyntax(vm.vmEntryGlobalObject(exec)-&gt;globalExec(), source, &amp;syntaxException);</span>
  
      if (!isValidSyntax) {
          if (exception)
<span class="line-modified">!             *exception = toRef(exec, syntaxException);</span>
  #if ENABLE(REMOTE_INSPECTOR)
          Exception* exception = Exception::create(vm, syntaxException);
<span class="line-modified">!         vm.vmEntryGlobalObject(exec)-&gt;inspectorController().reportAPIException(exec, exception);</span>
  #endif
          return false;
      }
  
      return true;
<span class="line-new-header">--- 48,82 ---</span>
  #include &quot;JSGlobalObjectInspectorController.h&quot;
  #endif
  
  using namespace JSC;
  
<span class="line-modified">! JSValueRef JSEvaluateScriptInternal(const JSLockHolder&amp;, JSContextRef ctx, JSObjectRef thisObject, const SourceCode&amp; source, JSValueRef* exception)</span>
  {
      JSObject* jsThisObject = toJS(thisObject);
  
      // evaluate sets &quot;this&quot; to the global object if it is NULL
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
      NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">!     JSValue returnValue = profiledEvaluate(globalObject, ProfilingReason::API, source, jsThisObject, evaluationException);</span>
  
      if (evaluationException) {
          if (exception)
<span class="line-modified">!             *exception = toRef(globalObject, evaluationException-&gt;value());</span>
  #if ENABLE(REMOTE_INSPECTOR)
          // FIXME: If we have a debugger attached we could learn about ParseError exceptions through
          // ScriptDebugServer::sourceParsed and this path could produce a duplicate warning. The
          // Debugger path is currently ignored by inspector.
          // NOTE: If we don&#39;t have a debugger, this SourceCode will be forever lost to the inspector.
          // We could stash it in the inspector in case an inspector is ever opened.
<span class="line-modified">!         globalObject-&gt;inspectorController().reportAPIException(globalObject, evaluationException);</span>
  #endif
          return nullptr;
      }
  
      if (returnValue)
<span class="line-modified">!         return toRef(globalObject, returnValue);</span>
  
      // happens, for example, when the only statement is an empty (&#39;;&#39;) statement
<span class="line-modified">!     return toRef(globalObject, jsUndefined());</span>
  }
  
  JSValueRef JSEvaluateScript(JSContextRef ctx, JSStringRef script, JSObjectRef thisObject, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
      SourceCode source = makeSource(script-&gt;string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
  
<span class="line-modified">!     return JSEvaluateScriptInternal(locker, ctx, thisObject, source, exception);</span>
  }
  
  bool JSCheckScriptSyntax(JSContextRef ctx, JSStringRef script, JSStringRef sourceURL, int startingLineNumber, JSValueRef* exception)
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return false;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      startingLineNumber = std::max(1, startingLineNumber);
  
      auto sourceURLString = sourceURL ? sourceURL-&gt;string() : String();
      SourceCode source = makeSource(script-&gt;string(), SourceOrigin { sourceURLString }, URL({ }, sourceURLString), TextPosition(OrdinalNumber::fromOneBasedInt(startingLineNumber), OrdinalNumber()));
  
      JSValue syntaxException;
<span class="line-modified">!     bool isValidSyntax = checkSyntax(globalObject, source, &amp;syntaxException);</span>
  
      if (!isValidSyntax) {
          if (exception)
<span class="line-modified">!             *exception = toRef(globalObject, syntaxException);</span>
  #if ENABLE(REMOTE_INSPECTOR)
          Exception* exception = Exception::create(vm, syntaxException);
<span class="line-modified">!         globalObject-&gt;inspectorController().reportAPIException(globalObject, exception);</span>
  #endif
          return false;
      }
  
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,12 ***</span>
      // Because the function argument was originally ignored, some clients may pass their released context here,
      // in which case there is a risk of crashing if another thread performs GC on the same heap in between.
      if (!ctx)
          return;
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      vm.heap.reportAbandonedObjectGraph();
  }
  
<span class="line-new-header">--- 137,12 ---</span>
      // Because the function argument was originally ignored, some clients may pass their released context here,
      // in which case there is a risk of crashing if another thread performs GC on the same heap in between.
      if (!ctx)
          return;
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      vm.heap.reportAbandonedObjectGraph();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,12 ***</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      vm.heap.deprecatedReportExtraMemory(size);
  }
  
<span class="line-new-header">--- 150,12 ---</span>
  {
      if (!ctx) {
          ASSERT_NOT_REACHED();
          return;
      }
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
  
      vm.heap.deprecatedReportExtraMemory(size);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 166,32 ***</span>
  void JSSynchronousGarbageCollectForDebugging(JSContextRef ctx)
  {
      if (!ctx)
          return;
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
  }
  
  void JSSynchronousEdenCollectForDebugging(JSContextRef ctx)
  {
      if (!ctx)
          return;
  
<span class="line-modified">!     ExecState* exec = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder locker(vm);
      vm.heap.collectSync(CollectionScope::Eden);
  }
  
  void JSDisableGCTimer(void)
  {
      GCActivityCallback::s_shouldCreateGCTimer = false;
  }
  
  #if PLATFORM(IOS_FAMILY) &amp;&amp; TARGET_OS_IOS
  // FIXME: Expose symbols to tell dyld where to find JavaScriptCore on older versions of
  // iOS (&lt; 7.0). We should remove these symbols once we no longer need to support such
  // versions of iOS. See &lt;rdar://problem/13696872&gt; for more details.
  JS_EXPORT extern const char iosInstallName43 __asm(&quot;$ld$install_name$os4.3$/System/Library/PrivateFrameworks/JavaScriptCore.framework/JavaScriptCore&quot;);
<span class="line-new-header">--- 165,55 ---</span>
  void JSSynchronousGarbageCollectForDebugging(JSContextRef ctx)
  {
      if (!ctx)
          return;
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      vm.heap.collectNow(Sync, CollectionScope::Full);
  }
  
  void JSSynchronousEdenCollectForDebugging(JSContextRef ctx)
  {
      if (!ctx)
          return;
  
<span class="line-modified">!     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder locker(vm);
      vm.heap.collectSync(CollectionScope::Eden);
  }
  
  void JSDisableGCTimer(void)
  {
      GCActivityCallback::s_shouldCreateGCTimer = false;
  }
  
<span class="line-added">+ JSObjectRef JSGetMemoryUsageStatistics(JSContextRef ctx)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!ctx) {</span>
<span class="line-added">+         ASSERT_NOT_REACHED();</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSGlobalObject* globalObject = toJS(ctx);</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     JSLockHolder locker(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* object = constructEmptyObject(globalObject);</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;heapSize&quot;), jsNumber(vm.heap.size()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;heapCapacity&quot;), jsNumber(vm.heap.capacity()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;extraMemorySize&quot;), jsNumber(vm.heap.extraMemorySize()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;objectCount&quot;), jsNumber(vm.heap.objectCount()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;protectedObjectCount&quot;), jsNumber(vm.heap.protectedObjectCount()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;globalObjectCount&quot;), jsNumber(vm.heap.globalObjectCount()));</span>
<span class="line-added">+     object-&gt;putDirect(vm, Identifier::fromString(vm, &quot;protectedGlobalObjectCount&quot;), jsNumber(vm.heap.protectedGlobalObjectCount()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     return toRef(object);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #if PLATFORM(IOS_FAMILY) &amp;&amp; TARGET_OS_IOS
  // FIXME: Expose symbols to tell dyld where to find JavaScriptCore on older versions of
  // iOS (&lt; 7.0). We should remove these symbols once we no longer need to support such
  // versions of iOS. See &lt;rdar://problem/13696872&gt; for more details.
  JS_EXPORT extern const char iosInstallName43 __asm(&quot;$ld$install_name$os4.3$/System/Library/PrivateFrameworks/JavaScriptCore.framework/JavaScriptCore&quot;);
</pre>
<center><a href="JSAPIWrapperObject.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
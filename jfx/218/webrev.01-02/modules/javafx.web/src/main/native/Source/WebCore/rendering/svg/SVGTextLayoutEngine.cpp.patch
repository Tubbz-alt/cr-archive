diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGTextLayoutEngine.cpp
@@ -21,10 +21,11 @@
 #include "SVGTextLayoutEngine.h"
 
 #include "PathTraversalState.h"
 #include "RenderSVGTextPath.h"
 #include "SVGElement.h"
+#include "SVGGeometryElement.h"
 #include "SVGInlineTextBox.h"
 #include "SVGLengthContext.h"
 #include "SVGTextContentElement.h"
 #include "SVGTextLayoutEngineBaseline.h"
 #include "SVGTextLayoutEngineSpacing.h"
@@ -168,14 +169,23 @@
 
     m_textPath = textPath.layoutPath();
     if (m_textPath.isEmpty())
         return;
 
-    m_textPathStartOffset = textPath.startOffset();
+    const auto& startOffset = textPath.startOffset();
     m_textPathLength = m_textPath.length();
-    if (m_textPathStartOffset > 0 && m_textPathStartOffset <= 1)
-        m_textPathStartOffset *= m_textPathLength;
+
+    if (textPath.startOffset().lengthType() == SVGLengthType::Percentage)
+        m_textPathStartOffset = startOffset.valueAsPercentage() * m_textPathLength;
+    else {
+        m_textPathStartOffset = startOffset.valueInSpecifiedUnits();
+        if (auto* tragetElement = textPath.targetElement()) {
+            // FIXME: A value of zero is valid. Need to differentiate this case from being unspecified.
+            if (float pathLength = tragetElement->pathLength())
+                m_textPathStartOffset *= m_textPathLength / pathLength;
+        }
+    }
 
     lineLayout.m_chunkLayoutBuilder.buildTextChunks(lineLayout.m_lineLayoutBoxes);
 
     // Handle text-anchor as additional start offset for text paths.
     m_textPathStartOffset += lineLayout.m_chunkLayoutBuilder.totalAnchorShift();
@@ -529,13 +539,12 @@
 
             // Stop processing, if the next character lies behind the path.
             if (textPathOffset > m_textPathLength)
                 break;
 
-            bool success = false;
-            auto traversalState(m_textPath.traversalStateAtLength(textPathOffset, success));
-            ASSERT(success);
+            auto traversalState(m_textPath.traversalStateAtLength(textPathOffset));
+            ASSERT(traversalState.success());
 
             FloatPoint point = traversalState.current();
             x = point.x();
             y = point.y();
 

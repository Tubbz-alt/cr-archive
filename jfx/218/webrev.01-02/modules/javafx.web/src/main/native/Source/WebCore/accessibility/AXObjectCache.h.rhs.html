<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/AXObjectCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2003, 2006, 2007, 2008, 2009, 2010, 2011, 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
<a name="1" id="anc1"></a>


 28 #include &quot;AXTextStateChangeIntent.h&quot;
 29 #include &quot;AccessibilityObject.h&quot;
 30 #include &quot;Range.h&quot;
 31 #include &quot;Timer.h&quot;
 32 #include &quot;VisibleUnits.h&quot;
 33 #include &lt;limits.h&gt;
 34 #include &lt;wtf/Forward.h&gt;
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/HashSet.h&gt;
 37 #include &lt;wtf/ListHashSet.h&gt;
 38 #include &lt;wtf/RefPtr.h&gt;
 39 
 40 #if USE(ATK)
 41 #include &lt;wtf/glib/GRefPtr.h&gt;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<a name="2" id="anc2"></a><span class="line-modified"> 47 class AXIsolatedObject;</span>
<span class="line-added"> 48 class AXIsolatedTree;</span>
 49 #endif
 50 class Document;
 51 class HTMLAreaElement;
 52 class HTMLTextFormControlElement;
 53 class Node;
 54 class Page;
 55 class RenderBlock;
 56 class RenderObject;
 57 class RenderText;
 58 class ScrollView;
 59 class VisiblePosition;
 60 class Widget;
 61 
 62 struct TextMarkerData {
 63     AXID axID { 0 };
 64     Node* node { nullptr };
 65     int offset { 0 };
 66     int characterStartIndex { 0 };
 67     int characterOffset { 0 };
 68     bool ignored { false };
 69     EAffinity affinity { DOWNSTREAM };
 70 };
 71 
 72 struct CharacterOffset {
 73     Node* node;
 74     int startIndex;
 75     int offset;
 76     int remainingOffset;
 77 
 78     CharacterOffset(Node* n = nullptr, int startIndex = 0, int offset = 0, int remaining = 0)
 79         : node(n)
 80         , startIndex(startIndex)
 81         , offset(offset)
 82         , remainingOffset(remaining)
 83     { }
 84 
 85     int remaining() const { return remainingOffset; }
 86     bool isNull() const { return !node; }
 87     bool isEqual(const CharacterOffset&amp; other) const
 88     {
 89         if (isNull() || other.isNull())
 90             return false;
 91         return node == other.node &amp;&amp; startIndex == other.startIndex &amp;&amp; offset == other.offset;
 92     }
 93 };
 94 
 95 class AXComputedObjectAttributeCache {
 96     WTF_MAKE_FAST_ALLOCATED;
 97 public:
 98     AccessibilityObjectInclusion getIgnored(AXID) const;
 99     void setIgnored(AXID, AccessibilityObjectInclusion);
100 
101 private:
102     struct CachedAXObjectAttributes {
103         CachedAXObjectAttributes()
104             : ignored(AccessibilityObjectInclusion::DefaultBehavior)
105         { }
106 
107         AccessibilityObjectInclusion ignored;
108     };
109 
110     HashMap&lt;AXID, CachedAXObjectAttributes&gt; m_idMapping;
111 };
112 
113 struct VisiblePositionIndex {
114     int value = -1;
115     RefPtr&lt;ContainerNode&gt; scope;
116 };
117 
118 struct VisiblePositionIndexRange {
119     VisiblePositionIndex startIndex;
120     VisiblePositionIndex endIndex;
121     bool isNull() const { return startIndex.value == -1 || endIndex.value == -1; }
122 };
123 
124 class AccessibilityReplacedText {
125 public:
126     AccessibilityReplacedText() = default;
127     AccessibilityReplacedText(const VisibleSelection&amp;);
128     void postTextStateChangeNotification(AXObjectCache*, AXTextEditType, const String&amp;, const VisibleSelection&amp;);
129     const VisiblePositionIndexRange&amp; replacedRange() { return m_replacedRange; }
130 protected:
131     String m_replacedText;
132     VisiblePositionIndexRange m_replacedRange;
133 };
134 
135 #if !PLATFORM(COCOA)
136 enum AXTextChange { AXTextInserted, AXTextDeleted, AXTextAttributesChanged };
137 #endif
138 
139 enum PostTarget { TargetElement, TargetObservableParent };
140 
141 enum PostType { PostSynchronously, PostAsynchronously };
142 
143 class AXObjectCache {
144     WTF_MAKE_NONCOPYABLE(AXObjectCache); WTF_MAKE_FAST_ALLOCATED;
145 public:
146     explicit AXObjectCache(Document&amp;);
147     ~AXObjectCache();
148 
<a name="3" id="anc3"></a><span class="line-modified">149     WEBCORE_EXPORT static AXCoreObject* focusedUIElementForPage(const Page*);</span>
150 
151     // Returns the root object for the entire document.
<a name="4" id="anc4"></a><span class="line-modified">152     WEBCORE_EXPORT AXCoreObject* rootObject();</span>
153     // Returns the root object for a specific frame.
154     WEBCORE_EXPORT AccessibilityObject* rootObjectForFrame(Frame*);
155 
156     // For AX objects with elements that back them.
157     AccessibilityObject* getOrCreate(RenderObject*);
158     AccessibilityObject* getOrCreate(Widget*);
159     WEBCORE_EXPORT AccessibilityObject* getOrCreate(Node*);
160 
161     // used for objects without backing elements
162     AccessibilityObject* getOrCreate(AccessibilityRole);
163 
164     // will only return the AccessibilityObject if it already exists
165     AccessibilityObject* get(RenderObject*);
166     AccessibilityObject* get(Widget*);
167     AccessibilityObject* get(Node*);
168 
169     void remove(RenderObject*);
170     void remove(Node&amp;);
171     void remove(Widget*);
172     void remove(AXID);
173 
<a name="5" id="anc5"></a><span class="line-modified">174 #if !PLATFORM(COCOA)</span>
<span class="line-modified">175     void detachWrapper(AXCoreObject*, AccessibilityDetachmentType);</span>
<span class="line-added">176 #endif</span>
<span class="line-added">177 private:</span>
<span class="line-added">178     using DOMObjectVariant = Variant&lt;std::nullptr_t, RenderObject*, Node*, Widget*&gt;;</span>
<span class="line-added">179     void cacheAndInitializeWrapper(AccessibilityObject*, DOMObjectVariant = nullptr);</span>
<span class="line-added">180     void attachWrapper(AXCoreObject*);</span>
<span class="line-added">181 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)</span>
<span class="line-added">182     void attachWrapper(AXIsolatedObject*, WebAccessibilityObjectWrapper*);</span>
<span class="line-added">183 #endif</span>
<span class="line-added">184 </span>
<span class="line-added">185 public:</span>
186     void childrenChanged(Node*, Node* newChild = nullptr);
187     void childrenChanged(RenderObject*, RenderObject* newChild = nullptr);
<a name="6" id="anc6"></a><span class="line-modified">188     void childrenChanged(AXCoreObject*);</span>
189     void checkedStateChanged(Node*);
190     // Called when a node has just been attached, so we can make sure we have the right subclass of AccessibilityObject.
191     void updateCacheAfterNodeIsAttached(Node*);
192 
193     void deferFocusedUIElementChangeIfNeeded(Node* oldFocusedNode, Node* newFocusedNode);
194     void handleScrolledToAnchor(const Node* anchorNode);
195     void handleScrollbarUpdate(ScrollView*);
196 
197     Node* modalNode();
198 
199     void deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*);
200     void recomputeIsIgnored(RenderObject* renderer);
201 
202 #if ENABLE(ACCESSIBILITY_ISOLATED_TREE)
<a name="7" id="anc7"></a><span class="line-modified">203     WEBCORE_EXPORT static bool clientSupportsIsolatedTree();</span>
<span class="line-modified">204 private:</span>
<span class="line-modified">205     AXCoreObject* isolatedTreeRootObject();</span>
<span class="line-modified">206     static AXCoreObject* isolatedTreeFocusedObject(Document&amp;);</span>
<span class="line-added">207     void setIsolatedTreeFocusedObject(Node*);</span>
<span class="line-added">208     static Ref&lt;AXIsolatedTree&gt; generateIsolatedTree(PageIdentifier, Document&amp;);</span>
<span class="line-added">209     static Ref&lt;AXIsolatedObject&gt; createIsolatedTreeHierarchy(AXCoreObject&amp;, AXID, AXObjectCache*, AXIsolatedTree&amp;, Vector&lt;Ref&lt;AXIsolatedObject&gt;&gt;&amp;, bool isRoot);</span>
210 #endif
211 
<a name="8" id="anc8"></a><span class="line-added">212 public:</span>
<span class="line-added">213     WEBCORE_EXPORT bool canUseSecondaryAXThread();</span>
<span class="line-added">214 </span>
215 #if ENABLE(ACCESSIBILITY)
216     WEBCORE_EXPORT static void enableAccessibility();
217     WEBCORE_EXPORT static void disableAccessibility();
218 
219     // Enhanced user interface accessibility can be toggled by the assistive technology.
220     WEBCORE_EXPORT static void setEnhancedUserInterfaceAccessibility(bool flag);
221 
222     // Note: these may be called from a non-main thread concurrently as other readers.
223     static bool accessibilityEnabled() { return gAccessibilityEnabled; }
224     static bool accessibilityEnhancedUserInterfaceEnabled() { return gAccessibilityEnhancedUserInterfaceEnabled; }
225 #else
226     static void enableAccessibility() { }
227     static void disableAccessibility() { }
228     static void setEnhancedUserInterfaceAccessibility(bool) { }
229     static bool accessibilityEnabled() { return false; }
230     static bool accessibilityEnhancedUserInterfaceEnabled() { return false; }
231 #endif
232 
233     const Element* rootAXEditableElement(const Node*);
234     bool nodeIsTextControl(const Node*);
235 
236     AXID platformGenerateAXID() const;
237     AccessibilityObject* objectFromAXID(AXID id) const { return m_objects.get(id); }
238 
239     // Text marker utilities.
240     Optional&lt;TextMarkerData&gt; textMarkerDataForVisiblePosition(const VisiblePosition&amp;);
241     Optional&lt;TextMarkerData&gt; textMarkerDataForFirstPositionInTextControl(HTMLTextFormControlElement&amp;);
242     void textMarkerDataForCharacterOffset(TextMarkerData&amp;, const CharacterOffset&amp;);
243     void textMarkerDataForNextCharacterOffset(TextMarkerData&amp;, const CharacterOffset&amp;);
244     void textMarkerDataForPreviousCharacterOffset(TextMarkerData&amp;, const CharacterOffset&amp;);
245     VisiblePosition visiblePositionForTextMarkerData(TextMarkerData&amp;);
246     CharacterOffset characterOffsetForTextMarkerData(TextMarkerData&amp;);
247     // Use ignoreNextNodeStart/ignorePreviousNodeEnd to determine the behavior when we are at node boundary.
248     CharacterOffset nextCharacterOffset(const CharacterOffset&amp;, bool ignoreNextNodeStart = true);
249     CharacterOffset previousCharacterOffset(const CharacterOffset&amp;, bool ignorePreviousNodeEnd = true);
250     void startOrEndTextMarkerDataForRange(TextMarkerData&amp;, RefPtr&lt;Range&gt;, bool);
251     CharacterOffset startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt;, bool, bool enterTextControls = false);
252     AccessibilityObject* accessibilityObjectForTextMarkerData(TextMarkerData&amp;);
253     RefPtr&lt;Range&gt; rangeForUnorderedCharacterOffsets(const CharacterOffset&amp;, const CharacterOffset&amp;);
254     static RefPtr&lt;Range&gt; rangeForNodeContents(Node*);
255     static int lengthForRange(Range*);
256 
257     // Word boundary
258     CharacterOffset nextWordEndCharacterOffset(const CharacterOffset&amp;);
259     CharacterOffset previousWordStartCharacterOffset(const CharacterOffset&amp;);
260     RefPtr&lt;Range&gt; leftWordRange(const CharacterOffset&amp;);
261     RefPtr&lt;Range&gt; rightWordRange(const CharacterOffset&amp;);
262 
263     // Paragraph
264     RefPtr&lt;Range&gt; paragraphForCharacterOffset(const CharacterOffset&amp;);
265     CharacterOffset nextParagraphEndCharacterOffset(const CharacterOffset&amp;);
266     CharacterOffset previousParagraphStartCharacterOffset(const CharacterOffset&amp;);
267 
268     // Sentence
269     RefPtr&lt;Range&gt; sentenceForCharacterOffset(const CharacterOffset&amp;);
270     CharacterOffset nextSentenceEndCharacterOffset(const CharacterOffset&amp;);
271     CharacterOffset previousSentenceStartCharacterOffset(const CharacterOffset&amp;);
272 
273     // Bounds
<a name="9" id="anc9"></a><span class="line-modified">274     CharacterOffset characterOffsetForPoint(const IntPoint&amp;, AXCoreObject*);</span>
275     IntRect absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;);
276     CharacterOffset characterOffsetForBounds(const IntRect&amp;, bool);
277 
278     // Lines
279     CharacterOffset endCharacterOffsetOfLine(const CharacterOffset&amp;);
280     CharacterOffset startCharacterOffsetOfLine(const CharacterOffset&amp;);
281 
282     // Index
<a name="10" id="anc10"></a><span class="line-modified">283     CharacterOffset characterOffsetForIndex(int, const AXCoreObject*);</span>
284     int indexForCharacterOffset(const CharacterOffset&amp;, AccessibilityObject*);
285 
286     enum AXNotification {
287         AXActiveDescendantChanged,
288         AXAutocorrectionOccured,
289         AXCheckedStateChanged,
290         AXChildrenChanged,
291         AXCurrentChanged,
292         AXDisabledStateChanged,
293         AXFocusedUIElementChanged,
294         AXLayoutComplete,
295         AXLoadComplete,
296         AXNewDocumentLoadComplete,
297         AXSelectedChildrenChanged,
298         AXSelectedTextChanged,
299         AXValueChanged,
300         AXScrolledToAnchor,
301         AXLiveRegionCreated,
302         AXLiveRegionChanged,
303         AXMenuListItemSelected,
304         AXMenuListValueChanged,
305         AXMenuClosed,
306         AXMenuOpened,
307         AXRowCountChanged,
308         AXRowCollapsed,
309         AXRowExpanded,
310         AXExpandedChanged,
311         AXInvalidStatusChanged,
312         AXPressDidSucceed,
313         AXPressDidFail,
314         AXPressedStateChanged,
315         AXReadOnlyStatusChanged,
316         AXRequiredStatusChanged,
317         AXTextChanged,
318         AXAriaAttributeChanged,
319         AXElementBusyChanged
320     };
321 
322     void postNotification(RenderObject*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
323     void postNotification(Node*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);
<a name="11" id="anc11"></a><span class="line-modified">324     void postNotification(AXCoreObject*, Document*, AXNotification, PostTarget = TargetElement, PostType = PostAsynchronously);</span>
325 
326 #ifndef NDEBUG
327     void showIntent(const AXTextStateChangeIntent&amp;);
328 #endif
329 
330     void setTextSelectionIntent(const AXTextStateChangeIntent&amp;);
331     void setIsSynchronizingSelection(bool);
332 
333     void postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
334     void postTextReplacementNotification(Node*, AXTextEditType deletionType, const String&amp; deletedText, AXTextEditType insertionType, const String&amp; insertedText, const VisiblePosition&amp;);
335     void postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; deletedText, const String&amp; insertedText);
336     void postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
337     void postTextStateChangeNotification(const Position&amp;, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
338     void postLiveRegionChangeNotification(AccessibilityObject*);
339     void focusModalNode();
340 
341     enum AXLoadingEvent {
342         AXLoadingStarted,
343         AXLoadingReloaded,
344         AXLoadingFailed,
345         AXLoadingFinished
346     };
347 
348     void frameLoadingEventNotification(Frame*, AXLoadingEvent);
349 
350     void prepareForDocumentDestruction(const Document&amp;);
351 
352     void startCachingComputedObjectAttributesUntilTreeMutates();
353     void stopCachingComputedObjectAttributes();
354 
355     AXComputedObjectAttributeCache* computedObjectAttributeCache() { return m_computedObjectAttributeCache.get(); }
356 
357     Document&amp; document() const { return m_document; }
358 
359 #if PLATFORM(MAC)
360     static void setShouldRepostNotificationsForTests(bool value);
361 #endif
362     void deferRecomputeIsIgnoredIfNeeded(Element*);
363     void deferRecomputeIsIgnored(Element*);
364     void deferTextChangedIfNeeded(Node*);
365     void deferSelectedChildrenChangedIfNeeded(Element&amp;);
366     void performDeferredCacheUpdate();
367     void deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp; previousValue);
368 
369     RefPtr&lt;Range&gt; rangeMatchesTextNearRange(RefPtr&lt;Range&gt;, const String&amp;);
370 
371 
372 protected:
<a name="12" id="anc12"></a><span class="line-modified">373     void postPlatformNotification(AXCoreObject*, AXNotification);</span>
374     void platformHandleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
375 
376     void platformPerformDeferredCacheUpdate();
377 
378 #if PLATFORM(COCOA)
379     void postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
380     void postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
381     void postTextReplacementPlatformNotificationForTextControl(AccessibilityObject*, const String&amp; deletedText, const String&amp; insertedText, HTMLTextFormControlElement&amp;);
382     void postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;);
383 #else
384     static AXTextChange textChangeForEditType(AXTextEditType);
385     void nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;);
386 #endif
387 
388     void frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent);
389     void textChanged(AccessibilityObject*);
390     void labelChanged(Element*);
391 
392     // This is a weak reference cache for knowing if Nodes used by TextMarkers are valid.
393     void setNodeInUse(Node* n) { m_textMarkerNodes.add(n); }
394     void removeNodeForUse(Node&amp; n) { m_textMarkerNodes.remove(&amp;n); }
395     bool isNodeInUse(Node* n) { return m_textMarkerNodes.contains(n); }
396 
397     // CharacterOffset functions.
398     enum TraverseOption { TraverseOptionDefault = 1 &lt;&lt; 0, TraverseOptionToNodeEnd = 1 &lt;&lt; 1, TraverseOptionIncludeStart = 1 &lt;&lt; 2, TraverseOptionValidateOffset = 1 &lt;&lt; 3, TraverseOptionDoNotEnterTextControls = 1 &lt;&lt; 4 };
399     Node* nextNode(Node*) const;
400     Node* previousNode(Node*) const;
401     CharacterOffset traverseToOffsetInRange(RefPtr&lt;Range&gt;, int, TraverseOption = TraverseOptionDefault, bool stayWithinRange = false);
402     VisiblePosition visiblePositionFromCharacterOffset(const CharacterOffset&amp;);
403     CharacterOffset characterOffsetFromVisiblePosition(const VisiblePosition&amp;);
404     void setTextMarkerDataWithCharacterOffset(TextMarkerData&amp;, const CharacterOffset&amp;);
405     UChar32 characterAfter(const CharacterOffset&amp;);
406     UChar32 characterBefore(const CharacterOffset&amp;);
407     CharacterOffset characterOffsetForNodeAndOffset(Node&amp;, int, TraverseOption = TraverseOptionDefault);
408 
409     enum class NeedsContextAtParagraphStart { Yes, No };
410     CharacterOffset previousBoundary(const CharacterOffset&amp;, BoundarySearchFunction, NeedsContextAtParagraphStart = NeedsContextAtParagraphStart::No);
411     CharacterOffset nextBoundary(const CharacterOffset&amp;, BoundarySearchFunction);
412     CharacterOffset startCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
413     CharacterOffset endCharacterOffsetOfWord(const CharacterOffset&amp;, EWordSide = RightWordIfOnBoundary);
414     CharacterOffset startCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
415     CharacterOffset endCharacterOffsetOfParagraph(const CharacterOffset&amp;, EditingBoundaryCrossingRule = CannotCrossEditingBoundary);
416     CharacterOffset startCharacterOffsetOfSentence(const CharacterOffset&amp;);
417     CharacterOffset endCharacterOffsetOfSentence(const CharacterOffset&amp;);
418     CharacterOffset characterOffsetForPoint(const IntPoint&amp;);
419     LayoutRect localCaretRectForCharacterOffset(RenderObject*&amp;, const CharacterOffset&amp;);
420     bool shouldSkipBoundary(const CharacterOffset&amp;, const CharacterOffset&amp;);
421 
422 private:
423     AccessibilityObject* rootWebArea();
424 
425     static AccessibilityObject* focusedImageMapUIElement(HTMLAreaElement*);
<a name="13" id="anc13"></a><span class="line-added">426     static AXCoreObject* focusedObject(Document&amp;);</span>
427 
428     AXID getAXID(AccessibilityObject*);
429 
430     void notificationPostTimerFired();
431 
432     void liveRegionChangedNotificationPostTimerFired();
433 
434     void focusModalNodeTimerFired();
435 
436     void performCacheUpdateTimerFired();
437 
438     void postTextStateChangeNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;);
439 
440     bool enqueuePasswordValueChangeNotification(AccessibilityObject*);
441     void passwordNotificationPostTimerFired();
442 
443     void handleMenuOpened(Node*);
444     void handleLiveRegionCreated(Node*);
445     void handleMenuItemSelected(Node*);
446     void handleAttributeChange(const QualifiedName&amp;, Element*);
447     bool shouldProcessAttributeChange(const QualifiedName&amp;, Element*);
448     void selectedChildrenChanged(Node*);
449     void selectedChildrenChanged(RenderObject*);
450     // Called by a node when text or a text equivalent (e.g. alt) attribute is changed.
451     void textChanged(Node*);
452     void handleActiveDescendantChanged(Node*);
453     void handleAriaRoleChanged(Node*);
454     void handleAriaExpandedChange(Node*);
455     void handleFocusedUIElementChanged(Node* oldFocusedNode, Node* newFocusedNode);
456 
457     // aria-modal related
458     void findModalNodes();
459     void updateCurrentModalNode();
460     bool isNodeVisible(Node*) const;
461     void handleModalChange(Node*);
462 
463     Document&amp; m_document;
<a name="14" id="anc14"></a><span class="line-added">464     const Optional&lt;PageIdentifier&gt; m_pageID; // constant for object&#39;s lifetime.</span>
465     HashMap&lt;AXID, RefPtr&lt;AccessibilityObject&gt;&gt; m_objects;
466     HashMap&lt;RenderObject*, AXID&gt; m_renderObjectMapping;
467     HashMap&lt;Widget*, AXID&gt; m_widgetObjectMapping;
468     HashMap&lt;Node*, AXID&gt; m_nodeObjectMapping;
469     ListHashSet&lt;Node*&gt; m_textMarkerNodes;
470     std::unique_ptr&lt;AXComputedObjectAttributeCache&gt; m_computedObjectAttributeCache;
471     WEBCORE_EXPORT static bool gAccessibilityEnabled;
472     WEBCORE_EXPORT static bool gAccessibilityEnhancedUserInterfaceEnabled;
473 
474     HashSet&lt;AXID&gt; m_idsInUse;
475 
476     Timer m_notificationPostTimer;
<a name="15" id="anc15"></a><span class="line-modified">477     Vector&lt;std::pair&lt;RefPtr&lt;AXCoreObject&gt;, AXNotification&gt;&gt; m_notificationsToPost;</span>
478 
479     Timer m_passwordNotificationPostTimer;
480 
481     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_passwordNotificationsToPost;
482 
483     Timer m_liveRegionChangedPostTimer;
484     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_liveRegionObjectsSet;
485 
486     Timer m_focusModalNodeTimer;
487     Node* m_currentModalNode;
488     ListHashSet&lt;Node*&gt; m_modalNodesSet;
489 
490     Timer m_performCacheUpdateTimer;
491 
492     AXTextStateChangeIntent m_textSelectionIntent;
493     ListHashSet&lt;Element*&gt; m_deferredRecomputeIsIgnoredList;
494     ListHashSet&lt;Node*&gt; m_deferredTextChangedList;
495     ListHashSet&lt;Element*&gt; m_deferredSelectedChildredChangedList;
<a name="16" id="anc16"></a><span class="line-modified">496     ListHashSet&lt;RefPtr&lt;AXCoreObject&gt;&gt; m_deferredChildrenChangedList;</span>
497     ListHashSet&lt;Node*&gt; m_deferredChildrenChangedNodeList;
498     HashMap&lt;Element*, String&gt; m_deferredTextFormControlValue;
499     HashMap&lt;Element*, QualifiedName&gt; m_deferredAttributeChange;
500     Vector&lt;std::pair&lt;Node*, Node*&gt;&gt; m_deferredFocusedNodeChange;
501     bool m_isSynchronizingSelection { false };
502     bool m_performingDeferredCacheUpdate { false };
503 
504 #if USE(ATK)
505     ListHashSet&lt;RefPtr&lt;AccessibilityObject&gt;&gt; m_deferredAttachedWrapperObjectList;
506     ListHashSet&lt;GRefPtr&lt;AccessibilityObjectWrapper&gt;&gt; m_deferredDetachedWrapperList;
507 #endif
508 };
509 
510 class AXAttributeCacheEnabler
511 {
512 public:
513     explicit AXAttributeCacheEnabler(AXObjectCache *cache);
514     ~AXAttributeCacheEnabler();
515 
516 #if ENABLE(ACCESSIBILITY)
517 private:
518     AXObjectCache* m_cache;
519 #endif
520 };
521 
522 bool nodeHasRole(Node*, const String&amp; role);
523 // This will let you know if aria-hidden was explicitly set to false.
524 bool isNodeAriaVisible(Node*);
525 
526 #if !ENABLE(ACCESSIBILITY)
527 inline AccessibilityObjectInclusion AXComputedObjectAttributeCache::getIgnored(AXID) const { return AccessibilityObjectInclusion::DefaultBehavior; }
528 inline AccessibilityReplacedText::AccessibilityReplacedText(const VisibleSelection&amp;) { }
529 inline void AccessibilityReplacedText::postTextStateChangeNotification(AXObjectCache*, AXTextEditType, const String&amp;, const VisibleSelection&amp;) { }
530 inline void AXComputedObjectAttributeCache::setIgnored(AXID, AccessibilityObjectInclusion) { }
531 inline AXObjectCache::AXObjectCache(Document&amp; document) : m_document(document), m_notificationPostTimer(*this, &amp;AXObjectCache::notificationPostTimerFired), m_passwordNotificationPostTimer(*this, &amp;AXObjectCache::passwordNotificationPostTimerFired), m_liveRegionChangedPostTimer(*this, &amp;AXObjectCache::liveRegionChangedNotificationPostTimerFired), m_focusModalNodeTimer(*this, &amp;AXObjectCache::focusModalNodeTimerFired), m_performCacheUpdateTimer(*this, &amp;AXObjectCache::performCacheUpdateTimerFired) { }
532 inline AXObjectCache::~AXObjectCache() { }
<a name="17" id="anc17"></a><span class="line-modified">533 inline AXCoreObject* AXObjectCache::focusedUIElementForPage(const Page*) { return nullptr; }</span>
534 inline AccessibilityObject* AXObjectCache::get(RenderObject*) { return nullptr; }
535 inline AccessibilityObject* AXObjectCache::get(Node*) { return nullptr; }
536 inline AccessibilityObject* AXObjectCache::get(Widget*) { return nullptr; }
537 inline AccessibilityObject* AXObjectCache::getOrCreate(RenderObject*) { return nullptr; }
538 inline AccessibilityObject* AXObjectCache::getOrCreate(AccessibilityRole) { return nullptr; }
539 inline AccessibilityObject* AXObjectCache::getOrCreate(Node*) { return nullptr; }
540 inline AccessibilityObject* AXObjectCache::getOrCreate(Widget*) { return nullptr; }
<a name="18" id="anc18"></a><span class="line-modified">541 inline AXCoreObject* AXObjectCache::rootObject() { return nullptr; }</span>
542 inline AccessibilityObject* AXObjectCache::rootObjectForFrame(Frame*) { return nullptr; }
543 inline bool nodeHasRole(Node*, const String&amp;) { return false; }
544 inline void AXObjectCache::startCachingComputedObjectAttributesUntilTreeMutates() { }
545 inline void AXObjectCache::stopCachingComputedObjectAttributes() { }
546 inline bool isNodeAriaVisible(Node*) { return true; }
547 inline const Element* AXObjectCache::rootAXEditableElement(const Node*) { return nullptr; }
548 inline Node* AXObjectCache::modalNode() { return nullptr; }
<a name="19" id="anc19"></a><span class="line-modified">549 inline void AXObjectCache::attachWrapper(AXCoreObject*) { }</span>
550 inline void AXObjectCache::checkedStateChanged(Node*) { }
<a name="20" id="anc20"></a><span class="line-modified">551 inline void AXObjectCache::childrenChanged(AXCoreObject*) { }</span>
552 inline void AXObjectCache::childrenChanged(Node*, Node*) { }
553 inline void AXObjectCache::childrenChanged(RenderObject*, RenderObject*) { }
554 inline void AXObjectCache::deferFocusedUIElementChangeIfNeeded(Node*, Node*) { }
555 inline void AXObjectCache::deferRecomputeIsIgnoredIfNeeded(Element*) { }
556 inline void AXObjectCache::deferRecomputeIsIgnored(Element*) { }
557 inline void AXObjectCache::deferTextChangedIfNeeded(Node*) { }
558 inline void AXObjectCache::deferSelectedChildrenChangedIfNeeded(Element&amp;) { }
559 inline void AXObjectCache::deferTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;) { }
<a name="21" id="anc21"></a><span class="line-modified">560 #if !PLATFORM(COCOA)</span>
<span class="line-added">561 inline void AXObjectCache::detachWrapper(AXCoreObject*, AccessibilityDetachmentType) { }</span>
<span class="line-added">562 #endif</span>
563 inline void AXObjectCache::focusModalNodeTimerFired() { }
564 inline void AXObjectCache::performCacheUpdateTimerFired() { }
565 inline void AXObjectCache::frameLoadingEventNotification(Frame*, AXLoadingEvent) { }
566 inline void AXObjectCache::frameLoadingEventPlatformNotification(AccessibilityObject*, AXLoadingEvent) { }
567 inline void AXObjectCache::handleActiveDescendantChanged(Node*) { }
568 inline void AXObjectCache::handleAriaExpandedChange(Node*) { }
569 inline void AXObjectCache::handleModalChange(Node*) { }
570 inline void AXObjectCache::handleAriaRoleChanged(Node*) { }
571 inline void AXObjectCache::deferAttributeChangeIfNeeded(const QualifiedName&amp;, Element*) { }
572 inline void AXObjectCache::handleAttributeChange(const QualifiedName&amp;, Element*) { }
573 inline bool AXObjectCache::shouldProcessAttributeChange(const QualifiedName&amp;, Element*) { return false; }
574 inline void AXObjectCache::handleFocusedUIElementChanged(Node*, Node*) { }
575 inline void AXObjectCache::handleScrollbarUpdate(ScrollView*) { }
576 inline void AXObjectCache::handleScrolledToAnchor(const Node*) { }
577 inline void AXObjectCache::liveRegionChangedNotificationPostTimerFired() { }
578 inline void AXObjectCache::notificationPostTimerFired() { }
579 inline void AXObjectCache::passwordNotificationPostTimerFired() { }
580 inline void AXObjectCache::performDeferredCacheUpdate() { }
581 inline void AXObjectCache::postLiveRegionChangeNotification(AccessibilityObject*) { }
<a name="22" id="anc22"></a><span class="line-modified">582 inline void AXObjectCache::postNotification(AXCoreObject*, Document*, AXNotification, PostTarget, PostType) { }</span>
583 inline void AXObjectCache::postNotification(Node*, AXNotification, PostTarget, PostType) { }
584 inline void AXObjectCache::postNotification(RenderObject*, AXNotification, PostTarget, PostType) { }
<a name="23" id="anc23"></a><span class="line-modified">585 inline void AXObjectCache::postPlatformNotification(AXCoreObject*, AXNotification) { }</span>
586 inline void AXObjectCache::postTextReplacementNotification(Node*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
587 inline void AXObjectCache::postTextReplacementNotificationForTextControl(HTMLTextFormControlElement&amp;, const String&amp;, const String&amp;) { }
588 inline void AXObjectCache::postTextStateChangeNotification(Node*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
589 inline void AXObjectCache::postTextStateChangeNotification(Node*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
590 inline void AXObjectCache::recomputeIsIgnored(RenderObject*) { }
591 inline void AXObjectCache::textChanged(AccessibilityObject*) { }
592 inline void AXObjectCache::textChanged(Node*) { }
593 inline void AXObjectCache::updateCacheAfterNodeIsAttached(Node*) { }
594 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForNodeContents(Node*) { return nullptr; }
595 inline void AXObjectCache::remove(AXID) { }
596 inline void AXObjectCache::remove(RenderObject*) { }
597 inline void AXObjectCache::remove(Node&amp;) { }
598 inline void AXObjectCache::remove(Widget*) { }
599 inline void AXObjectCache::selectedChildrenChanged(RenderObject*) { }
600 inline void AXObjectCache::selectedChildrenChanged(Node*) { }
601 inline void AXObjectCache::setIsSynchronizingSelection(bool) { }
602 inline void AXObjectCache::setTextSelectionIntent(const AXTextStateChangeIntent&amp;) { }
603 inline RefPtr&lt;Range&gt; AXObjectCache::rangeForUnorderedCharacterOffsets(const CharacterOffset&amp;, const CharacterOffset&amp;) { return nullptr; }
604 inline IntRect AXObjectCache::absoluteCaretBoundsForCharacterOffset(const CharacterOffset&amp;) { return IntRect(); }
<a name="24" id="anc24"></a><span class="line-modified">605 inline CharacterOffset AXObjectCache::characterOffsetForIndex(int, const AXCoreObject*) { return CharacterOffset(); }</span>
606 inline CharacterOffset AXObjectCache::startOrEndCharacterOffsetForRange(RefPtr&lt;Range&gt;, bool, bool) { return CharacterOffset(); }
607 inline CharacterOffset AXObjectCache::endCharacterOffsetOfLine(const CharacterOffset&amp;) { return CharacterOffset(); }
608 inline CharacterOffset AXObjectCache::nextCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
609 inline CharacterOffset AXObjectCache::previousCharacterOffset(const CharacterOffset&amp;, bool) { return CharacterOffset(); }
610 #if PLATFORM(COCOA)
611 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, const AXTextStateChangeIntent&amp;, const VisibleSelection&amp;) { }
612 inline void AXObjectCache::postTextStateChangePlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
613 inline void AXObjectCache::postTextReplacementPlatformNotification(AccessibilityObject*, AXTextEditType, const String&amp;, AXTextEditType, const String&amp;, const VisiblePosition&amp;) { }
614 #else
615 inline AXTextChange AXObjectCache::textChangeForEditType(AXTextEditType) { return AXTextInserted; }
616 inline void AXObjectCache::nodeTextChangePlatformNotification(AccessibilityObject*, AXTextChange, unsigned, const String&amp;) { }
617 #endif
618 
619 inline AXAttributeCacheEnabler::AXAttributeCacheEnabler(AXObjectCache*) { }
620 inline AXAttributeCacheEnabler::~AXAttributeCacheEnabler() { }
621 
622 #endif
623 
624 } // namespace WebCore
<a name="25" id="anc25"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="25" type="hidden" />
</body>
</html>
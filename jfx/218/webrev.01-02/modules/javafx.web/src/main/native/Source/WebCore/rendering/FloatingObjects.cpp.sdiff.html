<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FloatingObjects.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;FloatingObjects.h&quot;
 26 

 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderBox.h&quot;
 29 #include &quot;RenderView.h&quot;
 30 #include &lt;wtf/HexNumber.h&gt;
 31 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 struct SameSizeAsFloatingObject {
 36     void* pointers[2];
 37     LayoutRect rect;
 38     int paginationStrut;
 39     LayoutSize size;
 40     uint32_t bitfields : 8;
 41 };
 42 
 43 COMPILE_ASSERT(sizeof(FloatingObject) == sizeof(SameSizeAsFloatingObject), FloatingObject_should_stay_small);
 44 
 45 FloatingObject::FloatingObject(RenderBox&amp; renderer)
 46     : m_renderer(makeWeakPtr(renderer))
 47     , m_shouldPaint(true)
 48     , m_isDescendant(false)
 49     , m_isPlaced(false)
<span class="line-modified"> 50 #ifndef NDEBUG</span>
 51     , m_isInPlacedTree(false)
 52 #endif
 53 {
 54     Float type = renderer.style().floating();
 55     ASSERT(type != Float::No);
 56     if (type == Float::Left)
 57         m_type = FloatLeft;
 58     else if (type == Float::Right)
 59         m_type = FloatRight;
 60 }
 61 
 62 FloatingObject::FloatingObject(RenderBox&amp; renderer, Type type, const LayoutRect&amp; frameRect, const LayoutSize&amp; marginOffset, bool shouldPaint, bool isDescendant)
 63     : m_renderer(makeWeakPtr(renderer))
 64     , m_frameRect(frameRect)
 65     , m_marginOffset(marginOffset)
 66     , m_type(type)
 67     , m_shouldPaint(shouldPaint)
 68     , m_isDescendant(isDescendant)
 69     , m_isPlaced(true)
<span class="line-modified"> 70 #ifndef NDEBUG</span>
 71     , m_isInPlacedTree(false)
 72 #endif
 73 {
 74 }
 75 
 76 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::create(RenderBox&amp; renderer)
 77 {
 78     auto object = makeUnique&lt;FloatingObject&gt;(renderer);
 79     object-&gt;setShouldPaint(!renderer.hasSelfPaintingLayer()); // If a layer exists, the float will paint itself. Otherwise someone else will.
 80     object-&gt;setIsDescendant(true);
 81     return object;
 82 }
 83 
 84 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::copyToNewContainer(LayoutSize offset, bool shouldPaint, bool isDescendant) const
 85 {
 86     return makeUnique&lt;FloatingObject&gt;(renderer(), type(), LayoutRect(frameRect().location() - offset, frameRect().size()), marginOffset(), shouldPaint, isDescendant);
 87 }
 88 
 89 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::cloneForNewParent() const
 90 {
 91     auto cloneObject = makeUnique&lt;FloatingObject&gt;(renderer(), type(), m_frameRect, m_marginOffset, m_shouldPaint, m_isDescendant);
 92     cloneObject-&gt;m_paginationStrut = m_paginationStrut;
 93     cloneObject-&gt;m_isPlaced = m_isPlaced;
 94     return cloneObject;
 95 }
 96 
 97 LayoutSize FloatingObject::translationOffsetToAncestor() const
 98 {
 99     return locationOffsetOfBorderBox() - renderer().locationOffset();
100 }
101 
102 #ifndef NDEBUG
103 
<span class="line-modified">104 String FloatingObject::debugString() const</span>
105 {
<span class="line-modified">106     return makeString(&quot;0x&quot;, hex(reinterpret_cast&lt;uintptr_t&gt;(this)), &quot; (&quot;, frameRect().x().toInt(), &#39;x&#39;, frameRect().y().toInt(), &#39; &#39;, frameRect().maxX().toInt(), &#39;x&#39;, frameRect().maxY().toInt(), &#39;)&#39;);</span>
107 }
108 
109 #endif
110 
111 inline static bool rangesIntersect(LayoutUnit floatTop, LayoutUnit floatBottom, LayoutUnit objectTop, LayoutUnit objectBottom)
112 {
113     if (objectTop &gt;= floatBottom || objectBottom &lt; floatTop)
114         return false;
115 
116     // The top of the object overlaps the float
117     if (objectTop &gt;= floatTop)
118         return true;
119 
120     // The object encloses the float
121     if (objectTop &lt; floatTop &amp;&amp; objectBottom &gt; floatBottom)
122         return true;
123 
124     // The bottom of the object overlaps the float
125     if (objectBottom &gt; objectTop &amp;&amp; objectBottom &gt; floatTop &amp;&amp; objectBottom &lt;= floatBottom)
126         return true;
</pre>
<hr />
<pre>
310         m_rightObjectsCount--;
311 }
312 
313 FloatingObjectInterval FloatingObjects::intervalForFloatingObject(FloatingObject* floatingObject)
314 {
315     // FIXME The endpoints of the floating object interval shouldn&#39;t need to be
316     // floored. See http://wkb.ug/125831 for more details.
317     if (m_horizontalWritingMode)
318         return FloatingObjectInterval(floatingObject-&gt;frameRect().y().floor(), floatingObject-&gt;frameRect().maxY().floor(), floatingObject);
319     return FloatingObjectInterval(floatingObject-&gt;frameRect().x().floor(), floatingObject-&gt;frameRect().maxX().floor(), floatingObject);
320 }
321 
322 void FloatingObjects::addPlacedObject(FloatingObject* floatingObject)
323 {
324     ASSERT(!floatingObject-&gt;isInPlacedTree());
325 
326     floatingObject-&gt;setIsPlaced(true);
327     if (m_placedFloatsTree)
328         m_placedFloatsTree-&gt;add(intervalForFloatingObject(floatingObject));
329 
<span class="line-modified">330 #ifndef NDEBUG</span>
331     floatingObject-&gt;setIsInPlacedTree(true);
332 #endif
333 }
334 
335 void FloatingObjects::removePlacedObject(FloatingObject* floatingObject)
336 {
337     ASSERT(floatingObject-&gt;isPlaced() &amp;&amp; floatingObject-&gt;isInPlacedTree());
338 
339     if (m_placedFloatsTree) {
340         bool removed = m_placedFloatsTree-&gt;remove(intervalForFloatingObject(floatingObject));
341         ASSERT_UNUSED(removed, removed);
342     }
343 
344     floatingObject-&gt;setIsPlaced(false);
<span class="line-modified">345 #ifndef NDEBUG</span>
346     floatingObject-&gt;setIsInPlacedTree(false);
347 #endif
348 }
349 
350 FloatingObject* FloatingObjects::add(std::unique_ptr&lt;FloatingObject&gt; floatingObject)
351 {
352     increaseObjectsCount(floatingObject-&gt;type());
353     if (floatingObject-&gt;isPlaced())
354         addPlacedObject(floatingObject.get());
355     return m_set.add(WTFMove(floatingObject)).iterator-&gt;get();
356 }
357 
358 void FloatingObjects::remove(FloatingObject* floatingObject)
359 {
360     ASSERT((m_set.contains(floatingObject)));
361     decreaseObjectsCount(floatingObject-&gt;type());
362     ASSERT(floatingObject-&gt;isPlaced() || !floatingObject-&gt;isInPlacedTree());
363     if (floatingObject-&gt;isPlaced())
364         removePlacedObject(floatingObject);
365     ASSERT(!floatingObject-&gt;originatingLine());
</pre>
</td>
<td>
<hr />
<pre>
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;FloatingObjects.h&quot;
 26 
<span class="line-added"> 27 #include &quot;PODIntervalTree.h&quot;</span>
 28 #include &quot;RenderBlockFlow.h&quot;
 29 #include &quot;RenderBox.h&quot;
 30 #include &quot;RenderView.h&quot;
 31 #include &lt;wtf/HexNumber.h&gt;
 32 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 struct SameSizeAsFloatingObject {
 37     void* pointers[2];
 38     LayoutRect rect;
 39     int paginationStrut;
 40     LayoutSize size;
 41     uint32_t bitfields : 8;
 42 };
 43 
 44 COMPILE_ASSERT(sizeof(FloatingObject) == sizeof(SameSizeAsFloatingObject), FloatingObject_should_stay_small);
 45 
 46 FloatingObject::FloatingObject(RenderBox&amp; renderer)
 47     : m_renderer(makeWeakPtr(renderer))
 48     , m_shouldPaint(true)
 49     , m_isDescendant(false)
 50     , m_isPlaced(false)
<span class="line-modified"> 51 #if ASSERT_ENABLED</span>
 52     , m_isInPlacedTree(false)
 53 #endif
 54 {
 55     Float type = renderer.style().floating();
 56     ASSERT(type != Float::No);
 57     if (type == Float::Left)
 58         m_type = FloatLeft;
 59     else if (type == Float::Right)
 60         m_type = FloatRight;
 61 }
 62 
 63 FloatingObject::FloatingObject(RenderBox&amp; renderer, Type type, const LayoutRect&amp; frameRect, const LayoutSize&amp; marginOffset, bool shouldPaint, bool isDescendant)
 64     : m_renderer(makeWeakPtr(renderer))
 65     , m_frameRect(frameRect)
 66     , m_marginOffset(marginOffset)
 67     , m_type(type)
 68     , m_shouldPaint(shouldPaint)
 69     , m_isDescendant(isDescendant)
 70     , m_isPlaced(true)
<span class="line-modified"> 71 #if ASSERT_ENABLED</span>
 72     , m_isInPlacedTree(false)
 73 #endif
 74 {
 75 }
 76 
 77 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::create(RenderBox&amp; renderer)
 78 {
 79     auto object = makeUnique&lt;FloatingObject&gt;(renderer);
 80     object-&gt;setShouldPaint(!renderer.hasSelfPaintingLayer()); // If a layer exists, the float will paint itself. Otherwise someone else will.
 81     object-&gt;setIsDescendant(true);
 82     return object;
 83 }
 84 
 85 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::copyToNewContainer(LayoutSize offset, bool shouldPaint, bool isDescendant) const
 86 {
 87     return makeUnique&lt;FloatingObject&gt;(renderer(), type(), LayoutRect(frameRect().location() - offset, frameRect().size()), marginOffset(), shouldPaint, isDescendant);
 88 }
 89 
 90 std::unique_ptr&lt;FloatingObject&gt; FloatingObject::cloneForNewParent() const
 91 {
 92     auto cloneObject = makeUnique&lt;FloatingObject&gt;(renderer(), type(), m_frameRect, m_marginOffset, m_shouldPaint, m_isDescendant);
 93     cloneObject-&gt;m_paginationStrut = m_paginationStrut;
 94     cloneObject-&gt;m_isPlaced = m_isPlaced;
 95     return cloneObject;
 96 }
 97 
 98 LayoutSize FloatingObject::translationOffsetToAncestor() const
 99 {
100     return locationOffsetOfBorderBox() - renderer().locationOffset();
101 }
102 
103 #ifndef NDEBUG
104 
<span class="line-modified">105 TextStream&amp; operator&lt;&lt;(TextStream&amp; stream, const FloatingObject&amp; object)</span>
106 {
<span class="line-modified">107     return stream &lt;&lt; &amp;object &lt;&lt; &quot; (&quot; &lt;&lt; object.frameRect().x().toInt() &lt;&lt; &#39;x&#39; &lt;&lt; object.frameRect().y().toInt() &lt;&lt; &#39; &#39; &lt;&lt; object.frameRect().maxX().toInt() &lt;&lt; &#39;x&#39; &lt;&lt; object.frameRect().maxY().toInt() &lt;&lt; &#39;)&#39;;</span>
108 }
109 
110 #endif
111 
112 inline static bool rangesIntersect(LayoutUnit floatTop, LayoutUnit floatBottom, LayoutUnit objectTop, LayoutUnit objectBottom)
113 {
114     if (objectTop &gt;= floatBottom || objectBottom &lt; floatTop)
115         return false;
116 
117     // The top of the object overlaps the float
118     if (objectTop &gt;= floatTop)
119         return true;
120 
121     // The object encloses the float
122     if (objectTop &lt; floatTop &amp;&amp; objectBottom &gt; floatBottom)
123         return true;
124 
125     // The bottom of the object overlaps the float
126     if (objectBottom &gt; objectTop &amp;&amp; objectBottom &gt; floatTop &amp;&amp; objectBottom &lt;= floatBottom)
127         return true;
</pre>
<hr />
<pre>
311         m_rightObjectsCount--;
312 }
313 
314 FloatingObjectInterval FloatingObjects::intervalForFloatingObject(FloatingObject* floatingObject)
315 {
316     // FIXME The endpoints of the floating object interval shouldn&#39;t need to be
317     // floored. See http://wkb.ug/125831 for more details.
318     if (m_horizontalWritingMode)
319         return FloatingObjectInterval(floatingObject-&gt;frameRect().y().floor(), floatingObject-&gt;frameRect().maxY().floor(), floatingObject);
320     return FloatingObjectInterval(floatingObject-&gt;frameRect().x().floor(), floatingObject-&gt;frameRect().maxX().floor(), floatingObject);
321 }
322 
323 void FloatingObjects::addPlacedObject(FloatingObject* floatingObject)
324 {
325     ASSERT(!floatingObject-&gt;isInPlacedTree());
326 
327     floatingObject-&gt;setIsPlaced(true);
328     if (m_placedFloatsTree)
329         m_placedFloatsTree-&gt;add(intervalForFloatingObject(floatingObject));
330 
<span class="line-modified">331 #if ASSERT_ENABLED</span>
332     floatingObject-&gt;setIsInPlacedTree(true);
333 #endif
334 }
335 
336 void FloatingObjects::removePlacedObject(FloatingObject* floatingObject)
337 {
338     ASSERT(floatingObject-&gt;isPlaced() &amp;&amp; floatingObject-&gt;isInPlacedTree());
339 
340     if (m_placedFloatsTree) {
341         bool removed = m_placedFloatsTree-&gt;remove(intervalForFloatingObject(floatingObject));
342         ASSERT_UNUSED(removed, removed);
343     }
344 
345     floatingObject-&gt;setIsPlaced(false);
<span class="line-modified">346 #if ASSERT_ENABLED</span>
347     floatingObject-&gt;setIsInPlacedTree(false);
348 #endif
349 }
350 
351 FloatingObject* FloatingObjects::add(std::unique_ptr&lt;FloatingObject&gt; floatingObject)
352 {
353     increaseObjectsCount(floatingObject-&gt;type());
354     if (floatingObject-&gt;isPlaced())
355         addPlacedObject(floatingObject.get());
356     return m_set.add(WTFMove(floatingObject)).iterator-&gt;get();
357 }
358 
359 void FloatingObjects::remove(FloatingObject* floatingObject)
360 {
361     ASSERT((m_set.contains(floatingObject)));
362     decreaseObjectsCount(floatingObject-&gt;type());
363     ASSERT(floatingObject-&gt;isPlaced() || !floatingObject-&gt;isInPlacedTree());
364     if (floatingObject-&gt;isPlaced())
365         removePlacedObject(floatingObject);
366     ASSERT(!floatingObject-&gt;originatingLine());
</pre>
</td>
</tr>
</table>
<center><a href="EventRegion.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FloatingObjects.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>